{"buggy_code": ["Bison was originally written by Robert Corbett.  It would not be what\nit is today without the invaluable help of these people:\n\nAaro Koskinen             aaro.koskinen@iki.fi\n\u0410\u0441\u043a\u0430\u0440 \u0421\u0430\u0444\u0438\u043d               safinaskar@mail.ru\nAdam Sampson              ats@offog.org\nAdrian Vogelsgesang       avogelsgesang@tableau.com\nAhcheong Lee              dkcjd2000@gmail.com\nAiry Andre                Airy.Andre@edf.fr\nAkim Demaille             akim@gnu.org\nAlbert Chin-A-Young       china@thewrittenword.com\nAlexander Belopolsky      alexb@rentec.com\nAlexandre Duret-Lutz      adl@lrde.epita.fr\nAndre da Costa Barros     andre.cbarros@yahoo.com\nAndreas Damm              adamm@onica.com\nAndreas Schwab            schwab@suse.de\nAndrew Suffield           asuffield@users.sourceforge.net\nAngelo Borsotti           angelo.borsotti@gmail.com\nAnthony Heading           ajrh@ajrh.net\nAntonio Silva Correia     amsilvacorreia@hotmail.com\nArnold Robbins            arnold@skeeve.com\nArt Haas                  ahaas@neosoft.com\nArthur Schwarz            aschwarz1309@att.net\nAskar Safin               safinaskar@mail.ru\nBal\u00e1zs Scheidler          balazs.scheidler@oneidentity.com\nBaron Schwartz            baron@sequent.org\nBen Pfaff                 blp@cs.stanford.edu\nBenoit Perrot             benoit.perrot@epita.fr\nBernd Edlinger            bernd.edlinger@hotmail.de\nBernd Kiefer              kiefer@dfki.de\nBert Deknuydt             Bert.Deknuydt@esat.kuleuven.ac.be\nBill Allombert            Bill.Allombert@math.u-bordeaux1.fr\nBob Rossi                 bob@brasko.net\nBrandon Lucia             blucia@gmail.com\nBrooks Moses              bmoses@google.com\nBruce Lilly               blilly@erols.com\nBruno Haible              bruno@clisp.org\nCharles-Henri de Boysson  de-boy_c@epita.fr\nChristian Burger          cburger@sunysb.edu\nCl\u00e9ment D\u00e9moulins         demoulins@lrde.epita.fr\nColin Daley               colin.daley@outlook.com\nCris Bailiff              c.bailiff+bison@awayweb.com\nCris van Pelt             cris@amf03054.office.wxs.nl\nCsaba Raduly              csaba_22@yahoo.co.uk\nDagobert Michelsen        dam@baltic-online.de\nDaniel Fru\u017cy\u0144ski          daniel@poradnik-webmastera.com\nDaniel Galloway           dg1751@att.com\nDaniela Becker            daniela@lrde.epita.fr\nDaniel Hagerty            hag@gnu.org\nDavid Barto               david.barto@sparqlcity.com\nDavid J. MacKenzie        djm@gnu.org\nDavid Kastrup             dak@gnu.org\nDavid Michael             fedora.dm0@gmail.com\nDengke Du                 dengke.du@windriver.com\nDenis Excoffier           gcc@Denis-Excoffier.org\nDennis Clarke             dclarke@blastwave.org\nDerek Clegg               derek@me.com\nDerek M. Jones            derek@knosof.co.uk\nDi-an Jan                 dianj@freeshell.org\nDick Streefland           dick.streefland@altium.nl\nDidier Godefroy           dg@ulysium.net\nDon Macpherson            donmac703@gmail.com\nDwight Guth               dwight.guth@runtimeverification.com\nEfi Fogel                 efifogel@gmail.com\nEnrico Scholz             enrico.scholz@informatik.tu-chemnitz.de\nEric Blake                ebb9@byu.net\nEric S. Raymond           esr@thyrsus.com\n\u00c9tienne Renault           renault@lrde.epita.fr\nEvan Lavelle              eml-bison@cyconix.com\nEvan Nemerson             evan@nemerson.com\nEvgeny Stambulchik        fnevgeny@plasma-gate.weizmann.ac.il\nFabrice Bauzac            noon@cote-dazur.com\nFerdinand Thiessen        ferdinand@fthiessen.de\nFlorian Krohm             florian@edamail.fishkill.ibm.com\nFrank Heckenbach          frank@g-n-u.de\nFrans Englich             frans.englich@telia.com\nGabriel Rassoul           gabriel.rassoul@epita.fr\nGary L Peskin             garyp@firstech.com\nGavin Smith               gavinsmith0123@gmail.com\nGeorg Sauthoff            gsauthof@TechFak.Uni-Bielefeld.DE\nGeorge Neuner             gneuner2@comcast.net\nGilles Espinasse          g.esp@free.fr\nGoran Uddeborg            goeran@uddeborg.se\nGuido Trentalancia        trentalg@aston.ac.uk\nH. Merijn Brand           h.m.brand@hccnet.nl\nHans \u00c5berg                haberg-1@telia.com\nHorst Von Brand           vonbrand@inf.utfsm.cl\nJacob L. Mandelson        jlm-bbison@jlm.ofb.net\nJan Nieuwenhuizen         janneke@gnu.org\nJannick                   thirdedition@gmx.net\nJeff Hammond              jeff_hammond@acm.org\nJerry Quinn               jlquinn@optonline.net\nJesse Thilo               jthilo@gnu.org\nJim Kent                  jkent@arch.sel.sony.com\nJim Meyering              jim@meyering.net\nJoel E. Denny             joeldenny@joeldenny.org\nJohan van Selst           johans@stack.nl\nJohn Horigan              john@glyphic.com\nJonathan Fabrizio         jonathan.fabrizio@lrde.epita.fr\nJonathan Nieder           jrnieder@gmail.com\nJosh Soref                jsoref@gmail.com\nJuan Manuel Guerrero      juan.guerrero@gmx.de\nKarl Berry                karl@freefriends.org\nKees Zeelenberg           kzlg@users.sourceforge.net\nKeith Browne              kbrowne@legato.com\nKen Moffat                zarniwhoop@ntlworld.com\nKiyoshi Kanazawa          yoi_no_myoujou@yahoo.co.jp\nLars Maier                lars.maier@tefax.net\nL\u00e1szl\u00f3 V\u00e1rady             laszlo.varady93@gmail.com\nLaurent Mascherpa         laurent.mascherpa@epita.fr\nLie Yan                   lie.yan@kaust.edu.sa\nMagnus Fromreide          magfr@lysator.liu.se\nMarc Autret               autret_m@epita.fr\nMarc Mendiola             mmendiol@usc.edu\nMarc Sch\u00f6nefeld           marc.schoenefeld@gmx.org\nMark Boyall               wolfeinstein@gmail.com\nMartin Blais              blais@furius.ca\nMartin Jacobs             martin.jacobs@arcor.de\nMartin Mokrejs            mmokrejs@natur.cuni.cz\nMartin Nylin              martin.nylin@linuxmail.org\nMatt Kraai                kraai@alumni.cmu.edu\nMatt Rosing               rosing@peakfive.com\nMaxim Prohorenko          Maxim.Prohorenko@gmail.com\nMichael Catanzaro         mcatanzaro@gnome.org\nMichael Felt              mamfelt@gmail.com\nMichael Hayes             m.hayes@elec.canterbury.ac.nz\nMichael Raskin            7c6f434c@mail.ru\nMichel d'Hooge            michel.dhooge@gmail.com\nMichiel De Wilde          mdewilde.agilent@gmail.com\nMickael Labau             labau_m@epita.fr\nMike Castle               dalgoda@ix.netcom.com\nMike Frysinger            vapier@gentoo.org\nMike Sullivan             Mike.sullivan@Oracle.COM\nNate Guerin               nathan.guerin@riseup.net\nNeil Booth                NeilB@earthling.net\nNelson H. F. Beebe        beebe@math.utah.edu\nneok m4700                neok.m4700@gmail.com\nNick Bowler               nbowler@elliptictech.com\nNicolas Bedon             nicolas.bedon@univ-rouen.fr\nNicolas Burrus            nicolas.burrus@epita.fr\nNicolas Tisserand         nicolas.tisserand@epita.fr\nNikki Valen               nicolettavalencia.nv@gmail.com\nNoah Friedman             friedman@gnu.org\nOdd Arild Olsen           oao@fibula.no\nOleg Smolsky              oleg.smolsky@pacific-simulators.co.nz\nOleksii Taran             oleksii.taran@gmail.com\nOliver Mangold            o.mangold@gmail.com\nPaolo Bonzini             bonzini@gnu.org\nPaolo Simone Gasparello   djgaspa@gmail.com\nPascal Bart               pascal.bart@epita.fr\nPatrice Dumas             pertusus@free.fr\nPaul Eggert               eggert@cs.ucla.edu\nPaul Hilfinger            Hilfinger@CS.Berkeley.EDU\nPer Allansson             per@appgate.com\nPeter Eisentraut          peter_e@gmx.net\nPeter Fales               psfales@lucent.com\nPeter Hamorsky            hamo@upjs.sk\nPeter Simons              simons@cryp.to\nPetr Machata              pmachata@redhat.com\nPho                       pho@cielonegro.org\nPiotr Gackiewicz          gacek@intertel.com.pl\nPiotr Marci\u0144czyk          piomar123@gmail.com\nPramod Kumbhar            pramod.s.kumbhar@gmail.com\nQuentin Hocquet           hocquet@gostai.com\nQuoc Peyrot               chojin@lrde.epita.fr\nR Blake                   blakers@mac.com\nRaja R Harinath           harinath@cs.umn.edu\nRalf Wildenhues           Ralf.Wildenhues@gmx.de\nRyan                      dev@splintermail.com\nRich Wilson               richaw@gmail.com\nRichard Stallman          rms@gnu.org\nRici Lake                 ricilake@gmail.com\nRob Conde                 rob.conde@ai-solutions.com\nRob Vermaas               rob.vermaas@gmail.com\nRobert Anisko             anisko_r@epita.fr\nRobert Yang               liezhi.yang@windriver.com\nRoland Levillain          roland@lrde.epita.fr\nSatya Kiran Popuri        satyakiran@gmail.com\nSebastian Setzer          sebastian.setzer.ext@siemens.com\nSebastien Fricker         sebastien.fricker@gmail.com\nS\u00e9bastien Villemot        sebastien@debian.org\nSergei Steshenko          sergstesh@yahoo.com\nShura                     debil_urod@ngs.ru\nSimon Sobisch             simonsobisch@web.de\nStefano Lattarini         stefano.lattarini@gmail.com\nStephen Cameron           stephenmcameron@gmail.com\nSteve Murphy              murf@parsetree.com\nSum Wu                    sum@geekhouse.org\nTh\u00e9ophile Ranquet         theophile.ranquet@gmail.com\nThiru Ramakrishnan        thiru.ramakrishnan@gmail.com\nThomas Jahns              jahns@dkrz.de\nThomas Petazzoni          thomas.petazzoni@bootlin.com\nTim Josling               tej@melbpc.org.au\nTim Landscheidt           tim@tim-landscheidt.de\nTim Van Holder            tim.van.holder@pandora.be\nTobias Frost              tobi@debian.org\nTodd Freed                todd.freed@gmail.com\nTom Kramer                kramer@nist.gov\nTom Lane                  tgl@sss.pgh.pa.us\nTom Tromey                tromey@cygnus.com\nTomasz K\u0142oczko            kloczko.tomasz@gmail.com\nTommy Nordgren            tommy.nordgren@chello.se\nTroy A. Johnson           troyj@ecn.purdue.edu\nTys Lefering              gccbison@gmail.com\nUxio Prego                uxio@uma.es\nValentin Tolmer           nitnelave1@gmail.com\nwcventure                 wcventure@126.com\nVictor Khomenko           victor.khomenko@newcastle.ac.uk\nVictor Zverovich          victor.zverovich@gmail.com\nVin Shelton               acs@alumni.princeton.edu\nW.C.A. Wijngaards         wouter@NLnetLabs.nl\nWayne Green               wayne@infosavvy.com\nWei Song                  wsong83@gmail.com\nWojciech Polak            polak@gnu.org\nWolfgang S. Kechel        wolfgang.kechel@prs.de\nWolfgang Thaller          wolfgang.thaller@gmx.net\nWolfram Wagner            ww@mpi-sb.mpg.de\nWwp                       subscript@free.fr\nxolodho                   xolodho@gmail.com\nYuichiro Kaneko           spiketeika@gmail.com\nYuriy Solodkyy            solodon@gmail.com\nZack Weinberg             zack@codesourcery.com\n\u6c5f \u7956\u94ed                    jjzuming@outlook.com\n\u9577\u7530\u5049\u4f38                   cbh34680@iret.co.jp\n\u9a6c\u4fca                       majun123@whu.edu.cn\n\nMany people are not named here because we lost track of them.  We\nthank them!  Please, help us keeping this list up to date.\n\nLocal Variables:\nmode: text\ncoding: utf-8\nEnd:\n\n-----\n\nCopyright (C) 2000-2015, 2018-2020 Free Software Foundation, Inc.\n\nThis file is part of Bison, the GNU Parser Generator.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n", "/* Common parts between scan-code.l, scan-gram.l, and scan-skel.l.\n\n   Copyright (C) 2006, 2009-2015, 2018-2020 Free Software Foundation,\n   Inc.\n\n   This file is part of Bison, the GNU Compiler Compiler.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n#ifndef FLEX_PREFIX\n# error \"FLEX_PREFIX not defined\"\n#endif\n\n/* Flex full version as a number.  */\n#define FLEX_VERSION                    \\\n  ((YY_FLEX_MAJOR_VERSION) * 1000000    \\\n   + (YY_FLEX_MINOR_VERSION) * 1000     \\\n   + (YY_FLEX_SUBMINOR_VERSION))\n\n// Pacify warnings in yy_init_buffer (observed with Flex 2.6.4 and GCC\n// 6.4.0 and 7.3.0).\n//\n// ./src/scan-skel.c: In function 'skel_restart':\n// ./src/scan-skel.c:2035:20: error: potential null pointer dereference [-Werror=null-dereference]\n//   b->yy_fill_buffer = 1;\n//   ~~~~~~~~~~~~~~~~~~^~~\n// ./src/scan-skel.c:2031:19: error: potential null pointer dereference [-Werror=null-dereference]\n//   b->yy_input_file = file;\n//   ~~~~~~~~~~~~~~~~~^~~~~~\n#if defined __GNUC__ && ! defined __clang__ && 6 <= __GNUC__\n# pragma GCC diagnostic ignored \"-Wnull-dereference\"\n#endif\n\n// Old versions of Flex (2.5.35) generate an incomplete documentation comment.\n//\n//  In file included from src/scan-code-c.c:3:\n//  src/scan-code.c:2198:21: error: empty paragraph passed to '@param' command\n//        [-Werror,-Wdocumentation]\n//   * @param line_number\n//     ~~~~~~~~~~~~~~~~~^\n//  1 error generated.\n#if FLEX_VERSION <= 20060000 && defined __clang__\n# pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n\n/* Pacify \"gcc -Wmissing-prototypes\" when flex 2.5.31 is used.  */\n#if FLEX_VERSION <= 2005031\nint   FLEX_PREFIX (get_lineno) (void);\nFILE *FLEX_PREFIX (get_in) (void);\nFILE *FLEX_PREFIX (get_out) (void);\nint   FLEX_PREFIX (get_leng) (void);\nchar *FLEX_PREFIX (get_text) (void);\nvoid  FLEX_PREFIX (set_lineno) (int);\nvoid  FLEX_PREFIX (set_in) (FILE *);\nvoid  FLEX_PREFIX (set_out) (FILE *);\nint   FLEX_PREFIX (get_debug) (void);\nvoid  FLEX_PREFIX (set_debug) (int);\nint   FLEX_PREFIX (lex_destroy) (void);\n#endif\n\n#define last_string    FLEX_PREFIX (last_string)\n\n/* It seems to be a nice \"feature\" of Flex that one cannot use yytext,\n   yyleng etc. when a prefix is given, since there is no longer a\n   #define, but rather the token is actually changed in the output.\n   However, this is not true for Flex 2.5.4.  */\n#ifndef yyleng\n# define yyleng  FLEX_PREFIX (leng)\n#endif\n#ifndef yytext\n# define yytext  FLEX_PREFIX (text)\n#endif\n\n/* Non-reentrant scanners generated by Flex 2.5.9 and later (and some earlier\n   versions according to the Flex manual) leak memory if yylex_destroy is not\n   invoked.  However, yylex_destroy is not defined before Flex 2.5.9, so give\n   an implementation here that at least appears to work with Flex 2.5.4.  */\n#if FLEX_VERSION <= 2005009\n# define yylex_destroy() yy_delete_buffer (YY_CURRENT_BUFFER)\n#endif\n\n/* OBSTACK_FOR_STRING -- Used to store all the characters that we need to\n   keep (to construct ID, STRINGS etc.).  Use the following macros to\n   use it.\n\n   Use STRING_GROW () to append what has just been matched, and\n   STRING_FINISH () to end the string (it puts the ending 0).\n   STRING_FINISH () also stores this string in LAST_STRING, which can be\n   used, and which is used by STRING_FREE () to free the last string.  */\n\n#ifndef FLEX_NO_OBSTACK\n\nstatic struct obstack obstack_for_string;\n\n# define STRING_GROW()                                  \\\n  obstack_grow (&obstack_for_string, yytext, yyleng)\n\n# define STRING_FINISH()                                \\\n  (last_string = obstack_finish0 (&obstack_for_string))\n\n# define STRING_1GROW(Char)                     \\\n  obstack_1grow (&obstack_for_string, Char)\n\n# define STRING_FREE()                                  \\\n  obstack_free (&obstack_for_string, last_string)\n\n#endif\n", "/* Bison Grammar Scanner                             -*- C -*-\n\n   Copyright (C) 2002-2015, 2018-2020 Free Software Foundation, Inc.\n\n   This file is part of Bison, the GNU Compiler Compiler.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n%option debug nodefault noinput noyywrap never-interactive\n%option prefix=\"gram_\" outfile=\"lex.yy.c\"\n\n%{\n#include <errno.h>\n\n#include <c-ctype.h>\n#include <mbswidth.h>\n#include <quote.h>\n#include <quotearg.h>\n\n#include \"src/complain.h\"\n#include \"src/files.h\"\n#include \"src/getargs.h\"\n#include \"src/gram.h\"\n#include \"src/reader.h\"\n#include \"src/scan-gram.h\"\n#include \"src/uniqstr.h\"\n\n#define FLEX_PREFIX(Id) gram_ ## Id\n#include \"src/flex-scanner.h\"\n\n/* Work around a bug in flex 2.5.31.  See Debian bug 333231\n   <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */\n#undef gram_wrap\n#define gram_wrap() 1\n\n#define YY_DECL GRAM_LEX_DECL\n\n/* Location of scanner cursor.  */\nstatic boundary scanner_cursor;\n\n#define YY_USER_ACTION  location_compute (loc, &scanner_cursor, yytext, yyleng);\n\n/* Report that yytext is an extension, and evaluate to its token kind.  */\n#define BISON_DIRECTIVE(Directive)                              \\\n  (bison_directive (loc, yytext), PERCENT_ ## Directive)\n\n#define RETURN_PERCENT_PARAM(Value)             \\\n  RETURN_VALUE(PERCENT_PARAM, param_ ## Value)\n\n#define RETURN_PERCENT_FLAG(Value)                      \\\n  RETURN_VALUE(PERCENT_FLAG, uniqstr_new (Value))\n\n#define RETURN_VALUE(Token, Value)              \\\n  do {                                          \\\n    val->Token = Value;                         \\\n    return Token;                               \\\n  } while (0)\n\n#define ROLLBACK_CURRENT_TOKEN                                  \\\n  do {                                                          \\\n    scanner_cursor.column -= mbsnwidth (yytext, yyleng, 0);     \\\n    scanner_cursor.byte -= yyleng;                              \\\n    yyless (0);                                                 \\\n  } while (0)\n\n#define DEPRECATED_DIRECTIVE(Msg)                               \\\n  do {                                                          \\\n    deprecated_directive (loc, yytext, Msg);                    \\\n    scanner_cursor.column -= mbsnwidth (Msg, strlen (Msg), 0);  \\\n    scanner_cursor.byte -= strlen (Msg);                        \\\n    for (size_t i = strlen (Msg); i != 0; --i)                  \\\n      unput (Msg[i - 1]);                                       \\\n  } while (0)\n\n\n#define STRING_GROW_ESCAPE(Char)                                \\\n  do {                                                          \\\n    verify (UCHAR_MAX < ULONG_MAX);                             \\\n    long c = Char;                                              \\\n    bool valid = 0 < c && c <= UCHAR_MAX;                       \\\n    if (!valid)                                                 \\\n      complain (loc, complaint,                                 \\\n                _(\"invalid number after \\\\-escape: %s\"),        \\\n                yytext + 1);                                    \\\n    if (YY_START == SC_ESCAPED_CHARACTER)                       \\\n      STRING_1GROW (valid ? c : '?');                           \\\n    else                                                        \\\n      STRING_GROW ();                                           \\\n  } while (0)\n\n\n/* The current file name.  Might change with #line.  */\nstatic uniqstr current_file = NULL;\n\n/* A string representing the most recently saved token.  */\nstatic char *last_string = NULL;\n\n/* Bracketed identifier. */\nstatic uniqstr bracketed_id_str = NULL;\nstatic location bracketed_id_loc;\nstatic boundary bracketed_id_start;\nstatic int bracketed_id_context_state = 0;\n\nvoid\ngram_scanner_last_string_free (void)\n{\n  STRING_FREE ();\n}\n\nstatic void handle_syncline (char *, location);\nstatic int scan_integer (char const *p, int base, location loc);\nstatic int convert_ucn_to_byte (char const *hex_text);\nstatic void unexpected_eof (boundary, char const *);\nstatic void unexpected_newline (boundary, char const *);\n\n%}\n /* A C-like comment in directives/rules. */\n%x SC_YACC_COMMENT\n /* Characters and strings in directives/rules. */\n%x SC_ESCAPED_CHARACTER SC_ESCAPED_STRING SC_ESCAPED_TSTRING\n /* A identifier was just read in directives/rules.  Special state\n    to capture the sequence 'identifier :'. */\n%x SC_AFTER_IDENTIFIER\n\n /* POSIX says that a tag must be both an id and a C union member, but\n    historically almost any character is allowed in a tag.  We\n    disallow NUL, as this simplifies our implementation.  We match\n    angle brackets in nested pairs: several languages use them for\n    generics/template types.  */\n%x SC_TAG\n\n /* Four types of user code:\n    - prologue (code between '%{' '%}' in the first section, before %%);\n    - actions, printers, union, etc, (between braced in the middle section);\n    - epilogue (everything after the second %%).\n    - predicate (code between '%?{' and '{' in middle section); */\n%x SC_PROLOGUE SC_BRACED_CODE SC_EPILOGUE SC_PREDICATE\n /* C and C++ comments in code. */\n%x SC_COMMENT SC_LINE_COMMENT\n /* Strings and characters in code. */\n%x SC_STRING SC_CHARACTER\n /* Bracketed identifiers support. */\n%x SC_BRACKETED_ID SC_RETURN_BRACKETED_ID\n\nletter    [.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]\nid        {letter}({letter}|[-0-9])*\nint       [0-9]+\nxint      0[xX][0-9abcdefABCDEF]+\n\neol       \\n|\\r\\n\n\n /* UTF-8 Encoded Unicode Code Point, from Flex's documentation. */\nmbchar    [\\x09\\x0A\\x0D\\x20-\\x7E]|[\\xC2-\\xDF][\\x80-\\xBF]|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]|[\\xE1-\\xEC\\xEE\\xEF]([\\x80-\\xBF]{2})|\\xED[\\x80-\\x9F][\\x80-\\xBF]|\\xF0[\\x\\90-\\xBF]([\\x80-\\xBF]{2})|[\\xF1-\\xF3]([\\x80-\\xBF]{3})|\\xF4[\\x80-\\x8F]([\\x80-\\xBF]{2})\n\n/* Zero or more instances of backslash-newline.  Following GCC, allow\n   white space between the backslash and the newline.  */\nsplice   (\\\\[ \\f\\t\\v]*{eol})*\n\n/* An equal sign, with optional leading whitespaces. This is used in some\n   deprecated constructs. */\nsp       [[:space:]]*\neqopt    ({sp}=)?\n\n%%\n%{\n  /* Nesting level.  Either for nested braces, or nested angle brackets\n     (but not mixed).  */\n  int nesting PACIFY_CC (= 0);\n\n  /* Parent context state, when applicable.  */\n  int context_state PACIFY_CC (= 0);\n\n  /* Location of most recent identifier, when applicable.  */\n  location id_loc PACIFY_CC (= empty_loc);\n\n  /* Where containing code started, when applicable.  Its initial\n     value is relevant only when yylex is invoked in the SC_EPILOGUE\n     start condition.  */\n  boundary code_start = scanner_cursor;\n\n  /* Where containing comment or string or character literal started,\n     when applicable.  */\n  boundary token_start PACIFY_CC (= scanner_cursor);\n\n  /* We cannot trust YY_USER_INIT, whose semantics changes over time\n     (it moved in Flex 2.5.38).  */\n  static bool first = true;\n  if (first)\n    {\n      scanner_cursor = loc->start;\n      first = false;\n    }\n%}\n\n\n  /*-----------------------.\n  | Scanning white space.  |\n  `-----------------------*/\n\n<INITIAL,SC_AFTER_IDENTIFIER,SC_BRACKETED_ID,SC_RETURN_BRACKETED_ID>\n{\n  /* Comments and white space.  */\n  \",\" {\n     complain (loc, Wother, _(\"stray ',' treated as white space\"));\n  }\n  [ \\f\\t\\v\\r]|{eol}  |\n  \"//\".*       continue;\n  \"/*\" {\n    token_start = loc->start;\n    context_state = YY_START;\n    BEGIN SC_YACC_COMMENT;\n  }\n\n  ^\"#line \"{int}(\" \\\"\".*\"\\\"\")?{eol} {\n    handle_syncline (yytext + sizeof \"#line \" - 1, *loc);\n  }\n}\n\n\n  /*----------------------------.\n  | Scanning Bison directives.  |\n  `----------------------------*/\n\n  /* For directives that are also command line options, the regex must be\n        \"%...\"\n     after \"[-_]\"s are removed, and the directive must match the --long\n     option name, with a single string argument.  Otherwise, add exceptions\n     to ../build-aux/cross-options.pl.  */\n\n<INITIAL>\n{\n  \"%binary\"                         return BISON_DIRECTIVE (NONASSOC);\n  \"%code\"                           return BISON_DIRECTIVE (CODE);\n  \"%debug\"                          RETURN_PERCENT_FLAG (\"parse.trace\");\n  \"%default-prec\"                   return BISON_DIRECTIVE (DEFAULT_PREC);\n  \"%define\"                         return BISON_DIRECTIVE (DEFINE);\n  \"%defines\"                        return BISON_DIRECTIVE (DEFINES);\n  \"%destructor\"                     return BISON_DIRECTIVE (DESTRUCTOR);\n  \"%dprec\"                          return BISON_DIRECTIVE (DPREC);\n  \"%empty\"                          return BISON_DIRECTIVE (EMPTY);\n  \"%expect\"                         return BISON_DIRECTIVE (EXPECT);\n  \"%expect-rr\"                      return BISON_DIRECTIVE (EXPECT_RR);\n  \"%file-prefix\"                    RETURN_VALUE (PERCENT_FILE_PREFIX, uniqstr_new (yytext));\n  \"%initial-action\"                 return BISON_DIRECTIVE (INITIAL_ACTION);\n  \"%glr-parser\"                     return BISON_DIRECTIVE (GLR_PARSER);\n  \"%language\"                       return BISON_DIRECTIVE (LANGUAGE);\n  \"%left\"                           return PERCENT_LEFT;\n  \"%lex-param\"                      RETURN_PERCENT_PARAM (lex);\n  \"%locations\"                      RETURN_PERCENT_FLAG (\"locations\");\n  \"%merge\"                          return BISON_DIRECTIVE (MERGE);\n  \"%no-default-prec\"                return BISON_DIRECTIVE (NO_DEFAULT_PREC);\n  \"%no-lines\"                       return BISON_DIRECTIVE (NO_LINES);\n  \"%nonassoc\"                       return PERCENT_NONASSOC;\n  \"%nondeterministic-parser\"        return BISON_DIRECTIVE (NONDETERMINISTIC_PARSER);\n  \"%nterm\"                          return BISON_DIRECTIVE (NTERM);\n  \"%output\"                         return BISON_DIRECTIVE (OUTPUT);\n  \"%param\"                          RETURN_PERCENT_PARAM (both);\n  \"%parse-param\"                    RETURN_PERCENT_PARAM (parse);\n  \"%prec\"                           return PERCENT_PREC;\n  \"%precedence\"                     return BISON_DIRECTIVE (PRECEDENCE);\n  \"%printer\"                        return BISON_DIRECTIVE (PRINTER);\n  \"%require\"                        return BISON_DIRECTIVE (REQUIRE);\n  \"%right\"                          return PERCENT_RIGHT;\n  \"%skeleton\"                       return BISON_DIRECTIVE (SKELETON);\n  \"%start\"                          return PERCENT_START;\n  \"%term\"                           return BISON_DIRECTIVE (TOKEN);\n  \"%token\"                          return PERCENT_TOKEN;\n  \"%token-table\"                    return BISON_DIRECTIVE (TOKEN_TABLE);\n  \"%type\"                           return PERCENT_TYPE;\n  \"%union\"                          return PERCENT_UNION;\n  \"%verbose\"                        return BISON_DIRECTIVE (VERBOSE);\n  \"%yacc\"                           return PERCENT_YACC;\n\n  /* Deprecated since Bison 2.3b (2008-05-27), but the warning is\n     issued only since Bison 3.4. */\n  \"%pure\"[-_]\"parser\"               RETURN_VALUE (PERCENT_PURE_PARSER, uniqstr_new (yytext));\n\n  /* Deprecated since Bison 3.0 (2013-07-25), but the warning is\n     issued only since Bison 3.3. */\n  \"%error-verbose\"                  RETURN_VALUE (PERCENT_ERROR_VERBOSE, uniqstr_new (yytext));\n\n  /* Deprecated since Bison 2.6 (2012-07-19), but the warning is\n     issued only since Bison 3.3. */\n  \"%name\"[-_]\"prefix\"{eqopt}{sp}    RETURN_VALUE (PERCENT_NAME_PREFIX, uniqstr_new (yytext));\n\n  /* Deprecated since Bison 2.7.90, 2012. */\n  \"%default\"[-_]\"prec\"              DEPRECATED_DIRECTIVE (\"%default-prec\");\n  \"%error\"[-_]\"verbose\"             RETURN_VALUE (PERCENT_ERROR_VERBOSE, uniqstr_new (yytext));\n  \"%expect\"[-_]\"rr\"                 DEPRECATED_DIRECTIVE (\"%expect-rr\");\n  \"%file-prefix\"{eqopt}             RETURN_VALUE (PERCENT_FILE_PREFIX, uniqstr_new (yytext));\n  \"%fixed\"[-_]\"output\"[-_]\"files\"   DEPRECATED_DIRECTIVE (\"%output \\\"y.tab.c\\\"\");\n  \"%no\"[-_]\"default\"[-_]\"prec\"      DEPRECATED_DIRECTIVE (\"%no-default-prec\");\n  \"%no\"[-_]\"lines\"                  DEPRECATED_DIRECTIVE (\"%no-lines\");\n  \"%output\"{eqopt}                  DEPRECATED_DIRECTIVE (\"%output\");\n  \"%token\"[-_]\"table\"               DEPRECATED_DIRECTIVE (\"%token-table\");\n\n  \"%\"{id} {\n    complain (loc, complaint, _(\"invalid directive: %s\"), quote (yytext));\n    return GRAM_error;\n  }\n\n  \":\"                     return COLON;\n  \"=\"                     return EQUAL;\n  \"|\"                     return PIPE;\n  \";\"                     return SEMICOLON;\n\n  {id} {\n    val->ID = uniqstr_new (yytext);\n    id_loc = *loc;\n    bracketed_id_str = NULL;\n    BEGIN SC_AFTER_IDENTIFIER;\n  }\n\n  {int}      RETURN_VALUE (INT, scan_integer (yytext, 10, *loc));\n  {xint}     RETURN_VALUE (INT, scan_integer (yytext, 16, *loc));\n\n  /* Identifiers may not start with a digit.  Yet, don't silently\n     accept \"1FOO\" as \"1 FOO\".  */\n  {int}{id} {\n    complain (loc, complaint, _(\"invalid identifier: %s\"), quote (yytext));\n    return GRAM_error;\n  }\n\n  /* Characters.  */\n  \"'\"         token_start = loc->start; BEGIN SC_ESCAPED_CHARACTER;\n\n  /* Strings. */\n  \"\\\"\"        token_start = loc->start; STRING_1GROW ('\"'); BEGIN SC_ESCAPED_STRING;\n  \"_(\\\"\"      token_start = loc->start; STRING_1GROW ('\"'); BEGIN SC_ESCAPED_TSTRING;\n\n  /* Prologue. */\n  \"%{\"        code_start = loc->start; BEGIN SC_PROLOGUE;\n\n  /* Code in between braces.  */\n  \"{\" {\n    STRING_GROW ();\n    nesting = 0;\n    code_start = loc->start;\n    BEGIN SC_BRACED_CODE;\n  }\n\n  /* Semantic predicate. */\n  \"%?\"([ \\f\\t\\v]|{eol})*\"{\" {\n    nesting = 0;\n    code_start = loc->start;\n    BEGIN SC_PREDICATE;\n  }\n\n  /* A type. */\n  \"<*>\"       return TAG_ANY;\n  \"<>\"        return TAG_NONE;\n  \"<\"         {\n    nesting = 0;\n    token_start = loc->start;\n    BEGIN SC_TAG;\n  }\n\n  \"%%\" {\n    static int percent_percent_count;\n    if (++percent_percent_count == 2)\n      BEGIN SC_EPILOGUE;\n    return PERCENT_PERCENT;\n  }\n\n  \"[\" {\n    bracketed_id_str = NULL;\n    bracketed_id_start = loc->start;\n    bracketed_id_context_state = YY_START;\n    BEGIN SC_BRACKETED_ID;\n  }\n\n  [^\\[%A-Za-z0-9_<>{}\"\"''*;|=/, \\f\\r\\n\\t\\v]+|. {\n    complain (loc, complaint, \"%s: %s\",\n              ngettext (\"invalid character\", \"invalid characters\", yyleng),\n              quote_mem (yytext, yyleng));\n    return GRAM_error;\n  }\n\n  <<EOF>> {\n    loc->start = loc->end = scanner_cursor;\n    yyterminate ();\n  }\n}\n\n\n  /*--------------------------------------------------------------.\n  | Supporting \\0 complexifies our implementation for no expected |\n  | added value.                                                  |\n  `--------------------------------------------------------------*/\n\n<SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING,SC_TAG>\n{\n  \\0         {\n    complain (loc, complaint, _(\"invalid null character\"));\n    STRING_FREE ();\n    return GRAM_error;\n  }\n}\n\n\n  /*-----------------------------------------------------------------.\n  | Scanning after an identifier, checking whether a colon is next.  |\n  `-----------------------------------------------------------------*/\n\n<SC_AFTER_IDENTIFIER>\n{\n  \"[\" {\n    if (bracketed_id_str)\n      {\n        ROLLBACK_CURRENT_TOKEN;\n        BEGIN SC_RETURN_BRACKETED_ID;\n        *loc = id_loc;\n        return ID;\n      }\n    else\n      {\n        bracketed_id_start = loc->start;\n        bracketed_id_context_state = YY_START;\n        BEGIN SC_BRACKETED_ID;\n      }\n  }\n  \":\" {\n    ROLLBACK_CURRENT_TOKEN;\n    BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);\n    *loc = id_loc;\n    return ID_COLON;\n  }\n  . {\n    ROLLBACK_CURRENT_TOKEN;\n    BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);\n    *loc = id_loc;\n    return ID;\n  }\n  <<EOF>> {\n    BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);\n    *loc = id_loc;\n    return ID;\n  }\n}\n\n  /*--------------------------------.\n  | Scanning bracketed identifiers. |\n  `--------------------------------*/\n\n<SC_BRACKETED_ID>\n{\n  {id} {\n    if (bracketed_id_str)\n      {\n        complain (loc, complaint,\n                  _(\"unexpected identifier in bracketed name: %s\"),\n                  quote (yytext));\n        return GRAM_error;\n      }\n    else\n      {\n        bracketed_id_str = uniqstr_new (yytext);\n        bracketed_id_loc = *loc;\n      }\n  }\n  \"]\" {\n    BEGIN bracketed_id_context_state;\n    if (bracketed_id_str)\n      {\n        if (INITIAL == bracketed_id_context_state)\n          {\n            val->BRACKETED_ID = bracketed_id_str;\n            bracketed_id_str = 0;\n            *loc = bracketed_id_loc;\n            return BRACKETED_ID;\n          }\n      }\n    else\n      {\n        complain (loc, complaint, _(\"an identifier expected\"));\n        return GRAM_error;\n      }\n  }\n\n  [^\\].A-Za-z0-9_/ \\f\\r\\n\\t\\v]+|. {\n    complain (loc, complaint, \"%s: %s\",\n              ngettext (\"invalid character in bracketed name\",\n                        \"invalid characters in bracketed name\", yyleng),\n              quote_mem (yytext, yyleng));\n    return GRAM_error;\n  }\n\n  <<EOF>> {\n    BEGIN bracketed_id_context_state;\n    unexpected_eof (bracketed_id_start, \"]\");\n  }\n}\n\n<SC_RETURN_BRACKETED_ID>\n{\n  . {\n    ROLLBACK_CURRENT_TOKEN;\n    val->BRACKETED_ID = bracketed_id_str;\n    bracketed_id_str = 0;\n    *loc = bracketed_id_loc;\n    BEGIN INITIAL;\n    return BRACKETED_ID;\n  }\n}\n\n\n  /*---------------------------------------------------------------.\n  | Scanning a Yacc comment.  The initial '/ *' is already eaten.  |\n  `---------------------------------------------------------------*/\n\n<SC_YACC_COMMENT>\n{\n  \"*/\"     BEGIN context_state;\n  .|{eol}  continue;\n  <<EOF>>  unexpected_eof (token_start, \"*/\"); BEGIN context_state;\n}\n\n\n  /*------------------------------------------------------------.\n  | Scanning a C comment.  The initial '/ *' is already eaten.  |\n  `------------------------------------------------------------*/\n\n<SC_COMMENT>\n{\n  \"*\"{splice}\"/\"  STRING_GROW (); BEGIN context_state;\n  <<EOF>>         unexpected_eof (token_start, \"*/\"); BEGIN context_state;\n}\n\n\n  /*--------------------------------------------------------------.\n  | Scanning a line comment.  The initial '//' is already eaten.  |\n  `--------------------------------------------------------------*/\n\n<SC_LINE_COMMENT>\n{\n  {eol}          STRING_GROW (); BEGIN context_state;\n  {splice}       STRING_GROW ();\n  <<EOF>>        BEGIN context_state;\n}\n\n\n  /*------------------------------------------------.\n  | Scanning a Bison string, including its escapes. |\n  | The initial quote is already eaten.             |\n  `------------------------------------------------*/\n\n<SC_ESCAPED_STRING>\n{\n  \"\\\"\" {\n    STRING_1GROW ('\"');\n    STRING_FINISH ();\n    BEGIN INITIAL;\n    loc->start = token_start;\n    complain (loc, Wyacc,\n              _(\"POSIX Yacc does not support string literals\"));\n    RETURN_VALUE (STRING, last_string);\n  }\n}\n\n<SC_ESCAPED_TSTRING>\n{\n  \"\\\")\" {\n    STRING_1GROW ('\"');\n    STRING_FINISH ();\n    BEGIN INITIAL;\n    loc->start = token_start;\n    complain (loc, Wyacc,\n              _(\"POSIX Yacc does not support string literals\"));\n    RETURN_VALUE (TSTRING, last_string);\n  }\n}\n\n<SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>\n{\n  <<EOF>>   unexpected_eof (token_start, \"\\\"\");\n  \"\\n\"      unexpected_newline (token_start, \"\\\"\");\n}\n\n\n  /*----------------------------------------------------------.\n  | Scanning a Bison character literal, decoding its escapes. |\n  | The initial quote is already eaten.                       |\n  `----------------------------------------------------------*/\n\n<SC_ESCAPED_CHARACTER>\n{\n  \"'\" {\n    STRING_FINISH ();\n    BEGIN INITIAL;\n    loc->start = token_start;\n    val->CHAR = last_string[0];\n\n    if (last_string[0] == '\\0')\n      {\n        complain (loc, complaint, _(\"empty character literal\"));\n        STRING_FREE ();\n        return GRAM_error;\n      }\n    else if (last_string[1] != '\\0')\n      {\n        complain (loc, complaint, _(\"extra characters in character literal\"));\n        STRING_FREE ();\n        return GRAM_error;\n      }\n    else\n      {\n        STRING_FREE ();\n        return CHAR;\n      }\n  }\n  {eol}     unexpected_newline (token_start, \"'\");\n  <<EOF>>   unexpected_eof (token_start, \"'\");\n}\n\n\n\n  /*--------------------------------------------------------------.\n  | Scanning a tag.  The initial angle bracket is already eaten.  |\n  `--------------------------------------------------------------*/\n\n<SC_TAG>\n{\n  \">\" {\n    --nesting;\n    if (nesting < 0)\n      {\n        STRING_FINISH ();\n        loc->start = token_start;\n        val->TAG = uniqstr_new (last_string);\n        STRING_FREE ();\n        BEGIN INITIAL;\n        return TAG;\n      }\n    STRING_GROW ();\n  }\n\n  ([^<>]|->)+ STRING_GROW ();\n  \"<\"+   STRING_GROW (); nesting += yyleng;\n\n  <<EOF>>   unexpected_eof (token_start, \">\");\n}\n\n  /*----------------------------.\n  | Decode escaped characters.  |\n  `----------------------------*/\n\n<SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>\n{\n  \\\\[0-7]{1,3} {\n    STRING_GROW_ESCAPE (strtol (yytext + 1, NULL, 8));\n  }\n\n  \\\\x[0-9abcdefABCDEF]+ {\n    STRING_GROW_ESCAPE (strtol (yytext + 2, NULL, 16));\n  }\n\n  \\\\a   STRING_GROW_ESCAPE ('\\a');\n  \\\\b   STRING_GROW_ESCAPE ('\\b');\n  \\\\f   STRING_GROW_ESCAPE ('\\f');\n  \\\\n   STRING_GROW_ESCAPE ('\\n');\n  \\\\r   STRING_GROW_ESCAPE ('\\r');\n  \\\\t   STRING_GROW_ESCAPE ('\\t');\n  \\\\v   STRING_GROW_ESCAPE ('\\v');\n\n  /* \\\\[\\\"\\'?\\\\] would be shorter, but it confuses xgettext.  */\n  \\\\(\"\\\"\"|\"'\"|\"?\"|\"\\\\\")  STRING_GROW_ESCAPE (yytext[1]);\n\n  \\\\(u|U[0-9abcdefABCDEF]{4})[0-9abcdefABCDEF]{4} {\n    STRING_GROW_ESCAPE (convert_ucn_to_byte (yytext));\n  }\n\n  \\\\(.|{eol})      {\n    char const *p = yytext + 1;\n    /* Quote only if escaping won't make the character visible.  */\n    if (c_isspace ((unsigned char) *p) && c_isprint ((unsigned char) *p))\n      p = quote (p);\n    else\n      p = quotearg_style_mem (escape_quoting_style, p, 1);\n    complain (loc, complaint, _(\"invalid character after \\\\-escape: %s\"),\n              p);\n    STRING_1GROW ('?');\n  }\n}\n\n  /*--------------------------------------------.\n  | Scanning user-code characters and strings.  |\n  `--------------------------------------------*/\n\n<SC_CHARACTER,SC_STRING>\n{\n  {splice}|\\\\{splice}[^\\n\\[\\]]  STRING_GROW ();\n}\n\n<SC_CHARACTER>\n{\n  \"'\"           STRING_GROW (); BEGIN context_state;\n  {eol}         unexpected_newline (token_start, \"'\");\n  <<EOF>>       unexpected_eof (token_start, \"'\");\n}\n\n<SC_STRING>\n{\n  \"\\\"\"          STRING_GROW (); BEGIN context_state;\n  {eol}         unexpected_newline (token_start, \"\\\"\");\n  <<EOF>>       unexpected_eof (token_start, \"\\\"\");\n}\n\n\n  /*---------------------------------------------------.\n  | Strings, comments etc. can be found in user code.  |\n  `---------------------------------------------------*/\n\n<SC_BRACED_CODE,SC_PROLOGUE,SC_EPILOGUE,SC_PREDICATE>\n{\n  \"'\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    token_start = loc->start;\n    BEGIN SC_CHARACTER;\n  }\n  \"\\\"\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    token_start = loc->start;\n    BEGIN SC_STRING;\n  }\n  \"/\"{splice}\"*\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    token_start = loc->start;\n    BEGIN SC_COMMENT;\n  }\n  \"/\"{splice}\"/\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    BEGIN SC_LINE_COMMENT;\n  }\n}\n\n\n\n  /*-----------------------------------------------------------.\n  | Scanning some code in braces (actions, predicates). The    |\n  | initial \"{\" is already eaten.                              |\n  `-----------------------------------------------------------*/\n\n<SC_BRACED_CODE,SC_PREDICATE>\n{\n  \"{\"|\"<\"{splice}\"%\"  STRING_GROW (); nesting++;\n  \"%\"{splice}\">\"      STRING_GROW (); nesting--;\n\n  /* Tokenize '<<%' correctly (as '<<' '%') rather than incorrectly\n     (as '<' '<%').  */\n  \"<\"{splice}\"<\"  STRING_GROW ();\n\n  <<EOF>>   unexpected_eof (code_start, \"}\");\n}\n\n<SC_BRACED_CODE>\n{\n  \"}\" {\n    STRING_1GROW ('}');\n\n    --nesting;\n    if (nesting < 0)\n      {\n        STRING_FINISH ();\n        loc->start = code_start;\n        BEGIN INITIAL;\n        RETURN_VALUE (BRACED_CODE, last_string);\n      }\n  }\n}\n\n<SC_PREDICATE>\n{\n  \"}\" {\n    --nesting;\n    if (nesting < 0)\n      {\n        STRING_FINISH ();\n        loc->start = code_start;\n        BEGIN INITIAL;\n        RETURN_VALUE (BRACED_PREDICATE, last_string);\n      }\n    else\n      STRING_1GROW ('}');\n  }\n}\n\n  /*--------------------------------------------------------------.\n  | Scanning some prologue: from \"%{\" (already scanned) to \"%}\".  |\n  `--------------------------------------------------------------*/\n\n<SC_PROLOGUE>\n{\n  \"%}\" {\n    STRING_FINISH ();\n    loc->start = code_start;\n    BEGIN INITIAL;\n    RETURN_VALUE (PROLOGUE, last_string);\n  }\n\n  <<EOF>>   unexpected_eof (code_start, \"%}\");\n}\n\n\n  /*---------------------------------------------------------------.\n  | Scanning the epilogue (everything after the second \"%%\", which |\n  | has already been eaten).                                       |\n  `---------------------------------------------------------------*/\n\n<SC_EPILOGUE>\n{\n  <<EOF>> {\n    STRING_FINISH ();\n    loc->start = code_start;\n    BEGIN INITIAL;\n    RETURN_VALUE (EPILOGUE, last_string);\n  }\n}\n\n\n  /*-----------------------------------------------------.\n  | By default, grow the string obstack with the input.  |\n  `-----------------------------------------------------*/\n\n<SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE,SC_STRING,SC_CHARACTER,SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>\n{\n  /* Accept multibyte characters in one block instead of byte after\n     byte, so that add_column_width and mbsnwidth can compute correct\n     screen width.\n\n     Add a fallthrough \"|.\" so that non UTF-8 input is still accepted\n     and does not jam the scanner.  */\n  {mbchar}|.   STRING_GROW ();\n}\n\n%%\n\n\n/*------------------------------------------------------.\n| Scan NUMBER for a base-BASE integer at location LOC.  |\n`------------------------------------------------------*/\n\nstatic int\nscan_integer (char const *number, int base, location loc)\n{\n  verify (INT_MAX < ULONG_MAX);\n  if (base == 16)\n    complain (&loc, Wyacc,\n              _(\"POSIX Yacc does not support hexadecimal literals\"));\n\n  errno = 0;\n  long num = strtol (number, NULL, base);\n\n  if (! (0 <= num && num <= INT_MAX && errno == 0))\n    {\n      complain (&loc, complaint, _(\"integer out of range: %s\"),\n                quote (number));\n      num = INT_MAX;\n    }\n\n  return num;\n}\n\n\n/*------------------------------------------------------------------.\n| Convert universal character name UCN to a single-byte character,  |\n| and return that character.  Return -1 if UCN does not correspond  |\n| to a single-byte character.                                       |\n`------------------------------------------------------------------*/\n\nstatic int\nconvert_ucn_to_byte (char const *ucn)\n{\n  verify (UCHAR_MAX <= INT_MAX);\n  long code = strtol (ucn + 2, NULL, 16);\n\n  /* FIXME: Currently we assume Unicode-compatible unibyte characters\n     on ASCII hosts (i.e., Latin-1 on hosts with 8-bit bytes).  On\n     non-ASCII hosts we support only the portable C character set.\n     These limitations should be removed once we add support for\n     multibyte characters.  */\n\n  if (! (0 <= code && code <= UCHAR_MAX))\n    return -1;\n\n#if ! ('$' == 0x24 && '@' == 0x40 && '`' == 0x60 && '~' == 0x7e)\n  {\n    /* A non-ASCII host.  Use CODE to index into a table of the C\n       basic execution character set, which is guaranteed to exist on\n       all Standard C platforms.  This table also includes '$', '@',\n       and '`', which are not in the basic execution character set but\n       which are unibyte characters on all the platforms that we know\n       about.  */\n    static signed char const table[] =\n      {\n        '\\0',   -1,   -1,   -1,   -1,   -1,   -1, '\\a',\n        '\\b', '\\t', '\\n', '\\v', '\\f', '\\r',   -1,   -1,\n          -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n          -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n         ' ',  '!',  '\"',  '#',  '$',  '%',  '&', '\\'',\n         '(',  ')',  '*',  '+',  ',',  '-',  '.',  '/',\n         '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',\n         '8',  '9',  ':',  ';',  '<',  '=',  '>',  '?',\n         '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',\n         'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',\n         'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',\n         'X',  'Y',  'Z',  '[', '\\\\',  ']',  '^',  '_',\n         '`',  'a',  'b',  'c',  'd',  'e',  'f',  'g',\n         'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',\n         'p',  'q',  'r',  's',  't',  'u',  'v',  'w',\n         'x',  'y',  'z',  '{',  '|',  '}',  '~'\n      };\n\n    code = code < sizeof table ? table[code] : -1;\n  }\n#endif\n\n  return code;\n}\n\n\n/*---------------------------------------------------------------------.\n| Handle '#line INT( \"FILE\")?\\n'.  ARGS has already skipped '#line '.  |\n`---------------------------------------------------------------------*/\n\nstatic void\nhandle_syncline (char *args, location loc)\n{\n  char *file;\n  errno = 0;\n  long lineno = strtol (args, &file, 10);\n  if (! (0 <= lineno && lineno <= INT_MAX && errno == 0))\n    {\n      complain (&loc, Wother, _(\"line number overflow\"));\n      lineno = INT_MAX;\n    }\n\n  file = strchr (file, '\"');\n  if (file)\n    {\n      *strchr (file + 1, '\"') = '\\0';\n      current_file = uniqstr_new (file + 1);\n    }\n  boundary_set (&scanner_cursor, current_file, lineno, 1, 1);\n}\n\n\n/*----------------------------------------------------------------.\n| For a token or comment starting at START, report message MSGID, |\n| which should say that an end marker was found before the        |\n| expected TOKEN_END. Then, pretend that TOKEN_END was found.     |\n`----------------------------------------------------------------*/\n\nstatic void\nunexpected_end (boundary start, char const *msgid, char const *token_end)\n{\n  location loc;\n  loc.start = start;\n  loc.end = scanner_cursor;\n  size_t i = strlen (token_end);\n\n  /* Adjust scanner cursor so that any later message does not count\n     the characters about to be inserted.  */\n  scanner_cursor.column -= i;\n  scanner_cursor.byte -= i;\n\n  while (i != 0)\n    unput (token_end[--i]);\n\n  token_end = quote (token_end);\n  /* Instead of '\\'', display \"'\".  */\n  if (STREQ (token_end, \"'\\\\''\"))\n    token_end = \"\\\"'\\\"\";\n  complain (&loc, complaint, msgid, token_end);\n}\n\n\n/*------------------------------------------------------------------------.\n| Report an unexpected EOF in a token or comment starting at START.       |\n| An end of file was encountered and the expected TOKEN_END was missing.  |\n| After reporting the problem, pretend that TOKEN_END was found.          |\n`------------------------------------------------------------------------*/\n\nstatic void\nunexpected_eof (boundary start, char const *token_end)\n{\n  unexpected_end (start, _(\"missing %s at end of file\"), token_end);\n}\n\n\n/*----------------------------------------.\n| Likewise, but for unexpected newlines.  |\n`----------------------------------------*/\n\nstatic void\nunexpected_newline (boundary start, char const *token_end)\n{\n  unexpected_end (start, _(\"missing %s at end of line\"), token_end);\n}\n\n\nvoid\ngram_scanner_open (const char *gram)\n{\n  gram__flex_debug = trace_flag & trace_scan;\n  gram_debug = trace_flag & trace_parse;\n  obstack_init (&obstack_for_string);\n  current_file = gram;\n  gram_in = xfopen (gram, \"r\");\n}\n\n\nvoid\ngram_scanner_close (void)\n{\n  xfclose (gram_in);\n  /* Reclaim Flex's buffers.  */\n  yylex_destroy ();\n}\n\n\nvoid\ngram_scanner_free (void)\n{\n  obstack_free (&obstack_for_string, 0);\n}\n", "# Checking the Bison scanner.                    -*- Autotest -*-\n\n# Copyright (C) 2002-2015, 2018-2020 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAT_BANNER([[Input Processing.]])\n\n# Mostly test that we are robust to mistakes.\n\n\n## ----------------------------- ##\n## Invalid number of arguments.  ##\n## ----------------------------- ##\n\nAT_SETUP([Invalid number of arguments])\n\nAT_BISON_CHECK([], [1], [],\n[[bison: missing operand\nTry 'bison --help' for more information.\n]])\n\nAT_BISON_CHECK([1.y 2.y], [1], [],\n[[bison: extra operand '2.y'\nTry 'bison --help' for more information.\n]])\n\n# For some reason, on some systems we use the system's getopt, not the\n# one we ship in gnulib.  So we can get two different error messages.\n# See https://lists.gnu.org/archive/html/bison-patches/2018-10/msg00154.html\nAT_BISON_CHECK([--skeleton], [1], [], [stderr])\nAT_CHECK([[sed -e \\\n  \"s/requires an argument -- skeleton/'--skeleton' requires an argument/\" \\\n  stderr]], 0,\n[[bison: option '--skeleton' requires an argument\nTry 'bison --help' for more information.\n]])\n\nAT_CLEANUP\n\n\n\n## ----------------- ##\n## Invalid options.  ##\n## ----------------- ##\n\nAT_SETUP([Invalid options])\n\nAT_DATA([input.y],\n[[%%\nexp: '0'\n]])\n\n# We used to accept these, as -f, --report and others were sharing\n# their code with -W.\nAT_BISON_CHECK([-ferror=caret input.y], [1], [], [ignore])\nAT_BISON_CHECK([--report=error=itemsets input.y], [1], [], [ignore])\n\n# We used to accept any character after \"-Werror\", instead of ensuring\n# this is \"=\".\nAT_BISON_CHECK([-Werror?all input.y], [1], [], [ignore])\n\nAT_CLEANUP\n\n\n## ---------------- ##\n## Invalid inputs.  ##\n## ---------------- ##\n\nAT_SETUP([Invalid inputs])\n\nAT_DATA([input.y],\n[[\\000\\001\\002\\377?\n%%\n?\ndefault: 'a' }\n%&\n%a-does-not-exist\n%-\n%{\n]])\nAT_PERL_REQUIRE([[-pi -e 's/\\\\(\\d{3})/chr(oct($1))/ge' input.y]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:1.1-2: error: invalid characters: '\\0\\001\\002\\377?'\ninput.y:3.1: error: invalid character: '?'\ninput.y:4.14: error: invalid character: '}'\ninput.y:5.1: error: invalid character: '%'\ninput.y:5.2: error: invalid character: '&'\ninput.y:6.1-17: error: invalid directive: '%a-does-not-exist'\ninput.y:7.1: error: invalid character: '%'\ninput.y:7.2: error: invalid character: '-'\ninput.y:8.1-9.0: error: missing '%}' at end of file\n]])\n\nAT_CLEANUP\n\n\nAT_SETUP([Invalid inputs with {}])\n\n# We used to SEGV here.  See\n# http://lists.gnu.org/archive/html/bug-bison/2005-07/msg00053.html\n\nAT_DATA([input.y],\n[[\n%destructor\n%initial-action\n%lex-param\n%parse-param\n%printer\n%union\n]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:3.1-15: error: expected {...} before %initial-action\n]])\n\nAT_CLEANUP\n\n\n## -------------------------- ##\n## Yacc warnings on symbols.  ##\n## -------------------------- ##\n\nAT_SETUP([Yacc warnings on symbols])\n\nAT_DATA([input.y],\n[[%nterm exp\n%token NUM 0x40 \"number\"\n%%\nexp: \"number\";\n]])\n\nAT_BISON_CHECK([-fcaret -Wyacc input.y], [0], [],\n[[input.y:1.1-6: warning: POSIX Yacc does not support %nterm [-Wyacc]\n    1 | %nterm exp\n      | ^~~~~~\ninput.y:2.12-15: warning: POSIX Yacc does not support hexadecimal literals [-Wyacc]\n    2 | %token NUM 0x40 \"number\"\n      |            ^~~~\ninput.y:2.17-24: warning: POSIX Yacc does not support string literals [-Wyacc]\n    2 | %token NUM 0x40 \"number\"\n      |                 ^~~~~~~~\ninput.y:4.6-13: warning: POSIX Yacc does not support string literals [-Wyacc]\n    4 | exp: \"number\";\n      |      ^~~~~~~~\n]])\n\nAT_CLEANUP\n\n\n## --------------- ##\n## Yacc warnings.  ##\n## --------------- ##\n\nAT_SETUP([Yacc warnings])\n\nAT_DATA([input.y],\n[[%destructor {} <int>\n%printer {} <int>\n%type <int> exp a b\n%%\nexp: a b             { $$ = $1 + $2; };\na: <int>{ $$ = 42; } { $$ = $1; };\nb: %empty            { $$ = 42; };\n]])\n\nAT_BISON_CHECK([-fcaret -Wyacc input.y], [0], [],\n[[input.y:1.1-11: warning: POSIX Yacc does not support %destructor [-Wyacc]\n    1 | %destructor {} <int>\n      | ^~~~~~~~~~~\ninput.y:2.1-8: warning: POSIX Yacc does not support %printer [-Wyacc]\n    2 | %printer {} <int>\n      | ^~~~~~~~\ninput.y:6.9-20: warning: POSIX Yacc does not support typed midrule actions [-Wyacc]\n    6 | a: <int>{ $$ = 42; } { $$ = $1; };\n      |         ^~~~~~~~~~~~\ninput.y:7.4-9: warning: POSIX Yacc does not support %empty [-Wyacc]\n    7 | b: %empty            { $$ = 42; };\n      |    ^~~~~~\n]])\n\nAT_CLEANUP\n\n\n## -------------- ##\n## Yacc's %type.  ##\n## -------------- ##\n\nAT_SETUP([Yacc's %type])\n\nAT_DATA([input.y],\n[[%token TOKEN1\n%nterm nterm1\n%type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n%token TOKEN2\n%nterm nterm2\n%%\nexpr: nterm1 nterm2 nterm3\nnterm1: TOKEN1\nnterm2: TOKEN2\nnterm3: \"TOKEN3\"\n]])\n\nAT_BISON_CHECK([-fcaret -Wyacc input.y], [0], [],\n[[input.y:2.1-6: warning: POSIX Yacc does not support %nterm [-Wyacc]\n    2 | %nterm nterm1\n      | ^~~~~~\ninput.y:3.14-19: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |              ^~~~~~\ninput.y:3.28-35: warning: POSIX Yacc does not support string literals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                            ^~~~~~~~\ninput.y:3.28-35: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                            ^~~~~~~~\ninput.y:3.58-60: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                                                          ^~~\ninput.y:5.1-6: warning: POSIX Yacc does not support %nterm [-Wyacc]\n    5 | %nterm nterm2\n      | ^~~~~~\ninput.y:3.21-26: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                     ^~~~~~\ninput.y:10.9-16: warning: POSIX Yacc does not support string literals [-Wyacc]\n   10 | nterm3: \"TOKEN3\"\n      |         ^~~~~~~~\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------- ##\n## Invalid symbol declarations.  ##\n## ----------------------------- ##\n\nAT_SETUP([Invalid symbol declarations])\n\nAT_DATA([input.y],\n[[%nterm expr \"expression\";\n%nterm term 123;\n%nterm fact 124 \"factor\";\n%nterm '+' '*';\n%nterm \"number\";\n%token \"tok1\" 1;\n%left \"tok2\" 2;\n%type \"tok3\" 3;\n%%\nexpr: expr '+' term | term;\nterm: term '*' fact | fact;\nfact: \"number\";\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:1.13-24: error: nonterminals cannot be given a string alias\n    1 | %nterm expr \"expression\";\n      |             ^~~~~~~~~~~~\ninput.y:2.13-15: error: nonterminals cannot be given a token code\n    2 | %nterm term 123;\n      |             ^~~\ninput.y:3.13-15: error: nonterminals cannot be given a token code\n    3 | %nterm fact 124 \"factor\";\n      |             ^~~\ninput.y:3.17-24: error: nonterminals cannot be given a string alias\n    3 | %nterm fact 124 \"factor\";\n      |                 ^~~~~~~~\ninput.y:4.8-10: error: character literals cannot be nonterminals\n    4 | %nterm '+' '*';\n      |        ^~~\ninput.y:5.8-15: error: expected character literal or identifier or <tag> before string\n    5 | %nterm \"number\";\n      |        ^~~~~~~~\ninput.y:6.8-13: error: expected character literal or identifier or <tag> before string\n    6 | %token \"tok1\" 1;\n      |        ^~~~~~\ninput.y:7.14: error: unexpected integer literal\n    7 | %left \"tok2\" 2;\n      |              ^\ninput.y:8.14: error: unexpected integer literal\n    8 | %type \"tok3\" 3;\n      |              ^\n]])\n\nAT_CLEANUP\n\n\n## ---------------------------- ##\n## Redefining the error token.  ##\n## ---------------------------- ##\n\nAT_SETUP([Redefining the error token])\n\n# We used to crash when trying to display the original definition of\n# \"error\", which is a builtin without any location.\nAT_BISON_OPTION_PUSHDEFS\n\nAT_DATA([input.y],\n[[%token error 123\n%token error 124\n%%\nexp:\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.8-12: warning: symbol error redeclared [-Wother]\n    2 | %token error 124\n      |        ^~~~~\ninput.y:1.8-12: note: previous declaration\n    1 | %token error 123\n      |        ^~~~~\ninput.y:2.14-16: error: redefining code of token error\n    2 | %token error 124\n      |              ^~~\n]])\n\n# While at it, make sure we properly used the user's number for\n# \"error\".  I don't see what it buys us, but...\nAT_DATA([input.y],\n[[%{\n#include <assert.h>\n#include <stdio.h>\n]AT_YYERROR_DEFINE[\n]AT_YYLEX_DEFINE[\n%}\n\n%token error 123\n%%\nexp:\n%%\nint main (void)\n{\n  assert (YYerror == 123);\n  assert (YYTRANSLATE (YYEOF) == YYSYMBOL_YYEOF);\n  assert (YYTRANSLATE (YYerror) == YYSYMBOL_YYerror);\n  assert (YYTRANSLATE (YYUNDEF) == YYSYMBOL_YYUNDEF);\n  return 0;\n}\n]])\n\nAT_FULL_COMPILE([input])\nAT_PARSER_CHECK([input], 0)\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ------------------ ##\n## Dangling aliases.  ##\n## ------------------ ##\n\nAT_SETUP([Dangling aliases])\n\nAT_DATA([input.y],\n[[%token FOO \"foo\"\n%type <val> \"bar\"\n%%\nexpr: \"foo\" \"bar\" \"baz\"\n]])\n\nAT_BISON_CHECK([-fcaret -Wdangling input.y], [0], [],\n[[input.y:2.13-17: warning: string literal \"bar\" not attached to a symbol [-Wdangling-alias]\n    2 | %type <val> \"bar\"\n      |             ^~~~~\ninput.y:4.19-23: warning: string literal \"baz\" not attached to a symbol [-Wdangling-alias]\n    4 | expr: \"foo\" \"bar\" \"baz\"\n      |                   ^~~~~\n]])\n\nAT_CLEANUP\n\n\n## --------------------- ##\n## Symbol declarations.  ##\n## --------------------- ##\n\n# Check the parsing of %token, %nterm, %type and %left...\nAT_SETUP([Symbol declarations])\n\nAT_DATA([dump-symbols.m4],\n[[m4@&t@_define([b4_api_PREFIX], [YY])\n\nm4@&t@_define([b4_symbol_dump],\n[$1, d@&t@nl\nb4_symbol_if([$1], [is_token], [Token], [Nonterminal]), d@&t@nl\nb4_symbol([$1], [tag]), d@&t@nl\nb4_symbol([$1], [id]), d@&t@nl\nb4_symbol([$1], [code]), d@&t@nl\nb4_symbol([$1], [type]),\n])\n\nb4_output_begin([symbols.csv])\nnumber, class, tag, id, code, type,\nb4_symbol_foreach([b4_symbol_dump])d@&t@nl\nb4_output_end\n]])\n\nAT_DATA([input.y],\n[[%token 'a' A1 1 \"A1\" A2 A3 \"A3\" A4 4\n      <type_b> 'b' B5 5 \"B5\" B6 B7 \"B8\" B9 9\n      <type_c> 'c' C10 10 \"C10\" C11 C12 \"C12\" C13 13\n\n%left 'd' D20 20 \"D20\" D21 D22 \"D22\" D23 23\n      <type_e> 'e' E25 25 \"E25\" E26 E27 \"E28\" E29 29\n      <type_f> 'f' F30 30 \"F30\" F31 F32 \"F32\" F33 33\n\n%type 'g' G40 \"D40\" G21 G22 G23\n      <type_h> 'h' H25 \"H25\" H26 H27 \"H28\" H29\n      <type_i> 'i' I30 \"I30\" I31 I32 \"I32\" I33\n\n%nterm j60 j61 j62 j63\n      <type_k> k75 k76 k77 k79\n      <type_l> l80 l81 l82 l83\n%%\nexp:;\n]])\n\nAT_BISON_CHECK([-Wno-other -S./dump-symbols.m4 input.y])\nAT_CHECK([cat symbols.csv], [],\n[[number, class, tag, id, code, type,\n0, Token, \"end of file\", YYEOF, 0, ,\n1, Token, error, YYerror, 256, ,\n2, Token, \"invalid token\", YYUNDEF, 257, ,\n3, Token, 'a', , 97, ,\n4, Token, \"A1\", A1, 1, ,\n5, Token, A2, A2, 258, ,\n6, Token, \"A3\", A3, 259, ,\n7, Token, A4, A4, 4, ,\n8, Token, 'b', , 98, type_b,\n9, Token, \"B5\", B5, 5, type_b,\n10, Token, B6, B6, 260, type_b,\n11, Token, \"B8\", B7, 261, type_b,\n12, Token, B9, B9, 9, type_b,\n13, Token, 'c', , 99, type_c,\n14, Token, \"C10\", C10, 10, type_c,\n15, Token, C11, C11, 262, type_c,\n16, Token, \"C12\", C12, 263, type_c,\n17, Token, C13, C13, 13, type_c,\n18, Token, 'd', , 100, ,\n19, Token, D20, D20, 20, ,\n20, Token, \"D20\", , 264, ,\n21, Token, D21, D21, 265, ,\n22, Token, D22, D22, 266, ,\n23, Token, \"D22\", , 267, ,\n24, Token, D23, D23, 23, ,\n25, Token, 'e', , 101, type_e,\n26, Token, E25, E25, 25, type_e,\n27, Token, \"E25\", , 268, type_e,\n28, Token, E26, E26, 269, type_e,\n29, Token, E27, E27, 270, type_e,\n30, Token, \"E28\", , 271, type_e,\n31, Token, E29, E29, 29, type_e,\n32, Token, 'f', , 102, type_f,\n33, Token, F30, F30, 30, type_f,\n34, Token, \"F30\", , 272, type_f,\n35, Token, F31, F31, 273, type_f,\n36, Token, F32, F32, 274, type_f,\n37, Token, \"F32\", , 275, type_f,\n38, Token, F33, F33, 33, type_f,\n39, Token, 'g', , 103, ,\n40, Token, \"D40\", , 276, ,\n41, Token, 'h', , 104, type_h,\n42, Token, \"H25\", , 277, type_h,\n43, Token, \"H28\", , 278, type_h,\n44, Token, 'i', , 105, type_i,\n45, Token, \"I30\", , 279, type_i,\n46, Token, \"I32\", , 280, type_i,\n47, Nonterminal, $accept, , -1, ,\n48, Nonterminal, exp, exp, -1, ,\n]])\n\nAT_CLEANUP\n\n\n## ------------ ##\n## Invalid $n.  ##\n## ------------ ##\n\nAT_SETUP([Invalid $n and @n])\n\nAT_DATA([input.y],\n[[%%\nexp: %empty { $$ = $1 ; };\nexp: %empty { @$ = @1 ; };\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.20-21: error: integer out of range: '$1'\n    2 | exp: %empty { $$ = $1 ; };\n      |                    ^~\ninput.y:3.20-21: error: integer out of range: '@1'\n    3 | exp: %empty { @$ = @1 ; };\n      |                    ^~\n]])\n\nAT_CLEANUP\n\n\n## -------------- ##\n## Type Clashes.  ##\n## -------------- ##\n\nAT_SETUP([Type Clashes])\n\nAT_DATA([input.y],\n[[%union { int bar; }\n%token foo\n%type <bar> exp\n%%\nexp: foo { $$; } foo { $2; } foo\n   | foo\n   | %empty\n   ;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:5.12-13: error: $$ for the midrule at $2 of 'exp' has no declared type\n    5 | exp: foo { $$; } foo { $2; } foo\n      |            ^~\ninput.y:5.24-25: error: $2 of 'exp' has no declared type\n    5 | exp: foo { $$; } foo { $2; } foo\n      |                        ^~\ninput.y:5.6-32: warning: type clash on default action: <bar> != <> [-Wother]\n    5 | exp: foo { $$; } foo { $2; } foo\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:6.6-8: warning: type clash on default action: <bar> != <> [-Wother]\n    6 |    | foo\n      |      ^~~\ninput.y:7.6-11: warning: empty rule for typed nonterminal, and no action [-Wother]\n    7 |    | %empty\n      |      ^~~~~~\n]])\n\nAT_CLEANUP\n\n\n# _AT_UNUSED_VALUES_DECLARATIONS()\n# --------------------------------\n# Generate the token, type, and destructor\n# declarations for the unused values tests.\nm4_define([_AT_UNUSED_VALUES_DECLARATIONS],\n[[[%token <integer> INT;\n%type <integer> a b c d e f g h i j k l m n o;\n%destructor { destroy ($$); } <integer>;]]])\n\n\n# AT_CHECK_UNUSED_VALUES(DECLARATIONS_AFTER, CHECK_MIDRULE_VALUES)\n# ----------------------------------------------------------------\n# Generate a grammar to test unused values, and compile it.  If\n# DECLARATIONS_AFTER is set, then the token, type, and destructor\n# declarations are generated after the rules rather than before.  If\n# CHECK_MIDRULE_VALUES is set, then --warnings=midrule-values is set.\nm4_define([AT_CHECK_UNUSED_VALUES],\n[AT_DATA([input.y],\nm4_ifval([$1], [\n\n\n], [_AT_UNUSED_VALUES_DECLARATIONS\n])[[%%\nstart:\n  'a' a { $][2; } | 'b' b { $][2; } | 'c' c { $][2; } | 'd' d { $][2; }\n| 'e' e { $][2; } | 'f' f { $][2; } | 'g' g { $][2; } | 'h' h { $][2; }\n| 'i' i { $][2; } | 'j' j { $][2; } | 'k' k { $][2; } | 'l' l { $][2; }\n| 'm' m { $][2; } | 'n' n { $][2; } | 'o' o { $][2; }\n;\n\na: INT | INT { } INT { } INT { };\nb: INT | %empty;\nc: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\nd: INT | INT { } INT { $][1; } INT { $<integer>2; };\ne: INT | INT { } INT {  } INT { $][1; };\nf: INT | INT { } INT {  } INT { $][$ = $][1 + $][3 + $][5; };\ng: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\nh: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\ni: INT | INT INT { } { $][$ = $][1 + $][2; };\nj: INT | INT INT { $<integer>$ = 1; } { $][$ = $][1 + $][2; };\nk: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\nl: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };\nm: INT | INT <integer>{ $][$ = $][1; } INT <integer>{ $][$ = $][2 + $][3; } INT { $][$ = $][4 + $][5; };\nn: INT | INT <integer>{ } INT <integer>{ } INT { };\no: INT | INT <integer>{ } INT <integer>{ } INT { $][$ = $][1 + $][2 + $][3 + $][4 + $][5; };\n]]m4_ifval([$1], [\n_AT_UNUSED_VALUES_DECLARATIONS])\n)\n\nAT_BISON_CHECK(m4_ifval([$2], [--warnings=midrule-values ])[-fcaret input.y],\n               [0], [],\n[[input.y:12.10-32: warning: unset value: $][$ [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~\ninput.y:12.10-12: warning: unused value: $][1 [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |          ^~~\ninput.y:12.18-20: warning: unused value: $][3 [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |                  ^~~\ninput.y:12.26-28: warning: unused value: $][5 [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |                          ^~~\ninput.y:13.10-15: warning: empty rule for typed nonterminal, and no action [-Wother]\n   13 | b: INT | %empty;\n      |          ^~~~~~\n]]m4_ifval([$2], [[[input.y:14.14-20: warning: unset value: $][$ [-Wmidrule-values]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |              ^~~~~~~\ninput.y:14.26-41: warning: unset value: $][$ [-Wmidrule-values]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |                          ^~~~~~~~~~~~~~~~\n]]])[[input.y:14.10-62: warning: unset value: $][$ [-Wother]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:14.22-24: warning: unused value: $][3 [-Wother]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |                      ^~~\ninput.y:14.43-45: warning: unused value: $][5 [-Wother]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |                                           ^~~\n]]m4_ifval([$2], [[[input.y:15.14-16: warning: unset value: $][$ [-Wmidrule-values]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |              ^~~\n]]])[[input.y:15.10-49: warning: unset value: $][$ [-Wother]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:15.18-20: warning: unused value: $][3 [-Wother]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |                  ^~~\ninput.y:15.30-32: warning: unused value: $][5 [-Wother]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |                              ^~~\ninput.y:16.10-37: warning: unset value: $][$ [-Wother]\n   16 | e: INT | INT { } INT {  } INT { $][1; };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:16.18-20: warning: unused value: $][3 [-Wother]\n   16 | e: INT | INT { } INT {  } INT { $][1; };\n      |                  ^~~\ninput.y:16.27-29: warning: unused value: $][5 [-Wother]\n   16 | e: INT | INT { } INT {  } INT { $][1; };\n      |                           ^~~\ninput.y:18.10-58: warning: unset value: $][$ [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:18.10-12: warning: unused value: $][1 [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |          ^~~\n]]m4_ifval([$2], [[[input.y:18.14-29: warning: unused value: $][2 [-Wmidrule-values]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |              ^~~~~~~~~~~~~~~~\n]]])[[input.y:18.31-33: warning: unused value: $][3 [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |                               ^~~\n]]m4_ifval([$2], [[[input.y:18.35-50: warning: unused value: $][4 [-Wmidrule-values]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |                                   ^~~~~~~~~~~~~~~~\n]]])[[input.y:18.52-54: warning: unused value: $][5 [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |                                                    ^~~\ninput.y:19.10-72: warning: unset value: $][$ [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:19.10-12: warning: unused value: $][1 [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |          ^~~\ninput.y:19.31-33: warning: unused value: $][3 [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |                               ^~~\n]]m4_ifval([$2], [[[input.y:19.35-64: warning: unused value: $][4 [-Wmidrule-values]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n]]])[[input.y:19.66-68: warning: unused value: $][5 [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |                                                                  ^~~\n]]m4_ifval([$2], [[[input.y:21.18-37: warning: unused value: $][3 [-Wmidrule-values]\n   21 | j: INT | INT INT { $<integer>$ = 1; } { $][$ = $][1 + $][2; };\n      |                  ^~~~~~~~~~~~~~~~~~~~\n]]])[[input.y:22.10-68: warning: unset value: $][$ [-Wother]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:22.10-12: warning: unused value: $][1 [-Wother]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |          ^~~\ninput.y:22.14-16: warning: unused value: $][2 [-Wother]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |              ^~~\n]]m4_ifval([$2], [[[input.y:22.35-64: warning: unused value: $][4 [-Wmidrule-values]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n]]])[[input.y:25.23-25: warning: unset value: $][$ [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                       ^~~\ninput.y:25.40-42: warning: unset value: $][$ [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                                        ^~~\ninput.y:25.10-50: warning: unset value: $][$ [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:25.10-12: warning: unused value: $][1 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |          ^~~\ninput.y:25.23-25: warning: unused value: $][2 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                       ^~~\ninput.y:25.27-29: warning: unused value: $][3 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                           ^~~\ninput.y:25.40-42: warning: unused value: $][4 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                                        ^~~\ninput.y:25.44-46: warning: unused value: $][5 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                                            ^~~\ninput.y:26.23-25: warning: unset value: $][$ [-Wother]\n   26 | o: INT | INT <integer>{ } INT <integer>{ } INT { $][$ = $][1 + $][2 + $][3 + $][4 + $][5; };\n      |                       ^~~\ninput.y:26.40-42: warning: unset value: $][$ [-Wother]\n   26 | o: INT | INT <integer>{ } INT <integer>{ } INT { $][$ = $][1 + $][2 + $][3 + $][4 + $][5; };\n      |                                        ^~~\n]])\n\n])\n\n## --------------- ##\n## Unused values.  ##\n## --------------- ##\n\nAT_SETUP([Unused values])\nAT_CHECK_UNUSED_VALUES\nAT_CHECK_UNUSED_VALUES(, [1])\nAT_CLEANUP\n\n\n## ------------------------------------------ ##\n## Unused values before symbol declarations.  ##\n## ------------------------------------------ ##\n\nAT_SETUP([Unused values before symbol declarations])\nAT_CHECK_UNUSED_VALUES([1])\nAT_CHECK_UNUSED_VALUES([1], [1])\nAT_CLEANUP\n\n\n## ------------------- ##\n## Symbol redeclared.  ##\n## ------------------- ##\n\nAT_SETUP([Symbol redeclared])\n\nAT_DATA([[input.y]],\n[[%token FOO FOO\n%token BAR 12 BAR 12\n%token EOF 0 EOF 0\n%%\nexp: FOO BAR\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [0], [],\n[[input.y:1.12-14: warning: symbol FOO redeclared [-Wother]\n    1 | %token FOO FOO\n      |            ^~~\ninput.y:1.8-10: note: previous declaration\n    1 | %token FOO FOO\n      |        ^~~\ninput.y:2.15-17: warning: symbol BAR redeclared [-Wother]\n    2 | %token BAR 12 BAR 12\n      |               ^~~\ninput.y:2.8-10: note: previous declaration\n    2 | %token BAR 12 BAR 12\n      |        ^~~\ninput.y:3.14-16: warning: symbol EOF redeclared [-Wother]\n    3 | %token EOF 0 EOF 0\n      |              ^~~\ninput.y:3.8-10: note: previous declaration\n    3 | %token EOF 0 EOF 0\n      |        ^~~\n]])\n\nAT_CLEANUP\n\n\n## --------------------------- ##\n## Symbol class redefinition.  ##\n## --------------------------- ##\n\nAT_SETUP([Symbol class redefinition])\n\nAT_DATA([[input.y]],\n[[%token FOO\n%nterm FOO BAR\n%token BAR\n%nterm error // The token error cannot be redefined as an nterm.\n%%\nFOO: BAR\nBAR:\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.8-10: error: symbol FOO redeclared as a nonterminal\n    2 | %nterm FOO BAR\n      |        ^~~\ninput.y:1.8-10: note: previous definition\n    1 | %token FOO\n      |        ^~~\ninput.y:3.8-10: error: symbol BAR redeclared as a token\n    3 | %token BAR\n      |        ^~~\ninput.y:2.12-14: note: previous definition\n    2 | %nterm FOO BAR\n      |            ^~~\ninput.y:4.8-12: error: symbol error redeclared as a nonterminal\n    4 | %nterm error // The token error cannot be redefined as an nterm.\n      |        ^~~~~\ninput.y:6.1-3: error: rule given for FOO, which is a token\n    6 | FOO: BAR\n      | ^~~\n]])\n\nAT_CLEANUP\n\n\n## --------------------------------------------- ##\n## Default %printer and %destructor redeclared.  ##\n## --------------------------------------------- ##\n\nAT_SETUP([Default %printer and %destructor redeclared])\n\n# AT_TEST([*])\n# ------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <$1> <$1>\n%printer { print ($$); } <$1> <$1>\n\n%destructor { destroy ($$); } <$1>\n%printer { print ($$); } <$1>\n\n%%\n\nstart: %empty;\n\n%destructor { destroy ($$); } <$1>;\n%printer { print ($$); } <$1>;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:1.13-29: error: %destructor redeclaration for <>\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:1.13-29: note: previous declaration\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:2.10-24: error: %printer redeclaration for <>\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:2.10-24: note: previous declaration\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:4.13-29: error: %destructor redeclaration for <>\n    4 | %destructor { destroy ($$); } <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:1.13-29: note: previous declaration\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:5.10-24: error: %printer redeclaration for <>\n    5 | %printer { print ($$); } <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:2.10-24: note: previous declaration\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:11.13-29: error: %destructor redeclaration for <>\n   11 | %destructor { destroy ($$); } <>;\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:1.13-29: note: previous declaration\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:12.10-24: error: %printer redeclaration for <>\n   12 | %printer { print ($$); } <>;\n      |          ^~~~~~~~~~~~~~~\ninput.y:2.10-24: note: previous declaration\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\n]])\n])\n\nAT_TEST([], [], [])\nAT_TEST([], [*], [*])\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ---------------------------------------------- ##\n## Per-type %printer and %destructor redeclared.  ##\n## ---------------------------------------------- ##\n\nAT_SETUP([Per-type %printer and %destructor redeclared])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <field1> <field2>\n%printer { print ($$); } <field1> <field2>\n\n%destructor { destroy ($$); } <field1> <field1>\n%printer { print ($$); } <field2> <field2>\n\n%%\n\nstart: %empty;\n\n%destructor { destroy ($$); } <field2> <field1>;\n%printer { print ($$); } <field2> <field1>;\n]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:4.13-29: error: %destructor redeclaration for <field1>\ninput.y:1.13-29: note: previous declaration\ninput.y:4.13-29: error: %destructor redeclaration for <field1>\ninput.y:1.13-29: note: previous declaration\ninput.y:5.10-24: error: %printer redeclaration for <field2>\ninput.y:2.10-24: note: previous declaration\ninput.y:5.10-24: error: %printer redeclaration for <field2>\ninput.y:2.10-24: note: previous declaration\ninput.y:11.13-29: error: %destructor redeclaration for <field2>\ninput.y:1.13-29: note: previous declaration\ninput.y:11.13-29: error: %destructor redeclaration for <field1>\ninput.y:1.13-29: note: previous declaration\ninput.y:12.10-24: error: %printer redeclaration for <field2>\ninput.y:2.10-24: note: previous declaration\ninput.y:12.10-24: error: %printer redeclaration for <field1>\ninput.y:2.10-24: note: previous declaration\n]])\n\nAT_CLEANUP\n\n\n## ------------------- ##\n## Undefined symbols.  ##\n## ------------------- ##\n\nAT_SETUP([Undefined symbols])\n\nAT_DATA([[input.y]],\n[[%printer {} foo baz\n%destructor {} bar\n%type <foo> qux\n%%\nexp: bar;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:1.13-15: warning: symbol 'foo' is used, but is not defined as a token and has no rules [-Wother]\n    1 | %printer {} foo baz\n      |             ^~~\ninput.y:1.17-19: warning: symbol 'baz' is used, but is not defined as a token and has no rules [-Wother]\n    1 | %printer {} foo baz\n      |                 ^~~\ninput.y:2.16-18: error: symbol 'bar' is used, but is not defined as a token and has no rules\n    2 | %destructor {} bar\n      |                ^~~\ninput.y:3.13-15: warning: symbol 'qux' is used, but is not defined as a token and has no rules [-Wother]\n    3 | %type <foo> qux\n      |             ^~~\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------------------------------- ##\n## Unassociated types used for a printer or destructor.  ##\n## ----------------------------------------------------- ##\n\nAT_SETUP([Unassociated types used for a printer or destructor])\n\nAT_DATA([[input.y]],\n[[%token <type1> tag1\n%type <type2> tag2\n\n%printer { } <type1> <type3>\n%destructor { } <type2> <type4>\n\n%%\n\nexp: tag1 { $1; }\n   | tag2 { $1; }\n\ntag2: \"a\" { $$; }\n]])\n\nAT_BISON_CHECK([input.y], [0], [],\n[[input.y:4.22-28: warning: type <type3> is used, but is not associated to any symbol [-Wother]\ninput.y:5.25-31: warning: type <type4> is used, but is not associated to any symbol [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## --------------------------------- ##\n## Useless printers or destructors.  ##\n## --------------------------------- ##\n\nAT_SETUP([Useless printers or destructors])\n\n# AT_TEST([INPUT], [STDERR])\n# --------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[$1\n])\nAT_BISON_CHECK([input.y], [0], [], [$2\n])])\n\nAT_TEST([[%token <type1> token1\n%token <type2> token2\n%token <type3> token3\n%token <type4> token4\n%token <type5> token51 token52\n%token <type6> token61 token62\n%token <type7> token7\n\n%printer {} token1\n%destructor {} token2\n%printer {} token51\n%destructor {} token61\n\n%printer {} token7\n\n%printer {} <type1>\n%destructor {} <type2>\n%printer {} <type3>\n%destructor {} <type4>\n\n%printer {} <type5>\n%destructor {} <type6>\n\n%destructor {} <type7>\n\n%%\nexp: \"a\";]],\n[[input.y:16.13-19: warning: useless %printer for type <type1> [-Wother]\ninput.y:17.16-22: warning: useless %destructor for type <type2> [-Wother]]])\n\n# If everybody is typed, <> is useless.\nAT_TEST([[%type <type> exp\n%token <type> a\n%printer {} <> <*>\n%%\nexp: a;]],\n[[input.y:3.13-14: warning: useless %printer for type <> [-Wother]]])\n\n# If nobody is typed, <*> is useless.\nAT_TEST([[%token a\n%printer {} <> <*>\n%%\nexp: a;]],\n[[input.y:2.16-18: warning: useless %printer for type <*> [-Wother]]])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ---------------------------------------- ##\n## Unused values with default %destructor.  ##\n## ---------------------------------------- ##\n\nAT_SETUP([Unused values with default %destructor])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <>\n%type <tag> tagged\n\n%%\n\nstart: end end tagged tagged { $<tag>1; $3; } ;\nend: { } ;\ntagged: { } ;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [0], [],\n[[input.y:6.8-45: warning: unset value: $$ [-Wother]\n    6 | start: end end tagged tagged { $<tag>1; $3; } ;\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:6.12-14: warning: unused value: $2 [-Wother]\n    6 | start: end end tagged tagged { $<tag>1; $3; } ;\n      |            ^~~\ninput.y:7.6-8: warning: unset value: $$ [-Wother]\n    7 | end: { } ;\n      |      ^~~\n]])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <*>\n%type <tag> tagged\n\n%%\n\nstart: end end tagged tagged { $<tag>1; $3; } ;\nend: { } ;\ntagged: { } ;\n]])\n\nAT_BISON_CHECK([input.y], [0], [],\n[[input.y:6.23-28: warning: unused value: $4 [-Wother]\ninput.y:8.9-11: warning: unset value: $$ [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------------------- ##\n## Unused values with per-type %destructor.  ##\n## ----------------------------------------- ##\n\nAT_SETUP([Unused values with per-type %destructor])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <field1>\n%type <field1> start end\n\n%%\n\nstart: end end { $1; } ;\nend: { }  ;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [0], [],\n[[input.y:6.8-22: warning: unset value: $$ [-Wother]\n    6 | start: end end { $1; } ;\n      |        ^~~~~~~~~~~~~~~\ninput.y:6.12-14: warning: unused value: $2 [-Wother]\n    6 | start: end end { $1; } ;\n      |            ^~~\ninput.y:7.6-8: warning: unset value: $$ [-Wother]\n    7 | end: { }  ;\n      |      ^~~\n]])\n\nAT_CLEANUP\n\n\n## ------------------ ##\n## Duplicate string.  ##\n## ------------------ ##\n\n\nAT_SETUP([Duplicate string])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA([input.y],\n[[/* 'Bison -v' used to dump core when two tokens are defined with the same\n   string, as LE and GE below. */\n\n%token NUM\n%token LE \"<=\"\n%token GE \"<=\"\n\n%%\nexp: '(' exp ')' | NUM ;\n%%\n]])\nAT_BISON_OPTION_POPDEFS\n\nAT_BISON_CHECK([-v -o input.c input.y], 0, [],\n[[input.y:6.11-14: warning: symbol \"<=\" used more than once as a literal string [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## ------------------ ##\n## Token collisions.  ##\n## ------------------ ##\n\nAT_SETUP([Token collisions])\n\nAT_DATA([[input.y]],\n[[%token FOO 42 \"foo\"\n         BAR 42 \"foo\"\n%%\nexp: FOO BAR;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.17-21: warning: symbol \"foo\" used more than once as a literal string [-Wother]\n    2 |          BAR 42 \"foo\"\n      |                 ^~~~~\ninput.y:2.10-12: error: code 42 reassigned to token BAR\n    2 |          BAR 42 \"foo\"\n      |          ^~~\ninput.y:1.15-19: note: previous declaration for \"foo\"\n    1 | %token FOO 42 \"foo\"\n      |               ^~~~~\n]])\n\nAT_CLEANUP\n\n\n## ---------------------- ##\n## Incompatible Aliases.  ##\n## ---------------------- ##\n\nAT_SETUP([Incompatible Aliases])\n\nm4_pushdef([AT_TEST],\n[AT_DATA([input.y], [$1])\nAT_BISON_CHECK([-fcaret input.y], [1], [], [$2])\n])\n\n# Use the string-alias first to check the order between \"first\n# declaration\" and second.\n\nAT_TEST([[%token foo \"foo\"\n%type <bar> \"foo\"\n%type <baz> foo\n%%\nexp: foo;\n]],\n[[input.y:3.7-11: error: %type redeclaration for foo\n    3 | %type <baz> foo\n      |       ^~~~~\ninput.y:2.7-11: note: previous declaration\n    2 | %type <bar> \"foo\"\n      |       ^~~~~\n]])\n\nAT_TEST([[%token foo \"foo\"\n%printer {bar} \"foo\"\n%printer {baz} foo\n%%\nexp: foo;\n]],\n[[input.y:3.10-14: error: %printer redeclaration for foo\n    3 | %printer {baz} foo\n      |          ^~~~~\ninput.y:2.10-14: note: previous declaration\n    2 | %printer {bar} \"foo\"\n      |          ^~~~~\n]])\n\nAT_TEST([[%token foo \"foo\"\n%destructor {bar} \"foo\"\n%destructor {baz} foo\n%%\nexp: foo;\n]],\n[[input.y:3.13-17: error: %destructor redeclaration for foo\n    3 | %destructor {baz} foo\n      |             ^~~~~\ninput.y:2.13-17: note: previous declaration\n    2 | %destructor {bar} \"foo\"\n      |             ^~~~~\n]])\n\nAT_TEST([[%token foo \"foo\"\n%left \"foo\"\n%left foo\n%%\nexp: foo;\n]],\n[[input.y:3.1-5: error: %left redeclaration for foo\n    3 | %left foo\n      | ^~~~~\ninput.y:2.1-5: note: previous declaration\n    2 | %left \"foo\"\n      | ^~~~~\n]])\n\n# This time, declare the alias after its use.\n\n# Precedence/associativity.\nAT_TEST([[%left \"foo\"\n%left foo\n%token foo \"foo\"\n%%\nexp: foo;\n]],\n[[input.y:2.1-5: error: %left redeclaration for foo\n    2 | %left foo\n      | ^~~~~\ninput.y:1.1-5: note: previous declaration\n    1 | %left \"foo\"\n      | ^~~~~\n]])\n\n# Printer.\nAT_TEST([[%printer {} \"foo\"\n%printer {} foo\n%token foo \"foo\"\n%%\nexp: foo;\n]],\n[[input.y:2.10-11: error: %printer redeclaration for foo\n    2 | %printer {} foo\n      |          ^~\ninput.y:1.10-11: note: previous declaration\n    1 | %printer {} \"foo\"\n      |          ^~\n]])\n\n# Destructor.\nAT_TEST([[%destructor {} \"foo\"\n%destructor {} foo\n%token foo \"foo\"\n%%\nexp: foo;\n]],\n[[input.y:2.13-14: error: %destructor redeclaration for foo\n    2 | %destructor {} foo\n      |             ^~\ninput.y:1.13-14: note: previous declaration\n    1 | %destructor {} \"foo\"\n      |             ^~\n]])\n\nm4_popdef([AT_TEST])\nAT_CLEANUP\n\n\n\n## ----------------------- ##\n## Torturing the Scanner.  ##\n## ----------------------- ##\n\n# Be sure to compile and run, so that the C compiler checks what\n# we do.\n\nAT_SETUP([Torturing the Scanner])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA([input.y], [])\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:1.1: error: unexpected end of file\n]])\n\n\nAT_DATA([input.y],\n[{}\n])\nAT_BISON_CHECK([-fcaret  input.y], [1], [],\n[[input.y:1.1-2: error: unexpected {...}\n    1 | {}\n      | ^~\n]])\n\n\n# Clang chokes on some of our comments, because it tries to \"parse\"\n# some documentation directives in the comments:\n#\n# input.c:166:50: error: '\\a' command does not have a valid word argument [-Werror,-Wdocumentation]\n#     FAKE = 258                     /* \"fake [] \\a\\b\\f\\n\\r\\t\\v\\\"'?\\\\[\\\\ ??!??'??(??)??-??/??<??=??> \\001\\001\"  */\n#                                                ~~^\nAT_DATA_GRAMMAR([input.y],\n[[%code requires {\n#if defined __clang__ && 10 <= __clang_major__\n# pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n}\n\n%{\n/* This is seen in GCC: a %{ and %} in middle of a comment. */\nconst char *foo = \"So %{ and %} can be here too.\";\n\n#if 0\n/* These examples test Bison while not stressing C compilers too much.\n   Many C compilers mishandle backslash-newlines, so this part of the\n   test is inside \"#if 0\".  The comment and string are written so that\n   the \"#endif\" will be seen regardless of the C compiler bugs that we\n   know about, namely:\n\n     HP C (as of late 2002) mishandles *\\[newline]\\[newline]/ within a\n     comment.\n\n     The Apple Darwin compiler (as of late 2002) mishandles\n     \\\\[newline]' within a character constant.\n\n   */\n\n/\\\n* A comment with backslash-newlines in it. %} *\\\n\\\n/\n/* { Close the above comment, if the C compiler mishandled it.  */\n\nchar str[] = \"\\\\\n\" A string with backslash-newlines in it %{ %} \\\\\n\\\n\"\";\n\nchar apostrophe = '\\'';\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n%}\n/* %{ and %} can be here too. */\n\n%{\n/* Exercise pre-prologue dependency to %union.  */\ntypedef int value;\n%}\n\n/* Exercise M4 quoting: '@:>@@:>@', 0.  */\n\n/* Also exercise %union. */\n%union\n{\n  value ival; /* A comment to exercise an old bug. */\n};\n\n\n/* Exercise post-prologue dependency to %union.  */\n%{\nstatic YYSTYPE value_as_yystype (value val);\n\n/* Exercise quotes in declarations.  */\nchar quote[] = \"@:>@@:>@,\";\n%}\n\n%{\n]AT_YYERROR_DECLARE[\n]AT_YYLEX_DECLARE[\n%}\n\n%type <ival> '@<:@'\n\n/* Exercise quotes in strings.  */\n%token FAKE \"fake @<:@@:>@ \\a\\b\\f\\n\\r\\t\\v\\\"\\'\\?\\\\\\u005B\\U0000005c ??!??'??(??)??-??/??<??=??> \\x1\\1\"\n\n/* Beware of the generated comments that embed string aliases that\n   might close the comment.  */\n%token COMMENT_CLOSE \"*/\"\n%token COMMENT       \"/* comment */\"\n\n%%\n/* Exercise M4 quoting: '@:>@@:>@', @<:@, 1.  */\nexp: '@<:@' '\\1' two '$' '@' '{' oline output.or.oline.opt\n  {\n    /* Exercise quotes in braces.  */\n    char tmp[] = \"@<:@%c@:>@,\\n\";\n    printf (tmp, $1);\n  }\n;\n\ntwo: '\\x000000000000000000000000000000000000000000000000000000000000000000002';\noline: '@' 'o' 'l' 'i' 'n' 'e' '@' '_' '_' 'o' 'l' 'i' 'n' 'e' '_' '_';\noutput.or.oline.opt: %empty;|oline;;|output;;;\noutput: '#' 'o' 'u' 't' 'p' 'u' 't' ' ';\n%%\n/* Exercise M4 quoting: '@:>@@:>@', @<:@, 2.  */\n\nstatic YYSTYPE\nvalue_as_yystype (value val)\n{\n  YYSTYPE res;\n  res.ival = val;\n  return res;\n}\n]AT_YYERROR_DEFINE[\nstatic int\nyylex (void)\n{\n  static char const input[] = \"@<:@\\1\\2$@{@oline@__@&t@oline__\\\n#output \"; /* \"\n  */\n  enum { input_elts = sizeof input };\n  (void) input_elts;\n  static int toknum;\n  assert (0 <= toknum && toknum < input_elts);\n  yylval = value_as_yystype (input[toknum]);\n  return input[toknum++];\n}\n]])\n\n# Pacify Emacs'font-lock-mode: \"\n\nAT_DATA([main.c],\n[[typedef int value;\n#include \"input.h\"\n\nint yyparse (void);\n]AT_MAIN_DEFINE[\n]])\nAT_BISON_OPTION_POPDEFS\n\nAT_BISON_CHECK([-d -v -o input.c input.y])\nAT_COMPILE([input.o])\nAT_COMPILE([main.o])\nAT_COMPILE([input], [input.o main.o])\nAT_PARSER_CHECK([input], 0,\n[[[@<:@],\n]])\n\nAT_CLEANUP\n\n\n## ---------------------- ##\n## Typed symbol aliases.  ##\n## ---------------------- ##\n\nAT_SETUP([Typed symbol aliases])\n\n# Bison 2.0 broke typed symbol aliases - ensure they work.\nAT_BISON_OPTION_PUSHDEFS\n\nAT_DATA_GRAMMAR([input.y],\n[[%union\n{\n  int val;\n};\n%token <val> MY_TOKEN \"MY TOKEN\"\n%type <val> exp\n%%\nexp: \"MY TOKEN\";\n%%\n]])\n\nAT_BISON_CHECK([-o input.c input.y])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## --------- ##\n## Require.  ##\n## --------- ##\n\nm4_define([AT_CHECK_REQUIRE],\n[AT_SETUP([Require $1])\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([input.y],\n[[%require \"$1\";\n%%\nempty_file: %empty;\n]])\nAT_BISON_CHECK([-o input.c input.y], $2, [], ignore)\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n])\n\nAT_CHECK_REQUIRE(1.0, 0)\nAT_CHECK_REQUIRE(AT_PACKAGE_VERSION, 0)\n## FIXME: Some day augment this version number.\nAT_CHECK_REQUIRE(100.0, 63)\n\n\n## ------------------------------------- ##\n## String aliases for character tokens.  ##\n## ------------------------------------- ##\n\nAT_SETUP([String aliases for character tokens])\n\n# Bison once thought a character token and its alias were different\n# symbols with the same code.\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([input.y],\n[[%token 'a' \"a\"\n%%\nstart: 'a';\n%%\n]])\n\nAT_BISON_CHECK([-o input.c input.y])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## -------------- ##\n## Symbol names.  ##\n## -------------- ##\n\nAT_SETUP([Symbols])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([input.y],\n[[%token WITH-DASH\n%token WITHOUT_DASH \"WITHOUT-DASH\"\n%token WITH.PERIOD\n%token WITHOUT_PERIOD \"WITHOUT.PERIOD\"\n%code {\n  ]AT_YYERROR_DECLARE[\n  ]AT_YYLEX_DECLARE[\n}\n%%\nstart: with-dash without_dash with.period without_period;\nwith-dash: WITH-DASH;\nwithout_dash: \"WITHOUT-DASH\";\nwith.period: WITH.PERIOD;\nwithout_period: \"WITHOUT.PERIOD\";\n%%\n]AT_YYERROR_DEFINE[\n]AT_YYLEX_DEFINE[\n]])\n\n# POSIX Yacc accept periods, but not dashes.\nAT_BISON_CHECK([--yacc input.y], [], [],\n[[input.y:1.1-5: warning: POSIX Yacc does not support %code [-Wyacc]\ninput.y:9.8-16: warning: POSIX Yacc forbids dashes in symbol names: WITH-DASH [-Wyacc]\ninput.y:10.21-34: warning: POSIX Yacc does not support string literals [-Wyacc]\ninput.y:12.23-38: warning: POSIX Yacc does not support string literals [-Wyacc]\ninput.y:13.1-5: warning: POSIX Yacc does not support %code [-Wyacc]\ninput.y:20.8-16: warning: POSIX Yacc forbids dashes in symbol names: with-dash [-Wyacc]\ninput.y:22.15-28: warning: POSIX Yacc does not support string literals [-Wyacc]\ninput.y:24.17-32: warning: POSIX Yacc does not support string literals [-Wyacc]\n]])\n\n# Dashes are fine for GNU Bison.\nAT_BISON_CHECK([-o input.c input.y])\n\n# Make sure we don't export silly token identifiers with periods or dashes.\nAT_COMPILE([input.o])\n\n\n# Periods are genuine letters, they can start identifiers.\n# Digits and dashes cannot.\nAT_DATA_GRAMMAR([input.y],\n[[%token .GOOD\n         -GOOD\n         1NV4L1D\n         -123\n%%\nstart: .GOOD GOOD\n]])\nAT_BISON_CHECK([-o input.c input.y], [1], [],\n[[input.y:10.10: error: invalid character: '-'\ninput.y:11.10-16: error: invalid identifier: '1NV4L1D'\ninput.y:12.10: error: invalid character: '-'\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ----------------- ##\n## Numbered tokens.  ##\n## ----------------- ##\n\nAT_SETUP([Numbered tokens])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([redecl.y],\n[[%token DECIMAL_1     11259375\n         HEXADECIMAL_1 0xabcdef\n         HEXADECIMAL_2 0xFEDCBA\n         DECIMAL_2     16702650\n%%\nstart: DECIMAL_1 HEXADECIMAL_2;\n]])\n\nAT_BISON_CHECK([redecl.y], [1], [],\n[[redecl.y:10.10-22: error: code 11259375 reassigned to token HEXADECIMAL_1\nredecl.y:9.8-16: note: previous declaration for DECIMAL_1\nredecl.y:12.10-18: error: code 16702650 reassigned to token DECIMAL_2\nredecl.y:11.10-22: note: previous declaration for HEXADECIMAL_2\n]])\n\nAT_DATA_GRAMMAR([too-large.y],\n[[%token TOO_LARGE_DEC 999999999999999999999\n         TOO_LARGE_HEX 0xFFFFFFFFFFFFFFFFFFF\n%%\nstart: TOO_LARGE_DEC TOO_LARGE_HEX\n%%\n]])\n\nAT_BISON_CHECK([too-large.y], [1], [],\n[[too-large.y:9.22-42: error: integer out of range: '999999999999999999999'\ntoo-large.y:9.22-42: error: code of token TOO_LARGE_DEC too large\ntoo-large.y:10.24-44: error: integer out of range: '0xFFFFFFFFFFFFFFFFFFF'\ntoo-large.y:10.24-44: error: code of token TOO_LARGE_HEX too large\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## --------------------- ##\n## Unclosed constructs.  ##\n## --------------------- ##\n\nAT_SETUP([Unclosed constructs])\n\n# Bison's scan-gram.l once forgot to STRING_FINISH () some unclosed\n# constructs, so they were prepended to whatever it STRING_GROW ()'ed\n# next.  It also threw them away rather than returning them to the\n# parser.  The effect was confusing subsequent error messages.\n\nAT_DATA([input.y],\n[[%token A \"a\n%token B \"b\"\n%token AB \"ab\" // Used to complain that \"ab\" was already used.\n%token C '1\n%token TWO \"2\"\n%token TICK_TWELVE \"'12\" // Used to complain that \"'12\" was already used.\n\n%%\n\nstart: %empty;\n\n// Used to report a syntax error because it didn't see any kind of symbol\n// identifier.\n%type <f> 'a\n;\n%type <f> \"a\n;\n// Used to report a syntax error because it didn't see braced code.\n%destructor { free ($$)\n]])\n\nAT_BISON_CHECK([-fcaret -o input.c input.y], 1, [],\n[[input.y:1.10-2.0: error: missing '\"' at end of line\n    1 | %token A \"a\n      |          ^~\ninput.y:4.10-5.0: error: missing \"'\" at end of line\n    4 | %token C '1\n      |          ^~\ninput.y:14.11-15.0: error: missing \"'\" at end of line\n   14 | %type <f> 'a\n      |           ^~\ninput.y:16.11-17.0: error: missing '\"' at end of line\n   16 | %type <f> \"a\n      |           ^~\ninput.y:19.13-20.0: error: missing '}' at end of file\n   19 | %destructor { free ($$)\n      |             ^~~~~~~~~~~\ninput.y:20.1: error: unexpected end of file\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## %start after first rule.  ##\n## ------------------------- ##\n\nAT_SETUP([%start after first rule])\n\n# Bison once complained that a %start after the first rule was a\n# redeclaration of the start symbol.\n\nAT_DATA([input.y],\n[[%%\nfalse_start: %empty;\nstart: false_start ;\n%start start;\n]])\n\nAT_BISON_CHECK([-o input.c input.y])\n\nAT_CLEANUP\n\n\n## --------------------- ##\n## %prec takes a token.  ##\n## --------------------- ##\n\nAT_SETUP([%prec takes a token])\n\n# Bison once allowed %prec sym where sym was a nonterminal.\n\nAT_DATA([input.y],\n[[%%\nstart: PREC %prec PREC ;\nPREC: %empty;\n]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:3.1-4: error: rule given for PREC, which is a token\n]])\n\nAT_CLEANUP\n\n\n## ------------------------------- ##\n## %prec's token must be defined.  ##\n## ------------------------------- ##\n\nAT_SETUP([[%prec's token must be defined]])\n\n# According to POSIX, a %prec token must be defined separately.\n\nAT_DATA([[input.y]],\n[[%%\nstart: %prec PREC ;\n]])\n\nAT_BISON_CHECK([[input.y]], [[0]], [],\n[[input.y:2.8-17: warning: token for %prec is not defined: PREC [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## -------------------------------- ##\n## Reject unused %code qualifiers.  ##\n## -------------------------------- ##\n\nAT_SETUP([Reject unused %code qualifiers])\n\nAT_DATA([input-c.y],\n[[%code q {}\n%code bad {}\n%code bad {}\n%code format {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c.y]], [[1]], [],\n[[input-c.y:1.7: error: %code qualifier 'q' is not used\ninput-c.y:2.7-9: error: %code qualifier 'bad' is not used\ninput-c.y:3.7-9: error: %code qualifier 'bad' is not used\ninput-c.y:4.7-12: error: %code qualifier 'format' is not used\n]])\n\nAT_DATA([input-c-glr.y],\n[[%code q {}\n%code bad {}\n %code bad {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c-glr.y]], [[1]], [],\n[[input-c-glr.y:1.7: error: %code qualifier 'q' is not used\ninput-c-glr.y:2.7-9: error: %code qualifier 'bad' is not used\ninput-c-glr.y:3.8-10: error: %code qualifier 'bad' is not used\n]])\n\nAT_DATA([input-c++.y],\n[[%code q {}\n%code bad {}\n %code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c++.y]], [[1]], [],\n[[input-c++.y:1.7: error: %code qualifier 'q' is not used\ninput-c++.y:2.7-9: error: %code qualifier 'bad' is not used\ninput-c++.y:3.8: error: %code qualifier 'q' is not used\n]])\n\nAT_DATA([input-c++-glr.y],\n[[%code bad {}\n%code q {}\n%code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c++-glr.y]], [[1]], [],\n[[input-c++-glr.y:1.7-9: error: %code qualifier 'bad' is not used\ninput-c++-glr.y:2.7: error: %code qualifier 'q' is not used\ninput-c++-glr.y:3.7: error: %code qualifier 'q' is not used\n]])\n\nAT_DATA([special-char-@@.y],\n[[%code bad {}\n%code q {}\n%code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[special-char-@@.y]], [[1]], [],\n[[special-char-@@.y:1.7-9: error: %code qualifier 'bad' is not used\nspecial-char-@@.y:2.7: error: %code qualifier 'q' is not used\nspecial-char-@@.y:3.7: error: %code qualifier 'q' is not used\n]])\n\nAT_DATA([special-char-@:>@.y],\n[[%code bad {}\n%code q {}\n%code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[special-char-@:>@.y]], [[1]], [],\n[[special-char-@:>@.y:1.7-9: error: %code qualifier 'bad' is not used\nspecial-char-@:>@.y:2.7: error: %code qualifier 'q' is not used\nspecial-char-@:>@.y:3.7: error: %code qualifier 'q' is not used\n]])\n\nAT_CLEANUP\n\n\n## ---------------- ##\n## Multiple %code.  ##\n## ---------------- ##\n\nAT_SETUP([Multiple %code])\n\n# Make sure that repeated arguments to %code are separated by\n# end-of-lines.  At some point, a missing eol would leave synclines\n# appended to the previous value.  Here, we use CPP directive to\n# introduce dependency on the absence/presence of the eol.\nAT_BISON_OPTION_PUSHDEFS\n\nAT_DATA([input.y],\n[[%code {#include <assert.h>}\n%code {#define A B}\n%code {#define B C}\n%code {#define C D}\n%code {#define D 42}\n%code {\n  ]AT_YYERROR_DECLARE[\n  ]AT_YYLEX_DECLARE[\n}\n%%\nstart: %empty;\n%%\n]AT_YYERROR_DEFINE[\n]AT_YYLEX_DEFINE[\nint main (void)\n{\n  assert (A == 42);\n  return 0;\n}\n]])\nAT_FULL_COMPILE([input])\nAT_PARSER_CHECK([input])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ---------------- ##\n## %define errors.  ##\n## ---------------- ##\n\nAT_SETUP([%define errors])\n\nAT_DATA([input-redefined.y],\n[[%define var \"value1\"\n%define var \"value1\"\n %define var \"value2\"\n%define special1 \"@:>@\"\n%define special2 \"@<:@\"\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input-redefined.y]], [[1]], [],\n[[input-redefined.y:2.1-20: warning: %define variable 'var' redefined [-Wother]\ninput-redefined.y:1.1-20: note: previous definition\ninput-redefined.y:3.2-21: error: %define variable 'var' redefined\ninput-redefined.y:2.1-20: note: previous definition\ninput-redefined.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_DATA([input-unused.y],\n[[%define var \"value\"\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input-unused.y]], [[1]], [],\n[[input-unused.y:1.1-19: error: %define variable 'var' is not used\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------------- ##\n## %define, --define, --force-define.  ##\n## ----------------------------------- ##\n\nAT_SETUP([[%define, --define, --force-define]])\n\nAT_DATA([[skel.c]],\n[[m4@&t@_divert_push(0)@\n@output(b4_parser_file_name@)@\n[var-dd: ]b4_percent_define_get([[var-dd]])[\nvar-ff: ]b4_percent_define_get([[var-ff]])[\nvar-dfg: ]b4_percent_define_get([[var-dfg]])[\nvar-fd: ]b4_percent_define_get([[var-fd]])\nm4@&t@_divert_pop(0)\n]])\nAT_DATA([[input.y]],\n[[%define var-dfg \"gram\"\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \\\n                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \\\n                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \\\n                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \\\n                 --skeleton ./skel.c input.y]])\nAT_CHECK([[cat input.tab.c]], [[0]],\n[[var-dd: cmd-d2\nvar-ff: cmd-f2\nvar-dfg: cmd-f\nvar-fd: cmd-d\n]])\n\nAT_DATA([[input-dg.y]],\n[[%define var \"gram\"\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-Dvar=cmd-d input-dg.y]], [[1]], [],\n[[input-dg.y:1.1-18: error: %define variable 'var' redefined\n<command line>:3: note: previous definition\ninput-dg.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_DATA([[input-dg.y]],\n[[%define var \"gram\"\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret -Dvar=cmd-d input-dg.y]], [[1]], [],\n[[input-dg.y:1.1-18: error: %define variable 'var' redefined\n    1 | %define var \"gram\"\n      | ^~~~~~~~~~~~~~~~~~\n<command line>:4: note: previous definition\ninput-dg.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_DATA([[input-unused.y]],\n[[%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-Dunused-d -Funused-f input-unused.y]], [[1]], [],\n[[<command line>:3: error: %define variable 'unused-d' is not used\n<command line>:4: error: %define variable 'unused-f' is not used\n]])\n\nAT_CLEANUP\n\n\n## --------------------------- ##\n## %define Boolean variables.  ##\n## --------------------------- ##\n\nAT_SETUP([[\"%define\" Boolean variables]])\n\nAT_DATA([Input.y],\n[[%language \"Java\"\n%define api.parser.class {Input}\n%define api.parser.public {maybe}\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[Input.y]], [1], [],\n[[Input.y:3.1-33: error: invalid value for %define Boolean variable 'api.parser.public'\n]])\n\nAT_CLEANUP\n\n\n## ------------------------ ##\n## %define code variables.  ##\n## ------------------------ ##\n\nAT_SETUP([[\"%define\" code variables]])\n\nm4_pushdef([AT_TEST],\n[AT_DATA([input.yy],\n[[%skeleton \"lalr1.cc\" %locations\n%define api.location.type ]$1[quux]$2[\n%define api.namespace     ]$1[quux]$2[\n%define api.prefix        ]$1[quux]$2[\n%define api.token.prefix  ]$1[quux]$2[\n%token TOK // Otherwise api.token.prefix is unused.\n%%\nstart: TOK;\n]])\n\nAT_BISON_CHECK([[input.yy]], [0], [],\n[[input.yy:2.$3: warning: %define variable 'api.location.type' requires '{...}' values [-Wdeprecated]\ninput.yy:4.$3: warning: %define variable 'api.prefix' requires '{...}' values [-Wdeprecated]\ninput.yy:5.$3: warning: %define variable 'api.token.prefix' requires '{...}' values [-Wdeprecated]\ninput.yy:3.$3: warning: %define variable 'api.namespace' requires '{...}' values [-Wdeprecated]\n]])\n])\n\nAT_TEST([],  [],  [1-30])\nAT_TEST([\"], [\"], [1-32])\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## --------------------------- ##\n## %define keyword variables.  ##\n## --------------------------- ##\n\nAT_SETUP([[\"%define\" keyword variables]])\n\nm4_pushdef([AT_TEST],\n[AT_DATA([input.y],\n[[%define api.pure                ]$1[true]$2[\n%define api.push-pull             ]$1[both]$2[\n%define lr.default-reduction      ]$1[most]$2[\n%define lr.keep-unreachable-state ]$1[true]$2[\n%define lr.type                   ]$1[lalr]$2[\n%%\nexp: %empty\n]])\n\nAT_BISON_CHECK([[input.y]], [0], [],\n[[input.y:5.1-40: warning: %define variable 'lr.type' requires keyword values [-Wdeprecated]\ninput.y:3.1-40: warning: %define variable 'lr.default-reduction' requires keyword values [-Wdeprecated]\ninput.y:4.1-40: warning: %define variable 'lr.keep-unreachable-state' requires keyword values [-Wdeprecated]\ninput.y:1.1-38: warning: %define variable 'api.pure' requires keyword values [-Wdeprecated]\ninput.y:2.1-40: warning: %define variable 'api.push-pull' requires keyword values [-Wdeprecated]\n]])\n])\n\nAT_TEST([\"], [\"])\nAT_TEST([{], [}])\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ------------------------ ##\n## %define enum variables.  ##\n## ------------------------ ##\n\nAT_SETUP([[\"%define\" enum variables]])\n\n# Check errors from the front-end, and the back-end.  Since the\n# front-end quits before calling the back-end, these tests cannot be\n# fused.\n\n# Front-end.\nAT_DATA([[input.y]],\n[[%define lr.default-reduction bogus\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:1.1-34: error: invalid value for %define variable 'lr.default-reduction': 'bogus'\n    1 | %define lr.default-reduction bogus\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-34: note: accepted value: 'most'\ninput.y:1.1-34: note: accepted value: 'consistent'\ninput.y:1.1-34: note: accepted value: 'accepting'\n]])\n\n# Check escapes.\nAT_DATA([[input.y]],\n[[%define lr.default-reduction {[$@]}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:1.1-35: warning: %define variable 'lr.default-reduction' requires keyword values [-Wdeprecated]\n    1 | %define lr.default-reduction {[$@]}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-35: error: invalid value for %define variable 'lr.default-reduction': '[$@]'\n    1 | %define lr.default-reduction {[$@]}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-35: note: accepted value: 'most'\ninput.y:1.1-35: note: accepted value: 'consistent'\ninput.y:1.1-35: note: accepted value: 'accepting'\n]])\n\n\n# Back-end.\nAT_DATA([[input.y]],\n[[%define api.push-pull neither\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:1.1-29: error: invalid value for %define variable 'api.push-pull': 'neither'\n    1 | %define api.push-pull neither\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-29: note: accepted value: 'pull'\ninput.y:1.1-29: note: accepted value: 'push'\ninput.y:1.1-29: note: accepted value: 'both'\n]])\n\nAT_CLEANUP\n\n\n\n## ------------------------ ##\n## %define file variables.  ##\n## ------------------------ ##\n\nAT_SETUP([[\"%define\" file variables]])\n\nAT_DATA([[input.y]],\n[[%skeleton \"lalr1.cc\"\n%locations\n%define api.location.file {bogus}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:3.1-33: error: %define variable 'api.location.file' requires 'none' or '\"...\"' values\n    3 | %define api.location.file {bogus}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n]])\n\nAT_CLEANUP\n\n\n## -------------------------------- ##\n## %define backward compatibility.  ##\n## -------------------------------- ##\n\nAT_SETUP([[\"%define\" backward compatibility]])\n\n# The error messages tell us whether the variables are properly updated.\nAT_DATA([[input.y]],\n[[%define api.push_pull both\n%define lr.keep_unreachable_states maybe\n%define namespace \"foo\"\n%define variant\n%define parser_class_name {parser}\n%define filename_type {filename}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [1], [],\n[[input.y:1.1-26: warning: deprecated directive: '%define api.push_pull both', use '%define api.push-pull both' [-Wdeprecated]\n    1 | %define api.push_pull both\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.push-pull both\ninput.y:2.1-40: warning: deprecated directive: '%define lr.keep_unreachable_states maybe', use '%define lr.keep-unreachable-state maybe' [-Wdeprecated]\n    2 | %define lr.keep_unreachable_states maybe\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define lr.keep-unreachable-state maybe\ninput.y:3.1-23: warning: deprecated directive: '%define namespace \"foo\"', use '%define api.namespace {foo}' [-Wdeprecated]\n    3 | %define namespace \"foo\"\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.namespace {foo}\ninput.y:4.1-15: warning: deprecated directive: '%define variant', use '%define api.value.type variant' [-Wdeprecated]\n    4 | %define variant\n      | ^~~~~~~~~~~~~~~\n      | %define api.value.type variant\ninput.y:5.1-34: warning: deprecated directive: '%define parser_class_name {parser}', use '%define api.parser.class {parser}' [-Wdeprecated]\n    5 | %define parser_class_name {parser}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.parser.class {parser}\ninput.y:6.1-32: warning: deprecated directive: '%define filename_type {filename}', use '%define api.filename.type {filename}' [-Wdeprecated]\n    6 | %define filename_type {filename}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.filename.type {filename}\ninput.y:2.1-40: error: invalid value for %define Boolean variable 'lr.keep-unreachable-state'\n    2 | %define lr.keep_unreachable_states maybe\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## Unused %define api.pure.  ##\n## ------------------------- ##\n\nAT_SETUP([[Unused %define api.pure]])\n\n# AT_TEST(DECLS, VALUE, LOCATION)\n# -------------------------------\n# Make sure Bison reports that '%define api.pure VALUE' is unused when DECLS\n# are specified.\nm4_pushdef([AT_TEST],\n[\nAT_DATA([[input.y]],\n[[%define api.pure ]$2[\n]$1[\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input.y]], [[1]], [],\n[[input.y:]$3[: error: %define variable 'api.pure' is not used\n]])\n])\n\nAT_TEST([[%language \"c++\"]],             [[]],      [[1.1-16]])\nAT_TEST([[%language \"c++\"]],             [[false]], [[1.1-22]])\nAT_TEST([[%language \"c++\" %glr-parser]], [[\"\"]],    [[1.1-19]])\nAT_TEST([[%language \"c++\" %glr-parser]], [[false]], [[1.1-22]])\nAT_TEST([[%language \"java\"]],            [[true]],  [[1.1-21]])\nAT_TEST([[%language \"java\"]],            [[false]], [[1.1-22]])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## -------------------------------- ##\n## C++ namespace reference errors.  ##\n## -------------------------------- ##\n\nAT_SETUP([[C++ namespace reference errors]])\n\n# AT_CHECK_NAMESPACE_ERROR(NAMESPACE-DECL, ERROR, [ERROR], ...)\n# -------------------------------------------------------------\n# Make sure Bison reports all ERROR's for %define namespace \"NAMESPACE-DECL\".\nm4_define([AT_CHECK_NAMESPACE_ERROR],\n[\nAT_DATA([[input.y]],\n[[%language \"C++\"\n%defines\n%define api.namespace {]$1[}\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input.y]], [1], [],\n[m4_foreach([b4_arg], m4_dquote(m4_shift($@)),\n[b4_arg\n])])\n])\n\nAT_CHECK_NAMESPACE_ERROR([[]],\n                         [[input.y:3.1-24: error: namespace reference is empty]])\nAT_CHECK_NAMESPACE_ERROR([[ @tb@@tb@  @tb@ @tb@]],\n                         [[input.y:3.1-57: error: namespace reference is empty]])\nAT_CHECK_NAMESPACE_ERROR([[foo::::bar]],\n                         [[input.y:3.1-34: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo:: @tb@::bar]],\n                         [[input.y:3.1-38: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[::::bar]],\n                         [[input.y:3.1-31: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[:: ::bar]],\n                         [[input.y:3.1-32: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo::bar::@tb@::]],\n                         [[input.y:3.1-43: error: namespace reference has consecutive \"::\"]],\n                         [[input.y:3.1-43: error: namespace reference has a trailing \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo::bar::]],\n                         [[input.y:3.1-34: error: namespace reference has a trailing \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo::bar:: @tb@]],\n                         [[input.y:3.1-41: error: namespace reference has a trailing \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[::]],\n                         [[input.y:3.1-26: error: namespace reference has a trailing \"::\"]])\n\nAT_CLEANUP\n\n\n## ------------------------ ##\n## Bad character literals.  ##\n## ------------------------ ##\n\n# Bison used to accept character literals that were empty or contained\n# too many characters.\n\nAT_SETUP([[Bad character literals]])\n\nAT_DATA_NO_FINAL_EOL([empty.y],\n[[%%\nstart: '';\nstart: '\nstart: ']])\n\nAT_BISON_CHECK([-fcaret empty.y], [1], [],\n[[empty.y:2.8-9: error: empty character literal\n    2 | start: '';\n      |        ^~\nempty.y:3.8-4.0: error: missing \"'\" at end of line\n    3 | start: '\n      |        ^\nempty.y:3.8-4.0: error: empty character literal\n    3 | start: '\n      |        ^\nempty.y:4.8: error: missing \"'\" at end of file\n    4 | start: '\n      |        ^\nempty.y:4.8: error: empty character literal\n    4 | start: '\n      |        ^\n]])\n\nAT_DATA_NO_FINAL_EOL([two.y],\n[[%%\nstart: 'ab';\nstart: 'ab\nstart: 'ab]])\n\nAT_BISON_CHECK([two.y], [1], [],\n[[two.y:2.8-11: error: extra characters in character literal\ntwo.y:3.8-4.0: error: missing \"'\" at end of line\ntwo.y:3.8-4.0: error: extra characters in character literal\ntwo.y:4.8-10: error: missing \"'\" at end of file\ntwo.y:4.8-10: error: extra characters in character literal\n]])\n\nAT_DATA_NO_FINAL_EOL([three.y],\n[[%%\nstart: 'abc';\nstart: 'abc\nstart: 'abc]])\n\nAT_BISON_CHECK([three.y], [1], [],\n[[three.y:2.8-12: error: extra characters in character literal\nthree.y:3.8-4.0: error: missing \"'\" at end of line\nthree.y:3.8-4.0: error: extra characters in character literal\nthree.y:4.8-11: error: missing \"'\" at end of file\nthree.y:4.8-11: error: extra characters in character literal\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## Bad escapes in literals.  ##\n## ------------------------- ##\n\nAT_SETUP([[Bad escapes in literals]])\n\nAT_DATA([input.y],\n[[%%\nstart: '\\777' '\\0' '\\xfff' '\\x0'\n       '\\uffff' '\\u0000' '\\Uffffffff' '\\U00000000'\n       '\\ ' '\\A';\n]])\n\n# It is not easy to create special characters, we cannot even trust tr.\n# Beside we cannot even expect \"echo '\\0'\" to output two characters\n# (well three with \\n): at least Bash 3.2 converts the two-character\n# sequence \"\\0\" into a single NUL character.\nAT_PERL_REQUIRE([[-e 'print \"start: \\\"\\\\\\t\\\\\\f\\\\\\0\\\\\\1\\\" ;\";' >> input.y]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:2.9-12: error: invalid number after \\-escape: 777\ninput.y:2.16-17: error: invalid number after \\-escape: 0\ninput.y:2.21-25: error: invalid number after \\-escape: xfff\ninput.y:2.29-31: error: invalid number after \\-escape: x0\ninput.y:3.9-14: error: invalid number after \\-escape: uffff\ninput.y:3.18-23: error: invalid number after \\-escape: u0000\ninput.y:3.27-36: error: invalid number after \\-escape: Uffffffff\ninput.y:3.40-49: error: invalid number after \\-escape: U00000000\ninput.y:4.9-10: error: invalid character after \\-escape: ' '\ninput.y:4.14-15: error: invalid character after \\-escape: A\ninput.y:5.9-16: error: invalid character after \\-escape: \\t\ninput.y:5.17: error: invalid character after \\-escape: \\f\ninput.y:5.18: error: invalid character after \\-escape: \\0\ninput.y:5.19: error: invalid character after \\-escape: \\001\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## LAC: Errors for %define.  ##\n## ------------------------- ##\n\nAT_SETUP([[LAC: Errors for %define]])\nAT_KEYWORDS([lac])\n\nAT_DATA([[input.y]],\n[[%%\nstart: %empty;\n]])\n\n# Only \"full\" and \"none\" are accepted for parse.lac\n# Unknown values (such as \"unsupported\") are rejected\nAT_BISON_CHECK([[-Dparse.lac=none input.y]])\nAT_BISON_CHECK([[-Dparse.lac=none -L c++ input.y]])\nAT_BISON_CHECK([[-Dparse.lac=full input.y]])\nAT_BISON_CHECK([[-Dparse.lac=full -L c++ input.y]])\nAT_BISON_CHECK([[-Dparse.lac=unsupported input.y]],\n               [[1]], [],\n[[<command line>:3: error: invalid value for %define variable 'parse.lac': 'unsupported'\n<command line>:3: note: accepted value: 'full'\n<command line>:3: note: accepted value: 'none'\n]])\nAT_BISON_CHECK([[-Dparse.lac=unsupported -L c++ input.y]],\n               [[1]], [],\n[[<command line>:3: error: invalid value for %define variable 'parse.lac': 'unsupported'\n<command line>:3: note: accepted value: 'full'\n<command line>:3: note: accepted value: 'none'\n]])\n\n# parse.lac.* options are useless if LAC isn't actually activated.\nAT_BISON_CHECK([[-Dparse.lac.es-capacity-initial=1 input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.es-capacity-initial' is not used\n]])\nAT_BISON_CHECK([[-Dparse.lac.memory-trace=full input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.memory-trace' is not used\n]])\n\n# parse.lac.* options are useless in C++ even if LAC isn't actually activated.\nAT_BISON_CHECK([[-Dparse.lac.es-capacity-initial=1 -L C++ -Dparse.lac=full input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.es-capacity-initial' is not used\n]])\nAT_BISON_CHECK([[-Dparse.lac.memory-trace=full -L C++ -Dparse.lac=full input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.memory-trace' is not used\n]])\n\nAT_CLEANUP\n\n\n## ---------------------- ##\n## -Werror combinations.  ##\n## ---------------------- ##\n\nAT_SETUP([[-Werror combinations]])\n\nAT_DATA([[input.y]],\n[[%%\na: '0' { $$ = $; };\n]])\n\n# -Werror is not enabled by -Wall or equivalent.\nAT_BISON_CHECK([[-Wall input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\nAT_BISON_CHECK([[-W input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\nAT_BISON_CHECK([[-Wno-none input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\n\n# -Werror is not disabled by -Wnone or equivalent.\nAT_BISON_CHECK([[-Werror,none,other input.y]], [[1]], [[]],\n[[input.y:2.15: error: stray '$' [-Werror=other]\n]])\nAT_BISON_CHECK([[-Werror,no-all,other input.y]], [[1]], [[]],\n[[input.y:2.15: error: stray '$' [-Werror=other]\n]])\n\n# Check that -Wno-error keeps warnings enabled, but non fatal.\nAT_BISON_CHECK([[-Werror -Wno-error=other input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\n\nAT_BISON_CHECK([[-Wno-error=other -Werror input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\n\nAT_BISON_CHECK([[-Werror=other -Wno-other input.y]], [[0]], [[]],\n[[]])\n\nAT_CLEANUP\n\n\n## ------------------------------------------------------ ##\n## %name-prefix and %define api.prefix are incompatible.  ##\n## ------------------------------------------------------ ##\n\nAT_SETUP([[%name-prefix and api.prefix are incompatible]])\n\n# AT_TEST(DIRECTIVES, OPTIONS, ERROR-LOCATION)\n# --------------------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[$1\n%%\nexp: %empty;\n]])\nAT_BISON_CHECK([[$2 -Wno-deprecated input.y]], [[1]], [[]],\n[[$3: error: '%name-prefix' and '%define api.prefix' cannot be used together\n]])\n])\n\nAT_TEST([%define api.prefix {foo} %name-prefix \"bar\"], [], [input.y:1.1-24])\nAT_TEST([], [-Dapi.prefix={foo} -p bar],                   [<command line>:3])\nAT_TEST([%name-prefix \"bar\"], [-Dapi.prefix={foo}],        [<command line>:3])\nAT_TEST([%define api.prefix {foo}], [-p bar],              [input.y:1.1-24])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ----------------------- ##\n## Redefined %union name.  ##\n## ----------------------- ##\n\nAT_SETUP([[Redefined %union name]])\n\n# AT_TEST(DIRECTIVES, EXIT-STATUS, ERROR)\n# ---------------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[$1\n%%\nexp: %empty;\n])\n\nAT_BISON_CHECK([[input.y]], [$2], [[]],\n[$3])\n])\n\nAT_TEST([[%union foo {};\n%union {};\n%union foo {};\n%define api.value.union.name foo]],\n[0],\n[[input.y:3.8-10: warning: %define variable 'api.value.union.name' redefined [-Wother]\ninput.y:1.8-10: note: previous definition\ninput.y:4.1-32: warning: %define variable 'api.value.union.name' redefined [-Wother]\ninput.y:3.8-10: note: previous definition\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_TEST([[%define api.value.union.name {foo}]], [1],\n[[input.y:1.1-34: error: %define variable 'api.value.union.name' requires keyword values\ninput.y:1.1-34: error: %define variable 'api.value.union.name' is not used\n]])\n\nAT_TEST([[%define api.value.union.name \"foo\"]], [1],\n[[input.y:1.1-34: error: %define variable 'api.value.union.name' requires keyword values\ninput.y:1.1-34: error: %define variable 'api.value.union.name' is not used\n]])\n\nm4_popdef([AT_TEST])\nAT_CLEANUP\n\n\n\n\n## -------------- ##\n## Stray $ or @.  ##\n## -------------- ##\n\nAT_SETUP([[Stray $ or @]])\nAT_BISON_OPTION_PUSHDEFS\n\n# Give %printer and %destructor \"<*> exp TOK\" instead of \"<*>\" to\n# check that the warnings are reported once, not three times.\n\nAT_DATA_GRAMMAR([[input.y]],\n[[%type <TYPE> exp\n%token <TYPE> TOK TOK2\n%destructor     { $%; @%; } <*> exp TOK;\n%initial-action { $%; @%; };\n%printer        { $%; @%; } <*> exp TOK;\n%{ $ @ %} // Should not warn.\n%%\nexp: TOK        { $%; @%; $$ = $1; }\n   | 'a'        { $<->1; $$ = 1; }\n   | 'b'        { $<foo->bar>$; }\n%%\n$ @ // Should not warn.\n]])\n\nAT_BISON_CHECK([[-Wall input.y]], 0, [],\n[[input.y:11.19: warning: stray '$' [-Wother]\ninput.y:11.23: warning: stray '@' [-Wother]\ninput.y:12.19: warning: stray '$' [-Wother]\ninput.y:12.23: warning: stray '@' [-Wother]\ninput.y:13.19: warning: stray '$' [-Wother]\ninput.y:13.23: warning: stray '@' [-Wother]\ninput.y:16.19: warning: stray '$' [-Wother]\ninput.y:16.23: warning: stray '@' [-Wother]\ninput.y:17.19: warning: stray '$' [-Wother]\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n\n## ---------------- ##\n## Code injection.  ##\n## ---------------- ##\n\n\nAT_SETUP([[Code injection]])\n\nm4_pattern_allow([^m4_errprintn$])\n\n# AT_TEST([MACRO])\n# ----------------\n# Try to have MACRO be run by bison.\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[%type <$1(DEAD %type)> exp\n%token <$1(DEAD %token)> a\n%token b\n%initial-action\n{\n  $$;\n  $<$1(DEAD %initial-action)>$\n};\n%printer\n{\n  $$\n  $<$1(DEAD %printer)>$\n} <> <*>;\n%lex-param\n{\n  $1(DEAD %lex-param)\n};\n%parse-param\n{\n  $1(DEAD %parse-param)\n};\n%%\nexp:\n  a a[name] b\n  {\n    $$;\n    $][1;\n    $<$1(DEAD action 1)>$\n    $<$1(DEAD action 2)>1\n    $<$1(DEAD action 3)>name\n    $<$1(DEAD action 4)>0\n    ;\n  };\n]])\n\n# FIXME: Provide a means to iterate over all the skeletons.\nAT_BISON_CHECK([[-d               input.y]])\nAT_BISON_CHECK([[-d -S glr.c      input.y]])\nAT_BISON_CHECK([[-d -S lalr1.cc   input.y]])\nAT_BISON_CHECK([[-d -S glr.cc     input.y]])\nAT_BISON_CHECK([[   -S lalr1.java input.y]])\n])\n\nAT_TEST([m4_errprintn])\nAT_TEST([@:>@m4_errprintn])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n##----------------------- ##\n## Deprecated directives. ##\n## ---------------------- ##\n\nAT_SETUP([[Deprecated directives]])\n\nAT_KEYWORDS([[deprec]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[\n%default_prec\n%error_verbose\n%expect_rr 0\n%file-prefix = \"foo\"\n%file-prefix\n =\n\"bar\"\n\t%fixed-output_files\n        %fixed_output-files\n%fixed-output-files\n%name-prefix= \"foo\"\n%no-default_prec\n%no_default-prec\n%no_lines\n%output = \"output.c\"\n%pure_parser\n%token_table\n%error-verbose\n%glr-parser\n%name-prefix \"bar\"\n%%\nexp : '0'\n]])\n\nAT_DATA([errors-all],\n[[input.y:10.1-13: warning: deprecated directive: '%default_prec', use '%default-prec' [-Wdeprecated]\nfix-it:\"input.y\":{10:1-10:14}:\"%default-prec\"\ninput.y:11.1-14: warning: deprecated directive: '%error_verbose', use '%define parse.error verbose' [-Wdeprecated]\nfix-it:\"input.y\":{11:1-11:15}:\"%define parse.error verbose\"\ninput.y:12.1-10: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\nfix-it:\"input.y\":{12:1-12:11}:\"%expect-rr\"\ninput.y:13.1-14: warning: deprecated directive: '%file-prefix =', use '%file-prefix' [-Wdeprecated]\nfix-it:\"input.y\":{13:1-13:15}:\"%file-prefix\"\ninput.y:14.1-16.5: warning: duplicate directive: '%file-prefix\\n =' [-Wother]\ninput.y:13.1-20: note: previous declaration\nfix-it:\"input.y\":{14:1-16:6}:\"\"\ninput.y:17.9-27: warning: deprecated directive: '%fixed-output_files', use '%output \"y.tab.c\"' [-Wdeprecated]\nfix-it:\"input.y\":{17:2-17:21}:\"%output \\\"y.tab.c\\\"\"\ninput.y:18.9-27: warning: deprecated directive: '%fixed_output-files', use '%output \"y.tab.c\"' [-Wdeprecated]\nfix-it:\"input.y\":{18:9-18:28}:\"%output \\\"y.tab.c\\\"\"\ninput.y:19.1-19: warning: deprecated directive: '%fixed-output-files', use '%output \"y.tab.c\"' [-Wdeprecated]\nfix-it:\"input.y\":{19:1-19:20}:\"%output \\\"y.tab.c\\\"\"\ninput.y:20.1-19: warning: deprecated directive: '%name-prefix= \"foo\"', use '%define api.prefix {foo}' [-Wdeprecated]\nfix-it:\"input.y\":{20:1-20:20}:\"%define api.prefix {foo}\"\ninput.y:21.1-16: warning: deprecated directive: '%no-default_prec', use '%no-default-prec' [-Wdeprecated]\nfix-it:\"input.y\":{21:1-21:17}:\"%no-default-prec\"\ninput.y:22.1-16: warning: deprecated directive: '%no_default-prec', use '%no-default-prec' [-Wdeprecated]\nfix-it:\"input.y\":{22:1-22:17}:\"%no-default-prec\"\ninput.y:23.1-9: warning: deprecated directive: '%no_lines', use '%no-lines' [-Wdeprecated]\nfix-it:\"input.y\":{23:1-23:10}:\"%no-lines\"\ninput.y:24.1-9: warning: deprecated directive: '%output =', use '%output' [-Wdeprecated]\nfix-it:\"input.y\":{24:1-24:10}:\"%output\"\ninput.y:25.1-12: warning: deprecated directive: '%pure_parser', use '%define api.pure' [-Wdeprecated]\nfix-it:\"input.y\":{25:1-25:13}:\"%define api.pure\"\ninput.y:26.1-12: warning: deprecated directive: '%token_table', use '%token-table' [-Wdeprecated]\nfix-it:\"input.y\":{26:1-26:13}:\"%token-table\"\ninput.y:27.1-14: warning: %define variable 'parse.error' redefined [-Wother]\ninput.y:11.1-14: note: previous definition\nfix-it:\"input.y\":{27:1-27:15}:\"\"\ninput.y:29.1-18: warning: duplicate directive: '%name-prefix \"bar\"' [-Wother]\ninput.y:13.1-20: note: previous declaration\nfix-it:\"input.y\":{29:1-29:19}:\"\"\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_CHECK([cp errors-all experr])\nAT_BISON_CHECK([[-ffixit input.y]], [], [], [experr])\n\nAT_CHECK([[sed -e '/^fix-it:/d' errors-all >experr]])\nAT_BISON_CHECK([[input.y]], [], [], [experr])\n\n\n# Update the input file.  Make sure we generated nothing.\nAT_CHECK([rm -f output.c])\nAT_CHECK([cp input.y input.y.orig])\nAT_CHECK([sed -e '/fix-it/d' <errors-all >experr])\nAT_CHECK([echo \"bison: file 'input.y' was updated (backup: 'input.y~')\" >>experr])\nAT_BISON_CHECK([[--update input.y]], [], [[]], [experr])\n\n# Check the backup.\nAT_CHECK([diff input.y.orig input.y~])\n\n# Check we did not generate any file.\nAT_CHECK([test ! -f output.c])\n\n# Check the update.\nAT_CHECK([sed -e '1,8d' input.y], [],\n[[\n%default-prec\n%define parse.error verbose\n%expect-rr 0\n%file-prefix \"foo\"\n\t%output \"y.tab.c\"\n        %output \"y.tab.c\"\n%output \"y.tab.c\"\n%define api.prefix {foo}\n%no-default-prec\n%no-default-prec\n%no-lines\n%output \"output.c\"\n%define api.pure\n%token-table\n%glr-parser\n%%\nexp : '0'\n]])\n\nAT_BISON_CHECK([[input.y]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ---------------------------- ##\n## Unput's effect on locations. ##\n## ---------------------------- ##\n\n# When the scanner detects a deprecated construct, it unputs the\n# correct version, but it should *not* have any impact on the scanner\n# cursor. If it does, the locations of directives on the same line\n# become erroneous.\n\nAT_SETUP([[Unput's effect on locations]])\n\nAT_KEYWORDS([[deprec]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[\n%glr-parser\n%expect_rr 42 %expect_rr 42\n              %expect_rr 42\n%error_verbose %error_verbose\n               %error_verbose\n%% exp: '0'\n]])\n\nAT_BISON_CHECK([[input.y]], [[1]], [[]],\n[[input.y:11.1-10: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\ninput.y:11.15-24: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\ninput.y:12.15-24: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\ninput.y:13.1-14: warning: deprecated directive: '%error_verbose', use '%define parse.error verbose' [-Wdeprecated]\ninput.y:13.16-29: warning: %define variable 'parse.error' redefined [-Wother]\ninput.y:13.1-14: note: previous definition\ninput.y:14.16-29: warning: %define variable 'parse.error' redefined [-Wother]\ninput.y:13.16-29: note: previous definition\ninput.y: error: reduce/reduce conflicts: 0 found, 42 expected\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## -------------------------- ##\n## Non-deprecated directives. ##\n## -------------------------- ##\n\nAT_SETUP([[Non-deprecated directives]])\n\nAT_KEYWORDS([[deprec]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[\n%default-prec\n%define parse.error verbose\n%expect-rr 42\n%file-prefix \"foo\"\n%file-prefix\n\"bar\"\n%no-default-prec\n%no-lines\n%output \"foo\"\n%token-table\n%% exp : '0'\n]])\n\nAT_BISON_CHECK([[input.y]], [[0]], [[]],\n[[input.y:14.1-15.5: warning: duplicate directive: '%file-prefix' [-Wother]\ninput.y:13.1-18: note: previous declaration\ninput.y: warning: %expect-rr applies only to GLR parsers [-Wother]\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## -------------------- ##\n## Cannot type action.  ##\n## -------------------- ##\n\nAT_SETUP([[Cannot type action]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[%%\nexp: <int> {}\n]])\n\nAT_BISON_CHECK([[-fcaret input.y]], [[0]], [[]],\n[[input.y:10.6-13: warning: only midrule actions can be typed: int [-Wother]\n   10 | exp: <int> {}\n      |      ^~~~~~~~\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n\n## -------------------------------------- ##\n## Character literals and api.token.raw.  ##\n## -------------------------------------- ##\n\nAT_SETUP([[Character literals and api.token.raw]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[%define api.token.raw\n%token 'a'\n%%\nexp: 'b' \"c\" {}\n]])\n\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:10.8-10: error: character literals cannot be used together with api.token.raw\n   10 | %token 'a'\n      |        ^~~\ninput.y:9.1-21: note: definition of api.token.raw\n    9 | %define api.token.raw\n      | ^~~~~~~~~~~~~~~~~~~~~\ninput.y:12.6-8: error: character literals cannot be used together with api.token.raw\n   12 | exp: 'b' \"c\" {}\n      |      ^~~\ninput.y:9.1-21: note: definition of api.token.raw\n    9 | %define api.token.raw\n      | ^~~~~~~~~~~~~~~~~~~~~\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n\n## ------------------------------ ##\n## %token-table and parse.error.  ##\n## ------------------------------ ##\n\nAT_SETUP([[%token-table and parse.error]])\n\n# AT_TEST(DIRECTIVES, ERROR-LOCATION)\n# -----------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[$1\n%%\nexp: %empty;\n]])\nAT_BISON_CHECK([[input.y]], [[1]], [[]],\n[$2: error: '%token-table' and '%define parse.error (custom|detailed)' cannot be used together\n])\n])\n\nAT_TEST([%define parse.error custom %token-table],  [[input.y:1.1-26]])\nAT_TEST([%define parse.error detailed %token-table],[[input.y:1.1-28]])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n## --------------------------------------- ##\n## Invalid file prefix mapping arguments.  ##\n## --------------------------------------- ##\n\nAT_SETUP([[Invalid file prefix mapping arguments]])\n\n# AT_TEST(DIRECTIVES, OPTIONS, ERROR-LOCATION)\n# --------------------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[\n%%\nexp: %empty;\n]])\nAT_BISON_CHECK([[$1 input.y]], [[1]], [[]],\n[[$3: error: invalid argument for '--file-prefix-map': $2\n]])\n])\n\nAT_TEST([-M foo], [foo], [<command line>:4])\nAT_TEST([--file-prefix-map foo], [foo], [<command line>:4])\nAT_TEST([-M foo=bar -M baz], [baz], [<command line>:6])\nAT_TEST([-M foo= -M baz], [baz], [<command line>:6])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n"], "fixing_code": ["Bison was originally written by Robert Corbett.  It would not be what\nit is today without the invaluable help of these people:\n\nAaro Koskinen             aaro.koskinen@iki.fi\n\u0410\u0441\u043a\u0430\u0440 \u0421\u0430\u0444\u0438\u043d               safinaskar@mail.ru\nAdam Sampson              ats@offog.org\nAdrian Vogelsgesang       avogelsgesang@tableau.com\nAhcheong Lee              dkcjd2000@gmail.com\nAiry Andre                Airy.Andre@edf.fr\nAkim Demaille             akim@gnu.org\nAlbert Chin-A-Young       china@thewrittenword.com\nAlexander Belopolsky      alexb@rentec.com\nAlexandre Duret-Lutz      adl@lrde.epita.fr\nAndre da Costa Barros     andre.cbarros@yahoo.com\nAndreas Damm              adamm@onica.com\nAndreas Schwab            schwab@suse.de\nAndrew Suffield           asuffield@users.sourceforge.net\nAngelo Borsotti           angelo.borsotti@gmail.com\nAnthony Heading           ajrh@ajrh.net\nAntonio Silva Correia     amsilvacorreia@hotmail.com\nArnold Robbins            arnold@skeeve.com\nArt Haas                  ahaas@neosoft.com\nArthur Schwarz            aschwarz1309@att.net\nAskar Safin               safinaskar@mail.ru\nBal\u00e1zs Scheidler          balazs.scheidler@oneidentity.com\nBaron Schwartz            baron@sequent.org\nBen Pfaff                 blp@cs.stanford.edu\nBenoit Perrot             benoit.perrot@epita.fr\nBernd Edlinger            bernd.edlinger@hotmail.de\nBernd Kiefer              kiefer@dfki.de\nBert Deknuydt             Bert.Deknuydt@esat.kuleuven.ac.be\nBill Allombert            Bill.Allombert@math.u-bordeaux1.fr\nBob Rossi                 bob@brasko.net\nBrandon Lucia             blucia@gmail.com\nBrooks Moses              bmoses@google.com\nBruce Lilly               blilly@erols.com\nBruno Haible              bruno@clisp.org\nCharles-Henri de Boysson  de-boy_c@epita.fr\nChristian Burger          cburger@sunysb.edu\nCl\u00e9ment D\u00e9moulins         demoulins@lrde.epita.fr\nColin Daley               colin.daley@outlook.com\nCris Bailiff              c.bailiff+bison@awayweb.com\nCris van Pelt             cris@amf03054.office.wxs.nl\nCsaba Raduly              csaba_22@yahoo.co.uk\nDagobert Michelsen        dam@baltic-online.de\nDaniel Fru\u017cy\u0144ski          daniel@poradnik-webmastera.com\nDaniel Galloway           dg1751@att.com\nDaniela Becker            daniela@lrde.epita.fr\nDaniel Hagerty            hag@gnu.org\nDavid Barto               david.barto@sparqlcity.com\nDavid J. MacKenzie        djm@gnu.org\nDavid Kastrup             dak@gnu.org\nDavid Michael             fedora.dm0@gmail.com\nDengke Du                 dengke.du@windriver.com\nDenis Excoffier           gcc@Denis-Excoffier.org\nDennis Clarke             dclarke@blastwave.org\nDerek Clegg               derek@me.com\nDerek M. Jones            derek@knosof.co.uk\nDi-an Jan                 dianj@freeshell.org\nDick Streefland           dick.streefland@altium.nl\nDidier Godefroy           dg@ulysium.net\nDon Macpherson            donmac703@gmail.com\nDwight Guth               dwight.guth@runtimeverification.com\nEfi Fogel                 efifogel@gmail.com\nEnrico Scholz             enrico.scholz@informatik.tu-chemnitz.de\nEric Blake                ebb9@byu.net\nEric S. Raymond           esr@thyrsus.com\n\u00c9tienne Renault           renault@lrde.epita.fr\nEvan Lavelle              eml-bison@cyconix.com\nEvan Nemerson             evan@nemerson.com\nEvgeny Stambulchik        fnevgeny@plasma-gate.weizmann.ac.il\nFabrice Bauzac            noon@cote-dazur.com\nFerdinand Thiessen        ferdinand@fthiessen.de\nFlorian Krohm             florian@edamail.fishkill.ibm.com\nFrank Heckenbach          frank@g-n-u.de\nFrans Englich             frans.englich@telia.com\nGabriel Rassoul           gabriel.rassoul@epita.fr\nGary L Peskin             garyp@firstech.com\nGavin Smith               gavinsmith0123@gmail.com\nGeorg Sauthoff            gsauthof@TechFak.Uni-Bielefeld.DE\nGeorge Neuner             gneuner2@comcast.net\nGilles Espinasse          g.esp@free.fr\nGoran Uddeborg            goeran@uddeborg.se\nGuido Trentalancia        trentalg@aston.ac.uk\nH. Merijn Brand           h.m.brand@hccnet.nl\nHans \u00c5berg                haberg-1@telia.com\nHorst Von Brand           vonbrand@inf.utfsm.cl\nJacob L. Mandelson        jlm-bbison@jlm.ofb.net\nJan Nieuwenhuizen         janneke@gnu.org\nJannick                   thirdedition@gmx.net\nJeff Hammond              jeff_hammond@acm.org\nJerry Quinn               jlquinn@optonline.net\nJesse Thilo               jthilo@gnu.org\nJim Kent                  jkent@arch.sel.sony.com\nJim Meyering              jim@meyering.net\nJoel E. Denny             joeldenny@joeldenny.org\nJohan van Selst           johans@stack.nl\nJohn Horigan              john@glyphic.com\nJonathan Fabrizio         jonathan.fabrizio@lrde.epita.fr\nJonathan Nieder           jrnieder@gmail.com\nJosh Soref                jsoref@gmail.com\nJuan Manuel Guerrero      juan.guerrero@gmx.de\nKarl Berry                karl@freefriends.org\nKees Zeelenberg           kzlg@users.sourceforge.net\nKeith Browne              kbrowne@legato.com\nKen Moffat                zarniwhoop@ntlworld.com\nKiyoshi Kanazawa          yoi_no_myoujou@yahoo.co.jp\nLars Maier                lars.maier@tefax.net\nL\u00e1szl\u00f3 V\u00e1rady             laszlo.varady93@gmail.com\nLaurent Mascherpa         laurent.mascherpa@epita.fr\nLie Yan                   lie.yan@kaust.edu.sa\nMagnus Fromreide          magfr@lysator.liu.se\nMarc Autret               autret_m@epita.fr\nMarc Mendiola             mmendiol@usc.edu\nMarc Sch\u00f6nefeld           marc.schoenefeld@gmx.org\nMark Boyall               wolfeinstein@gmail.com\nMartin Blais              blais@furius.ca\nMartin Jacobs             martin.jacobs@arcor.de\nMartin Mokrejs            mmokrejs@natur.cuni.cz\nMartin Nylin              martin.nylin@linuxmail.org\nMatt Kraai                kraai@alumni.cmu.edu\nMatt Rosing               rosing@peakfive.com\nMaxim Prohorenko          Maxim.Prohorenko@gmail.com\nMichael Catanzaro         mcatanzaro@gnome.org\nMichael Felt              mamfelt@gmail.com\nMichael Hayes             m.hayes@elec.canterbury.ac.nz\nMichael Raskin            7c6f434c@mail.ru\nMichel d'Hooge            michel.dhooge@gmail.com\nMichiel De Wilde          mdewilde.agilent@gmail.com\nMickael Labau             labau_m@epita.fr\nMike Castle               dalgoda@ix.netcom.com\nMike Frysinger            vapier@gentoo.org\nMike Sullivan             Mike.sullivan@Oracle.COM\nNate Guerin               nathan.guerin@riseup.net\nNeil Booth                NeilB@earthling.net\nNelson H. F. Beebe        beebe@math.utah.edu\nneok m4700                neok.m4700@gmail.com\nNick Bowler               nbowler@elliptictech.com\nNicolas Bedon             nicolas.bedon@univ-rouen.fr\nNicolas Burrus            nicolas.burrus@epita.fr\nNicolas Tisserand         nicolas.tisserand@epita.fr\nNikki Valen               nicolettavalencia.nv@gmail.com\nNoah Friedman             friedman@gnu.org\nOdd Arild Olsen           oao@fibula.no\nOleg Smolsky              oleg.smolsky@pacific-simulators.co.nz\nOleksii Taran             oleksii.taran@gmail.com\nOliver Mangold            o.mangold@gmail.com\nPaolo Bonzini             bonzini@gnu.org\nPaolo Simone Gasparello   djgaspa@gmail.com\nPascal Bart               pascal.bart@epita.fr\nPatrice Dumas             pertusus@free.fr\nPaul Eggert               eggert@cs.ucla.edu\nPaul Hilfinger            Hilfinger@CS.Berkeley.EDU\nPer Allansson             per@appgate.com\nPeter Eisentraut          peter_e@gmx.net\nPeter Fales               psfales@lucent.com\nPeter Hamorsky            hamo@upjs.sk\nPeter Simons              simons@cryp.to\nPetr Machata              pmachata@redhat.com\nPho                       pho@cielonegro.org\nPiotr Gackiewicz          gacek@intertel.com.pl\nPiotr Marci\u0144czyk          piomar123@gmail.com\nPramod Kumbhar            pramod.s.kumbhar@gmail.com\nQuentin Hocquet           hocquet@gostai.com\nQuoc Peyrot               chojin@lrde.epita.fr\nR Blake                   blakers@mac.com\nRaja R Harinath           harinath@cs.umn.edu\nRalf Wildenhues           Ralf.Wildenhues@gmx.de\nRyan                      dev@splintermail.com\nRich Wilson               richaw@gmail.com\nRichard Stallman          rms@gnu.org\nRici Lake                 ricilake@gmail.com\nRob Conde                 rob.conde@ai-solutions.com\nRob Vermaas               rob.vermaas@gmail.com\nRobert Anisko             anisko_r@epita.fr\nRobert Yang               liezhi.yang@windriver.com\nRoland Levillain          roland@lrde.epita.fr\nSatya Kiran Popuri        satyakiran@gmail.com\nSebastian Setzer          sebastian.setzer.ext@siemens.com\nSebastien Fricker         sebastien.fricker@gmail.com\nS\u00e9bastien Villemot        sebastien@debian.org\nSergei Steshenko          sergstesh@yahoo.com\nShura                     debil_urod@ngs.ru\nSimon Sobisch             simonsobisch@web.de\nStefano Lattarini         stefano.lattarini@gmail.com\nStephen Cameron           stephenmcameron@gmail.com\nSteve Murphy              murf@parsetree.com\nSuhwan Song               prada960808@gmail.com\nSum Wu                    sum@geekhouse.org\nTh\u00e9ophile Ranquet         theophile.ranquet@gmail.com\nThiru Ramakrishnan        thiru.ramakrishnan@gmail.com\nThomas Jahns              jahns@dkrz.de\nThomas Petazzoni          thomas.petazzoni@bootlin.com\nTim Josling               tej@melbpc.org.au\nTim Landscheidt           tim@tim-landscheidt.de\nTim Van Holder            tim.van.holder@pandora.be\nTobias Frost              tobi@debian.org\nTodd Freed                todd.freed@gmail.com\nTom Kramer                kramer@nist.gov\nTom Lane                  tgl@sss.pgh.pa.us\nTom Tromey                tromey@cygnus.com\nTomasz K\u0142oczko            kloczko.tomasz@gmail.com\nTommy Nordgren            tommy.nordgren@chello.se\nTroy A. Johnson           troyj@ecn.purdue.edu\nTys Lefering              gccbison@gmail.com\nUxio Prego                uxio@uma.es\nValentin Tolmer           nitnelave1@gmail.com\nwcventure                 wcventure@126.com\nVictor Khomenko           victor.khomenko@newcastle.ac.uk\nVictor Zverovich          victor.zverovich@gmail.com\nVin Shelton               acs@alumni.princeton.edu\nW.C.A. Wijngaards         wouter@NLnetLabs.nl\nWayne Green               wayne@infosavvy.com\nWei Song                  wsong83@gmail.com\nWojciech Polak            polak@gnu.org\nWolfgang S. Kechel        wolfgang.kechel@prs.de\nWolfgang Thaller          wolfgang.thaller@gmx.net\nWolfram Wagner            ww@mpi-sb.mpg.de\nWwp                       subscript@free.fr\nxolodho                   xolodho@gmail.com\nYuichiro Kaneko           spiketeika@gmail.com\nYuriy Solodkyy            solodon@gmail.com\nZack Weinberg             zack@codesourcery.com\n\u6c5f \u7956\u94ed                    jjzuming@outlook.com\n\u9577\u7530\u5049\u4f38                   cbh34680@iret.co.jp\n\u9a6c\u4fca                       majun123@whu.edu.cn\n\nMany people are not named here because we lost track of them.  We\nthank them!  Please, help us keeping this list up to date.\n\nLocal Variables:\nmode: text\ncoding: utf-8\nEnd:\n\n-----\n\nCopyright (C) 2000-2015, 2018-2020 Free Software Foundation, Inc.\n\nThis file is part of Bison, the GNU Parser Generator.\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <http://www.gnu.org/licenses/>.\n", "/* Common parts between scan-code.l, scan-gram.l, and scan-skel.l.\n\n   Copyright (C) 2006, 2009-2015, 2018-2020 Free Software Foundation,\n   Inc.\n\n   This file is part of Bison, the GNU Compiler Compiler.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n#ifndef FLEX_PREFIX\n# error \"FLEX_PREFIX not defined\"\n#endif\n\n/* Flex full version as a number.  */\n#define FLEX_VERSION                    \\\n  ((YY_FLEX_MAJOR_VERSION) * 1000000    \\\n   + (YY_FLEX_MINOR_VERSION) * 1000     \\\n   + (YY_FLEX_SUBMINOR_VERSION))\n\n// Pacify warnings in yy_init_buffer (observed with Flex 2.6.4 and GCC\n// 6.4.0 and 7.3.0).\n//\n// ./src/scan-skel.c: In function 'skel_restart':\n// ./src/scan-skel.c:2035:20: error: potential null pointer dereference [-Werror=null-dereference]\n//   b->yy_fill_buffer = 1;\n//   ~~~~~~~~~~~~~~~~~~^~~\n// ./src/scan-skel.c:2031:19: error: potential null pointer dereference [-Werror=null-dereference]\n//   b->yy_input_file = file;\n//   ~~~~~~~~~~~~~~~~~^~~~~~\n#if defined __GNUC__ && ! defined __clang__ && 6 <= __GNUC__\n# pragma GCC diagnostic ignored \"-Wnull-dereference\"\n#endif\n\n// Old versions of Flex (2.5.35) generate an incomplete documentation comment.\n//\n//  In file included from src/scan-code-c.c:3:\n//  src/scan-code.c:2198:21: error: empty paragraph passed to '@param' command\n//        [-Werror,-Wdocumentation]\n//   * @param line_number\n//     ~~~~~~~~~~~~~~~~~^\n//  1 error generated.\n#if FLEX_VERSION <= 20060000 && defined __clang__\n# pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n\n/* Pacify \"gcc -Wmissing-prototypes\" when flex 2.5.31 is used.  */\n#if FLEX_VERSION <= 2005031\nint   FLEX_PREFIX (get_lineno) (void);\nFILE *FLEX_PREFIX (get_in) (void);\nFILE *FLEX_PREFIX (get_out) (void);\nint   FLEX_PREFIX (get_leng) (void);\nchar *FLEX_PREFIX (get_text) (void);\nvoid  FLEX_PREFIX (set_lineno) (int);\nvoid  FLEX_PREFIX (set_in) (FILE *);\nvoid  FLEX_PREFIX (set_out) (FILE *);\nint   FLEX_PREFIX (get_debug) (void);\nvoid  FLEX_PREFIX (set_debug) (int);\nint   FLEX_PREFIX (lex_destroy) (void);\n#endif\n\n#define last_string    FLEX_PREFIX (last_string)\n\n/* It seems to be a nice \"feature\" of Flex that one cannot use yytext,\n   yyleng etc. when a prefix is given, since there is no longer a\n   #define, but rather the token is actually changed in the output.\n   However, this is not true for Flex 2.5.4.  */\n#ifndef yyleng\n# define yyleng  FLEX_PREFIX (leng)\n#endif\n#ifndef yytext\n# define yytext  FLEX_PREFIX (text)\n#endif\n\n/* Non-reentrant scanners generated by Flex 2.5.9 and later (and some earlier\n   versions according to the Flex manual) leak memory if yylex_destroy is not\n   invoked.  However, yylex_destroy is not defined before Flex 2.5.9, so give\n   an implementation here that at least appears to work with Flex 2.5.4.  */\n#if FLEX_VERSION <= 2005009\n# define yylex_destroy() yy_delete_buffer (YY_CURRENT_BUFFER)\n#endif\n\n/* OBSTACK_FOR_STRING -- Used to store all the characters that we need to\n   keep (to construct ID, STRINGS etc.).  Use the following macros to\n   use it.\n\n   Use STRING_GROW () to append what has just been matched, and\n   STRING_FINISH () to end the string (it puts the ending 0).\n   STRING_FINISH () also stores this string in LAST_STRING, which can be\n   used, and which is used by STRING_FREE () to free the last string.  */\n\n#ifndef FLEX_NO_OBSTACK\n\nstatic struct obstack obstack_for_string;\n\n# define STRING_GROW()                                  \\\n  obstack_grow (&obstack_for_string, yytext, yyleng)\n\n# define STRING_FINISH()                                \\\n  (last_string = obstack_finish0 (&obstack_for_string))\n\n# define STRING_1GROW(Char)                     \\\n  obstack_1grow (&obstack_for_string, Char)\n\n# ifdef NDEBUG\n#  define STRING_FREE()                                 \\\n  obstack_free (&obstack_for_string, last_string)\n# else\n#  define STRING_FREE()                                  \\\n  do {                                                   \\\n    obstack_free (&obstack_for_string, last_string);     \\\n    last_string = NULL;                                  \\\n  } while (0)\n#endif\n\n#endif\n", "/* Bison Grammar Scanner                             -*- C -*-\n\n   Copyright (C) 2002-2015, 2018-2020 Free Software Foundation, Inc.\n\n   This file is part of Bison, the GNU Compiler Compiler.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n%option debug nodefault noinput noyywrap never-interactive\n%option prefix=\"gram_\" outfile=\"lex.yy.c\"\n\n%{\n#include <errno.h>\n\n#include <c-ctype.h>\n#include <mbswidth.h>\n#include <quote.h>\n#include <quotearg.h>\n\n#include \"src/complain.h\"\n#include \"src/files.h\"\n#include \"src/getargs.h\"\n#include \"src/gram.h\"\n#include \"src/reader.h\"\n#include \"src/scan-gram.h\"\n#include \"src/uniqstr.h\"\n\n#define FLEX_PREFIX(Id) gram_ ## Id\n#include \"src/flex-scanner.h\"\n\n/* Work around a bug in flex 2.5.31.  See Debian bug 333231\n   <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=333231>.  */\n#undef gram_wrap\n#define gram_wrap() 1\n\n#define YY_DECL GRAM_LEX_DECL\n\n/* Location of scanner cursor.  */\nstatic boundary scanner_cursor;\n\n#define YY_USER_ACTION  location_compute (loc, &scanner_cursor, yytext, yyleng);\n\n/* Report that yytext is an extension, and evaluate to its token kind.  */\n#define BISON_DIRECTIVE(Directive)                              \\\n  (bison_directive (loc, yytext), PERCENT_ ## Directive)\n\n#define RETURN_PERCENT_PARAM(Value)             \\\n  RETURN_VALUE(PERCENT_PARAM, param_ ## Value)\n\n#define RETURN_PERCENT_FLAG(Value)                      \\\n  RETURN_VALUE(PERCENT_FLAG, uniqstr_new (Value))\n\n#define RETURN_VALUE(Token, Value)              \\\n  do {                                          \\\n    val->Token = Value;                         \\\n    return Token;                               \\\n  } while (0)\n\n#define ROLLBACK_CURRENT_TOKEN                                  \\\n  do {                                                          \\\n    scanner_cursor.column -= mbsnwidth (yytext, yyleng, 0);     \\\n    scanner_cursor.byte -= yyleng;                              \\\n    yyless (0);                                                 \\\n  } while (0)\n\n#define DEPRECATED_DIRECTIVE(Msg)                               \\\n  do {                                                          \\\n    deprecated_directive (loc, yytext, Msg);                    \\\n    scanner_cursor.column -= mbsnwidth (Msg, strlen (Msg), 0);  \\\n    scanner_cursor.byte -= strlen (Msg);                        \\\n    for (size_t i = strlen (Msg); i != 0; --i)                  \\\n      unput (Msg[i - 1]);                                       \\\n  } while (0)\n\n\n#define STRING_GROW_ESCAPE(Char)                                \\\n  do {                                                          \\\n    verify (UCHAR_MAX < ULONG_MAX);                             \\\n    long c = Char;                                              \\\n    bool valid = 0 < c && c <= UCHAR_MAX;                       \\\n    if (!valid)                                                 \\\n      complain (loc, complaint,                                 \\\n                _(\"invalid number after \\\\-escape: %s\"),        \\\n                yytext + 1);                                    \\\n    if (YY_START == SC_ESCAPED_CHARACTER)                       \\\n      STRING_1GROW (valid ? c : '?');                           \\\n    else                                                        \\\n      STRING_GROW ();                                           \\\n  } while (0)\n\n\n/* The current file name.  Might change with #line.  */\nstatic uniqstr current_file = NULL;\n\n/* A string representing the most recently saved token.  */\nstatic char *last_string = NULL;\n\n/* Bracketed identifier. */\nstatic uniqstr bracketed_id_str = NULL;\nstatic location bracketed_id_loc;\nstatic boundary bracketed_id_start;\nstatic int bracketed_id_context_state = 0;\n\nvoid\ngram_scanner_last_string_free (void)\n{\n  STRING_FREE ();\n}\n\nstatic void handle_syncline (char *, location);\nstatic int scan_integer (char const *p, int base, location loc);\nstatic int convert_ucn_to_byte (char const *hex_text);\nstatic void unexpected_eof (boundary, char const *);\nstatic void unexpected_newline (boundary, char const *);\n\n%}\n /* A C-like comment in directives/rules. */\n%x SC_YACC_COMMENT\n /* Characters and strings in directives/rules. */\n%x SC_ESCAPED_CHARACTER SC_ESCAPED_STRING SC_ESCAPED_TSTRING\n /* A identifier was just read in directives/rules.  Special state\n    to capture the sequence 'identifier :'. */\n%x SC_AFTER_IDENTIFIER\n\n /* POSIX says that a tag must be both an id and a C union member, but\n    historically almost any character is allowed in a tag.  We\n    disallow NUL, as this simplifies our implementation.  We match\n    angle brackets in nested pairs: several languages use them for\n    generics/template types.  */\n%x SC_TAG\n\n /* Four types of user code:\n    - prologue (code between '%{' '%}' in the first section, before %%);\n    - actions, printers, union, etc, (between braced in the middle section);\n    - epilogue (everything after the second %%).\n    - predicate (code between '%?{' and '{' in middle section); */\n%x SC_PROLOGUE SC_BRACED_CODE SC_EPILOGUE SC_PREDICATE\n /* C and C++ comments in code. */\n%x SC_COMMENT SC_LINE_COMMENT\n /* Strings and characters in code. */\n%x SC_STRING SC_CHARACTER\n /* Bracketed identifiers support. */\n%x SC_BRACKETED_ID SC_RETURN_BRACKETED_ID\n\nletter    [.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_]\nid        {letter}({letter}|[-0-9])*\nint       [0-9]+\nxint      0[xX][0-9abcdefABCDEF]+\n\neol       \\n|\\r\\n\n\n /* UTF-8 Encoded Unicode Code Point, from Flex's documentation. */\nmbchar    [\\x09\\x0A\\x0D\\x20-\\x7E]|[\\xC2-\\xDF][\\x80-\\xBF]|\\xE0[\\xA0-\\xBF][\\x80-\\xBF]|[\\xE1-\\xEC\\xEE\\xEF]([\\x80-\\xBF]{2})|\\xED[\\x80-\\x9F][\\x80-\\xBF]|\\xF0[\\x\\90-\\xBF]([\\x80-\\xBF]{2})|[\\xF1-\\xF3]([\\x80-\\xBF]{3})|\\xF4[\\x80-\\x8F]([\\x80-\\xBF]{2})\n\n/* Zero or more instances of backslash-newline.  Following GCC, allow\n   white space between the backslash and the newline.  */\nsplice   (\\\\[ \\f\\t\\v]*{eol})*\n\n/* An equal sign, with optional leading whitespaces. This is used in some\n   deprecated constructs. */\nsp       [[:space:]]*\neqopt    ({sp}=)?\n\n%%\n%{\n  /* Nesting level.  Either for nested braces, or nested angle brackets\n     (but not mixed).  */\n  int nesting PACIFY_CC (= 0);\n\n  /* Parent context state, when applicable.  */\n  int context_state PACIFY_CC (= 0);\n\n  /* Location of most recent identifier, when applicable.  */\n  location id_loc PACIFY_CC (= empty_loc);\n\n  /* Where containing code started, when applicable.  Its initial\n     value is relevant only when yylex is invoked in the SC_EPILOGUE\n     start condition.  */\n  boundary code_start = scanner_cursor;\n\n  /* Where containing comment or string or character literal started,\n     when applicable.  */\n  boundary token_start PACIFY_CC (= scanner_cursor);\n\n  /* We cannot trust YY_USER_INIT, whose semantics changes over time\n     (it moved in Flex 2.5.38).  */\n  static bool first = true;\n  if (first)\n    {\n      scanner_cursor = loc->start;\n      first = false;\n    }\n%}\n\n\n  /*-----------------------.\n  | Scanning white space.  |\n  `-----------------------*/\n\n<INITIAL,SC_AFTER_IDENTIFIER,SC_BRACKETED_ID,SC_RETURN_BRACKETED_ID>\n{\n  /* Comments and white space.  */\n  \",\" {\n     complain (loc, Wother, _(\"stray ',' treated as white space\"));\n  }\n  [ \\f\\t\\v\\r]|{eol}  |\n  \"//\".*       continue;\n  \"/*\" {\n    token_start = loc->start;\n    context_state = YY_START;\n    BEGIN SC_YACC_COMMENT;\n  }\n\n  ^\"#line \"{int}(\" \\\"\".*\"\\\"\")?{eol} {\n    handle_syncline (yytext + sizeof \"#line \" - 1, *loc);\n  }\n}\n\n\n  /*----------------------------.\n  | Scanning Bison directives.  |\n  `----------------------------*/\n\n  /* For directives that are also command line options, the regex must be\n        \"%...\"\n     after \"[-_]\"s are removed, and the directive must match the --long\n     option name, with a single string argument.  Otherwise, add exceptions\n     to ../build-aux/cross-options.pl.  */\n\n<INITIAL>\n{\n  \"%binary\"                         return BISON_DIRECTIVE (NONASSOC);\n  \"%code\"                           return BISON_DIRECTIVE (CODE);\n  \"%debug\"                          RETURN_PERCENT_FLAG (\"parse.trace\");\n  \"%default-prec\"                   return BISON_DIRECTIVE (DEFAULT_PREC);\n  \"%define\"                         return BISON_DIRECTIVE (DEFINE);\n  \"%defines\"                        return BISON_DIRECTIVE (DEFINES);\n  \"%destructor\"                     return BISON_DIRECTIVE (DESTRUCTOR);\n  \"%dprec\"                          return BISON_DIRECTIVE (DPREC);\n  \"%empty\"                          return BISON_DIRECTIVE (EMPTY);\n  \"%expect\"                         return BISON_DIRECTIVE (EXPECT);\n  \"%expect-rr\"                      return BISON_DIRECTIVE (EXPECT_RR);\n  \"%file-prefix\"                    RETURN_VALUE (PERCENT_FILE_PREFIX, uniqstr_new (yytext));\n  \"%initial-action\"                 return BISON_DIRECTIVE (INITIAL_ACTION);\n  \"%glr-parser\"                     return BISON_DIRECTIVE (GLR_PARSER);\n  \"%language\"                       return BISON_DIRECTIVE (LANGUAGE);\n  \"%left\"                           return PERCENT_LEFT;\n  \"%lex-param\"                      RETURN_PERCENT_PARAM (lex);\n  \"%locations\"                      RETURN_PERCENT_FLAG (\"locations\");\n  \"%merge\"                          return BISON_DIRECTIVE (MERGE);\n  \"%no-default-prec\"                return BISON_DIRECTIVE (NO_DEFAULT_PREC);\n  \"%no-lines\"                       return BISON_DIRECTIVE (NO_LINES);\n  \"%nonassoc\"                       return PERCENT_NONASSOC;\n  \"%nondeterministic-parser\"        return BISON_DIRECTIVE (NONDETERMINISTIC_PARSER);\n  \"%nterm\"                          return BISON_DIRECTIVE (NTERM);\n  \"%output\"                         return BISON_DIRECTIVE (OUTPUT);\n  \"%param\"                          RETURN_PERCENT_PARAM (both);\n  \"%parse-param\"                    RETURN_PERCENT_PARAM (parse);\n  \"%prec\"                           return PERCENT_PREC;\n  \"%precedence\"                     return BISON_DIRECTIVE (PRECEDENCE);\n  \"%printer\"                        return BISON_DIRECTIVE (PRINTER);\n  \"%require\"                        return BISON_DIRECTIVE (REQUIRE);\n  \"%right\"                          return PERCENT_RIGHT;\n  \"%skeleton\"                       return BISON_DIRECTIVE (SKELETON);\n  \"%start\"                          return PERCENT_START;\n  \"%term\"                           return BISON_DIRECTIVE (TOKEN);\n  \"%token\"                          return PERCENT_TOKEN;\n  \"%token-table\"                    return BISON_DIRECTIVE (TOKEN_TABLE);\n  \"%type\"                           return PERCENT_TYPE;\n  \"%union\"                          return PERCENT_UNION;\n  \"%verbose\"                        return BISON_DIRECTIVE (VERBOSE);\n  \"%yacc\"                           return PERCENT_YACC;\n\n  /* Deprecated since Bison 2.3b (2008-05-27), but the warning is\n     issued only since Bison 3.4. */\n  \"%pure\"[-_]\"parser\"               RETURN_VALUE (PERCENT_PURE_PARSER, uniqstr_new (yytext));\n\n  /* Deprecated since Bison 3.0 (2013-07-25), but the warning is\n     issued only since Bison 3.3. */\n  \"%error-verbose\"                  RETURN_VALUE (PERCENT_ERROR_VERBOSE, uniqstr_new (yytext));\n\n  /* Deprecated since Bison 2.6 (2012-07-19), but the warning is\n     issued only since Bison 3.3. */\n  \"%name\"[-_]\"prefix\"{eqopt}{sp}    RETURN_VALUE (PERCENT_NAME_PREFIX, uniqstr_new (yytext));\n\n  /* Deprecated since Bison 2.7.90, 2012. */\n  \"%default\"[-_]\"prec\"              DEPRECATED_DIRECTIVE (\"%default-prec\");\n  \"%error\"[-_]\"verbose\"             RETURN_VALUE (PERCENT_ERROR_VERBOSE, uniqstr_new (yytext));\n  \"%expect\"[-_]\"rr\"                 DEPRECATED_DIRECTIVE (\"%expect-rr\");\n  \"%file-prefix\"{eqopt}             RETURN_VALUE (PERCENT_FILE_PREFIX, uniqstr_new (yytext));\n  \"%fixed\"[-_]\"output\"[-_]\"files\"   DEPRECATED_DIRECTIVE (\"%output \\\"y.tab.c\\\"\");\n  \"%no\"[-_]\"default\"[-_]\"prec\"      DEPRECATED_DIRECTIVE (\"%no-default-prec\");\n  \"%no\"[-_]\"lines\"                  DEPRECATED_DIRECTIVE (\"%no-lines\");\n  \"%output\"{eqopt}                  DEPRECATED_DIRECTIVE (\"%output\");\n  \"%token\"[-_]\"table\"               DEPRECATED_DIRECTIVE (\"%token-table\");\n\n  \"%\"{id} {\n    complain (loc, complaint, _(\"invalid directive: %s\"), quote (yytext));\n    return GRAM_error;\n  }\n\n  \":\"                     return COLON;\n  \"=\"                     return EQUAL;\n  \"|\"                     return PIPE;\n  \";\"                     return SEMICOLON;\n\n  {id} {\n    val->ID = uniqstr_new (yytext);\n    id_loc = *loc;\n    bracketed_id_str = NULL;\n    BEGIN SC_AFTER_IDENTIFIER;\n  }\n\n  {int}      RETURN_VALUE (INT, scan_integer (yytext, 10, *loc));\n  {xint}     RETURN_VALUE (INT, scan_integer (yytext, 16, *loc));\n\n  /* Identifiers may not start with a digit.  Yet, don't silently\n     accept \"1FOO\" as \"1 FOO\".  */\n  {int}{id} {\n    complain (loc, complaint, _(\"invalid identifier: %s\"), quote (yytext));\n    return GRAM_error;\n  }\n\n  /* Characters.  */\n  \"'\"         token_start = loc->start; BEGIN SC_ESCAPED_CHARACTER;\n\n  /* Strings. */\n  \"\\\"\"        token_start = loc->start; STRING_1GROW ('\"'); BEGIN SC_ESCAPED_STRING;\n  \"_(\\\"\"      token_start = loc->start; STRING_1GROW ('\"'); BEGIN SC_ESCAPED_TSTRING;\n\n  /* Prologue. */\n  \"%{\"        code_start = loc->start; BEGIN SC_PROLOGUE;\n\n  /* Code in between braces.  */\n  \"{\" {\n    STRING_GROW ();\n    nesting = 0;\n    code_start = loc->start;\n    BEGIN SC_BRACED_CODE;\n  }\n\n  /* Semantic predicate. */\n  \"%?\"([ \\f\\t\\v]|{eol})*\"{\" {\n    nesting = 0;\n    code_start = loc->start;\n    BEGIN SC_PREDICATE;\n  }\n\n  /* A type. */\n  \"<*>\"       return TAG_ANY;\n  \"<>\"        return TAG_NONE;\n  \"<\"         {\n    nesting = 0;\n    token_start = loc->start;\n    BEGIN SC_TAG;\n  }\n\n  \"%%\" {\n    static int percent_percent_count;\n    if (++percent_percent_count == 2)\n      BEGIN SC_EPILOGUE;\n    return PERCENT_PERCENT;\n  }\n\n  \"[\" {\n    bracketed_id_str = NULL;\n    bracketed_id_start = loc->start;\n    bracketed_id_context_state = YY_START;\n    BEGIN SC_BRACKETED_ID;\n  }\n\n  [^\\[%A-Za-z0-9_<>{}\"\"''*;|=/, \\f\\r\\n\\t\\v]+|. {\n    complain (loc, complaint, \"%s: %s\",\n              ngettext (\"invalid character\", \"invalid characters\", yyleng),\n              quote_mem (yytext, yyleng));\n    return GRAM_error;\n  }\n\n  <<EOF>> {\n    loc->start = loc->end = scanner_cursor;\n    yyterminate ();\n  }\n}\n\n\n  /*--------------------------------------------------------------.\n  | Supporting \\0 complexifies our implementation for no expected |\n  | added value.                                                  |\n  `--------------------------------------------------------------*/\n\n<SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING,SC_TAG>\n{\n  \\0         {\n    complain (loc, complaint, _(\"invalid null character\"));\n    STRING_FINISH ();\n    STRING_FREE ();\n    return GRAM_error;\n  }\n}\n\n\n  /*-----------------------------------------------------------------.\n  | Scanning after an identifier, checking whether a colon is next.  |\n  `-----------------------------------------------------------------*/\n\n<SC_AFTER_IDENTIFIER>\n{\n  \"[\" {\n    if (bracketed_id_str)\n      {\n        ROLLBACK_CURRENT_TOKEN;\n        BEGIN SC_RETURN_BRACKETED_ID;\n        *loc = id_loc;\n        return ID;\n      }\n    else\n      {\n        bracketed_id_start = loc->start;\n        bracketed_id_context_state = YY_START;\n        BEGIN SC_BRACKETED_ID;\n      }\n  }\n  \":\" {\n    ROLLBACK_CURRENT_TOKEN;\n    BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);\n    *loc = id_loc;\n    return ID_COLON;\n  }\n  . {\n    ROLLBACK_CURRENT_TOKEN;\n    BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);\n    *loc = id_loc;\n    return ID;\n  }\n  <<EOF>> {\n    BEGIN (bracketed_id_str ? SC_RETURN_BRACKETED_ID : INITIAL);\n    *loc = id_loc;\n    return ID;\n  }\n}\n\n  /*--------------------------------.\n  | Scanning bracketed identifiers. |\n  `--------------------------------*/\n\n<SC_BRACKETED_ID>\n{\n  {id} {\n    if (bracketed_id_str)\n      {\n        complain (loc, complaint,\n                  _(\"unexpected identifier in bracketed name: %s\"),\n                  quote (yytext));\n        return GRAM_error;\n      }\n    else\n      {\n        bracketed_id_str = uniqstr_new (yytext);\n        bracketed_id_loc = *loc;\n      }\n  }\n  \"]\" {\n    BEGIN bracketed_id_context_state;\n    if (bracketed_id_str)\n      {\n        if (INITIAL == bracketed_id_context_state)\n          {\n            val->BRACKETED_ID = bracketed_id_str;\n            bracketed_id_str = 0;\n            *loc = bracketed_id_loc;\n            return BRACKETED_ID;\n          }\n      }\n    else\n      {\n        complain (loc, complaint, _(\"an identifier expected\"));\n        return GRAM_error;\n      }\n  }\n\n  [^\\].A-Za-z0-9_/ \\f\\r\\n\\t\\v]+|. {\n    complain (loc, complaint, \"%s: %s\",\n              ngettext (\"invalid character in bracketed name\",\n                        \"invalid characters in bracketed name\", yyleng),\n              quote_mem (yytext, yyleng));\n    return GRAM_error;\n  }\n\n  <<EOF>> {\n    BEGIN bracketed_id_context_state;\n    unexpected_eof (bracketed_id_start, \"]\");\n  }\n}\n\n<SC_RETURN_BRACKETED_ID>\n{\n  . {\n    ROLLBACK_CURRENT_TOKEN;\n    val->BRACKETED_ID = bracketed_id_str;\n    bracketed_id_str = 0;\n    *loc = bracketed_id_loc;\n    BEGIN INITIAL;\n    return BRACKETED_ID;\n  }\n}\n\n\n  /*---------------------------------------------------------------.\n  | Scanning a Yacc comment.  The initial '/ *' is already eaten.  |\n  `---------------------------------------------------------------*/\n\n<SC_YACC_COMMENT>\n{\n  \"*/\"     BEGIN context_state;\n  .|{eol}  continue;\n  <<EOF>>  unexpected_eof (token_start, \"*/\"); BEGIN context_state;\n}\n\n\n  /*------------------------------------------------------------.\n  | Scanning a C comment.  The initial '/ *' is already eaten.  |\n  `------------------------------------------------------------*/\n\n<SC_COMMENT>\n{\n  \"*\"{splice}\"/\"  STRING_GROW (); BEGIN context_state;\n  <<EOF>>         unexpected_eof (token_start, \"*/\"); BEGIN context_state;\n}\n\n\n  /*--------------------------------------------------------------.\n  | Scanning a line comment.  The initial '//' is already eaten.  |\n  `--------------------------------------------------------------*/\n\n<SC_LINE_COMMENT>\n{\n  {eol}          STRING_GROW (); BEGIN context_state;\n  {splice}       STRING_GROW ();\n  <<EOF>>        BEGIN context_state;\n}\n\n\n  /*------------------------------------------------.\n  | Scanning a Bison string, including its escapes. |\n  | The initial quote is already eaten.             |\n  `------------------------------------------------*/\n\n<SC_ESCAPED_STRING>\n{\n  \"\\\"\" {\n    STRING_1GROW ('\"');\n    STRING_FINISH ();\n    BEGIN INITIAL;\n    loc->start = token_start;\n    complain (loc, Wyacc,\n              _(\"POSIX Yacc does not support string literals\"));\n    RETURN_VALUE (STRING, last_string);\n  }\n}\n\n<SC_ESCAPED_TSTRING>\n{\n  \"\\\")\" {\n    STRING_1GROW ('\"');\n    STRING_FINISH ();\n    BEGIN INITIAL;\n    loc->start = token_start;\n    complain (loc, Wyacc,\n              _(\"POSIX Yacc does not support string literals\"));\n    RETURN_VALUE (TSTRING, last_string);\n  }\n}\n\n<SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>\n{\n  <<EOF>>   unexpected_eof (token_start, \"\\\"\");\n  \"\\n\"      unexpected_newline (token_start, \"\\\"\");\n}\n\n\n  /*----------------------------------------------------------.\n  | Scanning a Bison character literal, decoding its escapes. |\n  | The initial quote is already eaten.                       |\n  `----------------------------------------------------------*/\n\n<SC_ESCAPED_CHARACTER>\n{\n  \"'\" {\n    STRING_FINISH ();\n    BEGIN INITIAL;\n    loc->start = token_start;\n\n    if (last_string[0] == '\\0')\n      {\n        complain (loc, complaint, _(\"empty character literal\"));\n        STRING_FREE ();\n        return GRAM_error;\n      }\n    else if (last_string[1] != '\\0')\n      {\n        complain (loc, complaint, _(\"extra characters in character literal\"));\n        STRING_FREE ();\n        return GRAM_error;\n      }\n    else\n      {\n        val->CHAR = last_string[0];\n        STRING_FREE ();\n        return CHAR;\n      }\n  }\n  {eol}     unexpected_newline (token_start, \"'\");\n  <<EOF>>   unexpected_eof (token_start, \"'\");\n}\n\n\n\n  /*--------------------------------------------------------------.\n  | Scanning a tag.  The initial angle bracket is already eaten.  |\n  `--------------------------------------------------------------*/\n\n<SC_TAG>\n{\n  \">\" {\n    --nesting;\n    if (nesting < 0)\n      {\n        STRING_FINISH ();\n        loc->start = token_start;\n        val->TAG = uniqstr_new (last_string);\n        STRING_FREE ();\n        BEGIN INITIAL;\n        return TAG;\n      }\n    STRING_GROW ();\n  }\n\n  ([^<>]|->)+ STRING_GROW ();\n  \"<\"+   STRING_GROW (); nesting += yyleng;\n\n  <<EOF>>   unexpected_eof (token_start, \">\");\n}\n\n  /*----------------------------.\n  | Decode escaped characters.  |\n  `----------------------------*/\n\n<SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>\n{\n  \\\\[0-7]{1,3} {\n    STRING_GROW_ESCAPE (strtol (yytext + 1, NULL, 8));\n  }\n\n  \\\\x[0-9abcdefABCDEF]+ {\n    STRING_GROW_ESCAPE (strtol (yytext + 2, NULL, 16));\n  }\n\n  \\\\a   STRING_GROW_ESCAPE ('\\a');\n  \\\\b   STRING_GROW_ESCAPE ('\\b');\n  \\\\f   STRING_GROW_ESCAPE ('\\f');\n  \\\\n   STRING_GROW_ESCAPE ('\\n');\n  \\\\r   STRING_GROW_ESCAPE ('\\r');\n  \\\\t   STRING_GROW_ESCAPE ('\\t');\n  \\\\v   STRING_GROW_ESCAPE ('\\v');\n\n  /* \\\\[\\\"\\'?\\\\] would be shorter, but it confuses xgettext.  */\n  \\\\(\"\\\"\"|\"'\"|\"?\"|\"\\\\\")  STRING_GROW_ESCAPE (yytext[1]);\n\n  \\\\(u|U[0-9abcdefABCDEF]{4})[0-9abcdefABCDEF]{4} {\n    STRING_GROW_ESCAPE (convert_ucn_to_byte (yytext));\n  }\n\n  \\\\(.|{eol})      {\n    char const *p = yytext + 1;\n    /* Quote only if escaping won't make the character visible.  */\n    if (c_isspace ((unsigned char) *p) && c_isprint ((unsigned char) *p))\n      p = quote (p);\n    else\n      p = quotearg_style_mem (escape_quoting_style, p, 1);\n    complain (loc, complaint, _(\"invalid character after \\\\-escape: %s\"),\n              p);\n    STRING_1GROW ('?');\n  }\n}\n\n  /*--------------------------------------------.\n  | Scanning user-code characters and strings.  |\n  `--------------------------------------------*/\n\n<SC_CHARACTER,SC_STRING>\n{\n  {splice}|\\\\{splice}[^\\n\\[\\]]  STRING_GROW ();\n}\n\n<SC_CHARACTER>\n{\n  \"'\"           STRING_GROW (); BEGIN context_state;\n  {eol}         unexpected_newline (token_start, \"'\");\n  <<EOF>>       unexpected_eof (token_start, \"'\");\n}\n\n<SC_STRING>\n{\n  \"\\\"\"          STRING_GROW (); BEGIN context_state;\n  {eol}         unexpected_newline (token_start, \"\\\"\");\n  <<EOF>>       unexpected_eof (token_start, \"\\\"\");\n}\n\n\n  /*---------------------------------------------------.\n  | Strings, comments etc. can be found in user code.  |\n  `---------------------------------------------------*/\n\n<SC_BRACED_CODE,SC_PROLOGUE,SC_EPILOGUE,SC_PREDICATE>\n{\n  \"'\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    token_start = loc->start;\n    BEGIN SC_CHARACTER;\n  }\n  \"\\\"\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    token_start = loc->start;\n    BEGIN SC_STRING;\n  }\n  \"/\"{splice}\"*\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    token_start = loc->start;\n    BEGIN SC_COMMENT;\n  }\n  \"/\"{splice}\"/\" {\n    STRING_GROW ();\n    context_state = YY_START;\n    BEGIN SC_LINE_COMMENT;\n  }\n}\n\n\n\n  /*-----------------------------------------------------------.\n  | Scanning some code in braces (actions, predicates). The    |\n  | initial \"{\" is already eaten.                              |\n  `-----------------------------------------------------------*/\n\n<SC_BRACED_CODE,SC_PREDICATE>\n{\n  \"{\"|\"<\"{splice}\"%\"  STRING_GROW (); nesting++;\n  \"%\"{splice}\">\"      STRING_GROW (); nesting--;\n\n  /* Tokenize '<<%' correctly (as '<<' '%') rather than incorrectly\n     (as '<' '<%').  */\n  \"<\"{splice}\"<\"  STRING_GROW ();\n\n  <<EOF>>   unexpected_eof (code_start, \"}\");\n}\n\n<SC_BRACED_CODE>\n{\n  \"}\" {\n    STRING_1GROW ('}');\n\n    --nesting;\n    if (nesting < 0)\n      {\n        STRING_FINISH ();\n        loc->start = code_start;\n        BEGIN INITIAL;\n        RETURN_VALUE (BRACED_CODE, last_string);\n      }\n  }\n}\n\n<SC_PREDICATE>\n{\n  \"}\" {\n    --nesting;\n    if (nesting < 0)\n      {\n        STRING_FINISH ();\n        loc->start = code_start;\n        BEGIN INITIAL;\n        RETURN_VALUE (BRACED_PREDICATE, last_string);\n      }\n    else\n      STRING_1GROW ('}');\n  }\n}\n\n  /*--------------------------------------------------------------.\n  | Scanning some prologue: from \"%{\" (already scanned) to \"%}\".  |\n  `--------------------------------------------------------------*/\n\n<SC_PROLOGUE>\n{\n  \"%}\" {\n    STRING_FINISH ();\n    loc->start = code_start;\n    BEGIN INITIAL;\n    RETURN_VALUE (PROLOGUE, last_string);\n  }\n\n  <<EOF>>   unexpected_eof (code_start, \"%}\");\n}\n\n\n  /*---------------------------------------------------------------.\n  | Scanning the epilogue (everything after the second \"%%\", which |\n  | has already been eaten).                                       |\n  `---------------------------------------------------------------*/\n\n<SC_EPILOGUE>\n{\n  <<EOF>> {\n    STRING_FINISH ();\n    loc->start = code_start;\n    BEGIN INITIAL;\n    RETURN_VALUE (EPILOGUE, last_string);\n  }\n}\n\n\n  /*-----------------------------------------------------.\n  | By default, grow the string obstack with the input.  |\n  `-----------------------------------------------------*/\n\n<SC_COMMENT,SC_LINE_COMMENT,SC_BRACED_CODE,SC_PREDICATE,SC_PROLOGUE,SC_EPILOGUE,SC_STRING,SC_CHARACTER,SC_ESCAPED_CHARACTER,SC_ESCAPED_STRING,SC_ESCAPED_TSTRING>\n{\n  /* Accept multibyte characters in one block instead of byte after\n     byte, so that add_column_width and mbsnwidth can compute correct\n     screen width.\n\n     Add a fallthrough \"|.\" so that non UTF-8 input is still accepted\n     and does not jam the scanner.  */\n  {mbchar}|.   STRING_GROW ();\n}\n\n%%\n\n\n/*------------------------------------------------------.\n| Scan NUMBER for a base-BASE integer at location LOC.  |\n`------------------------------------------------------*/\n\nstatic int\nscan_integer (char const *number, int base, location loc)\n{\n  verify (INT_MAX < ULONG_MAX);\n  if (base == 16)\n    complain (&loc, Wyacc,\n              _(\"POSIX Yacc does not support hexadecimal literals\"));\n\n  errno = 0;\n  long num = strtol (number, NULL, base);\n\n  if (! (0 <= num && num <= INT_MAX && errno == 0))\n    {\n      complain (&loc, complaint, _(\"integer out of range: %s\"),\n                quote (number));\n      num = INT_MAX;\n    }\n\n  return num;\n}\n\n\n/*------------------------------------------------------------------.\n| Convert universal character name UCN to a single-byte character,  |\n| and return that character.  Return -1 if UCN does not correspond  |\n| to a single-byte character.                                       |\n`------------------------------------------------------------------*/\n\nstatic int\nconvert_ucn_to_byte (char const *ucn)\n{\n  verify (UCHAR_MAX <= INT_MAX);\n  long code = strtol (ucn + 2, NULL, 16);\n\n  /* FIXME: Currently we assume Unicode-compatible unibyte characters\n     on ASCII hosts (i.e., Latin-1 on hosts with 8-bit bytes).  On\n     non-ASCII hosts we support only the portable C character set.\n     These limitations should be removed once we add support for\n     multibyte characters.  */\n\n  if (! (0 <= code && code <= UCHAR_MAX))\n    return -1;\n\n#if ! ('$' == 0x24 && '@' == 0x40 && '`' == 0x60 && '~' == 0x7e)\n  {\n    /* A non-ASCII host.  Use CODE to index into a table of the C\n       basic execution character set, which is guaranteed to exist on\n       all Standard C platforms.  This table also includes '$', '@',\n       and '`', which are not in the basic execution character set but\n       which are unibyte characters on all the platforms that we know\n       about.  */\n    static signed char const table[] =\n      {\n        '\\0',   -1,   -1,   -1,   -1,   -1,   -1, '\\a',\n        '\\b', '\\t', '\\n', '\\v', '\\f', '\\r',   -1,   -1,\n          -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n          -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,\n         ' ',  '!',  '\"',  '#',  '$',  '%',  '&', '\\'',\n         '(',  ')',  '*',  '+',  ',',  '-',  '.',  '/',\n         '0',  '1',  '2',  '3',  '4',  '5',  '6',  '7',\n         '8',  '9',  ':',  ';',  '<',  '=',  '>',  '?',\n         '@',  'A',  'B',  'C',  'D',  'E',  'F',  'G',\n         'H',  'I',  'J',  'K',  'L',  'M',  'N',  'O',\n         'P',  'Q',  'R',  'S',  'T',  'U',  'V',  'W',\n         'X',  'Y',  'Z',  '[', '\\\\',  ']',  '^',  '_',\n         '`',  'a',  'b',  'c',  'd',  'e',  'f',  'g',\n         'h',  'i',  'j',  'k',  'l',  'm',  'n',  'o',\n         'p',  'q',  'r',  's',  't',  'u',  'v',  'w',\n         'x',  'y',  'z',  '{',  '|',  '}',  '~'\n      };\n\n    code = code < sizeof table ? table[code] : -1;\n  }\n#endif\n\n  return code;\n}\n\n\n/*---------------------------------------------------------------------.\n| Handle '#line INT( \"FILE\")?\\n'.  ARGS has already skipped '#line '.  |\n`---------------------------------------------------------------------*/\n\nstatic void\nhandle_syncline (char *args, location loc)\n{\n  char *file;\n  errno = 0;\n  long lineno = strtol (args, &file, 10);\n  if (! (0 <= lineno && lineno <= INT_MAX && errno == 0))\n    {\n      complain (&loc, Wother, _(\"line number overflow\"));\n      lineno = INT_MAX;\n    }\n\n  file = strchr (file, '\"');\n  if (file)\n    {\n      *strchr (file + 1, '\"') = '\\0';\n      current_file = uniqstr_new (file + 1);\n    }\n  boundary_set (&scanner_cursor, current_file, lineno, 1, 1);\n}\n\n\n/*----------------------------------------------------------------.\n| For a token or comment starting at START, report message MSGID, |\n| which should say that an end marker was found before the        |\n| expected TOKEN_END. Then, pretend that TOKEN_END was found.     |\n`----------------------------------------------------------------*/\n\nstatic void\nunexpected_end (boundary start, char const *msgid, char const *token_end)\n{\n  location loc;\n  loc.start = start;\n  loc.end = scanner_cursor;\n  size_t i = strlen (token_end);\n\n  /* Adjust scanner cursor so that any later message does not count\n     the characters about to be inserted.  */\n  scanner_cursor.column -= i;\n  scanner_cursor.byte -= i;\n\n  while (i != 0)\n    unput (token_end[--i]);\n\n  token_end = quote (token_end);\n  /* Instead of '\\'', display \"'\".  */\n  if (STREQ (token_end, \"'\\\\''\"))\n    token_end = \"\\\"'\\\"\";\n  complain (&loc, complaint, msgid, token_end);\n}\n\n\n/*------------------------------------------------------------------------.\n| Report an unexpected EOF in a token or comment starting at START.       |\n| An end of file was encountered and the expected TOKEN_END was missing.  |\n| After reporting the problem, pretend that TOKEN_END was found.          |\n`------------------------------------------------------------------------*/\n\nstatic void\nunexpected_eof (boundary start, char const *token_end)\n{\n  unexpected_end (start, _(\"missing %s at end of file\"), token_end);\n}\n\n\n/*----------------------------------------.\n| Likewise, but for unexpected newlines.  |\n`----------------------------------------*/\n\nstatic void\nunexpected_newline (boundary start, char const *token_end)\n{\n  unexpected_end (start, _(\"missing %s at end of line\"), token_end);\n}\n\n\nvoid\ngram_scanner_open (const char *gram)\n{\n  gram__flex_debug = trace_flag & trace_scan;\n  gram_debug = trace_flag & trace_parse;\n  obstack_init (&obstack_for_string);\n  current_file = gram;\n  gram_in = xfopen (gram, \"r\");\n}\n\n\nvoid\ngram_scanner_close (void)\n{\n  xfclose (gram_in);\n  /* Reclaim Flex's buffers.  */\n  yylex_destroy ();\n}\n\n\nvoid\ngram_scanner_free (void)\n{\n  obstack_free (&obstack_for_string, 0);\n}\n", "# Checking the Bison reader.                    -*- Autotest -*-\n\n# Copyright (C) 2002-2015, 2018-2020 Free Software Foundation, Inc.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAT_BANNER([[Input Processing.]])\n\n# Mostly test that we are robust to mistakes.\n\n\n## ----------------------------- ##\n## Invalid number of arguments.  ##\n## ----------------------------- ##\n\nAT_SETUP([Invalid number of arguments])\n\nAT_BISON_CHECK([], [1], [],\n[[bison: missing operand\nTry 'bison --help' for more information.\n]])\n\nAT_BISON_CHECK([1.y 2.y], [1], [],\n[[bison: extra operand '2.y'\nTry 'bison --help' for more information.\n]])\n\n# For some reason, on some systems we use the system's getopt, not the\n# one we ship in gnulib.  So we can get two different error messages.\n# See https://lists.gnu.org/archive/html/bison-patches/2018-10/msg00154.html\nAT_BISON_CHECK([--skeleton], [1], [], [stderr])\nAT_CHECK([[sed -e \\\n  \"s/requires an argument -- skeleton/'--skeleton' requires an argument/\" \\\n  stderr]], 0,\n[[bison: option '--skeleton' requires an argument\nTry 'bison --help' for more information.\n]])\n\nAT_CLEANUP\n\n\n\n## ----------------- ##\n## Invalid options.  ##\n## ----------------- ##\n\nAT_SETUP([Invalid options])\n\nAT_DATA([input.y],\n[[%%\nexp: '0'\n]])\n\n# We used to accept these, as -f, --report and others were sharing\n# their code with -W.\nAT_BISON_CHECK([-ferror=caret input.y], [1], [], [ignore])\nAT_BISON_CHECK([--report=error=itemsets input.y], [1], [], [ignore])\n\n# We used to accept any character after \"-Werror\", instead of ensuring\n# this is \"=\".\nAT_BISON_CHECK([-Werror?all input.y], [1], [], [ignore])\n\nAT_CLEANUP\n\n\n## ---------------- ##\n## Invalid inputs.  ##\n## ---------------- ##\n\n# The truly bad guys no human would write, but easily uncovered by\n# fuzzers.\nAT_SETUP([Invalid inputs])\n\nAT_DATA([input.y],\n[[\\000\\001\\002\\377?\n\"\\000\"\n%%\n?\ndefault: 'a' }\n%&\n%a-does-not-exist\n%-\n%{\n]])\nAT_PERL_REQUIRE([[-pi -e 's/\\\\(\\d{3})/chr(oct($1))/ge' input.y]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [], [stderr])\n\n# Autotest's diffing, when there are NUL bytes, just reports \"binary\n# files differ\".  So don't leave NUL bytes.\nAT_PERL_CHECK([[-p -e 's{([\\0\\377])}{sprintf \"\\\\x%02x\", ord($1)}ge' stderr]], [],\n[[input.y:1.1-2: error: invalid characters: '\\0\\001\\002\\377?'\n    1 | \\x00\u0001\u0002\\xff?\n      | ^~\ninput.y:2.2: error: invalid null character\n    2 | \"\\x00\"\n      |  ^\ninput.y:4.1: error: invalid character: '?'\n    4 | ?\n      | ^\ninput.y:5.14: error: invalid character: '}'\n    5 | default: 'a' }\n      |              ^\ninput.y:6.1: error: invalid character: '%'\n    6 | %&\n      | ^\ninput.y:6.2: error: invalid character: '&'\n    6 | %&\n      |  ^\ninput.y:7.1-17: error: invalid directive: '%a-does-not-exist'\n    7 | %a-does-not-exist\n      | ^~~~~~~~~~~~~~~~~\ninput.y:8.1: error: invalid character: '%'\n    8 | %-\n      | ^\ninput.y:8.2: error: invalid character: '-'\n    8 | %-\n      |  ^\ninput.y:9.1-10.0: error: missing '%}' at end of file\n    9 | %{\n      | ^~\n]])\n\nAT_CLEANUP\n\n\nAT_SETUP([Invalid inputs with {}])\n\n# We used to SEGV here.  See\n# http://lists.gnu.org/archive/html/bug-bison/2005-07/msg00053.html\n\nAT_DATA([input.y],\n[[\n%destructor\n%initial-action\n%lex-param\n%parse-param\n%printer\n%union\n]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:3.1-15: error: expected {...} before %initial-action\n]])\n\nAT_CLEANUP\n\n\n## -------------------------- ##\n## Yacc warnings on symbols.  ##\n## -------------------------- ##\n\nAT_SETUP([Yacc warnings on symbols])\n\nAT_DATA([input.y],\n[[%nterm exp\n%token NUM 0x40 \"number\"\n%%\nexp: \"number\";\n]])\n\nAT_BISON_CHECK([-fcaret -Wyacc input.y], [0], [],\n[[input.y:1.1-6: warning: POSIX Yacc does not support %nterm [-Wyacc]\n    1 | %nterm exp\n      | ^~~~~~\ninput.y:2.12-15: warning: POSIX Yacc does not support hexadecimal literals [-Wyacc]\n    2 | %token NUM 0x40 \"number\"\n      |            ^~~~\ninput.y:2.17-24: warning: POSIX Yacc does not support string literals [-Wyacc]\n    2 | %token NUM 0x40 \"number\"\n      |                 ^~~~~~~~\ninput.y:4.6-13: warning: POSIX Yacc does not support string literals [-Wyacc]\n    4 | exp: \"number\";\n      |      ^~~~~~~~\n]])\n\nAT_CLEANUP\n\n\n## --------------- ##\n## Yacc warnings.  ##\n## --------------- ##\n\nAT_SETUP([Yacc warnings])\n\nAT_DATA([input.y],\n[[%destructor {} <int>\n%printer {} <int>\n%type <int> exp a b\n%%\nexp: a b             { $$ = $1 + $2; };\na: <int>{ $$ = 42; } { $$ = $1; };\nb: %empty            { $$ = 42; };\n]])\n\nAT_BISON_CHECK([-fcaret -Wyacc input.y], [0], [],\n[[input.y:1.1-11: warning: POSIX Yacc does not support %destructor [-Wyacc]\n    1 | %destructor {} <int>\n      | ^~~~~~~~~~~\ninput.y:2.1-8: warning: POSIX Yacc does not support %printer [-Wyacc]\n    2 | %printer {} <int>\n      | ^~~~~~~~\ninput.y:6.9-20: warning: POSIX Yacc does not support typed midrule actions [-Wyacc]\n    6 | a: <int>{ $$ = 42; } { $$ = $1; };\n      |         ^~~~~~~~~~~~\ninput.y:7.4-9: warning: POSIX Yacc does not support %empty [-Wyacc]\n    7 | b: %empty            { $$ = 42; };\n      |    ^~~~~~\n]])\n\nAT_CLEANUP\n\n\n## -------------- ##\n## Yacc's %type.  ##\n## -------------- ##\n\nAT_SETUP([Yacc's %type])\n\nAT_DATA([input.y],\n[[%token TOKEN1\n%nterm nterm1\n%type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n%token TOKEN2\n%nterm nterm2\n%%\nexpr: nterm1 nterm2 nterm3\nnterm1: TOKEN1\nnterm2: TOKEN2\nnterm3: \"TOKEN3\"\n]])\n\nAT_BISON_CHECK([-fcaret -Wyacc input.y], [0], [],\n[[input.y:2.1-6: warning: POSIX Yacc does not support %nterm [-Wyacc]\n    2 | %nterm nterm1\n      | ^~~~~~\ninput.y:3.14-19: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |              ^~~~~~\ninput.y:3.28-35: warning: POSIX Yacc does not support string literals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                            ^~~~~~~~\ninput.y:3.28-35: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                            ^~~~~~~~\ninput.y:3.58-60: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                                                          ^~~\ninput.y:5.1-6: warning: POSIX Yacc does not support %nterm [-Wyacc]\n    5 | %nterm nterm2\n      | ^~~~~~\ninput.y:3.21-26: warning: POSIX yacc reserves %type to nonterminals [-Wyacc]\n    3 | %type <ival> TOKEN1 TOKEN2 \"TOKEN3\" nterm1 nterm2 nterm3 '+'\n      |                     ^~~~~~\ninput.y:10.9-16: warning: POSIX Yacc does not support string literals [-Wyacc]\n   10 | nterm3: \"TOKEN3\"\n      |         ^~~~~~~~\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------- ##\n## Invalid symbol declarations.  ##\n## ----------------------------- ##\n\nAT_SETUP([Invalid symbol declarations])\n\nAT_DATA([input.y],\n[[%nterm expr \"expression\";\n%nterm term 123;\n%nterm fact 124 \"factor\";\n%nterm '+' '*';\n%nterm \"number\";\n%token \"tok1\" 1;\n%left \"tok2\" 2;\n%type \"tok3\" 3;\n%%\nexpr: expr '+' term | term;\nterm: term '*' fact | fact;\nfact: \"number\";\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:1.13-24: error: nonterminals cannot be given a string alias\n    1 | %nterm expr \"expression\";\n      |             ^~~~~~~~~~~~\ninput.y:2.13-15: error: nonterminals cannot be given a token code\n    2 | %nterm term 123;\n      |             ^~~\ninput.y:3.13-15: error: nonterminals cannot be given a token code\n    3 | %nterm fact 124 \"factor\";\n      |             ^~~\ninput.y:3.17-24: error: nonterminals cannot be given a string alias\n    3 | %nterm fact 124 \"factor\";\n      |                 ^~~~~~~~\ninput.y:4.8-10: error: character literals cannot be nonterminals\n    4 | %nterm '+' '*';\n      |        ^~~\ninput.y:5.8-15: error: expected character literal or identifier or <tag> before string\n    5 | %nterm \"number\";\n      |        ^~~~~~~~\ninput.y:6.8-13: error: expected character literal or identifier or <tag> before string\n    6 | %token \"tok1\" 1;\n      |        ^~~~~~\ninput.y:7.14: error: unexpected integer literal\n    7 | %left \"tok2\" 2;\n      |              ^\ninput.y:8.14: error: unexpected integer literal\n    8 | %type \"tok3\" 3;\n      |              ^\n]])\n\nAT_CLEANUP\n\n\n## ---------------------------- ##\n## Redefining the error token.  ##\n## ---------------------------- ##\n\nAT_SETUP([Redefining the error token])\n\n# We used to crash when trying to display the original definition of\n# \"error\", which is a builtin without any location.\nAT_BISON_OPTION_PUSHDEFS\n\nAT_DATA([input.y],\n[[%token error 123\n%token error 124\n%%\nexp:\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.8-12: warning: symbol error redeclared [-Wother]\n    2 | %token error 124\n      |        ^~~~~\ninput.y:1.8-12: note: previous declaration\n    1 | %token error 123\n      |        ^~~~~\ninput.y:2.14-16: error: redefining code of token error\n    2 | %token error 124\n      |              ^~~\n]])\n\n# While at it, make sure we properly used the user's number for\n# \"error\".  I don't see what it buys us, but...\nAT_DATA([input.y],\n[[%{\n#include <assert.h>\n#include <stdio.h>\n]AT_YYERROR_DEFINE[\n]AT_YYLEX_DEFINE[\n%}\n\n%token error 123\n%%\nexp:\n%%\nint main (void)\n{\n  assert (YYerror == 123);\n  assert (YYTRANSLATE (YYEOF) == YYSYMBOL_YYEOF);\n  assert (YYTRANSLATE (YYerror) == YYSYMBOL_YYerror);\n  assert (YYTRANSLATE (YYUNDEF) == YYSYMBOL_YYUNDEF);\n  return 0;\n}\n]])\n\nAT_FULL_COMPILE([input])\nAT_PARSER_CHECK([input], 0)\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ------------------ ##\n## Dangling aliases.  ##\n## ------------------ ##\n\nAT_SETUP([Dangling aliases])\n\nAT_DATA([input.y],\n[[%token FOO \"foo\"\n%type <val> \"bar\"\n%%\nexpr: \"foo\" \"bar\" \"baz\"\n]])\n\nAT_BISON_CHECK([-fcaret -Wdangling input.y], [0], [],\n[[input.y:2.13-17: warning: string literal \"bar\" not attached to a symbol [-Wdangling-alias]\n    2 | %type <val> \"bar\"\n      |             ^~~~~\ninput.y:4.19-23: warning: string literal \"baz\" not attached to a symbol [-Wdangling-alias]\n    4 | expr: \"foo\" \"bar\" \"baz\"\n      |                   ^~~~~\n]])\n\nAT_CLEANUP\n\n\n## --------------------- ##\n## Symbol declarations.  ##\n## --------------------- ##\n\n# Check the parsing of %token, %nterm, %type and %left...\nAT_SETUP([Symbol declarations])\n\nAT_DATA([dump-symbols.m4],\n[[m4@&t@_define([b4_api_PREFIX], [YY])\n\nm4@&t@_define([b4_symbol_dump],\n[$1, d@&t@nl\nb4_symbol_if([$1], [is_token], [Token], [Nonterminal]), d@&t@nl\nb4_symbol([$1], [tag]), d@&t@nl\nb4_symbol([$1], [id]), d@&t@nl\nb4_symbol([$1], [code]), d@&t@nl\nb4_symbol([$1], [type]),\n])\n\nb4_output_begin([symbols.csv])\nnumber, class, tag, id, code, type,\nb4_symbol_foreach([b4_symbol_dump])d@&t@nl\nb4_output_end\n]])\n\nAT_DATA([input.y],\n[[%token 'a' A1 1 \"A1\" A2 A3 \"A3\" A4 4\n      <type_b> 'b' B5 5 \"B5\" B6 B7 \"B8\" B9 9\n      <type_c> 'c' C10 10 \"C10\" C11 C12 \"C12\" C13 13\n\n%left 'd' D20 20 \"D20\" D21 D22 \"D22\" D23 23\n      <type_e> 'e' E25 25 \"E25\" E26 E27 \"E28\" E29 29\n      <type_f> 'f' F30 30 \"F30\" F31 F32 \"F32\" F33 33\n\n%type 'g' G40 \"D40\" G21 G22 G23\n      <type_h> 'h' H25 \"H25\" H26 H27 \"H28\" H29\n      <type_i> 'i' I30 \"I30\" I31 I32 \"I32\" I33\n\n%nterm j60 j61 j62 j63\n      <type_k> k75 k76 k77 k79\n      <type_l> l80 l81 l82 l83\n%%\nexp:;\n]])\n\nAT_BISON_CHECK([-Wno-other -S./dump-symbols.m4 input.y])\nAT_CHECK([cat symbols.csv], [],\n[[number, class, tag, id, code, type,\n0, Token, \"end of file\", YYEOF, 0, ,\n1, Token, error, YYerror, 256, ,\n2, Token, \"invalid token\", YYUNDEF, 257, ,\n3, Token, 'a', , 97, ,\n4, Token, \"A1\", A1, 1, ,\n5, Token, A2, A2, 258, ,\n6, Token, \"A3\", A3, 259, ,\n7, Token, A4, A4, 4, ,\n8, Token, 'b', , 98, type_b,\n9, Token, \"B5\", B5, 5, type_b,\n10, Token, B6, B6, 260, type_b,\n11, Token, \"B8\", B7, 261, type_b,\n12, Token, B9, B9, 9, type_b,\n13, Token, 'c', , 99, type_c,\n14, Token, \"C10\", C10, 10, type_c,\n15, Token, C11, C11, 262, type_c,\n16, Token, \"C12\", C12, 263, type_c,\n17, Token, C13, C13, 13, type_c,\n18, Token, 'd', , 100, ,\n19, Token, D20, D20, 20, ,\n20, Token, \"D20\", , 264, ,\n21, Token, D21, D21, 265, ,\n22, Token, D22, D22, 266, ,\n23, Token, \"D22\", , 267, ,\n24, Token, D23, D23, 23, ,\n25, Token, 'e', , 101, type_e,\n26, Token, E25, E25, 25, type_e,\n27, Token, \"E25\", , 268, type_e,\n28, Token, E26, E26, 269, type_e,\n29, Token, E27, E27, 270, type_e,\n30, Token, \"E28\", , 271, type_e,\n31, Token, E29, E29, 29, type_e,\n32, Token, 'f', , 102, type_f,\n33, Token, F30, F30, 30, type_f,\n34, Token, \"F30\", , 272, type_f,\n35, Token, F31, F31, 273, type_f,\n36, Token, F32, F32, 274, type_f,\n37, Token, \"F32\", , 275, type_f,\n38, Token, F33, F33, 33, type_f,\n39, Token, 'g', , 103, ,\n40, Token, \"D40\", , 276, ,\n41, Token, 'h', , 104, type_h,\n42, Token, \"H25\", , 277, type_h,\n43, Token, \"H28\", , 278, type_h,\n44, Token, 'i', , 105, type_i,\n45, Token, \"I30\", , 279, type_i,\n46, Token, \"I32\", , 280, type_i,\n47, Nonterminal, $accept, , -1, ,\n48, Nonterminal, exp, exp, -1, ,\n]])\n\nAT_CLEANUP\n\n\n## ------------ ##\n## Invalid $n.  ##\n## ------------ ##\n\nAT_SETUP([Invalid $n and @n])\n\nAT_DATA([input.y],\n[[%%\nexp: %empty { $$ = $1 ; };\nexp: %empty { @$ = @1 ; };\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.20-21: error: integer out of range: '$1'\n    2 | exp: %empty { $$ = $1 ; };\n      |                    ^~\ninput.y:3.20-21: error: integer out of range: '@1'\n    3 | exp: %empty { @$ = @1 ; };\n      |                    ^~\n]])\n\nAT_CLEANUP\n\n\n## -------------- ##\n## Type Clashes.  ##\n## -------------- ##\n\nAT_SETUP([Type Clashes])\n\nAT_DATA([input.y],\n[[%union { int bar; }\n%token foo\n%type <bar> exp\n%%\nexp: foo { $$; } foo { $2; } foo\n   | foo\n   | %empty\n   ;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:5.12-13: error: $$ for the midrule at $2 of 'exp' has no declared type\n    5 | exp: foo { $$; } foo { $2; } foo\n      |            ^~\ninput.y:5.24-25: error: $2 of 'exp' has no declared type\n    5 | exp: foo { $$; } foo { $2; } foo\n      |                        ^~\ninput.y:5.6-32: warning: type clash on default action: <bar> != <> [-Wother]\n    5 | exp: foo { $$; } foo { $2; } foo\n      |      ^~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:6.6-8: warning: type clash on default action: <bar> != <> [-Wother]\n    6 |    | foo\n      |      ^~~\ninput.y:7.6-11: warning: empty rule for typed nonterminal, and no action [-Wother]\n    7 |    | %empty\n      |      ^~~~~~\n]])\n\nAT_CLEANUP\n\n\n# _AT_UNUSED_VALUES_DECLARATIONS()\n# --------------------------------\n# Generate the token, type, and destructor\n# declarations for the unused values tests.\nm4_define([_AT_UNUSED_VALUES_DECLARATIONS],\n[[[%token <integer> INT;\n%type <integer> a b c d e f g h i j k l m n o;\n%destructor { destroy ($$); } <integer>;]]])\n\n\n# AT_CHECK_UNUSED_VALUES(DECLARATIONS_AFTER, CHECK_MIDRULE_VALUES)\n# ----------------------------------------------------------------\n# Generate a grammar to test unused values, and compile it.  If\n# DECLARATIONS_AFTER is set, then the token, type, and destructor\n# declarations are generated after the rules rather than before.  If\n# CHECK_MIDRULE_VALUES is set, then --warnings=midrule-values is set.\nm4_define([AT_CHECK_UNUSED_VALUES],\n[AT_DATA([input.y],\nm4_ifval([$1], [\n\n\n], [_AT_UNUSED_VALUES_DECLARATIONS\n])[[%%\nstart:\n  'a' a { $][2; } | 'b' b { $][2; } | 'c' c { $][2; } | 'd' d { $][2; }\n| 'e' e { $][2; } | 'f' f { $][2; } | 'g' g { $][2; } | 'h' h { $][2; }\n| 'i' i { $][2; } | 'j' j { $][2; } | 'k' k { $][2; } | 'l' l { $][2; }\n| 'm' m { $][2; } | 'n' n { $][2; } | 'o' o { $][2; }\n;\n\na: INT | INT { } INT { } INT { };\nb: INT | %empty;\nc: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\nd: INT | INT { } INT { $][1; } INT { $<integer>2; };\ne: INT | INT { } INT {  } INT { $][1; };\nf: INT | INT { } INT {  } INT { $][$ = $][1 + $][3 + $][5; };\ng: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\nh: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\ni: INT | INT INT { } { $][$ = $][1 + $][2; };\nj: INT | INT INT { $<integer>$ = 1; } { $][$ = $][1 + $][2; };\nk: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\nl: INT | INT { $<integer>$ = $<integer>1; } INT { $<integer>$ = $<integer>2 + $<integer>3; } INT { $<integer>$ = $<integer>4 + $<integer>5; };\nm: INT | INT <integer>{ $][$ = $][1; } INT <integer>{ $][$ = $][2 + $][3; } INT { $][$ = $][4 + $][5; };\nn: INT | INT <integer>{ } INT <integer>{ } INT { };\no: INT | INT <integer>{ } INT <integer>{ } INT { $][$ = $][1 + $][2 + $][3 + $][4 + $][5; };\n]]m4_ifval([$1], [\n_AT_UNUSED_VALUES_DECLARATIONS])\n)\n\nAT_BISON_CHECK(m4_ifval([$2], [--warnings=midrule-values ])[-fcaret input.y],\n               [0], [],\n[[input.y:12.10-32: warning: unset value: $][$ [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~\ninput.y:12.10-12: warning: unused value: $][1 [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |          ^~~\ninput.y:12.18-20: warning: unused value: $][3 [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |                  ^~~\ninput.y:12.26-28: warning: unused value: $][5 [-Wother]\n   12 | a: INT | INT { } INT { } INT { };\n      |                          ^~~\ninput.y:13.10-15: warning: empty rule for typed nonterminal, and no action [-Wother]\n   13 | b: INT | %empty;\n      |          ^~~~~~\n]]m4_ifval([$2], [[[input.y:14.14-20: warning: unset value: $][$ [-Wmidrule-values]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |              ^~~~~~~\ninput.y:14.26-41: warning: unset value: $][$ [-Wmidrule-values]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |                          ^~~~~~~~~~~~~~~~\n]]])[[input.y:14.10-62: warning: unset value: $][$ [-Wother]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:14.22-24: warning: unused value: $][3 [-Wother]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |                      ^~~\ninput.y:14.43-45: warning: unused value: $][5 [-Wother]\n   14 | c: INT | INT { $][1; } INT { $<integer>2; } INT { $<integer>4; };\n      |                                           ^~~\n]]m4_ifval([$2], [[[input.y:15.14-16: warning: unset value: $][$ [-Wmidrule-values]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |              ^~~\n]]])[[input.y:15.10-49: warning: unset value: $][$ [-Wother]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:15.18-20: warning: unused value: $][3 [-Wother]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |                  ^~~\ninput.y:15.30-32: warning: unused value: $][5 [-Wother]\n   15 | d: INT | INT { } INT { $][1; } INT { $<integer>2; };\n      |                              ^~~\ninput.y:16.10-37: warning: unset value: $][$ [-Wother]\n   16 | e: INT | INT { } INT {  } INT { $][1; };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:16.18-20: warning: unused value: $][3 [-Wother]\n   16 | e: INT | INT { } INT {  } INT { $][1; };\n      |                  ^~~\ninput.y:16.27-29: warning: unused value: $][5 [-Wother]\n   16 | e: INT | INT { } INT {  } INT { $][1; };\n      |                           ^~~\ninput.y:18.10-58: warning: unset value: $][$ [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:18.10-12: warning: unused value: $][1 [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |          ^~~\n]]m4_ifval([$2], [[[input.y:18.14-29: warning: unused value: $][2 [-Wmidrule-values]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |              ^~~~~~~~~~~~~~~~\n]]])[[input.y:18.31-33: warning: unused value: $][3 [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |                               ^~~\n]]m4_ifval([$2], [[[input.y:18.35-50: warning: unused value: $][4 [-Wmidrule-values]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |                                   ^~~~~~~~~~~~~~~~\n]]])[[input.y:18.52-54: warning: unused value: $][5 [-Wother]\n   18 | g: INT | INT { $<integer>$; } INT { $<integer>$; } INT { };\n      |                                                    ^~~\ninput.y:19.10-72: warning: unset value: $][$ [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:19.10-12: warning: unused value: $][1 [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |          ^~~\ninput.y:19.31-33: warning: unused value: $][3 [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |                               ^~~\n]]m4_ifval([$2], [[[input.y:19.35-64: warning: unused value: $][4 [-Wmidrule-values]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n]]])[[input.y:19.66-68: warning: unused value: $][5 [-Wother]\n   19 | h: INT | INT { $<integer>$; } INT { $<integer>$ = $<integer>2; } INT { };\n      |                                                                  ^~~\n]]m4_ifval([$2], [[[input.y:21.18-37: warning: unused value: $][3 [-Wmidrule-values]\n   21 | j: INT | INT INT { $<integer>$ = 1; } { $][$ = $][1 + $][2; };\n      |                  ^~~~~~~~~~~~~~~~~~~~\n]]])[[input.y:22.10-68: warning: unset value: $][$ [-Wother]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:22.10-12: warning: unused value: $][1 [-Wother]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |          ^~~\ninput.y:22.14-16: warning: unused value: $][2 [-Wother]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |              ^~~\n]]m4_ifval([$2], [[[input.y:22.35-64: warning: unused value: $][4 [-Wmidrule-values]\n   22 | k: INT | INT INT { $<integer>$; } { $<integer>$ = $<integer>3; } { };\n      |                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n]]])[[input.y:25.23-25: warning: unset value: $][$ [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                       ^~~\ninput.y:25.40-42: warning: unset value: $][$ [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                                        ^~~\ninput.y:25.10-50: warning: unset value: $][$ [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:25.10-12: warning: unused value: $][1 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |          ^~~\ninput.y:25.23-25: warning: unused value: $][2 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                       ^~~\ninput.y:25.27-29: warning: unused value: $][3 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                           ^~~\ninput.y:25.40-42: warning: unused value: $][4 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                                        ^~~\ninput.y:25.44-46: warning: unused value: $][5 [-Wother]\n   25 | n: INT | INT <integer>{ } INT <integer>{ } INT { };\n      |                                            ^~~\ninput.y:26.23-25: warning: unset value: $][$ [-Wother]\n   26 | o: INT | INT <integer>{ } INT <integer>{ } INT { $][$ = $][1 + $][2 + $][3 + $][4 + $][5; };\n      |                       ^~~\ninput.y:26.40-42: warning: unset value: $][$ [-Wother]\n   26 | o: INT | INT <integer>{ } INT <integer>{ } INT { $][$ = $][1 + $][2 + $][3 + $][4 + $][5; };\n      |                                        ^~~\n]])\n\n])\n\n## --------------- ##\n## Unused values.  ##\n## --------------- ##\n\nAT_SETUP([Unused values])\nAT_CHECK_UNUSED_VALUES\nAT_CHECK_UNUSED_VALUES(, [1])\nAT_CLEANUP\n\n\n## ------------------------------------------ ##\n## Unused values before symbol declarations.  ##\n## ------------------------------------------ ##\n\nAT_SETUP([Unused values before symbol declarations])\nAT_CHECK_UNUSED_VALUES([1])\nAT_CHECK_UNUSED_VALUES([1], [1])\nAT_CLEANUP\n\n\n## ------------------- ##\n## Symbol redeclared.  ##\n## ------------------- ##\n\nAT_SETUP([Symbol redeclared])\n\nAT_DATA([[input.y]],\n[[%token FOO FOO\n%token BAR 12 BAR 12\n%token EOF 0 EOF 0\n%%\nexp: FOO BAR\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [0], [],\n[[input.y:1.12-14: warning: symbol FOO redeclared [-Wother]\n    1 | %token FOO FOO\n      |            ^~~\ninput.y:1.8-10: note: previous declaration\n    1 | %token FOO FOO\n      |        ^~~\ninput.y:2.15-17: warning: symbol BAR redeclared [-Wother]\n    2 | %token BAR 12 BAR 12\n      |               ^~~\ninput.y:2.8-10: note: previous declaration\n    2 | %token BAR 12 BAR 12\n      |        ^~~\ninput.y:3.14-16: warning: symbol EOF redeclared [-Wother]\n    3 | %token EOF 0 EOF 0\n      |              ^~~\ninput.y:3.8-10: note: previous declaration\n    3 | %token EOF 0 EOF 0\n      |        ^~~\n]])\n\nAT_CLEANUP\n\n\n## --------------------------- ##\n## Symbol class redefinition.  ##\n## --------------------------- ##\n\nAT_SETUP([Symbol class redefinition])\n\nAT_DATA([[input.y]],\n[[%token FOO\n%nterm FOO BAR\n%token BAR\n%nterm error // The token error cannot be redefined as an nterm.\n%%\nFOO: BAR\nBAR:\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.8-10: error: symbol FOO redeclared as a nonterminal\n    2 | %nterm FOO BAR\n      |        ^~~\ninput.y:1.8-10: note: previous definition\n    1 | %token FOO\n      |        ^~~\ninput.y:3.8-10: error: symbol BAR redeclared as a token\n    3 | %token BAR\n      |        ^~~\ninput.y:2.12-14: note: previous definition\n    2 | %nterm FOO BAR\n      |            ^~~\ninput.y:4.8-12: error: symbol error redeclared as a nonterminal\n    4 | %nterm error // The token error cannot be redefined as an nterm.\n      |        ^~~~~\ninput.y:6.1-3: error: rule given for FOO, which is a token\n    6 | FOO: BAR\n      | ^~~\n]])\n\nAT_CLEANUP\n\n\n## --------------------------------------------- ##\n## Default %printer and %destructor redeclared.  ##\n## --------------------------------------------- ##\n\nAT_SETUP([Default %printer and %destructor redeclared])\n\n# AT_TEST([*])\n# ------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <$1> <$1>\n%printer { print ($$); } <$1> <$1>\n\n%destructor { destroy ($$); } <$1>\n%printer { print ($$); } <$1>\n\n%%\n\nstart: %empty;\n\n%destructor { destroy ($$); } <$1>;\n%printer { print ($$); } <$1>;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:1.13-29: error: %destructor redeclaration for <>\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:1.13-29: note: previous declaration\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:2.10-24: error: %printer redeclaration for <>\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:2.10-24: note: previous declaration\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:4.13-29: error: %destructor redeclaration for <>\n    4 | %destructor { destroy ($$); } <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:1.13-29: note: previous declaration\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:5.10-24: error: %printer redeclaration for <>\n    5 | %printer { print ($$); } <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:2.10-24: note: previous declaration\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\ninput.y:11.13-29: error: %destructor redeclaration for <>\n   11 | %destructor { destroy ($$); } <>;\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:1.13-29: note: previous declaration\n    1 | %destructor { destroy ($$); } <> <>\n      |             ^~~~~~~~~~~~~~~~~\ninput.y:12.10-24: error: %printer redeclaration for <>\n   12 | %printer { print ($$); } <>;\n      |          ^~~~~~~~~~~~~~~\ninput.y:2.10-24: note: previous declaration\n    2 | %printer { print ($$); } <> <>\n      |          ^~~~~~~~~~~~~~~\n]])\n])\n\nAT_TEST([], [], [])\nAT_TEST([], [*], [*])\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ---------------------------------------------- ##\n## Per-type %printer and %destructor redeclared.  ##\n## ---------------------------------------------- ##\n\nAT_SETUP([Per-type %printer and %destructor redeclared])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <field1> <field2>\n%printer { print ($$); } <field1> <field2>\n\n%destructor { destroy ($$); } <field1> <field1>\n%printer { print ($$); } <field2> <field2>\n\n%%\n\nstart: %empty;\n\n%destructor { destroy ($$); } <field2> <field1>;\n%printer { print ($$); } <field2> <field1>;\n]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:4.13-29: error: %destructor redeclaration for <field1>\ninput.y:1.13-29: note: previous declaration\ninput.y:4.13-29: error: %destructor redeclaration for <field1>\ninput.y:1.13-29: note: previous declaration\ninput.y:5.10-24: error: %printer redeclaration for <field2>\ninput.y:2.10-24: note: previous declaration\ninput.y:5.10-24: error: %printer redeclaration for <field2>\ninput.y:2.10-24: note: previous declaration\ninput.y:11.13-29: error: %destructor redeclaration for <field2>\ninput.y:1.13-29: note: previous declaration\ninput.y:11.13-29: error: %destructor redeclaration for <field1>\ninput.y:1.13-29: note: previous declaration\ninput.y:12.10-24: error: %printer redeclaration for <field2>\ninput.y:2.10-24: note: previous declaration\ninput.y:12.10-24: error: %printer redeclaration for <field1>\ninput.y:2.10-24: note: previous declaration\n]])\n\nAT_CLEANUP\n\n\n## ------------------- ##\n## Undefined symbols.  ##\n## ------------------- ##\n\nAT_SETUP([Undefined symbols])\n\nAT_DATA([[input.y]],\n[[%printer {} foo baz\n%destructor {} bar\n%type <foo> qux\n%%\nexp: bar;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:1.13-15: warning: symbol 'foo' is used, but is not defined as a token and has no rules [-Wother]\n    1 | %printer {} foo baz\n      |             ^~~\ninput.y:1.17-19: warning: symbol 'baz' is used, but is not defined as a token and has no rules [-Wother]\n    1 | %printer {} foo baz\n      |                 ^~~\ninput.y:2.16-18: error: symbol 'bar' is used, but is not defined as a token and has no rules\n    2 | %destructor {} bar\n      |                ^~~\ninput.y:3.13-15: warning: symbol 'qux' is used, but is not defined as a token and has no rules [-Wother]\n    3 | %type <foo> qux\n      |             ^~~\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------------------------------- ##\n## Unassociated types used for a printer or destructor.  ##\n## ----------------------------------------------------- ##\n\nAT_SETUP([Unassociated types used for a printer or destructor])\n\nAT_DATA([[input.y]],\n[[%token <type1> tag1\n%type <type2> tag2\n\n%printer { } <type1> <type3>\n%destructor { } <type2> <type4>\n\n%%\n\nexp: tag1 { $1; }\n   | tag2 { $1; }\n\ntag2: \"a\" { $$; }\n]])\n\nAT_BISON_CHECK([input.y], [0], [],\n[[input.y:4.22-28: warning: type <type3> is used, but is not associated to any symbol [-Wother]\ninput.y:5.25-31: warning: type <type4> is used, but is not associated to any symbol [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## --------------------------------- ##\n## Useless printers or destructors.  ##\n## --------------------------------- ##\n\nAT_SETUP([Useless printers or destructors])\n\n# AT_TEST([INPUT], [STDERR])\n# --------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[$1\n])\nAT_BISON_CHECK([input.y], [0], [], [$2\n])])\n\nAT_TEST([[%token <type1> token1\n%token <type2> token2\n%token <type3> token3\n%token <type4> token4\n%token <type5> token51 token52\n%token <type6> token61 token62\n%token <type7> token7\n\n%printer {} token1\n%destructor {} token2\n%printer {} token51\n%destructor {} token61\n\n%printer {} token7\n\n%printer {} <type1>\n%destructor {} <type2>\n%printer {} <type3>\n%destructor {} <type4>\n\n%printer {} <type5>\n%destructor {} <type6>\n\n%destructor {} <type7>\n\n%%\nexp: \"a\";]],\n[[input.y:16.13-19: warning: useless %printer for type <type1> [-Wother]\ninput.y:17.16-22: warning: useless %destructor for type <type2> [-Wother]]])\n\n# If everybody is typed, <> is useless.\nAT_TEST([[%type <type> exp\n%token <type> a\n%printer {} <> <*>\n%%\nexp: a;]],\n[[input.y:3.13-14: warning: useless %printer for type <> [-Wother]]])\n\n# If nobody is typed, <*> is useless.\nAT_TEST([[%token a\n%printer {} <> <*>\n%%\nexp: a;]],\n[[input.y:2.16-18: warning: useless %printer for type <*> [-Wother]]])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ---------------------------------------- ##\n## Unused values with default %destructor.  ##\n## ---------------------------------------- ##\n\nAT_SETUP([Unused values with default %destructor])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <>\n%type <tag> tagged\n\n%%\n\nstart: end end tagged tagged { $<tag>1; $3; } ;\nend: { } ;\ntagged: { } ;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [0], [],\n[[input.y:6.8-45: warning: unset value: $$ [-Wother]\n    6 | start: end end tagged tagged { $<tag>1; $3; } ;\n      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:6.12-14: warning: unused value: $2 [-Wother]\n    6 | start: end end tagged tagged { $<tag>1; $3; } ;\n      |            ^~~\ninput.y:7.6-8: warning: unset value: $$ [-Wother]\n    7 | end: { } ;\n      |      ^~~\n]])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <*>\n%type <tag> tagged\n\n%%\n\nstart: end end tagged tagged { $<tag>1; $3; } ;\nend: { } ;\ntagged: { } ;\n]])\n\nAT_BISON_CHECK([input.y], [0], [],\n[[input.y:6.23-28: warning: unused value: $4 [-Wother]\ninput.y:8.9-11: warning: unset value: $$ [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------------------- ##\n## Unused values with per-type %destructor.  ##\n## ----------------------------------------- ##\n\nAT_SETUP([Unused values with per-type %destructor])\n\nAT_DATA([[input.y]],\n[[%destructor { destroy ($$); } <field1>\n%type <field1> start end\n\n%%\n\nstart: end end { $1; } ;\nend: { }  ;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [0], [],\n[[input.y:6.8-22: warning: unset value: $$ [-Wother]\n    6 | start: end end { $1; } ;\n      |        ^~~~~~~~~~~~~~~\ninput.y:6.12-14: warning: unused value: $2 [-Wother]\n    6 | start: end end { $1; } ;\n      |            ^~~\ninput.y:7.6-8: warning: unset value: $$ [-Wother]\n    7 | end: { }  ;\n      |      ^~~\n]])\n\nAT_CLEANUP\n\n\n## ------------------ ##\n## Duplicate string.  ##\n## ------------------ ##\n\n\nAT_SETUP([Duplicate string])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA([input.y],\n[[/* 'Bison -v' used to dump core when two tokens are defined with the same\n   string, as LE and GE below. */\n\n%token NUM\n%token LE \"<=\"\n%token GE \"<=\"\n\n%%\nexp: '(' exp ')' | NUM ;\n%%\n]])\nAT_BISON_OPTION_POPDEFS\n\nAT_BISON_CHECK([-v -o input.c input.y], 0, [],\n[[input.y:6.11-14: warning: symbol \"<=\" used more than once as a literal string [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## ------------------ ##\n## Token collisions.  ##\n## ------------------ ##\n\nAT_SETUP([Token collisions])\n\nAT_DATA([[input.y]],\n[[%token FOO 42 \"foo\"\n         BAR 42 \"foo\"\n%%\nexp: FOO BAR;\n]])\n\nAT_BISON_CHECK([-fcaret input.y], [1], [],\n[[input.y:2.17-21: warning: symbol \"foo\" used more than once as a literal string [-Wother]\n    2 |          BAR 42 \"foo\"\n      |                 ^~~~~\ninput.y:2.10-12: error: code 42 reassigned to token BAR\n    2 |          BAR 42 \"foo\"\n      |          ^~~\ninput.y:1.15-19: note: previous declaration for \"foo\"\n    1 | %token FOO 42 \"foo\"\n      |               ^~~~~\n]])\n\nAT_CLEANUP\n\n\n## ---------------------- ##\n## Incompatible Aliases.  ##\n## ---------------------- ##\n\nAT_SETUP([Incompatible Aliases])\n\nm4_pushdef([AT_TEST],\n[AT_DATA([input.y], [$1])\nAT_BISON_CHECK([-fcaret input.y], [1], [], [$2])\n])\n\n# Use the string-alias first to check the order between \"first\n# declaration\" and second.\n\nAT_TEST([[%token foo \"foo\"\n%type <bar> \"foo\"\n%type <baz> foo\n%%\nexp: foo;\n]],\n[[input.y:3.7-11: error: %type redeclaration for foo\n    3 | %type <baz> foo\n      |       ^~~~~\ninput.y:2.7-11: note: previous declaration\n    2 | %type <bar> \"foo\"\n      |       ^~~~~\n]])\n\nAT_TEST([[%token foo \"foo\"\n%printer {bar} \"foo\"\n%printer {baz} foo\n%%\nexp: foo;\n]],\n[[input.y:3.10-14: error: %printer redeclaration for foo\n    3 | %printer {baz} foo\n      |          ^~~~~\ninput.y:2.10-14: note: previous declaration\n    2 | %printer {bar} \"foo\"\n      |          ^~~~~\n]])\n\nAT_TEST([[%token foo \"foo\"\n%destructor {bar} \"foo\"\n%destructor {baz} foo\n%%\nexp: foo;\n]],\n[[input.y:3.13-17: error: %destructor redeclaration for foo\n    3 | %destructor {baz} foo\n      |             ^~~~~\ninput.y:2.13-17: note: previous declaration\n    2 | %destructor {bar} \"foo\"\n      |             ^~~~~\n]])\n\nAT_TEST([[%token foo \"foo\"\n%left \"foo\"\n%left foo\n%%\nexp: foo;\n]],\n[[input.y:3.1-5: error: %left redeclaration for foo\n    3 | %left foo\n      | ^~~~~\ninput.y:2.1-5: note: previous declaration\n    2 | %left \"foo\"\n      | ^~~~~\n]])\n\n# This time, declare the alias after its use.\n\n# Precedence/associativity.\nAT_TEST([[%left \"foo\"\n%left foo\n%token foo \"foo\"\n%%\nexp: foo;\n]],\n[[input.y:2.1-5: error: %left redeclaration for foo\n    2 | %left foo\n      | ^~~~~\ninput.y:1.1-5: note: previous declaration\n    1 | %left \"foo\"\n      | ^~~~~\n]])\n\n# Printer.\nAT_TEST([[%printer {} \"foo\"\n%printer {} foo\n%token foo \"foo\"\n%%\nexp: foo;\n]],\n[[input.y:2.10-11: error: %printer redeclaration for foo\n    2 | %printer {} foo\n      |          ^~\ninput.y:1.10-11: note: previous declaration\n    1 | %printer {} \"foo\"\n      |          ^~\n]])\n\n# Destructor.\nAT_TEST([[%destructor {} \"foo\"\n%destructor {} foo\n%token foo \"foo\"\n%%\nexp: foo;\n]],\n[[input.y:2.13-14: error: %destructor redeclaration for foo\n    2 | %destructor {} foo\n      |             ^~\ninput.y:1.13-14: note: previous declaration\n    1 | %destructor {} \"foo\"\n      |             ^~\n]])\n\nm4_popdef([AT_TEST])\nAT_CLEANUP\n\n\n\n## ----------------------- ##\n## Torturing the Scanner.  ##\n## ----------------------- ##\n\n# Be sure to compile and run, so that the C compiler checks what\n# we do.\n\nAT_SETUP([Torturing the Scanner])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA([input.y], [])\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:1.1: error: unexpected end of file\n]])\n\n\nAT_DATA([input.y],\n[{}\n])\nAT_BISON_CHECK([-fcaret  input.y], [1], [],\n[[input.y:1.1-2: error: unexpected {...}\n    1 | {}\n      | ^~\n]])\n\n\n# Clang chokes on some of our comments, because it tries to \"parse\"\n# some documentation directives in the comments:\n#\n# input.c:166:50: error: '\\a' command does not have a valid word argument [-Werror,-Wdocumentation]\n#     FAKE = 258                     /* \"fake [] \\a\\b\\f\\n\\r\\t\\v\\\"'?\\\\[\\\\ ??!??'??(??)??-??/??<??=??> \\001\\001\"  */\n#                                                ~~^\nAT_DATA_GRAMMAR([input.y],\n[[%code requires {\n#if defined __clang__ && 10 <= __clang_major__\n# pragma clang diagnostic ignored \"-Wdocumentation\"\n#endif\n}\n\n%{\n/* This is seen in GCC: a %{ and %} in middle of a comment. */\nconst char *foo = \"So %{ and %} can be here too.\";\n\n#if 0\n/* These examples test Bison while not stressing C compilers too much.\n   Many C compilers mishandle backslash-newlines, so this part of the\n   test is inside \"#if 0\".  The comment and string are written so that\n   the \"#endif\" will be seen regardless of the C compiler bugs that we\n   know about, namely:\n\n     HP C (as of late 2002) mishandles *\\[newline]\\[newline]/ within a\n     comment.\n\n     The Apple Darwin compiler (as of late 2002) mishandles\n     \\\\[newline]' within a character constant.\n\n   */\n\n/\\\n* A comment with backslash-newlines in it. %} *\\\n\\\n/\n/* { Close the above comment, if the C compiler mishandled it.  */\n\nchar str[] = \"\\\\\n\" A string with backslash-newlines in it %{ %} \\\\\n\\\n\"\";\n\nchar apostrophe = '\\'';\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n%}\n/* %{ and %} can be here too. */\n\n%{\n/* Exercise pre-prologue dependency to %union.  */\ntypedef int value;\n%}\n\n/* Exercise M4 quoting: '@:>@@:>@', 0.  */\n\n/* Also exercise %union. */\n%union\n{\n  value ival; /* A comment to exercise an old bug. */\n};\n\n\n/* Exercise post-prologue dependency to %union.  */\n%{\nstatic YYSTYPE value_as_yystype (value val);\n\n/* Exercise quotes in declarations.  */\nchar quote[] = \"@:>@@:>@,\";\n%}\n\n%{\n]AT_YYERROR_DECLARE[\n]AT_YYLEX_DECLARE[\n%}\n\n%type <ival> '@<:@'\n\n/* Exercise quotes in strings.  */\n%token FAKE \"fake @<:@@:>@ \\a\\b\\f\\n\\r\\t\\v\\\"\\'\\?\\\\\\u005B\\U0000005c ??!??'??(??)??-??/??<??=??> \\x1\\1\"\n\n/* Beware of the generated comments that embed string aliases that\n   might close the comment.  */\n%token COMMENT_CLOSE \"*/\"\n%token COMMENT       \"/* comment */\"\n\n%%\n/* Exercise M4 quoting: '@:>@@:>@', @<:@, 1.  */\nexp: '@<:@' '\\1' two '$' '@' '{' oline output.or.oline.opt\n  {\n    /* Exercise quotes in braces.  */\n    char tmp[] = \"@<:@%c@:>@,\\n\";\n    printf (tmp, $1);\n  }\n;\n\ntwo: '\\x000000000000000000000000000000000000000000000000000000000000000000002';\noline: '@' 'o' 'l' 'i' 'n' 'e' '@' '_' '_' 'o' 'l' 'i' 'n' 'e' '_' '_';\noutput.or.oline.opt: %empty;|oline;;|output;;;\noutput: '#' 'o' 'u' 't' 'p' 'u' 't' ' ';\n%%\n/* Exercise M4 quoting: '@:>@@:>@', @<:@, 2.  */\n\nstatic YYSTYPE\nvalue_as_yystype (value val)\n{\n  YYSTYPE res;\n  res.ival = val;\n  return res;\n}\n]AT_YYERROR_DEFINE[\nstatic int\nyylex (void)\n{\n  static char const input[] = \"@<:@\\1\\2$@{@oline@__@&t@oline__\\\n#output \"; /* \"\n  */\n  enum { input_elts = sizeof input };\n  (void) input_elts;\n  static int toknum;\n  assert (0 <= toknum && toknum < input_elts);\n  yylval = value_as_yystype (input[toknum]);\n  return input[toknum++];\n}\n]])\n\n# Pacify Emacs'font-lock-mode: \"\n\nAT_DATA([main.c],\n[[typedef int value;\n#include \"input.h\"\n\nint yyparse (void);\n]AT_MAIN_DEFINE[\n]])\nAT_BISON_OPTION_POPDEFS\n\nAT_BISON_CHECK([-d -v -o input.c input.y])\nAT_COMPILE([input.o])\nAT_COMPILE([main.o])\nAT_COMPILE([input], [input.o main.o])\nAT_PARSER_CHECK([input], 0,\n[[[@<:@],\n]])\n\nAT_CLEANUP\n\n\n## ---------------------- ##\n## Typed symbol aliases.  ##\n## ---------------------- ##\n\nAT_SETUP([Typed symbol aliases])\n\n# Bison 2.0 broke typed symbol aliases - ensure they work.\nAT_BISON_OPTION_PUSHDEFS\n\nAT_DATA_GRAMMAR([input.y],\n[[%union\n{\n  int val;\n};\n%token <val> MY_TOKEN \"MY TOKEN\"\n%type <val> exp\n%%\nexp: \"MY TOKEN\";\n%%\n]])\n\nAT_BISON_CHECK([-o input.c input.y])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## --------- ##\n## Require.  ##\n## --------- ##\n\nm4_define([AT_CHECK_REQUIRE],\n[AT_SETUP([Require $1])\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([input.y],\n[[%require \"$1\";\n%%\nempty_file: %empty;\n]])\nAT_BISON_CHECK([-o input.c input.y], $2, [], ignore)\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n])\n\nAT_CHECK_REQUIRE(1.0, 0)\nAT_CHECK_REQUIRE(AT_PACKAGE_VERSION, 0)\n## FIXME: Some day augment this version number.\nAT_CHECK_REQUIRE(100.0, 63)\n\n\n## ------------------------------------- ##\n## String aliases for character tokens.  ##\n## ------------------------------------- ##\n\nAT_SETUP([String aliases for character tokens])\n\n# Bison once thought a character token and its alias were different\n# symbols with the same code.\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([input.y],\n[[%token 'a' \"a\"\n%%\nstart: 'a';\n%%\n]])\n\nAT_BISON_CHECK([-o input.c input.y])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## -------------- ##\n## Symbol names.  ##\n## -------------- ##\n\nAT_SETUP([Symbols])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([input.y],\n[[%token WITH-DASH\n%token WITHOUT_DASH \"WITHOUT-DASH\"\n%token WITH.PERIOD\n%token WITHOUT_PERIOD \"WITHOUT.PERIOD\"\n%code {\n  ]AT_YYERROR_DECLARE[\n  ]AT_YYLEX_DECLARE[\n}\n%%\nstart: with-dash without_dash with.period without_period;\nwith-dash: WITH-DASH;\nwithout_dash: \"WITHOUT-DASH\";\nwith.period: WITH.PERIOD;\nwithout_period: \"WITHOUT.PERIOD\";\n%%\n]AT_YYERROR_DEFINE[\n]AT_YYLEX_DEFINE[\n]])\n\n# POSIX Yacc accept periods, but not dashes.\nAT_BISON_CHECK([--yacc input.y], [], [],\n[[input.y:1.1-5: warning: POSIX Yacc does not support %code [-Wyacc]\ninput.y:9.8-16: warning: POSIX Yacc forbids dashes in symbol names: WITH-DASH [-Wyacc]\ninput.y:10.21-34: warning: POSIX Yacc does not support string literals [-Wyacc]\ninput.y:12.23-38: warning: POSIX Yacc does not support string literals [-Wyacc]\ninput.y:13.1-5: warning: POSIX Yacc does not support %code [-Wyacc]\ninput.y:20.8-16: warning: POSIX Yacc forbids dashes in symbol names: with-dash [-Wyacc]\ninput.y:22.15-28: warning: POSIX Yacc does not support string literals [-Wyacc]\ninput.y:24.17-32: warning: POSIX Yacc does not support string literals [-Wyacc]\n]])\n\n# Dashes are fine for GNU Bison.\nAT_BISON_CHECK([-o input.c input.y])\n\n# Make sure we don't export silly token identifiers with periods or dashes.\nAT_COMPILE([input.o])\n\n\n# Periods are genuine letters, they can start identifiers.\n# Digits and dashes cannot.\nAT_DATA_GRAMMAR([input.y],\n[[%token .GOOD\n         -GOOD\n         1NV4L1D\n         -123\n%%\nstart: .GOOD GOOD\n]])\nAT_BISON_CHECK([-o input.c input.y], [1], [],\n[[input.y:10.10: error: invalid character: '-'\ninput.y:11.10-16: error: invalid identifier: '1NV4L1D'\ninput.y:12.10: error: invalid character: '-'\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ----------------- ##\n## Numbered tokens.  ##\n## ----------------- ##\n\nAT_SETUP([Numbered tokens])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([redecl.y],\n[[%token DECIMAL_1     11259375\n         HEXADECIMAL_1 0xabcdef\n         HEXADECIMAL_2 0xFEDCBA\n         DECIMAL_2     16702650\n%%\nstart: DECIMAL_1 HEXADECIMAL_2;\n]])\n\nAT_BISON_CHECK([redecl.y], [1], [],\n[[redecl.y:10.10-22: error: code 11259375 reassigned to token HEXADECIMAL_1\nredecl.y:9.8-16: note: previous declaration for DECIMAL_1\nredecl.y:12.10-18: error: code 16702650 reassigned to token DECIMAL_2\nredecl.y:11.10-22: note: previous declaration for HEXADECIMAL_2\n]])\n\nAT_DATA_GRAMMAR([too-large.y],\n[[%token TOO_LARGE_DEC 999999999999999999999\n         TOO_LARGE_HEX 0xFFFFFFFFFFFFFFFFFFF\n%%\nstart: TOO_LARGE_DEC TOO_LARGE_HEX\n%%\n]])\n\nAT_BISON_CHECK([too-large.y], [1], [],\n[[too-large.y:9.22-42: error: integer out of range: '999999999999999999999'\ntoo-large.y:9.22-42: error: code of token TOO_LARGE_DEC too large\ntoo-large.y:10.24-44: error: integer out of range: '0xFFFFFFFFFFFFFFFFFFF'\ntoo-large.y:10.24-44: error: code of token TOO_LARGE_HEX too large\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## --------------------- ##\n## Unclosed constructs.  ##\n## --------------------- ##\n\nAT_SETUP([Unclosed constructs])\n\n# Bison's scan-gram.l once forgot to STRING_FINISH () some unclosed\n# constructs, so they were prepended to whatever it STRING_GROW ()'ed\n# next.  It also threw them away rather than returning them to the\n# parser.  The effect was confusing subsequent error messages.\n\nAT_DATA([input.y],\n[[%token A \"a\n%token B \"b\"\n%token AB \"ab\" // Used to complain that \"ab\" was already used.\n%token C '1\n%token TWO \"2\"\n%token TICK_TWELVE \"'12\" // Used to complain that \"'12\" was already used.\n\n%%\n\nstart: %empty;\n\n// Used to report a syntax error because it didn't see any kind of symbol\n// identifier.\n%type <f> 'a\n;\n%type <f> \"a\n;\n// Used to report a syntax error because it didn't see braced code.\n%destructor { free ($$)\n]])\n\nAT_BISON_CHECK([-fcaret -o input.c input.y], 1, [],\n[[input.y:1.10-2.0: error: missing '\"' at end of line\n    1 | %token A \"a\n      |          ^~\ninput.y:4.10-5.0: error: missing \"'\" at end of line\n    4 | %token C '1\n      |          ^~\ninput.y:14.11-15.0: error: missing \"'\" at end of line\n   14 | %type <f> 'a\n      |           ^~\ninput.y:16.11-17.0: error: missing '\"' at end of line\n   16 | %type <f> \"a\n      |           ^~\ninput.y:19.13-20.0: error: missing '}' at end of file\n   19 | %destructor { free ($$)\n      |             ^~~~~~~~~~~\ninput.y:20.1: error: unexpected end of file\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## %start after first rule.  ##\n## ------------------------- ##\n\nAT_SETUP([%start after first rule])\n\n# Bison once complained that a %start after the first rule was a\n# redeclaration of the start symbol.\n\nAT_DATA([input.y],\n[[%%\nfalse_start: %empty;\nstart: false_start ;\n%start start;\n]])\n\nAT_BISON_CHECK([-o input.c input.y])\n\nAT_CLEANUP\n\n\n## --------------------- ##\n## %prec takes a token.  ##\n## --------------------- ##\n\nAT_SETUP([%prec takes a token])\n\n# Bison once allowed %prec sym where sym was a nonterminal.\n\nAT_DATA([input.y],\n[[%%\nstart: PREC %prec PREC ;\nPREC: %empty;\n]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:3.1-4: error: rule given for PREC, which is a token\n]])\n\nAT_CLEANUP\n\n\n## ------------------------------- ##\n## %prec's token must be defined.  ##\n## ------------------------------- ##\n\nAT_SETUP([[%prec's token must be defined]])\n\n# According to POSIX, a %prec token must be defined separately.\n\nAT_DATA([[input.y]],\n[[%%\nstart: %prec PREC ;\n]])\n\nAT_BISON_CHECK([[input.y]], [[0]], [],\n[[input.y:2.8-17: warning: token for %prec is not defined: PREC [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## -------------------------------- ##\n## Reject unused %code qualifiers.  ##\n## -------------------------------- ##\n\nAT_SETUP([Reject unused %code qualifiers])\n\nAT_DATA([input-c.y],\n[[%code q {}\n%code bad {}\n%code bad {}\n%code format {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c.y]], [[1]], [],\n[[input-c.y:1.7: error: %code qualifier 'q' is not used\ninput-c.y:2.7-9: error: %code qualifier 'bad' is not used\ninput-c.y:3.7-9: error: %code qualifier 'bad' is not used\ninput-c.y:4.7-12: error: %code qualifier 'format' is not used\n]])\n\nAT_DATA([input-c-glr.y],\n[[%code q {}\n%code bad {}\n %code bad {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c-glr.y]], [[1]], [],\n[[input-c-glr.y:1.7: error: %code qualifier 'q' is not used\ninput-c-glr.y:2.7-9: error: %code qualifier 'bad' is not used\ninput-c-glr.y:3.8-10: error: %code qualifier 'bad' is not used\n]])\n\nAT_DATA([input-c++.y],\n[[%code q {}\n%code bad {}\n %code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c++.y]], [[1]], [],\n[[input-c++.y:1.7: error: %code qualifier 'q' is not used\ninput-c++.y:2.7-9: error: %code qualifier 'bad' is not used\ninput-c++.y:3.8: error: %code qualifier 'q' is not used\n]])\n\nAT_DATA([input-c++-glr.y],\n[[%code bad {}\n%code q {}\n%code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[input-c++-glr.y]], [[1]], [],\n[[input-c++-glr.y:1.7-9: error: %code qualifier 'bad' is not used\ninput-c++-glr.y:2.7: error: %code qualifier 'q' is not used\ninput-c++-glr.y:3.7: error: %code qualifier 'q' is not used\n]])\n\nAT_DATA([special-char-@@.y],\n[[%code bad {}\n%code q {}\n%code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[special-char-@@.y]], [[1]], [],\n[[special-char-@@.y:1.7-9: error: %code qualifier 'bad' is not used\nspecial-char-@@.y:2.7: error: %code qualifier 'q' is not used\nspecial-char-@@.y:3.7: error: %code qualifier 'q' is not used\n]])\n\nAT_DATA([special-char-@:>@.y],\n[[%code bad {}\n%code q {}\n%code q {}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[special-char-@:>@.y]], [[1]], [],\n[[special-char-@:>@.y:1.7-9: error: %code qualifier 'bad' is not used\nspecial-char-@:>@.y:2.7: error: %code qualifier 'q' is not used\nspecial-char-@:>@.y:3.7: error: %code qualifier 'q' is not used\n]])\n\nAT_CLEANUP\n\n\n## ---------------- ##\n## Multiple %code.  ##\n## ---------------- ##\n\nAT_SETUP([Multiple %code])\n\n# Make sure that repeated arguments to %code are separated by\n# end-of-lines.  At some point, a missing eol would leave synclines\n# appended to the previous value.  Here, we use CPP directive to\n# introduce dependency on the absence/presence of the eol.\nAT_BISON_OPTION_PUSHDEFS\n\nAT_DATA([input.y],\n[[%code {#include <assert.h>}\n%code {#define A B}\n%code {#define B C}\n%code {#define C D}\n%code {#define D 42}\n%code {\n  ]AT_YYERROR_DECLARE[\n  ]AT_YYLEX_DECLARE[\n}\n%%\nstart: %empty;\n%%\n]AT_YYERROR_DEFINE[\n]AT_YYLEX_DEFINE[\nint main (void)\n{\n  assert (A == 42);\n  return 0;\n}\n]])\nAT_FULL_COMPILE([input])\nAT_PARSER_CHECK([input])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ---------------- ##\n## %define errors.  ##\n## ---------------- ##\n\nAT_SETUP([%define errors])\n\nAT_DATA([input-redefined.y],\n[[%define var \"value1\"\n%define var \"value1\"\n %define var \"value2\"\n%define special1 \"@:>@\"\n%define special2 \"@<:@\"\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input-redefined.y]], [[1]], [],\n[[input-redefined.y:2.1-20: warning: %define variable 'var' redefined [-Wother]\ninput-redefined.y:1.1-20: note: previous definition\ninput-redefined.y:3.2-21: error: %define variable 'var' redefined\ninput-redefined.y:2.1-20: note: previous definition\ninput-redefined.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_DATA([input-unused.y],\n[[%define var \"value\"\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input-unused.y]], [[1]], [],\n[[input-unused.y:1.1-19: error: %define variable 'var' is not used\n]])\n\nAT_CLEANUP\n\n\n## ----------------------------------- ##\n## %define, --define, --force-define.  ##\n## ----------------------------------- ##\n\nAT_SETUP([[%define, --define, --force-define]])\n\nAT_DATA([[skel.c]],\n[[m4@&t@_divert_push(0)@\n@output(b4_parser_file_name@)@\n[var-dd: ]b4_percent_define_get([[var-dd]])[\nvar-ff: ]b4_percent_define_get([[var-ff]])[\nvar-dfg: ]b4_percent_define_get([[var-dfg]])[\nvar-fd: ]b4_percent_define_get([[var-fd]])\nm4@&t@_divert_pop(0)\n]])\nAT_DATA([[input.y]],\n[[%define var-dfg \"gram\"\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-Dvar-dd=cmd-d1 -Dvar-dd=cmd-d2 \\\n                 -Fvar-ff=cmd-f1 -Fvar-ff=cmd-f2 \\\n                 -Dvar-dfg=cmd-d -Fvar-dfg=cmd-f \\\n                 -Fvar-fd=cmd-f -Dvar-fd=cmd-d   \\\n                 --skeleton ./skel.c input.y]])\nAT_CHECK([[cat input.tab.c]], [[0]],\n[[var-dd: cmd-d2\nvar-ff: cmd-f2\nvar-dfg: cmd-f\nvar-fd: cmd-d\n]])\n\nAT_DATA([[input-dg.y]],\n[[%define var \"gram\"\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-Dvar=cmd-d input-dg.y]], [[1]], [],\n[[input-dg.y:1.1-18: error: %define variable 'var' redefined\n<command line>:3: note: previous definition\ninput-dg.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_DATA([[input-dg.y]],\n[[%define var \"gram\"\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret -Dvar=cmd-d input-dg.y]], [[1]], [],\n[[input-dg.y:1.1-18: error: %define variable 'var' redefined\n    1 | %define var \"gram\"\n      | ^~~~~~~~~~~~~~~~~~\n<command line>:4: note: previous definition\ninput-dg.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_DATA([[input-unused.y]],\n[[%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-Dunused-d -Funused-f input-unused.y]], [[1]], [],\n[[<command line>:3: error: %define variable 'unused-d' is not used\n<command line>:4: error: %define variable 'unused-f' is not used\n]])\n\nAT_CLEANUP\n\n\n## --------------------------- ##\n## %define Boolean variables.  ##\n## --------------------------- ##\n\nAT_SETUP([[\"%define\" Boolean variables]])\n\nAT_DATA([Input.y],\n[[%language \"Java\"\n%define api.parser.class {Input}\n%define api.parser.public {maybe}\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[Input.y]], [1], [],\n[[Input.y:3.1-33: error: invalid value for %define Boolean variable 'api.parser.public'\n]])\n\nAT_CLEANUP\n\n\n## ------------------------ ##\n## %define code variables.  ##\n## ------------------------ ##\n\nAT_SETUP([[\"%define\" code variables]])\n\nm4_pushdef([AT_TEST],\n[AT_DATA([input.yy],\n[[%skeleton \"lalr1.cc\" %locations\n%define api.location.type ]$1[quux]$2[\n%define api.namespace     ]$1[quux]$2[\n%define api.prefix        ]$1[quux]$2[\n%define api.token.prefix  ]$1[quux]$2[\n%token TOK // Otherwise api.token.prefix is unused.\n%%\nstart: TOK;\n]])\n\nAT_BISON_CHECK([[input.yy]], [0], [],\n[[input.yy:2.$3: warning: %define variable 'api.location.type' requires '{...}' values [-Wdeprecated]\ninput.yy:4.$3: warning: %define variable 'api.prefix' requires '{...}' values [-Wdeprecated]\ninput.yy:5.$3: warning: %define variable 'api.token.prefix' requires '{...}' values [-Wdeprecated]\ninput.yy:3.$3: warning: %define variable 'api.namespace' requires '{...}' values [-Wdeprecated]\n]])\n])\n\nAT_TEST([],  [],  [1-30])\nAT_TEST([\"], [\"], [1-32])\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## --------------------------- ##\n## %define keyword variables.  ##\n## --------------------------- ##\n\nAT_SETUP([[\"%define\" keyword variables]])\n\nm4_pushdef([AT_TEST],\n[AT_DATA([input.y],\n[[%define api.pure                ]$1[true]$2[\n%define api.push-pull             ]$1[both]$2[\n%define lr.default-reduction      ]$1[most]$2[\n%define lr.keep-unreachable-state ]$1[true]$2[\n%define lr.type                   ]$1[lalr]$2[\n%%\nexp: %empty\n]])\n\nAT_BISON_CHECK([[input.y]], [0], [],\n[[input.y:5.1-40: warning: %define variable 'lr.type' requires keyword values [-Wdeprecated]\ninput.y:3.1-40: warning: %define variable 'lr.default-reduction' requires keyword values [-Wdeprecated]\ninput.y:4.1-40: warning: %define variable 'lr.keep-unreachable-state' requires keyword values [-Wdeprecated]\ninput.y:1.1-38: warning: %define variable 'api.pure' requires keyword values [-Wdeprecated]\ninput.y:2.1-40: warning: %define variable 'api.push-pull' requires keyword values [-Wdeprecated]\n]])\n])\n\nAT_TEST([\"], [\"])\nAT_TEST([{], [}])\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ------------------------ ##\n## %define enum variables.  ##\n## ------------------------ ##\n\nAT_SETUP([[\"%define\" enum variables]])\n\n# Check errors from the front-end, and the back-end.  Since the\n# front-end quits before calling the back-end, these tests cannot be\n# fused.\n\n# Front-end.\nAT_DATA([[input.y]],\n[[%define lr.default-reduction bogus\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:1.1-34: error: invalid value for %define variable 'lr.default-reduction': 'bogus'\n    1 | %define lr.default-reduction bogus\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-34: note: accepted value: 'most'\ninput.y:1.1-34: note: accepted value: 'consistent'\ninput.y:1.1-34: note: accepted value: 'accepting'\n]])\n\n# Check escapes.\nAT_DATA([[input.y]],\n[[%define lr.default-reduction {[$@]}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:1.1-35: warning: %define variable 'lr.default-reduction' requires keyword values [-Wdeprecated]\n    1 | %define lr.default-reduction {[$@]}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-35: error: invalid value for %define variable 'lr.default-reduction': '[$@]'\n    1 | %define lr.default-reduction {[$@]}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-35: note: accepted value: 'most'\ninput.y:1.1-35: note: accepted value: 'consistent'\ninput.y:1.1-35: note: accepted value: 'accepting'\n]])\n\n\n# Back-end.\nAT_DATA([[input.y]],\n[[%define api.push-pull neither\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:1.1-29: error: invalid value for %define variable 'api.push-pull': 'neither'\n    1 | %define api.push-pull neither\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y:1.1-29: note: accepted value: 'pull'\ninput.y:1.1-29: note: accepted value: 'push'\ninput.y:1.1-29: note: accepted value: 'both'\n]])\n\nAT_CLEANUP\n\n\n\n## ------------------------ ##\n## %define file variables.  ##\n## ------------------------ ##\n\nAT_SETUP([[\"%define\" file variables]])\n\nAT_DATA([[input.y]],\n[[%skeleton \"lalr1.cc\"\n%locations\n%define api.location.file {bogus}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:3.1-33: error: %define variable 'api.location.file' requires 'none' or '\"...\"' values\n    3 | %define api.location.file {bogus}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n]])\n\nAT_CLEANUP\n\n\n## -------------------------------- ##\n## %define backward compatibility.  ##\n## -------------------------------- ##\n\nAT_SETUP([[\"%define\" backward compatibility]])\n\n# The error messages tell us whether the variables are properly updated.\nAT_DATA([[input.y]],\n[[%define api.push_pull both\n%define lr.keep_unreachable_states maybe\n%define namespace \"foo\"\n%define variant\n%define parser_class_name {parser}\n%define filename_type {filename}\n%%\nstart: %empty;\n]])\nAT_BISON_CHECK([[-fcaret input.y]], [1], [],\n[[input.y:1.1-26: warning: deprecated directive: '%define api.push_pull both', use '%define api.push-pull both' [-Wdeprecated]\n    1 | %define api.push_pull both\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.push-pull both\ninput.y:2.1-40: warning: deprecated directive: '%define lr.keep_unreachable_states maybe', use '%define lr.keep-unreachable-state maybe' [-Wdeprecated]\n    2 | %define lr.keep_unreachable_states maybe\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define lr.keep-unreachable-state maybe\ninput.y:3.1-23: warning: deprecated directive: '%define namespace \"foo\"', use '%define api.namespace {foo}' [-Wdeprecated]\n    3 | %define namespace \"foo\"\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.namespace {foo}\ninput.y:4.1-15: warning: deprecated directive: '%define variant', use '%define api.value.type variant' [-Wdeprecated]\n    4 | %define variant\n      | ^~~~~~~~~~~~~~~\n      | %define api.value.type variant\ninput.y:5.1-34: warning: deprecated directive: '%define parser_class_name {parser}', use '%define api.parser.class {parser}' [-Wdeprecated]\n    5 | %define parser_class_name {parser}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.parser.class {parser}\ninput.y:6.1-32: warning: deprecated directive: '%define filename_type {filename}', use '%define api.filename.type {filename}' [-Wdeprecated]\n    6 | %define filename_type {filename}\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      | %define api.filename.type {filename}\ninput.y:2.1-40: error: invalid value for %define Boolean variable 'lr.keep-unreachable-state'\n    2 | %define lr.keep_unreachable_states maybe\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## Unused %define api.pure.  ##\n## ------------------------- ##\n\nAT_SETUP([[Unused %define api.pure]])\n\n# AT_TEST(DECLS, VALUE, LOCATION)\n# -------------------------------\n# Make sure Bison reports that '%define api.pure VALUE' is unused when DECLS\n# are specified.\nm4_pushdef([AT_TEST],\n[\nAT_DATA([[input.y]],\n[[%define api.pure ]$2[\n]$1[\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input.y]], [[1]], [],\n[[input.y:]$3[: error: %define variable 'api.pure' is not used\n]])\n])\n\nAT_TEST([[%language \"c++\"]],             [[]],      [[1.1-16]])\nAT_TEST([[%language \"c++\"]],             [[false]], [[1.1-22]])\nAT_TEST([[%language \"c++\" %glr-parser]], [[\"\"]],    [[1.1-19]])\nAT_TEST([[%language \"c++\" %glr-parser]], [[false]], [[1.1-22]])\nAT_TEST([[%language \"java\"]],            [[true]],  [[1.1-21]])\nAT_TEST([[%language \"java\"]],            [[false]], [[1.1-22]])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## -------------------------------- ##\n## C++ namespace reference errors.  ##\n## -------------------------------- ##\n\nAT_SETUP([[C++ namespace reference errors]])\n\n# AT_CHECK_NAMESPACE_ERROR(NAMESPACE-DECL, ERROR, [ERROR], ...)\n# -------------------------------------------------------------\n# Make sure Bison reports all ERROR's for %define namespace \"NAMESPACE-DECL\".\nm4_define([AT_CHECK_NAMESPACE_ERROR],\n[\nAT_DATA([[input.y]],\n[[%language \"C++\"\n%defines\n%define api.namespace {]$1[}\n%%\nstart: %empty;\n]])\n\nAT_BISON_CHECK([[input.y]], [1], [],\n[m4_foreach([b4_arg], m4_dquote(m4_shift($@)),\n[b4_arg\n])])\n])\n\nAT_CHECK_NAMESPACE_ERROR([[]],\n                         [[input.y:3.1-24: error: namespace reference is empty]])\nAT_CHECK_NAMESPACE_ERROR([[ @tb@@tb@  @tb@ @tb@]],\n                         [[input.y:3.1-57: error: namespace reference is empty]])\nAT_CHECK_NAMESPACE_ERROR([[foo::::bar]],\n                         [[input.y:3.1-34: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo:: @tb@::bar]],\n                         [[input.y:3.1-38: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[::::bar]],\n                         [[input.y:3.1-31: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[:: ::bar]],\n                         [[input.y:3.1-32: error: namespace reference has consecutive \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo::bar::@tb@::]],\n                         [[input.y:3.1-43: error: namespace reference has consecutive \"::\"]],\n                         [[input.y:3.1-43: error: namespace reference has a trailing \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo::bar::]],\n                         [[input.y:3.1-34: error: namespace reference has a trailing \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[foo::bar:: @tb@]],\n                         [[input.y:3.1-41: error: namespace reference has a trailing \"::\"]])\nAT_CHECK_NAMESPACE_ERROR([[::]],\n                         [[input.y:3.1-26: error: namespace reference has a trailing \"::\"]])\n\nAT_CLEANUP\n\n\n## ------------------------ ##\n## Bad character literals.  ##\n## ------------------------ ##\n\n# Bison used to accept character literals that were empty or contained\n# too many characters.\n\nAT_SETUP([[Bad character literals]])\n\nAT_DATA_NO_FINAL_EOL([empty.y],\n[[%%\nstart: '';\nstart: '\nstart: ']])\n\nAT_BISON_CHECK([-fcaret empty.y], [1], [],\n[[empty.y:2.8-9: error: empty character literal\n    2 | start: '';\n      |        ^~\nempty.y:3.8-4.0: error: missing \"'\" at end of line\n    3 | start: '\n      |        ^\nempty.y:3.8-4.0: error: empty character literal\n    3 | start: '\n      |        ^\nempty.y:4.8: error: missing \"'\" at end of file\n    4 | start: '\n      |        ^\nempty.y:4.8: error: empty character literal\n    4 | start: '\n      |        ^\n]])\n\nAT_DATA_NO_FINAL_EOL([two.y],\n[[%%\nstart: 'ab';\nstart: 'ab\nstart: 'ab]])\n\nAT_BISON_CHECK([two.y], [1], [],\n[[two.y:2.8-11: error: extra characters in character literal\ntwo.y:3.8-4.0: error: missing \"'\" at end of line\ntwo.y:3.8-4.0: error: extra characters in character literal\ntwo.y:4.8-10: error: missing \"'\" at end of file\ntwo.y:4.8-10: error: extra characters in character literal\n]])\n\nAT_DATA_NO_FINAL_EOL([three.y],\n[[%%\nstart: 'abc';\nstart: 'abc\nstart: 'abc]])\n\nAT_BISON_CHECK([three.y], [1], [],\n[[three.y:2.8-12: error: extra characters in character literal\nthree.y:3.8-4.0: error: missing \"'\" at end of line\nthree.y:3.8-4.0: error: extra characters in character literal\nthree.y:4.8-11: error: missing \"'\" at end of file\nthree.y:4.8-11: error: extra characters in character literal\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## Bad escapes in literals.  ##\n## ------------------------- ##\n\nAT_SETUP([[Bad escapes in literals]])\n\nAT_DATA([input.y],\n[[%%\nstart: '\\777' '\\0' '\\xfff' '\\x0'\n       '\\uffff' '\\u0000' '\\Uffffffff' '\\U00000000'\n       '\\ ' '\\A';\n]])\n\n# It is not easy to create special characters, we cannot even trust tr.\n# Beside we cannot even expect \"echo '\\0'\" to output two characters\n# (well three with \\n): at least Bash 3.2 converts the two-character\n# sequence \"\\0\" into a single NUL character.\nAT_PERL_REQUIRE([[-e 'print \"start: \\\"\\\\\\t\\\\\\f\\\\\\0\\\\\\1\\\" ;\";' >> input.y]])\n\nAT_BISON_CHECK([input.y], [1], [],\n[[input.y:2.9-12: error: invalid number after \\-escape: 777\ninput.y:2.16-17: error: invalid number after \\-escape: 0\ninput.y:2.21-25: error: invalid number after \\-escape: xfff\ninput.y:2.29-31: error: invalid number after \\-escape: x0\ninput.y:3.9-14: error: invalid number after \\-escape: uffff\ninput.y:3.18-23: error: invalid number after \\-escape: u0000\ninput.y:3.27-36: error: invalid number after \\-escape: Uffffffff\ninput.y:3.40-49: error: invalid number after \\-escape: U00000000\ninput.y:4.9-10: error: invalid character after \\-escape: ' '\ninput.y:4.14-15: error: invalid character after \\-escape: A\ninput.y:5.9-16: error: invalid character after \\-escape: \\t\ninput.y:5.17: error: invalid character after \\-escape: \\f\ninput.y:5.18: error: invalid character after \\-escape: \\0\ninput.y:5.19: error: invalid character after \\-escape: \\001\n]])\n\nAT_CLEANUP\n\n\n## ------------------------- ##\n## LAC: Errors for %define.  ##\n## ------------------------- ##\n\nAT_SETUP([[LAC: Errors for %define]])\nAT_KEYWORDS([lac])\n\nAT_DATA([[input.y]],\n[[%%\nstart: %empty;\n]])\n\n# Only \"full\" and \"none\" are accepted for parse.lac\n# Unknown values (such as \"unsupported\") are rejected\nAT_BISON_CHECK([[-Dparse.lac=none input.y]])\nAT_BISON_CHECK([[-Dparse.lac=none -L c++ input.y]])\nAT_BISON_CHECK([[-Dparse.lac=full input.y]])\nAT_BISON_CHECK([[-Dparse.lac=full -L c++ input.y]])\nAT_BISON_CHECK([[-Dparse.lac=unsupported input.y]],\n               [[1]], [],\n[[<command line>:3: error: invalid value for %define variable 'parse.lac': 'unsupported'\n<command line>:3: note: accepted value: 'full'\n<command line>:3: note: accepted value: 'none'\n]])\nAT_BISON_CHECK([[-Dparse.lac=unsupported -L c++ input.y]],\n               [[1]], [],\n[[<command line>:3: error: invalid value for %define variable 'parse.lac': 'unsupported'\n<command line>:3: note: accepted value: 'full'\n<command line>:3: note: accepted value: 'none'\n]])\n\n# parse.lac.* options are useless if LAC isn't actually activated.\nAT_BISON_CHECK([[-Dparse.lac.es-capacity-initial=1 input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.es-capacity-initial' is not used\n]])\nAT_BISON_CHECK([[-Dparse.lac.memory-trace=full input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.memory-trace' is not used\n]])\n\n# parse.lac.* options are useless in C++ even if LAC isn't actually activated.\nAT_BISON_CHECK([[-Dparse.lac.es-capacity-initial=1 -L C++ -Dparse.lac=full input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.es-capacity-initial' is not used\n]])\nAT_BISON_CHECK([[-Dparse.lac.memory-trace=full -L C++ -Dparse.lac=full input.y]],\n               [[1]], [],\n[[<command line>:3: error: %define variable 'parse.lac.memory-trace' is not used\n]])\n\nAT_CLEANUP\n\n\n## ---------------------- ##\n## -Werror combinations.  ##\n## ---------------------- ##\n\nAT_SETUP([[-Werror combinations]])\n\nAT_DATA([[input.y]],\n[[%%\na: '0' { $$ = $; };\n]])\n\n# -Werror is not enabled by -Wall or equivalent.\nAT_BISON_CHECK([[-Wall input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\nAT_BISON_CHECK([[-W input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\nAT_BISON_CHECK([[-Wno-none input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\n\n# -Werror is not disabled by -Wnone or equivalent.\nAT_BISON_CHECK([[-Werror,none,other input.y]], [[1]], [[]],\n[[input.y:2.15: error: stray '$' [-Werror=other]\n]])\nAT_BISON_CHECK([[-Werror,no-all,other input.y]], [[1]], [[]],\n[[input.y:2.15: error: stray '$' [-Werror=other]\n]])\n\n# Check that -Wno-error keeps warnings enabled, but non fatal.\nAT_BISON_CHECK([[-Werror -Wno-error=other input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\n\nAT_BISON_CHECK([[-Wno-error=other -Werror input.y]], [[0]], [[]],\n[[input.y:2.15: warning: stray '$' [-Wother]\n]])\n\nAT_BISON_CHECK([[-Werror=other -Wno-other input.y]], [[0]], [[]],\n[[]])\n\nAT_CLEANUP\n\n\n## ------------------------------------------------------ ##\n## %name-prefix and %define api.prefix are incompatible.  ##\n## ------------------------------------------------------ ##\n\nAT_SETUP([[%name-prefix and api.prefix are incompatible]])\n\n# AT_TEST(DIRECTIVES, OPTIONS, ERROR-LOCATION)\n# --------------------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[$1\n%%\nexp: %empty;\n]])\nAT_BISON_CHECK([[$2 -Wno-deprecated input.y]], [[1]], [[]],\n[[$3: error: '%name-prefix' and '%define api.prefix' cannot be used together\n]])\n])\n\nAT_TEST([%define api.prefix {foo} %name-prefix \"bar\"], [], [input.y:1.1-24])\nAT_TEST([], [-Dapi.prefix={foo} -p bar],                   [<command line>:3])\nAT_TEST([%name-prefix \"bar\"], [-Dapi.prefix={foo}],        [<command line>:3])\nAT_TEST([%define api.prefix {foo}], [-p bar],              [input.y:1.1-24])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n## ----------------------- ##\n## Redefined %union name.  ##\n## ----------------------- ##\n\nAT_SETUP([[Redefined %union name]])\n\n# AT_TEST(DIRECTIVES, EXIT-STATUS, ERROR)\n# ---------------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[$1\n%%\nexp: %empty;\n])\n\nAT_BISON_CHECK([[input.y]], [$2], [[]],\n[$3])\n])\n\nAT_TEST([[%union foo {};\n%union {};\n%union foo {};\n%define api.value.union.name foo]],\n[0],\n[[input.y:3.8-10: warning: %define variable 'api.value.union.name' redefined [-Wother]\ninput.y:1.8-10: note: previous definition\ninput.y:4.1-32: warning: %define variable 'api.value.union.name' redefined [-Wother]\ninput.y:3.8-10: note: previous definition\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_TEST([[%define api.value.union.name {foo}]], [1],\n[[input.y:1.1-34: error: %define variable 'api.value.union.name' requires keyword values\ninput.y:1.1-34: error: %define variable 'api.value.union.name' is not used\n]])\n\nAT_TEST([[%define api.value.union.name \"foo\"]], [1],\n[[input.y:1.1-34: error: %define variable 'api.value.union.name' requires keyword values\ninput.y:1.1-34: error: %define variable 'api.value.union.name' is not used\n]])\n\nm4_popdef([AT_TEST])\nAT_CLEANUP\n\n\n\n\n## -------------- ##\n## Stray $ or @.  ##\n## -------------- ##\n\nAT_SETUP([[Stray $ or @]])\nAT_BISON_OPTION_PUSHDEFS\n\n# Give %printer and %destructor \"<*> exp TOK\" instead of \"<*>\" to\n# check that the warnings are reported once, not three times.\n\nAT_DATA_GRAMMAR([[input.y]],\n[[%type <TYPE> exp\n%token <TYPE> TOK TOK2\n%destructor     { $%; @%; } <*> exp TOK;\n%initial-action { $%; @%; };\n%printer        { $%; @%; } <*> exp TOK;\n%{ $ @ %} // Should not warn.\n%%\nexp: TOK        { $%; @%; $$ = $1; }\n   | 'a'        { $<->1; $$ = 1; }\n   | 'b'        { $<foo->bar>$; }\n%%\n$ @ // Should not warn.\n]])\n\nAT_BISON_CHECK([[-Wall input.y]], 0, [],\n[[input.y:11.19: warning: stray '$' [-Wother]\ninput.y:11.23: warning: stray '@' [-Wother]\ninput.y:12.19: warning: stray '$' [-Wother]\ninput.y:12.23: warning: stray '@' [-Wother]\ninput.y:13.19: warning: stray '$' [-Wother]\ninput.y:13.23: warning: stray '@' [-Wother]\ninput.y:16.19: warning: stray '$' [-Wother]\ninput.y:16.23: warning: stray '@' [-Wother]\ninput.y:17.19: warning: stray '$' [-Wother]\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n\n## ---------------- ##\n## Code injection.  ##\n## ---------------- ##\n\n\nAT_SETUP([[Code injection]])\n\nm4_pattern_allow([^m4_errprintn$])\n\n# AT_TEST([MACRO])\n# ----------------\n# Try to have MACRO be run by bison.\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[%type <$1(DEAD %type)> exp\n%token <$1(DEAD %token)> a\n%token b\n%initial-action\n{\n  $$;\n  $<$1(DEAD %initial-action)>$\n};\n%printer\n{\n  $$\n  $<$1(DEAD %printer)>$\n} <> <*>;\n%lex-param\n{\n  $1(DEAD %lex-param)\n};\n%parse-param\n{\n  $1(DEAD %parse-param)\n};\n%%\nexp:\n  a a[name] b\n  {\n    $$;\n    $][1;\n    $<$1(DEAD action 1)>$\n    $<$1(DEAD action 2)>1\n    $<$1(DEAD action 3)>name\n    $<$1(DEAD action 4)>0\n    ;\n  };\n]])\n\n# FIXME: Provide a means to iterate over all the skeletons.\nAT_BISON_CHECK([[-d               input.y]])\nAT_BISON_CHECK([[-d -S glr.c      input.y]])\nAT_BISON_CHECK([[-d -S lalr1.cc   input.y]])\nAT_BISON_CHECK([[-d -S glr.cc     input.y]])\nAT_BISON_CHECK([[   -S lalr1.java input.y]])\n])\n\nAT_TEST([m4_errprintn])\nAT_TEST([@:>@m4_errprintn])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n\n##----------------------- ##\n## Deprecated directives. ##\n## ---------------------- ##\n\nAT_SETUP([[Deprecated directives]])\n\nAT_KEYWORDS([[deprec]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[\n%default_prec\n%error_verbose\n%expect_rr 0\n%file-prefix = \"foo\"\n%file-prefix\n =\n\"bar\"\n\t%fixed-output_files\n        %fixed_output-files\n%fixed-output-files\n%name-prefix= \"foo\"\n%no-default_prec\n%no_default-prec\n%no_lines\n%output = \"output.c\"\n%pure_parser\n%token_table\n%error-verbose\n%glr-parser\n%name-prefix \"bar\"\n%%\nexp : '0'\n]])\n\nAT_DATA([errors-all],\n[[input.y:10.1-13: warning: deprecated directive: '%default_prec', use '%default-prec' [-Wdeprecated]\nfix-it:\"input.y\":{10:1-10:14}:\"%default-prec\"\ninput.y:11.1-14: warning: deprecated directive: '%error_verbose', use '%define parse.error verbose' [-Wdeprecated]\nfix-it:\"input.y\":{11:1-11:15}:\"%define parse.error verbose\"\ninput.y:12.1-10: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\nfix-it:\"input.y\":{12:1-12:11}:\"%expect-rr\"\ninput.y:13.1-14: warning: deprecated directive: '%file-prefix =', use '%file-prefix' [-Wdeprecated]\nfix-it:\"input.y\":{13:1-13:15}:\"%file-prefix\"\ninput.y:14.1-16.5: warning: duplicate directive: '%file-prefix\\n =' [-Wother]\ninput.y:13.1-20: note: previous declaration\nfix-it:\"input.y\":{14:1-16:6}:\"\"\ninput.y:17.9-27: warning: deprecated directive: '%fixed-output_files', use '%output \"y.tab.c\"' [-Wdeprecated]\nfix-it:\"input.y\":{17:2-17:21}:\"%output \\\"y.tab.c\\\"\"\ninput.y:18.9-27: warning: deprecated directive: '%fixed_output-files', use '%output \"y.tab.c\"' [-Wdeprecated]\nfix-it:\"input.y\":{18:9-18:28}:\"%output \\\"y.tab.c\\\"\"\ninput.y:19.1-19: warning: deprecated directive: '%fixed-output-files', use '%output \"y.tab.c\"' [-Wdeprecated]\nfix-it:\"input.y\":{19:1-19:20}:\"%output \\\"y.tab.c\\\"\"\ninput.y:20.1-19: warning: deprecated directive: '%name-prefix= \"foo\"', use '%define api.prefix {foo}' [-Wdeprecated]\nfix-it:\"input.y\":{20:1-20:20}:\"%define api.prefix {foo}\"\ninput.y:21.1-16: warning: deprecated directive: '%no-default_prec', use '%no-default-prec' [-Wdeprecated]\nfix-it:\"input.y\":{21:1-21:17}:\"%no-default-prec\"\ninput.y:22.1-16: warning: deprecated directive: '%no_default-prec', use '%no-default-prec' [-Wdeprecated]\nfix-it:\"input.y\":{22:1-22:17}:\"%no-default-prec\"\ninput.y:23.1-9: warning: deprecated directive: '%no_lines', use '%no-lines' [-Wdeprecated]\nfix-it:\"input.y\":{23:1-23:10}:\"%no-lines\"\ninput.y:24.1-9: warning: deprecated directive: '%output =', use '%output' [-Wdeprecated]\nfix-it:\"input.y\":{24:1-24:10}:\"%output\"\ninput.y:25.1-12: warning: deprecated directive: '%pure_parser', use '%define api.pure' [-Wdeprecated]\nfix-it:\"input.y\":{25:1-25:13}:\"%define api.pure\"\ninput.y:26.1-12: warning: deprecated directive: '%token_table', use '%token-table' [-Wdeprecated]\nfix-it:\"input.y\":{26:1-26:13}:\"%token-table\"\ninput.y:27.1-14: warning: %define variable 'parse.error' redefined [-Wother]\ninput.y:11.1-14: note: previous definition\nfix-it:\"input.y\":{27:1-27:15}:\"\"\ninput.y:29.1-18: warning: duplicate directive: '%name-prefix \"bar\"' [-Wother]\ninput.y:13.1-20: note: previous declaration\nfix-it:\"input.y\":{29:1-29:19}:\"\"\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_CHECK([cp errors-all experr])\nAT_BISON_CHECK([[-ffixit input.y]], [], [], [experr])\n\nAT_CHECK([[sed -e '/^fix-it:/d' errors-all >experr]])\nAT_BISON_CHECK([[input.y]], [], [], [experr])\n\n\n# Update the input file.  Make sure we generated nothing.\nAT_CHECK([rm -f output.c])\nAT_CHECK([cp input.y input.y.orig])\nAT_CHECK([sed -e '/fix-it/d' <errors-all >experr])\nAT_CHECK([echo \"bison: file 'input.y' was updated (backup: 'input.y~')\" >>experr])\nAT_BISON_CHECK([[--update input.y]], [], [[]], [experr])\n\n# Check the backup.\nAT_CHECK([diff input.y.orig input.y~])\n\n# Check we did not generate any file.\nAT_CHECK([test ! -f output.c])\n\n# Check the update.\nAT_CHECK([sed -e '1,8d' input.y], [],\n[[\n%default-prec\n%define parse.error verbose\n%expect-rr 0\n%file-prefix \"foo\"\n\t%output \"y.tab.c\"\n        %output \"y.tab.c\"\n%output \"y.tab.c\"\n%define api.prefix {foo}\n%no-default-prec\n%no-default-prec\n%no-lines\n%output \"output.c\"\n%define api.pure\n%token-table\n%glr-parser\n%%\nexp : '0'\n]])\n\nAT_BISON_CHECK([[input.y]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## ---------------------------- ##\n## Unput's effect on locations. ##\n## ---------------------------- ##\n\n# When the scanner detects a deprecated construct, it unputs the\n# correct version, but it should *not* have any impact on the scanner\n# cursor. If it does, the locations of directives on the same line\n# become erroneous.\n\nAT_SETUP([[Unput's effect on locations]])\n\nAT_KEYWORDS([[deprec]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[\n%glr-parser\n%expect_rr 42 %expect_rr 42\n              %expect_rr 42\n%error_verbose %error_verbose\n               %error_verbose\n%% exp: '0'\n]])\n\nAT_BISON_CHECK([[input.y]], [[1]], [[]],\n[[input.y:11.1-10: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\ninput.y:11.15-24: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\ninput.y:12.15-24: warning: deprecated directive: '%expect_rr', use '%expect-rr' [-Wdeprecated]\ninput.y:13.1-14: warning: deprecated directive: '%error_verbose', use '%define parse.error verbose' [-Wdeprecated]\ninput.y:13.16-29: warning: %define variable 'parse.error' redefined [-Wother]\ninput.y:13.1-14: note: previous definition\ninput.y:14.16-29: warning: %define variable 'parse.error' redefined [-Wother]\ninput.y:13.16-29: note: previous definition\ninput.y: error: reduce/reduce conflicts: 0 found, 42 expected\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## -------------------------- ##\n## Non-deprecated directives. ##\n## -------------------------- ##\n\nAT_SETUP([[Non-deprecated directives]])\n\nAT_KEYWORDS([[deprec]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[\n%default-prec\n%define parse.error verbose\n%expect-rr 42\n%file-prefix \"foo\"\n%file-prefix\n\"bar\"\n%no-default-prec\n%no-lines\n%output \"foo\"\n%token-table\n%% exp : '0'\n]])\n\nAT_BISON_CHECK([[input.y]], [[0]], [[]],\n[[input.y:14.1-15.5: warning: duplicate directive: '%file-prefix' [-Wother]\ninput.y:13.1-18: note: previous declaration\ninput.y: warning: %expect-rr applies only to GLR parsers [-Wother]\ninput.y: warning: fix-its can be applied.  Rerun with option '--update'. [-Wother]\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n## -------------------- ##\n## Cannot type action.  ##\n## -------------------- ##\n\nAT_SETUP([[Cannot type action]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[%%\nexp: <int> {}\n]])\n\nAT_BISON_CHECK([[-fcaret input.y]], [[0]], [[]],\n[[input.y:10.6-13: warning: only midrule actions can be typed: int [-Wother]\n   10 | exp: <int> {}\n      |      ^~~~~~~~\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n\n## -------------------------------------- ##\n## Character literals and api.token.raw.  ##\n## -------------------------------------- ##\n\nAT_SETUP([[Character literals and api.token.raw]])\n\nAT_BISON_OPTION_PUSHDEFS\nAT_DATA_GRAMMAR([[input.y]],\n[[%define api.token.raw\n%token 'a'\n%%\nexp: 'b' \"c\" {}\n]])\n\nAT_BISON_CHECK([[-fcaret input.y]], [[1]], [[]],\n[[input.y:10.8-10: error: character literals cannot be used together with api.token.raw\n   10 | %token 'a'\n      |        ^~~\ninput.y:9.1-21: note: definition of api.token.raw\n    9 | %define api.token.raw\n      | ^~~~~~~~~~~~~~~~~~~~~\ninput.y:12.6-8: error: character literals cannot be used together with api.token.raw\n   12 | exp: 'b' \"c\" {}\n      |      ^~~\ninput.y:9.1-21: note: definition of api.token.raw\n    9 | %define api.token.raw\n      | ^~~~~~~~~~~~~~~~~~~~~\n]])\n\nAT_BISON_OPTION_POPDEFS\nAT_CLEANUP\n\n\n\n## ------------------------------ ##\n## %token-table and parse.error.  ##\n## ------------------------------ ##\n\nAT_SETUP([[%token-table and parse.error]])\n\n# AT_TEST(DIRECTIVES, ERROR-LOCATION)\n# -----------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[$1\n%%\nexp: %empty;\n]])\nAT_BISON_CHECK([[input.y]], [[1]], [[]],\n[$2: error: '%token-table' and '%define parse.error (custom|detailed)' cannot be used together\n])\n])\n\nAT_TEST([%define parse.error custom %token-table],  [[input.y:1.1-26]])\nAT_TEST([%define parse.error detailed %token-table],[[input.y:1.1-28]])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n\n## --------------------------------------- ##\n## Invalid file prefix mapping arguments.  ##\n## --------------------------------------- ##\n\nAT_SETUP([[Invalid file prefix mapping arguments]])\n\n# AT_TEST(DIRECTIVES, OPTIONS, ERROR-LOCATION)\n# --------------------------------------------\nm4_pushdef([AT_TEST],\n[AT_DATA([[input.y]],\n[[\n%%\nexp: %empty;\n]])\nAT_BISON_CHECK([[$1 input.y]], [[1]], [[]],\n[[$3: error: invalid argument for '--file-prefix-map': $2\n]])\n])\n\nAT_TEST([-M foo], [foo], [<command line>:4])\nAT_TEST([--file-prefix-map foo], [foo], [<command line>:4])\nAT_TEST([-M foo=bar -M baz], [baz], [<command line>:6])\nAT_TEST([-M foo= -M baz], [baz], [<command line>:6])\n\nm4_popdef([AT_TEST])\n\nAT_CLEANUP\n"], "filenames": ["THANKS", "src/flex-scanner.h", "src/scan-gram.l", "tests/input.at"], "buggy_code_start_loc": [187, 115, 405, 1], "buggy_code_end_loc": [187, 116, 617, 105], "fixing_code_start_loc": [188, 115, 406, 1], "fixing_code_end_loc": [189, 125, 619, 133], "type": "CWE-416", "message": "GNU Bison before 3.7.1 has a use-after-free in _obstack_free in lib/obstack.c (called from gram_lex) when a '\\0' byte is encountered. NOTE: there is a risk only if Bison is used with untrusted input, and the observed bug happens to cause unsafe behavior with a specific compiler/architecture. The bug report was intended to show that a crash may occur in Bison itself, not that a crash may occur in code that is generated by Bison.", "other": {"cve": {"id": "CVE-2020-24240", "sourceIdentifier": "cve@mitre.org", "published": "2020-08-25T14:15:16.543", "lastModified": "2020-09-02T14:31:13.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "GNU Bison before 3.7.1 has a use-after-free in _obstack_free in lib/obstack.c (called from gram_lex) when a '\\0' byte is encountered. NOTE: there is a risk only if Bison is used with untrusted input, and the observed bug happens to cause unsafe behavior with a specific compiler/architecture. The bug report was intended to show that a crash may occur in Bison itself, not that a crash may occur in code that is generated by Bison."}, {"lang": "es", "value": "GNU Bison versi\u00f3n 3.7, presenta una vulnerabilidad de uso de la memoria previamente liberada (UAF). Un atacante local puede ejecutar bison con un archivo de entrada dise\u00f1ado que contiene un byte NULL, lo que podr\u00eda desencadenar un UAF y, por lo tanto, causar un bloqueo del sistema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:bison:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "0838D60C-79CC-4AC7-A390-DB27DCA03303"}]}]}], "references": [{"url": "https://github.com/akimd/bison/commit/be95a4fe2951374676efc9454ffee8638faaf68d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/akimd/bison/compare/v3.7...v3.7.1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.gnu.org/r/bug-bison/2020-07/msg00051.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/akimd/bison/commit/be95a4fe2951374676efc9454ffee8638faaf68d"}}