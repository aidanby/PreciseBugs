{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Crypto user configuration API.\n *\n * Copyright (C) 2011 secunet Security Networks AG\n * Copyright (C) 2011 Steffen Klassert <steffen.klassert@secunet.com>\n */\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstatic DEFINE_MUTEX(crypto_cfg_mutex);\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstruct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint match = 0;\n\n\t\tif (crypto_is_larval(q))\n\t\t\tcontinue;\n\n\t\tif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\n\t\t\tcontinue;\n\n\t\tif (strlen(p->cru_driver_name))\n\t\t\tmatch = !strcmp(q->cra_driver_name,\n\t\t\t\t\tp->cru_driver_name);\n\t\telse if (!exact)\n\t\t\tmatch = !strcmp(q->cra_name, p->cru_name);\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (unlikely(!crypto_mod_get(q)))\n\t\t\tcontinue;\n\n\t\talg = q;\n\t\tbreak;\n\t}\n\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tmemset(&rcipher, 0, sizeof(rcipher));\n\n\tstrscpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t       sizeof(rcipher), &rcipher);\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tmemset(&rcomp, 0, sizeof(rcomp));\n\n\tstrscpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS, sizeof(rcomp), &rcomp);\n}\n\nstatic int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemset(ualg, 0, sizeof(*ualg));\n\n\tstrscpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrscpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrscpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tmemset(&rl, 0, sizeof(rl));\n\t\tstrscpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL, sizeof(rl), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_alg(struct crypto_alg *alg,\n\t\t\t     struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETALG, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_report_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nstatic int crypto_dump_report(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst size_t start_pos = cb->args[0];\n\tsize_t pos = 0;\n\tstruct crypto_dump_info info;\n\tstruct crypto_alg *alg;\n\tint res;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tdown_read(&crypto_alg_sem);\n\tlist_for_each_entry(alg, &crypto_alg_list, cra_list) {\n\t\tif (pos >= start_pos) {\n\t\t\tres = crypto_report_alg(alg, &info);\n\t\t\tif (res == -EMSGSIZE)\n\t\t\t\tbreak;\n\t\t\tif (res)\n\t\t\t\tgoto out;\n\t\t}\n\t\tpos++;\n\t}\n\tcb->args[0] = pos;\n\tres = skb->len;\nout:\n\tup_read(&crypto_alg_sem);\n\treturn res;\n}\n\nstatic int crypto_dump_report_done(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\tLIST_HEAD(list);\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (priority && !strlen(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_remove_spawns(alg, &list, NULL);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\tcrypto_remove_final(&list);\n\n\treturn 0;\n}\n\nstatic int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tint err;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\t/* We can not unregister core algorithms such as aes-generic.\n\t * We would loose the reference in the crypto_alg_list to this algorithm\n\t * if we try to unregister. Unregistering such an algorithm without\n\t * removing the module is not possible, so we restrict to crypto\n\t * instances that are build from templates. */\n\terr = -EINVAL;\n\tif (!(alg->cra_flags & CRYPTO_ALG_INSTANCE))\n\t\tgoto drop_alg;\n\n\terr = -EBUSY;\n\tif (refcount_read(&alg->cra_refcnt) > 2)\n\t\tgoto drop_alg;\n\n\terr = crypto_unregister_instance((struct crypto_instance *)alg);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic int crypto_add_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tint exact = 0;\n\tconst char *name;\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (strlen(p->cru_driver_name))\n\t\texact = 1;\n\n\tif (priority && !exact)\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, exact);\n\tif (alg) {\n\t\tcrypto_mod_put(alg);\n\t\treturn -EEXIST;\n\t}\n\n\tif (strlen(p->cru_driver_name))\n\t\tname = p->cru_driver_name;\n\telse\n\t\tname = p->cru_name;\n\n\talg = crypto_alg_mod_lookup(name, p->cru_type, p->cru_mask);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tdown_write(&crypto_alg_sem);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\n\treturn 0;\n}\n\nstatic int crypto_del_rng(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\treturn crypto_del_default_rng();\n}\n\n#define MSGSIZE(type) sizeof(struct type)\n\nstatic const int crypto_msg_min[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = 0,\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n};\n\nstatic const struct nla_policy crypto_policy[CRYPTOCFGA_MAX+1] = {\n\t[CRYPTOCFGA_PRIORITY_VAL]   = { .type = NLA_U32},\n};\n\n#undef MSGSIZE\n\nstatic const struct crypto_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} crypto_dispatch[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_add_alg},\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_alg},\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_update_alg},\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_report,\n\t\t\t\t\t\t       .dump = crypto_dump_report,\n\t\t\t\t\t\t       .done = crypto_dump_report_done},\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_rng },\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = { .doit = crypto_reportstat},\n};\n\nstatic int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\n\tconst struct crypto_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > CRYPTO_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= CRYPTO_MSG_BASE;\n\tlink = &crypto_dispatch[type];\n\n\tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP))) {\n\t\tstruct crypto_alg *alg;\n\t\tunsigned long dump_alloc = 0;\n\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdown_read(&crypto_alg_sem);\n\t\tlist_for_each_entry(alg, &crypto_alg_list, cra_list)\n\t\t\tdump_alloc += CRYPTO_REPORT_MAXSIZE;\n\t\tup_read(&crypto_alg_sem);\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t\t.min_dump_alloc = min(dump_alloc, 65535UL),\n\t\t\t};\n\t\t\terr = netlink_dump_start(net->crypto_nlsk, skb, nlh, &c);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\terr = nlmsg_parse_deprecated(nlh, crypto_msg_min[type], attrs,\n\t\t\t\t     CRYPTOCFGA_MAX, crypto_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void crypto_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&crypto_cfg_mutex);\n\tnetlink_rcv_skb(skb, &crypto_user_rcv_msg);\n\tmutex_unlock(&crypto_cfg_mutex);\n}\n\nstatic int __net_init crypto_netlink_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= crypto_netlink_rcv,\n\t};\n\n\tnet->crypto_nlsk = netlink_kernel_create(net, NETLINK_CRYPTO, &cfg);\n\treturn net->crypto_nlsk == NULL ? -ENOMEM : 0;\n}\n\nstatic void __net_exit crypto_netlink_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->crypto_nlsk);\n\tnet->crypto_nlsk = NULL;\n}\n\nstatic struct pernet_operations crypto_netlink_net_ops = {\n\t.init = crypto_netlink_init,\n\t.exit = crypto_netlink_exit,\n};\n\nstatic int __init crypto_user_init(void)\n{\n\treturn register_pernet_subsys(&crypto_netlink_net_ops);\n}\n\nstatic void __exit crypto_user_exit(void)\n{\n\tunregister_pernet_subsys(&crypto_netlink_net_ops);\n}\n\nmodule_init(crypto_user_init);\nmodule_exit(crypto_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"Crypto userspace configuration API\");\nMODULE_ALIAS(\"net-pf-16-proto-21\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Crypto user configuration API.\n *\n * Copyright (C) 2011 secunet Security Networks AG\n * Copyright (C) 2011 Steffen Klassert <steffen.klassert@secunet.com>\n */\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <linux/cryptouser.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <net/netlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <crypto/internal/skcipher.h>\n#include <crypto/internal/rng.h>\n#include <crypto/akcipher.h>\n#include <crypto/kpp.h>\n#include <crypto/internal/cryptouser.h>\n\n#include \"internal.h\"\n\n#define null_terminated(x)\t(strnlen(x, sizeof(x)) < sizeof(x))\n\nstatic DEFINE_MUTEX(crypto_cfg_mutex);\n\nstruct crypto_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstruct crypto_alg *crypto_alg_match(struct crypto_user_alg *p, int exact)\n{\n\tstruct crypto_alg *q, *alg = NULL;\n\n\tdown_read(&crypto_alg_sem);\n\n\tlist_for_each_entry(q, &crypto_alg_list, cra_list) {\n\t\tint match = 0;\n\n\t\tif (crypto_is_larval(q))\n\t\t\tcontinue;\n\n\t\tif ((q->cra_flags ^ p->cru_type) & p->cru_mask)\n\t\t\tcontinue;\n\n\t\tif (strlen(p->cru_driver_name))\n\t\t\tmatch = !strcmp(q->cra_driver_name,\n\t\t\t\t\tp->cru_driver_name);\n\t\telse if (!exact)\n\t\t\tmatch = !strcmp(q->cra_name, p->cru_name);\n\n\t\tif (!match)\n\t\t\tcontinue;\n\n\t\tif (unlikely(!crypto_mod_get(q)))\n\t\t\tcontinue;\n\n\t\talg = q;\n\t\tbreak;\n\t}\n\n\tup_read(&crypto_alg_sem);\n\n\treturn alg;\n}\n\nstatic int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tmemset(&rcipher, 0, sizeof(rcipher));\n\n\tstrscpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t       sizeof(rcipher), &rcipher);\n}\n\nstatic int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tmemset(&rcomp, 0, sizeof(rcomp));\n\n\tstrscpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\n\treturn nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS, sizeof(rcomp), &rcomp);\n}\n\nstatic int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemset(ualg, 0, sizeof(*ualg));\n\n\tstrscpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrscpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrscpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tmemset(&rl, 0, sizeof(rl));\n\t\tstrscpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL, sizeof(rl), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tgoto out;\n\t}\n\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int crypto_report_alg(struct crypto_alg *alg,\n\t\t\t     struct crypto_dump_info *info)\n{\n\tstruct sk_buff *in_skb = info->in_skb;\n\tstruct sk_buff *skb = info->out_skb;\n\tstruct nlmsghdr *nlh;\n\tstruct crypto_user_alg *ualg;\n\tint err = 0;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, info->nlmsg_seq,\n\t\t\tCRYPTO_MSG_GETALG, sizeof(*ualg), info->nlmsg_flags);\n\tif (!nlh) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tualg = nlmsg_data(nlh);\n\n\terr = crypto_report_one(alg, ualg, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\tgoto out;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\nout:\n\treturn err;\n}\n\nstatic int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}\n\nstatic int crypto_dump_report(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tconst size_t start_pos = cb->args[0];\n\tsize_t pos = 0;\n\tstruct crypto_dump_info info;\n\tstruct crypto_alg *alg;\n\tint res;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tdown_read(&crypto_alg_sem);\n\tlist_for_each_entry(alg, &crypto_alg_list, cra_list) {\n\t\tif (pos >= start_pos) {\n\t\t\tres = crypto_report_alg(alg, &info);\n\t\t\tif (res == -EMSGSIZE)\n\t\t\t\tbreak;\n\t\t\tif (res)\n\t\t\t\tgoto out;\n\t\t}\n\t\tpos++;\n\t}\n\tcb->args[0] = pos;\n\tres = skb->len;\nout:\n\tup_read(&crypto_alg_sem);\n\treturn res;\n}\n\nstatic int crypto_dump_report_done(struct netlink_callback *cb)\n{\n\treturn 0;\n}\n\nstatic int crypto_update_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\tLIST_HEAD(list);\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (priority && !strlen(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\tdown_write(&crypto_alg_sem);\n\n\tcrypto_remove_spawns(alg, &list, NULL);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\tcrypto_remove_final(&list);\n\n\treturn 0;\n}\n\nstatic int crypto_del_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tint err;\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 1);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\t/* We can not unregister core algorithms such as aes-generic.\n\t * We would loose the reference in the crypto_alg_list to this algorithm\n\t * if we try to unregister. Unregistering such an algorithm without\n\t * removing the module is not possible, so we restrict to crypto\n\t * instances that are build from templates. */\n\terr = -EINVAL;\n\tif (!(alg->cra_flags & CRYPTO_ALG_INSTANCE))\n\t\tgoto drop_alg;\n\n\terr = -EBUSY;\n\tif (refcount_read(&alg->cra_refcnt) > 2)\n\t\tgoto drop_alg;\n\n\terr = crypto_unregister_instance((struct crypto_instance *)alg);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}\n\nstatic int crypto_add_alg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tint exact = 0;\n\tconst char *name;\n\tstruct crypto_alg *alg;\n\tstruct crypto_user_alg *p = nlmsg_data(nlh);\n\tstruct nlattr *priority = attrs[CRYPTOCFGA_PRIORITY_VAL];\n\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\tif (strlen(p->cru_driver_name))\n\t\texact = 1;\n\n\tif (priority && !exact)\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, exact);\n\tif (alg) {\n\t\tcrypto_mod_put(alg);\n\t\treturn -EEXIST;\n\t}\n\n\tif (strlen(p->cru_driver_name))\n\t\tname = p->cru_driver_name;\n\telse\n\t\tname = p->cru_name;\n\n\talg = crypto_alg_mod_lookup(name, p->cru_type, p->cru_mask);\n\tif (IS_ERR(alg))\n\t\treturn PTR_ERR(alg);\n\n\tdown_write(&crypto_alg_sem);\n\n\tif (priority)\n\t\talg->cra_priority = nla_get_u32(priority);\n\n\tup_write(&crypto_alg_sem);\n\n\tcrypto_mod_put(alg);\n\n\treturn 0;\n}\n\nstatic int crypto_del_rng(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t  struct nlattr **attrs)\n{\n\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\treturn crypto_del_default_rng();\n}\n\n#define MSGSIZE(type) sizeof(struct type)\n\nstatic const int crypto_msg_min[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = 0,\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = MSGSIZE(crypto_user_alg),\n};\n\nstatic const struct nla_policy crypto_policy[CRYPTOCFGA_MAX+1] = {\n\t[CRYPTOCFGA_PRIORITY_VAL]   = { .type = NLA_U32},\n};\n\n#undef MSGSIZE\n\nstatic const struct crypto_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n} crypto_dispatch[CRYPTO_NR_MSGTYPES] = {\n\t[CRYPTO_MSG_NEWALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_add_alg},\n\t[CRYPTO_MSG_DELALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_alg},\n\t[CRYPTO_MSG_UPDATEALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_update_alg},\n\t[CRYPTO_MSG_GETALG\t- CRYPTO_MSG_BASE] = { .doit = crypto_report,\n\t\t\t\t\t\t       .dump = crypto_dump_report,\n\t\t\t\t\t\t       .done = crypto_dump_report_done},\n\t[CRYPTO_MSG_DELRNG\t- CRYPTO_MSG_BASE] = { .doit = crypto_del_rng },\n\t[CRYPTO_MSG_GETSTAT\t- CRYPTO_MSG_BASE] = { .doit = crypto_reportstat},\n};\n\nstatic int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[CRYPTOCFGA_MAX+1];\n\tconst struct crypto_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > CRYPTO_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= CRYPTO_MSG_BASE;\n\tlink = &crypto_dispatch[type];\n\n\tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP))) {\n\t\tstruct crypto_alg *alg;\n\t\tunsigned long dump_alloc = 0;\n\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\tdown_read(&crypto_alg_sem);\n\t\tlist_for_each_entry(alg, &crypto_alg_list, cra_list)\n\t\t\tdump_alloc += CRYPTO_REPORT_MAXSIZE;\n\t\tup_read(&crypto_alg_sem);\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t\t.min_dump_alloc = min(dump_alloc, 65535UL),\n\t\t\t};\n\t\t\terr = netlink_dump_start(net->crypto_nlsk, skb, nlh, &c);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\terr = nlmsg_parse_deprecated(nlh, crypto_msg_min[type], attrs,\n\t\t\t\t     CRYPTOCFGA_MAX, crypto_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void crypto_netlink_rcv(struct sk_buff *skb)\n{\n\tmutex_lock(&crypto_cfg_mutex);\n\tnetlink_rcv_skb(skb, &crypto_user_rcv_msg);\n\tmutex_unlock(&crypto_cfg_mutex);\n}\n\nstatic int __net_init crypto_netlink_init(struct net *net)\n{\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.input\t= crypto_netlink_rcv,\n\t};\n\n\tnet->crypto_nlsk = netlink_kernel_create(net, NETLINK_CRYPTO, &cfg);\n\treturn net->crypto_nlsk == NULL ? -ENOMEM : 0;\n}\n\nstatic void __net_exit crypto_netlink_exit(struct net *net)\n{\n\tnetlink_kernel_release(net->crypto_nlsk);\n\tnet->crypto_nlsk = NULL;\n}\n\nstatic struct pernet_operations crypto_netlink_net_ops = {\n\t.init = crypto_netlink_init,\n\t.exit = crypto_netlink_exit,\n};\n\nstatic int __init crypto_user_init(void)\n{\n\treturn register_pernet_subsys(&crypto_netlink_net_ops);\n}\n\nstatic void __exit crypto_user_exit(void)\n{\n\tunregister_pernet_subsys(&crypto_netlink_net_ops);\n}\n\nmodule_init(crypto_user_init);\nmodule_exit(crypto_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\nMODULE_DESCRIPTION(\"Crypto userspace configuration API\");\nMODULE_ALIAS(\"net-pf-16-proto-21\");\n"], "filenames": ["crypto/crypto_user_base.c"], "buggy_code_start_loc": [216], "buggy_code_end_loc": [217], "fixing_code_start_loc": [216], "fixing_code_end_loc": [220], "type": "CWE-401", "message": "A memory leak in the crypto_report() function in crypto/crypto_user_base.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_report_alg() failures, aka CID-ffdde5932042.", "other": {"cve": {"id": "CVE-2019-19062", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.483", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the crypto_report() function in crypto/crypto_user_base.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering crypto_report_alg() failures, aka CID-ffdde5932042."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n crypto_report() en el archivo crypto/crypto_user_base.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n crypto_report_alg(), tambi\u00e9n se conoce como CID-ffdde5932042."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.7}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://packetstormsecurity.com/files/155890/Slackware-Security-Advisory-Slackware-14.2-kernel-Updates.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/ffdde5932042600c6807d46c1550b28b0db6a3bc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/01/msg00013.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2020/Jan/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4254-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4254-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4258-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4284-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4287-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/ffdde5932042600c6807d46c1550b28b0db6a3bc"}}