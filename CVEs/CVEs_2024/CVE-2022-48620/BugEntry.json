{"buggy_code": ["/* libuEv - Micro event loop library\n *\n * Copyright (c) 2012       Flemming Madsen <flemming!madsen()madsensoft!dk>\n * Copyright (c) 2013-2021  Joachim Wiberg <troglobit()gmail!com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/** Micro event loop library\n * @file uev.c\n *\n */\n\n#include <errno.h>\n#include <fcntl.h>\t\t/* O_CLOEXEC */\n#include <string.h>\t\t/* memset() */\n#include <sys/epoll.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\t\t/* for select() workaround */\n#include <sys/signalfd.h>\t/* struct signalfd_siginfo */\n#include <unistd.h>\t\t/* close(), read() */\n\n#include \"uev.h\"\n\n\nstatic int _init(uev_ctx_t *ctx, int close_old)\n{\n\tint fd;\n\n\tfd = epoll_create1(EPOLL_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (close_old)\n\t\tclose(ctx->fd);\n\n\tctx->fd = fd;\n\n\treturn 0;\n}\n\n/* Used by file i/o workaround when epoll => EPERM */\nstatic int has_data(int fd)\n{\n\tstruct timeval timeout = { 0, 0 };\n\tfd_set fds;\n\tint n = 0;\n\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\n\tif (select(1, &fds, NULL, NULL, &timeout) > 0)\n\t\treturn ioctl(0, FIONREAD, &n) == 0 && n > 0;\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_init(uev_ctx_t *ctx, uev_t *w, uev_type_t type, uev_cb_t *cb, void *arg, int fd, int events)\n{\n\tif (!ctx || !w) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tw->ctx    = ctx;\n\tw->type   = type;\n\tw->active = 0;\n\tw->fd     = fd;\n\tw->cb     = cb;\n\tw->arg    = arg;\n\tw->events = events;\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_start(uev_t *w)\n{\n\tstruct epoll_event ev;\n\n\tif (!w || w->fd < 0 || !w->ctx) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (_uev_watcher_active(w))\n\t\treturn 0;\n\n\tev.events   = w->events | EPOLLRDHUP;\n\tev.data.ptr = w;\n\tif (epoll_ctl(w->ctx->fd, EPOLL_CTL_ADD, w->fd, &ev) < 0) {\n\t\tif (errno != EPERM)\n\t\t\treturn -1;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (w->type != UEV_IO_TYPE || w->events != UEV_READ)\n\t\t\treturn -1;\n\n\t\t/* Only allow this special handling for stdin */\n\t\tif (w->fd != STDIN_FILENO)\n\t\t\treturn -1;\n\n\t\tw->ctx->workaround = 1;\n\t\tw->active = -1;\n\t} else {\n\t\tw->active = 1;\n\t}\n\n\t/* Add to internal list for bookkeeping */\n\t_UEV_INSERT(w, w->ctx->watchers);\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_stop(uev_t *w)\n{\n\tif (!w) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (!_uev_watcher_active(w))\n\t\treturn 0;\n\n\tw->active = 0;\n\n\t/* Remove from internal list */\n\t_UEV_REMOVE(w, w->ctx->watchers);\n\n\t/* Remove from kernel */\n\tif (epoll_ctl(w->ctx->fd, EPOLL_CTL_DEL, w->fd, NULL) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_active(uev_t *w)\n{\n\tif (!w)\n\t\treturn 0;\n\n\treturn w->active > 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_rearm(uev_t *w)\n{\n\tstruct epoll_event ev;\n\n\tif (!w || w->fd < 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tev.events   = w->events | EPOLLRDHUP;\n\tev.data.ptr = w;\n\tif (epoll_ctl(w->ctx->fd, EPOLL_CTL_MOD, w->fd, &ev) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/**\n * Create an event loop context\n * @param ctx  Pointer to an uev_ctx_t context to be initialized\n *\n * This function calls uev_init1() with @p maxevents set to\n * ::UEV_MAX_EVENTS\n *\n * @return POSIX OK(0) on success, or non-zero on error.\n */\nint uev_init(uev_ctx_t *ctx)\n{\n\treturn uev_init1(ctx, UEV_MAX_EVENTS);\n}\n\n/**\n * Create an event loop context\n * @param ctx       Pointer to an uev_ctx_t context to be initialized\n * @param maxevents Maximum number of events in event cache\n *\n * This function is the same as uev_init() except for the @p maxevents\n * argument, which controls the number of events in the event cache\n * returned to the main loop.\n *\n * In cases where you have multiple events pending in the cache and some\n * event may cause later ones, already sent by the kernel to userspace,\n * to be deleted the pointer returned to the event loop for this later\n * event may be deleted.\n *\n * There are two ways around this (accessing deleted memory):\n *   -# use this function to initialize your event loop and set\n *      @p maxevents to 1\n *   -# use a free list in you application that you garbage collect\n *      at intervals relevant to your application\n *\n * @return POSIX OK(0) on success, or non-zero on error.\n */\nint uev_init1(uev_ctx_t *ctx, int maxevents)\n{\n\tif (!ctx || maxevents < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->maxevents = maxevents;\n\n\treturn _init(ctx, 0);\n}\n\n/**\n * Terminate the event loop\n * @param ctx  A valid libuEv context\n *\n * @return POSIX OK(0) or non-zero with @p errno set on error.\n */\nint uev_exit(uev_ctx_t *ctx)\n{\n\tuev_t *w;\n\n\tif (!ctx) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t/* Remove from internal list */\n\t\t_UEV_REMOVE(w, ctx->watchers);\n\n\t\tif (!_uev_watcher_active(w))\n\t\t\tcontinue;\n\n\t\tswitch (w->type) {\n\t\tcase UEV_IO_TYPE:\n\t\t\tuev_io_stop(w);\n\t\t\tbreak;\n\n\t\tcase UEV_SIGNAL_TYPE:\n\t\t\tuev_signal_stop(w);\n\t\t\tbreak;\n\n\t\tcase UEV_TIMER_TYPE:\n\t\tcase UEV_CRON_TYPE:\n\t\t\tuev_timer_stop(w);\n\t\t\tbreak;\n\n\t\tcase UEV_EVENT_TYPE:\n\t\t\tuev_event_stop(w);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->watchers = NULL;\n\tctx->running = 0;\n\tif (ctx->fd > -1)\n\t\tclose(ctx->fd);\n\tctx->fd = -1;\n\n\treturn 0;\n}\n\n/**\n * Start the event loop\n * @param ctx    A valid libuEv context\n * @param flags  A mask of ::UEV_ONCE and ::UEV_NONBLOCK, or zero\n *\n * With @p flags set to ::UEV_ONCE the event loop returns after the first\n * event has been served, useful for instance to set a timeout on a file\n * descriptor.  If @p flags also has the ::UEV_NONBLOCK flag set the event\n * loop will return immediately if no event is pending, useful when run\n * inside another event loop.\n *\n * @return POSIX OK(0) upon successful termination of the event loop, or\n * non-zero on error.\n */\nint uev_run(uev_ctx_t *ctx, int flags)\n{\n\tint timeout = -1;\n\tuev_t *w;\n\n        if (!ctx || ctx->fd < 0) {\n\t\terrno = EINVAL;\n                return -1;\n\t}\n\n\tif (flags & UEV_NONBLOCK)\n\t\ttimeout = 0;\n\n\t/* Start the event loop */\n\tctx->running = 1;\n\n\t/* Start all dormant timers */\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\tif (UEV_CRON_TYPE == w->type)\n\t\t\tuev_cron_set(w, w->u.c.when, w->u.c.interval);\n\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint i, nfds, rerun = 0;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!has_data(w->fd)) {\n\t\t\t\t\tw->active = 0;\n\t\t\t\t\t_UEV_REMOVE(w, ctx->watchers);\n\t\t\t\t}\n\n\t\t\t\trerun++;\n\t\t\t\tw->cb(w, w->arg, UEV_READ);\n\t\t\t}\n\t\t}\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, ctx->maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; /* Signalled, try again */\n\n\t\t\t/* Unrecoverable error, cleanup and exit with error. */\n\t\t\tuev_exit(ctx);\n\n\t\t\treturn -2;\n\t\t}\n\n\t\tfor (i = 0; ctx->running && i < nfds; i++) {\n\t\t\tstruct signalfd_siginfo fdsi;\n\t\t\tssize_t sz = sizeof(fdsi);\n\t\t\tuint32_t events;\n\t\t\tuint64_t exp;\n\n\t\t\tw = (uev_t *)ee[i].data.ptr;\n\t\t\tevents = ee[i].events;\n\n\t\t\tswitch (w->type) {\n\t\t\tcase UEV_IO_TYPE:\n\t\t\t\tif (events & (EPOLLHUP | EPOLLERR))\n\t\t\t\t\tuev_io_stop(w);\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_SIGNAL_TYPE:\n\t\t\t\tif (read(w->fd, &fdsi, sz) != sz) {\n\t\t\t\t\tif (uev_signal_start(w)) {\n\t\t\t\t\t\tuev_signal_stop(w);\n\t\t\t\t\t\tevents = UEV_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tmemset(&w->siginfo, 0, sizeof(w->siginfo));\n\t\t\t\t} else\n\t\t\t\t\tw->siginfo = fdsi;\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_TIMER_TYPE:\n\t\t\t\tif (read(w->fd, &exp, sizeof(exp)) != sizeof(exp)) {\n\t\t\t\t\tuev_timer_stop(w);\n\t\t\t\t\tevents = UEV_ERROR;\n\t\t\t\t}\n\n\t\t\t\tif (!w->u.t.period)\n\t\t\t\t\tw->u.t.timeout = 0;\n\t\t\t\tif (!w->u.t.timeout)\n\t\t\t\t\tuev_timer_stop(w);\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_CRON_TYPE:\n\t\t\t\tif (read(w->fd, &exp, sizeof(exp)) != sizeof(exp)) {\n\t\t\t\t\tevents = UEV_HUP;\n\t\t\t\t\tif (errno != ECANCELED) {\n\t\t\t\t\t\tuev_cron_stop(w);\n\t\t\t\t\t\tevents = UEV_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!w->u.c.interval)\n\t\t\t\t\tw->u.c.when = 0;\n\t\t\t\telse\n\t\t\t\t\tw->u.c.when += w->u.c.interval;\n\t\t\t\tif (!w->u.c.when)\n\t\t\t\t\tuev_timer_stop(w);\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_EVENT_TYPE:\n\t\t\t\tif (read(w->fd, &exp, sizeof(exp)) != sizeof(exp))\n\t\t\t\t\tevents = UEV_HUP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * NOTE: Must be last action for watcher, the\n\t\t\t *       callback may delete itself.\n\t\t\t */\n\t\t\tif (w->cb)\n\t\t\t\tw->cb(w, w->arg, events & UEV_EVENT_MASK);\n\t\t}\n\n\t\tif (flags & UEV_ONCE)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "fixing_code": ["/* libuEv - Micro event loop library\n *\n * Copyright (c) 2012       Flemming Madsen <flemming!madsen()madsensoft!dk>\n * Copyright (c) 2013-2021  Joachim Wiberg <troglobit()gmail!com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/** Micro event loop library\n * @file uev.c\n *\n */\n\n#include <errno.h>\n#include <fcntl.h>\t\t/* O_CLOEXEC */\n#include <string.h>\t\t/* memset() */\n#include <sys/epoll.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\t\t/* for select() workaround */\n#include <sys/signalfd.h>\t/* struct signalfd_siginfo */\n#include <unistd.h>\t\t/* close(), read() */\n\n#include \"uev.h\"\n\n\nstatic int _init(uev_ctx_t *ctx, int close_old)\n{\n\tint fd;\n\n\tfd = epoll_create1(EPOLL_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -1;\n\n\tif (close_old)\n\t\tclose(ctx->fd);\n\n\tctx->fd = fd;\n\n\treturn 0;\n}\n\n/* Used by file i/o workaround when epoll => EPERM */\nstatic int has_data(int fd)\n{\n\tstruct timeval timeout = { 0, 0 };\n\tfd_set fds;\n\tint n = 0;\n\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\n\tif (select(1, &fds, NULL, NULL, &timeout) > 0)\n\t\treturn ioctl(0, FIONREAD, &n) == 0 && n > 0;\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_init(uev_ctx_t *ctx, uev_t *w, uev_type_t type, uev_cb_t *cb, void *arg, int fd, int events)\n{\n\tif (!ctx || !w) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tw->ctx    = ctx;\n\tw->type   = type;\n\tw->active = 0;\n\tw->fd     = fd;\n\tw->cb     = cb;\n\tw->arg    = arg;\n\tw->events = events;\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_start(uev_t *w)\n{\n\tstruct epoll_event ev;\n\n\tif (!w || w->fd < 0 || !w->ctx) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (_uev_watcher_active(w))\n\t\treturn 0;\n\n\tev.events   = w->events | EPOLLRDHUP;\n\tev.data.ptr = w;\n\tif (epoll_ctl(w->ctx->fd, EPOLL_CTL_ADD, w->fd, &ev) < 0) {\n\t\tif (errno != EPERM)\n\t\t\treturn -1;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (w->type != UEV_IO_TYPE || w->events != UEV_READ)\n\t\t\treturn -1;\n\n\t\t/* Only allow this special handling for stdin */\n\t\tif (w->fd != STDIN_FILENO)\n\t\t\treturn -1;\n\n\t\tw->ctx->workaround = 1;\n\t\tw->active = -1;\n\t} else {\n\t\tw->active = 1;\n\t}\n\n\t/* Add to internal list for bookkeeping */\n\t_UEV_INSERT(w, w->ctx->watchers);\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_stop(uev_t *w)\n{\n\tif (!w) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (!_uev_watcher_active(w))\n\t\treturn 0;\n\n\tw->active = 0;\n\n\t/* Remove from internal list */\n\t_UEV_REMOVE(w, w->ctx->watchers);\n\n\t/* Remove from kernel */\n\tif (epoll_ctl(w->ctx->fd, EPOLL_CTL_DEL, w->fd, NULL) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_active(uev_t *w)\n{\n\tif (!w)\n\t\treturn 0;\n\n\treturn w->active > 0;\n}\n\n/* Private to libuEv, do not use directly! */\nint _uev_watcher_rearm(uev_t *w)\n{\n\tstruct epoll_event ev;\n\n\tif (!w || w->fd < 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tev.events   = w->events | EPOLLRDHUP;\n\tev.data.ptr = w;\n\tif (epoll_ctl(w->ctx->fd, EPOLL_CTL_MOD, w->fd, &ev) < 0)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/**\n * Create an event loop context\n * @param ctx  Pointer to an uev_ctx_t context to be initialized\n *\n * This function calls uev_init1() with @p maxevents set to\n * ::UEV_MAX_EVENTS\n *\n * @return POSIX OK(0) on success, or non-zero on error.\n */\nint uev_init(uev_ctx_t *ctx)\n{\n\treturn uev_init1(ctx, UEV_MAX_EVENTS);\n}\n\n/**\n * Create an event loop context\n * @param ctx       Pointer to an uev_ctx_t context to be initialized\n * @param maxevents Maximum number of events in event cache [1, 10]\n *\n * This function is the same as uev_init() except for the @p maxevents\n * argument, max ::UEV_MAX_EVENTS, which controls the number of events\n * in the event cache returned to the main loop.\n *\n * In cases where you have multiple events pending in the cache and some\n * event may cause later ones, already sent by the kernel to userspace,\n * to be deleted the pointer returned to the event loop for this later\n * event may be deleted.\n *\n * There are two ways around this (accessing deleted memory):\n *   -# use this function to initialize your event loop and set\n *      @p maxevents to 1\n *   -# use a free list in you application that you garbage collect\n *      at intervals relevant to your application\n *\n * @return POSIX OK(0) on success, or non-zero on error.\n */\nint uev_init1(uev_ctx_t *ctx, int maxevents)\n{\n\tif (!ctx || maxevents < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (maxevents > UEV_MAX_EVENTS)\n\t\tmaxevents = UEV_MAX_EVENTS;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->maxevents = maxevents;\n\n\treturn _init(ctx, 0);\n}\n\n/**\n * Terminate the event loop\n * @param ctx  A valid libuEv context\n *\n * @return POSIX OK(0) or non-zero with @p errno set on error.\n */\nint uev_exit(uev_ctx_t *ctx)\n{\n\tuev_t *w;\n\n\tif (!ctx) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t/* Remove from internal list */\n\t\t_UEV_REMOVE(w, ctx->watchers);\n\n\t\tif (!_uev_watcher_active(w))\n\t\t\tcontinue;\n\n\t\tswitch (w->type) {\n\t\tcase UEV_IO_TYPE:\n\t\t\tuev_io_stop(w);\n\t\t\tbreak;\n\n\t\tcase UEV_SIGNAL_TYPE:\n\t\t\tuev_signal_stop(w);\n\t\t\tbreak;\n\n\t\tcase UEV_TIMER_TYPE:\n\t\tcase UEV_CRON_TYPE:\n\t\t\tuev_timer_stop(w);\n\t\t\tbreak;\n\n\t\tcase UEV_EVENT_TYPE:\n\t\t\tuev_event_stop(w);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->watchers = NULL;\n\tctx->running = 0;\n\tif (ctx->fd > -1)\n\t\tclose(ctx->fd);\n\tctx->fd = -1;\n\n\treturn 0;\n}\n\n/**\n * Start the event loop\n * @param ctx    A valid libuEv context\n * @param flags  A mask of ::UEV_ONCE and ::UEV_NONBLOCK, or zero\n *\n * With @p flags set to ::UEV_ONCE the event loop returns after the first\n * event has been served, useful for instance to set a timeout on a file\n * descriptor.  If @p flags also has the ::UEV_NONBLOCK flag set the event\n * loop will return immediately if no event is pending, useful when run\n * inside another event loop.\n *\n * @return POSIX OK(0) upon successful termination of the event loop, or\n * non-zero on error.\n */\nint uev_run(uev_ctx_t *ctx, int flags)\n{\n\tint timeout = -1;\n\tuev_t *w;\n\n        if (!ctx || ctx->fd < 0) {\n\t\terrno = EINVAL;\n                return -1;\n\t}\n\n\tif (flags & UEV_NONBLOCK)\n\t\ttimeout = 0;\n\n\t/* Start the event loop */\n\tctx->running = 1;\n\n\t/* Start all dormant timers */\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\tif (UEV_CRON_TYPE == w->type)\n\t\t\tuev_cron_set(w, w->u.c.when, w->u.c.interval);\n\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint maxevents = ctx->maxevents;\n\t\tint i, nfds, rerun = 0;\n\n\t\tif (maxevents > UEV_MAX_EVENTS)\n\t\t\tmaxevents = UEV_MAX_EVENTS;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!has_data(w->fd)) {\n\t\t\t\t\tw->active = 0;\n\t\t\t\t\t_UEV_REMOVE(w, ctx->watchers);\n\t\t\t\t}\n\n\t\t\t\trerun++;\n\t\t\t\tw->cb(w, w->arg, UEV_READ);\n\t\t\t}\n\t\t}\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; /* Signalled, try again */\n\n\t\t\t/* Unrecoverable error, cleanup and exit with error. */\n\t\t\tuev_exit(ctx);\n\n\t\t\treturn -2;\n\t\t}\n\n\t\tfor (i = 0; ctx->running && i < nfds; i++) {\n\t\t\tstruct signalfd_siginfo fdsi;\n\t\t\tssize_t sz = sizeof(fdsi);\n\t\t\tuint32_t events;\n\t\t\tuint64_t exp;\n\n\t\t\tw = (uev_t *)ee[i].data.ptr;\n\t\t\tevents = ee[i].events;\n\n\t\t\tswitch (w->type) {\n\t\t\tcase UEV_IO_TYPE:\n\t\t\t\tif (events & (EPOLLHUP | EPOLLERR))\n\t\t\t\t\tuev_io_stop(w);\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_SIGNAL_TYPE:\n\t\t\t\tif (read(w->fd, &fdsi, sz) != sz) {\n\t\t\t\t\tif (uev_signal_start(w)) {\n\t\t\t\t\t\tuev_signal_stop(w);\n\t\t\t\t\t\tevents = UEV_ERROR;\n\t\t\t\t\t}\n\t\t\t\t\tmemset(&w->siginfo, 0, sizeof(w->siginfo));\n\t\t\t\t} else\n\t\t\t\t\tw->siginfo = fdsi;\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_TIMER_TYPE:\n\t\t\t\tif (read(w->fd, &exp, sizeof(exp)) != sizeof(exp)) {\n\t\t\t\t\tuev_timer_stop(w);\n\t\t\t\t\tevents = UEV_ERROR;\n\t\t\t\t}\n\n\t\t\t\tif (!w->u.t.period)\n\t\t\t\t\tw->u.t.timeout = 0;\n\t\t\t\tif (!w->u.t.timeout)\n\t\t\t\t\tuev_timer_stop(w);\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_CRON_TYPE:\n\t\t\t\tif (read(w->fd, &exp, sizeof(exp)) != sizeof(exp)) {\n\t\t\t\t\tevents = UEV_HUP;\n\t\t\t\t\tif (errno != ECANCELED) {\n\t\t\t\t\t\tuev_cron_stop(w);\n\t\t\t\t\t\tevents = UEV_ERROR;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!w->u.c.interval)\n\t\t\t\t\tw->u.c.when = 0;\n\t\t\t\telse\n\t\t\t\t\tw->u.c.when += w->u.c.interval;\n\t\t\t\tif (!w->u.c.when)\n\t\t\t\t\tuev_timer_stop(w);\n\t\t\t\tbreak;\n\n\t\t\tcase UEV_EVENT_TYPE:\n\t\t\t\tif (read(w->fd, &exp, sizeof(exp)) != sizeof(exp))\n\t\t\t\t\tevents = UEV_HUP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * NOTE: Must be last action for watcher, the\n\t\t\t *       callback may delete itself.\n\t\t\t */\n\t\t\tif (w->cb)\n\t\t\t\tw->cb(w, w->arg, events & UEV_EVENT_MASK);\n\t\t}\n\n\t\tif (flags & UEV_ONCE)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "filenames": ["src/uev.c"], "buggy_code_start_loc": [199], "buggy_code_end_loc": [345], "fixing_code_start_loc": [199], "fixing_code_end_loc": [352], "type": "CWE-120", "message": "uev (aka libuev) before 2.4.1 has a buffer overflow in epoll_wait if maxevents is a large number.", "other": {"cve": {"id": "CVE-2022-48620", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-12T04:15:08.123", "lastModified": "2024-01-20T18:44:50.393", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "uev (aka libuev) before 2.4.1 has a buffer overflow in epoll_wait if maxevents is a large number."}, {"lang": "es", "value": "uev (aka libuev) anterior a 2.4.1 tiene un desbordamiento de b\u00fafer en epoll_wait si maxevents es un n\u00famero grande."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:troglobit:libeuv:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.1", "matchCriteriaId": "BFF2C023-36E0-4067-8541-A9B49FF7361B"}]}]}], "references": [{"url": "https://github.com/troglobit/libuev/commit/2d9f1c9ce655cc38511aeeb6e95ac30914f7aec9", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/troglobit/libuev/compare/v2.4.0...v2.4.1", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/troglobit/libuev/issues/27", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}]}, "github_commit_url": "https://github.com/troglobit/libuev/commit/2d9f1c9ce655cc38511aeeb6e95ac30914f7aec9"}}