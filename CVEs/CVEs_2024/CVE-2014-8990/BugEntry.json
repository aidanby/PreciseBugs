{"buggy_code": ["--\n-- default-rsyncssh.lua\n--\n--    Improved rsync - sync with rsync, but moves and deletes executed over ssh.\n--    A (Layer 1) configuration.\n--\n-- Note:\n--    this is infact just a configuration using Layer 1 configuration\n--    like any other. It only gets compiled into the binary by default.\n--    You can simply use a modified one, by copying everything into a\n--    config file of yours and name it differently.\n--\n-- License: GPLv2 (see COPYING) or any later version\n-- Authors: Axel Kittenberger <axkibe@gmail.com>\n--\n--\n\nif not default then\n\terror( 'default not loaded' );\nend\n\nif not default.rsync then\n\terror( 'default.rsync not loaded' );\nend\n\nif default.rsyncssh then\n\terror( 'default-rsyncssh already loaded' );\nend\n\n--\n-- rsyncssh extends default.rsync\n--\nlocal rsyncssh = { default.rsync }\ndefault.rsyncssh = rsyncssh\n\n--\n-- used to ensure there aren't typos in the keys\n--\nrsyncssh.checkgauge = {\n\n\t-- unsets the inherited value of from default.rsync\n\ttarget          =  false,\n\tonMove          =  true,\n\n\t-- rsyncssh users host and targetdir\n\thost            =  true,\n\ttargetdir       =  true,\n\tsshExitCodes    =  true,\n\trsyncExitCodes  =  true,\n\n\t-- ssh settings\n\tssh = {\n\t\tbinary       =  true,\n\t\tidentityFile =  true,\n\t\toptions      =  true,\n\t\tport         =  true,\n\t\t_extra       =  true\n\t},\n\n\t-- xargs settings\n\txargs = {\n\t\tbinary      =  true,\n\t\tdelimiter   =  true,\n\t\t_extra      =  true\n\t}\n}\n\n--\n-- Spawns rsync for a list of events\n--\nrsyncssh.action = function( inlet )\n\n\tlocal event, event2 = inlet.getEvent( )\n\n\tlocal config = inlet.getConfig( )\n\n\t-- makes move local on target host\n\t-- if the move fails, it deletes the source\n\tif event.etype == 'Move' then\n\n\t\tlog(\n\t\t\t'Normal',\n\t\t\t'Moving ',\n\t\t\tevent.path,\n\t\t\t' -> ',\n\t\t\tevent2.path\n\t\t)\n\n\t\tspawn(\n\t\t\tevent,\n\t\t\tconfig.ssh.binary,\n\t\t\tconfig.ssh._computed,\n\t\t\tconfig.host,\n\t\t\t'mv',\n\t\t\t'\\\"' .. config.targetdir .. event.path .. '\\\"',\n\t\t\t'\\\"' .. config.targetdir .. event2.path .. '\\\"',\n\t\t\t'||', 'rm', '-rf',\n\t\t\t'\\\"' .. config.targetdir .. event.path .. '\\\"'\n\t\t)\n\n\t\treturn\n\tend\n\n\t-- uses ssh to delete files on remote host\n\t-- instead of constructing rsync filters\n\n\tif event.etype == 'Delete' then\n\n\t\tif\n\t\t\tconfig.delete ~= true and\n\t\t\tconfig.delete ~= 'running'\n\t\tthen\n\t\t\tinlet.discardEvent(event)\n\t\t\treturn\n\t\tend\n\n\t\t-- gets all other deletes ready to be\n\t\t-- executed\n\t\tlocal elist = inlet.getEvents(\n\t\t\tfunction( e )\n\t\t\t\treturn e.etype == 'Delete'\n\t\t\tend\n\t\t)\n\n\t\t-- returns the paths of the delete list\n\t\tlocal paths = elist.getPaths(\n\t\t\tfunction( etype, path1, path2 )\n\t\t\t\tif path2 then\n\t\t\t\t\treturn config.targetdir..path1, config.targetdir..path2\n\t\t\t\telse\n\t\t\t\t\treturn config.targetdir..path1\n\t\t\t\tend\n\t\t\tend\n\t\t)\n\n\t\t-- ensures none of the paths is '/'\n\t\tfor _, v in pairs( paths ) do\n\t\t\tif string.match(v, '^%s*/+%s*$') then\n\t\t\t\tlog('Error', 'refusing to `rm -rf /` the target!')\n\t\t\t\tterminate(-1) -- ERRNO\n\t\t\tend\n\t\tend\n\n\t\tlog(\n\t\t\t'Normal',\n\t\t\t'Deleting list\\n',\n\t\t\ttable.concat( paths, '\\n' )\n\t\t)\n\n\t\tlocal params = { }\n\n\t\tspawn(\n\t\t\telist,\n\t\t\tconfig.ssh.binary,\n\t\t\t'<', table.concat(paths, config.xargs.delimiter),\n\t\t\tparams,\n\t\t\tconfig.ssh._computed,\n\t\t\tconfig.host,\n\t\t\tconfig.xargs.binary,\n\t\t\tconfig.xargs._extra\n\t\t)\n\n\t\treturn\n\tend\n\n\t--\n\t-- for everything else a rsync is spawned\n\t--\n\tlocal elist = inlet.getEvents(\n\t\tfunction( e )\n\t\t\t-- TODO use a table\n\t\t\treturn e.etype ~= 'Move' and\n\t\t\t       e.etype ~= 'Delete' and\n\t\t\t\t   e.etype ~= 'Init' and\n\t\t\t\t   e.etype ~= 'Blanket'\n\t\tend\n\t)\n\n\tlocal paths = elist.getPaths( )\n\n\t--\n\t-- removes trailing slashes from dirs.\n\t--\n\tfor k, v in ipairs( paths ) do\n\t\tif string.byte( v, -1 ) == 47 then\n\t\t\tpaths[k] = string.sub( v, 1, -2 )\n\t\tend\n\tend\n\n\tlocal sPaths = table.concat( paths, '\\n' )\n\tlocal zPaths = table.concat( paths, '\\000' )\n\n\tlog(\n\t\t'Normal',\n\t\t'Rsyncing list\\n',\n\t\tsPaths\n\t)\n\n\tspawn(\n\t\telist,\n\t\tconfig.rsync.binary,\n\t\t'<', zPaths,\n\t\tconfig.rsync._computed,\n\t\t'--from0',\n\t\t'--files-from=-',\n\t\tconfig.source,\n\t\tconfig.host .. ':' .. config.targetdir\n\t)\nend\n\n-----\n-- Called when collecting a finished child process\n--\nrsyncssh.collect = function( agent, exitcode )\n\n\tlocal config = agent.config\n\n\tif not agent.isList and agent.etype == 'Init' then\n\t\tlocal rc = config.rsyncExitCodes[exitcode]\n\n\t\tif rc == 'ok' then\n\t\t\tlog('Normal', 'Startup of \"',agent.source,'\" finished: ', exitcode)\n\t\telseif rc == 'again' then\n\t\t\tif settings('insist') then\n\t\t\t\tlog('Normal', 'Retrying startup of \"',agent.source,'\": ', exitcode)\n\t\t\telse\n\t\t\t\tlog('Error', 'Temporary or permanent failure on startup of \"',\n\t\t\t\tagent.source, '\". Terminating since \"insist\" is not set.');\n\t\t\t\tterminate(-1) -- ERRNO\n\t\t\tend\n\n\t\telseif rc == 'die' then\n\t\t\tlog('Error', 'Failure on startup of \"',agent.source,'\": ', exitcode)\n\t\telse\n\t\t\tlog('Error', 'Unknown exitcode on startup of \"', agent.source,': \"',exitcode)\n\t\t\trc = 'die'\n\t\tend\n\n\t\treturn rc\n\n\tend\n\n\tif agent.isList then\n\t\tlocal rc = config.rsyncExitCodes[exitcode]\n\t\tif rc == 'ok' then\n\t\t\tlog('Normal', 'Finished (list): ',exitcode)\n\t\telseif rc == 'again' then\n\t\t\tlog('Normal', 'Retrying (list): ',exitcode)\n\t\telseif rc == 'die' then\n\t\t\tlog('Error',  'Failure (list): ', exitcode)\n\t\telse\n\t\t\tlog('Error', 'Unknown exitcode (list): ',exitcode)\n\t\t\trc = 'die'\n\t\tend\n\t\treturn rc\n\telse\n\t\tlocal rc = config.sshExitCodes[exitcode]\n\n\t\tif rc == 'ok' then\n\t\t\tlog('Normal', 'Finished ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\telseif rc == 'again' then\n\t\t\tlog('Normal', 'Retrying ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\telseif rc == 'die' then\n\t\t\tlog('Normal', 'Failure ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\telse\n\t\t\tlog('Error', 'Unknown exitcode ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\t\trc = 'die'\n\t\tend\n\n\t\treturn rc\n\tend\n\nend\n\n--\n-- checks the configuration.\n--\nrsyncssh.prepare = function( config, level )\n\n\tdefault.rsync.prepare( config, level + 1, true )\n\n\tif not config.host then\n\t\terror(\n\t\t\t'default.rsyncssh needs \"host\" configured',\n\t\t\tlevel\n\t\t)\n\tend\n\n\tif not config.targetdir then\n\t\terror(\n\t\t\t'default.rsyncssh needs \"targetdir\" configured',\n\t\t\tlevel\n\t\t)\n\tend\n\n\t--\n\t-- computes the ssh options\n\t--\n\tif config.ssh._computed then\n\t\terror(\n\t\t\t'please do not use the internal rsync._computed parameter',\n\t\t\tlevel\n\t\t)\n\tend\n\n\tlocal cssh =\n\t\tconfig.ssh;\n\n\tcssh._computed =\n\t\t{ }\n\n\tlocal computed =\n\t\tcssh._computed\n\n\tlocal computedN =\n\t\t1\n\n\tlocal rsyncc =\n\t\tconfig.rsync._computed\n\n\tif cssh.identityFile then\n\t\tcomputed[ computedN ] =\n\t\t\t'-i'\n\n\t\tcomputed[ computedN + 1 ] =\n\t\t\tcssh.identityFile\n\n\t\tcomputedN =\n\t\t\tcomputedN + 2\n\n\t\tif not config.rsync._rshIndex then\n\t\t\tconfig.rsync._rshIndex =\n\t\t\t\t#rsyncc + 1\n\n\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\t'--rsh=ssh'\n\t\tend\n\n\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\trsyncc[ config.rsync._rshIndex ] ..\n\t\t\t' -i ' ..\n\t\t\tcssh.identityFile\n\tend\n\n\tif cssh.options then\n\n\n\t\tfor k, v in pairs( cssh.options ) do\n\n\t\t\tcomputed[ computedN ] =\n\t\t\t\t'-o'\n\n\t\t\tcomputed[ computedN + 1 ] =\n\t\t\t\tk .. '=' .. v\n\n\t\t\tcomputedN =\n\t\t\t\tcomputedN + 2\n\n\t\t\tif not config.rsync._rshIndex then\n\t\t\t\tconfig.rsync._rshIndex =\n\t\t\t\t\t#rsyncc + 1\n\n\t\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\t\t'--rsh=ssh'\n\t\t\tend\n\n\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\ttable.concat(\n\t\t\t\t\t{\n\t\t\t\t\t\trsyncc[ config.rsync._rshIndex ],\n\t\t\t\t\t\t' -o ',\n\t\t\t\t\t\tk,\n\t\t\t\t\t\t'=',\n\t\t\t\t\t\tv\n\t\t\t\t\t},\n\t\t\t\t\t''\n\t\t\t\t)\n\t\tend\n\tend\n\n\tif cssh.port then\n\t\tcomputed[ computedN ] =\n\t\t\t'-p'\n\n\t\tcomputed[ computedN + 1 ] =\n\t\t\tcssh.port\n\n\t\tcomputedN =\n\t\t\tcomputedN + 2\n\n\t\tif not config.rsync._rshIndex then\n\t\t\tconfig.rsync._rshIndex =\n\t\t\t\t#rsyncc + 1\n\n\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\t'--rsh=ssh'\n\t\tend\n\n\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\trsyncc[ config.rsync._rshIndex ] .. ' -p ' .. cssh.port\n\tend\n\n\tif cssh._extra then\n\t\tfor k, v in ipairs( cssh._extra ) do\n\t\t\tcomputed[ computedN ] =\n\t\t\t\tv\n\n\t\t\tcomputedN =\n\t\t\t\tcomputedN  + 1\n\t\tend\n\tend\n\n\t-- appends a slash to the targetdir if missing\n\tif string.sub( config.targetdir, -1 ) ~= '/' then\n\t\tconfig.targetdir =\n\t\t\tconfig.targetdir .. '/'\n\tend\n\nend\n\n--\n-- allow processes\n--\nrsyncssh.maxProcesses =\n\t1\n\n--\n-- The core should not split move events\n--\nrsyncssh.onMove =\n\ttrue\n\n--\n-- default delay\n--\nrsyncssh.delay =\n\t15\n\n\n--\n-- no default exit codes\n--\nrsyncssh.exitcodes =\n\tfalse\n\n--\n-- rsync exit codes\n--\nrsyncssh.rsyncExitCodes =\n\tdefault.rsyncExitCodes\n\n--\n-- ssh exit codes\n--\nrsyncssh.sshExitCodes =\n\tdefault.sshExitCodes\n\n--\n-- xargs calls configuration\n--\n-- xargs is used to delete multiple remote files, when ssh access is\n-- available this is simpler than to build filters for rsync for this.\n--\nrsyncssh.xargs = {\n\n\t--\n\t-- the binary called (on target host)\n\tbinary =\n\t\t'/usr/bin/xargs',\n\n\t--\n\t-- delimiter, uses null by default, you might want to override this for older\n\t-- by for example '\\n'\n\tdelimiter =\n\t\t'\\000',\n\n\t--\n\t-- extra parameters\n\t_extra =\n\t\t{ '-0', 'rm -rf' }\n}\n\n--\n-- ssh calls configuration\n--\n-- ssh is used to move and delete files on the target host\n--\nrsyncssh.ssh = {\n\n\t--\n\t-- the binary called\n\t--\n\tbinary =\n\t\t'/usr/bin/ssh',\n\n\t--\n\t-- if set adds this key to ssh\n\t--\n\tidentityFile =\n\t\tnil,\n\n\t--\n\t-- if set adds this special options to ssh\n\t--\n\toptions =\n\t\tnil,\n\n\t--\n\t-- if set connect to this port\n\t--\n\tport =\n\t\tnil,\n\n\t--\n\t-- extra parameters\n\t--\n\t_extra =\n\t\t{ }\n}\n\n"], "fixing_code": ["--\n-- default-rsyncssh.lua\n--\n--    Improved rsync - sync with rsync, but moves and deletes executed over ssh.\n--    A (Layer 1) configuration.\n--\n-- Note:\n--    this is infact just a configuration using Layer 1 configuration\n--    like any other. It only gets compiled into the binary by default.\n--    You can simply use a modified one, by copying everything into a\n--    config file of yours and name it differently.\n--\n-- License: GPLv2 (see COPYING) or any later version\n-- Authors: Axel Kittenberger <axkibe@gmail.com>\n--\n--\n\nif not default then\n\terror( 'default not loaded' );\nend\n\nif not default.rsync then\n\terror( 'default.rsync not loaded' );\nend\n\nif default.rsyncssh then\n\terror( 'default-rsyncssh already loaded' );\nend\n\n--\n-- rsyncssh extends default.rsync\n--\nlocal rsyncssh = { default.rsync }\ndefault.rsyncssh = rsyncssh\n\n--\n-- used to ensure there aren't typos in the keys\n--\nrsyncssh.checkgauge = {\n\n\t-- unsets the inherited value of from default.rsync\n\ttarget          =  false,\n\tonMove          =  true,\n\n\t-- rsyncssh users host and targetdir\n\thost            =  true,\n\ttargetdir       =  true,\n\tsshExitCodes    =  true,\n\trsyncExitCodes  =  true,\n\n\t-- ssh settings\n\tssh = {\n\t\tbinary       =  true,\n\t\tidentityFile =  true,\n\t\toptions      =  true,\n\t\tport         =  true,\n\t\t_extra       =  true\n\t},\n\n\t-- xargs settings\n\txargs = {\n\t\tbinary      =  true,\n\t\tdelimiter   =  true,\n\t\t_extra      =  true\n\t}\n}\n\n--\n-- Spawns rsync for a list of events\n--\nrsyncssh.action = function( inlet )\n\n\tlocal event, event2 = inlet.getEvent( )\n\n\tlocal config = inlet.getConfig( )\n\n\t-- makes move local on target host\n\t-- if the move fails, it deletes the source\n\tif event.etype == 'Move' then\n\t\tlocal path1 = event.path:gsub ('\"', '\\\\\"'):gsub ('`', '\\\\`'):gsub ('%$','\\\\%$')\n\t\tlocal path2 = event2.path:gsub ('\"', '\\\\\"'):gsub ('`', '\\\\`'):gsub ('%$','\\\\%$')\n\n\t\tlog(\n\t\t\t'Normal',\n\t\t\t'Moving ',\n\t\t\tevent.path,\n\t\t\t' -> ',\n\t\t\tevent2.path\n\t\t)\n\n\t\tspawn(\n\t\t\tevent,\n\t\t\tconfig.ssh.binary,\n\t\t\tconfig.ssh._computed,\n\t\t\tconfig.host,\n\t\t\t'mv',\n\t\t\t'\\\"' .. config.targetdir .. path1 .. '\\\"',\n\t\t\t'\\\"' .. config.targetdir .. path2 .. '\\\"',\n\t\t\t'||', 'rm', '-rf',\n\t\t\t'\\\"' .. config.targetdir .. path1 .. '\\\"'\n\t\t)\n\n\t\treturn\n\tend\n\n\t-- uses ssh to delete files on remote host\n\t-- instead of constructing rsync filters\n\n\tif event.etype == 'Delete' then\n\n\t\tif\n\t\t\tconfig.delete ~= true and\n\t\t\tconfig.delete ~= 'running'\n\t\tthen\n\t\t\tinlet.discardEvent(event)\n\t\t\treturn\n\t\tend\n\n\t\t-- gets all other deletes ready to be\n\t\t-- executed\n\t\tlocal elist = inlet.getEvents(\n\t\t\tfunction( e )\n\t\t\t\treturn e.etype == 'Delete'\n\t\t\tend\n\t\t)\n\n\t\t-- returns the paths of the delete list\n\t\tlocal paths = elist.getPaths(\n\t\t\tfunction( etype, path1, path2 )\n\t\t\t\tif path2 then\n\t\t\t\t\treturn config.targetdir..path1, config.targetdir..path2\n\t\t\t\telse\n\t\t\t\t\treturn config.targetdir..path1\n\t\t\t\tend\n\t\t\tend\n\t\t)\n\n\t\t-- ensures none of the paths is '/'\n\t\tfor _, v in pairs( paths ) do\n\t\t\tif string.match(v, '^%s*/+%s*$') then\n\t\t\t\tlog('Error', 'refusing to `rm -rf /` the target!')\n\t\t\t\tterminate(-1) -- ERRNO\n\t\t\tend\n\t\tend\n\n\t\tlog(\n\t\t\t'Normal',\n\t\t\t'Deleting list\\n',\n\t\t\ttable.concat( paths, '\\n' )\n\t\t)\n\n\t\tlocal params = { }\n\n\t\tspawn(\n\t\t\telist,\n\t\t\tconfig.ssh.binary,\n\t\t\t'<', table.concat(paths, config.xargs.delimiter),\n\t\t\tparams,\n\t\t\tconfig.ssh._computed,\n\t\t\tconfig.host,\n\t\t\tconfig.xargs.binary,\n\t\t\tconfig.xargs._extra\n\t\t)\n\n\t\treturn\n\tend\n\n\t--\n\t-- for everything else a rsync is spawned\n\t--\n\tlocal elist = inlet.getEvents(\n\t\tfunction( e )\n\t\t\t-- TODO use a table\n\t\t\treturn e.etype ~= 'Move' and\n\t\t\t       e.etype ~= 'Delete' and\n\t\t\t\t   e.etype ~= 'Init' and\n\t\t\t\t   e.etype ~= 'Blanket'\n\t\tend\n\t)\n\n\tlocal paths = elist.getPaths( )\n\n\t--\n\t-- removes trailing slashes from dirs.\n\t--\n\tfor k, v in ipairs( paths ) do\n\t\tif string.byte( v, -1 ) == 47 then\n\t\t\tpaths[k] = string.sub( v, 1, -2 )\n\t\tend\n\tend\n\n\tlocal sPaths = table.concat( paths, '\\n' )\n\tlocal zPaths = table.concat( paths, '\\000' )\n\n\tlog(\n\t\t'Normal',\n\t\t'Rsyncing list\\n',\n\t\tsPaths\n\t)\n\n\tspawn(\n\t\telist,\n\t\tconfig.rsync.binary,\n\t\t'<', zPaths,\n\t\tconfig.rsync._computed,\n\t\t'--from0',\n\t\t'--files-from=-',\n\t\tconfig.source,\n\t\tconfig.host .. ':' .. config.targetdir\n\t)\nend\n\n-----\n-- Called when collecting a finished child process\n--\nrsyncssh.collect = function( agent, exitcode )\n\n\tlocal config = agent.config\n\n\tif not agent.isList and agent.etype == 'Init' then\n\t\tlocal rc = config.rsyncExitCodes[exitcode]\n\n\t\tif rc == 'ok' then\n\t\t\tlog('Normal', 'Startup of \"',agent.source,'\" finished: ', exitcode)\n\t\telseif rc == 'again' then\n\t\t\tif settings('insist') then\n\t\t\t\tlog('Normal', 'Retrying startup of \"',agent.source,'\": ', exitcode)\n\t\t\telse\n\t\t\t\tlog('Error', 'Temporary or permanent failure on startup of \"',\n\t\t\t\tagent.source, '\". Terminating since \"insist\" is not set.');\n\t\t\t\tterminate(-1) -- ERRNO\n\t\t\tend\n\n\t\telseif rc == 'die' then\n\t\t\tlog('Error', 'Failure on startup of \"',agent.source,'\": ', exitcode)\n\t\telse\n\t\t\tlog('Error', 'Unknown exitcode on startup of \"', agent.source,': \"',exitcode)\n\t\t\trc = 'die'\n\t\tend\n\n\t\treturn rc\n\n\tend\n\n\tif agent.isList then\n\t\tlocal rc = config.rsyncExitCodes[exitcode]\n\t\tif rc == 'ok' then\n\t\t\tlog('Normal', 'Finished (list): ',exitcode)\n\t\telseif rc == 'again' then\n\t\t\tlog('Normal', 'Retrying (list): ',exitcode)\n\t\telseif rc == 'die' then\n\t\t\tlog('Error',  'Failure (list): ', exitcode)\n\t\telse\n\t\t\tlog('Error', 'Unknown exitcode (list): ',exitcode)\n\t\t\trc = 'die'\n\t\tend\n\t\treturn rc\n\telse\n\t\tlocal rc = config.sshExitCodes[exitcode]\n\n\t\tif rc == 'ok' then\n\t\t\tlog('Normal', 'Finished ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\telseif rc == 'again' then\n\t\t\tlog('Normal', 'Retrying ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\telseif rc == 'die' then\n\t\t\tlog('Normal', 'Failure ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\telse\n\t\t\tlog('Error', 'Unknown exitcode ',agent.etype,' ',agent.sourcePath,': ',exitcode)\n\t\t\trc = 'die'\n\t\tend\n\n\t\treturn rc\n\tend\n\nend\n\n--\n-- checks the configuration.\n--\nrsyncssh.prepare = function( config, level )\n\n\tdefault.rsync.prepare( config, level + 1, true )\n\n\tif not config.host then\n\t\terror(\n\t\t\t'default.rsyncssh needs \"host\" configured',\n\t\t\tlevel\n\t\t)\n\tend\n\n\tif not config.targetdir then\n\t\terror(\n\t\t\t'default.rsyncssh needs \"targetdir\" configured',\n\t\t\tlevel\n\t\t)\n\tend\n\n\t--\n\t-- computes the ssh options\n\t--\n\tif config.ssh._computed then\n\t\terror(\n\t\t\t'please do not use the internal rsync._computed parameter',\n\t\t\tlevel\n\t\t)\n\tend\n\n\tlocal cssh =\n\t\tconfig.ssh;\n\n\tcssh._computed =\n\t\t{ }\n\n\tlocal computed =\n\t\tcssh._computed\n\n\tlocal computedN =\n\t\t1\n\n\tlocal rsyncc =\n\t\tconfig.rsync._computed\n\n\tif cssh.identityFile then\n\t\tcomputed[ computedN ] =\n\t\t\t'-i'\n\n\t\tcomputed[ computedN + 1 ] =\n\t\t\tcssh.identityFile\n\n\t\tcomputedN =\n\t\t\tcomputedN + 2\n\n\t\tif not config.rsync._rshIndex then\n\t\t\tconfig.rsync._rshIndex =\n\t\t\t\t#rsyncc + 1\n\n\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\t'--rsh=ssh'\n\t\tend\n\n\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\trsyncc[ config.rsync._rshIndex ] ..\n\t\t\t' -i ' ..\n\t\t\tcssh.identityFile\n\tend\n\n\tif cssh.options then\n\n\n\t\tfor k, v in pairs( cssh.options ) do\n\n\t\t\tcomputed[ computedN ] =\n\t\t\t\t'-o'\n\n\t\t\tcomputed[ computedN + 1 ] =\n\t\t\t\tk .. '=' .. v\n\n\t\t\tcomputedN =\n\t\t\t\tcomputedN + 2\n\n\t\t\tif not config.rsync._rshIndex then\n\t\t\t\tconfig.rsync._rshIndex =\n\t\t\t\t\t#rsyncc + 1\n\n\t\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\t\t'--rsh=ssh'\n\t\t\tend\n\n\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\ttable.concat(\n\t\t\t\t\t{\n\t\t\t\t\t\trsyncc[ config.rsync._rshIndex ],\n\t\t\t\t\t\t' -o ',\n\t\t\t\t\t\tk,\n\t\t\t\t\t\t'=',\n\t\t\t\t\t\tv\n\t\t\t\t\t},\n\t\t\t\t\t''\n\t\t\t\t)\n\t\tend\n\tend\n\n\tif cssh.port then\n\t\tcomputed[ computedN ] =\n\t\t\t'-p'\n\n\t\tcomputed[ computedN + 1 ] =\n\t\t\tcssh.port\n\n\t\tcomputedN =\n\t\t\tcomputedN + 2\n\n\t\tif not config.rsync._rshIndex then\n\t\t\tconfig.rsync._rshIndex =\n\t\t\t\t#rsyncc + 1\n\n\t\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\t\t'--rsh=ssh'\n\t\tend\n\n\t\trsyncc[ config.rsync._rshIndex ] =\n\t\t\trsyncc[ config.rsync._rshIndex ] .. ' -p ' .. cssh.port\n\tend\n\n\tif cssh._extra then\n\t\tfor k, v in ipairs( cssh._extra ) do\n\t\t\tcomputed[ computedN ] =\n\t\t\t\tv\n\n\t\t\tcomputedN =\n\t\t\t\tcomputedN  + 1\n\t\tend\n\tend\n\n\t-- appends a slash to the targetdir if missing\n\tif string.sub( config.targetdir, -1 ) ~= '/' then\n\t\tconfig.targetdir =\n\t\t\tconfig.targetdir .. '/'\n\tend\n\nend\n\n--\n-- allow processes\n--\nrsyncssh.maxProcesses =\n\t1\n\n--\n-- The core should not split move events\n--\nrsyncssh.onMove =\n\ttrue\n\n--\n-- default delay\n--\nrsyncssh.delay =\n\t15\n\n\n--\n-- no default exit codes\n--\nrsyncssh.exitcodes =\n\tfalse\n\n--\n-- rsync exit codes\n--\nrsyncssh.rsyncExitCodes =\n\tdefault.rsyncExitCodes\n\n--\n-- ssh exit codes\n--\nrsyncssh.sshExitCodes =\n\tdefault.sshExitCodes\n\n--\n-- xargs calls configuration\n--\n-- xargs is used to delete multiple remote files, when ssh access is\n-- available this is simpler than to build filters for rsync for this.\n--\nrsyncssh.xargs = {\n\n\t--\n\t-- the binary called (on target host)\n\tbinary =\n\t\t'/usr/bin/xargs',\n\n\t--\n\t-- delimiter, uses null by default, you might want to override this for older\n\t-- by for example '\\n'\n\tdelimiter =\n\t\t'\\000',\n\n\t--\n\t-- extra parameters\n\t_extra =\n\t\t{ '-0', 'rm -rf' }\n}\n\n--\n-- ssh calls configuration\n--\n-- ssh is used to move and delete files on the target host\n--\nrsyncssh.ssh = {\n\n\t--\n\t-- the binary called\n\t--\n\tbinary =\n\t\t'/usr/bin/ssh',\n\n\t--\n\t-- if set adds this key to ssh\n\t--\n\tidentityFile =\n\t\tnil,\n\n\t--\n\t-- if set adds this special options to ssh\n\t--\n\toptions =\n\t\tnil,\n\n\t--\n\t-- if set connect to this port\n\t--\n\tport =\n\t\tnil,\n\n\t--\n\t-- extra parameters\n\t--\n\t_extra =\n\t\t{ }\n}\n\n"], "filenames": ["default-rsyncssh.lua"], "buggy_code_start_loc": [79], "buggy_code_end_loc": [99], "fixing_code_start_loc": [80], "fixing_code_end_loc": [101], "type": "CWE-77", "message": "default-rsyncssh.lua in Lsyncd 2.1.5 and earlier allows remote attackers to execute arbitrary commands via shell metacharacters in a filename.", "other": {"cve": {"id": "CVE-2014-8990", "sourceIdentifier": "cve@mitre.org", "published": "2014-12-05T16:59:11.707", "lastModified": "2017-07-01T01:29:08.797", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "default-rsyncssh.lua in Lsyncd 2.1.5 and earlier allows remote attackers to execute arbitrary commands via shell metacharacters in a filename."}, {"lang": "es", "value": "default-rsyncssh.lua en Lsyncd 2.1.5 y anteriores permite a atacantes remotos ejecutar comandos arbitrarios a trav\u00e9s de metacaracteres de shell en un nombre de fichero."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:19:*:*:*:*:*:*:*", "matchCriteriaId": "5991814D-CA77-4C25-90D2-DB542B17E0AD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:20:*:*:*:*:*:*:*", "matchCriteriaId": "FF47C9F0-D8DA-4B55-89EB-9B2C9383ADB9"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lsyncd_project:lsyncd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.5", "matchCriteriaId": "F7C9FF9A-7845-42B1-9FF5-FC61CCCEFFB1"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-December/145114.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-December/145131.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/62321", "source": "cve@mitre.org"}, {"url": "http://www.debian.org/security/2015/dsa-3130", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/11/19/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/11/20/5", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71179", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/axkibe/lsyncd/commit/18f02ad013b41a72753912155ae2ba72f2a53e52", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Issue Tracking"]}, {"url": "https://github.com/axkibe/lsyncd/commit/e6016b3748370878778b8f0b568d5281cc248aa4", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Issue Tracking"]}, {"url": "https://github.com/axkibe/lsyncd/issues/220", "source": "cve@mitre.org", "tags": ["Patch", "Issue Tracking"]}, {"url": "https://security.gentoo.org/glsa/201702-05", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/axkibe/lsyncd/commit/18f02ad013b41a72753912155ae2ba72f2a53e52"}}