{"buggy_code": ["package paranoidhttp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"time\"\n)\n\n// Config stores the rules for allowing IP/hosts\ntype config struct {\n\tForbiddenIPNets []*net.IPNet\n\tPermittedIPNets []*net.IPNet\n\tForbiddenHosts  []*regexp.Regexp\n}\n\n// DefaultClient is the default Client whose setting is the same as http.DefaultClient.\nvar (\n\tdefaultConfig config\n\tDefaultClient *http.Client\n)\n\nfunc mustParseCIDR(addr string) *net.IPNet {\n\t_, ipnet, err := net.ParseCIDR(addr)\n\tif err != nil {\n\t\tpanic(`net: ParseCIDR(\"` + addr + `\"): ` + err.Error())\n\t}\n\treturn ipnet\n}\n\nfunc init() {\n\tdefaultConfig = config{\n\t\tForbiddenIPNets: []*net.IPNet{\n\t\t\tmustParseCIDR(\"10.0.0.0/8\"),     // private class A\n\t\t\tmustParseCIDR(\"172.16.0.0/12\"),  // private class B\n\t\t\tmustParseCIDR(\"192.168.0.0/16\"), // private class C\n\t\t\tmustParseCIDR(\"192.0.2.0/24\"),   // test net 1\n\t\t\tmustParseCIDR(\"192.88.99.0/24\"), // 6to4 relay\n\t\t},\n\t\tForbiddenHosts: []*regexp.Regexp{\n\t\t\tregexp.MustCompile(`(?i)^localhost$`),\n\t\t\tregexp.MustCompile(`(?i)\\s+`),\n\t\t},\n\t}\n\tDefaultClient, _, _ = NewClient()\n}\n\n// isHostForbidden checks whether a hostname is forbidden by the Config\nfunc (c *config) isHostForbidden(host string) bool {\n\tfor _, forbiddenHost := range c.ForbiddenHosts {\n\t\tif forbiddenHost.MatchString(host) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isIPForbidden checks whether an IP address is forbidden by the Config\nfunc (c *config) isIPForbidden(ip net.IP) bool {\n\tfor _, permittedIPNet := range c.PermittedIPNets {\n\t\tif permittedIPNet.Contains(ip) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif ip.Equal(net.IPv4bcast) || !ip.IsGlobalUnicast() {\n\t\treturn true\n\t}\n\n\tfor _, forbiddenIPNet := range c.ForbiddenIPNets {\n\t\tif forbiddenIPNet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// BasicConfig contains the most common hosts and IPs to be blocked\nfunc basicConfig() *config {\n\tc := defaultConfig // copy to return clone\n\treturn &c\n}\n\n// Option type of paranoidhttp\ntype Option func(*config)\n\n// ForbiddenIPNets sets forbidden IPNets\nfunc ForbiddenIPNets(ips ...*net.IPNet) Option {\n\treturn func(c *config) {\n\t\tc.ForbiddenIPNets = ips\n\t}\n}\n\n// PermittedIPNets sets permitted IPNets\n// It takes priority over other forbidden rules.\nfunc PermittedIPNets(ips ...*net.IPNet) Option {\n\treturn func(c *config) {\n\t\tc.PermittedIPNets = ips\n\t}\n}\n\n// ForbiddenHosts set forbidden host rules by regexp\nfunc ForbiddenHosts(hostRegs ...*regexp.Regexp) Option {\n\treturn func(c *config) {\n\t\tc.ForbiddenHosts = hostRegs\n\t}\n}\n\nfunc safeAddr(ctx context.Context, resolver *net.Resolver, hostport string, opts ...Option) (string, error) {\n\tc := basicConfig()\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\thost, port, err := net.SplitHostPort(hostport)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tip := net.ParseIP(host)\n\tif ip != nil {\n\t\tif ip.To4() != nil && c.isIPForbidden(ip) {\n\t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", ip)\n\t\t}\n\t\treturn net.JoinHostPort(ip.String(), port), nil\n\t}\n\n\tif c.isHostForbidden(host) {\n\t\treturn \"\", fmt.Errorf(\"bad host is detected: %v\", host)\n\t}\n\n\tr := resolver\n\tif r == nil {\n\t\tr = net.DefaultResolver\n\t}\n\taddrs, err := r.LookupIPAddr(ctx, host)\n\tif err != nil || len(addrs) <= 0 {\n\t\treturn \"\", err\n\t}\n\tsafeAddrs := make([]net.IPAddr, 0, len(addrs))\n\tfor _, addr := range addrs {\n\t\t// only support IPv4 address\n\t\tif addr.IP.To4() == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif c.isIPForbidden(addr.IP) {\n\t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", addr.IP)\n\t\t}\n\t\tsafeAddrs = append(safeAddrs, addr)\n\t}\n\tif len(safeAddrs) == 0 {\n\t\treturn \"\", fmt.Errorf(\"fail to lookup ip addr: %v\", host)\n\t}\n\treturn net.JoinHostPort(safeAddrs[0].IP.String(), port), nil\n}\n\n// NewDialer returns a dialer function which only accepts IPv4 connections.\n//\n// This is used to create a new paranoid http.Client,\n// because I'm not sure about a paranoid behavior for IPv6 connections :(\nfunc NewDialer(dialer *net.Dialer, opts ...Option) func(ctx context.Context, network, addr string) (net.Conn, error) {\n\treturn func(ctx context.Context, network, hostport string) (net.Conn, error) {\n\t\tswitch network {\n\t\tcase \"tcp\", \"tcp4\":\n\t\t\taddr, err := safeAddr(ctx, dialer.Resolver, hostport, opts...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn dialer.DialContext(ctx, \"tcp4\", addr)\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"does not support any networks except tcp4\")\n\t\t}\n\t}\n}\n\n// NewClient returns a new http.Client configured to be paranoid for attackers.\n//\n// This also returns http.Tranport and net.Dialer so that you can customize those behavior.\nfunc NewClient(opts ...Option) (*http.Client, *http.Transport, *net.Dialer) {\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t}\n\ttransport := &http.Transport{\n\t\tProxy:               http.ProxyFromEnvironment,\n\t\tDialContext:         NewDialer(dialer, opts...),\n\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t}\n\treturn &http.Client{\n\t\tTimeout:   30 * time.Second,\n\t\tTransport: transport,\n\t}, transport, dialer\n}\n", "package paranoidhttp\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestRequest(t *testing.T) {\n\tresp, err := DefaultClient.Get(\"http://www.example.org\")\n\tif err != nil && resp.StatusCode == 200 {\n\t\tt.Error(\"The request with an ordinal url should be successful\")\n\t}\n\n\tresp, err = DefaultClient.Get(\"http://localhost\")\n\tif err == nil {\n\t\tt.Errorf(\"The request for localhost should be fail\")\n\t}\n\n\tif _, err := DefaultClient.Get(\"http://192.168.0.1\"); err == nil {\n\t\tt.Errorf(\"The request for localhost should be fail\")\n\t}\n}\n\nfunc TestIsHostForbidden(t *testing.T) {\n\tbadHosts := []string{\n\t\t\"localhost\",\n\t\t\"host has space\",\n\t}\n\n\tfor _, h := range badHosts {\n\t\tif !basicConfig().isHostForbidden(h) {\n\t\t\tt.Errorf(\"%s should be forbidden\", h)\n\t\t}\n\t}\n\n\tnotBadHosts := []string{\n\t\t\"www.hatena.ne.jp\",\n\t\t\"www.google.com\",\n\t\t\"xn--t8jx73hngb.jp\",\n\t}\n\n\tfor _, h := range notBadHosts {\n\t\tif basicConfig().isHostForbidden(h) {\n\t\t\tt.Errorf(\"%s should not be forbidden\", h)\n\t\t}\n\t}\n}\n\nfunc TestIsIpForbidden(t *testing.T) {\n\tbadIPs := []string{\n\t\t\"0.0.0.0\",                      // Unspecified\n\t\t\"127.0.0.0\", \"127.255.255.255\", // Loopback\n\t\t\"10.0.0.0\", \"10.255.255.255\", // Private A\n\t\t\"172.16.0.0\", \"172.31.255.255\", // Private B\n\t\t\"192.168.0.0\", \"192.168.255.255\", // Private C\n\t\t\"192.0.2.0\", \"192.0.2.255\", // Test-Net\n\t\t\"192.88.99.0\", \"192.88.99.255\", // 6to4 relay\n\t\t\"224.0.0.0\", \"239.255.255.255\", // Multicast\n\t\t\"169.254.0.0\", \"169.254.255.255\", // Link local\n\t}\n\n\tfor _, ip := range badIPs {\n\t\tif !basicConfig().isIPForbidden(net.ParseIP(ip)) {\n\t\t\tt.Errorf(\"%s should be forbidden\", ip)\n\t\t}\n\t}\n\n\tnotBadIPs := []string{\n\t\t\"0.0.0.1\", \"8.8.8.8\",\n\t\t\"126.255.255.255\", \"128.0.0.0\",\n\t\t\"9.255.255.255\", \"11.0.0.0\",\n\t\t\"172.15.255.255\", \"172.32.0.0\",\n\t\t\"192.167.255.255\", \"192.169.0.0\",\n\t\t\"192.88.98.255\", \"192.88.100.0\",\n\t\t\"223.255.255.255\", \"240.0.0.0\",\n\t\t\"169.253.255.255\", \"169.255.0.0\",\n\t}\n\n\tfor _, ip := range notBadIPs {\n\t\tif basicConfig().isIPForbidden(net.ParseIP(ip)) {\n\t\t\tt.Errorf(\"%s should not be forbidden\", ip)\n\t\t}\n\t}\n\n\tc := basicConfig()\n\tip := \"172.18.0.1\"\n\tif !c.isIPForbidden(net.ParseIP(ip)) {\n\t\tt.Errorf(\"%s should be forbidden\", ip)\n\t}\n\n\tc.PermittedIPNets = append(c.PermittedIPNets, mustParseCIDR(\"172.18.0.1/32\"))\n\tif c.isIPForbidden(net.ParseIP(ip)) {\n\t\tt.Errorf(\"%s should not be forbidden\", ip)\n\t}\n}\n"], "fixing_code": ["package paranoidhttp\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"regexp\"\n\t\"time\"\n)\n\n// Config stores the rules for allowing IP/hosts\ntype config struct {\n\tForbiddenIPNets []*net.IPNet\n\tPermittedIPNets []*net.IPNet\n\tForbiddenHosts  []*regexp.Regexp\n}\n\n// DefaultClient is the default Client whose setting is the same as http.DefaultClient.\nvar (\n\tdefaultConfig config\n\tDefaultClient *http.Client\n)\n\nfunc mustParseCIDR(addr string) *net.IPNet {\n\t_, ipnet, err := net.ParseCIDR(addr)\n\tif err != nil {\n\t\tpanic(`net: ParseCIDR(\"` + addr + `\"): ` + err.Error())\n\t}\n\treturn ipnet\n}\n\nfunc init() {\n\tdefaultConfig = config{\n\t\tForbiddenIPNets: []*net.IPNet{\n\t\t\tmustParseCIDR(\"10.0.0.0/8\"),     // private class A\n\t\t\tmustParseCIDR(\"172.16.0.0/12\"),  // private class B\n\t\t\tmustParseCIDR(\"192.168.0.0/16\"), // private class C\n\t\t\tmustParseCIDR(\"192.0.2.0/24\"),   // test net 1\n\t\t\tmustParseCIDR(\"192.88.99.0/24\"), // 6to4 relay\n\t\t},\n\t\tForbiddenHosts: []*regexp.Regexp{\n\t\t\tregexp.MustCompile(`(?i)^localhost$`),\n\t\t\tregexp.MustCompile(`(?i)\\s+`),\n\t\t},\n\t}\n\tDefaultClient, _, _ = NewClient()\n}\n\n// isHostForbidden checks whether a hostname is forbidden by the Config\nfunc (c *config) isHostForbidden(host string) bool {\n\tfor _, forbiddenHost := range c.ForbiddenHosts {\n\t\tif forbiddenHost.MatchString(host) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isIPForbidden checks whether an IP address is forbidden by the Config\nfunc (c *config) isIPForbidden(ip net.IP) bool {\n\tfor _, permittedIPNet := range c.PermittedIPNets {\n\t\tif permittedIPNet.Contains(ip) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif ip.Equal(net.IPv4bcast) || !ip.IsGlobalUnicast() {\n\t\treturn true\n\t}\n\n\tfor _, forbiddenIPNet := range c.ForbiddenIPNets {\n\t\tif forbiddenIPNet.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// BasicConfig contains the most common hosts and IPs to be blocked\nfunc basicConfig() *config {\n\tc := defaultConfig // copy to return clone\n\treturn &c\n}\n\n// Option type of paranoidhttp\ntype Option func(*config)\n\n// ForbiddenIPNets sets forbidden IPNets\nfunc ForbiddenIPNets(ips ...*net.IPNet) Option {\n\treturn func(c *config) {\n\t\tc.ForbiddenIPNets = ips\n\t}\n}\n\n// PermittedIPNets sets permitted IPNets\n// It takes priority over other forbidden rules.\nfunc PermittedIPNets(ips ...*net.IPNet) Option {\n\treturn func(c *config) {\n\t\tc.PermittedIPNets = ips\n\t}\n}\n\n// ForbiddenHosts set forbidden host rules by regexp\nfunc ForbiddenHosts(hostRegs ...*regexp.Regexp) Option {\n\treturn func(c *config) {\n\t\tc.ForbiddenHosts = hostRegs\n\t}\n}\n\nfunc safeAddr(ctx context.Context, resolver *net.Resolver, hostport string, opts ...Option) (string, error) {\n\tc := basicConfig()\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\thost, port, err := net.SplitHostPort(hostport)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tip := net.ParseIP(host)\n\tif ip != nil {\n\t\tif ip.IsUnspecified() || (ip.To4() != nil && c.isIPForbidden(ip)) {\n\t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", ip)\n\t\t}\n\t\treturn net.JoinHostPort(ip.String(), port), nil\n\t}\n\n\tif c.isHostForbidden(host) {\n\t\treturn \"\", fmt.Errorf(\"bad host is detected: %v\", host)\n\t}\n\n\tr := resolver\n\tif r == nil {\n\t\tr = net.DefaultResolver\n\t}\n\taddrs, err := r.LookupIPAddr(ctx, host)\n\tif err != nil || len(addrs) <= 0 {\n\t\treturn \"\", err\n\t}\n\tsafeAddrs := make([]net.IPAddr, 0, len(addrs))\n\tfor _, addr := range addrs {\n\t\t// only support IPv4 address\n\t\tif addr.IP.To4() == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif c.isIPForbidden(addr.IP) {\n\t\t\treturn \"\", fmt.Errorf(\"bad ip is detected: %v\", addr.IP)\n\t\t}\n\t\tsafeAddrs = append(safeAddrs, addr)\n\t}\n\tif len(safeAddrs) == 0 {\n\t\treturn \"\", fmt.Errorf(\"fail to lookup ip addr: %v\", host)\n\t}\n\treturn net.JoinHostPort(safeAddrs[0].IP.String(), port), nil\n}\n\n// NewDialer returns a dialer function which only accepts IPv4 connections.\n//\n// This is used to create a new paranoid http.Client,\n// because I'm not sure about a paranoid behavior for IPv6 connections :(\nfunc NewDialer(dialer *net.Dialer, opts ...Option) func(ctx context.Context, network, addr string) (net.Conn, error) {\n\treturn func(ctx context.Context, network, hostport string) (net.Conn, error) {\n\t\tswitch network {\n\t\tcase \"tcp\", \"tcp4\":\n\t\t\taddr, err := safeAddr(ctx, dialer.Resolver, hostport, opts...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn dialer.DialContext(ctx, \"tcp4\", addr)\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"does not support any networks except tcp4\")\n\t\t}\n\t}\n}\n\n// NewClient returns a new http.Client configured to be paranoid for attackers.\n//\n// This also returns http.Tranport and net.Dialer so that you can customize those behavior.\nfunc NewClient(opts ...Option) (*http.Client, *http.Transport, *net.Dialer) {\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t}\n\ttransport := &http.Transport{\n\t\tProxy:               http.ProxyFromEnvironment,\n\t\tDialContext:         NewDialer(dialer, opts...),\n\t\tTLSHandshakeTimeout: 10 * time.Second,\n\t}\n\treturn &http.Client{\n\t\tTimeout:   30 * time.Second,\n\t\tTransport: transport,\n\t}, transport, dialer\n}\n", "package paranoidhttp\n\nimport (\n\t\"net\"\n\t\"testing\"\n)\n\nfunc TestRequest(t *testing.T) {\n\tresp, err := DefaultClient.Get(\"http://www.example.org\")\n\tif err != nil && resp.StatusCode == 200 {\n\t\tt.Error(\"The request with an ordinal url should be successful\")\n\t}\n\n\tresp, err = DefaultClient.Get(\"http://localhost\")\n\tif err == nil {\n\t\tt.Errorf(\"The request for localhost should be fail\")\n\t}\n\n\tif _, err := DefaultClient.Get(\"http://192.168.0.1\"); err == nil {\n\t\tt.Errorf(\"The request for localhost should be fail\")\n\t}\n\n\tif _, err := DefaultClient.Get(\"http://[::]\"); err == nil {\n\t\tt.Errorf(\"The request for IPv6 unspecified address should be fail\")\n\t}\n}\n\nfunc TestIsHostForbidden(t *testing.T) {\n\tbadHosts := []string{\n\t\t\"localhost\",\n\t\t\"host has space\",\n\t}\n\n\tfor _, h := range badHosts {\n\t\tif !basicConfig().isHostForbidden(h) {\n\t\t\tt.Errorf(\"%s should be forbidden\", h)\n\t\t}\n\t}\n\n\tnotBadHosts := []string{\n\t\t\"www.hatena.ne.jp\",\n\t\t\"www.google.com\",\n\t\t\"xn--t8jx73hngb.jp\",\n\t}\n\n\tfor _, h := range notBadHosts {\n\t\tif basicConfig().isHostForbidden(h) {\n\t\t\tt.Errorf(\"%s should not be forbidden\", h)\n\t\t}\n\t}\n}\n\nfunc TestIsIpForbidden(t *testing.T) {\n\tbadIPs := []string{\n\t\t\"0.0.0.0\",                      // Unspecified\n\t\t\"127.0.0.0\", \"127.255.255.255\", // Loopback\n\t\t\"10.0.0.0\", \"10.255.255.255\", // Private A\n\t\t\"172.16.0.0\", \"172.31.255.255\", // Private B\n\t\t\"192.168.0.0\", \"192.168.255.255\", // Private C\n\t\t\"192.0.2.0\", \"192.0.2.255\", // Test-Net\n\t\t\"192.88.99.0\", \"192.88.99.255\", // 6to4 relay\n\t\t\"224.0.0.0\", \"239.255.255.255\", // Multicast\n\t\t\"169.254.0.0\", \"169.254.255.255\", // Link local\n\t}\n\n\tfor _, ip := range badIPs {\n\t\tif !basicConfig().isIPForbidden(net.ParseIP(ip)) {\n\t\t\tt.Errorf(\"%s should be forbidden\", ip)\n\t\t}\n\t}\n\n\tnotBadIPs := []string{\n\t\t\"0.0.0.1\", \"8.8.8.8\",\n\t\t\"126.255.255.255\", \"128.0.0.0\",\n\t\t\"9.255.255.255\", \"11.0.0.0\",\n\t\t\"172.15.255.255\", \"172.32.0.0\",\n\t\t\"192.167.255.255\", \"192.169.0.0\",\n\t\t\"192.88.98.255\", \"192.88.100.0\",\n\t\t\"223.255.255.255\", \"240.0.0.0\",\n\t\t\"169.253.255.255\", \"169.255.0.0\",\n\t}\n\n\tfor _, ip := range notBadIPs {\n\t\tif basicConfig().isIPForbidden(net.ParseIP(ip)) {\n\t\t\tt.Errorf(\"%s should not be forbidden\", ip)\n\t\t}\n\t}\n\n\tc := basicConfig()\n\tip := \"172.18.0.1\"\n\tif !c.isIPForbidden(net.ParseIP(ip)) {\n\t\tt.Errorf(\"%s should be forbidden\", ip)\n\t}\n\n\tc.PermittedIPNets = append(c.PermittedIPNets, mustParseCIDR(\"172.18.0.1/32\"))\n\tif c.isIPForbidden(net.ParseIP(ip)) {\n\t\tt.Errorf(\"%s should not be forbidden\", ip)\n\t}\n}\n"], "filenames": ["client.go", "client_test.go"], "buggy_code_start_loc": [124, 20], "buggy_code_end_loc": [125, 20], "fixing_code_start_loc": [124, 21], "fixing_code_end_loc": [125, 25], "type": "CWE-918", "message": "Paranoidhttp before 0.3.0 allows SSRF because [::] is equivalent to the 127.0.0.1 address, but does not match the filter for private addresses.", "other": {"cve": {"id": "CVE-2023-24623", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-30T05:15:10.373", "lastModified": "2023-02-07T15:04:20.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Paranoidhttp before 0.3.0 allows SSRF because [::] is equivalent to the 127.0.0.1 address, but does not match the filter for private addresses."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:paranoidhttp_project:paranoidhttp:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.0", "matchCriteriaId": "F349DBA3-D1CA-41D5-8065-B6519D42D094"}]}]}], "references": [{"url": "https://github.com/hakobe/paranoidhttp/blob/master/CHANGELOG.md#v030-2023-01-19", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/hakobe/paranoidhttp/commit/07f671da14ce63a80f4e52432b32e8d178d75fd3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/hakobe/paranoidhttp/compare/v0.2.0...v0.3.0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hakobe/paranoidhttp/commit/07f671da14ce63a80f4e52432b32e8d178d75fd3"}}