{"buggy_code": ["\n#ifndef ACOMMON_OBJSTACK__HPP\n#define ACOMMON_OBJSTACK__HPP\n\n#include \"parm_string.hpp\"\n#include <stdlib.h>\n#include <assert.h>\n\nnamespace acommon {\n\nclass ObjStack\n{\n  typedef unsigned char byte;\n  struct Node\n  {\n    Node * next;\n    byte data[1]; // hack for data[]\n  };\n  size_t chunk_size;\n  size_t min_align;\n  Node * first;\n  Node * first_free;\n  Node * reserve;\n  byte * top;\n  byte * bottom;\n  byte * temp_end;\n  void setup_chunk();\n  void new_chunk();\n\n  ObjStack(const ObjStack &);\n  void operator=(const ObjStack &);\n\n  void align_bottom(size_t align) {\n    size_t a = (size_t)bottom % align;\n    if (a != 0) bottom += align - a;\n  }\n  void align_top(size_t align) {\n    top -= (size_t)top % align;\n  }\npublic:\n  // The alignment here is the guaranteed alignment that memory in\n  // new chunks will be aligned to.   It does NOT guarantee that\n  // every object is aligned as such unless all objects inserted\n  // are a multiple of align.\n  ObjStack(size_t chunk_s = 1024, size_t align = sizeof(void *));\n  ~ObjStack();\n\n  size_t calc_size();\n\n  void reset();\n  void trim();\n  \n  // This alloc_bottom does NOT check alignment.  However, if you always\n  // insert objects with a multiple of min_align than it will always\n  // me aligned as such.\n  void * alloc_bottom(size_t size)  {\n    byte * tmp = bottom;\n    bottom += size;\n    if (bottom > top) {new_chunk(); tmp = bottom; bottom += size;}\n    return tmp;\n  }\n  // This alloc_bottom will insure that the object is aligned based on the\n  // alignment given.\n  void * alloc_bottom(size_t size, size_t align) \n  {loop:\n    align_bottom(align);\n    byte * tmp = bottom;\n    bottom += size;\n    if (bottom > top) {new_chunk(); goto loop;}\n    return tmp;\n  }\n  char * dup_bottom(ParmString str) {\n    return (char *)memcpy(alloc_bottom(str.size() + 1), \n                          str.str(), str.size() + 1);\n  }\n\n  // This alloc_bottom does NOT check alignment.  However, if you\n  // always insert objects with a multiple of min_align than it will\n  // always be aligned as such.\n  void * alloc_top(size_t size) {\n    top -= size;\n    if (top < bottom) {new_chunk(); top -= size;}\n    return top;\n  }\n  // This alloc_top will insure that the object is aligned based on\n  // the alignment given.\n  void * alloc_top(size_t size, size_t align) \n  {loop:\n    top -= size;\n    align_top(align);\n    if (top < bottom) {new_chunk(); goto loop;}\n    return top;\n  }\n  char * dup_top(ParmString str) {\n    return (char *)memcpy(alloc_top(str.size() + 1), \n                          str.str(), str.size() + 1);\n  }\n\n  // By default objects are allocated from the top since that is sligtly\n  // more efficient\n  void * alloc(size_t size) {return alloc_top(size);}\n  void * alloc(size_t size, size_t align) {return alloc_top(size,align);}\n  char * dup(ParmString str) {return dup_top(str);}\n\n  // alloc_temp allocates an object from the bottom which can be\n  // resized until it is committed.  If the resizing will involve\n  // moving the object than the data will be copied in the same way\n  // realloc does.  Any previously allocated objects are aborted when\n  // alloc_temp is called.\n  void * temp_ptr() {\n    if (temp_end) return bottom;\n    else return 0;\n  }\n  unsigned temp_size() {\n    return temp_end - bottom;\n  }\n  void * alloc_temp(size_t size) {\n    temp_end = bottom + size;\n    if (temp_end > top) {\n      new_chunk();\n      temp_end = bottom + size;\n    }\n    return bottom;\n  }\n  // returns a pointer the the new beginning of the temp memory\n  void * resize_temp(size_t size) {\n    if (temp_end == 0)\n      return alloc_temp(size);\n    if (bottom + size <= top) {\n      temp_end = bottom + size;\n    } else {\n      size_t s = temp_end - bottom;\n      byte * p = bottom;\n      new_chunk();\n      memcpy(bottom, p, s);\n      temp_end = bottom + size;\n    }\n    return bottom;\n  }\n  // returns a pointer to the beginning of the new memory (in\n  // otherwords the END of the temp memory BEFORE the call to grow\n  // temp) NOT the beginning if the temp memory\n  void * grow_temp(size_t s) {\n    if (temp_end == 0)\n      return alloc_temp(s);\n    unsigned old_size = temp_end - bottom;\n    unsigned size = old_size + s;\n    if (bottom + size <= top) {\n      temp_end = bottom + size;\n    } else {\n      size_t s = temp_end - bottom;\n      byte * p = bottom;\n      new_chunk();\n      memcpy(bottom, p, s);\n      temp_end = bottom + size;\n    }\n    return bottom + old_size;\n  }\n  void abort_temp() {\n    temp_end = 0;}\n  void commit_temp() {\n    bottom = temp_end;\n    temp_end = 0;}\n\n  typedef Node Memory;\n  Memory * freeze();\n  static void dealloc(Memory *);\n};\n\ntypedef ObjStack StringBuffer;\n\n}\n\n#endif\n"], "fixing_code": ["\n#ifndef ACOMMON_OBJSTACK__HPP\n#define ACOMMON_OBJSTACK__HPP\n\n#include \"parm_string.hpp\"\n#include <stdlib.h>\n#include <assert.h>\n#include <stddef.h>\n\nnamespace acommon {\n\nclass ObjStack\n{\n  typedef unsigned char byte;\n  struct Node\n  {\n    Node * next;\n    byte data[1]; // hack for data[]\n  };\n  size_t chunk_size;\n  size_t min_align;\n  Node * first;\n  Node * first_free;\n  Node * reserve;\n  byte * top;\n  byte * bottom;\n  byte * temp_end;\n  void setup_chunk();\n  void new_chunk();\n  bool will_overflow(size_t sz) const {\n    return offsetof(Node,data) + sz > chunk_size;\n  }\n  void check_size(size_t sz) {\n    assert(!will_overflow(sz));\n  }\n\n  ObjStack(const ObjStack &);\n  void operator=(const ObjStack &);\n\n  void align_bottom(size_t align) {\n    size_t a = (size_t)bottom % align;\n    if (a != 0) bottom += align - a;\n  }\n  void align_top(size_t align) {\n    top -= (size_t)top % align;\n  }\npublic:\n  // The alignment here is the guaranteed alignment that memory in\n  // new chunks will be aligned to.   It does NOT guarantee that\n  // every object is aligned as such unless all objects inserted\n  // are a multiple of align.\n  ObjStack(size_t chunk_s = 1024, size_t align = sizeof(void *));\n  ~ObjStack();\n\n  size_t calc_size();\n\n  void reset();\n  void trim();\n  \n  // This alloc_bottom does NOT check alignment.  However, if you always\n  // insert objects with a multiple of min_align than it will always\n  // me aligned as such.\n  void * alloc_bottom(size_t size)  {\n    byte * tmp = bottom;\n    bottom += size;\n    if (bottom > top) {check_size(size); new_chunk(); tmp = bottom; bottom += size;}\n    return tmp;\n  }\n  // This alloc_bottom will insure that the object is aligned based on the\n  // alignment given.\n  void * alloc_bottom(size_t size, size_t align) \n  {loop:\n    align_bottom(align);\n    byte * tmp = bottom;\n    bottom += size;\n    if (bottom > top) {check_size(size); new_chunk(); goto loop;}\n    return tmp;\n  }\n  char * dup_bottom(ParmString str) {\n    return (char *)memcpy(alloc_bottom(str.size() + 1), \n                          str.str(), str.size() + 1);\n  }\n\n  // This alloc_bottom does NOT check alignment.  However, if you\n  // always insert objects with a multiple of min_align than it will\n  // always be aligned as such.\n  void * alloc_top(size_t size) {\n    top -= size;\n    if (top < bottom) {check_size(size); new_chunk(); top -= size;}\n    return top;\n  }\n  // This alloc_top will insure that the object is aligned based on\n  // the alignment given.\n  void * alloc_top(size_t size, size_t align) \n  {loop:\n    top -= size;\n    align_top(align);\n    if (top < bottom) {check_size(size); new_chunk(); goto loop;}\n    return top;\n  }\n  char * dup_top(ParmString str) {\n    return (char *)memcpy(alloc_top(str.size() + 1), \n                          str.str(), str.size() + 1);\n  }\n\n  // By default objects are allocated from the top since that is sligtly\n  // more efficient\n  void * alloc(size_t size) {return alloc_top(size);}\n  void * alloc(size_t size, size_t align) {return alloc_top(size,align);}\n  char * dup(ParmString str) {return dup_top(str);}\n\n  // alloc_temp allocates an object from the bottom which can be\n  // resized until it is committed.  If the resizing will involve\n  // moving the object than the data will be copied in the same way\n  // realloc does.  Any previously allocated objects are aborted when\n  // alloc_temp is called.\n  void * temp_ptr() {\n    if (temp_end) return bottom;\n    else return 0;\n  }\n  unsigned temp_size() {\n    return temp_end - bottom;\n  }\n  void * alloc_temp(size_t size) {\n    temp_end = bottom + size;\n    if (temp_end > top) {\n      check_size(size);\n      new_chunk();\n      temp_end = bottom + size;\n    }\n    return bottom;\n  }\n  // returns a pointer the the new beginning of the temp memory\n  void * resize_temp(size_t size) {\n    if (temp_end == 0)\n      return alloc_temp(size);\n    if (bottom + size <= top) {\n      temp_end = bottom + size;\n    } else {\n      size_t s = temp_end - bottom;\n      byte * p = bottom;\n      check_size(size);\n      new_chunk();\n      memcpy(bottom, p, s);\n      temp_end = bottom + size;\n    }\n    return bottom;\n  }\n  // returns a pointer to the beginning of the new memory (in\n  // otherwords the END of the temp memory BEFORE the call to grow\n  // temp) NOT the beginning if the temp memory\n  void * grow_temp(size_t s) {\n    if (temp_end == 0)\n      return alloc_temp(s);\n    unsigned old_size = temp_end - bottom;\n    unsigned size = old_size + s;\n    if (bottom + size <= top) {\n      temp_end = bottom + size;\n    } else {\n      size_t s = temp_end - bottom;\n      byte * p = bottom;\n      check_size(size);\n      new_chunk();\n      memcpy(bottom, p, s);\n      temp_end = bottom + size;\n    }\n    return bottom + old_size;\n  }\n  void abort_temp() {\n    temp_end = 0;}\n  void commit_temp() {\n    bottom = temp_end;\n    temp_end = 0;}\n\n  typedef Node Memory;\n  Memory * freeze();\n  static void dealloc(Memory *);\n};\n\ntypedef ObjStack StringBuffer;\n\n}\n\n#endif\n"], "filenames": ["common/objstack.hpp"], "buggy_code_start_loc": [7], "buggy_code_end_loc": [152], "fixing_code_start_loc": [8], "fixing_code_end_loc": [163], "type": "CWE-787", "message": "objstack in GNU Aspell 0.60.8 has a heap-based buffer overflow in acommon::ObjStack::dup_top (called from acommon::StringMap::add and acommon::Config::lookup_list).", "other": {"cve": {"id": "CVE-2019-25051", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-20T07:15:07.677", "lastModified": "2021-09-20T12:22:03.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "objstack in GNU Aspell 0.60.8 has a heap-based buffer overflow in acommon::ObjStack::dup_top (called from acommon::StringMap::add and acommon::Config::lookup_list)."}, {"lang": "es", "value": "objstack en GNU Aspell versi\u00f3n 0.60.8, presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n acommon::ObjStack::dup_top (llamado desde acommon::StringMap::add y acommon::Config::lookup_list)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnu:aspell:0.60.8:*:*:*:*:*:*:*", "matchCriteriaId": "78A18DCB-EADB-4DD1-90D9-8A35584C82D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=18462", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/gnuaspell/aspell/commit/0718b375425aad8e54e1150313b862e4c6fd324a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/google/oss-fuzz-vulns/blob/main/vulns/aspell/OSV-2020-521.yaml", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/07/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/H7E4EI7F6TVN7K6XWU6HSANMCOKKEREE/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4948", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gnuaspell/aspell/commit/0718b375425aad8e54e1150313b862e4c6fd324a"}}