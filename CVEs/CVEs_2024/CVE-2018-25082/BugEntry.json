{"buggy_code": ["# -*- coding: utf-8 -*-\n\n\nfrom __future__ import unicode_literals\n\nimport time\nimport hashlib\n\nfrom datetime import datetime\n\nfrom .base import WeixinError\n\ntry:\n    from flask import request, Response\nexcept ImportError:\n    request, Response = None, None\n\ntry:\n    from django.http import HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed\nexcept Exception:\n    HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed = None, None, None\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    from xml.etree import cElementTree as etree\nexcept ImportError:\n    from xml.etree import ElementTree as etree\n\n\n__all__ = (\"WeixinMsgError\", \"WeixinMsg\")\n\n\nclass WeixinMsgError(WeixinError):\n\n    def __init__(self, msg):\n        super(WeixinMsgError, self).__init__(msg)\n\n\nclass WeixinMsg(object):\n\n    def __init__(self, token, sender=None, expires_in=0):\n        self.token = token\n        self.sender = sender\n        self.expires_in = expires_in\n        self._registry = dict()\n\n    def validate(self, signature, timestamp, nonce):\n        if not self.token:\n            raise WeixinMsgError(\"weixin token is missing\")\n\n        if self.expires_in:\n            try:\n                timestamp = int(timestamp)\n            except ValueError:\n                return False\n            delta = time.time() - timestamp\n            if delta < 0 or delta > self.expires_in:\n                return False\n        values = [self.token, str(timestamp), str(nonce)]\n        s = ''.join(sorted(values))\n        hsh = hashlib.sha1(s.encode(\"utf-8\")).hexdigest()\n        return signature == hsh\n\n    def parse(self, content):\n        raw = {}\n        root = etree.fromstring(content)\n        for child in root:\n            raw[child.tag] = child.text\n\n        formatted = self.format(raw)\n        msg_type = formatted['type']\n        msg_parser = getattr(self, 'parse_{0}'.format(msg_type), None)\n        if callable(msg_parser):\n            parsed = msg_parser(raw)\n        else:\n            parsed = self.parse_invalid_type(raw)\n\n        formatted.update(parsed)\n        return formatted\n\n    def format(self, kwargs):\n        timestamp = int(kwargs['CreateTime'])\n        return {\n            'id': kwargs.get('MsgId'),\n            'timestamp': timestamp,\n            'receiver': kwargs['ToUserName'],\n            'sender': kwargs['FromUserName'],\n            'type': kwargs['MsgType'],\n            'time': datetime.fromtimestamp(timestamp),\n        }\n\n    def parse_text(self, raw):\n        return {'content': raw['Content']}\n\n    def parse_image(self, raw):\n        return {'picurl': raw['PicUrl']}\n\n    def parse_location(self, raw):\n        return {\n            'location_x': raw['Location_X'],\n            'location_y': raw['Location_Y'],\n            'scale': int(raw.get('Scale', 0)),\n            'label': raw['Label'],\n        }\n\n    def parse_link(self, raw):\n        return {\n            'title': raw['Title'],\n            'description': raw['Description'],\n            'url': raw['url'],\n        }\n\n    def parse_voice(self, raw):\n        return {\n            'media_id': raw['MediaId'],\n            'format': raw['Format'],\n            'recognition': raw['Recognition'],\n        }\n\n    def parse_video(self, raw):\n        return {\n            'media_id': raw['MediaId'],\n            'thumb_media_id': raw['ThumbMediaId'],\n        }\n\n    def parse_shortvideo(self, raw):\n        return {\n            'media_id': raw['MediaId'],\n            'thumb_media_id': raw['ThumbMediaId'],\n        }\n\n    def parse_event(self, raw):\n        return {\n            'event': raw.get('Event'),\n            'event_key': raw.get('EventKey'),\n            'ticket': raw.get('Ticket'),\n            'latitude': raw.get('Latitude'),\n            'longitude': raw.get('Longitude'),\n            'precision': raw.get('Precision'),\n            'status': raw.get('status')\n        }\n\n    def parse_invalid_type(self, raw):\n        return {}\n\n    def reply(self, username=None, type='text', sender=None, **kwargs):\n        if not username:\n            raise RuntimeError(\"username is missing\")\n        sender = sender or self.sender\n        if not sender:\n            raise RuntimeError('WEIXIN_SENDER or sender argument is missing')\n\n        if type == 'text':\n            content = kwargs.get('content', '')\n            return text_reply(username, sender, content)\n\n        if type == 'music':\n            values = {}\n            for k in ('title', 'description', 'music_url', 'hq_music_url'):\n                values[k] = kwargs[k]\n            return music_reply(username, sender, **values)\n\n        if type == 'news':\n            items = kwargs['articles']\n            return news_reply(username, sender, *items)\n\n        if type == 'customer_service':\n            service_account = kwargs['service_account']\n            return transfer_customer_service_reply(username, sender,\n                                                   service_account)\n\n        if type == 'image':\n            media_id = kwargs.get('media_id')\n            return image_reply(username, sender, media_id)\n\n        if type == 'voice':\n            media_id = kwargs.get('media_id')\n            return voice_reply(username, sender, media_id)\n\n        if type == 'video':\n            values = {}\n            for k in ('media_id', 'title', 'description'):\n                values[k] = kwargs[k]\n            return video_reply(username, sender, **values)\n\n    def register(self, type, key=None, func=None):\n        if func:\n            key = '*' if not key else key\n            self._registry.setdefault(type, dict())[key] = func\n            return func\n        return self.__call__(type, key)\n\n    def __call__(self, type, key):\n        def wrapper(func):\n            self.register(type, key, func)\n            return func\n        return wrapper\n\n    @property\n    def all(self):\n        return self.register('*')\n\n    def text(self, key='*'):\n        return self.register('text', key)\n\n    def __getattr__(self, key):\n        key = key.lower()\n        if key in ['image', 'video', 'voice', 'shortvideo', 'location', 'link', 'event']:\n            return self.register(key)\n        if key in ['subscribe', 'unsubscribe', 'location', 'click', 'view', 'scan', \\\n                   'scancode_push', 'scancode_waitmsg', 'pic_sysphoto', \\\n                   'pic_photo_or_album', 'pic_weixin', 'location_select', \\\n                   'qualification_verify_success', 'qualification_verify_fail', 'naming_verify_success', \\\n                   'naming_verify_fail', 'annual_renew', 'verify_expired', \\\n                   'card_pass_check', 'user_get_card', 'user_del_card', 'user_consume_card', \\\n                   'user_pay_from_pay_cell', 'user_view_card', 'user_enter_session_from_card', \\\n                   'card_sku_remind']:\n            return self.register('event', key)\n        raise AttributeError('invalid attribute \"' + key + '\"')\n\n    def django_view_func(self):\n\n        def run(request):\n            if HttpResponse is None:\n                raise RuntimeError('django_view_func need Django be installed')\n            signature = request.GET.get('signature')\n\n            timestamp = request.GET.get('timestamp')\n            nonce = request.GET.get('nonce')\n            if not self.validate(signature, timestamp, nonce):\n                return HttpResponseForbidden('signature failed')\n            if request.method == 'GET':\n                echostr = request.args.get('echostr', '')\n                return HttpResponse(echostr)\n            elif request.method == \"POST\":\n                try:\n                    ret = self.parse(request.body)\n                except ValueError:\n                    return HttpResponseForbidden('invalid')\n\n                func = None\n                type = ret['type']\n                _registry = self._registry.get(type, dict())\n                if type == 'text':\n                    if ret['content'] in _registry:\n                        func = _registry[ret['content']]\n                elif type == 'event':\n                    if ret['event'].lower() in _registry:\n                        func = _registry[ret['event'].lower()]\n\n                if func is None and '*' in _registry:\n                    func = _registry['*']\n                if func is None and '*' in self._registry:\n                    func = self._registry.get('*', dict()).get('*')\n\n                text = ''\n                if func is None:\n                    text = 'failed'\n\n                if callable(func):\n                    text = func(**ret)\n\n                content = ''\n                if isinstance(text, basestring):\n                    if text:\n                        content = self.reply(\n                            username=ret['sender'],\n                            sender=ret['receiver'],\n                            content=text,\n                        )\n                elif isinstance(text, dict):\n                    text.setdefault('username', ret['sender'])\n                    text.setdefault('sender', ret['receiver'])\n                    content = self.reply(**text)\n\n                return HttpResponse(content, content_type='text/xml; charset=utf-8')\n            return HttpResponseNotAllowed(['GET', 'POST'])\n        return run\n\n    def view_func(self):\n        if request is None:\n            raise RuntimeError('view_func need Flask be installed')\n\n        signature = request.args.get('signature')\n        timestamp = request.args.get('timestamp')\n        nonce = request.args.get('nonce')\n        if not self.validate(signature, timestamp, nonce):\n            return 'signature failed', 400\n        if request.method == 'GET':\n            echostr = request.args.get('echostr', '')\n            return echostr\n\n        try:\n            ret = self.parse(request.data)\n        except ValueError:\n            return 'invalid', 400\n\n        func = None\n        type = ret['type']\n        _registry = self._registry.get(type, dict())\n        if type == 'text':\n            if ret['content'] in _registry:\n                func = _registry[ret['content']]\n        elif type == 'event':\n            if ret['event'].lower() in _registry:\n                func = _registry[ret['event'].lower()]\n\n        if func is None and '*' in _registry:\n            func = _registry['*']\n        if func is None and '*' in self._registry:\n            func = self._registry.get('*', dict()).get('*')\n\n        text = ''\n        if func is None:\n            text = 'failed'\n\n        if callable(func):\n            text = func(**ret)\n\n        content = ''\n        if isinstance(text, basestring):\n            if text:\n                content = self.reply(\n                    username=ret['sender'],\n                    sender=ret['receiver'],\n                    content=text,\n                )\n        elif isinstance(text, dict):\n            text.setdefault('username', ret['sender'])\n            text.setdefault('sender', ret['receiver'])\n            content = self.reply(**text)\n\n        return Response(content, content_type='text/xml; charset=utf-8')\n\n    view_func.methods = ['GET', 'POST']\n\n\ndef text_reply(username, sender, content):\n    shared = _shared_reply(username, sender, 'text')\n    template = '<xml>%s<Content><![CDATA[%s]]></Content></xml>'\n    return template % (shared, content)\n\n\ndef music_reply(username, sender, **kwargs):\n    kwargs['shared'] = _shared_reply(username, sender, 'music')\n\n    template = (\n        '<xml>'\n        '%(shared)s'\n        '<Music>'\n        '<Title><![CDATA[%(title)s]]></Title>'\n        '<Description><![CDATA[%(description)s]]></Description>'\n        '<MusicUrl><![CDATA[%(music_url)s]]></MusicUrl>'\n        '<HQMusicUrl><![CDATA[%(hq_music_url)s]]></HQMusicUrl>'\n        '</Music>'\n        '</xml>'\n    )\n    return template % kwargs\n\n\ndef news_reply(username, sender, *items):\n    item_template = (\n        '<item>'\n        '<Title><![CDATA[%(title)s]]></Title>'\n        '<Description><![CDATA[%(description)s]]></Description>'\n        '<PicUrl><![CDATA[%(picurl)s]]></PicUrl>'\n        '<Url><![CDATA[%(url)s]]></Url>'\n        '</item>'\n    )\n    articles = [item_template % o for o in items]\n\n    template = (\n        '<xml>'\n        '%(shared)s'\n        '<ArticleCount>%(count)d</ArticleCount>'\n        '<Articles>%(articles)s</Articles>'\n        '</xml>'\n    )\n    dct = {\n        'shared': _shared_reply(username, sender, 'news'),\n        'count': len(items),\n        'articles': ''.join(articles)\n    }\n    return template % dct\n\n\ndef transfer_customer_service_reply(username, sender, service_account):\n    template = (\n        '<xml>%(shared)s'\n        '%(transfer_info)s</xml>')\n    transfer_info = ''\n    if service_account:\n        transfer_info = (\n            '<TransInfo>'\n            '<KfAccount>![CDATA[%s]]</KfAccount>'\n            '</TransInfo>') % service_account\n\n    dct = {\n        'shared': _shared_reply(username, sender,\n                                type='transfer_customer_service'),\n        'transfer_info': transfer_info\n    }\n    return template % dct\n\n\ndef image_reply(username, sender, media_id):\n    shared = _shared_reply(username, sender, 'image')\n    template = '<xml>%s<Image><MediaId><![CDATA[%s]]></MediaId></Image></xml>'\n    return template % (shared, media_id)\n\n\ndef voice_reply(username, sender, media_id):\n    shared = _shared_reply(username, sender, 'voice')\n    template = '<xml>%s<Voice><MediaId><![CDATA[%s]]></MediaId></Voice></xml>'\n    return template % (shared, media_id)\n\n\ndef video_reply(username, sender, **kwargs):\n    kwargs['shared'] = _shared_reply(username, sender, 'video')\n\n    template = (\n        '<xml>'\n        '%(shared)s'\n        '<Video>'\n        '<MediaId><![CDATA[%(media_id)s]]></MediaId>'\n        '<Title><![CDATA[%(title)s]]></Title>'\n        '<Description><![CDATA[%(description)s]]></Description>'\n        '</Video>'\n        '</xml>'\n    )\n    return template % kwargs\n\n\ndef _shared_reply(username, sender, type):\n    dct = {\n        'username': username,\n        'sender': sender,\n        'type': type,\n        'timestamp': int(time.time()),\n    }\n    template = (\n        '<ToUserName><![CDATA[%(username)s]]></ToUserName>'\n        '<FromUserName><![CDATA[%(sender)s]]></FromUserName>'\n        '<CreateTime>%(timestamp)d</CreateTime>'\n        '<MsgType><![CDATA[%(type)s]]></MsgType>'\n    )\n    return template % dct\n", "# -*- coding: utf-8 -*-\n\n\nfrom __future__ import unicode_literals\n\nimport time\nimport string\nimport random\nimport hashlib\nimport requests\n\nfrom .base import Map, WeixinError\n\ntry:\n    from flask import request\nexcept Exception:\n    request = None\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    from xml.etree import cElementTree as etree\nexcept ImportError:\n    from xml.etree import ElementTree as etree\n\n\n__all__ = (\"WeixinPayError\", \"WeixinPay\")\n\n\nFAIL = \"FAIL\"\nSUCCESS = \"SUCCESS\"\n\n\nclass WeixinPayError(WeixinError):\n\n    def __init__(self, msg):\n        super(WeixinPayError, self).__init__(msg)\n\n\nclass WeixinPay(object):\n\n    def __init__(self, app_id, mch_id, mch_key, notify_url, key=None, cert=None):\n        self.app_id = app_id\n        self.mch_id = mch_id\n        self.mch_key = mch_key\n        self.notify_url = notify_url\n        self.key = key\n        self.cert = cert\n        self.sess = requests.Session()\n\n    @property\n    def remote_addr(self):\n        if request is not None:\n            return request.remote_addr\n        return \"\"\n\n    @property\n    def nonce_str(self):\n        char = string.ascii_letters + string.digits\n        return \"\".join(random.choice(char) for _ in range(32))\n\n    def sign(self, raw):\n        raw = [(k, str(raw[k]) if isinstance(raw[k], int) else raw[k])\n               for k in sorted(raw.keys())]\n        s = \"&\".join(\"=\".join(kv) for kv in raw if kv[1])\n        s += \"&key={0}\".format(self.mch_key)\n        return hashlib.md5(s.encode(\"utf-8\")).hexdigest().upper()\n\n    def check(self, data):\n        sign = data.pop(\"sign\")\n        return sign == self.sign(data)\n\n    def to_xml(self, raw):\n        s = \"\"\n        for k, v in raw.items():\n            s += \"<{0}>{1}</{0}>\".format(k, v)\n        s = \"<xml>{0}</xml>\".format(s)\n        return s.encode(\"utf-8\")\n\n    def to_dict(self, content):\n        raw = {}\n        root = etree.fromstring(content.encode(\"utf-8\"))\n        for child in root:\n            raw[child.tag] = child.text\n        return raw\n\n    def _fetch(self, url, data, use_cert=False):\n        data.setdefault(\"appid\", self.app_id)\n        data.setdefault(\"mch_id\", self.mch_id)\n        data.setdefault(\"nonce_str\", self.nonce_str)\n        data.setdefault(\"sign\", self.sign(data))\n\n        if use_cert:\n            resp = self.sess.post(url, data=self.to_xml(data), cert=(self.cert, self.key))\n        else:\n            resp = self.sess.post(url, data=self.to_xml(data))\n        content = resp.content.decode(\"utf-8\")\n        if \"return_code\" in content:\n            data = Map(self.to_dict(content))\n            if data.return_code == FAIL:\n                raise WeixinPayError(data.return_msg)\n            if \"result_code\" in content and data.result_code == FAIL:\n                raise WeixinPayError(data.err_code_des)\n            return data\n        return content\n\n    def reply(self, msg, ok=True):\n        code = SUCCESS if ok else FAIL\n        return self.to_xml(dict(return_code=code, return_msg=msg))\n\n    def unified_order(self, **data):\n        \"\"\"\n        \u7edf\u4e00\u4e0b\u5355\n        out_trade_no\u3001body\u3001total_fee\u3001trade_type\u5fc5\u586b\n        app_id, mchid, nonce_str\u81ea\u52a8\u586b\u5199\n        spbill_create_ip \u5728flask\u6846\u67b6\u4e0b\u53ef\u4ee5\u81ea\u52a8\u586b\u5199, \u975eflask\u6846\u67b6\u9700\u8981\u4e3b\u52a8\u4f20\u5165\u6b64\u53c2\u6570\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/unifiedorder\"\n\n        # \u5fc5\u586b\u53c2\u6570\n        if \"out_trade_no\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570out_trade_no\")\n        if \"body\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570body\")\n        if \"total_fee\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570total_fee\")\n        if \"trade_type\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570trade_type\")\n\n        # \u5173\u8054\u53c2\u6570\n        if data[\"trade_type\"] == \"JSAPI\" and \"openid\" not in data:\n            raise WeixinPayError(\"trade_type\u4e3aJSAPI\u65f6\uff0copenid\u4e3a\u5fc5\u586b\u53c2\u6570\")\n        if data[\"trade_type\"] == \"NATIVE\" and \"product_id\" not in data:\n            raise WeixinPayError(\"trade_type\u4e3aNATIVE\u65f6\uff0cproduct_id\u4e3a\u5fc5\u586b\u53c2\u6570\")\n        data.setdefault(\"notify_url\", self.notify_url)\n        if \"spbill_create_ip\" not in data:\n            data.setdefault(\"spbill_create_ip\", self.remote_addr)\n\n        raw = self._fetch(url, data)\n        return raw\n\n    def jsapi(self, **kwargs):\n        \"\"\"\n        \u751f\u6210\u7ed9JavaScript\u8c03\u7528\u7684\u6570\u636e\n        \u8be6\u7ec6\u89c4\u5219\u53c2\u8003 https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6\n        \"\"\"\n        kwargs.setdefault(\"trade_type\", \"JSAPI\")\n        raw = self.unified_order(**kwargs)\n        package = \"prepay_id={0}\".format(raw[\"prepay_id\"])\n        timestamp = str(int(time.time()))\n        nonce_str = self.nonce_str\n        raw = dict(appId=self.app_id, timeStamp=timestamp,\n                   nonceStr=nonce_str, package=package, signType=\"MD5\")\n        sign = self.sign(raw)\n        return dict(package=package, appId=self.app_id, signType=\"MD5\",\n                    timeStamp=timestamp, nonceStr=nonce_str, sign=sign)\n\n    def order_query(self, **data):\n        \"\"\"\n        \u8ba2\u5355\u67e5\u8be2\n        out_trade_no, transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\n        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/orderquery\"\n\n        if \"out_trade_no\" not in data and \"transaction_id\" not in data:\n            raise WeixinPayError(\"\u8ba2\u5355\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")\n\n        return self._fetch(url, data)\n\n    def close_order(self, out_trade_no, **data):\n        \"\"\"\n        \u5173\u95ed\u8ba2\u5355\n        out_trade_no\u5fc5\u586b\n        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/closeorder\"\n\n        data.setdefault(\"out_trade_no\", out_trade_no)\n\n        return self._fetch(url, data)\n\n    def refund(self, **data):\n        \"\"\"\n        \u7533\u8bf7\u9000\u6b3e\n        out_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\u4e14\n        out_refund_no\u3001total_fee\u3001refund_fee\u3001op_user_id\u4e3a\u5fc5\u586b\u53c2\u6570\n        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        if not self.key or not self.cert:\n            raise WeixinError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u9700\u8981\u53cc\u5411\u8bc1\u4e66\")\n        url = \"https://api.mch.weixin.qq.com/secapi/pay/refund\"\n        if \"out_trade_no\" not in data and \"transaction_id\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")\n        if \"out_refund_no\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570out_refund_no\");\n        if \"total_fee\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570total_fee\");\n        if \"refund_fee\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570refund_fee\");\n\n        return self._fetch(url, data, True)\n\n    def refund_query(self, **data):\n        \"\"\"\n        \u67e5\u8be2\u9000\u6b3e\n        \u63d0\u4ea4\u9000\u6b3e\u7533\u8bf7\u540e\uff0c\u901a\u8fc7\u8c03\u7528\u8be5\u63a5\u53e3\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002\u9000\u6b3e\u6709\u4e00\u5b9a\u5ef6\u65f6\uff0c\n        \u7528\u96f6\u94b1\u652f\u4ed8\u7684\u9000\u6b3e20\u5206\u949f\u5185\u5230\u8d26\uff0c\u94f6\u884c\u5361\u652f\u4ed8\u7684\u9000\u6b3e3\u4e2a\u5de5\u4f5c\u65e5\u540e\u91cd\u65b0\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002\n\n        out_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a\n        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/refundquery\"\n        if \"out_refund_no\" not in data and \"out_trade_no\" not in data \\\n                and \"transaction_id\" not in data and \"refund_id\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a\")\n\n        return self._fetch(url, data)\n\n    def download_bill(self, bill_date, bill_type=\"ALL\", **data):\n        \"\"\"\n        \u4e0b\u8f7d\u5bf9\u8d26\u5355\n        bill_date\u3001bill_type\u4e3a\u5fc5\u586b\u53c2\u6570\n        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/downloadbill\"\n        data.setdefault(\"bill_date\", bill_date)\n        data.setdefault(\"bill_type\", bill_type)\n\n        if \"bill_date\" not in data:\n            raise WeixinPayError(\"\u5bf9\u8d26\u5355\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570bill_date\")\n\n        return self._fetch(url, data)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n\nfrom __future__ import unicode_literals\n\nimport time\nimport hashlib\n\nfrom datetime import datetime\n\nfrom .base import WeixinError\n\ntry:\n    from flask import request, Response\nexcept ImportError:\n    request, Response = None, None\n\ntry:\n    from django.http import HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed\nexcept Exception:\n    HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed = None, None, None\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    from xml.etree import cElementTree as etree\nexcept ImportError:\n    from xml.etree import ElementTree as etree\n\n\n__all__ = (\"WeixinMsgError\", \"WeixinMsg\")\n\n\nclass WeixinMsgError(WeixinError):\n\n    def __init__(self, msg):\n        super(WeixinMsgError, self).__init__(msg)\n\n\nclass WeixinMsg(object):\n\n    def __init__(self, token, sender=None, expires_in=0):\n        self.token = token\n        self.sender = sender\n        self.expires_in = expires_in\n        self._registry = dict()\n\n    def validate(self, signature, timestamp, nonce):\n        if not self.token:\n            raise WeixinMsgError(\"weixin token is missing\")\n\n        if self.expires_in:\n            try:\n                timestamp = int(timestamp)\n            except ValueError:\n                return False\n            delta = time.time() - timestamp\n            if delta < 0 or delta > self.expires_in:\n                return False\n        values = [self.token, str(timestamp), str(nonce)]\n        s = ''.join(sorted(values))\n        hsh = hashlib.sha1(s.encode(\"utf-8\")).hexdigest()\n        return signature == hsh\n\n    def parse(self, content):\n        raw = {}\n        root = etree.fromstring(content,\n                                parser=etree.XMLParser(resolve_entities=False))\n        for child in root:\n            raw[child.tag] = child.text\n\n        formatted = self.format(raw)\n        msg_type = formatted['type']\n        msg_parser = getattr(self, 'parse_{0}'.format(msg_type), None)\n        if callable(msg_parser):\n            parsed = msg_parser(raw)\n        else:\n            parsed = self.parse_invalid_type(raw)\n\n        formatted.update(parsed)\n        return formatted\n\n    def format(self, kwargs):\n        timestamp = int(kwargs['CreateTime'])\n        return {\n            'id': kwargs.get('MsgId'),\n            'timestamp': timestamp,\n            'receiver': kwargs['ToUserName'],\n            'sender': kwargs['FromUserName'],\n            'type': kwargs['MsgType'],\n            'time': datetime.fromtimestamp(timestamp),\n        }\n\n    def parse_text(self, raw):\n        return {'content': raw['Content']}\n\n    def parse_image(self, raw):\n        return {'picurl': raw['PicUrl']}\n\n    def parse_location(self, raw):\n        return {\n            'location_x': raw['Location_X'],\n            'location_y': raw['Location_Y'],\n            'scale': int(raw.get('Scale', 0)),\n            'label': raw['Label'],\n        }\n\n    def parse_link(self, raw):\n        return {\n            'title': raw['Title'],\n            'description': raw['Description'],\n            'url': raw['url'],\n        }\n\n    def parse_voice(self, raw):\n        return {\n            'media_id': raw['MediaId'],\n            'format': raw['Format'],\n            'recognition': raw['Recognition'],\n        }\n\n    def parse_video(self, raw):\n        return {\n            'media_id': raw['MediaId'],\n            'thumb_media_id': raw['ThumbMediaId'],\n        }\n\n    def parse_shortvideo(self, raw):\n        return {\n            'media_id': raw['MediaId'],\n            'thumb_media_id': raw['ThumbMediaId'],\n        }\n\n    def parse_event(self, raw):\n        return {\n            'event': raw.get('Event'),\n            'event_key': raw.get('EventKey'),\n            'ticket': raw.get('Ticket'),\n            'latitude': raw.get('Latitude'),\n            'longitude': raw.get('Longitude'),\n            'precision': raw.get('Precision'),\n            'status': raw.get('status')\n        }\n\n    def parse_invalid_type(self, raw):\n        return {}\n\n    def reply(self, username=None, type='text', sender=None, **kwargs):\n        if not username:\n            raise RuntimeError(\"username is missing\")\n        sender = sender or self.sender\n        if not sender:\n            raise RuntimeError('WEIXIN_SENDER or sender argument is missing')\n\n        if type == 'text':\n            content = kwargs.get('content', '')\n            return text_reply(username, sender, content)\n\n        if type == 'music':\n            values = {}\n            for k in ('title', 'description', 'music_url', 'hq_music_url'):\n                values[k] = kwargs[k]\n            return music_reply(username, sender, **values)\n\n        if type == 'news':\n            items = kwargs['articles']\n            return news_reply(username, sender, *items)\n\n        if type == 'customer_service':\n            service_account = kwargs['service_account']\n            return transfer_customer_service_reply(username, sender,\n                                                   service_account)\n\n        if type == 'image':\n            media_id = kwargs.get('media_id')\n            return image_reply(username, sender, media_id)\n\n        if type == 'voice':\n            media_id = kwargs.get('media_id')\n            return voice_reply(username, sender, media_id)\n\n        if type == 'video':\n            values = {}\n            for k in ('media_id', 'title', 'description'):\n                values[k] = kwargs[k]\n            return video_reply(username, sender, **values)\n\n    def register(self, type, key=None, func=None):\n        if func:\n            key = '*' if not key else key\n            self._registry.setdefault(type, dict())[key] = func\n            return func\n        return self.__call__(type, key)\n\n    def __call__(self, type, key):\n        def wrapper(func):\n            self.register(type, key, func)\n            return func\n        return wrapper\n\n    @property\n    def all(self):\n        return self.register('*')\n\n    def text(self, key='*'):\n        return self.register('text', key)\n\n    def __getattr__(self, key):\n        key = key.lower()\n        if key in ['image', 'video', 'voice', 'shortvideo', 'location', 'link', 'event']:\n            return self.register(key)\n        if key in ['subscribe', 'unsubscribe', 'location', 'click', 'view', 'scan', \\\n                   'scancode_push', 'scancode_waitmsg', 'pic_sysphoto', \\\n                   'pic_photo_or_album', 'pic_weixin', 'location_select', \\\n                   'qualification_verify_success', 'qualification_verify_fail', 'naming_verify_success', \\\n                   'naming_verify_fail', 'annual_renew', 'verify_expired', \\\n                   'card_pass_check', 'user_get_card', 'user_del_card', 'user_consume_card', \\\n                   'user_pay_from_pay_cell', 'user_view_card', 'user_enter_session_from_card', \\\n                   'card_sku_remind']:\n            return self.register('event', key)\n        raise AttributeError('invalid attribute \"' + key + '\"')\n\n    def django_view_func(self):\n\n        def run(request):\n            if HttpResponse is None:\n                raise RuntimeError('django_view_func need Django be installed')\n            signature = request.GET.get('signature')\n\n            timestamp = request.GET.get('timestamp')\n            nonce = request.GET.get('nonce')\n            if not self.validate(signature, timestamp, nonce):\n                return HttpResponseForbidden('signature failed')\n            if request.method == 'GET':\n                echostr = request.args.get('echostr', '')\n                return HttpResponse(echostr)\n            elif request.method == \"POST\":\n                try:\n                    ret = self.parse(request.body)\n                except ValueError:\n                    return HttpResponseForbidden('invalid')\n\n                func = None\n                type = ret['type']\n                _registry = self._registry.get(type, dict())\n                if type == 'text':\n                    if ret['content'] in _registry:\n                        func = _registry[ret['content']]\n                elif type == 'event':\n                    if ret['event'].lower() in _registry:\n                        func = _registry[ret['event'].lower()]\n\n                if func is None and '*' in _registry:\n                    func = _registry['*']\n                if func is None and '*' in self._registry:\n                    func = self._registry.get('*', dict()).get('*')\n\n                text = ''\n                if func is None:\n                    text = 'failed'\n\n                if callable(func):\n                    text = func(**ret)\n\n                content = ''\n                if isinstance(text, basestring):\n                    if text:\n                        content = self.reply(\n                            username=ret['sender'],\n                            sender=ret['receiver'],\n                            content=text,\n                        )\n                elif isinstance(text, dict):\n                    text.setdefault('username', ret['sender'])\n                    text.setdefault('sender', ret['receiver'])\n                    content = self.reply(**text)\n\n                return HttpResponse(content, content_type='text/xml; charset=utf-8')\n            return HttpResponseNotAllowed(['GET', 'POST'])\n        return run\n\n    def view_func(self):\n        if request is None:\n            raise RuntimeError('view_func need Flask be installed')\n\n        signature = request.args.get('signature')\n        timestamp = request.args.get('timestamp')\n        nonce = request.args.get('nonce')\n        if not self.validate(signature, timestamp, nonce):\n            return 'signature failed', 400\n        if request.method == 'GET':\n            echostr = request.args.get('echostr', '')\n            return echostr\n\n        try:\n            ret = self.parse(request.data)\n        except ValueError:\n            return 'invalid', 400\n\n        func = None\n        type = ret['type']\n        _registry = self._registry.get(type, dict())\n        if type == 'text':\n            if ret['content'] in _registry:\n                func = _registry[ret['content']]\n        elif type == 'event':\n            if ret['event'].lower() in _registry:\n                func = _registry[ret['event'].lower()]\n\n        if func is None and '*' in _registry:\n            func = _registry['*']\n        if func is None and '*' in self._registry:\n            func = self._registry.get('*', dict()).get('*')\n\n        text = ''\n        if func is None:\n            text = 'failed'\n\n        if callable(func):\n            text = func(**ret)\n\n        content = ''\n        if isinstance(text, basestring):\n            if text:\n                content = self.reply(\n                    username=ret['sender'],\n                    sender=ret['receiver'],\n                    content=text,\n                )\n        elif isinstance(text, dict):\n            text.setdefault('username', ret['sender'])\n            text.setdefault('sender', ret['receiver'])\n            content = self.reply(**text)\n\n        return Response(content, content_type='text/xml; charset=utf-8')\n\n    view_func.methods = ['GET', 'POST']\n\n\ndef text_reply(username, sender, content):\n    shared = _shared_reply(username, sender, 'text')\n    template = '<xml>%s<Content><![CDATA[%s]]></Content></xml>'\n    return template % (shared, content)\n\n\ndef music_reply(username, sender, **kwargs):\n    kwargs['shared'] = _shared_reply(username, sender, 'music')\n\n    template = (\n        '<xml>'\n        '%(shared)s'\n        '<Music>'\n        '<Title><![CDATA[%(title)s]]></Title>'\n        '<Description><![CDATA[%(description)s]]></Description>'\n        '<MusicUrl><![CDATA[%(music_url)s]]></MusicUrl>'\n        '<HQMusicUrl><![CDATA[%(hq_music_url)s]]></HQMusicUrl>'\n        '</Music>'\n        '</xml>'\n    )\n    return template % kwargs\n\n\ndef news_reply(username, sender, *items):\n    item_template = (\n        '<item>'\n        '<Title><![CDATA[%(title)s]]></Title>'\n        '<Description><![CDATA[%(description)s]]></Description>'\n        '<PicUrl><![CDATA[%(picurl)s]]></PicUrl>'\n        '<Url><![CDATA[%(url)s]]></Url>'\n        '</item>'\n    )\n    articles = [item_template % o for o in items]\n\n    template = (\n        '<xml>'\n        '%(shared)s'\n        '<ArticleCount>%(count)d</ArticleCount>'\n        '<Articles>%(articles)s</Articles>'\n        '</xml>'\n    )\n    dct = {\n        'shared': _shared_reply(username, sender, 'news'),\n        'count': len(items),\n        'articles': ''.join(articles)\n    }\n    return template % dct\n\n\ndef transfer_customer_service_reply(username, sender, service_account):\n    template = (\n        '<xml>%(shared)s'\n        '%(transfer_info)s</xml>')\n    transfer_info = ''\n    if service_account:\n        transfer_info = (\n            '<TransInfo>'\n            '<KfAccount>![CDATA[%s]]</KfAccount>'\n            '</TransInfo>') % service_account\n\n    dct = {\n        'shared': _shared_reply(username, sender,\n                                type='transfer_customer_service'),\n        'transfer_info': transfer_info\n    }\n    return template % dct\n\n\ndef image_reply(username, sender, media_id):\n    shared = _shared_reply(username, sender, 'image')\n    template = '<xml>%s<Image><MediaId><![CDATA[%s]]></MediaId></Image></xml>'\n    return template % (shared, media_id)\n\n\ndef voice_reply(username, sender, media_id):\n    shared = _shared_reply(username, sender, 'voice')\n    template = '<xml>%s<Voice><MediaId><![CDATA[%s]]></MediaId></Voice></xml>'\n    return template % (shared, media_id)\n\n\ndef video_reply(username, sender, **kwargs):\n    kwargs['shared'] = _shared_reply(username, sender, 'video')\n\n    template = (\n        '<xml>'\n        '%(shared)s'\n        '<Video>'\n        '<MediaId><![CDATA[%(media_id)s]]></MediaId>'\n        '<Title><![CDATA[%(title)s]]></Title>'\n        '<Description><![CDATA[%(description)s]]></Description>'\n        '</Video>'\n        '</xml>'\n    )\n    return template % kwargs\n\n\ndef _shared_reply(username, sender, type):\n    dct = {\n        'username': username,\n        'sender': sender,\n        'type': type,\n        'timestamp': int(time.time()),\n    }\n    template = (\n        '<ToUserName><![CDATA[%(username)s]]></ToUserName>'\n        '<FromUserName><![CDATA[%(sender)s]]></FromUserName>'\n        '<CreateTime>%(timestamp)d</CreateTime>'\n        '<MsgType><![CDATA[%(type)s]]></MsgType>'\n    )\n    return template % dct\n", "# -*- coding: utf-8 -*-\n\n\nfrom __future__ import unicode_literals\n\nimport time\nimport string\nimport random\nimport hashlib\nimport requests\n\nfrom .base import Map, WeixinError\n\ntry:\n    from flask import request\nexcept Exception:\n    request = None\n\ntry:\n    from lxml import etree\nexcept ImportError:\n    from xml.etree import cElementTree as etree\nexcept ImportError:\n    from xml.etree import ElementTree as etree\n\n\n__all__ = (\"WeixinPayError\", \"WeixinPay\")\n\n\nFAIL = \"FAIL\"\nSUCCESS = \"SUCCESS\"\n\n\nclass WeixinPayError(WeixinError):\n\n    def __init__(self, msg):\n        super(WeixinPayError, self).__init__(msg)\n\n\nclass WeixinPay(object):\n\n    def __init__(self, app_id, mch_id, mch_key, notify_url, key=None, cert=None):\n        self.app_id = app_id\n        self.mch_id = mch_id\n        self.mch_key = mch_key\n        self.notify_url = notify_url\n        self.key = key\n        self.cert = cert\n        self.sess = requests.Session()\n\n    @property\n    def remote_addr(self):\n        if request is not None:\n            return request.remote_addr\n        return \"\"\n\n    @property\n    def nonce_str(self):\n        char = string.ascii_letters + string.digits\n        return \"\".join(random.choice(char) for _ in range(32))\n\n    def sign(self, raw):\n        raw = [(k, str(raw[k]) if isinstance(raw[k], int) else raw[k])\n               for k in sorted(raw.keys())]\n        s = \"&\".join(\"=\".join(kv) for kv in raw if kv[1])\n        s += \"&key={0}\".format(self.mch_key)\n        return hashlib.md5(s.encode(\"utf-8\")).hexdigest().upper()\n\n    def check(self, data):\n        sign = data.pop(\"sign\")\n        return sign == self.sign(data)\n\n    def to_xml(self, raw):\n        s = \"\"\n        for k, v in raw.items():\n            s += \"<{0}>{1}</{0}>\".format(k, v)\n        s = \"<xml>{0}</xml>\".format(s)\n        return s.encode(\"utf-8\")\n\n    def to_dict(self, content):\n        raw = {}\n        root = etree.fromstring(content.encode(\"utf-8\"),\n                                parser=etree.XMLParser(resolve_entities=False))\n        for child in root:\n            raw[child.tag] = child.text\n        return raw\n\n    def _fetch(self, url, data, use_cert=False):\n        data.setdefault(\"appid\", self.app_id)\n        data.setdefault(\"mch_id\", self.mch_id)\n        data.setdefault(\"nonce_str\", self.nonce_str)\n        data.setdefault(\"sign\", self.sign(data))\n\n        if use_cert:\n            resp = self.sess.post(url, data=self.to_xml(data), cert=(self.cert, self.key))\n        else:\n            resp = self.sess.post(url, data=self.to_xml(data))\n        content = resp.content.decode(\"utf-8\")\n        if \"return_code\" in content:\n            data = Map(self.to_dict(content))\n            if data.return_code == FAIL:\n                raise WeixinPayError(data.return_msg)\n            if \"result_code\" in content and data.result_code == FAIL:\n                raise WeixinPayError(data.err_code_des)\n            return data\n        return content\n\n    def reply(self, msg, ok=True):\n        code = SUCCESS if ok else FAIL\n        return self.to_xml(dict(return_code=code, return_msg=msg))\n\n    def unified_order(self, **data):\n        \"\"\"\n        \u7edf\u4e00\u4e0b\u5355\n        out_trade_no\u3001body\u3001total_fee\u3001trade_type\u5fc5\u586b\n        app_id, mchid, nonce_str\u81ea\u52a8\u586b\u5199\n        spbill_create_ip \u5728flask\u6846\u67b6\u4e0b\u53ef\u4ee5\u81ea\u52a8\u586b\u5199, \u975eflask\u6846\u67b6\u9700\u8981\u4e3b\u52a8\u4f20\u5165\u6b64\u53c2\u6570\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/unifiedorder\"\n\n        # \u5fc5\u586b\u53c2\u6570\n        if \"out_trade_no\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570out_trade_no\")\n        if \"body\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570body\")\n        if \"total_fee\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570total_fee\")\n        if \"trade_type\" not in data:\n            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570trade_type\")\n\n        # \u5173\u8054\u53c2\u6570\n        if data[\"trade_type\"] == \"JSAPI\" and \"openid\" not in data:\n            raise WeixinPayError(\"trade_type\u4e3aJSAPI\u65f6\uff0copenid\u4e3a\u5fc5\u586b\u53c2\u6570\")\n        if data[\"trade_type\"] == \"NATIVE\" and \"product_id\" not in data:\n            raise WeixinPayError(\"trade_type\u4e3aNATIVE\u65f6\uff0cproduct_id\u4e3a\u5fc5\u586b\u53c2\u6570\")\n        data.setdefault(\"notify_url\", self.notify_url)\n        if \"spbill_create_ip\" not in data:\n            data.setdefault(\"spbill_create_ip\", self.remote_addr)\n\n        raw = self._fetch(url, data)\n        return raw\n\n    def jsapi(self, **kwargs):\n        \"\"\"\n        \u751f\u6210\u7ed9JavaScript\u8c03\u7528\u7684\u6570\u636e\n        \u8be6\u7ec6\u89c4\u5219\u53c2\u8003 https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6\n        \"\"\"\n        kwargs.setdefault(\"trade_type\", \"JSAPI\")\n        raw = self.unified_order(**kwargs)\n        package = \"prepay_id={0}\".format(raw[\"prepay_id\"])\n        timestamp = str(int(time.time()))\n        nonce_str = self.nonce_str\n        raw = dict(appId=self.app_id, timeStamp=timestamp,\n                   nonceStr=nonce_str, package=package, signType=\"MD5\")\n        sign = self.sign(raw)\n        return dict(package=package, appId=self.app_id, signType=\"MD5\",\n                    timeStamp=timestamp, nonceStr=nonce_str, sign=sign)\n\n    def order_query(self, **data):\n        \"\"\"\n        \u8ba2\u5355\u67e5\u8be2\n        out_trade_no, transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\n        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/orderquery\"\n\n        if \"out_trade_no\" not in data and \"transaction_id\" not in data:\n            raise WeixinPayError(\"\u8ba2\u5355\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")\n\n        return self._fetch(url, data)\n\n    def close_order(self, out_trade_no, **data):\n        \"\"\"\n        \u5173\u95ed\u8ba2\u5355\n        out_trade_no\u5fc5\u586b\n        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/closeorder\"\n\n        data.setdefault(\"out_trade_no\", out_trade_no)\n\n        return self._fetch(url, data)\n\n    def refund(self, **data):\n        \"\"\"\n        \u7533\u8bf7\u9000\u6b3e\n        out_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\u4e14\n        out_refund_no\u3001total_fee\u3001refund_fee\u3001op_user_id\u4e3a\u5fc5\u586b\u53c2\u6570\n        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        if not self.key or not self.cert:\n            raise WeixinError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u9700\u8981\u53cc\u5411\u8bc1\u4e66\")\n        url = \"https://api.mch.weixin.qq.com/secapi/pay/refund\"\n        if \"out_trade_no\" not in data and \"transaction_id\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")\n        if \"out_refund_no\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570out_refund_no\");\n        if \"total_fee\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570total_fee\");\n        if \"refund_fee\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570refund_fee\");\n\n        return self._fetch(url, data, True)\n\n    def refund_query(self, **data):\n        \"\"\"\n        \u67e5\u8be2\u9000\u6b3e\n        \u63d0\u4ea4\u9000\u6b3e\u7533\u8bf7\u540e\uff0c\u901a\u8fc7\u8c03\u7528\u8be5\u63a5\u53e3\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002\u9000\u6b3e\u6709\u4e00\u5b9a\u5ef6\u65f6\uff0c\n        \u7528\u96f6\u94b1\u652f\u4ed8\u7684\u9000\u6b3e20\u5206\u949f\u5185\u5230\u8d26\uff0c\u94f6\u884c\u5361\u652f\u4ed8\u7684\u9000\u6b3e3\u4e2a\u5de5\u4f5c\u65e5\u540e\u91cd\u65b0\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002\n\n        out_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a\n        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/refundquery\"\n        if \"out_refund_no\" not in data and \"out_trade_no\" not in data \\\n                and \"transaction_id\" not in data and \"refund_id\" not in data:\n            raise WeixinPayError(\"\u9000\u6b3e\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a\")\n\n        return self._fetch(url, data)\n\n    def download_bill(self, bill_date, bill_type=\"ALL\", **data):\n        \"\"\"\n        \u4e0b\u8f7d\u5bf9\u8d26\u5355\n        bill_date\u3001bill_type\u4e3a\u5fc5\u586b\u53c2\u6570\n        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165\n        \"\"\"\n        url = \"https://api.mch.weixin.qq.com/pay/downloadbill\"\n        data.setdefault(\"bill_date\", bill_date)\n        data.setdefault(\"bill_type\", bill_type)\n\n        if \"bill_date\" not in data:\n            raise WeixinPayError(\"\u5bf9\u8d26\u5355\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570bill_date\")\n\n        return self._fetch(url, data)\n"], "filenames": ["weixin/msg.py", "weixin/pay.py"], "buggy_code_start_loc": [67, 82], "buggy_code_end_loc": [68, 83], "fixing_code_start_loc": [67, 82], "fixing_code_end_loc": [69, 84], "type": "CWE-611", "message": "A vulnerability was found in zwczou WeChat SDK Python 0.3.0 and classified as critical. This issue affects the function validate/to_xml. The manipulation leads to xml external entity reference. The attack may be initiated remotely. Upgrading to version 0.5.5 is able to address this issue. The name of the patch is e54abadc777715b6dcb545c13214d1dea63df6c9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-223403.", "other": {"cve": {"id": "CVE-2018-25082", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-21T18:15:11.677", "lastModified": "2023-03-24T19:34:14.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in zwczou WeChat SDK Python 0.3.0 and classified as critical. This issue affects the function validate/to_xml. The manipulation leads to xml external entity reference. The attack may be initiated remotely. Upgrading to version 0.5.5 is able to address this issue. The name of the patch is e54abadc777715b6dcb545c13214d1dea63df6c9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-223403."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wechat_sdk_python_project:wechat_sdk_python:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.5.5", "matchCriteriaId": "D5B727A2-DE10-4E73-AA89-DD0AD92D4291"}]}]}], "references": [{"url": "https://github.com/zwczou/weixin-python/commit/e54abadc777715b6dcb545c13214d1dea63df6c9", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/zwczou/weixin-python/pull/30", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/zwczou/weixin-python/releases/tag/v0.5.5", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.223403", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.223403", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/zwczou/weixin-python/commit/e54abadc777715b6dcb545c13214d1dea63df6c9"}}