{"buggy_code": ["/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport org.jboss.logging.Logger;\nimport org.keycloak.models.ClientConfigResolver;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.protocol.saml.util.ArtifactBindingUtils;\nimport org.keycloak.saml.SignatureAlgorithm;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.common.util.XmlKeyInfoKeyNameTransformer;\n\n/**\n * Configuration of a SAML-enabled client.\n *\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class SamlClient extends ClientConfigResolver {\n\n    protected static final Logger logger = Logger.getLogger(SamlClient.class);\n\n    public static final XmlKeyInfoKeyNameTransformer DEFAULT_XML_KEY_INFO_KEY_NAME_TRANSFORMER = XmlKeyInfoKeyNameTransformer.KEY_ID;\n\n    public SamlClient(ClientModel client) {\n        super(client);\n    }\n\n    public String getCanonicalizationMethod() {\n        return resolveAttribute(SamlConfigAttributes.SAML_CANONICALIZATION_METHOD_ATTRIBUTE);\n    }\n\n    public void setCanonicalizationMethod(String value) {\n        client.setAttribute(SamlConfigAttributes.SAML_CANONICALIZATION_METHOD_ATTRIBUTE, value);\n    }\n\n    public SignatureAlgorithm getSignatureAlgorithm() {\n        String alg = resolveAttribute(SamlConfigAttributes.SAML_SIGNATURE_ALGORITHM);\n        if (alg != null) {\n            SignatureAlgorithm algorithm = SignatureAlgorithm.valueOf(alg);\n            if (algorithm != null)\n                return algorithm;\n        }\n        return SignatureAlgorithm.RSA_SHA256;\n    }\n\n    public void setSignatureAlgorithm(SignatureAlgorithm algorithm) {\n        client.setAttribute(SamlConfigAttributes.SAML_SIGNATURE_ALGORITHM, algorithm.name());\n    }\n\n    public String getNameIDFormat() {\n        String nameIdFormat = null;\n\n        String configuredNameIdFormat = resolveAttribute(SamlConfigAttributes.SAML_NAME_ID_FORMAT_ATTRIBUTE);\n        if (configuredNameIdFormat != null) {\n            if (configuredNameIdFormat.equals(\"email\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get();\n            } else if (configuredNameIdFormat.equals(\"persistent\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_PERSISTENT.get();\n            } else if (configuredNameIdFormat.equals(\"transient\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_TRANSIENT.get();\n            } else if (configuredNameIdFormat.equals(\"username\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_UNSPECIFIED.get();\n            } else {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_UNSPECIFIED.get();\n            }\n        }\n        return nameIdFormat;\n\n    }\n\n    public static String samlNameIDFormatToClientAttribute(String nameIdFormat) {\n        if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n            return \"email\";\n        } else if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_PERSISTENT.get())) {\n            return \"persistent\";\n        } else if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_TRANSIENT.get())) {\n            return \"transient\";\n        } else if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_UNSPECIFIED.get())) {\n            return \"username\";\n        }\n        return null;\n\n    }\n\n\n    public void setNameIDFormat(String format) {\n        client.setAttribute(SamlConfigAttributes.SAML_NAME_ID_FORMAT_ATTRIBUTE, format);\n    }\n\n    public boolean includeAuthnStatement() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_AUTHNSTATEMENT));\n    }\n\n    public void setIncludeAuthnStatement(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_AUTHNSTATEMENT, Boolean.toString(val));\n    }\n\n    public boolean forceNameIDFormat() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE));\n\n    }\n\n    public void setForceNameIDFormat(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE, Boolean.toString(val));\n    }\n\n    public boolean forceArtifactBinding(){\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING));\n    }\n\n    public void setForceArtifactBinding(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING, Boolean.toString(val));\n    }\n\n    public boolean requiresRealmSignature() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE));\n    }\n\n    public void setRequiresRealmSignature(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, Boolean.toString(val));\n    }\n\n    public boolean addExtensionsElementWithKeyInfo() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_EXT));\n    }\n\n    public void setAddExtensionsElementWithKeyInfo(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_EXT, Boolean.toString(val));\n    }\n\n    public boolean forcePostBinding() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_FORCE_POST_BINDING));\n    }\n\n    public void setForcePostBinding(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_FORCE_POST_BINDING, Boolean.toString(val));\n\n    }\n\n    public boolean requiresAssertionSignature() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ASSERTION_SIGNATURE));\n    }\n\n    public void setRequiresAssertionSignature(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ASSERTION_SIGNATURE, Boolean.toString(val));\n\n    }\n\n    public boolean requiresEncryption() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ENCRYPT));\n    }\n\n\n    public void setRequiresEncryption(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ENCRYPT, Boolean.toString(val));\n\n    }\n\n    public boolean requiresClientSignature() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE));\n    }\n\n    public void setRequiresClientSignature(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, Boolean.toString(val));\n\n    }\n\n    public String getClientSigningCertificate() {\n        return client.getAttribute(SamlConfigAttributes.SAML_SIGNING_CERTIFICATE_ATTRIBUTE);\n    }\n\n    public void setClientSigningCertificate(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SIGNING_CERTIFICATE_ATTRIBUTE, val);\n\n    }\n\n    public String getClientSigningPrivateKey() {\n        return client.getAttribute(SamlConfigAttributes.SAML_SIGNING_PRIVATE_KEY);\n    }\n\n    public void setClientSigningPrivateKey(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SIGNING_PRIVATE_KEY, val);\n\n    }\n\n    public String getClientEncryptingCertificate() {\n        return client.getAttribute(SamlConfigAttributes.SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE);\n    }\n\n    public void setClientEncryptingCertificate(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE, val);\n\n    }\n\n    public String getClientEncryptingPrivateKey() {\n        return client.getAttribute(SamlConfigAttributes.SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE);\n    }\n\n    public void setClientEncryptingPrivateKey(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE, val);\n\n    }\n\n    /**\n     * Always returns non-{@code null} result.\n     *\n     * @return Configured ransformer of {@link #DEFAULT_XML_KEY_INFO_KEY_NAME_TRANSFORMER} if not set.\n     */\n    public XmlKeyInfoKeyNameTransformer getXmlSigKeyInfoKeyNameTransformer() {\n        return XmlKeyInfoKeyNameTransformer.from(\n                client.getAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER),\n                DEFAULT_XML_KEY_INFO_KEY_NAME_TRANSFORMER);\n    }\n\n    public void setXmlSigKeyInfoKeyNameTransformer(XmlKeyInfoKeyNameTransformer xmlSigKeyInfoKeyNameTransformer) {\n        client.setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER,\n                xmlSigKeyInfoKeyNameTransformer == null\n                        ? null\n                        : xmlSigKeyInfoKeyNameTransformer.name());\n    }\n\n    public boolean includeOneTimeUseCondition() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ONETIMEUSE_CONDITION));\n    }\n\n    public void setIncludeOneTimeUseCondition(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ONETIMEUSE_CONDITION, Boolean.toString(val));\n    }\n\n    public void setAssertionLifespan(int assertionLifespan) {\n        client.setAttribute(SamlConfigAttributes.SAML_ASSERTION_LIFESPAN, Integer.toString(assertionLifespan));\n    }\n\n    public int getAssertionLifespan() {\n        String value = client.getAttribute(SamlConfigAttributes.SAML_ASSERTION_LIFESPAN);\n        if (value == null || value.isEmpty()) {\n            return -1;\n        }\n        try {\n            return Integer.parseInt(value);\n        } catch (NumberFormatException e) {\n            logger.warnf(\"Invalid numeric value for saml attribute \\\"%s\\\": %s\", SamlConfigAttributes.SAML_ASSERTION_LIFESPAN, value);\n            return -1;\n        }\n    }\n\n    public void setArtifactBindingIdentifierFrom(String identifierFrom) {\n        client.setAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(identifierFrom));\n    }\n\n    public String getArtifactBindingIdentifier() {\n        return client.getAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER);\n    }\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport org.keycloak.services.util.CertificateInfoHelper;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic interface SamlConfigAttributes {\n    String SAML_SIGNING_PRIVATE_KEY = \"saml.signing.private.key\";\n    String SAML_CANONICALIZATION_METHOD_ATTRIBUTE = \"saml_signature_canonicalization_method\";\n    String SAML_SIGNATURE_ALGORITHM = \"saml.signature.algorithm\";\n    String SAML_NAME_ID_FORMAT_ATTRIBUTE = \"saml_name_id_format\";\n    String SAML_AUTHNSTATEMENT = \"saml.authnstatement\";\n    String SAML_ONETIMEUSE_CONDITION = \"saml.onetimeuse.condition\";\n    String SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE = \"saml_force_name_id_format\";\n    String SAML_ARTIFACT_BINDING = \"saml.artifact.binding\";\n    String SAML_SERVER_SIGNATURE = \"saml.server.signature\";\n    String SAML_SERVER_SIGNATURE_KEYINFO_EXT = \"saml.server.signature.keyinfo.ext\";\n    String SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER = \"saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer\";\n    String SAML_FORCE_POST_BINDING = \"saml.force.post.binding\";\n    String SAML_ASSERTION_SIGNATURE = \"saml.assertion.signature\";\n    String SAML_ENCRYPT = \"saml.encrypt\";\n    String SAML_CLIENT_SIGNATURE_ATTRIBUTE = \"saml.client.signature\";\n    String SAML_SIGNING_CERTIFICATE_ATTRIBUTE = \"saml.signing.\" + CertificateInfoHelper.X509CERTIFICATE;\n    String SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE = \"saml.encryption.\" + CertificateInfoHelper.X509CERTIFICATE;\n    String SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE = \"saml.encryption.\" + CertificateInfoHelper.PRIVATE_KEY;\n    String SAML_ASSERTION_LIFESPAN = \"saml.assertion.lifespan\";\n    String SAML_ARTIFACT_BINDING_IDENTIFIER = \"saml.artifact.binding.identifier\";\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport org.keycloak.Config;\nimport org.keycloak.events.EventBuilder;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.models.ClientScopeModel;\nimport org.keycloak.models.KeycloakSession;\nimport org.keycloak.models.ProtocolMapperModel;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.utils.KeycloakModelUtils;\nimport org.keycloak.protocol.AbstractLoginProtocolFactory;\nimport org.keycloak.protocol.LoginProtocol;\nimport org.keycloak.protocol.saml.mappers.AttributeStatementHelper;\nimport org.keycloak.protocol.saml.mappers.RoleListMapper;\nimport org.keycloak.protocol.saml.mappers.UserPropertyAttributeStatementMapper;\nimport org.keycloak.representations.idm.CertificateRepresentation;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.saml.SignatureAlgorithm;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.processing.core.saml.v2.constants.X500SAMLProfileConstants;\n\nimport org.keycloak.saml.validators.DestinationValidator;\nimport javax.xml.crypto.dsig.CanonicalizationMethod;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class SamlProtocolFactory extends AbstractLoginProtocolFactory {\n\n    public static final String SCOPE_ROLE_LIST = \"role_list\";\n    private static final String ROLE_LIST_CONSENT_TEXT = \"${samlRoleListScopeConsentText}\";\n\n    private DestinationValidator destinationValidator;\n\n    @Override\n    public Object createProtocolEndpoint(RealmModel realm, EventBuilder event) {\n        return new SamlService(realm, event, destinationValidator);\n    }\n\n    @Override\n    public LoginProtocol create(KeycloakSession session) {\n        return new SamlProtocol().setSession(session);\n    }\n\n    @Override\n    public void init(Config.Scope config) {\n        //PicketLinkCoreSTS sts = PicketLinkCoreSTS.instance();\n        //sts.installDefaultConfiguration();\n\n        this.destinationValidator = DestinationValidator.forProtocolMap(config.getArray(\"knownProtocols\"));\n    }\n\n    @Override\n    public String getId() {\n        return SamlProtocol.LOGIN_PROTOCOL;\n    }\n\n    @Override\n    public Map<String, ProtocolMapperModel> getBuiltinMappers() {\n        return builtins;\n    }\n\n    static Map<String, ProtocolMapperModel> builtins = new HashMap<>();\n    static List<ProtocolMapperModel> defaultBuiltins = new ArrayList<>();\n\n    static {\n        ProtocolMapperModel model;\n        model = UserPropertyAttributeStatementMapper.createAttributeMapper(\"X500 email\",\n                \"email\",\n                X500SAMLProfileConstants.EMAIL.get(),\n                JBossSAMLURIConstants.ATTRIBUTE_FORMAT_URI.get(),\n                X500SAMLProfileConstants.EMAIL.getFriendlyName(),\n                true, \"${email}\");\n        builtins.put(\"X500 email\", model);\n        model = UserPropertyAttributeStatementMapper.createAttributeMapper(\"X500 givenName\",\n                \"firstName\",\n                X500SAMLProfileConstants.GIVEN_NAME.get(),\n                JBossSAMLURIConstants.ATTRIBUTE_FORMAT_URI.get(),\n                X500SAMLProfileConstants.GIVEN_NAME.getFriendlyName(),\n                true, \"${givenName}\");\n        builtins.put(\"X500 givenName\", model);\n        model = UserPropertyAttributeStatementMapper.createAttributeMapper(\"X500 surname\",\n                \"lastName\",\n                X500SAMLProfileConstants.SURNAME.get(),\n                JBossSAMLURIConstants.ATTRIBUTE_FORMAT_URI.get(),\n                X500SAMLProfileConstants.SURNAME.getFriendlyName(),\n                true, \"${familyName}\");\n        builtins.put(\"X500 surname\", model);\n        model = RoleListMapper.create(\"role list\", \"Role\", AttributeStatementHelper.BASIC, null, false);\n        builtins.put(\"role list\", model);\n        defaultBuiltins.add(model);\n\n    }\n\n\n    @Override\n    protected void createDefaultClientScopesImpl(RealmModel newRealm) {\n        ClientScopeModel roleListScope = newRealm.addClientScope(SCOPE_ROLE_LIST);\n        roleListScope.setDescription(\"SAML role list\");\n        roleListScope.setDisplayOnConsentScreen(true);\n        roleListScope.setConsentScreenText(ROLE_LIST_CONSENT_TEXT);\n        roleListScope.setProtocol(getId());\n        roleListScope.addProtocolMapper(builtins.get(\"role list\"));\n        newRealm.addDefaultClientScope(roleListScope, true);\n    }\n\n    @Override\n    protected void addDefaults(ClientModel client) {\n    }\n\n    @Override\n    public void setupClientDefaults(ClientRepresentation clientRep, ClientModel newClient) {\n        SamlRepresentationAttributes rep = new SamlRepresentationAttributes(clientRep.getAttributes());\n        SamlClient client = new SamlClient(newClient);\n        if (clientRep.isStandardFlowEnabled() == null) newClient.setStandardFlowEnabled(true);\n        if (rep.getCanonicalizationMethod() == null) {\n            client.setCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE);\n        }\n        if (rep.getSignatureAlgorithm() == null) {\n            client.setSignatureAlgorithm(SignatureAlgorithm.RSA_SHA256);\n        }\n\n        if (rep.getNameIDFormat() == null) {\n            client.setNameIDFormat(\"username\");\n        }\n\n        if (rep.getIncludeAuthnStatement() == null) {\n            client.setIncludeAuthnStatement(true);\n        }\n\n        if (rep.getForceNameIDFormat() == null) {\n            client.setForceNameIDFormat(false);\n        }\n\n        if (rep.getSamlServerSignature() == null) {\n            client.setRequiresRealmSignature(true);\n        }\n        if (rep.getForcePostBinding() == null) {\n            client.setForcePostBinding(true);\n        }\n\n        if (rep.getClientSignature() == null) {\n            client.setRequiresClientSignature(true);\n        }\n\n        if (client.requiresClientSignature() && client.getClientSigningCertificate() == null) {\n            CertificateRepresentation info = KeycloakModelUtils.generateKeyPairCertificate(newClient.getClientId());\n            client.setClientSigningCertificate(info.getCertificate());\n            client.setClientSigningPrivateKey(info.getPrivateKey());\n\n        }\n\n        if (clientRep.isFrontchannelLogout() == null) {\n            newClient.setFrontchannelLogout(true);\n        }\n\n        client.setArtifactBindingIdentifierFrom(clientRep.getClientId());\n    }\n\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class SamlRepresentationAttributes {\n    protected Map<String, String> attributes;\n\n    public SamlRepresentationAttributes(Map<String, String> attributes) {\n        this.attributes = attributes;\n    }\n\n    public String getCanonicalizationMethod() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_CANONICALIZATION_METHOD_ATTRIBUTE);\n    }\n\n    protected Map<String, String> getAttributes() {\n        return attributes;\n    }\n\n    public String getSignatureAlgorithm() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_SIGNATURE_ALGORITHM);\n    }\n\n    public String getNameIDFormat() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_NAME_ID_FORMAT_ATTRIBUTE);\n\n    }\n\n    public String getIncludeAuthnStatement() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_AUTHNSTATEMENT);\n\n    }\n\n    public String getForceNameIDFormat() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE);\n    }\n\n    public String getSamlArtifactBinding() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_ARTIFACT_BINDING);\n    }\n\n    public String getSamlServerSignature() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_SERVER_SIGNATURE);\n    }\n\n    public String getAddExtensionsElementWithKeyInfo() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_EXT);\n    }\n\n    public String getForcePostBinding() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_FORCE_POST_BINDING);\n\n    }\n    public String getClientSignature() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE);\n\n    }\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml.profile.ecp;\n\nimport org.keycloak.dom.saml.v2.protocol.AuthnRequestType;\nimport org.keycloak.events.EventBuilder;\nimport org.keycloak.models.AuthenticationFlowModel;\nimport org.keycloak.models.AuthenticatedClientSessionModel;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.UserSessionModel;\nimport org.keycloak.models.utils.DefaultAuthenticationFlows;\nimport org.keycloak.protocol.saml.JaxrsSAML2BindingBuilder;\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.protocol.saml.SamlProtocol;\nimport org.keycloak.protocol.saml.SamlService;\nimport org.keycloak.protocol.saml.profile.util.Soap;\nimport org.keycloak.saml.SAML2LogoutResponseBuilder;\nimport org.keycloak.saml.common.constants.JBossSAMLConstants;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.common.exceptions.ConfigurationException;\nimport org.keycloak.saml.common.exceptions.ProcessingException;\nimport org.keycloak.saml.validators.DestinationValidator;\nimport org.keycloak.sessions.AuthenticationSessionModel;\nimport org.w3c.dom.Document;\n\nimport javax.ws.rs.core.Response;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPHeaderElement;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n */\npublic class SamlEcpProfileService extends SamlService {\n\n    private static final String NS_PREFIX_PROFILE_ECP = \"ecp\";\n    private static final String NS_PREFIX_SAML_PROTOCOL = \"samlp\";\n    private static final String NS_PREFIX_SAML_ASSERTION = \"saml\";\n\n    public SamlEcpProfileService(RealmModel realm, EventBuilder event, DestinationValidator destinationValidator) {\n        super(realm, event, destinationValidator);\n    }\n\n    public Response authenticate(InputStream inputStream) {\n        return authenticate(Soap.extractSoapMessage(inputStream));\n    }\n\n    public Response authenticate(Document soapMessage) {\n        try {\n            return new PostBindingProtocol() {\n                @Override\n                protected String getBindingType(AuthnRequestType requestAbstractType) {\n                    return SamlProtocol.SAML_SOAP_BINDING;\n                }\n\n                @Override\n                protected boolean isDestinationRequired() {\n                    return false;\n                }\n\n                @Override\n                protected Response loginRequest(String relayState, AuthnRequestType requestAbstractType, ClientModel client) {\n                    // force passive authentication when executing this profile\n                    requestAbstractType.setIsPassive(true);\n                    requestAbstractType.setDestination(session.getContext().getUri().getAbsolutePath());\n                    return super.loginRequest(relayState, requestAbstractType, client);\n                }\n            }.execute(Soap.toSamlHttpPostMessage(soapMessage), null, null, null);\n        } catch (Exception e) {\n            String reason = \"Some error occurred while processing the AuthnRequest.\";\n            String detail = e.getMessage();\n\n            if (detail == null) {\n                detail = reason;\n            }\n\n            return Soap.createFault().reason(reason).detail(detail).build();\n        }\n    }\n\n    @Override\n    protected Response newBrowserAuthentication(AuthenticationSessionModel authSession, boolean isPassive, boolean redirectToAuthentication, SamlProtocol samlProtocol) {\n        return super.newBrowserAuthentication(authSession, isPassive, redirectToAuthentication, createEcpSamlProtocol());\n    }\n\n    private SamlProtocol createEcpSamlProtocol() {\n        return new SamlProtocol() {\n            // method created to send a SOAP Binding response instead of a HTTP POST response\n            @Override\n            protected Response buildAuthenticatedResponse(AuthenticatedClientSessionModel clientSession, String redirectUri, Document samlDocument, JaxrsSAML2BindingBuilder bindingBuilder) throws ConfigurationException, ProcessingException, IOException {\n                Document document = bindingBuilder.postBinding(samlDocument).getDocument();\n\n                try {\n                    Soap.SoapMessageBuilder messageBuilder = Soap.createMessage()\n                            .addNamespace(NS_PREFIX_SAML_ASSERTION, JBossSAMLURIConstants.ASSERTION_NSURI.get())\n                            .addNamespace(NS_PREFIX_SAML_PROTOCOL, JBossSAMLURIConstants.PROTOCOL_NSURI.get())\n                            .addNamespace(NS_PREFIX_PROFILE_ECP, JBossSAMLURIConstants.ECP_PROFILE.get());\n\n                    createEcpResponseHeader(redirectUri, messageBuilder);\n                    createRequestAuthenticatedHeader(clientSession, messageBuilder);\n\n                    messageBuilder.addToBody(document);\n\n                    return messageBuilder.build();\n                } catch (Exception e) {\n                    throw new RuntimeException(\"Error while creating SAML response.\", e);\n                }\n            }\n\n            private void createRequestAuthenticatedHeader(AuthenticatedClientSessionModel clientSession, Soap.SoapMessageBuilder messageBuilder) {\n                ClientModel client = clientSession.getClient();\n\n                if (\"true\".equals(client.getAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE))) {\n                    SOAPHeaderElement ecpRequestAuthenticated = messageBuilder.addHeader(JBossSAMLConstants.REQUEST_AUTHENTICATED.get(), NS_PREFIX_PROFILE_ECP);\n\n                    ecpRequestAuthenticated.setMustUnderstand(true);\n                    ecpRequestAuthenticated.setActor(\"http://schemas.xmlsoap.org/soap/actor/next\");\n                }\n            }\n\n            private void createEcpResponseHeader(String redirectUri, Soap.SoapMessageBuilder messageBuilder) throws SOAPException {\n                SOAPHeaderElement ecpResponseHeader = messageBuilder.addHeader(JBossSAMLConstants.RESPONSE__ECP.get(), NS_PREFIX_PROFILE_ECP);\n\n                ecpResponseHeader.setMustUnderstand(true);\n                ecpResponseHeader.setActor(\"http://schemas.xmlsoap.org/soap/actor/next\");\n                ecpResponseHeader.addAttribute(messageBuilder.createName(JBossSAMLConstants.ASSERTION_CONSUMER_SERVICE_URL.get()), redirectUri);\n            }\n\n            @Override\n            protected Response buildErrorResponse(boolean isPostBinding, String uri, JaxrsSAML2BindingBuilder binding, Document document) throws ConfigurationException, ProcessingException, IOException {\n                return Soap.createMessage().addToBody(document).build();\n            }\n\n            @Override\n            protected Response buildLogoutResponse(UserSessionModel userSession, String logoutBindingUri, SAML2LogoutResponseBuilder builder, JaxrsSAML2BindingBuilder binding) throws ConfigurationException, ProcessingException, IOException {\n                return Soap.createFault().reason(\"Logout not supported.\").build();\n            }\n        }.setEventBuilder(event).setHttpHeaders(headers).setRealm(realm).setSession(session).setUriInfo(session.getContext().getUri());\n    }\n\n    @Override\n    protected AuthenticationFlowModel getAuthenticationFlow(AuthenticationSessionModel authSession) {\n        return realm.getAuthenticationFlowsStream()\n                .filter(flow -> Objects.equals(flow.getAlias(), DefaultAuthenticationFlows.SAML_ECP_FLOW))\n                .findFirst()\n                .orElseThrow(() -> new RuntimeException(\"Could not resolve authentication flow for SAML ECP Profile.\"));\n    }\n}\n", "/*\n * Copyright 2021 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.keycloak.testsuite.saml;\n\nimport org.junit.Test;\nimport org.keycloak.dom.saml.v2.protocol.ResponseType;\nimport org.keycloak.dom.saml.v2.protocol.StatusResponseType;\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.saml.processing.core.saml.v2.common.SAMLDocumentHolder;\nimport org.keycloak.testsuite.updaters.ClientAttributeUpdater;\nimport org.keycloak.testsuite.util.SamlClientBuilder;\n\nimport static org.hamcrest.Matchers.empty;\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.assertThat;\nimport static org.keycloak.testsuite.util.SamlClient.Binding.POST;\nimport static org.keycloak.testsuite.util.SamlClient.Binding.SOAP;\n\npublic class SOAPBindingTest extends AbstractSamlTest {\n\n    @Test\n    public void soapBindingAuthnWithSignatureTest() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                    .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingAuthnWithSignatureMissingDestinationTest() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                    .transformObject(authnRequestType -> {\n                        authnRequestType.setDestination(null);\n                        return authnRequestType;\n                    })\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingAuthnWithoutSignatureTest() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingAuthnWithoutSignatureMissingDestinationTest() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                    .transformObject(authnRequestType -> {\n                        authnRequestType.setDestination(null);\n                        return authnRequestType;\n                    })\n                    .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingLogoutWithSignature() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                    .nameId(nameIdRef::get)\n                    .sessionIndex(sessionIndexRef::get)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingLogoutWithoutSignature() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                    .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                    .nameId(nameIdRef::get)\n                    .sessionIndex(sessionIndexRef::get)\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingLogoutWithSignatureMissingDestinationTest() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                    .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                    .nameId(nameIdRef::get)\n                    .sessionIndex(sessionIndexRef::get)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                    .transformObject(logoutRequestType -> {\n                        logoutRequestType.setDestination(null);\n                        return logoutRequestType;\n                    })\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingLogoutWithoutSignatureMissingDestinationTest() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                .nameId(nameIdRef::get)\n                .sessionIndex(sessionIndexRef::get)\n                .transformObject(logoutRequestType -> {\n                    logoutRequestType.setDestination(null);\n                    return logoutRequestType;\n                })\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n}\n", "{\n    \"id\": \"demo\",\n    \"realm\": \"demo\",\n    \"enabled\": true,\n    \"sslRequired\": \"external\",\n    \"registrationAllowed\": true,\n    \"resetPasswordAllowed\": true,\n    \"privateKey\": \"MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y=\",\n    \"publicKey\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n    \"requiredCredentials\": [ \"password\" ],\n    \"passwordPolicy\": \"hashIterations(1)\",\n    \"defaultRoles\": [ \"user\" ],\n    \"smtpServer\": {\n        \"from\": \"auto@keycloak.org\",\n        \"host\": \"localhost\",\n        \"port\":\"3025\"\n    },\n    \"eventsEnabled\" : true,\n    \"eventsListeners\" : [ \"jboss-logging\" ],\n    \"enabledEventTypes\" : [ ],\n    \"users\" : [\n        {\n            \"username\" : \"bburke\",\n            \"enabled\": true,\n            \"email\" : \"bburke@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"attributes\" : {\n                \"phone\": \"617\"\n            },\n            \"realmRoles\": [\"manager\", \"user\"],\n            \"applicationRoles\": {\n                \"http://localhost:8280/employee/\": [ \"employee\" ],\n                \"http://localhost:8280/employee2/\": [ \"empl.oyee\", \"employee\" ],\n                \"http://localhost:8280/employee-role-mapping/\": [\"employee\"]\n            }\n        },\n        {\n            \"username\" : \"bburke-additional-domain\",\n            \"enabled\": true,\n            \"email\" : \"bburke@redhat.com.additional.domain\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"attributes\" : {\n                \"phone\": \"617\"\n            },\n            \"realmRoles\": [\"manager\", \"user\"],\n            \"applicationRoles\": {\n                \"http://localhost:8280/employee/\": [ \"employee\" ],\n                \"http://localhost:8280/employee2/\": [ \"employee\" ]\n            }\n        },\n        {\n            \"username\" : \"unauthorized\",\n            \"enabled\": true,\n            \"email\" : \"unauthorized@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ]\n        },\n        {\n            \"username\" : \"topGroupUser\",\n            \"enabled\": true,\n            \"email\" : \"top@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"groups\": [\n                \"/top\"\n            ]\n        },\n        {\n            \"username\" : \"level2GroupUser\",\n            \"enabled\": true,\n            \"email\" : \"level2@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"groups\": [\n                \"/top/level2\"\n            ]\n        },\n        {\n            \"username\" : \"pedroigor\",\n            \"enabled\": true,\n            \"email\" : \"psilva@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"attributes\" : {\n                \"phone\": \"617\"\n            },\n            \"realmRoles\": [\"manager\", \"user\"]\n        }\n    ],\n    \"clients\": [\n        {\n            \"clientId\": \"http://localhost:8280/missing-assertion-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/missing-assertion-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/missing-assertion-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml.server.signature\": \"true\",\n                \"saml.assertion.signature\": \"false\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/bad-assertion-sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/bad-assertion-sales-post-sig/\",\n            \"adminUrl\": \"http://localhost:8080/bad-assertion-sales-post-sig/saml\",\n            \"redirectUris\": [\n                \"http://localhost:8080/bad-assertion-sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.assertion.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/input-portal/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/input-portal\",\n            \"redirectUris\": [\n                \"http://localhost:8080/input-portal/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/input-portal/saml\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/input-portal/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/input-portal/saml\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/input-portal/saml\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-assertion-and-response-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-assertion-and-response-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-assertion-and-response-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml.server.signature\": \"true\",\n                \"saml.assertion.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post2/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post2\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post2/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/sales-post2/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/sales-post2/saml\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post2\",\n                \"saml_idp_initiated_sso_relay_state\": \"redirectTo=/foo\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/different-cookie-name/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/different-cookie-name\",\n            \"redirectUris\": [\n                \"http://localhost:8080/different-cookie-name/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/different-cookie-name/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/different-cookie-name/saml\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/sales-post/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/sales-post/saml\",\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-clock-skew/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post-clock-skew\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-clock-skew/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post-clock-skew\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-passive/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post-passive\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-passive/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post-passive\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig-transient/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig-transient\",\n            \"adminUrl\": \"http://localhost:8080/sales-post-sig-transient\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig-transient/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig-persistent/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig-persistent\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig-persistent/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig-email/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig-email\",\n            \"adminUrl\": \"http://localhost:8080/sales-post-sig-email\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig-email/*\"\n            ],\n            \"attributes\": {\n                \"saml_force_name_id_format\": \"true\",\n                \"saml_name_id_format\": \"email\",\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\" : \"sales-post-sig-email\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/bad-realm-sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/bad-realm-sales-post-sig\",\n            \"adminUrl\": \"http://localhost:8080/bad-realm-sales-post-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/bad-realm-sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/bad-client-sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/bad-client-sales-post-sig\",\n            \"adminUrl\": \"http://localhost:8080/bad-client-sales-post-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/bad-client-sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-enc/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-enc\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-enc/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA512\",\n                \"saml.client.signature\": \"true\",\n                \"saml.encrypt\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\",\n                \"saml.encryption.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-enc-sign-assertions-only/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-enc-sign-assertions-only\",\n            \"redirectUris\": [\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"false\",\n                \"saml.assertion.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA512\",\n                \"saml.client.signature\": \"true\",\n                \"saml.encrypt\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\",\n                \"saml.encryption.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-redir-noidpkey/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-redir-noidpkey\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-redir-noidpkey/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig-redir-noidpkey\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-redir-opt-noidpkey/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-redir-opt-noidpkey\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-redir-opt-noidpkey/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig-redir-opt-noidpkey\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.server.signature.keyinfo.ext\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-post-noidpkey/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-post-noidpkey\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-post-noidpkey/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig-post-noidpkey\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-acs/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-acs\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-acs/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-acs\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee2/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee2\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee2/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee2\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\" : \"employee2\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-dom/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-dom\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-dom/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-dom\",\n            \"attributes\": {\n                \"saml.assertion.signature\": \"true\",\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIC+zCCAeOgAwIBAgIEcFrChjANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtZG9tLzAeFw0xOTA3MDMwOTE1NDlaFw00NjExMTgwOTE1NDlaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1kb20vMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmEbjaKmKCh2MXTVLMUXdbjKSdmXAOenuE2bDD0AlEaJmnJ5zU2JY6UuFflH3332n2YktaaCyTznwX1Zcf7GH3bm7xhV1HSmlbFpIY17M8QUOIGZEzvKSbT9gjRJSPIdE1JvZuqgzuXpRlRfC4eoH1VgS0Vmu4gwIRFnUUgqc5hW11AQVkGZs7TkEYbVEYneKMbQOKa1OzW+FAb7C13Yn19gSvGr3THE+7FGwxEJM6N6kr4xnxg4VpaXcsW4ijGI3CHPJA06MZ6LzXxCmz+8TOSLo5pV7GKgME9QR1lBSC2Cp0yDtHjqK6QCqApyHhP2xN8qzJhMIhffSSHq4GokhjwIDAQABoyEwHzAdBgNVHQ4EFgQUOVG/h7cr+T6LJ4dQIVALBknwF/AwDQYJKoZIhvcNAQELBQADggEBAI5Y1MPMHPsDRJBQke/+tkRO4PALbsAQtfvYDNmpBGzUNo2xU3n7PNzbWrcqubjLN0nqXloBTaeeHtrFGAejMCS5X8UOGLyXbKBm7hHJs5ZZASrm0FkUzyuJexWCbSAg0p7Z6wWw03dnV/A9LDFwTdGIYsnSzZ59/v3BUH89mavOwVuVJB5O2PysUob3urcv1tmv9eL5jAMc764ID1gLkydcNrmICa+aZ/FojfReyTtwWX0DoPflPvF/Xllp3jLg1HwSlD6fD2wO/MKawgBbE6xrAkg5bF01B25RadJJffx3hEtgxBzlo1EL4Ir+lJmM1vzuTq4c1wDYKku4Y0Qg5o0=\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-front/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"frontchannelLogout\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-front\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-front/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA1\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/ecp-sp/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/ecp-sp\",\n            \"redirectUris\": [\n                \"http://localhost:8080/ecp-sp/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/ecp-sp/\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/ecp-sp/\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/ecp-sp/\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/ecp-sp/\",\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-role-mapping/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-role-mapping\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-role-mapping/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-role-mapping\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\" : \"employee-role-mapping\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        }\n    ],\n    \"groups\" : [\n        {\n            \"name\": \"top\",\n            \"attributes\": {\n                \"topAttribute\": [\"true\"]\n\n            },\n            \"realmRoles\": [\"manager\"],\n            \"subGroups\": [\n                {\n                    \"name\": \"level2\",\n                    \"realmRoles\": [\"user\"],\n                    \"attributes\": {\n                        \"level2Attribute\": [\"true\"]\n\n                    }\n                }\n            ]\n        }\n    ],\n\n    \"roles\" : {\n        \"realm\" : [\n            {\n                \"name\": \"manager\",\n                \"description\": \"Have Manager privileges\"\n            },\n            {\n                \"name\": \"user\",\n                \"description\": \"Have User privileges\"\n            },\n            {\n                \"name\": \"role.with.dots\",\n                \"description\": \"Role with dots in the name\"\n            }\n        ],\n        \"application\" : {\n            \"http://localhost:8280/employee/\" : [\n                {\n                    \"name\": \"employee\",\n                    \"description\": \"Have Employee privileges\"\n                }\n            ],\n            \"http://localhost:8280/employee2/\" : [\n                {\n                    \"name\": \"employee\",\n                    \"description\": \"Have Employee privileges\"\n                },\n                {\n                    \"name\": \"empl.oyee\",\n                    \"description\": \"Have Employee privileges with dots\"\n                }\n            ],\n            \"http://localhost:8280/employee-role-mapping/\" : [\n                {\n                    \"name\": \"employee\",\n                    \"description\": \"Have Employee privileges\"\n                },\n                {\n                    \"name\": \"supervisor\",\n                    \"description\": \"Have Supervisor privileges\"\n                }\n            ]\n\n        }\n    }\n}\n", "package org.keycloak.testsuite.console.page.clients.settings;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.testsuite.console.page.clients.CreateClientForm;\nimport org.keycloak.testsuite.console.page.fragment.OnOffSwitch;\nimport org.keycloak.testsuite.page.Form;\nimport org.keycloak.testsuite.util.Timer;\nimport org.keycloak.testsuite.util.UIUtils;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.FindBy;\nimport org.openqa.selenium.support.ui.Select;\n\nimport static org.keycloak.testsuite.util.WaitUtils.pause;\nimport static org.keycloak.testsuite.util.WaitUtils.waitUntilElement;\n\n/**\n * @author tkyjovsk\n */\npublic class ClientSettingsForm extends CreateClientForm {\n\n    @FindBy(id = \"name\")\n    private WebElement nameInput;\n\n    @FindBy(id = \"baseUrl\")\n    private WebElement baseUrlInput;\n    @FindBy(id = \"adminUrl\")\n    private WebElement adminUrlInput;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='enabled']]\")\n    private OnOffSwitch enabledSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='alwaysDisplayInConsole']]\")\n    private OnOffSwitch alwaysDisplayInConsole;\n    \n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='consentRequired']]\")\n    private OnOffSwitch consentRequiredSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='standardFlowEnabled']]\")\n    private OnOffSwitch standardFlowEnabledSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='implicitFlowEnabled']]\")\n    private OnOffSwitch implicitFlowEnabledSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='directAccessGrantsEnabled']]\")\n    private OnOffSwitch directAccessGrantsEnabledSwitch;\n\n    @FindBy(id = \"accessType\")\n    private Select accessTypeSelect;\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='serviceAccountsEnabled']]\")\n    private OnOffSwitch serviceAccountsEnabledSwitch;\n\n    @FindBy(id = \"newRedirectUri\")\n    private WebElement newRedirectUriInput;\n    @FindBy(xpath = \".//button[contains(@data-ng-click,'addRedirectUri')]\")\n    private WebElement newRedirectUriSubmit;\n    @FindBy(xpath = \".//input[@ng-model='client.redirectUris[i]']\")\n    private List<WebElement> redirectUriInputs;\n    @FindBy(xpath = \".//button[contains(@data-ng-click, 'deleteRedirectUri')]\")\n    private List<WebElement> deleteRedirectUriIcons;\n\n    @FindBy(id = \"newWebOrigin\")\n    private WebElement newWebOriginInput;\n    @FindBy(xpath = \".//button[contains(@data-ng-click,'addWebOrigin')]\")\n    private WebElement newWebOriginSubmit;\n    @FindBy(xpath = \".//input[ng-model='client.webOrigins[i]']\")\n    private List<WebElement> webOriginInputs;\n    @FindBy(xpath = \".//button[contains(@data-ng-click, 'deleteWebOrigin')]\")\n    private List<WebElement> deleteWebOriginIcons;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='authorizationServicesEnabled']]\")\n    private OnOffSwitch authorizationSettingsEnabledSwitch;\n\n    @FindBy(xpath = ACTIVE_DIV_XPATH + \"/button[text()='Disable Authorization Settings']\")\n    private WebElement confirmDisableAuthorizationSettingsButton;\n\n    public enum OidcAccessType {\n        BEARER_ONLY(\"bearer-only\"), PUBLIC(\"public\"), CONFIDENTIAL(\"confidential\");\n\n        private final String name;\n\n        private OidcAccessType(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n    }\n\n    public void setBaseUrl(String baseUrl) {\n        UIUtils.setTextInputValue(baseUrlInput, baseUrl);\n    }\n\n    public String getBaseUrl() {\n        return UIUtils.getTextInputValue(baseUrlInput);\n    }\n\n    public void setAdminUrl(String adminUrl) {\n        UIUtils.setTextInputValue(adminUrlInput, adminUrl);\n    }\n\n    public String getAdminUrl() {\n        return UIUtils.getTextInputValue(adminUrlInput);\n    }\n\n    public void addWebOrigin(String redirectUri) {\n        newWebOriginInput.sendKeys(redirectUri);\n        newWebOriginSubmit.click();\n    }\n\n    public List<String> getWebOrigins() {\n        List<String> values = new ArrayList<>();\n        for (WebElement input : webOriginInputs) {\n            values.add(UIUtils.getTextInputValue(input));\n        }\n        return values;\n    }\n\n    public void setWebOrigins(List<String> webOrigins) {\n        while (!deleteWebOriginIcons.isEmpty()) {\n            deleteWebOriginIcons.get(0).click();\n            pause(100);\n        }\n        if (webOrigins != null) {\n            for (String redirectUri : webOrigins) {\n                addWebOrigin(redirectUri);\n                pause(100);\n            }\n        }\n    }\n\n    public String getName() {\n        return UIUtils.getTextInputValue(nameInput);\n    }\n\n    public void setName(String name) {\n        UIUtils.setTextInputValue(nameInput, name);\n    }\n\n    public boolean isEnabled() {\n        return enabledSwitch.isOn();\n    }\n\n    public void setEnabled(boolean enabled) {\n        enabledSwitch.setOn(enabled);\n    }\n\n    public boolean isAlwaysDisplayInConsole() {\n        return alwaysDisplayInConsole.isOn();\n    }\n\n    public void setAlwaysDisplayInConsole(boolean enabled) {\n        alwaysDisplayInConsole.setOn(enabled);\n    }\n\n    public boolean isAlwaysDisplayInConsoleVisible() {\n        return alwaysDisplayInConsole.isVisible();\n    }\n\n    public boolean isConsentRequired() {\n        return consentRequiredSwitch.isOn();\n    }\n\n    public void setConsentRequired(boolean consentRequired) {\n        consentRequiredSwitch.setOn(consentRequired);\n    }\n\n    public void setAccessType(OidcAccessType accessType) {\n        accessTypeSelect.selectByVisibleText(accessType.getName());\n    }\n\n    public void addRedirectUri(String redirectUri) {\n        newRedirectUriInput.sendKeys(redirectUri);\n        newRedirectUriSubmit.click();\n    }\n\n    public List<String> getRedirectUris() {\n        List<String> values = new ArrayList<>();\n        for (WebElement input : redirectUriInputs) {\n            values.add(UIUtils.getTextInputValue(input));\n        }\n        return values;\n    }\n\n    public void setRedirectUris(List<String> redirectUris) {\n        Timer.DEFAULT.reset();\n        while (!deleteRedirectUriIcons.isEmpty()) {\n            deleteRedirectUriIcons.get(0).click();\n            pause(100);\n        }\n        Timer.DEFAULT.reset(\"deleteRedirectUris\");\n        if (redirectUris != null) {\n            for (String redirectUri : redirectUris) {\n                addRedirectUri(redirectUri);\n                pause(100);\n            }\n        }\n        Timer.DEFAULT.reset(\"addRedirectUris\");\n    }\n\n    public boolean isStandardFlowEnabled() {\n        return standardFlowEnabledSwitch.isOn();\n    }\n\n    public void setStandardFlowEnabled(boolean standardFlowEnabled) {\n        standardFlowEnabledSwitch.setOn(standardFlowEnabled);\n    }\n\n    public boolean isImplicitFlowEnabled() {\n        return implicitFlowEnabledSwitch.isOn();\n    }\n\n    public void setImplicitFlowEnabled(boolean implicitFlowEnabled) {\n        implicitFlowEnabledSwitch.setOn(implicitFlowEnabled);\n    }\n\n    public boolean isDirectAccessGrantsEnabled() {\n        return directAccessGrantsEnabledSwitch.isOn();\n    }\n\n    public void setDirectAccessGrantsEnabled(boolean directAccessGrantsEnabled) {\n        directAccessGrantsEnabledSwitch.setOn(directAccessGrantsEnabled);\n    }\n\n    public boolean isServiceAccountsEnabled() {\n        return serviceAccountsEnabledSwitch.isOn();\n    }\n\n    public void setServiceAccountsEnabled(boolean serviceAccountsEnabled) {\n        serviceAccountsEnabledSwitch.setOn(serviceAccountsEnabled);\n    }\n\n    public void setAuthorizationSettingsEnabled(boolean enabled) {\n        authorizationSettingsEnabledSwitch.setOn(enabled);\n    }\n\n    public boolean isAuthorizationSettingsEnabled() {\n        return authorizationSettingsEnabledSwitch.isOn();\n    }\n\n    public void confirmDisableAuthorizationSettings() {\n        confirmDisableAuthorizationSettingsButton.click();\n    }\n\n    public class SAMLClientSettingsForm extends Form {\n\n        public static final String SAML_ASSERTION_SIGNATURE = \"saml.assertion.signature\";\n        public static final String SAML_AUTHNSTATEMENT = \"saml.authnstatement\";\n        public static final String SAML_ONETIMEUSE_CONDITION = \"saml.onetimeuse.condition\";\n        public static final String SAML_CLIENT_SIGNATURE = \"saml.client.signature\";\n        public static final String SAML_ENCRYPT = \"saml.encrypt\";\n        public static final String SAML_FORCE_POST_BINDING = \"saml.force.post.binding\";\n        public static final String SAML_MULTIVALUED_ROLES = \"saml.multivalued.roles\";\n        public static final String SAML_SERVER_SIGNATURE = \"saml.server.signature\";\n        public static final String SAML_SERVER_SIGNATURE_KEYINFO_EXT = \"saml.server.signature.keyinfo.ext\";\n        public static final String SAML_SIGNATURE_ALGORITHM = \"saml.signature.algorithm\";\n        public static final String SAML_ASSERTION_CONSUMER_URL_POST = \"saml_assertion_consumer_url_post\";\n        public static final String SAML_ASSERTION_CONSUMER_URL_REDIRECT = \"saml_assertion_consumer_url_redirect\";\n        public static final String SAML_FORCE_NAME_ID_FORMAT = \"saml_force_name_id_format\";\n        public static final String SAML_NAME_ID_FORMAT = \"saml_name_id_format\";\n        public static final String SAML_SIGNATURE_CANONICALIZATION_METHOD = \"saml_signature_canonicalization_method\";\n        public static final String SAML_SINGLE_LOGOUT_SERVICE_URL_POST = \"saml_single_logout_service_url_post\";\n        public static final String SAML_SINGLE_LOGOUT_SERVICE_URL_REDIRECT = \"saml_single_logout_service_url_redirect\";\n\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlAuthnStatement']]\")\n        private OnOffSwitch samlAuthnStatement;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlOneTimeUseCondition']]\")\n        private OnOffSwitch samlOneTimeUseCondition;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlServerSignature']]\")\n        private OnOffSwitch samlServerSignature;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlServerSignatureEnableKeyInfoExtension']]\")\n        private OnOffSwitch samlServerSignatureKeyInfoExt;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlAssertionSignature']]\")\n        private OnOffSwitch samlAssertionSignature;\n        @FindBy(id = \"signatureAlgorithm\")\n        private Select signatureAlgorithm;\n        @FindBy(id = \"canonicalization\")\n        private Select canonicalization;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlEncrypt']]\")\n        private OnOffSwitch samlEncrypt;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlClientSignature']]\")\n        private OnOffSwitch samlClientSignature;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlForcePostBinding']]\")\n        private OnOffSwitch samlForcePostBinding;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='frontchannelLogout']]\")\n        private OnOffSwitch frontchannelLogout;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlForceNameIdFormat']]\")\n        private OnOffSwitch samlForceNameIdFormat;\n        @FindBy(id = \"samlNameIdFormat\")\n        private Select samlNameIdFormat;\n\n        @FindBy(xpath = \"//fieldset[contains(@data-ng-show, 'saml')]//i\")\n        private WebElement fineGrainCollapsor;\n\n        @FindBy(id = \"consumerServicePost\")\n        private WebElement consumerServicePostInput;\n        @FindBy(id = \"consumerServiceRedirect\")\n        private WebElement consumerServiceRedirectInput;\n        @FindBy(id = \"logoutPostBinding\")\n        private WebElement logoutPostBindingInput;\n        @FindBy(id = \"logoutRedirectBinding\")\n        private WebElement logoutRedirectBindingInput;\n\n        public void setValues(ClientRepresentation client) {\n            waitUntilElement(fineGrainCollapsor).is().visible();\n\n            Map<String, String> attributes = client.getAttributes();\n            samlAuthnStatement.setOn(\"true\".equals(attributes.get(SAML_AUTHNSTATEMENT)));\n            samlOneTimeUseCondition.setOn(\"true\".equals(attributes.get(SAML_ONETIMEUSE_CONDITION)));\n            samlServerSignature.setOn(\"true\".equals(attributes.get(SAML_SERVER_SIGNATURE)));\n            samlAssertionSignature.setOn(\"true\".equals(attributes.get(SAML_ASSERTION_SIGNATURE)));\n            if (samlServerSignature.isOn() || samlAssertionSignature.isOn()) {\n                signatureAlgorithm.selectByVisibleText(attributes.get(SAML_SIGNATURE_ALGORITHM));\n                canonicalization.selectByValue(\"string:\" + attributes.get(SAML_SIGNATURE_CANONICALIZATION_METHOD));\n                samlServerSignatureKeyInfoExt.setOn(\"true\".equals(attributes.get(SAML_SERVER_SIGNATURE_KEYINFO_EXT)));\n            }\n            samlEncrypt.setOn(\"true\".equals(attributes.get(SAML_ENCRYPT)));\n            samlClientSignature.setOn(\"true\".equals(attributes.get(SAML_CLIENT_SIGNATURE)));\n            samlForcePostBinding.setOn(\"true\".equals(attributes.get(SAML_FORCE_POST_BINDING)));\n            frontchannelLogout.setOn(client.isFrontchannelLogout());\n            samlForceNameIdFormat.setOn(\"true\".equals(attributes.get(SAML_FORCE_NAME_ID_FORMAT)));\n            samlNameIdFormat.selectByVisibleText(attributes.get(SAML_NAME_ID_FORMAT));\n\n            fineGrainCollapsor.click();\n            waitUntilElement(consumerServicePostInput).is().present();\n\n            UIUtils.setTextInputValue(consumerServicePostInput, attributes.get(SAML_ASSERTION_CONSUMER_URL_POST));\n            UIUtils.setTextInputValue(consumerServiceRedirectInput, attributes.get(SAML_ASSERTION_CONSUMER_URL_REDIRECT));\n            UIUtils.setTextInputValue(logoutPostBindingInput, attributes.get(SAML_SINGLE_LOGOUT_SERVICE_URL_POST));\n            UIUtils.setTextInputValue(logoutRedirectBindingInput, attributes.get(SAML_SINGLE_LOGOUT_SERVICE_URL_REDIRECT));\n        }\n    }\n\n}\n", "package org.keycloak.testsuite.console.clients;\n\nimport org.jboss.arquillian.graphene.page.Page;\nimport org.junit.Before;\nimport org.keycloak.admin.client.resource.ClientResource;\nimport org.keycloak.admin.client.resource.ClientsResource;\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.protocol.saml.util.ArtifactBindingUtils;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.representations.idm.ProtocolMapperRepresentation;\nimport org.keycloak.testsuite.console.AbstractConsoleTest;\nimport org.keycloak.testsuite.console.page.clients.Client;\nimport org.keycloak.testsuite.console.page.clients.Clients;\nimport org.keycloak.testsuite.console.page.clients.CreateClient;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.keycloak.testsuite.auth.page.login.OIDCLogin.OIDC;\nimport static org.keycloak.testsuite.auth.page.login.OIDCLogin.SAML;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_AUTHNSTATEMENT;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_CLIENT_SIGNATURE;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_FORCE_NAME_ID_FORMAT;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_FORCE_POST_BINDING;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_NAME_ID_FORMAT;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_ONETIMEUSE_CONDITION;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_SERVER_SIGNATURE;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_SIGNATURE_ALGORITHM;\nimport static org.keycloak.testsuite.util.AttributesAssert.assertEqualsBooleanAttributes;\nimport static org.keycloak.testsuite.util.AttributesAssert.assertEqualsListAttributes;\nimport static org.keycloak.testsuite.util.AttributesAssert.assertEqualsStringAttributes;\nimport static org.keycloak.testsuite.util.URLAssert.assertCurrentUrlEquals;\n\n/**\n *\n * @author tkyjovsk\n */\npublic abstract class AbstractClientTest extends AbstractConsoleTest {\n\n    public final String TEST_CLIENT_ID = \"test-client\";\n    public final List<String> TEST_REDIRECT_URIs = Arrays.asList(new String[] { \"http://example.test/app/\" });\n\n    @Page\n    protected Clients clientsPage;\n    @Page\n    protected Client clientPage; // note: cannot call navigateTo() unless client id is set\n    @Page\n    protected CreateClient createClientPage;\n\n    @Before\n    public void beforeClientTest() {\n        clientsPage.navigateTo();\n    }\n\n    public void createClient(ClientRepresentation client) {\n        assertCurrentUrlEquals(clientsPage);\n        clientsPage.table().createClient();\n        createClientPage.form().setValues(client);\n        createClientPage.form().save();\n        assertAlertSuccess();\n    }\n\n    public static ClientRepresentation createClientRep(String clientId, String protocol) {\n        ClientRepresentation client = new ClientRepresentation();\n        client.setClientId(clientId);\n        client.setEnabled(true);\n        client.setProtocol(protocol);\n\n        client.setDirectAccessGrantsEnabled(true);\n        client.setFullScopeAllowed(true);\n        client.setPublicClient(true);\n        client.setStandardFlowEnabled(true);\n\n        if (protocol.equals(SAML)) {\n            client.setAttributes(getSAMLAttributes());\n        }\n        return client;\n    }\n\n    public static Map<String, String> getSAMLAttributes() {\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(SAML_CLIENT_SIGNATURE, \"true\");\n        attributes.put(SAML_AUTHNSTATEMENT, \"true\");\n        attributes.put(SAML_FORCE_POST_BINDING, \"true\");\n        attributes.put(SAML_SERVER_SIGNATURE, \"true\");\n        attributes.put(SAML_SIGNATURE_ALGORITHM, \"RSA_SHA256\");\n        attributes.put(SAML_FORCE_NAME_ID_FORMAT, \"false\");\n        attributes.put(SAML_NAME_ID_FORMAT, \"username\");\n        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(\"saml\"));\n        return attributes;\n    }\n\n    public ClientRepresentation findClientByClientId(String clientId) {\n        ClientRepresentation found = null;\n        for (ClientRepresentation clientRepresentation : testRealmResource().clients().findAll()) {\n            if (clientRepresentation.getClientId().equals(clientId)) {\n                found = clientRepresentation;\n                break;\n            }\n        }\n        return found;\n    }\n\n    public void assertClientSettingsEqual(ClientRepresentation c1, ClientRepresentation c2) {\n        assertEqualsStringAttributes(c1.getClientId(), c2.getClientId());\n        assertEqualsStringAttributes(c1.getName(), c2.getName());\n        assertEqualsBooleanAttributes(c1.isEnabled(), c2.isEnabled());\n        assertEqualsBooleanAttributes(c1.isAlwaysDisplayInConsole(), c2.isAlwaysDisplayInConsole());\n        assertEqualsStringAttributes(c1.getBaseUrl(), c2.getBaseUrl());\n        assertEqualsBooleanAttributes(c1.isConsentRequired(), c2.isConsentRequired());\n        assertEqualsStringAttributes(c1.getProtocol(), c2.getProtocol());\n        assertEqualsListAttributes(c1.getRedirectUris(), c2.getRedirectUris());\n\n        if (c1.getProtocol().equals(OIDC)) {\n            assertEqualsBooleanAttributes(c1.isBearerOnly(), c2.isBearerOnly());\n            assertEqualsBooleanAttributes(c1.isDirectAccessGrantsEnabled(), c2.isDirectAccessGrantsEnabled());\n            assertEqualsBooleanAttributes(c1.isPublicClient(), c2.isPublicClient());\n            assertEqualsListAttributes(c1.getWebOrigins(), c2.getWebOrigins());\n            assertEqualsStringAttributes(c1.getAdminUrl(), c2.getAdminUrl());\n            assertEqualsBooleanAttributes(c1.isSurrogateAuthRequired(), c2.isSurrogateAuthRequired());\n            assertEqualsBooleanAttributes(c1.isServiceAccountsEnabled(), c2.isServiceAccountsEnabled());\n        }\n    }\n\n    public void assertClientSamlAttributes(Map<String, String> expected, Map<String, String> actual) {\n        for (String key : expected.keySet()) {\n            assertEquals(\"Expected attribute \" + key, expected.get(key), actual.get(key));\n        }\n    }\n\n    public ProtocolMapperRepresentation findClientMapperByName(String clientId, String mapperName) {\n        ProtocolMapperRepresentation found = null;\n        for (ProtocolMapperRepresentation mapper : testRealmResource().clients().get(clientId).getProtocolMappers()\n                .getMappers()) {\n            if (mapperName.equals(mapper.getName())) {\n                found = mapper;\n            }\n        }\n        return found;\n    }\n\n    public ClientsResource clientsResource() {\n        return testRealmResource().clients();\n    }\n\n    public ClientResource clientResource(String id) {\n        return clientsResource().get(id);\n    }\n\n}\n", "consoleTitle=Keycloak Admin Console\n\n# Common messages\nenabled=Enabled\nhidden=Hidden\nlink-only-column=Link only\nname=Name\ndisplayName=Display name\ndisplayNameHtml=HTML Display name\nsave=Save\ncancel=Cancel\nnext=Next\nonText=ON\noffText=OFF\nclient=Client\nclients=Clients\nclear=Clear\nselectOne=Select One...\n\ntrue=True\nfalse=False\n\nendpoints=Endpoints\n\n# Angular date filter format strings: https://docs.angularjs.org/api/ng/filter/date\ndateFormat=shortDate\ntimeFormat=mediumTime\n\n# Realm settings\nrealm-detail.enabled.tooltip=Users and clients can only access a realm if it's enabled\nrealm-detail.protocol-endpoints.tooltip=Shows the configuration of the protocol endpoints\nrealm-detail.protocol-endpoints.oidc=OpenID Endpoint Configuration\nrealm-detail.protocol-endpoints.saml=SAML 2.0 Identity Provider Metadata\nrealm-detail.userManagedAccess.tooltip=If enabled, users are allowed to manage their resources and permissions using the Account Management Console.\nuserProfileEnabled=User Profile Enabled\nuserProfileEnabled.tooltip=If enabled, allows managing user profiles. \nuserManagedAccess=User-Managed Access\nregistrationAllowed=User registration\nregistrationAllowed.tooltip=Enable/disable the registration page. A link for registration will show on login page too.\nregistrationEmailAsUsername=Email as username\nregistrationEmailAsUsername.tooltip=If enabled then username field is hidden from registration form and email is used as username for new user.\neditUsernameAllowed=Edit username\neditUsernameAllowed.tooltip=If enabled, the username field is editable, readonly otherwise.\nresetPasswordAllowed=Forgot password\nresetPasswordAllowed.tooltip=Show a link on login page for user to click on when they have forgotten their credentials.\nrememberMe=Remember Me\nrememberMe.tooltip=Show checkbox on login page to allow user to remain logged in between browser restarts until session expires.\nloginWithEmailAllowed=Login with email\nloginWithEmailAllowed.tooltip=Allow users to log in with their email address.\nduplicateEmailsAllowed=Duplicate emails\nduplicateEmailsAllowed.tooltip=Allow multiple users to have the same email address. Changing this setting will also clear the user's cache. It is recommended to manually update email constraints of existing users in the database after switching off support for duplicate email addresses.\nverifyEmail=Verify email\nverifyEmail.tooltip=Require users to verify their email address after initial login or after address changes are submitted.\nsslRequired=Require SSL\nsslRequired.option.all=all requests\nsslRequired.option.external=external requests\nsslRequired.option.none=none\nsslRequired.tooltip=Is HTTPS required? 'None' means HTTPS is not required for any client IP address. 'External requests' means localhost and private IP addresses can access without HTTPS. 'All requests' means HTTPS is required for all IP addresses.\npublicKeys=Public keys\npublicKey=Public key\nprivateKey=Private key\ngen-new-keys=Generate new keys\ncertificate=Certificate\nhost=Host\nsmtp-host=SMTP Host\nport=Port\nsmtp-port=SMTP Port (defaults to 25)\nsmtp-password.tooltip=SMTP password. This field is able to obtain its value from vault, use ${vault.ID} format.\nfrom=From\nfromDisplayName=From Display Name\nfromDisplayName.tooltip=A user-friendly name for the 'From' address (optional).\nreplyTo=Reply To\nreplyToDisplayName=Reply To Display Name\nreplyToDisplayName.tooltip=A user-friendly name for the 'Reply-To' address (optional).\nenvelopeFrom=Envelope From\nenvelopeFrom.tooltip=An email address used for bounces (optional).\nsender-email-addr=Sender Email Address\nsender-email-addr-display=Display Name for Sender Email Address\nreply-to-email-addr=Reply To Email Address\nreply-to-email-addr-display=Display Name for Reply To Email Address\nsender-envelope-email-addr=Sender Envelope Email Address\nenable-ssl=Enable SSL\nenable-start-tls=Enable StartTLS\nenable-auth=Enable Authentication\nusername=Username\nlogin-username=Login Username\npassword=Password\nlogin-password=Login Password\nlogin-theme=Login Theme\nlogin-theme.tooltip=Select theme for login, OTP, grant, registration, and forgot password pages.\naccount-theme=Account Theme\naccount-theme.tooltip=Select theme for user account management pages.\nadmin-console-theme=Admin Console Theme\nselect-theme-admin-console=Select theme for admin console.\nemail-theme=Email Theme\nselect-theme-email=Select theme for emails that are sent by the server.\ni18n-enabled=Internationalization Enabled\nsupported-locales=Supported Locales\nsupported-locales.placeholder=Type a locale and enter\ndefault-locale=Default Locale\nlocalization-upload-file=Upload localization JSON file\nmissing-locale=Missing locale.\nmissing-file=Missing file. Please select a file to upload.\nlocalization-file.upload.success=The localization data has been loaded from file.\nlocalization-file.upload.error=The file can not be uploaded. Please verify the file.\nlocalization-show=Show realm specific localizations\nno-localizations-configured=No realm specific localizations configured\nadd-localization-text=Add localization text\nlocalization-text.create.success=The localization text has been created.\nlocalization-text.update.success=The localization text has been updated.\nlocalization-text.remove.success=The localization text has been deleted.\nrealm-cache-clear=Realm Cache\nrealm-cache-clear.tooltip=Clears all entries from the realm cache (this will clear entries for all realms)\nuser-cache-clear=User Cache\nuser-cache-clear.tooltip=Clears all entries from the user cache (this will clear entries for all realms)\nkeys-cache-clear=Keys Cache\nkeys-cache-clear.tooltip=Clears all entries from the cache of external public keys. These are keys of external clients or identity providers. (this will clear entries for all realms)\ndefault-signature-algorithm=Default Signature Algorithm\ndefault-signature-algorithm.tooltip=Default algorithm used to sign tokens for the realm\nrevoke-refresh-token=Revoke Refresh Token\nrevoke-refresh-token.tooltip=If enabled a refresh token can only be used up to 'Refresh Token Max Reuse' and is revoked when a different token is used. Otherwise refresh tokens are not revoked when used and can be used multiple times.\nrefresh-token-max-reuse=Refresh Token Max Reuse\nrefresh-token-max-reuse.tooltip=Maximum number of times a refresh token can be reused. When a different token is used, revocation is immediate.\nsso-session-idle=SSO Session Idle\nseconds=Seconds\nminutes=Minutes\nhours=Hours\ndays=Days\nsso-session-max=SSO Session Max\nsso-session-idle.tooltip=Time a session is allowed to be idle before it expires. Tokens and browser sessions are invalidated when a session is expired.\nsso-session-max.tooltip=Max time before a session is expired. Tokens and browser sessions are invalidated when a session is expired.\nsso-session-idle-remember-me=SSO Session Idle Remember Me\nsso-session-idle-remember-me.tooltip=Time a remember me session is allowed to be idle before it expires. Tokens and browser sessions are invalidated when a session is expired. If not set it uses the standard SSO Session Idle value.\nsso-session-max-remember-me=SSO Session Max Remember Me\nsso-session-max-remember-me.tooltip=Max time before a session is expired when the user has set the remember me option. Tokens and browser sessions are invalidated when a session is expired. If not set, it uses the standard SSO Session Max value.\noffline-session-idle=Offline Session Idle\noffline-session-idle.tooltip=Time an offline session is allowed to be idle before it expires. You need to use offline token to refresh at least once within this period; otherwise offline session will expire.\nrealm-detail.hostname=Hostname\nrealm-detail.hostname.tooltip=Set the hostname for the realm. Use in combination with the fixed hostname provider to override the server hostname for a specific realm.\nrealm-detail.frontendUrl=Frontend URL\nrealm-detail.frontendUrl.tooltip=Set the frontend URL for the realm. Use in combination with the default hostname provider to override the base URL for frontend requests for a specific realm.\n\n## KEYCLOAK-7688 Offline Session Max for Offline Token\noffline-session-max-limited=Offline Session Max Limited\noffline-session-max-limited.tooltip=Enable Offline Session Max.\noffline-session-max=Offline Session Max\noffline-session-max.tooltip=Max time before an offline session is expired regardless of activity. \nclient-session-idle=Client Session Idle\nclient-session-idle.tooltip=Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.\nclient-session-max=Client Session Max\nclient-session-max.tooltip=Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.\nclient-offline-session-idle=Client Offline Session Idle\nclient-offline-session-idle.tooltip=Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.\nclient-offline-session-max=Client Offline Session Max\nclient-offline-session-max.tooltip=Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.\naccess-token-lifespan=Access Token Lifespan\naccess-token-lifespan.tooltip=Max time before an access token is expired. This value is recommended to be short relative to the SSO timeout.\naccess-token-lifespan-for-implicit-flow=Access Token Lifespan For Implicit Flow\naccess-token-lifespan-for-implicit-flow.tooltip=Max time before an access token issued during OpenID Connect Implicit Flow is expired. This value is recommended to be shorter than SSO timeout. There is no possibility to refresh token during implicit flow, that's why there is a separate timeout different to 'Access Token Lifespan'.\naction-token-generated-by-admin-lifespan=Default Admin-Initiated Action Lifespan\naction-token-generated-by-admin-lifespan.tooltip=Maximum time before an action permit sent to a user by administrator is expired. This value is recommended to be long to allow administrators send e-mails for users that are currently offline. The default timeout can be overridden immediately before issuing the token.\naction-token-generated-by-user-lifespan=User-Initiated Action Lifespan\naction-token-generated-by-user-lifespan.tooltip=Maximum time before an action permit sent by a user (such as a forgot password e-mail) is expired. This value is recommended to be short because it is expected that the user would react to self-created action quickly.\nsaml-assertion-lifespan=Assertion Lifespan\nsaml-assertion-lifespan.tooltip=Lifespan set in the SAML assertion conditions. After that time the assertion will be invalid. The \"SessionNotOnOrAfter\" attribute is not modified and continue using the \"SSO Session Max\" time defined at realm level.\n\naction-token-generated-by-user.execute-actions=Execute Actions\naction-token-generated-by-user.idp-verify-account-via-email=IdP Account E-mail Verification\naction-token-generated-by-user.reset-credentials=Forgot Password\naction-token-generated-by-user.verify-email=E-mail Verification\naction-token-generated-by-user.tooltip=Override default settings of maximum time before an action permit sent by a user (such as a forgot password e-mail) is expired for specific action. This value is recommended to be short because it is expected that the user would react to self-created action quickly.\naction-token-generated-by-user.reset=Reset\naction-token-generated-by-user.operation=Override User-Initiated Action Lifespan\n\nclient-login-timeout=Client login timeout\nclient-login-timeout.tooltip=Max time a client has to finish the access token protocol. This should normally be 1 minute.\nlogin-timeout=Login timeout\nlogin-timeout.tooltip=Max time a user has to complete a login. This is recommended to be relatively long, such as 30 minutes or more.\nlogin-action-timeout=Login action timeout\nlogin-action-timeout.tooltip=Max time a user has to complete login related actions like update password or configure totp. This is recommended to be relatively long, such as 5 minutes or more.\n\noauth2-device-code-lifespan=OAuth 2.0 Device Code Lifespan\noauth2-device-code-lifespan.tooltip=Max time before the device code and user code are expired. This value needs to be a long enough lifetime to be usable (allowing the user to retrieve their secondary device, navigate to the verification URI, login, etc.), but should be sufficiently short to limit the usability of a code obtained for phishing.\noauth2-device-polling-interval=OAuth 2.0 Device Polling Interval\noauth2-device-polling-interval.tooltip=The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n\nheaders=Headers\nbrute-force-detection=Brute Force Detection\nx-frame-options=X-Frame-Options\nx-frame-options-tooltip=Default value prevents pages from being included by non-origin iframes (click label for more information)\ncontent-sec-policy=Content-Security-Policy\ncontent-sec-policy-tooltip=Default value prevents pages from being included by non-origin iframes (click label for more information)\ncontent-sec-policy-report-only=Content-Security-Policy-Report-Only\ncontent-sec-policy-report-only-tooltip=For testing Content Security Policies\ncontent-type-options=X-Content-Type-Options\ncontent-type-options-tooltip=Default value prevents Internet Explorer and Google Chrome from MIME-sniffing a response away from the declared content-type (click label for more information)\nrobots-tag=X-Robots-Tag\nrobots-tag-tooltip=Prevent pages from appearing in search engines (click label for more information)\nx-xss-protection=X-XSS-Protection\nx-xss-protection-tooltip=This header configures the Cross-site scripting (XSS) filter in your browser. Using the default behavior, the browser will prevent rendering of the page when a XSS attack is detected (click label for more information)\nstrict-transport-security=HTTP Strict Transport Security (HSTS)\nstrict-transport-security-tooltip=The Strict-Transport-Security HTTP header tells browsers to always use HTTPS. Once a browser sees this header, it will only visit the site over HTTPS for the time specified (1 year) at max-age, including the subdomains.\npermanent-lockout=Permanent Lockout\npermanent-lockout.tooltip=Lock the user permanently when the user exceeds the maximum login failures.\nmax-login-failures=Max Login Failures\nmax-login-failures.tooltip=How many failures before wait is triggered.\nwait-increment=Wait Increment\nwait-increment.tooltip=When failure threshold has been met, how much time should the user be locked out?\nquick-login-check-millis=Quick Login Check Milli Seconds\nquick-login-check-millis.tooltip=If a failure happens concurrently too quickly, lock out the user.\nmin-quick-login-wait=Minimum Quick Login Wait\nmin-quick-login-wait.tooltip=How long to wait after a quick login failure.\nmax-wait=Max Wait\nmax-wait.tooltip=Max time a user will be locked out.\nfailure-reset-time=Failure Reset Time\nfailure-reset-time.tooltip=When will failure count be reset?\nrealm-tab-login=Login\nrealm-tab-keys=Keys\nrealm-tab-email=Email\nrealm-tab-themes=Themes\nrealm-tab-localization=Localization\nrealm-tab-cache=Cache\nrealm-tab-tokens=Tokens\nrealm-tab-client-registration=Client Registration\nrealm-tab-security-defenses=Security Defenses\nrealm-tab-user-profile=User Profile\nrealm-tab-general=General\nadd-realm=Add realm\n\n#Session settings\nrealm-sessions=Realm Sessions\nrevocation=Revocation\nlogout-all=Logout all\nactive-sessions=Active Sessions\noffline-sessions=Offline Sessions\nsessions=Sessions\nnot-before=Not Before\nnot-before.tooltip=Revoke any tokens issued before this date.\nset-to-now=Set to now\npush=Push\npush.tooltip=For every client that has an admin URL, notify them of the new revocation policy.\n\n#Protocol Mapper\nusermodel.prop.label=Property\nusermodel.prop.tooltip=Name of the property method in the UserModel interface. For example, a value of 'email' would reference the UserModel.getEmail() method.\nusermodel.attr.label=User Attribute\nusermodel.attr.tooltip=Name of stored user attribute which is the name of an attribute within the UserModel.attribute map.\nuserSession.modelNote.label=User Session Note\nuserSession.modelNote.tooltip=Name of stored user session note within the UserSessionModel.note map.\nmultivalued.label=Multivalued\nmultivalued.tooltip=Indicates if attribute supports multiple values. If true, the list of all values of this attribute will be set as claim. If false, just first value will be set as claim\naggregate.attrs.label=Aggregate attribute values\naggregate.attrs.tooltip=Indicates if attribute values should be aggregated with the group attributes. If using OpenID Connect mapper the multivalued option needs to be enabled too in order to get all the values. Duplicated values are discarded and the order of values is not guaranteed with this option.\nselectRole.label=Select Role\nselectRole.tooltip=Enter role in the textbox to the left, or click this button to browse and select the role you want.\nselectGroup.label=Select Group\nselectGroup.tooltip=Enter group in the textbox to the left, or click this button to browse and select the group you want.\ntokenClaimName.label=Token Claim Name\ntokenClaimName.tooltip=Name of the claim to insert into the token. This can be a fully qualified name like 'address.street'. In this case, a nested json object will be created. To prevent nesting and use dot literally, escape the dot with backslash (\\\\.).\njsonType.label=Claim JSON Type\njsonType.tooltip=JSON type that should be used to populate the json claim in the token. long, int, boolean, String and JSON are valid values.\nincludeInIdToken.label=Add to ID token\nincludeInIdToken.tooltip=Should the claim be added to the ID token?\nincludeInAccessToken.label=Add to access token\nincludeInAccessToken.tooltip=Should the claim be added to the access token?\nincludeInAccessTokenResponse.label=Add to access token response\nincludeInAccessTokenResponse.tooltip=Should the claim be added to the access token response? Should only be used for informative and non-sensitive data\nincludeInUserInfo.label=Add to userinfo\nincludeInUserInfo.tooltip=Should the claim be added to the userinfo?\nusermodel.clientRoleMapping.clientId.label=Client ID\nusermodel.clientRoleMapping.clientId.tooltip=Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\nusermodel.clientRoleMapping.rolePrefix.label=Client Role prefix\nusermodel.clientRoleMapping.rolePrefix.tooltip=A prefix for each client role (optional).\nusermodel.clientRoleMapping.tokenClaimName.tooltip=Name of the claim to insert into the token. This can be a fully qualified name like 'address.street'. In this case, a nested json object will be created. To prevent nesting and use dot literally, escape the dot with backslash (\\\\.). The special token ${client_id} can be used and this will be replaced by the actual client ID. Example usage is 'resource_access.${client_id}.roles'. This is useful especially when you are adding roles from all the clients (Hence 'Client ID' switch is unset) and you want client roles of each client stored separately.\nusermodel.realmRoleMapping.rolePrefix.label=Realm Role prefix\nusermodel.realmRoleMapping.rolePrefix.tooltip=A prefix for each Realm Role (optional).\nsectorIdentifierUri.label=Sector Identifier URI\nsectorIdentifierUri.tooltip=Providers that use pairwise sub values and support Dynamic Client Registration SHOULD use the sector_identifier_uri parameter. It provides a way for a group of websites under common administrative control to have consistent pairwise sub values independent of the individual domain names. It also provides a way for Clients to change redirect_uri domains without having to reregister all their users.\npairwiseSubAlgorithmSalt.label=Salt\npairwiseSubAlgorithmSalt.tooltip=Salt used when calculating the pairwise subject identifier. If left blank, a salt will be generated.\naddressClaim.street.label=User Attribute Name for Street\naddressClaim.street.tooltip=Name of User Attribute, which will be used to map to 'street_address' subclaim inside 'address' token claim. Defaults to 'street' .\naddressClaim.locality.label=User Attribute Name for Locality\naddressClaim.locality.tooltip=Name of User Attribute, which will be used to map to 'locality' subclaim inside 'address' token claim. Defaults to 'locality' .\naddressClaim.region.label=User Attribute Name for Region\naddressClaim.region.tooltip=Name of User Attribute, which will be used to map to 'region' subclaim inside 'address' token claim. Defaults to 'region' .\naddressClaim.postal_code.label=User Attribute Name for Postal Code\naddressClaim.postal_code.tooltip=Name of User Attribute, which will be used to map to 'postal_code' subclaim inside 'address' token claim. Defaults to 'postal_code' .\naddressClaim.country.label=User Attribute Name for Country\naddressClaim.country.tooltip=Name of User Attribute, which will be used to map to 'country' subclaim inside 'address' token claim. Defaults to 'country' .\naddressClaim.formatted.label=User Attribute Name for Formatted Address\naddressClaim.formatted.tooltip=Name of User Attribute, which will be used to map to 'formatted' subclaim inside 'address' token claim. Defaults to 'formatted' .\nincluded.client.audience.label=Included Client Audience\nincluded.client.audience.tooltip=The Client ID of the specified audience client will be included in audience (aud) field of the token. If there are existing audiences in the token, the specified value is just added to them. It won't override existing audiences.\nincluded.custom.audience.label=Included Custom Audience\nincluded.custom.audience.tooltip=This is used just if 'Included Client Audience' is not filled. The specified value will be included in audience (aud) field of the token. If there are existing audiences in the token, the specified value is just added to them. It won't override existing audiences.\n\n# client details\nclients.tooltip=Clients are trusted browser apps and web services in a realm. These clients can request a login. You can also define client specific roles.\nsearch.placeholder=Search...\nsearch.loading=Searching...\ncreate=Create\nimport=Import\nclient-id=Client ID\nbase-url=Base URL\nactions=Actions\nnot-defined=Not defined\nedit=Edit\ndelete=Delete\nno-results=No results\nno-clients-available=No clients available\nadd-client=Add Client\nselect-file=Select file\nview-details=View details\nclear-import=Clear import\nclient-id.tooltip=Specifies ID referenced in URI and tokens. For example 'my-client'. For SAML this is also the expected issuer value from authn requests\nclient.name.tooltip=Specifies display name of the client. For example 'My Client'. Supports keys for localized values as well. For example\\: ${my_client}\nclient.enabled.tooltip=Disabled clients cannot initiate a login or have obtain access tokens.\nalwaysDisplayInConsole=Always Display in Console\nalwaysDisplayInConsole.tooltip=Always list this client in the Account Console, even if the user does not have an active session.\nconsent-required=Consent Required\nconsent-required.tooltip=If enabled, users have to consent to client access.\nclient.display-on-consent-screen=Display Client On Consent Screen\nclient.display-on-consent-screen.tooltip=Applicable just if Consent Required is on. If this switch is off, consent screen will contain just the consents corresponding to configured client scopes. If on, there will be also one item on consent screen about this client itself\nclient.consent-screen-text=Client Consent Screen Text \nclient.consent-screen-text.tooltip=Applicable just if 'Display Client On Consent Screen' is on for this client. Contains the text, which will be on consent screen about permissions specific just for this client\nclient-protocol=Client Protocol\nclient-protocol.tooltip='OpenID connect' allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server.'SAML' enables web-based authentication and authorization scenarios including cross-domain single sign-on (SSO) and uses security tokens containing assertions to pass information.\naccess-type=Access Type\naccess-type.tooltip='Confidential' clients require a secret to initiate login protocol. 'Public' clients do not require a secret. 'Bearer-only' clients are web services that never initiate a login.\nstandard-flow-enabled=Standard Flow Enabled\nstandard-flow-enabled.tooltip=This enables standard OpenID Connect redirect based authentication with authorization code. In terms of OpenID Connect or OAuth2 specifications, this enables support of 'Authorization Code Flow' for this client.\nimplicit-flow-enabled=Implicit Flow Enabled\nimplicit-flow-enabled.tooltip=This enables support for OpenID Connect redirect based authentication without authorization code. In terms of OpenID Connect or OAuth2 specifications, this enables support of 'Implicit Flow' for this client.\ndirect-access-grants-enabled=Direct Access Grants Enabled\ndirect-access-grants-enabled.tooltip=This enables support for Direct Access Grants, which means that client has access to username/password of user and exchange it directly with Keycloak server for access token. In terms of OAuth2 specification, this enables support of 'Resource Owner Password Credentials Grant' for this client.\nservice-accounts-enabled=Service Accounts Enabled\nservice-accounts-enabled.tooltip=Allows you to authenticate this client to Keycloak and retrieve access token dedicated to this client. In terms of OAuth2 specification, this enables support of 'Client Credentials Grant' for this client.\noauth2-device-authorization-grant-enabled=OAuth 2.0 Device Authorization Grant Enabled\noauth2-device-authorization-grant-enabled.tooltip=This enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.\noidc-ciba-grant-enabled=OIDC CIBA Grant Enabled\noidc-ciba-grant-enabled.tooltip=This enables support for OIDC CIBA Grant, which means that the user is authenticated via some external authentication device instead of the user's browser.\ninclude-authnstatement=Include AuthnStatement\ninclude-authnstatement.tooltip=Should a statement specifying the method and timestamp be included in login responses?\ninclude-onetimeuse-condition=Include OneTimeUse Condition\ninclude-onetimeuse-condition.tooltip=Should a OneTimeUse Condition be included in login responses?\nartifact-binding = Force Artifact Binding\nartifact-binding.tooltip = Should response messages be returned to the client through the SAML ARTIFACT binding system?\nsign-documents=Sign Documents\nsign-documents.tooltip=Should SAML documents be signed by the realm?\nsign-documents-redirect-enable-key-info-ext=Optimize REDIRECT signing key lookup\nsign-documents-redirect-enable-key-info-ext.tooltip=When signing SAML documents in REDIRECT binding for SP that is secured by Keycloak adapter, should the ID of the signing key be included in SAML protocol message in <Extensions> element? This optimizes validation of the signature as the validating party uses a single key instead of trying every known key for validation.\nsign-assertions=Sign Assertions\nsign-assertions.tooltip=Should assertions inside SAML documents be signed? This setting is not needed if document is already being signed.\nsignature-algorithm=Signature Algorithm\nsignature-algorithm.tooltip=The signature algorithm to use to sign documents.\ncanonicalization-method=Canonicalization Method\ncanonicalization-method.tooltip=Canonicalization Method for XML signatures.\nencrypt-assertions=Encrypt Assertions\nencrypt-assertions.tooltip=Should SAML assertions be encrypted with client's public key using AES?\nclient-signature-required=Client Signature Required\nclient-signature-required.tooltip=Will the client sign their saml requests and responses? And should they be validated?\nforce-post-binding=Force POST Binding\nforce-post-binding.tooltip=Always use POST binding for responses.\nfront-channel-logout=Front Channel Logout\nfront-channel-logout.tooltip=When true, logout requires a browser redirect to client. When false, server performs a background invocation for logout.\nfront-channel-logout-url=Front-Channel Logout URL\nfront-channel-logout-url.tooltip=URL that will cause the client to log itself out when a logout request is sent to this realm (via end_session_endpoint). If not provided, it defaults to the base url.\nfront-channel-logout-session-required=Front-Channel Logout Session Required\nfront-channel-logout-session-required.tooltip=Specifying whether a sid (session ID) and iss (Issuer) claims are included in the Logout Token when the Front-Channel Logout URL is used.\n\nforce-name-id-format=Force Name ID Format\nforce-name-id-format.tooltip=Ignore requested NameID subject format and use admin console configured one.\nname-id-format=Name ID Format\nname-id-format.tooltip=The name ID format to use for the subject.\nmapper.nameid.format.tooltip=Name ID Format using Mapper\nroot-url=Root URL\nroot-url.tooltip=Root URL appended to relative URLs\nvalid-redirect-uris=Valid Redirect URIs\nvalid-redirect-uris.tooltip=Valid URI pattern a browser can redirect to after a successful login or logout. Simple wildcards are allowed such as 'http://example.com/*'. Relative path can be specified too such as /my/relative/path/*. Relative paths are relative to the client root URL, or if none is specified the auth server root URL is used. For SAML, you must set valid URI patterns if you are relying on the consumer service URL embedded with the login request.\nbase-url.tooltip=Default URL to use when the auth server needs to redirect or link back to the client.\nadmin-url=Admin URL\nadmin-url.tooltip=URL to the admin interface of the client. Set this if the client supports the adapter REST API. This REST API allows the auth server to push revocation policies and other administrative tasks. Usually this is set to the base URL of the client.\nmaster-saml-processing-url=Master SAML Processing URL\nmaster-saml-processing-url.tooltip=If configured, this URL will be used for every binding to both the SP's Assertion Consumer and Single Logout Services. This can be individually overridden for each binding and service in the Fine Grain SAML Endpoint Configuration.\nidp-sso-url-ref=IDP Initiated SSO URL Name\nidp-sso-url-ref.tooltip=URL fragment name to reference client when you want to do IDP Initiated SSO. Leaving this empty will disable IDP Initiated SSO. The URL you will reference from your browser will be: {server-root}/realms/{realm}/protocol/saml/clients/{client-url-name}\nidp-sso-url-ref.urlhint=Target IDP initiated SSO URL:\nidp-sso-relay-state=IDP Initiated SSO Relay State\nidp-sso-relay-state.tooltip=Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\nweb-origins=Web Origins\nweb-origins.tooltip=Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.\nbackchannel-logout-url=Backchannel Logout URL\nbackchannel-logout-url.tooltip=URL that will cause the client to log itself out when a logout request is sent to this realm (via end_session_endpoint). If omitted, no logout request will be sent to the client is this case.\nbackchannel-logout-session-required=Backchannel Logout Session Required\nbackchannel-logout-session-required.tooltip=Specifying whether a sid (session ID) Claim is included in the Logout Token when the Backchannel Logout URL is used.\nbackchannel-logout-revoke-offline-sessions=Backchannel Logout Revoke Offline Sessions\nbackchannel-logout-revoke-offline-sessions.tooltip=Specifying whether a \"revoke_offline_access\" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.\nfine-oidc-endpoint-conf=Fine Grain OpenID Connect Configuration\nfine-oidc-endpoint-conf.tooltip=Expand this section to configure advanced settings of this client related to OpenID Connect protocol\naccess-token-signed-response-alg=Access Token Signature Algorithm\naccess-token-signed-response-alg.tooltip=JWA algorithm used for signing access tokens.\nid-token-signed-response-alg=ID Token Signature Algorithm\nid-token-signed-response-alg.tooltip=JWA algorithm used for signing ID tokens.\nid-token-encrypted-response-alg=ID Token Encryption Key Management Algorithm\nid-token-encrypted-response-alg.tooltip=JWA Algorithm used for key management in encrypting ID tokens. This option is needed if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted.\nid-token-encrypted-response-enc=ID Token Encryption Content Encryption Algorithm\nid-token-encrypted-response-enc.tooltip=JWA Algorithm used for content encryption in encrypting ID tokens. This option is needed just if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted.\nuser-info-signed-response-alg=User Info Signed Response Algorithm\nuser-info-signed-response-alg.tooltip=JWA algorithm used for signed User Info Endpoint response. If set to 'unsigned', User Info Response won't be signed and will be returned in application/json format.\nrequest-object-signature-alg=Request Object Signature Algorithm\nrequest-object-signature-alg.tooltip=JWA algorithm, which client needs to use when sending OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', Request object can be signed by any algorithm (including 'none' ).\nrequest-object-required=Request Object Required\nrequest-object-required.tooltip=Specifies if the client needs to provide a request object with their authorization requests, and what method they can use for this. If set to \"not required\", providing a request object is optional. In all other cases, providing a request object is mandatory. If set to \"request\", the request object must be provided by value. If set to \"request_uri\", the request object must be provided by reference. If set to \"request or request_uri\", either method can be used.\nrequest-object-encryption-alg=Request Object Encryption Algorithm\nrequest-object-encryption-alg.tooltip=JWE algorithm, which client needs to use when sending OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', encryption is optional and any algorithm is allowed.\nrequest-object-encryption-enc=Request Object Content Encryption Algorithm\nrequest-object-encryption-enc.tooltip=JWE algorithm, which client needs to use when encrypting the content of the OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', any algorithm is allowed.\nciba-backchannel-token-delivery-mode=CIBA Backchannel Token Delivery Mode\nciba-backchannel-token-delivery-mode.tooltip= CIBA mode, which will be used by this client. If not set, defaults to realm attribute set at the CIBA Policy (defaults to 'poll')\nciba-backchannel-client-notification-endpoint=CIBA Backchannel Client Notification Endpoint\nciba-backchannel-client-notification-endpoint.tooltip=Client Notification Endpoint URL used by the CIBA Ping mode.\nciba-backchannel-auth-request-signing-alg=CIBA Backchannel Authentication Request Signature Algorithm\nciba-backchannel-auth-request-signing-alg.tooltip=JWA algorithm, which client needs to use when sending CIBA backchannel authentication request specified by 'request' or 'request_uri' parameters. Only asymmetric algorithms are allowed according CIBA specification. If set to 'any', any algorithm is allowed.\nrequest-uris=Valid Request URIs\nrequest-uris.tooltip=List of valid URIs, which can be used as values of 'request_uri' parameter during OpenID Connect authentication request. There is support for the same capabilities like for Valid Redirect URIs. For example wildcards or relative paths.\nfine-saml-endpoint-conf=Fine Grain SAML Endpoint Configuration\nfine-saml-endpoint-conf.tooltip=Expand this section to configure exact URLs for Assertion Consumer and Single Logout Service.\nassertion-consumer-post-binding-url=Assertion Consumer Service POST Binding URL\nassertion-consumer-post-binding-url.tooltip=SAML POST Binding URL for the client's assertion consumer service (login responses). You can leave this blank if you do not have a URL for this binding.\nassertion-consumer-redirect-binding-url=Assertion Consumer Service Redirect Binding URL\nassertion-consumer-redirect-binding-url.tooltip=SAML Redirect Binding URL for the client's assertion consumer service (login responses). You can leave this blank if you do not have a URL for this binding.\nlogout-service-post-binding-url=Logout Service POST Binding URL\nlogout-service-post-binding-url.tooltip=SAML POST Binding URL for the client's single logout service. You can leave this blank if you are using a different binding\nlogout-service-redir-binding-url=Logout Service Redirect Binding URL\nlogout-service-redir-binding-url.tooltip=SAML Redirect Binding URL for the client's single logout service. You can leave this blank if you are using a different binding.\nlogout-service-artifact-binding-url=Logout Service ARTIFACT Binding URL\nlogout-service-artifact-binding-url.tooltip=SAML ARTIFACT Binding URL for the client's single logout service. You can leave this blank if you are using a different binding.\nartifact-binding-url= Artifact Binding URL\nartifact-binding-url.tooltip=URL to send the HTTP ARTIFACT messages to. You can leave this blank if you are using a different binding. This value should be set when forcing ARTIFACT binding together with IdP initiated login.\nartifact-resolution-service-url= Artifact Resolution Service\nartifact-resolution-service-url.tooltip= SAML Artifact resolution service for the client. This is the endpoint to which Keycloak will send a SOAP ArtifactResolve message. You can leave this blank if you do not have a URL for this binding.\nsaml-signature-keyName-transformer=SAML Signature Key Name\nsaml-signature-keyName-transformer.tooltip=Signed SAML documents contain identification of signing key in KeyName element. For Keycloak / RH-SSO counterparty, use KEY_ID, for MS AD FS use CERT_SUBJECT, for others check and use NONE if no other option works.\noidc-compatibility-modes=OpenID Connect Compatibility Modes\noidc-compatibility-modes.tooltip=Expand this section to configure settings for backwards compatibility with older OpenID Connect / OAuth2 adapters. It is useful especially if your client uses older version of Keycloak / RH-SSO adapter.\nexclude-session-state-from-auth-response=Exclude Session State From Authentication Response\nexclude-session-state-from-auth-response.tooltip=If this is on, the parameter 'session_state' will not be included in OpenID Connect Authentication Response. It is useful if your client uses older OIDC / OAuth2 adapter, which does not support 'session_state' parameter.\nuse-refresh-tokens=Use Refresh Tokens\nuse-refresh-tokens.tooltip=If this is on, a refresh_token will be created and added to the token response. If this is off then no refresh_token will be generated.\nuse-refresh-token-for-client-credentials-grant=Use Refresh Tokens For Client Credentials Grant\nuse-refresh-token-for-client-credentials-grant.tooltip=If this is on, a refresh_token will be created and added to the token response if the client_credentials grant is used. The OAuth 2.0 RFC6749 Section 4.4.3 states that a refresh_token should not be generated when client_credentials grant is used. If this is off then no refresh_token will be generated and the associated user session will be removed.\nuse-lower-case-bearer-in-token-responses=Use lower-case bearer type in token responses\nuse-lower-case-bearer-in-token-responses.tooltip=If this is on, token responses will be set the with the type \"bearer\" in lower-case. By default, the server sets the type as \"Bearer\" as defined by RFC6750. \nauthorization-signed-response-alg=Authorization Response Signature Algorithm\nauthorization-signed-response-alg.tooltip=JWA algorithm used for signing authorization response tokens when the response mode is jwt.\nauthorization-encrypted-response-alg=Authorization Response Encryption Key Management Algorithm\nauthorization-encrypted-response-alg.tooltip=JWA Algorithm used for key management in encrypting the authorization response when the response mode is jwt. This option is needed if you want encrypted authorization response. If left empty, the authorization response is just signed, but not encrypted.\nauthorization-encrypted-response-enc=Authorization Response Encryption Content Encryption Algorithm\nauthorization-encrypted-response-enc.tooltip=JWA Algorithm used for content encryption in encrypting the authorization response when the response mode is jwt. This option is needed if you want encrypted authorization response. If left empty, the authorization response is just signed, but not encrypted.\nlogo-uri=Logo URL\nlogo-uri.tooltip=URL that references a logo for the Client application\npolicy-uri=Policy URL\npolicy-uri.tooltip=URL that the Relying Party Client provides to the End-User to read about the how the profile data will be used\ntos-uri=Terms of service URL\ntos-uri.tooltip=URL that the Relying Party Client provides to the End-User to read about the Relying Party's terms of service\n\n\n# client import\nimport-client=Import Client\nformat-option=Format Option\nselect-format=Select a Format\nimport-file=Import File\n\n# client tabs\nsettings=Settings\ncredentials=Credentials\nroles=Roles\nmappers=Mappers\nmappers.tooltip=Protocol mappers perform transformation on tokens and documents. They can do things like map user data into protocol claims, or just transform any requests going between the client and auth server.\nscope=Scope\nscope.tooltip=Scope mappings allow you to restrict which user role mappings are included within the access token requested by the client.\nsessions.tooltip=View active sessions for this client. Allows you to see which users are active and when they logged in.\noffline-access=Offline Access\noffline-access.tooltip=View offline sessions for this client. Allows you to see which users retrieve offline token and when they retrieve it. To revoke all tokens for the client, go to the Revocation tab and set Not Before to Now.\nclustering=Clustering\ninstallation=Installation\ninstallation.tooltip=Helper utility for generating various client adapter configuration formats which you can download or cut and paste to configure your clients.\nservice-account-roles=Service Account Roles\nservice-account-roles.tooltip=Allows you to authenticate role mappings for the service account dedicated to this client.\n\n# client credentials\nclient-authenticator=Client Authenticator\nclient-authenticator.tooltip=Client Authenticator used for authentication of this client against Keycloak server\ncertificate.tooltip=Client Certificate for validate JWT issued by client and signed by Client private key from your keystore.\npublicKey.tooltip=Public Key for validate JWT issued by client and signed by Client private key.\nno-client-certificate-configured=No client certificate configured\nneed-to-configure-keys=Configure JWKS URL or Signing key in the Keys tab\ngen-new-keys-and-cert=Generate new keys and certificate\nimport-certificate=Import Certificate\ngen-client-private-key=Generate Client Private Key\ngenerate-private-key=Generate Private Key\nkid=Kid\nkid.tooltip=KID (Key ID) of the client public key from imported JWKS.\ntoken-endpoint-auth-signing-alg=Signature Algorithm\ntoken-endpoint-auth-signing-alg.tooltip=JWA algorithm, which the client needs to use when signing a JWT for authentication. If left blank, the client is allowed to use any algorithm.\nuse-jwks-url=Use JWKS URL\nuse-jwks-url.tooltip=If the switch is on, client public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded again when client generates new keypair. If the switch is off, public key (or certificate) from the Keycloak DB is used, so when client keypair changes, you always need to import new key (or certificate) to the Keycloak DB as well. This switch is mutually exclusive with the switch \"Use JWKS\".\njwks-url=JWKS URL\njwks-url.tooltip=URL where client keys in JWK format are stored. See JWK specification for more details. If you use Keycloak client adapter with \"jwt\" credential, you can use URL of your app with '/k_jwks' suffix. For example 'http://www.myhost.com/myapp/k_jwks' .\nuse-jwks-string=Use JWKS\nuse-jwks-string.tooltip=If the switch is on, client public keys will be configurable in JWKS. This switch is mutually exclusive with the switch \"Use JWKS URL\".\njwks-string=JWKS\njwks-string.tooltip=Client keys in JWK format. See JWK specification for more details.\npkce-enabled=Use PKCE\npkce-enabled.tooltip=Use PKCE (Proof of Key-code exchange) for IdP Brokering\npkce-method=PKCE Method\npkce-method.tooltip=PKCE Method to use\npkce.plain.option=Plain\npkce.s256.option=S256\narchive-format=Archive Format\narchive-format.tooltip=Java keystore or PKCS12 archive format.\nkey-alias=Key Alias\nkey-alias.tooltip=Archive alias for your private key and certificate.\nkey-password=Key Password\nkey-password.tooltip=Password to access the private key in the archive\nstore-password=Store Password\nstore-password.tooltip=Password to access the archive itself\ngenerate-and-download=Generate and Download\nclient-certificate-import=Client Certificate Import\nimport-client-certificate=Import Client Certificate\njwt-import.key-alias.tooltip=Archive alias for your certificate.\nsecret=Secret\nregenerate-secret=Regenerate Secret\nsecret-rotation=Secret Rotation\nsecret-rotation-enabled.tooltip=This enables client secret rotation.\nrotate.secret=Rotate Secret\nsecret-rotated=Secret Rotated\ninvalidate-secret=Invalidate Secret\nsecret-expires-on=Secret expires on\nregistrationAccessToken=Registration access token\nregistrationAccessToken.regenerate=Regenerate registration access token\nregistrationAccessToken.tooltip=The registration access token provides access for clients to the client registration service.\nadd-role=Add Role\nrole-name=Role Name\ncomposite=Composite\ndescription=Description\nno-client-roles-available=No client roles available\ncomposite-roles=Composite Roles\ncomposite-roles.tooltip=When this role is (un)assigned to a user any role associated with it will be (un)assigned implicitly.\nrealm-roles=Realm Roles\navailable-roles=Available Roles\nadd-selected=Add selected\nassociated-roles=Associated Roles\ncomposite.associated-realm-roles.tooltip=Realm level roles associated with this composite role.\ncomposite.available-realm-roles.tooltip=Realm level roles that you can associate to this composite role.\nremove-selected=Remove selected\nclient-roles=Client Roles\nselect-client-to-view-roles=Select client to view roles for client\navailable-roles.tooltip=Roles from this client that you can associate to this composite role.\nclient.associated-roles.tooltip=Client roles associated with this composite role.\nadd-builtin=Add Builtin\ncategory=Category\ntype=Type\npriority-order=Priority Order\nno-mappers-available=No mappers available\nadd-builtin-protocol-mappers=Add Builtin Protocol Mappers\nadd-builtin-protocol-mapper=Add Builtin Protocol Mapper\nscope-mappings=Scope Mappings\nfull-scope-allowed=Full Scope Allowed\nfull-scope-allowed.tooltip=Allows you to disable all restrictions.\nscope.available-roles.tooltip=Realm level roles that can be assigned to scope. Contains effectively assigned roles which are not directly assigned.\nassigned-roles=Assigned Roles\nassigned-roles.tooltip=Realm level roles assigned to scope.\neffective-roles=Effective Roles\nrealm.effective-roles.tooltip=Assigned realm level roles that may have been inherited from a composite role.\nselect-client-roles.tooltip=Select client to view roles for client\nassign.available-roles.tooltip=Client roles available to be assigned. Contains effectively assigned roles which are not directly assigned.\nclient.assigned-roles.tooltip=Assigned client roles.\nclient.effective-roles.tooltip=Assigned client roles that may have been inherited from a composite role.\nbasic-configuration=Basic configuration\nnode-reregistration-timeout=Node Re-registration Timeout\nnode-reregistration-timeout.tooltip=Interval to specify max time for registered clients cluster nodes to re-register. If cluster node will not send re-registration request to Keycloak within this time, it will be unregistered from Keycloak\nregistered-cluster-nodes=Registered cluster nodes\nregister-node-manually=Register node manually\ntest-cluster-availability=Test cluster availability\nlast-registration=Last registration\nnode-host=Node host\nno-registered-cluster-nodes=No registered cluster nodes available\ncluster-nodes=Cluster Nodes\nadd-node=Add Node\nactive-sessions.tooltip=Total number of active user sessions for this client.\nshow-sessions=Show Sessions\nshow-sessions.tooltip=Warning, this is a potentially expensive operation depending on the number of active sessions.\nuser=User\nfrom-ip=From IP\nsession-start=Session Start\nfirst-page=First Page\nprevious-page=Previous Page\nnext-page=Next Page\nclient-revoke.not-before.tooltip=Revoke any tokens issued before this date for this client.\nclient-revoke.push.tooltip=If the admin URL is configured for this client, push this policy to that client.\nselect-a-format=Select a Format\ndownload=Download\noffline-tokens=Offline Tokens\noffline-tokens.tooltip=Total number of offline tokens for this client.\nshow-offline-tokens=Show Offline Tokens\nshow-offline-tokens.tooltip=Warning, this is a potentially expensive operation depending on the number of offline tokens.\ntoken-issued=Token Issued\nlast-access=Last Access\nlast-refresh=Last Refresh\nkey-export=Key Export\nkey-import=Key Import\nexport-saml-key=Export SAML Key\nimport-saml-key=Import SAML Key\nrealm-certificate-alias=Realm Certificate Alias\nrealm-certificate-alias.tooltip=Realm certificate is stored in archive too. This is the alias to it.\nsigning-key=Signing Key\nsaml-signing-key=SAML Signing Key.\nprivate-key=Private Key\ngenerate-new-keys=Generate new keys\nexport=Export\nencryption-key=Encryption Key\nsaml-encryption-key.tooltip=SAML Encryption Key.\nservice-accounts=Service Accounts\nservice-account.available-roles.tooltip=Realm level roles that can be assigned to service account. Contains effectively assigned roles which are not directly assigned.\nservice-account=Service Account\nservice-account.roles=Service Account Roles\nservice-account.user=Service Account User\nservice-account.user.tooltip=Username of the Service Account. To manage details and group mappings click on the username.\nservice-account.assigned-roles.tooltip=Realm level roles assigned to service account.\nservice-account-is-not-enabled-for=Service account is not enabled for {{client}}\ncreate-protocol-mappers=Create Protocol Mappers\ncreate-protocol-mapper=Create Protocol Mapper\nprotocol=Protocol\nprotocol.tooltip=Protocol...\nid=ID\nmapper.name.tooltip=Name of the mapper.\nmapper.consent-required.tooltip=When granting temporary access, must the user consent to providing this data to the client?\nconsent-text=Consent Text\nconsent-text.tooltip=Text to display on consent page.\nmapper-type=Mapper Type\nmapper-type.tooltip=Type of the mapper\nuser-label=User Label\ndata=Data\nshow-data=Show data...\nposition=Position\n# realm identity providers\nidentity-providers=Identity Providers\ntable-of-identity-providers=Table of identity providers\nadd-provider.placeholder=Add provider...\nprovider=Provider\ngui-order=GUI order\nfirst-broker-login-flow=First Login Flow\npost-broker-login-flow=Post Login Flow\nsync-mode=Sync Mode\nsync-mode.tooltip=Default sync mode for all mappers. The sync mode determines when user data will be synced using the mappers. Possible values are: 'legacy' to keep the behaviour before this option was introduced, 'import' to only import the user once during first login of the user with this identity provider, 'force' to always update the user during every login with this identity provider.\nsync-mode.inherit=inherit\nsync-mode.legacy=legacy\nsync-mode.import=import\nsync-mode.force=force\nsync-mode-override=Sync Mode Override\nsync-mode-override.tooltip=Overrides the default sync mode of the IDP for this mapper. Values are: 'legacy' to keep the behaviour before this option was introduced, 'import' to only import the user once during first login of the user with this identity provider, 'force' to always update the user during every login with this identity provider and 'inherit' to use the sync mode defined in the identity provider for this mapper.\nredirect-uri=Redirect URI\nredirect-uri.tooltip=The redirect uri to use when configuring the identity provider.\nalias=Alias\ndisplay-name=Display Name\nidentity-provider.alias.tooltip=The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\nidentity-provider.display-name.tooltip=Friendly name for Identity Providers.\nidentity-provider.enabled.tooltip=Enable/disable this identity provider.\nauthenticate-by-default=Authenticate by Default\nidentity-provider.authenticate-by-default.tooltip=Indicates if this provider should be tried by default for authentication even before displaying login screen.\nstore-tokens=Store Tokens\nidentity-provider.store-tokens.tooltip=Enable/disable if tokens must be stored after authenticating users.\nstored-tokens-readable=Stored Tokens Readable\nidentity-provider.stored-tokens-readable.tooltip=Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\ndisableUserInfo=Disable User Info\nidentity-provider.disableUserInfo.tooltip=Disable usage of User Info service to obtain additional user information?  Default is to use this OIDC service.\nuserIp=Use userIp Param\nidentity-provider.google-userIp.tooltip=Set 'userIp' query parameter when invoking on Google's User Info service.  This will use the user's ip address.  Useful if Google is throttling access to the User Info service.\nofflineAccess=Request refresh token\nidentity-provider.google-offlineAccess.tooltip=Set 'access_type' query parameter to 'offline' when redirecting to google authorization endpoint, to get a refresh token back. Useful if planning to use Token Exchange to retrieve Google token to access Google APIs when the user is not at the browser.\nhostedDomain=Hosted Domain\nidentity-provider.google-hostedDomain.tooltip=Set 'hd' query parameter when logging in with Google. Google will list accounts only for this domain. Keycloak validates that the returned identity token has a claim for this domain. When '*' is entered, any hosted account can be used.\nidentity-provider.facebook-fetchedFields.label=Additional user's profile fields\nidentity-provider.facebook-fetchedFields.tooltip=Provide additional fields which would be fetched using the profile request. This will be appended to the default set of 'id,name,email,first_name,last_name'.\nsandbox=Target Sandbox\nidentity-provider.paypal-sandbox.tooltip=Target PayPal's sandbox environment\nupdate-profile-on-first-login=Update Profile on First Login\non=On\non-missing-info=On missing info\noff=Off\nupdate-profile-on-first-login.tooltip=Define conditions under which a user has to update their profile during first-time login.\ntrust-email=Trust Email\ntrust-email.tooltip=If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\nlink-only=Account Linking Only\nlink-only.tooltip=If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider\nhide-on-login-page=Hide on Login Page\nhide-on-login-page.tooltip=If hidden, login with this provider is possible only if requested explicitly, for example using the 'kc_idp_hint' parameter.\ngui-order.tooltip=Number defining order of the provider in GUI (for example, on Login page).\nfirst-broker-login-flow.tooltip=Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that no Keycloak account is currently linked to the authenticated identity provider account.\npost-broker-login-flow.tooltip=Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you need no any additional authenticators to be triggered after login with this identity provider. Also note that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\nopenid-connect-config=OpenID Connect Config\nopenid-connect-config.tooltip=OIDC SP and external IDP configuration.\nauthorization-url=Authorization URL\nauthorization-url.tooltip=The Authorization Url.\ntoken-url=Token URL\ntoken-url.tooltip=The Token URL.\nloginHint=Pass login_hint\nloginHint.tooltip=Pass login_hint to identity provider.\nuiLocales=Pass current locale\nuiLocales.tooltip=Pass the current locale to the identity provider as a ui_locales parameter.\nlogout-url=Logout URL\nidentity-provider.logout-url.tooltip=End session endpoint to use to logout user from external IDP.\nbackchannel-logout=Backchannel Logout\nbackchannel-logout.tooltip=Does the external IDP support backchannel logout?\nuser-info-url=User Info URL\nuser-info-url.tooltip=The User Info Url. This is optional.\nclient-auth=Client Authentication\nclient-auth.tooltip=The client authentication method (cfr. https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication). In case of JWT signed with private key, the realm private key is used.\nclient-auth.client_secret_post=Client secret sent as post\nclient-auth.client_secret_basic=Client secret sent as basic auth\nclient-auth.client_secret_jwt=Client secret as jwt\nclient-auth.private_key_jwt=JWT signed with private key\nidentity-provider.client-id.tooltip=The client or client identifier registered within the identity provider.\nclient-secret=Client Secret\nclient-assertion-signing-algorithm=Client Assertion Signature Algorithm\nclient-assertion-signing-algorithm.tooltip=Signature algorithm to create JWT assertion as client authentication. In the case of JWT signed with private key or Client secret as jwt, it is required. If no algorithm is specified, the following algorithm is adapted. RS256 is adapted in the case of JWT signed with private key. HS256 is adapted in the case of Client secret as jwt.\nshow-secret=Show secret\nhide-secret=Hide secret\nclient-secret.tooltip=The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use ${vault.ID} format.\nissuer=Issuer\nissuer.tooltip=The issuer identifier for the issuer of the response. If not provided, no validation will be performed.\ndefault-scopes=Default Scopes\nidentity-provider.default-scopes.tooltip=The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.\nprompt=Prompt\nunspecified.option=unspecified\nnone.option=none\nconsent.option=consent\nlogin.option=login\nselect-account.option=select_account\nprompt.tooltip=Specifies whether the Authorization Server prompts the End-User for reauthentication and consent.\naccepts-prompt-none-forward-from-client=Accepts prompt=none forward from client\naccepts-prompt-none-forward-from-client.tooltip=This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In case that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly returned to client, but the request with prompt=none will be forwarded to this identity provider.\nvalidate-signatures=Validate Signatures\nidentity-provider.validate-signatures.tooltip=Enable/disable signature validation of external IDP signatures.\nidentity-provider.use-jwks-url.tooltip=If the switch is on, identity provider public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded again when identity provider generates new keypair. If the switch is off, public key (or certificate) from the Keycloak DB is used, so when the identity provider keypair changes, you always need to import the new key to the Keycloak DB as well.\nidentity-provider.jwks-url.tooltip=URL where identity provider keys in JWK format are stored. See JWK specification for more details. If you use external Keycloak identity provider, you can use URL like 'http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs' assuming your brokered Keycloak is running on 'http://broker-keycloak:8180' and its realm is 'test' .\nvalidating-public-key=Validating Public Key\nidentity-provider.validating-public-key.tooltip=The public key in PEM format that must be used to verify external IDP signatures.\nvalidating-public-key-id=Validating Public Key Id\nidentity-provider.validating-public-key-id.tooltip=Explicit ID of the validating public key given above if the key ID. Leave blank if the key above should be used always, regardless of key ID specified by external IDP; set it if the key should only be used for verifying if the key ID from external IDP matches.\nallowed-clock-skew=Allowed clock skew\nidentity-provider.allowed-clock-skew.tooltip=Clock skew in seconds that is tolerated when validating identity provider tokens. Default value is zero.\nforwarded-query-parameters=Forwarded Query Parameters\nidentity-provider.forwarded-query-parameters.tooltip=Non OpenID Connect/OAuth standard query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).\nimport-external-idp-config=Import External IDP Config\nimport-external-idp-config.tooltip=Allows you to load external IDP metadata from a config file or to download it from a URL.\nimport-from-url=Import from URL\nidentity-provider.import-from-url.tooltip=Import metadata from a remote IDP discovery descriptor.\nimport-from-file=Import from file\nidentity-provider.import-from-file.tooltip=Import metadata from a downloaded IDP discovery descriptor.\nidentity-provider.saml.entity-id=Service Provider Entity ID\nidentity-provider.saml.entity-id.tooltip=The Entity ID that will be used to uniquely identify this SAML Service Provider\nidentity-provider.saml.protocol-endpoints.saml=SAML 2.0 Service Provider Metadata\nidentity-provider.saml.protocol-endpoints.saml.tooltip=Shows the configuration of the Service Provider endpoint\nidentity-provider.saml.attribute-consuming-service-index=Attribute Consuming Service Index\nidentity-provider.saml.attribute-consuming-service-index.tooltip=Index of the Attribute Consuming Service profile to request during authentication\nidentity-provider.saml.attribute-consuming-service-name=Attribute Consuming Service Name\nidentity-provider.saml.attribute-consuming-service-name.tooltip=Name of the Attribute Consuming Service profile to advertise in the SP metadata. Default value equal to the realm display name when configured, otherwise equal to the realm name.\nsaml-config=SAML Config\nidentity-provider.saml-config.tooltip=SAML SP and external IDP configuration.\nsingle-signon-service-url=Single Sign-On Service URL\nsaml.single-signon-service-url.tooltip=The Url that must be used to send authentication requests (SAML AuthnRequest).\nsingle-logout-service-url=Single Logout Service URL\nsaml.single-logout-service-url.tooltip=The Url that must be used to send logout requests.\nnameid-policy-format=NameID Policy Format\nnameid-policy-format.tooltip=Specifies the URI reference corresponding to a name identifier format. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:persistent.\nsaml.principal-type=Principal Type\nsaml.principal-type.tooltip=Way to identify and track external users from the assertion. Default is using Subject NameID, alternatively you can set up identifying attribute.\nsaml.principal-attribute=Principal Attribute\nsaml.principal-attribute.tooltip=Name or Friendly Name of the attribute used to identify external users.\nsaml.allow-create=Allow create\nsaml.allow-create.tooltip=Allow the external identity provider to create a new identifier to represent the principal\nhttp-post-binding-response=HTTP-POST Binding Response\nhttp-post-binding-response.tooltip=Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nhttp-post-binding-for-authn-request=HTTP-POST Binding for AuthnRequest\nhttp-post-binding-for-authn-request.tooltip=Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nhttp-post-binding-logout=HTTP-POST Binding Logout\nhttp-post-binding-logout.tooltip=Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nwant-authn-requests-signed=Want AuthnRequests Signed\nwant-authn-requests-signed.tooltip=Indicates whether the identity provider expects a signed AuthnRequest.\nwant-assertions-signed=Want Assertions Signed\nwant-assertions-signed.tooltip=Indicates whether this service provider expects a signed Assertion.\nwant-assertions-encrypted=Want Assertions Encrypted\nwant-assertions-encrypted.tooltip=Indicates whether this service provider expects an encrypted Assertion.\nforce-authentication=Force Authentication\nidentity-provider.force-authentication.tooltip=Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\nvalidate-signature=Validate Signature\nsaml.validate-signature.tooltip=Enable/disable signature validation of SAML responses.\nvalidating-x509-certificate=Validating X509 Certificates\nvalidating-x509-certificate.tooltip=The certificate in PEM format that must be used to check for signatures. Multiple certificates can be entered, separated by comma (,).\nsaml.loginHint=Pass subject\nsaml.loginHint.tooltip=During login phase, forward an optional login_hint query parameter to SAML AuthnRequest's Subject.\nsaml.import-from-url.tooltip=Import metadata from a remote IDP SAML entity descriptor.\nidentity-provider.saml.sign-sp-metadata=Sign Service Provider Metadata\nidentity-provider.saml.sign-sp-metadata.tooltip=Enable/disable signature of the provider SAML metadata\nidentity-provider.saml.requested-authncontext=Requested AuthnContext Constraints\nidentity-provider.saml.requested-authncontext.tooltip=Allows the SP to specify the authentication context requirements of authentication statements returned.\nidentity-provider.saml.authncontext-comparison-type=Comparison\nidentity-provider.saml.authncontext-comparison-type.tooltip=Specifies the comparison method used to evaluate the requested context classes or statements. The default is \"Exact\".\nidentity-provider.saml.authncontext-comparison-type.exact=Exact\nidentity-provider.saml.authncontext-comparison-type.minimum=Minimum\nidentity-provider.saml.authncontext-comparison-type.maximum=Maximum\nidentity-provider.saml.authncontext-comparison-type.better=Better\nidentity-provider.saml.authncontext-class-ref=AuthnContext ClassRefs\nidentity-provider.saml.authncontext-class-ref.tooltip=Ordered list of requested AuthnContext ClassRefs.\nidentity-provider.saml.authncontext-decl-ref=AuthnContext DeclRefs\nidentity-provider.saml.authncontext-decl-ref.tooltip=Ordered list of requested AuthnContext DeclRefs.\nsocial.client-id.tooltip=The client identifier registered with the identity provider.\nsocial.client-secret.tooltip=The client secret registered with the identity provider. This field is able to obtain its value from vault, use ${vault.ID} format.\nsocial.default-scopes.tooltip=The scopes to be sent when asking for authorization. See the documentation for possible values, separator and default value'.\nkey=Key\nstackoverflow.key.tooltip=The Key obtained from Stack Overflow client registration.\nopenshift.base-url=Base Url\nopenshift.base-url.tooltip=Base Url to OpenShift Online API\nopenshift4.base-url=Base Url\nopenshift4.base-url.tooltip=Base Url to OpenShift Online API\ngitlab-application-id=Application Id\ngitlab-application-secret=Application Secret\ngitlab.application-id.tooltip=Application Id for the application you created in your GitLab Applications account menu\ngitlab.application-secret.tooltip=Secret for the application that you created in your GitLab Applications account menu\ngitlab.default-scopes.tooltip=Scopes to ask for on login.  Will always ask for openid.  Additionally adds read_user if you do not specify anything.\nbitbucket-consumer-key=Consumer Key\nbitbucket-consumer-secret=Consumer Secret\nbitbucket.key.tooltip=Bitbucket OAuth Consumer Key\nbitbucket.secret.tooltip=Bitbucket OAuth Consumer Secret\nbitbucket.default-scopes.tooltip=Scopes to ask for on login.  If you do not specify anything, scope defaults to 'email'.\n# User federation\nsync-ldap-roles-to-keycloak=Sync LDAP Roles To Keycloak\nsync-keycloak-roles-to-ldap=Sync Keycloak Roles To LDAP\nsync-ldap-groups-to-keycloak=Sync LDAP Groups To Keycloak\nsync-keycloak-groups-to-ldap=Sync Keycloak Groups To LDAP\nrealms=Realms\nrealm=Realm\nidentity-provider-mappers=Identity Provider Mappers\ncreate-identity-provider-mapper=Create Identity Provider Mapper\nadd-identity-provider-mapper=Add Identity Provider Mapper\nclient.description.tooltip=Specifies description of the client. For example 'My Client for TimeSheets'. Supports keys for localized values as well. For example\\: ${my_client_description}\nexpires=Expires\nexpiration=Expiration\nexpiration.tooltip=Specifies how long the token should be valid\ncount=Count\ncount.tooltip=Specifies how many clients can be created using the token\nremainingCount=Remaining Count\ncreated=Created\nback=Back\ninitial-access-tokens=Initial Access Tokens\nadd-initial-access-tokens=Add Initial Access Token\ninitial-access-token=Initial Access Token\ninitial-access.copyPaste.tooltip=Copy/paste the initial access token before navigating away from this page as it is not possible to retrieve later\ncontinue=Continue\ninitial-access-token.confirm.title=Copy Initial Access Token\ninitial-access-token.confirm.text=Please copy and paste the initial access token before confirming as it cannot be retrieved later\nno-initial-access-available=No Initial Access Tokens available\nclient-reg-policies=Client Registration Policies\nclient-reg-policy.name.tooltip=Display Name of the policy\nanonymous-policies=Anonymous Access Policies\nanonymous-policies.tooltip=Those Policies are used when the Client Registration Service is invoked by unauthenticated request. This means that the request does not contain Initial Access Token nor Bearer Token.\nauth-policies=Authenticated Access Policies\nauth-policies.tooltip=Those Policies are used when Client Registration Service is invoked by authenticated request. This means that the request contains Initial Access Token or Bearer Token.\npolicy-name=Policy Name\nno-client-reg-policies-configured=No Client Registration Policies\ntrusted-hosts.label=Trusted Hosts\ntrusted-hosts.tooltip=List of Hosts, which are trusted and are allowed to invoke Client Registration Service and/or be used as values of Client URIs. You can use hostnames or IP addresses. If you use star at the beginning (for example '*.example.com' ) then whole domain example.com will be trusted.\nhost-sending-registration-request-must-match.label=Host Sending Client Registration Request Must Match\nhost-sending-registration-request-must-match.tooltip=If on, any request to Client Registration Service is allowed just if it was sent from some trusted host or domain.\nclient-uris-must-match.label=Client URIs Must Match\nclient-uris-must-match.tooltip=If on, all Client URIs (Redirect URIs and others) are allowed just if they match some trusted host or domain.\nconsent-required-for-all-mappers.label=Consent Required For Mappers\nconsent-required-for-all-mappers.tooltip=If on, all newly registered protocol mappers will automatically have consentRequired switch on. This means that user will need to approve consent screen. NOTE: Consent screen is shown just if client has consentRequired switch on. So it is usually good to use this switch together with consent-required policy.\nallowed-client-scopes.label=Allowed Client Scopes\nallowed-client-scopes.tooltip=Whitelist of the client scopes, which can be used on a newly registered client. Attempt to register client with some client scope, which is not whitelisted, will be rejected. By default, the whitelist is either empty or contains just realm default client scopes (based on 'Allow Default Scopes' configuration property)\nallow-default-scopes.label=Allow Default Scopes\nallow-default-scopes.tooltip=If on, newly registered clients will be allowed to have client scopes mentioned in realm default client scopes or realm optional client scopes\n\n# Client Registration Policies providers\nallowed-protocol-mappers.label=Allowed Protocol Mappers\nallowed-protocol-mappers.tooltip=Whitelist of allowed protocol mapper providers. If there is an attempt to register client, which contains some protocol mappers, which were not whitelisted, registration request will be rejected.\n\nallowed-client-templates.label=Allowed Client Templates\nclient-disabled.label=Client Disabled\nscope.label=Scope\nconsent-required.label=Consent Required\n\nmax-clients.label=Max Clients Per Realm\nmax-clients.tooltip=It will not be allowed to register a new client if count of existing clients in realm is same or bigger than the configured limit.\n\nclient-scopes=Client Scopes\nclient-scopes.tooltip=Client scopes allow you to define a common set of protocol mappers and roles, which are shared between multiple clients\n\n# Client Policies\nrealm-tab-client-policies=Client Policies\nclient-policies-profiles=Profiles\nclient-policies-profiles.tooltip=Client Profile allows to setup set of executors, which are enforced for various actions done with the client. Actions can be admin actions like creating or updating client, or user actions like authentication to the client.\nclient-policies-policies=Policies\nclient-policies-policies.tooltip=Client Policy allows to bind client profiles with various conditions to specify when exactly is enforced behaviour specified by executors of the particular client profile.\nclient-profiles-form-view=Form View\nclient-profiles-json-editor=JSON Editor\nglobal=Global\nexecutors=Executors\nclient-profile-name.tooltip=Name of the client profile. Must be unique within the realm\nclient-profile-executors.tooltip=Executors, which will be applied for this client profile\nno-executors-available=No Executors Available\npush-profile-to-json=Push Profile to JSON\nexecutor-type=Executor Type\ncreate-executor=Create Executor\nclient-policy-name.tooltip=Name of the client policy. Must be unique within the realm.\nclient-policy-enabled.tooltip=Specifies if client policy is enabled. Disabled policies are not considered at all during evaluation of client requests.\nconditions=Conditions\nclient-policy-conditions.tooltip=Conditions, which will be evaluated to determine if client policy should be applied during particular action or not.\nno-conditions-available=No Conditions Available\ncondition-type=Condition Type\ncreate-condition=Create Condition\nclient-profiles=Client Profiles\nclient-policies=Client Policies\nclient-profiles.tooltip=Client Profiles applied on this policy\nadd-profile.placeholder=Add client profile ...\nno-client-profiles-configured=No client profiles configured\ncreate-client-profile=Create Client Profile\ncreate-client-policy=Create Client Policy\n\nclient-scopes-condition.label=Expected Scopes\nclient-scopes-condition.tooltip=The list of expected client scopes. Condition evaluates to true if specified client request matches some of the client scopes. It depends also whether it should be default or optional client scope based on the 'Scope Type' configured.\nclient-accesstype.label=Client Access Type\nclient-accesstype.tooltip=Access Type of the client, for which the condition will be applied.\nclient-roles.label=Client Roles\nclient-roles-condition.tooltip=Client roles, which will be checked during this condition evaluation. Condition evaluates to true if client has at least one client role with the name as the client roles specified in the configuration.\nclient-updater-source-groups.label=Groups\nclient-updater-source-groups.tooltip=Name of groups to check. Condition evaluates to true if the entity, who creates/updates client is member of some of the specified groups. Configured groups are specified by their simple name, which must match to the name of the Keycloak group. No support for group hierarchy is used here.\nclient-updater-trusted-hosts.label=Trusted hosts\nclient-updater-trusted-hosts.tooltip=List of Hosts, which are trusted. In case that client registration/update request comes from the host/domain specified in this configuration, condition evaluates to true. You can use hostnames or IP addresses. If you use star at the beginning (for example '*.example.com' ) then whole domain example.com will be trusted.\nclient-updater-source-roles.label=Updating entity role\nclient-updater-source-roles.tooltip=The condition is checked during client registration/update requests and it evaluates to true if the entity (usually user), who is creating/updating client is member of the specified role. For reference the realm role, you can use the realm role name like 'my_realm_role' . For reference client role, you can use the client_id.role_name for example 'my_client.my_client_role' will refer to client role 'my_client_role' of client 'my_client'.\n\ngroups=Groups\n\ngroup.add-selected.tooltip=Realm roles that can be assigned to the group. Contains effectively assigned roles which are not directly assigned.\ngroup.assigned-roles.tooltip=Realm roles mapped to the group\ngroup.effective-roles.tooltip=All realm role mappings. Some roles here might be inherited from a mapped composite role.\ngroup.available-roles.tooltip=Assignable roles from this client. Contains effectively assigned roles which are not directly assigned.\ngroup.assigned-roles-client.tooltip=Role mappings for this client.\ngroup.effective-roles-client.tooltip=Role mappings for this client. Some roles here might be inherited from a mapped composite role.\n\ngroup.move.success=Group moved.\ngroup.remove.confirm.title=Delete Group\ngroup.remove.confirm.message=Are you sure you want to permanently delete the group {{name}}?\ngroup.remove.success=The group has been deleted.\ngroup.fetch.fail=Unable to fetch {{params}}\ngroup.create.success=Group Created.\ngroup.edit.success=Your changes have been saved to the group.\ngroup.roles.add.success=Role mappings updated.\ngroup.roles.remove.success=Role mappings updated.\ngroup.default.add.error=Please select a group to add\ngroup.default.add.success=Added default group\ngroup.default.remove.success=Removed default group\n\ndefault-roles=Default Roles\nno-realm-roles-available=No realm roles available\n\nusers=Users\nuser.add-selected.tooltip=Realm roles that can be assigned to the user. Contains effectively assigned roles which are not directly assigned.\nuser.assigned-roles.tooltip=Realm roles mapped to the user\nuser.effective-roles.tooltip=All realm role mappings. Some roles here might be inherited from a mapped composite role.\nuser.available-roles.tooltip=Assignable roles from this client. Contains effectively assigned roles which are not directly assigned.\nuser.assigned-roles-client.tooltip=Role mappings for this client.\nuser.effective-roles-client.tooltip=Role mappings for this client. Some roles here might be inherited from a mapped composite role.\n\nuser.roles.add.success=Role mappings updated.\nuser.roles.remove.success=Role mappings updated.\nuser.logout.all.success=Logged out user in all clients\nuser.logout.session.success=Logged out session\nuser.fedid.link.remove.confirm.title=Delete Identity Provider Link\nuser.fedid.link.remove.confirm.message=Are you sure you want to permanently delete the Identity Provider Link {{name}}?\nuser.fedid.link.remove.success=The provider link has been deleted.\nuser.fedid.link.add.success=Provider link has been created.\nuser.consent.revoke.success=Grant revoked successfully\nuser.consent.revoke.error=Grant couldn't be revoked\nuser.remove.confirm.title=Delete User\nuser.remove.confirm.message=Are you sure you want to permanently delete the user {{name}}?\nuser.unlock.success=Any temporarily locked users are now unlocked.\nuser.remove.success=The user has been deleted.\nuser.remove.error=User couldn't be deleted\nuser.create.success=The user has been created.\nuser.edit.success=Your changes have been saved to the user.\nuser.credential.update.success=Credentials saved!\nuser.credential.update.error=Error while updating the credential. See console for more information.\nuser.credential.remove.confirm.title=Delete credentials\nuser.credential.remove.confirm.message=Are you sure you want to delete these users credentials?\nuser.credential.remove.success=Credentials deleted!\nuser.credential.remove.error=Error while deleting the credential. See console for more information.\nuser.credential.move-top.error=Error while moving the credential to top. See console for more information.\nuser.credential.move-up.error=Error while moving the credential up. See console for more information.\nuser.credential.move-down.error=Error while moving the credential down. See console for more information.\nuser.credential.fetch.error=Error while loading user credentials. See console for more information.\nuser.credential.storage.fetch.error=Error while loading user storage credentials. See console for more information.\nuser.password.error.not-matching=Password and confirmation does not match.\nuser.password.reset.confirm.title=Reset password\nuser.password.reset.confirm.message=Are you sure you want to reset the password for the user?\nuser.password.reset.success=The password has been reset.\nuser.password.set.confirm.title=Set password\nuser.password.set.confirm.message=Are you sure you want to set a password for the user?\nuser.password.set.success=The password has been set.\nuser.credential.disable.confirm.title=Disable credentials\nuser.credential.disable.confirm.message=Are you sure you want to disable these users credentials?\nuser.credential.disable.confirm.success=Credentials disabled\nuser.credential.disable.confirm.error=Failed to disable credentials\nuser.actions-email.send.pending-changes.title=Cannot send email\nuser.actions-email.send.pending-changes.message=You must save your current changes before you can send an email\nuser.actions-email.send.confirm.title=Send Email\nuser.actions-email.send.confirm.message=Are you sure you want to send email to user?\nuser.actions-email.send.confirm.success=Email sent to user\nuser.actions-email.send.confirm.error=Failed to send email to user\nuser.storage.remove.confirm.title=Delete User storage provider\nuser.storage.remove.confirm.message=Are you sure you want to permanently delete the user storage provider {{name}}?\nuser.storage.remove.success=The provider has been deleted.\nuser.storage.create.success=The provider has been created.\nuser.storage.edit.success=The provider has been updated.\nuser.storage.sync.success=Sync of users finished successfully. {{status}}\nuser.storage.sync.error=Error during sync of users\nuser.storage.remove-users.success=Remove imported users finished successfully.\nuser.storage.remove-users.error=Error during remove\nuser.storage.unlink.success=Unlink of users finished successfully.\nuser.storage.unlink.error=Error during unlink\nuser.groups.fetch.all.error=Unable to fetch all group memberships {{params}}\nuser.groups.fetch.error=Unable to fetch {{params}}\nuser.groups.join.error.no-group-selected=Please select a group to add\nuser.groups.join.error.already-added=Group already added\nuser.groups.join.success=Added group membership\nuser.groups.leave.error.no-group-selected=Please select a group to remove\nuser.groups.leave.success=Removed group membership\n\ndefault.available-roles.tooltip=Realm level roles that can be assigned.\nrealm-default-roles=Realm Default Roles\nrealm-default-roles.tooltip=Realm level roles assigned to new users.\ndefault.available-roles-client.tooltip=Roles from this client that are assignable as a default.\nclient-default-roles=Client Default Roles\nclient-default-roles.tooltip=Roles from this client assigned as a default role.\ncomposite.available-roles.tooltip=Realm level roles that you can associate to this composite role.\ncomposite.associated-roles.tooltip=Realm level roles associated with this composite role.\ncomposite.available-roles-client.tooltip=Roles from this client that you can associate to this composite role.\ncomposite.associated-roles-client.tooltip=Client roles associated with this composite role.\npartial-import=Partial Import\npartial-import.tooltip=Partial import allows you to import users, clients, and other resources from a previously exported json file.\n\nfile=File\nexported-json-file=Exported json file\nimport-from-realm=Import from realm\nimport-users=Import users\nimport-groups=Import groups\nimport-clients=Import clients\nimport-identity-providers=Import identity providers\nimport-realm-roles=Import realm roles\nimport-client-roles=Import client roles\nif-resource-exists=If a resource exists\nfail=Fail\nskip=Skip\noverwrite=Overwrite\nif-resource-exists.tooltip=Specify what should be done if you try to import a resource that already exists.\n\npartial-export=Partial Export\npartial-export.tooltip=Partial export allows you to export realm configuration, and other associated resources into a json file.\nexport-groups-and-roles=Export groups and roles\nexport-clients=Export clients\n\naction=Action\nrole-selector=Role Selector\ngroup-selector=Group Selector\nrealm-roles.tooltip=Realm roles that can be selected.\n\nselect-a-role=Select a role\nselect-realm-role=Select realm role\nselect-group=Select group\nclient-roles.tooltip=Client roles that can be selected.\nselect-client-role=Select client role\n\nclient-saml-endpoint=Client SAML Endpoint\nadd-client-scope=Add client scope\n\ndefault-client-scopes=Default Client Scopes\ndefault-client-scopes.tooltip=Client Scopes, which will be added automatically to each created client\ndefault-client-scopes.default=Default Client Scopes\ndefault-client-scopes.default.tooltip=Allow to define client scopes, which will be added as default scopes to each created client\ndefault-client-scopes.default.available=Available Client Scopes\ndefault-client-scopes.default.available.tooltip=Client scopes, which are not yet assigned as realm default scopes or realm optional scopes\ndefault-client-scopes.default.assigned=Assigned Default Client Scopes\ndefault-client-scopes.default.assigned.tooltip=Client scopes, which will be added as default scopes to each created client\ndefault-client-scopes.optional=Optional Client Scopes\ndefault-client-scopes.optional.tooltip=Allow to define client scopes, which will be added as optional scopes to each created client\ndefault-client-scopes.optional.available=Available Client Scopes\ndefault-client-scopes.optional.available.tooltip=Client scopes, which are not yet assigned as realm default scopes or realm optional scopes\ndefault-client-scopes.optional.assigned=Assigned Optional Client Scopes\ndefault-client-scopes.optional.assigned.tooltip=Client scopes, which will be added as optional scopes to each created client\n\nclient-scopes.setup=Setup\nclient-scopes.setup.tooltip=Allow to setup client scopes linked to this client\nclient-scopes.default=Default Client Scopes\nclient-scopes.default.tooltip=Default client scopes are always applied when issuing tokens for this client. Protocol mappers and role scope mappings are always applied regardless of value of used scope parameter in OIDC Authorization request \nclient-scopes.default.available=Available Client Scopes\nclient-scopes.default.available.tooltip=Client scopes, which are not yet assigned as default scopes or optional scopes\nclient-scopes.default.assigned=Assigned Default Client Scopes\nclient-scopes.default.assigned.tooltip=Client scopes, which will be used as default scopes when generating tokens for this client\nclient-scopes.optional=Optional Client Scopes\nclient-scopes.optional.tooltip=Optional client scopes are applied when issuing tokens for this client, however just in case when they are requested by scope parameter in OIDC Authorization request \nclient-scopes.optional.available=Available Client Scopes\nclient-scopes.optional.available.tooltip=Client scopes, which are not yet assigned as default scopes or optional scopes\nclient-scopes.optional.assigned=Assigned Optional Client Scopes\nclient-scopes.optional.assigned.tooltip=Client scopes, which may be used as optional scopes when generating tokens for this client\n\nclient-scopes.evaluate=Evaluate\nclient-scopes.evaluate.tooltip=Allow to see all protocol mappers and role scope mapping that will be used in the tokens issued to this client. Also allow to generate example access token based on provided scope parameter\nscope-parameter=Scope Parameter\nscope-parameter.tooltip=You can copy/paste this value of scope parameter and use it in initial OpenID Connect Authentication Request sent from this client adapter. Default client scopes and selected optional client scopes will be used when generating token issued for this client\nclient-scopes.evaluate.scopes=Client Scopes\nclient-scopes.evaluate.scopes.tooltip=Allow to select optional client scopes, which may be used when generating token issued for this client\nclient-scopes.evaluate.scopes.available=Available Optional Client Scopes\nclient-scopes.evaluate.scopes.available.tooltip=This contains Optional Client Scopes, which can be optionally used when issuing access token for this client\nclient-scopes.evaluate.scopes.assigned=Selected Optional Client Scopes\nclient-scopes.evaluate.scopes.assigned.tooltip=Selected Optional Client Scopes, which will be used when issuing access token for this client. You can see above what value of OAuth Scope Parameter needs to be used when you want to have these optional client scopes applied when the initial OpenID Connect Authentication request will be sent from your client adapter  \nclient-scopes.evaluate.scopes.effective=Effective Client Scopes\nclient-scopes.evaluate.scopes.effective.tooltip=Contains all default client scopes and selected optional scopes. All protocol mappers and role scope mappings of all those client scopes will be used when generating access token issued for your client\nclient-scopes.evaluate.user.tooltip=Optionally select user, for whom the example access token will be generated. If you do not select a user, example access token will not be generated during evaluation\nsend-evaluation-request=Evaluate\nsend-evaluation-request.tooltip=Click this to see all protocol mappers and role scope mappings that will be used when issuing an access token for this client. It will also optionally generate example access token in case that some user was selected\n\nevaluated-protocol-mappers=Effective Protocol Mappers\nevaluated-protocol-mappers.tooltip=Shows all effective protocol mappers that will be used when issuing token for this client. Also contains protocol mappers of selected optional client scopes. For each protocol mapper, you can see from which client scope it is inherited from\nevaluated-roles=Effective Role Scope Mappings\nevaluated-roles.tooltip=Shows all effective roles scope mappings that will be used when issuing token for this client. Also contains role scope mappings of selected optional client scopes\nparent-client-scope=Parent Client Scope\nclient-scopes.evaluate.not-granted-roles=Not Granted Roles\nclient-scopes.evaluate.not-granted-roles.tooltip=Client does not have scope mappings for these roles. Those roles will not be in the access token issued to this client even if the authenticated user is a member of them\nclient-scopes.evaluate.granted-realm-effective-roles=Granted Effective Realm Roles\nclient-scopes.evaluate.granted-realm-effective-roles.tooltip=Client has scope mappings for these roles. Those roles will be in the access token issued to this client if the authenticated user is a member of them\nclient-scopes.evaluate.granted-client-effective-roles=Granted Effective Client Roles\ngenerated-access-token=Generated Access Token\ngenerated-access-token.tooltip=See the example access token, which will be generated and sent to the client when selected user is authenticated. You can see claims and roles that the token will contain based on the effective protocol mappers and role scope mappings and also based on the claims/roles assigned to user himself \ngenerated-id-token=Generated ID Token\ngenerated-id-token.tooltip=See the example ID Token, which will be generated and sent to the client when selected user is authenticated. You can see claims and roles that the token will contain based on the effective protocol mappers and role scope mappings and also based on the claims/roles assigned to user himself\ngenerated-user-info=Generated User Info\ngenerated-user-info.tooltip=See the example User Info, which will be provided by the User Info Endpoint\n\nmanage=Manage\nauthentication=Authentication\nuser-federation=User Federation\nuser-storage=User Storage\nevents=Events\nrealm-settings=Realm Settings\nconfigure=Configure\nselect-realm=Select realm\nadd=Add\n\nclient-storage=Client Storage\nno-client-storage-providers-configured=No client storage providers configured\nclient-stores.tooltip=Keycloak can retrieve clients and their details from external stores.\n\nclient-scope.name.tooltip=Name of the client scope. Must be unique in the realm. Name should not contain space characters as it is used as value of scope parameter\nclient-scope.description.tooltip=Description of the client scope\nclient-scope.protocol.tooltip=Which SSO protocol configuration is being supplied by this client scope\nclient-scope.display-on-consent-screen=Display On Consent Screen\nclient-scope.display-on-consent-screen.tooltip=If on, and this client scope is added to some client with consent required, the text specified by 'Consent Screen Text' will be displayed on consent screen. If off, this client scope will not be displayed on the consent screen\nclient-scope.consent-screen-text=Consent Screen Text\nclient-scope.consent-screen-text.tooltip=Text that will be shown on the consent screen when this client scope is added to some client with consent required. Defaults to name of client scope if it is not filled\nclient-scope.gui-order=GUI order\nclient-scope.gui-order.tooltip=Specify order of the provider in GUI (such as in Consent page) as integer\nclient-scope.include-in-token-scope=Include In Token Scope\nclient-scope.include-in-token-scope.tooltip=If on, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response. If off, this client scope will be omitted from the token and from the Token Introspection Endpoint response.\nclient-scope.is-dynamic-scope=Dynamic Scope\nclient-scope.is-dynamic-scope.tooltip=If on, this scope will be considered a Dynamic Scope, which will be comprised of a static and a variable portion.\nclient-scope.dynamic-scope-regexp=Dynamic Scope Format\nclient-scope.dynamic-scope-regexp.tooltip=This is the regular expression that the system will use to extract the scope name and variable.\n\nadd-user-federation-provider=Add user federation provider\nadd-user-storage-provider=Add user storage provider\nrequired-settings=Required Settings\nprovider-id=Provider ID\nconsole-display-name=Console Display Name\nconsole-display-name.tooltip=Display name of provider when linked in admin console.\npriority=Priority\npriority.tooltip=Priority of provider when doing a user lookup. Lowest first.\nuser-storage.enabled.tooltip=If provider is disabled, it will not be considered for queries and imported users will be disabled and read-only until the provider is enabled again.\nsync-settings=Sync Settings\nperiodic-full-sync=Periodic Full Sync\nperiodic-full-sync.tooltip=Does periodic full synchronization of provider users to Keycloak should be enabled or not\nfull-sync-period=Full Sync Period\nfull-sync-period.tooltip=Period for full synchronization in seconds\nperiodic-changed-users-sync=Periodic Changed Users Sync\nperiodic-changed-users-sync.tooltip=Does periodic synchronization of changed or newly created provider users to Keycloak should be enabled or not\nchanged-users-sync-period=Changed Users Sync Period\nchanged-users-sync-period.tooltip=Period for synchronization of changed or newly created provider users in seconds\nsynchronize-changed-users=Synchronize changed users\nsynchronize-all-users=Synchronize all users\nremove-imported-users=Remove imported\nunlink-users=Unlink users\nkerberos-realm=Kerberos Realm\nkerberos-realm.tooltip=Name of kerberos realm. For example FOO.ORG\nserver-principal=Server Principal\nserver-principal.tooltip=Full name of server principal for HTTP service including server and domain name. For example 'HTTP/host.foo.org@FOO.ORG'. Use '*' to accept any service principal in the KeyTab file.\nkeytab=KeyTab\nkeytab.tooltip=Location of Kerberos KeyTab file containing the credentials of server principal. For example /etc/krb5.keytab\ndebug=Debug\ndebug.tooltip=Enable/disable debug logging to standard output for Krb5LoginModule.\nallow-password-authentication=Allow Password Authentication\nallow-password-authentication.tooltip=Enable/disable possibility of username/password authentication against Kerberos database\nedit-mode=Edit Mode\nedit-mode.tooltip=READ_ONLY means that password updates are not allowed and user always authenticates with Kerberos password. UNSYNCED means that the user can change the password in the Keycloak database and this one will be used instead of the Kerberos password\nldap.edit-mode.tooltip=READ_ONLY is a read-only LDAP store. WRITABLE means data will be synced back to LDAP on demand. UNSYNCED means user data will be imported, but not synced back to LDAP.\nupdate-profile-first-login=Update Profile First Login\nupdate-profile-first-login.tooltip=Update profile on first login\nsync-registrations=Sync Registrations\nldap.sync-registrations.tooltip=Should newly created users be created within LDAP store? Priority effects which provider is chosen to sync the new user. This setting is effectively appplied only with WRITABLE edit mode.\nimport-enabled=Import Users\nldap.import-enabled.tooltip=If true, LDAP users will be imported into Keycloak DB and synced by the configured sync policies.\nvendor=Vendor\nldap.vendor.tooltip=LDAP vendor (provider)\nenable-usePasswordModifyExtendedOp=Enable the LDAPv3 Password Modify Extended Operation\nldap.usePasswordModifyExtendedOp.tooltip=Use the LDAPv3 Password Modify Extended Operation (RFC-3062). The password modify extended operation usually requires that LDAP user already has password in the LDAP server. So when this is used with 'Sync Registrations', it can be good to add also 'Hardcoded LDAP attribute mapper' with randomly generated initial password. \nusername-ldap-attribute=Username LDAP attribute\nldap-attribute-name-for-username=LDAP attribute name for username\nusername-ldap-attribute.tooltip=Name of LDAP attribute, which is mapped as Keycloak username. For many LDAP server vendors it can be 'uid'. For Active directory it can be 'sAMAccountName' or 'cn'. The attribute should be filled for all LDAP user records you want to import from LDAP to Keycloak.\nrdn-ldap-attribute=RDN LDAP attribute\nldap-attribute-name-for-user-rdn=LDAP attribute name for user RDN\nrdn-ldap-attribute.tooltip=Name of LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as Username LDAP attribute, however it is not required. For example for Active directory, it is common to use 'cn' as RDN attribute when username attribute might be 'sAMAccountName'.\nuuid-ldap-attribute=UUID LDAP attribute\nldap-attribute-name-for-uuid=LDAP attribute name for UUID\nuuid-ldap-attribute.tooltip=Name of LDAP attribute, which is used as unique object identifier (UUID) for objects in LDAP. For many LDAP server vendors, it is 'entryUUID'; however some are different. For example for Active directory it should be 'objectGUID'. If your LDAP server does not support the notion of UUID, you can use any other attribute that is supposed to be unique among LDAP users in tree. For example 'uid' or 'entryDN'.\nuser-object-classes=User Object Classes\nldap-user-object-classes.placeholder=LDAP User Object Classes (div. by comma)\nldap-connection-url=LDAP connection URL\nldap-users-dn=LDAP Users DN\nldap-bind-dn=LDAP Bind DN\nldap-bind-credentials=LDAP Bind Credentials\nldap-filter=LDAP Filter\nldap.user-object-classes.tooltip=All values of LDAP objectClass attribute for users in LDAP divided by comma. For example: 'inetOrgPerson, organizationalPerson' . Newly created Keycloak users will be written to LDAP with all those object classes and existing LDAP user records are found just if they contain all those object classes.\nconnection-url=Connection URL\nldap.connection-url.tooltip=Connection URL to your LDAP server\ntest-connection=Test connection\nusers-dn=Users DN\nldap.users-dn.tooltip=Full DN of LDAP tree where your users are. This DN is the parent of LDAP users. It could be for example 'ou=users,dc=example,dc=com' assuming that your typical user will have DN like 'uid=john,ou=users,dc=example,dc=com'\nauthentication-type=Bind Type\nldap.authentication-type.tooltip=Type of the Authentication method used during LDAP Bind operation. It is used in most of the requests sent to the LDAP server. Currently only 'none' (anonymous LDAP authentication) or 'simple' (Bind credential + Bind password authentication) mechanisms are available\nbind-dn=Bind DN\nldap.bind-dn.tooltip=DN of LDAP admin, which will be used by Keycloak to access LDAP server\nbind-credential=Bind Credential\nldap.bind-credential.tooltip=Password of LDAP admin. This field is able to obtain its value from vault, use ${vault.ID} format.\ntest-authentication=Test authentication\ncustom-user-ldap-filter=Custom User LDAP Filter\nldap.custom-user-ldap-filter.tooltip=Additional LDAP Filter for filtering searched users. Leave this empty if you don't need additional filter. Make sure that it starts with '(' and ends with ')'\nsearch-scope=Search Scope\nldap.search-scope.tooltip=For one level, the search applies only for users in the DNs specified by User DNs. For subtree, the search applies to the whole subtree. See LDAP documentation for more details\nuse-truststore-spi=Use Truststore SPI\nldap.use-truststore-spi.tooltip=Specifies whether LDAP connection will use the truststore SPI with the truststore configured in standalone.xml/domain.xml. 'Always' means that it will always use it. 'Never' means that it will not use it. 'Only for ldaps' means that it will use if your connection URL use ldaps. Note even if standalone.xml/domain.xml is not configured, the default Java cacerts or certificate specified by 'javax.net.ssl.trustStore' property will be used.\nvalidate-password-policy=Validate Password Policy\nconnection-pooling=Connection Pooling\nconnection-pooling-settings=Connection Pooling Settings\nconnection-pooling-authentication=Connection Pooling Authentication\nconnection-pooling-authentication-default=none simple\nconnection-pooling-debug=Connection Pool Debug Level\nconnection-pooling-debug-default=off\nconnection-pooling-initsize=Connection Pool Initial Size\nconnection-pooling-initsize-default=1\nconnection-pooling-maxsize=Connection Pool Maximum Size\nconnection-pooling-maxsize-default=1000\nconnection-pooling-prefsize=Connection Pool Preferred Size\nconnection-pooling-prefsize-default=5\nconnection-pooling-protocol=Connection Pool Protocol\nconnection-pooling-protocol-default=plain ssl\nconnection-pooling-timeout=Connection Pool Timeout\nconnection-pooling-timeout-default=300000\nldap-connection-timeout=Connection Timeout\nldap.connection-timeout.tooltip=LDAP Connection Timeout in milliseconds\nldap-read-timeout=Read Timeout\nldap.read-timeout.tooltip=LDAP Read Timeout in milliseconds. This timeout applies for LDAP read operations\nldap.validate-password-policy.tooltip=Determines if Keycloak should validate the password with the realm password policy before updating the LDAP mapped user. When this is false, Keycloak password policy would not be applied, which means that password will be updated on LDAP server unless LDAP server itself has some password policy rules. This setting is possible only with WRITABLE edit mode.\nldap.connection-pooling.tooltip=Determines if Keycloak should use connection pooling for accessing LDAP server\nldap.connection-pooling.authentication.tooltip=A list of space-separated authentication types of connections that may be pooled. Valid types are \"none\", \"simple\", and \"DIGEST-MD5\".\nldap.connection-pooling.debug.tooltip=A string that indicates the level of debug output to produce. Valid values are \"fine\" (trace connection creation and removal) and \"all\" (all debugging information).\nldap.connection-pooling.initsize.tooltip=The string representation of an integer that represents the number of connections per connection identity to create when initially creating a connection for the identity.\nldap.connection-pooling.maxsize.tooltip=The string representation of an integer that represents the maximum number of connections per connection identity that can be maintained concurrently.\nldap.connection-pooling.prefsize.tooltip=The string representation of an integer that represents the preferred number of connections per connection identity that should be maintained concurrently.\nldap.connection-pooling.protocol.tooltip=A list of space-separated protocol types of connections that may be pooled. Valid types are \"plain\" and \"ssl\".\nldap.connection-pooling.timeout.tooltip=The string representation of an integer that represents the number of milliseconds that an idle connection may remain in the pool without being closed and removed from the pool.\nldap.pagination.tooltip=Does the LDAP server support pagination.\nldap.startTls.tooltip=Encrypts the connection to LDAP using STARTTLS, which will disable connection pooling.\nkerberos-integration=Kerberos Integration\nallow-kerberos-authentication=Allow Kerberos authentication\nldap.allow-kerberos-authentication.tooltip=Enable/disable HTTP authentication of users with SPNEGO/Kerberos tokens. The data about authenticated users will be provisioned from this LDAP server\nuse-kerberos-for-password-authentication=Use Kerberos For Password Authentication\nldap.use-kerberos-for-password-authentication.tooltip=Use Kerberos login module for authenticate username/password against Kerberos server instead of authenticating against LDAP server with Directory Service API\nbatch-size=Batch Size\nldap.batch-size.tooltip=Count of LDAP users to be imported from LDAP to Keycloak within a single transaction.\nldap.periodic-full-sync.tooltip=Does periodic full synchronization of LDAP users to Keycloak should be enabled or not\nldap.periodic-changed-users-sync.tooltip=Does periodic synchronization of changed or newly created LDAP users to Keycloak should be enabled or not\nldap.changed-users-sync-period.tooltip=Period for synchronization of changed or newly created LDAP users in seconds\nuser-federation-mappers=User Federation Mappers\ncreate-user-federation-mapper=Create user federation mapper\nadd-user-federation-mapper=Add user federation mapper\nprovider-name=Provider Name\nno-user-federation-providers-configured=No user federation providers configured\nno-user-storage-providers-configured=No user storage providers configured\nadd-identity-provider=Add identity provider\nadd-identity-provider-link=Add identity provider link\nidentity-provider=Identity Provider\nidentity-provider-user-id=Identity Provider User ID\nidentity-provider-user-id.tooltip=Unique ID of the user on the Identity Provider side\nidentity-provider-username=Identity Provider Username\nidentity-provider-username.tooltip=Username on the Identity Provider side\npagination=Pagination\nbrowser-flow=Browser Flow\nbrowser-flow.tooltip=Select the flow you want to use for browser authentication.\nregistration-flow=Registration Flow\nregistration-flow.tooltip=Select the flow you want to use for registration.\ndirect-grant-flow=Direct Grant Flow\ndirect-grant-flow.tooltip=Select the flow you want to use for direct grant authentication.\nreset-credentials=Reset Credentials\nreset-credentials.tooltip=Select the flow you want to use when the user has forgotten their credentials.\nclient-authentication=Client Authentication\nclient-authentication.tooltip=Select the flow you want to use for authentication of clients.\ndocker-auth=Docker Authentication\ndocker-auth.tooltip=Select the flow you want to use for authentication against a docker client.\nnew=New\ncopy=Copy\nadd-execution=Add execution\nadd-flow=Add flow\nauth-type=Auth Type\nrequirement=Requirement\nconfig=Config\nno-executions-available=No executions available\nauthentication-flows=Authentication Flows\ncreate-authenticator-config=Create authenticator config\nauthenticator.alias.tooltip=Name of the configuration\notp-type=OTP Type\ntime-based=Time Based\ncounter-based=Counter Based\notp-type.tooltip=totp is Time-Based One Time Password. 'hotp' is a counter base one time password in which the server keeps a counter to hash against.\notp-hash-algorithm=OTP Hash Algorithm\notp-hash-algorithm.tooltip=What hashing algorithm should be used to generate the OTP.\nnumber-of-digits=Number of Digits\notp.number-of-digits.tooltip=How many digits should the OTP have?\nlook-ahead-window=Look Ahead Window\notp.look-ahead-window.tooltip=How far ahead should the server look just in case the token generator and server are out of counter sync?\nlook-around-window=Look Around Window\notp.look-around-window.tooltip=How far should the server look around just in case the token generator and server are out of time sync?\ninitial-counter=Initial Counter\notp.initial-counter.tooltip=What should the initial counter value be?\notp-token-period=OTP Token Period\notp-token-period.tooltip=How many seconds should an OTP token be valid? Defaults to 30 seconds.\notp-supported-applications=Supported Applications\notp-supported-applications.tooltip=Applications that are known to work with the current OTP policy\nloa-level=Level of Authentication\nloa-level.tooltip=Sets the Level of Authentication to the specified value.\nloa-max-age=Max Age\nloa-max-age.tooltip=Maximum age in seconds for which this level is considered valid after successful authentication. For example if this is set to 300 and user authenticated with this level and then tries to authenticate again in less than 300 second, then this level will be automatically considered as authenticated without need of user to re-authenticate. If it is set to 0, then the authenticated level is valid just for this authentication and next authentication will always need to re-authenticate. Default value is 10 hours, which is same as default SSO session timeout and it means that level is valid until end of SSO session and user doesn't need to re-authenticate.\nloa-condition-level=Level of Authentication (LoA)\nloa-condition-level.tooltip=The number value, usually 1 or bigger, which specifies level of authentication. Condition evaluates to true if user does not yet have this authentication level and this level is requested. This level of authentication will be set to the session after the subflow, where this condition is configured, is successfully finished.\ntable-of-password-policies=Table of Password Policies\nadd-policy.placeholder=Add policy...\npolicy-type=Policy Type\npolicy-value=Policy Value\nwebauthn-policy=WebAuthn Policy\nwebauthn-policy.tooltip=Policy for WebAuthn authentication. This one will be used by 'WebAuthn Register' required action and 'WebAuthn Authenticator' authenticator. Typical usage is, when WebAuthn will be used for the two-factor authentication.\nwebauthn-policy-passwordless=WebAuthn Passwordless Policy\nwebauthn-policy-passwordless.tooltip=Policy for passwordless WebAuthn authentication. This one will be used by 'Webauthn Register Passwordless' required action and 'WebAuthn Passwordless Authenticator' authenticator. Typical usage is, when WebAuthn will be used as first-factor authentication. Having both 'WebAuthn Policy' and 'WebAuthn Passwordless Policy' allows to use WebAuthn as both first factor and second factor authenticator in the same realm.\nwebauthn-rp-entity-name=Relying Party Entity Name\nwebauthn-rp-entity-name.tooltip=Human-readable server name as WebAuthn Relying Party\nwebauthn-signature-algorithms=Signature Algorithms\nwebauthn-signature-algorithms.tooltip=What signature algorithms should be used for Authentication Assertion.\nwebauthn-rp-id=Relying Party ID\nwebauthn-rp-id.tooltip=This is ID as WebAuthn Relying Party. It must be origin's effective domain.\nwebauthn-attestation-conveyance-preference=Attestation Conveyance Preference\nwebauthn-attestation-conveyance-preference.tooltip=Communicates to an authenticator the preference of how to generate an attestation statement.\nwebauthn-authenticator-attachment=Authenticator Attachment\nwebauthn-authenticator-attachment.tooltip=Communicates to an authenticator an acceptable attachment pattern.\nwebauthn-require-resident-key=Require Resident Key\nwebauthn-require-resident-key.tooltip=It tells an authenticator create a public key credential as Resident Key or not.\nwebauthn-user-verification-requirement=User Verification Requirement\nwebauthn-user-verification-requirement.tooltip=Communicates to an authenticator to confirm actually verifying a user.\nwebauthn-create-timeout=Timeout\nwebauthn-create-timeout.tooltip=Timeout value for creating user's public key credential in seconds. if set to 0, this timeout option is not adapted.\nwebauthn-avoid-same-authenticator-register=Avoid Same Authenticator Registration\nwebauthn-avoid-same-authenticator-register.tooltip=avoid registering the authenticator that has already been registered.\nwebauthn-acceptable-aaguids=Acceptable AAGUIDs\nwebauthn-acceptable-aaguids.tooltip=The list of AAGUID of which an authenticator can be registered.\nmanage-webauthn-authenticator=Manage WebAuthn Authenticator\npublic-key-credential-id=Public Key Credential ID\npublic-key-credential-aaguid=Public Key Credential AAGUID\npublic-key-credential-label=Public Key Credential Label\nciba-policy=CIBA Policy\nciba-backchannel-tokendelivery-mode=Backchannel Token Delivery Mode\nciba-backchannel-tokendelivery-mode.tooltip=Specifies how the CD(Consumption Device) gets the authentication result and related tokens. This mode will be used by default for the CIBA clients, which do not have other mode explicitly set. The default mode is 'poll'.\nciba-expires-in=Expires In\nciba-expires-in.tooltip=The expiration time of the \"auth_req_id\" in seconds since the authentication request was received.\nciba-interval=Interval\nciba-interval.tooltip=The minimum amount of time in seconds that the CD(Consumption Device) must wait between polling requests to the token endpoint.\nciba-auth-requested-user-hint=Authentication Requested User Hint\nciba-auth-requested-user-hint.tooltip=The way of identifying the end-user for whom authentication is being requested.\nadmin-events=Admin Events\nadmin-events.tooltip=Displays saved admin events for the realm. Events are related to admin account, for example a realm creation. To enable persisted events go to config.\nlogin-events=Login Events\nfilter=Filter\nupdate=Update\nreset=Reset\noperation-types=Operation Types\nresource-types=Resource Types\nselect-operations.placeholder=Select operations...\nselect-resource-types.placeholder=Select resource types...\nresource-path=Resource Path\nresource-path.tooltip=Filter by resource path. Supports wildcard '*' (for example 'users/*').\ndate-(from)=Date (From)\ndate-(to)=Date (To)\nauthentication-details=Authentication Details\nip-address=IP Address\ntime=Time\noperation-type=Operation Type\nresource-type=Resource Type\nauth=Auth\nrepresentation=Representation\nregister=Register\nrequired-action=Required Action\ndefault-action=Default Action\nauth.default-action.tooltip=If enabled, any new user will have this required action assigned to it.\nno-required-actions-configured=No required actions configured\ndefaults-to-id=Defaults to id\nflows=Flows\nbindings=Bindings\nclient-flow-bindings=Authentication Flow Overrides\nclient-flow-bindings.tooltip=Override realm authentication flow bindings.\nrequired-actions=Required Actions\npassword-policy=Password Policy\notp-policy=OTP Policy\nuser-groups=User Groups\ndefault-groups=Default Groups\ngroups.default-groups.tooltip=Set of groups that new users will automatically join.\ncut=Cut\npaste=Paste\ncreate-group=Create group\ncreate-authenticator-execution=Create Authenticator Execution\nedit-flow=Edit Flow\ncreate-form-action-execution=Create Form Action Execution\ncreate-top-level-form=Create Top Level Form\nflow.alias.tooltip=Specifies display name for the flow.\ntop-level-flow-type=Top Level Flow Type\nflow.generic=generic\nflow.client=client\ntop-level-flow-type.tooltip=What kind of top level flow is it? Type 'client' is used for authentication of clients (applications) when generic is for users and everything else\ncreate-execution-flow=Create Execution Flow\nflow-type=Flow Type\nflow.form.type=form\nflow.generic.type=generic\nflow-type.tooltip=What kind of form is it\nform-provider=Form Provider\ndefault-groups.tooltip=Newly created or registered users will automatically be added to these groups\nselect-a-type.placeholder=select a type\navailable-groups=Available Groups\navailable-groups.tooltip=Select a group you want to add as a default.\nvalue=Value\ntable-of-group-members=Table of group members\ntable-of-role-members=Table of role members\nlast-name=Last Name\nfirst-name=First Name\nemail=Email\ntoggle-navigation=Toggle navigation\nmanage-account=Manage account\nsign-out=Sign Out\nserver-info=Server Info\nresource-not-found=Resource <strong>not found</strong>...\nresource-not-found.instruction=We could not find the resource you are looking for. Please make sure the URL you entered is correct.\ngo-to-the-home-page=Go to the home page &raquo;\npage-not-found=Page <strong>not found</strong>...\npage-not-found.instruction=We could not find the page you are looking for. Please make sure the URL you entered is correct.\nevents.tooltip=Displays saved events for the realm. Events are related to user accounts, for example a user login. To enable persisted events go to config.\nselect-event-types.placeholder=Select event types...\nevents-config.tooltip=Displays configuration options to enable persistence of user and admin events.\nselect-an-action.placeholder=Select an action...\nevent-listeners.tooltip=Configure what listeners receive events for the realm.\nlogin.save-events.tooltip=If enabled, login events are saved to the database, which makes events available to the admin and account management consoles.\nclear-events.tooltip=Deletes all events in the database.\nevents.expiration.tooltip=Sets the expiration for events. Expired events are periodically deleted from the database.\nadmin-events-settings=Admin Events Settings\nsave-events=Save Events\nadmin.save-events.tooltip=If enabled, admin events are saved to the database, which makes events available to the admin console.\nsaved-types.tooltip=Configure what event types are saved.\ninclude-representation=Include Representation\ninclude-representation.tooltip=Include JSON representation for create and update requests.\nclear-admin-events.tooltip=Deletes all admin events in the database.\nserver-version=Server Version\nserver-profile=Server Profile\nserver-disabled=Disabled Features\nserver-disabled.tooltip=Features that are not currently enabled. Some features are not enabled by default. This applies to all preview and experimental features.\nserver-preview=Preview Features\nserver-preview.tooltip=Preview features are not supported in production use and may be significantly changed or removed in the future.\nserver-experimental=Experimental Features\nserver-experimental.tooltip=Experimental features, which may not be fully functional. Never use experimental features in production.\ninfo=Info\nproviders=Providers\nserver-time=Server Time\nserver-uptime=Server Uptime\nprofile=Profile\nmemory=Memory\ntotal-memory=Total Memory\nfree-memory=Free Memory\nused-memory=Used Memory\nsystem=System\ncurrent-working-directory=Current Working Directory\njava-version=Java Version\njava-vendor=Java Vendor\njava-runtime=Java Runtime\njava-vm=Java VM\njava-vm-version=Java VM Version\njava-home=Java Home\nuser-name=User Name\nuser-timezone=User Timezone\nuser-locale=User Locale\nsystem-encoding=System Encoding\noperating-system=Operating System\nos-architecture=OS Architecture\nspi=SPI\ngranted-client-scopes=Granted Client Scopes\nadditional-grants=Additional Grants\nconsent-created-date=Created\nconsent-last-updated-date=Last updated\nrevoke=Revoke\nnew-password=New Password\npassword-confirmation=Password Confirmation\nreset-password=Reset Password\nset-password=Set Password\ncredentials.temporary.tooltip=If enabled, the user must change the password on next login\nremove-totp=Remove OTP\ncredentials.remove-totp.tooltip=Remove one time password generator for user.\nreset-actions=Reset Actions\ncredentials.reset-actions.tooltip=Set of actions to execute when sending the user a Reset Actions Email. 'Verify email' sends an email to the user to verify their email address. 'Update profile' requires user to enter in new personal information. 'Update password' requires user to enter in a new password. 'Configure OTP' requires setup of a mobile password generator.\nreset-actions-email=Reset Actions Email\nsend-email=Send email\ncredentials.reset-actions-email.tooltip=Sends an email to user with an embedded link. Clicking the link enables the user to execute the reset actions without first logging in. For example, set the action to update password, click this button, and the user can change the password without logging in.\nadd-user=Add user\ncreated-at=Created At\nuser-enabled=User Enabled\nuser-enabled.tooltip=A disabled user cannot login.\nuser-temporarily-locked=User Temporarily Locked\nuser-temporarily-locked.tooltip=The user may be locked due to multiple failed attempts to log in.\nunlock-user=Unlock user\nfederation-link=Federation Link\nemail-verified=Email Verified\nemail-verified.tooltip=Has the user's email been verified?\ngroups-joining=Groups\ngroups-joining.tooltip=Groups the user will be joining. To add a group, search for any existing one and select it.\ngroups-joining-select.placeholder=Select existing group\ngroups-joining-no-selected=No group selected\ngroups-joining-path=Path\nrequired-user-actions=Required User Actions\nrequired-user-actions.tooltip=Require an action when the user logs in. 'Verify email' sends an email to the user to verify their email address. 'Update profile' requires user to enter in new personal information. 'Update password' requires user to enter in a new password. 'Configure OTP' requires setup of a mobile password generator.\nlocale=Locale\nselect-one.placeholder=Select one...\nimpersonate=Impersonate\nimpersonate-user=Impersonate user\nimpersonate-user.tooltip=Login as this user. If user is in same realm as you, your current login session will be logged out before you are logged in as this user.\nidentity-provider-alias=Identity Provider Alias\nprovider-user-id=Provider User ID\nprovider-username=Provider Username\nno-identity-provider-links-available=No identity provider links available\ngroup-membership=Group Membership\nleave=Leave\ngroup-membership.tooltip=Groups where the user has membership. To leave a group, select it and click Leave.\nmembership.available-groups.tooltip=Groups a user can join. Select a group and click Join.\ntable-of-realm-users=Table of Realm Users\nview-all-users=View all users\nview-all-groups=View all groups\nview-all-roles=View all roles\nunlock-users=Unlock users\nno-users-available=No users available\nusers.instruction=Please enter a search, or click on view all users\nclients.instruction=Please enter a search\nconsents=Consents\nstarted=Started\nlogout-all-sessions=Log out all sessions\nlogout=Logout\nnew-name=New Name\nnew-description=New Description\nok=Ok\nattributes=Attributes\nrole-mappings=Role Mappings\nmembers=Members\ndetails=Details\nidentity-provider-links=Identity Provider Links\nregister-required-action=Register required action\ngender=Gender\naddress=Address\nphone=Phone\nprofile-url=Profile URL\npicture-url=Picture URL\nwebsite=Website\nimport-keys-and-cert=Import keys and cert\nimport-keys-and-cert.tooltip=Upload the client's key pair and cert.\nupload-keys=Upload Keys\ndownload-keys-and-cert=Download keys and cert\nno-value-assigned.placeholder=No value assigned\nremove=Remove\nno-group-members=No group members\nno-role-members=No role members\ntemporary=Temporary\njoin=Join\nevent-type=Event Type\nevents-config=Events Config\nevent-listeners=Event Listeners\nlogin-events-settings=Login Events Settings\nclear-events=Clear events\nsaved-types=Saved Types\nclear-admin-events=Clear admin events\nclear-changes=Clear changes\nerror=Error\n# Authz\n# Authz Common\nauthz-authorization=Authorization\nauthz-owner=Owner\nauthz-uri=URI\nauthz-uris=URIS\nauthz-scopes=Scopes\nauthz-resource=Resource\nauthz-resource-type=Resource Type\nauthz-resources=Resources\nauthz-scope=Scope\nauthz-authz-scopes=Authorization Scopes\nauthz-policies=Policies\nauthz-policy=Policy\nauthz-permissions=Permissions\nauthz-users=Users in Role\nauthz-evaluate=Evaluate\nauthz-icon-uri=Icon URI\nauthz-icon-uri.tooltip=An URI pointing to an icon.\nauthz-select-scope=Select a scope\nauthz-select-resource=Select a resource\nauthz-associated-policies=Associated Policies\nauthz-any-resource=Any resource\nauthz-any-scope=Any scope\nauthz-any-role=Any role\nauthz-policy-evaluation=Policy Evaluation\nauthz-select-user=Select a user\nauthz-select-client=Select a client\nauthz-entitlements=Entitlements\nauthz-no-resources=No resources\nauthz-result=Result\nauthz-authorization-services-enabled=Authorization Enabled\nauthz-authorization-services-enabled.tooltip=Enable/Disable fine-grained authorization support for a client\nauthz-required=Required\nauthz-show-details=Show Details\nauthz-hide-details=Hide Details\nauthz-associated-permissions=Associated Permissions\nauthz-no-permission-associated=No permissions associated\n# Authz Settings\nauthz-import-config.tooltip=Import a JSON file containing authorization settings for this resource server.\nauthz-policy-enforcement-mode=Policy Enforcement Mode\nauthz-policy-enforcement-mode.tooltip=The policy enforcement mode dictates how policies are enforced when evaluating authorization requests. 'Enforcing' means requests are denied by default even when there is no policy associated with a given resource. 'Permissive' means requests are allowed even when there is no policy associated with a given resource. 'Disabled' completely disables the evaluation of policies and allows access to any resource.\nauthz-policy-enforcement-mode-enforcing=Enforcing\nauthz-policy-enforcement-mode-permissive=Permissive\nauthz-policy-enforcement-mode-disabled=Disabled\nauthz-remote-resource-management=Remote Resource Management\nauthz-remote-resource-management.tooltip=Should resources be managed remotely by the resource server? If false, resources can be managed only from this admin console.\nauthz-export-settings=Export Settings\nauthz-export-settings.tooltip=Export and download all authorization settings for this resource server.\nauthz-server-decision-strategy.tooltip=The decision strategy dictates how permissions are evaluated and how a final decision is obtained. 'Affirmative' means that at least one permission must evaluate to a positive decision in order to grant access to a resource and its scopes. 'Unanimous' means that all permissions must evaluate to a positive decision in order for the final decision to be also positive.\n# Authz Resource List\nauthz-no-resources-available=No resources available.\nauthz-no-scopes-assigned=No scopes assigned.\nauthz-no-type-defined=No type defined.\nauthz-no-uri-defined=No URI defined.\nauthz-no-permission-assigned=No permission assigned.\nauthz-no-policy-assigned=No policy assigned.\nauthz-create-permission=Create Permission\n# Authz Resource Detail\nauthz-add-resource=Add Resource\nauthz-resource-name.tooltip=A unique name for this resource. The name can be used to uniquely identify a resource, useful when querying for a specific resource.\nauthz-resource-owner.tooltip=The owner of this resource.\nauthz-resource-type.tooltip=The type of this resource. It can be used to group different resource instances with the same type.\nauthz-resource-uri.tooltip=Set of URIs which are protected by resource.\nauthz-resource-scopes.tooltip=The scopes associated with this resource.\nauthz-resource-attributes=Resource Attributes\nauthz-resource-attributes.tooltip=The attributes associated wth the resource.\nauthz-resource-user-managed-access-enabled=User-Managed Access Enabled\nauthz-resource-user-managed-access-enabled.tooltip=If enabled, the access to this resource can be managed by the resource owner.\n\n# Authz Scope List\nauthz-add-scope=Add Scope\nauthz-no-scopes-available=No scopes available.\n# Authz Scope Detail\nauthz-scope-name.tooltip=A unique name for this scope. The name can be used to uniquely identify a scope, useful when querying for a specific scope.\n# Authz Policy List\nauthz-all-types=All types\nauthz-create-policy=Create Policy\nauthz-no-policies-available=No policies available.\n# Authz Policy Detail\nauthz-policy-name.tooltip=The name of this policy.\nauthz-policy-description.tooltip=A description for this policy.\nauthz-policy-logic=Logic\nauthz-policy-logic-positive=Positive\nauthz-policy-logic-negative=Negative\nauthz-policy-logic.tooltip=The logic dictates how the policy decision should be made. If 'Positive', the resulting effect (permit or deny) obtained during the evaluation of this policy will be used to perform a decision. If 'Negative', the resulting effect will be negated, in other words, a permit becomes a deny and vice-versa.\nauthz-policy-apply-policy=Apply Policy\nauthz-policy-apply-policy.tooltip=Specifies all the policies that must be applied to the scopes defined by this policy or permission.\nauthz-policy-decision-strategy=Decision Strategy\nauthz-policy-decision-strategy.tooltip=The decision strategy dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. 'Affirmative' means that at least one policy must evaluate to a positive decision in order for the final decision to be also positive. 'Unanimous' means that all policies must evaluate to a positive decision in order for the final decision to be also positive. 'Consensus' means that the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative is the same, the final decision will be negative.\nauthz-policy-decision-strategy-affirmative=Affirmative\nauthz-policy-decision-strategy-unanimous=Unanimous\nauthz-policy-decision-strategy-consensus=Consensus\nauthz-select-a-policy=Select existing policy\nauthz-no-policies-assigned=No policies assigned.\n# Authz Role Policy Detail\nauthz-add-role-policy=Add Role Policy\nauthz-no-roles-assigned=No roles assigned.\nauthz-policy-role-realm-roles.tooltip=Specifies the *realm* roles allowed by this policy.\nauthz-policy-role-clients.tooltip=Selects a client in order to filter the client roles that can be applied to this policy.\nauthz-policy-role-client-roles.tooltip=Specifies the client roles allowed by this policy.\n# Authz User Policy Detail\nauthz-add-user-policy=Add User Policy\nauthz-no-users-assigned=No users assigned.\nauthz-policy-user-users.tooltip=Specifies which user(s) are allowed by this policy.\n# Authz Client Policy Detail\nauthz-add-client-policy=Add Client Policy\nauthz-no-clients-assigned=No clients assigned.\nauthz-policy-client-clients.tooltip=Specifies which client(s) are allowed by this policy.\n# Authz Time Policy Detail\nauthz-add-time-policy=Add Time Policy\nauthz-policy-time-not-before.tooltip=Defines the time before which the policy MUST NOT be granted. Only granted if current date/time is after or equal to this value.\nauthz-policy-time-not-on-after=Not On or After\nauthz-policy-time-not-on-after.tooltip=Defines the time after which the policy MUST NOT be granted. Only granted if current date/time is before or equal to this value.\nauthz-policy-time-day-month=Day of Month\nauthz-policy-time-day-month.tooltip=Defines the day of month when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current day of month is between or equal to the two values you provided.\nauthz-policy-time-month=Month\nauthz-policy-time-month.tooltip=Defines the month which the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current month is between or equal to the two values you provided.\nauthz-policy-time-year=Year\nauthz-policy-time-year.tooltip=Defines the year when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current year is between or equal to the two values you provided.\nauthz-policy-time-hour=Hour\nauthz-policy-time-hour.tooltip=Defines the hour when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current hour is between or equal to the two values you provided.\nauthz-policy-time-minute=Minute\nauthz-policy-time-minute.tooltip=Defines the minute when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current minute is between or equal to the two values you provided.\n# Authz JS Policy Detail\nauthz-add-js-policy=Add JavaScript Policy\nauthz-policy-js-code=Code\nauthz-policy-js-code.tooltip=The JavaScript code providing the conditions for this policy.\n# Authz Aggregated Policy Detail\nauthz-aggregated=Aggregated\nauthz-add-aggregated-policy=Add Aggregated Policy\n# Authz Group Policy Detail\nauthz-add-group-policy=Add Group Policy\nauthz-no-groups-assigned=No groups assigned.\nauthz-policy-group-claim=Groups Claim\nauthz-policy-group-claim.tooltip=If defined, the policy will fetch user's groups from the given claim within an access token or ID token representing the identity asking permissions. If not defined, user's groups are obtained from your realm configuration.\nauthz-policy-group-groups.tooltip=Specifies the groups allowed by this policy.\n# Authz Client Scope Policy Detail\nauthz-add-client-scope-policy=Add Client Scope Policy\nauthz-no-client-scopes-assigned=No client scopes assigned.\nauthz-policy-client-scope-client-scopes.tooltip=Specifies which client scope(s) are allowed by this policy.\nselect-a-client-scope=Select a client scope\n# Authz Regex Policy Detail\nauthz-add-regex-policy=Add Regex Policy\nregex=Regex\nauthz-policy-target-claim=Target Claim\nauthz-policy-target-claim.tooltip=Specifies the target claim which the policy will fetch.\nauthz-policy-regex-pattern=Regex Pattern\nauthz-policy-regex-pattern.tooltip=Specifies the regex pattern.\n\n# Authz Permission List\nauthz-no-permissions-available=No permissions available.\n\n# Authz Permission Detail\nauthz-permission-name.tooltip=The name of this permission.\nauthz-permission-description.tooltip=A description for this permission.\n\n# Authz Resource Permission Detail\nauthz-add-resource-permission=Add Resource Permission\nauthz-permission-resource-apply-to-resource-type=Apply to Resource Type\nauthz-permission-resource-apply-to-resource-type.tooltip=Specifies if this permission should be applied to all resources with a given type. In this case, this permission will be evaluated for all instances of a given resource type.\nauthz-permission-resource-resource.tooltip=Specifies that this permission must be applied to a specific resource instance.\nauthz-permission-resource-type.tooltip=Specifies that this permission must be applied to all resources instances of a given type.\n\n# Authz Scope Permission Detail\nauthz-add-scope-permission=Add Scope Permission\nauthz-permission-scope-resource.tooltip=Restrict the scopes to those associated with the selected resource. If not selected all scopes would be available.\nauthz-permission-scope-scope.tooltip=Specifies that this permission must be applied to one or more scopes.\n\n# Authz Evaluation\nauthz-evaluation-identity-information=Identity Information\nauthz-evaluation-identity-information.tooltip=The available options to configure the identity information that will be used when evaluating policies.\nauthz-evaluation-client.tooltip=Select the client making this authorization request. If not provided, authorization requests would be done based on the client you are in.\nauthz-evaluation-user.tooltip=Select a user whose identity is going to be used to query permissions from the server.\nauthz-evaluation-role.tooltip=Select the roles you want to associate with the selected user.\nauthz-evaluation-new=New Evaluation\nauthz-evaluation-re-evaluate=Re-Evaluate\nauthz-evaluation-previous=Previous Evaluation\nauthz-evaluation-contextual-info=Contextual Information\nauthz-evaluation-contextual-info.tooltip=The available options to configure any contextual information that will be used when evaluating policies.\nauthz-evaluation-contextual-attributes=Contextual Attributes\nauthz-evaluation-contextual-attributes.tooltip=Any attribute provided by a running environment or execution context.\nauthz-evaluation-permissions.tooltip=The available options to configure the permissions to which policies will be applied.\nauthz-evaluation-evaluate=Evaluate\nauthz-evaluation-any-resource-with-scopes=Any resource with scope(s)\nauthz-evaluation-no-result=Could not obtain any result for the given authorization request. Check if the provided resource(s) or scope(s) are associated with any policy.\nauthz-evaluation-no-policies-resource=No policies were found for this resource.\nauthz-evaluation-result.tooltip=The overall result for this permission request.\nauthz-evaluation-scopes.tooltip=The list of allowed scopes.\nauthz-evaluation-policies.tooltip=Details about which policies were evaluated and their decisions.\nauthz-evaluation-authorization-data=Response\nauthz-evaluation-authorization-data.tooltip=Represents a token carrying authorization data as a result of the processing of an authorization request. This representation is basically what Keycloak issues to clients asking for permissions. Check the 'authorization' claim for the permissions that were granted based on the current authorization request.\nauthz-show-authorization-data=Show Authorization Data\n\nkeys=Keys\nstatus=Status\nkeystore=Keystore\nkeystores=Keystores\nadd-keystore=Add Keystore\nadd-keystore.placeholder=Add keystore...\nview=View\nactive=Active\npassive=Passive\ndisabled=Disabled\nalgorithm=Algorithm\nproviderHelpText=Provider description\n\nSunday=Sunday\nMonday=Monday\nTuesday=Tuesday\nWednesday=Wednesday\nThursday=Thursday\nFriday=Friday\nSaturday=Saturday\n\nuser-storage-cache-policy=Cache Settings\nuserStorage.cachePolicy=Cache Policy\nuserStorage.cachePolicy.option.DEFAULT=DEFAULT\nuserStorage.cachePolicy.option.EVICT_WEEKLY=EVICT_WEEKLY\nuserStorage.cachePolicy.option.EVICT_DAILY=EVICT_DAILY\nuserStorage.cachePolicy.option.MAX_LIFESPAN=MAX_LIFESPAN\nuserStorage.cachePolicy.option.NO_CACHE=NO_CACHE\nuserStorage.cachePolicy.tooltip=Cache Policy for this storage provider.  'DEFAULT' is whatever the default settings are for the global cache.  'EVICT_DAILY' is a time of day every day that the cache will be invalidated.  'EVICT_WEEKLY' is a day of the week and time the cache will be invalidated.  'MAX-LIFESPAN' is the time in milliseconds that will be the lifespan of a cache entry.\nuserStorage.cachePolicy.evictionDay=Eviction Day\nuserStorage.cachePolicy.evictionDay.tooltip=Day of the week the entry will become invalid on\nuserStorage.cachePolicy.evictionHour=Eviction Hour\nuserStorage.cachePolicy.evictionHour.tooltip=Hour of day the entry will become invalid on.\nuserStorage.cachePolicy.evictionMinute=Eviction Minute\nuserStorage.cachePolicy.evictionMinute.tooltip=Minute of day the entry will become invalid on.\nuserStorage.cachePolicy.maxLifespan=Max Lifespan\nuserStorage.cachePolicy.maxLifespan.tooltip=Max lifespan of cache entry in milliseconds.\nuser-origin-link=Storage Origin\nuser-origin.tooltip=UserStorageProvider the user was loaded from\nuser-link.tooltip=UserStorageProvider this locally stored user was imported from.\nclient-origin-link=Storage Origin\nclient-origin.tooltip=Provider the client was loaded from\n\nclient-storage-cache-policy=Cache Settings\nclientStorage.cachePolicy=Cache Policy\nclientStorage.cachePolicy.option.DEFAULT=DEFAULT\nclientStorage.cachePolicy.option.EVICT_WEEKLY=EVICT_WEEKLY\nclientStorage.cachePolicy.option.EVICT_DAILY=EVICT_DAILY\nclientStorage.cachePolicy.option.MAX_LIFESPAN=MAX_LIFESPAN\nclientStorage.cachePolicy.option.NO_CACHE=NO_CACHE\nclientStorage.cachePolicy.tooltip=Cache Policy for this storage provider.  'DEFAULT' is whatever the default settings are for the global cache.  'EVICT_DAILY' is a time of day every day that the cache will be invalidated.  'EVICT_WEEKLY' is a day of the week and time the cache will be invalidated.  'MAX-LIFESPAN' is the time in milliseconds that will be the lifespan of a cache entry.\nclientStorage.cachePolicy.evictionDay=Eviction Day\nclientStorage.cachePolicy.evictionDay.tooltip=Day of the week the entry will become invalid on\nclientStorage.cachePolicy.evictionHour=Eviction Hour\nclientStorage.cachePolicy.evictionHour.tooltip=Hour of day the entry will become invalid on.\nclientStorage.cachePolicy.evictionMinute=Eviction Minute\nclientStorage.cachePolicy.evictionMinute.tooltip=Minute of day the entry will become invalid on.\nclientStorage.cachePolicy.maxLifespan=Max Lifespan\nclientStorage.cachePolicy.maxLifespan.tooltip=Max lifespan of cache entry in milliseconds.\n\nclient-storage-list-no-entries=Keycloak can federate external client databases. By default, we support Openshift OAuth clients and service accounts. To get started, select a provider from the dropdown below:\n\n\ndisable=Disable\ndisableable-credential-types=Disableable Types\ncredentials.disableable.tooltip=List of credential types that you can disable\ndisable-credential-types=Disable Credential Types\ncredentials.disable.tooltip=Click button to disable selected credential types\ncredential-types=Credential Types\nmanage-user-password=Manage Password\nsupported-user-storage-credential-types=Supported User Storage Credential Types\nsupported-user-storage-credential-types.tooltip=Credential types, which are provided by User Storage Provider and which are configured for this user. Validation and eventually update of the credentials of those types can be delegated to the User Storage Provider based on the configuration and implementation of the particular provider.\nprovided-by=Provided By\nmanage-credentials=Manage Credentials\nmanage-credentials.tooltip=Credentials, which are not provided by the user storage. They are saved in the local database.\ndisable-credentials=Disable Credentials\ncredential-reset-actions=Credential Reset\ncredential-reset-actions-timeout=Expires In\ncredential-reset-actions-timeout.tooltip=Maximum time before the action permit expires.\nldap-mappers=LDAP Mappers\ncreate-ldap-mapper=Create LDAP mapper\nmap-role-mgmt-scope-description=Policies that decide if an administrator can map this role to a user or group\nmanage-authz-users-scope-description=Policies that decide if an administrator can manage all users in the realm\nview-authz-users-scope-description=Policies that decide if an administrator can view all users in realm\npermissions-enabled-role=Permissions Enabled\npermissions-enabled-role.tooltip=Determines if fine grained permissions are enabled for managing this role.  Disabling will delete all current permissions that have been set up.\nmanage-permissions-role.tooltip=Fine grained permissions for managing roles.  For example, you can define different policies for who is allowed to map a role.\nlookup=Lookup\nmanage-permissions-users.tooltip=Fine grained permissions for managing all users in realm.  You can define different policies for who is allowed to manage users in the realm.\npermissions-enabled-users=Permissions Enabled\npermissions-enabled-users.tooltip=Determines if fined grain permissions are enabled for managing users.  Disabling will delete all current permissions that have been set up.\nmanage-permissions-client.tooltip=Fine grained permissions for administrators that want to manage this client or apply roles defined by this client.\nmanage-permissions-group.tooltip=Fine grained permissions for administrators that want to manage this group or the members of this group.\nmanage-authz-group-scope-description=Policies that decide if an administrator can manage this group\nview-authz-group-scope-description=Policies that decide if an administrator can view this group\nview-members-authz-group-scope-description=Policies that decide if an administrator can view the members of this group\ntoken-exchange-authz-client-scope-description=Policies that decide which clients are allowed exchange tokens for a token that is targeted to this client.\ntoken-exchange-authz-idp-scope-description=Policies that decide which clients are allowed exchange tokens for an external token minted by this identity provider.\nmanage-authz-client-scope-description=Policies that decide if an administrator can manage this client\nconfigure-authz-client-scope-description=Reduced management permissions for administrator.  Cannot set scope, template, or protocol mappers.\nview-authz-client-scope-description=Policies that decide if an administrator can view this client\nmap-roles-authz-client-scope-description=Policies that decide if an administrator can map roles defined by this client\nmap-roles-client-scope-authz-client-scope-description=Policies that decide if an administrator can apply roles defined by this client to the client scope of another client\nmap-roles-composite-authz-client-scope-description=Policies that decide if an administrator can apply roles defined by this client as a composite to another role\nmap-role-authz-role-scope-description=Policies that decide if an administrator can map this role to a user or group\nmap-role-client-scope-authz-role-scope-description=Policies that decide if an administrator can apply this role to the client scope of a client\nmap-role-composite-authz-role-scope-description=Policies that decide if an administrator can apply this role as a composite to another role\nmanage-group-membership-authz-users-scope-description=Policies that decide if an administrator can manage group membership for all users in the realm.  This is used in conjunction with specific group policy\nimpersonate-authz-users-scope-description=Policies that decide if administrator can impersonate other users\nmap-roles-authz-users-scope-description=Policies that decide if administrator can map roles for all users\nuser-impersonated-authz-users-scope-description=Policies that decide which users can be impersonated.  These policies are applied to the user being impersonated.\nmanage-membership-authz-group-scope-description=Policies that decide if an administrator can add or remove users from this group\nmanage-members-authz-group-scope-description=Policies that decide if an administrator can manage the members of this group\n\n# KEYCLOAK-6771 Certificate Bound Token\n# https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\nadvanced-client-settings=Advanced Settings\nadvanced-client-settings.tooltip=Expand this section to configure advanced settings of this client\ntls-client-certificate-bound-access-tokens=OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled\ntls-client-certificate-bound-access-tokens.tooltip=This enables support for OAuth 2.0 Mutual TLS Certificate Bound Access Tokens, which means that keycloak bind an access token and a refresh token with a X.509 certificate of a token requesting client exchanged in mutual TLS between keycloak's Token Endpoint and this client. These tokens can be treated as Holder-of-Key tokens instead of bearer tokens.\n\n# PAR request parameters.\nrequire-pushed-authorization-requests=Pushed Authorization Request Required\nrequire-pushed-authorization-requests.tooltip=Boolean parameter indicating whether the authorization server accepts authorization request data only via the pushed authorization request method.\nrequest-uri-lifespan=Lifetime of the Request URI for Pushed Authorization Request\nrequest-uri-lifespan.tooltip=Number that represents the lifetime of the request URI in minutes or hours, the default value is 1 minute.\n\nsubjectdn=Subject DN\nsubjectdn-tooltip=The expected Subject DN, which should match DN from client certificate. In case that 'Allow Regex Pattern Comparison' allowed, this can contain regular expression for validating Subject DN in the Client Certificate. Use \"(.*?)(?:$)\" to match all kind of expressions.\nallow-regex-pattern-comparison=Allow Regex Pattern Comparison\nallow-regex-pattern-comparison.tooltip=If OFF, then the Subject DN from given client certificate must exactly match the given DN from the 'Subject DN' property as described in the RFC8705 specification. The Subject DN can be in the RFC2553 or RFC1779 format. If ON, then the Subject DN from given client certificate should match regex specified by 'Subject DN' property.\n\npkce-code-challenge-method=Proof Key for Code Exchange Code Challenge Method\npkce-code-challenge-method.tooltip=Choose which code challenge method for PKCE is used. If not specified, keycloak does not applies PKCE to a client unless the client sends an authorization request with appropriate code challenge and code exchange method.\n\nuse-idtoken-as-detached-signature=Use ID Token as a Detached Signature\nuse-idtoken-as-detached-signature.tooltip=This makes ID token returned from Authorization Endpoint in OIDC Hybrid flow use as a detached signature defined in FAPI 1.0 Advanced Security Profile. Therefore, this ID token does not include an authenticated user's information.\n\nacr-loa-map=ACR to LoA Mapping\nacr-loa-map.tooltip=Define which ACR (Authentication Context Class Reference) value is mapped to which LoA (Level of Authentication). The ACR can be any value, whereas the LoA must be numeric. The LoA typically refers to the numbers configured as levels in the conditions in the authentication flow. The ACR refers to the value used in the OIDC/SAML authorization request and returned to client in the tokens.\nacr-loa-map-client.tooltip=Define which ACR (Authentication Context Class Reference) value is mapped to which LoA (Level of Authentication). The ACR can be any value, whereas the LoA must be numeric. This is recommended to be configured at the realm level where it is shared for all the clients. If you configure at the client level, the client mapping will take precedence over the mapping from the realm level.\ndefault-acr-values=Default ACR Values\ndefault-acr-values.tooltip=Default values to be used as voluntary ACR in case that there is no explicit ACR requested by 'claims' or 'acr_values' parameter in the OIDC request.\n\nkey-not-allowed-here=Key '{{character}}' is not allowed here.\n\n# KEYCLOAK-10927 Implement LDAPv3 Password Modify Extended Operation\nadvanced-ldap-settings=Advanced Settings\nldap-query-supported-extensions=Query Supported Extensions\nldap-query-supported-extensions.tooltip=This will query LDAP server for supported extensions, controls and features. Some advanced settings of the LDAP provider will be then automatically configured based on the capabilities/extensions/features supported by LDAP server. For example if LDAPv3 Password Modify extension is supported by LDAP server, corresponding switch will be enabled for LDAP provider.   \n\nnotifications.info.header=Info!\nnotifications.success.header=Success!\nnotifications.error.header=Error!\nnotifications.warn.header=Warning!\n\ndialogs.delete.title=Delete {{type}}\ndialogs.delete.message=Are you sure you want to permanently delete the {{type}} {{name}}?\ndialogs.delete.confirm=Delete\ndialogs.cancel=Cancel\ndialogs.ok=Ok\nuse=Use\n\nuser.profile.attribute=Attribute\nuser.profile.attribute.name=Name\nuser.profile.attribute.name.tooltip=The name of the attribute.\nuser.profile.attribute.displayName=Display name\nuser.profile.attribute.displayName.tooltip=Display name for the attribute. Supports keys for localized values as well. For example\\: ${profile.attribute.phoneNumber}.\nuser.profile.attribute.selector.scopes=Enabled when scope\nuser.profile.attribute.selector.scopes.tooltip=Set the attribute as enabled only when a set of one or more scopes are requested by clients. This constraint only applies to flows where clients are able to ask for scopes (e.g.: during login or registration).\nuser.profile.attribute.required=Required\nuser.profile.attribute.required.tooltip=Set the attribute as required. If enabled, the attribute must be set by users and administrators. Otherwise, the attribute is optional.\nuser.profile.attribute.required.roles=Required for roles\nuser.profile.attribute.required.roles.tooltip=Set the attribute as required for specific types of users. If set to 'user', the attribute is required for users. If set to 'admin' the attribute is required only for administrators.\nuser.profile.attribute.required.scopes=Required for scopes\nuser.profile.attribute.required.scopes.tooltip=Set the attribute as required only when a set of one or more scopes are requested by clients. This constraint only applies to flows where clients are able to ask for scopes (e.g.: during login or registration).\nuser.profile.attribute.permission=Permission\nuser.profile.attribute.canUserView=Can user view?\nuser.profile.attribute.canUserView.tooltip=If enabled, users can view the attribute. Otherwise, users don't have access to the attribute.\nuser.profile.attribute.canUserEdit=Can user edit?\nuser.profile.attribute.canUserEdit.tooltip=If enabled, users can view and edit the attribute. Otherwise, users don't have access to write to the attribute.\nuser.profile.attribute.canAdminView=Can admin view?\nuser.profile.attribute.canAdminView.tooltip=If enabled, administrators can view the attribute. Otherwise, administrators don't have access to the attribute.\nuser.profile.attribute.canAdminEdit=Can admin edit?\nuser.profile.attribute.canAdminEdit.tooltip=If enabled, administrators can view and edit the attribute. Otherwise, administrators don't have access to write to the attribute.\nuser.profile.attribute.validation=Validation\nuser.profile.attribute.validation.add.validator=Add Validator\nuser.profile.attribute.validation.add.validator.tooltip=Select a validator to enforce specific constraints to the attribute value.\nuser.profile.attribute.validation.no.validators=No validators.\nuser.profile.attribute.annotation=Annotation\nuser.profile.attribute.group=Attribute Group\nattribute-groups=Attribute Groups\nuser.profile.attributegroup.displayHeader=Display header\nuser.profile.attributegroup.displayHeader.tooltip=A user-friendly name for the group that should be used when rendering a group of attributes in user-facing forms. Supports keys for localized values as well. For example\\: ${profile.attribute.group.address}.\nuser.profile.attributegroup.displayDescription=Display description\nuser.profile.attributegroup.displayDescription.tooltip=A text that should be used as a tooltip when rendering user-facing forms.\nuser.profile.attributegroup=Attribute Group\nuser.profile.attributegroup.name=Name\nuser.profile.attributegroup.name.tooltip=A unique name for the group. This name will be used to reference the group when binding an attribute to a group.\nuser.profile.attributegroup.annotation=Annotation\n", "Array.prototype.remove = function(from, to) {\n    var rest = this.slice((to || from) + 1 || this.length);\n    this.length = from < 0 ? this.length + from : from;\n    return this.push.apply(this, rest);\n};\n\nmodule.controller('ClientTabCtrl', function(Dialog, $scope, Current, Notifications, $location) {\n    $scope.removeClient = function() {\n        Dialog.confirmDelete($scope.client.clientId, 'client', function() {\n            $scope.client.$remove({\n                realm : Current.realm.realm,\n                client : $scope.client.id\n            }, function() {\n                $location.url(\"/realms/\" + Current.realm.realm + \"/clients\");\n                Notifications.success(\"The client has been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('ClientRoleListCtrl', function($scope, $route, realm, client, ClientRoleList, RoleById, Notifications, Dialog) {\n    $scope.realm = realm;\n    $scope.roles = [];\n    $scope.client = client;\n\n    $scope.query = {\n        realm: realm.realm,\n        client: $scope.client.id,\n        search : null,\n        max : 20,\n        first : 0\n    }\n\n    $scope.$watch('query.search', function (newVal, oldVal) {\n        if($scope.query.search && $scope.query.search.length >= 3) {\n            $scope.firstPage();\n        }\n    }, true);\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        $scope.searchQuery();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.searchQuery();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.searchQuery();\n    }\n\n    $scope.searchQuery = function() {\n        $scope.searchLoaded = false;\n\n        $scope.roles = ClientRoleList.query($scope.query, function() {\n            $scope.searchLoaded = true;\n            $scope.lastSearch = $scope.query.search;\n        });\n    };\n\n    $scope.searchQuery();\n\n    $scope.removeRole = function(role) {\n        Dialog.confirmDelete(role.name, 'role', function() {\n            RoleById.remove({\n                realm: realm.realm,\n                role: role.id\n            }, function () {\n                $route.reload();\n                Notifications.success(\"The role has been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('ClientCredentialsCtrl', function($scope, $location, realm, client, clientAuthenticatorProviders, clientConfigProperties, Client, ClientRegistrationAccessToken, Notifications) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n    $scope.clientAuthenticatorProviders = clientAuthenticatorProviders;\n\n    var updateCurrentPartial = function(val) {\n        $scope.clientAuthenticatorConfigPartial;\n        switch(val) {\n            case 'client-secret':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-secret.html';\n                break;\n            case 'client-jwt':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-jwt.html';\n                break;\n            case 'client-secret-jwt':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-secret-jwt.html';\n                break;\n            case 'client-x509':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-x509.html';\n                break;\n            default:\n                $scope.currentAuthenticatorConfigProperties = clientConfigProperties[val];\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-generic.html';\n                break;\n        }\n    };\n\n    updateCurrentPartial(client.clientAuthenticatorType);\n\n    $scope.$watch('client.clientAuthenticatorType', function() {\n        if (!angular.equals($scope.client.clientAuthenticatorType, client.clientAuthenticatorType)) {\n\n            Client.update({\n                realm : realm.realm,\n                client : client.id\n            }, $scope.client, function() {\n                $scope.changed = false;\n                client = angular.copy($scope.client);\n                updateCurrentPartial(client.clientAuthenticatorType)\n            });\n\n        }\n    }, true);\n\n    $scope.regenerateRegistrationAccessToken = function() {\n        var secret = ClientRegistrationAccessToken.update({ realm : $scope.realm.realm, client : $scope.client.id },\n            function(data) {\n                Notifications.success('The registration access token has been updated.');\n                $scope.client['registrationAccessToken'] = data.registrationAccessToken;\n            },\n            function() {\n                Notifications.error('Failed to update the registration access token');\n            }\n        );\n    };\n});\n\nmodule.controller('ClientSecretCtrl', function($scope, $location, Client, ClientSecret, Notifications, $route) {\n\n    var secret = ClientSecret.get({ realm : $scope.realm.realm, client : $scope.client.id },\n        function() {\n            $scope.secret = secret.value;\n        }\n    );\n\n    $scope.changePassword = function() {\n        var secret = ClientSecret.update({ realm : $scope.realm.realm, client : $scope.client.id },\n            function() {\n                $route.reload();\n                Notifications.success('The secret has been changed.');\n            },\n            function() {\n                Notifications.error(\"The secret was not changed due to a problem.\");\n                $scope.secret = \"error\";\n            }\n        );\n    };\n\n    $scope.removeRotatedSecret = function(){\n        ClientSecret.invalidate({realm: $scope.realm.realm, client: $scope.client.id },\n          function(){\n            $route.reload();\n            Notifications.success('The rotated secret has been invalidated.');\n          },\n          function(){\n            Notifications.error(\"The rotated secret was not invalidated due to a problem.\");\n          }\n        );\n    };\n\n    $scope.tokenEndpointAuthSigningAlg = $scope.client.attributes['token.endpoint.auth.signing.alg'];\n\n    if ($scope.client.attributes['client.secret.expiration.time']){\n        $scope.secret_expiration_time = $scope.client.attributes['client.secret.expiration.time'] * 1000;\n    }\n\n    if ($scope.client.attributes[\"client.secret.rotated\"]) {\n        $scope.secretRotated = $scope.client.attributes[\"client.secret.rotated\"];\n    }\n\n    if ($scope.client.attributes['client.secret.rotated.expiration.time']){\n        $scope.rotated_secret_expiration_time = $scope.client.attributes['client.secret.rotated.expiration.time'] * 1000;\n    }\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.save = function() {\n        $scope.client.attributes['token.endpoint.auth.signing.alg'] = $scope.tokenEndpointAuthSigningAlg;\n\n        Client.update({\n            realm : $scope.realm.realm,\n            client : $scope.client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            $scope.clientCopy = angular.copy($scope.client);\n            Notifications.success(\"Client authentication configuration has been saved to the client.\");\n        });\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + $scope.realm.realm + \"/clients/\" + $scope.client.id + \"/credentials\");\n        $route.reload();\n    };\n\n});\n\nmodule.controller('ClientX509Ctrl', function($scope, $location, Client, Notifications) {\n    console.log('ClientX509Ctrl invoked');\n\n    $scope.clientCopy = angular.copy($scope.client);\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, $scope.clientCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    function updateProperties() {\n       if ($scope.client.attributes[\"x509.allow.regex.pattern.comparison\"]) {\n           if ($scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] == \"true\") {\n               $scope.allowRegexPatternComparison = true;\n           } else {\n               $scope.allowRegexPatternComparison = false;\n           }\n       }\n    }\n\n    updateProperties();\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.save = function() {\n        if ($scope.allowRegexPatternComparison == true) {\n            $scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] = \"true\";\n        } else {\n            $scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] = \"false\";\n        }\n\n        if (!$scope.client.attributes[\"x509.subjectdn\"]) {\n            Notifications.error(\"The SubjectDN must not be empty.\");\n        } else {\n            Client.update({\n                realm : $scope.realm.realm,\n                client : $scope.client.id\n            }, $scope.client, function() {\n                $scope.changed = false;\n                $scope.clientCopy = angular.copy($scope.client);\n                Notifications.success(\"Client authentication configuration has been saved to the client.\");\n            }, function() {\n                Notifications.error(\"The SubjectDN was not changed due to a problem.\");\n                $scope.subjectdn = \"error\";\n            });\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.reset = function() {\n        $scope.client.attributes[\"x509.subjectdn\"] = $scope.clientCopy.attributes[\"x509.subjectdn\"];\n        $scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] = $scope.clientCopy.attributes[\"x509.allow.regex.pattern.comparison\"];\n        updateProperties();\n        $location.url(\"/realms/\" + $scope.realm.realm + \"/clients/\" + $scope.client.id + \"/credentials\");\n    };\n});\n\nmodule.controller('ClientSignedJWTCtrl', function($scope, Client, Notifications) {\n    console.log('ClientSignedJWTCtrl invoked');\n\n    $scope.tokenEndpointAuthSigningAlg = $scope.client.attributes['token.endpoint.auth.signing.alg'];\n\n    $scope.$watch('tokenEndpointAuthSigningAlg', function() {\n        if (!angular.equals($scope.client.attributes['token.endpoint.auth.signing.alg'], $scope.tokenEndpointAuthSigningAlg)) {\n            $scope.client.attributes['token.endpoint.auth.signing.alg'] = $scope.tokenEndpointAuthSigningAlg;\n\n            Client.update({\n                realm : $scope.realm.realm,\n                client : $scope.client.id\n            }, $scope.client, function() {\n                Notifications.success(\"Signature algorithm has been saved to the client.\");\n            });\n        }\n    }, true);\n\n});\n\nmodule.controller('ClientGenericCredentialsCtrl', function($scope, $location, Client, Notifications) {\n\n    console.log('ClientGenericCredentialsCtrl invoked');\n\n    $scope.clientCopy = angular.copy($scope.client);\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, $scope.clientCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    $scope.save = function() {\n\n        Client.update({\n            realm : $scope.realm.realm,\n            client : $scope.client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            $scope.clientCopy = angular.copy($scope.client);\n            Notifications.success(\"Client authentication configuration has been saved to the client.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.client = angular.copy($scope.clientCopy);\n        $scope.changed = false;\n    };\n});\n\nmodule.controller('ClientIdentityProviderCtrl', function($scope, $location, $route, realm, client, Client, $location, Notifications) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n    var length = 0;\n\n    if ($scope.client.identityProviders) {\n        length = $scope.client.identityProviders.length;\n\n        for (i = 0; i < $scope.client.identityProviders.length; i++) {\n            var clientProvider = $scope.client.identityProviders[i];\n            if (clientProvider.retrieveToken) {\n                clientProvider.retrieveToken = clientProvider.retrieveToken.toString();\n            }\n        }\n\n    } else {\n        $scope.client.identityProviders = [];\n    }\n\n    $scope.identityProviders = [];\n    var providersMissingInClient = [];\n\n    for (j = 0; j < realm.identityProviders.length; j++) {\n        var identityProvider = realm.identityProviders[j];\n        var clientProvider = null;\n\n        for (i = 0; i < $scope.client.identityProviders.length; i++) {\n            clientProvider = $scope.client.identityProviders[i];\n\n            if (clientProvider) {\n\n                if (clientProvider.id == identityProvider.id) {\n                    $scope.identityProviders[i] = {};\n                    $scope.identityProviders[i].identityProvider = identityProvider;\n                    $scope.identityProviders[i].retrieveToken = clientProvider.retrieveToken;\n                    break;\n                }\n\n                clientProvider = null;\n            }\n        }\n\n        if (clientProvider == null) {\n            providersMissingInClient.push(identityProvider);\n        }\n    }\n\n    for (j = 0; j < providersMissingInClient.length; j++) {\n        var identityProvider = providersMissingInClient[j];\n\n        var currentProvider = {};\n        currentProvider.identityProvider = identityProvider;\n        currentProvider.retrieveToken = \"false\";\n        $scope.identityProviders.push(currentProvider);\n\n        var currentClientProvider = {};\n        currentClientProvider.id = identityProvider.id;\n        currentClientProvider.retrieveToken = \"false\";\n        $scope.client.identityProviders.push(currentClientProvider);\n    }\n\n    var oldCopy = angular.copy($scope.client);\n\n    $scope.save = function() {\n\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            $route.reload();\n            Notifications.success(\"Your changes have been saved to the client.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.client = angular.copy(oldCopy);\n        $scope.changed = false;\n    };\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, oldCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n});\n\nmodule.controller('ClientSamlKeyCtrl', function($scope, $location, $http, $upload, realm, client,\n                                                         ClientCertificate, ClientCertificateGenerate,\n                                                         ClientCertificateDownload, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n\n    var signingKeyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: 'saml.signing' },\n        function() {\n            $scope.signingKeyInfo = signingKeyInfo;\n        }\n    );\n\n    $scope.generateSigningKey = function() {\n        var keyInfo = ClientCertificateGenerate.generate({ realm : realm.realm, client : client.id, attribute: 'saml.signing' },\n            function() {\n                Notifications.success('Signing key has been regenerated.');\n                $scope.signingKeyInfo = keyInfo;\n            },\n            function() {\n                Notifications.error(\"Signing key was not regenerated.\");\n            }\n        );\n    };\n\n    $scope.importSigningKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Signing/import/saml.signing\");\n    };\n\n    $scope.exportSigningKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Signing/export/saml.signing\");\n    };\n\n    var encryptionKeyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: 'saml.encryption' },\n        function() {\n            $scope.encryptionKeyInfo = encryptionKeyInfo;\n        }\n    );\n\n    $scope.generateEncryptionKey = function() {\n        var keyInfo = ClientCertificateGenerate.generate({ realm : realm.realm, client : client.id, attribute: 'saml.encryption' },\n            function() {\n                Notifications.success('Encryption key has been regenerated.');\n                $scope.encryptionKeyInfo = keyInfo;\n            },\n            function() {\n                Notifications.error(\"Encryption key was not regenerated.\");\n            }\n        );\n    };\n\n    $scope.importEncryptionKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Encryption/import/saml.encryption\");\n    };\n\n    $scope.exportEncryptionKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Encryption/export/saml.encryption\");\n    };\n\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n});\n\nmodule.controller('ClientCertificateImportCtrl', function($scope, $location, $http, $upload, realm, client, callingContext, $routeParams,\n                                                         ClientCertificate, ClientCertificateGenerate,\n                                                         ClientCertificateDownload, Notifications) {\n\n    console.log(\"callingContext: \" + callingContext);\n\n    var keyType = $routeParams.keyType;\n    var attribute = $routeParams.attribute;\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.keyType = keyType;\n\n    if (callingContext == 'saml') {\n        var uploadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/upload';\n        var redirectLocation = \"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/keys\";\n    } else if (callingContext == 'oidc') {\n        var uploadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/upload-certificate';\n        var redirectLocation = \"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/keys\";\n    }\n\n    $scope.files = [];\n\n    $scope.onFileSelect = function($files) {\n        $scope.files = $files;\n    };\n\n    $scope.cancel = function() {\n        $location.url(redirectLocation);\n    }\n\n    $scope.keyFormats = [\n        \"JKS\",\n        \"PKCS12\",\n        \"Certificate PEM\"\n    ];\n\n    if (callingContext == 'oidc') {\n        $scope.keyFormats.push('Public Key PEM');\n        $scope.keyFormats.push('JSON Web Key Set');\n    }\n\n    $scope.hideKeystoreSettings = function() {\n        return $scope.uploadKeyFormat == 'Certificate PEM' || $scope.uploadKeyFormat == 'Public Key PEM' || $scope.uploadKeyFormat == 'JSON Web Key Set';\n    }\n\n    $scope.uploadKeyFormat = $scope.keyFormats[0];\n\n    $scope.uploadFile = function() {\n        //$files: an array of files selected, each file has name, size, and type.\n        for (var i = 0; i < $scope.files.length; i++) {\n            var $file = $scope.files[i];\n            $scope.upload = $upload.upload({\n                url: uploadUrl,\n                // method: POST or PUT,\n                // headers: {'headerKey': 'headerValue'}, withCredential: true,\n                data: {keystoreFormat: $scope.uploadKeyFormat,\n                    keyAlias: $scope.uploadKeyAlias,\n                    keyPassword: $scope.uploadKeyPassword,\n                    storePassword: $scope.uploadStorePassword\n                },\n                file: $file\n                /* set file formData name for 'Content-Desposition' header. Default: 'file' */\n                //fileFormDataName: myFile,\n                /* customize how data is added to formData. See #40#issuecomment-28612000 for example */\n                //formDataAppender: function(formData, key, val){}\n            }).then(function(data, status, headers) {\n                Notifications.success(\"Keystore uploaded successfully.\");\n                $location.url(redirectLocation);\n            })\n            //.then(success, error, progress);\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n});\n\nmodule.controller('ClientCertificateExportCtrl', function($scope, $location, $http, $upload, realm, client, callingContext, $routeParams,\n                                                         ClientCertificate, ClientCertificateGenerate,\n                                                         ClientCertificateDownload, Notifications) {\n    var keyType = $routeParams.keyType;\n    var attribute = $routeParams.attribute;\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.keyType = keyType;\n\n    if (callingContext == 'saml') {\n        var downloadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/download';\n        var realmCertificate = true;\n    } else if (callingContext == 'oidc') {\n        var downloadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/generate-and-download'\n        var realmCertificate = false;\n    }\n\n    var jks = {\n        keyAlias: client.clientId,\n        realmAlias: realm.realm,\n        realmCertificate: realmCertificate\n    };\n\n    $scope.keyFormats = [\n        \"JKS\",\n        \"PKCS12\"\n    ];\n\n    var keyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: attribute },\n        function() {\n            $scope.keyInfo = keyInfo;\n        }\n    );\n    $scope.jks = jks;\n    $scope.jks.format = $scope.keyFormats[0];\n\n    $scope.download = function() {\n        $http({\n            url: downloadUrl,\n            method: 'POST',\n            responseType: 'arraybuffer',\n            data: $scope.jks,\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/octet-stream'\n            }\n        }).then(function(response){\n            var blob = new Blob([response.data], {\n                type: 'application/octet-stream'\n            });\n            var ext = \".jks\";\n            if ($scope.jks.format == 'PKCS12') ext = \".p12\";\n\n            if (callingContext == 'oidc') {\n                $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/keys\");\n                Notifications.success(\"New keypair and certificate generated successfully. Download keystore file\")\n            }\n\n            saveAs(blob, 'keystore' + ext);\n        }).catch(function(response) {\n            var errorMsg = 'Error downloading';\n            try {\n                var error = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(response.data)));\n                errorMsg = error['error_description'] ? error['error_description'] : errorMsg;\n            } catch (err) {\n            }\n            Notifications.error(errorMsg);\n        });\n    }\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/keys\");\n    }\n});\n\nmodule.controller('ClientOidcKeyCtrl', function($scope, $location, realm, client, Client, ClientCertificate, Notifications, $route) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n\n    var signingKeyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: 'jwt.credential' },\n        function() {\n            $scope.signingKeyInfo = signingKeyInfo;\n        }\n    );\n\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, client)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    if ($scope.client.attributes[\"use.jwks.url\"]) {\n        if ($scope.client.attributes[\"use.jwks.url\"] == \"true\") {\n            $scope.useJwksUrl = true;\n        } else {\n            $scope.useJwksUrl = false;\n        }\n    }\n\n    if ($scope.client.attributes[\"use.jwks.string\"]) {\n        if ($scope.client.attributes[\"use.jwks.string\"] == \"true\") {\n            $scope.useJwksString = true;\n        } else {\n            $scope.useJwksString = false;\n        }\n    }\n\n    $scope.jwksUrlSwitchChange = function() {\n        $scope.changed = true;\n        if ($scope.useJwksUrl == false) {\n            $scope.useJwksString = false;\n        }\n    }\n\n    $scope.jwksStringSwitchChange = function() {\n        $scope.changed = true;\n        if ($scope.useJwksString == false) {\n            $scope.useJwksUrl = false;\n        }\n    }\n\n    $scope.save = function() {\n\n        if ($scope.useJwksUrl == true) {\n            $scope.client.attributes[\"use.jwks.url\"] = \"true\";\n        } else {\n            $scope.client.attributes[\"use.jwks.url\"] = \"false\";\n        }\n\n        if ($scope.useJwksString == true) {\n            $scope.client.attributes[\"use.jwks.string\"] = \"true\";\n        } else {\n            $scope.client.attributes[\"use.jwks.string\"] = \"false\";\n        }\n\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            client = angular.copy($scope.client);\n            Notifications.success(\"OIDC key has been saved to the client.\");\n        });\n    };\n\n    $scope.importCertificate = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/Signing/import/jwt.credential\");\n    };\n\n    $scope.generateSigningKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/Signing/export/jwt.credential\");\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n});\n\nmodule.controller('ClientSessionsCtrl', function($scope, realm, sessionCount, client,\n                                                      ClientUserSessions) {\n    $scope.realm = realm;\n    $scope.count = sessionCount.count;\n    $scope.sessions = [];\n    $scope.client = client;\n\n    $scope.page = 0;\n\n    $scope.query = {\n        realm : realm.realm,\n        client: $scope.client.id,\n        max : 5,\n        first : 0\n    }\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.loadUsers();\n    }\n\n    $scope.toDate = function(val) {\n        return new Date(val);\n    };\n\n    $scope.loadUsers = function() {\n        ClientUserSessions.query($scope.query, function(updated) {\n            $scope.sessions = updated;\n        })\n    };\n});\n\nmodule.controller('ClientOfflineSessionsCtrl', function($scope, realm, offlineSessionCount, client,\n                                                      ClientOfflineSessions) {\n    $scope.realm = realm;\n    $scope.count = offlineSessionCount.count;\n    $scope.sessions = [];\n    $scope.client = client;\n\n    $scope.page = 0;\n\n    $scope.query = {\n        realm : realm.realm,\n        client: $scope.client.id,\n        max : 5,\n        first : 0\n    }\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.loadUsers();\n    }\n\n    $scope.toDate = function(val) {\n        return new Date(val);\n    };\n\n    $scope.loadUsers = function() {\n        ClientOfflineSessions.query($scope.query, function(updated) {\n            $scope.sessions = updated;\n        })\n    };\n});\n\nmodule.controller('ClientRoleDetailCtrl', function($scope, $route, realm, client, role, roles, Client,\n                                                        Role, ClientRole, RoleById, RoleRealmComposites, RoleClientComposites,\n                                                        $http, $location, Dialog, Notifications, ComponentUtils) {\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.role = angular.copy(role);\n    $scope.create = !role.name;\n\n    $scope.changed = $scope.create;\n\n    $scope.save = function() {\n        convertAttributeValuesToLists();\n        if ($scope.create) {\n            ClientRole.save({\n                realm: realm.realm,\n                client : client.id\n            }, $scope.role, function (data, headers) {\n                $scope.changed = false;\n                convertAttributeValuesToString($scope.role);\n                role = angular.copy($scope.role);\n\n                ClientRole.get({ realm: realm.realm, client : client.id, role: role.name }, function(role) {\n                    var id = role.id;\n                    $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/roles/\" + id);\n                    Notifications.success(\"The role has been created.\");\n                });\n            });\n        } else {\n            $scope.update();\n        }\n    };\n\n    $scope.remove = function() {\n        Dialog.confirmDelete($scope.role.name, 'role', function() {\n            $scope.role.$remove({\n                realm : realm.realm,\n                client : client.id,\n                role : $scope.role.id\n            }, function() {\n                $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/roles\");\n                Notifications.success(\"The role has been deleted.\");\n            });\n        });\n    };\n\n    $scope.cancel = function () {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/roles\");\n    };\n\n    $scope.addAttribute = function() {\n        $scope.role.attributes[$scope.newAttribute.key] = $scope.newAttribute.value;\n        delete $scope.newAttribute;\n    }\n\n    $scope.removeAttribute = function(key) {\n        delete $scope.role.attributes[key];\n    }\n\n    function convertAttributeValuesToLists() {\n        var attrs = $scope.role.attributes;\n        for (var attribute in attrs) {\n            if (typeof attrs[attribute] === \"string\") {\n                var attrVals = attrs[attribute].split(\"##\");\n                attrs[attribute] = attrVals;\n            }\n        }\n    }\n\n    function convertAttributeValuesToString(role) {\n        var attrs = role.attributes;\n        for (var attribute in attrs) {\n            if (typeof attrs[attribute] === \"object\") {\n                var attrVals = attrs[attribute].join(\"##\");\n                attrs[attribute] = attrVals;\n            }\n        }\n    }\n\n    roleControl($scope, $route, realm, role, roles, Client,\n        ClientRole, RoleById, RoleRealmComposites, RoleClientComposites,\n        $http, $location, Notifications, Dialog, ComponentUtils);\n\n});\n\nmodule.controller('ClientRoleMembersCtrl', function($scope, realm, client, role, ClientRoleMembership, Dialog, Notifications, $location) {\n    $scope.realm = realm;\n    $scope.page = 0;\n    $scope.role = role;\n    $scope.client = client;\n\n    $scope.query = {\n        realm: realm.realm,\n        role: role.name,\n        client: client.id,\n        max : 5,\n        first : 0\n    }\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        $scope.searchQuery();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.searchQuery();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.searchQuery();\n    }\n\n    $scope.searchQuery = function() {\n        $scope.searchLoaded = false;\n\n        $scope.users = ClientRoleMembership.query($scope.query, function() {\n            console.log('search loaded');\n            $scope.searchLoaded = true;\n            $scope.lastSearch = $scope.query.search;\n        });\n    };\n\n    $scope.searchQuery();\n});\n\nmodule.controller('ClientImportCtrl', function($scope, $location, $upload, realm, serverInfo, Notifications) {\n\n    $scope.realm = realm;\n\n    $scope.files = [];\n\n    $scope.onFileSelect = function($files) {\n        $scope.files = $files;\n    };\n\n    $scope.clearFileSelect = function() {\n        $scope.files = null;\n    }\n\n    $scope.uploadFile = function() {\n        //$files: an array of files selected, each file has name, size, and type.\n        for (var i = 0; i < $scope.files.length; i++) {\n            var $file = $scope.files[i];\n            $scope.upload = $upload.upload({\n                url: authUrl + '/admin/realms/' + realm.realm + '/client-importers/' + $scope.configFormat.id + '/upload',\n                // method: POST or PUT,\n                // headers: {'headerKey': 'headerValue'}, withCredential: true,\n                data: {myObj: \"\"},\n                file: $file\n                /* set file formData name for 'Content-Desposition' header. Default: 'file' */\n                //fileFormDataName: myFile,\n                /* customize how data is added to formData. See #40#issuecomment-28612000 for example */\n                //formDataAppender: function(formData, key, val){}\n            }).success(function(data, status, headers) {\n                Notifications.success(\"Uploaded successfully.\");\n                $location.url(\"/realms/\" + realm.realm + \"/clients\");\n            })\n                .error(function() {\n                    Notifications.error(\"The file can not be uploaded. Please verify the file.\");\n\n                });\n            //.then(success, error, progress);\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n});\n\n\nmodule.controller('ClientListCtrl', function($scope, realm, Client, ClientListSearchState, $route, Dialog, Notifications) {\n    $scope.init = function() {\n        $scope.realm = realm;\n        $scope.searchLoaded = true;\n\n        ClientListSearchState.query.realm = realm.realm;\n        $scope.query = ClientListSearchState.query;\n\n        if (!ClientListSearchState.isFirstSearch) {\n            $scope.searchQuery();\n        } else {\n            $scope.query.clientId = null;\n            $scope.firstPage();\n        }\n    };\n\n    $scope.searchQuery = function() {\n        console.log(\"query.search: \", $scope.query);\n        $scope.searchLoaded = false;\n\n        $scope.clients = Client.query($scope.query, function() {\n            $scope.searchLoaded = true;\n            $scope.lastSearch = $scope.query.search;\n            ClientListSearchState.isFirstSearch = false;\n        });\n    };\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        $scope.searchQuery();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.searchQuery();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.searchQuery();\n    }\n\n    $scope.removeClient = function(client) {\n        Dialog.confirmDelete(client.clientId, 'client', function() {\n            Client.remove({\n                realm : realm.realm,\n                client : client.id\n            }, function() {\n                $route.reload();\n                Notifications.success(\"The client has been deleted.\");\n            });\n        });\n    };\n\n    $scope.exportClient = function(client) {\n        var clientCopy = angular.copy(client);\n        delete clientCopy.id;\n\n        if (clientCopy.protocolMappers) {\n            for (var i = 0; i < clientCopy.protocolMappers.length; i++) {\n                delete clientCopy.protocolMappers[i].id;\n            }\n        }\n\n        saveAs(new Blob([angular.toJson(clientCopy, 4)], { type: 'application/json' }), clientCopy.clientId + '.json');\n    }\n});\n\nmodule.controller('ClientInstallationCtrl', function($scope, realm, client, serverInfo, ClientInstallation,$http, $routeParams) {\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.installation = null;\n    $scope.download = null;\n    $scope.configFormat = null;\n    $scope.filename = null;\n\n    var protocol = client.protocol;\n    if (!protocol) protocol = 'openid-connect';\n    $scope.configFormats = serverInfo.clientInstallations[protocol];\n    console.log('configFormats.length: ' + $scope.configFormats.length);\n\n    $scope.changeFormat = function() {\n        var url = ClientInstallation.url({ realm: $routeParams.realm, client: $routeParams.client, provider: $scope.configFormat.id });\n        if ($scope.configFormat.mediaType == 'application/zip') {\n            $http({\n                url: url,\n                method: 'GET',\n                responseType: 'arraybuffer',\n                cache: false\n            }).then(function(response) {\n                var installation = response.data;\n                $scope.installation = installation;\n                }\n            );\n        } else {\n            $http.get(url).then(function (response) {\n                var installation = response.data;\n                if ($scope.configFormat.mediaType == 'application/json') {\n                    installation = angular.fromJson(response.data);\n                    installation = angular.toJson(installation, true);\n                }\n                $scope.installation = installation;\n            });\n        }\n\n    };\n    $scope.download = function() {\n        saveAs(new Blob([$scope.installation], { type: $scope.configFormat.mediaType }), $scope.configFormat.filename);\n    }\n});\n\n\nmodule.controller('ClientDetailCtrl', function($scope, realm, client, flows, $route, serverInfo, Client, ClientDescriptionConverter, Components, ClientStorageOperations, $location, $modal, Dialog, Notifications, TimeUnit2) {\n    $scope.serverInfo = serverInfo;\n    $scope.flows = [];\n    $scope.clientFlows = [];\n    var emptyFlow = {\n        id: \"\",\n        alias: \"\"\n    }\n    for (var i=0 ; i<flows.length ; i++) {\n        if (flows[i].providerId == 'client-flow') {\n            $scope.clientFlows.push(flows[i]);\n        } else {\n            $scope.flows.push(flows[i]);\n        }\n    }\n    $scope.flows.push(emptyFlow)\n    $scope.clientFlows.push(emptyFlow)\n    var deletedSomeDefaultAcrValue = false;\n\n\n    $scope.accessTypes = [\n        \"confidential\",\n        \"public\",\n        \"bearer-only\"\n    ];\n\n    $scope.protocols = serverInfo.listProviderIds('login-protocol');\n\n    $scope.signatureAlgorithms = [\n        \"RSA_SHA1\",\n        \"RSA_SHA256\",\n        \"RSA_SHA256_MGF1\",\n        \"RSA_SHA512\",\n        \"RSA_SHA512_MGF1\",\n        \"DSA_SHA1\"\n    ];\n    $scope.nameIdFormats = [\n        \"username\",\n        \"email\",\n        \"transient\",\n        \"persistent\"\n    ];\n    $scope.xmlKeyNameTranformers = [\n        \"NONE\",\n        \"KEY_ID\",\n        \"CERT_SUBJECT\"\n    ];\n\n    $scope.canonicalization = [\n        {name: \"EXCLUSIVE\", value:  \"http://www.w3.org/2001/10/xml-exc-c14n#\"  },\n        {name: \"EXCLUSIVE_WITH_COMMENTS\", value: \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\"},\n        {name: \"INCLUSIVE\", value: \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" },\n        {name: \"INCLUSIVE_WITH_COMMENTS\", value: \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"}\n    ];\n\n    $scope.requestObjectRequiredOptions = [\n        \"not required\",\n        \"request or request_uri\",\n        \"request only\",\n        \"request_uri only\"\n    ];\n\n    $scope.changePkceCodeChallengeMethodOptions = [\n        \"S256\",\n        \"plain\",\n        \"\"\n    ];\n\n    $scope.realm = realm;\n    $scope.samlAuthnStatement = false;\n    $scope.samlOneTimeUseCondition = false;\n    $scope.samlMultiValuedRoles = false;\n    $scope.samlArtifactBinding = false;\n    $scope.samlServerSignature = false;\n    $scope.samlServerSignatureEnableKeyInfoExtension = false;\n    $scope.samlAssertionSignature = false;\n    $scope.samlClientSignature = false;\n    $scope.samlEncrypt = false;\n    $scope.samlForcePostBinding = false;\n    $scope.samlForceNameIdFormat = false;\n    $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[1];\n    $scope.disableAuthorizationTab = !client.authorizationServicesEnabled;\n    $scope.disableServiceAccountRolesTab = !client.serviceAccountsEnabled;\n    $scope.disableCredentialsTab = client.publicClient;\n    $scope.oauth2DeviceAuthorizationGrantEnabled = false;\n    $scope.oidcCibaGrantEnabled = false;\n    // KEYCLOAK-6771 Certificate Bound Token\n    // https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\n    $scope.tlsClientCertificateBoundAccessTokens = false;\n    $scope.useRefreshTokens = true;\n    $scope.useIdTokenAsDetachedSignature = false;\n\n    $scope.accessTokenLifespan = TimeUnit2.asUnit(client.attributes['access.token.lifespan']);\n    $scope.samlAssertionLifespan = TimeUnit2.asUnit(client.attributes['saml.assertion.lifespan']);\n    $scope.clientSessionIdleTimeout = TimeUnit2.asUnit(client.attributes['client.session.idle.timeout']);\n    $scope.clientSessionMaxLifespan = TimeUnit2.asUnit(client.attributes['client.session.max.lifespan']);\n    $scope.clientOfflineSessionIdleTimeout = TimeUnit2.asUnit(client.attributes['client.offline.session.idle.timeout']);\n    $scope.clientOfflineSessionMaxLifespan = TimeUnit2.asUnit(client.attributes['client.offline.session.max.lifespan']);\n    $scope.oauth2DeviceCodeLifespan = TimeUnit2.asUnit(client.attributes['oauth2.device.code.lifespan']);\n    $scope.oauth2DevicePollingInterval = parseInt(client.attributes['oauth2.device.polling.interval']);\n\n    // PAR request.\n    $scope.requirePushedAuthorizationRequests = false;\n\n    if(client.origin) {\n        if ($scope.access.viewRealm) {\n            Components.get({realm: realm.realm, componentId: client.origin}, function (link) {\n                $scope.originName = link.name;\n                //$scope.originLink = \"#/realms/\" + realm.realm + \"/user-storage/providers/\" + link.providerId + \"/\" + link.id;\n            })\n        }\n        else {\n            // KEYCLOAK-4328\n            ClientStorageOperations.simpleName.get({realm: realm.realm, componentId: client.origin}, function (link) {\n                $scope.originName = link.name;\n                //$scope.originLink = $location.absUrl();\n            })\n        }\n    } else {\n        console.log(\"origin is null\");\n    }\n\n\n    function updateProperties() {\n        if (!$scope.client.attributes) {\n            $scope.client.attributes = {};\n        }\n        $scope.accessType = $scope.accessTypes[0];\n        if ($scope.client.bearerOnly) {\n            $scope.accessType = $scope.accessTypes[2];\n        } else if ($scope.client.publicClient) {\n            $scope.accessType = $scope.accessTypes[1];\n        }\n        if ($scope.client.protocol) {\n            $scope.protocol = $scope.protocols[$scope.protocols.indexOf($scope.client.protocol)];\n        } else {\n            $scope.protocol = $scope.protocols[0];\n        }\n        if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[0];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA256') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[1];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA256_MGF1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[2];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA512') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[3];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA512_MGF1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[4];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'DSA_SHA1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[5];\n        }\n        if ($scope.client.attributes['saml_name_id_format'] == 'username') {\n            $scope.nameIdFormat = $scope.nameIdFormats[0];\n        } else if ($scope.client.attributes['saml_name_id_format'] == 'email') {\n            $scope.nameIdFormat = $scope.nameIdFormats[1];\n        } else if ($scope.client.attributes['saml_name_id_format'] == 'transient') {\n            $scope.nameIdFormat = $scope.nameIdFormats[2];\n        } else if ($scope.client.attributes['saml_name_id_format'] == 'persistent') {\n            $scope.nameIdFormat = $scope.nameIdFormats[3];\n        }\n\n\n        if ($scope.client.attributes[\"saml.artifact.binding\"]) {\n            if ($scope.client.attributes[\"saml.artifact.binding\"] == \"true\") {\n                $scope.samlArtifactBinding = true;\n            } else {\n                $scope.samlArtifactBinding = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"saml.server.signature\"]) {\n            if ($scope.client.attributes[\"saml.server.signature\"] == \"true\") {\n                $scope.samlServerSignature = true;\n            } else {\n                $scope.samlServerSignature = false;\n\n            }\n        }\n        if ($scope.client.attributes[\"saml.server.signature.keyinfo.ext\"]) {\n            if ($scope.client.attributes[\"saml.server.signature.keyinfo.ext\"] == \"true\") {\n                $scope.samlServerSignatureEnableKeyInfoExtension = true;\n            } else {\n                $scope.samlServerSignatureEnableKeyInfoExtension = false;\n            }\n        }\n        if ($scope.client.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] === 'NONE') {\n            $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[0];\n        } else if ($scope.client.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] === 'KEY_ID') {\n            $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[1];\n        } else if ($scope.client.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] === 'CERT_SUBJECT') {\n            $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[2];\n        }\n        if ($scope.client.attributes[\"saml.assertion.signature\"]) {\n            if ($scope.client.attributes[\"saml.assertion.signature\"] == \"true\") {\n                $scope.samlAssertionSignature = true;\n            } else {\n                $scope.samlAssertionSignature = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.client.signature\"]) {\n            if ($scope.client.attributes[\"saml.client.signature\"] == \"true\") {\n                $scope.samlClientSignature = true;\n            } else {\n                $scope.samlClientSignature = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.encrypt\"]) {\n            if ($scope.client.attributes[\"saml.encrypt\"] == \"true\") {\n                $scope.samlEncrypt = true;\n            } else {\n                $scope.samlEncrypt = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.authnstatement\"]) {\n            if ($scope.client.attributes[\"saml.authnstatement\"] == \"true\") {\n                $scope.samlAuthnStatement = true;\n            } else {\n                $scope.samlAuthnStatement = false;\n            }\n        }\n         if ($scope.client.attributes[\"saml.onetimeuse.condition\"]) {\n                    if ($scope.client.attributes[\"saml.onetimeuse.condition\"] == \"true\") {\n                        $scope.samlOneTimeUseCondition = true;\n                    } else {\n                        $scope.samlOneTimeUseCondition = false;\n                    }\n                }\n        if ($scope.client.attributes[\"saml_force_name_id_format\"]) {\n            if ($scope.client.attributes[\"saml_force_name_id_format\"] == \"true\") {\n                $scope.samlForceNameIdFormat = true;\n            } else {\n                $scope.samlForceNameIdFormat = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.multivalued.roles\"]) {\n            if ($scope.client.attributes[\"saml.multivalued.roles\"] == \"true\") {\n                $scope.samlMultiValuedRoles = true;\n            } else {\n                $scope.samlMultiValuedRoles = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.force.post.binding\"]) {\n            if ($scope.client.attributes[\"saml.force.post.binding\"] == \"true\") {\n                $scope.samlForcePostBinding = true;\n            } else {\n                $scope.samlForcePostBinding = false;\n            }\n        }\n\n        $scope.accessTokenSignedResponseAlg = $scope.client.attributes['access.token.signed.response.alg'];\n        $scope.idTokenSignedResponseAlg = $scope.client.attributes['id.token.signed.response.alg'];\n        $scope.idTokenEncryptedResponseAlg = $scope.client.attributes['id.token.encrypted.response.alg'];\n        $scope.idTokenEncryptedResponseEnc = $scope.client.attributes['id.token.encrypted.response.enc'];\n        $scope.authorizationSignedResponseAlg = $scope.client.attributes['authorization.signed.response.alg'];\n        $scope.authorizationEncryptedResponseAlg = $scope.client.attributes['authorization.encrypted.response.alg'];\n        $scope.authorizationEncryptedResponseEnc = $scope.client.attributes['authorization.encrypted.response.enc'];\n\n        var attrVal1 = $scope.client.attributes['user.info.response.signature.alg'];\n        $scope.userInfoSignedResponseAlg = attrVal1==null ? 'unsigned' : attrVal1;\n\n        var attrVal2 = $scope.client.attributes['request.object.signature.alg'];\n        $scope.requestObjectSignatureAlg = attrVal2==null ? 'any' : attrVal2;\n\n        var attrVal3 = $scope.client.attributes['request.object.required'];\n        $scope.requestObjectRequired = attrVal3==null ? 'not required' : attrVal3;\n\n        var attrVal4 = $scope.client.attributes['pkce.code.challenge.method'];\n        $scope.pkceCodeChallengeMethod = attrVal4==null ? 'none' : attrVal4;\n\n        var attrVal5 = $scope.client.attributes['ciba.backchannel.auth.request.signing.alg'];\n        $scope.cibaBackchannelAuthRequestSigningAlg = attrVal5==null ? 'none' : attrVal5;\n\n        var attrVal6 = $scope.client.attributes['request.object.encryption.alg'];\n        $scope.requestObjectEncryptionAlg = attrVal6==null ? 'any' : attrVal6;\n\n        var attrVal7 = $scope.client.attributes['request.object.encryption.enc'];\n        $scope.requestObjectEncryptionEnc = attrVal7==null ? 'any' : attrVal7;\n\n        var attrVal8 = $scope.client.attributes['ciba.backchannel.auth.request.signing.alg'];\n        $scope.cibaBackchannelAuthRequestSigningAlg = attrVal8==null ? 'any' : attrVal8;\n\n        if ($scope.client.attributes[\"exclude.session.state.from.auth.response\"]) {\n            if ($scope.client.attributes[\"exclude.session.state.from.auth.response\"] == \"true\") {\n                $scope.excludeSessionStateFromAuthResponse = true;\n            } else {\n                $scope.excludeSessionStateFromAuthResponse = false;\n            }\n        }\n\n       if ($scope.client.attributes[\"oauth2.device.authorization.grant.enabled\"]) {\n           if ($scope.client.attributes[\"oauth2.device.authorization.grant.enabled\"] == \"true\") {\n               $scope.oauth2DeviceAuthorizationGrantEnabled = true;\n           } else {\n               $scope.oauth2DeviceAuthorizationGrantEnabled = false;\n           }\n       }\n\n       if ($scope.client.attributes[\"oidc.ciba.grant.enabled\"]) {\n           if ($scope.client.attributes[\"oidc.ciba.grant.enabled\"] == \"true\") {\n               $scope.oidcCibaGrantEnabled = true;\n           } else {\n               $scope.oidcCibaGrantEnabled = false;\n           }\n       }\n\n       $scope.cibaBackchannelTokenDeliveryMode = $scope.client.attributes['ciba.backchannel.token.delivery.mode'];\n\n       if ($scope.client.attributes[\"use.refresh.tokens\"]) {\n           if ($scope.client.attributes[\"use.refresh.tokens\"] == \"true\") {\n               $scope.useRefreshTokens = true;\n           } else {\n               $scope.useRefreshTokens = false;\n           }\n       }\n\n       if ($scope.client.attributes[\"id.token.as.detached.signature\"]) {\n           if ($scope.client.attributes[\"id.token.as.detached.signature\"] == \"true\") {\n               $scope.useIdTokenAsDetachedSignature = true;\n           } else {\n               $scope.useIdTokenAsDetachedSignature = false;\n           }\n       }\n\n        // KEYCLOAK-6771 Certificate Bound Token\n        // https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\n       if ($scope.client.attributes[\"tls.client.certificate.bound.access.tokens\"]) {\n           if ($scope.client.attributes[\"tls.client.certificate.bound.access.tokens\"] == \"true\") {\n               $scope.tlsClientCertificateBoundAccessTokens = true;\n           } else {\n               $scope.tlsClientCertificateBoundAccessTokens = false;\n           }\n       }\n\n        // PAR request.\n        if ($scope.client.attributes[\"require.pushed.authorization.requests\"]) {\n            if ($scope.client.attributes[\"require.pushed.authorization.requests\"] == \"true\") {\n                $scope.requirePushedAuthorizationRequests = true;\n            } else {\n                $scope.requirePushedAuthorizationRequests = false;\n            }\n        }\n\n        var useRefreshToken = $scope.client.attributes[\"client_credentials.use_refresh_token\"];\n        if (useRefreshToken === \"true\") {\n            $scope.useRefreshTokenForClientCredentialsGrant = true;\n        } else {\n            $scope.useRefreshTokenForClientCredentialsGrant = false;\n        }\n\n        var useLowerCaseBearerTypeInTokenResponse = $scope.client.attributes[\"token.response.type.bearer.lower-case\"];\n        if (useLowerCaseBearerTypeInTokenResponse === \"true\") {\n            $scope.useLowerCaseBearerTypeInTokenResponse = true;\n        } else {\n            $scope.useLowerCaseBearerTypeInTokenResponse = false;\n        }\n\n        if ($scope.client.attributes[\"display.on.consent.screen\"]) {\n            if ($scope.client.attributes[\"display.on.consent.screen\"] == \"true\") {\n                $scope.displayOnConsentScreen = true;\n            } else {\n                $scope.displayOnConsentScreen = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"backchannel.logout.session.required\"]) {\n            if ($scope.client.attributes[\"backchannel.logout.session.required\"] == \"true\") {\n                $scope.backchannelLogoutSessionRequired = true;\n            } else {\n                $scope.backchannelLogoutSessionRequired = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"backchannel.logout.revoke.offline.tokens\"]) {\n            if ($scope.client.attributes[\"backchannel.logout.revoke.offline.tokens\"] == \"true\") {\n                $scope.backchannelLogoutRevokeOfflineSessions = true;\n            } else {\n                $scope.backchannelLogoutRevokeOfflineSessions = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"frontchannel.logout.session.required\"]) {\n            if ($scope.client.attributes[\"frontchannel.logout.session.required\"] == \"true\") {\n                $scope.frontchannelLogoutSessionRequired = true;\n            } else {\n                $scope.frontchannelLogoutSessionRequired = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"request.uris\"] && $scope.client.attributes[\"request.uris\"].length > 0) {\n            $scope.client.requestUris = $scope.client.attributes[\"request.uris\"].split(\"##\");\n        } else {\n            $scope.client.requestUris = [];\n        }\n\n        if ($scope.client.attributes[\"default.acr.values\"] && $scope.client.attributes[\"default.acr.values\"].length > 0) {\n            $scope.defaultAcrValues = $scope.client.attributes[\"default.acr.values\"].split(\"##\");\n        } else {\n            $scope.defaultAcrValues = [];\n        }\n        deletedSomeDefaultAcrValue = false;\n\n        try {\n          $scope.acrLoaMap = JSON.parse($scope.client.attributes[\"acr.loa.map\"] || \"{}\");\n        } catch (e) {\n          $scope.acrLoaMap = {};\n        }\n    }\n\n    if (!$scope.create) {\n        $scope.client = client;\n        updateProperties();\n\n        $scope.clientEdit = angular.copy(client);\n    }\n\n\n    $scope.samlIdpInitiatedUrl = function(ssoName) {\n        return encodeURI($location.absUrl().replace(/\\/admin.*/, \"/realms/\") + realm.realm + \"/protocol/saml/clients/\") + encodeURIComponent(ssoName)\n    }\n\n    $scope.importFile = function(fileContent){\n        console.debug(fileContent);\n        ClientDescriptionConverter.save({\n            realm: realm.realm\n        }, fileContent, function (data) {\n            $scope.client = data;\n            updateProperties();\n            $scope.importing = true;\n\n            $scope.clientEdit = angular.copy(client);\n        });\n    };\n\n    $scope.viewImportDetails = function() {\n        $modal.open({\n            templateUrl: resourceUrl + '/partials/modal/view-object.html',\n            controller: 'ObjectModalCtrl',\n            resolve: {\n                object: function () {\n                    return $scope.client;\n                }\n            }\n        })\n    };\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.changeAccessType = function() {\n        if ($scope.accessType == \"confidential\") {\n            $scope.clientEdit.bearerOnly = false;\n            $scope.clientEdit.publicClient = false;\n        } else if ($scope.accessType == \"public\") {\n            $scope.clientEdit.bearerOnly = false;\n            $scope.clientEdit.publicClient = true;\n        } else if ($scope.accessType == \"bearer-only\") {\n            $scope.clientEdit.bearerOnly = true;\n            $scope.clientEdit.publicClient = false;\n            $scope.clientEdit.alwaysDisplayInConsole = false;\n        }\n    };\n\n    $scope.changeProtocol = function() {\n        if ($scope.protocol == \"openid-connect\") {\n            $scope.clientEdit.protocol = \"openid-connect\";\n        } else if ($scope.protocol == \"saml\") {\n            $scope.clientEdit.protocol = \"saml\";\n        }\n    };\n\n    $scope.changeAlgorithm = function() {\n        $scope.clientEdit.attributes['saml.signature.algorithm'] = $scope.signatureAlgorithm;\n    };\n\n    $scope.changeNameIdFormat = function() {\n        $scope.clientEdit.attributes['saml_name_id_format'] = $scope.nameIdFormat;\n    };\n\n    $scope.changeSamlSigKeyNameTranformer = function() {\n        $scope.clientEdit.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] = $scope.samlXmlKeyNameTranformer;\n    };\n\n    $scope.changeAccessTokenSignedResponseAlg = function() {\n        $scope.clientEdit.attributes['access.token.signed.response.alg'] = $scope.accessTokenSignedResponseAlg;\n    };\n\n    $scope.changeIdTokenSignedResponseAlg = function() {\n        $scope.clientEdit.attributes['id.token.signed.response.alg'] = $scope.idTokenSignedResponseAlg;\n    };\n\n    $scope.changeIdTokenEncryptedResponseAlg = function() {\n        $scope.clientEdit.attributes['id.token.encrypted.response.alg'] = $scope.idTokenEncryptedResponseAlg;\n    };\n\n    $scope.changeIdTokenEncryptedResponseEnc = function() {\n        $scope.clientEdit.attributes['id.token.encrypted.response.enc'] = $scope.idTokenEncryptedResponseEnc;\n    };\n\n    $scope.changeUserInfoSignedResponseAlg = function() {\n        if ($scope.userInfoSignedResponseAlg === 'unsigned') {\n            $scope.clientEdit.attributes['user.info.response.signature.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['user.info.response.signature.alg'] = $scope.userInfoSignedResponseAlg;\n        }\n    };\n\n    $scope.changeRequestObjectSignatureAlg = function() {\n        if ($scope.requestObjectSignatureAlg === 'any') {\n            $scope.clientEdit.attributes['request.object.signature.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.signature.alg'] = $scope.requestObjectSignatureAlg;\n        }\n    };\n\n    $scope.changeRequestObjectRequired = function() {\n        if ($scope.requestObjectRequired === 'not required') {\n            $scope.clientEdit.attributes['request.object.required'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.required'] = $scope.requestObjectRequired;\n        }\n    };\n\n    $scope.changeRequestObjectEncryptionAlg = function() {\n        if ($scope.requestObjectEncryptionAlg === 'any') {\n            $scope.clientEdit.attributes['request.object.encryption.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.encryption.alg'] = $scope.requestObjectEncryptionAlg;\n        }\n    };\n\n    $scope.changeRequestObjectEncryptionEnc = function() {\n        if ($scope.requestObjectEncryptionEnc === 'any') {\n            $scope.clientEdit.attributes['request.object.encryption.enc'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.encryption.enc'] = $scope.requestObjectEncryptionEnc;\n        }\n    };\n\n    $scope.changePkceCodeChallengeMethod = function() {\n        $scope.clientEdit.attributes['pkce.code.challenge.method'] = $scope.pkceCodeChallengeMethod;\n    };\n\n    $scope.$watch('newAcr', function() {\n            $scope.changed = isChanged();\n        }, true);\n    $scope.$watch('newLoa', function() {\n            $scope.changed = isChanged();\n        }, true);\n    $scope.deleteAcrLoaMapping = function(acr) {\n        delete $scope.acrLoaMap[acr];\n        $scope.changed = true;\n    }\n    $scope.addAcrLoaMapping = function() {\n        if ($scope.newLoa.match(/^[0-9]+$/)) {\n            $scope.acrLoaMap[$scope.newAcr] = $scope.newLoa;\n            $scope.newAcr = $scope.newLoa = \"\";\n            $scope.changed = true;\n        }\n    }\n\n    $scope.changeCibaBackchannelAuthRequestSigningAlg = function() {\n        if ($scope.cibaBackchannelAuthRequestSigningAlg === 'any') {\n            $scope.clientEdit.attributes['ciba.backchannel.auth.request.signing.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['ciba.backchannel.auth.request.signing.alg'] = $scope.cibaBackchannelAuthRequestSigningAlg;\n        }\n    };\n\n    $scope.changeCibaBackchannelTokenDeliveryMode = function() {\n        $scope.clientEdit.attributes['ciba.backchannel.token.delivery.mode'] = $scope.cibaBackchannelTokenDeliveryMode;\n    };\n\n    $scope.changeAuthorizationSignedResponseAlg = function() {\n        $scope.clientEdit.attributes['authorization.signed.response.alg'] = $scope.authorizationSignedResponseAlg;\n    };\n\n    $scope.changeAuthorizationEncryptedResponseAlg = function() {\n        $scope.clientEdit.attributes['authorization.encrypted.response.alg'] = $scope.authorizationEncryptedResponseAlg;\n    };\n\n    $scope.changeAuthorizationEncryptedResponseEnc = function() {\n        $scope.clientEdit.attributes['authorization.encrypted.response.enc'] = $scope.authorizationEncryptedResponseEnc;\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    function isChanged() {\n        if (!angular.equals($scope.client, $scope.clientEdit)) {\n            return true;\n        }\n        if ($scope.newRedirectUri && $scope.newRedirectUri.length > 0) {\n            return true;\n        }\n        if ($scope.newWebOrigin && $scope.newWebOrigin.length > 0) {\n            return true;\n        }\n        if ($scope.newRequestUri && $scope.newRequestUri.length > 0) {\n            return true;\n        }\n        if ($scope.newDefaultAcrValue && $scope.newDefaultAcrValue.length > 0) {\n            return true;\n        }\n        if (deletedSomeDefaultAcrValue) return true;\n        if ($scope.newAcr && $scope.newAcr.length > 0 && $scope.newLoa && $scope.newLoa.length > 0) {\n            return true;\n        }\n        return false;\n    }\n\n    $scope.updateTimeouts = function() {\n        if ($scope.accessTokenLifespan.time) {\n            if ($scope.accessTokenLifespan.time === -1) {\n                $scope.clientEdit.attributes['access.token.lifespan'] = -1;\n            } else {\n                $scope.clientEdit.attributes['access.token.lifespan'] = $scope.accessTokenLifespan.toSeconds();\n            }\n        } else {\n            $scope.clientEdit.attributes['access.token.lifespan'] = null;\n        }\n    }\n\n    $scope.updateAssertionLifespan = function() {\n        if ($scope.samlAssertionLifespan.time) {\n            $scope.clientEdit.attributes['saml.assertion.lifespan'] = $scope.samlAssertionLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['saml.assertion.lifespan'] = null;\n        }\n    }\n\n    $scope.updateClientSessionIdleTimeout = function() {\n        if ($scope.clientSessionIdleTimeout.time) {\n            $scope.clientEdit.attributes['client.session.idle.timeout'] = $scope.clientSessionIdleTimeout.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.session.idle.timeout'] = null;\n        }\n    }\n\n    $scope.updateClientSessionMaxLifespan = function() {\n        if ($scope.clientSessionMaxLifespan.time) {\n            $scope.clientEdit.attributes['client.session.max.lifespan'] = $scope.clientSessionMaxLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.session.max.lifespan'] = null;\n        }\n    }\n\n    $scope.updateClientOfflineSessionIdleTimeout = function() {\n        if ($scope.clientOfflineSessionIdleTimeout.time) {\n            $scope.clientEdit.attributes['client.offline.session.idle.timeout'] = $scope.clientOfflineSessionIdleTimeout.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.offline.session.idle.timeout'] = null;\n        }\n    }\n\n    $scope.updateClientOfflineSessionMaxLifespan = function() {\n        if ($scope.clientOfflineSessionMaxLifespan.time) {\n            $scope.clientEdit.attributes['client.offline.session.max.lifespan'] = $scope.clientOfflineSessionMaxLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.offline.session.max.lifespan'] = null;\n        }\n    }\n\n    $scope.updateOauth2DeviceCodeLifespan = function() {\n        if ($scope.oauth2DeviceCodeLifespan.time) {\n            $scope.clientEdit.attributes['oauth2.device.code.lifespan'] = $scope.oauth2DeviceCodeLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['oauth2.device.code.lifespan'] = null;\n        }\n    }\n\n    $scope.updateOauth2DevicePollingInterval = function() {\n        if ($scope.oauth2DevicePollingInterval) {\n            $scope.clientEdit.attributes['oauth2.device.polling.interval'] = $scope.oauth2DevicePollingInterval;\n        } else {\n            $scope.clientEdit.attributes['oauth2.device.polling.interval'] = null;\n        }\n    }\n\n    $scope.confirmChangeAuthzSettings = function($event) {\n        if ($scope.client.authorizationServicesEnabled && $scope.clientEdit.authorizationServicesEnabled) {\n            $event.preventDefault();\n            Dialog.confirm(\"Disable Authorization Settings\", \"Are you sure you want to disable authorization ? Once you save your changes, all authorization settings associated with this client will be removed. This operation can not be reverted.\", function () {\n                $scope.clientEdit.authorizationServicesEnabled = false;\n            }, function () {\n                $scope.clientEdit.authorizationServicesEnabled = true;\n            });\n        }\n    }\n\n    function configureAuthorizationServices() {\n        if ($scope.clientEdit.authorizationServicesEnabled) {\n            if ($scope.accessType == 'public') {\n                $scope.accessType = 'confidential';\n            }\n            $scope.clientEdit.publicClient = false;\n            $scope.clientEdit.serviceAccountsEnabled = true;\n        } else if ($scope.clientEdit.bearerOnly) {\n            $scope.clientEdit.serviceAccountsEnabled = false;\n        }\n    }\n\n    $scope.$watch('clientEdit', function() {\n        $scope.changed = isChanged();\n        configureAuthorizationServices();\n    }, true);\n\n    $scope.$watch('newRedirectUri', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n\n    $scope.$watch('newWebOrigin', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.$watch('newRequestUri', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.$watch('newDefaultAcrValue', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.deleteWebOrigin = function(index) {\n        $scope.clientEdit.webOrigins.splice(index, 1);\n    }\n    $scope.addWebOrigin = function() {\n        $scope.clientEdit.webOrigins.push($scope.newWebOrigin);\n        $scope.newWebOrigin = \"\";\n    }\n    $scope.deleteRequestUri = function(index) {\n        $scope.clientEdit.requestUris.splice(index, 1);\n    }\n    $scope.addRequestUri = function() {\n        $scope.clientEdit.requestUris.push($scope.newRequestUri);\n        $scope.newRequestUri = \"\";\n    }\n    $scope.deleteDefaultAcrValue = function(index) {\n        $scope.defaultAcrValues.splice(index, 1);\n        deletedSomeDefaultAcrValue = true;\n        $scope.changed = isChanged();\n    }\n    $scope.addDefaultAcrValue = function() {\n        $scope.defaultAcrValues.push($scope.newDefaultAcrValue);\n        $scope.newDefaultAcrValue = \"\";\n    }\n    $scope.deleteRedirectUri = function(index) {\n        $scope.clientEdit.redirectUris.splice(index, 1);\n    }\n\n    $scope.addRedirectUri = function() {\n        $scope.clientEdit.redirectUris.push($scope.newRedirectUri);\n        $scope.newRedirectUri = \"\";\n    }\n\n    $scope.save = function() {\n        if ($scope.newRedirectUri && $scope.newRedirectUri.length > 0) {\n            $scope.addRedirectUri();\n        }\n\n        if ($scope.newWebOrigin && $scope.newWebOrigin.length > 0) {\n            $scope.addWebOrigin();\n        }\n\n        if ($scope.newRequestUri && $scope.newRequestUri.length > 0) {\n            $scope.addRequestUri();\n        }\n        if ($scope.clientEdit.requestUris && $scope.clientEdit.requestUris.length > 0) {\n            $scope.clientEdit.attributes[\"request.uris\"] = $scope.clientEdit.requestUris.join(\"##\");\n        } else {\n            $scope.clientEdit.attributes[\"request.uris\"] = null;\n        }\n        if (!$scope.clientEdit.frontchannelLogout) {\n            $scope.clientEdit.attributes[\"frontchannel.logout.url\"] = null;\n        }\n        delete $scope.clientEdit.requestUris;\n\n        if ($scope.newDefaultAcrValue && $scope.newDefaultAcrValue.length > 0) {\n            $scope.addDefaultAcrValue();\n        }\n        if ($scope.defaultAcrValues && $scope.defaultAcrValues.length > 0) {\n            $scope.clientEdit.attributes[\"default.acr.values\"] = $scope.defaultAcrValues.join(\"##\");\n        } else {\n            $scope.clientEdit.attributes[\"default.acr.values\"] = null;\n        }\n\n        if ($scope.samlArtifactBinding == true) {\n            $scope.clientEdit.attributes[\"saml.artifact.binding\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.artifact.binding\"] = \"false\";\n        }\n\n        if ($scope.newAcr && $scope.newAcr.length > 0 && $scope.newLoa && $scope.newLoa.length > 0) {\n          $scope.addAcrLoaMapping();\n        }\n\n        if ($scope.samlServerSignature == true) {\n            $scope.clientEdit.attributes[\"saml.server.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.server.signature\"] = \"false\";\n        }\n        if ($scope.samlServerSignatureEnableKeyInfoExtension == true) {\n            $scope.clientEdit.attributes[\"saml.server.signature.keyinfo.ext\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.server.signature.keyinfo.ext\"] = \"false\";\n        }\n        if ($scope.samlAssertionSignature == true) {\n            $scope.clientEdit.attributes[\"saml.assertion.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.assertion.signature\"] = \"false\";\n        }\n        if ($scope.samlClientSignature == true) {\n            $scope.clientEdit.attributes[\"saml.client.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.client.signature\"] = \"false\";\n\n        }\n        if ($scope.samlEncrypt == true) {\n            $scope.clientEdit.attributes[\"saml.encrypt\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.encrypt\"] = \"false\";\n\n        }\n        if ($scope.samlAuthnStatement == true) {\n            $scope.clientEdit.attributes[\"saml.authnstatement\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.authnstatement\"] = \"false\";\n\n        }\n        if ($scope.samlOneTimeUseCondition == true) {\n                    $scope.clientEdit.attributes[\"saml.onetimeuse.condition\"] = \"true\";\n                } else {\n                    $scope.clientEdit.attributes[\"saml.onetimeuse.condition\"] = \"false\";\n\n                }\n        if ($scope.samlForceNameIdFormat == true) {\n            $scope.clientEdit.attributes[\"saml_force_name_id_format\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml_force_name_id_format\"] = \"false\";\n\n        }\n        if ($scope.samlMultiValuedRoles == true) {\n            $scope.clientEdit.attributes[\"saml.multivalued.roles\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.multivalued.roles\"] = \"false\";\n\n        }\n        if ($scope.samlForcePostBinding == true) {\n            $scope.clientEdit.attributes[\"saml.force.post.binding\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.force.post.binding\"] = \"false\";\n\n        }\n\n        if ($scope.excludeSessionStateFromAuthResponse == true) {\n            $scope.clientEdit.attributes[\"exclude.session.state.from.auth.response\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"exclude.session.state.from.auth.response\"] = \"false\";\n\n        }\n\n        if ($scope.oauth2DeviceAuthorizationGrantEnabled == true) {\n            $scope.clientEdit.attributes[\"oauth2.device.authorization.grant.enabled\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"oauth2.device.authorization.grant.enabled\"] = \"false\";\n        }\n\n        if ($scope.oidcCibaGrantEnabled == true) {\n            $scope.clientEdit.attributes[\"oidc.ciba.grant.enabled\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"oidc.ciba.grant.enabled\"] = \"false\";\n        }\n\n        if ($scope.useRefreshTokens == true) {\n            $scope.clientEdit.attributes[\"use.refresh.tokens\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"use.refresh.tokens\"] = \"false\";\n        }\n\n        if ($scope.useIdTokenAsDetachedSignature == true) {\n            $scope.clientEdit.attributes[\"id.token.as.detached.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"id.token.as.detached.signature\"] = \"false\";\n        }\n\n        // KEYCLOAK-6771 Certificate Bound Token\n        // https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\n        if ($scope.tlsClientCertificateBoundAccessTokens == true) {\n            $scope.clientEdit.attributes[\"tls.client.certificate.bound.access.tokens\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"tls.client.certificate.bound.access.tokens\"] = \"false\";\n        }\n\n        // PAR request.\n        if ($scope.requirePushedAuthorizationRequests == true) {\n            $scope.clientEdit.attributes[\"require.pushed.authorization.requests\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"require.pushed.authorization.requests\"] = \"false\";\n        }\n\n        // KEYCLOAK-9551 Client Credentials Grant generates refresh token\n        // https://tools.ietf.org/html/rfc6749#section-4.4.3\n        if ($scope.useRefreshTokenForClientCredentialsGrant === true) {\n            $scope.clientEdit.attributes[\"client_credentials.use_refresh_token\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"client_credentials.use_refresh_token\"] = \"false\";\n        }\n\n        if ($scope.useLowerCaseBearerTypeInTokenResponse === true) {\n            $scope.clientEdit.attributes[\"token.response.type.bearer.lower-case\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"token.response.type.bearer.lower-case\"] = \"false\";\n        }\n\n        if ($scope.displayOnConsentScreen == true) {\n            $scope.clientEdit.attributes[\"display.on.consent.screen\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"display.on.consent.screen\"] = \"false\";\n        }\n\n        if ($scope.backchannelLogoutSessionRequired == true) {\n            $scope.clientEdit.attributes[\"backchannel.logout.session.required\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"backchannel.logout.session.required\"] = \"false\";\n        }\n\n        if ($scope.backchannelLogoutRevokeOfflineSessions == true) {\n            $scope.clientEdit.attributes[\"backchannel.logout.revoke.offline.tokens\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"backchannel.logout.revoke.offline.tokens\"] = \"false\";\n        }\n\n        if ($scope.frontchannelLogoutSessionRequired == true) {\n            $scope.clientEdit.attributes[\"frontchannel.logout.session.required\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"frontchannel.logout.session.required\"] = \"false\";\n        }\n\n        $scope.clientEdit.attributes[\"acr.loa.map\"] = JSON.stringify($scope.acrLoaMap);\n\n        $scope.clientEdit.protocol = $scope.protocol;\n        $scope.clientEdit.attributes['saml.signature.algorithm'] = $scope.signatureAlgorithm;\n        $scope.clientEdit.attributes['saml_name_id_format'] = $scope.nameIdFormat;\n\n        if ($scope.clientEdit.protocol != 'saml' && !$scope.clientEdit.bearerOnly && ($scope.clientEdit.standardFlowEnabled || $scope.clientEdit.implicitFlowEnabled) && (!$scope.clientEdit.redirectUris || $scope.clientEdit.redirectUris.length == 0)) {\n            Notifications.error(\"You must specify at least one redirect uri\");\n        } else {\n            Client.update({\n                realm : realm.realm,\n                client : client.id\n            }, $scope.clientEdit, function() {\n                $route.reload();\n                Notifications.success(\"Your changes have been saved to the client.\");\n            });\n        }\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients\");\n    };\n});\n\nmodule.controller('CreateClientCtrl', function($scope, realm, client, $route, serverInfo, Client, ClientDescriptionConverter, $location, $modal, Dialog, Notifications) {\n    $scope.protocols = serverInfo.listProviderIds('login-protocol');\n    $scope.create = true;\n\n    $scope.realm = realm;\n\n    $scope.client = {\n        enabled: true,\n        attributes: {}\n    };\n    $scope.client.redirectUris = [];\n    $scope.protocol = $scope.protocols[0];\n\n\n    $scope.importFile = function(fileContent){\n        console.debug(fileContent);\n        ClientDescriptionConverter.save({\n            realm: realm.realm\n        }, fileContent, function (data) {\n            $scope.client = data;\n            if (data.protocol) {\n                $scope.protocol = data.protocol;\n            }\n            $scope.importing = true;\n        });\n    };\n\n    $scope.viewImportDetails = function() {\n        $modal.open({\n            templateUrl: resourceUrl + '/partials/modal/view-object.html',\n            controller: 'ObjectModalCtrl',\n            resolve: {\n                object: function () {\n                    return $scope.client;\n                }\n            }\n        })\n    };\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.changeProtocol = function() {\n        if ($scope.protocol == \"openid-connect\") {\n            $scope.client.protocol = \"openid-connect\";\n        } else if ($scope.protocol == \"saml\") {\n            $scope.client.protocol = \"saml\";\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    function isChanged() {\n        if (!angular.equals($scope.client, client)) {\n            return true;\n        }\n        return false;\n    }\n\n    $scope.$watch('client', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n\n    $scope.save = function() {\n        $scope.client.protocol = $scope.protocol;\n\n        Client.save({\n            realm: realm.realm,\n            client: ''\n        }, $scope.client, function (data, headers) {\n            $scope.changed = false;\n            var l = headers().location;\n            var id = l.substring(l.lastIndexOf(\"/\") + 1);\n            $location.url(\"/realms/\" + realm.realm + \"/clients/\" + id);\n            Notifications.success(\"The client has been created.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients\");\n    };\n});\n\nmodule.controller('ClientScopeMappingCtrl', function($scope, $http, realm, $route, client, clients, Notifications,\n                                                          Client, ClientScope,\n                                                          ClientRealmScopeMapping, ClientClientScopeMapping, ClientRole,\n                                                          ClientAvailableRealmScopeMapping, ClientAvailableClientScopeMapping,\n                                                          ClientCompositeRealmScopeMapping, ClientCompositeClientScopeMapping) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n    $scope.selectedRealmRoles = [];\n    $scope.selectedRealmMappings = [];\n    $scope.realmMappings = [];\n    $scope.clients = clients;\n    $scope.clientRoles = [];\n    $scope.clientComposite = [];\n    $scope.selectedClientRoles = [];\n    $scope.selectedClientMappings = [];\n    $scope.clientMappings = [];\n    $scope.dummymodel = [];\n\n    $scope.hideRoleSelector = function() {\n       return $scope.client.fullScopeAllowed;\n    }\n\n    $scope.changeFlag = function() {\n        console.log('changeFlag');\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            client = angular.copy($scope.client);\n            updateRealmRoles();\n            Notifications.success(\"Scope mappings updated.\");\n        });\n    }\n\n    \n    $scope.selectedClient = null;\n\n    $scope.selectClient = function(client) {\n        if (!client || !client.id) {\n            $scope.selectedClient = null;\n            return;\n        }\n\n        $scope.selectedClient = client;\n        updateClientRoles();\n    }\n\n    function updateRealmRoles() {\n        $scope.realmRoles = ClientAvailableRealmScopeMapping.query({realm : realm.realm, client : client.id});\n        $scope.realmMappings = ClientRealmScopeMapping.query({realm : realm.realm, client : client.id});\n        $scope.realmComposite = ClientCompositeRealmScopeMapping.query({realm : realm.realm, client : client.id});\n    }\n\n    function updateClientRoles() {\n        if ($scope.selectedClient) {\n            $scope.clientRoles = ClientAvailableClientScopeMapping.query({realm : realm.realm, client : client.id, targetClient : $scope.selectedClient.id});\n            $scope.clientMappings = ClientClientScopeMapping.query({realm : realm.realm, client : client.id, targetClient : $scope.selectedClient.id});\n            $scope.clientComposite = ClientCompositeClientScopeMapping.query({realm : realm.realm, client : client.id, targetClient : $scope.selectedClient.id});\n        } else {\n            $scope.clientRoles = null;\n            $scope.clientMappings = null;\n            $scope.clientComposite = null;\n        }\n    }\n\n    $scope.addRealmRole = function() {\n        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');\n        $scope.selectedRealmRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/scope-mappings/realm',\n            $scope.selectedRealmRolesToAdd).then(function() {\n                updateRealmRoles();\n                $scope.selectedRealmRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteRealmRole = function() {\n        $scope.selectedRealmMappingsToRemove = JSON.parse('[' + $scope.selectedRealmMappings + ']');\n        $scope.selectedRealmMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id +  '/scope-mappings/realm',\n            {data : $scope.selectedRealmMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateRealmRoles();\n                $scope.selectedRealmMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.addClientRole = function() {\n        $scope.selectedClientRolesToAdd = JSON.parse('[' + $scope.selectedClientRoles + ']');\n        $scope.selectedClientRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n                $scope.selectedClientRolesToAdd).then(function () {\n                updateClientRoles();\n                $scope.selectedClientRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteClientRole = function() {\n        $scope.selectedClientMappingsToRemove = JSON.parse('[' + $scope.selectedClientMappings + ']');\n        $scope.selectedClientMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n            {data : $scope.selectedClientMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateClientRoles();\n                $scope.selectedClientMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    clientSelectControl($scope, $route.current.params.realm, Client);\n    updateRealmRoles();\n});\n\nmodule.controller('ClientRevocationCtrl', function($scope, realm, client, Client, ClientPushRevocation, $location, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n\n    var setNotBefore = function() {\n        if ($scope.client.notBefore == 0) {\n            $scope.notBefore = \"None\";\n        } else {\n            $scope.notBefore = new Date($scope.client.notBefore * 1000);\n        }\n    };\n\n    setNotBefore();\n\n    var refresh = function() {\n        Client.get({ realm : realm.realm, client: $scope.client.id }, function(updated) {\n            $scope.client = updated;\n            setNotBefore();\n        })\n\n    };\n\n    $scope.clear = function() {\n        $scope.client.notBefore = 0;\n        Client.update({ realm : realm.realm, client: client.id}, $scope.client, function () {\n            $scope.notBefore = \"None\";\n            Notifications.success('Not Before cleared for client.');\n            refresh();\n        });\n    }\n    $scope.setNotBeforeNow = function() {\n        $scope.client.notBefore = new Date().getTime()/1000;\n        Client.update({ realm : realm.realm, client: $scope.client.id}, $scope.client, function () {\n            Notifications.success('Not Before set for client.');\n            refresh();\n        });\n    }\n    $scope.pushRevocation = function() {\n        ClientPushRevocation.save({realm : realm.realm, client: $scope.client.id}, function (globalReqResult) {\n            var successCount = globalReqResult.successRequests ? globalReqResult.successRequests.length : 0;\n            var failedCount  = globalReqResult.failedRequests ? globalReqResult.failedRequests.length : 0;\n\n            if (successCount==0 && failedCount==0) {\n                Notifications.warn('No push sent. No admin URI configured or no registered cluster nodes available');\n            } else if (failedCount > 0) {\n                var msgStart = successCount>0 ? 'Successfully push notBefore to: ' + globalReqResult.successRequests + ' . ' : '';\n                Notifications.error(msgStart + 'Failed to push notBefore to: ' + globalReqResult.failedRequests + '. Verify availability of failed hosts and try again');\n            } else {\n                Notifications.success('Successfully push notBefore to: ' + globalReqResult.successRequests);\n            }\n        });\n    }\n\n});\n\nmodule.controller('ClientClusteringCtrl', function($scope, client, Client, ClientTestNodesAvailable, ClientClusterNode, realm, $location, $route, Dialog, Notifications, TimeUnit) {\n    $scope.client = client;\n    $scope.realm = realm;\n\n    var oldCopy = angular.copy($scope.client);\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, oldCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    $scope.client.nodeReRegistrationTimeoutUnit = TimeUnit.autoUnit(client.nodeReRegistrationTimeout);\n    $scope.client.nodeReRegistrationTimeout = TimeUnit.toUnit(client.nodeReRegistrationTimeout, $scope.client.nodeReRegistrationTimeoutUnit);\n\n    $scope.save = function() {\n        var clientCopy = angular.copy($scope.client);\n        delete clientCopy['nodeReRegistrationTimeoutUnit'];\n        clientCopy.nodeReRegistrationTimeout = TimeUnit.toSeconds($scope.client.nodeReRegistrationTimeout, $scope.client.nodeReRegistrationTimeoutUnit)\n        Client.update({ realm : realm.realm, client : client.id }, clientCopy, function () {\n            $route.reload();\n            Notifications.success('Your changes have been saved to the client.');\n        });\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.testNodesAvailable = function() {\n        ClientTestNodesAvailable.get({ realm : realm.realm, client : client.id }, function(globalReqResult) {\n            $route.reload();\n\n            var successCount = globalReqResult.successRequests ? globalReqResult.successRequests.length : 0;\n            var failedCount  = globalReqResult.failedRequests ? globalReqResult.failedRequests.length : 0;\n\n            if (successCount==0 && failedCount==0) {\n                Notifications.warn('No requests sent. No admin URI configured or no registered cluster nodes available');\n            } else if (failedCount > 0) {\n                var msgStart = successCount>0 ? 'Successfully verify availability for ' + globalReqResult.successRequests + ' . ' : '';\n                Notifications.error(msgStart + 'Failed to verify availability for: ' + globalReqResult.failedRequests + '. Fix or unregister failed cluster nodes and try again');\n            } else {\n                Notifications.success('Successfully sent requests to: ' + globalReqResult.successRequests);\n            }\n        });\n    };\n\n    if (client.registeredNodes) {\n        var nodeRegistrations = [];\n        for (node in client.registeredNodes) {\n            reg = {\n                host: node,\n                lastRegistration: new Date(client.registeredNodes[node] * 1000)\n            }\n            nodeRegistrations.push(reg);\n        }\n\n        $scope.nodeRegistrations = nodeRegistrations;\n    };\n\n    $scope.removeNode = function(node) {\n        Dialog.confirmDelete(node.host, 'node', function() {\n            ClientClusterNode.remove({ realm : realm.realm, client : client.id , node: node.host }, function() {\n                Notifications.success('Node ' + node.host + ' unregistered successfully.');\n                $route.reload();\n            });\n        });\n    };\n});\n\nmodule.controller('ClientClusteringNodeCtrl', function($scope, client, Client, ClientClusterNode, realm,\n                                                       $location, $routeParams, Notifications, Dialog) {\n    $scope.client = client;\n    $scope.realm = realm;\n    $scope.create = !$routeParams.node;\n\n    $scope.save = function() {\n        ClientClusterNode.save({ realm : realm.realm, client : client.id , node: $scope.node.host }, function() {\n            Notifications.success('Node ' + $scope.node.host + ' registered successfully.');\n            $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/clustering');\n        });\n    }\n\n    $scope.unregisterNode = function() {\n        Dialog.confirmDelete($scope.node.host, 'node', function() {\n            ClientClusterNode.remove({ realm : realm.realm, client : client.id , node: $scope.node.host }, function() {\n                Notifications.success('Node ' + $scope.node.host + ' unregistered successfully.');\n                $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/clustering');\n            });\n        });\n    }\n\n    if ($scope.create) {\n        $scope.node = {}\n        $scope.registered = false;\n    } else {\n        var lastRegTime = client.registeredNodes[$routeParams.node];\n\n        if (lastRegTime) {\n            $scope.registered = true;\n            $scope.node = {\n                host: $routeParams.node,\n                lastRegistration: new Date(lastRegTime * 1000)\n            }\n\n        } else {\n            $scope.registered = false;\n            $scope.node = {\n                host: $routeParams.node\n            }\n        }\n    }\n});\n\nmodule.controller('AddBuiltinProtocolMapperCtrl', function($scope, realm, client, serverInfo,\n                                                            ClientProtocolMappersByProtocol,\n                                                            $http, $location, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n\n\n\n    var updateMappers = function() {\n        var clientMappers = ClientProtocolMappersByProtocol.query({realm : realm.realm, client : client.id, protocol : client.protocol}, function() {\n            var builtinMappers = serverInfo.builtinProtocolMappers[client.protocol];\n            for (var i = 0; i < clientMappers.length; i++) {\n                for (var j = 0; j < builtinMappers.length; j++) {\n                    if (builtinMappers[j].name == clientMappers[i].name\n                        && builtinMappers[j].protocolMapper == clientMappers[i].protocolMapper) {\n                        builtinMappers.splice(j, 1);\n                        break;\n                    }\n                }\n            }\n            $scope.mappers = builtinMappers;\n            for (var i = 0; i < $scope.mappers.length; i++) {\n                $scope.mappers[i].isChecked = false;\n            }\n\n\n        });\n    };\n\n    updateMappers();\n\n    $scope.add = function() {\n        var toAdd = [];\n        for (var i = 0; i < $scope.mappers.length; i++) {\n            if ($scope.mappers[i].isChecked) {\n                delete $scope.mappers[i].isChecked;\n                toAdd.push($scope.mappers[i]);\n            }\n        }\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/protocol-mappers/add-models',\n                   toAdd).then(function() {\n                Notifications.success(\"Mappers added\");\n                $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/mappers');\n            }).catch(function() {\n                Notifications.error(\"Error adding mappers\");\n                $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/mappers');\n            });\n    };\n\n});\n\nmodule.controller('ClientProtocolMapperListCtrl', function($scope, realm, client, serverInfo,\n                                                           Client,\n                                                           ClientProtocolMappersByProtocol, ClientProtocolMapper,\n                                                           $route, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n\n    $scope.changeFlag = function() {\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            client = angular.copy($scope.client);\n            Notifications.success(\"Client updated.\");\n        });\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n    $scope.removeMapper = function(mapper) {\n        console.debug(mapper);\n        Dialog.confirmDelete(mapper.name, 'mapper', function() {\n            ClientProtocolMapper.remove({ realm: realm.realm, client: client.id, id : mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $route.reload();\n            });\n        });\n    };\n\n    $scope.sortMappersByPriority = function(mapper) {\n        return $scope.mapperTypes[mapper.protocolMapper].priority;\n    }\n\n    var updateMappers = function() {\n        $scope.mappers = ClientProtocolMappersByProtocol.query({realm : realm.realm, client : client.id, protocol : client.protocol});\n    };\n\n    updateMappers();\n});\n\nmodule.controller('ClientProtocolMapperCtrl', function($scope, realm, serverInfo, client, clients, mapper, ClientProtocolMapper, Notifications, Dialog, $location) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    /*\n    $scope.client = client;\n    $scope.create = false;\n    $scope.protocol = client.protocol;\n    $scope.mapper = angular.copy(mapper);\n    $scope.changed = false;\n    */\n\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n\n    $scope.model = {\n        realm: realm,\n        client: client,\n        create: false,\n        protocol: client.protocol,\n        mapper: angular.copy(mapper),\n        changed: false\n    };\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    for (var i = 0; i < protocolMappers.length; i++) {\n        if (protocolMappers[i].id === mapper.protocolMapper) {\n            $scope.model.mapperType = protocolMappers[i];\n        }\n    }\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.$watch('model.mapper', function() {\n        if (!angular.equals($scope.model.mapper, mapper)) {\n            $scope.model.changed = true;\n        }\n    }, true);\n\n    $scope.save = function() {\n        ClientProtocolMapper.update({\n            realm : realm.realm,\n            client: client.id,\n            id : $scope.model.mapper.id\n        }, $scope.model.mapper, function() {\n            $scope.model.changed = false;\n            mapper = angular.copy($scope.mapper);\n            $location.url(\"/realms/\" + realm.realm + '/clients/' + client.id + \"/mappers/\" + $scope.model.mapper.id);\n            Notifications.success(\"Your changes have been saved.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.model.mapper = angular.copy(mapper);\n        $scope.model.changed = false;\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n    $scope.remove = function() {\n        Dialog.confirmDelete($scope.model.mapper.name, 'mapper', function() {\n            ClientProtocolMapper.remove({ realm: realm.realm, client: client.id, id : $scope.model.mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $location.url(\"/realms/\" + realm.realm + '/clients/' + client.id + \"/mappers\");\n            });\n        });\n    };\n\n});\n\nmodule.controller('ClientProtocolMapperCreateCtrl', function($scope, realm, serverInfo, client, clients, ClientProtocolMapper, Notifications, Dialog, $location) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n    var protocol = client.protocol;\n    /*\n    $scope.client = client;\n    $scope.create = true;\n    $scope.protocol = protocol;\n    $scope.mapper = { protocol :  client.protocol, config: {}};\n    $scope.mapperTypes = serverInfo.protocolMapperTypes[protocol];\n    */\n    $scope.model = {\n        realm: realm,\n        client: client,\n        create: true,\n        protocol: client.protocol,\n        mapper: { protocol :  client.protocol, config: {}},\n        changed: false,\n        mapperTypes: serverInfo.protocolMapperTypes[protocol]\n    };\n    console.log(\"mapper types: \", $scope.model.mapperTypes);\n\n    // apply default configurations on change for selected protocolmapper type.\n    $scope.$watch('model.mapperType', function() {\n        var currentMapperType = $scope.model.mapperType;\n        var defaultConfig = {};\n\n        if (currentMapperType && Array.isArray(currentMapperType.properties)) {\n            for (var i = 0; i < currentMapperType.properties.length; i++) {\n                var property = currentMapperType.properties[i];\n                if (property && property.name && property.defaultValue) {\n                    defaultConfig[property.name] = property.defaultValue;\n                }\n            }\n        }\n\n        $scope.model.mapper.config = defaultConfig;\n    }, true);\n\n    $scope.model.mapperType = $scope.model.mapperTypes[0];\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.save = function() {\n        $scope.model.mapper.protocolMapper = $scope.model.mapperType.id;\n        ClientProtocolMapper.save({\n            realm : realm.realm, client: client.id\n        }, $scope.model.mapper, function(data, headers) {\n            var l = headers().location;\n            var id = l.substring(l.lastIndexOf(\"/\") + 1);\n            $location.url(\"/realms/\" + realm.realm + '/clients/' + client.id + \"/mappers/\" + id);\n            Notifications.success(\"Mapper has been created.\");\n        });\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n\n});\n\n\nmodule.controller('ClientClientScopesSetupCtrl', function($scope, realm, Realm, client, clientScopes, serverInfo,\n        clientDefaultClientScopes, ClientDefaultClientScopes, clientOptionalClientScopes, ClientOptionalClientScopes, $route, Notifications, $location) {\n    console.log('ClientClientScopesSetupCtrl');\n\n    $scope.realm = realm;\n    $scope.client = client;\n\n    $scope.clientDefaultClientScopes = clientDefaultClientScopes;\n    $scope.clientOptionalClientScopes = clientOptionalClientScopes;\n\n    $scope.availableClientScopes = [];\n    $scope.selectedDefaultClientScopes = [];\n    $scope.selectedDefDefaultClientScopes = [];\n\n    $scope.selectedOptionalClientScopes = [];\n    $scope.selectedDefOptionalClientScopes = [];\n\n    // Populate available client scopes. Available client scopes are neither already assigned to 'default' or 'optional'\n    for (var i = 0; i < clientScopes.length; i++) {\n        var clientScope = clientScopes[i];\n        var scopeName = clientScopes[i].name;\n\n        var available = true;\n        if (clientScope.protocol != client.protocol) {\n            available = false;\n        }\n\n        for (var j = 0; j < $scope.clientDefaultClientScopes.length; j++) {\n            if (scopeName === $scope.clientDefaultClientScopes[j].name) {\n                available = false;\n            }\n        }\n        for (var j = 0; j < $scope.clientOptionalClientScopes.length; j++) {\n            if (scopeName === $scope.clientOptionalClientScopes[j].name) {\n                available = false;\n            }\n        }\n\n        if (available) {\n            $scope.availableClientScopes.push(clientScope);\n        }\n    }\n\n    $scope.addDefaultClientScope = function () {\n        $scope.selectedDefaultClientScopesToAdd = JSON.parse('[' + $scope.selectedDefaultClientScopes + ']');\n        toAdd = $scope.selectedDefaultClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedDefaultClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedDefaultClientScopesToAdd[i];\n\n            ClientDefaultClientScopes.update({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefaultClientScopesToAdd = [];\n    };\n\n    $scope.deleteDefaultClientScope = function () {\n        $scope.selectedDefDefaultClientScopesToRemove = JSON.parse('[' + $scope.selectedDefDefaultClientScopes + ']');\n        toRemove = $scope.selectedDefDefaultClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefDefaultClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefDefaultClientScopesToRemove[i];\n\n            ClientDefaultClientScopes.remove({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefDefaultClientScopesToRemove = [];\n    };\n\n    $scope.addOptionalClientScope = function () {\n        $scope.selectedOptionalClientScopesToAdd = JSON.parse('[' + $scope.selectedOptionalClientScopes + ']');\n        toAdd = $scope.selectedOptionalClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedOptionalClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedOptionalClientScopesToAdd[i];\n\n            ClientOptionalClientScopes.update({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Optional scopes updated.\");\n                }\n            });\n        }\n    };\n\n    $scope.deleteOptionalClientScope = function () {\n        $scope.selectedDefOptionalClientScopesToRemove = JSON.parse('[' + $scope.selectedDefOptionalClientScopes + ']');\n        toRemove = $scope.selectedDefOptionalClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefOptionalClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefOptionalClientScopesToRemove[i];\n\n            ClientOptionalClientScopes.remove({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Optional scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefOptionalClientScopesToRemove = [];\n    };\n\n});\n\nmodule.controller('ClientClientScopesEvaluateCtrl', function($scope, Realm, User, ClientEvaluateProtocolMappers, ClientEvaluateGrantedRoles,\n        ClientEvaluateNotGrantedRoles, ClientEvaluateGenerateExampleAccessToken, ClientEvaluateGenerateExampleIDToken,\n        ClientEvaluateGenerateExampleUserInfo, realm, client, clients, clientScopes, serverInfo, ComponentUtils,\n        clientOptionalClientScopes, clientDefaultClientScopes, $route, $routeParams, $http, Notifications, $location,\n        Client) {\n\n    console.log('ClientClientScopesEvaluateCtrl');\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.clients = clients;\n    $scope.userId = null;\n\n    $scope.availableClientScopes = [];\n    $scope.assignedClientScopes = [];\n    $scope.selectedClientScopes = [];\n    $scope.selectedDefClientScopes = [];\n    $scope.effectiveClientScopes = [];\n\n    // Populate available client scopes. Available client scopes are neither already assigned to 'default' or 'optional'\n    for (var i = 0; i < clientOptionalClientScopes.length; i++) {\n        $scope.availableClientScopes.push(clientOptionalClientScopes[i]);\n    }\n\n    function clearEvalResponse() {\n        $scope.protocolMappers = null;\n        $scope.grantedRealmRoles = null;\n        $scope.notGrantedRealmRoles = null;\n        $scope.grantedClientRoles = null;\n        $scope.notGrantedClientRoles = null;\n        $scope.targetClient = null;\n        $scope.oidcAccessToken = null;\n        $scope.oidcIDToken = null;\n        $scope.oidcUserInfo = null;\n\n        $scope.selectedTab = 0;\n    }\n\n    function updateState() {\n        // Compute scope parameter\n        $scope.scopeParam = 'openid';\n        for (var i = 0; i < $scope.assignedClientScopes.length; i++) {\n            var currentScopeParam = $scope.assignedClientScopes[i].name;\n            $scope.scopeParam = $scope.scopeParam + ' ' + currentScopeParam;\n        }\n\n        // Compute effective scopes\n        $scope.effectiveClientScopes = [];\n\n        for (var i = 0; i < clientDefaultClientScopes.length; i++) {\n            var currentScope = clientDefaultClientScopes[i];\n            $scope.effectiveClientScopes.push(currentScope);\n        }\n        for (var i = 0; i < $scope.assignedClientScopes.length; i++) {\n            var currentScope = $scope.assignedClientScopes[i];\n            $scope.effectiveClientScopes.push(currentScope);\n        }\n\n        // Clear the evaluation response\n        clearEvalResponse();\n    }\n\n    updateState();\n\n\n    $scope.addAppliedClientScope = function () {\n        $scope.selectedClientScopesToAdd = JSON.parse('[' + $scope.selectedClientScopes + ']');\n        for (var i = 0; i < $scope.selectedClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedClientScopesToAdd[i];\n\n            $scope.assignedClientScopes.push(currentScope);\n\n            var index = ComponentUtils.findIndexById($scope.availableClientScopes, currentScope.id);\n            if (index > -1) {\n                $scope.availableClientScopes.splice(index, 1);\n            }\n        }\n\n        $scope.selectedClientScopes = [];\n        $scope.selectedClientScopesToAdd = [];\n        updateState();\n    };\n\n    $scope.deleteAppliedClientScope = function () {\n        $scope.selectedDefClientScopesToRemove = JSON.parse('[' + $scope.selectedDefClientScopes + ']');\n        for (var i = 0; i < $scope.selectedDefClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefClientScopesToRemove[i];\n\n            $scope.availableClientScopes.push(currentScope);\n\n            var index = ComponentUtils.findIndexById($scope.assignedClientScopes, currentScope.id);\n            if (index > -1) {\n                $scope.assignedClientScopes.splice(index, 1);\n            }\n        }\n\n        $scope.selectedDefClientScopes = [];\n        $scope.selectedDefClientScopesToRemove = [];\n\n        updateState();\n    };\n\n    $scope.usersUiSelect = {\n        minimumInputLength: 1,\n        delay: 500,\n        allowClear: true,\n        query: function (query) {\n            var data = {results: []};\n            if ('' == query.term.trim()) {\n                query.callback(data);\n                return;\n            }\n            User.query({realm: $route.current.params.realm, search: query.term.trim(), max: 20}, function(response) {\n                data.results = response;\n                query.callback(data);\n            });\n        },\n        formatResult: function(object, container, query) {\n            object.text = object.username;\n            return object.username;\n        }\n    };\n\n    $scope.selectedUser = null;\n\n    $scope.selectUser = function(user) {\n        clearEvalResponse();\n\n        if (!user || !user.id) {\n            $scope.selectedUser = null;\n            $scope.userId = '';\n            return;\n        }\n\n        $scope.userId = user.id;\n    }\n\n    clientSelectControl($scope, $route.current.params.realm, Client);\n    \n    $scope.selectedClient = null;\n\n    $scope.selectClient = function(client) {\n        console.log(\"selected client: \", client);\n        if (!client || !client.id) {\n            $scope.selectedClient = null;\n            return;\n        }\n\n        $scope.selectedClient = client;\n        updateScopeClientRoles();\n    }\n\n\n    $scope.sendEvaluationRequest = function () {\n\n        // Send request for retrieve protocolMappers\n        $scope.protocolMappers = ClientEvaluateProtocolMappers.query({\n            realm: realm.realm,\n            client: client.id,\n            scopeParam: $scope.scopeParam\n        });\n\n        // Send request for retrieve realmRoles\n        updateScopeRealmRoles();\n\n        // Send request for retrieve accessToken (in case user was selected)\n        if (client.protocol === 'openid-connect' && $scope.userId != null && $scope.userId !== '') {\n            var exampleRequestParams = {\n                realm: realm.realm,\n                client: client.id,\n                userId: $scope.userId,\n                scopeParam: $scope.scopeParam\n            };\n\n            var accessTokenUrl = ClientEvaluateGenerateExampleAccessToken.url(exampleRequestParams);\n            getPrettyJsonResponse(accessTokenUrl).then(function (result) {\n                $scope.oidcAccessToken = result;\n            });\n\n            var idTokenUrl = ClientEvaluateGenerateExampleIDToken.url(exampleRequestParams);\n            getPrettyJsonResponse(idTokenUrl).then(function (result) {\n                $scope.oidcIDToken = result;\n            });\n\n            var userInfoUrl = ClientEvaluateGenerateExampleUserInfo.url(exampleRequestParams);\n            getPrettyJsonResponse(userInfoUrl).then(function (result) {\n                $scope.oidcUserInfo = result;\n            });\n        }\n\n        $scope.showTab(1);\n    };\n\n    function getPrettyJsonResponse(url) {\n        return $http.get(url).then(function (response) {\n            if (response.data) {\n                var responseJson = angular.fromJson(response.data);\n                return angular.toJson(responseJson, true);\n            } else {\n                return null;\n            }\n        });\n    }\n\n    $scope.isResponseAvailable = function () {\n        return $scope.protocolMappers != null;\n    }\n\n    $scope.isAccessTokenAvailable = function () {\n        return $scope.oidcAccessToken != null;\n    }\n\n    $scope.isIDTokenAvailable = function () {\n        return $scope.oidcIDToken != null;\n    }\n\n    $scope.isUserInfoAvailable = function () {\n        return $scope.oidcUserInfo != null;\n    }\n\n    $scope.showTab = function (tab) {\n        $scope.selectedTab = tab;\n\n        $scope.tabCss = {\n            tab1: getTabCssClass(1, tab),\n            tab2: getTabCssClass(2, tab),\n            tab3: getTabCssClass(3, tab),\n            tab4: getTabCssClass(4, tab),\n            tab5: getTabCssClass(5, tab)\n        }\n    }\n\n    function getTabCssClass(tabNo, selectedTab) {\n        return (tabNo === selectedTab) ? 'active' : '';\n    }\n\n    $scope.protocolMappersShown = function () {\n        return $scope.selectedTab === 1;\n    }\n\n    $scope.rolesShown = function () {\n        return $scope.selectedTab === 2;\n    }\n\n    $scope.exampleTabInfo = function() {\n        switch ($scope.selectedTab) {\n            case 3:\n                return { isShown: true, value: $scope.oidcAccessToken}\n            case 4:\n                return { isShown: true, value: $scope.oidcIDToken}\n            case 5:\n                return { isShown: true, value: $scope.oidcUserInfo}\n            default:\n                return { isShown: false, value: null}\n        }\n    }\n\n    $scope.sortMappersByPriority = function(mapper) {\n        return $scope.mapperTypes[mapper.protocolMapper].priority;\n    }\n\n\n    // Roles\n\n    function updateScopeRealmRoles() {\n        $scope.grantedRealmRoles = ClientEvaluateGrantedRoles.query({\n            realm: realm.realm,\n            client: client.id,\n            roleContainer: realm.realm,\n            scopeParam: $scope.scopeParam\n        });\n        $scope.notGrantedRealmRoles = ClientEvaluateNotGrantedRoles.query({\n            realm: realm.realm,\n            client: client.id,\n            roleContainer: realm.realm,\n            scopeParam: $scope.scopeParam\n        });\n    }\n\n    function updateScopeClientRoles() {\n        if ($scope.selectedClient) {\n            $scope.grantedClientRoles = ClientEvaluateGrantedRoles.query({\n                realm: realm.realm,\n                client: client.id,\n                roleContainer: $scope.selectedClient.id,\n                scopeParam: $scope.scopeParam\n            });\n            $scope.notGrantedClientRoles = ClientEvaluateNotGrantedRoles.query({\n                realm: realm.realm,\n                client: client.id,\n                roleContainer: $scope.selectedClient.id,\n                scopeParam: $scope.scopeParam\n            });\n        } else {\n            $scope.grantedClientRoles = null;\n            $scope.notGrantedClientRoles = null;\n        }\n    }\n});\n\n\nmodule.controller('ClientScopeTabCtrl', function(Dialog, $scope, Current, Notifications, $location) {\n    $scope.removeClientScope = function() {\n        Dialog.confirmDelete($scope.clientScope.name, 'client scope', function() {\n            $scope.clientScope.$remove({\n                realm : Current.realm.realm,\n                clientScope : $scope.clientScope.id\n            }, function() {\n                $location.url(\"/realms/\" + Current.realm.realm + \"/client-scopes\");\n                Notifications.success(\"The client scope has been deleted.\");\n            });\n        });\n    };\n});\n\n\n\nmodule.controller('ClientScopeListCtrl', function($scope, realm, clientScopes, ClientScope, serverInfo, $route, Dialog, Notifications, $location) {\n    $scope.realm = realm;\n    $scope.clientScopes = clientScopes;\n\n    $scope.removeClientScope = function(clientScope) {\n        Dialog.confirmDelete(clientScope.name, 'client scope', function() {\n            ClientScope.remove({\n                realm : realm.realm,\n                clientScope : clientScope.id\n            }, function() {\n                $route.reload();\n                Notifications.success(\"The client scope been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('ClientScopesRealmDefaultCtrl', function($scope, realm, Realm, clientScopes, realmDefaultClientScopes, RealmDefaultClientScopes,\n        realmOptionalClientScopes, RealmOptionalClientScopes, serverInfo, $route, Dialog, Notifications, $location) {\n\n    console.log('ClientScopesRealmDefaultCtrl');\n\n    $scope.realm = realm;\n    $scope.realmDefaultClientScopes = realmDefaultClientScopes;\n    $scope.realmOptionalClientScopes = realmOptionalClientScopes;\n\n    $scope.availableClientScopes = [];\n    $scope.selectedDefaultClientScopes = [];\n    $scope.selectedDefDefaultClientScopes = [];\n\n    $scope.selectedOptionalClientScopes = [];\n    $scope.selectedDefOptionalClientScopes = [];\n\n    // Populate available client scopes. Available client scopes are neither already assigned to 'default' or 'optional'\n    for (var i = 0; i < clientScopes.length; i++) {\n        var scopeName = clientScopes[i].name;\n\n        var available = true;\n        for (var j = 0; j < $scope.realmDefaultClientScopes.length; j++) {\n            if (scopeName === $scope.realmDefaultClientScopes[j].name) {\n                available = false;\n            }\n        }\n        for (var j = 0; j < $scope.realmOptionalClientScopes.length; j++) {\n            if (scopeName === $scope.realmOptionalClientScopes[j].name) {\n                available = false;\n            }\n        }\n\n        if (available) {\n            $scope.availableClientScopes.push(clientScopes[i]);\n        }\n    }\n\n    $scope.addDefaultClientScope = function () {\n        $scope.selectedDefaultClientScopesToAdd = JSON.parse('[' + $scope.selectedDefaultClientScopes + ']');\n        toAdd = $scope.selectedDefaultClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedDefaultClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedDefaultClientScopesToAdd[i];\n\n            RealmDefaultClientScopes.update({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                console.log('toAdd: ' + toAdd);\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefaultClientScopesToAdd = [];\n    };\n\n    $scope.deleteDefaultClientScope = function () {\n        $scope.selectedDefDefaultClientScopesToRemove = JSON.parse('[' + $scope.selectedDefDefaultClientScopes + ']');\n        toRemove = $scope.selectedDefDefaultClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefDefaultClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefDefaultClientScopesToRemove[i];\n\n            RealmDefaultClientScopes.remove({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefDefaultClientScopesToRemove = [];\n    };\n\n    $scope.addOptionalClientScope = function () {\n        $scope.selectedOptionalClientScopesToAdd = JSON.parse('[' + $scope.selectedOptionalClientScopes + ']');\n        toAdd = $scope.selectedOptionalClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedOptionalClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedOptionalClientScopesToAdd[i];\n\n            RealmOptionalClientScopes.update({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                console.log('toAdd: ' + toAdd);\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm optional scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedOptionalClientScopesToAdd = [];\n    };\n\n    $scope.deleteOptionalClientScope = function () {\n        $scope.selectedDefOptionalClientScopesToRemove = JSON.parse('[' + $scope.selectedDefOptionalClientScopes + ']');\n        toRemove = $scope.selectedDefOptionalClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefOptionalClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefOptionalClientScopesToRemove[i];\n\n            RealmOptionalClientScopes.remove({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm optional scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefOptionalClientScopesToRemove = [];\n    };\n});\n\nmodule.controller('ClientScopeDetailCtrl', function($scope, realm, clientScope, $route, serverInfo, ClientScope, $location, $modal, Dialog, Notifications) {\n    $scope.protocols = serverInfo.listProviderIds('login-protocol');\n\n    $scope.realm = realm;\n    $scope.create = !clientScope.name;\n\n    function updateProperties() {\n        if (!$scope.clientScope.attributes) {\n            $scope.clientScope.attributes = {};\n        }\n\n        if ($scope.clientScope.protocol) {\n            $scope.protocol = $scope.protocols[$scope.protocols.indexOf($scope.clientScope.protocol)];\n        } else {\n            $scope.protocol = $scope.protocols[0];\n        }\n\n        if ($scope.clientScope.attributes[\"display.on.consent.screen\"]) {\n            if ($scope.clientScope.attributes[\"display.on.consent.screen\"] == \"true\") {\n                $scope.displayOnConsentScreen = true;\n            } else {\n                $scope.displayOnConsentScreen = false;\n            }\n        } else {\n            $scope.displayOnConsentScreen = true;\n        }\n\n        if(serverInfo.featureEnabled(\"DYNAMIC_SCOPES\")) {\n            if ($scope.clientScope.attributes[\"is.dynamic.scope\"]) {\n                if ($scope.clientScope.attributes[\"is.dynamic.scope\"] === \"true\") {\n                    $scope.isDynamicScope = true;\n                } else {\n                    $scope.isDynamicScope = false;\n                }\n            } else {\n                $scope.isDynamicScope = false;\n            }\n\n            $scope.clientScope.attributes[\"dynamic.scope.regexp\"] = $scope.clientScope.name + \":*\";\n        }\n\n        if ($scope.clientScope.attributes[\"include.in.token.scope\"]) {\n            if ($scope.clientScope.attributes[\"include.in.token.scope\"] == \"true\") {\n                $scope.includeInTokenScope = true;\n            } else {\n                $scope.includeInTokenScope = false;\n            }\n        } else {\n            $scope.includeInTokenScope = true;\n        }\n    }\n\n    if (!$scope.create) {\n        $scope.clientScope = angular.copy(clientScope);\n    } else {\n        $scope.clientScope = {};\n    }\n\n    updateProperties();\n\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.changeProtocol = function() {\n        if ($scope.protocol == \"openid-connect\") {\n            $scope.clientScope.protocol = \"openid-connect\";\n        } else if ($scope.protocol == \"saml\") {\n            $scope.clientScope.protocol = \"saml\";\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    function isChanged() {\n        if (!angular.equals($scope.clientScope, clientScope)) {\n            return true;\n        }\n        return false;\n    }\n\n    $scope.$watch('clientScope', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.save = function() {\n        $scope.clientScope.protocol = $scope.protocol;\n\n        if ($scope.displayOnConsentScreen == true) {\n            $scope.clientScope.attributes[\"display.on.consent.screen\"] = \"true\";\n        } else {\n            $scope.clientScope.attributes[\"display.on.consent.screen\"] = \"false\";\n        }\n\n        if(serverInfo.featureEnabled(\"DYNAMIC_SCOPES\")) {\n            if ($scope.isDynamicScope === true) {\n                $scope.clientScope.attributes[\"is.dynamic.scope\"] = \"true\";\n            } else {\n                $scope.clientScope.attributes[\"is.dynamic.scope\"] = \"false\";\n            }\n        }\n\n        if ($scope.includeInTokenScope == true) {\n            $scope.clientScope.attributes[\"include.in.token.scope\"] = \"true\";\n        } else {\n            $scope.clientScope.attributes[\"include.in.token.scope\"] = \"false\";\n        }\n\n        if ($scope.create) {\n            ClientScope.save({\n                realm: realm.realm,\n                clientScope: ''\n            }, $scope.clientScope, function (data, headers) {\n                $scope.changed = false;\n                var l = headers().location;\n                var id = l.substring(l.lastIndexOf(\"/\") + 1);\n                $location.url(\"/realms/\" + realm.realm + \"/client-scopes/\" + id);\n                Notifications.success(\"The client scope has been created.\");\n            });\n        } else {\n            ClientScope.update({\n                realm : realm.realm,\n                clientScope : clientScope.id\n            }, $scope.clientScope, function() {\n                $scope.changed = false;\n                clientScope = angular.copy($scope.clientScope);\n                $location.url(\"/realms/\" + realm.realm + \"/client-scopes/\" + clientScope.id);\n                Notifications.success(\"Your changes have been saved to the client scope.\");\n            });\n        }\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/client-scopes\");\n    };\n});\n\nmodule.controller('ClientScopeProtocolMapperListCtrl', function($scope, realm, clientScope, serverInfo,\n                                                           ClientScopeProtocolMappersByProtocol, ClientScopeProtocolMapper,\n                                                           $route, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.clientScope = clientScope;\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[clientScope.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n    $scope.removeMapper = function(mapper) {\n        console.debug(mapper);\n        Dialog.confirmDelete(mapper.name, 'mapper', function() {\n            ClientScopeProtocolMapper.remove({ realm: realm.realm, clientScope: clientScope.id, id : mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $route.reload();\n            });\n        });\n    };\n\n    $scope.sortMappersByPriority = function(mapper) {\n        return $scope.mapperTypes[mapper.protocolMapper].priority;\n    }\n\n    var updateMappers = function() {\n        $scope.mappers = ClientScopeProtocolMappersByProtocol.query({realm : realm.realm, clientScope : clientScope.id, protocol : clientScope.protocol});\n    };\n\n    updateMappers();\n});\n\nmodule.controller('ClientScopeProtocolMapperCtrl', function($scope, realm, serverInfo, clientScope, mapper, clients, ClientScopeProtocolMapper, Notifications, Dialog, $location, $route) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n\n    $scope.model = {\n        realm: realm,\n        clientScope: clientScope,\n        create: false,\n        protocol: clientScope.protocol,\n        mapper: angular.copy(mapper),\n        changed: false\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[clientScope.protocol];\n    for (var i = 0; i < protocolMappers.length; i++) {\n        if (protocolMappers[i].id == mapper.protocolMapper) {\n            $scope.model.mapperType = protocolMappers[i];\n        }\n    }\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.$watch('model.mapper', function() {\n        if (!angular.equals($scope.model.mapper, mapper)) {\n            $scope.model.changed = true;\n        }\n    }, true);\n\n    $scope.save = function() {\n        ClientScopeProtocolMapper.update({\n            realm : realm.realm,\n            clientScope: clientScope.id,\n            id : mapper.id\n        }, $scope.model.mapper, function() {\n            $route.reload();\n            Notifications.success(\"Your changes have been saved.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.model.mapper = angular.copy(mapper);\n        $scope.model.changed = false;\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n    $scope.remove = function() {\n        Dialog.confirmDelete($scope.model.mapper.name, 'mapper', function() {\n            ClientScopeProtocolMapper.remove({ realm: realm.realm, clientScope: clientScope.id, id : $scope.model.mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $location.url(\"/realms/\" + realm.realm + '/client-scopes/' + clientScope.id + \"/mappers\");\n            });\n        });\n    };\n\n});\n\nmodule.controller('ClientScopeProtocolMapperCreateCtrl', function($scope, realm, serverInfo, clientScope, clients, ClientScopeProtocolMapper, Notifications, Dialog, $location) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n    var protocol = clientScope.protocol;\n    $scope.model = {\n        realm: realm,\n        clientScope: clientScope,\n        create: true,\n        protocol: clientScope.protocol,\n        mapper: { protocol :  clientScope.protocol, config: {}},\n        changed: false,\n        mapperTypes: serverInfo.protocolMapperTypes[protocol]\n    }\n\n    // apply default configurations on change for selected protocolmapper type.\n    $scope.$watch('model.mapperType', function() {\n        var currentMapperType = $scope.model.mapperType;\n        var defaultConfig = {};\n\n        if (currentMapperType && Array.isArray(currentMapperType.properties)) {\n            for (var i = 0; i < currentMapperType.properties.length; i++) {\n                var property = currentMapperType.properties[i];\n                if (property && property.name && property.defaultValue) {\n                    defaultConfig[property.name] = property.defaultValue;\n                }\n            }\n        }\n\n        $scope.model.mapper.config = defaultConfig;\n    }, true);\n\n    $scope.model.mapperType = $scope.model.mapperTypes[0];\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.save = function() {\n        $scope.model.mapper.protocolMapper = $scope.model.mapperType.id;\n        ClientScopeProtocolMapper.save({\n            realm : realm.realm, clientScope: clientScope.id\n        }, $scope.model.mapper, function(data, headers) {\n            var l = headers().location;\n            var id = l.substring(l.lastIndexOf(\"/\") + 1);\n            $location.url(\"/realms/\" + realm.realm + '/client-scopes/' + clientScope.id + \"/mappers/\" + id);\n            Notifications.success(\"Mapper has been created.\");\n        });\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n\n});\n\nmodule.controller('ClientScopeAddBuiltinProtocolMapperCtrl', function($scope, realm, clientScope, serverInfo,\n                                                           ClientScopeProtocolMappersByProtocol,\n                                                           $http, $location, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.clientScope = clientScope;\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[clientScope.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n\n\n\n    var updateMappers = function() {\n        var clientMappers = ClientScopeProtocolMappersByProtocol.query({realm : realm.realm, clientScope : clientScope.id, protocol : clientScope.protocol}, function() {\n            var builtinMappers = serverInfo.builtinProtocolMappers[clientScope.protocol];\n            for (var i = 0; i < clientMappers.length; i++) {\n                for (var j = 0; j < builtinMappers.length; j++) {\n                    if (builtinMappers[j].name == clientMappers[i].name\n                        && builtinMappers[j].protocolMapper == clientMappers[i].protocolMapper) {\n                        builtinMappers.splice(j, 1);\n                        break;\n                    }\n                }\n            }\n            $scope.mappers = builtinMappers;\n            for (var i = 0; i < $scope.mappers.length; i++) {\n                $scope.mappers[i].isChecked = false;\n            }\n\n\n        });\n    };\n\n    updateMappers();\n\n    $scope.add = function() {\n        var toAdd = [];\n        for (var i = 0; i < $scope.mappers.length; i++) {\n            if ($scope.mappers[i].isChecked) {\n                delete $scope.mappers[i].isChecked;\n                toAdd.push($scope.mappers[i]);\n            }\n        }\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id + '/protocol-mappers/add-models',\n            toAdd).then(function() {\n                Notifications.success(\"Mappers added\");\n                $location.url('/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/mappers');\n            }).catch(function() {\n                Notifications.error(\"Error adding mappers\");\n                $location.url('/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/mappers');\n            });\n    };\n\n});\n\n\nmodule.controller('ClientScopeScopeMappingCtrl', function($scope, $http, $route, realm, clientScope, Notifications,\n                                                     ClientScope, Client,\n                                                     ClientScopeRealmScopeMapping, ClientScopeClientScopeMapping, ClientRole,\n                                                     ClientScopeAvailableRealmScopeMapping, ClientScopeAvailableClientScopeMapping,\n                                                     ClientScopeCompositeRealmScopeMapping, ClientScopeCompositeClientScopeMapping) {\n    $scope.realm = realm;\n    $scope.clientScope = angular.copy(clientScope);\n    $scope.selectedRealmRoles = [];\n    $scope.selectedRealmMappings = [];\n    $scope.realmMappings = [];\n    $scope.clientRoles = [];\n    $scope.clientComposite = [];\n    $scope.selectedClientRoles = [];\n    $scope.selectedClientMappings = [];\n    $scope.clientMappings = [];\n    $scope.dummymodel = [];\n    $scope.selectedClient = null;\n\n    function updateScopeRealmRoles() {\n        $scope.realmRoles = ClientScopeAvailableRealmScopeMapping.query({realm : realm.realm, clientScope : clientScope.id});\n        $scope.realmMappings = ClientScopeRealmScopeMapping.query({realm : realm.realm, clientScope : clientScope.id});\n        $scope.realmComposite = ClientScopeCompositeRealmScopeMapping.query({realm : realm.realm, clientScope : clientScope.id});\n    }\n\n    function updateScopeClientRoles() {\n        if ($scope.selectedClient) {\n            $scope.clientRoles = ClientScopeAvailableClientScopeMapping.query({realm : realm.realm, clientScope : clientScope.id, targetClient : $scope.selectedClient.id});\n            $scope.clientMappings = ClientScopeClientScopeMapping.query({realm : realm.realm, clientScope : clientScope.id, targetClient : $scope.selectedClient.id});\n            $scope.clientComposite = ClientScopeCompositeClientScopeMapping.query({realm : realm.realm, clientScope : clientScope.id, targetClient : $scope.selectedClient.id});\n        } else {\n            $scope.clientRoles = null;\n            $scope.clientMappings = null;\n            $scope.clientComposite = null;\n        }\n    }\n\n    $scope.changeClient = function(client) {\n        if (!client || !client.id) {\n            $scope.selectedClient = null;\n            return;\n        }\n        $scope.selectedClient = client;\n        updateScopeClientRoles();\n    };\n\n    $scope.addRealmRole = function() {\n        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');\n        $scope.selectedRealmRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id + '/scope-mappings/realm',\n            $scope.selectedRealmRolesToAdd).then(function() {\n                updateScopeRealmRoles();\n                $scope.selectedRealmRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteRealmRole = function() {\n        $scope.selectedRealmMappingsToRemove = JSON.parse('[' + $scope.selectedRealmMappings + ']');\n        $scope.selectedRealmMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/scope-mappings/realm',\n            {data : $scope.selectedRealmMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateScopeRealmRoles();\n                $scope.selectedRealmMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.addClientRole = function() {\n        $scope.selectedClientRolesToAdd = JSON.parse('[' + $scope.selectedClientRoles + ']');\n        $scope.selectedClientRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n            $scope.selectedClientRolesToAdd).then(function () {\n                updateScopeClientRoles();\n                $scope.selectedClientRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteClientRole = function() {\n        $scope.selectedClientMappingsToRemove = JSON.parse('[' + $scope.selectedClientMappings + ']');\n        $scope.selectedClientMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n            {data : $scope.selectedClientMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateScopeClientRoles();\n                $scope.selectedClientMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    clientSelectControl($scope, $route.current.params.realm, Client);\n    updateScopeRealmRoles();\n});\n\nmodule.controller('ClientStoresCtrl', function($scope, $location, $route, realm, serverInfo, Components, Notifications, Dialog) {\n    console.log('ClientStoresCtrl ++++****');\n    $scope.realm = realm;\n    $scope.providers = serverInfo.componentTypes['org.keycloak.storage.client.ClientStorageProvider'];\n    $scope.clientStorageProviders = serverInfo.componentTypes['org.keycloak.storage.client.ClientStorageProvider'];\n    $scope.instancesLoaded = false;\n\n    if (!$scope.providers) $scope.providers = [];\n\n    $scope.addProvider = function(provider) {\n        console.log('Add provider: ' + provider.id);\n        $location.url(\"/create/client-storage/\" + realm.realm + \"/providers/\" + provider.id);\n    };\n\n    $scope.getInstanceLink = function(instance) {\n        return \"/realms/\" + realm.realm + \"/client-storage/providers/\" + instance.providerId + \"/\" + instance.id;\n    }\n\n    $scope.getInstanceName = function(instance) {\n        return instance.name;\n    }\n    $scope.getInstanceProvider = function(instance) {\n        return instance.providerId;\n    }\n\n    $scope.isProviderEnabled = function(instance) {\n        return !instance.config['enabled'] || instance.config['enabled'][0] == 'true';\n    }\n\n    $scope.getInstancePriority = function(instance) {\n        if (!instance.config['priority']) {\n            return \"0\";\n        }\n        return instance.config['priority'][0];\n    }\n\n    Components.query({realm: realm.realm,\n        parent: realm.id,\n        type: 'org.keycloak.storage.client.ClientStorageProvider'\n    }, function(data) {\n        $scope.instances = data;\n        $scope.instancesLoaded = true;\n    });\n\n    $scope.removeInstance = function(instance) {\n        Dialog.confirmDelete(instance.name, 'client storage provider', function() {\n            Components.remove({\n                realm : realm.realm,\n                componentId : instance.id\n            }, function() {\n                $route.reload();\n                Notifications.success(\"The provider has been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('GenericClientStorageCtrl', function($scope, $location, Notifications, $route, Dialog, realm,\n                                                     serverInfo, instance, providerId, Components) {\n    console.log('GenericClientStorageCtrl');\n    console.log('providerId: ' + providerId);\n    $scope.create = !instance.providerId;\n    console.log('create: ' + $scope.create);\n    var providers = serverInfo.componentTypes['org.keycloak.storage.client.ClientStorageProvider'];\n    console.log('providers length ' + providers.length);\n    var providerFactory = null;\n    for (var i = 0; i < providers.length; i++) {\n        var p = providers[i];\n        console.log('provider: ' + p.id);\n        if (p.id == providerId) {\n            $scope.providerFactory = p;\n            providerFactory = p;\n            break;\n        }\n\n    }\n    $scope.changed = false;\n\n    console.log(\"providerFactory: \" + providerFactory.id);\n\n    function initClientStorageSettings() {\n        if ($scope.create) {\n            $scope.changed = true;\n            instance.name = providerFactory.id;\n            instance.providerId = providerFactory.id;\n            instance.providerType = 'org.keycloak.storage.client.ClientStorageProvider';\n            instance.parentId = realm.id;\n            instance.config = {\n\n            };\n            instance.config['priority'] = [\"0\"];\n            instance.config['enabled'] = [\"true\"];\n\n            $scope.fullSyncEnabled = false;\n            $scope.changedSyncEnabled = false;\n            instance.config['cachePolicy'] = ['DEFAULT'];\n            instance.config['evictionDay'] = [''];\n            instance.config['evictionHour'] = [''];\n            instance.config['evictionMinute'] = [''];\n            instance.config['maxLifespan'] = [''];\n            if (providerFactory.properties) {\n\n                for (var i = 0; i < providerFactory.properties.length; i++) {\n                    var configProperty = providerFactory.properties[i];\n                    if (configProperty.defaultValue) {\n                        instance.config[configProperty.name] = [configProperty.defaultValue];\n                    } else {\n                        instance.config[configProperty.name] = [''];\n                    }\n\n                }\n            }\n\n        } else {\n            $scope.changed = false;\n             if (!instance.config['enabled']) {\n                instance.config['enabled'] = ['true'];\n            }\n            if (!instance.config['cachePolicy']) {\n                instance.config['cachePolicy'] = ['DEFAULT'];\n\n            }\n            if (!instance.config['evictionDay']) {\n                instance.config['evictionDay'] = [''];\n\n            }\n            if (!instance.config['evictionHour']) {\n                instance.config['evictionHour'] = [''];\n\n            }\n            if (!instance.config['evictionMinute']) {\n                instance.config['evictionMinute'] = [''];\n\n            }\n            if (!instance.config['maxLifespan']) {\n                instance.config['maxLifespan'] = [''];\n\n            }\n            if (!instance.config['priority']) {\n                instance.config['priority'] = ['0'];\n            }\n\n            if (providerFactory.properties) {\n                for (var i = 0; i < providerFactory.properties.length; i++) {\n                    var configProperty = providerFactory.properties[i];\n                    if (!instance.config[configProperty.name]) {\n                        instance.config[configProperty.name] = [''];\n                    }\n                }\n            }\n\n        }\n    }\n\n    initClientStorageSettings();\n    $scope.instance = angular.copy(instance);\n    $scope.realm = realm;\n\n     $scope.$watch('instance', function() {\n        if (!angular.equals($scope.instance, instance)) {\n            $scope.changed = true;\n        }\n\n    }, true);\n\n    $scope.save = function() {\n        console.log('save provider');\n        $scope.changed = false;\n        if ($scope.create) {\n            console.log('saving new provider');\n            Components.save({realm: realm.realm}, $scope.instance,  function (data, headers) {\n                var l = headers().location;\n                var id = l.substring(l.lastIndexOf(\"/\") + 1);\n\n                $location.url(\"/realms/\" + realm.realm + \"/client-storage/providers/\" + $scope.instance.providerId + \"/\" + id);\n                Notifications.success(\"The provider has been created.\");\n            });\n        } else {\n            console.log('update existing provider');\n            Components.update({realm: realm.realm,\n                    componentId: instance.id\n                },\n                $scope.instance,  function () {\n                    $route.reload();\n                    Notifications.success(\"The provider has been updated.\");\n                });\n        }\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        console.log('cancel');\n        if ($scope.create) {\n            $location.url(\"/realms/\" + realm.realm + \"/client-stores\");\n        } else {\n            $route.reload();\n        }\n    };\n\n\n\n});\n\n\n", "<div class=\"col-sm-9 col-md-10 col-sm-push-3 col-md-push-2\">\n\n    <ol class=\"breadcrumb\">\n        <li><a href=\"#/realms/{{realm.realm}}/clients\">{{:: 'clients' | translate}}</a></li>\n        <li>{{client.clientId}}</li>\n    </ol>\n\n    <kc-tabs-client></kc-tabs-client>\n\n    <form class=\"form-horizontal\" name=\"clientForm\" novalidate kc-read-only=\"!client.access.configure\">\n        <fieldset class=\"border-top\">\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"clientId\">{{:: 'client-id' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"clientId\" name=\"clientId\" data-ng-model=\"clientEdit.clientId\" autofocus required>\n                </div>\n                <kc-tooltip>{{:: 'client-id.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"name\">{{:: 'name' | translate}} </label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"name\" name=\"name\" data-ng-model=\"clientEdit.name\" autofocus>\n                </div>\n                <kc-tooltip>{{:: 'client.name.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"description\">{{:: 'description' | translate}} </label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"description\" name=\"description\" data-ng-model=\"clientEdit.description\">\n                </div>\n                <kc-tooltip>{{:: 'client.description.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"enabled\">{{:: 'enabled' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.enabled\" name=\"enabled\" id=\"enabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"serverInfo.featureEnabled('ACCOUNT2') && !(accessType === 'bearer-only' && protocol === 'openid-connect')\">\n                <label class=\"col-md-2 control-label\" for=\"alwaysDisplayInConsole\">{{:: 'alwaysDisplayInConsole' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.alwaysDisplayInConsole\" name=\"alwaysDisplayInConsole\" id=\"alwaysDisplayInConsole\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'alwaysDisplayInConsole.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"client.origin\">\n                <label class=\"col-md-2 control-label\">{{:: 'client-origin-link' | translate}}</label>\n                <div class=\"col-md-6\">\n                    {{originName}}\n                </div>\n                <kc-tooltip>{{:: 'client-origin.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"consentRequired\">{{:: 'consent-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.consentRequired\" name=\"consentRequired\" id=\"consentRequired\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'consent-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"clientEdit.consentRequired && protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"displayOnConsentScreen\">{{:: 'client.display-on-consent-screen' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"displayOnConsentScreen\" ng-click=\"switchChange()\" name=\"displayOnConsentScreen\" id=\"displayOnConsentScreen\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'client.display-on-consent-screen.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"clientEdit.consentRequired && protocol != 'docker-v2' && displayOnConsentScreen\">\n                <label class=\"col-md-2 control-label\" for=\"consentScreenText\">{{:: 'client.consent-screen-text' | translate}} </label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"consentScreenText\" name=\"consentScreenText\" data-ng-model=\"clientEdit.attributes['consent.screen.text']\">\n                </div>\n                <kc-tooltip>{{:: 'client.consent-screen-text.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"loginTheme\">{{:: 'login-theme' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <select class=\"form-control\" id=\"loginTheme\"\n                            ng-model=\"clientEdit.attributes['login_theme']\"\n                            ng-options=\"o.name as o.name for o in serverInfo.themes.login\">\n                        <option value=\"\" selected></option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'login-theme.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"protocol\">{{:: 'client-protocol' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"protocol\"\n                                ng-change=\"changeProtocol()\"\n                                ng-model=\"protocol\"\n                                ng-options=\"aProtocol for aProtocol in protocols\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'client-protocol.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"accessType\">{{:: 'access-type' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"accessType\"\n                                ng-change=\"changeAccessType()\"\n                                ng-model=\"accessType\"\n                                ng-options=\"aType for aType in accessTypes\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'access-type.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"standardFlowEnabled\">{{:: 'standard-flow-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'standard-flow-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.standardFlowEnabled\" name=\"standardFlowEnabled\" id=\"standardFlowEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"implicitFlowEnabled\">{{:: 'implicit-flow-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'implicit-flow-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.implicitFlowEnabled\" name=\"implicitFlowEnabled\" id=\"implicitFlowEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"directAccessGrantsEnabled\">{{:: 'direct-access-grants-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'direct-access-grants-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.directAccessGrantsEnabled\" name=\"directAccessGrantsEnabled\" id=\"directAccessGrantsEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"serviceAccountsEnabled\">{{:: 'service-accounts-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'service-accounts-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.serviceAccountsEnabled\" name=\"serviceAccountsEnabled\" id=\"serviceAccountsEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"oauth2DeviceAuthorizationGrantEnabled\">{{::\n                    'oauth2-device-authorization-grant-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'oauth2-device-authorization-grant-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"oauth2DeviceAuthorizationGrantEnabled\" ng-click=\"switchChange()\"\n                        name=\"oauth2DeviceAuthorizationGrantEnabled\" id=\"oauth2DeviceAuthorizationGrantEnabled\" onoffswitch\n                        on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\" />\n                </div>\n            </div>\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA')\">\n                <label class=\"col-md-2 control-label\" for=\"oidcCibaGrantEnabled\">{{::\n                    'oidc-ciba-grant-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'oidc-ciba-grant-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"oidcCibaGrantEnabled\" ng-click=\"switchChange()\"\n                        name=\"oidcCibaGrantEnabled\" id=\"oidcCibaGrantEnabled\" onoffswitch\n                        on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\" />\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"serverInfo.featureEnabled('AUTHORIZATION') && protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationServicesEnabled\">{{:: 'authz-authorization-services-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'authz-authorization-services-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.authorizationServicesEnabled\" ng-click=\"confirmChangeAuthzSettings($event)\" name=\"authorizationServicesEnabled\" id=\"authorizationServicesEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAuthnStatement\">{{:: 'include-authnstatement' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlAuthnStatement\" ng-click=\"switchChange()\" name=\"samlAuthnStatement\" id=\"samlAuthnStatement\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'include-authnstatement.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlOneTimeUseCondition\">{{:: 'include-onetimeuse-condition' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlOneTimeUseCondition\" ng-click=\"switchChange()\" name=\"samlOneTimeUseCondition\" id=\"samlOneTimeUseCondition\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'include-onetimeuse-condition.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlArtifactBinding\">{{:: 'artifact-binding' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlArtifactBinding\" ng-click=\"switchChange()\" name=\"samlArtifactBinding\" id=\"samlArtifactBinding\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'artifact-binding.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlServerSignature\">{{:: 'sign-documents' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlServerSignature\" ng-click=\"switchChange()\" name=\"samlServerSignature\" id=\"samlServerSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'sign-documents.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml' && samlServerSignature == true\">\n                <label class=\"col-md-2 control-label\" for=\"samlServerSignatureEnableKeyInfoExtension\">{{:: 'sign-documents-redirect-enable-key-info-ext' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlServerSignatureEnableKeyInfoExtension\" ng-click=\"switchChange()\" name=\"samlServerSignatureEnableKeyInfoExtension\" id=\"samlServerSignatureEnableKeyInfoExtension\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'sign-documents-redirect-enable-key-info-ext.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAssertionSignature\">{{:: 'sign-assertions' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlAssertionSignature\" ng-click=\"switchChange()\" name=\"samlAssertionSignature\" id=\"samlAssertionSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'sign-assertions.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"(samlAssertionSignature || samlServerSignature) && protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"signatureAlgorithm\">{{:: 'signature-algorithm' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"signatureAlgorithm\"\n                                ng-change=\"changeAlgorithm()\"\n                                ng-model=\"signatureAlgorithm\"\n                                ng-options=\"alg for alg in signatureAlgorithms\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'signature-algorithm.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"(samlAssertionSignature || samlServerSignature) && protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlSigKeyNameTranformer\">{{:: 'saml-signature-keyName-transformer' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"xmlKeyNameTranformer\"\n                                ng-change=\"changeSamlSigKeyNameTranformer()\"\n                                ng-model=\"samlXmlKeyNameTranformer\"\n                                ng-options=\"alg for alg in xmlKeyNameTranformers\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'saml-signature-keyName-transformer.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"(samlAssertionSignature || samlServerSignature) && protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"canonicalization\">{{:: 'canonicalization-method' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"canonicalization\"\n                                ng-model=\"clientEdit.attributes['saml_signature_canonicalization_method']\"\n                                ng-options=\"canon.value as canon.name for canon in canonicalization\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'canonicalization-method.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlEncrypt\">{{:: 'encrypt-assertions' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlEncrypt\" ng-click=\"switchChange()\" name=\"samlEncrypt\" id=\"samlEncrypt\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'encrypt-assertions.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlClientSignature\">{{:: 'client-signature-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlClientSignature\" ng-click=\"switchChange()\" name=\"samlClientSignature\" id=\"samlClientSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'client-signature-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlForcePostBinding\">{{:: 'force-post-binding' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlForcePostBinding\" ng-click=\"switchChange()\" name=\"samlForcePostBinding\" id=\"samlForcePostBinding\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'force-post-binding.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"frontchannelLogout\">{{:: 'front-channel-logout' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.frontchannelLogout\" name=\"frontchannelLogout\" id=\"frontchannelLogout\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'front-channel-logout.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && clientEdit.frontchannelLogout\">\n                <label class=\"col-md-2 control-label\" for=\"frontchannelLogoutUrl\">{{:: 'front-channel-logout-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"frontchannelLogoutUrl\" id=\"frontchannelLogoutUrl\" data-ng-model=\"clientEdit.attributes['frontchannel.logout.url']\">\n                </div>\n                <kc-tooltip>{{:: 'front-channel-logout-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && clientEdit.frontchannelLogout\">\n                <label class=\"col-md-2 control-label\" for=\"frontchannelLogoutSessionRequired\">{{:: 'front-channel-logout-session-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"frontchannelLogoutSessionRequired\" name=\"frontchannelLogoutSessionRequired\" id=\"frontchannelLogoutSessionRequired\" onoffswitch ng-click=\"switchChange()\" on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'front-channel-logout-session-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlForceNameIdFormat\">{{:: 'force-name-id-format' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlForceNameIdFormat\" ng-click=\"switchChange()\" name=\"samlForceNameIdFormat\" id=\"samlForceNameIdFormat\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'force-name-id-format.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlNameIdFormat\">{{:: 'name-id-format' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"samlNameIdFormat\"\n                                ng-change=\"changeNameIdFormat()\"\n                                ng-model=\"nameIdFormat\"\n                                ng-options=\"format for format in nameIdFormats\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'name-id-format.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"!clientEdit.bearerOnly && protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"rootUrl\">{{:: 'root-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"rootUrl\" id=\"rootUrl\" data-ng-model=\"clientEdit.rootUrl\">\n                </div>\n                <kc-tooltip>{{:: 'root-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-hide=\"clientEdit.bearerOnly || (!clientEdit.standardFlowEnabled && !clientEdit.implicitFlowEnabled) || protocol == 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"newRedirectUri\"><span class=\"required\" data-ng-show=\"protocol != 'saml'\">*</span> {{:: 'valid-redirect-uris' | translate}}</label>\n\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, redirectUri) in clientEdit.redirectUris track by $index\">\n                        <input class=\"form-control\" ng-model=\"clientEdit.redirectUris[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteRedirectUri($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newRedirectUri\" id=\"newRedirectUri\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newRedirectUri.length > 0 && addRedirectUri()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n\n                <kc-tooltip>{{:: 'valid-redirect-uris.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"!clientEdit.bearerOnly && protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"baseUrl\">{{:: 'base-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"baseUrl\" id=\"baseUrl\" data-ng-model=\"clientEdit.baseUrl\">\n                </div>\n                <kc-tooltip>{{:: 'base-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-hide=\"protocol == 'saml' || protocol == 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"adminUrl\">{{:: 'admin-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"adminUrl\" id=\"adminUrl\"\n                           data-ng-model=\"clientEdit.adminUrl\">\n                </div>\n                <kc-tooltip>{{:: 'admin-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"masterSamlUrl\">{{:: 'master-saml-processing-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"masterSamlUrl\" id=\"masterSamlUrl\"\n                           data-ng-model=\"clientEdit.adminUrl\">\n                </div>\n                <kc-tooltip>{{:: 'master-saml-processing-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"urlReferenceName\">{{:: 'idp-sso-url-ref' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_idp_initiated_sso_url_name\" class=\"form-control\" type=\"text\" name=\"urlReferenceName\" id=\"urlReferenceName\" />\n                    <div data-ng-show=\"clientEdit.attributes.saml_idp_initiated_sso_url_name\">\n                        {{:: 'idp-sso-url-ref.urlhint' | translate}} {{samlIdpInitiatedUrl(clientEdit.attributes.saml_idp_initiated_sso_url_name)}}\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'idp-sso-url-ref.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"logoUri\">{{:: 'logo-uri' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"logoUri\" id=\"logoUri\" data-ng-model=\"clientEdit.attributes.logoUri\">\n                </div>\n                <kc-tooltip>{{:: 'logo-uri.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"policyUri\">{{:: 'policy-uri' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"policyUri\" id=\"policyUri\" data-ng-model=\"clientEdit.attributes.policyUri\">\n                </div>\n                <kc-tooltip>{{:: 'policy-uri.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"tosUri\">{{:: 'tos-uri' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"tosUri\" id=\"tosUri\" data-ng-model=\"clientEdit.attributes.tosUri\">\n                </div>\n                <kc-tooltip>{{:: 'tos-uri.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"idpInitiatedRelayState\">{{:: 'idp-sso-relay-state' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_idp_initiated_sso_relay_state\" class=\"form-control\" type=\"text\" name=\"idpInitiatedRelayState\" id=\"idpInitiatedRelayState\" />\n                </div>\n                <kc-tooltip>{{:: 'idp-sso-relay-state.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"(!clientEdit.bearerOnly && protocol == 'openid-connect') && (clientEdit.standardFlowEnabled || clientEdit.directAccessGrantsEnabled || clientEdit.implicitFlowEnabled)\">\n                <label class=\"col-md-2 control-label\" for=\"newWebOrigin\">{{:: 'web-origins' | translate}}</label>\n\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, webOrigin) in clientEdit.webOrigins track by $index\">\n                        <input class=\"form-control\" ng-model=\"clientEdit.webOrigins[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteWebOrigin($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newWebOrigin\" id=\"newWebOrigin\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newWebOrigin.length > 0 && addWebOrigin()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n\n                <kc-tooltip>{{:: 'web-origins.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"backchannelLogoutUrl\">{{:: 'backchannel-logout-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"backchannelLogoutUrl\" id=\"backchannelLogoutUrl\" data-ng-model=\"clientEdit.attributes['backchannel.logout.url']\">\n                </div>\n                <kc-tooltip>{{:: 'backchannel-logout-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"backchannelLogoutSessionRequired\">{{:: 'backchannel-logout-session-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"backchannelLogoutSessionRequired\" name=\"backchannelLogoutSessionRequired\" id=\"backchannelLogoutSessionRequired\" onoffswitch ng-click=\"switchChange()\" on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'backchannel-logout-session-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"backchannelLogoutRevokeOfflineSessions\">{{:: 'backchannel-logout-revoke-offline-sessions' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"backchannelLogoutRevokeOfflineSessions\" name=\"backchannelLogoutRevokeOfflineSessions\" id=\"backchannelLogoutRevokeOfflineSessions\" onoffswitch ng-click=\"switchChange()\" on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'backchannel-logout-revoke-offline-sessions.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n        <fieldset data-ng-show=\"protocol == 'saml'\">\n            <legend collapsed><span class=\"text\">{{:: 'fine-saml-endpoint-conf' | translate}}</span>  <kc-tooltip>{{:: 'fine-saml-endpoint-conf.tooltip' | translate}}</kc-tooltip></legend>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"consumerServicePost\">{{:: 'assertion-consumer-post-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_assertion_consumer_url_post\" class=\"form-control\" type=\"text\" name=\"consumerServicePost\" id=\"consumerServicePost\" />\n                </div>\n                <kc-tooltip>{{:: 'assertion-consumer-post-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"consumerServiceRedirect\">{{:: 'assertion-consumer-redirect-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_assertion_consumer_url_redirect\" class=\"form-control\" type=\"text\" name=\"consumerServiceRedirect\" id=\"consumerServiceRedirect\" />\n                </div>\n                <kc-tooltip>{{:: 'assertion-consumer-redirect-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"logoutPostBinding\">{{:: 'logout-service-post-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_single_logout_service_url_post\" class=\"form-control\" type=\"text\" name=\"logoutPostBinding\" id=\"logoutPostBinding\" />\n                </div>\n                <kc-tooltip>{{:: 'logout-service-post-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"logoutRedirectBinding\">{{:: 'logout-service-redir-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_single_logout_service_url_redirect\" class=\"form-control\" type=\"text\" name=\"logoutRedirectBinding\" id=\"logoutRedirectBinding\" />\n                </div>\n                <kc-tooltip>{{:: 'logout-service-redir-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"logoutArtifactBinding\">{{:: 'logout-service-artifact-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_single_logout_service_url_artifact\" class=\"form-control\" type=\"text\" name=\"logoutRedirectBinding\" id=\"logoutArtifactBinding\" />\n                </div>\n                <kc-tooltip>{{:: 'logout-service-artifact-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"artifactBindingUrl\">{{:: 'artifact-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_artifact_binding_url\" class=\"form-control\" type=\"text\" name=\"artifactBindingUrl\" id=\"artifactBindingUrl\" />\n                </div>\n                <kc-tooltip>{{:: 'artifact-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"artifactResolutionServiceUrl\">{{:: 'artifact-resolution-service-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_artifact_resolution_service_url\" class=\"form-control\" type=\"text\" name=\"artifactResolutionServiceUrl\" id=\"artifactResolutionServiceUrl\" />\n                </div>\n                <kc-tooltip>{{:: 'artifact-resolution-service-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n        <fieldset data-ng-show=\"protocol == 'openid-connect'\">\n            <legend collapsed><span class=\"text\">{{:: 'fine-oidc-endpoint-conf' | translate}}</span>  <kc-tooltip>{{:: 'fine-oidc-endpoint-conf.tooltip' | translate}}</kc-tooltip></legend>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"accessTokenSignedResponseAlg\">{{:: 'access-token-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"accessTokenSignedResponseAlg\"\n                                ng-change=\"changeAccessTokenSignedResponseAlg()\"\n                                ng-model=\"accessTokenSignedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'access-token-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"idTokenSignedResponseAlg\">{{:: 'id-token-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"idTokenSignedResponseAlg\"\n                                ng-change=\"changeIdTokenSignedResponseAlg()\"\n                                ng-model=\"idTokenSignedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'id-token-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"idTokenEncryptedResponseAlg\">{{:: 'id-token-encrypted-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"idTokenEncryptedResponseAlg\"\n                                ng-change=\"changeIdTokenEncryptedResponseAlg()\"\n                                ng-model=\"idTokenEncryptedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('cekmanagement')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'id-token-encrypted-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"idTokenEncryptedResponseEnc\">{{:: 'id-token-encrypted-response-enc' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"idTokenEncryptedResponseEnc\"\n                                ng-change=\"changeIdTokenEncryptedResponseEnc()\"\n                                ng-model=\"idTokenEncryptedResponseEnc\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('contentencryption')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'id-token-encrypted-response-enc.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"userInfoSignedResponseAlg\">{{:: 'user-info-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"userInfoSignedResponseAlg\"\n                                ng-change=\"changeUserInfoSignedResponseAlg()\"\n                                ng-model=\"userInfoSignedResponseAlg\">\n                            <option value=\"unsigned\">unsigned</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'user-info-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requestObjectSignatureAlg\">{{:: 'request-object-signature-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectSignatureAlg\"\n                                ng-change=\"changeRequestObjectSignatureAlg()\"\n                                ng-model=\"requestObjectSignatureAlg\">\n                            <option value=\"any\">any</option>\n                            <option value=\"none\">none</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('clientSignature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-signature-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requestObjectEncryptionAlg\">{{:: 'request-object-encryption-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectEncryptionAlg\"\n                                ng-change=\"changeRequestObjectEncryptionAlg()\"\n                                ng-model=\"requestObjectEncryptionAlg\">\n                            <option value=\"any\">any</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('cekmanagement')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-encryption-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requestObjectEncryptionEnc\">{{:: 'request-object-encryption-enc' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectEncryptionEnc\"\n                                ng-change=\"changeRequestObjectEncryptionEnc()\"\n                                ng-model=\"requestObjectEncryptionEnc\">\n                            <option value=\"any\">any</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('contentencryption')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-encryption-enc.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"changeRequestObjectRequired\">{{:: 'request-object-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectRequired\"\n                                ng-change=\"changeRequestObjectRequired()\"\n                                ng-model=\"requestObjectRequired\"\n                                ng-options=\"sig for sig in requestObjectRequiredOptions\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA') && oidcCibaGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"cibaBackchannelTokenDeliveryMode\">{{:: 'ciba-backchannel-token-delivery-mode' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"cibaBackchannelTokenDeliveryMode\"\n                                ng-change=\"changeCibaBackchannelTokenDeliveryMode()\"\n                                ng-model=\"cibaBackchannelTokenDeliveryMode\">\n                            <option value=\"poll\">poll</option>\n                            <option value=\"ping\">ping</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'ciba-backchannel-token-delivery-mode.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA') && oidcCibaGrantEnabled == true && cibaBackchannelTokenDeliveryMode == 'ping'\">\n                <label class=\"col-md-2 control-label\" for=\"cibaBackchannelClientNotificationEndpoint\">{{:: 'ciba-backchannel-client-notification-endpoint' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes['ciba.backchannel.client.notification.endpoint']\" class=\"form-control\" type=\"text\" name=\"cibaBackchannelClientNotificationEndpoint\" id=\"cibaBackchannelClientNotificationEndpoint\" />\n                </div>\n                <kc-tooltip>{{:: 'ciba-backchannel-client-notification-endpoint.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA') && oidcCibaGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"cibaBackchannelAuthRequestSigningAlg\">{{:: 'ciba-backchannel-auth-request-signing-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"cibaBackchannelAuthRequestSigningAlg\"\n                                ng-change=\"changeCibaBackchannelAuthRequestSigningAlg()\"\n                                ng-model=\"cibaBackchannelAuthRequestSigningAlg\">\n                            <option value=\"any\">any</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('clientSignature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'ciba-backchannel-auth-request-signing-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"newRequestUri\">{{:: 'request-uris' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, requestUri) in clientEdit.requestUris track by $index\">\n                        <input class=\"form-control\" ng-model=\"clientEdit.requestUris[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteRequestUri($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newRequestUri\" id=\"newRequestUri\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newRequestUri.length > 0 && addRequestUri()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-uris.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationSignedResponseAlg\">{{:: 'authorization-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"authorizationSignedResponseAlg\"\n                                ng-change=\"changeAuthorizationSignedResponseAlg()\"\n                                ng-model=\"authorizationSignedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'authorization-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationEncryptedResponseAlg\">{{:: 'authorization-encrypted-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"authorizationEncryptedResponseAlg\"\n                                ng-change=\"changeAuthorizationEncryptedResponseAlg()\"\n                                ng-model=\"authorizationEncryptedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('cekmanagement')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'authorization-encrypted-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationEncryptedResponseEnc\">{{:: 'authorization-encrypted-response-enc' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"authorizationEncryptedResponseEnc\"\n                                ng-change=\"changeAuthorizationEncryptedResponseEnc()\"\n                                ng-model=\"authorizationEncryptedResponseEnc\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('contentencryption')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'authorization-encrypted-response-enc.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n        <fieldset data-ng-show=\"protocol == 'openid-connect'\">\n            <legend collapsed><span class=\"text\">{{:: 'oidc-compatibility-modes' | translate}}</span>  <kc-tooltip>{{:: 'oidc-compatibility-modes.tooltip' | translate}}</kc-tooltip></legend>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"excludeSessionStateFromAuthResponse\">{{:: 'exclude-session-state-from-auth-response' | translate}}</label>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"excludeSessionStateFromAuthResponse\" ng-click=\"switchChange()\" name=\"excludeSessionStateFromAuthResponse\" id=\"excludeSessionStateFromAuthResponse\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'exclude-session-state-from-auth-response.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"useRefreshTokens\">{{:: 'use-refresh-tokens' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"useRefreshTokens\" ng-click=\"switchChange()\" name=\"useRefreshTokens\" id=\"useRefreshTokens\"\n                        onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\" />\n                </div>\n                <kc-tooltip>{{:: 'use-refresh-tokens.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"useRefreshTokenForClientCredentialsGrant\">{{:: 'use-refresh-token-for-client-credentials-grant' | translate}}</label>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"useRefreshTokenForClientCredentialsGrant\" ng-click=\"switchChange()\" name=\"useRefreshTokenForClientCredentialsGrant\" id=\"useRefreshTokenForClientCredentialsGrant\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'use-refresh-token-for-client-credentials-grant.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"useLowerCaseBearerTypeInTokenResponse\">{{:: 'use-lower-case-bearer-in-token-responses' | translate}}</label>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"useLowerCaseBearerTypeInTokenResponse\" ng-click=\"switchChange()\" name=\"useLowerCaseBearerTypeInTokenResponse\" id=\"useLowerCaseBearerTypeInTokenResponse\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'use-lower-case-bearer-in-token-responses.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n        <fieldset>\n            <legend collapsed><span class=\"text\">{{:: 'advanced-client-settings' | translate}}</span>  <kc-tooltip>{{:: 'advanced-client-settings.tooltip' | translate}}</kc-tooltip></legend>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"accessTokenLifespan\">{{:: 'access-token-lifespan' | translate}}</label>\n\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"-1\"\n                           max=\"31536000\" data-ng-model=\"accessTokenLifespan.time\"\n                           id=\"accessTokenLifespan\" name=\"accessTokenLifespan\"\n                           data-ng-change=\"updateTimeouts()\"/>\n                    <select class=\"form-control\" name=\"accessTokenLifespanUnit\" data-ng-model=\"accessTokenLifespan.unit\" data-ng-change=\"updateTimeouts()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'access-token-lifespan.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAssertionLifespan\">{{:: 'saml-assertion-lifespan' | translate}}</label>\n\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"1\"\n                           max=\"31536000\" data-ng-model=\"samlAssertionLifespan.time\"\n                           id=\"samlAssertionLifespan\" name=\"samlAssertionLifespan\"\n                           data-ng-change=\"updateAssertionLifespan()\"/>\n                    <select class=\"form-control\" name=\"samlAssertionLifespanUnit\" data-ng-model=\"samlAssertionLifespan.unit\" data-ng-change=\"updateAssertionLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'saml-assertion-lifespan.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientSessionIdleTimeout\">{{:: 'client-session-idle' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\"\n                           max=\"31536000\" data-ng-model=\"clientSessionIdleTimeout.time\"\n                           id=\"clientSessionIdleTimeout\" name=\"clientSessionIdleTimeout\"\n                           data-ng-change=\"updateClientSessionIdleTimeout()\"/>\n                    <select class=\"form-control\" name=\"clientSessionIdleTimeoutUnit\" data-ng-model=\"clientSessionIdleTimeout.unit\" data-ng-change=\"updateClientSessionIdleTimeout()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-session-idle.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientSessionMaxLifespan\">{{:: 'client-session-max' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\"\n                           max=\"31536000\" data-ng-model=\"clientSessionMaxLifespan.time\"\n                           id=\"clientSessionMaxLifespan\" name=\"clientSessionMaxLifespan\"\n                           data-ng-change=\"updateClientSessionMaxLifespan()\"/>\n                    <select class=\"form-control\" name=\"clientSessionMaxLifespanUnit\" data-ng-model=\"clientSessionMaxLifespan.unit\" data-ng-change=\"updateClientSessionMaxLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-session-max.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientOfflineSessionIdleTimeout\">{{::\n                    'client-offline-session-idle' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\" max=\"31536000\"\n                        data-ng-model=\"clientOfflineSessionIdleTimeout.time\" id=\"clientOfflineSessionIdleTimeout\"\n                        name=\"clientOfflineSessionIdleTimeout\" data-ng-change=\"updateClientOfflineSessionIdleTimeout()\" /> <select\n                        class=\"form-control\" name=\"clientOfflineSessionIdleTimeoutUnit\"\n                        data-ng-model=\"clientOfflineSessionIdleTimeout.unit\"\n                        data-ng-change=\"updateClientOfflineSessionIdleTimeout()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-offline-session-idle.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientOfflineSessionMaxLifespan\">{{::\n                    'client-offline-session-max' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\" max=\"31536000\"\n                        data-ng-model=\"clientOfflineSessionMaxLifespan.time\" id=\"clientOfflineSessionMaxLifespan\"\n                        name=\"clientOfflineSessionMaxLifespan\" data-ng-change=\"updateClientOfflineSessionMaxLifespan()\" /> <select\n                        class=\"form-control\" name=\"clientOfflineSessionMaxLifespanUnit\"\n                        data-ng-model=\"clientOfflineSessionMaxLifespan.unit\"\n                        data-ng-change=\"updateClientOfflineSessionMaxLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-offline-session-max.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly && oauth2DeviceAuthorizationGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"oauth2DeviceCodeLifespan\">{{:: 'oauth2-device-code-lifespan'\n                    | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"1\" max=\"31536000\"\n                        data-ng-model=\"oauth2DeviceCodeLifespan.time\" id=\"oauth2DeviceCodeLifespan\"\n                        name=\"oauth2DeviceCodeLifespan\" data-ng-change=\"updateOauth2DeviceCodeLifespan()\" /> <select\n                        class=\"form-control\" name=\"oauth2DeviceCodeLifespanUnit\" data-ng-model=\"oauth2DeviceCodeLifespan.unit\"\n                        data-ng-change=\"updateOauth2DeviceCodeLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'oauth2-device-code-lifespan.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly && oauth2DeviceAuthorizationGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"oauth2DevicePollingInterval\">{{::\n                    'oauth2-device-polling-interval' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"1\" max=\"31536000\" data-ng-model=\"oauth2DevicePollingInterval\"\n                        id=\"oauth2DevicePollingInterval\" name=\"oauth2DevicePollingInterval\"\n                        data-ng-change=\"updateOauth2DevicePollingInterval()\" />\n                </div>\n                <kc-tooltip>{{:: 'oauth2-device-polling-interval.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"tlsClientCertificateBoundAccessTokens\">{{:: 'tls-client-certificate-bound-access-tokens' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"tlsClientCertificateBoundAccessTokens\" ng-click=\"switchChange()\" name=\"tlsClientCertificateBoundAccessTokens\" id=\"tlsClientCertificateBoundAccessTokens\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'tls-client-certificate-bound-access-tokens.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && clientEdit.standardFlowEnabled && clientEdit.implicitFlowEnabled\">\n                <label class=\"col-md-2 control-label\" for=\"useIdTokenAsDetachedSignature\">{{:: 'use-idtoken-as-detached-signature' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"useIdTokenAsDetachedSignature\" ng-click=\"switchChange()\" name=\"useIdTokenAsDetachedSignature\" id=\"useIdTokenAsDetachedSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'use-idtoken-as-detached-signature.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"changePkceCodeChallengeMethod\">{{:: 'pkce-code-challenge-method' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"pkceCodeChallengeMethod\"\n                                ng-change=\"changePkceCodeChallengeMethod()\"\n                                ng-model=\"pkceCodeChallengeMethod\"\n                                ng-options=\"method for method in changePkceCodeChallengeMethodOptions\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'pkce-code-challenge-method.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requirePushedAuthorizationRequests\">{{:: 'require-pushed-authorization-requests' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"requirePushedAuthorizationRequests\" ng-click=\"switchChange()\" name=\"requirePushedAuthorizationRequests\" id=\"requirePushedAuthorizationRequests\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'require-pushed-authorization-requests.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"!clientEdit.bearerOnly && protocol == 'openid-connect' && serverInfo.featureEnabled('STEP_UP_AUTHENTICATION')\">\n                <label class=\"col-md-2 control-label\" for=\"newAcr\">{{:: 'acr-loa-map' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group input-map\" ng-repeat=\"(acr, loa) in acrLoaMap\">\n                        <input class=\"form-control\" readonly value=\"{{acr}}\">\n                        <input class=\"form-control\" ng-model=\"acrLoaMap[acr]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteAcrLoaMapping(acr)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n                    <div class=\"input-group input-map\">\n                        <input class=\"form-control\" ng-model=\"newAcr\" id=\"newAcr\" placeholder=\"ACR\">\n                        <input class=\"form-control\" ng-model=\"newLoa\" id=\"newLoa\" placeholder=\"LOA\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newAcr.length > 0 && newLoa.length > 0 && addAcrLoaMapping()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'acr-loa-map-client.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"!clientEdit.bearerOnly && protocol == 'openid-connect' && serverInfo.featureEnabled('STEP_UP_AUTHENTICATION')\">\n                <label class=\"col-md-2 control-label\" for=\"newDefaultAcrValue\">{{:: 'default-acr-values' | translate}}</label>\n\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, defaultAcrValue) in defaultAcrValues track by $index\">\n                        <input class=\"form-control\" ng-model=\"defaultAcrValues[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteDefaultAcrValue($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newDefaultAcrValue\" id=\"newDefaultAcrValue\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newDefaultAcrValue.length > 0 && addDefaultAcrValue()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n\n                <kc-tooltip>{{:: 'default-acr-values.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n        </fieldset>\n\n        <fieldset>\n            <legend collapsed><span class=\"text\">{{:: 'client-flow-bindings' | translate}}</span>  <kc-tooltip>{{:: 'client-flow-bindings.tooltip' | translate}}</kc-tooltip></legend>\n            <div class=\"form-group\">\n                <label for=\"browser\" class=\"col-md-2 control-label\">{{:: 'browser-flow' | translate}}</label>\n                <div class=\"col-md-2\">\n                    <div>\n                        <select id=\"browser\" data-ng-model=\"clientEdit.authenticationFlowBindingOverrides['browser']\" class=\"form-control\" ng-options=\"flow.id as flow.alias for flow in flows\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'browser-flow.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label for=\"grant\" class=\"col-md-2 control-label\">{{:: 'direct-grant-flow' | translate}}</label>\n                <div class=\"col-md-2\">\n                    <div>\n                        <select id=\"grant\" ng-model=\"clientEdit.authenticationFlowBindingOverrides['direct_grant']\" class=\"form-control\" ng-options=\"flow.id as flow.alias for flow in flows\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'direct-grant-flow.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n\n\n        <div class=\"form-group\">\n            <div class=\"col-md-10 col-md-offset-2\" data-ng-show=\"client.access.configure\">\n                <button kc-save  data-ng-disabled=\"!changed\">{{:: 'save' | translate}}</button>\n                <button kc-reset data-ng-disabled=\"!changed\">{{:: 'cancel' | translate}}</button>\n            </div>\n        </div>\n    </form>\n</div>\n\n<kc-menu></kc-menu>\n"], "fixing_code": ["/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport org.jboss.logging.Logger;\nimport org.keycloak.models.ClientConfigResolver;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.protocol.saml.util.ArtifactBindingUtils;\nimport org.keycloak.saml.SignatureAlgorithm;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.common.util.XmlKeyInfoKeyNameTransformer;\n\n/**\n * Configuration of a SAML-enabled client.\n *\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class SamlClient extends ClientConfigResolver {\n\n    protected static final Logger logger = Logger.getLogger(SamlClient.class);\n\n    public static final XmlKeyInfoKeyNameTransformer DEFAULT_XML_KEY_INFO_KEY_NAME_TRANSFORMER = XmlKeyInfoKeyNameTransformer.KEY_ID;\n\n    public SamlClient(ClientModel client) {\n        super(client);\n    }\n\n    public String getCanonicalizationMethod() {\n        return resolveAttribute(SamlConfigAttributes.SAML_CANONICALIZATION_METHOD_ATTRIBUTE);\n    }\n\n    public void setCanonicalizationMethod(String value) {\n        client.setAttribute(SamlConfigAttributes.SAML_CANONICALIZATION_METHOD_ATTRIBUTE, value);\n    }\n\n    public SignatureAlgorithm getSignatureAlgorithm() {\n        String alg = resolveAttribute(SamlConfigAttributes.SAML_SIGNATURE_ALGORITHM);\n        if (alg != null) {\n            SignatureAlgorithm algorithm = SignatureAlgorithm.valueOf(alg);\n            if (algorithm != null)\n                return algorithm;\n        }\n        return SignatureAlgorithm.RSA_SHA256;\n    }\n\n    public void setSignatureAlgorithm(SignatureAlgorithm algorithm) {\n        client.setAttribute(SamlConfigAttributes.SAML_SIGNATURE_ALGORITHM, algorithm.name());\n    }\n\n    public String getNameIDFormat() {\n        String nameIdFormat = null;\n\n        String configuredNameIdFormat = resolveAttribute(SamlConfigAttributes.SAML_NAME_ID_FORMAT_ATTRIBUTE);\n        if (configuredNameIdFormat != null) {\n            if (configuredNameIdFormat.equals(\"email\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get();\n            } else if (configuredNameIdFormat.equals(\"persistent\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_PERSISTENT.get();\n            } else if (configuredNameIdFormat.equals(\"transient\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_TRANSIENT.get();\n            } else if (configuredNameIdFormat.equals(\"username\")) {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_UNSPECIFIED.get();\n            } else {\n                nameIdFormat = JBossSAMLURIConstants.NAMEID_FORMAT_UNSPECIFIED.get();\n            }\n        }\n        return nameIdFormat;\n\n    }\n\n    public static String samlNameIDFormatToClientAttribute(String nameIdFormat) {\n        if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_EMAIL.get())) {\n            return \"email\";\n        } else if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_PERSISTENT.get())) {\n            return \"persistent\";\n        } else if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_TRANSIENT.get())) {\n            return \"transient\";\n        } else if (nameIdFormat.equals(JBossSAMLURIConstants.NAMEID_FORMAT_UNSPECIFIED.get())) {\n            return \"username\";\n        }\n        return null;\n\n    }\n\n\n    public void setNameIDFormat(String format) {\n        client.setAttribute(SamlConfigAttributes.SAML_NAME_ID_FORMAT_ATTRIBUTE, format);\n    }\n\n    public boolean includeAuthnStatement() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_AUTHNSTATEMENT));\n    }\n\n    public void setIncludeAuthnStatement(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_AUTHNSTATEMENT, Boolean.toString(val));\n    }\n\n    public boolean forceNameIDFormat() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE));\n\n    }\n\n    public void setForceNameIDFormat(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE, Boolean.toString(val));\n    }\n\n    public boolean allowECPFlow() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ALLOW_ECP_FLOW));\n    }\n\n    public void setAllowECPFlow(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ALLOW_ECP_FLOW, Boolean.toString(val));\n    }\n\n    public boolean forceArtifactBinding(){\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING));\n    }\n\n    public void setForceArtifactBinding(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING, Boolean.toString(val));\n    }\n\n    public boolean requiresRealmSignature() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE));\n    }\n\n    public void setRequiresRealmSignature(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, Boolean.toString(val));\n    }\n\n    public boolean addExtensionsElementWithKeyInfo() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_EXT));\n    }\n\n    public void setAddExtensionsElementWithKeyInfo(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_EXT, Boolean.toString(val));\n    }\n\n    public boolean forcePostBinding() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_FORCE_POST_BINDING));\n    }\n\n    public void setForcePostBinding(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_FORCE_POST_BINDING, Boolean.toString(val));\n\n    }\n\n    public boolean requiresAssertionSignature() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ASSERTION_SIGNATURE));\n    }\n\n    public void setRequiresAssertionSignature(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ASSERTION_SIGNATURE, Boolean.toString(val));\n\n    }\n\n    public boolean requiresEncryption() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ENCRYPT));\n    }\n\n\n    public void setRequiresEncryption(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ENCRYPT, Boolean.toString(val));\n\n    }\n\n    public boolean requiresClientSignature() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE));\n    }\n\n    public void setRequiresClientSignature(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, Boolean.toString(val));\n\n    }\n\n    public String getClientSigningCertificate() {\n        return client.getAttribute(SamlConfigAttributes.SAML_SIGNING_CERTIFICATE_ATTRIBUTE);\n    }\n\n    public void setClientSigningCertificate(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SIGNING_CERTIFICATE_ATTRIBUTE, val);\n\n    }\n\n    public String getClientSigningPrivateKey() {\n        return client.getAttribute(SamlConfigAttributes.SAML_SIGNING_PRIVATE_KEY);\n    }\n\n    public void setClientSigningPrivateKey(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_SIGNING_PRIVATE_KEY, val);\n\n    }\n\n    public String getClientEncryptingCertificate() {\n        return client.getAttribute(SamlConfigAttributes.SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE);\n    }\n\n    public void setClientEncryptingCertificate(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE, val);\n\n    }\n\n    public String getClientEncryptingPrivateKey() {\n        return client.getAttribute(SamlConfigAttributes.SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE);\n    }\n\n    public void setClientEncryptingPrivateKey(String val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE, val);\n\n    }\n\n    /**\n     * Always returns non-{@code null} result.\n     *\n     * @return Configured ransformer of {@link #DEFAULT_XML_KEY_INFO_KEY_NAME_TRANSFORMER} if not set.\n     */\n    public XmlKeyInfoKeyNameTransformer getXmlSigKeyInfoKeyNameTransformer() {\n        return XmlKeyInfoKeyNameTransformer.from(\n                client.getAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER),\n                DEFAULT_XML_KEY_INFO_KEY_NAME_TRANSFORMER);\n    }\n\n    public void setXmlSigKeyInfoKeyNameTransformer(XmlKeyInfoKeyNameTransformer xmlSigKeyInfoKeyNameTransformer) {\n        client.setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER,\n                xmlSigKeyInfoKeyNameTransformer == null\n                        ? null\n                        : xmlSigKeyInfoKeyNameTransformer.name());\n    }\n\n    public boolean includeOneTimeUseCondition() {\n        return \"true\".equals(resolveAttribute(SamlConfigAttributes.SAML_ONETIMEUSE_CONDITION));\n    }\n\n    public void setIncludeOneTimeUseCondition(boolean val) {\n        client.setAttribute(SamlConfigAttributes.SAML_ONETIMEUSE_CONDITION, Boolean.toString(val));\n    }\n\n    public void setAssertionLifespan(int assertionLifespan) {\n        client.setAttribute(SamlConfigAttributes.SAML_ASSERTION_LIFESPAN, Integer.toString(assertionLifespan));\n    }\n\n    public int getAssertionLifespan() {\n        String value = client.getAttribute(SamlConfigAttributes.SAML_ASSERTION_LIFESPAN);\n        if (value == null || value.isEmpty()) {\n            return -1;\n        }\n        try {\n            return Integer.parseInt(value);\n        } catch (NumberFormatException e) {\n            logger.warnf(\"Invalid numeric value for saml attribute \\\"%s\\\": %s\", SamlConfigAttributes.SAML_ASSERTION_LIFESPAN, value);\n            return -1;\n        }\n    }\n\n    public void setArtifactBindingIdentifierFrom(String identifierFrom) {\n        client.setAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(identifierFrom));\n    }\n\n    public String getArtifactBindingIdentifier() {\n        return client.getAttribute(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER);\n    }\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport org.keycloak.services.util.CertificateInfoHelper;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic interface SamlConfigAttributes {\n    String SAML_SIGNING_PRIVATE_KEY = \"saml.signing.private.key\";\n    String SAML_CANONICALIZATION_METHOD_ATTRIBUTE = \"saml_signature_canonicalization_method\";\n    String SAML_SIGNATURE_ALGORITHM = \"saml.signature.algorithm\";\n    String SAML_NAME_ID_FORMAT_ATTRIBUTE = \"saml_name_id_format\";\n    String SAML_AUTHNSTATEMENT = \"saml.authnstatement\";\n    String SAML_ONETIMEUSE_CONDITION = \"saml.onetimeuse.condition\";\n    String SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE = \"saml_force_name_id_format\";\n    String SAML_ARTIFACT_BINDING = \"saml.artifact.binding\";\n    String SAML_SERVER_SIGNATURE = \"saml.server.signature\";\n    String SAML_SERVER_SIGNATURE_KEYINFO_EXT = \"saml.server.signature.keyinfo.ext\";\n    String SAML_SERVER_SIGNATURE_KEYINFO_KEY_NAME_TRANSFORMER = \"saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer\";\n    String SAML_FORCE_POST_BINDING = \"saml.force.post.binding\";\n    String SAML_ASSERTION_SIGNATURE = \"saml.assertion.signature\";\n    String SAML_ENCRYPT = \"saml.encrypt\";\n    String SAML_CLIENT_SIGNATURE_ATTRIBUTE = \"saml.client.signature\";\n    String SAML_SIGNING_CERTIFICATE_ATTRIBUTE = \"saml.signing.\" + CertificateInfoHelper.X509CERTIFICATE;\n    String SAML_ENCRYPTION_CERTIFICATE_ATTRIBUTE = \"saml.encryption.\" + CertificateInfoHelper.X509CERTIFICATE;\n    String SAML_ENCRYPTION_PRIVATE_KEY_ATTRIBUTE = \"saml.encryption.\" + CertificateInfoHelper.PRIVATE_KEY;\n    String SAML_ASSERTION_LIFESPAN = \"saml.assertion.lifespan\";\n    String SAML_ARTIFACT_BINDING_IDENTIFIER = \"saml.artifact.binding.identifier\";\n    String SAML_ALLOW_ECP_FLOW = \"saml.allow.ecp.flow\";\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport org.keycloak.Config;\nimport org.keycloak.events.EventBuilder;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.models.ClientScopeModel;\nimport org.keycloak.models.KeycloakSession;\nimport org.keycloak.models.ProtocolMapperModel;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.utils.KeycloakModelUtils;\nimport org.keycloak.protocol.AbstractLoginProtocolFactory;\nimport org.keycloak.protocol.LoginProtocol;\nimport org.keycloak.protocol.saml.mappers.AttributeStatementHelper;\nimport org.keycloak.protocol.saml.mappers.RoleListMapper;\nimport org.keycloak.protocol.saml.mappers.UserPropertyAttributeStatementMapper;\nimport org.keycloak.representations.idm.CertificateRepresentation;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.saml.SignatureAlgorithm;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.processing.core.saml.v2.constants.X500SAMLProfileConstants;\n\nimport org.keycloak.saml.validators.DestinationValidator;\nimport javax.xml.crypto.dsig.CanonicalizationMethod;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class SamlProtocolFactory extends AbstractLoginProtocolFactory {\n\n    public static final String SCOPE_ROLE_LIST = \"role_list\";\n    private static final String ROLE_LIST_CONSENT_TEXT = \"${samlRoleListScopeConsentText}\";\n\n    private DestinationValidator destinationValidator;\n\n    @Override\n    public Object createProtocolEndpoint(RealmModel realm, EventBuilder event) {\n        return new SamlService(realm, event, destinationValidator);\n    }\n\n    @Override\n    public LoginProtocol create(KeycloakSession session) {\n        return new SamlProtocol().setSession(session);\n    }\n\n    @Override\n    public void init(Config.Scope config) {\n        //PicketLinkCoreSTS sts = PicketLinkCoreSTS.instance();\n        //sts.installDefaultConfiguration();\n\n        this.destinationValidator = DestinationValidator.forProtocolMap(config.getArray(\"knownProtocols\"));\n    }\n\n    @Override\n    public String getId() {\n        return SamlProtocol.LOGIN_PROTOCOL;\n    }\n\n    @Override\n    public Map<String, ProtocolMapperModel> getBuiltinMappers() {\n        return builtins;\n    }\n\n    static Map<String, ProtocolMapperModel> builtins = new HashMap<>();\n    static List<ProtocolMapperModel> defaultBuiltins = new ArrayList<>();\n\n    static {\n        ProtocolMapperModel model;\n        model = UserPropertyAttributeStatementMapper.createAttributeMapper(\"X500 email\",\n                \"email\",\n                X500SAMLProfileConstants.EMAIL.get(),\n                JBossSAMLURIConstants.ATTRIBUTE_FORMAT_URI.get(),\n                X500SAMLProfileConstants.EMAIL.getFriendlyName(),\n                true, \"${email}\");\n        builtins.put(\"X500 email\", model);\n        model = UserPropertyAttributeStatementMapper.createAttributeMapper(\"X500 givenName\",\n                \"firstName\",\n                X500SAMLProfileConstants.GIVEN_NAME.get(),\n                JBossSAMLURIConstants.ATTRIBUTE_FORMAT_URI.get(),\n                X500SAMLProfileConstants.GIVEN_NAME.getFriendlyName(),\n                true, \"${givenName}\");\n        builtins.put(\"X500 givenName\", model);\n        model = UserPropertyAttributeStatementMapper.createAttributeMapper(\"X500 surname\",\n                \"lastName\",\n                X500SAMLProfileConstants.SURNAME.get(),\n                JBossSAMLURIConstants.ATTRIBUTE_FORMAT_URI.get(),\n                X500SAMLProfileConstants.SURNAME.getFriendlyName(),\n                true, \"${familyName}\");\n        builtins.put(\"X500 surname\", model);\n        model = RoleListMapper.create(\"role list\", \"Role\", AttributeStatementHelper.BASIC, null, false);\n        builtins.put(\"role list\", model);\n        defaultBuiltins.add(model);\n\n    }\n\n\n    @Override\n    protected void createDefaultClientScopesImpl(RealmModel newRealm) {\n        ClientScopeModel roleListScope = newRealm.addClientScope(SCOPE_ROLE_LIST);\n        roleListScope.setDescription(\"SAML role list\");\n        roleListScope.setDisplayOnConsentScreen(true);\n        roleListScope.setConsentScreenText(ROLE_LIST_CONSENT_TEXT);\n        roleListScope.setProtocol(getId());\n        roleListScope.addProtocolMapper(builtins.get(\"role list\"));\n        newRealm.addDefaultClientScope(roleListScope, true);\n    }\n\n    @Override\n    protected void addDefaults(ClientModel client) {\n    }\n\n    @Override\n    public void setupClientDefaults(ClientRepresentation clientRep, ClientModel newClient) {\n        SamlRepresentationAttributes rep = new SamlRepresentationAttributes(clientRep.getAttributes());\n        SamlClient client = new SamlClient(newClient);\n        if (clientRep.isStandardFlowEnabled() == null) newClient.setStandardFlowEnabled(true);\n        if (rep.getCanonicalizationMethod() == null) {\n            client.setCanonicalizationMethod(CanonicalizationMethod.EXCLUSIVE);\n        }\n        if (rep.getSignatureAlgorithm() == null) {\n            client.setSignatureAlgorithm(SignatureAlgorithm.RSA_SHA256);\n        }\n\n        if (rep.getNameIDFormat() == null) {\n            client.setNameIDFormat(\"username\");\n        }\n\n        if (rep.getIncludeAuthnStatement() == null) {\n            client.setIncludeAuthnStatement(true);\n        }\n\n        if (rep.getForceNameIDFormat() == null) {\n            client.setForceNameIDFormat(false);\n        }\n\n        if (rep.getAllowEcpFlow() == null) {\n            client.setAllowECPFlow(false);\n        }\n\n        if (rep.getSamlServerSignature() == null) {\n            client.setRequiresRealmSignature(true);\n        }\n        if (rep.getForcePostBinding() == null) {\n            client.setForcePostBinding(true);\n        }\n\n        if (rep.getClientSignature() == null) {\n            client.setRequiresClientSignature(true);\n        }\n\n        if (client.requiresClientSignature() && client.getClientSigningCertificate() == null) {\n            CertificateRepresentation info = KeycloakModelUtils.generateKeyPairCertificate(newClient.getClientId());\n            client.setClientSigningCertificate(info.getCertificate());\n            client.setClientSigningPrivateKey(info.getPrivateKey());\n\n        }\n\n        if (clientRep.isFrontchannelLogout() == null) {\n            newClient.setFrontchannelLogout(true);\n        }\n\n        client.setArtifactBindingIdentifierFrom(clientRep.getClientId());\n    }\n\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml;\n\nimport java.util.Map;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class SamlRepresentationAttributes {\n    protected Map<String, String> attributes;\n\n    public SamlRepresentationAttributes(Map<String, String> attributes) {\n        this.attributes = attributes;\n    }\n\n    public String getCanonicalizationMethod() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_CANONICALIZATION_METHOD_ATTRIBUTE);\n    }\n\n    protected Map<String, String> getAttributes() {\n        return attributes;\n    }\n\n    public String getSignatureAlgorithm() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_SIGNATURE_ALGORITHM);\n    }\n\n    public String getNameIDFormat() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_NAME_ID_FORMAT_ATTRIBUTE);\n\n    }\n\n    public String getIncludeAuthnStatement() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_AUTHNSTATEMENT);\n\n    }\n\n    public String getForceNameIDFormat() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_FORCE_NAME_ID_FORMAT_ATTRIBUTE);\n    }\n\n    public String getAllowEcpFlow() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_ALLOW_ECP_FLOW);\n    }\n\n    public String getSamlArtifactBinding() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_ARTIFACT_BINDING);\n    }\n\n    public String getSamlServerSignature() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_SERVER_SIGNATURE);\n    }\n\n    public String getAddExtensionsElementWithKeyInfo() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_SERVER_SIGNATURE_KEYINFO_EXT);\n    }\n\n    public String getForcePostBinding() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_FORCE_POST_BINDING);\n\n    }\n    public String getClientSignature() {\n        if (getAttributes() == null) return null;\n        return getAttributes().get(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE);\n\n    }\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.protocol.saml.profile.ecp;\n\nimport org.keycloak.dom.saml.v2.protocol.AuthnRequestType;\nimport org.keycloak.events.EventBuilder;\nimport org.keycloak.models.AuthenticationFlowModel;\nimport org.keycloak.models.AuthenticatedClientSessionModel;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.UserSessionModel;\nimport org.keycloak.models.utils.DefaultAuthenticationFlows;\nimport org.keycloak.protocol.saml.JaxrsSAML2BindingBuilder;\nimport org.keycloak.protocol.saml.SamlClient;\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.protocol.saml.SamlProtocol;\nimport org.keycloak.protocol.saml.SamlService;\nimport org.keycloak.protocol.saml.profile.util.Soap;\nimport org.keycloak.saml.SAML2LogoutResponseBuilder;\nimport org.keycloak.saml.common.constants.JBossSAMLConstants;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.common.exceptions.ConfigurationException;\nimport org.keycloak.saml.common.exceptions.ProcessingException;\nimport org.keycloak.saml.validators.DestinationValidator;\nimport org.keycloak.services.managers.AuthenticationManager;\nimport org.keycloak.sessions.AuthenticationSessionModel;\nimport org.w3c.dom.Document;\n\nimport javax.ws.rs.core.Response;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPHeaderElement;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Objects;\n\n/**\n * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n */\npublic class SamlEcpProfileService extends SamlService {\n\n    private static final String NS_PREFIX_PROFILE_ECP = \"ecp\";\n    private static final String NS_PREFIX_SAML_PROTOCOL = \"samlp\";\n    private static final String NS_PREFIX_SAML_ASSERTION = \"saml\";\n\n    public SamlEcpProfileService(RealmModel realm, EventBuilder event, DestinationValidator destinationValidator) {\n        super(realm, event, destinationValidator);\n    }\n\n    public Response authenticate(InputStream inputStream) {\n        return authenticate(Soap.extractSoapMessage(inputStream));\n    }\n\n    public Response authenticate(Document soapMessage) {\n        try {\n            return new PostBindingProtocol() {\n                @Override\n                protected String getBindingType(AuthnRequestType requestAbstractType) {\n                    return SamlProtocol.SAML_SOAP_BINDING;\n                }\n\n                @Override\n                protected boolean isDestinationRequired() {\n                    return false;\n                }\n\n                @Override\n                protected Response loginRequest(String relayState, AuthnRequestType requestAbstractType, ClientModel client) {\n                    // Do not allow ECP login when client does not support it\n                    if (!new SamlClient(client).allowECPFlow()) {\n                        logger.errorf(\"Client %s is not allowed to execute ECP flow\", client.getClientId());\n                        throw new RuntimeException(\"Client is not allowed to use ECP profile.\");\n                    }\n\n                    // force passive authentication when executing this profile\n                    requestAbstractType.setIsPassive(true);\n                    requestAbstractType.setDestination(session.getContext().getUri().getAbsolutePath());\n                    return super.loginRequest(relayState, requestAbstractType, client);\n                }\n            }.execute(Soap.toSamlHttpPostMessage(soapMessage), null, null, null);\n        } catch (Exception e) {\n            String reason = \"Some error occurred while processing the AuthnRequest.\";\n            String detail = e.getMessage();\n\n            if (detail == null) {\n                detail = reason;\n            }\n\n            return Soap.createFault().reason(reason).detail(detail).build();\n        }\n    }\n\n    @Override\n    protected Response newBrowserAuthentication(AuthenticationSessionModel authSession, boolean isPassive, boolean redirectToAuthentication, SamlProtocol samlProtocol) {\n        // Saml ECP flow creates only TRANSIENT user sessions\n        authSession.setClientNote(AuthenticationManager.USER_SESSION_PERSISTENT_STATE, UserSessionModel.SessionPersistenceState.TRANSIENT.toString());\n        return super.newBrowserAuthentication(authSession, isPassive, redirectToAuthentication, createEcpSamlProtocol());\n    }\n\n    private SamlProtocol createEcpSamlProtocol() {\n        return new SamlProtocol() {\n            // method created to send a SOAP Binding response instead of a HTTP POST response\n            @Override\n            protected Response buildAuthenticatedResponse(AuthenticatedClientSessionModel clientSession, String redirectUri, Document samlDocument, JaxrsSAML2BindingBuilder bindingBuilder) throws ConfigurationException, ProcessingException, IOException {\n                Document document = bindingBuilder.postBinding(samlDocument).getDocument();\n\n                try {\n                    Soap.SoapMessageBuilder messageBuilder = Soap.createMessage()\n                            .addNamespace(NS_PREFIX_SAML_ASSERTION, JBossSAMLURIConstants.ASSERTION_NSURI.get())\n                            .addNamespace(NS_PREFIX_SAML_PROTOCOL, JBossSAMLURIConstants.PROTOCOL_NSURI.get())\n                            .addNamespace(NS_PREFIX_PROFILE_ECP, JBossSAMLURIConstants.ECP_PROFILE.get());\n\n                    createEcpResponseHeader(redirectUri, messageBuilder);\n                    createRequestAuthenticatedHeader(clientSession, messageBuilder);\n\n                    messageBuilder.addToBody(document);\n\n                    return messageBuilder.build();\n                } catch (Exception e) {\n                    throw new RuntimeException(\"Error while creating SAML response.\", e);\n                }\n            }\n\n            private void createRequestAuthenticatedHeader(AuthenticatedClientSessionModel clientSession, Soap.SoapMessageBuilder messageBuilder) {\n                ClientModel client = clientSession.getClient();\n\n                if (\"true\".equals(client.getAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE))) {\n                    SOAPHeaderElement ecpRequestAuthenticated = messageBuilder.addHeader(JBossSAMLConstants.REQUEST_AUTHENTICATED.get(), NS_PREFIX_PROFILE_ECP);\n\n                    ecpRequestAuthenticated.setMustUnderstand(true);\n                    ecpRequestAuthenticated.setActor(\"http://schemas.xmlsoap.org/soap/actor/next\");\n                }\n            }\n\n            private void createEcpResponseHeader(String redirectUri, Soap.SoapMessageBuilder messageBuilder) throws SOAPException {\n                SOAPHeaderElement ecpResponseHeader = messageBuilder.addHeader(JBossSAMLConstants.RESPONSE__ECP.get(), NS_PREFIX_PROFILE_ECP);\n\n                ecpResponseHeader.setMustUnderstand(true);\n                ecpResponseHeader.setActor(\"http://schemas.xmlsoap.org/soap/actor/next\");\n                ecpResponseHeader.addAttribute(messageBuilder.createName(JBossSAMLConstants.ASSERTION_CONSUMER_SERVICE_URL.get()), redirectUri);\n            }\n\n            @Override\n            protected Response buildErrorResponse(boolean isPostBinding, String uri, JaxrsSAML2BindingBuilder binding, Document document) throws ConfigurationException, ProcessingException, IOException {\n                return Soap.createMessage().addToBody(document).build();\n            }\n\n            @Override\n            protected Response buildLogoutResponse(UserSessionModel userSession, String logoutBindingUri, SAML2LogoutResponseBuilder builder, JaxrsSAML2BindingBuilder binding) throws ConfigurationException, ProcessingException, IOException {\n                return Soap.createFault().reason(\"Logout not supported.\").build();\n            }\n        }.setEventBuilder(event).setHttpHeaders(headers).setRealm(realm).setSession(session).setUriInfo(session.getContext().getUri());\n    }\n\n    @Override\n    protected AuthenticationFlowModel getAuthenticationFlow(AuthenticationSessionModel authSession) {\n        return realm.getAuthenticationFlowsStream()\n                .filter(flow -> Objects.equals(flow.getAlias(), DefaultAuthenticationFlows.SAML_ECP_FLOW))\n                .findFirst()\n                .orElseThrow(() -> new RuntimeException(\"Could not resolve authentication flow for SAML ECP Profile.\"));\n    }\n}\n", "/*\n * Copyright 2021 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.keycloak.testsuite.saml;\n\nimport org.junit.Test;\nimport org.keycloak.dom.saml.v2.SAML2Object;\nimport org.keycloak.dom.saml.v2.assertion.AuthnStatementType;\nimport org.keycloak.dom.saml.v2.protocol.ResponseType;\nimport org.keycloak.dom.saml.v2.protocol.StatusResponseType;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.UserSessionModel;\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.saml.common.constants.JBossSAMLURIConstants;\nimport org.keycloak.saml.processing.core.saml.v2.common.SAMLDocumentHolder;\nimport org.keycloak.testsuite.updaters.ClientAttributeUpdater;\nimport org.keycloak.testsuite.util.SamlClientBuilder;\n\nimport javax.ws.rs.core.Response;\nimport javax.xml.soap.MessageFactory;\nimport javax.xml.soap.SOAPException;\nimport javax.xml.soap.SOAPMessage;\n\nimport java.io.IOException;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.empty;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hamcrest.Matchers.is;\nimport static org.hamcrest.Matchers.not;\nimport static org.hamcrest.Matchers.nullValue;\nimport static org.keycloak.testsuite.util.Matchers.isSamlResponse;\nimport static org.keycloak.testsuite.util.Matchers.statusCodeIsHC;\nimport static org.keycloak.testsuite.util.SamlClient.Binding.POST;\nimport static org.keycloak.testsuite.util.SamlClient.Binding.SOAP;\n\npublic class SOAPBindingTest extends AbstractSamlTest {\n\n    @Test\n    public void soapBindingAuthnWithSignatureTest() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                    .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingAuthnWithSignatureMissingDestinationTest() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                    .transformObject(authnRequestType -> {\n                        authnRequestType.setDestination(null);\n                        return authnRequestType;\n                    })\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingAuthnWithoutSignatureTest() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingAuthnWithoutSignatureMissingDestinationTest() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                    .transformObject(authnRequestType -> {\n                        authnRequestType.setDestination(null);\n                        return authnRequestType;\n                    })\n                    .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(ResponseType.class));\n        ResponseType rt = (ResponseType)response.getSamlObject();\n        assertThat(rt.getAssertions(), not(empty()));\n    }\n\n    @Test\n    public void soapBindingLogoutWithSignature() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                    .nameId(nameIdRef::get)\n                    .sessionIndex(sessionIndexRef::get)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingLogoutWithoutSignature() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                    .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                    .nameId(nameIdRef::get)\n                    .sessionIndex(sessionIndexRef::get)\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingLogoutWithSignatureMissingDestinationTest() {\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                    .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                    .nameId(nameIdRef::get)\n                    .sessionIndex(sessionIndexRef::get)\n                    .signWith(SAML_CLIENT_SALES_POST_SIG_PRIVATE_KEY, SAML_CLIENT_SALES_POST_SIG_PUBLIC_KEY)\n                    .transformObject(logoutRequestType -> {\n                        logoutRequestType.setDestination(null);\n                        return logoutRequestType;\n                    })\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingLogoutWithoutSignatureMissingDestinationTest() {\n        getCleanup()\n                .addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                        .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                        .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                        .update()\n                );\n\n        SAMLDocumentHolder response = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, POST)\n                .build()\n                .login().user(bburkeUser).build()\n                .processSamlResponse(POST)\n                .transformObject(this::extractNameIdAndSessionIndexAndTerminate)\n                .build()\n                .logoutRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SOAP)\n                .nameId(nameIdRef::get)\n                .sessionIndex(sessionIndexRef::get)\n                .transformObject(logoutRequestType -> {\n                    logoutRequestType.setDestination(null);\n                    return logoutRequestType;\n                })\n                .build()\n                .executeAndTransform(POST::extractResponse);\n\n\n        assertThat(response.getSamlObject(), instanceOf(StatusResponseType.class));\n    }\n\n    @Test\n    public void soapBindingIsNotPossibleForClientsWithSamlEcpFlowAttributeFalse() {\n        // Disable ECP_FLOW_ENABLED switch\n        getCleanup().addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                .setAttribute(SamlConfigAttributes.SAML_ALLOW_ECP_FLOW, \"false\")\n                .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                .update());\n\n        new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                .basicAuthentication(bburkeUser)\n                .build()\n                .execute(response -> {\n                    assertThat(response, statusCodeIsHC(Response.Status.INTERNAL_SERVER_ERROR));\n\n                    try {\n                        MessageFactory messageFactory = MessageFactory.newInstance();\n                        SOAPMessage soapMessage = messageFactory.createMessage(null, response.getEntity().getContent());\n                        String faultDetail = soapMessage.getSOAPBody().getFault().getDetail().getValue();\n                        assertThat(faultDetail, is(equalTo(\"Client is not allowed to use ECP profile.\")));\n                    } catch (SOAPException | IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                });\n\n    }\n\n    @Test\n    public void ecpFlowCreatesTransientSessions() {\n        // Disable ECP_FLOW_ENABLED switch\n        getCleanup().addCleanup(ClientAttributeUpdater.forClient(adminClient, REALM_NAME, SAML_CLIENT_ID_ECP_SP)\n                .setAttribute(SamlConfigAttributes.SAML_SERVER_SIGNATURE, \"false\")\n                .setAttribute(SamlConfigAttributes.SAML_CLIENT_SIGNATURE_ATTRIBUTE, \"false\")\n                .update());\n\n        // Successfully login using ECP flow\n        SAML2Object samlObject = new SamlClientBuilder()\n                .authnRequest(getAuthServerSamlEndpoint(REALM_NAME), SAML_CLIENT_ID_ECP_SP, SAML_ASSERTION_CONSUMER_URL_ECP_SP, SOAP)\n                .basicAuthentication(bburkeUser)\n                .build()\n                .executeAndTransform(SOAP::extractResponse).getSamlObject();\n\n        assertThat(samlObject, isSamlResponse(JBossSAMLURIConstants.STATUS_SUCCESS));\n        ResponseType loginResp1 = (ResponseType) samlObject;\n        AuthnStatementType sessionId = (AuthnStatementType) loginResp1.getAssertions().get(0).getAssertion().getStatements().iterator().next();\n\n        String userSessionId = sessionId.getSessionIndex().split(\"::\")[0];\n\n        // Test that the user session with the given ID does not exist\n        testingClient.server().run(session -> {\n            RealmModel realmByName = session.realms().getRealmByName(REALM_NAME);\n            UserSessionModel userSession = session.sessions().getUserSession(realmByName, userSessionId);\n\n            assertThat(userSession, nullValue());\n        });\n\n\n    }\n}\n", "{\n    \"id\": \"demo\",\n    \"realm\": \"demo\",\n    \"enabled\": true,\n    \"sslRequired\": \"external\",\n    \"registrationAllowed\": true,\n    \"resetPasswordAllowed\": true,\n    \"privateKey\": \"MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y=\",\n    \"publicKey\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n    \"requiredCredentials\": [ \"password\" ],\n    \"passwordPolicy\": \"hashIterations(1)\",\n    \"defaultRoles\": [ \"user\" ],\n    \"smtpServer\": {\n        \"from\": \"auto@keycloak.org\",\n        \"host\": \"localhost\",\n        \"port\":\"3025\"\n    },\n    \"eventsEnabled\" : true,\n    \"eventsListeners\" : [ \"jboss-logging\" ],\n    \"enabledEventTypes\" : [ ],\n    \"users\" : [\n        {\n            \"username\" : \"bburke\",\n            \"enabled\": true,\n            \"email\" : \"bburke@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"attributes\" : {\n                \"phone\": \"617\"\n            },\n            \"realmRoles\": [\"manager\", \"user\"],\n            \"applicationRoles\": {\n                \"http://localhost:8280/employee/\": [ \"employee\" ],\n                \"http://localhost:8280/employee2/\": [ \"empl.oyee\", \"employee\" ],\n                \"http://localhost:8280/employee-role-mapping/\": [\"employee\"]\n            }\n        },\n        {\n            \"username\" : \"bburke-additional-domain\",\n            \"enabled\": true,\n            \"email\" : \"bburke@redhat.com.additional.domain\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"attributes\" : {\n                \"phone\": \"617\"\n            },\n            \"realmRoles\": [\"manager\", \"user\"],\n            \"applicationRoles\": {\n                \"http://localhost:8280/employee/\": [ \"employee\" ],\n                \"http://localhost:8280/employee2/\": [ \"employee\" ]\n            }\n        },\n        {\n            \"username\" : \"unauthorized\",\n            \"enabled\": true,\n            \"email\" : \"unauthorized@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ]\n        },\n        {\n            \"username\" : \"topGroupUser\",\n            \"enabled\": true,\n            \"email\" : \"top@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"groups\": [\n                \"/top\"\n            ]\n        },\n        {\n            \"username\" : \"level2GroupUser\",\n            \"enabled\": true,\n            \"email\" : \"level2@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"groups\": [\n                \"/top/level2\"\n            ]\n        },\n        {\n            \"username\" : \"pedroigor\",\n            \"enabled\": true,\n            \"email\" : \"psilva@redhat.com\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"attributes\" : {\n                \"phone\": \"617\"\n            },\n            \"realmRoles\": [\"manager\", \"user\"]\n        }\n    ],\n    \"clients\": [\n        {\n            \"clientId\": \"http://localhost:8280/missing-assertion-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/missing-assertion-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/missing-assertion-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/missing-assertion-sig/saml\",\n                \"saml.server.signature\": \"true\",\n                \"saml.assertion.signature\": \"false\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/bad-assertion-sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/bad-assertion-sales-post-sig/\",\n            \"adminUrl\": \"http://localhost:8080/bad-assertion-sales-post-sig/saml\",\n            \"redirectUris\": [\n                \"http://localhost:8080/bad-assertion-sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.assertion.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/input-portal/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/input-portal\",\n            \"redirectUris\": [\n                \"http://localhost:8080/input-portal/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/input-portal/saml\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/input-portal/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/input-portal/saml\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/input-portal/saml\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-assertion-and-response-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-assertion-and-response-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-assertion-and-response-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/sales-post-assertion-and-response-sig/saml\",\n                \"saml.server.signature\": \"true\",\n                \"saml.assertion.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post2/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post2\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post2/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/sales-post2/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/sales-post2/saml\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post2\",\n                \"saml_idp_initiated_sso_relay_state\": \"redirectTo=/foo\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/different-cookie-name/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/different-cookie-name\",\n            \"redirectUris\": [\n                \"http://localhost:8080/different-cookie-name/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/different-cookie-name/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/different-cookie-name/saml\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/sales-post/saml\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/sales-post/saml\",\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-clock-skew/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post-clock-skew\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-clock-skew/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post-clock-skew\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-passive/\",\n            \"enabled\": true,\n            \"fullScopeAllowed\": true,\n            \"protocol\": \"saml\",\n            \"baseUrl\": \"http://localhost:8080/sales-post-passive\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-passive/*\"\n            ],\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\": \"sales-post-passive\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig-transient/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig-transient\",\n            \"adminUrl\": \"http://localhost:8080/sales-post-sig-transient\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig-transient/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig-persistent/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig-persistent\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig-persistent/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-sig-email/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-sig-email\",\n            \"adminUrl\": \"http://localhost:8080/sales-post-sig-email\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-sig-email/*\"\n            ],\n            \"attributes\": {\n                \"saml_force_name_id_format\": \"true\",\n                \"saml_name_id_format\": \"email\",\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\" : \"sales-post-sig-email\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/bad-realm-sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/bad-realm-sales-post-sig\",\n            \"adminUrl\": \"http://localhost:8080/bad-realm-sales-post-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/bad-realm-sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/bad-client-sales-post-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/bad-client-sales-post-sig\",\n            \"adminUrl\": \"http://localhost:8080/bad-client-sales-post-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/bad-client-sales-post-sig/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-enc/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-enc\",\n            \"redirectUris\": [\n                \"http://localhost:8080/sales-post-enc/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA512\",\n                \"saml.client.signature\": \"true\",\n                \"saml.encrypt\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\",\n                \"saml.encryption.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/sales-post-enc-sign-assertions-only/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/sales-post-enc-sign-assertions-only\",\n            \"redirectUris\": [\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"false\",\n                \"saml.assertion.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA512\",\n                \"saml.client.signature\": \"true\",\n                \"saml.encrypt\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\",\n                \"saml.encryption.certificate\": \"MIIB1DCCAT0CBgFJGVacCDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1lbmMvMB4XDTE0MTAxNjE0MjA0NloXDTI0MTAxNjE0MjIyNlowMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3QtZW5jLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA2+5MCT5BnVN+IYnKZcH6ev1pjXGi4feE0nOycq/VJ3aeaZMi4G9AxOxCBPupErOC7Kgm/Bw5AdJyw+Q12wSRXfJ9FhqCrLXpb7YOhbVSTJ8De5O8mW35DxAlh/cxe9FXjqPb286wKTUZ3LfGYR+X235UQeCTAPS/Ufi21EXaEikCAwEAATANBgkqhkiG9w0BAQsFAAOBgQBMrfGD9QFfx5v7ld/OAto5rjkTe3R1Qei8XRXfcs83vLaqEzjEtTuLGrJEi55kXuJgBpVmQpnwCCkkjSy0JxbqLDdVi9arfWUxEGmOr01ZHycELhDNaQcFqVMPr5kRHIHgktT8hK2IgCvd3Fy9/JCgUgCPxKfhwecyEOKxUc857g==\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-redir-noidpkey/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-redir-noidpkey\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-redir-noidpkey/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig-redir-noidpkey\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-redir-opt-noidpkey/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-redir-opt-noidpkey\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-redir-opt-noidpkey/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig-redir-opt-noidpkey\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.server.signature.keyinfo.ext\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-post-noidpkey/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-post-noidpkey\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-post-noidpkey/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-sig-post-noidpkey\",\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-acs/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-acs\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-acs/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-acs\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee2/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee2\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee2/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee2\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\" : \"employee2\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-dom/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-dom\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-dom/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-dom\",\n            \"attributes\": {\n                \"saml.assertion.signature\": \"true\",\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIC+zCCAeOgAwIBAgIEcFrChjANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtZG9tLzAeFw0xOTA3MDMwOTE1NDlaFw00NjExMTgwOTE1NDlaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1kb20vMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmEbjaKmKCh2MXTVLMUXdbjKSdmXAOenuE2bDD0AlEaJmnJ5zU2JY6UuFflH3332n2YktaaCyTznwX1Zcf7GH3bm7xhV1HSmlbFpIY17M8QUOIGZEzvKSbT9gjRJSPIdE1JvZuqgzuXpRlRfC4eoH1VgS0Vmu4gwIRFnUUgqc5hW11AQVkGZs7TkEYbVEYneKMbQOKa1OzW+FAb7C13Yn19gSvGr3THE+7FGwxEJM6N6kr4xnxg4VpaXcsW4ijGI3CHPJA06MZ6LzXxCmz+8TOSLo5pV7GKgME9QR1lBSC2Cp0yDtHjqK6QCqApyHhP2xN8qzJhMIhffSSHq4GokhjwIDAQABoyEwHzAdBgNVHQ4EFgQUOVG/h7cr+T6LJ4dQIVALBknwF/AwDQYJKoZIhvcNAQELBQADggEBAI5Y1MPMHPsDRJBQke/+tkRO4PALbsAQtfvYDNmpBGzUNo2xU3n7PNzbWrcqubjLN0nqXloBTaeeHtrFGAejMCS5X8UOGLyXbKBm7hHJs5ZZASrm0FkUzyuJexWCbSAg0p7Z6wWw03dnV/A9LDFwTdGIYsnSzZ59/v3BUH89mavOwVuVJB5O2PysUob3urcv1tmv9eL5jAMc764ID1gLkydcNrmICa+aZ/FojfReyTtwWX0DoPflPvF/Xllp3jLg1HwSlD6fD2wO/MKawgBbE6xrAkg5bF01B25RadJJffx3hEtgxBzlo1EL4Ir+lJmM1vzuTq4c1wDYKku4Y0Qg5o0=\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-sig-front/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"frontchannelLogout\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-sig-front\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-sig-front/*\"\n            ],\n            \"attributes\": {\n                \"saml.server.signature\": \"true\",\n                \"saml.client.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA1\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB0DCCATkCBgFJH5u0EDANBgkqhkiG9w0BAQsFADAuMSwwKgYDVQQDEyNodHRwOi8vbG9jYWxob3N0OjgwODAvZW1wbG95ZWUtc2lnLzAeFw0xNDEwMTcxOTMzNThaFw0yNDEwMTcxOTM1MzhaMC4xLDAqBgNVBAMTI2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9lbXBsb3llZS1zaWcvMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC+9kVgPFpshjS2aT2g52lqTv2lqb1jgvXZVk7iFF4LAO6SdCXKXRZI4SuzIRkVNpE1a42V1kQRlaozoFklgvX5sje8tkpa9ylq+bxGXM9RRycqRu2B+oWUV7Aqq7Bs0Xud0WeHQYRcEoCjqsFKGy65qkLRDdT70FTJgpSHts+gDwIDAQABMA0GCSqGSIb3DQEBCwUAA4GBACKyPLGqMX8GsIrCfJU8eVnpaqzTXMglLVo/nTcfAnWe9UAdVe8N3a2PXpDBvuqNA/DEAhVcQgxdlOTWnB6s8/yLTRuH0bZgb3qGdySif+lU+E7zZ/SiDzavAvn+ABqemnzHcHyhYO+hNRGHvUbW5OAii9Vdjhm8BI32YF1NwhKp\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/ecp-sp/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/ecp-sp\",\n            \"redirectUris\": [\n                \"http://localhost:8080/ecp-sp/*\"\n            ],\n            \"attributes\": {\n                \"saml_assertion_consumer_url_post\": \"http://localhost:8080/ecp-sp/\",\n                \"saml_assertion_consumer_url_redirect\": \"http://localhost:8080/ecp-sp/\",\n                \"saml_single_logout_service_url_post\": \"http://localhost:8080/ecp-sp/\",\n                \"saml_single_logout_service_url_redirect\": \"http://localhost:8080/ecp-sp/\",\n                \"saml.server.signature\": \"true\",\n                \"saml.signature.algorithm\": \"RSA_SHA256\",\n                \"saml.client.signature\": \"true\",\n                \"saml.authnstatement\": \"true\",\n                \"saml.signing.certificate\": \"MIIB1DCCAT0CBgFJGP5dZDANBgkqhkiG9w0BAQsFADAwMS4wLAYDVQQDEyVodHRwOi8vbG9jYWxob3N0OjgwODAvc2FsZXMtcG9zdC1zaWcvMB4XDTE0MTAxNjEyNDQyM1oXDTI0MTAxNjEyNDYwM1owMDEuMCwGA1UEAxMlaHR0cDovL2xvY2FsaG9zdDo4MDgwL3NhbGVzLXBvc3Qtc2lnLzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1RvGu8RjemSJA23nnMksoHA37MqY1DDTxOECY4rPAd9egr7GUNIXE0y1MokaR5R2crNpN8RIRwR8phQtQDjXL82c6W+NLQISxztarQJ7rdNJIYwHY0d5ri1XRpDP8zAuxubPYiMAVYcDkIcvlbBpwh/dRM5I2eElRK+eSiaMkCUCAwEAATANBgkqhkiG9w0BAQsFAAOBgQCLms6htnPaY69k1ntm9a5jgwSn/K61cdai8R8B0ccY7zvinn9AfRD7fiROQpFyY29wKn8WCLrJ86NBXfgFUGyR5nLNHVy3FghE36N2oHy53uichieMxffE6vhkKJ4P8ChfJMMOZlmCPsQPDvjoAghHt4mriFiQgRdPgIy/zDjSNw==\",\n                \"saml.allow.ecp.flow\": \"true\"\n            }\n        },\n        {\n            \"clientId\": \"http://localhost:8280/employee-role-mapping/\",\n            \"enabled\": true,\n            \"protocol\": \"saml\",\n            \"fullScopeAllowed\": true,\n            \"baseUrl\": \"http://localhost:8080/employee-role-mapping\",\n            \"redirectUris\": [\n                \"http://localhost:8080/employee-role-mapping/*\"\n            ],\n            \"adminUrl\": \"http://localhost:8080/employee-role-mapping\",\n            \"attributes\": {\n                \"saml.authnstatement\": \"true\",\n                \"saml_idp_initiated_sso_url_name\" : \"employee-role-mapping\"\n            },\n            \"protocolMappers\": [\n                {\n                    \"name\": \"email\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-property-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"email\",\n                        \"friendly.name\": \"email\",\n                        \"attribute.name\": \"urn:oid:1.2.840.113549.1.9.1\",\n                        \"attribute.nameformat\": \"URI Reference\"\n                    }\n                },\n                {\n                    \"name\": \"phone\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-user-attribute-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"user.attribute\": \"phone\",\n                        \"attribute.name\": \"phone\",\n                        \"attribute.nameformat\": \"Basic\"\n                    }\n                },\n                {\n                    \"name\": \"role-list\",\n                    \"protocol\": \"saml\",\n                    \"protocolMapper\": \"saml-role-list-mapper\",\n                    \"consentRequired\": false,\n                    \"config\": {\n                        \"attribute.name\": \"Role\",\n                        \"attribute.nameformat\": \"Basic\",\n                        \"single\": \"false\"\n                    }\n                }\n            ]\n        }\n    ],\n    \"groups\" : [\n        {\n            \"name\": \"top\",\n            \"attributes\": {\n                \"topAttribute\": [\"true\"]\n\n            },\n            \"realmRoles\": [\"manager\"],\n            \"subGroups\": [\n                {\n                    \"name\": \"level2\",\n                    \"realmRoles\": [\"user\"],\n                    \"attributes\": {\n                        \"level2Attribute\": [\"true\"]\n\n                    }\n                }\n            ]\n        }\n    ],\n\n    \"roles\" : {\n        \"realm\" : [\n            {\n                \"name\": \"manager\",\n                \"description\": \"Have Manager privileges\"\n            },\n            {\n                \"name\": \"user\",\n                \"description\": \"Have User privileges\"\n            },\n            {\n                \"name\": \"role.with.dots\",\n                \"description\": \"Role with dots in the name\"\n            }\n        ],\n        \"application\" : {\n            \"http://localhost:8280/employee/\" : [\n                {\n                    \"name\": \"employee\",\n                    \"description\": \"Have Employee privileges\"\n                }\n            ],\n            \"http://localhost:8280/employee2/\" : [\n                {\n                    \"name\": \"employee\",\n                    \"description\": \"Have Employee privileges\"\n                },\n                {\n                    \"name\": \"empl.oyee\",\n                    \"description\": \"Have Employee privileges with dots\"\n                }\n            ],\n            \"http://localhost:8280/employee-role-mapping/\" : [\n                {\n                    \"name\": \"employee\",\n                    \"description\": \"Have Employee privileges\"\n                },\n                {\n                    \"name\": \"supervisor\",\n                    \"description\": \"Have Supervisor privileges\"\n                }\n            ]\n\n        }\n    }\n}\n", "package org.keycloak.testsuite.console.page.clients.settings;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.testsuite.console.page.clients.CreateClientForm;\nimport org.keycloak.testsuite.console.page.fragment.OnOffSwitch;\nimport org.keycloak.testsuite.page.Form;\nimport org.keycloak.testsuite.util.Timer;\nimport org.keycloak.testsuite.util.UIUtils;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.support.FindBy;\nimport org.openqa.selenium.support.ui.Select;\n\nimport static org.keycloak.testsuite.util.WaitUtils.pause;\nimport static org.keycloak.testsuite.util.WaitUtils.waitUntilElement;\n\n/**\n * @author tkyjovsk\n */\npublic class ClientSettingsForm extends CreateClientForm {\n\n    @FindBy(id = \"name\")\n    private WebElement nameInput;\n\n    @FindBy(id = \"baseUrl\")\n    private WebElement baseUrlInput;\n    @FindBy(id = \"adminUrl\")\n    private WebElement adminUrlInput;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='enabled']]\")\n    private OnOffSwitch enabledSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='alwaysDisplayInConsole']]\")\n    private OnOffSwitch alwaysDisplayInConsole;\n    \n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='consentRequired']]\")\n    private OnOffSwitch consentRequiredSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='standardFlowEnabled']]\")\n    private OnOffSwitch standardFlowEnabledSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='implicitFlowEnabled']]\")\n    private OnOffSwitch implicitFlowEnabledSwitch;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='directAccessGrantsEnabled']]\")\n    private OnOffSwitch directAccessGrantsEnabledSwitch;\n\n    @FindBy(id = \"accessType\")\n    private Select accessTypeSelect;\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='serviceAccountsEnabled']]\")\n    private OnOffSwitch serviceAccountsEnabledSwitch;\n\n    @FindBy(id = \"newRedirectUri\")\n    private WebElement newRedirectUriInput;\n    @FindBy(xpath = \".//button[contains(@data-ng-click,'addRedirectUri')]\")\n    private WebElement newRedirectUriSubmit;\n    @FindBy(xpath = \".//input[@ng-model='client.redirectUris[i]']\")\n    private List<WebElement> redirectUriInputs;\n    @FindBy(xpath = \".//button[contains(@data-ng-click, 'deleteRedirectUri')]\")\n    private List<WebElement> deleteRedirectUriIcons;\n\n    @FindBy(id = \"newWebOrigin\")\n    private WebElement newWebOriginInput;\n    @FindBy(xpath = \".//button[contains(@data-ng-click,'addWebOrigin')]\")\n    private WebElement newWebOriginSubmit;\n    @FindBy(xpath = \".//input[ng-model='client.webOrigins[i]']\")\n    private List<WebElement> webOriginInputs;\n    @FindBy(xpath = \".//button[contains(@data-ng-click, 'deleteWebOrigin')]\")\n    private List<WebElement> deleteWebOriginIcons;\n\n    @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='authorizationServicesEnabled']]\")\n    private OnOffSwitch authorizationSettingsEnabledSwitch;\n\n    @FindBy(xpath = ACTIVE_DIV_XPATH + \"/button[text()='Disable Authorization Settings']\")\n    private WebElement confirmDisableAuthorizationSettingsButton;\n\n    public enum OidcAccessType {\n        BEARER_ONLY(\"bearer-only\"), PUBLIC(\"public\"), CONFIDENTIAL(\"confidential\");\n\n        private final String name;\n\n        private OidcAccessType(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n    }\n\n    public void setBaseUrl(String baseUrl) {\n        UIUtils.setTextInputValue(baseUrlInput, baseUrl);\n    }\n\n    public String getBaseUrl() {\n        return UIUtils.getTextInputValue(baseUrlInput);\n    }\n\n    public void setAdminUrl(String adminUrl) {\n        UIUtils.setTextInputValue(adminUrlInput, adminUrl);\n    }\n\n    public String getAdminUrl() {\n        return UIUtils.getTextInputValue(adminUrlInput);\n    }\n\n    public void addWebOrigin(String redirectUri) {\n        newWebOriginInput.sendKeys(redirectUri);\n        newWebOriginSubmit.click();\n    }\n\n    public List<String> getWebOrigins() {\n        List<String> values = new ArrayList<>();\n        for (WebElement input : webOriginInputs) {\n            values.add(UIUtils.getTextInputValue(input));\n        }\n        return values;\n    }\n\n    public void setWebOrigins(List<String> webOrigins) {\n        while (!deleteWebOriginIcons.isEmpty()) {\n            deleteWebOriginIcons.get(0).click();\n            pause(100);\n        }\n        if (webOrigins != null) {\n            for (String redirectUri : webOrigins) {\n                addWebOrigin(redirectUri);\n                pause(100);\n            }\n        }\n    }\n\n    public String getName() {\n        return UIUtils.getTextInputValue(nameInput);\n    }\n\n    public void setName(String name) {\n        UIUtils.setTextInputValue(nameInput, name);\n    }\n\n    public boolean isEnabled() {\n        return enabledSwitch.isOn();\n    }\n\n    public void setEnabled(boolean enabled) {\n        enabledSwitch.setOn(enabled);\n    }\n\n    public boolean isAlwaysDisplayInConsole() {\n        return alwaysDisplayInConsole.isOn();\n    }\n\n    public void setAlwaysDisplayInConsole(boolean enabled) {\n        alwaysDisplayInConsole.setOn(enabled);\n    }\n\n    public boolean isAlwaysDisplayInConsoleVisible() {\n        return alwaysDisplayInConsole.isVisible();\n    }\n\n    public boolean isConsentRequired() {\n        return consentRequiredSwitch.isOn();\n    }\n\n    public void setConsentRequired(boolean consentRequired) {\n        consentRequiredSwitch.setOn(consentRequired);\n    }\n\n    public void setAccessType(OidcAccessType accessType) {\n        accessTypeSelect.selectByVisibleText(accessType.getName());\n    }\n\n    public void addRedirectUri(String redirectUri) {\n        newRedirectUriInput.sendKeys(redirectUri);\n        newRedirectUriSubmit.click();\n    }\n\n    public List<String> getRedirectUris() {\n        List<String> values = new ArrayList<>();\n        for (WebElement input : redirectUriInputs) {\n            values.add(UIUtils.getTextInputValue(input));\n        }\n        return values;\n    }\n\n    public void setRedirectUris(List<String> redirectUris) {\n        Timer.DEFAULT.reset();\n        while (!deleteRedirectUriIcons.isEmpty()) {\n            deleteRedirectUriIcons.get(0).click();\n            pause(100);\n        }\n        Timer.DEFAULT.reset(\"deleteRedirectUris\");\n        if (redirectUris != null) {\n            for (String redirectUri : redirectUris) {\n                addRedirectUri(redirectUri);\n                pause(100);\n            }\n        }\n        Timer.DEFAULT.reset(\"addRedirectUris\");\n    }\n\n    public boolean isStandardFlowEnabled() {\n        return standardFlowEnabledSwitch.isOn();\n    }\n\n    public void setStandardFlowEnabled(boolean standardFlowEnabled) {\n        standardFlowEnabledSwitch.setOn(standardFlowEnabled);\n    }\n\n    public boolean isImplicitFlowEnabled() {\n        return implicitFlowEnabledSwitch.isOn();\n    }\n\n    public void setImplicitFlowEnabled(boolean implicitFlowEnabled) {\n        implicitFlowEnabledSwitch.setOn(implicitFlowEnabled);\n    }\n\n    public boolean isDirectAccessGrantsEnabled() {\n        return directAccessGrantsEnabledSwitch.isOn();\n    }\n\n    public void setDirectAccessGrantsEnabled(boolean directAccessGrantsEnabled) {\n        directAccessGrantsEnabledSwitch.setOn(directAccessGrantsEnabled);\n    }\n\n    public boolean isServiceAccountsEnabled() {\n        return serviceAccountsEnabledSwitch.isOn();\n    }\n\n    public void setServiceAccountsEnabled(boolean serviceAccountsEnabled) {\n        serviceAccountsEnabledSwitch.setOn(serviceAccountsEnabled);\n    }\n\n    public void setAuthorizationSettingsEnabled(boolean enabled) {\n        authorizationSettingsEnabledSwitch.setOn(enabled);\n    }\n\n    public boolean isAuthorizationSettingsEnabled() {\n        return authorizationSettingsEnabledSwitch.isOn();\n    }\n\n    public void confirmDisableAuthorizationSettings() {\n        confirmDisableAuthorizationSettingsButton.click();\n    }\n\n    public class SAMLClientSettingsForm extends Form {\n\n        public static final String SAML_ASSERTION_SIGNATURE = \"saml.assertion.signature\";\n        public static final String SAML_AUTHNSTATEMENT = \"saml.authnstatement\";\n        public static final String SAML_ONETIMEUSE_CONDITION = \"saml.onetimeuse.condition\";\n        public static final String SAML_CLIENT_SIGNATURE = \"saml.client.signature\";\n        public static final String SAML_ENCRYPT = \"saml.encrypt\";\n        public static final String SAML_FORCE_POST_BINDING = \"saml.force.post.binding\";\n        public static final String SAML_MULTIVALUED_ROLES = \"saml.multivalued.roles\";\n        public static final String SAML_SERVER_SIGNATURE = \"saml.server.signature\";\n        public static final String SAML_SERVER_SIGNATURE_KEYINFO_EXT = \"saml.server.signature.keyinfo.ext\";\n        public static final String SAML_SIGNATURE_ALGORITHM = \"saml.signature.algorithm\";\n        public static final String SAML_ASSERTION_CONSUMER_URL_POST = \"saml_assertion_consumer_url_post\";\n        public static final String SAML_ASSERTION_CONSUMER_URL_REDIRECT = \"saml_assertion_consumer_url_redirect\";\n        public static final String SAML_FORCE_NAME_ID_FORMAT = \"saml_force_name_id_format\";\n        public static final String SAML_NAME_ID_FORMAT = \"saml_name_id_format\";\n        public static final String SAML_ALLOW_ECP_FLOW = SamlConfigAttributes.SAML_ALLOW_ECP_FLOW;\n        public static final String SAML_SIGNATURE_CANONICALIZATION_METHOD = \"saml_signature_canonicalization_method\";\n        public static final String SAML_SINGLE_LOGOUT_SERVICE_URL_POST = \"saml_single_logout_service_url_post\";\n        public static final String SAML_SINGLE_LOGOUT_SERVICE_URL_REDIRECT = \"saml_single_logout_service_url_redirect\";\n\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlAuthnStatement']]\")\n        private OnOffSwitch samlAuthnStatement;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlOneTimeUseCondition']]\")\n        private OnOffSwitch samlOneTimeUseCondition;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlServerSignature']]\")\n        private OnOffSwitch samlServerSignature;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlServerSignatureEnableKeyInfoExtension']]\")\n        private OnOffSwitch samlServerSignatureKeyInfoExt;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlAssertionSignature']]\")\n        private OnOffSwitch samlAssertionSignature;\n        @FindBy(id = \"signatureAlgorithm\")\n        private Select signatureAlgorithm;\n        @FindBy(id = \"canonicalization\")\n        private Select canonicalization;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlEncrypt']]\")\n        private OnOffSwitch samlEncrypt;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlClientSignature']]\")\n        private OnOffSwitch samlClientSignature;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlForcePostBinding']]\")\n        private OnOffSwitch samlForcePostBinding;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='frontchannelLogout']]\")\n        private OnOffSwitch frontchannelLogout;\n        @FindBy(xpath = \".//div[@class='onoffswitch' and ./input[@id='samlForceNameIdFormat']]\")\n        private OnOffSwitch samlForceNameIdFormat;\n        @FindBy(id = \"samlNameIdFormat\")\n        private Select samlNameIdFormat;\n\n        @FindBy(xpath = \"//fieldset[contains(@data-ng-show, 'saml')]//i\")\n        private WebElement fineGrainCollapsor;\n\n        @FindBy(id = \"consumerServicePost\")\n        private WebElement consumerServicePostInput;\n        @FindBy(id = \"consumerServiceRedirect\")\n        private WebElement consumerServiceRedirectInput;\n        @FindBy(id = \"logoutPostBinding\")\n        private WebElement logoutPostBindingInput;\n        @FindBy(id = \"logoutRedirectBinding\")\n        private WebElement logoutRedirectBindingInput;\n\n        public void setValues(ClientRepresentation client) {\n            waitUntilElement(fineGrainCollapsor).is().visible();\n\n            Map<String, String> attributes = client.getAttributes();\n            samlAuthnStatement.setOn(\"true\".equals(attributes.get(SAML_AUTHNSTATEMENT)));\n            samlOneTimeUseCondition.setOn(\"true\".equals(attributes.get(SAML_ONETIMEUSE_CONDITION)));\n            samlServerSignature.setOn(\"true\".equals(attributes.get(SAML_SERVER_SIGNATURE)));\n            samlAssertionSignature.setOn(\"true\".equals(attributes.get(SAML_ASSERTION_SIGNATURE)));\n            if (samlServerSignature.isOn() || samlAssertionSignature.isOn()) {\n                signatureAlgorithm.selectByVisibleText(attributes.get(SAML_SIGNATURE_ALGORITHM));\n                canonicalization.selectByValue(\"string:\" + attributes.get(SAML_SIGNATURE_CANONICALIZATION_METHOD));\n                samlServerSignatureKeyInfoExt.setOn(\"true\".equals(attributes.get(SAML_SERVER_SIGNATURE_KEYINFO_EXT)));\n            }\n            samlEncrypt.setOn(\"true\".equals(attributes.get(SAML_ENCRYPT)));\n            samlClientSignature.setOn(\"true\".equals(attributes.get(SAML_CLIENT_SIGNATURE)));\n            samlForcePostBinding.setOn(\"true\".equals(attributes.get(SAML_FORCE_POST_BINDING)));\n            frontchannelLogout.setOn(client.isFrontchannelLogout());\n            samlForceNameIdFormat.setOn(\"true\".equals(attributes.get(SAML_FORCE_NAME_ID_FORMAT)));\n            samlNameIdFormat.selectByVisibleText(attributes.get(SAML_NAME_ID_FORMAT));\n\n            fineGrainCollapsor.click();\n            waitUntilElement(consumerServicePostInput).is().present();\n\n            UIUtils.setTextInputValue(consumerServicePostInput, attributes.get(SAML_ASSERTION_CONSUMER_URL_POST));\n            UIUtils.setTextInputValue(consumerServiceRedirectInput, attributes.get(SAML_ASSERTION_CONSUMER_URL_REDIRECT));\n            UIUtils.setTextInputValue(logoutPostBindingInput, attributes.get(SAML_SINGLE_LOGOUT_SERVICE_URL_POST));\n            UIUtils.setTextInputValue(logoutRedirectBindingInput, attributes.get(SAML_SINGLE_LOGOUT_SERVICE_URL_REDIRECT));\n        }\n    }\n\n}\n", "package org.keycloak.testsuite.console.clients;\n\nimport org.jboss.arquillian.graphene.page.Page;\nimport org.junit.Before;\nimport org.keycloak.admin.client.resource.ClientResource;\nimport org.keycloak.admin.client.resource.ClientsResource;\nimport org.keycloak.protocol.saml.SamlConfigAttributes;\nimport org.keycloak.protocol.saml.util.ArtifactBindingUtils;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.representations.idm.ProtocolMapperRepresentation;\nimport org.keycloak.testsuite.console.AbstractConsoleTest;\nimport org.keycloak.testsuite.console.page.clients.Client;\nimport org.keycloak.testsuite.console.page.clients.Clients;\nimport org.keycloak.testsuite.console.page.clients.CreateClient;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.keycloak.testsuite.auth.page.login.OIDCLogin.OIDC;\nimport static org.keycloak.testsuite.auth.page.login.OIDCLogin.SAML;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_AUTHNSTATEMENT;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_CLIENT_SIGNATURE;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_ALLOW_ECP_FLOW;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_FORCE_NAME_ID_FORMAT;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_FORCE_POST_BINDING;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_NAME_ID_FORMAT;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_SERVER_SIGNATURE;\nimport static org.keycloak.testsuite.console.page.clients.settings.ClientSettingsForm.SAMLClientSettingsForm.SAML_SIGNATURE_ALGORITHM;\nimport static org.keycloak.testsuite.util.AttributesAssert.assertEqualsBooleanAttributes;\nimport static org.keycloak.testsuite.util.AttributesAssert.assertEqualsListAttributes;\nimport static org.keycloak.testsuite.util.AttributesAssert.assertEqualsStringAttributes;\nimport static org.keycloak.testsuite.util.URLAssert.assertCurrentUrlEquals;\n\n/**\n *\n * @author tkyjovsk\n */\npublic abstract class AbstractClientTest extends AbstractConsoleTest {\n\n    public final String TEST_CLIENT_ID = \"test-client\";\n    public final List<String> TEST_REDIRECT_URIs = Arrays.asList(new String[] { \"http://example.test/app/\" });\n\n    @Page\n    protected Clients clientsPage;\n    @Page\n    protected Client clientPage; // note: cannot call navigateTo() unless client id is set\n    @Page\n    protected CreateClient createClientPage;\n\n    @Before\n    public void beforeClientTest() {\n        clientsPage.navigateTo();\n    }\n\n    public void createClient(ClientRepresentation client) {\n        assertCurrentUrlEquals(clientsPage);\n        clientsPage.table().createClient();\n        createClientPage.form().setValues(client);\n        createClientPage.form().save();\n        assertAlertSuccess();\n    }\n\n    public static ClientRepresentation createClientRep(String clientId, String protocol) {\n        ClientRepresentation client = new ClientRepresentation();\n        client.setClientId(clientId);\n        client.setEnabled(true);\n        client.setProtocol(protocol);\n\n        client.setDirectAccessGrantsEnabled(true);\n        client.setFullScopeAllowed(true);\n        client.setPublicClient(true);\n        client.setStandardFlowEnabled(true);\n\n        if (protocol.equals(SAML)) {\n            client.setAttributes(getSAMLAttributes());\n        }\n        return client;\n    }\n\n    public static Map<String, String> getSAMLAttributes() {\n        Map<String, String> attributes = new HashMap<>();\n        attributes.put(SAML_CLIENT_SIGNATURE, \"true\");\n        attributes.put(SAML_AUTHNSTATEMENT, \"true\");\n        attributes.put(SAML_FORCE_POST_BINDING, \"true\");\n        attributes.put(SAML_SERVER_SIGNATURE, \"true\");\n        attributes.put(SAML_SIGNATURE_ALGORITHM, \"RSA_SHA256\");\n        attributes.put(SAML_FORCE_NAME_ID_FORMAT, \"false\");\n        attributes.put(SAML_NAME_ID_FORMAT, \"username\");\n        attributes.put(SAML_ALLOW_ECP_FLOW, \"false\");\n        attributes.put(SamlConfigAttributes.SAML_ARTIFACT_BINDING_IDENTIFIER, ArtifactBindingUtils.computeArtifactBindingIdentifierString(\"saml\"));\n        return attributes;\n    }\n\n    public ClientRepresentation findClientByClientId(String clientId) {\n        ClientRepresentation found = null;\n        for (ClientRepresentation clientRepresentation : testRealmResource().clients().findAll()) {\n            if (clientRepresentation.getClientId().equals(clientId)) {\n                found = clientRepresentation;\n                break;\n            }\n        }\n        return found;\n    }\n\n    public void assertClientSettingsEqual(ClientRepresentation c1, ClientRepresentation c2) {\n        assertEqualsStringAttributes(c1.getClientId(), c2.getClientId());\n        assertEqualsStringAttributes(c1.getName(), c2.getName());\n        assertEqualsBooleanAttributes(c1.isEnabled(), c2.isEnabled());\n        assertEqualsBooleanAttributes(c1.isAlwaysDisplayInConsole(), c2.isAlwaysDisplayInConsole());\n        assertEqualsStringAttributes(c1.getBaseUrl(), c2.getBaseUrl());\n        assertEqualsBooleanAttributes(c1.isConsentRequired(), c2.isConsentRequired());\n        assertEqualsStringAttributes(c1.getProtocol(), c2.getProtocol());\n        assertEqualsListAttributes(c1.getRedirectUris(), c2.getRedirectUris());\n\n        if (c1.getProtocol().equals(OIDC)) {\n            assertEqualsBooleanAttributes(c1.isBearerOnly(), c2.isBearerOnly());\n            assertEqualsBooleanAttributes(c1.isDirectAccessGrantsEnabled(), c2.isDirectAccessGrantsEnabled());\n            assertEqualsBooleanAttributes(c1.isPublicClient(), c2.isPublicClient());\n            assertEqualsListAttributes(c1.getWebOrigins(), c2.getWebOrigins());\n            assertEqualsStringAttributes(c1.getAdminUrl(), c2.getAdminUrl());\n            assertEqualsBooleanAttributes(c1.isSurrogateAuthRequired(), c2.isSurrogateAuthRequired());\n            assertEqualsBooleanAttributes(c1.isServiceAccountsEnabled(), c2.isServiceAccountsEnabled());\n        }\n    }\n\n    public void assertClientSamlAttributes(Map<String, String> expected, Map<String, String> actual) {\n        for (String key : expected.keySet()) {\n            assertEquals(\"Expected attribute \" + key, expected.get(key), actual.get(key));\n        }\n    }\n\n    public ProtocolMapperRepresentation findClientMapperByName(String clientId, String mapperName) {\n        ProtocolMapperRepresentation found = null;\n        for (ProtocolMapperRepresentation mapper : testRealmResource().clients().get(clientId).getProtocolMappers()\n                .getMappers()) {\n            if (mapperName.equals(mapper.getName())) {\n                found = mapper;\n            }\n        }\n        return found;\n    }\n\n    public ClientsResource clientsResource() {\n        return testRealmResource().clients();\n    }\n\n    public ClientResource clientResource(String id) {\n        return clientsResource().get(id);\n    }\n\n}\n", "consoleTitle=Keycloak Admin Console\n\n# Common messages\nenabled=Enabled\nhidden=Hidden\nlink-only-column=Link only\nname=Name\ndisplayName=Display name\ndisplayNameHtml=HTML Display name\nsave=Save\ncancel=Cancel\nnext=Next\nonText=ON\noffText=OFF\nclient=Client\nclients=Clients\nclear=Clear\nselectOne=Select One...\n\ntrue=True\nfalse=False\n\nendpoints=Endpoints\n\n# Angular date filter format strings: https://docs.angularjs.org/api/ng/filter/date\ndateFormat=shortDate\ntimeFormat=mediumTime\n\n# Realm settings\nrealm-detail.enabled.tooltip=Users and clients can only access a realm if it's enabled\nrealm-detail.protocol-endpoints.tooltip=Shows the configuration of the protocol endpoints\nrealm-detail.protocol-endpoints.oidc=OpenID Endpoint Configuration\nrealm-detail.protocol-endpoints.saml=SAML 2.0 Identity Provider Metadata\nrealm-detail.userManagedAccess.tooltip=If enabled, users are allowed to manage their resources and permissions using the Account Management Console.\nuserProfileEnabled=User Profile Enabled\nuserProfileEnabled.tooltip=If enabled, allows managing user profiles. \nuserManagedAccess=User-Managed Access\nregistrationAllowed=User registration\nregistrationAllowed.tooltip=Enable/disable the registration page. A link for registration will show on login page too.\nregistrationEmailAsUsername=Email as username\nregistrationEmailAsUsername.tooltip=If enabled then username field is hidden from registration form and email is used as username for new user.\neditUsernameAllowed=Edit username\neditUsernameAllowed.tooltip=If enabled, the username field is editable, readonly otherwise.\nresetPasswordAllowed=Forgot password\nresetPasswordAllowed.tooltip=Show a link on login page for user to click on when they have forgotten their credentials.\nrememberMe=Remember Me\nrememberMe.tooltip=Show checkbox on login page to allow user to remain logged in between browser restarts until session expires.\nloginWithEmailAllowed=Login with email\nloginWithEmailAllowed.tooltip=Allow users to log in with their email address.\nduplicateEmailsAllowed=Duplicate emails\nduplicateEmailsAllowed.tooltip=Allow multiple users to have the same email address. Changing this setting will also clear the user's cache. It is recommended to manually update email constraints of existing users in the database after switching off support for duplicate email addresses.\nverifyEmail=Verify email\nverifyEmail.tooltip=Require users to verify their email address after initial login or after address changes are submitted.\nsslRequired=Require SSL\nsslRequired.option.all=all requests\nsslRequired.option.external=external requests\nsslRequired.option.none=none\nsslRequired.tooltip=Is HTTPS required? 'None' means HTTPS is not required for any client IP address. 'External requests' means localhost and private IP addresses can access without HTTPS. 'All requests' means HTTPS is required for all IP addresses.\npublicKeys=Public keys\npublicKey=Public key\nprivateKey=Private key\ngen-new-keys=Generate new keys\ncertificate=Certificate\nhost=Host\nsmtp-host=SMTP Host\nport=Port\nsmtp-port=SMTP Port (defaults to 25)\nsmtp-password.tooltip=SMTP password. This field is able to obtain its value from vault, use ${vault.ID} format.\nfrom=From\nfromDisplayName=From Display Name\nfromDisplayName.tooltip=A user-friendly name for the 'From' address (optional).\nreplyTo=Reply To\nreplyToDisplayName=Reply To Display Name\nreplyToDisplayName.tooltip=A user-friendly name for the 'Reply-To' address (optional).\nenvelopeFrom=Envelope From\nenvelopeFrom.tooltip=An email address used for bounces (optional).\nsender-email-addr=Sender Email Address\nsender-email-addr-display=Display Name for Sender Email Address\nreply-to-email-addr=Reply To Email Address\nreply-to-email-addr-display=Display Name for Reply To Email Address\nsender-envelope-email-addr=Sender Envelope Email Address\nenable-ssl=Enable SSL\nenable-start-tls=Enable StartTLS\nenable-auth=Enable Authentication\nusername=Username\nlogin-username=Login Username\npassword=Password\nlogin-password=Login Password\nlogin-theme=Login Theme\nlogin-theme.tooltip=Select theme for login, OTP, grant, registration, and forgot password pages.\naccount-theme=Account Theme\naccount-theme.tooltip=Select theme for user account management pages.\nadmin-console-theme=Admin Console Theme\nselect-theme-admin-console=Select theme for admin console.\nemail-theme=Email Theme\nselect-theme-email=Select theme for emails that are sent by the server.\ni18n-enabled=Internationalization Enabled\nsupported-locales=Supported Locales\nsupported-locales.placeholder=Type a locale and enter\ndefault-locale=Default Locale\nlocalization-upload-file=Upload localization JSON file\nmissing-locale=Missing locale.\nmissing-file=Missing file. Please select a file to upload.\nlocalization-file.upload.success=The localization data has been loaded from file.\nlocalization-file.upload.error=The file can not be uploaded. Please verify the file.\nlocalization-show=Show realm specific localizations\nno-localizations-configured=No realm specific localizations configured\nadd-localization-text=Add localization text\nlocalization-text.create.success=The localization text has been created.\nlocalization-text.update.success=The localization text has been updated.\nlocalization-text.remove.success=The localization text has been deleted.\nrealm-cache-clear=Realm Cache\nrealm-cache-clear.tooltip=Clears all entries from the realm cache (this will clear entries for all realms)\nuser-cache-clear=User Cache\nuser-cache-clear.tooltip=Clears all entries from the user cache (this will clear entries for all realms)\nkeys-cache-clear=Keys Cache\nkeys-cache-clear.tooltip=Clears all entries from the cache of external public keys. These are keys of external clients or identity providers. (this will clear entries for all realms)\ndefault-signature-algorithm=Default Signature Algorithm\ndefault-signature-algorithm.tooltip=Default algorithm used to sign tokens for the realm\nrevoke-refresh-token=Revoke Refresh Token\nrevoke-refresh-token.tooltip=If enabled a refresh token can only be used up to 'Refresh Token Max Reuse' and is revoked when a different token is used. Otherwise refresh tokens are not revoked when used and can be used multiple times.\nrefresh-token-max-reuse=Refresh Token Max Reuse\nrefresh-token-max-reuse.tooltip=Maximum number of times a refresh token can be reused. When a different token is used, revocation is immediate.\nsso-session-idle=SSO Session Idle\nseconds=Seconds\nminutes=Minutes\nhours=Hours\ndays=Days\nsso-session-max=SSO Session Max\nsso-session-idle.tooltip=Time a session is allowed to be idle before it expires. Tokens and browser sessions are invalidated when a session is expired.\nsso-session-max.tooltip=Max time before a session is expired. Tokens and browser sessions are invalidated when a session is expired.\nsso-session-idle-remember-me=SSO Session Idle Remember Me\nsso-session-idle-remember-me.tooltip=Time a remember me session is allowed to be idle before it expires. Tokens and browser sessions are invalidated when a session is expired. If not set it uses the standard SSO Session Idle value.\nsso-session-max-remember-me=SSO Session Max Remember Me\nsso-session-max-remember-me.tooltip=Max time before a session is expired when the user has set the remember me option. Tokens and browser sessions are invalidated when a session is expired. If not set, it uses the standard SSO Session Max value.\noffline-session-idle=Offline Session Idle\noffline-session-idle.tooltip=Time an offline session is allowed to be idle before it expires. You need to use offline token to refresh at least once within this period; otherwise offline session will expire.\nrealm-detail.hostname=Hostname\nrealm-detail.hostname.tooltip=Set the hostname for the realm. Use in combination with the fixed hostname provider to override the server hostname for a specific realm.\nrealm-detail.frontendUrl=Frontend URL\nrealm-detail.frontendUrl.tooltip=Set the frontend URL for the realm. Use in combination with the default hostname provider to override the base URL for frontend requests for a specific realm.\n\n## KEYCLOAK-7688 Offline Session Max for Offline Token\noffline-session-max-limited=Offline Session Max Limited\noffline-session-max-limited.tooltip=Enable Offline Session Max.\noffline-session-max=Offline Session Max\noffline-session-max.tooltip=Max time before an offline session is expired regardless of activity. \nclient-session-idle=Client Session Idle\nclient-session-idle.tooltip=Time a client session is allowed to be idle before it expires. Tokens are invalidated when a client session is expired. If not set it uses the standard SSO Session Idle value.\nclient-session-max=Client Session Max\nclient-session-max.tooltip=Max time before a client session is expired. Tokens are invalidated when a client session is expired. If not set, it uses the standard SSO Session Max value.\nclient-offline-session-idle=Client Offline Session Idle\nclient-offline-session-idle.tooltip=Time a client offline session is allowed to be idle before it expires. Offline tokens are invalidated when a client offline session is expired. If not set it uses the Offline Session Idle value.\nclient-offline-session-max=Client Offline Session Max\nclient-offline-session-max.tooltip=Max time before a client offline session is expired. Offline tokens are invalidated when a client offline session is expired. If not set, it uses the Offline Session Max value.\naccess-token-lifespan=Access Token Lifespan\naccess-token-lifespan.tooltip=Max time before an access token is expired. This value is recommended to be short relative to the SSO timeout.\naccess-token-lifespan-for-implicit-flow=Access Token Lifespan For Implicit Flow\naccess-token-lifespan-for-implicit-flow.tooltip=Max time before an access token issued during OpenID Connect Implicit Flow is expired. This value is recommended to be shorter than SSO timeout. There is no possibility to refresh token during implicit flow, that's why there is a separate timeout different to 'Access Token Lifespan'.\naction-token-generated-by-admin-lifespan=Default Admin-Initiated Action Lifespan\naction-token-generated-by-admin-lifespan.tooltip=Maximum time before an action permit sent to a user by administrator is expired. This value is recommended to be long to allow administrators send e-mails for users that are currently offline. The default timeout can be overridden immediately before issuing the token.\naction-token-generated-by-user-lifespan=User-Initiated Action Lifespan\naction-token-generated-by-user-lifespan.tooltip=Maximum time before an action permit sent by a user (such as a forgot password e-mail) is expired. This value is recommended to be short because it is expected that the user would react to self-created action quickly.\nsaml-assertion-lifespan=Assertion Lifespan\nsaml-assertion-lifespan.tooltip=Lifespan set in the SAML assertion conditions. After that time the assertion will be invalid. The \"SessionNotOnOrAfter\" attribute is not modified and continue using the \"SSO Session Max\" time defined at realm level.\n\naction-token-generated-by-user.execute-actions=Execute Actions\naction-token-generated-by-user.idp-verify-account-via-email=IdP Account E-mail Verification\naction-token-generated-by-user.reset-credentials=Forgot Password\naction-token-generated-by-user.verify-email=E-mail Verification\naction-token-generated-by-user.tooltip=Override default settings of maximum time before an action permit sent by a user (such as a forgot password e-mail) is expired for specific action. This value is recommended to be short because it is expected that the user would react to self-created action quickly.\naction-token-generated-by-user.reset=Reset\naction-token-generated-by-user.operation=Override User-Initiated Action Lifespan\n\nclient-login-timeout=Client login timeout\nclient-login-timeout.tooltip=Max time a client has to finish the access token protocol. This should normally be 1 minute.\nlogin-timeout=Login timeout\nlogin-timeout.tooltip=Max time a user has to complete a login. This is recommended to be relatively long, such as 30 minutes or more.\nlogin-action-timeout=Login action timeout\nlogin-action-timeout.tooltip=Max time a user has to complete login related actions like update password or configure totp. This is recommended to be relatively long, such as 5 minutes or more.\n\noauth2-device-code-lifespan=OAuth 2.0 Device Code Lifespan\noauth2-device-code-lifespan.tooltip=Max time before the device code and user code are expired. This value needs to be a long enough lifetime to be usable (allowing the user to retrieve their secondary device, navigate to the verification URI, login, etc.), but should be sufficiently short to limit the usability of a code obtained for phishing.\noauth2-device-polling-interval=OAuth 2.0 Device Polling Interval\noauth2-device-polling-interval.tooltip=The minimum amount of time in seconds that the client should wait between polling requests to the token endpoint.\n\nheaders=Headers\nbrute-force-detection=Brute Force Detection\nx-frame-options=X-Frame-Options\nx-frame-options-tooltip=Default value prevents pages from being included by non-origin iframes (click label for more information)\ncontent-sec-policy=Content-Security-Policy\ncontent-sec-policy-tooltip=Default value prevents pages from being included by non-origin iframes (click label for more information)\ncontent-sec-policy-report-only=Content-Security-Policy-Report-Only\ncontent-sec-policy-report-only-tooltip=For testing Content Security Policies\ncontent-type-options=X-Content-Type-Options\ncontent-type-options-tooltip=Default value prevents Internet Explorer and Google Chrome from MIME-sniffing a response away from the declared content-type (click label for more information)\nrobots-tag=X-Robots-Tag\nrobots-tag-tooltip=Prevent pages from appearing in search engines (click label for more information)\nx-xss-protection=X-XSS-Protection\nx-xss-protection-tooltip=This header configures the Cross-site scripting (XSS) filter in your browser. Using the default behavior, the browser will prevent rendering of the page when a XSS attack is detected (click label for more information)\nstrict-transport-security=HTTP Strict Transport Security (HSTS)\nstrict-transport-security-tooltip=The Strict-Transport-Security HTTP header tells browsers to always use HTTPS. Once a browser sees this header, it will only visit the site over HTTPS for the time specified (1 year) at max-age, including the subdomains.\npermanent-lockout=Permanent Lockout\npermanent-lockout.tooltip=Lock the user permanently when the user exceeds the maximum login failures.\nmax-login-failures=Max Login Failures\nmax-login-failures.tooltip=How many failures before wait is triggered.\nwait-increment=Wait Increment\nwait-increment.tooltip=When failure threshold has been met, how much time should the user be locked out?\nquick-login-check-millis=Quick Login Check Milli Seconds\nquick-login-check-millis.tooltip=If a failure happens concurrently too quickly, lock out the user.\nmin-quick-login-wait=Minimum Quick Login Wait\nmin-quick-login-wait.tooltip=How long to wait after a quick login failure.\nmax-wait=Max Wait\nmax-wait.tooltip=Max time a user will be locked out.\nfailure-reset-time=Failure Reset Time\nfailure-reset-time.tooltip=When will failure count be reset?\nrealm-tab-login=Login\nrealm-tab-keys=Keys\nrealm-tab-email=Email\nrealm-tab-themes=Themes\nrealm-tab-localization=Localization\nrealm-tab-cache=Cache\nrealm-tab-tokens=Tokens\nrealm-tab-client-registration=Client Registration\nrealm-tab-security-defenses=Security Defenses\nrealm-tab-user-profile=User Profile\nrealm-tab-general=General\nadd-realm=Add realm\n\n#Session settings\nrealm-sessions=Realm Sessions\nrevocation=Revocation\nlogout-all=Logout all\nactive-sessions=Active Sessions\noffline-sessions=Offline Sessions\nsessions=Sessions\nnot-before=Not Before\nnot-before.tooltip=Revoke any tokens issued before this date.\nset-to-now=Set to now\npush=Push\npush.tooltip=For every client that has an admin URL, notify them of the new revocation policy.\n\n#Protocol Mapper\nusermodel.prop.label=Property\nusermodel.prop.tooltip=Name of the property method in the UserModel interface. For example, a value of 'email' would reference the UserModel.getEmail() method.\nusermodel.attr.label=User Attribute\nusermodel.attr.tooltip=Name of stored user attribute which is the name of an attribute within the UserModel.attribute map.\nuserSession.modelNote.label=User Session Note\nuserSession.modelNote.tooltip=Name of stored user session note within the UserSessionModel.note map.\nmultivalued.label=Multivalued\nmultivalued.tooltip=Indicates if attribute supports multiple values. If true, the list of all values of this attribute will be set as claim. If false, just first value will be set as claim\naggregate.attrs.label=Aggregate attribute values\naggregate.attrs.tooltip=Indicates if attribute values should be aggregated with the group attributes. If using OpenID Connect mapper the multivalued option needs to be enabled too in order to get all the values. Duplicated values are discarded and the order of values is not guaranteed with this option.\nselectRole.label=Select Role\nselectRole.tooltip=Enter role in the textbox to the left, or click this button to browse and select the role you want.\nselectGroup.label=Select Group\nselectGroup.tooltip=Enter group in the textbox to the left, or click this button to browse and select the group you want.\ntokenClaimName.label=Token Claim Name\ntokenClaimName.tooltip=Name of the claim to insert into the token. This can be a fully qualified name like 'address.street'. In this case, a nested json object will be created. To prevent nesting and use dot literally, escape the dot with backslash (\\\\.).\njsonType.label=Claim JSON Type\njsonType.tooltip=JSON type that should be used to populate the json claim in the token. long, int, boolean, String and JSON are valid values.\nincludeInIdToken.label=Add to ID token\nincludeInIdToken.tooltip=Should the claim be added to the ID token?\nincludeInAccessToken.label=Add to access token\nincludeInAccessToken.tooltip=Should the claim be added to the access token?\nincludeInAccessTokenResponse.label=Add to access token response\nincludeInAccessTokenResponse.tooltip=Should the claim be added to the access token response? Should only be used for informative and non-sensitive data\nincludeInUserInfo.label=Add to userinfo\nincludeInUserInfo.tooltip=Should the claim be added to the userinfo?\nusermodel.clientRoleMapping.clientId.label=Client ID\nusermodel.clientRoleMapping.clientId.tooltip=Client ID for role mappings. Just client roles of this client will be added to the token. If this is unset, client roles of all clients will be added to the token.\nusermodel.clientRoleMapping.rolePrefix.label=Client Role prefix\nusermodel.clientRoleMapping.rolePrefix.tooltip=A prefix for each client role (optional).\nusermodel.clientRoleMapping.tokenClaimName.tooltip=Name of the claim to insert into the token. This can be a fully qualified name like 'address.street'. In this case, a nested json object will be created. To prevent nesting and use dot literally, escape the dot with backslash (\\\\.). The special token ${client_id} can be used and this will be replaced by the actual client ID. Example usage is 'resource_access.${client_id}.roles'. This is useful especially when you are adding roles from all the clients (Hence 'Client ID' switch is unset) and you want client roles of each client stored separately.\nusermodel.realmRoleMapping.rolePrefix.label=Realm Role prefix\nusermodel.realmRoleMapping.rolePrefix.tooltip=A prefix for each Realm Role (optional).\nsectorIdentifierUri.label=Sector Identifier URI\nsectorIdentifierUri.tooltip=Providers that use pairwise sub values and support Dynamic Client Registration SHOULD use the sector_identifier_uri parameter. It provides a way for a group of websites under common administrative control to have consistent pairwise sub values independent of the individual domain names. It also provides a way for Clients to change redirect_uri domains without having to reregister all their users.\npairwiseSubAlgorithmSalt.label=Salt\npairwiseSubAlgorithmSalt.tooltip=Salt used when calculating the pairwise subject identifier. If left blank, a salt will be generated.\naddressClaim.street.label=User Attribute Name for Street\naddressClaim.street.tooltip=Name of User Attribute, which will be used to map to 'street_address' subclaim inside 'address' token claim. Defaults to 'street' .\naddressClaim.locality.label=User Attribute Name for Locality\naddressClaim.locality.tooltip=Name of User Attribute, which will be used to map to 'locality' subclaim inside 'address' token claim. Defaults to 'locality' .\naddressClaim.region.label=User Attribute Name for Region\naddressClaim.region.tooltip=Name of User Attribute, which will be used to map to 'region' subclaim inside 'address' token claim. Defaults to 'region' .\naddressClaim.postal_code.label=User Attribute Name for Postal Code\naddressClaim.postal_code.tooltip=Name of User Attribute, which will be used to map to 'postal_code' subclaim inside 'address' token claim. Defaults to 'postal_code' .\naddressClaim.country.label=User Attribute Name for Country\naddressClaim.country.tooltip=Name of User Attribute, which will be used to map to 'country' subclaim inside 'address' token claim. Defaults to 'country' .\naddressClaim.formatted.label=User Attribute Name for Formatted Address\naddressClaim.formatted.tooltip=Name of User Attribute, which will be used to map to 'formatted' subclaim inside 'address' token claim. Defaults to 'formatted' .\nincluded.client.audience.label=Included Client Audience\nincluded.client.audience.tooltip=The Client ID of the specified audience client will be included in audience (aud) field of the token. If there are existing audiences in the token, the specified value is just added to them. It won't override existing audiences.\nincluded.custom.audience.label=Included Custom Audience\nincluded.custom.audience.tooltip=This is used just if 'Included Client Audience' is not filled. The specified value will be included in audience (aud) field of the token. If there are existing audiences in the token, the specified value is just added to them. It won't override existing audiences.\n\n# client details\nclients.tooltip=Clients are trusted browser apps and web services in a realm. These clients can request a login. You can also define client specific roles.\nsearch.placeholder=Search...\nsearch.loading=Searching...\ncreate=Create\nimport=Import\nclient-id=Client ID\nbase-url=Base URL\nactions=Actions\nnot-defined=Not defined\nedit=Edit\ndelete=Delete\nno-results=No results\nno-clients-available=No clients available\nadd-client=Add Client\nselect-file=Select file\nview-details=View details\nclear-import=Clear import\nclient-id.tooltip=Specifies ID referenced in URI and tokens. For example 'my-client'. For SAML this is also the expected issuer value from authn requests\nclient.name.tooltip=Specifies display name of the client. For example 'My Client'. Supports keys for localized values as well. For example\\: ${my_client}\nclient.enabled.tooltip=Disabled clients cannot initiate a login or have obtain access tokens.\nalwaysDisplayInConsole=Always Display in Console\nalwaysDisplayInConsole.tooltip=Always list this client in the Account Console, even if the user does not have an active session.\nconsent-required=Consent Required\nconsent-required.tooltip=If enabled, users have to consent to client access.\nclient.display-on-consent-screen=Display Client On Consent Screen\nclient.display-on-consent-screen.tooltip=Applicable just if Consent Required is on. If this switch is off, consent screen will contain just the consents corresponding to configured client scopes. If on, there will be also one item on consent screen about this client itself\nclient.consent-screen-text=Client Consent Screen Text \nclient.consent-screen-text.tooltip=Applicable just if 'Display Client On Consent Screen' is on for this client. Contains the text, which will be on consent screen about permissions specific just for this client\nclient-protocol=Client Protocol\nclient-protocol.tooltip='OpenID connect' allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server.'SAML' enables web-based authentication and authorization scenarios including cross-domain single sign-on (SSO) and uses security tokens containing assertions to pass information.\naccess-type=Access Type\naccess-type.tooltip='Confidential' clients require a secret to initiate login protocol. 'Public' clients do not require a secret. 'Bearer-only' clients are web services that never initiate a login.\nstandard-flow-enabled=Standard Flow Enabled\nstandard-flow-enabled.tooltip=This enables standard OpenID Connect redirect based authentication with authorization code. In terms of OpenID Connect or OAuth2 specifications, this enables support of 'Authorization Code Flow' for this client.\nimplicit-flow-enabled=Implicit Flow Enabled\nimplicit-flow-enabled.tooltip=This enables support for OpenID Connect redirect based authentication without authorization code. In terms of OpenID Connect or OAuth2 specifications, this enables support of 'Implicit Flow' for this client.\ndirect-access-grants-enabled=Direct Access Grants Enabled\ndirect-access-grants-enabled.tooltip=This enables support for Direct Access Grants, which means that client has access to username/password of user and exchange it directly with Keycloak server for access token. In terms of OAuth2 specification, this enables support of 'Resource Owner Password Credentials Grant' for this client.\nservice-accounts-enabled=Service Accounts Enabled\nservice-accounts-enabled.tooltip=Allows you to authenticate this client to Keycloak and retrieve access token dedicated to this client. In terms of OAuth2 specification, this enables support of 'Client Credentials Grant' for this client.\noauth2-device-authorization-grant-enabled=OAuth 2.0 Device Authorization Grant Enabled\noauth2-device-authorization-grant-enabled.tooltip=This enables support for OAuth 2.0 Device Authorization Grant, which means that client is an application on device that has limited input capabilities or lack a suitable browser.\noidc-ciba-grant-enabled=OIDC CIBA Grant Enabled\noidc-ciba-grant-enabled.tooltip=This enables support for OIDC CIBA Grant, which means that the user is authenticated via some external authentication device instead of the user's browser.\ninclude-authnstatement=Include AuthnStatement\ninclude-authnstatement.tooltip=Should a statement specifying the method and timestamp be included in login responses?\ninclude-onetimeuse-condition=Include OneTimeUse Condition\ninclude-onetimeuse-condition.tooltip=Should a OneTimeUse Condition be included in login responses?\nartifact-binding = Force Artifact Binding\nartifact-binding.tooltip = Should response messages be returned to the client through the SAML ARTIFACT binding system?\nsign-documents=Sign Documents\nsign-documents.tooltip=Should SAML documents be signed by the realm?\nsign-documents-redirect-enable-key-info-ext=Optimize REDIRECT signing key lookup\nsign-documents-redirect-enable-key-info-ext.tooltip=When signing SAML documents in REDIRECT binding for SP that is secured by Keycloak adapter, should the ID of the signing key be included in SAML protocol message in <Extensions> element? This optimizes validation of the signature as the validating party uses a single key instead of trying every known key for validation.\nsign-assertions=Sign Assertions\nsign-assertions.tooltip=Should assertions inside SAML documents be signed? This setting is not needed if document is already being signed.\nsignature-algorithm=Signature Algorithm\nsignature-algorithm.tooltip=The signature algorithm to use to sign documents.\ncanonicalization-method=Canonicalization Method\ncanonicalization-method.tooltip=Canonicalization Method for XML signatures.\nencrypt-assertions=Encrypt Assertions\nencrypt-assertions.tooltip=Should SAML assertions be encrypted with client's public key using AES?\nclient-signature-required=Client Signature Required\nclient-signature-required.tooltip=Will the client sign their saml requests and responses? And should they be validated?\nforce-post-binding=Force POST Binding\nforce-post-binding.tooltip=Always use POST binding for responses.\nfront-channel-logout=Front Channel Logout\nfront-channel-logout.tooltip=When true, logout requires a browser redirect to client. When false, server performs a background invocation for logout.\nfront-channel-logout-url=Front-Channel Logout URL\nfront-channel-logout-url.tooltip=URL that will cause the client to log itself out when a logout request is sent to this realm (via end_session_endpoint). If not provided, it defaults to the base url.\nfront-channel-logout-session-required=Front-Channel Logout Session Required\nfront-channel-logout-session-required.tooltip=Specifying whether a sid (session ID) and iss (Issuer) claims are included in the Logout Token when the Front-Channel Logout URL is used.\n\nforce-name-id-format=Force Name ID Format\nforce-name-id-format.tooltip=Ignore requested NameID subject format and use admin console configured one.\nallow-ecp-flow=Allow ECP Flow\nallow-ecp-flow.tooltip=This client is allowed to use ECP flow for authenticating users.\nname-id-format=Name ID Format\nname-id-format.tooltip=The name ID format to use for the subject.\nmapper.nameid.format.tooltip=Name ID Format using Mapper\nroot-url=Root URL\nroot-url.tooltip=Root URL appended to relative URLs\nvalid-redirect-uris=Valid Redirect URIs\nvalid-redirect-uris.tooltip=Valid URI pattern a browser can redirect to after a successful login or logout. Simple wildcards are allowed such as 'http://example.com/*'. Relative path can be specified too such as /my/relative/path/*. Relative paths are relative to the client root URL, or if none is specified the auth server root URL is used. For SAML, you must set valid URI patterns if you are relying on the consumer service URL embedded with the login request.\nbase-url.tooltip=Default URL to use when the auth server needs to redirect or link back to the client.\nadmin-url=Admin URL\nadmin-url.tooltip=URL to the admin interface of the client. Set this if the client supports the adapter REST API. This REST API allows the auth server to push revocation policies and other administrative tasks. Usually this is set to the base URL of the client.\nmaster-saml-processing-url=Master SAML Processing URL\nmaster-saml-processing-url.tooltip=If configured, this URL will be used for every binding to both the SP's Assertion Consumer and Single Logout Services. This can be individually overridden for each binding and service in the Fine Grain SAML Endpoint Configuration.\nidp-sso-url-ref=IDP Initiated SSO URL Name\nidp-sso-url-ref.tooltip=URL fragment name to reference client when you want to do IDP Initiated SSO. Leaving this empty will disable IDP Initiated SSO. The URL you will reference from your browser will be: {server-root}/realms/{realm}/protocol/saml/clients/{client-url-name}\nidp-sso-url-ref.urlhint=Target IDP initiated SSO URL:\nidp-sso-relay-state=IDP Initiated SSO Relay State\nidp-sso-relay-state.tooltip=Relay state you want to send with SAML request when you want to do IDP Initiated SSO.\nweb-origins=Web Origins\nweb-origins.tooltip=Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.\nbackchannel-logout-url=Backchannel Logout URL\nbackchannel-logout-url.tooltip=URL that will cause the client to log itself out when a logout request is sent to this realm (via end_session_endpoint). If omitted, no logout request will be sent to the client is this case.\nbackchannel-logout-session-required=Backchannel Logout Session Required\nbackchannel-logout-session-required.tooltip=Specifying whether a sid (session ID) Claim is included in the Logout Token when the Backchannel Logout URL is used.\nbackchannel-logout-revoke-offline-sessions=Backchannel Logout Revoke Offline Sessions\nbackchannel-logout-revoke-offline-sessions.tooltip=Specifying whether a \"revoke_offline_access\" event is included in the Logout Token when the Backchannel Logout URL is used. Keycloak will revoke offline sessions when receiving a Logout Token with this event.\nfine-oidc-endpoint-conf=Fine Grain OpenID Connect Configuration\nfine-oidc-endpoint-conf.tooltip=Expand this section to configure advanced settings of this client related to OpenID Connect protocol\naccess-token-signed-response-alg=Access Token Signature Algorithm\naccess-token-signed-response-alg.tooltip=JWA algorithm used for signing access tokens.\nid-token-signed-response-alg=ID Token Signature Algorithm\nid-token-signed-response-alg.tooltip=JWA algorithm used for signing ID tokens.\nid-token-encrypted-response-alg=ID Token Encryption Key Management Algorithm\nid-token-encrypted-response-alg.tooltip=JWA Algorithm used for key management in encrypting ID tokens. This option is needed if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted.\nid-token-encrypted-response-enc=ID Token Encryption Content Encryption Algorithm\nid-token-encrypted-response-enc.tooltip=JWA Algorithm used for content encryption in encrypting ID tokens. This option is needed just if you want encrypted ID tokens. If left empty, ID Tokens are just signed, but not encrypted.\nuser-info-signed-response-alg=User Info Signed Response Algorithm\nuser-info-signed-response-alg.tooltip=JWA algorithm used for signed User Info Endpoint response. If set to 'unsigned', User Info Response won't be signed and will be returned in application/json format.\nrequest-object-signature-alg=Request Object Signature Algorithm\nrequest-object-signature-alg.tooltip=JWA algorithm, which client needs to use when sending OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', Request object can be signed by any algorithm (including 'none' ).\nrequest-object-required=Request Object Required\nrequest-object-required.tooltip=Specifies if the client needs to provide a request object with their authorization requests, and what method they can use for this. If set to \"not required\", providing a request object is optional. In all other cases, providing a request object is mandatory. If set to \"request\", the request object must be provided by value. If set to \"request_uri\", the request object must be provided by reference. If set to \"request or request_uri\", either method can be used.\nrequest-object-encryption-alg=Request Object Encryption Algorithm\nrequest-object-encryption-alg.tooltip=JWE algorithm, which client needs to use when sending OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', encryption is optional and any algorithm is allowed.\nrequest-object-encryption-enc=Request Object Content Encryption Algorithm\nrequest-object-encryption-enc.tooltip=JWE algorithm, which client needs to use when encrypting the content of the OIDC request object specified by 'request' or 'request_uri' parameters. If set to 'any', any algorithm is allowed.\nciba-backchannel-token-delivery-mode=CIBA Backchannel Token Delivery Mode\nciba-backchannel-token-delivery-mode.tooltip= CIBA mode, which will be used by this client. If not set, defaults to realm attribute set at the CIBA Policy (defaults to 'poll')\nciba-backchannel-client-notification-endpoint=CIBA Backchannel Client Notification Endpoint\nciba-backchannel-client-notification-endpoint.tooltip=Client Notification Endpoint URL used by the CIBA Ping mode.\nciba-backchannel-auth-request-signing-alg=CIBA Backchannel Authentication Request Signature Algorithm\nciba-backchannel-auth-request-signing-alg.tooltip=JWA algorithm, which client needs to use when sending CIBA backchannel authentication request specified by 'request' or 'request_uri' parameters. Only asymmetric algorithms are allowed according CIBA specification. If set to 'any', any algorithm is allowed.\nrequest-uris=Valid Request URIs\nrequest-uris.tooltip=List of valid URIs, which can be used as values of 'request_uri' parameter during OpenID Connect authentication request. There is support for the same capabilities like for Valid Redirect URIs. For example wildcards or relative paths.\nfine-saml-endpoint-conf=Fine Grain SAML Endpoint Configuration\nfine-saml-endpoint-conf.tooltip=Expand this section to configure exact URLs for Assertion Consumer and Single Logout Service.\nassertion-consumer-post-binding-url=Assertion Consumer Service POST Binding URL\nassertion-consumer-post-binding-url.tooltip=SAML POST Binding URL for the client's assertion consumer service (login responses). You can leave this blank if you do not have a URL for this binding.\nassertion-consumer-redirect-binding-url=Assertion Consumer Service Redirect Binding URL\nassertion-consumer-redirect-binding-url.tooltip=SAML Redirect Binding URL for the client's assertion consumer service (login responses). You can leave this blank if you do not have a URL for this binding.\nlogout-service-post-binding-url=Logout Service POST Binding URL\nlogout-service-post-binding-url.tooltip=SAML POST Binding URL for the client's single logout service. You can leave this blank if you are using a different binding\nlogout-service-redir-binding-url=Logout Service Redirect Binding URL\nlogout-service-redir-binding-url.tooltip=SAML Redirect Binding URL for the client's single logout service. You can leave this blank if you are using a different binding.\nlogout-service-artifact-binding-url=Logout Service ARTIFACT Binding URL\nlogout-service-artifact-binding-url.tooltip=SAML ARTIFACT Binding URL for the client's single logout service. You can leave this blank if you are using a different binding.\nartifact-binding-url= Artifact Binding URL\nartifact-binding-url.tooltip=URL to send the HTTP ARTIFACT messages to. You can leave this blank if you are using a different binding. This value should be set when forcing ARTIFACT binding together with IdP initiated login.\nartifact-resolution-service-url= Artifact Resolution Service\nartifact-resolution-service-url.tooltip= SAML Artifact resolution service for the client. This is the endpoint to which Keycloak will send a SOAP ArtifactResolve message. You can leave this blank if you do not have a URL for this binding.\nsaml-signature-keyName-transformer=SAML Signature Key Name\nsaml-signature-keyName-transformer.tooltip=Signed SAML documents contain identification of signing key in KeyName element. For Keycloak / RH-SSO counterparty, use KEY_ID, for MS AD FS use CERT_SUBJECT, for others check and use NONE if no other option works.\noidc-compatibility-modes=OpenID Connect Compatibility Modes\noidc-compatibility-modes.tooltip=Expand this section to configure settings for backwards compatibility with older OpenID Connect / OAuth2 adapters. It is useful especially if your client uses older version of Keycloak / RH-SSO adapter.\nexclude-session-state-from-auth-response=Exclude Session State From Authentication Response\nexclude-session-state-from-auth-response.tooltip=If this is on, the parameter 'session_state' will not be included in OpenID Connect Authentication Response. It is useful if your client uses older OIDC / OAuth2 adapter, which does not support 'session_state' parameter.\nuse-refresh-tokens=Use Refresh Tokens\nuse-refresh-tokens.tooltip=If this is on, a refresh_token will be created and added to the token response. If this is off then no refresh_token will be generated.\nuse-refresh-token-for-client-credentials-grant=Use Refresh Tokens For Client Credentials Grant\nuse-refresh-token-for-client-credentials-grant.tooltip=If this is on, a refresh_token will be created and added to the token response if the client_credentials grant is used. The OAuth 2.0 RFC6749 Section 4.4.3 states that a refresh_token should not be generated when client_credentials grant is used. If this is off then no refresh_token will be generated and the associated user session will be removed.\nuse-lower-case-bearer-in-token-responses=Use lower-case bearer type in token responses\nuse-lower-case-bearer-in-token-responses.tooltip=If this is on, token responses will be set the with the type \"bearer\" in lower-case. By default, the server sets the type as \"Bearer\" as defined by RFC6750. \nauthorization-signed-response-alg=Authorization Response Signature Algorithm\nauthorization-signed-response-alg.tooltip=JWA algorithm used for signing authorization response tokens when the response mode is jwt.\nauthorization-encrypted-response-alg=Authorization Response Encryption Key Management Algorithm\nauthorization-encrypted-response-alg.tooltip=JWA Algorithm used for key management in encrypting the authorization response when the response mode is jwt. This option is needed if you want encrypted authorization response. If left empty, the authorization response is just signed, but not encrypted.\nauthorization-encrypted-response-enc=Authorization Response Encryption Content Encryption Algorithm\nauthorization-encrypted-response-enc.tooltip=JWA Algorithm used for content encryption in encrypting the authorization response when the response mode is jwt. This option is needed if you want encrypted authorization response. If left empty, the authorization response is just signed, but not encrypted.\nlogo-uri=Logo URL\nlogo-uri.tooltip=URL that references a logo for the Client application\npolicy-uri=Policy URL\npolicy-uri.tooltip=URL that the Relying Party Client provides to the End-User to read about the how the profile data will be used\ntos-uri=Terms of service URL\ntos-uri.tooltip=URL that the Relying Party Client provides to the End-User to read about the Relying Party's terms of service\n\n\n# client import\nimport-client=Import Client\nformat-option=Format Option\nselect-format=Select a Format\nimport-file=Import File\n\n# client tabs\nsettings=Settings\ncredentials=Credentials\nroles=Roles\nmappers=Mappers\nmappers.tooltip=Protocol mappers perform transformation on tokens and documents. They can do things like map user data into protocol claims, or just transform any requests going between the client and auth server.\nscope=Scope\nscope.tooltip=Scope mappings allow you to restrict which user role mappings are included within the access token requested by the client.\nsessions.tooltip=View active sessions for this client. Allows you to see which users are active and when they logged in.\noffline-access=Offline Access\noffline-access.tooltip=View offline sessions for this client. Allows you to see which users retrieve offline token and when they retrieve it. To revoke all tokens for the client, go to the Revocation tab and set Not Before to Now.\nclustering=Clustering\ninstallation=Installation\ninstallation.tooltip=Helper utility for generating various client adapter configuration formats which you can download or cut and paste to configure your clients.\nservice-account-roles=Service Account Roles\nservice-account-roles.tooltip=Allows you to authenticate role mappings for the service account dedicated to this client.\n\n# client credentials\nclient-authenticator=Client Authenticator\nclient-authenticator.tooltip=Client Authenticator used for authentication of this client against Keycloak server\ncertificate.tooltip=Client Certificate for validate JWT issued by client and signed by Client private key from your keystore.\npublicKey.tooltip=Public Key for validate JWT issued by client and signed by Client private key.\nno-client-certificate-configured=No client certificate configured\nneed-to-configure-keys=Configure JWKS URL or Signing key in the Keys tab\ngen-new-keys-and-cert=Generate new keys and certificate\nimport-certificate=Import Certificate\ngen-client-private-key=Generate Client Private Key\ngenerate-private-key=Generate Private Key\nkid=Kid\nkid.tooltip=KID (Key ID) of the client public key from imported JWKS.\ntoken-endpoint-auth-signing-alg=Signature Algorithm\ntoken-endpoint-auth-signing-alg.tooltip=JWA algorithm, which the client needs to use when signing a JWT for authentication. If left blank, the client is allowed to use any algorithm.\nuse-jwks-url=Use JWKS URL\nuse-jwks-url.tooltip=If the switch is on, client public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded again when client generates new keypair. If the switch is off, public key (or certificate) from the Keycloak DB is used, so when client keypair changes, you always need to import new key (or certificate) to the Keycloak DB as well. This switch is mutually exclusive with the switch \"Use JWKS\".\njwks-url=JWKS URL\njwks-url.tooltip=URL where client keys in JWK format are stored. See JWK specification for more details. If you use Keycloak client adapter with \"jwt\" credential, you can use URL of your app with '/k_jwks' suffix. For example 'http://www.myhost.com/myapp/k_jwks' .\nuse-jwks-string=Use JWKS\nuse-jwks-string.tooltip=If the switch is on, client public keys will be configurable in JWKS. This switch is mutually exclusive with the switch \"Use JWKS URL\".\njwks-string=JWKS\njwks-string.tooltip=Client keys in JWK format. See JWK specification for more details.\npkce-enabled=Use PKCE\npkce-enabled.tooltip=Use PKCE (Proof of Key-code exchange) for IdP Brokering\npkce-method=PKCE Method\npkce-method.tooltip=PKCE Method to use\npkce.plain.option=Plain\npkce.s256.option=S256\narchive-format=Archive Format\narchive-format.tooltip=Java keystore or PKCS12 archive format.\nkey-alias=Key Alias\nkey-alias.tooltip=Archive alias for your private key and certificate.\nkey-password=Key Password\nkey-password.tooltip=Password to access the private key in the archive\nstore-password=Store Password\nstore-password.tooltip=Password to access the archive itself\ngenerate-and-download=Generate and Download\nclient-certificate-import=Client Certificate Import\nimport-client-certificate=Import Client Certificate\njwt-import.key-alias.tooltip=Archive alias for your certificate.\nsecret=Secret\nregenerate-secret=Regenerate Secret\nsecret-rotation=Secret Rotation\nsecret-rotation-enabled.tooltip=This enables client secret rotation.\nrotate.secret=Rotate Secret\nsecret-rotated=Secret Rotated\ninvalidate-secret=Invalidate Secret\nsecret-expires-on=Secret expires on\nregistrationAccessToken=Registration access token\nregistrationAccessToken.regenerate=Regenerate registration access token\nregistrationAccessToken.tooltip=The registration access token provides access for clients to the client registration service.\nadd-role=Add Role\nrole-name=Role Name\ncomposite=Composite\ndescription=Description\nno-client-roles-available=No client roles available\ncomposite-roles=Composite Roles\ncomposite-roles.tooltip=When this role is (un)assigned to a user any role associated with it will be (un)assigned implicitly.\nrealm-roles=Realm Roles\navailable-roles=Available Roles\nadd-selected=Add selected\nassociated-roles=Associated Roles\ncomposite.associated-realm-roles.tooltip=Realm level roles associated with this composite role.\ncomposite.available-realm-roles.tooltip=Realm level roles that you can associate to this composite role.\nremove-selected=Remove selected\nclient-roles=Client Roles\nselect-client-to-view-roles=Select client to view roles for client\navailable-roles.tooltip=Roles from this client that you can associate to this composite role.\nclient.associated-roles.tooltip=Client roles associated with this composite role.\nadd-builtin=Add Builtin\ncategory=Category\ntype=Type\npriority-order=Priority Order\nno-mappers-available=No mappers available\nadd-builtin-protocol-mappers=Add Builtin Protocol Mappers\nadd-builtin-protocol-mapper=Add Builtin Protocol Mapper\nscope-mappings=Scope Mappings\nfull-scope-allowed=Full Scope Allowed\nfull-scope-allowed.tooltip=Allows you to disable all restrictions.\nscope.available-roles.tooltip=Realm level roles that can be assigned to scope. Contains effectively assigned roles which are not directly assigned.\nassigned-roles=Assigned Roles\nassigned-roles.tooltip=Realm level roles assigned to scope.\neffective-roles=Effective Roles\nrealm.effective-roles.tooltip=Assigned realm level roles that may have been inherited from a composite role.\nselect-client-roles.tooltip=Select client to view roles for client\nassign.available-roles.tooltip=Client roles available to be assigned. Contains effectively assigned roles which are not directly assigned.\nclient.assigned-roles.tooltip=Assigned client roles.\nclient.effective-roles.tooltip=Assigned client roles that may have been inherited from a composite role.\nbasic-configuration=Basic configuration\nnode-reregistration-timeout=Node Re-registration Timeout\nnode-reregistration-timeout.tooltip=Interval to specify max time for registered clients cluster nodes to re-register. If cluster node will not send re-registration request to Keycloak within this time, it will be unregistered from Keycloak\nregistered-cluster-nodes=Registered cluster nodes\nregister-node-manually=Register node manually\ntest-cluster-availability=Test cluster availability\nlast-registration=Last registration\nnode-host=Node host\nno-registered-cluster-nodes=No registered cluster nodes available\ncluster-nodes=Cluster Nodes\nadd-node=Add Node\nactive-sessions.tooltip=Total number of active user sessions for this client.\nshow-sessions=Show Sessions\nshow-sessions.tooltip=Warning, this is a potentially expensive operation depending on the number of active sessions.\nuser=User\nfrom-ip=From IP\nsession-start=Session Start\nfirst-page=First Page\nprevious-page=Previous Page\nnext-page=Next Page\nclient-revoke.not-before.tooltip=Revoke any tokens issued before this date for this client.\nclient-revoke.push.tooltip=If the admin URL is configured for this client, push this policy to that client.\nselect-a-format=Select a Format\ndownload=Download\noffline-tokens=Offline Tokens\noffline-tokens.tooltip=Total number of offline tokens for this client.\nshow-offline-tokens=Show Offline Tokens\nshow-offline-tokens.tooltip=Warning, this is a potentially expensive operation depending on the number of offline tokens.\ntoken-issued=Token Issued\nlast-access=Last Access\nlast-refresh=Last Refresh\nkey-export=Key Export\nkey-import=Key Import\nexport-saml-key=Export SAML Key\nimport-saml-key=Import SAML Key\nrealm-certificate-alias=Realm Certificate Alias\nrealm-certificate-alias.tooltip=Realm certificate is stored in archive too. This is the alias to it.\nsigning-key=Signing Key\nsaml-signing-key=SAML Signing Key.\nprivate-key=Private Key\ngenerate-new-keys=Generate new keys\nexport=Export\nencryption-key=Encryption Key\nsaml-encryption-key.tooltip=SAML Encryption Key.\nservice-accounts=Service Accounts\nservice-account.available-roles.tooltip=Realm level roles that can be assigned to service account. Contains effectively assigned roles which are not directly assigned.\nservice-account=Service Account\nservice-account.roles=Service Account Roles\nservice-account.user=Service Account User\nservice-account.user.tooltip=Username of the Service Account. To manage details and group mappings click on the username.\nservice-account.assigned-roles.tooltip=Realm level roles assigned to service account.\nservice-account-is-not-enabled-for=Service account is not enabled for {{client}}\ncreate-protocol-mappers=Create Protocol Mappers\ncreate-protocol-mapper=Create Protocol Mapper\nprotocol=Protocol\nprotocol.tooltip=Protocol...\nid=ID\nmapper.name.tooltip=Name of the mapper.\nmapper.consent-required.tooltip=When granting temporary access, must the user consent to providing this data to the client?\nconsent-text=Consent Text\nconsent-text.tooltip=Text to display on consent page.\nmapper-type=Mapper Type\nmapper-type.tooltip=Type of the mapper\nuser-label=User Label\ndata=Data\nshow-data=Show data...\nposition=Position\n# realm identity providers\nidentity-providers=Identity Providers\ntable-of-identity-providers=Table of identity providers\nadd-provider.placeholder=Add provider...\nprovider=Provider\ngui-order=GUI order\nfirst-broker-login-flow=First Login Flow\npost-broker-login-flow=Post Login Flow\nsync-mode=Sync Mode\nsync-mode.tooltip=Default sync mode for all mappers. The sync mode determines when user data will be synced using the mappers. Possible values are: 'legacy' to keep the behaviour before this option was introduced, 'import' to only import the user once during first login of the user with this identity provider, 'force' to always update the user during every login with this identity provider.\nsync-mode.inherit=inherit\nsync-mode.legacy=legacy\nsync-mode.import=import\nsync-mode.force=force\nsync-mode-override=Sync Mode Override\nsync-mode-override.tooltip=Overrides the default sync mode of the IDP for this mapper. Values are: 'legacy' to keep the behaviour before this option was introduced, 'import' to only import the user once during first login of the user with this identity provider, 'force' to always update the user during every login with this identity provider and 'inherit' to use the sync mode defined in the identity provider for this mapper.\nredirect-uri=Redirect URI\nredirect-uri.tooltip=The redirect uri to use when configuring the identity provider.\nalias=Alias\ndisplay-name=Display Name\nidentity-provider.alias.tooltip=The alias uniquely identifies an identity provider and it is also used to build the redirect uri.\nidentity-provider.display-name.tooltip=Friendly name for Identity Providers.\nidentity-provider.enabled.tooltip=Enable/disable this identity provider.\nauthenticate-by-default=Authenticate by Default\nidentity-provider.authenticate-by-default.tooltip=Indicates if this provider should be tried by default for authentication even before displaying login screen.\nstore-tokens=Store Tokens\nidentity-provider.store-tokens.tooltip=Enable/disable if tokens must be stored after authenticating users.\nstored-tokens-readable=Stored Tokens Readable\nidentity-provider.stored-tokens-readable.tooltip=Enable/disable if new users can read any stored tokens. This assigns the broker.read-token role.\ndisableUserInfo=Disable User Info\nidentity-provider.disableUserInfo.tooltip=Disable usage of User Info service to obtain additional user information?  Default is to use this OIDC service.\nuserIp=Use userIp Param\nidentity-provider.google-userIp.tooltip=Set 'userIp' query parameter when invoking on Google's User Info service.  This will use the user's ip address.  Useful if Google is throttling access to the User Info service.\nofflineAccess=Request refresh token\nidentity-provider.google-offlineAccess.tooltip=Set 'access_type' query parameter to 'offline' when redirecting to google authorization endpoint, to get a refresh token back. Useful if planning to use Token Exchange to retrieve Google token to access Google APIs when the user is not at the browser.\nhostedDomain=Hosted Domain\nidentity-provider.google-hostedDomain.tooltip=Set 'hd' query parameter when logging in with Google. Google will list accounts only for this domain. Keycloak validates that the returned identity token has a claim for this domain. When '*' is entered, any hosted account can be used.\nidentity-provider.facebook-fetchedFields.label=Additional user's profile fields\nidentity-provider.facebook-fetchedFields.tooltip=Provide additional fields which would be fetched using the profile request. This will be appended to the default set of 'id,name,email,first_name,last_name'.\nsandbox=Target Sandbox\nidentity-provider.paypal-sandbox.tooltip=Target PayPal's sandbox environment\nupdate-profile-on-first-login=Update Profile on First Login\non=On\non-missing-info=On missing info\noff=Off\nupdate-profile-on-first-login.tooltip=Define conditions under which a user has to update their profile during first-time login.\ntrust-email=Trust Email\ntrust-email.tooltip=If enabled, email provided by this provider is not verified even if verification is enabled for the realm.\nlink-only=Account Linking Only\nlink-only.tooltip=If true, users cannot log in through this provider.  They can only link to this provider.  This is useful if you don't want to allow login from the provider, but want to integrate with a provider\nhide-on-login-page=Hide on Login Page\nhide-on-login-page.tooltip=If hidden, login with this provider is possible only if requested explicitly, for example using the 'kc_idp_hint' parameter.\ngui-order.tooltip=Number defining order of the provider in GUI (for example, on Login page).\nfirst-broker-login-flow.tooltip=Alias of authentication flow, which is triggered after first login with this identity provider. Term 'First Login' means that no Keycloak account is currently linked to the authenticated identity provider account.\npost-broker-login-flow.tooltip=Alias of authentication flow, which is triggered after each login with this identity provider. Useful if you want additional verification of each user authenticated with this identity provider (for example OTP). Leave this empty if you need no any additional authenticators to be triggered after login with this identity provider. Also note that authenticator implementations must assume that user is already set in ClientSession as identity provider already set it.\nopenid-connect-config=OpenID Connect Config\nopenid-connect-config.tooltip=OIDC SP and external IDP configuration.\nauthorization-url=Authorization URL\nauthorization-url.tooltip=The Authorization Url.\ntoken-url=Token URL\ntoken-url.tooltip=The Token URL.\nloginHint=Pass login_hint\nloginHint.tooltip=Pass login_hint to identity provider.\nuiLocales=Pass current locale\nuiLocales.tooltip=Pass the current locale to the identity provider as a ui_locales parameter.\nlogout-url=Logout URL\nidentity-provider.logout-url.tooltip=End session endpoint to use to logout user from external IDP.\nbackchannel-logout=Backchannel Logout\nbackchannel-logout.tooltip=Does the external IDP support backchannel logout?\nuser-info-url=User Info URL\nuser-info-url.tooltip=The User Info Url. This is optional.\nclient-auth=Client Authentication\nclient-auth.tooltip=The client authentication method (cfr. https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication). In case of JWT signed with private key, the realm private key is used.\nclient-auth.client_secret_post=Client secret sent as post\nclient-auth.client_secret_basic=Client secret sent as basic auth\nclient-auth.client_secret_jwt=Client secret as jwt\nclient-auth.private_key_jwt=JWT signed with private key\nidentity-provider.client-id.tooltip=The client or client identifier registered within the identity provider.\nclient-secret=Client Secret\nclient-assertion-signing-algorithm=Client Assertion Signature Algorithm\nclient-assertion-signing-algorithm.tooltip=Signature algorithm to create JWT assertion as client authentication. In the case of JWT signed with private key or Client secret as jwt, it is required. If no algorithm is specified, the following algorithm is adapted. RS256 is adapted in the case of JWT signed with private key. HS256 is adapted in the case of Client secret as jwt.\nshow-secret=Show secret\nhide-secret=Hide secret\nclient-secret.tooltip=The client or client secret registered within the identity provider. This field is able to obtain its value from vault, use ${vault.ID} format.\nissuer=Issuer\nissuer.tooltip=The issuer identifier for the issuer of the response. If not provided, no validation will be performed.\ndefault-scopes=Default Scopes\nidentity-provider.default-scopes.tooltip=The scopes to be sent when asking for authorization. It can be a space-separated list of scopes. Defaults to 'openid'.\nprompt=Prompt\nunspecified.option=unspecified\nnone.option=none\nconsent.option=consent\nlogin.option=login\nselect-account.option=select_account\nprompt.tooltip=Specifies whether the Authorization Server prompts the End-User for reauthentication and consent.\naccepts-prompt-none-forward-from-client=Accepts prompt=none forward from client\naccepts-prompt-none-forward-from-client.tooltip=This is just used together with Identity Provider Authenticator or when kc_idp_hint points to this identity provider. In case that client sends a request with prompt=none and user is not yet authenticated, the error will not be directly returned to client, but the request with prompt=none will be forwarded to this identity provider.\nvalidate-signatures=Validate Signatures\nidentity-provider.validate-signatures.tooltip=Enable/disable signature validation of external IDP signatures.\nidentity-provider.use-jwks-url.tooltip=If the switch is on, identity provider public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded again when identity provider generates new keypair. If the switch is off, public key (or certificate) from the Keycloak DB is used, so when the identity provider keypair changes, you always need to import the new key to the Keycloak DB as well.\nidentity-provider.jwks-url.tooltip=URL where identity provider keys in JWK format are stored. See JWK specification for more details. If you use external Keycloak identity provider, you can use URL like 'http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs' assuming your brokered Keycloak is running on 'http://broker-keycloak:8180' and its realm is 'test' .\nvalidating-public-key=Validating Public Key\nidentity-provider.validating-public-key.tooltip=The public key in PEM format that must be used to verify external IDP signatures.\nvalidating-public-key-id=Validating Public Key Id\nidentity-provider.validating-public-key-id.tooltip=Explicit ID of the validating public key given above if the key ID. Leave blank if the key above should be used always, regardless of key ID specified by external IDP; set it if the key should only be used for verifying if the key ID from external IDP matches.\nallowed-clock-skew=Allowed clock skew\nidentity-provider.allowed-clock-skew.tooltip=Clock skew in seconds that is tolerated when validating identity provider tokens. Default value is zero.\nforwarded-query-parameters=Forwarded Query Parameters\nidentity-provider.forwarded-query-parameters.tooltip=Non OpenID Connect/OAuth standard query parameters to be forwarded to external IDP from the initial application request to Authorization Endpoint. Multiple parameters can be entered, separated by comma (,).\nimport-external-idp-config=Import External IDP Config\nimport-external-idp-config.tooltip=Allows you to load external IDP metadata from a config file or to download it from a URL.\nimport-from-url=Import from URL\nidentity-provider.import-from-url.tooltip=Import metadata from a remote IDP discovery descriptor.\nimport-from-file=Import from file\nidentity-provider.import-from-file.tooltip=Import metadata from a downloaded IDP discovery descriptor.\nidentity-provider.saml.entity-id=Service Provider Entity ID\nidentity-provider.saml.entity-id.tooltip=The Entity ID that will be used to uniquely identify this SAML Service Provider\nidentity-provider.saml.protocol-endpoints.saml=SAML 2.0 Service Provider Metadata\nidentity-provider.saml.protocol-endpoints.saml.tooltip=Shows the configuration of the Service Provider endpoint\nidentity-provider.saml.attribute-consuming-service-index=Attribute Consuming Service Index\nidentity-provider.saml.attribute-consuming-service-index.tooltip=Index of the Attribute Consuming Service profile to request during authentication\nidentity-provider.saml.attribute-consuming-service-name=Attribute Consuming Service Name\nidentity-provider.saml.attribute-consuming-service-name.tooltip=Name of the Attribute Consuming Service profile to advertise in the SP metadata. Default value equal to the realm display name when configured, otherwise equal to the realm name.\nsaml-config=SAML Config\nidentity-provider.saml-config.tooltip=SAML SP and external IDP configuration.\nsingle-signon-service-url=Single Sign-On Service URL\nsaml.single-signon-service-url.tooltip=The Url that must be used to send authentication requests (SAML AuthnRequest).\nsingle-logout-service-url=Single Logout Service URL\nsaml.single-logout-service-url.tooltip=The Url that must be used to send logout requests.\nnameid-policy-format=NameID Policy Format\nnameid-policy-format.tooltip=Specifies the URI reference corresponding to a name identifier format. Defaults to urn:oasis:names:tc:SAML:2.0:nameid-format:persistent.\nsaml.principal-type=Principal Type\nsaml.principal-type.tooltip=Way to identify and track external users from the assertion. Default is using Subject NameID, alternatively you can set up identifying attribute.\nsaml.principal-attribute=Principal Attribute\nsaml.principal-attribute.tooltip=Name or Friendly Name of the attribute used to identify external users.\nsaml.allow-create=Allow create\nsaml.allow-create.tooltip=Allow the external identity provider to create a new identifier to represent the principal\nhttp-post-binding-response=HTTP-POST Binding Response\nhttp-post-binding-response.tooltip=Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nhttp-post-binding-for-authn-request=HTTP-POST Binding for AuthnRequest\nhttp-post-binding-for-authn-request.tooltip=Indicates whether the AuthnRequest must be sent using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nhttp-post-binding-logout=HTTP-POST Binding Logout\nhttp-post-binding-logout.tooltip=Indicates whether to respond to requests using HTTP-POST binding. If false, HTTP-REDIRECT binding will be used.\nwant-authn-requests-signed=Want AuthnRequests Signed\nwant-authn-requests-signed.tooltip=Indicates whether the identity provider expects a signed AuthnRequest.\nwant-assertions-signed=Want Assertions Signed\nwant-assertions-signed.tooltip=Indicates whether this service provider expects a signed Assertion.\nwant-assertions-encrypted=Want Assertions Encrypted\nwant-assertions-encrypted.tooltip=Indicates whether this service provider expects an encrypted Assertion.\nforce-authentication=Force Authentication\nidentity-provider.force-authentication.tooltip=Indicates whether the identity provider must authenticate the presenter directly rather than rely on a previous security context.\nvalidate-signature=Validate Signature\nsaml.validate-signature.tooltip=Enable/disable signature validation of SAML responses.\nvalidating-x509-certificate=Validating X509 Certificates\nvalidating-x509-certificate.tooltip=The certificate in PEM format that must be used to check for signatures. Multiple certificates can be entered, separated by comma (,).\nsaml.loginHint=Pass subject\nsaml.loginHint.tooltip=During login phase, forward an optional login_hint query parameter to SAML AuthnRequest's Subject.\nsaml.import-from-url.tooltip=Import metadata from a remote IDP SAML entity descriptor.\nidentity-provider.saml.sign-sp-metadata=Sign Service Provider Metadata\nidentity-provider.saml.sign-sp-metadata.tooltip=Enable/disable signature of the provider SAML metadata\nidentity-provider.saml.requested-authncontext=Requested AuthnContext Constraints\nidentity-provider.saml.requested-authncontext.tooltip=Allows the SP to specify the authentication context requirements of authentication statements returned.\nidentity-provider.saml.authncontext-comparison-type=Comparison\nidentity-provider.saml.authncontext-comparison-type.tooltip=Specifies the comparison method used to evaluate the requested context classes or statements. The default is \"Exact\".\nidentity-provider.saml.authncontext-comparison-type.exact=Exact\nidentity-provider.saml.authncontext-comparison-type.minimum=Minimum\nidentity-provider.saml.authncontext-comparison-type.maximum=Maximum\nidentity-provider.saml.authncontext-comparison-type.better=Better\nidentity-provider.saml.authncontext-class-ref=AuthnContext ClassRefs\nidentity-provider.saml.authncontext-class-ref.tooltip=Ordered list of requested AuthnContext ClassRefs.\nidentity-provider.saml.authncontext-decl-ref=AuthnContext DeclRefs\nidentity-provider.saml.authncontext-decl-ref.tooltip=Ordered list of requested AuthnContext DeclRefs.\nsocial.client-id.tooltip=The client identifier registered with the identity provider.\nsocial.client-secret.tooltip=The client secret registered with the identity provider. This field is able to obtain its value from vault, use ${vault.ID} format.\nsocial.default-scopes.tooltip=The scopes to be sent when asking for authorization. See the documentation for possible values, separator and default value'.\nkey=Key\nstackoverflow.key.tooltip=The Key obtained from Stack Overflow client registration.\nopenshift.base-url=Base Url\nopenshift.base-url.tooltip=Base Url to OpenShift Online API\nopenshift4.base-url=Base Url\nopenshift4.base-url.tooltip=Base Url to OpenShift Online API\ngitlab-application-id=Application Id\ngitlab-application-secret=Application Secret\ngitlab.application-id.tooltip=Application Id for the application you created in your GitLab Applications account menu\ngitlab.application-secret.tooltip=Secret for the application that you created in your GitLab Applications account menu\ngitlab.default-scopes.tooltip=Scopes to ask for on login.  Will always ask for openid.  Additionally adds read_user if you do not specify anything.\nbitbucket-consumer-key=Consumer Key\nbitbucket-consumer-secret=Consumer Secret\nbitbucket.key.tooltip=Bitbucket OAuth Consumer Key\nbitbucket.secret.tooltip=Bitbucket OAuth Consumer Secret\nbitbucket.default-scopes.tooltip=Scopes to ask for on login.  If you do not specify anything, scope defaults to 'email'.\n# User federation\nsync-ldap-roles-to-keycloak=Sync LDAP Roles To Keycloak\nsync-keycloak-roles-to-ldap=Sync Keycloak Roles To LDAP\nsync-ldap-groups-to-keycloak=Sync LDAP Groups To Keycloak\nsync-keycloak-groups-to-ldap=Sync Keycloak Groups To LDAP\nrealms=Realms\nrealm=Realm\nidentity-provider-mappers=Identity Provider Mappers\ncreate-identity-provider-mapper=Create Identity Provider Mapper\nadd-identity-provider-mapper=Add Identity Provider Mapper\nclient.description.tooltip=Specifies description of the client. For example 'My Client for TimeSheets'. Supports keys for localized values as well. For example\\: ${my_client_description}\nexpires=Expires\nexpiration=Expiration\nexpiration.tooltip=Specifies how long the token should be valid\ncount=Count\ncount.tooltip=Specifies how many clients can be created using the token\nremainingCount=Remaining Count\ncreated=Created\nback=Back\ninitial-access-tokens=Initial Access Tokens\nadd-initial-access-tokens=Add Initial Access Token\ninitial-access-token=Initial Access Token\ninitial-access.copyPaste.tooltip=Copy/paste the initial access token before navigating away from this page as it is not possible to retrieve later\ncontinue=Continue\ninitial-access-token.confirm.title=Copy Initial Access Token\ninitial-access-token.confirm.text=Please copy and paste the initial access token before confirming as it cannot be retrieved later\nno-initial-access-available=No Initial Access Tokens available\nclient-reg-policies=Client Registration Policies\nclient-reg-policy.name.tooltip=Display Name of the policy\nanonymous-policies=Anonymous Access Policies\nanonymous-policies.tooltip=Those Policies are used when the Client Registration Service is invoked by unauthenticated request. This means that the request does not contain Initial Access Token nor Bearer Token.\nauth-policies=Authenticated Access Policies\nauth-policies.tooltip=Those Policies are used when Client Registration Service is invoked by authenticated request. This means that the request contains Initial Access Token or Bearer Token.\npolicy-name=Policy Name\nno-client-reg-policies-configured=No Client Registration Policies\ntrusted-hosts.label=Trusted Hosts\ntrusted-hosts.tooltip=List of Hosts, which are trusted and are allowed to invoke Client Registration Service and/or be used as values of Client URIs. You can use hostnames or IP addresses. If you use star at the beginning (for example '*.example.com' ) then whole domain example.com will be trusted.\nhost-sending-registration-request-must-match.label=Host Sending Client Registration Request Must Match\nhost-sending-registration-request-must-match.tooltip=If on, any request to Client Registration Service is allowed just if it was sent from some trusted host or domain.\nclient-uris-must-match.label=Client URIs Must Match\nclient-uris-must-match.tooltip=If on, all Client URIs (Redirect URIs and others) are allowed just if they match some trusted host or domain.\nconsent-required-for-all-mappers.label=Consent Required For Mappers\nconsent-required-for-all-mappers.tooltip=If on, all newly registered protocol mappers will automatically have consentRequired switch on. This means that user will need to approve consent screen. NOTE: Consent screen is shown just if client has consentRequired switch on. So it is usually good to use this switch together with consent-required policy.\nallowed-client-scopes.label=Allowed Client Scopes\nallowed-client-scopes.tooltip=Whitelist of the client scopes, which can be used on a newly registered client. Attempt to register client with some client scope, which is not whitelisted, will be rejected. By default, the whitelist is either empty or contains just realm default client scopes (based on 'Allow Default Scopes' configuration property)\nallow-default-scopes.label=Allow Default Scopes\nallow-default-scopes.tooltip=If on, newly registered clients will be allowed to have client scopes mentioned in realm default client scopes or realm optional client scopes\n\n# Client Registration Policies providers\nallowed-protocol-mappers.label=Allowed Protocol Mappers\nallowed-protocol-mappers.tooltip=Whitelist of allowed protocol mapper providers. If there is an attempt to register client, which contains some protocol mappers, which were not whitelisted, registration request will be rejected.\n\nallowed-client-templates.label=Allowed Client Templates\nclient-disabled.label=Client Disabled\nscope.label=Scope\nconsent-required.label=Consent Required\n\nmax-clients.label=Max Clients Per Realm\nmax-clients.tooltip=It will not be allowed to register a new client if count of existing clients in realm is same or bigger than the configured limit.\n\nclient-scopes=Client Scopes\nclient-scopes.tooltip=Client scopes allow you to define a common set of protocol mappers and roles, which are shared between multiple clients\n\n# Client Policies\nrealm-tab-client-policies=Client Policies\nclient-policies-profiles=Profiles\nclient-policies-profiles.tooltip=Client Profile allows to setup set of executors, which are enforced for various actions done with the client. Actions can be admin actions like creating or updating client, or user actions like authentication to the client.\nclient-policies-policies=Policies\nclient-policies-policies.tooltip=Client Policy allows to bind client profiles with various conditions to specify when exactly is enforced behaviour specified by executors of the particular client profile.\nclient-profiles-form-view=Form View\nclient-profiles-json-editor=JSON Editor\nglobal=Global\nexecutors=Executors\nclient-profile-name.tooltip=Name of the client profile. Must be unique within the realm\nclient-profile-executors.tooltip=Executors, which will be applied for this client profile\nno-executors-available=No Executors Available\npush-profile-to-json=Push Profile to JSON\nexecutor-type=Executor Type\ncreate-executor=Create Executor\nclient-policy-name.tooltip=Name of the client policy. Must be unique within the realm.\nclient-policy-enabled.tooltip=Specifies if client policy is enabled. Disabled policies are not considered at all during evaluation of client requests.\nconditions=Conditions\nclient-policy-conditions.tooltip=Conditions, which will be evaluated to determine if client policy should be applied during particular action or not.\nno-conditions-available=No Conditions Available\ncondition-type=Condition Type\ncreate-condition=Create Condition\nclient-profiles=Client Profiles\nclient-policies=Client Policies\nclient-profiles.tooltip=Client Profiles applied on this policy\nadd-profile.placeholder=Add client profile ...\nno-client-profiles-configured=No client profiles configured\ncreate-client-profile=Create Client Profile\ncreate-client-policy=Create Client Policy\n\nclient-scopes-condition.label=Expected Scopes\nclient-scopes-condition.tooltip=The list of expected client scopes. Condition evaluates to true if specified client request matches some of the client scopes. It depends also whether it should be default or optional client scope based on the 'Scope Type' configured.\nclient-accesstype.label=Client Access Type\nclient-accesstype.tooltip=Access Type of the client, for which the condition will be applied.\nclient-roles.label=Client Roles\nclient-roles-condition.tooltip=Client roles, which will be checked during this condition evaluation. Condition evaluates to true if client has at least one client role with the name as the client roles specified in the configuration.\nclient-updater-source-groups.label=Groups\nclient-updater-source-groups.tooltip=Name of groups to check. Condition evaluates to true if the entity, who creates/updates client is member of some of the specified groups. Configured groups are specified by their simple name, which must match to the name of the Keycloak group. No support for group hierarchy is used here.\nclient-updater-trusted-hosts.label=Trusted hosts\nclient-updater-trusted-hosts.tooltip=List of Hosts, which are trusted. In case that client registration/update request comes from the host/domain specified in this configuration, condition evaluates to true. You can use hostnames or IP addresses. If you use star at the beginning (for example '*.example.com' ) then whole domain example.com will be trusted.\nclient-updater-source-roles.label=Updating entity role\nclient-updater-source-roles.tooltip=The condition is checked during client registration/update requests and it evaluates to true if the entity (usually user), who is creating/updating client is member of the specified role. For reference the realm role, you can use the realm role name like 'my_realm_role' . For reference client role, you can use the client_id.role_name for example 'my_client.my_client_role' will refer to client role 'my_client_role' of client 'my_client'.\n\ngroups=Groups\n\ngroup.add-selected.tooltip=Realm roles that can be assigned to the group. Contains effectively assigned roles which are not directly assigned.\ngroup.assigned-roles.tooltip=Realm roles mapped to the group\ngroup.effective-roles.tooltip=All realm role mappings. Some roles here might be inherited from a mapped composite role.\ngroup.available-roles.tooltip=Assignable roles from this client. Contains effectively assigned roles which are not directly assigned.\ngroup.assigned-roles-client.tooltip=Role mappings for this client.\ngroup.effective-roles-client.tooltip=Role mappings for this client. Some roles here might be inherited from a mapped composite role.\n\ngroup.move.success=Group moved.\ngroup.remove.confirm.title=Delete Group\ngroup.remove.confirm.message=Are you sure you want to permanently delete the group {{name}}?\ngroup.remove.success=The group has been deleted.\ngroup.fetch.fail=Unable to fetch {{params}}\ngroup.create.success=Group Created.\ngroup.edit.success=Your changes have been saved to the group.\ngroup.roles.add.success=Role mappings updated.\ngroup.roles.remove.success=Role mappings updated.\ngroup.default.add.error=Please select a group to add\ngroup.default.add.success=Added default group\ngroup.default.remove.success=Removed default group\n\ndefault-roles=Default Roles\nno-realm-roles-available=No realm roles available\n\nusers=Users\nuser.add-selected.tooltip=Realm roles that can be assigned to the user. Contains effectively assigned roles which are not directly assigned.\nuser.assigned-roles.tooltip=Realm roles mapped to the user\nuser.effective-roles.tooltip=All realm role mappings. Some roles here might be inherited from a mapped composite role.\nuser.available-roles.tooltip=Assignable roles from this client. Contains effectively assigned roles which are not directly assigned.\nuser.assigned-roles-client.tooltip=Role mappings for this client.\nuser.effective-roles-client.tooltip=Role mappings for this client. Some roles here might be inherited from a mapped composite role.\n\nuser.roles.add.success=Role mappings updated.\nuser.roles.remove.success=Role mappings updated.\nuser.logout.all.success=Logged out user in all clients\nuser.logout.session.success=Logged out session\nuser.fedid.link.remove.confirm.title=Delete Identity Provider Link\nuser.fedid.link.remove.confirm.message=Are you sure you want to permanently delete the Identity Provider Link {{name}}?\nuser.fedid.link.remove.success=The provider link has been deleted.\nuser.fedid.link.add.success=Provider link has been created.\nuser.consent.revoke.success=Grant revoked successfully\nuser.consent.revoke.error=Grant couldn't be revoked\nuser.remove.confirm.title=Delete User\nuser.remove.confirm.message=Are you sure you want to permanently delete the user {{name}}?\nuser.unlock.success=Any temporarily locked users are now unlocked.\nuser.remove.success=The user has been deleted.\nuser.remove.error=User couldn't be deleted\nuser.create.success=The user has been created.\nuser.edit.success=Your changes have been saved to the user.\nuser.credential.update.success=Credentials saved!\nuser.credential.update.error=Error while updating the credential. See console for more information.\nuser.credential.remove.confirm.title=Delete credentials\nuser.credential.remove.confirm.message=Are you sure you want to delete these users credentials?\nuser.credential.remove.success=Credentials deleted!\nuser.credential.remove.error=Error while deleting the credential. See console for more information.\nuser.credential.move-top.error=Error while moving the credential to top. See console for more information.\nuser.credential.move-up.error=Error while moving the credential up. See console for more information.\nuser.credential.move-down.error=Error while moving the credential down. See console for more information.\nuser.credential.fetch.error=Error while loading user credentials. See console for more information.\nuser.credential.storage.fetch.error=Error while loading user storage credentials. See console for more information.\nuser.password.error.not-matching=Password and confirmation does not match.\nuser.password.reset.confirm.title=Reset password\nuser.password.reset.confirm.message=Are you sure you want to reset the password for the user?\nuser.password.reset.success=The password has been reset.\nuser.password.set.confirm.title=Set password\nuser.password.set.confirm.message=Are you sure you want to set a password for the user?\nuser.password.set.success=The password has been set.\nuser.credential.disable.confirm.title=Disable credentials\nuser.credential.disable.confirm.message=Are you sure you want to disable these users credentials?\nuser.credential.disable.confirm.success=Credentials disabled\nuser.credential.disable.confirm.error=Failed to disable credentials\nuser.actions-email.send.pending-changes.title=Cannot send email\nuser.actions-email.send.pending-changes.message=You must save your current changes before you can send an email\nuser.actions-email.send.confirm.title=Send Email\nuser.actions-email.send.confirm.message=Are you sure you want to send email to user?\nuser.actions-email.send.confirm.success=Email sent to user\nuser.actions-email.send.confirm.error=Failed to send email to user\nuser.storage.remove.confirm.title=Delete User storage provider\nuser.storage.remove.confirm.message=Are you sure you want to permanently delete the user storage provider {{name}}?\nuser.storage.remove.success=The provider has been deleted.\nuser.storage.create.success=The provider has been created.\nuser.storage.edit.success=The provider has been updated.\nuser.storage.sync.success=Sync of users finished successfully. {{status}}\nuser.storage.sync.error=Error during sync of users\nuser.storage.remove-users.success=Remove imported users finished successfully.\nuser.storage.remove-users.error=Error during remove\nuser.storage.unlink.success=Unlink of users finished successfully.\nuser.storage.unlink.error=Error during unlink\nuser.groups.fetch.all.error=Unable to fetch all group memberships {{params}}\nuser.groups.fetch.error=Unable to fetch {{params}}\nuser.groups.join.error.no-group-selected=Please select a group to add\nuser.groups.join.error.already-added=Group already added\nuser.groups.join.success=Added group membership\nuser.groups.leave.error.no-group-selected=Please select a group to remove\nuser.groups.leave.success=Removed group membership\n\ndefault.available-roles.tooltip=Realm level roles that can be assigned.\nrealm-default-roles=Realm Default Roles\nrealm-default-roles.tooltip=Realm level roles assigned to new users.\ndefault.available-roles-client.tooltip=Roles from this client that are assignable as a default.\nclient-default-roles=Client Default Roles\nclient-default-roles.tooltip=Roles from this client assigned as a default role.\ncomposite.available-roles.tooltip=Realm level roles that you can associate to this composite role.\ncomposite.associated-roles.tooltip=Realm level roles associated with this composite role.\ncomposite.available-roles-client.tooltip=Roles from this client that you can associate to this composite role.\ncomposite.associated-roles-client.tooltip=Client roles associated with this composite role.\npartial-import=Partial Import\npartial-import.tooltip=Partial import allows you to import users, clients, and other resources from a previously exported json file.\n\nfile=File\nexported-json-file=Exported json file\nimport-from-realm=Import from realm\nimport-users=Import users\nimport-groups=Import groups\nimport-clients=Import clients\nimport-identity-providers=Import identity providers\nimport-realm-roles=Import realm roles\nimport-client-roles=Import client roles\nif-resource-exists=If a resource exists\nfail=Fail\nskip=Skip\noverwrite=Overwrite\nif-resource-exists.tooltip=Specify what should be done if you try to import a resource that already exists.\n\npartial-export=Partial Export\npartial-export.tooltip=Partial export allows you to export realm configuration, and other associated resources into a json file.\nexport-groups-and-roles=Export groups and roles\nexport-clients=Export clients\n\naction=Action\nrole-selector=Role Selector\ngroup-selector=Group Selector\nrealm-roles.tooltip=Realm roles that can be selected.\n\nselect-a-role=Select a role\nselect-realm-role=Select realm role\nselect-group=Select group\nclient-roles.tooltip=Client roles that can be selected.\nselect-client-role=Select client role\n\nclient-saml-endpoint=Client SAML Endpoint\nadd-client-scope=Add client scope\n\ndefault-client-scopes=Default Client Scopes\ndefault-client-scopes.tooltip=Client Scopes, which will be added automatically to each created client\ndefault-client-scopes.default=Default Client Scopes\ndefault-client-scopes.default.tooltip=Allow to define client scopes, which will be added as default scopes to each created client\ndefault-client-scopes.default.available=Available Client Scopes\ndefault-client-scopes.default.available.tooltip=Client scopes, which are not yet assigned as realm default scopes or realm optional scopes\ndefault-client-scopes.default.assigned=Assigned Default Client Scopes\ndefault-client-scopes.default.assigned.tooltip=Client scopes, which will be added as default scopes to each created client\ndefault-client-scopes.optional=Optional Client Scopes\ndefault-client-scopes.optional.tooltip=Allow to define client scopes, which will be added as optional scopes to each created client\ndefault-client-scopes.optional.available=Available Client Scopes\ndefault-client-scopes.optional.available.tooltip=Client scopes, which are not yet assigned as realm default scopes or realm optional scopes\ndefault-client-scopes.optional.assigned=Assigned Optional Client Scopes\ndefault-client-scopes.optional.assigned.tooltip=Client scopes, which will be added as optional scopes to each created client\n\nclient-scopes.setup=Setup\nclient-scopes.setup.tooltip=Allow to setup client scopes linked to this client\nclient-scopes.default=Default Client Scopes\nclient-scopes.default.tooltip=Default client scopes are always applied when issuing tokens for this client. Protocol mappers and role scope mappings are always applied regardless of value of used scope parameter in OIDC Authorization request \nclient-scopes.default.available=Available Client Scopes\nclient-scopes.default.available.tooltip=Client scopes, which are not yet assigned as default scopes or optional scopes\nclient-scopes.default.assigned=Assigned Default Client Scopes\nclient-scopes.default.assigned.tooltip=Client scopes, which will be used as default scopes when generating tokens for this client\nclient-scopes.optional=Optional Client Scopes\nclient-scopes.optional.tooltip=Optional client scopes are applied when issuing tokens for this client, however just in case when they are requested by scope parameter in OIDC Authorization request \nclient-scopes.optional.available=Available Client Scopes\nclient-scopes.optional.available.tooltip=Client scopes, which are not yet assigned as default scopes or optional scopes\nclient-scopes.optional.assigned=Assigned Optional Client Scopes\nclient-scopes.optional.assigned.tooltip=Client scopes, which may be used as optional scopes when generating tokens for this client\n\nclient-scopes.evaluate=Evaluate\nclient-scopes.evaluate.tooltip=Allow to see all protocol mappers and role scope mapping that will be used in the tokens issued to this client. Also allow to generate example access token based on provided scope parameter\nscope-parameter=Scope Parameter\nscope-parameter.tooltip=You can copy/paste this value of scope parameter and use it in initial OpenID Connect Authentication Request sent from this client adapter. Default client scopes and selected optional client scopes will be used when generating token issued for this client\nclient-scopes.evaluate.scopes=Client Scopes\nclient-scopes.evaluate.scopes.tooltip=Allow to select optional client scopes, which may be used when generating token issued for this client\nclient-scopes.evaluate.scopes.available=Available Optional Client Scopes\nclient-scopes.evaluate.scopes.available.tooltip=This contains Optional Client Scopes, which can be optionally used when issuing access token for this client\nclient-scopes.evaluate.scopes.assigned=Selected Optional Client Scopes\nclient-scopes.evaluate.scopes.assigned.tooltip=Selected Optional Client Scopes, which will be used when issuing access token for this client. You can see above what value of OAuth Scope Parameter needs to be used when you want to have these optional client scopes applied when the initial OpenID Connect Authentication request will be sent from your client adapter  \nclient-scopes.evaluate.scopes.effective=Effective Client Scopes\nclient-scopes.evaluate.scopes.effective.tooltip=Contains all default client scopes and selected optional scopes. All protocol mappers and role scope mappings of all those client scopes will be used when generating access token issued for your client\nclient-scopes.evaluate.user.tooltip=Optionally select user, for whom the example access token will be generated. If you do not select a user, example access token will not be generated during evaluation\nsend-evaluation-request=Evaluate\nsend-evaluation-request.tooltip=Click this to see all protocol mappers and role scope mappings that will be used when issuing an access token for this client. It will also optionally generate example access token in case that some user was selected\n\nevaluated-protocol-mappers=Effective Protocol Mappers\nevaluated-protocol-mappers.tooltip=Shows all effective protocol mappers that will be used when issuing token for this client. Also contains protocol mappers of selected optional client scopes. For each protocol mapper, you can see from which client scope it is inherited from\nevaluated-roles=Effective Role Scope Mappings\nevaluated-roles.tooltip=Shows all effective roles scope mappings that will be used when issuing token for this client. Also contains role scope mappings of selected optional client scopes\nparent-client-scope=Parent Client Scope\nclient-scopes.evaluate.not-granted-roles=Not Granted Roles\nclient-scopes.evaluate.not-granted-roles.tooltip=Client does not have scope mappings for these roles. Those roles will not be in the access token issued to this client even if the authenticated user is a member of them\nclient-scopes.evaluate.granted-realm-effective-roles=Granted Effective Realm Roles\nclient-scopes.evaluate.granted-realm-effective-roles.tooltip=Client has scope mappings for these roles. Those roles will be in the access token issued to this client if the authenticated user is a member of them\nclient-scopes.evaluate.granted-client-effective-roles=Granted Effective Client Roles\ngenerated-access-token=Generated Access Token\ngenerated-access-token.tooltip=See the example access token, which will be generated and sent to the client when selected user is authenticated. You can see claims and roles that the token will contain based on the effective protocol mappers and role scope mappings and also based on the claims/roles assigned to user himself \ngenerated-id-token=Generated ID Token\ngenerated-id-token.tooltip=See the example ID Token, which will be generated and sent to the client when selected user is authenticated. You can see claims and roles that the token will contain based on the effective protocol mappers and role scope mappings and also based on the claims/roles assigned to user himself\ngenerated-user-info=Generated User Info\ngenerated-user-info.tooltip=See the example User Info, which will be provided by the User Info Endpoint\n\nmanage=Manage\nauthentication=Authentication\nuser-federation=User Federation\nuser-storage=User Storage\nevents=Events\nrealm-settings=Realm Settings\nconfigure=Configure\nselect-realm=Select realm\nadd=Add\n\nclient-storage=Client Storage\nno-client-storage-providers-configured=No client storage providers configured\nclient-stores.tooltip=Keycloak can retrieve clients and their details from external stores.\n\nclient-scope.name.tooltip=Name of the client scope. Must be unique in the realm. Name should not contain space characters as it is used as value of scope parameter\nclient-scope.description.tooltip=Description of the client scope\nclient-scope.protocol.tooltip=Which SSO protocol configuration is being supplied by this client scope\nclient-scope.display-on-consent-screen=Display On Consent Screen\nclient-scope.display-on-consent-screen.tooltip=If on, and this client scope is added to some client with consent required, the text specified by 'Consent Screen Text' will be displayed on consent screen. If off, this client scope will not be displayed on the consent screen\nclient-scope.consent-screen-text=Consent Screen Text\nclient-scope.consent-screen-text.tooltip=Text that will be shown on the consent screen when this client scope is added to some client with consent required. Defaults to name of client scope if it is not filled\nclient-scope.gui-order=GUI order\nclient-scope.gui-order.tooltip=Specify order of the provider in GUI (such as in Consent page) as integer\nclient-scope.include-in-token-scope=Include In Token Scope\nclient-scope.include-in-token-scope.tooltip=If on, the name of this client scope will be added to the access token property 'scope' as well as to the Token Introspection Endpoint response. If off, this client scope will be omitted from the token and from the Token Introspection Endpoint response.\nclient-scope.is-dynamic-scope=Dynamic Scope\nclient-scope.is-dynamic-scope.tooltip=If on, this scope will be considered a Dynamic Scope, which will be comprised of a static and a variable portion.\nclient-scope.dynamic-scope-regexp=Dynamic Scope Format\nclient-scope.dynamic-scope-regexp.tooltip=This is the regular expression that the system will use to extract the scope name and variable.\n\nadd-user-federation-provider=Add user federation provider\nadd-user-storage-provider=Add user storage provider\nrequired-settings=Required Settings\nprovider-id=Provider ID\nconsole-display-name=Console Display Name\nconsole-display-name.tooltip=Display name of provider when linked in admin console.\npriority=Priority\npriority.tooltip=Priority of provider when doing a user lookup. Lowest first.\nuser-storage.enabled.tooltip=If provider is disabled, it will not be considered for queries and imported users will be disabled and read-only until the provider is enabled again.\nsync-settings=Sync Settings\nperiodic-full-sync=Periodic Full Sync\nperiodic-full-sync.tooltip=Does periodic full synchronization of provider users to Keycloak should be enabled or not\nfull-sync-period=Full Sync Period\nfull-sync-period.tooltip=Period for full synchronization in seconds\nperiodic-changed-users-sync=Periodic Changed Users Sync\nperiodic-changed-users-sync.tooltip=Does periodic synchronization of changed or newly created provider users to Keycloak should be enabled or not\nchanged-users-sync-period=Changed Users Sync Period\nchanged-users-sync-period.tooltip=Period for synchronization of changed or newly created provider users in seconds\nsynchronize-changed-users=Synchronize changed users\nsynchronize-all-users=Synchronize all users\nremove-imported-users=Remove imported\nunlink-users=Unlink users\nkerberos-realm=Kerberos Realm\nkerberos-realm.tooltip=Name of kerberos realm. For example FOO.ORG\nserver-principal=Server Principal\nserver-principal.tooltip=Full name of server principal for HTTP service including server and domain name. For example 'HTTP/host.foo.org@FOO.ORG'. Use '*' to accept any service principal in the KeyTab file.\nkeytab=KeyTab\nkeytab.tooltip=Location of Kerberos KeyTab file containing the credentials of server principal. For example /etc/krb5.keytab\ndebug=Debug\ndebug.tooltip=Enable/disable debug logging to standard output for Krb5LoginModule.\nallow-password-authentication=Allow Password Authentication\nallow-password-authentication.tooltip=Enable/disable possibility of username/password authentication against Kerberos database\nedit-mode=Edit Mode\nedit-mode.tooltip=READ_ONLY means that password updates are not allowed and user always authenticates with Kerberos password. UNSYNCED means that the user can change the password in the Keycloak database and this one will be used instead of the Kerberos password\nldap.edit-mode.tooltip=READ_ONLY is a read-only LDAP store. WRITABLE means data will be synced back to LDAP on demand. UNSYNCED means user data will be imported, but not synced back to LDAP.\nupdate-profile-first-login=Update Profile First Login\nupdate-profile-first-login.tooltip=Update profile on first login\nsync-registrations=Sync Registrations\nldap.sync-registrations.tooltip=Should newly created users be created within LDAP store? Priority effects which provider is chosen to sync the new user. This setting is effectively appplied only with WRITABLE edit mode.\nimport-enabled=Import Users\nldap.import-enabled.tooltip=If true, LDAP users will be imported into Keycloak DB and synced by the configured sync policies.\nvendor=Vendor\nldap.vendor.tooltip=LDAP vendor (provider)\nenable-usePasswordModifyExtendedOp=Enable the LDAPv3 Password Modify Extended Operation\nldap.usePasswordModifyExtendedOp.tooltip=Use the LDAPv3 Password Modify Extended Operation (RFC-3062). The password modify extended operation usually requires that LDAP user already has password in the LDAP server. So when this is used with 'Sync Registrations', it can be good to add also 'Hardcoded LDAP attribute mapper' with randomly generated initial password. \nusername-ldap-attribute=Username LDAP attribute\nldap-attribute-name-for-username=LDAP attribute name for username\nusername-ldap-attribute.tooltip=Name of LDAP attribute, which is mapped as Keycloak username. For many LDAP server vendors it can be 'uid'. For Active directory it can be 'sAMAccountName' or 'cn'. The attribute should be filled for all LDAP user records you want to import from LDAP to Keycloak.\nrdn-ldap-attribute=RDN LDAP attribute\nldap-attribute-name-for-user-rdn=LDAP attribute name for user RDN\nrdn-ldap-attribute.tooltip=Name of LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as Username LDAP attribute, however it is not required. For example for Active directory, it is common to use 'cn' as RDN attribute when username attribute might be 'sAMAccountName'.\nuuid-ldap-attribute=UUID LDAP attribute\nldap-attribute-name-for-uuid=LDAP attribute name for UUID\nuuid-ldap-attribute.tooltip=Name of LDAP attribute, which is used as unique object identifier (UUID) for objects in LDAP. For many LDAP server vendors, it is 'entryUUID'; however some are different. For example for Active directory it should be 'objectGUID'. If your LDAP server does not support the notion of UUID, you can use any other attribute that is supposed to be unique among LDAP users in tree. For example 'uid' or 'entryDN'.\nuser-object-classes=User Object Classes\nldap-user-object-classes.placeholder=LDAP User Object Classes (div. by comma)\nldap-connection-url=LDAP connection URL\nldap-users-dn=LDAP Users DN\nldap-bind-dn=LDAP Bind DN\nldap-bind-credentials=LDAP Bind Credentials\nldap-filter=LDAP Filter\nldap.user-object-classes.tooltip=All values of LDAP objectClass attribute for users in LDAP divided by comma. For example: 'inetOrgPerson, organizationalPerson' . Newly created Keycloak users will be written to LDAP with all those object classes and existing LDAP user records are found just if they contain all those object classes.\nconnection-url=Connection URL\nldap.connection-url.tooltip=Connection URL to your LDAP server\ntest-connection=Test connection\nusers-dn=Users DN\nldap.users-dn.tooltip=Full DN of LDAP tree where your users are. This DN is the parent of LDAP users. It could be for example 'ou=users,dc=example,dc=com' assuming that your typical user will have DN like 'uid=john,ou=users,dc=example,dc=com'\nauthentication-type=Bind Type\nldap.authentication-type.tooltip=Type of the Authentication method used during LDAP Bind operation. It is used in most of the requests sent to the LDAP server. Currently only 'none' (anonymous LDAP authentication) or 'simple' (Bind credential + Bind password authentication) mechanisms are available\nbind-dn=Bind DN\nldap.bind-dn.tooltip=DN of LDAP admin, which will be used by Keycloak to access LDAP server\nbind-credential=Bind Credential\nldap.bind-credential.tooltip=Password of LDAP admin. This field is able to obtain its value from vault, use ${vault.ID} format.\ntest-authentication=Test authentication\ncustom-user-ldap-filter=Custom User LDAP Filter\nldap.custom-user-ldap-filter.tooltip=Additional LDAP Filter for filtering searched users. Leave this empty if you don't need additional filter. Make sure that it starts with '(' and ends with ')'\nsearch-scope=Search Scope\nldap.search-scope.tooltip=For one level, the search applies only for users in the DNs specified by User DNs. For subtree, the search applies to the whole subtree. See LDAP documentation for more details\nuse-truststore-spi=Use Truststore SPI\nldap.use-truststore-spi.tooltip=Specifies whether LDAP connection will use the truststore SPI with the truststore configured in standalone.xml/domain.xml. 'Always' means that it will always use it. 'Never' means that it will not use it. 'Only for ldaps' means that it will use if your connection URL use ldaps. Note even if standalone.xml/domain.xml is not configured, the default Java cacerts or certificate specified by 'javax.net.ssl.trustStore' property will be used.\nvalidate-password-policy=Validate Password Policy\nconnection-pooling=Connection Pooling\nconnection-pooling-settings=Connection Pooling Settings\nconnection-pooling-authentication=Connection Pooling Authentication\nconnection-pooling-authentication-default=none simple\nconnection-pooling-debug=Connection Pool Debug Level\nconnection-pooling-debug-default=off\nconnection-pooling-initsize=Connection Pool Initial Size\nconnection-pooling-initsize-default=1\nconnection-pooling-maxsize=Connection Pool Maximum Size\nconnection-pooling-maxsize-default=1000\nconnection-pooling-prefsize=Connection Pool Preferred Size\nconnection-pooling-prefsize-default=5\nconnection-pooling-protocol=Connection Pool Protocol\nconnection-pooling-protocol-default=plain ssl\nconnection-pooling-timeout=Connection Pool Timeout\nconnection-pooling-timeout-default=300000\nldap-connection-timeout=Connection Timeout\nldap.connection-timeout.tooltip=LDAP Connection Timeout in milliseconds\nldap-read-timeout=Read Timeout\nldap.read-timeout.tooltip=LDAP Read Timeout in milliseconds. This timeout applies for LDAP read operations\nldap.validate-password-policy.tooltip=Determines if Keycloak should validate the password with the realm password policy before updating the LDAP mapped user. When this is false, Keycloak password policy would not be applied, which means that password will be updated on LDAP server unless LDAP server itself has some password policy rules. This setting is possible only with WRITABLE edit mode.\nldap.connection-pooling.tooltip=Determines if Keycloak should use connection pooling for accessing LDAP server\nldap.connection-pooling.authentication.tooltip=A list of space-separated authentication types of connections that may be pooled. Valid types are \"none\", \"simple\", and \"DIGEST-MD5\".\nldap.connection-pooling.debug.tooltip=A string that indicates the level of debug output to produce. Valid values are \"fine\" (trace connection creation and removal) and \"all\" (all debugging information).\nldap.connection-pooling.initsize.tooltip=The string representation of an integer that represents the number of connections per connection identity to create when initially creating a connection for the identity.\nldap.connection-pooling.maxsize.tooltip=The string representation of an integer that represents the maximum number of connections per connection identity that can be maintained concurrently.\nldap.connection-pooling.prefsize.tooltip=The string representation of an integer that represents the preferred number of connections per connection identity that should be maintained concurrently.\nldap.connection-pooling.protocol.tooltip=A list of space-separated protocol types of connections that may be pooled. Valid types are \"plain\" and \"ssl\".\nldap.connection-pooling.timeout.tooltip=The string representation of an integer that represents the number of milliseconds that an idle connection may remain in the pool without being closed and removed from the pool.\nldap.pagination.tooltip=Does the LDAP server support pagination.\nldap.startTls.tooltip=Encrypts the connection to LDAP using STARTTLS, which will disable connection pooling.\nkerberos-integration=Kerberos Integration\nallow-kerberos-authentication=Allow Kerberos authentication\nldap.allow-kerberos-authentication.tooltip=Enable/disable HTTP authentication of users with SPNEGO/Kerberos tokens. The data about authenticated users will be provisioned from this LDAP server\nuse-kerberos-for-password-authentication=Use Kerberos For Password Authentication\nldap.use-kerberos-for-password-authentication.tooltip=Use Kerberos login module for authenticate username/password against Kerberos server instead of authenticating against LDAP server with Directory Service API\nbatch-size=Batch Size\nldap.batch-size.tooltip=Count of LDAP users to be imported from LDAP to Keycloak within a single transaction.\nldap.periodic-full-sync.tooltip=Does periodic full synchronization of LDAP users to Keycloak should be enabled or not\nldap.periodic-changed-users-sync.tooltip=Does periodic synchronization of changed or newly created LDAP users to Keycloak should be enabled or not\nldap.changed-users-sync-period.tooltip=Period for synchronization of changed or newly created LDAP users in seconds\nuser-federation-mappers=User Federation Mappers\ncreate-user-federation-mapper=Create user federation mapper\nadd-user-federation-mapper=Add user federation mapper\nprovider-name=Provider Name\nno-user-federation-providers-configured=No user federation providers configured\nno-user-storage-providers-configured=No user storage providers configured\nadd-identity-provider=Add identity provider\nadd-identity-provider-link=Add identity provider link\nidentity-provider=Identity Provider\nidentity-provider-user-id=Identity Provider User ID\nidentity-provider-user-id.tooltip=Unique ID of the user on the Identity Provider side\nidentity-provider-username=Identity Provider Username\nidentity-provider-username.tooltip=Username on the Identity Provider side\npagination=Pagination\nbrowser-flow=Browser Flow\nbrowser-flow.tooltip=Select the flow you want to use for browser authentication.\nregistration-flow=Registration Flow\nregistration-flow.tooltip=Select the flow you want to use for registration.\ndirect-grant-flow=Direct Grant Flow\ndirect-grant-flow.tooltip=Select the flow you want to use for direct grant authentication.\nreset-credentials=Reset Credentials\nreset-credentials.tooltip=Select the flow you want to use when the user has forgotten their credentials.\nclient-authentication=Client Authentication\nclient-authentication.tooltip=Select the flow you want to use for authentication of clients.\ndocker-auth=Docker Authentication\ndocker-auth.tooltip=Select the flow you want to use for authentication against a docker client.\nnew=New\ncopy=Copy\nadd-execution=Add execution\nadd-flow=Add flow\nauth-type=Auth Type\nrequirement=Requirement\nconfig=Config\nno-executions-available=No executions available\nauthentication-flows=Authentication Flows\ncreate-authenticator-config=Create authenticator config\nauthenticator.alias.tooltip=Name of the configuration\notp-type=OTP Type\ntime-based=Time Based\ncounter-based=Counter Based\notp-type.tooltip=totp is Time-Based One Time Password. 'hotp' is a counter base one time password in which the server keeps a counter to hash against.\notp-hash-algorithm=OTP Hash Algorithm\notp-hash-algorithm.tooltip=What hashing algorithm should be used to generate the OTP.\nnumber-of-digits=Number of Digits\notp.number-of-digits.tooltip=How many digits should the OTP have?\nlook-ahead-window=Look Ahead Window\notp.look-ahead-window.tooltip=How far ahead should the server look just in case the token generator and server are out of counter sync?\nlook-around-window=Look Around Window\notp.look-around-window.tooltip=How far should the server look around just in case the token generator and server are out of time sync?\ninitial-counter=Initial Counter\notp.initial-counter.tooltip=What should the initial counter value be?\notp-token-period=OTP Token Period\notp-token-period.tooltip=How many seconds should an OTP token be valid? Defaults to 30 seconds.\notp-supported-applications=Supported Applications\notp-supported-applications.tooltip=Applications that are known to work with the current OTP policy\nloa-level=Level of Authentication\nloa-level.tooltip=Sets the Level of Authentication to the specified value.\nloa-max-age=Max Age\nloa-max-age.tooltip=Maximum age in seconds for which this level is considered valid after successful authentication. For example if this is set to 300 and user authenticated with this level and then tries to authenticate again in less than 300 second, then this level will be automatically considered as authenticated without need of user to re-authenticate. If it is set to 0, then the authenticated level is valid just for this authentication and next authentication will always need to re-authenticate. Default value is 10 hours, which is same as default SSO session timeout and it means that level is valid until end of SSO session and user doesn't need to re-authenticate.\nloa-condition-level=Level of Authentication (LoA)\nloa-condition-level.tooltip=The number value, usually 1 or bigger, which specifies level of authentication. Condition evaluates to true if user does not yet have this authentication level and this level is requested. This level of authentication will be set to the session after the subflow, where this condition is configured, is successfully finished.\ntable-of-password-policies=Table of Password Policies\nadd-policy.placeholder=Add policy...\npolicy-type=Policy Type\npolicy-value=Policy Value\nwebauthn-policy=WebAuthn Policy\nwebauthn-policy.tooltip=Policy for WebAuthn authentication. This one will be used by 'WebAuthn Register' required action and 'WebAuthn Authenticator' authenticator. Typical usage is, when WebAuthn will be used for the two-factor authentication.\nwebauthn-policy-passwordless=WebAuthn Passwordless Policy\nwebauthn-policy-passwordless.tooltip=Policy for passwordless WebAuthn authentication. This one will be used by 'Webauthn Register Passwordless' required action and 'WebAuthn Passwordless Authenticator' authenticator. Typical usage is, when WebAuthn will be used as first-factor authentication. Having both 'WebAuthn Policy' and 'WebAuthn Passwordless Policy' allows to use WebAuthn as both first factor and second factor authenticator in the same realm.\nwebauthn-rp-entity-name=Relying Party Entity Name\nwebauthn-rp-entity-name.tooltip=Human-readable server name as WebAuthn Relying Party\nwebauthn-signature-algorithms=Signature Algorithms\nwebauthn-signature-algorithms.tooltip=What signature algorithms should be used for Authentication Assertion.\nwebauthn-rp-id=Relying Party ID\nwebauthn-rp-id.tooltip=This is ID as WebAuthn Relying Party. It must be origin's effective domain.\nwebauthn-attestation-conveyance-preference=Attestation Conveyance Preference\nwebauthn-attestation-conveyance-preference.tooltip=Communicates to an authenticator the preference of how to generate an attestation statement.\nwebauthn-authenticator-attachment=Authenticator Attachment\nwebauthn-authenticator-attachment.tooltip=Communicates to an authenticator an acceptable attachment pattern.\nwebauthn-require-resident-key=Require Resident Key\nwebauthn-require-resident-key.tooltip=It tells an authenticator create a public key credential as Resident Key or not.\nwebauthn-user-verification-requirement=User Verification Requirement\nwebauthn-user-verification-requirement.tooltip=Communicates to an authenticator to confirm actually verifying a user.\nwebauthn-create-timeout=Timeout\nwebauthn-create-timeout.tooltip=Timeout value for creating user's public key credential in seconds. if set to 0, this timeout option is not adapted.\nwebauthn-avoid-same-authenticator-register=Avoid Same Authenticator Registration\nwebauthn-avoid-same-authenticator-register.tooltip=avoid registering the authenticator that has already been registered.\nwebauthn-acceptable-aaguids=Acceptable AAGUIDs\nwebauthn-acceptable-aaguids.tooltip=The list of AAGUID of which an authenticator can be registered.\nmanage-webauthn-authenticator=Manage WebAuthn Authenticator\npublic-key-credential-id=Public Key Credential ID\npublic-key-credential-aaguid=Public Key Credential AAGUID\npublic-key-credential-label=Public Key Credential Label\nciba-policy=CIBA Policy\nciba-backchannel-tokendelivery-mode=Backchannel Token Delivery Mode\nciba-backchannel-tokendelivery-mode.tooltip=Specifies how the CD(Consumption Device) gets the authentication result and related tokens. This mode will be used by default for the CIBA clients, which do not have other mode explicitly set. The default mode is 'poll'.\nciba-expires-in=Expires In\nciba-expires-in.tooltip=The expiration time of the \"auth_req_id\" in seconds since the authentication request was received.\nciba-interval=Interval\nciba-interval.tooltip=The minimum amount of time in seconds that the CD(Consumption Device) must wait between polling requests to the token endpoint.\nciba-auth-requested-user-hint=Authentication Requested User Hint\nciba-auth-requested-user-hint.tooltip=The way of identifying the end-user for whom authentication is being requested.\nadmin-events=Admin Events\nadmin-events.tooltip=Displays saved admin events for the realm. Events are related to admin account, for example a realm creation. To enable persisted events go to config.\nlogin-events=Login Events\nfilter=Filter\nupdate=Update\nreset=Reset\noperation-types=Operation Types\nresource-types=Resource Types\nselect-operations.placeholder=Select operations...\nselect-resource-types.placeholder=Select resource types...\nresource-path=Resource Path\nresource-path.tooltip=Filter by resource path. Supports wildcard '*' (for example 'users/*').\ndate-(from)=Date (From)\ndate-(to)=Date (To)\nauthentication-details=Authentication Details\nip-address=IP Address\ntime=Time\noperation-type=Operation Type\nresource-type=Resource Type\nauth=Auth\nrepresentation=Representation\nregister=Register\nrequired-action=Required Action\ndefault-action=Default Action\nauth.default-action.tooltip=If enabled, any new user will have this required action assigned to it.\nno-required-actions-configured=No required actions configured\ndefaults-to-id=Defaults to id\nflows=Flows\nbindings=Bindings\nclient-flow-bindings=Authentication Flow Overrides\nclient-flow-bindings.tooltip=Override realm authentication flow bindings.\nrequired-actions=Required Actions\npassword-policy=Password Policy\notp-policy=OTP Policy\nuser-groups=User Groups\ndefault-groups=Default Groups\ngroups.default-groups.tooltip=Set of groups that new users will automatically join.\ncut=Cut\npaste=Paste\ncreate-group=Create group\ncreate-authenticator-execution=Create Authenticator Execution\nedit-flow=Edit Flow\ncreate-form-action-execution=Create Form Action Execution\ncreate-top-level-form=Create Top Level Form\nflow.alias.tooltip=Specifies display name for the flow.\ntop-level-flow-type=Top Level Flow Type\nflow.generic=generic\nflow.client=client\ntop-level-flow-type.tooltip=What kind of top level flow is it? Type 'client' is used for authentication of clients (applications) when generic is for users and everything else\ncreate-execution-flow=Create Execution Flow\nflow-type=Flow Type\nflow.form.type=form\nflow.generic.type=generic\nflow-type.tooltip=What kind of form is it\nform-provider=Form Provider\ndefault-groups.tooltip=Newly created or registered users will automatically be added to these groups\nselect-a-type.placeholder=select a type\navailable-groups=Available Groups\navailable-groups.tooltip=Select a group you want to add as a default.\nvalue=Value\ntable-of-group-members=Table of group members\ntable-of-role-members=Table of role members\nlast-name=Last Name\nfirst-name=First Name\nemail=Email\ntoggle-navigation=Toggle navigation\nmanage-account=Manage account\nsign-out=Sign Out\nserver-info=Server Info\nresource-not-found=Resource <strong>not found</strong>...\nresource-not-found.instruction=We could not find the resource you are looking for. Please make sure the URL you entered is correct.\ngo-to-the-home-page=Go to the home page &raquo;\npage-not-found=Page <strong>not found</strong>...\npage-not-found.instruction=We could not find the page you are looking for. Please make sure the URL you entered is correct.\nevents.tooltip=Displays saved events for the realm. Events are related to user accounts, for example a user login. To enable persisted events go to config.\nselect-event-types.placeholder=Select event types...\nevents-config.tooltip=Displays configuration options to enable persistence of user and admin events.\nselect-an-action.placeholder=Select an action...\nevent-listeners.tooltip=Configure what listeners receive events for the realm.\nlogin.save-events.tooltip=If enabled, login events are saved to the database, which makes events available to the admin and account management consoles.\nclear-events.tooltip=Deletes all events in the database.\nevents.expiration.tooltip=Sets the expiration for events. Expired events are periodically deleted from the database.\nadmin-events-settings=Admin Events Settings\nsave-events=Save Events\nadmin.save-events.tooltip=If enabled, admin events are saved to the database, which makes events available to the admin console.\nsaved-types.tooltip=Configure what event types are saved.\ninclude-representation=Include Representation\ninclude-representation.tooltip=Include JSON representation for create and update requests.\nclear-admin-events.tooltip=Deletes all admin events in the database.\nserver-version=Server Version\nserver-profile=Server Profile\nserver-disabled=Disabled Features\nserver-disabled.tooltip=Features that are not currently enabled. Some features are not enabled by default. This applies to all preview and experimental features.\nserver-preview=Preview Features\nserver-preview.tooltip=Preview features are not supported in production use and may be significantly changed or removed in the future.\nserver-experimental=Experimental Features\nserver-experimental.tooltip=Experimental features, which may not be fully functional. Never use experimental features in production.\ninfo=Info\nproviders=Providers\nserver-time=Server Time\nserver-uptime=Server Uptime\nprofile=Profile\nmemory=Memory\ntotal-memory=Total Memory\nfree-memory=Free Memory\nused-memory=Used Memory\nsystem=System\ncurrent-working-directory=Current Working Directory\njava-version=Java Version\njava-vendor=Java Vendor\njava-runtime=Java Runtime\njava-vm=Java VM\njava-vm-version=Java VM Version\njava-home=Java Home\nuser-name=User Name\nuser-timezone=User Timezone\nuser-locale=User Locale\nsystem-encoding=System Encoding\noperating-system=Operating System\nos-architecture=OS Architecture\nspi=SPI\ngranted-client-scopes=Granted Client Scopes\nadditional-grants=Additional Grants\nconsent-created-date=Created\nconsent-last-updated-date=Last updated\nrevoke=Revoke\nnew-password=New Password\npassword-confirmation=Password Confirmation\nreset-password=Reset Password\nset-password=Set Password\ncredentials.temporary.tooltip=If enabled, the user must change the password on next login\nremove-totp=Remove OTP\ncredentials.remove-totp.tooltip=Remove one time password generator for user.\nreset-actions=Reset Actions\ncredentials.reset-actions.tooltip=Set of actions to execute when sending the user a Reset Actions Email. 'Verify email' sends an email to the user to verify their email address. 'Update profile' requires user to enter in new personal information. 'Update password' requires user to enter in a new password. 'Configure OTP' requires setup of a mobile password generator.\nreset-actions-email=Reset Actions Email\nsend-email=Send email\ncredentials.reset-actions-email.tooltip=Sends an email to user with an embedded link. Clicking the link enables the user to execute the reset actions without first logging in. For example, set the action to update password, click this button, and the user can change the password without logging in.\nadd-user=Add user\ncreated-at=Created At\nuser-enabled=User Enabled\nuser-enabled.tooltip=A disabled user cannot login.\nuser-temporarily-locked=User Temporarily Locked\nuser-temporarily-locked.tooltip=The user may be locked due to multiple failed attempts to log in.\nunlock-user=Unlock user\nfederation-link=Federation Link\nemail-verified=Email Verified\nemail-verified.tooltip=Has the user's email been verified?\ngroups-joining=Groups\ngroups-joining.tooltip=Groups the user will be joining. To add a group, search for any existing one and select it.\ngroups-joining-select.placeholder=Select existing group\ngroups-joining-no-selected=No group selected\ngroups-joining-path=Path\nrequired-user-actions=Required User Actions\nrequired-user-actions.tooltip=Require an action when the user logs in. 'Verify email' sends an email to the user to verify their email address. 'Update profile' requires user to enter in new personal information. 'Update password' requires user to enter in a new password. 'Configure OTP' requires setup of a mobile password generator.\nlocale=Locale\nselect-one.placeholder=Select one...\nimpersonate=Impersonate\nimpersonate-user=Impersonate user\nimpersonate-user.tooltip=Login as this user. If user is in same realm as you, your current login session will be logged out before you are logged in as this user.\nidentity-provider-alias=Identity Provider Alias\nprovider-user-id=Provider User ID\nprovider-username=Provider Username\nno-identity-provider-links-available=No identity provider links available\ngroup-membership=Group Membership\nleave=Leave\ngroup-membership.tooltip=Groups where the user has membership. To leave a group, select it and click Leave.\nmembership.available-groups.tooltip=Groups a user can join. Select a group and click Join.\ntable-of-realm-users=Table of Realm Users\nview-all-users=View all users\nview-all-groups=View all groups\nview-all-roles=View all roles\nunlock-users=Unlock users\nno-users-available=No users available\nusers.instruction=Please enter a search, or click on view all users\nclients.instruction=Please enter a search\nconsents=Consents\nstarted=Started\nlogout-all-sessions=Log out all sessions\nlogout=Logout\nnew-name=New Name\nnew-description=New Description\nok=Ok\nattributes=Attributes\nrole-mappings=Role Mappings\nmembers=Members\ndetails=Details\nidentity-provider-links=Identity Provider Links\nregister-required-action=Register required action\ngender=Gender\naddress=Address\nphone=Phone\nprofile-url=Profile URL\npicture-url=Picture URL\nwebsite=Website\nimport-keys-and-cert=Import keys and cert\nimport-keys-and-cert.tooltip=Upload the client's key pair and cert.\nupload-keys=Upload Keys\ndownload-keys-and-cert=Download keys and cert\nno-value-assigned.placeholder=No value assigned\nremove=Remove\nno-group-members=No group members\nno-role-members=No role members\ntemporary=Temporary\njoin=Join\nevent-type=Event Type\nevents-config=Events Config\nevent-listeners=Event Listeners\nlogin-events-settings=Login Events Settings\nclear-events=Clear events\nsaved-types=Saved Types\nclear-admin-events=Clear admin events\nclear-changes=Clear changes\nerror=Error\n# Authz\n# Authz Common\nauthz-authorization=Authorization\nauthz-owner=Owner\nauthz-uri=URI\nauthz-uris=URIS\nauthz-scopes=Scopes\nauthz-resource=Resource\nauthz-resource-type=Resource Type\nauthz-resources=Resources\nauthz-scope=Scope\nauthz-authz-scopes=Authorization Scopes\nauthz-policies=Policies\nauthz-policy=Policy\nauthz-permissions=Permissions\nauthz-users=Users in Role\nauthz-evaluate=Evaluate\nauthz-icon-uri=Icon URI\nauthz-icon-uri.tooltip=An URI pointing to an icon.\nauthz-select-scope=Select a scope\nauthz-select-resource=Select a resource\nauthz-associated-policies=Associated Policies\nauthz-any-resource=Any resource\nauthz-any-scope=Any scope\nauthz-any-role=Any role\nauthz-policy-evaluation=Policy Evaluation\nauthz-select-user=Select a user\nauthz-select-client=Select a client\nauthz-entitlements=Entitlements\nauthz-no-resources=No resources\nauthz-result=Result\nauthz-authorization-services-enabled=Authorization Enabled\nauthz-authorization-services-enabled.tooltip=Enable/Disable fine-grained authorization support for a client\nauthz-required=Required\nauthz-show-details=Show Details\nauthz-hide-details=Hide Details\nauthz-associated-permissions=Associated Permissions\nauthz-no-permission-associated=No permissions associated\n# Authz Settings\nauthz-import-config.tooltip=Import a JSON file containing authorization settings for this resource server.\nauthz-policy-enforcement-mode=Policy Enforcement Mode\nauthz-policy-enforcement-mode.tooltip=The policy enforcement mode dictates how policies are enforced when evaluating authorization requests. 'Enforcing' means requests are denied by default even when there is no policy associated with a given resource. 'Permissive' means requests are allowed even when there is no policy associated with a given resource. 'Disabled' completely disables the evaluation of policies and allows access to any resource.\nauthz-policy-enforcement-mode-enforcing=Enforcing\nauthz-policy-enforcement-mode-permissive=Permissive\nauthz-policy-enforcement-mode-disabled=Disabled\nauthz-remote-resource-management=Remote Resource Management\nauthz-remote-resource-management.tooltip=Should resources be managed remotely by the resource server? If false, resources can be managed only from this admin console.\nauthz-export-settings=Export Settings\nauthz-export-settings.tooltip=Export and download all authorization settings for this resource server.\nauthz-server-decision-strategy.tooltip=The decision strategy dictates how permissions are evaluated and how a final decision is obtained. 'Affirmative' means that at least one permission must evaluate to a positive decision in order to grant access to a resource and its scopes. 'Unanimous' means that all permissions must evaluate to a positive decision in order for the final decision to be also positive.\n# Authz Resource List\nauthz-no-resources-available=No resources available.\nauthz-no-scopes-assigned=No scopes assigned.\nauthz-no-type-defined=No type defined.\nauthz-no-uri-defined=No URI defined.\nauthz-no-permission-assigned=No permission assigned.\nauthz-no-policy-assigned=No policy assigned.\nauthz-create-permission=Create Permission\n# Authz Resource Detail\nauthz-add-resource=Add Resource\nauthz-resource-name.tooltip=A unique name for this resource. The name can be used to uniquely identify a resource, useful when querying for a specific resource.\nauthz-resource-owner.tooltip=The owner of this resource.\nauthz-resource-type.tooltip=The type of this resource. It can be used to group different resource instances with the same type.\nauthz-resource-uri.tooltip=Set of URIs which are protected by resource.\nauthz-resource-scopes.tooltip=The scopes associated with this resource.\nauthz-resource-attributes=Resource Attributes\nauthz-resource-attributes.tooltip=The attributes associated wth the resource.\nauthz-resource-user-managed-access-enabled=User-Managed Access Enabled\nauthz-resource-user-managed-access-enabled.tooltip=If enabled, the access to this resource can be managed by the resource owner.\n\n# Authz Scope List\nauthz-add-scope=Add Scope\nauthz-no-scopes-available=No scopes available.\n# Authz Scope Detail\nauthz-scope-name.tooltip=A unique name for this scope. The name can be used to uniquely identify a scope, useful when querying for a specific scope.\n# Authz Policy List\nauthz-all-types=All types\nauthz-create-policy=Create Policy\nauthz-no-policies-available=No policies available.\n# Authz Policy Detail\nauthz-policy-name.tooltip=The name of this policy.\nauthz-policy-description.tooltip=A description for this policy.\nauthz-policy-logic=Logic\nauthz-policy-logic-positive=Positive\nauthz-policy-logic-negative=Negative\nauthz-policy-logic.tooltip=The logic dictates how the policy decision should be made. If 'Positive', the resulting effect (permit or deny) obtained during the evaluation of this policy will be used to perform a decision. If 'Negative', the resulting effect will be negated, in other words, a permit becomes a deny and vice-versa.\nauthz-policy-apply-policy=Apply Policy\nauthz-policy-apply-policy.tooltip=Specifies all the policies that must be applied to the scopes defined by this policy or permission.\nauthz-policy-decision-strategy=Decision Strategy\nauthz-policy-decision-strategy.tooltip=The decision strategy dictates how the policies associated with a given permission are evaluated and how a final decision is obtained. 'Affirmative' means that at least one policy must evaluate to a positive decision in order for the final decision to be also positive. 'Unanimous' means that all policies must evaluate to a positive decision in order for the final decision to be also positive. 'Consensus' means that the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative is the same, the final decision will be negative.\nauthz-policy-decision-strategy-affirmative=Affirmative\nauthz-policy-decision-strategy-unanimous=Unanimous\nauthz-policy-decision-strategy-consensus=Consensus\nauthz-select-a-policy=Select existing policy\nauthz-no-policies-assigned=No policies assigned.\n# Authz Role Policy Detail\nauthz-add-role-policy=Add Role Policy\nauthz-no-roles-assigned=No roles assigned.\nauthz-policy-role-realm-roles.tooltip=Specifies the *realm* roles allowed by this policy.\nauthz-policy-role-clients.tooltip=Selects a client in order to filter the client roles that can be applied to this policy.\nauthz-policy-role-client-roles.tooltip=Specifies the client roles allowed by this policy.\n# Authz User Policy Detail\nauthz-add-user-policy=Add User Policy\nauthz-no-users-assigned=No users assigned.\nauthz-policy-user-users.tooltip=Specifies which user(s) are allowed by this policy.\n# Authz Client Policy Detail\nauthz-add-client-policy=Add Client Policy\nauthz-no-clients-assigned=No clients assigned.\nauthz-policy-client-clients.tooltip=Specifies which client(s) are allowed by this policy.\n# Authz Time Policy Detail\nauthz-add-time-policy=Add Time Policy\nauthz-policy-time-not-before.tooltip=Defines the time before which the policy MUST NOT be granted. Only granted if current date/time is after or equal to this value.\nauthz-policy-time-not-on-after=Not On or After\nauthz-policy-time-not-on-after.tooltip=Defines the time after which the policy MUST NOT be granted. Only granted if current date/time is before or equal to this value.\nauthz-policy-time-day-month=Day of Month\nauthz-policy-time-day-month.tooltip=Defines the day of month when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current day of month is between or equal to the two values you provided.\nauthz-policy-time-month=Month\nauthz-policy-time-month.tooltip=Defines the month which the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current month is between or equal to the two values you provided.\nauthz-policy-time-year=Year\nauthz-policy-time-year.tooltip=Defines the year when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current year is between or equal to the two values you provided.\nauthz-policy-time-hour=Hour\nauthz-policy-time-hour.tooltip=Defines the hour when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current hour is between or equal to the two values you provided.\nauthz-policy-time-minute=Minute\nauthz-policy-time-minute.tooltip=Defines the minute when the policy MUST be granted. You can also provide a range by filling the second field. In this case, permission is granted only if current minute is between or equal to the two values you provided.\n# Authz JS Policy Detail\nauthz-add-js-policy=Add JavaScript Policy\nauthz-policy-js-code=Code\nauthz-policy-js-code.tooltip=The JavaScript code providing the conditions for this policy.\n# Authz Aggregated Policy Detail\nauthz-aggregated=Aggregated\nauthz-add-aggregated-policy=Add Aggregated Policy\n# Authz Group Policy Detail\nauthz-add-group-policy=Add Group Policy\nauthz-no-groups-assigned=No groups assigned.\nauthz-policy-group-claim=Groups Claim\nauthz-policy-group-claim.tooltip=If defined, the policy will fetch user's groups from the given claim within an access token or ID token representing the identity asking permissions. If not defined, user's groups are obtained from your realm configuration.\nauthz-policy-group-groups.tooltip=Specifies the groups allowed by this policy.\n# Authz Client Scope Policy Detail\nauthz-add-client-scope-policy=Add Client Scope Policy\nauthz-no-client-scopes-assigned=No client scopes assigned.\nauthz-policy-client-scope-client-scopes.tooltip=Specifies which client scope(s) are allowed by this policy.\nselect-a-client-scope=Select a client scope\n# Authz Regex Policy Detail\nauthz-add-regex-policy=Add Regex Policy\nregex=Regex\nauthz-policy-target-claim=Target Claim\nauthz-policy-target-claim.tooltip=Specifies the target claim which the policy will fetch.\nauthz-policy-regex-pattern=Regex Pattern\nauthz-policy-regex-pattern.tooltip=Specifies the regex pattern.\n\n# Authz Permission List\nauthz-no-permissions-available=No permissions available.\n\n# Authz Permission Detail\nauthz-permission-name.tooltip=The name of this permission.\nauthz-permission-description.tooltip=A description for this permission.\n\n# Authz Resource Permission Detail\nauthz-add-resource-permission=Add Resource Permission\nauthz-permission-resource-apply-to-resource-type=Apply to Resource Type\nauthz-permission-resource-apply-to-resource-type.tooltip=Specifies if this permission should be applied to all resources with a given type. In this case, this permission will be evaluated for all instances of a given resource type.\nauthz-permission-resource-resource.tooltip=Specifies that this permission must be applied to a specific resource instance.\nauthz-permission-resource-type.tooltip=Specifies that this permission must be applied to all resources instances of a given type.\n\n# Authz Scope Permission Detail\nauthz-add-scope-permission=Add Scope Permission\nauthz-permission-scope-resource.tooltip=Restrict the scopes to those associated with the selected resource. If not selected all scopes would be available.\nauthz-permission-scope-scope.tooltip=Specifies that this permission must be applied to one or more scopes.\n\n# Authz Evaluation\nauthz-evaluation-identity-information=Identity Information\nauthz-evaluation-identity-information.tooltip=The available options to configure the identity information that will be used when evaluating policies.\nauthz-evaluation-client.tooltip=Select the client making this authorization request. If not provided, authorization requests would be done based on the client you are in.\nauthz-evaluation-user.tooltip=Select a user whose identity is going to be used to query permissions from the server.\nauthz-evaluation-role.tooltip=Select the roles you want to associate with the selected user.\nauthz-evaluation-new=New Evaluation\nauthz-evaluation-re-evaluate=Re-Evaluate\nauthz-evaluation-previous=Previous Evaluation\nauthz-evaluation-contextual-info=Contextual Information\nauthz-evaluation-contextual-info.tooltip=The available options to configure any contextual information that will be used when evaluating policies.\nauthz-evaluation-contextual-attributes=Contextual Attributes\nauthz-evaluation-contextual-attributes.tooltip=Any attribute provided by a running environment or execution context.\nauthz-evaluation-permissions.tooltip=The available options to configure the permissions to which policies will be applied.\nauthz-evaluation-evaluate=Evaluate\nauthz-evaluation-any-resource-with-scopes=Any resource with scope(s)\nauthz-evaluation-no-result=Could not obtain any result for the given authorization request. Check if the provided resource(s) or scope(s) are associated with any policy.\nauthz-evaluation-no-policies-resource=No policies were found for this resource.\nauthz-evaluation-result.tooltip=The overall result for this permission request.\nauthz-evaluation-scopes.tooltip=The list of allowed scopes.\nauthz-evaluation-policies.tooltip=Details about which policies were evaluated and their decisions.\nauthz-evaluation-authorization-data=Response\nauthz-evaluation-authorization-data.tooltip=Represents a token carrying authorization data as a result of the processing of an authorization request. This representation is basically what Keycloak issues to clients asking for permissions. Check the 'authorization' claim for the permissions that were granted based on the current authorization request.\nauthz-show-authorization-data=Show Authorization Data\n\nkeys=Keys\nstatus=Status\nkeystore=Keystore\nkeystores=Keystores\nadd-keystore=Add Keystore\nadd-keystore.placeholder=Add keystore...\nview=View\nactive=Active\npassive=Passive\ndisabled=Disabled\nalgorithm=Algorithm\nproviderHelpText=Provider description\n\nSunday=Sunday\nMonday=Monday\nTuesday=Tuesday\nWednesday=Wednesday\nThursday=Thursday\nFriday=Friday\nSaturday=Saturday\n\nuser-storage-cache-policy=Cache Settings\nuserStorage.cachePolicy=Cache Policy\nuserStorage.cachePolicy.option.DEFAULT=DEFAULT\nuserStorage.cachePolicy.option.EVICT_WEEKLY=EVICT_WEEKLY\nuserStorage.cachePolicy.option.EVICT_DAILY=EVICT_DAILY\nuserStorage.cachePolicy.option.MAX_LIFESPAN=MAX_LIFESPAN\nuserStorage.cachePolicy.option.NO_CACHE=NO_CACHE\nuserStorage.cachePolicy.tooltip=Cache Policy for this storage provider.  'DEFAULT' is whatever the default settings are for the global cache.  'EVICT_DAILY' is a time of day every day that the cache will be invalidated.  'EVICT_WEEKLY' is a day of the week and time the cache will be invalidated.  'MAX-LIFESPAN' is the time in milliseconds that will be the lifespan of a cache entry.\nuserStorage.cachePolicy.evictionDay=Eviction Day\nuserStorage.cachePolicy.evictionDay.tooltip=Day of the week the entry will become invalid on\nuserStorage.cachePolicy.evictionHour=Eviction Hour\nuserStorage.cachePolicy.evictionHour.tooltip=Hour of day the entry will become invalid on.\nuserStorage.cachePolicy.evictionMinute=Eviction Minute\nuserStorage.cachePolicy.evictionMinute.tooltip=Minute of day the entry will become invalid on.\nuserStorage.cachePolicy.maxLifespan=Max Lifespan\nuserStorage.cachePolicy.maxLifespan.tooltip=Max lifespan of cache entry in milliseconds.\nuser-origin-link=Storage Origin\nuser-origin.tooltip=UserStorageProvider the user was loaded from\nuser-link.tooltip=UserStorageProvider this locally stored user was imported from.\nclient-origin-link=Storage Origin\nclient-origin.tooltip=Provider the client was loaded from\n\nclient-storage-cache-policy=Cache Settings\nclientStorage.cachePolicy=Cache Policy\nclientStorage.cachePolicy.option.DEFAULT=DEFAULT\nclientStorage.cachePolicy.option.EVICT_WEEKLY=EVICT_WEEKLY\nclientStorage.cachePolicy.option.EVICT_DAILY=EVICT_DAILY\nclientStorage.cachePolicy.option.MAX_LIFESPAN=MAX_LIFESPAN\nclientStorage.cachePolicy.option.NO_CACHE=NO_CACHE\nclientStorage.cachePolicy.tooltip=Cache Policy for this storage provider.  'DEFAULT' is whatever the default settings are for the global cache.  'EVICT_DAILY' is a time of day every day that the cache will be invalidated.  'EVICT_WEEKLY' is a day of the week and time the cache will be invalidated.  'MAX-LIFESPAN' is the time in milliseconds that will be the lifespan of a cache entry.\nclientStorage.cachePolicy.evictionDay=Eviction Day\nclientStorage.cachePolicy.evictionDay.tooltip=Day of the week the entry will become invalid on\nclientStorage.cachePolicy.evictionHour=Eviction Hour\nclientStorage.cachePolicy.evictionHour.tooltip=Hour of day the entry will become invalid on.\nclientStorage.cachePolicy.evictionMinute=Eviction Minute\nclientStorage.cachePolicy.evictionMinute.tooltip=Minute of day the entry will become invalid on.\nclientStorage.cachePolicy.maxLifespan=Max Lifespan\nclientStorage.cachePolicy.maxLifespan.tooltip=Max lifespan of cache entry in milliseconds.\n\nclient-storage-list-no-entries=Keycloak can federate external client databases. By default, we support Openshift OAuth clients and service accounts. To get started, select a provider from the dropdown below:\n\n\ndisable=Disable\ndisableable-credential-types=Disableable Types\ncredentials.disableable.tooltip=List of credential types that you can disable\ndisable-credential-types=Disable Credential Types\ncredentials.disable.tooltip=Click button to disable selected credential types\ncredential-types=Credential Types\nmanage-user-password=Manage Password\nsupported-user-storage-credential-types=Supported User Storage Credential Types\nsupported-user-storage-credential-types.tooltip=Credential types, which are provided by User Storage Provider and which are configured for this user. Validation and eventually update of the credentials of those types can be delegated to the User Storage Provider based on the configuration and implementation of the particular provider.\nprovided-by=Provided By\nmanage-credentials=Manage Credentials\nmanage-credentials.tooltip=Credentials, which are not provided by the user storage. They are saved in the local database.\ndisable-credentials=Disable Credentials\ncredential-reset-actions=Credential Reset\ncredential-reset-actions-timeout=Expires In\ncredential-reset-actions-timeout.tooltip=Maximum time before the action permit expires.\nldap-mappers=LDAP Mappers\ncreate-ldap-mapper=Create LDAP mapper\nmap-role-mgmt-scope-description=Policies that decide if an administrator can map this role to a user or group\nmanage-authz-users-scope-description=Policies that decide if an administrator can manage all users in the realm\nview-authz-users-scope-description=Policies that decide if an administrator can view all users in realm\npermissions-enabled-role=Permissions Enabled\npermissions-enabled-role.tooltip=Determines if fine grained permissions are enabled for managing this role.  Disabling will delete all current permissions that have been set up.\nmanage-permissions-role.tooltip=Fine grained permissions for managing roles.  For example, you can define different policies for who is allowed to map a role.\nlookup=Lookup\nmanage-permissions-users.tooltip=Fine grained permissions for managing all users in realm.  You can define different policies for who is allowed to manage users in the realm.\npermissions-enabled-users=Permissions Enabled\npermissions-enabled-users.tooltip=Determines if fined grain permissions are enabled for managing users.  Disabling will delete all current permissions that have been set up.\nmanage-permissions-client.tooltip=Fine grained permissions for administrators that want to manage this client or apply roles defined by this client.\nmanage-permissions-group.tooltip=Fine grained permissions for administrators that want to manage this group or the members of this group.\nmanage-authz-group-scope-description=Policies that decide if an administrator can manage this group\nview-authz-group-scope-description=Policies that decide if an administrator can view this group\nview-members-authz-group-scope-description=Policies that decide if an administrator can view the members of this group\ntoken-exchange-authz-client-scope-description=Policies that decide which clients are allowed exchange tokens for a token that is targeted to this client.\ntoken-exchange-authz-idp-scope-description=Policies that decide which clients are allowed exchange tokens for an external token minted by this identity provider.\nmanage-authz-client-scope-description=Policies that decide if an administrator can manage this client\nconfigure-authz-client-scope-description=Reduced management permissions for administrator.  Cannot set scope, template, or protocol mappers.\nview-authz-client-scope-description=Policies that decide if an administrator can view this client\nmap-roles-authz-client-scope-description=Policies that decide if an administrator can map roles defined by this client\nmap-roles-client-scope-authz-client-scope-description=Policies that decide if an administrator can apply roles defined by this client to the client scope of another client\nmap-roles-composite-authz-client-scope-description=Policies that decide if an administrator can apply roles defined by this client as a composite to another role\nmap-role-authz-role-scope-description=Policies that decide if an administrator can map this role to a user or group\nmap-role-client-scope-authz-role-scope-description=Policies that decide if an administrator can apply this role to the client scope of a client\nmap-role-composite-authz-role-scope-description=Policies that decide if an administrator can apply this role as a composite to another role\nmanage-group-membership-authz-users-scope-description=Policies that decide if an administrator can manage group membership for all users in the realm.  This is used in conjunction with specific group policy\nimpersonate-authz-users-scope-description=Policies that decide if administrator can impersonate other users\nmap-roles-authz-users-scope-description=Policies that decide if administrator can map roles for all users\nuser-impersonated-authz-users-scope-description=Policies that decide which users can be impersonated.  These policies are applied to the user being impersonated.\nmanage-membership-authz-group-scope-description=Policies that decide if an administrator can add or remove users from this group\nmanage-members-authz-group-scope-description=Policies that decide if an administrator can manage the members of this group\n\n# KEYCLOAK-6771 Certificate Bound Token\n# https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\nadvanced-client-settings=Advanced Settings\nadvanced-client-settings.tooltip=Expand this section to configure advanced settings of this client\ntls-client-certificate-bound-access-tokens=OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled\ntls-client-certificate-bound-access-tokens.tooltip=This enables support for OAuth 2.0 Mutual TLS Certificate Bound Access Tokens, which means that keycloak bind an access token and a refresh token with a X.509 certificate of a token requesting client exchanged in mutual TLS between keycloak's Token Endpoint and this client. These tokens can be treated as Holder-of-Key tokens instead of bearer tokens.\n\n# PAR request parameters.\nrequire-pushed-authorization-requests=Pushed Authorization Request Required\nrequire-pushed-authorization-requests.tooltip=Boolean parameter indicating whether the authorization server accepts authorization request data only via the pushed authorization request method.\nrequest-uri-lifespan=Lifetime of the Request URI for Pushed Authorization Request\nrequest-uri-lifespan.tooltip=Number that represents the lifetime of the request URI in minutes or hours, the default value is 1 minute.\n\nsubjectdn=Subject DN\nsubjectdn-tooltip=The expected Subject DN, which should match DN from client certificate. In case that 'Allow Regex Pattern Comparison' allowed, this can contain regular expression for validating Subject DN in the Client Certificate. Use \"(.*?)(?:$)\" to match all kind of expressions.\nallow-regex-pattern-comparison=Allow Regex Pattern Comparison\nallow-regex-pattern-comparison.tooltip=If OFF, then the Subject DN from given client certificate must exactly match the given DN from the 'Subject DN' property as described in the RFC8705 specification. The Subject DN can be in the RFC2553 or RFC1779 format. If ON, then the Subject DN from given client certificate should match regex specified by 'Subject DN' property.\n\npkce-code-challenge-method=Proof Key for Code Exchange Code Challenge Method\npkce-code-challenge-method.tooltip=Choose which code challenge method for PKCE is used. If not specified, keycloak does not applies PKCE to a client unless the client sends an authorization request with appropriate code challenge and code exchange method.\n\nuse-idtoken-as-detached-signature=Use ID Token as a Detached Signature\nuse-idtoken-as-detached-signature.tooltip=This makes ID token returned from Authorization Endpoint in OIDC Hybrid flow use as a detached signature defined in FAPI 1.0 Advanced Security Profile. Therefore, this ID token does not include an authenticated user's information.\n\nacr-loa-map=ACR to LoA Mapping\nacr-loa-map.tooltip=Define which ACR (Authentication Context Class Reference) value is mapped to which LoA (Level of Authentication). The ACR can be any value, whereas the LoA must be numeric. The LoA typically refers to the numbers configured as levels in the conditions in the authentication flow. The ACR refers to the value used in the OIDC/SAML authorization request and returned to client in the tokens.\nacr-loa-map-client.tooltip=Define which ACR (Authentication Context Class Reference) value is mapped to which LoA (Level of Authentication). The ACR can be any value, whereas the LoA must be numeric. This is recommended to be configured at the realm level where it is shared for all the clients. If you configure at the client level, the client mapping will take precedence over the mapping from the realm level.\ndefault-acr-values=Default ACR Values\ndefault-acr-values.tooltip=Default values to be used as voluntary ACR in case that there is no explicit ACR requested by 'claims' or 'acr_values' parameter in the OIDC request.\n\nkey-not-allowed-here=Key '{{character}}' is not allowed here.\n\n# KEYCLOAK-10927 Implement LDAPv3 Password Modify Extended Operation\nadvanced-ldap-settings=Advanced Settings\nldap-query-supported-extensions=Query Supported Extensions\nldap-query-supported-extensions.tooltip=This will query LDAP server for supported extensions, controls and features. Some advanced settings of the LDAP provider will be then automatically configured based on the capabilities/extensions/features supported by LDAP server. For example if LDAPv3 Password Modify extension is supported by LDAP server, corresponding switch will be enabled for LDAP provider.   \n\nnotifications.info.header=Info!\nnotifications.success.header=Success!\nnotifications.error.header=Error!\nnotifications.warn.header=Warning!\n\ndialogs.delete.title=Delete {{type}}\ndialogs.delete.message=Are you sure you want to permanently delete the {{type}} {{name}}?\ndialogs.delete.confirm=Delete\ndialogs.cancel=Cancel\ndialogs.ok=Ok\nuse=Use\n\nuser.profile.attribute=Attribute\nuser.profile.attribute.name=Name\nuser.profile.attribute.name.tooltip=The name of the attribute.\nuser.profile.attribute.displayName=Display name\nuser.profile.attribute.displayName.tooltip=Display name for the attribute. Supports keys for localized values as well. For example\\: ${profile.attribute.phoneNumber}.\nuser.profile.attribute.selector.scopes=Enabled when scope\nuser.profile.attribute.selector.scopes.tooltip=Set the attribute as enabled only when a set of one or more scopes are requested by clients. This constraint only applies to flows where clients are able to ask for scopes (e.g.: during login or registration).\nuser.profile.attribute.required=Required\nuser.profile.attribute.required.tooltip=Set the attribute as required. If enabled, the attribute must be set by users and administrators. Otherwise, the attribute is optional.\nuser.profile.attribute.required.roles=Required for roles\nuser.profile.attribute.required.roles.tooltip=Set the attribute as required for specific types of users. If set to 'user', the attribute is required for users. If set to 'admin' the attribute is required only for administrators.\nuser.profile.attribute.required.scopes=Required for scopes\nuser.profile.attribute.required.scopes.tooltip=Set the attribute as required only when a set of one or more scopes are requested by clients. This constraint only applies to flows where clients are able to ask for scopes (e.g.: during login or registration).\nuser.profile.attribute.permission=Permission\nuser.profile.attribute.canUserView=Can user view?\nuser.profile.attribute.canUserView.tooltip=If enabled, users can view the attribute. Otherwise, users don't have access to the attribute.\nuser.profile.attribute.canUserEdit=Can user edit?\nuser.profile.attribute.canUserEdit.tooltip=If enabled, users can view and edit the attribute. Otherwise, users don't have access to write to the attribute.\nuser.profile.attribute.canAdminView=Can admin view?\nuser.profile.attribute.canAdminView.tooltip=If enabled, administrators can view the attribute. Otherwise, administrators don't have access to the attribute.\nuser.profile.attribute.canAdminEdit=Can admin edit?\nuser.profile.attribute.canAdminEdit.tooltip=If enabled, administrators can view and edit the attribute. Otherwise, administrators don't have access to write to the attribute.\nuser.profile.attribute.validation=Validation\nuser.profile.attribute.validation.add.validator=Add Validator\nuser.profile.attribute.validation.add.validator.tooltip=Select a validator to enforce specific constraints to the attribute value.\nuser.profile.attribute.validation.no.validators=No validators.\nuser.profile.attribute.annotation=Annotation\nuser.profile.attribute.group=Attribute Group\nattribute-groups=Attribute Groups\nuser.profile.attributegroup.displayHeader=Display header\nuser.profile.attributegroup.displayHeader.tooltip=A user-friendly name for the group that should be used when rendering a group of attributes in user-facing forms. Supports keys for localized values as well. For example\\: ${profile.attribute.group.address}.\nuser.profile.attributegroup.displayDescription=Display description\nuser.profile.attributegroup.displayDescription.tooltip=A text that should be used as a tooltip when rendering user-facing forms.\nuser.profile.attributegroup=Attribute Group\nuser.profile.attributegroup.name=Name\nuser.profile.attributegroup.name.tooltip=A unique name for the group. This name will be used to reference the group when binding an attribute to a group.\nuser.profile.attributegroup.annotation=Annotation\n", "Array.prototype.remove = function(from, to) {\n    var rest = this.slice((to || from) + 1 || this.length);\n    this.length = from < 0 ? this.length + from : from;\n    return this.push.apply(this, rest);\n};\n\nmodule.controller('ClientTabCtrl', function(Dialog, $scope, Current, Notifications, $location) {\n    $scope.removeClient = function() {\n        Dialog.confirmDelete($scope.client.clientId, 'client', function() {\n            $scope.client.$remove({\n                realm : Current.realm.realm,\n                client : $scope.client.id\n            }, function() {\n                $location.url(\"/realms/\" + Current.realm.realm + \"/clients\");\n                Notifications.success(\"The client has been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('ClientRoleListCtrl', function($scope, $route, realm, client, ClientRoleList, RoleById, Notifications, Dialog) {\n    $scope.realm = realm;\n    $scope.roles = [];\n    $scope.client = client;\n\n    $scope.query = {\n        realm: realm.realm,\n        client: $scope.client.id,\n        search : null,\n        max : 20,\n        first : 0\n    }\n\n    $scope.$watch('query.search', function (newVal, oldVal) {\n        if($scope.query.search && $scope.query.search.length >= 3) {\n            $scope.firstPage();\n        }\n    }, true);\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        $scope.searchQuery();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.searchQuery();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.searchQuery();\n    }\n\n    $scope.searchQuery = function() {\n        $scope.searchLoaded = false;\n\n        $scope.roles = ClientRoleList.query($scope.query, function() {\n            $scope.searchLoaded = true;\n            $scope.lastSearch = $scope.query.search;\n        });\n    };\n\n    $scope.searchQuery();\n\n    $scope.removeRole = function(role) {\n        Dialog.confirmDelete(role.name, 'role', function() {\n            RoleById.remove({\n                realm: realm.realm,\n                role: role.id\n            }, function () {\n                $route.reload();\n                Notifications.success(\"The role has been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('ClientCredentialsCtrl', function($scope, $location, realm, client, clientAuthenticatorProviders, clientConfigProperties, Client, ClientRegistrationAccessToken, Notifications) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n    $scope.clientAuthenticatorProviders = clientAuthenticatorProviders;\n\n    var updateCurrentPartial = function(val) {\n        $scope.clientAuthenticatorConfigPartial;\n        switch(val) {\n            case 'client-secret':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-secret.html';\n                break;\n            case 'client-jwt':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-jwt.html';\n                break;\n            case 'client-secret-jwt':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-secret-jwt.html';\n                break;\n            case 'client-x509':\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-x509.html';\n                break;\n            default:\n                $scope.currentAuthenticatorConfigProperties = clientConfigProperties[val];\n                $scope.clientAuthenticatorConfigPartial = 'client-credentials-generic.html';\n                break;\n        }\n    };\n\n    updateCurrentPartial(client.clientAuthenticatorType);\n\n    $scope.$watch('client.clientAuthenticatorType', function() {\n        if (!angular.equals($scope.client.clientAuthenticatorType, client.clientAuthenticatorType)) {\n\n            Client.update({\n                realm : realm.realm,\n                client : client.id\n            }, $scope.client, function() {\n                $scope.changed = false;\n                client = angular.copy($scope.client);\n                updateCurrentPartial(client.clientAuthenticatorType)\n            });\n\n        }\n    }, true);\n\n    $scope.regenerateRegistrationAccessToken = function() {\n        var secret = ClientRegistrationAccessToken.update({ realm : $scope.realm.realm, client : $scope.client.id },\n            function(data) {\n                Notifications.success('The registration access token has been updated.');\n                $scope.client['registrationAccessToken'] = data.registrationAccessToken;\n            },\n            function() {\n                Notifications.error('Failed to update the registration access token');\n            }\n        );\n    };\n});\n\nmodule.controller('ClientSecretCtrl', function($scope, $location, Client, ClientSecret, Notifications, $route) {\n\n    var secret = ClientSecret.get({ realm : $scope.realm.realm, client : $scope.client.id },\n        function() {\n            $scope.secret = secret.value;\n        }\n    );\n\n    $scope.changePassword = function() {\n        var secret = ClientSecret.update({ realm : $scope.realm.realm, client : $scope.client.id },\n            function() {\n                $route.reload();\n                Notifications.success('The secret has been changed.');\n            },\n            function() {\n                Notifications.error(\"The secret was not changed due to a problem.\");\n                $scope.secret = \"error\";\n            }\n        );\n    };\n\n    $scope.removeRotatedSecret = function(){\n        ClientSecret.invalidate({realm: $scope.realm.realm, client: $scope.client.id },\n          function(){\n            $route.reload();\n            Notifications.success('The rotated secret has been invalidated.');\n          },\n          function(){\n            Notifications.error(\"The rotated secret was not invalidated due to a problem.\");\n          }\n        );\n    };\n\n    $scope.tokenEndpointAuthSigningAlg = $scope.client.attributes['token.endpoint.auth.signing.alg'];\n\n    if ($scope.client.attributes['client.secret.expiration.time']){\n        $scope.secret_expiration_time = $scope.client.attributes['client.secret.expiration.time'] * 1000;\n    }\n\n    if ($scope.client.attributes[\"client.secret.rotated\"]) {\n        $scope.secretRotated = $scope.client.attributes[\"client.secret.rotated\"];\n    }\n\n    if ($scope.client.attributes['client.secret.rotated.expiration.time']){\n        $scope.rotated_secret_expiration_time = $scope.client.attributes['client.secret.rotated.expiration.time'] * 1000;\n    }\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.save = function() {\n        $scope.client.attributes['token.endpoint.auth.signing.alg'] = $scope.tokenEndpointAuthSigningAlg;\n\n        Client.update({\n            realm : $scope.realm.realm,\n            client : $scope.client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            $scope.clientCopy = angular.copy($scope.client);\n            Notifications.success(\"Client authentication configuration has been saved to the client.\");\n        });\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + $scope.realm.realm + \"/clients/\" + $scope.client.id + \"/credentials\");\n        $route.reload();\n    };\n\n});\n\nmodule.controller('ClientX509Ctrl', function($scope, $location, Client, Notifications) {\n    console.log('ClientX509Ctrl invoked');\n\n    $scope.clientCopy = angular.copy($scope.client);\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, $scope.clientCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    function updateProperties() {\n       if ($scope.client.attributes[\"x509.allow.regex.pattern.comparison\"]) {\n           if ($scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] == \"true\") {\n               $scope.allowRegexPatternComparison = true;\n           } else {\n               $scope.allowRegexPatternComparison = false;\n           }\n       }\n    }\n\n    updateProperties();\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.save = function() {\n        if ($scope.allowRegexPatternComparison == true) {\n            $scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] = \"true\";\n        } else {\n            $scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] = \"false\";\n        }\n\n        if (!$scope.client.attributes[\"x509.subjectdn\"]) {\n            Notifications.error(\"The SubjectDN must not be empty.\");\n        } else {\n            Client.update({\n                realm : $scope.realm.realm,\n                client : $scope.client.id\n            }, $scope.client, function() {\n                $scope.changed = false;\n                $scope.clientCopy = angular.copy($scope.client);\n                Notifications.success(\"Client authentication configuration has been saved to the client.\");\n            }, function() {\n                Notifications.error(\"The SubjectDN was not changed due to a problem.\");\n                $scope.subjectdn = \"error\";\n            });\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.reset = function() {\n        $scope.client.attributes[\"x509.subjectdn\"] = $scope.clientCopy.attributes[\"x509.subjectdn\"];\n        $scope.client.attributes[\"x509.allow.regex.pattern.comparison\"] = $scope.clientCopy.attributes[\"x509.allow.regex.pattern.comparison\"];\n        updateProperties();\n        $location.url(\"/realms/\" + $scope.realm.realm + \"/clients/\" + $scope.client.id + \"/credentials\");\n    };\n});\n\nmodule.controller('ClientSignedJWTCtrl', function($scope, Client, Notifications) {\n    console.log('ClientSignedJWTCtrl invoked');\n\n    $scope.tokenEndpointAuthSigningAlg = $scope.client.attributes['token.endpoint.auth.signing.alg'];\n\n    $scope.$watch('tokenEndpointAuthSigningAlg', function() {\n        if (!angular.equals($scope.client.attributes['token.endpoint.auth.signing.alg'], $scope.tokenEndpointAuthSigningAlg)) {\n            $scope.client.attributes['token.endpoint.auth.signing.alg'] = $scope.tokenEndpointAuthSigningAlg;\n\n            Client.update({\n                realm : $scope.realm.realm,\n                client : $scope.client.id\n            }, $scope.client, function() {\n                Notifications.success(\"Signature algorithm has been saved to the client.\");\n            });\n        }\n    }, true);\n\n});\n\nmodule.controller('ClientGenericCredentialsCtrl', function($scope, $location, Client, Notifications) {\n\n    console.log('ClientGenericCredentialsCtrl invoked');\n\n    $scope.clientCopy = angular.copy($scope.client);\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, $scope.clientCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    $scope.save = function() {\n\n        Client.update({\n            realm : $scope.realm.realm,\n            client : $scope.client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            $scope.clientCopy = angular.copy($scope.client);\n            Notifications.success(\"Client authentication configuration has been saved to the client.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.client = angular.copy($scope.clientCopy);\n        $scope.changed = false;\n    };\n});\n\nmodule.controller('ClientIdentityProviderCtrl', function($scope, $location, $route, realm, client, Client, $location, Notifications) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n    var length = 0;\n\n    if ($scope.client.identityProviders) {\n        length = $scope.client.identityProviders.length;\n\n        for (i = 0; i < $scope.client.identityProviders.length; i++) {\n            var clientProvider = $scope.client.identityProviders[i];\n            if (clientProvider.retrieveToken) {\n                clientProvider.retrieveToken = clientProvider.retrieveToken.toString();\n            }\n        }\n\n    } else {\n        $scope.client.identityProviders = [];\n    }\n\n    $scope.identityProviders = [];\n    var providersMissingInClient = [];\n\n    for (j = 0; j < realm.identityProviders.length; j++) {\n        var identityProvider = realm.identityProviders[j];\n        var clientProvider = null;\n\n        for (i = 0; i < $scope.client.identityProviders.length; i++) {\n            clientProvider = $scope.client.identityProviders[i];\n\n            if (clientProvider) {\n\n                if (clientProvider.id == identityProvider.id) {\n                    $scope.identityProviders[i] = {};\n                    $scope.identityProviders[i].identityProvider = identityProvider;\n                    $scope.identityProviders[i].retrieveToken = clientProvider.retrieveToken;\n                    break;\n                }\n\n                clientProvider = null;\n            }\n        }\n\n        if (clientProvider == null) {\n            providersMissingInClient.push(identityProvider);\n        }\n    }\n\n    for (j = 0; j < providersMissingInClient.length; j++) {\n        var identityProvider = providersMissingInClient[j];\n\n        var currentProvider = {};\n        currentProvider.identityProvider = identityProvider;\n        currentProvider.retrieveToken = \"false\";\n        $scope.identityProviders.push(currentProvider);\n\n        var currentClientProvider = {};\n        currentClientProvider.id = identityProvider.id;\n        currentClientProvider.retrieveToken = \"false\";\n        $scope.client.identityProviders.push(currentClientProvider);\n    }\n\n    var oldCopy = angular.copy($scope.client);\n\n    $scope.save = function() {\n\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            $route.reload();\n            Notifications.success(\"Your changes have been saved to the client.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.client = angular.copy(oldCopy);\n        $scope.changed = false;\n    };\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, oldCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n});\n\nmodule.controller('ClientSamlKeyCtrl', function($scope, $location, $http, $upload, realm, client,\n                                                         ClientCertificate, ClientCertificateGenerate,\n                                                         ClientCertificateDownload, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n\n    var signingKeyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: 'saml.signing' },\n        function() {\n            $scope.signingKeyInfo = signingKeyInfo;\n        }\n    );\n\n    $scope.generateSigningKey = function() {\n        var keyInfo = ClientCertificateGenerate.generate({ realm : realm.realm, client : client.id, attribute: 'saml.signing' },\n            function() {\n                Notifications.success('Signing key has been regenerated.');\n                $scope.signingKeyInfo = keyInfo;\n            },\n            function() {\n                Notifications.error(\"Signing key was not regenerated.\");\n            }\n        );\n    };\n\n    $scope.importSigningKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Signing/import/saml.signing\");\n    };\n\n    $scope.exportSigningKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Signing/export/saml.signing\");\n    };\n\n    var encryptionKeyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: 'saml.encryption' },\n        function() {\n            $scope.encryptionKeyInfo = encryptionKeyInfo;\n        }\n    );\n\n    $scope.generateEncryptionKey = function() {\n        var keyInfo = ClientCertificateGenerate.generate({ realm : realm.realm, client : client.id, attribute: 'saml.encryption' },\n            function() {\n                Notifications.success('Encryption key has been regenerated.');\n                $scope.encryptionKeyInfo = keyInfo;\n            },\n            function() {\n                Notifications.error(\"Encryption key was not regenerated.\");\n            }\n        );\n    };\n\n    $scope.importEncryptionKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Encryption/import/saml.encryption\");\n    };\n\n    $scope.exportEncryptionKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/Encryption/export/saml.encryption\");\n    };\n\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n});\n\nmodule.controller('ClientCertificateImportCtrl', function($scope, $location, $http, $upload, realm, client, callingContext, $routeParams,\n                                                         ClientCertificate, ClientCertificateGenerate,\n                                                         ClientCertificateDownload, Notifications) {\n\n    console.log(\"callingContext: \" + callingContext);\n\n    var keyType = $routeParams.keyType;\n    var attribute = $routeParams.attribute;\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.keyType = keyType;\n\n    if (callingContext == 'saml') {\n        var uploadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/upload';\n        var redirectLocation = \"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/saml/keys\";\n    } else if (callingContext == 'oidc') {\n        var uploadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/upload-certificate';\n        var redirectLocation = \"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/keys\";\n    }\n\n    $scope.files = [];\n\n    $scope.onFileSelect = function($files) {\n        $scope.files = $files;\n    };\n\n    $scope.cancel = function() {\n        $location.url(redirectLocation);\n    }\n\n    $scope.keyFormats = [\n        \"JKS\",\n        \"PKCS12\",\n        \"Certificate PEM\"\n    ];\n\n    if (callingContext == 'oidc') {\n        $scope.keyFormats.push('Public Key PEM');\n        $scope.keyFormats.push('JSON Web Key Set');\n    }\n\n    $scope.hideKeystoreSettings = function() {\n        return $scope.uploadKeyFormat == 'Certificate PEM' || $scope.uploadKeyFormat == 'Public Key PEM' || $scope.uploadKeyFormat == 'JSON Web Key Set';\n    }\n\n    $scope.uploadKeyFormat = $scope.keyFormats[0];\n\n    $scope.uploadFile = function() {\n        //$files: an array of files selected, each file has name, size, and type.\n        for (var i = 0; i < $scope.files.length; i++) {\n            var $file = $scope.files[i];\n            $scope.upload = $upload.upload({\n                url: uploadUrl,\n                // method: POST or PUT,\n                // headers: {'headerKey': 'headerValue'}, withCredential: true,\n                data: {keystoreFormat: $scope.uploadKeyFormat,\n                    keyAlias: $scope.uploadKeyAlias,\n                    keyPassword: $scope.uploadKeyPassword,\n                    storePassword: $scope.uploadStorePassword\n                },\n                file: $file\n                /* set file formData name for 'Content-Desposition' header. Default: 'file' */\n                //fileFormDataName: myFile,\n                /* customize how data is added to formData. See #40#issuecomment-28612000 for example */\n                //formDataAppender: function(formData, key, val){}\n            }).then(function(data, status, headers) {\n                Notifications.success(\"Keystore uploaded successfully.\");\n                $location.url(redirectLocation);\n            })\n            //.then(success, error, progress);\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n});\n\nmodule.controller('ClientCertificateExportCtrl', function($scope, $location, $http, $upload, realm, client, callingContext, $routeParams,\n                                                         ClientCertificate, ClientCertificateGenerate,\n                                                         ClientCertificateDownload, Notifications) {\n    var keyType = $routeParams.keyType;\n    var attribute = $routeParams.attribute;\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.keyType = keyType;\n\n    if (callingContext == 'saml') {\n        var downloadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/download';\n        var realmCertificate = true;\n    } else if (callingContext == 'oidc') {\n        var downloadUrl = authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/certificates/' + attribute + '/generate-and-download'\n        var realmCertificate = false;\n    }\n\n    var jks = {\n        keyAlias: client.clientId,\n        realmAlias: realm.realm,\n        realmCertificate: realmCertificate\n    };\n\n    $scope.keyFormats = [\n        \"JKS\",\n        \"PKCS12\"\n    ];\n\n    var keyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: attribute },\n        function() {\n            $scope.keyInfo = keyInfo;\n        }\n    );\n    $scope.jks = jks;\n    $scope.jks.format = $scope.keyFormats[0];\n\n    $scope.download = function() {\n        $http({\n            url: downloadUrl,\n            method: 'POST',\n            responseType: 'arraybuffer',\n            data: $scope.jks,\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/octet-stream'\n            }\n        }).then(function(response){\n            var blob = new Blob([response.data], {\n                type: 'application/octet-stream'\n            });\n            var ext = \".jks\";\n            if ($scope.jks.format == 'PKCS12') ext = \".p12\";\n\n            if (callingContext == 'oidc') {\n                $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/keys\");\n                Notifications.success(\"New keypair and certificate generated successfully. Download keystore file\")\n            }\n\n            saveAs(blob, 'keystore' + ext);\n        }).catch(function(response) {\n            var errorMsg = 'Error downloading';\n            try {\n                var error = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(response.data)));\n                errorMsg = error['error_description'] ? error['error_description'] : errorMsg;\n            } catch (err) {\n            }\n            Notifications.error(errorMsg);\n        });\n    }\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/keys\");\n    }\n});\n\nmodule.controller('ClientOidcKeyCtrl', function($scope, $location, realm, client, Client, ClientCertificate, Notifications, $route) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n\n    var signingKeyInfo = ClientCertificate.get({ realm : realm.realm, client : client.id, attribute: 'jwt.credential' },\n        function() {\n            $scope.signingKeyInfo = signingKeyInfo;\n        }\n    );\n\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, client)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    if ($scope.client.attributes[\"use.jwks.url\"]) {\n        if ($scope.client.attributes[\"use.jwks.url\"] == \"true\") {\n            $scope.useJwksUrl = true;\n        } else {\n            $scope.useJwksUrl = false;\n        }\n    }\n\n    if ($scope.client.attributes[\"use.jwks.string\"]) {\n        if ($scope.client.attributes[\"use.jwks.string\"] == \"true\") {\n            $scope.useJwksString = true;\n        } else {\n            $scope.useJwksString = false;\n        }\n    }\n\n    $scope.jwksUrlSwitchChange = function() {\n        $scope.changed = true;\n        if ($scope.useJwksUrl == false) {\n            $scope.useJwksString = false;\n        }\n    }\n\n    $scope.jwksStringSwitchChange = function() {\n        $scope.changed = true;\n        if ($scope.useJwksString == false) {\n            $scope.useJwksUrl = false;\n        }\n    }\n\n    $scope.save = function() {\n\n        if ($scope.useJwksUrl == true) {\n            $scope.client.attributes[\"use.jwks.url\"] = \"true\";\n        } else {\n            $scope.client.attributes[\"use.jwks.url\"] = \"false\";\n        }\n\n        if ($scope.useJwksString == true) {\n            $scope.client.attributes[\"use.jwks.string\"] = \"true\";\n        } else {\n            $scope.client.attributes[\"use.jwks.string\"] = \"false\";\n        }\n\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            client = angular.copy($scope.client);\n            Notifications.success(\"OIDC key has been saved to the client.\");\n        });\n    };\n\n    $scope.importCertificate = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/Signing/import/jwt.credential\");\n    };\n\n    $scope.generateSigningKey = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/oidc/Signing/export/jwt.credential\");\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n});\n\nmodule.controller('ClientSessionsCtrl', function($scope, realm, sessionCount, client,\n                                                      ClientUserSessions) {\n    $scope.realm = realm;\n    $scope.count = sessionCount.count;\n    $scope.sessions = [];\n    $scope.client = client;\n\n    $scope.page = 0;\n\n    $scope.query = {\n        realm : realm.realm,\n        client: $scope.client.id,\n        max : 5,\n        first : 0\n    }\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.loadUsers();\n    }\n\n    $scope.toDate = function(val) {\n        return new Date(val);\n    };\n\n    $scope.loadUsers = function() {\n        ClientUserSessions.query($scope.query, function(updated) {\n            $scope.sessions = updated;\n        })\n    };\n});\n\nmodule.controller('ClientOfflineSessionsCtrl', function($scope, realm, offlineSessionCount, client,\n                                                      ClientOfflineSessions) {\n    $scope.realm = realm;\n    $scope.count = offlineSessionCount.count;\n    $scope.sessions = [];\n    $scope.client = client;\n\n    $scope.page = 0;\n\n    $scope.query = {\n        realm : realm.realm,\n        client: $scope.client.id,\n        max : 5,\n        first : 0\n    }\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.loadUsers();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.loadUsers();\n    }\n\n    $scope.toDate = function(val) {\n        return new Date(val);\n    };\n\n    $scope.loadUsers = function() {\n        ClientOfflineSessions.query($scope.query, function(updated) {\n            $scope.sessions = updated;\n        })\n    };\n});\n\nmodule.controller('ClientRoleDetailCtrl', function($scope, $route, realm, client, role, roles, Client,\n                                                        Role, ClientRole, RoleById, RoleRealmComposites, RoleClientComposites,\n                                                        $http, $location, Dialog, Notifications, ComponentUtils) {\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.role = angular.copy(role);\n    $scope.create = !role.name;\n\n    $scope.changed = $scope.create;\n\n    $scope.save = function() {\n        convertAttributeValuesToLists();\n        if ($scope.create) {\n            ClientRole.save({\n                realm: realm.realm,\n                client : client.id\n            }, $scope.role, function (data, headers) {\n                $scope.changed = false;\n                convertAttributeValuesToString($scope.role);\n                role = angular.copy($scope.role);\n\n                ClientRole.get({ realm: realm.realm, client : client.id, role: role.name }, function(role) {\n                    var id = role.id;\n                    $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/roles/\" + id);\n                    Notifications.success(\"The role has been created.\");\n                });\n            });\n        } else {\n            $scope.update();\n        }\n    };\n\n    $scope.remove = function() {\n        Dialog.confirmDelete($scope.role.name, 'role', function() {\n            $scope.role.$remove({\n                realm : realm.realm,\n                client : client.id,\n                role : $scope.role.id\n            }, function() {\n                $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/roles\");\n                Notifications.success(\"The role has been deleted.\");\n            });\n        });\n    };\n\n    $scope.cancel = function () {\n        $location.url(\"/realms/\" + realm.realm + \"/clients/\" + client.id + \"/roles\");\n    };\n\n    $scope.addAttribute = function() {\n        $scope.role.attributes[$scope.newAttribute.key] = $scope.newAttribute.value;\n        delete $scope.newAttribute;\n    }\n\n    $scope.removeAttribute = function(key) {\n        delete $scope.role.attributes[key];\n    }\n\n    function convertAttributeValuesToLists() {\n        var attrs = $scope.role.attributes;\n        for (var attribute in attrs) {\n            if (typeof attrs[attribute] === \"string\") {\n                var attrVals = attrs[attribute].split(\"##\");\n                attrs[attribute] = attrVals;\n            }\n        }\n    }\n\n    function convertAttributeValuesToString(role) {\n        var attrs = role.attributes;\n        for (var attribute in attrs) {\n            if (typeof attrs[attribute] === \"object\") {\n                var attrVals = attrs[attribute].join(\"##\");\n                attrs[attribute] = attrVals;\n            }\n        }\n    }\n\n    roleControl($scope, $route, realm, role, roles, Client,\n        ClientRole, RoleById, RoleRealmComposites, RoleClientComposites,\n        $http, $location, Notifications, Dialog, ComponentUtils);\n\n});\n\nmodule.controller('ClientRoleMembersCtrl', function($scope, realm, client, role, ClientRoleMembership, Dialog, Notifications, $location) {\n    $scope.realm = realm;\n    $scope.page = 0;\n    $scope.role = role;\n    $scope.client = client;\n\n    $scope.query = {\n        realm: realm.realm,\n        role: role.name,\n        client: client.id,\n        max : 5,\n        first : 0\n    }\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        $scope.searchQuery();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.searchQuery();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.searchQuery();\n    }\n\n    $scope.searchQuery = function() {\n        $scope.searchLoaded = false;\n\n        $scope.users = ClientRoleMembership.query($scope.query, function() {\n            console.log('search loaded');\n            $scope.searchLoaded = true;\n            $scope.lastSearch = $scope.query.search;\n        });\n    };\n\n    $scope.searchQuery();\n});\n\nmodule.controller('ClientImportCtrl', function($scope, $location, $upload, realm, serverInfo, Notifications) {\n\n    $scope.realm = realm;\n\n    $scope.files = [];\n\n    $scope.onFileSelect = function($files) {\n        $scope.files = $files;\n    };\n\n    $scope.clearFileSelect = function() {\n        $scope.files = null;\n    }\n\n    $scope.uploadFile = function() {\n        //$files: an array of files selected, each file has name, size, and type.\n        for (var i = 0; i < $scope.files.length; i++) {\n            var $file = $scope.files[i];\n            $scope.upload = $upload.upload({\n                url: authUrl + '/admin/realms/' + realm.realm + '/client-importers/' + $scope.configFormat.id + '/upload',\n                // method: POST or PUT,\n                // headers: {'headerKey': 'headerValue'}, withCredential: true,\n                data: {myObj: \"\"},\n                file: $file\n                /* set file formData name for 'Content-Desposition' header. Default: 'file' */\n                //fileFormDataName: myFile,\n                /* customize how data is added to formData. See #40#issuecomment-28612000 for example */\n                //formDataAppender: function(formData, key, val){}\n            }).success(function(data, status, headers) {\n                Notifications.success(\"Uploaded successfully.\");\n                $location.url(\"/realms/\" + realm.realm + \"/clients\");\n            })\n                .error(function() {\n                    Notifications.error(\"The file can not be uploaded. Please verify the file.\");\n\n                });\n            //.then(success, error, progress);\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n});\n\n\nmodule.controller('ClientListCtrl', function($scope, realm, Client, ClientListSearchState, $route, Dialog, Notifications) {\n    $scope.init = function() {\n        $scope.realm = realm;\n        $scope.searchLoaded = true;\n\n        ClientListSearchState.query.realm = realm.realm;\n        $scope.query = ClientListSearchState.query;\n\n        if (!ClientListSearchState.isFirstSearch) {\n            $scope.searchQuery();\n        } else {\n            $scope.query.clientId = null;\n            $scope.firstPage();\n        }\n    };\n\n    $scope.searchQuery = function() {\n        console.log(\"query.search: \", $scope.query);\n        $scope.searchLoaded = false;\n\n        $scope.clients = Client.query($scope.query, function() {\n            $scope.searchLoaded = true;\n            $scope.lastSearch = $scope.query.search;\n            ClientListSearchState.isFirstSearch = false;\n        });\n    };\n\n    $scope.firstPage = function() {\n        $scope.query.first = 0;\n        $scope.searchQuery();\n    }\n\n    $scope.previousPage = function() {\n        $scope.query.first -= parseInt($scope.query.max);\n        if ($scope.query.first < 0) {\n            $scope.query.first = 0;\n        }\n        $scope.searchQuery();\n    }\n\n    $scope.nextPage = function() {\n        $scope.query.first += parseInt($scope.query.max);\n        $scope.searchQuery();\n    }\n\n    $scope.removeClient = function(client) {\n        Dialog.confirmDelete(client.clientId, 'client', function() {\n            Client.remove({\n                realm : realm.realm,\n                client : client.id\n            }, function() {\n                $route.reload();\n                Notifications.success(\"The client has been deleted.\");\n            });\n        });\n    };\n\n    $scope.exportClient = function(client) {\n        var clientCopy = angular.copy(client);\n        delete clientCopy.id;\n\n        if (clientCopy.protocolMappers) {\n            for (var i = 0; i < clientCopy.protocolMappers.length; i++) {\n                delete clientCopy.protocolMappers[i].id;\n            }\n        }\n\n        saveAs(new Blob([angular.toJson(clientCopy, 4)], { type: 'application/json' }), clientCopy.clientId + '.json');\n    }\n});\n\nmodule.controller('ClientInstallationCtrl', function($scope, realm, client, serverInfo, ClientInstallation,$http, $routeParams) {\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.installation = null;\n    $scope.download = null;\n    $scope.configFormat = null;\n    $scope.filename = null;\n\n    var protocol = client.protocol;\n    if (!protocol) protocol = 'openid-connect';\n    $scope.configFormats = serverInfo.clientInstallations[protocol];\n    console.log('configFormats.length: ' + $scope.configFormats.length);\n\n    $scope.changeFormat = function() {\n        var url = ClientInstallation.url({ realm: $routeParams.realm, client: $routeParams.client, provider: $scope.configFormat.id });\n        if ($scope.configFormat.mediaType == 'application/zip') {\n            $http({\n                url: url,\n                method: 'GET',\n                responseType: 'arraybuffer',\n                cache: false\n            }).then(function(response) {\n                var installation = response.data;\n                $scope.installation = installation;\n                }\n            );\n        } else {\n            $http.get(url).then(function (response) {\n                var installation = response.data;\n                if ($scope.configFormat.mediaType == 'application/json') {\n                    installation = angular.fromJson(response.data);\n                    installation = angular.toJson(installation, true);\n                }\n                $scope.installation = installation;\n            });\n        }\n\n    };\n    $scope.download = function() {\n        saveAs(new Blob([$scope.installation], { type: $scope.configFormat.mediaType }), $scope.configFormat.filename);\n    }\n});\n\n\nmodule.controller('ClientDetailCtrl', function($scope, realm, client, flows, $route, serverInfo, Client, ClientDescriptionConverter, Components, ClientStorageOperations, $location, $modal, Dialog, Notifications, TimeUnit2) {\n    $scope.serverInfo = serverInfo;\n    $scope.flows = [];\n    $scope.clientFlows = [];\n    var emptyFlow = {\n        id: \"\",\n        alias: \"\"\n    }\n    for (var i=0 ; i<flows.length ; i++) {\n        if (flows[i].providerId == 'client-flow') {\n            $scope.clientFlows.push(flows[i]);\n        } else {\n            $scope.flows.push(flows[i]);\n        }\n    }\n    $scope.flows.push(emptyFlow)\n    $scope.clientFlows.push(emptyFlow)\n    var deletedSomeDefaultAcrValue = false;\n\n\n    $scope.accessTypes = [\n        \"confidential\",\n        \"public\",\n        \"bearer-only\"\n    ];\n\n    $scope.protocols = serverInfo.listProviderIds('login-protocol');\n\n    $scope.signatureAlgorithms = [\n        \"RSA_SHA1\",\n        \"RSA_SHA256\",\n        \"RSA_SHA256_MGF1\",\n        \"RSA_SHA512\",\n        \"RSA_SHA512_MGF1\",\n        \"DSA_SHA1\"\n    ];\n    $scope.nameIdFormats = [\n        \"username\",\n        \"email\",\n        \"transient\",\n        \"persistent\"\n    ];\n    $scope.xmlKeyNameTranformers = [\n        \"NONE\",\n        \"KEY_ID\",\n        \"CERT_SUBJECT\"\n    ];\n\n    $scope.canonicalization = [\n        {name: \"EXCLUSIVE\", value:  \"http://www.w3.org/2001/10/xml-exc-c14n#\"  },\n        {name: \"EXCLUSIVE_WITH_COMMENTS\", value: \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\"},\n        {name: \"INCLUSIVE\", value: \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" },\n        {name: \"INCLUSIVE_WITH_COMMENTS\", value: \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"}\n    ];\n\n    $scope.requestObjectRequiredOptions = [\n        \"not required\",\n        \"request or request_uri\",\n        \"request only\",\n        \"request_uri only\"\n    ];\n\n    $scope.changePkceCodeChallengeMethodOptions = [\n        \"S256\",\n        \"plain\",\n        \"\"\n    ];\n\n    $scope.realm = realm;\n    $scope.samlAuthnStatement = false;\n    $scope.samlOneTimeUseCondition = false;\n    $scope.samlMultiValuedRoles = false;\n    $scope.samlArtifactBinding = false;\n    $scope.samlServerSignature = false;\n    $scope.samlServerSignatureEnableKeyInfoExtension = false;\n    $scope.samlAssertionSignature = false;\n    $scope.samlClientSignature = false;\n    $scope.samlEncrypt = false;\n    $scope.samlForcePostBinding = false;\n    $scope.samlForceNameIdFormat = false;\n    $scope.samlAllowECPFlow = false;\n    $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[1];\n    $scope.disableAuthorizationTab = !client.authorizationServicesEnabled;\n    $scope.disableServiceAccountRolesTab = !client.serviceAccountsEnabled;\n    $scope.disableCredentialsTab = client.publicClient;\n    $scope.oauth2DeviceAuthorizationGrantEnabled = false;\n    $scope.oidcCibaGrantEnabled = false;\n    // KEYCLOAK-6771 Certificate Bound Token\n    // https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\n    $scope.tlsClientCertificateBoundAccessTokens = false;\n    $scope.useRefreshTokens = true;\n    $scope.useIdTokenAsDetachedSignature = false;\n\n    $scope.accessTokenLifespan = TimeUnit2.asUnit(client.attributes['access.token.lifespan']);\n    $scope.samlAssertionLifespan = TimeUnit2.asUnit(client.attributes['saml.assertion.lifespan']);\n    $scope.clientSessionIdleTimeout = TimeUnit2.asUnit(client.attributes['client.session.idle.timeout']);\n    $scope.clientSessionMaxLifespan = TimeUnit2.asUnit(client.attributes['client.session.max.lifespan']);\n    $scope.clientOfflineSessionIdleTimeout = TimeUnit2.asUnit(client.attributes['client.offline.session.idle.timeout']);\n    $scope.clientOfflineSessionMaxLifespan = TimeUnit2.asUnit(client.attributes['client.offline.session.max.lifespan']);\n    $scope.oauth2DeviceCodeLifespan = TimeUnit2.asUnit(client.attributes['oauth2.device.code.lifespan']);\n    $scope.oauth2DevicePollingInterval = parseInt(client.attributes['oauth2.device.polling.interval']);\n\n    // PAR request.\n    $scope.requirePushedAuthorizationRequests = false;\n\n    if(client.origin) {\n        if ($scope.access.viewRealm) {\n            Components.get({realm: realm.realm, componentId: client.origin}, function (link) {\n                $scope.originName = link.name;\n                //$scope.originLink = \"#/realms/\" + realm.realm + \"/user-storage/providers/\" + link.providerId + \"/\" + link.id;\n            })\n        }\n        else {\n            // KEYCLOAK-4328\n            ClientStorageOperations.simpleName.get({realm: realm.realm, componentId: client.origin}, function (link) {\n                $scope.originName = link.name;\n                //$scope.originLink = $location.absUrl();\n            })\n        }\n    } else {\n        console.log(\"origin is null\");\n    }\n\n\n    function updateProperties() {\n        if (!$scope.client.attributes) {\n            $scope.client.attributes = {};\n        }\n        $scope.accessType = $scope.accessTypes[0];\n        if ($scope.client.bearerOnly) {\n            $scope.accessType = $scope.accessTypes[2];\n        } else if ($scope.client.publicClient) {\n            $scope.accessType = $scope.accessTypes[1];\n        }\n        if ($scope.client.protocol) {\n            $scope.protocol = $scope.protocols[$scope.protocols.indexOf($scope.client.protocol)];\n        } else {\n            $scope.protocol = $scope.protocols[0];\n        }\n        if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[0];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA256') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[1];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA256_MGF1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[2];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA512') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[3];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'RSA_SHA512_MGF1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[4];\n        } else if ($scope.client.attributes['saml.signature.algorithm'] == 'DSA_SHA1') {\n            $scope.signatureAlgorithm = $scope.signatureAlgorithms[5];\n        }\n        if ($scope.client.attributes['saml_name_id_format'] == 'username') {\n            $scope.nameIdFormat = $scope.nameIdFormats[0];\n        } else if ($scope.client.attributes['saml_name_id_format'] == 'email') {\n            $scope.nameIdFormat = $scope.nameIdFormats[1];\n        } else if ($scope.client.attributes['saml_name_id_format'] == 'transient') {\n            $scope.nameIdFormat = $scope.nameIdFormats[2];\n        } else if ($scope.client.attributes['saml_name_id_format'] == 'persistent') {\n            $scope.nameIdFormat = $scope.nameIdFormats[3];\n        }\n\n\n        if ($scope.client.attributes[\"saml.artifact.binding\"]) {\n            if ($scope.client.attributes[\"saml.artifact.binding\"] == \"true\") {\n                $scope.samlArtifactBinding = true;\n            } else {\n                $scope.samlArtifactBinding = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"saml.server.signature\"]) {\n            if ($scope.client.attributes[\"saml.server.signature\"] == \"true\") {\n                $scope.samlServerSignature = true;\n            } else {\n                $scope.samlServerSignature = false;\n\n            }\n        }\n        if ($scope.client.attributes[\"saml.server.signature.keyinfo.ext\"]) {\n            if ($scope.client.attributes[\"saml.server.signature.keyinfo.ext\"] == \"true\") {\n                $scope.samlServerSignatureEnableKeyInfoExtension = true;\n            } else {\n                $scope.samlServerSignatureEnableKeyInfoExtension = false;\n            }\n        }\n        if ($scope.client.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] === 'NONE') {\n            $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[0];\n        } else if ($scope.client.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] === 'KEY_ID') {\n            $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[1];\n        } else if ($scope.client.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] === 'CERT_SUBJECT') {\n            $scope.samlXmlKeyNameTranformer = $scope.xmlKeyNameTranformers[2];\n        }\n        if ($scope.client.attributes[\"saml.assertion.signature\"]) {\n            if ($scope.client.attributes[\"saml.assertion.signature\"] == \"true\") {\n                $scope.samlAssertionSignature = true;\n            } else {\n                $scope.samlAssertionSignature = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.client.signature\"]) {\n            if ($scope.client.attributes[\"saml.client.signature\"] == \"true\") {\n                $scope.samlClientSignature = true;\n            } else {\n                $scope.samlClientSignature = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.encrypt\"]) {\n            if ($scope.client.attributes[\"saml.encrypt\"] == \"true\") {\n                $scope.samlEncrypt = true;\n            } else {\n                $scope.samlEncrypt = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.authnstatement\"]) {\n            if ($scope.client.attributes[\"saml.authnstatement\"] == \"true\") {\n                $scope.samlAuthnStatement = true;\n            } else {\n                $scope.samlAuthnStatement = false;\n            }\n        }\n         if ($scope.client.attributes[\"saml.onetimeuse.condition\"]) {\n                    if ($scope.client.attributes[\"saml.onetimeuse.condition\"] == \"true\") {\n                        $scope.samlOneTimeUseCondition = true;\n                    } else {\n                        $scope.samlOneTimeUseCondition = false;\n                    }\n                }\n        if ($scope.client.attributes[\"saml_force_name_id_format\"]) {\n            if ($scope.client.attributes[\"saml_force_name_id_format\"] == \"true\") {\n                $scope.samlForceNameIdFormat = true;\n            } else {\n                $scope.samlForceNameIdFormat = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.allow.ecp.flow\"]) {\n            if ($scope.client.attributes[\"saml.allow.ecp.flow\"] == \"true\") {\n                $scope.samlAllowECPFlow = true;\n            } else {\n                $scope.samlAllowECPFlow = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.multivalued.roles\"]) {\n            if ($scope.client.attributes[\"saml.multivalued.roles\"] == \"true\") {\n                $scope.samlMultiValuedRoles = true;\n            } else {\n                $scope.samlMultiValuedRoles = false;\n            }\n        }\n        if ($scope.client.attributes[\"saml.force.post.binding\"]) {\n            if ($scope.client.attributes[\"saml.force.post.binding\"] == \"true\") {\n                $scope.samlForcePostBinding = true;\n            } else {\n                $scope.samlForcePostBinding = false;\n            }\n        }\n\n        $scope.accessTokenSignedResponseAlg = $scope.client.attributes['access.token.signed.response.alg'];\n        $scope.idTokenSignedResponseAlg = $scope.client.attributes['id.token.signed.response.alg'];\n        $scope.idTokenEncryptedResponseAlg = $scope.client.attributes['id.token.encrypted.response.alg'];\n        $scope.idTokenEncryptedResponseEnc = $scope.client.attributes['id.token.encrypted.response.enc'];\n        $scope.authorizationSignedResponseAlg = $scope.client.attributes['authorization.signed.response.alg'];\n        $scope.authorizationEncryptedResponseAlg = $scope.client.attributes['authorization.encrypted.response.alg'];\n        $scope.authorizationEncryptedResponseEnc = $scope.client.attributes['authorization.encrypted.response.enc'];\n\n        var attrVal1 = $scope.client.attributes['user.info.response.signature.alg'];\n        $scope.userInfoSignedResponseAlg = attrVal1==null ? 'unsigned' : attrVal1;\n\n        var attrVal2 = $scope.client.attributes['request.object.signature.alg'];\n        $scope.requestObjectSignatureAlg = attrVal2==null ? 'any' : attrVal2;\n\n        var attrVal3 = $scope.client.attributes['request.object.required'];\n        $scope.requestObjectRequired = attrVal3==null ? 'not required' : attrVal3;\n\n        var attrVal4 = $scope.client.attributes['pkce.code.challenge.method'];\n        $scope.pkceCodeChallengeMethod = attrVal4==null ? 'none' : attrVal4;\n\n        var attrVal5 = $scope.client.attributes['ciba.backchannel.auth.request.signing.alg'];\n        $scope.cibaBackchannelAuthRequestSigningAlg = attrVal5==null ? 'none' : attrVal5;\n\n        var attrVal6 = $scope.client.attributes['request.object.encryption.alg'];\n        $scope.requestObjectEncryptionAlg = attrVal6==null ? 'any' : attrVal6;\n\n        var attrVal7 = $scope.client.attributes['request.object.encryption.enc'];\n        $scope.requestObjectEncryptionEnc = attrVal7==null ? 'any' : attrVal7;\n\n        var attrVal8 = $scope.client.attributes['ciba.backchannel.auth.request.signing.alg'];\n        $scope.cibaBackchannelAuthRequestSigningAlg = attrVal8==null ? 'any' : attrVal8;\n\n        if ($scope.client.attributes[\"exclude.session.state.from.auth.response\"]) {\n            if ($scope.client.attributes[\"exclude.session.state.from.auth.response\"] == \"true\") {\n                $scope.excludeSessionStateFromAuthResponse = true;\n            } else {\n                $scope.excludeSessionStateFromAuthResponse = false;\n            }\n        }\n\n       if ($scope.client.attributes[\"oauth2.device.authorization.grant.enabled\"]) {\n           if ($scope.client.attributes[\"oauth2.device.authorization.grant.enabled\"] == \"true\") {\n               $scope.oauth2DeviceAuthorizationGrantEnabled = true;\n           } else {\n               $scope.oauth2DeviceAuthorizationGrantEnabled = false;\n           }\n       }\n\n       if ($scope.client.attributes[\"oidc.ciba.grant.enabled\"]) {\n           if ($scope.client.attributes[\"oidc.ciba.grant.enabled\"] == \"true\") {\n               $scope.oidcCibaGrantEnabled = true;\n           } else {\n               $scope.oidcCibaGrantEnabled = false;\n           }\n       }\n\n       $scope.cibaBackchannelTokenDeliveryMode = $scope.client.attributes['ciba.backchannel.token.delivery.mode'];\n\n       if ($scope.client.attributes[\"use.refresh.tokens\"]) {\n           if ($scope.client.attributes[\"use.refresh.tokens\"] == \"true\") {\n               $scope.useRefreshTokens = true;\n           } else {\n               $scope.useRefreshTokens = false;\n           }\n       }\n\n       if ($scope.client.attributes[\"id.token.as.detached.signature\"]) {\n           if ($scope.client.attributes[\"id.token.as.detached.signature\"] == \"true\") {\n               $scope.useIdTokenAsDetachedSignature = true;\n           } else {\n               $scope.useIdTokenAsDetachedSignature = false;\n           }\n       }\n\n        // KEYCLOAK-6771 Certificate Bound Token\n        // https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\n       if ($scope.client.attributes[\"tls.client.certificate.bound.access.tokens\"]) {\n           if ($scope.client.attributes[\"tls.client.certificate.bound.access.tokens\"] == \"true\") {\n               $scope.tlsClientCertificateBoundAccessTokens = true;\n           } else {\n               $scope.tlsClientCertificateBoundAccessTokens = false;\n           }\n       }\n\n        // PAR request.\n        if ($scope.client.attributes[\"require.pushed.authorization.requests\"]) {\n            if ($scope.client.attributes[\"require.pushed.authorization.requests\"] == \"true\") {\n                $scope.requirePushedAuthorizationRequests = true;\n            } else {\n                $scope.requirePushedAuthorizationRequests = false;\n            }\n        }\n\n        var useRefreshToken = $scope.client.attributes[\"client_credentials.use_refresh_token\"];\n        if (useRefreshToken === \"true\") {\n            $scope.useRefreshTokenForClientCredentialsGrant = true;\n        } else {\n            $scope.useRefreshTokenForClientCredentialsGrant = false;\n        }\n\n        var useLowerCaseBearerTypeInTokenResponse = $scope.client.attributes[\"token.response.type.bearer.lower-case\"];\n        if (useLowerCaseBearerTypeInTokenResponse === \"true\") {\n            $scope.useLowerCaseBearerTypeInTokenResponse = true;\n        } else {\n            $scope.useLowerCaseBearerTypeInTokenResponse = false;\n        }\n\n        if ($scope.client.attributes[\"display.on.consent.screen\"]) {\n            if ($scope.client.attributes[\"display.on.consent.screen\"] == \"true\") {\n                $scope.displayOnConsentScreen = true;\n            } else {\n                $scope.displayOnConsentScreen = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"backchannel.logout.session.required\"]) {\n            if ($scope.client.attributes[\"backchannel.logout.session.required\"] == \"true\") {\n                $scope.backchannelLogoutSessionRequired = true;\n            } else {\n                $scope.backchannelLogoutSessionRequired = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"backchannel.logout.revoke.offline.tokens\"]) {\n            if ($scope.client.attributes[\"backchannel.logout.revoke.offline.tokens\"] == \"true\") {\n                $scope.backchannelLogoutRevokeOfflineSessions = true;\n            } else {\n                $scope.backchannelLogoutRevokeOfflineSessions = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"frontchannel.logout.session.required\"]) {\n            if ($scope.client.attributes[\"frontchannel.logout.session.required\"] == \"true\") {\n                $scope.frontchannelLogoutSessionRequired = true;\n            } else {\n                $scope.frontchannelLogoutSessionRequired = false;\n            }\n        }\n\n        if ($scope.client.attributes[\"request.uris\"] && $scope.client.attributes[\"request.uris\"].length > 0) {\n            $scope.client.requestUris = $scope.client.attributes[\"request.uris\"].split(\"##\");\n        } else {\n            $scope.client.requestUris = [];\n        }\n\n        if ($scope.client.attributes[\"default.acr.values\"] && $scope.client.attributes[\"default.acr.values\"].length > 0) {\n            $scope.defaultAcrValues = $scope.client.attributes[\"default.acr.values\"].split(\"##\");\n        } else {\n            $scope.defaultAcrValues = [];\n        }\n        deletedSomeDefaultAcrValue = false;\n\n        try {\n          $scope.acrLoaMap = JSON.parse($scope.client.attributes[\"acr.loa.map\"] || \"{}\");\n        } catch (e) {\n          $scope.acrLoaMap = {};\n        }\n    }\n\n    if (!$scope.create) {\n        $scope.client = client;\n        updateProperties();\n\n        $scope.clientEdit = angular.copy(client);\n    }\n\n\n    $scope.samlIdpInitiatedUrl = function(ssoName) {\n        return encodeURI($location.absUrl().replace(/\\/admin.*/, \"/realms/\") + realm.realm + \"/protocol/saml/clients/\") + encodeURIComponent(ssoName)\n    }\n\n    $scope.importFile = function(fileContent){\n        console.debug(fileContent);\n        ClientDescriptionConverter.save({\n            realm: realm.realm\n        }, fileContent, function (data) {\n            $scope.client = data;\n            updateProperties();\n            $scope.importing = true;\n\n            $scope.clientEdit = angular.copy(client);\n        });\n    };\n\n    $scope.viewImportDetails = function() {\n        $modal.open({\n            templateUrl: resourceUrl + '/partials/modal/view-object.html',\n            controller: 'ObjectModalCtrl',\n            resolve: {\n                object: function () {\n                    return $scope.client;\n                }\n            }\n        })\n    };\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.changeAccessType = function() {\n        if ($scope.accessType == \"confidential\") {\n            $scope.clientEdit.bearerOnly = false;\n            $scope.clientEdit.publicClient = false;\n        } else if ($scope.accessType == \"public\") {\n            $scope.clientEdit.bearerOnly = false;\n            $scope.clientEdit.publicClient = true;\n        } else if ($scope.accessType == \"bearer-only\") {\n            $scope.clientEdit.bearerOnly = true;\n            $scope.clientEdit.publicClient = false;\n            $scope.clientEdit.alwaysDisplayInConsole = false;\n        }\n    };\n\n    $scope.changeProtocol = function() {\n        if ($scope.protocol == \"openid-connect\") {\n            $scope.clientEdit.protocol = \"openid-connect\";\n        } else if ($scope.protocol == \"saml\") {\n            $scope.clientEdit.protocol = \"saml\";\n        }\n    };\n\n    $scope.changeAlgorithm = function() {\n        $scope.clientEdit.attributes['saml.signature.algorithm'] = $scope.signatureAlgorithm;\n    };\n\n    $scope.changeNameIdFormat = function() {\n        $scope.clientEdit.attributes['saml_name_id_format'] = $scope.nameIdFormat;\n    };\n\n    $scope.changeSamlSigKeyNameTranformer = function() {\n        $scope.clientEdit.attributes['saml.server.signature.keyinfo.xmlSigKeyInfoKeyNameTransformer'] = $scope.samlXmlKeyNameTranformer;\n    };\n\n    $scope.changeAccessTokenSignedResponseAlg = function() {\n        $scope.clientEdit.attributes['access.token.signed.response.alg'] = $scope.accessTokenSignedResponseAlg;\n    };\n\n    $scope.changeIdTokenSignedResponseAlg = function() {\n        $scope.clientEdit.attributes['id.token.signed.response.alg'] = $scope.idTokenSignedResponseAlg;\n    };\n\n    $scope.changeIdTokenEncryptedResponseAlg = function() {\n        $scope.clientEdit.attributes['id.token.encrypted.response.alg'] = $scope.idTokenEncryptedResponseAlg;\n    };\n\n    $scope.changeIdTokenEncryptedResponseEnc = function() {\n        $scope.clientEdit.attributes['id.token.encrypted.response.enc'] = $scope.idTokenEncryptedResponseEnc;\n    };\n\n    $scope.changeUserInfoSignedResponseAlg = function() {\n        if ($scope.userInfoSignedResponseAlg === 'unsigned') {\n            $scope.clientEdit.attributes['user.info.response.signature.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['user.info.response.signature.alg'] = $scope.userInfoSignedResponseAlg;\n        }\n    };\n\n    $scope.changeRequestObjectSignatureAlg = function() {\n        if ($scope.requestObjectSignatureAlg === 'any') {\n            $scope.clientEdit.attributes['request.object.signature.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.signature.alg'] = $scope.requestObjectSignatureAlg;\n        }\n    };\n\n    $scope.changeRequestObjectRequired = function() {\n        if ($scope.requestObjectRequired === 'not required') {\n            $scope.clientEdit.attributes['request.object.required'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.required'] = $scope.requestObjectRequired;\n        }\n    };\n\n    $scope.changeRequestObjectEncryptionAlg = function() {\n        if ($scope.requestObjectEncryptionAlg === 'any') {\n            $scope.clientEdit.attributes['request.object.encryption.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.encryption.alg'] = $scope.requestObjectEncryptionAlg;\n        }\n    };\n\n    $scope.changeRequestObjectEncryptionEnc = function() {\n        if ($scope.requestObjectEncryptionEnc === 'any') {\n            $scope.clientEdit.attributes['request.object.encryption.enc'] = null;\n        } else {\n            $scope.clientEdit.attributes['request.object.encryption.enc'] = $scope.requestObjectEncryptionEnc;\n        }\n    };\n\n    $scope.changePkceCodeChallengeMethod = function() {\n        $scope.clientEdit.attributes['pkce.code.challenge.method'] = $scope.pkceCodeChallengeMethod;\n    };\n\n    $scope.$watch('newAcr', function() {\n            $scope.changed = isChanged();\n        }, true);\n    $scope.$watch('newLoa', function() {\n            $scope.changed = isChanged();\n        }, true);\n    $scope.deleteAcrLoaMapping = function(acr) {\n        delete $scope.acrLoaMap[acr];\n        $scope.changed = true;\n    }\n    $scope.addAcrLoaMapping = function() {\n        if ($scope.newLoa.match(/^[0-9]+$/)) {\n            $scope.acrLoaMap[$scope.newAcr] = $scope.newLoa;\n            $scope.newAcr = $scope.newLoa = \"\";\n            $scope.changed = true;\n        }\n    }\n\n    $scope.changeCibaBackchannelAuthRequestSigningAlg = function() {\n        if ($scope.cibaBackchannelAuthRequestSigningAlg === 'any') {\n            $scope.clientEdit.attributes['ciba.backchannel.auth.request.signing.alg'] = null;\n        } else {\n            $scope.clientEdit.attributes['ciba.backchannel.auth.request.signing.alg'] = $scope.cibaBackchannelAuthRequestSigningAlg;\n        }\n    };\n\n    $scope.changeCibaBackchannelTokenDeliveryMode = function() {\n        $scope.clientEdit.attributes['ciba.backchannel.token.delivery.mode'] = $scope.cibaBackchannelTokenDeliveryMode;\n    };\n\n    $scope.changeAuthorizationSignedResponseAlg = function() {\n        $scope.clientEdit.attributes['authorization.signed.response.alg'] = $scope.authorizationSignedResponseAlg;\n    };\n\n    $scope.changeAuthorizationEncryptedResponseAlg = function() {\n        $scope.clientEdit.attributes['authorization.encrypted.response.alg'] = $scope.authorizationEncryptedResponseAlg;\n    };\n\n    $scope.changeAuthorizationEncryptedResponseEnc = function() {\n        $scope.clientEdit.attributes['authorization.encrypted.response.enc'] = $scope.authorizationEncryptedResponseEnc;\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    function isChanged() {\n        if (!angular.equals($scope.client, $scope.clientEdit)) {\n            return true;\n        }\n        if ($scope.newRedirectUri && $scope.newRedirectUri.length > 0) {\n            return true;\n        }\n        if ($scope.newWebOrigin && $scope.newWebOrigin.length > 0) {\n            return true;\n        }\n        if ($scope.newRequestUri && $scope.newRequestUri.length > 0) {\n            return true;\n        }\n        if ($scope.newDefaultAcrValue && $scope.newDefaultAcrValue.length > 0) {\n            return true;\n        }\n        if (deletedSomeDefaultAcrValue) return true;\n        if ($scope.newAcr && $scope.newAcr.length > 0 && $scope.newLoa && $scope.newLoa.length > 0) {\n            return true;\n        }\n        return false;\n    }\n\n    $scope.updateTimeouts = function() {\n        if ($scope.accessTokenLifespan.time) {\n            if ($scope.accessTokenLifespan.time === -1) {\n                $scope.clientEdit.attributes['access.token.lifespan'] = -1;\n            } else {\n                $scope.clientEdit.attributes['access.token.lifespan'] = $scope.accessTokenLifespan.toSeconds();\n            }\n        } else {\n            $scope.clientEdit.attributes['access.token.lifespan'] = null;\n        }\n    }\n\n    $scope.updateAssertionLifespan = function() {\n        if ($scope.samlAssertionLifespan.time) {\n            $scope.clientEdit.attributes['saml.assertion.lifespan'] = $scope.samlAssertionLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['saml.assertion.lifespan'] = null;\n        }\n    }\n\n    $scope.updateClientSessionIdleTimeout = function() {\n        if ($scope.clientSessionIdleTimeout.time) {\n            $scope.clientEdit.attributes['client.session.idle.timeout'] = $scope.clientSessionIdleTimeout.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.session.idle.timeout'] = null;\n        }\n    }\n\n    $scope.updateClientSessionMaxLifespan = function() {\n        if ($scope.clientSessionMaxLifespan.time) {\n            $scope.clientEdit.attributes['client.session.max.lifespan'] = $scope.clientSessionMaxLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.session.max.lifespan'] = null;\n        }\n    }\n\n    $scope.updateClientOfflineSessionIdleTimeout = function() {\n        if ($scope.clientOfflineSessionIdleTimeout.time) {\n            $scope.clientEdit.attributes['client.offline.session.idle.timeout'] = $scope.clientOfflineSessionIdleTimeout.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.offline.session.idle.timeout'] = null;\n        }\n    }\n\n    $scope.updateClientOfflineSessionMaxLifespan = function() {\n        if ($scope.clientOfflineSessionMaxLifespan.time) {\n            $scope.clientEdit.attributes['client.offline.session.max.lifespan'] = $scope.clientOfflineSessionMaxLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['client.offline.session.max.lifespan'] = null;\n        }\n    }\n\n    $scope.updateOauth2DeviceCodeLifespan = function() {\n        if ($scope.oauth2DeviceCodeLifespan.time) {\n            $scope.clientEdit.attributes['oauth2.device.code.lifespan'] = $scope.oauth2DeviceCodeLifespan.toSeconds();\n        } else {\n            $scope.clientEdit.attributes['oauth2.device.code.lifespan'] = null;\n        }\n    }\n\n    $scope.updateOauth2DevicePollingInterval = function() {\n        if ($scope.oauth2DevicePollingInterval) {\n            $scope.clientEdit.attributes['oauth2.device.polling.interval'] = $scope.oauth2DevicePollingInterval;\n        } else {\n            $scope.clientEdit.attributes['oauth2.device.polling.interval'] = null;\n        }\n    }\n\n    $scope.confirmChangeAuthzSettings = function($event) {\n        if ($scope.client.authorizationServicesEnabled && $scope.clientEdit.authorizationServicesEnabled) {\n            $event.preventDefault();\n            Dialog.confirm(\"Disable Authorization Settings\", \"Are you sure you want to disable authorization ? Once you save your changes, all authorization settings associated with this client will be removed. This operation can not be reverted.\", function () {\n                $scope.clientEdit.authorizationServicesEnabled = false;\n            }, function () {\n                $scope.clientEdit.authorizationServicesEnabled = true;\n            });\n        }\n    }\n\n    function configureAuthorizationServices() {\n        if ($scope.clientEdit.authorizationServicesEnabled) {\n            if ($scope.accessType == 'public') {\n                $scope.accessType = 'confidential';\n            }\n            $scope.clientEdit.publicClient = false;\n            $scope.clientEdit.serviceAccountsEnabled = true;\n        } else if ($scope.clientEdit.bearerOnly) {\n            $scope.clientEdit.serviceAccountsEnabled = false;\n        }\n    }\n\n    $scope.$watch('clientEdit', function() {\n        $scope.changed = isChanged();\n        configureAuthorizationServices();\n    }, true);\n\n    $scope.$watch('newRedirectUri', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n\n    $scope.$watch('newWebOrigin', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.$watch('newRequestUri', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.$watch('newDefaultAcrValue', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.deleteWebOrigin = function(index) {\n        $scope.clientEdit.webOrigins.splice(index, 1);\n    }\n    $scope.addWebOrigin = function() {\n        $scope.clientEdit.webOrigins.push($scope.newWebOrigin);\n        $scope.newWebOrigin = \"\";\n    }\n    $scope.deleteRequestUri = function(index) {\n        $scope.clientEdit.requestUris.splice(index, 1);\n    }\n    $scope.addRequestUri = function() {\n        $scope.clientEdit.requestUris.push($scope.newRequestUri);\n        $scope.newRequestUri = \"\";\n    }\n    $scope.deleteDefaultAcrValue = function(index) {\n        $scope.defaultAcrValues.splice(index, 1);\n        deletedSomeDefaultAcrValue = true;\n        $scope.changed = isChanged();\n    }\n    $scope.addDefaultAcrValue = function() {\n        $scope.defaultAcrValues.push($scope.newDefaultAcrValue);\n        $scope.newDefaultAcrValue = \"\";\n    }\n    $scope.deleteRedirectUri = function(index) {\n        $scope.clientEdit.redirectUris.splice(index, 1);\n    }\n\n    $scope.addRedirectUri = function() {\n        $scope.clientEdit.redirectUris.push($scope.newRedirectUri);\n        $scope.newRedirectUri = \"\";\n    }\n\n    $scope.save = function() {\n        if ($scope.newRedirectUri && $scope.newRedirectUri.length > 0) {\n            $scope.addRedirectUri();\n        }\n\n        if ($scope.newWebOrigin && $scope.newWebOrigin.length > 0) {\n            $scope.addWebOrigin();\n        }\n\n        if ($scope.newRequestUri && $scope.newRequestUri.length > 0) {\n            $scope.addRequestUri();\n        }\n        if ($scope.clientEdit.requestUris && $scope.clientEdit.requestUris.length > 0) {\n            $scope.clientEdit.attributes[\"request.uris\"] = $scope.clientEdit.requestUris.join(\"##\");\n        } else {\n            $scope.clientEdit.attributes[\"request.uris\"] = null;\n        }\n        if (!$scope.clientEdit.frontchannelLogout) {\n            $scope.clientEdit.attributes[\"frontchannel.logout.url\"] = null;\n        }\n        delete $scope.clientEdit.requestUris;\n\n        if ($scope.newDefaultAcrValue && $scope.newDefaultAcrValue.length > 0) {\n            $scope.addDefaultAcrValue();\n        }\n        if ($scope.defaultAcrValues && $scope.defaultAcrValues.length > 0) {\n            $scope.clientEdit.attributes[\"default.acr.values\"] = $scope.defaultAcrValues.join(\"##\");\n        } else {\n            $scope.clientEdit.attributes[\"default.acr.values\"] = null;\n        }\n\n        if ($scope.samlArtifactBinding == true) {\n            $scope.clientEdit.attributes[\"saml.artifact.binding\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.artifact.binding\"] = \"false\";\n        }\n\n        if ($scope.newAcr && $scope.newAcr.length > 0 && $scope.newLoa && $scope.newLoa.length > 0) {\n          $scope.addAcrLoaMapping();\n        }\n\n        if ($scope.samlServerSignature == true) {\n            $scope.clientEdit.attributes[\"saml.server.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.server.signature\"] = \"false\";\n        }\n        if ($scope.samlServerSignatureEnableKeyInfoExtension == true) {\n            $scope.clientEdit.attributes[\"saml.server.signature.keyinfo.ext\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.server.signature.keyinfo.ext\"] = \"false\";\n        }\n        if ($scope.samlAssertionSignature == true) {\n            $scope.clientEdit.attributes[\"saml.assertion.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.assertion.signature\"] = \"false\";\n        }\n        if ($scope.samlClientSignature == true) {\n            $scope.clientEdit.attributes[\"saml.client.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.client.signature\"] = \"false\";\n\n        }\n        if ($scope.samlEncrypt == true) {\n            $scope.clientEdit.attributes[\"saml.encrypt\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.encrypt\"] = \"false\";\n\n        }\n        if ($scope.samlAuthnStatement == true) {\n            $scope.clientEdit.attributes[\"saml.authnstatement\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.authnstatement\"] = \"false\";\n\n        }\n        if ($scope.samlOneTimeUseCondition == true) {\n                    $scope.clientEdit.attributes[\"saml.onetimeuse.condition\"] = \"true\";\n                } else {\n                    $scope.clientEdit.attributes[\"saml.onetimeuse.condition\"] = \"false\";\n\n                }\n        if ($scope.samlForceNameIdFormat == true) {\n            $scope.clientEdit.attributes[\"saml_force_name_id_format\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml_force_name_id_format\"] = \"false\";\n\n        }\n        if ($scope.samlAllowECPFlow == true) {\n            $scope.clientEdit.attributes[\"saml.allow.ecp.flow\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.allow.ecp.flow\"] = \"false\";\n\n        }\n        if ($scope.samlMultiValuedRoles == true) {\n            $scope.clientEdit.attributes[\"saml.multivalued.roles\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.multivalued.roles\"] = \"false\";\n\n        }\n        if ($scope.samlForcePostBinding == true) {\n            $scope.clientEdit.attributes[\"saml.force.post.binding\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"saml.force.post.binding\"] = \"false\";\n\n        }\n\n        if ($scope.excludeSessionStateFromAuthResponse == true) {\n            $scope.clientEdit.attributes[\"exclude.session.state.from.auth.response\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"exclude.session.state.from.auth.response\"] = \"false\";\n\n        }\n\n        if ($scope.oauth2DeviceAuthorizationGrantEnabled == true) {\n            $scope.clientEdit.attributes[\"oauth2.device.authorization.grant.enabled\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"oauth2.device.authorization.grant.enabled\"] = \"false\";\n        }\n\n        if ($scope.oidcCibaGrantEnabled == true) {\n            $scope.clientEdit.attributes[\"oidc.ciba.grant.enabled\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"oidc.ciba.grant.enabled\"] = \"false\";\n        }\n\n        if ($scope.useRefreshTokens == true) {\n            $scope.clientEdit.attributes[\"use.refresh.tokens\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"use.refresh.tokens\"] = \"false\";\n        }\n\n        if ($scope.useIdTokenAsDetachedSignature == true) {\n            $scope.clientEdit.attributes[\"id.token.as.detached.signature\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"id.token.as.detached.signature\"] = \"false\";\n        }\n\n        // KEYCLOAK-6771 Certificate Bound Token\n        // https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3\n        if ($scope.tlsClientCertificateBoundAccessTokens == true) {\n            $scope.clientEdit.attributes[\"tls.client.certificate.bound.access.tokens\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"tls.client.certificate.bound.access.tokens\"] = \"false\";\n        }\n\n        // PAR request.\n        if ($scope.requirePushedAuthorizationRequests == true) {\n            $scope.clientEdit.attributes[\"require.pushed.authorization.requests\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"require.pushed.authorization.requests\"] = \"false\";\n        }\n\n        // KEYCLOAK-9551 Client Credentials Grant generates refresh token\n        // https://tools.ietf.org/html/rfc6749#section-4.4.3\n        if ($scope.useRefreshTokenForClientCredentialsGrant === true) {\n            $scope.clientEdit.attributes[\"client_credentials.use_refresh_token\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"client_credentials.use_refresh_token\"] = \"false\";\n        }\n\n        if ($scope.useLowerCaseBearerTypeInTokenResponse === true) {\n            $scope.clientEdit.attributes[\"token.response.type.bearer.lower-case\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"token.response.type.bearer.lower-case\"] = \"false\";\n        }\n\n        if ($scope.displayOnConsentScreen == true) {\n            $scope.clientEdit.attributes[\"display.on.consent.screen\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"display.on.consent.screen\"] = \"false\";\n        }\n\n        if ($scope.backchannelLogoutSessionRequired == true) {\n            $scope.clientEdit.attributes[\"backchannel.logout.session.required\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"backchannel.logout.session.required\"] = \"false\";\n        }\n\n        if ($scope.backchannelLogoutRevokeOfflineSessions == true) {\n            $scope.clientEdit.attributes[\"backchannel.logout.revoke.offline.tokens\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"backchannel.logout.revoke.offline.tokens\"] = \"false\";\n        }\n\n        if ($scope.frontchannelLogoutSessionRequired == true) {\n            $scope.clientEdit.attributes[\"frontchannel.logout.session.required\"] = \"true\";\n        } else {\n            $scope.clientEdit.attributes[\"frontchannel.logout.session.required\"] = \"false\";\n        }\n\n        $scope.clientEdit.attributes[\"acr.loa.map\"] = JSON.stringify($scope.acrLoaMap);\n\n        $scope.clientEdit.protocol = $scope.protocol;\n        $scope.clientEdit.attributes['saml.signature.algorithm'] = $scope.signatureAlgorithm;\n        $scope.clientEdit.attributes['saml_name_id_format'] = $scope.nameIdFormat;\n\n        if ($scope.clientEdit.protocol != 'saml' && !$scope.clientEdit.bearerOnly && ($scope.clientEdit.standardFlowEnabled || $scope.clientEdit.implicitFlowEnabled) && (!$scope.clientEdit.redirectUris || $scope.clientEdit.redirectUris.length == 0)) {\n            Notifications.error(\"You must specify at least one redirect uri\");\n        } else {\n            Client.update({\n                realm : realm.realm,\n                client : client.id\n            }, $scope.clientEdit, function() {\n                $route.reload();\n                Notifications.success(\"Your changes have been saved to the client.\");\n            });\n        }\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients\");\n    };\n});\n\nmodule.controller('CreateClientCtrl', function($scope, realm, client, $route, serverInfo, Client, ClientDescriptionConverter, $location, $modal, Dialog, Notifications) {\n    $scope.protocols = serverInfo.listProviderIds('login-protocol');\n    $scope.create = true;\n\n    $scope.realm = realm;\n\n    $scope.client = {\n        enabled: true,\n        attributes: {}\n    };\n    $scope.client.redirectUris = [];\n    $scope.protocol = $scope.protocols[0];\n\n\n    $scope.importFile = function(fileContent){\n        console.debug(fileContent);\n        ClientDescriptionConverter.save({\n            realm: realm.realm\n        }, fileContent, function (data) {\n            $scope.client = data;\n            if (data.protocol) {\n                $scope.protocol = data.protocol;\n            }\n            $scope.importing = true;\n        });\n    };\n\n    $scope.viewImportDetails = function() {\n        $modal.open({\n            templateUrl: resourceUrl + '/partials/modal/view-object.html',\n            controller: 'ObjectModalCtrl',\n            resolve: {\n                object: function () {\n                    return $scope.client;\n                }\n            }\n        })\n    };\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.changeProtocol = function() {\n        if ($scope.protocol == \"openid-connect\") {\n            $scope.client.protocol = \"openid-connect\";\n        } else if ($scope.protocol == \"saml\") {\n            $scope.client.protocol = \"saml\";\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    function isChanged() {\n        if (!angular.equals($scope.client, client)) {\n            return true;\n        }\n        return false;\n    }\n\n    $scope.$watch('client', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n\n    $scope.save = function() {\n        $scope.client.protocol = $scope.protocol;\n\n        Client.save({\n            realm: realm.realm,\n            client: ''\n        }, $scope.client, function (data, headers) {\n            $scope.changed = false;\n            var l = headers().location;\n            var id = l.substring(l.lastIndexOf(\"/\") + 1);\n            $location.url(\"/realms/\" + realm.realm + \"/clients/\" + id);\n            Notifications.success(\"The client has been created.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/clients\");\n    };\n});\n\nmodule.controller('ClientScopeMappingCtrl', function($scope, $http, realm, $route, client, clients, Notifications,\n                                                          Client, ClientScope,\n                                                          ClientRealmScopeMapping, ClientClientScopeMapping, ClientRole,\n                                                          ClientAvailableRealmScopeMapping, ClientAvailableClientScopeMapping,\n                                                          ClientCompositeRealmScopeMapping, ClientCompositeClientScopeMapping) {\n    $scope.realm = realm;\n    $scope.client = angular.copy(client);\n    $scope.selectedRealmRoles = [];\n    $scope.selectedRealmMappings = [];\n    $scope.realmMappings = [];\n    $scope.clients = clients;\n    $scope.clientRoles = [];\n    $scope.clientComposite = [];\n    $scope.selectedClientRoles = [];\n    $scope.selectedClientMappings = [];\n    $scope.clientMappings = [];\n    $scope.dummymodel = [];\n\n    $scope.hideRoleSelector = function() {\n       return $scope.client.fullScopeAllowed;\n    }\n\n    $scope.changeFlag = function() {\n        console.log('changeFlag');\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            client = angular.copy($scope.client);\n            updateRealmRoles();\n            Notifications.success(\"Scope mappings updated.\");\n        });\n    }\n\n    \n    $scope.selectedClient = null;\n\n    $scope.selectClient = function(client) {\n        if (!client || !client.id) {\n            $scope.selectedClient = null;\n            return;\n        }\n\n        $scope.selectedClient = client;\n        updateClientRoles();\n    }\n\n    function updateRealmRoles() {\n        $scope.realmRoles = ClientAvailableRealmScopeMapping.query({realm : realm.realm, client : client.id});\n        $scope.realmMappings = ClientRealmScopeMapping.query({realm : realm.realm, client : client.id});\n        $scope.realmComposite = ClientCompositeRealmScopeMapping.query({realm : realm.realm, client : client.id});\n    }\n\n    function updateClientRoles() {\n        if ($scope.selectedClient) {\n            $scope.clientRoles = ClientAvailableClientScopeMapping.query({realm : realm.realm, client : client.id, targetClient : $scope.selectedClient.id});\n            $scope.clientMappings = ClientClientScopeMapping.query({realm : realm.realm, client : client.id, targetClient : $scope.selectedClient.id});\n            $scope.clientComposite = ClientCompositeClientScopeMapping.query({realm : realm.realm, client : client.id, targetClient : $scope.selectedClient.id});\n        } else {\n            $scope.clientRoles = null;\n            $scope.clientMappings = null;\n            $scope.clientComposite = null;\n        }\n    }\n\n    $scope.addRealmRole = function() {\n        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');\n        $scope.selectedRealmRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/scope-mappings/realm',\n            $scope.selectedRealmRolesToAdd).then(function() {\n                updateRealmRoles();\n                $scope.selectedRealmRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteRealmRole = function() {\n        $scope.selectedRealmMappingsToRemove = JSON.parse('[' + $scope.selectedRealmMappings + ']');\n        $scope.selectedRealmMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id +  '/scope-mappings/realm',\n            {data : $scope.selectedRealmMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateRealmRoles();\n                $scope.selectedRealmMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.addClientRole = function() {\n        $scope.selectedClientRolesToAdd = JSON.parse('[' + $scope.selectedClientRoles + ']');\n        $scope.selectedClientRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n                $scope.selectedClientRolesToAdd).then(function () {\n                updateClientRoles();\n                $scope.selectedClientRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteClientRole = function() {\n        $scope.selectedClientMappingsToRemove = JSON.parse('[' + $scope.selectedClientMappings + ']');\n        $scope.selectedClientMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n            {data : $scope.selectedClientMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateClientRoles();\n                $scope.selectedClientMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    clientSelectControl($scope, $route.current.params.realm, Client);\n    updateRealmRoles();\n});\n\nmodule.controller('ClientRevocationCtrl', function($scope, realm, client, Client, ClientPushRevocation, $location, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n\n    var setNotBefore = function() {\n        if ($scope.client.notBefore == 0) {\n            $scope.notBefore = \"None\";\n        } else {\n            $scope.notBefore = new Date($scope.client.notBefore * 1000);\n        }\n    };\n\n    setNotBefore();\n\n    var refresh = function() {\n        Client.get({ realm : realm.realm, client: $scope.client.id }, function(updated) {\n            $scope.client = updated;\n            setNotBefore();\n        })\n\n    };\n\n    $scope.clear = function() {\n        $scope.client.notBefore = 0;\n        Client.update({ realm : realm.realm, client: client.id}, $scope.client, function () {\n            $scope.notBefore = \"None\";\n            Notifications.success('Not Before cleared for client.');\n            refresh();\n        });\n    }\n    $scope.setNotBeforeNow = function() {\n        $scope.client.notBefore = new Date().getTime()/1000;\n        Client.update({ realm : realm.realm, client: $scope.client.id}, $scope.client, function () {\n            Notifications.success('Not Before set for client.');\n            refresh();\n        });\n    }\n    $scope.pushRevocation = function() {\n        ClientPushRevocation.save({realm : realm.realm, client: $scope.client.id}, function (globalReqResult) {\n            var successCount = globalReqResult.successRequests ? globalReqResult.successRequests.length : 0;\n            var failedCount  = globalReqResult.failedRequests ? globalReqResult.failedRequests.length : 0;\n\n            if (successCount==0 && failedCount==0) {\n                Notifications.warn('No push sent. No admin URI configured or no registered cluster nodes available');\n            } else if (failedCount > 0) {\n                var msgStart = successCount>0 ? 'Successfully push notBefore to: ' + globalReqResult.successRequests + ' . ' : '';\n                Notifications.error(msgStart + 'Failed to push notBefore to: ' + globalReqResult.failedRequests + '. Verify availability of failed hosts and try again');\n            } else {\n                Notifications.success('Successfully push notBefore to: ' + globalReqResult.successRequests);\n            }\n        });\n    }\n\n});\n\nmodule.controller('ClientClusteringCtrl', function($scope, client, Client, ClientTestNodesAvailable, ClientClusterNode, realm, $location, $route, Dialog, Notifications, TimeUnit) {\n    $scope.client = client;\n    $scope.realm = realm;\n\n    var oldCopy = angular.copy($scope.client);\n    $scope.changed = false;\n\n    $scope.$watch('client', function() {\n        if (!angular.equals($scope.client, oldCopy)) {\n            $scope.changed = true;\n        }\n    }, true);\n\n    $scope.client.nodeReRegistrationTimeoutUnit = TimeUnit.autoUnit(client.nodeReRegistrationTimeout);\n    $scope.client.nodeReRegistrationTimeout = TimeUnit.toUnit(client.nodeReRegistrationTimeout, $scope.client.nodeReRegistrationTimeoutUnit);\n\n    $scope.save = function() {\n        var clientCopy = angular.copy($scope.client);\n        delete clientCopy['nodeReRegistrationTimeoutUnit'];\n        clientCopy.nodeReRegistrationTimeout = TimeUnit.toSeconds($scope.client.nodeReRegistrationTimeout, $scope.client.nodeReRegistrationTimeoutUnit)\n        Client.update({ realm : realm.realm, client : client.id }, clientCopy, function () {\n            $route.reload();\n            Notifications.success('Your changes have been saved to the client.');\n        });\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.testNodesAvailable = function() {\n        ClientTestNodesAvailable.get({ realm : realm.realm, client : client.id }, function(globalReqResult) {\n            $route.reload();\n\n            var successCount = globalReqResult.successRequests ? globalReqResult.successRequests.length : 0;\n            var failedCount  = globalReqResult.failedRequests ? globalReqResult.failedRequests.length : 0;\n\n            if (successCount==0 && failedCount==0) {\n                Notifications.warn('No requests sent. No admin URI configured or no registered cluster nodes available');\n            } else if (failedCount > 0) {\n                var msgStart = successCount>0 ? 'Successfully verify availability for ' + globalReqResult.successRequests + ' . ' : '';\n                Notifications.error(msgStart + 'Failed to verify availability for: ' + globalReqResult.failedRequests + '. Fix or unregister failed cluster nodes and try again');\n            } else {\n                Notifications.success('Successfully sent requests to: ' + globalReqResult.successRequests);\n            }\n        });\n    };\n\n    if (client.registeredNodes) {\n        var nodeRegistrations = [];\n        for (node in client.registeredNodes) {\n            reg = {\n                host: node,\n                lastRegistration: new Date(client.registeredNodes[node] * 1000)\n            }\n            nodeRegistrations.push(reg);\n        }\n\n        $scope.nodeRegistrations = nodeRegistrations;\n    };\n\n    $scope.removeNode = function(node) {\n        Dialog.confirmDelete(node.host, 'node', function() {\n            ClientClusterNode.remove({ realm : realm.realm, client : client.id , node: node.host }, function() {\n                Notifications.success('Node ' + node.host + ' unregistered successfully.');\n                $route.reload();\n            });\n        });\n    };\n});\n\nmodule.controller('ClientClusteringNodeCtrl', function($scope, client, Client, ClientClusterNode, realm,\n                                                       $location, $routeParams, Notifications, Dialog) {\n    $scope.client = client;\n    $scope.realm = realm;\n    $scope.create = !$routeParams.node;\n\n    $scope.save = function() {\n        ClientClusterNode.save({ realm : realm.realm, client : client.id , node: $scope.node.host }, function() {\n            Notifications.success('Node ' + $scope.node.host + ' registered successfully.');\n            $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/clustering');\n        });\n    }\n\n    $scope.unregisterNode = function() {\n        Dialog.confirmDelete($scope.node.host, 'node', function() {\n            ClientClusterNode.remove({ realm : realm.realm, client : client.id , node: $scope.node.host }, function() {\n                Notifications.success('Node ' + $scope.node.host + ' unregistered successfully.');\n                $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/clustering');\n            });\n        });\n    }\n\n    if ($scope.create) {\n        $scope.node = {}\n        $scope.registered = false;\n    } else {\n        var lastRegTime = client.registeredNodes[$routeParams.node];\n\n        if (lastRegTime) {\n            $scope.registered = true;\n            $scope.node = {\n                host: $routeParams.node,\n                lastRegistration: new Date(lastRegTime * 1000)\n            }\n\n        } else {\n            $scope.registered = false;\n            $scope.node = {\n                host: $routeParams.node\n            }\n        }\n    }\n});\n\nmodule.controller('AddBuiltinProtocolMapperCtrl', function($scope, realm, client, serverInfo,\n                                                            ClientProtocolMappersByProtocol,\n                                                            $http, $location, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n\n\n\n    var updateMappers = function() {\n        var clientMappers = ClientProtocolMappersByProtocol.query({realm : realm.realm, client : client.id, protocol : client.protocol}, function() {\n            var builtinMappers = serverInfo.builtinProtocolMappers[client.protocol];\n            for (var i = 0; i < clientMappers.length; i++) {\n                for (var j = 0; j < builtinMappers.length; j++) {\n                    if (builtinMappers[j].name == clientMappers[i].name\n                        && builtinMappers[j].protocolMapper == clientMappers[i].protocolMapper) {\n                        builtinMappers.splice(j, 1);\n                        break;\n                    }\n                }\n            }\n            $scope.mappers = builtinMappers;\n            for (var i = 0; i < $scope.mappers.length; i++) {\n                $scope.mappers[i].isChecked = false;\n            }\n\n\n        });\n    };\n\n    updateMappers();\n\n    $scope.add = function() {\n        var toAdd = [];\n        for (var i = 0; i < $scope.mappers.length; i++) {\n            if ($scope.mappers[i].isChecked) {\n                delete $scope.mappers[i].isChecked;\n                toAdd.push($scope.mappers[i]);\n            }\n        }\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/clients/' + client.id + '/protocol-mappers/add-models',\n                   toAdd).then(function() {\n                Notifications.success(\"Mappers added\");\n                $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/mappers');\n            }).catch(function() {\n                Notifications.error(\"Error adding mappers\");\n                $location.url('/realms/' + realm.realm + '/clients/' + client.id +  '/mappers');\n            });\n    };\n\n});\n\nmodule.controller('ClientProtocolMapperListCtrl', function($scope, realm, client, serverInfo,\n                                                           Client,\n                                                           ClientProtocolMappersByProtocol, ClientProtocolMapper,\n                                                           $route, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.client = client;\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n\n    $scope.changeFlag = function() {\n        Client.update({\n            realm : realm.realm,\n            client : client.id\n        }, $scope.client, function() {\n            $scope.changed = false;\n            client = angular.copy($scope.client);\n            Notifications.success(\"Client updated.\");\n        });\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n    $scope.removeMapper = function(mapper) {\n        console.debug(mapper);\n        Dialog.confirmDelete(mapper.name, 'mapper', function() {\n            ClientProtocolMapper.remove({ realm: realm.realm, client: client.id, id : mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $route.reload();\n            });\n        });\n    };\n\n    $scope.sortMappersByPriority = function(mapper) {\n        return $scope.mapperTypes[mapper.protocolMapper].priority;\n    }\n\n    var updateMappers = function() {\n        $scope.mappers = ClientProtocolMappersByProtocol.query({realm : realm.realm, client : client.id, protocol : client.protocol});\n    };\n\n    updateMappers();\n});\n\nmodule.controller('ClientProtocolMapperCtrl', function($scope, realm, serverInfo, client, clients, mapper, ClientProtocolMapper, Notifications, Dialog, $location) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    /*\n    $scope.client = client;\n    $scope.create = false;\n    $scope.protocol = client.protocol;\n    $scope.mapper = angular.copy(mapper);\n    $scope.changed = false;\n    */\n\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n\n    $scope.model = {\n        realm: realm,\n        client: client,\n        create: false,\n        protocol: client.protocol,\n        mapper: angular.copy(mapper),\n        changed: false\n    };\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    for (var i = 0; i < protocolMappers.length; i++) {\n        if (protocolMappers[i].id === mapper.protocolMapper) {\n            $scope.model.mapperType = protocolMappers[i];\n        }\n    }\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.$watch('model.mapper', function() {\n        if (!angular.equals($scope.model.mapper, mapper)) {\n            $scope.model.changed = true;\n        }\n    }, true);\n\n    $scope.save = function() {\n        ClientProtocolMapper.update({\n            realm : realm.realm,\n            client: client.id,\n            id : $scope.model.mapper.id\n        }, $scope.model.mapper, function() {\n            $scope.model.changed = false;\n            mapper = angular.copy($scope.mapper);\n            $location.url(\"/realms/\" + realm.realm + '/clients/' + client.id + \"/mappers/\" + $scope.model.mapper.id);\n            Notifications.success(\"Your changes have been saved.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.model.mapper = angular.copy(mapper);\n        $scope.model.changed = false;\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n    $scope.remove = function() {\n        Dialog.confirmDelete($scope.model.mapper.name, 'mapper', function() {\n            ClientProtocolMapper.remove({ realm: realm.realm, client: client.id, id : $scope.model.mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $location.url(\"/realms/\" + realm.realm + '/clients/' + client.id + \"/mappers\");\n            });\n        });\n    };\n\n});\n\nmodule.controller('ClientProtocolMapperCreateCtrl', function($scope, realm, serverInfo, client, clients, ClientProtocolMapper, Notifications, Dialog, $location) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    if (client.protocol == null) {\n        client.protocol = 'openid-connect';\n    }\n    var protocol = client.protocol;\n    /*\n    $scope.client = client;\n    $scope.create = true;\n    $scope.protocol = protocol;\n    $scope.mapper = { protocol :  client.protocol, config: {}};\n    $scope.mapperTypes = serverInfo.protocolMapperTypes[protocol];\n    */\n    $scope.model = {\n        realm: realm,\n        client: client,\n        create: true,\n        protocol: client.protocol,\n        mapper: { protocol :  client.protocol, config: {}},\n        changed: false,\n        mapperTypes: serverInfo.protocolMapperTypes[protocol]\n    };\n    console.log(\"mapper types: \", $scope.model.mapperTypes);\n\n    // apply default configurations on change for selected protocolmapper type.\n    $scope.$watch('model.mapperType', function() {\n        var currentMapperType = $scope.model.mapperType;\n        var defaultConfig = {};\n\n        if (currentMapperType && Array.isArray(currentMapperType.properties)) {\n            for (var i = 0; i < currentMapperType.properties.length; i++) {\n                var property = currentMapperType.properties[i];\n                if (property && property.name && property.defaultValue) {\n                    defaultConfig[property.name] = property.defaultValue;\n                }\n            }\n        }\n\n        $scope.model.mapper.config = defaultConfig;\n    }, true);\n\n    $scope.model.mapperType = $scope.model.mapperTypes[0];\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.save = function() {\n        $scope.model.mapper.protocolMapper = $scope.model.mapperType.id;\n        ClientProtocolMapper.save({\n            realm : realm.realm, client: client.id\n        }, $scope.model.mapper, function(data, headers) {\n            var l = headers().location;\n            var id = l.substring(l.lastIndexOf(\"/\") + 1);\n            $location.url(\"/realms/\" + realm.realm + '/clients/' + client.id + \"/mappers/\" + id);\n            Notifications.success(\"Mapper has been created.\");\n        });\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n\n});\n\n\nmodule.controller('ClientClientScopesSetupCtrl', function($scope, realm, Realm, client, clientScopes, serverInfo,\n        clientDefaultClientScopes, ClientDefaultClientScopes, clientOptionalClientScopes, ClientOptionalClientScopes, $route, Notifications, $location) {\n    console.log('ClientClientScopesSetupCtrl');\n\n    $scope.realm = realm;\n    $scope.client = client;\n\n    $scope.clientDefaultClientScopes = clientDefaultClientScopes;\n    $scope.clientOptionalClientScopes = clientOptionalClientScopes;\n\n    $scope.availableClientScopes = [];\n    $scope.selectedDefaultClientScopes = [];\n    $scope.selectedDefDefaultClientScopes = [];\n\n    $scope.selectedOptionalClientScopes = [];\n    $scope.selectedDefOptionalClientScopes = [];\n\n    // Populate available client scopes. Available client scopes are neither already assigned to 'default' or 'optional'\n    for (var i = 0; i < clientScopes.length; i++) {\n        var clientScope = clientScopes[i];\n        var scopeName = clientScopes[i].name;\n\n        var available = true;\n        if (clientScope.protocol != client.protocol) {\n            available = false;\n        }\n\n        for (var j = 0; j < $scope.clientDefaultClientScopes.length; j++) {\n            if (scopeName === $scope.clientDefaultClientScopes[j].name) {\n                available = false;\n            }\n        }\n        for (var j = 0; j < $scope.clientOptionalClientScopes.length; j++) {\n            if (scopeName === $scope.clientOptionalClientScopes[j].name) {\n                available = false;\n            }\n        }\n\n        if (available) {\n            $scope.availableClientScopes.push(clientScope);\n        }\n    }\n\n    $scope.addDefaultClientScope = function () {\n        $scope.selectedDefaultClientScopesToAdd = JSON.parse('[' + $scope.selectedDefaultClientScopes + ']');\n        toAdd = $scope.selectedDefaultClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedDefaultClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedDefaultClientScopesToAdd[i];\n\n            ClientDefaultClientScopes.update({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefaultClientScopesToAdd = [];\n    };\n\n    $scope.deleteDefaultClientScope = function () {\n        $scope.selectedDefDefaultClientScopesToRemove = JSON.parse('[' + $scope.selectedDefDefaultClientScopes + ']');\n        toRemove = $scope.selectedDefDefaultClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefDefaultClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefDefaultClientScopesToRemove[i];\n\n            ClientDefaultClientScopes.remove({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefDefaultClientScopesToRemove = [];\n    };\n\n    $scope.addOptionalClientScope = function () {\n        $scope.selectedOptionalClientScopesToAdd = JSON.parse('[' + $scope.selectedOptionalClientScopes + ']');\n        toAdd = $scope.selectedOptionalClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedOptionalClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedOptionalClientScopesToAdd[i];\n\n            ClientOptionalClientScopes.update({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Optional scopes updated.\");\n                }\n            });\n        }\n    };\n\n    $scope.deleteOptionalClientScope = function () {\n        $scope.selectedDefOptionalClientScopesToRemove = JSON.parse('[' + $scope.selectedDefOptionalClientScopes + ']');\n        toRemove = $scope.selectedDefOptionalClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefOptionalClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefOptionalClientScopesToRemove[i];\n\n            ClientOptionalClientScopes.remove({\n                realm : realm.realm,\n                client : client.id,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Optional scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefOptionalClientScopesToRemove = [];\n    };\n\n});\n\nmodule.controller('ClientClientScopesEvaluateCtrl', function($scope, Realm, User, ClientEvaluateProtocolMappers, ClientEvaluateGrantedRoles,\n        ClientEvaluateNotGrantedRoles, ClientEvaluateGenerateExampleAccessToken, ClientEvaluateGenerateExampleIDToken,\n        ClientEvaluateGenerateExampleUserInfo, realm, client, clients, clientScopes, serverInfo, ComponentUtils,\n        clientOptionalClientScopes, clientDefaultClientScopes, $route, $routeParams, $http, Notifications, $location,\n        Client) {\n\n    console.log('ClientClientScopesEvaluateCtrl');\n\n    var protocolMappers = serverInfo.protocolMapperTypes[client.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n    $scope.realm = realm;\n    $scope.client = client;\n    $scope.clients = clients;\n    $scope.userId = null;\n\n    $scope.availableClientScopes = [];\n    $scope.assignedClientScopes = [];\n    $scope.selectedClientScopes = [];\n    $scope.selectedDefClientScopes = [];\n    $scope.effectiveClientScopes = [];\n\n    // Populate available client scopes. Available client scopes are neither already assigned to 'default' or 'optional'\n    for (var i = 0; i < clientOptionalClientScopes.length; i++) {\n        $scope.availableClientScopes.push(clientOptionalClientScopes[i]);\n    }\n\n    function clearEvalResponse() {\n        $scope.protocolMappers = null;\n        $scope.grantedRealmRoles = null;\n        $scope.notGrantedRealmRoles = null;\n        $scope.grantedClientRoles = null;\n        $scope.notGrantedClientRoles = null;\n        $scope.targetClient = null;\n        $scope.oidcAccessToken = null;\n        $scope.oidcIDToken = null;\n        $scope.oidcUserInfo = null;\n\n        $scope.selectedTab = 0;\n    }\n\n    function updateState() {\n        // Compute scope parameter\n        $scope.scopeParam = 'openid';\n        for (var i = 0; i < $scope.assignedClientScopes.length; i++) {\n            var currentScopeParam = $scope.assignedClientScopes[i].name;\n            $scope.scopeParam = $scope.scopeParam + ' ' + currentScopeParam;\n        }\n\n        // Compute effective scopes\n        $scope.effectiveClientScopes = [];\n\n        for (var i = 0; i < clientDefaultClientScopes.length; i++) {\n            var currentScope = clientDefaultClientScopes[i];\n            $scope.effectiveClientScopes.push(currentScope);\n        }\n        for (var i = 0; i < $scope.assignedClientScopes.length; i++) {\n            var currentScope = $scope.assignedClientScopes[i];\n            $scope.effectiveClientScopes.push(currentScope);\n        }\n\n        // Clear the evaluation response\n        clearEvalResponse();\n    }\n\n    updateState();\n\n\n    $scope.addAppliedClientScope = function () {\n        $scope.selectedClientScopesToAdd = JSON.parse('[' + $scope.selectedClientScopes + ']');\n        for (var i = 0; i < $scope.selectedClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedClientScopesToAdd[i];\n\n            $scope.assignedClientScopes.push(currentScope);\n\n            var index = ComponentUtils.findIndexById($scope.availableClientScopes, currentScope.id);\n            if (index > -1) {\n                $scope.availableClientScopes.splice(index, 1);\n            }\n        }\n\n        $scope.selectedClientScopes = [];\n        $scope.selectedClientScopesToAdd = [];\n        updateState();\n    };\n\n    $scope.deleteAppliedClientScope = function () {\n        $scope.selectedDefClientScopesToRemove = JSON.parse('[' + $scope.selectedDefClientScopes + ']');\n        for (var i = 0; i < $scope.selectedDefClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefClientScopesToRemove[i];\n\n            $scope.availableClientScopes.push(currentScope);\n\n            var index = ComponentUtils.findIndexById($scope.assignedClientScopes, currentScope.id);\n            if (index > -1) {\n                $scope.assignedClientScopes.splice(index, 1);\n            }\n        }\n\n        $scope.selectedDefClientScopes = [];\n        $scope.selectedDefClientScopesToRemove = [];\n\n        updateState();\n    };\n\n    $scope.usersUiSelect = {\n        minimumInputLength: 1,\n        delay: 500,\n        allowClear: true,\n        query: function (query) {\n            var data = {results: []};\n            if ('' == query.term.trim()) {\n                query.callback(data);\n                return;\n            }\n            User.query({realm: $route.current.params.realm, search: query.term.trim(), max: 20}, function(response) {\n                data.results = response;\n                query.callback(data);\n            });\n        },\n        formatResult: function(object, container, query) {\n            object.text = object.username;\n            return object.username;\n        }\n    };\n\n    $scope.selectedUser = null;\n\n    $scope.selectUser = function(user) {\n        clearEvalResponse();\n\n        if (!user || !user.id) {\n            $scope.selectedUser = null;\n            $scope.userId = '';\n            return;\n        }\n\n        $scope.userId = user.id;\n    }\n\n    clientSelectControl($scope, $route.current.params.realm, Client);\n    \n    $scope.selectedClient = null;\n\n    $scope.selectClient = function(client) {\n        console.log(\"selected client: \", client);\n        if (!client || !client.id) {\n            $scope.selectedClient = null;\n            return;\n        }\n\n        $scope.selectedClient = client;\n        updateScopeClientRoles();\n    }\n\n\n    $scope.sendEvaluationRequest = function () {\n\n        // Send request for retrieve protocolMappers\n        $scope.protocolMappers = ClientEvaluateProtocolMappers.query({\n            realm: realm.realm,\n            client: client.id,\n            scopeParam: $scope.scopeParam\n        });\n\n        // Send request for retrieve realmRoles\n        updateScopeRealmRoles();\n\n        // Send request for retrieve accessToken (in case user was selected)\n        if (client.protocol === 'openid-connect' && $scope.userId != null && $scope.userId !== '') {\n            var exampleRequestParams = {\n                realm: realm.realm,\n                client: client.id,\n                userId: $scope.userId,\n                scopeParam: $scope.scopeParam\n            };\n\n            var accessTokenUrl = ClientEvaluateGenerateExampleAccessToken.url(exampleRequestParams);\n            getPrettyJsonResponse(accessTokenUrl).then(function (result) {\n                $scope.oidcAccessToken = result;\n            });\n\n            var idTokenUrl = ClientEvaluateGenerateExampleIDToken.url(exampleRequestParams);\n            getPrettyJsonResponse(idTokenUrl).then(function (result) {\n                $scope.oidcIDToken = result;\n            });\n\n            var userInfoUrl = ClientEvaluateGenerateExampleUserInfo.url(exampleRequestParams);\n            getPrettyJsonResponse(userInfoUrl).then(function (result) {\n                $scope.oidcUserInfo = result;\n            });\n        }\n\n        $scope.showTab(1);\n    };\n\n    function getPrettyJsonResponse(url) {\n        return $http.get(url).then(function (response) {\n            if (response.data) {\n                var responseJson = angular.fromJson(response.data);\n                return angular.toJson(responseJson, true);\n            } else {\n                return null;\n            }\n        });\n    }\n\n    $scope.isResponseAvailable = function () {\n        return $scope.protocolMappers != null;\n    }\n\n    $scope.isAccessTokenAvailable = function () {\n        return $scope.oidcAccessToken != null;\n    }\n\n    $scope.isIDTokenAvailable = function () {\n        return $scope.oidcIDToken != null;\n    }\n\n    $scope.isUserInfoAvailable = function () {\n        return $scope.oidcUserInfo != null;\n    }\n\n    $scope.showTab = function (tab) {\n        $scope.selectedTab = tab;\n\n        $scope.tabCss = {\n            tab1: getTabCssClass(1, tab),\n            tab2: getTabCssClass(2, tab),\n            tab3: getTabCssClass(3, tab),\n            tab4: getTabCssClass(4, tab),\n            tab5: getTabCssClass(5, tab)\n        }\n    }\n\n    function getTabCssClass(tabNo, selectedTab) {\n        return (tabNo === selectedTab) ? 'active' : '';\n    }\n\n    $scope.protocolMappersShown = function () {\n        return $scope.selectedTab === 1;\n    }\n\n    $scope.rolesShown = function () {\n        return $scope.selectedTab === 2;\n    }\n\n    $scope.exampleTabInfo = function() {\n        switch ($scope.selectedTab) {\n            case 3:\n                return { isShown: true, value: $scope.oidcAccessToken}\n            case 4:\n                return { isShown: true, value: $scope.oidcIDToken}\n            case 5:\n                return { isShown: true, value: $scope.oidcUserInfo}\n            default:\n                return { isShown: false, value: null}\n        }\n    }\n\n    $scope.sortMappersByPriority = function(mapper) {\n        return $scope.mapperTypes[mapper.protocolMapper].priority;\n    }\n\n\n    // Roles\n\n    function updateScopeRealmRoles() {\n        $scope.grantedRealmRoles = ClientEvaluateGrantedRoles.query({\n            realm: realm.realm,\n            client: client.id,\n            roleContainer: realm.realm,\n            scopeParam: $scope.scopeParam\n        });\n        $scope.notGrantedRealmRoles = ClientEvaluateNotGrantedRoles.query({\n            realm: realm.realm,\n            client: client.id,\n            roleContainer: realm.realm,\n            scopeParam: $scope.scopeParam\n        });\n    }\n\n    function updateScopeClientRoles() {\n        if ($scope.selectedClient) {\n            $scope.grantedClientRoles = ClientEvaluateGrantedRoles.query({\n                realm: realm.realm,\n                client: client.id,\n                roleContainer: $scope.selectedClient.id,\n                scopeParam: $scope.scopeParam\n            });\n            $scope.notGrantedClientRoles = ClientEvaluateNotGrantedRoles.query({\n                realm: realm.realm,\n                client: client.id,\n                roleContainer: $scope.selectedClient.id,\n                scopeParam: $scope.scopeParam\n            });\n        } else {\n            $scope.grantedClientRoles = null;\n            $scope.notGrantedClientRoles = null;\n        }\n    }\n});\n\n\nmodule.controller('ClientScopeTabCtrl', function(Dialog, $scope, Current, Notifications, $location) {\n    $scope.removeClientScope = function() {\n        Dialog.confirmDelete($scope.clientScope.name, 'client scope', function() {\n            $scope.clientScope.$remove({\n                realm : Current.realm.realm,\n                clientScope : $scope.clientScope.id\n            }, function() {\n                $location.url(\"/realms/\" + Current.realm.realm + \"/client-scopes\");\n                Notifications.success(\"The client scope has been deleted.\");\n            });\n        });\n    };\n});\n\n\n\nmodule.controller('ClientScopeListCtrl', function($scope, realm, clientScopes, ClientScope, serverInfo, $route, Dialog, Notifications, $location) {\n    $scope.realm = realm;\n    $scope.clientScopes = clientScopes;\n\n    $scope.removeClientScope = function(clientScope) {\n        Dialog.confirmDelete(clientScope.name, 'client scope', function() {\n            ClientScope.remove({\n                realm : realm.realm,\n                clientScope : clientScope.id\n            }, function() {\n                $route.reload();\n                Notifications.success(\"The client scope been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('ClientScopesRealmDefaultCtrl', function($scope, realm, Realm, clientScopes, realmDefaultClientScopes, RealmDefaultClientScopes,\n        realmOptionalClientScopes, RealmOptionalClientScopes, serverInfo, $route, Dialog, Notifications, $location) {\n\n    console.log('ClientScopesRealmDefaultCtrl');\n\n    $scope.realm = realm;\n    $scope.realmDefaultClientScopes = realmDefaultClientScopes;\n    $scope.realmOptionalClientScopes = realmOptionalClientScopes;\n\n    $scope.availableClientScopes = [];\n    $scope.selectedDefaultClientScopes = [];\n    $scope.selectedDefDefaultClientScopes = [];\n\n    $scope.selectedOptionalClientScopes = [];\n    $scope.selectedDefOptionalClientScopes = [];\n\n    // Populate available client scopes. Available client scopes are neither already assigned to 'default' or 'optional'\n    for (var i = 0; i < clientScopes.length; i++) {\n        var scopeName = clientScopes[i].name;\n\n        var available = true;\n        for (var j = 0; j < $scope.realmDefaultClientScopes.length; j++) {\n            if (scopeName === $scope.realmDefaultClientScopes[j].name) {\n                available = false;\n            }\n        }\n        for (var j = 0; j < $scope.realmOptionalClientScopes.length; j++) {\n            if (scopeName === $scope.realmOptionalClientScopes[j].name) {\n                available = false;\n            }\n        }\n\n        if (available) {\n            $scope.availableClientScopes.push(clientScopes[i]);\n        }\n    }\n\n    $scope.addDefaultClientScope = function () {\n        $scope.selectedDefaultClientScopesToAdd = JSON.parse('[' + $scope.selectedDefaultClientScopes + ']');\n        toAdd = $scope.selectedDefaultClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedDefaultClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedDefaultClientScopesToAdd[i];\n\n            RealmDefaultClientScopes.update({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                console.log('toAdd: ' + toAdd);\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefaultClientScopesToAdd = [];\n    };\n\n    $scope.deleteDefaultClientScope = function () {\n        $scope.selectedDefDefaultClientScopesToRemove = JSON.parse('[' + $scope.selectedDefDefaultClientScopes + ']');\n        toRemove = $scope.selectedDefDefaultClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefDefaultClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefDefaultClientScopesToRemove[i];\n\n            RealmDefaultClientScopes.remove({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm default scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefDefaultClientScopesToRemove = [];\n    };\n\n    $scope.addOptionalClientScope = function () {\n        $scope.selectedOptionalClientScopesToAdd = JSON.parse('[' + $scope.selectedOptionalClientScopes + ']');\n        toAdd = $scope.selectedOptionalClientScopesToAdd.length;\n\n        for (var i = 0; i < $scope.selectedOptionalClientScopesToAdd.length; i++) {\n            var currentScope = $scope.selectedOptionalClientScopesToAdd[i];\n\n            RealmOptionalClientScopes.update({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toAdd = toAdd - 1;\n                console.log('toAdd: ' + toAdd);\n                if (toAdd === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm optional scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedOptionalClientScopesToAdd = [];\n    };\n\n    $scope.deleteOptionalClientScope = function () {\n        $scope.selectedDefOptionalClientScopesToRemove = JSON.parse('[' + $scope.selectedDefOptionalClientScopes + ']');\n        toRemove = $scope.selectedDefOptionalClientScopesToRemove.length;\n\n        for (var i = 0; i < $scope.selectedDefOptionalClientScopesToRemove.length; i++) {\n            var currentScope = $scope.selectedDefOptionalClientScopesToRemove[i];\n\n            RealmOptionalClientScopes.remove({\n                realm : realm.realm,\n                clientScopeId : currentScope.id\n            }, function () {\n                toRemove = toRemove - 1;\n                if (toRemove === 0) {\n                    $route.reload();\n                    Notifications.success(\"Realm optional scopes updated.\");\n                }\n            });\n        }\n        $scope.selectedDefOptionalClientScopesToRemove = [];\n    };\n});\n\nmodule.controller('ClientScopeDetailCtrl', function($scope, realm, clientScope, $route, serverInfo, ClientScope, $location, $modal, Dialog, Notifications) {\n    $scope.protocols = serverInfo.listProviderIds('login-protocol');\n\n    $scope.realm = realm;\n    $scope.create = !clientScope.name;\n\n    function updateProperties() {\n        if (!$scope.clientScope.attributes) {\n            $scope.clientScope.attributes = {};\n        }\n\n        if ($scope.clientScope.protocol) {\n            $scope.protocol = $scope.protocols[$scope.protocols.indexOf($scope.clientScope.protocol)];\n        } else {\n            $scope.protocol = $scope.protocols[0];\n        }\n\n        if ($scope.clientScope.attributes[\"display.on.consent.screen\"]) {\n            if ($scope.clientScope.attributes[\"display.on.consent.screen\"] == \"true\") {\n                $scope.displayOnConsentScreen = true;\n            } else {\n                $scope.displayOnConsentScreen = false;\n            }\n        } else {\n            $scope.displayOnConsentScreen = true;\n        }\n\n        if(serverInfo.featureEnabled(\"DYNAMIC_SCOPES\")) {\n            if ($scope.clientScope.attributes[\"is.dynamic.scope\"]) {\n                if ($scope.clientScope.attributes[\"is.dynamic.scope\"] === \"true\") {\n                    $scope.isDynamicScope = true;\n                } else {\n                    $scope.isDynamicScope = false;\n                }\n            } else {\n                $scope.isDynamicScope = false;\n            }\n\n            $scope.clientScope.attributes[\"dynamic.scope.regexp\"] = $scope.clientScope.name + \":*\";\n        }\n\n        if ($scope.clientScope.attributes[\"include.in.token.scope\"]) {\n            if ($scope.clientScope.attributes[\"include.in.token.scope\"] == \"true\") {\n                $scope.includeInTokenScope = true;\n            } else {\n                $scope.includeInTokenScope = false;\n            }\n        } else {\n            $scope.includeInTokenScope = true;\n        }\n    }\n\n    if (!$scope.create) {\n        $scope.clientScope = angular.copy(clientScope);\n    } else {\n        $scope.clientScope = {};\n    }\n\n    updateProperties();\n\n\n    $scope.switchChange = function() {\n        $scope.changed = true;\n    }\n\n    $scope.changeProtocol = function() {\n        if ($scope.protocol == \"openid-connect\") {\n            $scope.clientScope.protocol = \"openid-connect\";\n        } else if ($scope.protocol == \"saml\") {\n            $scope.clientScope.protocol = \"saml\";\n        }\n    };\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    function isChanged() {\n        if (!angular.equals($scope.clientScope, clientScope)) {\n            return true;\n        }\n        return false;\n    }\n\n    $scope.$watch('clientScope', function() {\n        $scope.changed = isChanged();\n    }, true);\n\n    $scope.save = function() {\n        $scope.clientScope.protocol = $scope.protocol;\n\n        if ($scope.displayOnConsentScreen == true) {\n            $scope.clientScope.attributes[\"display.on.consent.screen\"] = \"true\";\n        } else {\n            $scope.clientScope.attributes[\"display.on.consent.screen\"] = \"false\";\n        }\n\n        if(serverInfo.featureEnabled(\"DYNAMIC_SCOPES\")) {\n            if ($scope.isDynamicScope === true) {\n                $scope.clientScope.attributes[\"is.dynamic.scope\"] = \"true\";\n            } else {\n                $scope.clientScope.attributes[\"is.dynamic.scope\"] = \"false\";\n            }\n        }\n\n        if ($scope.includeInTokenScope == true) {\n            $scope.clientScope.attributes[\"include.in.token.scope\"] = \"true\";\n        } else {\n            $scope.clientScope.attributes[\"include.in.token.scope\"] = \"false\";\n        }\n\n        if ($scope.create) {\n            ClientScope.save({\n                realm: realm.realm,\n                clientScope: ''\n            }, $scope.clientScope, function (data, headers) {\n                $scope.changed = false;\n                var l = headers().location;\n                var id = l.substring(l.lastIndexOf(\"/\") + 1);\n                $location.url(\"/realms/\" + realm.realm + \"/client-scopes/\" + id);\n                Notifications.success(\"The client scope has been created.\");\n            });\n        } else {\n            ClientScope.update({\n                realm : realm.realm,\n                clientScope : clientScope.id\n            }, $scope.clientScope, function() {\n                $scope.changed = false;\n                clientScope = angular.copy($scope.clientScope);\n                $location.url(\"/realms/\" + realm.realm + \"/client-scopes/\" + clientScope.id);\n                Notifications.success(\"Your changes have been saved to the client scope.\");\n            });\n        }\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        $location.url(\"/realms/\" + realm.realm + \"/client-scopes\");\n    };\n});\n\nmodule.controller('ClientScopeProtocolMapperListCtrl', function($scope, realm, clientScope, serverInfo,\n                                                           ClientScopeProtocolMappersByProtocol, ClientScopeProtocolMapper,\n                                                           $route, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.clientScope = clientScope;\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[clientScope.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n    $scope.removeMapper = function(mapper) {\n        console.debug(mapper);\n        Dialog.confirmDelete(mapper.name, 'mapper', function() {\n            ClientScopeProtocolMapper.remove({ realm: realm.realm, clientScope: clientScope.id, id : mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $route.reload();\n            });\n        });\n    };\n\n    $scope.sortMappersByPriority = function(mapper) {\n        return $scope.mapperTypes[mapper.protocolMapper].priority;\n    }\n\n    var updateMappers = function() {\n        $scope.mappers = ClientScopeProtocolMappersByProtocol.query({realm : realm.realm, clientScope : clientScope.id, protocol : clientScope.protocol});\n    };\n\n    updateMappers();\n});\n\nmodule.controller('ClientScopeProtocolMapperCtrl', function($scope, realm, serverInfo, clientScope, mapper, clients, ClientScopeProtocolMapper, Notifications, Dialog, $location, $route) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n\n    $scope.model = {\n        realm: realm,\n        clientScope: clientScope,\n        create: false,\n        protocol: clientScope.protocol,\n        mapper: angular.copy(mapper),\n        changed: false\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[clientScope.protocol];\n    for (var i = 0; i < protocolMappers.length; i++) {\n        if (protocolMappers[i].id == mapper.protocolMapper) {\n            $scope.model.mapperType = protocolMappers[i];\n        }\n    }\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.$watch('model.mapper', function() {\n        if (!angular.equals($scope.model.mapper, mapper)) {\n            $scope.model.changed = true;\n        }\n    }, true);\n\n    $scope.save = function() {\n        ClientScopeProtocolMapper.update({\n            realm : realm.realm,\n            clientScope: clientScope.id,\n            id : mapper.id\n        }, $scope.model.mapper, function() {\n            $route.reload();\n            Notifications.success(\"Your changes have been saved.\");\n        });\n    };\n\n    $scope.reset = function() {\n        $scope.model.mapper = angular.copy(mapper);\n        $scope.model.changed = false;\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n    $scope.remove = function() {\n        Dialog.confirmDelete($scope.model.mapper.name, 'mapper', function() {\n            ClientScopeProtocolMapper.remove({ realm: realm.realm, clientScope: clientScope.id, id : $scope.model.mapper.id }, function() {\n                Notifications.success(\"The mapper has been deleted.\");\n                $location.url(\"/realms/\" + realm.realm + '/client-scopes/' + clientScope.id + \"/mappers\");\n            });\n        });\n    };\n\n});\n\nmodule.controller('ClientScopeProtocolMapperCreateCtrl', function($scope, realm, serverInfo, clientScope, clients, ClientScopeProtocolMapper, Notifications, Dialog, $location) {\n    $scope.realm = realm;\n    $scope.clients = clients;\n\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n    var protocol = clientScope.protocol;\n    $scope.model = {\n        realm: realm,\n        clientScope: clientScope,\n        create: true,\n        protocol: clientScope.protocol,\n        mapper: { protocol :  clientScope.protocol, config: {}},\n        changed: false,\n        mapperTypes: serverInfo.protocolMapperTypes[protocol]\n    }\n\n    // apply default configurations on change for selected protocolmapper type.\n    $scope.$watch('model.mapperType', function() {\n        var currentMapperType = $scope.model.mapperType;\n        var defaultConfig = {};\n\n        if (currentMapperType && Array.isArray(currentMapperType.properties)) {\n            for (var i = 0; i < currentMapperType.properties.length; i++) {\n                var property = currentMapperType.properties[i];\n                if (property && property.name && property.defaultValue) {\n                    defaultConfig[property.name] = property.defaultValue;\n                }\n            }\n        }\n\n        $scope.model.mapper.config = defaultConfig;\n    }, true);\n\n    $scope.model.mapperType = $scope.model.mapperTypes[0];\n\n    $scope.$watch(function() {\n        return $location.path();\n    }, function() {\n        $scope.path = $location.path().substring(1).split(\"/\");\n    });\n\n    $scope.save = function() {\n        $scope.model.mapper.protocolMapper = $scope.model.mapperType.id;\n        ClientScopeProtocolMapper.save({\n            realm : realm.realm, clientScope: clientScope.id\n        }, $scope.model.mapper, function(data, headers) {\n            var l = headers().location;\n            var id = l.substring(l.lastIndexOf(\"/\") + 1);\n            $location.url(\"/realms/\" + realm.realm + '/client-scopes/' + clientScope.id + \"/mappers/\" + id);\n            Notifications.success(\"Mapper has been created.\");\n        });\n    };\n\n    $scope.cancel = function() {\n        //$location.url(\"/realms\");\n        window.history.back();\n    };\n\n\n});\n\nmodule.controller('ClientScopeAddBuiltinProtocolMapperCtrl', function($scope, realm, clientScope, serverInfo,\n                                                           ClientScopeProtocolMappersByProtocol,\n                                                           $http, $location, Dialog, Notifications) {\n    $scope.realm = realm;\n    $scope.clientScope = clientScope;\n    if (clientScope.protocol == null) {\n        clientScope.protocol = 'openid-connect';\n    }\n\n    var protocolMappers = serverInfo.protocolMapperTypes[clientScope.protocol];\n    var mapperTypes = {};\n    for (var i = 0; i < protocolMappers.length; i++) {\n        mapperTypes[protocolMappers[i].id] = protocolMappers[i];\n    }\n    $scope.mapperTypes = mapperTypes;\n\n\n\n\n    var updateMappers = function() {\n        var clientMappers = ClientScopeProtocolMappersByProtocol.query({realm : realm.realm, clientScope : clientScope.id, protocol : clientScope.protocol}, function() {\n            var builtinMappers = serverInfo.builtinProtocolMappers[clientScope.protocol];\n            for (var i = 0; i < clientMappers.length; i++) {\n                for (var j = 0; j < builtinMappers.length; j++) {\n                    if (builtinMappers[j].name == clientMappers[i].name\n                        && builtinMappers[j].protocolMapper == clientMappers[i].protocolMapper) {\n                        builtinMappers.splice(j, 1);\n                        break;\n                    }\n                }\n            }\n            $scope.mappers = builtinMappers;\n            for (var i = 0; i < $scope.mappers.length; i++) {\n                $scope.mappers[i].isChecked = false;\n            }\n\n\n        });\n    };\n\n    updateMappers();\n\n    $scope.add = function() {\n        var toAdd = [];\n        for (var i = 0; i < $scope.mappers.length; i++) {\n            if ($scope.mappers[i].isChecked) {\n                delete $scope.mappers[i].isChecked;\n                toAdd.push($scope.mappers[i]);\n            }\n        }\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id + '/protocol-mappers/add-models',\n            toAdd).then(function() {\n                Notifications.success(\"Mappers added\");\n                $location.url('/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/mappers');\n            }).catch(function() {\n                Notifications.error(\"Error adding mappers\");\n                $location.url('/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/mappers');\n            });\n    };\n\n});\n\n\nmodule.controller('ClientScopeScopeMappingCtrl', function($scope, $http, $route, realm, clientScope, Notifications,\n                                                     ClientScope, Client,\n                                                     ClientScopeRealmScopeMapping, ClientScopeClientScopeMapping, ClientRole,\n                                                     ClientScopeAvailableRealmScopeMapping, ClientScopeAvailableClientScopeMapping,\n                                                     ClientScopeCompositeRealmScopeMapping, ClientScopeCompositeClientScopeMapping) {\n    $scope.realm = realm;\n    $scope.clientScope = angular.copy(clientScope);\n    $scope.selectedRealmRoles = [];\n    $scope.selectedRealmMappings = [];\n    $scope.realmMappings = [];\n    $scope.clientRoles = [];\n    $scope.clientComposite = [];\n    $scope.selectedClientRoles = [];\n    $scope.selectedClientMappings = [];\n    $scope.clientMappings = [];\n    $scope.dummymodel = [];\n    $scope.selectedClient = null;\n\n    function updateScopeRealmRoles() {\n        $scope.realmRoles = ClientScopeAvailableRealmScopeMapping.query({realm : realm.realm, clientScope : clientScope.id});\n        $scope.realmMappings = ClientScopeRealmScopeMapping.query({realm : realm.realm, clientScope : clientScope.id});\n        $scope.realmComposite = ClientScopeCompositeRealmScopeMapping.query({realm : realm.realm, clientScope : clientScope.id});\n    }\n\n    function updateScopeClientRoles() {\n        if ($scope.selectedClient) {\n            $scope.clientRoles = ClientScopeAvailableClientScopeMapping.query({realm : realm.realm, clientScope : clientScope.id, targetClient : $scope.selectedClient.id});\n            $scope.clientMappings = ClientScopeClientScopeMapping.query({realm : realm.realm, clientScope : clientScope.id, targetClient : $scope.selectedClient.id});\n            $scope.clientComposite = ClientScopeCompositeClientScopeMapping.query({realm : realm.realm, clientScope : clientScope.id, targetClient : $scope.selectedClient.id});\n        } else {\n            $scope.clientRoles = null;\n            $scope.clientMappings = null;\n            $scope.clientComposite = null;\n        }\n    }\n\n    $scope.changeClient = function(client) {\n        if (!client || !client.id) {\n            $scope.selectedClient = null;\n            return;\n        }\n        $scope.selectedClient = client;\n        updateScopeClientRoles();\n    };\n\n    $scope.addRealmRole = function() {\n        $scope.selectedRealmRolesToAdd = JSON.parse('[' + $scope.selectedRealmRoles + ']');\n        $scope.selectedRealmRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id + '/scope-mappings/realm',\n            $scope.selectedRealmRolesToAdd).then(function() {\n                updateScopeRealmRoles();\n                $scope.selectedRealmRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteRealmRole = function() {\n        $scope.selectedRealmMappingsToRemove = JSON.parse('[' + $scope.selectedRealmMappings + ']');\n        $scope.selectedRealmMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/scope-mappings/realm',\n            {data : $scope.selectedRealmMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateScopeRealmRoles();\n                $scope.selectedRealmMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.addClientRole = function() {\n        $scope.selectedClientRolesToAdd = JSON.parse('[' + $scope.selectedClientRoles + ']');\n        $scope.selectedClientRoles = [];\n        $http.post(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n            $scope.selectedClientRolesToAdd).then(function () {\n                updateScopeClientRoles();\n                $scope.selectedClientRolesToAdd = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    $scope.deleteClientRole = function() {\n        $scope.selectedClientMappingsToRemove = JSON.parse('[' + $scope.selectedClientMappings + ']');\n        $scope.selectedClientMappings = [];\n        $http.delete(authUrl + '/admin/realms/' + realm.realm + '/client-scopes/' + clientScope.id +  '/scope-mappings/clients/' + $scope.selectedClient.id,\n            {data : $scope.selectedClientMappingsToRemove, headers : {\"content-type\" : \"application/json\"}}).then(function () {\n                updateScopeClientRoles();\n                $scope.selectedClientMappingsToRemove = [];\n                Notifications.success(\"Scope mappings updated.\");\n            });\n    };\n\n    clientSelectControl($scope, $route.current.params.realm, Client);\n    updateScopeRealmRoles();\n});\n\nmodule.controller('ClientStoresCtrl', function($scope, $location, $route, realm, serverInfo, Components, Notifications, Dialog) {\n    console.log('ClientStoresCtrl ++++****');\n    $scope.realm = realm;\n    $scope.providers = serverInfo.componentTypes['org.keycloak.storage.client.ClientStorageProvider'];\n    $scope.clientStorageProviders = serverInfo.componentTypes['org.keycloak.storage.client.ClientStorageProvider'];\n    $scope.instancesLoaded = false;\n\n    if (!$scope.providers) $scope.providers = [];\n\n    $scope.addProvider = function(provider) {\n        console.log('Add provider: ' + provider.id);\n        $location.url(\"/create/client-storage/\" + realm.realm + \"/providers/\" + provider.id);\n    };\n\n    $scope.getInstanceLink = function(instance) {\n        return \"/realms/\" + realm.realm + \"/client-storage/providers/\" + instance.providerId + \"/\" + instance.id;\n    }\n\n    $scope.getInstanceName = function(instance) {\n        return instance.name;\n    }\n    $scope.getInstanceProvider = function(instance) {\n        return instance.providerId;\n    }\n\n    $scope.isProviderEnabled = function(instance) {\n        return !instance.config['enabled'] || instance.config['enabled'][0] == 'true';\n    }\n\n    $scope.getInstancePriority = function(instance) {\n        if (!instance.config['priority']) {\n            return \"0\";\n        }\n        return instance.config['priority'][0];\n    }\n\n    Components.query({realm: realm.realm,\n        parent: realm.id,\n        type: 'org.keycloak.storage.client.ClientStorageProvider'\n    }, function(data) {\n        $scope.instances = data;\n        $scope.instancesLoaded = true;\n    });\n\n    $scope.removeInstance = function(instance) {\n        Dialog.confirmDelete(instance.name, 'client storage provider', function() {\n            Components.remove({\n                realm : realm.realm,\n                componentId : instance.id\n            }, function() {\n                $route.reload();\n                Notifications.success(\"The provider has been deleted.\");\n            });\n        });\n    };\n});\n\nmodule.controller('GenericClientStorageCtrl', function($scope, $location, Notifications, $route, Dialog, realm,\n                                                     serverInfo, instance, providerId, Components) {\n    console.log('GenericClientStorageCtrl');\n    console.log('providerId: ' + providerId);\n    $scope.create = !instance.providerId;\n    console.log('create: ' + $scope.create);\n    var providers = serverInfo.componentTypes['org.keycloak.storage.client.ClientStorageProvider'];\n    console.log('providers length ' + providers.length);\n    var providerFactory = null;\n    for (var i = 0; i < providers.length; i++) {\n        var p = providers[i];\n        console.log('provider: ' + p.id);\n        if (p.id == providerId) {\n            $scope.providerFactory = p;\n            providerFactory = p;\n            break;\n        }\n\n    }\n    $scope.changed = false;\n\n    console.log(\"providerFactory: \" + providerFactory.id);\n\n    function initClientStorageSettings() {\n        if ($scope.create) {\n            $scope.changed = true;\n            instance.name = providerFactory.id;\n            instance.providerId = providerFactory.id;\n            instance.providerType = 'org.keycloak.storage.client.ClientStorageProvider';\n            instance.parentId = realm.id;\n            instance.config = {\n\n            };\n            instance.config['priority'] = [\"0\"];\n            instance.config['enabled'] = [\"true\"];\n\n            $scope.fullSyncEnabled = false;\n            $scope.changedSyncEnabled = false;\n            instance.config['cachePolicy'] = ['DEFAULT'];\n            instance.config['evictionDay'] = [''];\n            instance.config['evictionHour'] = [''];\n            instance.config['evictionMinute'] = [''];\n            instance.config['maxLifespan'] = [''];\n            if (providerFactory.properties) {\n\n                for (var i = 0; i < providerFactory.properties.length; i++) {\n                    var configProperty = providerFactory.properties[i];\n                    if (configProperty.defaultValue) {\n                        instance.config[configProperty.name] = [configProperty.defaultValue];\n                    } else {\n                        instance.config[configProperty.name] = [''];\n                    }\n\n                }\n            }\n\n        } else {\n            $scope.changed = false;\n             if (!instance.config['enabled']) {\n                instance.config['enabled'] = ['true'];\n            }\n            if (!instance.config['cachePolicy']) {\n                instance.config['cachePolicy'] = ['DEFAULT'];\n\n            }\n            if (!instance.config['evictionDay']) {\n                instance.config['evictionDay'] = [''];\n\n            }\n            if (!instance.config['evictionHour']) {\n                instance.config['evictionHour'] = [''];\n\n            }\n            if (!instance.config['evictionMinute']) {\n                instance.config['evictionMinute'] = [''];\n\n            }\n            if (!instance.config['maxLifespan']) {\n                instance.config['maxLifespan'] = [''];\n\n            }\n            if (!instance.config['priority']) {\n                instance.config['priority'] = ['0'];\n            }\n\n            if (providerFactory.properties) {\n                for (var i = 0; i < providerFactory.properties.length; i++) {\n                    var configProperty = providerFactory.properties[i];\n                    if (!instance.config[configProperty.name]) {\n                        instance.config[configProperty.name] = [''];\n                    }\n                }\n            }\n\n        }\n    }\n\n    initClientStorageSettings();\n    $scope.instance = angular.copy(instance);\n    $scope.realm = realm;\n\n     $scope.$watch('instance', function() {\n        if (!angular.equals($scope.instance, instance)) {\n            $scope.changed = true;\n        }\n\n    }, true);\n\n    $scope.save = function() {\n        console.log('save provider');\n        $scope.changed = false;\n        if ($scope.create) {\n            console.log('saving new provider');\n            Components.save({realm: realm.realm}, $scope.instance,  function (data, headers) {\n                var l = headers().location;\n                var id = l.substring(l.lastIndexOf(\"/\") + 1);\n\n                $location.url(\"/realms/\" + realm.realm + \"/client-storage/providers/\" + $scope.instance.providerId + \"/\" + id);\n                Notifications.success(\"The provider has been created.\");\n            });\n        } else {\n            console.log('update existing provider');\n            Components.update({realm: realm.realm,\n                    componentId: instance.id\n                },\n                $scope.instance,  function () {\n                    $route.reload();\n                    Notifications.success(\"The provider has been updated.\");\n                });\n        }\n    };\n\n    $scope.reset = function() {\n        $route.reload();\n    };\n\n    $scope.cancel = function() {\n        console.log('cancel');\n        if ($scope.create) {\n            $location.url(\"/realms/\" + realm.realm + \"/client-stores\");\n        } else {\n            $route.reload();\n        }\n    };\n\n\n\n});\n\n\n", "<div class=\"col-sm-9 col-md-10 col-sm-push-3 col-md-push-2\">\n\n    <ol class=\"breadcrumb\">\n        <li><a href=\"#/realms/{{realm.realm}}/clients\">{{:: 'clients' | translate}}</a></li>\n        <li>{{client.clientId}}</li>\n    </ol>\n\n    <kc-tabs-client></kc-tabs-client>\n\n    <form class=\"form-horizontal\" name=\"clientForm\" novalidate kc-read-only=\"!client.access.configure\">\n        <fieldset class=\"border-top\">\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"clientId\">{{:: 'client-id' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"clientId\" name=\"clientId\" data-ng-model=\"clientEdit.clientId\" autofocus required>\n                </div>\n                <kc-tooltip>{{:: 'client-id.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"name\">{{:: 'name' | translate}} </label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"name\" name=\"name\" data-ng-model=\"clientEdit.name\" autofocus>\n                </div>\n                <kc-tooltip>{{:: 'client.name.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"description\">{{:: 'description' | translate}} </label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"description\" name=\"description\" data-ng-model=\"clientEdit.description\">\n                </div>\n                <kc-tooltip>{{:: 'client.description.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"enabled\">{{:: 'enabled' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.enabled\" name=\"enabled\" id=\"enabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'client.enabled.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"serverInfo.featureEnabled('ACCOUNT2') && !(accessType === 'bearer-only' && protocol === 'openid-connect')\">\n                <label class=\"col-md-2 control-label\" for=\"alwaysDisplayInConsole\">{{:: 'alwaysDisplayInConsole' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.alwaysDisplayInConsole\" name=\"alwaysDisplayInConsole\" id=\"alwaysDisplayInConsole\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'alwaysDisplayInConsole.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"client.origin\">\n                <label class=\"col-md-2 control-label\">{{:: 'client-origin-link' | translate}}</label>\n                <div class=\"col-md-6\">\n                    {{originName}}\n                </div>\n                <kc-tooltip>{{:: 'client-origin.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"consentRequired\">{{:: 'consent-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.consentRequired\" name=\"consentRequired\" id=\"consentRequired\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'consent-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"clientEdit.consentRequired && protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"displayOnConsentScreen\">{{:: 'client.display-on-consent-screen' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"displayOnConsentScreen\" ng-click=\"switchChange()\" name=\"displayOnConsentScreen\" id=\"displayOnConsentScreen\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'client.display-on-consent-screen.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"clientEdit.consentRequired && protocol != 'docker-v2' && displayOnConsentScreen\">\n                <label class=\"col-md-2 control-label\" for=\"consentScreenText\">{{:: 'client.consent-screen-text' | translate}} </label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" id=\"consentScreenText\" name=\"consentScreenText\" data-ng-model=\"clientEdit.attributes['consent.screen.text']\">\n                </div>\n                <kc-tooltip>{{:: 'client.consent-screen-text.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"loginTheme\">{{:: 'login-theme' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <select class=\"form-control\" id=\"loginTheme\"\n                            ng-model=\"clientEdit.attributes['login_theme']\"\n                            ng-options=\"o.name as o.name for o in serverInfo.themes.login\">\n                        <option value=\"\" selected></option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'login-theme.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\">\n                <label class=\"col-md-2 control-label\" for=\"protocol\">{{:: 'client-protocol' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"protocol\"\n                                ng-change=\"changeProtocol()\"\n                                ng-model=\"protocol\"\n                                ng-options=\"aProtocol for aProtocol in protocols\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'client-protocol.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"accessType\">{{:: 'access-type' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"accessType\"\n                                ng-change=\"changeAccessType()\"\n                                ng-model=\"accessType\"\n                                ng-options=\"aType for aType in accessTypes\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'access-type.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"standardFlowEnabled\">{{:: 'standard-flow-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'standard-flow-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.standardFlowEnabled\" name=\"standardFlowEnabled\" id=\"standardFlowEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"implicitFlowEnabled\">{{:: 'implicit-flow-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'implicit-flow-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.implicitFlowEnabled\" name=\"implicitFlowEnabled\" id=\"implicitFlowEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"directAccessGrantsEnabled\">{{:: 'direct-access-grants-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'direct-access-grants-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.directAccessGrantsEnabled\" name=\"directAccessGrantsEnabled\" id=\"directAccessGrantsEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"serviceAccountsEnabled\">{{:: 'service-accounts-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'service-accounts-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.serviceAccountsEnabled\" name=\"serviceAccountsEnabled\" id=\"serviceAccountsEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"oauth2DeviceAuthorizationGrantEnabled\">{{::\n                    'oauth2-device-authorization-grant-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'oauth2-device-authorization-grant-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"oauth2DeviceAuthorizationGrantEnabled\" ng-click=\"switchChange()\"\n                        name=\"oauth2DeviceAuthorizationGrantEnabled\" id=\"oauth2DeviceAuthorizationGrantEnabled\" onoffswitch\n                        on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\" />\n                </div>\n            </div>\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA')\">\n                <label class=\"col-md-2 control-label\" for=\"oidcCibaGrantEnabled\">{{::\n                    'oidc-ciba-grant-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'oidc-ciba-grant-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"oidcCibaGrantEnabled\" ng-click=\"switchChange()\"\n                        name=\"oidcCibaGrantEnabled\" id=\"oidcCibaGrantEnabled\" onoffswitch\n                        on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\" />\n                </div>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"serverInfo.featureEnabled('AUTHORIZATION') && protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationServicesEnabled\">{{:: 'authz-authorization-services-enabled' | translate}}</label>\n                <kc-tooltip>{{:: 'authz-authorization-services-enabled.tooltip' | translate}}</kc-tooltip>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"clientEdit.authorizationServicesEnabled\" ng-click=\"confirmChangeAuthzSettings($event)\" name=\"authorizationServicesEnabled\" id=\"authorizationServicesEnabled\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAuthnStatement\">{{:: 'include-authnstatement' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlAuthnStatement\" ng-click=\"switchChange()\" name=\"samlAuthnStatement\" id=\"samlAuthnStatement\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'include-authnstatement.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlOneTimeUseCondition\">{{:: 'include-onetimeuse-condition' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlOneTimeUseCondition\" ng-click=\"switchChange()\" name=\"samlOneTimeUseCondition\" id=\"samlOneTimeUseCondition\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'include-onetimeuse-condition.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlArtifactBinding\">{{:: 'artifact-binding' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlArtifactBinding\" ng-click=\"switchChange()\" name=\"samlArtifactBinding\" id=\"samlArtifactBinding\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'artifact-binding.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlServerSignature\">{{:: 'sign-documents' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlServerSignature\" ng-click=\"switchChange()\" name=\"samlServerSignature\" id=\"samlServerSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'sign-documents.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml' && samlServerSignature == true\">\n                <label class=\"col-md-2 control-label\" for=\"samlServerSignatureEnableKeyInfoExtension\">{{:: 'sign-documents-redirect-enable-key-info-ext' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlServerSignatureEnableKeyInfoExtension\" ng-click=\"switchChange()\" name=\"samlServerSignatureEnableKeyInfoExtension\" id=\"samlServerSignatureEnableKeyInfoExtension\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'sign-documents-redirect-enable-key-info-ext.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAssertionSignature\">{{:: 'sign-assertions' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlAssertionSignature\" ng-click=\"switchChange()\" name=\"samlAssertionSignature\" id=\"samlAssertionSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'sign-assertions.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"(samlAssertionSignature || samlServerSignature) && protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"signatureAlgorithm\">{{:: 'signature-algorithm' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"signatureAlgorithm\"\n                                ng-change=\"changeAlgorithm()\"\n                                ng-model=\"signatureAlgorithm\"\n                                ng-options=\"alg for alg in signatureAlgorithms\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'signature-algorithm.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"(samlAssertionSignature || samlServerSignature) && protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlSigKeyNameTranformer\">{{:: 'saml-signature-keyName-transformer' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"xmlKeyNameTranformer\"\n                                ng-change=\"changeSamlSigKeyNameTranformer()\"\n                                ng-model=\"samlXmlKeyNameTranformer\"\n                                ng-options=\"alg for alg in xmlKeyNameTranformers\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'saml-signature-keyName-transformer.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"(samlAssertionSignature || samlServerSignature) && protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"canonicalization\">{{:: 'canonicalization-method' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"canonicalization\"\n                                ng-model=\"clientEdit.attributes['saml_signature_canonicalization_method']\"\n                                ng-options=\"canon.value as canon.name for canon in canonicalization\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'canonicalization-method.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlEncrypt\">{{:: 'encrypt-assertions' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlEncrypt\" ng-click=\"switchChange()\" name=\"samlEncrypt\" id=\"samlEncrypt\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'encrypt-assertions.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlClientSignature\">{{:: 'client-signature-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlClientSignature\" ng-click=\"switchChange()\" name=\"samlClientSignature\" id=\"samlClientSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'client-signature-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlForcePostBinding\">{{:: 'force-post-binding' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlForcePostBinding\" ng-click=\"switchChange()\" name=\"samlForcePostBinding\" id=\"samlForcePostBinding\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'force-post-binding.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"frontchannelLogout\">{{:: 'front-channel-logout' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.frontchannelLogout\" name=\"frontchannelLogout\" id=\"frontchannelLogout\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'front-channel-logout.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && clientEdit.frontchannelLogout\">\n                <label class=\"col-md-2 control-label\" for=\"frontchannelLogoutUrl\">{{:: 'front-channel-logout-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"frontchannelLogoutUrl\" id=\"frontchannelLogoutUrl\" data-ng-model=\"clientEdit.attributes['frontchannel.logout.url']\">\n                </div>\n                <kc-tooltip>{{:: 'front-channel-logout-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && clientEdit.frontchannelLogout\">\n                <label class=\"col-md-2 control-label\" for=\"frontchannelLogoutSessionRequired\">{{:: 'front-channel-logout-session-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"frontchannelLogoutSessionRequired\" name=\"frontchannelLogoutSessionRequired\" id=\"frontchannelLogoutSessionRequired\" onoffswitch ng-click=\"switchChange()\" on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'front-channel-logout-session-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlForceNameIdFormat\">{{:: 'force-name-id-format' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlForceNameIdFormat\" ng-click=\"switchChange()\" name=\"samlForceNameIdFormat\" id=\"samlForceNameIdFormat\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'force-name-id-format.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAllowECPFlow\">{{:: 'allow-ecp-flow' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"samlAllowECPFlow\" ng-click=\"switchChange()\" name=\"samlAllowECPFlow\" id=\"samlAllowECPFlow\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'allow-ecp-flow.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlNameIdFormat\">{{:: 'name-id-format' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"samlNameIdFormat\"\n                                ng-change=\"changeNameIdFormat()\"\n                                ng-model=\"nameIdFormat\"\n                                ng-options=\"format for format in nameIdFormats\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'name-id-format.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"!clientEdit.bearerOnly && protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"rootUrl\">{{:: 'root-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"rootUrl\" id=\"rootUrl\" data-ng-model=\"clientEdit.rootUrl\">\n                </div>\n                <kc-tooltip>{{:: 'root-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-hide=\"clientEdit.bearerOnly || (!clientEdit.standardFlowEnabled && !clientEdit.implicitFlowEnabled) || protocol == 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"newRedirectUri\"><span class=\"required\" data-ng-show=\"protocol != 'saml'\">*</span> {{:: 'valid-redirect-uris' | translate}}</label>\n\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, redirectUri) in clientEdit.redirectUris track by $index\">\n                        <input class=\"form-control\" ng-model=\"clientEdit.redirectUris[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteRedirectUri($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newRedirectUri\" id=\"newRedirectUri\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newRedirectUri.length > 0 && addRedirectUri()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n\n                <kc-tooltip>{{:: 'valid-redirect-uris.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"!clientEdit.bearerOnly && protocol != 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"baseUrl\">{{:: 'base-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"baseUrl\" id=\"baseUrl\" data-ng-model=\"clientEdit.baseUrl\">\n                </div>\n                <kc-tooltip>{{:: 'base-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-hide=\"protocol == 'saml' || protocol == 'docker-v2'\">\n                <label class=\"col-md-2 control-label\" for=\"adminUrl\">{{:: 'admin-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"adminUrl\" id=\"adminUrl\"\n                           data-ng-model=\"clientEdit.adminUrl\">\n                </div>\n                <kc-tooltip>{{:: 'admin-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"masterSamlUrl\">{{:: 'master-saml-processing-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"masterSamlUrl\" id=\"masterSamlUrl\"\n                           data-ng-model=\"clientEdit.adminUrl\">\n                </div>\n                <kc-tooltip>{{:: 'master-saml-processing-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"urlReferenceName\">{{:: 'idp-sso-url-ref' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_idp_initiated_sso_url_name\" class=\"form-control\" type=\"text\" name=\"urlReferenceName\" id=\"urlReferenceName\" />\n                    <div data-ng-show=\"clientEdit.attributes.saml_idp_initiated_sso_url_name\">\n                        {{:: 'idp-sso-url-ref.urlhint' | translate}} {{samlIdpInitiatedUrl(clientEdit.attributes.saml_idp_initiated_sso_url_name)}}\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'idp-sso-url-ref.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"logoUri\">{{:: 'logo-uri' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"logoUri\" id=\"logoUri\" data-ng-model=\"clientEdit.attributes.logoUri\">\n                </div>\n                <kc-tooltip>{{:: 'logo-uri.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"policyUri\">{{:: 'policy-uri' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"policyUri\" id=\"policyUri\" data-ng-model=\"clientEdit.attributes.policyUri\">\n                </div>\n                <kc-tooltip>{{:: 'policy-uri.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml' || protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"tosUri\">{{:: 'tos-uri' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"tosUri\" id=\"tosUri\" data-ng-model=\"clientEdit.attributes.tosUri\">\n                </div>\n                <kc-tooltip>{{:: 'tos-uri.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"idpInitiatedRelayState\">{{:: 'idp-sso-relay-state' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_idp_initiated_sso_relay_state\" class=\"form-control\" type=\"text\" name=\"idpInitiatedRelayState\" id=\"idpInitiatedRelayState\" />\n                </div>\n                <kc-tooltip>{{:: 'idp-sso-relay-state.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"(!clientEdit.bearerOnly && protocol == 'openid-connect') && (clientEdit.standardFlowEnabled || clientEdit.directAccessGrantsEnabled || clientEdit.implicitFlowEnabled)\">\n                <label class=\"col-md-2 control-label\" for=\"newWebOrigin\">{{:: 'web-origins' | translate}}</label>\n\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, webOrigin) in clientEdit.webOrigins track by $index\">\n                        <input class=\"form-control\" ng-model=\"clientEdit.webOrigins[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteWebOrigin($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newWebOrigin\" id=\"newWebOrigin\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newWebOrigin.length > 0 && addWebOrigin()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n\n                <kc-tooltip>{{:: 'web-origins.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"backchannelLogoutUrl\">{{:: 'backchannel-logout-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input class=\"form-control\" type=\"text\" name=\"backchannelLogoutUrl\" id=\"backchannelLogoutUrl\" data-ng-model=\"clientEdit.attributes['backchannel.logout.url']\">\n                </div>\n                <kc-tooltip>{{:: 'backchannel-logout-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"backchannelLogoutSessionRequired\">{{:: 'backchannel-logout-session-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"backchannelLogoutSessionRequired\" name=\"backchannelLogoutSessionRequired\" id=\"backchannelLogoutSessionRequired\" onoffswitch ng-click=\"switchChange()\" on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'backchannel-logout-session-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly\">\n                <label class=\"col-md-2 control-label\" for=\"backchannelLogoutRevokeOfflineSessions\">{{:: 'backchannel-logout-revoke-offline-sessions' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"backchannelLogoutRevokeOfflineSessions\" name=\"backchannelLogoutRevokeOfflineSessions\" id=\"backchannelLogoutRevokeOfflineSessions\" onoffswitch ng-click=\"switchChange()\" on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'backchannel-logout-revoke-offline-sessions.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n        <fieldset data-ng-show=\"protocol == 'saml'\">\n            <legend collapsed><span class=\"text\">{{:: 'fine-saml-endpoint-conf' | translate}}</span>  <kc-tooltip>{{:: 'fine-saml-endpoint-conf.tooltip' | translate}}</kc-tooltip></legend>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"consumerServicePost\">{{:: 'assertion-consumer-post-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_assertion_consumer_url_post\" class=\"form-control\" type=\"text\" name=\"consumerServicePost\" id=\"consumerServicePost\" />\n                </div>\n                <kc-tooltip>{{:: 'assertion-consumer-post-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"consumerServiceRedirect\">{{:: 'assertion-consumer-redirect-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_assertion_consumer_url_redirect\" class=\"form-control\" type=\"text\" name=\"consumerServiceRedirect\" id=\"consumerServiceRedirect\" />\n                </div>\n                <kc-tooltip>{{:: 'assertion-consumer-redirect-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"logoutPostBinding\">{{:: 'logout-service-post-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_single_logout_service_url_post\" class=\"form-control\" type=\"text\" name=\"logoutPostBinding\" id=\"logoutPostBinding\" />\n                </div>\n                <kc-tooltip>{{:: 'logout-service-post-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"logoutRedirectBinding\">{{:: 'logout-service-redir-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_single_logout_service_url_redirect\" class=\"form-control\" type=\"text\" name=\"logoutRedirectBinding\" id=\"logoutRedirectBinding\" />\n                </div>\n                <kc-tooltip>{{:: 'logout-service-redir-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"logoutArtifactBinding\">{{:: 'logout-service-artifact-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_single_logout_service_url_artifact\" class=\"form-control\" type=\"text\" name=\"logoutRedirectBinding\" id=\"logoutArtifactBinding\" />\n                </div>\n                <kc-tooltip>{{:: 'logout-service-artifact-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"artifactBindingUrl\">{{:: 'artifact-binding-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_artifact_binding_url\" class=\"form-control\" type=\"text\" name=\"artifactBindingUrl\" id=\"artifactBindingUrl\" />\n                </div>\n                <kc-tooltip>{{:: 'artifact-binding-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"artifactResolutionServiceUrl\">{{:: 'artifact-resolution-service-url' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes.saml_artifact_resolution_service_url\" class=\"form-control\" type=\"text\" name=\"artifactResolutionServiceUrl\" id=\"artifactResolutionServiceUrl\" />\n                </div>\n                <kc-tooltip>{{:: 'artifact-resolution-service-url.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n        <fieldset data-ng-show=\"protocol == 'openid-connect'\">\n            <legend collapsed><span class=\"text\">{{:: 'fine-oidc-endpoint-conf' | translate}}</span>  <kc-tooltip>{{:: 'fine-oidc-endpoint-conf.tooltip' | translate}}</kc-tooltip></legend>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"accessTokenSignedResponseAlg\">{{:: 'access-token-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"accessTokenSignedResponseAlg\"\n                                ng-change=\"changeAccessTokenSignedResponseAlg()\"\n                                ng-model=\"accessTokenSignedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'access-token-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"idTokenSignedResponseAlg\">{{:: 'id-token-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"idTokenSignedResponseAlg\"\n                                ng-change=\"changeIdTokenSignedResponseAlg()\"\n                                ng-model=\"idTokenSignedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'id-token-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"idTokenEncryptedResponseAlg\">{{:: 'id-token-encrypted-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"idTokenEncryptedResponseAlg\"\n                                ng-change=\"changeIdTokenEncryptedResponseAlg()\"\n                                ng-model=\"idTokenEncryptedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('cekmanagement')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'id-token-encrypted-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"idTokenEncryptedResponseEnc\">{{:: 'id-token-encrypted-response-enc' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"idTokenEncryptedResponseEnc\"\n                                ng-change=\"changeIdTokenEncryptedResponseEnc()\"\n                                ng-model=\"idTokenEncryptedResponseEnc\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('contentencryption')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'id-token-encrypted-response-enc.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"userInfoSignedResponseAlg\">{{:: 'user-info-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"userInfoSignedResponseAlg\"\n                                ng-change=\"changeUserInfoSignedResponseAlg()\"\n                                ng-model=\"userInfoSignedResponseAlg\">\n                            <option value=\"unsigned\">unsigned</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'user-info-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requestObjectSignatureAlg\">{{:: 'request-object-signature-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectSignatureAlg\"\n                                ng-change=\"changeRequestObjectSignatureAlg()\"\n                                ng-model=\"requestObjectSignatureAlg\">\n                            <option value=\"any\">any</option>\n                            <option value=\"none\">none</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('clientSignature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-signature-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requestObjectEncryptionAlg\">{{:: 'request-object-encryption-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectEncryptionAlg\"\n                                ng-change=\"changeRequestObjectEncryptionAlg()\"\n                                ng-model=\"requestObjectEncryptionAlg\">\n                            <option value=\"any\">any</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('cekmanagement')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-encryption-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requestObjectEncryptionEnc\">{{:: 'request-object-encryption-enc' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectEncryptionEnc\"\n                                ng-change=\"changeRequestObjectEncryptionEnc()\"\n                                ng-model=\"requestObjectEncryptionEnc\">\n                            <option value=\"any\">any</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('contentencryption')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-encryption-enc.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"changeRequestObjectRequired\">{{:: 'request-object-required' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"requestObjectRequired\"\n                                ng-change=\"changeRequestObjectRequired()\"\n                                ng-model=\"requestObjectRequired\"\n                                ng-options=\"sig for sig in requestObjectRequiredOptions\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-object-required.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA') && oidcCibaGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"cibaBackchannelTokenDeliveryMode\">{{:: 'ciba-backchannel-token-delivery-mode' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"cibaBackchannelTokenDeliveryMode\"\n                                ng-change=\"changeCibaBackchannelTokenDeliveryMode()\"\n                                ng-model=\"cibaBackchannelTokenDeliveryMode\">\n                            <option value=\"poll\">poll</option>\n                            <option value=\"ping\">ping</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'ciba-backchannel-token-delivery-mode.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA') && oidcCibaGrantEnabled == true && cibaBackchannelTokenDeliveryMode == 'ping'\">\n                <label class=\"col-md-2 control-label\" for=\"cibaBackchannelClientNotificationEndpoint\">{{:: 'ciba-backchannel-client-notification-endpoint' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"clientEdit.attributes['ciba.backchannel.client.notification.endpoint']\" class=\"form-control\" type=\"text\" name=\"cibaBackchannelClientNotificationEndpoint\" id=\"cibaBackchannelClientNotificationEndpoint\" />\n                </div>\n                <kc-tooltip>{{:: 'ciba-backchannel-client-notification-endpoint.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && !clientEdit.publicClient && !clientEdit.bearerOnly && serverInfo.featureEnabled('CIBA') && oidcCibaGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"cibaBackchannelAuthRequestSigningAlg\">{{:: 'ciba-backchannel-auth-request-signing-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"cibaBackchannelAuthRequestSigningAlg\"\n                                ng-change=\"changeCibaBackchannelAuthRequestSigningAlg()\"\n                                ng-model=\"cibaBackchannelAuthRequestSigningAlg\">\n                            <option value=\"any\">any</option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('clientSignature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'ciba-backchannel-auth-request-signing-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"newRequestUri\">{{:: 'request-uris' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, requestUri) in clientEdit.requestUris track by $index\">\n                        <input class=\"form-control\" ng-model=\"clientEdit.requestUris[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteRequestUri($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newRequestUri\" id=\"newRequestUri\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newRequestUri.length > 0 && addRequestUri()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'request-uris.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationSignedResponseAlg\">{{:: 'authorization-signed-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"authorizationSignedResponseAlg\"\n                                ng-change=\"changeAuthorizationSignedResponseAlg()\"\n                                ng-model=\"authorizationSignedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('signature')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'authorization-signed-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationEncryptedResponseAlg\">{{:: 'authorization-encrypted-response-alg' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"authorizationEncryptedResponseAlg\"\n                                ng-change=\"changeAuthorizationEncryptedResponseAlg()\"\n                                ng-model=\"authorizationEncryptedResponseAlg\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('cekmanagement')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'authorization-encrypted-response-alg.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\">\n                <label class=\"col-md-2 control-label\" for=\"authorizationEncryptedResponseEnc\">{{:: 'authorization-encrypted-response-enc' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"authorizationEncryptedResponseEnc\"\n                                ng-change=\"changeAuthorizationEncryptedResponseEnc()\"\n                                ng-model=\"authorizationEncryptedResponseEnc\">\n                            <option value=\"\"></option>\n                            <option ng-repeat=\"provider in serverInfo.listProviderIds('contentencryption')\" value=\"{{provider}}\">{{provider}}</option>\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'authorization-encrypted-response-enc.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n        <fieldset data-ng-show=\"protocol == 'openid-connect'\">\n            <legend collapsed><span class=\"text\">{{:: 'oidc-compatibility-modes' | translate}}</span>  <kc-tooltip>{{:: 'oidc-compatibility-modes.tooltip' | translate}}</kc-tooltip></legend>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"excludeSessionStateFromAuthResponse\">{{:: 'exclude-session-state-from-auth-response' | translate}}</label>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"excludeSessionStateFromAuthResponse\" ng-click=\"switchChange()\" name=\"excludeSessionStateFromAuthResponse\" id=\"excludeSessionStateFromAuthResponse\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'exclude-session-state-from-auth-response.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"useRefreshTokens\">{{:: 'use-refresh-tokens' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"useRefreshTokens\" ng-click=\"switchChange()\" name=\"useRefreshTokens\" id=\"useRefreshTokens\"\n                        onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\" />\n                </div>\n                <kc-tooltip>{{:: 'use-refresh-tokens.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"useRefreshTokenForClientCredentialsGrant\">{{:: 'use-refresh-token-for-client-credentials-grant' | translate}}</label>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"useRefreshTokenForClientCredentialsGrant\" ng-click=\"switchChange()\" name=\"useRefreshTokenForClientCredentialsGrant\" id=\"useRefreshTokenForClientCredentialsGrant\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'use-refresh-token-for-client-credentials-grant.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"useLowerCaseBearerTypeInTokenResponse\">{{:: 'use-lower-case-bearer-in-token-responses' | translate}}</label>\n                <div class=\"col-md-6\">\n                    <input ng-model=\"useLowerCaseBearerTypeInTokenResponse\" ng-click=\"switchChange()\" name=\"useLowerCaseBearerTypeInTokenResponse\" id=\"useLowerCaseBearerTypeInTokenResponse\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'use-lower-case-bearer-in-token-responses.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n        <fieldset>\n            <legend collapsed><span class=\"text\">{{:: 'advanced-client-settings' | translate}}</span>  <kc-tooltip>{{:: 'advanced-client-settings.tooltip' | translate}}</kc-tooltip></legend>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"accessTokenLifespan\">{{:: 'access-token-lifespan' | translate}}</label>\n\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"-1\"\n                           max=\"31536000\" data-ng-model=\"accessTokenLifespan.time\"\n                           id=\"accessTokenLifespan\" name=\"accessTokenLifespan\"\n                           data-ng-change=\"updateTimeouts()\"/>\n                    <select class=\"form-control\" name=\"accessTokenLifespanUnit\" data-ng-model=\"accessTokenLifespan.unit\" data-ng-change=\"updateTimeouts()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'access-token-lifespan.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'saml'\">\n                <label class=\"col-md-2 control-label\" for=\"samlAssertionLifespan\">{{:: 'saml-assertion-lifespan' | translate}}</label>\n\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"1\"\n                           max=\"31536000\" data-ng-model=\"samlAssertionLifespan.time\"\n                           id=\"samlAssertionLifespan\" name=\"samlAssertionLifespan\"\n                           data-ng-change=\"updateAssertionLifespan()\"/>\n                    <select class=\"form-control\" name=\"samlAssertionLifespanUnit\" data-ng-model=\"samlAssertionLifespan.unit\" data-ng-change=\"updateAssertionLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'saml-assertion-lifespan.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientSessionIdleTimeout\">{{:: 'client-session-idle' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\"\n                           max=\"31536000\" data-ng-model=\"clientSessionIdleTimeout.time\"\n                           id=\"clientSessionIdleTimeout\" name=\"clientSessionIdleTimeout\"\n                           data-ng-change=\"updateClientSessionIdleTimeout()\"/>\n                    <select class=\"form-control\" name=\"clientSessionIdleTimeoutUnit\" data-ng-model=\"clientSessionIdleTimeout.unit\" data-ng-change=\"updateClientSessionIdleTimeout()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-session-idle.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientSessionMaxLifespan\">{{:: 'client-session-max' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\"\n                           max=\"31536000\" data-ng-model=\"clientSessionMaxLifespan.time\"\n                           id=\"clientSessionMaxLifespan\" name=\"clientSessionMaxLifespan\"\n                           data-ng-change=\"updateClientSessionMaxLifespan()\"/>\n                    <select class=\"form-control\" name=\"clientSessionMaxLifespanUnit\" data-ng-model=\"clientSessionMaxLifespan.unit\" data-ng-change=\"updateClientSessionMaxLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-session-max.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientOfflineSessionIdleTimeout\">{{::\n                    'client-offline-session-idle' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\" max=\"31536000\"\n                        data-ng-model=\"clientOfflineSessionIdleTimeout.time\" id=\"clientOfflineSessionIdleTimeout\"\n                        name=\"clientOfflineSessionIdleTimeout\" data-ng-change=\"updateClientOfflineSessionIdleTimeout()\" /> <select\n                        class=\"form-control\" name=\"clientOfflineSessionIdleTimeoutUnit\"\n                        data-ng-model=\"clientOfflineSessionIdleTimeout.unit\"\n                        data-ng-change=\"updateClientOfflineSessionIdleTimeout()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-offline-session-idle.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"clientOfflineSessionMaxLifespan\">{{::\n                    'client-offline-session-max' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"0\" max=\"31536000\"\n                        data-ng-model=\"clientOfflineSessionMaxLifespan.time\" id=\"clientOfflineSessionMaxLifespan\"\n                        name=\"clientOfflineSessionMaxLifespan\" data-ng-change=\"updateClientOfflineSessionMaxLifespan()\" /> <select\n                        class=\"form-control\" name=\"clientOfflineSessionMaxLifespanUnit\"\n                        data-ng-model=\"clientOfflineSessionMaxLifespan.unit\"\n                        data-ng-change=\"updateClientOfflineSessionMaxLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'client-offline-session-max.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly && oauth2DeviceAuthorizationGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"oauth2DeviceCodeLifespan\">{{:: 'oauth2-device-code-lifespan'\n                    | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"1\" max=\"31536000\"\n                        data-ng-model=\"oauth2DeviceCodeLifespan.time\" id=\"oauth2DeviceCodeLifespan\"\n                        name=\"oauth2DeviceCodeLifespan\" data-ng-change=\"updateOauth2DeviceCodeLifespan()\" /> <select\n                        class=\"form-control\" name=\"oauth2DeviceCodeLifespanUnit\" data-ng-model=\"oauth2DeviceCodeLifespan.unit\"\n                        data-ng-change=\"updateOauth2DeviceCodeLifespan()\">\n                        <option value=\"Minutes\">{{:: 'minutes' | translate}}</option>\n                        <option value=\"Hours\">{{:: 'hours' | translate}}</option>\n                        <option value=\"Days\">{{:: 'days' | translate}}</option>\n                    </select>\n                </div>\n                <kc-tooltip>{{:: 'oauth2-device-code-lifespan.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\"\n                data-ng-show=\"protocol == 'openid-connect' && !clientEdit.bearerOnly && oauth2DeviceAuthorizationGrantEnabled == true\">\n                <label class=\"col-md-2 control-label\" for=\"oauth2DevicePollingInterval\">{{::\n                    'oauth2-device-polling-interval' | translate}}</label>\n                <div class=\"col-md-6 time-selector\">\n                    <input class=\"form-control\" type=\"number\" min=\"1\" max=\"31536000\" data-ng-model=\"oauth2DevicePollingInterval\"\n                        id=\"oauth2DevicePollingInterval\" name=\"oauth2DevicePollingInterval\"\n                        data-ng-change=\"updateOauth2DevicePollingInterval()\" />\n                </div>\n                <kc-tooltip>{{:: 'oauth2-device-polling-interval.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"tlsClientCertificateBoundAccessTokens\">{{:: 'tls-client-certificate-bound-access-tokens' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"tlsClientCertificateBoundAccessTokens\" ng-click=\"switchChange()\" name=\"tlsClientCertificateBoundAccessTokens\" id=\"tlsClientCertificateBoundAccessTokens\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'tls-client-certificate-bound-access-tokens.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect' && clientEdit.standardFlowEnabled && clientEdit.implicitFlowEnabled\">\n                <label class=\"col-md-2 control-label\" for=\"useIdTokenAsDetachedSignature\">{{:: 'use-idtoken-as-detached-signature' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"useIdTokenAsDetachedSignature\" ng-click=\"switchChange()\" name=\"useIdTokenAsDetachedSignature\" id=\"useIdTokenAsDetachedSignature\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'use-idtoken-as-detached-signature.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"changePkceCodeChallengeMethod\">{{:: 'pkce-code-challenge-method' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div>\n                        <select class=\"form-control\" id=\"pkceCodeChallengeMethod\"\n                                ng-change=\"changePkceCodeChallengeMethod()\"\n                                ng-model=\"pkceCodeChallengeMethod\"\n                                ng-options=\"method for method in changePkceCodeChallengeMethodOptions\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'pkce-code-challenge-method.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label class=\"col-md-2 control-label\" for=\"requirePushedAuthorizationRequests\">{{:: 'require-pushed-authorization-requests' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <input ng-model=\"requirePushedAuthorizationRequests\" ng-click=\"switchChange()\" name=\"requirePushedAuthorizationRequests\" id=\"requirePushedAuthorizationRequests\" onoffswitch on-text=\"{{:: 'onText' | translate}}\" off-text=\"{{:: 'offText' | translate}}\"/>\n                </div>\n                <kc-tooltip>{{:: 'require-pushed-authorization-requests.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group clearfix block\" data-ng-show=\"!clientEdit.bearerOnly && protocol == 'openid-connect' && serverInfo.featureEnabled('STEP_UP_AUTHENTICATION')\">\n                <label class=\"col-md-2 control-label\" for=\"newAcr\">{{:: 'acr-loa-map' | translate}}</label>\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group input-map\" ng-repeat=\"(acr, loa) in acrLoaMap\">\n                        <input class=\"form-control\" readonly value=\"{{acr}}\">\n                        <input class=\"form-control\" ng-model=\"acrLoaMap[acr]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteAcrLoaMapping(acr)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n                    <div class=\"input-group input-map\">\n                        <input class=\"form-control\" ng-model=\"newAcr\" id=\"newAcr\" placeholder=\"ACR\">\n                        <input class=\"form-control\" ng-model=\"newLoa\" id=\"newLoa\" placeholder=\"LOA\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newAcr.length > 0 && newLoa.length > 0 && addAcrLoaMapping()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'acr-loa-map-client.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n            <div class=\"form-group\" data-ng-show=\"!clientEdit.bearerOnly && protocol == 'openid-connect' && serverInfo.featureEnabled('STEP_UP_AUTHENTICATION')\">\n                <label class=\"col-md-2 control-label\" for=\"newDefaultAcrValue\">{{:: 'default-acr-values' | translate}}</label>\n\n                <div class=\"col-sm-6\">\n                    <div class=\"input-group\" ng-repeat=\"(i, defaultAcrValue) in defaultAcrValues track by $index\">\n                        <input class=\"form-control\" ng-model=\"defaultAcrValues[i]\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"deleteDefaultAcrValue($index)\"><span class=\"fa fa-minus\"></span></button>\n                        </div>\n                    </div>\n\n                    <div class=\"input-group\">\n                        <input class=\"form-control\" ng-model=\"newDefaultAcrValue\" id=\"newDefaultAcrValue\">\n                        <div class=\"input-group-btn\">\n                            <button class=\"btn btn-default\" type=\"button\" data-ng-click=\"newDefaultAcrValue.length > 0 && addDefaultAcrValue()\"><span class=\"fa fa-plus\"></span></button>\n                        </div>\n                    </div>\n                </div>\n\n                <kc-tooltip>{{:: 'default-acr-values.tooltip' | translate}}</kc-tooltip>\n            </div>\n\n        </fieldset>\n\n        <fieldset>\n            <legend collapsed><span class=\"text\">{{:: 'client-flow-bindings' | translate}}</span>  <kc-tooltip>{{:: 'client-flow-bindings.tooltip' | translate}}</kc-tooltip></legend>\n            <div class=\"form-group\">\n                <label for=\"browser\" class=\"col-md-2 control-label\">{{:: 'browser-flow' | translate}}</label>\n                <div class=\"col-md-2\">\n                    <div>\n                        <select id=\"browser\" data-ng-model=\"clientEdit.authenticationFlowBindingOverrides['browser']\" class=\"form-control\" ng-options=\"flow.id as flow.alias for flow in flows\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'browser-flow.tooltip' | translate}}</kc-tooltip>\n            </div>\n            <div class=\"form-group\" data-ng-show=\"protocol == 'openid-connect'\">\n                <label for=\"grant\" class=\"col-md-2 control-label\">{{:: 'direct-grant-flow' | translate}}</label>\n                <div class=\"col-md-2\">\n                    <div>\n                        <select id=\"grant\" ng-model=\"clientEdit.authenticationFlowBindingOverrides['direct_grant']\" class=\"form-control\" ng-options=\"flow.id as flow.alias for flow in flows\">\n                        </select>\n                    </div>\n                </div>\n                <kc-tooltip>{{:: 'direct-grant-flow.tooltip' | translate}}</kc-tooltip>\n            </div>\n        </fieldset>\n\n\n\n        <div class=\"form-group\">\n            <div class=\"col-md-10 col-md-offset-2\" data-ng-show=\"client.access.configure\">\n                <button kc-save  data-ng-disabled=\"!changed\">{{:: 'save' | translate}}</button>\n                <button kc-reset data-ng-disabled=\"!changed\">{{:: 'cancel' | translate}}</button>\n            </div>\n        </div>\n    </form>\n</div>\n\n<kc-menu></kc-menu>\n"], "filenames": ["services/src/main/java/org/keycloak/protocol/saml/SamlClient.java", "services/src/main/java/org/keycloak/protocol/saml/SamlConfigAttributes.java", "services/src/main/java/org/keycloak/protocol/saml/SamlProtocolFactory.java", "services/src/main/java/org/keycloak/protocol/saml/SamlRepresentationAttributes.java", "services/src/main/java/org/keycloak/protocol/saml/profile/ecp/SamlEcpProfileService.java", "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/saml/SOAPBindingTest.java", "testsuite/integration-arquillian/tests/base/src/test/resources/adapter-test/keycloak-saml/testsaml.json", "testsuite/integration-arquillian/tests/other/console/src/main/java/org/keycloak/testsuite/console/page/clients/settings/ClientSettingsForm.java", "testsuite/integration-arquillian/tests/other/console/src/test/java/org/keycloak/testsuite/console/clients/AbstractClientTest.java", "themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties", "themes/src/main/resources/theme/base/admin/resources/js/controllers/clients.js", "themes/src/main/resources/theme/base/admin/resources/partials/client-detail.html"], "buggy_code_start_loc": [122, 46, 156, 63, 28, 19, 719, 6, 25, 373, 1199, 300], "buggy_code_end_loc": [122, 46, 156, 63, 101, 216, 720, 264, 91, 373, 1962, 300], "fixing_code_start_loc": [123, 47, 157, 64, 29, 20, 719, 7, 26, 374, 1200, 301], "fixing_code_end_loc": [131, 48, 161, 69, 111, 294, 721, 267, 93, 376, 1977, 308], "type": "CWE-287", "message": "A flaw was found in keycloak, where the default ECP binding flow allows other authentication flows to be bypassed. By exploiting this behavior, an attacker can bypass the MFA authentication by sending a SOAP request with an AuthnRequest and Authorization header with the user's credentials. The highest threat from this vulnerability is to confidentiality and integrity.", "other": {"cve": {"id": "CVE-2021-3827", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:10.030", "lastModified": "2022-11-30T18:46:55.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in keycloak, where the default ECP binding flow allows other authentication flows to be bypassed. By exploiting this behavior, an attacker can bypass the MFA authentication by sending a SOAP request with an AuthnRequest and Authorization header with the user's credentials. The highest threat from this vulnerability is to confidentiality and integrity."}, {"lang": "es", "value": "Se ha encontrado un fallo en keycloak, en el que el flujo de vinculaci\u00f3n ECP por defecto permite omitir otros flujos de autenticaci\u00f3n. Al explotar este comportamiento, un atacante puede omitir la autenticaci\u00f3n MFA mediante el env\u00edo de una petici\u00f3n SOAP con un encabezado AuthnRequest y Authorization con las credenciales del usuario. La mayor amenaza de esta vulnerabilidad es para la confidencialidad y la integridad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:keycloak:*:*:*:*:*:*:*:*", "versionEndExcluding": "18.0.0", "matchCriteriaId": "EC308493-1A81-4D85-B568-ECAA9AE15A82"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "9EFEC7CA-8DDA-48A6-A7B6-1F1D14792890"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:7.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "A69E9AB7-AC48-4448-BE34-68AC0AA0CD46"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:-:*:*:*", "matchCriteriaId": "053C1B35-3869-41C2-9551-044182DE0A64"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.8:*:*:*:*:*:*:*", "matchCriteriaId": "91B493F0-5542-49F7-AAAE-E6CA6E468D7B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.9:*:*:*:*:*:*:*", "matchCriteriaId": "81609549-25CE-4C8A-9DE3-170D23704208"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3827", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2007512", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/keycloak/keycloak/commit/44000caaf5051d7f218d1ad79573bd3d175cad0d", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/keycloak/keycloak/security/advisories/GHSA-4pc7-vqv5-5r3v", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keycloak/keycloak/commit/44000caaf5051d7f218d1ad79573bd3d175cad0d"}}