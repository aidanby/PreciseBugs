{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"isoffin.h\"\n#include <gpac/iso639.h>\n#include <gpac/base_coding.h>\n#include <gpac/media_tools.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n\nstatic void isor_get_chapters(GF_ISOFile *file, GF_FilterPid *opid)\n{\n\tu32 i, count;\n\tGF_PropertyValue p;\n\tGF_PropUIntList times;\n\tGF_PropStringList names;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\t\tnames.vals = gf_malloc(sizeof(char *)*count);\n\t\ttimes.nb_items = names.nb_items = count;\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst char *name;\n\t\t\tu64 start;\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &start, &name);\n\t\t\ttimes.vals[i] = (u32) start;\n\t\t\tnames.vals[i] = gf_strdup(name);\n\t\t}\n\t\tp.type = GF_PROP_UINT_LIST;\n\t\tp.value.uint_list = times;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\tgf_free(times.vals);\n\n\t\tp.type = GF_PROP_STRING_LIST;\n\t\tp.value.string_list = names;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t//no free for string lists\n\t\treturn;\n\t}\n\n\tu32 chap_tk=0;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_ref = gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP);\n\t\tif (nb_ref) {\n\t\t\tgf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chap_tk) {\n\t\tcount = gf_isom_get_sample_count(file, chap_tk);\n\t\tif (!count) chap_tk=0;\n\t}\n\tif (!chap_tk) return;\n\n\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\tnames.vals = gf_malloc(sizeof(char *)*count);\n\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text);\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n\n\tp.type = GF_PROP_STRING_LIST;\n\tp.value.string_list = names;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\n}\n\nstatic void isor_export_ref(ISOMReader *read, ISOMChannel *ch, u32 rtype, char *rname)\n{\n\tu32 nb_refs = gf_isom_get_reference_count(read->mov, ch->track, rtype);\n\tif (nb_refs) {\n\t\tu32 j;\n\t\tGF_PropertyValue prop;\n\t\tprop.type = GF_PROP_UINT_LIST;\n\t\tprop.value.uint_list.nb_items = nb_refs;\n\t\tprop.value.uint_list.vals = gf_malloc(sizeof(u32)*nb_refs);\n\t\tfor (j=0; j<nb_refs; j++) {\n\t\t\tu32 ref_tk;\n\t\t\tgf_isom_get_reference(read->mov, ch->track, rtype, j+1, &ref_tk );\n\t\t\tprop.value.uint_list.vals[j] = gf_isom_get_track_id(read->mov, ref_tk);\n\t\t}\n\t\tgf_filter_pid_set_property_str(ch->pid, rname, &prop);\n\t\tgf_free(prop.value.uint_list.vals);\n\t}\n}\n\nstatic void isor_declare_track(ISOMReader *read, ISOMChannel *ch, u32 track, u32 stsd_idx, u32 streamtype, Bool use_iod)\n{\n\tu32 w, h, sr, nb_ch, nb_bps, codec_id, depends_on_id, esid, avg_rate, max_rate, buffer_size, sample_count, max_size, base_track, audio_fmt, pix_fmt;\n\tGF_ESD *an_esd;\n\tconst char *mime, *encoding, *stxtcfg, *namespace, *schemaloc, *mime_cfg;\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\tu8 *tk_template;\n\tu32 tk_template_size;\n#endif\n\tGF_Language *lang_desc = NULL;\n\tBool external_base=GF_FALSE;\n\tBool has_scalable_layers = GF_FALSE;\n\tu8 *dsi = NULL, *enh_dsi = NULL;\n\tu32 dsi_size = 0, enh_dsi_size = 0;\n\tDouble track_dur=0;\n\tu32 srd_id=0, srd_indep=0, srd_x=0, srd_y=0, srd_w=0, srd_h=0;\n\tu32 base_tile_track=0;\n\tBool srd_full_frame=GF_FALSE;\n\tu32 mtype, m_subtype;\n\tGF_GenericSampleDescription *udesc = NULL;\n\tGF_Err e;\n\tu32 ocr_es_id;\n\tu32 meta_codec_id = 0;\n\tchar *meta_codec_name = NULL;\n\tu32 meta_opaque=0;\n\tBool first_config = GF_FALSE;\n\tu32 force_subs = 0;\n\n\n\tdepends_on_id = avg_rate = max_rate = buffer_size = 0;\n\tmime = encoding = stxtcfg = namespace = schemaloc = mime_cfg = NULL;\n\n\tif ( gf_isom_is_media_encrypted(read->mov, track, stsd_idx)) {\n\t\tgf_isom_get_original_format_type(read->mov, track, stsd_idx, &m_subtype);\n\t} else {\n\t\tm_subtype = gf_isom_get_media_subtype(read->mov, track, stsd_idx);\n\t}\n\n\tif (m_subtype==GF_ISOM_SUBTYPE_MPEG4) {\n\t\tu32 stsd_type = gf_isom_get_mpeg4_subtype(read->mov, track, stsd_idx);\n\t\tif (stsd_type==GF_ISOM_SUBTYPE_RESV)\n\t\t\tgf_isom_get_original_format_type(read->mov, track, stsd_idx, &m_subtype);\n\t}\n\n\taudio_fmt = 0;\n\tpix_fmt = 0;\n\tocr_es_id = 0;\n\tan_esd = gf_media_map_esd(read->mov, track, stsd_idx);\n\tif (an_esd && an_esd->decoderConfig) {\n\t\tif (an_esd->decoderConfig->streamType==GF_STREAM_INTERACT) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)an_esd);\n\t\t\treturn;\n\t\t}\n\t\tstreamtype = an_esd->decoderConfig->streamType;\n\t\tif (an_esd->decoderConfig->objectTypeIndication < GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\tcodec_id = gf_codecid_from_oti(streamtype, an_esd->decoderConfig->objectTypeIndication);\n\t\t} else {\n\t\t\tcodec_id = an_esd->decoderConfig->objectTypeIndication;\n\t\t}\n\t\tocr_es_id = an_esd->OCRESID;\n\t\tdepends_on_id = an_esd->dependsOnESID;\n\t\tlang_desc = an_esd->langDesc;\n\t\tan_esd->langDesc = NULL;\n\t\tesid = an_esd->ESID;\n\n\t\tif (an_esd->decoderConfig->decoderSpecificInfo && an_esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tdsi = an_esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\tdsi_size = an_esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\tan_esd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\tan_esd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t}\n\n\t\tgf_odf_desc_del((GF_Descriptor *)an_esd);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (dsi && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\tgf_m4a_get_config(dsi, dsi_size, &acfg);\n\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t}\n#endif\n\n\t} else {\n\t\tu32 i, pcm_flags, pcm_size, pcm_ch;\n\t\tDouble pcm_sr;\n\t\tBool load_default = GF_FALSE;\n\t\tBool is_float = GF_FALSE;\n\n\t\tif (an_esd)\n\t\t\tgf_odf_desc_del((GF_Descriptor *)an_esd);\n\n\t\tlang_desc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\t\tgf_isom_get_media_language(read->mov, track, &lang_desc->full_lang_code);\n\t\tesid = gf_isom_get_track_id(read->mov, track);\n\n\t\tif (!streamtype) streamtype = gf_codecid_type(m_subtype);\n\t\tcodec_id = 0;\n\n\t\tswitch (m_subtype) {\n\t\tcase GF_ISOM_SUBTYPE_STXT:\n\t\tcase GF_ISOM_SUBTYPE_METT:\n\t\tcase GF_ISOM_SUBTYPE_SBTT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\n\t\t\tcodec_id = GF_CODECID_SIMPLE_TEXT;\n\t\t\tgf_isom_stxt_get_description(read->mov, track, stsd_idx, &mime, &encoding, &stxtcfg);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_STPP:\n\t\t\tcodec_id = GF_CODECID_SUBS_XML;\n\t\t\tgf_isom_xml_subtitle_get_description(read->mov, track, stsd_idx, &namespace, &schemaloc, &mime);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_METX:\n\t\t\tcodec_id = GF_CODECID_META_XML;\n\t\t\tgf_isom_xml_subtitle_get_description(read->mov, track, stsd_idx, &namespace, &schemaloc, &mime);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_WVTT:\n\t\t\tcodec_id = GF_CODECID_WEBVTT;\n#ifndef GPAC_DISABLE_VTT\n\t\t\tstxtcfg = gf_isom_get_webvtt_config(read->mov, track, stsd_idx);\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MJP2:\n\t\t\tcodec_id = GF_CODECID_J2K;\n\t\t\tgf_isom_get_jp2_config(read->mov, track, stsd_idx, &dsi, &dsi_size);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\tcodec_id = GF_CODECID_HEVC_TILES;\n\t\t\tgf_isom_get_reference(read->mov, track, GF_ISOM_REF_TBAS, 1, &base_tile_track);\n\t\t\tif (base_tile_track) {\n\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_tile_track);\n\t\t\t}\n\t\t\tgf_isom_get_tile_info(read->mov, track, 1, NULL, &srd_id, &srd_indep, &srd_full_frame, &srd_x, &srd_y, &srd_w, &srd_h);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_TEXT:\n\t\tcase GF_ISOM_SUBTYPE_TX3G:\n\t\t{\n\t\t\tGF_TextSampleDescriptor *txtcfg = NULL;\n\t\t\tcodec_id = GF_CODECID_TX3G;\n\t\t\te = gf_isom_get_text_description(read->mov, track, stsd_idx, &txtcfg);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d unable to fetch TX3G config\\n\", track));\n\t\t\t}\n\t\t\tif (txtcfg) {\n\t\t\t\tif (txtcfg->displayFlags & GF_TXT_ALL_SAMPLES_FORCED) force_subs = 2;\n\t\t\t\telse if (txtcfg->displayFlags & GF_TXT_SOME_SAMPLES_FORCED) force_subs = 1;\n\n\t\t\t\tgf_odf_tx3g_write(txtcfg, &dsi, &dsi_size);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) txtcfg);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_FLAC:\n\t\t\tcodec_id = GF_CODECID_FLAC;\n\t\t\tgf_isom_flac_config_get(read->mov, track, stsd_idx, &dsi, &dsi_size);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\t\tcodec_id = GF_CODECID_OPUS;\n\t\t\tgf_isom_opus_config_get(read->mov, track, stsd_idx, &dsi, &dsi_size);\n\t\t\tbreak;\n\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\t\tis_float = GF_TRUE;\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\t\tif (gf_isom_get_pcm_config(read->mov, track, stsd_idx, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\tif (pcm_size==16) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_S16 : GF_AUDIO_FMT_S16_BE;\n\t\t\t\telse if (pcm_size==24) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_S24 : GF_AUDIO_FMT_S24_BE;\n\t\t\t\telse if (!is_float && (pcm_size==32)) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_S32 : GF_AUDIO_FMT_S32_BE;\n\t\t\t\telse if (is_float && (pcm_size==32)) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_FLT : GF_AUDIO_FMT_FLT_BE;\n\t\t\t\telse if (is_float && (pcm_size==64)) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_DBL : GF_AUDIO_FMT_DBL_BE;\n\t\t\t\telse codec_id = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TIMECODE:\n\t\t\tcodec_id = GF_CODECID_TMCD;\n\t\t\tstreamtype = GF_STREAM_METADATA;\n\t\t\tbreak;\n\n\t\tcase GF_QT_SUBTYPE_RAW:\n\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\tif (streamtype==GF_STREAM_AUDIO)\n \t\t\t\taudio_fmt = GF_AUDIO_FMT_U8;\n\t\t\telse\n \t\t\t\tpix_fmt = GF_PIXEL_RGB;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_IPCM:\n\t\t\tif (gf_isom_get_pcm_config(read->mov, track, stsd_idx, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\tif (pcm_size==16) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_S16 : GF_AUDIO_FMT_S16_BE;\n\t\t\t\telse if (pcm_size==24) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_S24 : GF_AUDIO_FMT_S24_BE;\n\t\t\t\telse if (pcm_size==32) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_S32 : GF_AUDIO_FMT_S32_BE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_FPCM:\n\t\t\tif (gf_isom_get_pcm_config(read->mov, track, stsd_idx, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\tif (pcm_size==64) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_DBL : GF_AUDIO_FMT_DBL_BE;\n\t\t\t\telse if (pcm_size==32) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_FLT : GF_AUDIO_FMT_FLT_BE;\n\t\t\t\telse codec_id = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_QT_SUBTYPE_LPCM:\n\t\t\tif (gf_isom_get_lpcm_config(read->mov, track, stsd_idx, &pcm_sr, &pcm_ch, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\taudio_fmt = 0;\n\t\t\t\tBool is_be = (pcm_flags & (1<<1)) ? GF_TRUE : GF_FALSE;\n\t\t\t\tif (pcm_flags >> 4) {}\n\t\t\t\t//we don't support non-packed audio\n\t\t\t\telse if (!(pcm_flags & (1<<3))) {}\n\t\t\t\telse if (pcm_sr != (u32) gf_ceil(pcm_sr)) {}\n\t\t\t\telse {\n\t\t\t\t\tsr = (u32) gf_ceil(pcm_sr);\n\t\t\t\t\tnb_ch = pcm_ch;\n\t\t\t\t\t//float formats\n\t\t\t\t\tif (pcm_flags & 1) {\n\t\t\t\t\t\tif (pcm_size==64) audio_fmt = is_be ? GF_AUDIO_FMT_DBL_BE : GF_AUDIO_FMT_DBL;\n\t\t\t\t\t\telse if (pcm_size==32) audio_fmt = is_be ? GF_AUDIO_FMT_FLT_BE : GF_AUDIO_FMT_FLT;\n\t\t\t\t\t}\n\t\t\t\t\t//signed int formats\n\t\t\t\t\telse if (pcm_flags & 4) {\n\t\t\t\t\t\tif (pcm_size==16) audio_fmt = is_be ? GF_AUDIO_FMT_S16_BE : GF_AUDIO_FMT_S16;\n\t\t\t\t\t\telse if (pcm_size==24) audio_fmt = is_be ? GF_AUDIO_FMT_S24_BE : GF_AUDIO_FMT_S24;\n\t\t\t\t\t\telse if (pcm_size==32) audio_fmt = is_be ? GF_AUDIO_FMT_S32_BE : GF_AUDIO_FMT_S32;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pcm_size==8) audio_fmt = GF_AUDIO_FMT_U8;\n\t\t\t\t\t}\n\t\t\t\t\tif (audio_fmt) {\n\t\t\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\t\t\tnb_bps = pcm_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_VVC1:\n\t\tcase GF_ISOM_SUBTYPE_VVI1:\n\t\t{\n\t\t\tGF_VVCConfig *vvccfg = gf_isom_vvc_config_get(read->mov, track, stsd_idx);\n\t\t\tif (vvccfg) {\n\t\t\t\tgf_odf_vvc_cfg_write(vvccfg, &dsi, &dsi_size);\n\t\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\t}\n\t\t\tcodec_id = GF_CODECID_VVC;\n\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_VVS1:\n\t\t\tbase_tile_track = 0;\n\t\t\tcodec_id = gf_isom_get_track_group(read->mov, track, GF_4CC('a','l','t','e') );\n\t\t\tfor (i=0; i<gf_isom_get_track_count(read->mov); i++) {\n\t\t\t\tu32 j, nb_refs = gf_isom_get_reference_count(read->mov, i+1, GF_ISOM_REF_SUBPIC);\n\t\t\t\tfor (j=0; j<nb_refs; j++) {\n\t\t\t\t\tu32 ref_tk=0;\n\t\t\t\t\tgf_isom_get_reference_ID(read->mov, i+1, GF_ISOM_REF_SUBPIC, j+1, &ref_tk);\n\t\t\t\t\tif ((ref_tk == esid) || (ref_tk == codec_id)) {\n\t\t\t\t\t\tbase_tile_track = i+1;\n\t\t\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_tile_track);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (base_tile_track) break;\n\t\t\t}\n\t\t\tif (!base_tile_track) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] VVC subpicture track ID %d with no base VVC track referencing it, ignoring\\n\", esid));\n\t\t\t\tif (lang_desc) gf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\t\t\tif (dsi) gf_free(dsi);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcodec_id = GF_CODECID_VVC_SUBPIC;\n\t\t\tgf_isom_get_tile_info(read->mov, track, 1, NULL, &srd_id, &srd_indep, &srd_full_frame, &srd_x, &srd_y, &srd_w, &srd_h);\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\tcase GF_ISOM_SUBTYPE_EC3:\n\t\t{\n\t\t\tGF_AC3Config *ac3cfg = gf_isom_ac3_config_get(read->mov, track, stsd_idx);\n\t\t\tcodec_id = (m_subtype==GF_ISOM_SUBTYPE_AC3) ? GF_CODECID_AC3 : GF_CODECID_EAC3;\n\t\t\tif (ac3cfg) {\n\t\t\t\tgf_odf_ac3_cfg_write(ac3cfg, &dsi, &dsi_size);\n\t\t\t\tgf_free(ac3cfg);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d missing AC3/EC3 configuration !\\n\", track));\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_MLPA:\n\t\t{\n\t\t\tu32 fmt, prate;\n\t\t\tif (gf_isom_truehd_config_get(read->mov, track, stsd_idx, &fmt, &prate) == GF_OK) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tgf_bs_write_u32(bs, fmt);\n\t\t\t\tgf_bs_write_int(bs, prate, 15);\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\tgf_bs_get_content(bs, &dsi, &dsi_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tcodec_id = GF_CODECID_TRUEHD;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d missing TrueHD configuration !\\n\", track));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GF_ISOM_SUBTYPE_DVB_SUBS:\n\t\t\tcodec_id = GF_CODECID_DVB_SUBS;\n\t\t\tload_default = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_DVB_TELETEXT:\n\t\t\tcodec_id = GF_CODECID_DVB_TELETEXT;\n\t\t\tload_default = GF_TRUE;\n\t\t\tbreak;\n\n\t\tcase GF_4CC('G','M','C','W'):\n\t\t\tcodec_id = m_subtype;\n\t\t\tload_default = GF_TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcodec_id = gf_codec_id_from_isobmf(m_subtype);\n\t\t\tif (!codec_id || (codec_id==GF_CODECID_RAW)) {\n\t\t\t\tpix_fmt=0;\n\t\t\t\tif (streamtype==GF_STREAM_VISUAL) {\n\t\t\t\t\tpix_fmt = gf_pixel_fmt_from_qt_type(m_subtype);\n\t\t\t\t\tif (!pix_fmt && gf_pixel_fmt_probe(m_subtype, NULL))\n\t\t\t\t\t\tpix_fmt = m_subtype;\n\t\t\t\t}\n\n \t\t\t\tif (pix_fmt) {\n\t\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\t\tif (pix_fmt==GF_PIXEL_UNCV) {\n\t\t\t\t\t\tload_default = GF_TRUE;\n\t\t\t\t\t\tcodec_id = GF_CODECID_RAW_UNCV;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tload_default = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//load dsi in any other case\n\t\t\telse {\n\t\t\t//if ((codec_id==GF_CODECID_FFV1) || (codec_id==GF_CODECID_ALAC))\n\t\t\t\tload_default = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (load_default) {\n\t\t\tif (!codec_id) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d type %s not natively handled\\n\", track, gf_4cc_to_str(m_subtype) ));\n\n\t\t\t\tcodec_id = m_subtype;\n\t\t\t}\n\t\t\tudesc = gf_isom_get_generic_sample_description(read->mov, track, stsd_idx);\n\t\t\tif (udesc) {\n\t\t\t\tif ((codec_id==GF_CODECID_FFV1) && (udesc->extension_buf_size>8)) {\n\t\t\t\t\tdsi = gf_malloc(udesc->extension_buf_size-8);\n\t\t\t\t\tif (dsi) memcpy(dsi, udesc->extension_buf+8, udesc->extension_buf_size-8);\n\t\t\t\t\tdsi_size = udesc->extension_buf_size - 8;\n\t\t\t\t} else if ((codec_id==GF_4CC('G','M','C','W')) && (udesc->extension_buf_size>=16)) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(udesc->extension_buf, udesc->extension_buf_size, GF_BITSTREAM_READ);\n\t\t\t\t\tif (udesc->ext_box_wrap == GF_4CC('G','M','C','C')) {\n\t\t\t\t\t\tcodec_id = gf_bs_read_u32(bs);\n\t\t\t\t\t\tmeta_codec_id = gf_bs_read_u32(bs);\n\t\t\t\t\t\tmeta_codec_name = gf_bs_read_utf8(bs);\n\t\t\t\t\t\tmeta_opaque = gf_bs_read_u32(bs);\n\t\t\t\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\t\t\t\tu32 pos = (u32) gf_bs_get_position(bs);\n\t\t\t\t\t\t\tdsi = udesc->extension_buf+pos;\n\t\t\t\t\t\t\tdsi_size = udesc->extension_buf_size-pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\tdsi = udesc->extension_buf;\n\t\t\t\t\tdsi_size = udesc->extension_buf_size;\n\t\t\t\t\tudesc->extension_buf = NULL;\n\t\t\t\t\tudesc->extension_buf_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!streamtype || !codec_id) {\n\t\tif (udesc) gf_free(udesc);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to %s pid for track %d, could not extract codec/streamtype info\\n\", ch ? \"update\" : \"create\", track));\n\t\tif (lang_desc) gf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\tif (dsi) gf_free(dsi);\n\t\treturn;\n\t}\n\n\tmime_cfg = gf_isom_subtitle_get_mime(read->mov, track, stsd_idx);\n\n\t//first setup, creation of PID and channel\n\tif (!ch) {\n\t\tBool use_sidx_dur = GF_FALSE;\n\t\tGF_FilterPid *pid;\n\t\tfirst_config = GF_TRUE;\n\n\t\tgf_isom_get_reference(read->mov, track, GF_ISOM_REF_BASE, 1, &base_track);\n\n\t\tif (base_track) {\n\t\t\tu32 base_subtype=0;\n\t\t\tif (read->smode==MP4DMX_SINGLE)\n\t\t\t\tdepends_on_id = 0;\n\n\t\t\tswitch (m_subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\t\tbase_subtype = gf_isom_get_media_subtype(read->mov, base_track, stsd_idx);\n\t\t\t\tswitch (base_subtype) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\texternal_base=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (external_base) {\n\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_track);\n\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tswitch (gf_isom_get_hevc_lhvc_type(read->mov, track, stsd_idx)) {\n\t\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t//this is likely temporal sublayer of base\n\t\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\t\t\thas_scalable_layers = GF_FALSE;\n\t\t\t\t\tif (gf_isom_get_reference_count(read->mov, track, GF_ISOM_REF_SCAL)<=0) {\n\t\t\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_track);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (gf_isom_get_hevc_lhvc_type(read->mov, track, stsd_idx)) {\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!has_scalable_layers) {\n\t\t\t\tu32 i;\n\t\t\t\tGF_ISOTrackID track_id = gf_isom_get_track_id(read->mov, track);\n\t\t\t\tfor (i=0; i<gf_isom_get_track_count(read->mov); i++) {\n\t\t\t\t\tif (gf_isom_get_reference_count(read->mov, i+1, GF_ISOM_REF_BASE)>=0) {\n\t\t\t\t\t\tGF_ISOTrackID tkid;\n\t\t\t\t\t\tgf_isom_get_reference_ID(read->mov, i+1, GF_ISOM_REF_BASE, 1, &tkid);\n\t\t\t\t\t\tif (tkid==track_id) {\n\t\t\t\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (base_track && !ocr_es_id) {\n\t\t\tocr_es_id = gf_isom_get_track_id(read->mov, base_track);\n\t\t}\n\t\tif (!ocr_es_id) ocr_es_id = esid;\n\n\t\t//OK declare PID\n\t\tpid = gf_filter_pid_new(read->filter);\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esid));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(ocr_es_id));\n\t\tif (depends_on_id && (depends_on_id != esid))\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(depends_on_id));\n\n\t\tif (gf_isom_get_track_count(read->mov)>1) {\n\t\t\tchar szPName[1024];\n\t\t\tconst char *szST = gf_stream_type_name(streamtype);\n\t\t\tsprintf(szPName, \"%c%d\", szST[0], esid);\n\t\t\tgf_filter_pid_set_name(pid, szPName);\n\t\t}\n\n\t\t//MPEG-4 systems present\n\t\tif (use_iod)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ESID, &PROP_UINT(esid));\n\n\t\tif (gf_isom_is_track_in_root_od(read->mov, track) && !read->lightp) {\n\t\t\tswitch (streamtype) {\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(streamtype));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT( gf_isom_get_media_timescale(read->mov, track) ) );\n\n\t\tif (!gf_sys_is_test_mode())\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TRACK_NUM, &PROP_UINT(track) );\n\n\t\t//Dolby Vision - check for any video type\n\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(read->mov, track, stsd_idx);\n\t\tif (dovi) {\n\t\t\tu8 *data = NULL;\n\t\t\tu32 size = 0;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_odf_dovi_cfg_write_bs(dovi, bs);\n\t\t\tgf_bs_get_content(bs, &data, &size);\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA_NO_COPY(data, size));\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_odf_dovi_cfg_del(dovi);\n\n\t\t\tif (gf_isom_get_reference_count(read->mov, track, GF_4CC('v','d','e','p'))) {\n\t\t\t\tGF_ISOTrackID ref_id=0;\n\t\t\t\tgf_isom_get_reference_ID(read->mov, track, GF_4CC('v','d','e','p'), 1, &ref_id);\n\t\t\t\tif (ref_id) gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(ref_id));\n\t\t\t}\n\t\t}\n\n\t\t//create our channel\n\t\tch = isor_create_channel(read, pid, track, 0, (codec_id==GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\n\t\tif (lang_desc) {\n\t\t\tchar *lang=NULL;\n\t\t\tgf_isom_get_media_language(read->mov, track, &lang);\n\t\t\t//s32 idx = gf_lang_find(lang);\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_LANGUAGE, &PROP_STRING( lang ));\n\t\t\tif (lang) gf_free(lang);\n\t\t\tgf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\t\tlang_desc = NULL;\n\t\t}\n\n\t\tch->streamType = streamtype;\n//\t\tch->clock_id = ocr_es_id;\n\n\t\tif (!read->lightp) {\n\t\t\tif (has_scalable_layers)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SCALABLE, &PROP_BOOL(GF_TRUE));\n\n\t\t\tif (gf_isom_get_reference_count(read->mov, track, GF_ISOM_REF_SABT)>0) {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\t\t\telse if (gf_isom_get_reference_count(read->mov, track, GF_ISOM_REF_SUBPIC)>0) {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\n\t\t\tif (srd_w && srd_h) {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(srd_x, srd_y) );\n\t\t\t\tif (base_tile_track) {\n\t\t\t\t\tgf_isom_get_visual_info(read->mov, base_tile_track, stsd_idx, &w, &h);\n\t\t\t\t\tif (w && h) {\n\t\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_SIZE, &PROP_VEC2I_INT(w, h) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu8 *srdg=NULL;\n\t\t\t\tu32 srdg_s=0;\n\t\t\t\tgf_isom_get_user_data(read->mov, track, GF_ISOM_UDTA_GPAC_SRD, NULL, 1, &srdg, &srdg_s);\n\t\t\t\tif (srdg && srdg_s>=21) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(srdg, srdg_s, GF_BITSTREAM_READ);\n\t\t\t\t\tgf_bs_skip_bytes(bs, 5);\n\t\t\t\t\tsrd_x = (s32) gf_bs_read_u32(bs);\n\t\t\t\t\tsrd_y = (s32) gf_bs_read_u32(bs);\n\t\t\t\t\tsrd_w = gf_bs_read_u32(bs);\n\t\t\t\t\tsrd_h = gf_bs_read_u32(bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(srd_x, srd_y) );\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_SIZE, &PROP_VEC2I_INT(srd_w, srd_h) );\n\t\t\t\t}\n\t\t\t\tif (srdg) gf_free(srdg);\n\t\t\t}\n\n\n\t\t\tif (codec_id !=GF_CODECID_LHVC)\n\t\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_SCAL, \"isom:scal\");\n\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_SABT, \"isom:sabt\");\n\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_TBAS, \"isom:tbas\");\n\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_SUBPIC, \"isom:subp\");\n\t\t}\n\n\t\tif (read->lightp) {\n\t\t\tch->duration = gf_isom_get_track_duration_orig(read->mov, ch->track);\n\t\t} else {\n\t\t\tch->duration = gf_isom_get_track_duration(read->mov, ch->track);\n\t\t}\n\t\tif (!ch->duration) {\n\t\t\tch->duration = gf_isom_get_duration(read->mov);\n\t\t}\n\t\tsample_count = gf_isom_get_sample_count(read->mov, ch->track);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (read->frag_type && !read->input_loaded) {\n\t\t\tu32 ts;\n\t\t\tu64 dur;\n\t\t\tif (gf_isom_get_sidx_duration(read->mov, &dur, &ts)==GF_OK) {\n\t\t\t\tdur *= read->timescale;\n\t\t\t\tdur /= ts;\n\t\t\t\tch->duration = dur;\n\t\t\t\tuse_sidx_dur = GF_TRUE;\n\t\t\t\tsample_count = 0;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (!read->mem_load_mode || ch->duration) {\n\t\t\t//if no edit list (whether complex or simple TS offset) and no sidx, use media duration\n\t\t\tif (!ch->has_edit_list && !use_sidx_dur && !ch->ts_offset) {\n\t\t\t\t//no specific edit list type but edit present, use the duration in the edit\n\t\t\t\tif (gf_isom_get_edits_count(read->mov, ch->track)) {\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));\n\t\t\t\t} else {\n\t\t\t\t\tu64 dur = gf_isom_get_media_duration(read->mov, ch->track);\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(dur, ch->timescale));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//otherwise trust track duration\n\t\t\telse {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_NB_FRAMES, &PROP_UINT(sample_count));\n\t\t}\n\n\t\tif (sample_count && (streamtype==GF_STREAM_VISUAL)) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(read->mov, track);\n\t\t\t//if ts_offset is negative (skip), update media dur before computing fps\n\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\tu32 sdur = gf_isom_get_avg_sample_delta(read->mov, ch->track);\n\t\t\t\tif (sdur) {\n\t\t\t\t\tmdur = sdur;\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->ts_offset<0)\n\t\t\t\t\t\tmdur -= (u32) -ch->ts_offset;\n\t\t\t\t\tmdur /= sample_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmdur /= sample_count;\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT(ch->timescale, (u32) mdur));\n\t\t}\n\n\t\ttrack_dur = (Double) (s64) ch->duration;\n\t\ttrack_dur /= read->timescale;\n\t\t//move channel duration in media timescale\n\t\tch->duration = (u64) (track_dur * ch->timescale);\n\n\n\t\t//set stream subtype\n\t\tmtype = gf_isom_get_media_type(read->mov, track);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SUBTYPE, &PROP_4CC(mtype) );\n\n\t\tif (!read->mem_load_mode) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MEDIA_DATA_SIZE, &PROP_LONGUINT(gf_isom_get_media_data_size(read->mov, track) ) );\n\t\t}\n\t\t//in no cache mode, depending on fetch speed we may have fetched a fragment or not, resulting in has_rap set\n\t\t//always for HAS_SYNC to false\n\t\telse if (gf_sys_is_test_mode() && !sample_count) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(GF_FALSE) );\n\t\t}\n\n\t\tif (read->lightp) goto props_done;\n\n\t\tw = gf_isom_get_constant_sample_size(read->mov, track);\n\t\tif (w)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_FRAME_SIZE, &PROP_UINT(w));\n\n\t\t//mem mode, cannot read backwards\n\t\tif (read->mem_load_mode) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_PLAYBACK_MODE);\n\t\t\tif (!p)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_REWIND) );\n\t\t}\n\n\t\tGF_PropertyValue brands;\n\t\tbrands.type = GF_PROP_4CC_LIST;\n\t\tu32 major_brand=0;\n\t\tgf_isom_get_brand_info(read->mov, &major_brand, NULL, &brands.value.uint_list.nb_items);\n\t\tbrands.value.uint_list.vals = (u32 *) gf_isom_get_brands(read->mov);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_BRANDS, &brands);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_MBRAND, &PROP_4CC(major_brand) );\n\n\t\t//we cannot expose average size/dur in mem mode with fragmented files (sample_count=0)\n\t\tif (sample_count) {\n\t\t\tmax_size = gf_isom_get_max_sample_size(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_MAX_FRAME_SIZE, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_avg_sample_size(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_AVG_FRAME_SIZE, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_max_sample_delta(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_MAX_TS_DELTA, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_max_sample_cts_offset(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_MAX_CTS_OFFSET, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_constant_sample_duration(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_CONSTANT_DURATION, &PROP_UINT(max_size) );\n\t\t}\n\n\n\t\tu32 media_pl=0;\n\t\tif (streamtype==GF_STREAM_VISUAL) {\n\t\t\tmedia_pl = gf_isom_get_pl_indication(read->mov, GF_ISOM_PL_VISUAL);\n\t\t} else if (streamtype==GF_STREAM_AUDIO) {\n\t\t\tmedia_pl = gf_isom_get_pl_indication(read->mov, GF_ISOM_PL_AUDIO);\n\t\t}\n\t\tif (media_pl && (media_pl!=0xFF) ) gf_filter_pid_set_property(pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT(media_pl) );\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\t\te = gf_isom_get_track_template(read->mov, ch->track, &tk_template, &tk_template_size);\n\t\tif (e == GF_OK) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_TEMPLATE, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to serialize track box: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\n\t\te = gf_isom_get_trex_template(read->mov, ch->track, &tk_template, &tk_template_size);\n\t\tif (e == GF_OK) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TREX_TEMPLATE, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\t\t}\n\n\t\te = gf_isom_get_raw_user_data(read->mov, &tk_template, &tk_template_size);\n\t\tif (e==GF_OK) {\n\t\t\tif (tk_template_size)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_UDTA, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to serialize moov UDTA box: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n#endif\n\n\t\tGF_Fraction64 moov_time;\n\t\tmoov_time.num = gf_isom_get_duration(read->mov);\n\t\tmoov_time.den = gf_isom_get_timescale(read->mov);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_MOVIE_TIME, &PROP_FRAC64(moov_time) );\n\n\n\t\tu32 i;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\t\tgf_isom_get_track_layout_info(read->mov, ch->track, &w, &h, &tx, &ty, &l);\n\t\tif (w && h) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_TRANS_X, &PROP_SINT(tx) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_TRANS_Y, &PROP_SINT(ty) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ZORDER, &PROP_SINT(l) );\n\t\t}\n\t\tif (codec_id==GF_CODECID_TX3G) {\n\t\t\tu32 m_w = w;\n\t\t\tu32 m_h = h;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(read->mov); i++) {\n\t\t\t\tswitch (gf_isom_get_media_type(read->mov, i+1)) {\n\t\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\t\tgf_isom_get_track_layout_info(read->mov, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_WIDTH_MAX, &PROP_UINT(m_w) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HEIGHT_MAX, &PROP_UINT(m_h) );\n\t\t\tchar *tx3g_config_sdp = NULL;\n\t\t\tfor (i=0; i<gf_isom_get_sample_description_count(read->mov, ch->track); i++) {\n\t\t\t\tu8 *tx3g;\n\t\t\t\tu32 l1;\n\t\t\t\tu32 tx3g_len, len;\n\t\t\t\te = gf_isom_text_get_encoded_tx3g(read->mov, ch->track, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\tchar buffer[2000];\n\t\t\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\t\t\tgf_free(tx3g);\n\t\t\t\t\tbuffer[len] = 0;\n\n\t\t\t\t\tl1 = tx3g_config_sdp ? (u32) strlen(tx3g_config_sdp) : 0;\n\t\t\t\t\ttx3g_config_sdp = gf_realloc(tx3g_config_sdp, len+3+l1);\n\t\t\t\t\ttx3g_config_sdp[l1] = 0;\n\t\t\t\t\tif (i) strcat(tx3g_config_sdp, \", \");\n\t\t\t\t\tstrcat(tx3g_config_sdp, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tx3g_config_sdp) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_STRING_NO_COPY(tx3g_config_sdp) );\n\t\t\t}\n\t\t}\n\n\t\tu32 idx=0;\n\t\twhile (1) {\n\t\t\tu32 data_len, int_val2, flags;\n\t\t\tu64 int_val;\n\t\t\tconst char *name;\n\t\t\tconst u8 *data;\n\t\t\tGF_ISOiTunesTag itag;\n\t\t\tu32 itype = 0;\n\t\t\ts32 tag_idx;\n\n\t\t\te = gf_isom_apple_enum_tag(read->mov, idx, &itag, &data, &data_len, &int_val, &int_val2, &flags);\n\t\t\tif (e) break;\n\t\t\tidx++;\n\n\t\t\t//do not expose tool\n\t\t\tif (!gf_sys_is_test_mode() && (itag == GF_ISOM_ITUNE_TOOL))\n\t\t\t\tcontinue;\n\n\t\t\ttag_idx = gf_itags_find_by_itag(itag);\n\t\t\tif (tag_idx>=0)\n\t\t\t\titype = gf_itags_get_type(tag_idx);\n\n\t\t\tname = gf_itags_get_name(tag_idx);\n\t\t\tswitch (itype) {\n\t\t\tcase GF_ITAG_BOOL:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_BOOL((Bool) int_val ) );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_INT8:\n\t\t\tcase GF_ITAG_INT16:\n\t\t\tcase GF_ITAG_INT32:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_UINT((u32) int_val ) );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_INT64:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_LONGUINT(int_val) );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FRAC8:\n\t\t\tcase GF_ITAG_FRAC6:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_FRAC_INT((s32) int_val, int_val2)  );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FILE:\n\t\t\t\tif (data && data_len)\n\t\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_DATA((u8 *)data, data_len)  );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (data && data_len) {\n\t\t\t\t\tif (gf_utf8_is_legal(data, data_len))\n\t\t\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_STRING(data) );\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_DATA((u8 *)data, data_len)  );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (codec_id==GF_CODECID_TMCD) {\n\t\t\tu32 tmcd_flags=0, tmcd_fps_num=0, tmcd_fps_den=0, tmcd_fpt=0;\n\t\t\tgf_isom_get_tmcd_config(read->mov, track, stsd_idx, &tmcd_flags, &tmcd_fps_num, &tmcd_fps_den, &tmcd_fpt);\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"tmcd:flags\", &PROP_UINT(tmcd_flags) );\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"tmcd:framerate\", &PROP_FRAC_INT(tmcd_fps_num, tmcd_fps_den) );\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"tmcd:frames_per_tick\", &PROP_UINT(tmcd_fpt) );\n\n\t\t}\n\n\t\tif (gf_sys_old_arch_compat()) {\n\t\t\tBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber);\n\t\t\tif (gf_isom_has_time_offset_table(read->mov, ch->track))\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, \"isom_force_ctts\", &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\tif (read->nodata==2)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"nodata\", &PROP_BOOL(GF_TRUE) );\n\n\t\tif (!gf_sys_is_test_mode()) {\n\t\t\tu32 nb_udta, alt_grp=0;\n\t\t\tconst char *hdlr = NULL;\n\t\t\tgf_isom_get_handler_name(read->mov, ch->track, &hdlr);\n\t\t\tif (hdlr)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_HANDLER, &PROP_STRING(hdlr));\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_FLAGS, &PROP_UINT( gf_isom_get_track_flags(read->mov, ch->track) ));\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_FLAGS, &PROP_UINT( gf_isom_get_track_flags(read->mov, ch->track) ));\n\n\t\t\tgf_isom_get_track_switch_group_count(read->mov, ch->track, &alt_grp, NULL);\n\t\t\tif (alt_grp)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_ALT_GROUP, &PROP_UINT( alt_grp ));\n\n\n\t\t\tif (streamtype==GF_STREAM_VISUAL) {\n\t\t\t\tGF_PropertyValue p;\n\t\t\t\tu32 vals[9];\n\t\t\t\tmemset(vals, 0, sizeof(u32)*9);\n\t\t\t\tmemset(&p, 0, sizeof(GF_PropertyValue));\n\t\t\t\tp.type = GF_PROP_SINT_LIST;\n\t\t\t\tp.value.uint_list.nb_items = 9;\n\t\t\t\tp.value.uint_list.vals = vals;\n\t\t\t\tgf_isom_get_track_matrix(read->mov, ch->track, vals);\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_MATRIX, &p);\n\t\t\t}\n\n\n\t\t\tnb_udta =  gf_isom_get_udta_count(read->mov, ch->track);\n\t\t\tif (nb_udta) {\n\t\t\t\tfor (i=0; i<nb_udta; i++) {\n\t\t\t\t\tu32 j, type, nb_items;\n\t\t\t\t\tbin128 uuid;\n\t\t\t\t\tgf_isom_get_udta_type(read->mov, ch->track, i+1, &type, &uuid);\n\t\t\t\t\tnb_items = gf_isom_get_user_data_count(read->mov, ch->track, type, uuid);\n\t\t\t\t\t//we only export 4CC udta boxes\n\t\t\t\t\tif (!type) continue;\n\n\t\t\t\t\tfor (j=0; j<nb_items; j++) {\n\t\t\t\t\t\tchar szName[31];\n\t\t\t\t\t\tu8 *udta=NULL;\n\t\t\t\t\t\tu32 udta_size;\n\t\t\t\t\t\tgf_isom_get_user_data(read->mov, ch->track, type, uuid, j+1, &udta, &udta_size);\n\t\t\t\t\t\tif (!udta || !udta_size) continue;\n\t\t\t\t\t\tif (nb_items>1)\n\t\t\t\t\t\t\tsnprintf(szName, 30, \"udta_%s_%d\", gf_4cc_to_str(type), j+1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsnprintf(szName, 30, \"udta_%s\", gf_4cc_to_str(type));\n\t\t\t\t\t\tszName[30]=0;\n\t\t\t\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\t\t\t\tif (!udta[udta_size-1]) {\n\t\t\t\t\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_STRING_NO_COPY(udta));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchar *data = gf_malloc(udta_size+1);\n\t\t\t\t\t\t\t\tmemcpy(data, udta, udta_size);\n\t\t\t\t\t\t\t\tdata[udta_size]=0;\n\t\t\t\t\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_STRING_NO_COPY(data));\n\t\t\t\t\t\t\t\tgf_free(udta);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_DATA_NO_COPY(udta, udta_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//delcare track groups\n\t\t\tu32 idx=0;\n\t\t\twhile (1) {\n\t\t\t\tchar szTK[100];\n\t\t\t\tu32 track_group_type, track_group_id;\n\t\t\t\tif (!gf_isom_enum_track_group(read->mov, ch->track, &idx, &track_group_type, &track_group_id)) break;\n\t\t\t\tsprintf(szTK, \"tkgp_%s\", gf_4cc_to_str(track_group_type));\n\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szTK, &PROP_SINT(track_group_id));\n\t\t\t}\n\t\t}\n\nprops_done:\n\n\t\tif (read->sigfrag) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tu64 start, end;\n\t\t\tif (gf_isom_get_root_sidx_offsets(read->mov, &start, &end)) {\n\t\t\t\tif (end)\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(start , end));\n\t\t\t}\n#endif\n\t\t\tif (!read->frag_type) {\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, \"nofrag\", &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\t\t}\n\t}\n\n\t//update decoder configs\n\tch->check_avc_ps = ch->check_hevc_ps = ch->check_vvc_ps = 0;\n\tif (ch->avcc) gf_odf_avc_cfg_del(ch->avcc);\n\tch->avcc = NULL;\n\tif (ch->hvcc) gf_odf_hevc_cfg_del(ch->hvcc);\n\tch->hvcc = NULL;\n\tif (ch->vvcc) gf_odf_vvc_cfg_del(ch->vvcc);\n\tch->vvcc = NULL;\n\n\tif (lang_desc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\tlang_desc = NULL;\n\t}\n\t\n\tif (read->smode != MP4DMX_SINGLE) {\n\t\tif ((codec_id==GF_CODECID_LHVC) || (codec_id==GF_CODECID_HEVC)) {\n\t\t\tBool signal_lhv = (read->smode==MP4DMX_SPLIT) ? GF_TRUE : GF_FALSE;\n\t\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(read->mov, track, stsd_idx);\n\t\t\tGF_HEVCConfig *lhcc = gf_isom_lhvc_config_get(read->mov, track, stsd_idx);\n\n\t\t\tif (hvcc || lhcc) {\n\t\t\t\tif (dsi) gf_free(dsi);\n\t\t\t\tdsi = NULL;\n\t\t\t\t//no base layer config\n\t\t\t\tif (!hvcc) signal_lhv = GF_TRUE;\n\n\t\t\t\tif (signal_lhv && lhcc) {\n\t\t\t\t\tif (hvcc) {\n\t\t\t\t\t\thvcc->is_lhvc = GF_FALSE;\n\t\t\t\t\t\tgf_odf_hevc_cfg_write(hvcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tlhcc->is_lhvc = GF_TRUE;\n\t\t\t\t\tgf_odf_hevc_cfg_write(lhcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\tcodec_id = GF_CODECID_LHVC;\n\t\t\t\t} else {\n\t\t\t\t\tif (hvcc) {\n\t\t\t\t\t\thvcc->is_lhvc = GF_FALSE;\n\t\t\t\t\t\tgf_odf_hevc_cfg_write(hvcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tif (lhcc) {\n\t\t\t\t\t\tlhcc->is_lhvc = GF_TRUE;\n\t\t\t\t\t\tgf_odf_hevc_cfg_write(lhcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tcodec_id = GF_CODECID_HEVC;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\tif (lhcc) gf_odf_hevc_cfg_del(lhcc);\n\t\t}\n\t\tif ((codec_id==GF_CODECID_AVC) || (codec_id==GF_CODECID_SVC) || (codec_id==GF_CODECID_MVC)) {\n\t\t\tBool is_mvc = GF_FALSE;\n\t\t\tBool signal_svc = (read->smode==MP4DMX_SPLIT) ? GF_TRUE : GF_FALSE;\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(read->mov, track, stsd_idx);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(read->mov, track, stsd_idx);\n\t\t\tif (!svcc) {\n\t\t\t\tsvcc = gf_isom_mvc_config_get(read->mov, track, stsd_idx);\n\t\t\t\tis_mvc = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (avcc || svcc) {\n\t\t\t\tif (dsi) gf_free(dsi);\n\t\t\t\tdsi = NULL;\n\t\t\t\t//no base layer config\n\t\t\t\tif (!avcc) signal_svc = GF_TRUE;\n\n\t\t\t\tif (signal_svc && svcc) {\n\t\t\t\t\tif (avcc) {\n\t\t\t\t\t\tgf_odf_avc_cfg_write(avcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_avc_cfg_write(svcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\tcodec_id = is_mvc ? GF_CODECID_MVC : GF_CODECID_SVC;\n\t\t\t\t} else {\n\t\t\t\t\tif (avcc) {\n\t\t\t\t\t\tgf_odf_avc_cfg_write(avcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tif (svcc) {\n\t\t\t\t\t\tgf_odf_avc_cfg_write(svcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tcodec_id = GF_CODECID_AVC;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avcc) gf_odf_avc_cfg_del(avcc);\n\t\t\tif (svcc) gf_odf_avc_cfg_del(svcc);\n\t\t}\n\n\t\tif (!gf_sys_is_test_mode()) {\n\t\t\tu64 create_date, modif_date;\n\t\t\tgf_isom_get_creation_time(read->mov, &create_date, &modif_date);\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"isom:creation_date\", &PROP_LONGUINT(create_date));\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"isom:modification_date\", &PROP_LONGUINT(modif_date));\n\t\t}\n\n\t\tisor_get_chapters(read->mov, ch->pid);\n\n\t\tif (!gf_sys_is_test_mode()) {\n\t\t\tBool has_roll=GF_FALSE;\n\t\t\tgf_isom_has_cenc_sample_group(read->mov, track, NULL, &has_roll);\n\t\t\tif (has_roll)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_HAS_ROLL, &PROP_BOOL(GF_TRUE));\n\t\t}\n\t}\n\n\t//all stsd specific init/reconfig\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CODECID, &PROP_UINT(codec_id));\n\n\tif (meta_codec_name || meta_codec_id) {\n\t\tif (meta_codec_id)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT(meta_codec_id));\n\n\t\tif (meta_codec_name) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_META_DEMUX_CODEC_NAME, &PROP_STRING(meta_codec_name ) );\n\t\t\tgf_free(meta_codec_name);\n\t\t}\n\t\tif (meta_opaque)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(meta_opaque));\n\n\t\tif (dsi) {\n\t\t\tch->dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(dsi, dsi_size)); //copy\n\t\t\tdsi = NULL; //do not free it\n\t\t}\n\t\tm_subtype = 0;\n\t\tif (udesc) {\n\t\t\tif (udesc->extension_buf) gf_free(udesc->extension_buf);\n\t\t\tgf_free(udesc);\n\t\t\tudesc = NULL;\n\t\t}\n\t}\n\n\tif (dsi) {\n\t\tch->dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t//strip box header for these codecs\n\t\tif (codec_id==GF_CODECID_SMPTE_VC1) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(dsi+8, dsi_size-8));\n\t\t\tgf_free(dsi);\n\t\t\tdsi=NULL;\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size));\n\t\t}\n\t}\n\tif (enh_dsi) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_DATA_NO_COPY(enh_dsi, enh_dsi_size));\n\t}\n\tif (audio_fmt) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(audio_fmt));\n\t\tif (codec_id == GF_CODECID_RAW) {\n\t\t\tgf_isom_enable_raw_pack(read->mov, track, read->frame_size);\n\t\t}\n\t}\n\tif (pix_fmt) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PIXFMT, &PROP_UINT(pix_fmt));\n\t}\n\n\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_FORCED_SUB, force_subs ? &PROP_UINT(force_subs) : NULL );\n\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CONFIG_IDX, &PROP_UINT(stsd_idx) );\n\n\tw = h = 0;\n\tgf_isom_get_visual_info(read->mov, track, stsd_idx, &w, &h);\n\tif (w && h) {\n\t\tGF_ISOM_Y3D_Info yt3d;\n\t\tu32 hspace, vspace;\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_WIDTH, &PROP_UINT(w));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HEIGHT, &PROP_UINT(h));\n\n\t\tgf_isom_get_pixel_aspect_ratio(read->mov, track, stsd_idx, &hspace, &vspace);\n\t\tif (hspace != vspace)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SAR, &PROP_FRAC_INT(hspace, vspace) );\n\n\t\t{\n\t\t\tconst u8 *icc;\n\t\t\tu32 icc_size;\n\t\t\tu32 colour_type;\n\t\t\tu16 colour_primaries, transfer_characteristics, matrix_coefficients;\n\t\t\tBool full_range_flag;\n\t\t\tif (GF_OK == gf_isom_get_color_info(read->mov, track, stsd_idx,\n\t\t\t\t&colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag)) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_PRIMARIES, &PROP_UINT(colour_primaries));\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_TRANSFER, &PROP_UINT(transfer_characteristics));\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_MX, &PROP_UINT(matrix_coefficients));\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_RANGE, &PROP_BOOL(full_range_flag));\n\t\t\t}\n\t\t\tif (gf_isom_get_icc_profile(read->mov, track, stsd_idx, NULL, &icc, &icc_size)==GF_OK) {\n\t\t\t\tif (icc && icc_size)\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ICC_PROFILE, &PROP_DATA((u8*)icc, icc_size) );\n\t\t\t}\n\t\t}\n\n\t\te = gf_isom_get_y3d_info(ch->owner->mov, ch->track, stsd_idx, &yt3d);\n\t\tif (e==GF_OK) {\n\t\t\tif (yt3d.stereo_type) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_STEREO_TYPE, &PROP_UINT(yt3d.stereo_type));\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_STEREO_TYPE, NULL);\n\t\t\t}\n\n\t\t\tif (yt3d.projection_type) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROJECTION_TYPE, &PROP_UINT(yt3d.projection_type));\n\t\t\t\tif (yt3d.projection_type==GF_PROJ360_CUBE_MAP) {\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CUBE_MAP_PAD, yt3d.padding ? &PROP_UINT(yt3d.padding) : NULL);\n\t\t\t\t}\n\t\t\t\telse if (yt3d.projection_type==GF_PROJ360_EQR) {\n\t\t\t\t\tif (yt3d.top || yt3d.bottom || yt3d.left || yt3d.right)\n\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_EQR_CLAMP, &PROP_VEC4I_INT(yt3d.top, yt3d.bottom , yt3d.left , yt3d.right));\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_EQR_CLAMP, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROJECTION_TYPE, NULL);\n\t\t\t}\n\t\t\tif (yt3d.pose_present) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_VR_POSE, &PROP_VEC3I_INT(yt3d.yaw, yt3d.pitch, yt3d.roll) );\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_VR_POSE, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (m_subtype!=GF_QT_SUBTYPE_LPCM) {\n\t\tsr = nb_ch = nb_bps = 0;\n\t\tgf_isom_get_audio_info(read->mov,track, stsd_idx, &sr, &nb_ch, &nb_bps);\n\t}\n\tif (streamtype==GF_STREAM_AUDIO) {\n\t\tif (!sr) sr = gf_isom_get_media_timescale(read->mov, track);\n\t}\n\t//nb_ch may be set to 0 for \"not applicable\" (3D / object coding audio)\n\tif (sr) {\n\t\tu32 d1, d2;\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(sr));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(nb_ch));\n\n\t\t//to remove once we deprecate master\n\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\tGF_AudioChannelLayout layout;\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_BPS, &PROP_UINT(nb_bps));\n\n\t\t\tif (gf_isom_get_audio_layout(read->mov, track, stsd_idx, &layout)==GF_OK) {\n\t\t\t\tif (layout.definedLayout) {\n\t\t\t\t\tu64 lay = gf_audio_fmt_get_layout_from_cicp(layout.definedLayout);\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(lay));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (first_config ) {\n\t\t\td1 = gf_isom_get_sample_duration(read->mov, ch->track, 1);\n\t\t\td2 = gf_isom_get_sample_duration(read->mov, ch->track, 2);\n\t\t\tif (d1 && d2 && (d1==d2)) {\n\t\t\t\td1 *= sr;\n\t\t\t\td1 /= ch->timescale;\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT(d1));\n\t\t\t}\n\t\t}\n\n\t\tif ((codec_id==GF_CODECID_MPHA) || (codec_id==GF_CODECID_MHAS)) {\n\t\t\tu32 nb_profiles;\n\t\t\tconst u8 *prof_compat = gf_isom_get_mpegh_compatible_profiles(read->mov, ch->track, stsd_idx, &nb_profiles);\n\t\t\tif (prof_compat) {\n\t\t\t\tu32 j;\n\t\t\t\tGF_PropertyValue prop;\n\t\t\t\tprop.type = GF_PROP_UINT_LIST;\n\t\t\t\tprop.value.uint_list.nb_items = nb_profiles;\n\t\t\t\tprop.value.uint_list.vals = gf_malloc(sizeof(u32)*nb_profiles);\n\t\t\t\tfor (j=0; j<nb_profiles; j++)\n\t\t\t\t\tprop.value.uint_list.vals[j] = prof_compat[j];\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES, &prop);\n\t\t\t\tgf_free(prop.value.uint_list.vals);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tgf_isom_get_bitrate(read->mov, ch->track, stsd_idx, &avg_rate, &max_rate, &buffer_size);\n\n\tif (!avg_rate) {\n\t\tif (first_config && ch->duration) {\n\t\t\tu64 avgrate = 8 * gf_isom_get_media_data_size(read->mov, ch->track);\n\t\t\tavgrate = (u64) (avgrate / track_dur);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_BITRATE, &PROP_UINT((u32) avgrate));\n\t\t}\n\t} else {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_BITRATE, &PROP_UINT((u32) avg_rate));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MAXRATE, &PROP_UINT((u32) max_rate));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DBSIZE, &PROP_UINT((u32) buffer_size));\n\t}\n\n\tif (mime) gf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(mime) );\n\tif (encoding) gf_filter_pid_set_property_str(ch->pid, \"meta:encoding\", &PROP_STRING(encoding) );\n\tif (namespace) gf_filter_pid_set_property_str(ch->pid, \"meta:xmlns\", &PROP_STRING(namespace) );\n\tif (schemaloc) gf_filter_pid_set_property_str(ch->pid, \"meta:schemaloc\", &PROP_STRING(schemaloc) );\n\tif (mime_cfg) gf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\telse if ((m_subtype==GF_ISOM_SUBTYPE_STPP) && namespace && strstr(namespace, \"ns/ttml\")) {\n\t\tmime_cfg = \"application/ttml+xml;codecs=im1t\";\n\t\tif (gf_isom_sample_has_subsamples(read->mov, track, 0, 0) )\n\t\t\tmime_cfg = \"application/ttml+xml;codecs=im1i\";\n\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\t}\n\n\tif (!gf_sys_is_test_mode() && (m_subtype==GF_ISOM_SUBTYPE_MPEG4))\n\t\tm_subtype = gf_isom_get_mpeg4_subtype(read->mov, ch->track, stsd_idx);\n\n\tif (m_subtype)\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_SUBTYPE, &PROP_4CC(m_subtype) );\n\n\tif (stxtcfg) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *)stxtcfg, (u32) strlen(stxtcfg) ));\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\ttk_template=NULL;\n\ttk_template_size=0;\n\te = gf_isom_get_stsd_template(read->mov, ch->track, stsd_idx, &tk_template, &tk_template_size);\n\tif (e == GF_OK) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_STSD_TEMPLATE, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\n\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t//if more than one sample desc, export all of them\n\t\t\tif (gf_isom_get_sample_description_count(read->mov, ch->track)>1) {\n\t\t\t\ttk_template=NULL;\n\t\t\t\ttk_template_size=0;\n\t\t\t\te = gf_isom_get_stsd_template(read->mov, ch->track, 0, &tk_template, &tk_template_size);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_STSD_TEMPLATE_IDX, &PROP_UINT(stsd_idx) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to serialize stsd box: %s\\n\", gf_error_to_string(e) ));\n\t}\n#endif\n\n\tif (codec_id == GF_CODECID_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tmemset(&dims, 0, sizeof(GF_DIMSDescription));\n\n\t\tgf_isom_get_dims_description(read->mov, ch->track, stsd_idx, &dims);\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:profile\", &PROP_UINT(dims.profile));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:level\", &PROP_UINT(dims.level));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:pathComponents\", &PROP_UINT(dims.pathComponents));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:fullRequestHost\", &PROP_BOOL(dims.fullRequestHost));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:streamType\", &PROP_BOOL(dims.streamType));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:redundant\", &PROP_BOOL(dims.containsRedundant));\n\t\tif (dims.content_script_types)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:scriptTypes\", &PROP_STRING(dims.content_script_types));\n\t\tif (dims.textEncoding)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:encoding\", &PROP_STRING(dims.textEncoding));\n\t\tif (dims.contentEncoding)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:content_encoding\", &PROP_STRING(dims.contentEncoding));\n\t\tif (dims.xml_schema_loc)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:schemaloc\", &PROP_STRING(dims.xml_schema_loc));\n\t\tif (dims.mime_type)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(dims.mime_type));\n\t}\n\telse if (codec_id==GF_CODECID_AVC)\n\t\tch->check_avc_ps = (ch->owner->xps_check==MP4DMX_XPS_REMOVE) ? 1 : 0;\n\telse if (codec_id==GF_CODECID_HEVC)\n\t\tch->check_hevc_ps = (ch->owner->xps_check==MP4DMX_XPS_REMOVE) ? 1 : 0;\n\telse if (codec_id==GF_CODECID_VVC)\n\t\tch->check_vvc_ps = (ch->owner->xps_check==MP4DMX_XPS_REMOVE) ? 1 : 0;\n\telse if (codec_id==GF_CODECID_MHAS) {\n\t\tif (!dsi) {\n\t\t\tch->check_mhas_pl = 1;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(ch->owner->mov, ch->track, 1, NULL);\n\t\t\tif (samp) {\n\t\t\t\tu64 ch_layout=0;\n\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\tif (PL>0) {\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT((u32) PL));\n\t\t\t\t\tch->check_mhas_pl = 0;\n\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(ch_layout));\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tif (udesc) {\n\t\tgf_filter_pid_set_property_str(ch->pid, \"codec_vendor\", &PROP_UINT(udesc->vendor_code));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"codec_version\", &PROP_UINT(udesc->version));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"codec_revision\", &PROP_UINT(udesc->revision));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"compressor_name\", &PROP_STRING(udesc->compressor_name));\n\t\tif (udesc->temporal_quality)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"temporal_quality\", &PROP_UINT(udesc->temporal_quality));\n\n\t\tif (udesc->spatial_quality)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"spatial_quality\", &PROP_UINT(udesc->spatial_quality));\n\n\t\tif (udesc->h_res) {\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"hres\", &PROP_UINT(udesc->h_res));\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"vres\", &PROP_UINT(udesc->v_res));\n\t\t} else if (udesc->nb_channels) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(udesc->nb_channels));\n\t\t\tswitch (udesc->bits_per_sample) {\n\t\t\tcase 8:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_U8));\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S16));\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S24));\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S32));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d unsupported audio bit depth %d\\n\", track, udesc->bits_per_sample ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (udesc->depth)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_BIT_DEPTH_Y, &PROP_UINT(udesc->depth));\n\n\t\tgf_free(udesc);\n\t}\n\n\n\tif (ch->check_avc_ps) {\n\t\tch->avcc = gf_isom_avc_config_get(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t}\n\telse if (ch->check_hevc_ps) {\n\t\tch->hvcc = gf_isom_hevc_config_get(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t}\n\telse if (ch->check_vvc_ps) {\n\t\tch->vvcc = gf_isom_vvc_config_get(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t}\n\n\tif (streamtype==GF_STREAM_VISUAL) {\n\t\tu32 cwn, cwd, chn, chd, cxn, cxd, cyn, cyd;\n\t\tgf_isom_get_clean_aperture(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1, &cwn, &cwd, &chn, &chd, &cxn, &cxd, &cyn, &cyd);\n\n\t\tif (cwd && chd && cxd && cyd) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_W, &PROP_FRAC_INT(cwn, cwd) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_H, &PROP_FRAC_INT(chn, chd) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_X, &PROP_FRAC_INT(cxn, cxd) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_Y, &PROP_FRAC_INT(cyn, cyd) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_W, NULL);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_H, NULL);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_X, NULL);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_Y, NULL);\n\t\t}\n\n\t\tconst GF_MasteringDisplayColourVolumeInfo *mdcv = gf_isom_get_mastering_display_colour_info(ch->owner->mov, ch->track,ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t\tif (mdcv) {\n\t\t\tu8 *pdata;\n\t\t\tu32 psize, c;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\tfor(c=0;c<3;c++) {\n\t\t\t\tgf_bs_write_u16(bs, mdcv->display_primaries[c].x);\n\t\t\t\tgf_bs_write_u16(bs, mdcv->display_primaries[c].y);\n\t\t\t}\n\t\t\tgf_bs_write_u16(bs, mdcv->white_point_x);\n\t\t\tgf_bs_write_u16(bs, mdcv->white_point_y);\n\t\t\tgf_bs_write_u32(bs, mdcv->max_display_mastering_luminance);\n\t\t\tgf_bs_write_u32(bs, mdcv->min_display_mastering_luminance);\n\t\t\tgf_bs_get_content(bs, &pdata, &psize);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA_NO_COPY(pdata, psize));\n\t\t}\n\n\t\tconst GF_ContentLightLevelInfo *clli = gf_isom_get_content_light_level_info(ch->owner->mov, ch->track,ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t\tif (clli) {\n\t\t\tu8 *pdata;\n\t\t\tu32 psize;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u16(bs, clli->max_content_light_level);\n\t\t\tgf_bs_write_u16(bs, clli->max_pic_average_light_level);\n\t\t\tgf_bs_get_content(bs, &pdata, &psize);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA_NO_COPY(pdata, psize));\n\t\t}\n\t}\n}\n\nvoid isor_update_channel_config(ISOMChannel *ch)\n{\n\tisor_declare_track(ch->owner, ch, ch->track, ch->last_sample_desc_index, ch->streamType, GF_FALSE);\n}\n\nGF_Err isor_declare_objects(ISOMReader *read)\n{\n\tconst u8 *tag;\n\tu32 tlen;\n\tu32 i, count, j, track_id;\n\tBool highest_stream;\n\tBool single_media_found = GF_FALSE;\n\tBool use_iod = GF_FALSE;\n\tBool tk_found = GF_FALSE;\n\tGF_Err e;\n\tBool isom_contains_video = GF_FALSE;\n\tGF_Descriptor *od = gf_isom_get_root_od(read->mov);\n\tif (od && gf_list_count(((GF_ObjectDescriptor*)od)->ESDescriptors)) {\n\t\tuse_iod = GF_TRUE;\n\t}\n\tif (od) gf_odf_desc_del(od);\n\n\t/*TODO\n\t check for alternate tracks\n    */\n\tcount = gf_isom_get_track_count(read->mov);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype, m_subtype, streamtype, stsd_idx;\n\n\t\tmtype = gf_isom_get_media_type(read->mov, i+1);\n\n\t\tif (read->tkid) {\n\t\t\tu32 for_id=0;\n\t\t\tif (sscanf(read->tkid, \"%d\", &for_id)) {\n\t\t\t\tu32 id = gf_isom_get_track_id(read->mov, i+1);\n\t\t\t\tif (id != for_id) continue;\n\t\t\t} else if (!strcmp(read->tkid, \"audio\")) {\n\t\t\t\tif (mtype!=GF_ISOM_MEDIA_AUDIO) continue;\n\t\t\t} else if (!strcmp(read->tkid, \"video\")) {\n\t\t\t\tif (mtype!=GF_ISOM_MEDIA_VISUAL) continue;\n\t\t\t} else if (!strcmp(read->tkid, \"text\")) {\n\t\t\t\tif ((mtype!=GF_ISOM_MEDIA_TEXT) && (mtype!=GF_ISOM_MEDIA_SUBT) && (mtype!=GF_ISOM_MEDIA_MPEG_SUBT)) continue;\n\t\t\t} else if (strlen(read->tkid)==4) {\n\t\t\t\tu32 t = GF_4CC(read->tkid[0], read->tkid[1], read->tkid[2], read->tkid[3]);\n\t\t\t\tif (mtype!=t) continue;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Bad format for tkid option %s, no match\\n\", read->tkid));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\ttk_found = GF_TRUE;\n\t\t}\n\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tstreamtype = GF_STREAM_AUDIO;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_QTVR:\n\t\t\tstreamtype = GF_STREAM_VISUAL;\n\t\t\tisom_contains_video = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_SUBPIC:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tcase GF_ISOM_MEDIA_CLOSED_CAPTION:\n\t\t\tstreamtype = GF_STREAM_TEXT;\n\t\t\tmtype = GF_ISOM_MEDIA_TEXT;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\tcase GF_ISOM_MEDIA_DIMS:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tstreamtype = GF_STREAM_SCENE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tstreamtype = GF_STREAM_OD;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_META:\n\t\tcase GF_ISOM_MEDIA_TIMECODE:\n\t\t\tstreamtype = GF_STREAM_METADATA;\n\t\t\tbreak;\n\t\t/*hint tracks are never exported*/\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (!read->allt) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d type %s not supported, ignoring track - you may retry by specifying allt option\\n\", i+1, gf_4cc_to_str(mtype) ));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstreamtype = GF_STREAM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!read->alltk && !read->tkid && !gf_isom_is_track_enabled(read->mov, i+1)) {\n\t\t\tif (count>1) {\n\t\t\t\tu32 type = gf_isom_get_media_type(read->mov, i+1);\n\n\t\t\t\t//we don't warn for disabled text tracks due to chapters and forced subs\n\t\t\t\tif ((type==GF_ISOM_SUBTYPE_TEXT) || (type==GF_ISOM_MEDIA_SUBT))\n\t\t\t\t\tcontinue;\n\t\t\t\t//disabled tracks using QT chapter refs, do not warn\n\t\t\t\tif (gf_isom_is_track_referenced(read->mov, i+1, GF_ISOM_REF_CHAP)) continue;\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d is disabled, ignoring track - you may retry by specifying alltk option\\n\", i+1));\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d is disabled but single track in file, considering it enabled\\n\", i+1 ));\n\t\t\t}\n\t\t}\n\n\t\tstsd_idx = read->stsd ? read->stsd : 1;\n\t\t//some subtypes are not declared as readable objects\n\t\tm_subtype = gf_isom_get_media_subtype(read->mov, i+1, stsd_idx);\n\t\tswitch (m_subtype) {\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\tif (read->smode == MP4DMX_SINGLE)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/*we declare only the highest video track (i.e the track we play)*/\n\t\thighest_stream = GF_TRUE;\n\t\ttrack_id = gf_isom_get_track_id(read->mov, i+1);\n\t\tif (read->play_only_track_id && (read->play_only_track_id != track_id)) continue;\n\n\t\tif (read->play_only_first_media) {\n\t\t\tif (read->play_only_first_media != mtype) continue;\n\t\t\tif (single_media_found) continue;\n\t\t\tsingle_media_found = GF_TRUE;\n\t\t}\n\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tif (gf_isom_has_track_reference(read->mov, j+1, GF_ISOM_REF_SCAL, track_id) > 0) {\n\t\t\t\thighest_stream = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gf_isom_has_track_reference(read->mov, j+1, GF_ISOM_REF_BASE, track_id) > 0) {\n\t\t\t\thighest_stream = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((read->smode==MP4DMX_SINGLE) && (gf_isom_get_media_type(read->mov, i+1) == GF_ISOM_MEDIA_VISUAL) && !highest_stream)\n\t\t\tcontinue;\n\n\n\t\tisor_declare_track(read, NULL, i+1, stsd_idx, streamtype, use_iod);\n\n\t\tif (read->tkid)\n\t\t\tbreak;\n\t}\n\n\tif (!read->tkid) {\n\t\t/*declare image items*/\n\t\tcount = gf_isom_get_meta_item_count(read->mov, GF_TRUE, 0);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (! isor_declare_item_properties(read, NULL, i+1))\n\t\t\t\tcontinue;\n\n\t\t\tif (read->itt) break;\n\t\t}\n\t} else {\n\t\tif (!tk_found) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] TrackID %s not found in file\\n\", read->tkid ));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tif (! gf_list_count(read->channels)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] No suitable tracks in file\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\t\n\t/*if cover art, declare a video pid*/\n\tif (gf_isom_apple_get_tag(read->mov, GF_ISOM_ITUNE_COVER_ART, &tag, &tlen)==GF_OK) {\n\n\t\t/*write cover data*/\n\t\tassert(!(tlen & 0x80000000));\n\t\ttlen &= 0x7FFFFFFF;\n\n\t\tif (read->expart && !isom_contains_video) {\n\t\t\tGF_FilterPid *cover_pid=NULL;\n\t\t\te = gf_filter_pid_raw_new(read->filter, NULL, NULL, NULL, NULL, (char *) tag, tlen, GF_FALSE, &cover_pid);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t\tif (cover_pid) {\n\t\t\t\tu8 *out_buffer;\n\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\tgf_filter_pid_set_property(cover_pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\t\t\t\tgf_filter_pid_set_name(cover_pid, \"CoverArt\");\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(cover_pid, tlen, &out_buffer);\n\t\t\t\tif (dst_pck) {\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\tmemcpy(out_buffer, tag, tlen);\n\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_set_eos(cover_pid);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nBool isor_declare_item_properties(ISOMReader *read, ISOMChannel *ch, u32 item_idx)\n{\n\tGF_ImageItemProperties props;\n\tGF_FilterPid *pid;\n\tGF_ESD *esd;\n\tu32 item_id=0;\n\tu32 scheme_type=0, scheme_version=0, item_type;\n\tu32 item_codecid=0;\n\tconst char *item_name, *item_mime_type, *item_encoding;\n\nretry:\n\n\tif (item_idx>gf_isom_get_meta_item_count(read->mov, GF_TRUE, 0))\n\t\treturn GF_FALSE;\n\n\titem_name = item_mime_type = item_encoding = NULL;\n\tgf_isom_get_meta_item_info(read->mov, GF_TRUE, 0, item_idx, &item_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &item_name, &item_mime_type, &item_encoding);\n\n\tif (!item_id) return GF_FALSE;\n\tif (item_type==GF_ISOM_ITEM_TYPE_AUXI) return GF_FALSE;\n\tif (read->play_only_track_id && (read->play_only_track_id!=item_id)) return GF_FALSE;\n\n\tgf_isom_get_meta_image_props(read->mov, GF_TRUE, 0, item_id, &props, NULL);\n\n\t//check we support the protection scheme\n\tswitch (scheme_type) {\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_PIFF_SCHEME:\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\n\tesd = gf_media_map_item_esd(read->mov, item_id);\n\tif (!esd) {\n\t\tswitch (item_type) {\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\titem_codecid = GF_CODECID_HEVC_TILES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//unsupported item, try next\n\t\t\titem_idx++;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\titem_codecid = esd->decoderConfig->objectTypeIndication;\n\t}\n\n\t//OK declare PID\n\tif (!ch)\n\t\tpid = gf_filter_pid_new(read->filter);\n\telse {\n\t\tpid = ch->pid;\n\t\tch->item_id = item_id;\n\t}\n\n\n\t//do not override PID ID if itt is set\n\tif (!ch) {\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\t\t\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n\n\t//TODO: no support for LHEVC images\n\t//gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID));\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(item_codecid));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\tif (esd) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength));\n\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data=NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength=0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t}\n\n\tif (props.width && props.height) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT(props.width));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT(props.height));\n\t}\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_HIDDEN, props.hidden ? &PROP_BOOL(GF_TRUE) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_ALPHA, props.alpha ? &PROP_BOOL(GF_TRUE) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_MIRROR, props.mirror ? &PROP_UINT(props.mirror) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_ROTATE, props.alpha ? &PROP_UINT(props.angle) : NULL);\n\n\tif (props.clap_wden) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_W, &PROP_FRAC_INT(props.clap_wnum,props.clap_wden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_H, &PROP_FRAC_INT(props.clap_hnum,props.clap_hden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_X, &PROP_FRAC_INT(props.clap_honum,props.clap_hoden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_Y, &PROP_FRAC_INT(props.clap_vonum,props.clap_voden) );\n\t} else {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_W, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_H, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_X, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_Y, NULL);\n\t}\n\n\tif (gf_isom_get_meta_primary_item_id(read->mov, GF_TRUE, 0) == item_id) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PRIMARY_ITEM, &PROP_BOOL(GF_TRUE));\n\t} else {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PRIMARY_ITEM, &PROP_BOOL(GF_FALSE));\n\t}\n\n\tif (!gf_sys_is_test_mode() && !read->itt)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_NUM, &PROP_UINT(item_idx) );\n\n\tgf_filter_pid_set_property_str(pid, \"meta:mime\", item_mime_type ? &PROP_STRING(item_mime_type) : NULL );\n\tgf_filter_pid_set_property_str(pid, \"meta:name\", item_name ? &PROP_STRING(item_name) : NULL );\n\tgf_filter_pid_set_property_str(pid, \"meta:encoding\", item_encoding ? &PROP_STRING(item_encoding) : NULL );\n\n\tif ((item_type == GF_ISOM_SUBTYPE_UNCV) || (item_type == GF_ISOM_ITEM_TYPE_UNCI)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_UNCV) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW_UNCV) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ISOM_SUBTYPE,  &PROP_4CC(GF_ISOM_ITEM_TYPE_UNCI) );\n\t}\n\n\tif (item_codecid == GF_CODECID_HEVC_TILES) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(props.hOffset, props.vOffset) );\n\n\t\tu32 base_id = gf_isom_meta_get_item_ref_id(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS, 1);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, base_id ? &PROP_UINT(base_id) : NULL );\n\t}\n\n\t//setup cenc\n\tif (scheme_type) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_4CC(scheme_type) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION, &PROP_UINT(scheme_version) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ENCRYPTED, &PROP_BOOL(GF_TRUE) );\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_ENCRYPTED) );\n\t}\n\n\tif (!ch) {\n\t\tch = isor_create_channel(read, pid, 0, item_id, GF_FALSE);\n\t\tif (ch && scheme_type) {\n\t\t\tch->is_cenc = 1;\n\t\t\tch->is_encrypted = 1;\n\n\t\t\tisor_declare_pssh(ch);\n\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n#endif // !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n\n\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMF mux filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/internal/media_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MP4MX)\n\n#define TEXT_DEFAULT_WIDTH\t400\n#define TEXT_DEFAULT_HEIGHT\t60\n#define TEXT_DEFAULT_FONT_SIZE\t18\n\n#define GF_VENDOR_GPAC\t\tGF_4CC('G','P','A','C')\n\n#define GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF (GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF+1)\n\n#define ISOM_FILE_EXT \"mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|ismv|m4s|heif|heic|iff|avci|avif|mj2|mov|qt\"\n#define ISOM_FILE_MIME \"video/mp4|audio/mp4|application/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/jp2|video/quicktime\"\n\nenum{\n\tNALU_NONE,\n\tNALU_AVC,\n\tNALU_HEVC,\n\tNALU_VVC\n};\n\n\nenum\n{\n\tCENC_NONE=0,\n\tCENC_NEED_SETUP,\n\tCENC_SETUP_DONE,\n\tCENC_SETUP_ERROR\n};\n\nenum{\n\tTAG_NONE,\n\tTAG_STRICT,\n\tTAG_ALL\n};\n\nenum\n{\n\tXPS_IB_NO = 0,\n\tXPS_IB_PPS,\n\tXPS_IB_ALL,\n\tXPS_IB_BOTH,\n\tXPS_IB_MIX,\n\tXPS_IB_AUTO\n};\n\ntypedef struct\n{\n\tGF_FilterPid *ipid;\n\tu32 track_num, track_id;\n\tGF_ISOSample sample;\n\tu32 prev_duration;\n\n\tu32 src_timescale;\n\tu32 tk_timescale;\n\tu32 stream_type;\n\tu32 codecid;\n\tBool is_encrypted;\n\n\tu32 cfg_crc, enh_cfg_crc;\n\tu32 dep_id;\n\tu32 stsd_idx;\n\tu32 clear_stsd_idx;\n\tBool reused_stsd;\n\n\tBool use_dref;\n\tBool aborted;\n\tBool suspended;\n\tBool has_append;\n\tBool has_ctts;\n\ts64 min_neg_ctts;\n\tu32 nb_samples, samples_in_stsd;\n\tu32 nb_frames_per_sample;\n\tu64 ts_shift;\n\tu64 si_min_ts_plus_one;\n\tBool has_subs;\n\n\tBool skip_bitrate_update;\n\tBool has_open_gop;\n\tGF_FilterSAPType gdr_type;\n\n\tu32 media_profile_level;\n\n\tBool import_msg_header_done;\n\n\tu32 nal_unit_size;\n\n\tGF_AVCConfig *avcc, *svcc;\n\tGF_HEVCConfig *hvcc, *lvcc;\n\tGF_VVCConfig *vvcc;\n\n\tu8 *inband_hdr, *inband_hdr_non_rap;\n\tu32 inband_hdr_size, inband_hdr_non_rap_size;\n\tu32 is_nalu;\n\tBool is_av1, is_vpx;\n\tBool fragment_done;\n\ts32 ts_delay, negctts_shift;\n\tBool insert_tfdt, probe_min_ctts;\n\tu64 first_dts_in_seg_plus_one, next_seg_cts, cts_next;\n\ts64 tfdt_offset;\n\tu32 samples_in_frag;\n\tBool patch_tfdt;\n\n\t//0: not cenc, 1: needs setup of stsd entry, 2: setup done\n\tu32 cenc_state;\n\tBool cenc_subsamples;\n\tu32 scheme_type;\n\tu32 def_skip_byte_block, def_crypt_byte_block;\n\tu32 def_cenc_key_info_crc;\n\tconst GF_PropertyValue *cenc_ki;\n\tu32 cenc_key_info_crc;\n\tu32 constant_IV_size;\n\tBool cenc_multikey;\n\tBool cenc_frag_protected;\n\tu32 skip_byte_block, crypt_byte_block;\n\n\tBool fake_track;\n\n\tBool has_brands;\n\tBool force_inband_inject;\n\n\tu64 dur_in_frag;\n\n\tu32 amr_mode_set;\n\tBool has_seig;\n\tu64 empty_init_dur;\n\tu32 raw_audio_bytes_per_sample, raw_samplerate;\n\tu64 dts_patch;\n\n\tBool is_item;\n\tu32 item_id;\n\tchar status_type;\n\tu32 last_import_pc;\n\n\tu32 nb_frames, frame_offset;\n\tu64 down_bytes, down_size;\n\tGF_Fraction64 pid_dur;\n\t//for import message\n\tu64 prog_done, prog_total;\n\n\tu32 prev_tid_group;\n\n\tBool box_patched;\n\n\tu64 imported_edit_sdur, imported_edit_offset;\n\n\tBool force_ctts;\n\n\tBool is_hevc_tile_base;\n\tBool insert_pssh;\n\n\tBool wait_sap;\n\tu64 min_ts_seek_plus_one;\n\tu64 clamp_ts_plus_one;\n\tBool check_seek_ts;\n\n\tu64 max_cts, min_cts;\n\tu32 max_cts_samp_dur;\n\n\tu32 w_or_sr, h_or_ch, pf_or_af;\n\tu32 xps_inband;\n\n\tu8 *dyn_pssh;\n\tu32 dyn_pssh_len;\n\n\tBool sparse_inject;\n\tBool is_chap;\n\n\tGF_FilterPacket *dgl_copy;\n\tu32 all_stsd_crc;\n} TrackWriter;\n\nenum\n{\n\tMP4MX_MODE_INTER=0,\n\tMP4MX_MODE_FLAT,\n\tMP4MX_MODE_FASTSTART,\n\tMP4MX_MODE_TIGHT,\n\tMP4MX_MODE_FRAG,\n\tMP4MX_MODE_SFRAG,\n};\n\n\nenum\n{\n\tMP4MX_DASH_OFF=0,\n\tMP4MX_DASH_ON,\n\tMP4MX_DASH_VOD,\n};\n\nenum\n{\n\tMP4MX_PSSH_MOOV=0,\n\tMP4MX_PSSH_MOOF,\n\tMP4MX_PSSH_BOTH,\n\tMP4MX_PSSH_SKIP,\n};\n\nenum\n{\n\tMP4MX_CT_EDIT=0,\n\tMP4MX_CT_NOEDIT,\n\tMP4MX_CT_NEGCTTS,\n};\n\nenum\n{\n\tMP4MX_VODCACHE_ON=0,\n\tMP4MX_VODCACHE_INSERT,\n\tMP4MX_VODCACHE_REPLACE,\n};\n\nenum\n{\n\tMP4MX_CMAF_NO=0,\n\tMP4MX_CMAF_CMFC,\n\tMP4MX_CMAF_CMF2,\n};\n\nenum\n{\n\tMP4MX_CHAPM_OFF=0,\n\tMP4MX_CHAPM_TRACK,\n\tMP4MX_CHAPM_UDTA,\n\tMP4MX_CHAPM_BOTH\n};\n\nenum\n{\n\tMP4MX_UNCV_OFF=0,\n\tMP4MX_UNCV_NOPROF,\n\tMP4MX_UNCV_PROF,\n\tMP4MX_UNCV_PROF_ONLY\n};\n\n\ntypedef struct\n{\n\t//filter args\n\tGF_ISOFile *file;\n\tBool m4sys, dref;\n\tGF_Fraction dur;\n\tu32 pack3gp, ctmode;\n\tBool importer, pack_nal, moof_first, abs_offset, fsap, tfdt_traf, keep_utc, pps_inband;\n\tu32 xps_inband, moovpad;\n\tu32 block_size;\n\tu32 store, tktpl, mudta;\n\ts32 subs_sidx;\n\tGF_Fraction cdur;\n\ts32 moovts;\n\tchar *m4cc;\n\tBool chain_sidx;\n\tu32 msn, msninc;\n\tGF_Fraction64 tfdt;\n\tBool nofragdef, straf, strun, sgpd_traf, noinit;\n\tu32 vodcache;\n\tu32 psshs;\n\tu32 trackid;\n\tBool fragdur;\n\tBool btrt;\n\tBool ssix;\n\tBool ccst;\n\ts32 mediats;\n\tGF_AudioSampleEntryImportMode ase;\n\tchar *styp;\n\tBool sseg;\n\tBool noroll, norap;\n\tBool saio32, tfdt64;\n\tu32 compress;\n\tBool trun_inter;\n\tBool truns_first;\n\tchar *boxpatch;\n\tBool fcomp, otyp;\n\tBool deps;\n\tBool mvex;\n\tBool trunv1;\n\tu32 sdtp_traf;\n\tu32 cmaf;\n#ifdef GF_ENABLE_CTRN\n\tBool ctrn;\n\tBool ctrni;\n#endif\n\tBool mfra;\n\tu32 uncv;\n\tBool forcesync, refrag, pad_sparse;\n\tBool force_dv, tsalign, dvsingle, patch_dts;\n\tu32 itags;\n\tDouble start;\n\tu32 chapm;\n\n\n\t//internal\n\tGF_Filter *filter;\n\tBool owns_mov;\n\tGF_FilterPid *opid;\n\tBool first_pck_sent;\n\n\tGF_List *tracks;\n\n\tGF_BitStream *bs_r;\n\t//fragmentation state\n\tBool init_movie_done, fragment_started, segment_started, insert_tfdt, insert_pssh, cdur_set;\n\n\tu64 next_frag_start, adjusted_next_frag_start;\n\n\tu64 current_offset;\n\tu64 current_size;\n\n\tu32 nb_segs, nb_frags, nb_frags_in_seg;\n\n\tGF_FilterPacket *dst_pck;\n\tchar *seg_name;\n\tu32 dash_seg_num_plus_one;\n\tGF_Fraction64 dash_seg_start;\n\n\tBool flush_seg;\n\tu32 eos_marker;\n\tTrackWriter *ref_tkw;\n\tBool single_file;\n\tBool store_output;\n\tFILE *tmp_store;\n\tu64 flush_size, flush_done;\n\n\tu32 dash_mode, llhls_mode;\n\tGF_Fraction dash_dur;\n\tDouble media_dur;\n\tu32 sidx_max_size, sidx_chunk_offset;\n\tBool final_sidx_flush;\n\tBool sidx_size_exact;\n\n\tu32 *seg_sizes;\n\tu32 nb_seg_sizes, alloc_seg_sizes, config_retry_start;\n\tBool config_timing;\n\n\tu32 major_brand_set;\n\tBool def_brand_patched;\n\n\tBool force_play;\n\n\tBool moov_inserted;\n\tBool update_report;\n\tu64 total_bytes_in, total_bytes_out;\n\tu32 total_samples, last_mux_pc;\n\n\tu32 maxchunk;\n\tu32 make_qt;\n\tTrackWriter *prores_track;\n\n\tGF_SegmentIndexBox *cloned_sidx;\n\tu32 cloned_sidx_index;\n\tGF_Fraction faststart_ts_regulate;\n\n\tBool is_rewind;\n\tBool box_patched;\n\tu32 cur_file_idx_plus_one;\n\tchar *cur_file_suffix;\n\tBool notify_filename;\n\n\tu32 next_file_idx;\n\tconst char *next_file_suffix;\n\n\t//for route scheduling\n\tu64 min_cts_plus_one, next_seg_start;\n\tu64 min_cts_next_frag;\n\n\tu64 frag_size, frag_offset;\n\tu32 frag_num;\n\tu64 frag_duration;\n\tu32 frag_timescale;\n\tBool frag_has_intra;\n\n\tu64 wait_dts_plus_one;\n\tu32 wait_dts_timescale;\n\tBool force_seg_sync;\n\tu32 seg_flush_state;\n\tu64 flush_idx_start_range, flush_idx_end_range;\n\tBool flush_ll_hls;\n\n\tBool has_def_vid, has_def_aud, has_def_txt;\n\n\t//created from chapters prop\n\tu32 chap_track_num;\n\tBool has_chap_tracks;\n\n\tGF_List *ref_pcks;\n} GF_MP4MuxCtx;\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust);\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw);\n\nstatic GF_Err mp4mx_setup_dash_vod(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tif (tkw) {\n\t\tconst GF_PropertyValue *p;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_DUR);\n\t\tif (p) {\n\t\t\tctx->dash_dur = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\tDouble mdur = (Double) p->value.lfrac.num;\n\t\t\tif (mdur<0) mdur = -mdur;\n\t\t\tmdur /= p->value.lfrac.den;\n\t\t\tif (ctx->media_dur < mdur) ctx->media_dur = mdur;\n\t\t}\n\t}\n\tctx->dash_mode = MP4MX_DASH_VOD;\n\tctx->llhls_mode = 0;\n\tif ((ctx->vodcache==MP4MX_VODCACHE_ON) && !ctx->tmp_store) {\n\t\tctx->tmp_store = gf_file_temp(NULL);\n\t\tif (!ctx->tmp_store) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot allocate temp file for VOD sidx generation\\n\"));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tif (!ctx->block_size) ctx->block_size = 10000;\n\t}\n\n\treturn GF_OK;\n}\n\n\nstatic u32 gf_isom_stream_type_to_media_type(u32 stream_type, u32 codecid)\n{\n\tswitch (stream_type) {\n\tcase GF_STREAM_SCENE: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_OD: return GF_ISOM_MEDIA_OD;\n\tcase GF_STREAM_OCR: return GF_ISOM_MEDIA_OCR;\n\tcase GF_STREAM_OCI: return GF_ISOM_MEDIA_OCI;\n\tcase GF_STREAM_MPEG7: return GF_ISOM_MEDIA_MPEG7;\n\tcase GF_STREAM_METADATA: return GF_ISOM_MEDIA_META;\n\tcase GF_STREAM_VISUAL: return GF_ISOM_MEDIA_VISUAL;\n\tcase GF_STREAM_AUDIO: return GF_ISOM_MEDIA_AUDIO;\n\tcase GF_STREAM_TEXT:\n\t\tif (codecid==GF_ISOM_SUBTYPE_STPP)\n\t\t\treturn GF_ISOM_MEDIA_MPEG_SUBT;\n\t\tif (codecid == GF_CODECID_SUBPIC)\n\t\t\treturn GF_ISOM_MEDIA_SUBPIC;\n\t\treturn GF_ISOM_MEDIA_TEXT;\n\tcase GF_STREAM_INTERACT: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_IPMP: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_MPEGJ: return GF_ISOM_MEDIA_MPEGJ;\n\tcase GF_STREAM_IPMP_TOOL: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_FONT: return GF_ISOM_MEDIA_MPEGJ;//TOCHECK !!\n\n\tcase GF_STREAM_PRIVATE_SCENE:\n\tcase GF_STREAM_ENCRYPTED:\n\tcase GF_STREAM_FILE:\n\t\treturn 0;\n\tdefault:\n\t\treturn stream_type;\n\t}\n\treturn 0;\n}\n\nstatic void mp4_mux_write_ps_list(GF_BitStream *bs, GF_List *list, u32 nalu_size_length)\n{\n\tu32 i, count = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(list, i);\n\t\tgf_bs_write_int(bs, sl->size, 8*nalu_size_length);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\nstatic GF_List *mp4_mux_get_nalus_ps(GF_List *list, u8 type)\n{\n\tu32 i, count = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(list, i);\n\t\tif (pa->type == type) return pa->nalus;\n\t}\n\treturn NULL;\n}\n\nstatic void mp4_mux_make_inband_header(GF_MP4MuxCtx *ctx, TrackWriter *tkw, Bool for_non_rap)\n{\n\tGF_BitStream *bs;\n\tif (for_non_rap) {\n\t\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\t\ttkw->inband_hdr_non_rap = NULL;\n\t} else {\n\t\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\t\ttkw->inband_hdr = NULL;\n\t}\n\n\ttkw->nal_unit_size = 0;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (tkw->avcc || tkw->svcc) {\n\t\tif (tkw->avcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSets, tkw->avcc->nal_unit_size);\n\t\t\t/*if (!tkw->nal_unit_size) */tkw->nal_unit_size = tkw->avcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->svcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSets, tkw->svcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->svcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->avcc && tkw->avcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSetExtensions, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc && tkw->svcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSetExtensions, tkw->svcc->nal_unit_size);\n\n\t\tif (tkw->avcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->pictureParameterSets, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->pictureParameterSets, tkw->svcc->nal_unit_size);\n\t}\n\tif (tkw->hvcc || tkw->lvcc) {\n\t\tif (tkw->hvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->hvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->hvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->lvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->lvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->hvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->lvcc->nal_unit_size);\n\t\tif (tkw->hvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->lvcc->nal_unit_size);\n\t}\n\n\tif (tkw->vvcc) {\n\t\tif (tkw->xps_inband==XPS_IB_PPS) {\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t} else {\n\t\t\tif (!for_non_rap) {\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_OPI), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_DEC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_VID_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_SEQ_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t}\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t}\n\t}\n\n\tif (for_non_rap) {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr_non_rap, &tkw->inband_hdr_non_rap_size);\n\t} else {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr, &tkw->inband_hdr_size);\n\t}\n\tgf_bs_del(bs);\n\t//we may have cases where the param sets are updated before a non-IDR/SAP3 picture, we must inject asap at least once\n\ttkw->force_inband_inject = GF_TRUE;\n}\n\nvoid mp4_mux_get_video_size(GF_MP4MuxCtx *ctx, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(ctx->file); i++) {\n\t\tswitch (gf_isom_get_media_type(ctx->file, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tgf_isom_get_visual_info(ctx->file, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\t//fallthrough\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\tgf_isom_get_track_layout_info(ctx->file, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TEXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TEXT_DEFAULT_HEIGHT;\n}\n\nstatic void mp4_mux_track_writer_del(TrackWriter *tkw)\n{\n\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\tif (tkw->dgl_copy) gf_filter_pck_discard(tkw->dgl_copy);\n\tgf_free(tkw);\n}\n\nstatic void mp4_mux_write_track_refs(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const char *rname, u32 rtype, Bool remove_from_pres)\n{\n\tu32 i;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(tkw->ipid, rname);\n\tif (!p) return;\n\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, rtype, p->value.uint_list.vals[i]);\n\t\tif (remove_from_pres) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t}\n\t}\n}\n\nstatic void mp4mux_track_reorder(void *udta, u32 old_track_num, u32 new_track_num)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) udta;\n\tu32 i, count;\n\n\tif (ctx->chap_track_num==old_track_num) {\n\t\tctx->chap_track_num = new_track_num;\n\t\treturn;\n\t}\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\tif (tkw->track_num==old_track_num) {\n\t\t\ttkw->track_num = new_track_num;\n\t\t\t//prevent any further changes, trackID is restored in mp4mux_reorder_tracks\n\t\t\ttkw->track_id = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void mp4mux_reorder_tracks(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, count, prev_num, prev_pos;\n\tGF_List *new_tracks = gf_list_new();\n\tprev_num = prev_pos = 0;\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id)\n\t\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tif (tkw->track_num<prev_num) {\n\t\t\tgf_list_insert(new_tracks, tkw, prev_pos);\n\t\t} else {\n\t\t\tgf_list_add(new_tracks, tkw);\n\t\t}\n\t\tprev_pos = gf_list_count(new_tracks) - 1;\n\t\tprev_num = tkw->track_num;\n\t}\n\tif (gf_list_count(new_tracks)!=count) {\n\t\tgf_list_del(new_tracks);\n\t\treturn;\n\t}\n\tgf_list_del(ctx->tracks);\n\tctx->tracks = new_tracks;\n}\n\nstatic void mp4mx_set_track_group(GF_MP4MuxCtx *ctx, TrackWriter *tkw, char *name, const GF_PropertyValue *p)\n{\n\ts32 grp_id=0;\n\tu32 grp_type;\n\tu32 len = (u32) strlen(name);\n\tBool do_add=GF_TRUE;\n\tif (len!=4) return;\n\n\tif ((p->type==GF_PROP_STRING) || (p->type==GF_PROP_NAME)) {\n\t\tgrp_id = atoi(p->value.string);\n\t} else {\n\t\tgrp_id = p->value.sint;\n\t}\n\tif (grp_id<0) {\n\t\tgrp_id = -grp_id;\n\t\tdo_add = GF_FALSE;\n\t}\n\tgrp_type = GF_4CC(name[0], name[1], name[2], name[3]);\n\tgf_isom_set_track_group(ctx->file, tkw->track_num, grp_id, grp_type, do_add);\n}\n\n\n#include <gpac/revision.h>\nstatic void mp4_mux_set_tags(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\n\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat() ) {\n\t\tconst char *tool = \"GPAC-\"GPAC_VERSION\"-rev\"GPAC_GIT_REVISION;\n\t\tu32 len = (u32) strlen(tool);\n\t\tgf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_TOOL, tool, len, 0, 0);\n\t}\n\n\tif (ctx->itags==TAG_NONE) return;\n\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 len;\n\t\tu32 prop_4cc=0;\n\t\tu32 itag;\n\t\ts32 tag_idx;\n\t\tconst char *tag_name=NULL;\n\t\tconst GF_PropertyValue *tag = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &tag_name);\n\t\tif (!tag) break;\n\n\t\tif (prop_4cc==GF_PROP_PID_COVER_ART) {\n\t\t\te = gf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_COVER_ART, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set cover art: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t}\n\t\tif (!tag_name)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(tag_name, \"tkgp_\", 5)) {\n\t\t\tmp4mx_set_track_group(ctx, tkw, (char*) tag_name+5, tag);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag_idx = gf_itags_find_by_name(tag_name);\n\t\tif (tag_idx>=0) {\n\t\t\titag = gf_itags_get_itag(tag_idx);\n\t\t} else if (!strnicmp(tag_name, \"qtt_\", 4)) {\n\t\t\ttag_name += 4;\n\n\t\t\tswitch (tag->type) {\n\t\t\tcase GF_PROP_DATA:\n\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\t{\n\t\t\t\tGF_QT_UDTAKey key;\n\t\t\t\tkey.type = GF_QT_KEY_OPAQUE;\n\t\t\t\tkey.name = tag_name;\n\t\t\t\tkey.ns = GF_4CC('m','d','t','a');\n\t\t\t\tchar *sep = strchr(tag_name, '@');\n\t\t\t\tif (sep) {\n\t\t\t\t\tkey.name = sep+1;\n\t\t\t\t\tkey.ns = GF_4CC(tag_name[0], tag_name[1],tag_name[2],tag_name[3]);\n\t\t\t\t}\n\t\t\t\tkey.value.data.data = tag->value.data.ptr;\n\t\t\t\tkey.value.data.data_len = tag->value.data.size;\n\t\t\t\te = gf_isom_set_qt_key(ctx->file, &key);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_POINTER:\n\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\t\t\t\tconst char *str = gf_props_dump_val(tag, szDump, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\t\t\te = gf_media_isom_apply_qt_key(ctx->file, tag_name, str);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set QT tag: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (ctx->itags==TAG_STRICT)\n\t\t\t\tcontinue;\n\n\t\t\tif (strnicmp(tag_name, \"tag_\", 4))\n\t\t\t\tcontinue;\n\n\t\t\ttag_name += 4;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized tag %s: %s\\n\", tag_name, tag->value.string));\n\n\t\t\tif (strlen(tag_name)==4) {\n\t\t\t\titag = GF_4CC(tag_name[0], tag_name[1], tag_name[2], tag_name[3]);\n\t\t\t} else if (strlen(tag_name)==3) {\n\t\t\t\titag = GF_4CC(0xA9, tag_name[0], tag_name[1], tag_name[2]);\n\t\t\t} else {\n\t\t\t\titag = gf_crc_32(tag_name, (u32) strlen(tag_name));\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] Tag name %s is not a 4CC, using CRC32 %08X as value\\n\", tag_name, itag));\n\t\t\t}\n\t\t}\n\n\t\tif (itag==GF_ISOM_ITUNE_TOOL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag->type) {\n\t\tcase GF_PROP_STRING:\n\t\tcase GF_PROP_NAME:\n\t\t\tlen = tag->value.string ? (u32) strlen(tag->value.string) : 0;\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.string, len, 0, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_BOOL:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.boolean, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_UINT:\n\t\tcase GF_PROP_4CC:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.uint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_LUINT:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.longuint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.frac.num, tag->value.frac.den);\n\t\t\tbreak;\n\t\tcase GF_PROP_DATA:\n\t\tcase GF_PROP_CONST_DATA:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: invalid data format\\n\", gf_itags_get_name(tag_idx) ));\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: %s\\n\", tag_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void mp4_mux_set_udta(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 prop_4cc=0;\n\t\tconst char *udta_name=NULL;\n\t\tconst GF_PropertyValue *udta = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &udta_name);\n\t\tif (!udta) break;\n\t\tif (!udta_name)\n\t\t\tcontinue;\n\t\tif (!strncmp(udta_name, \"udta_\", 5) || !strncmp(udta_name, \"mudta_\", 6) ) {\n\t\t\tu32 udta_type;\n\t\t\tu8 *data=NULL;\n\t\t\tu32 size=0;\n\t\t\tu32 track_num = 0;\n\n\t\t\tif (!strncmp(udta_name, \"udta_\", 5)) {\n\t\t\t\tudta_name += 5;\n\t\t\t\ttrack_num = tkw->track_num;\n\t\t\t} else {\n\t\t\t\tudta_name += 6;\n\t\t\t}\n\n\t\t\tif (strlen(udta_name) != 4) continue;\n\t\t\tudta_type = GF_4CC(udta_name[0], udta_name[1], udta_name[2], udta_name[3]);\n\n\t\t\tif (udta->type==GF_PROP_DATA) {\n\t\t\t\tdata = (u8 *) udta->value.data.ptr;\n\t\t\t\tsize = udta->value.data.size;\n\t\t\t} else if ((udta->type == GF_PROP_STRING) && udta->value.string) {\n\t\t\t\tdata = (u8 *) udta->value.string;\n\t\t\t\tsize = (u32) strlen(udta->value.string)+1;\n\t\t\t}\n\t\t\tif (!data) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_user_data(ctx->file, track_num, udta_type, NULL, data, size);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(udta_name, \"udtab\") || !strcmp(udta_name, \"mudtab\")) {\n\t\t\tu32 track_num = (!strcmp(udta_name, \"mudtab\")) ? 0 : tkw->track_num;\n\t\t\tif (udta->type == GF_PROP_DATA) {\n\t\t\t\te = gf_isom_add_user_data_boxes(ctx->file, track_num, udta->value.data.ptr, udta->value.data.size);\n\t\t\t} else {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set udta %s: %s\\n\", udta_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void update_chap_refs(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, j, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->is_chap) continue;\n\t\tfor (j=0; j<count; j++) {\n\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\tif (atkw->is_chap) continue;\n\t\t\tif ((atkw->stream_type==GF_STREAM_AUDIO) || (atkw->stream_type==GF_STREAM_VISUAL))\n\t\t\t\tgf_isom_set_track_reference(ctx->file, atkw->track_num, GF_ISOM_REF_CHAP, tkw->track_id);\n\t\t}\n\t}\n}\n\n\n\nstatic GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_true_pid)\n{\n\tvoid mux_assign_mime_file_ext(GF_FilterPid *ipid, GF_FilterPid *opid, const char *file_exts, const char *mime_types, const char *def_ext);\n\tBool use_m4sys = GF_FALSE;\n\tBool use_tx3g = GF_FALSE;\n\tBool use_webvtt = GF_FALSE;\n\tBool needs_track = GF_FALSE;\n\tu32 needs_sample_entry = 0; //1: change of codecID, 2 change of decoder config\n\tBool use_gen_sample_entry = GF_FALSE;\n\tBool skip_crypto = GF_FALSE;\n\tBool use_3gpp_config = GF_FALSE;\n\tBool use_ac3_entry = GF_FALSE;\n\tBool use_flac_entry = GF_FALSE;\n\tBool use_avc = GF_FALSE;\n\tBool use_hevc = GF_FALSE;\n\tBool use_vvc = GF_FALSE;\n\tBool use_hvt1 = GF_FALSE;\n\tBool use_av1 = GF_FALSE;\n\tBool use_vpX = GF_FALSE;\n\tBool use_mj2 = GF_FALSE;\n\tBool use_opus = GF_FALSE;\n\tBool use_dref = GF_FALSE;\n\tBool skip_dsi = GF_FALSE;\n\tBool is_text_subs = GF_FALSE;\n\tBool force_colr = GF_FALSE;\n\tu32 gen_dsi_wrap = 0;\n\tu32 m_subtype=0;\n\tu32 m_subtype_src=0;\n\tu32 m_subtype_alt_raw=0;\n\tu32 override_stype=0;\n\tu32 width, height, sr, nb_chan, nb_bps, z_order, txt_fsize;\n\tu32 afmt_flags = 0;\n\tu64 ch_layout;\n\tGF_Fraction fps, sar;\n\tGF_List *multi_pid_stsd = NULL;\n\tu32 multi_pid_idx = 0;\n\tGF_FilterPid *orig_pid = NULL;\n\tu32 codec_id, pix_fmt=0;\n\tu32 frames_per_sample_backup=0;\n\tu32 is_nalu_backup = NALU_NONE;\n\tBool is_tile_base = GF_FALSE;\n\tBool unknown_generic = GF_FALSE;\n\tu32 multi_pid_final_stsd_idx = 0;\n\tu32 audio_pli=0;\n\tu32 prev_codecid=0;\n\tBool force_tk_layout = GF_FALSE;\n\tBool force_mix_xps = GF_FALSE;\n\tBool make_inband_headers = GF_FALSE;\n\tBool is_prores = GF_FALSE;\n\tconst char *lang_name = NULL;\n\tconst char *comp_name = NULL;\n\tconst char *imp_name = NULL;\n\tconst char *src_url = NULL;\n\tconst char *meta_mime = NULL;\n\tconst char *meta_encoding = NULL;\n\tconst char *meta_config = NULL;\n\tconst char *meta_xmlns = NULL;\n\tconst char *meta_schemaloc = NULL;\n\tconst char *meta_auxmimes = NULL;\n\tconst char *meta_content_encoding = NULL;\n\tchar *txt_font = NULL;\n\n\tu32 i, count, reuse_stsd = 0;\n\tGF_Err e;\n\tconst GF_PropertyValue *dsi=NULL;\n\tconst GF_PropertyValue *enh_dsi=NULL;\n\tconst GF_PropertyValue *p;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_AudioSampleEntryImportMode ase_mode = ctx->ase;\n\tTrackWriter *tkw;\n\tu32 xps_inband = XPS_IB_NO;\n\n\tif (ctx->owns_mov && !ctx->opid) {\n\t\tchar *dst;\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\t\tdst = gf_filter_get_dst_name(filter);\n\t\tif (dst) {\n\t\t\tchar *ext = gf_file_ext_start(dst);\n\t\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\t\tctx->make_qt = 1;\n\t\t\t}\n\t\t\tgf_free(dst);\n\t\t}\n\t} else {\n\t\tconst char *fname = gf_isom_get_filename(ctx->file);\n\t\tchar *ext = fname ? gf_file_ext_start(fname) : NULL;\n\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\tctx->make_qt = 1;\n\t\t}\n\t}\n\t//copy properties at init or reconfig\n\tif (ctx->opid && is_true_pid) {\n\t\tgf_filter_pid_copy_properties(ctx->opid, pid);\n\t\tif (gf_list_count(ctx->tracks)>1)\n\t\t\tgf_filter_pid_set_name(ctx->opid, \"isobmf_mux\");\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\n\t\tmux_assign_mime_file_ext(pid, ctx->opid, ISOM_FILE_EXT, ISOM_FILE_MIME, NULL);\n\t\t\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DASH_MODE, NULL);\n\t\t//we dispatch timing in milliseconds\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_FLAT:\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\tgf_filter_pid_allow_direct_dispatch(ctx->opid);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\tif (p && p->value.boolean)\n\t\tis_tile_base = GF_TRUE;\n\n\tif (is_true_pid && !is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tu32 j, count2;\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tconst GF_PropertyValue *a_pidid = gf_filter_pid_get_property(a_ipid, GF_PROP_PID_ID);\n\t\t\t\tcount2 = gf_list_count(ctx->tracks);\n\t\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\t\t\tconst GF_PropertyValue *c_pidid = gf_filter_pid_get_property(atkw->ipid, GF_PROP_PID_ID);\n\t\t\t\t\tif (gf_props_equal(a_pidid, c_pidid)) {\n\t\t\t\t\t\ta_ipid = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a_ipid)\n\t\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\taudio_pli = gf_isom_get_pl_indication(ctx->file, GF_ISOM_PL_AUDIO);\n\n\t//new pid ?\n\ttkw = gf_filter_pid_get_udta(pid);\n\tif (!tkw) {\n\t\tGF_FilterEvent evt;\n\t\tGF_SAFEALLOC(tkw, TrackWriter);\n\t\tif (!tkw) return GF_OUT_OF_MEM;\n\t\t\n\t\tgf_list_add(ctx->tracks, tkw);\n\t\ttkw->ipid = pid;\n\t\ttkw->fake_track = !is_true_pid;\n\t\ttkw->min_cts = (u64) -1;\n\n\t\tif (is_true_pid) {\n\t\t\tgf_filter_pid_set_udta(pid, tkw);\n\n\t\t\ttkw->is_hevc_tile_base = is_tile_base;\n#ifdef GPAC_ENABLE_COVERAGE\n\t\t\tif (gf_sys_is_cov_mode()) {\n\t\t\t\tgf_filter_pid_get_min_pck_duration(pid);\n\t\t\t}\n#endif\n\t\t\tif (!ctx->owns_mov || ctx->force_play) {\n\t\t\t\tif (!ctx->owns_mov) {\n\t\t\t\t\tif (ctx->start != 0)\n\t\t\t\t\t\ttkw->wait_sap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_init_play_event(pid, &evt, ctx->start, 0, \"MP4Mux\");\n\t\t\t\t} else {\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_send_event(pid, &evt);\n\t\t\t}\n\t\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ITEM_ID);\n\t\t\tif (p) {\n\t\t\t\ttkw->is_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tctx->config_timing = GF_TRUE;\n\t\t\t\tctx->update_report = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check change of pid config\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->dep_id) needs_track = GF_TRUE;\n\t\ttkw->dep_id = p->value.uint;\n\t}\n\n\t//check change of pid config\n\tprev_codecid = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->codecid) needs_sample_entry = 1;\n\t\ttkw->codecid = p->value.uint;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) {\n\t\tu32 stype = p->value.uint;\n\t\tif (tkw->is_encrypted && (p->value.uint==GF_STREAM_ENCRYPTED) ) {\n\t\t\tstype = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tif (stype != tkw->stream_type) {\n\t\t\tneeds_track = GF_TRUE;\n\t\t\ttkw->stream_type = stype;\n\t\t\tconst char *name = gf_stream_type_name(stype);\n\t\t\ttkw->status_type = name ? name[0] : 'U';\n\t\t}\n\t}\n\n\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tif (dsi) {\n\t\tu32 cfg_crc = gf_crc_32(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->cfg_crc = cfg_crc;\n\t} else if (tkw->cfg_crc) {\n\t\ttkw->cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tif (enh_dsi && (enh_dsi->type==GF_PROP_DATA) ) {\n\t\tu32 cfg_crc = gf_crc_32(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->enh_cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->enh_cfg_crc = cfg_crc;\n\t} else if (tkw->enh_cfg_crc) {\n\t\ttkw->enh_cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\t//store current cenc pattern if any\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\tif (p) {\n\t\ttkw->skip_byte_block = p->value.frac.num;\n\t\ttkw->crypt_byte_block = p->value.frac.den;\n\t} else {\n\t\ttkw->skip_byte_block = tkw->crypt_byte_block = 0;\n\t}\n\n\t//TODO: try to merge PPS/SPS for AVC and HEVC rather than creating a new sample description\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\tcase GF_CODECID_MPEG4_PART2:\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\tcase GF_CODECID_VP8:\n\tcase GF_CODECID_VP9:\n\tcase GF_CODECID_AV1:\n\tcase GF_CODECID_AC3:\n\tcase GF_CODECID_EAC3:\n\tcase GF_CODECID_OPUS:\n\tcase GF_CODECID_TRUEHD:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_APCH:\n\tcase GF_CODECID_APCO:\n\tcase GF_CODECID_APCN:\n\tcase GF_CODECID_APCS:\n\tcase GF_CODECID_AP4X:\n\tcase GF_CODECID_AP4H:\n\t\tif (!ctx->make_qt) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] ProRes track detected, muxing to QTFF even though ISOBMFF was asked\\n\"));\n\t\t\tctx->make_qt = 2;\n\t\t}\n\t\tif (ctx->prores_track && (ctx->prores_track != tkw)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] More than one ProRes track detected, result might be non compliant\\n\"));\n\t\t}\n\t\tis_prores = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_TX3G:\n\tcase GF_CODECID_WEBVTT:\n\tcase GF_CODECID_DVB_SUBS:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!tkw->track_num) {\n\t\tneeds_sample_entry = 1;\n\t\tneeds_track = GF_TRUE;\n\t}\n\n\tif (ctx->make_qt) {\n\t\tgf_isom_remove_root_od(ctx->file);\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_QT, 512);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\ttkw->has_brands = GF_TRUE;\n\t\tctx->major_brand_set = GF_ISOM_BRAND_QT;\n\t\tctx->btrt = GF_FALSE;\n\n\t\tif (is_prores && !ctx->prores_track) {\n\t\t\tctx->prores_track = tkw;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\tif (p) src_url = p->value.string;\n\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MODE);\n\tif (p) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t\tif (p->value.uint==2) {\n\t\t\te = mp4mx_setup_dash_vod(ctx, tkw);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t//we consider that when muxing single segments, we are always in DASH, not VoD mode\n\telse if (ctx->noinit) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LLHLS);\n\tctx->llhls_mode = p ? p->value.uint : 0;\n\t//insert tfdt in each traf for LL-HLS so that correct timing can be found when doing in-segment tune-in\n\tif (ctx->llhls_mode) {\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\tctx->store = MP4MX_MODE_SFRAG;\n\t}\n\n\tif (ctx->dash_mode == MP4MX_DASH_ON) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FORCE_SEG_SYNC);\n\t\tif (p && p->value.boolean)\n\t\t\tctx->force_seg_sync = GF_TRUE;\n\t}\n\n\tif (!ctx->cdur_set) {\n\t\tctx->cdur_set = GF_TRUE;\n\t\tif (ctx->cdur.num<0) {\n\t\t\tif (ctx->make_qt) {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 2000;\n\t\t\t} else {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 1000;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->fragdur = GF_FALSE;\n\t\t\t}\n\t\t} else if (ctx->dash_mode)\n\t\t\tctx->fragdur = GF_TRUE;\n\t}\n\n\tif (needs_track) {\n\t\tif (ctx->init_movie_done) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add track to already finalized movie in fragmented file, will request a new muxer for that track\\n\"));\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (tkw->is_item) {\n\t\t\tneeds_track = GF_FALSE;\n\n\t\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t\t\ttkw->insert_pssh = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needs_track) {\n\t\tu32 tkid=0;\n\t\tu32 tk_idx=0;\n\t\tu32 mtype=0;\n\t\tu32 target_timescale = 0;\n\t\tBool hdlr_name_set=GF_FALSE;\n\n\t\tif (ctx->make_qt && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p) {\n\t\t\t\tu32 ts=p->value.frac.num, inc=p->value.frac.den;\n\t\t\t\tif (inc * 24000 == ts * 1001) target_timescale = 24000;\n\t\t\t\telse if (inc * 2400 == ts * 100) target_timescale = 2400;\n\t\t\t\telse if (inc * 2500 == ts * 100) target_timescale = 2500;\n\t\t\t\telse if (inc * 30000 == ts * 1001) target_timescale = 30000;\n\t\t\t\telse if (inc * 2997 == ts * 100) target_timescale = 30000;\n\t\t\t\telse if (inc * 3000 == ts * 100) target_timescale = 3000;\n\t\t\t\telse if (inc * 5000 == ts * 100) target_timescale = 5000;\n\t\t\t\telse if (inc * 60000 == ts * 1001) target_timescale = 60000;\n\t\t\t\telse if (inc * 5994 == ts * 100) target_timescale = 60000;\n\t\t\t\telse if (is_prores) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] Unrecognized frame rate %g\\n\", ((Double)ts)/inc ));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ctx->prores_track)\n\t\t\t\tctx->prores_track = tkw;\n\t\t}\n\n\t\tif (!ctx->moov_inserted) {\n\t\t\tif (target_timescale) {\n\t\t\t\tctx->moovts = target_timescale;\n\t\t\t\tgf_isom_set_timescale(ctx->file, target_timescale);\n\t\t\t} else if (ctx->moovts>=0) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MOVIE_TIME);\n\t\t\t\tif (p && p->value.lfrac.den) {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, (u32) p->value.lfrac.den);\n\t\t\t\t\tctx->moovts = (u32) p->value.lfrac.den;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, ctx->moovts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tgf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t}\n\n\t\t//assign some defaults\n\t\ttkw->src_timescale = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\n\t\tu32 mtimescale = 1000;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\tif (p) mtimescale = p->value.uint;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p && p->value.frac.den) mtimescale = p->value.frac.den;\n\t\t}\n\t\tif (!tkw->src_timescale) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No timescale specified, guessing from media: %d\\n\", mtimescale));\n\t\t\ttkw->src_timescale = mtimescale;\n\t\t}\n\t\tif (target_timescale) tkw->tk_timescale = target_timescale;\n\t\telse if (ctx->mediats>0) tkw->tk_timescale = ctx->mediats;\n\t\telse if (ctx->mediats<0) tkw->tk_timescale = mtimescale;\n\t\telse tkw->tk_timescale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);\n\t\tif (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_ID);\n\t\tif (p) tkid = p->value.uint;\n\n\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tmtype = gf_isom_stream_type_to_media_type(tkw->stream_type, tkw->codecid);\n\n\t\tif (ctx->moovts<0) {\n\t\t\tctx->moovts = tkw->tk_timescale;\n\t\t\tgf_isom_set_timescale(ctx->file, (u32) ctx->moovts);\n\t\t}\n\t\tif (ctx->pad_sparse) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SPARSE);\n\t\t\tif (p) {\n\t\t\t\ttkw->sparse_inject = p->value.boolean;\n\t\t\t} else {\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tcase GF_STREAM_METADATA:\n\t\t\t\t\tswitch (tkw->codecid) {\n\t\t\t\t\tcase GF_CODECID_TEXT_MPEG4:\n\t\t\t\t\tcase GF_CODECID_TX3G:\n\t\t\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\t\t\tcase GF_CODECID_SUBPIC:\n\t\t\t\t\tcase GF_CODECID_TMCD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttkw->sparse_inject = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MUX_INDEX);\n\t\tif (p) {\n\t\t\ttk_idx = p->value.uint;\n\t\t\tif (!ctx->owns_mov) {\n\t\t\t\tu32 nb_dst_tk = gf_isom_get_track_count(ctx->file);\n\t\t\t\tif (tk_idx < nb_dst_tk) {\n\t\t\t\t\t//tk_idx = nb_dst_tk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->keep_utc) {\n\t\t\tif (!gf_isom_get_track_count(ctx->file)) {\n\t\t\t\tu64 create_date=0, modif_date=0;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:creation_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) create_date = p->value.longuint;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:modification_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) modif_date = p->value.longuint;\n\n\t\t\t\tif (create_date && modif_date)\n\t\t\t\t\tgf_isom_set_creation_time(ctx->file, create_date, modif_date);\n\t\t\t}\n\t\t\tgf_isom_keep_utc_times(ctx->file, GF_TRUE);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_TRACK_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tBool udta_only = (ctx->tktpl==2) ? GF_TRUE : GF_FALSE;\n\n\n\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, tkid, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, 0, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\t}\n\t\t\t//purge all track references we inject internally\n\t\t\tif (tkw->track_num) {\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SCAL);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SABT);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_TBAS);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE);\n\t\t\t}\n\n\t\t\tif (!ctx->btrt) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, 0, 0, 0, 0);\n\t\t\t}\n\t\t\tif (!udta_only) {\n\t\t\t\tGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size);\n\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_stsd_templates(ctx->file, tkw->track_num, p->value.data.ptr, p->value.data.size);\n\t\t\t\t\ttkw->all_stsd_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (!mtype) {\n\t\t\t\tmtype = GF_4CC('u','n','k','n');\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to find ISOM media type for stream type %s codec %s\\n\", gf_stream_type_name(tkw->stream_type), gf_codecid_name(tkw->codecid) ));\n\t\t\t}\n\t\t\tif (!tkid) tkid = tk_idx;\n\n\t\t\tif (ctx->trackid) {\n\t\t\t\tif (ctx->trackid==(u32)-1) tkid = 0;\n\t\t\t\telse tkid = ctx->trackid;\n\t\t\t}\n\n\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, tkid, mtype, tkw->tk_timescale);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, 0, mtype, tkw->tk_timescale);\n\t\t\t}\n\t\t\t//FIXME once we finally merge to filters, there is an old bug in isobmff initializing the width and height to 320x240 which breaks text import\n\t\t\t//this should be removed and hashes regenerated\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 0, 0, 0, 0, 0);\n\n\t\t\tif (!gf_sys_is_test_mode() && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER)) {\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_URL);\n\t\t\t\tif (tkw->track_num && p && p->value.string) {\n\t\t\t\t\tchar szHName[1025];\n\t\t\t\t\tchar *f = gf_file_basename(p->value.string);\n\t\t\t\t\tszHName[1024]=0;\n\t\t\t\t\tsnprintf(szHName, 1024, \"*%s@GPAC%s\", f ? f : \"\", gf_gpac_version() );\n\t\t\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, szHName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tkw->track_num) {\n\t\t\te = gf_isom_last_error(ctx->file);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to create new track: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tBool is_disabled = GF_FALSE;\n\t\t//cmaf mandates these flags and only them are set\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_ENABLED|GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t}\n\t\telse {\n\t\t\t//unless in test mode or old arch compat, set track to be enabled, in movie and in preview\n\t\t\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t}\n\n\t\t\t//override flags if provided\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_FLAGS);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, p->value.uint, GF_ISOM_TKFLAGS_SET);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DISABLED);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tis_disabled = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t//if we have a subtype set for the pid, use it\n\t\tp = NULL;\n\t\tif ((tkw->stream_type==GF_STREAM_TEXT) && (tkw->codecid==GF_CODECID_TX3G)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IS_CHAP);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tmtype = GF_ISOM_MEDIA_TEXT;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t\ttkw->is_chap = GF_TRUE;\n\t\t\t\tctx->has_chap_tracks = GF_TRUE;\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!p) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tmtype = p->value.uint;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t}\n\t\t}\n\t\tif (ctx->has_chap_tracks)\n\t\t\tupdate_chap_refs(ctx);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER);\n\t\tif (p && p->value.string) {\n\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, p->value.string);\n\t\t\thdlr_name_set = GF_TRUE;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_ALT_GROUP);\n\t\tif (p && p->value.uint) {\n\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, p->value.uint);\n\t\t} else if (!p && !gf_sys_is_test_mode()) {\n\t\t\t//we by default set groups for audio and subs if group is not present\n\t\t\tif (mtype==GF_ISOM_SUBTYPE_SUBTITLE) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 2);\n\t\t\t}\n\t\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 1);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have default flag set\n\t\tif (!is_disabled && !ctx->cmaf) {\n\t\t\tBool *has_def = NULL;\n\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) has_def = &ctx->has_def_vid;\n\t\t\telse if (tkw->stream_type==GF_STREAM_AUDIO) has_def = &ctx->has_def_aud;\n\t\t\telse if (tkw->stream_type==GF_STREAM_TEXT) has_def = &ctx->has_def_txt;\n\n\t\t\tBool set_def = GF_FALSE;\n\t\t\tBool set_all_def = GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_IS_DEFAULT);\n\t\t\t//first track of this kind set to default, deactivate all except this track\n\t\t\tif (has_def && ! *has_def && p && p->value.boolean) {\n\t\t\t\t*has_def = GF_TRUE;\n\t\t\t\tset_def = GF_TRUE;\n\t\t\t}\n\t\t\t//second or more track of this kind set to default, re-activate all\n\t\t\telse if (has_def && *has_def && p && p->value.boolean) {\n\t\t\t\tset_all_def = GF_TRUE;\n\t\t\t}\n\t\t\tif (set_def || set_all_def) {\n\t\t\t\tu32 nb_tk = gf_list_count(ctx->tracks);\n\t\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\t\tTrackWriter *atk = gf_list_get(ctx->tracks, i);\n\t\t\t\t\tif (atk->stream_type != tkw->stream_type) continue;\n\t\t\t\t\tif (set_all_def || (tkw == atk)) {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_ADD);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no default prop and a default exists for this kind, update flags\n\t\t\telse if (has_def && *has_def) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_MATRIX);\n\t\tif (p && (p->value.sint_list.nb_items==9)) {\n\t\t\tgf_isom_set_track_matrix(ctx->file, tkw->track_num, (s32 *) p->value.sint_list.vals);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SRC_MAGIC);\n\t\tif (p) {\n\t\t\tu64 magic = 0;\n\t\t\tif (hdlr_name_set) {\n\t\t\t\tmagic |= 1;\n\t\t\t\tmagic <<= 32;\n\t\t\t}\n\t\t\tmagic |= p->value.longuint;\n\t\t\tgf_isom_set_track_magic(ctx->file, tkw->track_num, magic);\n\t\t}\n\t\tif (tk_idx) {\n\t\t\tgf_isom_set_track_index(ctx->file, tkw->track_num, tk_idx, mp4mux_track_reorder, ctx);\n\t\t\tmp4mux_reorder_tracks(ctx);\n\t\t}\n\n\t\t//by default use cttsv1 (negative ctts)\n\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\tp = ctx->make_qt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_PROFILE_LEVEL);\n\t\tif (p) {\n\t\t\ttkw->media_profile_level = p->value.uint;\n\t\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, p->value.uint);\n\t\t\t\t}\n\t\t\t} else if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, p->value.uint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mudta && gf_isom_get_track_count(ctx->file)==1) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_UDTA);\n\t\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\t\tgf_isom_load_extra_boxes(ctx->file, p->value.data.ptr, p->value.data.size, (ctx->mudta==2) ? GF_TRUE : GF_FALSE);\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->sgpd_traf)\n\t\t\tgf_isom_set_sample_group_in_traf(ctx->file);\n#endif\n\t\tif (ctx->noroll) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_ROLL);\n\t\t}\n\t\tif (ctx->norap) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_RAP);\n\t\t}\n\n\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tBool use_cache = (ctx->vodcache == MP4MX_VODCACHE_ON) ? GF_TRUE : GF_FALSE;\n\t\t\tif ((ctx->vodcache == MP4MX_VODCACHE_REPLACE) && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\t\tuse_cache = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\t}\n\t\t\telse if (!use_cache) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_REPLACE) );\n\t\t\t}\n\t\t}\n\n\t\tif (gf_sys_old_arch_compat()) {\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"isom_force_ctts\");\n\t\t\tif (p && p->value.boolean) tkw->force_ctts = GF_TRUE;\n\t\t}\n\t} else {\n\n\t\tu32 old_timescale = tkw->src_timescale;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\t\tif (old_timescale && (tkw->src_timescale != old_timescale)) {\n\t\t\tif (tkw->ts_shift)\n\t\t\t\ttkw->ts_shift = gf_timestamp_rescale(tkw->ts_shift, old_timescale, tkw->src_timescale);\n\t\t}\n\t}\n\n\tif (!tkw->has_brands) {\n\t\tBool ignore_alt = GF_FALSE;\n\t\tBool is_isom = GF_FALSE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MBRAND);\n\t\tif (p) {\n\t\t\tu32 brand = p->value.uint;\n\t\t\t//remove QT brand\n\t\t\tif ((brand==GF_ISOM_BRAND_QT) && !ctx->make_qt) {\n\t\t\t\tis_isom = GF_TRUE;\n\t\t\t\tctx->major_brand_set = brand = GF_ISOM_BRAND_ISOM;\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_QT, GF_FALSE);\n\t\t\t\tignore_alt = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!ctx->major_brand_set) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tctx->major_brand_set = brand;\n\t\t\t} else {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, brand, GF_TRUE);\n\t\t\t}\n\t\t\tif (p->value.uint == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t}\n\t\tp = ignore_alt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_BRANDS);\n\t\tif (p && p->value.uint_list.nb_items) {\n\t\t\ttkw->has_brands = GF_TRUE;\n\t\t\tif (!ctx->major_brand_set) {\n\t\t\t\tctx->major_brand_set = p->value.uint_list.vals[0];\n\t\t\t\tgf_isom_set_brand_info(ctx->file, p->value.uint_list.vals[0], 1);\n\t\t\t}\n\t\t\t//reset alt brands, push old ones\n\t\t\tgf_isom_reset_alt_brands_ex(ctx->file, GF_TRUE);\n\t\t\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, p->value.uint_list.vals[i], GF_TRUE);\n\t\t\t\tif (p->value.uint_list.vals[i] == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t\t}\n\t\t\t//and in case it was not present add major brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, ctx->major_brand_set, GF_TRUE);\n\t\t}\n\t\tif (!ctx->m4sys && !is_isom && !ctx->def_brand_patched) {\n\t\t\t//remove default brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tctx->def_brand_patched = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, (ctx->cmaf==MP4MX_CMAF_CMF2) ? GF_ISOM_BRAND_CMF2 : GF_ISOM_BRAND_CMFC, GF_TRUE);\n\t\t}\n\t}\n\n\twidth = height = sr = nb_chan = z_order = txt_fsize = 0;\n\tnb_bps = 16;\n\tch_layout = 0;\n\tfps.num = 25;\n\tfps.den = 1;\n\tsar.num = sar.den = 0;\n\tcodec_id = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_PID);\n\tif (p) {\n\t\tmulti_pid_stsd = p->value.ptr;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_MULTI_PID_IDX);\n\t\tassert(p);\n\t\tmulti_pid_final_stsd_idx = p->value.uint;\n\n\t\t//should never be the case\n\t\ttkw->xps_inband = XPS_IB_NO;\n\t\tctx->dref = GF_FALSE;\n\t\torig_pid = pid;\n\t\tgoto multipid_stsd_setup;\n\t}\n\n\n\t//WARNING !! from this point on until the goto multipid_stsd_setup, use pid and not tkw->ipid\n\t//so that we setup the sample entry properly for each PIDs\nsample_entry_setup:\n\n\tuse_m4sys = ctx->m4sys;\n\tuse_gen_sample_entry = GF_TRUE;\n\tuse_dref = ctx->dref;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);\n\tif (p) width = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);\n\tif (p) height = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\tif (p) fps = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAR);\n\tif (p) sar = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ZORDER);\n\tif (p) z_order = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\tif (p) sr = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NUM_CHANNELS);\n\tif (p) nb_chan = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_BPS);\n\tif (p) nb_bps = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHANNEL_LAYOUT);\n\tif (p) ch_layout = p->value.longuint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LANGUAGE);\n\tif (p) lang_name = p->value.string;\n\n\tif (is_true_pid) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NB_FRAMES);\n\t\ttkw->nb_frames = p ? p->value.uint : 0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FRAME_OFFSET);\n\t\ttkw->frame_offset = p ? p->value.uint : 0;\n\t}\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\tif (p) m_subtype_src = p->value.uint;\n\n\t//if crypto scheme type changes, we will need a new sample entry\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\tif (p && (tkw->scheme_type != p->value.uint))\n\t\tneeds_sample_entry = 1;\n\telse if (!p && tkw->scheme_type)\n\t\tneeds_sample_entry = 1;\n\telse if (tkw->scheme_type) {\n\t\tif (codec_id == prev_codecid)\n\t\t\tskip_crypto = GF_TRUE;\n\t}\n\n\t//get our subtype\n\tswitch (codec_id) {\n\tcase GF_CODECID_MPEG_AUDIO:\n\tcase GF_CODECID_MPEG2_PART3:\n\tcase GF_CODECID_MPEG_AUDIO_L1:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MP3;\n\t\tcomp_name = \"MP3\";\n\t\t//if source had a DSI, this was mpeg4 systems signaling, reuse that\n\t\tif (dsi)\n\t\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"AAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\n\t\tif (ctx->importer) {\n\t\t\tconst char *pid_args = gf_filter_pid_get_args(pid);\n\t\t\tif (pid_args) {\n\t\t\t\tBool sbr_i = strstr(pid_args, \"sbr=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool sbr_x = strstr(pid_args, \"sbr=exp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_i = strstr(pid_args, \"ps=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_x = strstr(pid_args, \"ps=exp\") ? GF_TRUE : GF_FALSE;\n\n\t\t\t\tif (sbr_x) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC explicit SBR implict PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit SBR+PS\";\n\t\t\t\t\telse imp_name = \"AAC explicit SBR\";\n\t\t\t\t} else if (sbr_i) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit SBR+PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC implicit SBR explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC implicit SBR\";\n\t\t\t\t} else {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_USAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"xHE-AAC / USAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_JPEG;\n\t\tcomp_name = \"JPEG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tif (!use_m4sys)\n\t\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_PNG;\n\t\tcomp_name = \"PNG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_MJP2;\n\t\tcomp_name = \"JPEG2000\";\n\t\tuse_mj2 = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_AMR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\tcomp_name = \"AMR\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AMR_WB:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR_WB;\n\t\tcomp_name = \"AMR-WB\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_EVRC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\tcomp_name = \"EVRC\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_SMV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\tcomp_name = \"SMV\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_QCELP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\tcomp_name = \"QCELP\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_S263:\n\tcase GF_CODECID_H263:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_H263;\n\t\tcomp_name = \"H263\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_AC3;\n\t\tcomp_name = \"AC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_EAC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_EC3;\n\t\tcomp_name = \"EAC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPHA:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHA1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H Audio\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_MHAS:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHM1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H AudioMux\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_FLAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_FLAC;\n\t\tcomp_name = \"FLAC\";\n\t\tuse_flac_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_OPUS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_OPUS;\n\t\tcomp_name = \"Opus\";\n\t\tuse_opus = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG4_PART2:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-4 Visual Part 2\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_DVAV:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_AVC3_H264 : GF_ISOM_SUBTYPE_AVC_H264;\n\t\t}\n\t\tuse_avc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_SVC) ? \"MPEG-4 SVC\" : \"MPEG-4 AVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_AVC_H264) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_DVHE:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_HVC1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_HEV1  : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tuse_hevc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_LHVC) ? \"L-HEVC\" : \"HEVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_HVC1) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC_TILES:\n\t\tm_subtype = GF_ISOM_SUBTYPE_HVT1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_hvt1 = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"HEVC Tiles\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_VVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tif (m_subtype_src == GF_ISOM_SUBTYPE_VVI1) {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVI1;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t} else {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVC1;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_PPS) || (xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_VVI1  : GF_ISOM_SUBTYPE_VVC1;\n\t\t}\n\t\tuse_vvc = GF_TRUE;\n\t\tcomp_name = \"VVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_VVC_SUBPIC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_VVS1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_vvc = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"VVC Subpicture\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-2 Video\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase 0:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] muxing codecID %d not yet implemented - patch welcome\\n\", codec_id));\n\t\treturn GF_NOT_SUPPORTED;\n\n\tcase GF_ISOM_SUBTYPE_TX3G:\n\t\tm_subtype = GF_ISOM_SUBTYPE_TX3G;\n\t\tuse_tx3g = GF_TRUE;\n\t\tcomp_name = \"Timed Text\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_WVTT:\n\t\tm_subtype = GF_ISOM_SUBTYPE_WVTT;\n\t\tuse_webvtt = GF_TRUE;\n\t\tcomp_name = \"WebVTT\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_DVB_SUBS:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_SUBS;\n\t\tgen_dsi_wrap = GF_4CC('d', 'v', 's', 'C');\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_DVB_TELETEXT:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_TELETEXT;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_SUBPIC:\n\t\tuse_m4sys = GF_TRUE;\n\t\toverride_stype = GF_STREAM_ND_SUBPIC;\n\t\tcomp_name = \"VobSub\";\n\t\tbreak;\n\tcase GF_CODECID_TEXT_MPEG4:\n\t\tuse_m4sys = GF_TRUE;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SCENE);\n\t\tcomp_name = \"MPEG4 Streaming Text\";\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_AV01;\n\t\tuse_av1 = GF_TRUE;\n\t\tcomp_name = \"AOM AV1 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VP8:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP08;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP8 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP9:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP09;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP9 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP10:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP10;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP10 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VORBIS:\n\tcase GF_CODECID_THEORA:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_TRUEHD:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MLPA;\n\t\tcomp_name = \"Dolby TrueHD\";\n\t\tbreak;\n\n\tcase GF_CODECID_DTS_CA:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSC;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_HR_MASTER:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSH;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_LOSSLESS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSL;\n\t\tbreak;\n\tcase GF_CODECID_DTS_EXPRESS_LBR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSE;\n\t\tbreak;\n\tcase GF_CODECID_DTS_X:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSX;\n\t\tbreak;\n\tcase GF_CODECID_DTS_Y:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSY;\n\t\tbreak;\n\tcase GF_CODECID_ALAC:\n\t\tm_subtype = GF_QT_SUBTYPE_ALAC;\n\t\tbreak;\n\n\tcase GF_CODECID_BIFS:\n/* ==  GF_CODECID_OD_V1:*/\n\tcase GF_CODECID_BIFS_V2:\n/*\t== GF_CODECID_OD_V2:*/\n\tcase GF_CODECID_BIFS_EXTENDED:\n\tcase GF_CODECID_LASER:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_RAW:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\tu32 afmt;\n\t\t\tu32 req_non_planar_type = 0;\n\t\t\tBool qt_only=GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) break;\n\t\t\tcomp_name = \"RawAudio\";\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\t\tafmt = p->value.uint;\n\t\t\tafmt_flags |= 1<<2; //signed\n\t\t\t//m_subtype used for QTFF-style raw media, m_subtype_alt_raw for ISOBMFF raw audio\n\t\t\tswitch (afmt) {\n\t\t\tcase GF_AUDIO_FMT_U8P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_U8;\n\t\t\tcase GF_AUDIO_FMT_U8:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_RAW;\n\t\t\t\tafmt_flags &= ~(1<<2); //unsigned\n\t\t\t\tqt_only = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S16;\n\t\t\tcase GF_AUDIO_FMT_S16:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_SOWT;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_TWOS;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S24;\n\t\t\tcase GF_AUDIO_FMT_S24:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S32P;\n\t\t\tcase GF_AUDIO_FMT_S32:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLTP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_FLTP;\n\t\t\tcase GF_AUDIO_FMT_FLT:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLT_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBLP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_DBL;\n\t\t\tcase GF_AUDIO_FMT_DBL:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBL_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF)) {\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_LPCM;\n\t\t\t}\n\t\t\t//if qt-only sample desc available, force ase mode\n\t\t\telse if (!ctx->make_qt && qt_only) {\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\n\t\t\tif (req_non_planar_type) {\n\t\t\t\tif (is_true_pid)\n\t\t\t\t\tgf_filter_pid_negociate_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S16));\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] raw audio format planar in DASH multi-stsd mode is not supported, try assigning a resampler before the dasher\\n\"));\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnb_bps = gf_audio_fmt_bit_depth(afmt);\n\t\t\ttkw->raw_audio_bytes_per_sample = nb_bps;\n\t\t\ttkw->raw_audio_bytes_per_sample *= nb_chan;\n\t\t\ttkw->raw_audio_bytes_per_sample /= 8;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\t\ttkw->raw_samplerate = p ? p->value.uint : 0;\n\t\t\t//force timescale to be samplerate, except if explicit overwrite\n\t\t\tif (ctx->mediats==0)\n\t\t\t\ttkw->tk_timescale = tkw->raw_samplerate;\n\n\t\t\tif ((sr == tkw->w_or_sr) && (nb_chan==tkw->h_or_ch) && (afmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = sr;\n\t\t\t\ttkw->h_or_ch = nb_chan;\n\t\t\t\ttkw->pf_or_af = afmt;\n\t\t\t}\n\t\t}\n\t\telse if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\tu32 pfmt;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) break;\n\t\t\tpfmt = p->value.uint;\n\t\t\tcomp_name = \"RawVideo\";\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\t\tpix_fmt = p->value.uint;\n\n\t\t\tm_subtype = gf_pixel_fmt_to_qt_type(pix_fmt);\n\t\t\tif (m_subtype) {\n\t\t\t\tif (gf_pixel_fmt_is_yuv(p->value.uint))\n\t\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = pix_fmt;\n\t\t\t}\n\n\t\t\tif ((width == tkw->w_or_sr) && (height==tkw->h_or_ch) && (pfmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = width;\n\t\t\t\ttkw->h_or_ch = height;\n\t\t\t\ttkw->pf_or_af = pfmt;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_RAW_UNCV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\tunknown_generic = GF_FALSE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tbreak;\n\n\tdefault:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tif (is_prores)\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:mime\");\n\t\tif (p) meta_mime = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:encoding\");\n\t\tif (p) meta_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:content_encoding\");\n\t\tif (p) meta_content_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:xmlns\");\n\t\tif (p) meta_xmlns = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:schemaloc\");\n\t\tif (p) meta_schemaloc = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:aux_mimes\");\n\t\tif (p) meta_auxmimes = p->value.string;\n\t\tbreak;\n\t}\n\tif (!comp_name) comp_name = gf_codecid_name(codec_id);\n\tif (!comp_name) comp_name = gf_4cc_to_str(m_subtype);\n\n\tif (dsi)\n\t\tmeta_config = dsi->value.data.ptr;\n\n\tif (is_text_subs && !width && !height) {\n\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t}\n\n\t//if not LPCM and qt v2 is requested, move to qtv1\n\tif ((ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF) && (m_subtype != GF_QT_SUBTYPE_LPCM) ) {\n\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t}\n\n\n\tif (!ctx->init_movie_done && !tkw->nb_samples && (ctx->mediats<0) && (tkw->tk_timescale==1000)) {\n\t\tif (sr) {\n\t\t\ttkw->tk_timescale = sr;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, sr, 0, 1);\n\t\t}\n\t\telse if (width && fps.den) {\n\t\t\ttkw->tk_timescale = fps.den;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, fps.den, 0, 1);\n\t\t}\n\t}\n\tif (!needs_sample_entry || tkw->is_item) {\n\t\tgoto sample_entry_done;\n\t}\n\n\t//we are fragmented, init movie done, we cannot update the sample description\n\tif (ctx->init_movie_done) {\n\t\tif (needs_sample_entry==1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (codec change) for finalized movie in fragmented mode\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tforce_mix_xps = GF_TRUE;\n\t} else if (ctx->store < MP4MX_MODE_FRAG) {\n\t\tif ((needs_sample_entry==2) && (xps_inband==XPS_IB_BOTH)) {\n\t\t\tforce_mix_xps = GF_TRUE;\n\t\t}\n\t\telse if ((needs_sample_entry==2) && ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_MIX)) ) {\n\t\t\tneeds_sample_entry = 0;\n\t\t\tmake_inband_headers = GF_TRUE;\n\t\t}\n\t}\n\n\tif (force_mix_xps) {\n\t\tif (tkw->all_stsd_crc) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\tu32 crc = p ? gf_crc_32(p->value.data.ptr, p->value.data.size) : 0;\n\t\t\tif (crc == tkw->all_stsd_crc) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE_IDX);\n\t\t\t\tif (p) {\n\t\t\t\t\ttkw->stsd_idx = p->value.uint;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for AVC and HEVC, move to inband params if config changed\n\t\tif (use_avc && dsi) {\n\t\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\n\t\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] AVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_hevc && dsi) {\n\t\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] HEVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_vvc && dsi) {\n\t\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] VVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (config changed) for finalized movie in fragmented mode\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\ttkw->xps_inband = xps_inband;\n\tp = needs_sample_entry ? gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DSI_SUPERSET) : NULL;\n\n\t//if dsi is a superset of previous one, remove stream description\n\tif ((p && p->value.boolean)\n\t\t//little optim here: if no samples were added on the stream description remove it\n\t\t|| (!tkw->samples_in_stsd && tkw->stsd_idx && needs_sample_entry)\n\t) {\n\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t}\n\n\tif (!use_dref) src_url = NULL;\n\n\tif (use_m4sys && !gf_codecid_oti(codec_id)) {\n\t\tuse_m4sys = GF_FALSE;\n\t}\n\t//nope, create sample entry\n\tif (use_m4sys) {\n\t\tGF_ESD *esd = gf_odf_desc_esd_new(2);\n\t\tesd->decoderConfig->streamType = override_stype ? override_stype : tkw->stream_type;\n\t\tesd->decoderConfig->objectTypeIndication = gf_codecid_oti(codec_id);\n\t\tif (!esd->decoderConfig->objectTypeIndication) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Codec %s does not have an official MPEG-4 systems mapping, cannot mux\\n\", gf_codecid_name(codec_id) ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\n\t\t}\n\t\tesd->slConfig->timestampResolution = tkw->tk_timescale;\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = dsi->value.data.ptr;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dsi->value.data.size;\n\t\t}\n\n\t\te = gf_isom_new_mpeg4_description(ctx->file, tkw->track_num, esd, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-4 Systems sample description for stream type %d OTI %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IN_IOD);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_add_track_to_root_od(ctx->file, tkw->track_num);\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (dsi && (tkw->stream_type==GF_STREAM_AUDIO)) {\n\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\tgf_m4a_get_config(dsi->value.data.ptr, dsi->value.data.size, &acfg);\n\t\t\taudio_pli = acfg.audioPL;\n\t\t}\n\t\t//patch to align old arch (IOD not written in dash) with new\n\t\tif (audio_pli && !ctx->dash_mode)\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, audio_pli);\n#endif\n\n\t} else if (use_avc) {\n\t\t//not yet known\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\n\t\tif (!dsi) {\n\t\t\tdsi = enh_dsi;\n\t\t\tenh_dsi = NULL;\n\t\t}\n\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->codecid == GF_CODECID_SVC) {\n\t\t\t\te = gf_isom_svc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else if (tkw->codecid == GF_CODECID_MVC) {\n\t\t\t\te = gf_isom_mvc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else {\n\t\t\t\te = gf_isom_avc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t\tif (tkw->svcc) {\n\t\t\t\t\tif ((tkw->svcc->AVCProfileIndication==118) || (tkw->svcc->AVCProfileIndication==128)) {\n\t\t\t\t\t\te = gf_isom_mvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_isom_svc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\t\t\ttkw->svcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (xps_inband) {\n\t\t\t\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\tif (xps_inband==XPS_IB_BOTH) make_inband_headers = GF_TRUE;\n\t\t} else {\n\t\t\tgf_odf_avc_cfg_del(tkw->avcc);\n\t\t\ttkw->avcc = NULL;\n\t\t}\n\t\t//patch to align old arch with filters\n\t\tif (!ctx->dash_mode && !ctx->make_qt && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE) )\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, 0x7F);\n\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_TRUE);\n\n\t\ttkw->is_nalu = NALU_AVC;\n\n\t\ttkw->use_dref = GF_FALSE;\n\n\t} else if (use_hvt1) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (!e) {\n\t\t\tgf_isom_hevc_set_tile_config(ctx->file, tkw->track_num, tkw->stsd_idx, NULL, GF_FALSE);\n\t\t}\n\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = NULL;\n\t\ttkw->is_nalu = NALU_HEVC;\n\t\ttkw->use_dref = GF_FALSE;\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_HVTI, GF_TRUE);\n\t} else if (use_hevc) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\n\t\tif (!dsi && !enh_dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (dsi) {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\t}\n\t\ttkw->is_nalu = NALU_HEVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t\tif (tkw->lvcc) {\n\t\t\t\t\te = gf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->lvcc, dsi ? GF_ISOM_LEHVC_WITH_BASE_BACKWARD : GF_ISOM_LEHVC_ONLY);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\t\t\ttkw->lvcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!dsi && tkw->xps_inband) {\n\t\t\t\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (codec_id == GF_CODECID_LHVC) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_LEHVC_ONLY);\n\t\t\t} else if (is_tile_base) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_HEVC_TILE_BASE);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (dsi && tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_vvc) {\n\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\n\t\tif (!dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\ttkw->is_nalu = NALU_VVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->xps_inband == XPS_IB_PPS) {\n\t\t\t\tu32 k; count=gf_list_count(tkw->vvcc->param_array);\n\t\t\t\tfor (k=0;k<count;k++) {\n\t\t\t\t\tGF_NALUFFParamArray *pa = gf_list_get(tkw->vvcc->param_array, k);\n\t\t\t\t\tif (pa->type==GF_VVC_NALU_PIC_PARAM)\n\t\t\t\t\t\tpa->array_completeness = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\te = gf_isom_vvc_config_new(ctx->file, tkw->track_num, tkw->vvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in vvcC\n\t\t\tgf_isom_vvc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, ((tkw->xps_inband==XPS_IB_PPS) || (tkw->xps_inband==XPS_IB_BOTH)) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_av1) {\n\t\tGF_AV1Config *av1c;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for AV1\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tav1c = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser AV1 decoder specific info\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_av1_config_new(ctx->file, tkw->track_num, av1c, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AV1 sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_av1 = GF_TRUE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AV01, GF_TRUE);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (use_vpX) {\n\t\tGF_VPConfig *vpc;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for %s\\n\", gf_4cc_to_str(codec_id) ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tvpc = gf_odf_vp_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!vpc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser %s decoder specific info\\n\", gf_4cc_to_str(codec_id)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_vp_config_new(ctx->file, tkw->track_num, vpc, (char *) src_url, NULL, &tkw->stsd_idx, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(codec_id), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_vpx = GF_TRUE;\n\t\tgf_odf_vp_cfg_del(vpc);\n\t} else if (use_3gpp_config) {\n\t\tGF_3GPConfig gpp_cfg;\n\t\tmemset(&gpp_cfg, 0, sizeof(GF_3GPConfig));\n\t\tgpp_cfg.type = m_subtype;\n\t\tgpp_cfg.vendor = GF_VENDOR_GPAC;\n\n\t\tif (use_dref) {\n\t\t\tgpp_cfg.frames_per_sample  = 1;\n\t\t} else {\n\t\t\tgpp_cfg.frames_per_sample = ctx->pack3gp;\n\t\t\tif (!gpp_cfg.frames_per_sample) gpp_cfg.frames_per_sample  = 1;\n\t\t\telse if (gpp_cfg.frames_per_sample >15) gpp_cfg.frames_per_sample = 15;\n\t\t}\n\t\tgpp_cfg.AMR_mode_set = tkw->amr_mode_set;\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t/*FIXME - we need more in-depth parsing of the bitstream to detect P3@L10 (streaming wireless)*/\n\t\t\tgpp_cfg.H263_profile = 0;\n\t\t\tgpp_cfg.H263_level = 10;\n\t\t\tgpp_cfg.frames_per_sample = 0;\n\t\t}\n\t\ttkw->nb_frames_per_sample = gpp_cfg.frames_per_sample;\n\n\t\te = gf_isom_3gp_config_new(ctx->file, tkw->track_num, &gpp_cfg, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new 3GPP audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tswitch (gpp_cfg.type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_3G2A, 65536);\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG6, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG5, GF_TRUE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_ac3_entry) {\n\t\tGF_AC3Config ac3cfg;\n\t\tmemset(&ac3cfg, 0, sizeof(GF_AC3Config));\n\n\t\tif (dsi) {\n\t\t\tgf_odf_ac3_config_parse(dsi->value.data.ptr, dsi->value.data.size, (codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3cfg);\n\t\t} else {\n\t\t\tif (codec_id==GF_CODECID_EAC3) ac3cfg.is_ec3 = GF_TRUE;\n\t\t}\n\t\te = gf_isom_ac3_config_new(ctx->file, tkw->track_num, &ac3cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AC3 audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_flac_entry) {\n\t\te = gf_isom_flac_config_new(ctx->file, tkw->track_num, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new FLAC audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_opus) {\n\t\tGF_OpusConfig opus_cfg;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for opus\\n\" ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\te = gf_odf_opus_cfg_parse(dsi->value.data.ptr, dsi->value.data.size, &opus_cfg);\n\t\tif (!e)\n\t\t\te = gf_isom_opus_config_new(ctx->file, tkw->track_num, &opus_cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new Opus audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METX) {\n\t\tcomp_name = \"XML Metadata\";\n\t\te = gf_isom_new_xml_metadata_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_encoding, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METX sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METT) {\n\t\tcomp_name = \"Text Metadata\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, GF_ISOM_SUBTYPE_METT, meta_mime, meta_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METT sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_STPP) {\n\t\tif (meta_xmlns && !strcmp(meta_xmlns, \"http://www.w3.org/ns/ttml\")) {\n\t\t\tcomp_name = \"TTML\";\n\t\t} else {\n\t\t\tcomp_name = \"XML Subtitle\";\n\t\t}\n\t\te = gf_isom_new_xml_subtitle_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_auxmimes, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new XML subtitle sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\t//CMAF 11.3.2\n\t\tif (ctx->cmaf) {\n\t\t\tif (!meta_mime) meta_mime = gf_isom_subtitle_get_mime(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (!meta_mime || (!strstr(meta_mime, \"im1t\") && !strstr(meta_mime, \"im1i\"))) {\n\t\t\t\tgf_isom_subtitle_set_mime(ctx->file, tkw->track_num, tkw->stsd_idx, \"application/ttml+xml;codecs=im1t\");\n\t\t\t}\n\t\t}\n\n\n\t} else if ((m_subtype == GF_ISOM_SUBTYPE_SBTT) || (m_subtype == GF_ISOM_SUBTYPE_STXT) ) {\n\t\tcomp_name = (m_subtype == GF_ISOM_SUBTYPE_STXT) ? \"Simple Timed Text\" : \"Textual Subtitle\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, m_subtype, meta_mime, meta_content_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (m_subtype == GF_ISOM_SUBTYPE_STXT) force_tk_layout = GF_TRUE;\n\t} else if (use_tx3g) {\n\t\tGF_TextSampleDescriptor *txtc;\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for TX3G\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\ttxtc = gf_odf_tx3g_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!txtc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parse TX3G config\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tif (!txtc->default_pos.right) txtc->default_pos.right = width + txtc->default_pos.left;\n\t\tif (!txtc->default_pos.bottom) txtc->default_pos.bottom = height + txtc->default_pos.top;\n\n\n\t\te = gf_isom_new_text_description(ctx->file, tkw->track_num, txtc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->importer) {\n\t\t\ttxt_fsize = txtc->default_style.font_size;\n\t\t\tif (txtc->font_count && txtc->fonts[0].fontName) txt_font = gf_strdup(txtc->fonts[0].fontName);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_webvtt) {\n#ifndef GPAC_DISABLE_VTT\n\t\te = gf_isom_new_webvtt_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e)));\n\t\t\treturn e;\n\t\t}\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_mj2) {\n\t\te = gf_isom_new_mj2k_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_TMCD) {\n\t\tu32 tmcd_flags=0, tmcd_fps_num=0, tmcd_fps_den=0;\n\t\ts32 tmcd_fpt=0;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:flags\");\n\t\tif (p) tmcd_flags = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:framerate\");\n\t\tif (p) {\n\t\t\ttmcd_fps_num = p->value.frac.num;\n\t\t\ttmcd_fps_den = p->value.frac.den;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:frames_per_tick\");\n\t\tif (p) tmcd_fpt = p->value.uint;\n\t\tif (tkw->tk_timescale != tmcd_fps_num) {\n\t\t\ttmcd_fps_den *= tmcd_fps_num;\n\t\t\ttmcd_fps_den /= tkw->tk_timescale;\n\t\t}\n\n\t\te = gf_isom_tmcd_config_new(ctx->file, tkw->track_num, tmcd_fps_num, tmcd_fps_den, tmcd_fpt, (tmcd_flags & 0x1), (tmcd_flags & 0x8), &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new tmcd sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_DIMS) {\n\t\tGF_DIMSDescription dims_c;\n\t\tmemset(&dims_c, 0, sizeof(GF_DIMSDescription));\n\t\tdims_c.contentEncoding = meta_content_encoding;\n\t\tdims_c.mime_type = meta_mime;\n\t\tdims_c.textEncoding = meta_encoding;\n\t\tdims_c.xml_schema_loc = meta_xmlns;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:profile\");\n\t\tif (p) dims_c.profile = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:level\");\n\t\tif (p) dims_c.level = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:pathComponents\");\n\t\tif (p) dims_c.pathComponents = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:fullRequestHost\");\n\t\tif (p) dims_c.fullRequestHost = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:streamType\");\n\t\tif (p) dims_c.streamType = p->value.boolean;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:redundant\");\n\t\tif (p) dims_c.containsRedundant = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:scriptTypes\");\n\t\tif (p) dims_c.content_script_types = p->value.string;\n\n\t\te = gf_isom_new_dims_description(ctx->file, tkw->track_num, &dims_c, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new DIMS sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if ((codec_id==GF_CODECID_MPHA) || (codec_id==GF_CODECID_MHAS)) {\n\t\t//not ready yet\n\t\tu8 *pdsi=NULL;\n\t\tu32 dsi_len=0;\n\t\tif (codec_id==GF_CODECID_MPHA) {\n\t\t\tif (!dsi) return GF_OK;\n\t\t\tpdsi = dsi->value.data.ptr;\n\t\t\tdsi_len = dsi->value.data.size;\n\t\t}\n\t\te = gf_isom_new_mpha_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, pdsi, dsi_len, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-H Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\tif (p) {\n\t\t\tgf_isom_set_mpegh_compatible_profiles(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint_list.vals, p->value.uint_list.nb_items);\n\t\t}\n\t} else if (codec_id==GF_CODECID_TRUEHD) {\n\t\tu32 fmt=0, prate=0;\n\t\t//not ready yet\n\t\tif (!dsi) return GF_OK;\n\t\tif (dsi->value.data.size < 6) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tfmt = dsi->value.data.ptr[0];\n\t\tfmt <<= 8;\n\t\tfmt |= dsi->value.data.ptr[1];\n\t\tprate = dsi->value.data.ptr[2];\n\t\tprate <<= 8;\n\t\tprate |= dsi->value.data.ptr[3];\n\t\tprate >>= 1;\n\n\t\te = gf_isom_truehd_config_new(ctx->file, tkw->track_num, (char *)src_url, NULL, fmt, prate, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new TrueHD Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (use_gen_sample_entry) {\n\t\tu8 isor_ext_buf[14], *gpac_meta_dsi=NULL;\n\t\tu32 len = 0;\n\t\tGF_GenericSampleDescription udesc;\n\t\tmemset(&udesc, 0, sizeof(GF_GenericSampleDescription));\n\n\t\tif (!comp_name) comp_name = \"Unknown\";\n\t\tlen = (u32) strlen(comp_name);\n\t\tif (len>32) len = 32;\n\t\tudesc.compressor_name[0] = len;\n\t\tmemcpy(udesc.compressor_name+1, comp_name, len);\n\t\tif ((codec_id==GF_CODECID_RAW) || unknown_generic)\n\t\t\tudesc.vendor_code = GF_4CC('G','P','A','C');\n\n\t\tudesc.samplerate = sr;\n\t\tudesc.nb_channels = nb_chan;\n\t\tudesc.bits_per_sample = nb_bps;\n\t\tudesc.lpcm_flags = afmt_flags | (1<<3); //add packed flag\n\t\t//for raw audio, select qt vs isom and set version\n\t\tif (sr && (codec_id==GF_CODECID_RAW)) {\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS)) {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\t//if extensions or not 'raw ' or 'twos', use v1\n\t\t\t\tif (dsi ||\n\t\t\t\t\t((m_subtype!=GF_QT_SUBTYPE_TWOS) && (m_subtype!=GF_QT_SUBTYPE_RAW))\n\t\t\t\t) {\n\t\t\t\t\tudesc.version = 1;\n\t\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ase_mode<=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG) {\n\t\t\t\tm_subtype = m_subtype_alt_raw;\n\t\t\t\tudesc.extension_buf_size = 14;\n\t\t\t\tudesc.extension_buf = isor_ext_buf;\n\t\t\t\tmemset(isor_ext_buf, 0, sizeof(u8)*14);\n\t\t\t\tisor_ext_buf[3] = 14;\n\t\t\t\tisor_ext_buf[4] = 'p';\n\t\t\t\tisor_ext_buf[5] = 'c';\n\t\t\t\tisor_ext_buf[6] = 'm';\n\t\t\t\tisor_ext_buf[7] = 'C';\n\t\t\t\tisor_ext_buf[12] = (afmt_flags & (1<<1)) ? 0 : 1; //big/little endian\n\t\t\t\tisor_ext_buf[13] = nb_bps;\n\t\t\t\tif (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG)\n\t\t\t\t\tudesc.version = 1;\n\t\t\t} else {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\tudesc.version = 1;\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\t\t}\n\n\t\tif (codec_id == GF_CODECID_FFMPEG) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t} else {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\t\tif (p && p->type==GF_PROP_UINT)\n\t\t\t\t\tm_subtype = p->value.uint;\n\t\t\t}\n\t\t}\n\n\t\tudesc.codec_tag = m_subtype;\n\t\tudesc.width = width;\n\t\tudesc.height = height;\n\t\tif (width) {\n\t\t\tudesc.v_res = 72;\n\t\t\tudesc.h_res = 72;\n\t\t\tudesc.depth = 24;\n\t\t}\n\t\tif (dsi) {\n\t\t\tudesc.extension_buf = dsi->value.data.ptr;\n\t\t\tudesc.extension_buf_size = dsi->value.data.size;\n\t\t\tudesc.ext_box_wrap = gen_dsi_wrap;\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"DSIWrap\");\n\t\t\tif (p) {\n\t\t\t\tif (p->type==GF_PROP_UINT) udesc.ext_box_wrap = p->value.uint;\n\t\t\t\telse if (p->type==GF_PROP_STRING) udesc.ext_box_wrap = gf_4cc_parse(p->value.string);\n\t\t\t}\n\t\t}\n\t\tif (codec_id==GF_CODECID_FFV1) {\n\t\t\tudesc.codec_tag = GF_4CC('F', 'F', 'V', '1');\n\t\t\tudesc.ext_box_wrap = GF_4CC('g', 'l', 'b', 'l');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t}\n\t\tif (codec_id==GF_CODECID_SMPTE_VC1) {\n\t\t\tudesc.codec_tag = GF_4CC('v', 'c', '-', '1');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\tif (udesc.extension_buf)\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('d', 'v', 'c', '1');\n\t\t}\n\t\t//move to uncv\n\t\tif ((codec_id==GF_CODECID_RAW) && !ctx->make_qt && ctx->uncv && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tif ( gf_pixel_fmt_get_uncc(pix_fmt, ctx->uncv-1, &gpac_meta_dsi, &udesc.extension_buf_size) == GF_TRUE) {\n\t\t\t\tunknown_generic = GF_FALSE;\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.codec_tag = m_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\t\t}\n\t\t}\n\n\t\tif (unknown_generic) {\n\t\t\t//check if this is a meta codec (unmapped codec from ffmpeg or other)\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_NAME);\n\t\t\tif (p || p2) {\n\t\t\t\tu32 cid = (p && (p->type==GF_PROP_UINT)) ? p->value.uint : m_subtype;\n\t\t\t\tconst char *cname = p2 ? p2->value.string : NULL;\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u32(bs, codec_id);\n\t\t\t\tgf_bs_write_u32(bs, cid);\n\t\t\t\tgf_bs_write_utf8(bs, cname ? cname : gf_4cc_to_str(cid));\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_OPAQUE);\n\t\t\t\tgf_bs_write_u32(bs, p ? p->value.uint : 0);\n\n\t\t\t\tif (dsi && (dsi->type != GF_PROP_DATA) && (dsi->type != GF_PROP_CONST_DATA))\n\t\t\t\t\tdsi = NULL;\n\n\t\t\t\tif (dsi) {\n\t\t\t\t\tgf_bs_write_data(bs, dsi->value.data.ptr, dsi->value.data.size);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(bs, &gpac_meta_dsi, &udesc.extension_buf_size);\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.ext_box_wrap = GF_FALSE;\n\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing %s, using generic sample entry with 4CC \\\"GMCW\\\" and \\\"GMCC\\\" config box\\n\", gf_codecid_name(codec_id)));\n\t\t\t\tudesc.codec_tag = GF_4CC('G', 'M', 'C', 'W');\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('G', 'M', 'C', 'C');\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing unknown codec ID %s, using generic sample entry with 4CC \\\"%s\\\"\\n\", gf_codecid_name(codec_id), gf_4cc_to_str(m_subtype) ));\n\t\t\t}\n\t\t}\n\t\t\n\t\te = gf_isom_new_generic_sample_description(ctx->file, tkw->track_num, (char *)src_url, NULL, &udesc, &tkw->stsd_idx);\n\t\tif (gpac_meta_dsi) gf_free(gpac_meta_dsi);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t} else {\n\t\tassert(0);\n\t}\n\n\tif (!tkw->all_stsd_crc) {\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update) {\n\t\t\tu32 avg_rate, max_rate, dbsize;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_BITRATE);\n\t\t\tavg_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MAXRATE);\n\t\t\tmax_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DBSIZE);\n\t\t\tdbsize = p ? p->value.uint : 0;\n\n\t\t\tif (avg_rate && max_rate) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, avg_rate, max_rate, dbsize);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0);\n\t\t}\n\t}\n\nmultipid_stsd_setup:\n\tif (multi_pid_stsd) {\n\t\tif (multi_pid_idx<gf_list_count(multi_pid_stsd)) {\n\n\t\t\tif (multi_pid_final_stsd_idx == multi_pid_idx) {\n\t\t\t\tframes_per_sample_backup = tkw->nb_frames_per_sample;\n\t\t\t\tis_nalu_backup = tkw->is_nalu;\n\t\t\t}\n\t\t\tpid = gf_list_get(multi_pid_stsd, multi_pid_idx);\n\t\t\tmulti_pid_idx ++;\n\t\t\t//reload codecID, decoder config and enhancement decoder config\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\t\t\tif (p) codec_id = p->value.uint;\n\t\t\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\t\t\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\t\t\t//force stsd idx to be 0 to avoid removing the stsd\n\t\t\ttkw->stsd_idx = 0;\n\t\t\tgoto sample_entry_setup;\n\t\t}\n\t\ttkw->stsd_idx = multi_pid_final_stsd_idx;\n\t\t//restore input pid\n\t\tpid = orig_pid;\n\t\tcodec_id = tkw->codecid;\n\n\t\ttkw->is_nalu = is_nalu_backup;\n\t\ttkw->nb_frames_per_sample = frames_per_sample_backup;\n\t}\n\n\n\t//final opt: we couldn't detect before if the same stsd was possible, now that we have create a new one, check again\n\tif (needs_sample_entry) {\n\t\treuse_stsd = 0;\n\t\t//don't try to reuse STSDs in multi STSD setup for DASH\n\t\tif (multi_pid_stsd) count = 0;\n\t\telse count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (i+1 == tkw->stsd_idx) continue;\n\n\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, i+1) ) {\n\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\ttkw->stsd_idx = i+1;\n\t\t\t\treuse_stsd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->reused_stsd = reuse_stsd;\n\t\tif (!reuse_stsd) {\n\t\t\ttkw->samples_in_stsd = 0;\n\t\t} else if (use_3gpp_config) {\n\t\t\tGF_3GPConfig *gpp_cfg = gf_isom_3gp_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (gpp_cfg) {\n\t\t\t\tgpp_cfg->AMR_mode_set = tkw->amr_mode_set;\n\t\t\t\tgf_isom_3gp_config_update(ctx->file, tkw->track_num, gpp_cfg, tkw->stsd_idx);\n\t\t\t\tgf_free(gpp_cfg);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted && !skip_crypto) {\n\t\tconst char *scheme_uri=NULL;\n\t\tconst char *kms_uri=NULL;\n\t\tu32 scheme_version=0;\n\t\tu32 scheme_type = 0;\n\t\tBool is_sel_enc = GF_FALSE;\n\t\tu32 KI_length=0;\n\t\tu32 IV_length=0;\n\t\t/*todo !*/\n\t\tconst char *oma_contentID=0;\n\t\tu32 oma_encryption_type=0;\n\t\tu64 oma_plainTextLength=0;\n\t\tconst char *oma_textual_headers=NULL;\n\t\tu32 textual_headers_len=0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_URI);\n\t\tif (p) scheme_uri = p->value.string;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_KMS_URI);\n\t\tif (p) kms_uri = p->value.string;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_SELECTIVE_ENC);\n\t\tif (p) is_sel_enc = p->value.boolean;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_IV_LENGTH);\n\t\tif (p) IV_length = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_KI_LENGTH);\n\t\tif (p) KI_length = p->value.uint;\n\n\t\ttkw->scheme_type = scheme_type;\n\t\tswitch (scheme_type) {\n\t\tcase GF_ISOM_ISMACRYP_SCHEME:\n\t\t\tgf_isom_set_ismacryp_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char *) scheme_uri, (char *) kms_uri, is_sel_enc, KI_length, IV_length);\n\t\t\tbreak;\n\t\tcase GF_ISOM_OMADRM_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CRYPT_TYPE);\n\t\t\tif (p) oma_encryption_type = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CID);\n\t\t\tif (p) oma_contentID = p->value.string;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_TXT_HDR);\n\t\t\tif (p) oma_textual_headers = p->value.string;\n\t\t\tif (oma_textual_headers) textual_headers_len = (u32) strlen(oma_textual_headers);\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CLEAR_LEN);\n\t\t\tif (p) oma_plainTextLength = p->value.longuint;\n\t\t\tgf_isom_set_oma_protection(ctx->file, tkw->track_num, tkw->stsd_idx, (char *) oma_contentID, (char*) kms_uri, oma_encryption_type, oma_plainTextLength, (char*)oma_textual_headers, textual_headers_len,\n                                  is_sel_enc, KI_length, IV_length);\n\n\t\t\tbreak;\n\t\tcase GF_ISOM_ADOBE_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ADOBE_CRYPT_META);\n\t\t\tgf_isom_set_adobe_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, 1/*scheme_version*/, 1/*is_sel_enc*/,p ? p->value.data.ptr : NULL, p ? p->value.data.size : 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_HLS_SAMPLE_AES_SCHEME:\n\t\t\ttkw->cenc_state = CENC_NEED_SETUP;\n\t\t\tif (tkw->is_nalu || tkw->is_av1 || tkw->is_vpx) tkw->cenc_subsamples = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized protection scheme type %s, using generic signaling\\n\", gf_4cc_to_str(scheme_type) ));\n\t\t\tswitch (tkw->stream_type) {\n\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCV);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCA);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCT);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_FONT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCF);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_isom_set_generic_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char*)scheme_uri, (char*)kms_uri);\n\t\t}\n\t} else if (!tkw->is_encrypted) {\n\t\t//in case we used track template\n\t\tgf_isom_remove_samp_enc_box(ctx->file, tkw->track_num);\n\t\tgf_isom_remove_samp_group_box(ctx->file, tkw->track_num);\n\t}\n\n\tif (is_true_pid) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:scal\", GF_ISOM_REF_SCAL, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sbas\", GF_ISOM_REF_BASE, GF_FALSE);\n\t\t//whenever we add a new tile track, rewrite sabt on main tile track\n\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\tcount = gf_list_count(ctx->tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tTrackWriter *base_tk = gf_list_get(ctx->tracks, i);\n\t\t\t\tif (base_tk->is_hevc_tile_base)\n\t\t\t\t\tmp4_mux_write_track_refs(ctx, base_tk, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have sample-accurate seek info for the pid. If so, enable seek ts checking\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (p && p->value.sint)\n\t\t\ttkw->check_seek_ts = GF_TRUE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t}\n\n\t} else if (codec_id==GF_CODECID_HEVC_TILES) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t}\n\n\tif (is_true_pid && ctx->dash_mode && is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (width) {\n\t\tif (ctx->ccst) {\n\t\t\te = gf_isom_set_image_sequence_coding_constraints(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set coding constraints parameter: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\t\tif (p && p->value.boolean) {\n\t\t\te = gf_isom_set_image_sequence_alpha(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set alpha config: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\nsample_entry_done:\n\tif (!tkw->is_item) {\n\t\tif (ctx->maxchunk)\n\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, ctx->maxchunk);\n\n\t\tif (ctx->store==MP4MX_MODE_FLAT)\n\t\t\tgf_isom_hint_max_chunk_duration(ctx->file, tkw->track_num, tkw->tk_timescale * ctx->cdur.num / ctx->cdur.den);\n\n\t\tif (sr) {\n\t\t\tif (use_flac_entry) {\n\t\t\t\twhile (sr>65535) {\n\t\t\t\t\tu32 val = sr/2;\n\t\t\t\t\tif (val*2 != sr) {\n\t\t\t\t\t\tsr=65535;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsr = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m_subtype!=GF_QT_SUBTYPE_LPCM) {\n\t\t\t\tgf_isom_set_audio_info(ctx->file, tkw->track_num, tkw->stsd_idx, sr, nb_chan, nb_bps, ctx->make_qt ? GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF : ase_mode);\n\t\t\t}\n\n\t\t\tif ((m_subtype==GF_ISOM_SUBTYPE_IPCM) || (m_subtype==GF_ISOM_SUBTYPE_FPCM)) {\n\t\t\t\tGF_AudioChannelLayout layout;\n\t\t\t\tmemset(&layout, 0, sizeof(GF_AudioChannelLayout));\n\t\t\t\tlayout.stream_structure = 1;\n\t\t\t\tlayout.channels_count = nb_chan;\n\t\t\t\tif (ch_layout)\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_from_layout(ch_layout);\n\t\t\t\telse\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_layout(nb_chan, 0, 0);\n\t\t\t\tgf_isom_set_audio_layout(ctx->file, tkw->track_num, tkw->stsd_idx, &layout);\n\t\t\t}\n\t\t}\n\t\telse if (width) {\n\t\t\tu32 colour_type=0;\n\t\t\tu16 colour_primaries=0, transfer_characteristics=0, matrix_coefficients=0;\n\t\t\tBool full_range_flag=GF_FALSE;\n\n\t\t\tgf_isom_set_visual_info(ctx->file, tkw->track_num, tkw->stsd_idx, width, height);\n\t\t\tif (sar.den) {\n\t\t\t\tif (sar.num != sar.den) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, sar.num, sar.den, GF_FALSE);\n\t\t\t\t\twidth = width * sar.num / sar.den;\n\t\t\t\t}\n\t\t\t\t//old importer did not set PASP for\n\t\t\t\telse if (!gf_sys_old_arch_compat() || (codec_id!=GF_CODECID_MPEG4_PART2) ) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, 1, 1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, width<<16, height<<16, 0, 0, z_order);\n\t\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ORIG_SIZE);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, p->value.vec2i.x<<16, p->value.vec2i.y<<16, 0, 0, z_order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_PRIMARIES);\n\t\t\tif (p) colour_primaries = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_TRANSFER);\n\t\t\tif (p) transfer_characteristics = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_MX);\n\t\t\tif (p) matrix_coefficients = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_RANGE);\n\t\t\tif (p) full_range_flag = p->value.boolean;\n\n\t\t\tif (ctx->cmaf) {\n\t\t\t\tu32 hspac=0, vspac=0;\n\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t\tgf_isom_get_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, &hspac, &vspac);\n\t\t\t\tif (hspac && vspac) {\n\t\t\t\t\tsar.num = hspac;\n\t\t\t\t\tsar.den = vspac;\n\t\t\t\t} else {\n\t\t\t\t\tsar.den = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->prores_track == tkw) || force_colr) {\n\t\t\t\tu32 colr_mode;\n\n\t\t\t\tif ((ctx->prores_track == tkw) || ctx->make_qt)\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','c');\n\t\t\t\telse\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','x');\n\n\t\t\t\t//other conditions were set above, here we force 1:1 pasp box even if no sar or 1:1\n\t\t\t\tif (!sar.den || (sar.num == 1)) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, -1, -1, GF_TRUE);\n\t\t\t\t}\n\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, GF_FALSE, NULL, 0);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\te = gf_media_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\tcolour_primaries = 1;\n\t\t\t\t\t\ttransfer_characteristics = 1;\n\t\t\t\t\t\tmatrix_coefficients = 1;\n\t\t\t\t\t\tfull_range_flag = GF_FALSE;\n\t\t\t\t\t\tif (ctx->make_qt==1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ProRes] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ctx->cmaf) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[CMAF] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->prores_track == tkw) {\n\t\t\t\t\tu32 chunk_size;\n\t\t\t\t\tif ((width<=720) && (height<=576)) chunk_size = 2000000;\n\t\t\t\t\telse chunk_size = 4000000;\n\t\t\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, chunk_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC('n','c','l','x'), colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//check if we have an icc profile\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ICC_PROFILE);\n\t\t\tif (p && (p->type==GF_PROP_DATA) && p->value.data.ptr) {\n\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0, 0, GF_FALSE, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONTENT_LIGHT_LEVEL);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MASTER_DISPLAY_COLOUR);\n\t\t\tif (p || p2) {\n\t\t\t\tGF_MasteringDisplayColourVolumeInfo mdcv;\n\t\t\t\tGF_ContentLightLevelInfo clli;\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tif (p) {\n\t\t\t\t\tbs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\t\tclli.max_content_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tclli.max_pic_average_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tif (p2) {\n\t\t\t\t\tbs = gf_bs_new(p2->value.data.ptr, p2->value.data.size, GF_BITSTREAM_READ);\n\n\t\t\t\t\tfor(u32 c=0;c<3;c++) {\n\t\t\t\t\t\tmdcv.display_primaries[c].x = gf_bs_read_int(bs, 16);\n\t\t\t\t\t\tmdcv.display_primaries[c].y = gf_bs_read_int(bs, 16);\n\t\t\t\t\t}\n\t\t\t\t\tmdcv.white_point_x = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.white_point_y = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.max_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tmdcv.min_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_set_high_dynamic_range_info(ctx->file, tkw->track_num, tkw->stsd_idx, p2 ? &mdcv : NULL, p ? &clli : NULL);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DOLBY_VISION);\n\t\t\tif (p) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\tGF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tif (dvcc && tkw->xps_inband && (dvcc->dv_profile==8) && ctx->dvsingle) {\n\t\t\t\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tif (dovi) {\n\t\t\t\t\t\tif (dovi->dv_profile==5) {\n\t\t\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t\t\t\tdvcc = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_odf_dovi_cfg_del(dovi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dvcc) {\n\t\t\t\t\tif (ctx->force_dv)\n\t\t\t\t\t\tdvcc->force_dv = 1;\n\n\t\t\t\t\tgf_isom_set_dolby_vision_profile(ctx->file, tkw->track_num, tkw->stsd_idx, dvcc);\n\n\t\t\t\t\tif (!dvcc->bl_present_flag) {\n\t\t\t\t\t\tu32 ref_id = 0;\n\n\t\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\t\t\t\t\t\tif (p) ref_id = p->value.uint;\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(ctx->tracks); i++) {\n\t\t\t\t\t\t\tTrackWriter *tkw_base = gf_list_get(ctx->tracks, i);\n\t\t\t\t\t\t\tif (tkw_base == tkw) continue;\n\t\t\t\t\t\t\tif (tkw->codecid!=tkw_base->codecid) continue;\n\t\t\t\t\t\t\tif (ref_id) {\n\t\t\t\t\t\t\t\tp = gf_filter_pid_get_property(tkw_base->ipid, GF_PROP_PID_ID);\n\t\t\t\t\t\t\t\tif (!p || (p->value.uint!=ref_id)) continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tref_id = gf_isom_get_track_id(ctx->file, tkw_base->track_num);\n\t\t\t\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_4CC('v','d','e','p'), ref_id);\n\n\t\t\t\t\t\t\t//dolby requires seperate moof for each track fragment for base and el\n\t\t\t\t\t\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\t\t\t\t\t\tctx->straf = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = (codec_id==GF_CODECID_HEVC) ? gf_filter_pid_get_property_str(pid, \"hevc_split\") : NULL;\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CROP_POS);\n\t\t\t\tp2 = gf_filter_pid_get_property(pid, GF_PROP_PID_ORIG_SIZE);\n\t\t\t\tif (p && p2) {\n#define GPAC_SRD_SIZE\t21\n\t\t\t\t\tu8 srdg[GPAC_SRD_SIZE];\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(srdg, GPAC_SRD_SIZE, GF_BITSTREAM_WRITE);\n\t\t\t\t\tgf_bs_write_int(bs, 1, 1);//mergeable\n\t\t\t\t\tgf_bs_write_int(bs, 0, 7);//unused\n\t\t\t\t\tgf_bs_write_u32(bs, 1);//groupID\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.x);//offx\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.y);//offy\n\t\t\t\t\tgf_bs_write_u32(bs, p2->value.vec2i.x);//osize_w\n\t\t\t\t\tgf_bs_write_u32(bs, p2->value.vec2i.y);//osize_h\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t//stored as track user data for now\n\t\t\t\t\tgf_isom_add_user_data(ctx->file, tkw->track_num, GF_ISOM_UDTA_GPAC_SRD, NULL, srdg, GPAC_SRD_SIZE);\n\n\t\t\t\t\ts32 mx[9];\n\t\t\t\t\tmemset(mx, 0, sizeof(s32)*9);\n\t\t\t\t\tmx[0] = mx[4] = 0x00010000;\n\t\t\t\t\tmx[8] = 0x40000000;\n\t\t\t\t\tmx[6] = 65536*p->value.vec2i.x;\n\t\t\t\t\tmx[7] = 65536*p->value.vec2i.y;\n\t\t\t\t\tgf_isom_set_track_matrix(ctx->file, tkw->track_num, mx);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t//default for old arch\n\t\telse if (force_tk_layout\n\t\t\t|| (use_m4sys && (tkw->stream_type==GF_STREAM_VISUAL) && !width && !height)\n\t\t)  {\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 320<<16, 240<<16, 0, 0, 0);\n\t\t}\n\n\t\tif (lang_name) gf_isom_set_media_language(ctx->file, tkw->track_num, (char*)lang_name);\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tgf_isom_update_sample_description_from_template(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.data.ptr, p->value.data.size);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_TIMES);\n\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_NAMES);\n\t\tif (p && p2 && (p->value.uint_list.nb_items == p2->value.string_list.nb_items)) {\n\t\t\tBool add_chap=GF_FALSE;\n\t\t\tBool add_tk=GF_FALSE;\n\t\t\tu32 trak_di=0;\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_UDTA)) {\n\t\t\t\tgf_isom_remove_chapter(ctx->file, 0, 0);\n\t\t\t\tadd_chap = GF_TRUE;\n\t\t\t}\n\t\t\tif (((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK))\n\t\t\t\t&& !ctx->chap_track_num\n\t\t\t) {\n\t\t\t\tGF_FontRecord frec;\n\t\t\t\tGF_TextSampleDescriptor txtdesc;\n\t\t\t\tctx->chap_track_num = gf_isom_new_track(ctx->file, 0xFFFE, GF_ISOM_MEDIA_TEXT, 1000);\n\t\t\t\tgf_isom_set_track_flags (ctx->file, ctx->chap_track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t\t//move chapter track last\n\t\t\t\tgf_isom_set_track_index(ctx->file, ctx->chap_track_num, 0xFFFE, mp4mux_track_reorder, ctx);\n\t\t\t\tmemset(&txtdesc, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttxtdesc.font_count = 1;\n\t\t\t\ttxtdesc.fonts = &frec;\n\t\t\t\tfrec.fontName = \"SANS\";\n\t\t\t\tfrec.fontID=1;\n\t\t\t\ttxtdesc.default_style.fontID=1;\n\t\t\t\ttxtdesc.default_style.font_size = 32;\n\t\t\t\t//txtdesc.default_style.text_color = 0xFFFFFFFF;\n\t\t\t\t//txtdesc.horiz_justif = 1;\n\t\t\t\t//txtdesc.vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\t\t\tgf_isom_new_text_description(ctx->file, ctx->chap_track_num, &txtdesc, NULL, NULL, &trak_di);\n\t\t\t\tadd_tk = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (add_tk || add_chap) {\n\t\t\t\tu32 j;\n\t\t\t\tu64 maxts = (ctx->dur.num && ctx->dur.den) ? gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, 1000) : 0;\n\t\t\t\tfor (j=0; j<p->value.uint_list.nb_items; j++) {\n\t\t\t\t\tu32 start_time = p->value.uint_list.vals[j];\n\t\t\t\t\tif (ctx->start > start_time) {\n\t\t\t\t\t\tif (j+1 < p->value.uint_list.nb_items) {\n\t\t\t\t\t\t\tu64 next = p->value.uint_list.vals[j+1];\n\t\t\t\t\t\t\tif (ctx->start>=next)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (start_time > (u32) ctx->start) start_time -= (u32) ctx->start;\n\t\t\t\t\t\telse start_time=0;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxts && (maxts<=start_time))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (add_chap) {\n\t\t\t\t\t\tgf_isom_add_chapter(ctx->file, 0, start_time, p2->value.string_list.vals[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (add_tk) {\n\t\t\t\t\t\tGF_TextSample tx;\n\t\t\t\t\t\tmemset(&tx, 0, sizeof(tx));\n\t\t\t\t\t\ttx.text = p2->value.string_list.vals[j];\n\t\t\t\t\t\ttx.len = (u32) strlen(p2->value.string_list.vals[j])+1;\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_text_to_sample(&tx);\n\t\t\t\t\t\tsamp->DTS = start_time;\n\t\t\t\t\t\tsamp->IsRAP = 1;\n\n\t\t\t\t\t\t//force fist chapter to start at 0\n\t\t\t\t\t\tif (!j && samp->DTS) {\n\t\t\t\t\t\t\tsamp->DTS = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_add_sample(ctx->file, ctx->chap_track_num, trak_di, samp);\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK)) {\n\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_CHAP, gf_isom_get_track_id(ctx->file, ctx->chap_track_num));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted) {\n\t\ttkw->cenc_ki = gf_filter_pid_get_property(pid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (tkw->cenc_ki && ((tkw->cenc_ki->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size))\n\t\t) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC key info\\n\"));\n\t\t\ttkw->cenc_ki = NULL;\n\t\t}\n\n\t\ttkw->constant_IV_size = 0;\n\t\tif (tkw->cenc_ki && tkw->cenc_ki->value.data.ptr) {\n\t\t\ttkw->cenc_multikey = tkw->cenc_ki->value.data.ptr[0] ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (!tkw->cenc_ki->value.data.ptr[3])\n\t\t\t\ttkw->constant_IV_size = !tkw->cenc_ki->value.data.ptr[20];\n\n\t\t\ttkw->cenc_key_info_crc = gf_crc_32(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t}\n\t}\n\n\tif (is_true_pid) {\n\t\tconst GF_PropertyValue *ster = gf_filter_pid_get_property(pid, GF_PROP_PID_STEREO_TYPE);\n\t\tconst GF_PropertyValue *proj = gf_filter_pid_get_property(pid, GF_PROP_PID_PROJECTION_TYPE);\n\t\tconst GF_PropertyValue *pose = gf_filter_pid_get_property(pid, GF_PROP_PID_VR_POSE);\n\n\t\tif (ster || proj) {\n\t\t\tGF_ISOM_Y3D_Info yt3d;\n\t\t\tmemset(&yt3d, 0, sizeof(GF_ISOM_Y3D_Info));\n\t\t\tyt3d.projection_type = proj ? proj->value.uint : 0;\n\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\tif (pose) {\n\t\t\t\tyt3d.pose_present = GF_TRUE;\n\t\t\t\tyt3d.yaw = pose->value.vec3i.x;\n\t\t\t\tyt3d.pitch = pose->value.vec3i.y;\n\t\t\t\tyt3d.roll = pose->value.vec3i.z;\n\t\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\t}\n\t\t\tif (yt3d.projection_type==GF_PROJ360_CUBE_MAP) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_CUBE_MAP_PAD);\n\t\t\t\tyt3d.padding = proj ? proj->value.uint : 0;\n\t\t\t}\n\t\t\telse if (yt3d.projection_type==GF_PROJ360_EQR) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_EQR_CLAMP);\n\t\t\t\tif (proj) {\n\t\t\t\t\tyt3d.top = proj->value.vec4i.x;\n\t\t\t\t\tyt3d.bottom = proj->value.vec4i.y;\n\t\t\t\t\tyt3d.left = proj->value.vec4i.z;\n\t\t\t\t\tyt3d.right = proj->value.vec4i.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_set_y3d_info(ctx->file, tkw->track_num, tkw->stsd_idx, &yt3d);\n\t\t}\n\t}\n\n\n\tif (is_true_pid && ctx->importer && !tkw->import_msg_header_done) {\n#ifndef GPAC_DISABLE_LOG\n\t\tconst char *dst_type = tkw->is_item ? \"Item Importing\" : \"Track Importing\";\n#endif\n\t\ttkw->import_msg_header_done = GF_TRUE;\n\t\tif (!imp_name) imp_name = comp_name;\n\t\tif (sr) {\n\t\t\tif (nb_chan) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d Num Channels %d\\n\", dst_type, imp_name, sr, nb_chan));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d\\n\", dst_type, imp_name, sr));\n\t\t\t}\n\t\t} else if (is_text_subs) {\n\t\t\tif (txt_fsize || txt_font) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d font %s (size %d) layer %d\\n\", dst_type, imp_name, width, height, txt_font ? txt_font : \"unspecified\", txt_fsize, z_order));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d layer %d\\n\", dst_type, imp_name, width, height, z_order));\n\n\t\t\t}\n\t\t} else if (width) {\n\t\t\tif (sar.den && sar.num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d SAR %d/%u\\n\", dst_type, imp_name, width, height, fps.num, fps.den, sar.num, sar.den));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d\\n\", dst_type, imp_name, width, height, fps.num, fps.den));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s\\n\", dst_type, imp_name));\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (tkw->svcc) {\n\t\t\tAVCState avc;\n\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\tcount = gf_list_count(tkw->svcc->sequenceParameterSets);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(tkw->svcc->sequenceParameterSets, i);\n\t\t\t\tu8 nal_type = sl->data[0] & 0x1F;\n\t\t\t\tBool is_subseq = (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) ? GF_TRUE : GF_FALSE;\n\t\t\t\ts32 ps_idx = gf_avc_read_sps(sl->data, sl->size, &avc, is_subseq, NULL);\n\t\t\t\tif (ps_idx>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"SVC Detected - SSPS ID %d - frame size %d x %d\\n\", ps_idx-GF_SVC_SSPS_ID_SHIFT, avc.sps[ps_idx].width, avc.sps[ps_idx].height ));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n\tif (txt_font) gf_free(txt_font);\n\tif (!tkw->xps_inband || tkw->is_item) {\n\t\tif (tkw->svcc) {\n\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\ttkw->svcc = NULL;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\ttkw->lvcc = NULL;\n\t\t}\n\t} else if (needs_sample_entry || make_inband_headers) {\n\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t}\n\n\ttkw->negctts_shift = 0;\n\ttkw->probe_min_ctts = GF_FALSE;\n\tif (is_true_pid && !tkw->nb_samples && !tkw->is_item) {\n\t\tBool use_negccts = GF_FALSE;\n\t\tBool remove_edits = GF_FALSE;\n\t\ts64 moffset=0;\n\t\tctx->config_timing = GF_TRUE;\n\t\tctx->update_report = GF_TRUE;\n\n\t\t//if we have an edit list (due to track template) only providing media offset, trash it\n\t\tif (!gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) {\n\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t} else {\n\t\t\t\t//old arch compat: if we had a simple edit list in source, keep dur and offset\n\t\t\t\t//and avoid rewriting it when recomputing edit for b-frames\n\t\t\t\tu64 etime, sdur;\n\t\t\t\tGF_ISOEditType etype;\n\t\t\t\tgf_isom_get_edit(ctx->file, tkw->track_num, 1, &etime, &sdur, &moffset, &etype);\n\t\t\t\tif (!etime && sdur) {\n\t\t\t\t\ttkw->imported_edit_sdur = sdur;\n\t\t\t\t\ttkw->imported_edit_offset = moffset;\n\t\t\t\t}\n\t\t\t\tremove_edits = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) use_negccts = GF_TRUE;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DELAY);\n\t\tif (p) {\n\t\t\t//media skip\n\t\t\tif (p->value.longsint < 0) {\n\t\t\t\t//if cmf2, remove edits and use negctss\n\t\t\t\tif ((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tctx->ctmode = MP4MX_CT_NEGCTTS;\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ctx->ctmode==MP4MX_CT_NEGCTTS) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, 0, -p->value.longsint, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//media delay\n\t\t\telse if (p->value.longsint > 0) {\n\t\t\t\t//if cmaf (whether cmfc or cmf2), remove edits and add delay to tfdt\n\t\t\t\tif (ctx->cmaf) {\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\ttkw->patch_tfdt = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dur = gf_timestamp_rescale_signed(p->value.longsint, tkw->src_timescale, ctx->moovts);\n\t\t\t\t\ts64 diff_low = (s64) p->value.longuint - dur * tkw->src_timescale / ctx->moovts;\n\t\t\t\t\t//we are loosing precision, check if true value is closer to next representable value in movie timescale\n\t\t\t\t\tif (diff_low>0) {\n\t\t\t\t\t\ts64 diff_high = (dur+1) * tkw->src_timescale / ctx->moovts - (s64) p->value.longuint;\n\t\t\t\t\t\tif (diff_high < diff_low) dur++;\n\t\t\t\t\t}\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tif (dur) {\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->ts_delay = (s32) p->value.longsint;\n\t\t} else if (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\ttkw->probe_min_ctts = GF_TRUE;\n\t\t}\n\t\t//for old arch compatibility\n\t\telse if (remove_edits) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"reframer_rem_edits\");\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t}\n\t\tif (use_negccts) {\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\t\t}\n\n\t\t\ttkw->negctts_shift = (tkw->ts_delay<0) ? -tkw->ts_delay : 0;\n\t\t} else {\n\t\t\t//this will remove any cslg in the track due to template\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\t\t}\n\n\t\tif (!ctx->noinit) {\n\t\t\tmp4_mux_set_tags(ctx, tkw);\n\t\t\tmp4_mux_set_udta(ctx, tkw);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx);\n#endif\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final);\n\nstatic GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ctx->ref_tkw == tkw) ctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\t//removing last pid\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\t//non-frag file, flush file\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t//delete output pid (to flush destruction of filter chain)\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}\n\nstatic Bool mp4_mux_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_INFO_UPDATE) ) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(evt->base.on_pid);\n\t\tif (tkw) {\n\t\t\tGF_PropertyEntry *pe=NULL;\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_BYTES, &pe);\n\t\t\tif (p) tkw->down_bytes = p->value.longuint;\n\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_SIZE, &pe);\n\t\t\tif (p) tkw->down_size = p->value.longuint;\n\n\t\t\tgf_filter_release_property(pe);\n\t\t}\n\n\t\treturn GF_FALSE;\n\t}\n\tif (!evt->base.on_pid && (evt->base.type==GF_FEVT_STOP) ) {\n\t\tif (ctx->file && ctx->owns_mov) {\n\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t}\n\t}\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_PLAY) ) {\n\t\tu32 i, count;\n\t\tGF_FilterEvent anevt;\n\t\tctx->force_play = GF_TRUE;\n\t\tif (evt->play.speed<0)\n\t\t\tctx->is_rewind = GF_TRUE;\n\n\t\tif (ctx->start == 0)\n\t\t\treturn GF_FALSE;\n\n\t\tcount = gf_list_count(ctx->tracks);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->fake_track) continue;\n\n\t\t\tanevt.play = evt->play;\n\t\t\tgf_filter_pid_init_play_event(tkw->ipid, &anevt, ctx->start, 0, \"MP4Mux\");\n\t\t\tif (anevt.play.start_range > 0)\n\t\t\t\ttkw->wait_sap = GF_TRUE;\n\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &anevt);\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nenum\n{\n\tCENC_CONFIG=0,\n\tCENC_ADD_NORMAL,\n\tCENC_ADD_FRAG,\n};\n\nstatic void mp4_mux_cenc_insert_pssh(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const GF_PropertyValue *pssh, u32 dyn_pssh_mode)\n{\n\tbin128 *keyIDs=NULL;\n\tu32 max_keys = 0;\n\tu32 i, nb_pssh;\n\tGF_PropertyValue _the_prop;\n\n\t//set pssh\n\tconst GF_PropertyValue *p=NULL;\n\n\t//only inject if pssh in packet\n\tif (dyn_pssh_mode==2) {\n\t\tGF_FilterPacket *pck;\n\t\t//nothing to inject\n\t\tif (!tkw->dyn_pssh) return;\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (pck) {\n\t\t\tpssh = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t//change of dynamic pssh is pending, don't inject the old one\n\t\t\tif (pssh) return;\n\t\t}\n\t\t_the_prop.type = GF_PROP_DATA;\n\t\t_the_prop.value.data.ptr = tkw->dyn_pssh;\n\t\t_the_prop.value.data.size = tkw->dyn_pssh_len;\n\t\tp = &_the_prop;\n\t} else {\n\t\tif (pssh) {\n\t\t\tp = pssh;\n\t\t} else {\n\t\t\t//inject pssh from packet if any, or from PID (used for keyroll of master+leaf schemes)\n\t\t\tif (dyn_pssh_mode) {\n\t\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t\tif (pck) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p)\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PSSH);\n\t\t}\n\t\tif (!p) return;\n\t}\n\n\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size);\n\n\tnb_pssh = gf_bs_read_u32(ctx->bs_r);\n\tfor (i = 0; i < nb_pssh; i++) {\n\t\tu32 mode;\n\t\tbin128 sysID;\n\t\tu32 j, kid_count, version=0;\n\t\tchar *data;\n\t\tu32 len;\n\n\t\tgf_bs_read_data(ctx->bs_r, sysID, 16);\n\t\tversion = gf_bs_read_u32(ctx->bs_r);\n\t\tkid_count = version ? gf_bs_read_u32(ctx->bs_r) : 0;\n\n\t\tif (kid_count>=max_keys) {\n\t\t\tmax_keys = kid_count;\n\t\t\tkeyIDs = gf_realloc(keyIDs, sizeof(bin128)*max_keys);\n\t\t}\n\t\tfor (j=0; j<kid_count; j++) {\n\t\t\tgf_bs_read_data(ctx->bs_r, keyIDs[j], 16);\n\t\t}\n\t\tlen = gf_bs_read_u32(ctx->bs_r);\n\t\tdata = p->value.data.ptr + gf_bs_get_position(ctx->bs_r);\n\n\t\tif (tkw->is_item) mode = 2;\n\t\telse if (tkw->scheme_type==GF_ISOM_PIFF_SCHEME) mode = 1;\n\t\telse mode = 0;\n\n\t\tgf_cenc_set_pssh(ctx->file, sysID, version, kid_count, keyIDs, data, len, mode);\n\t\tgf_bs_skip_bytes(ctx->bs_r, len);\n\t\tif (gf_bs_is_overflow(ctx->bs_r))\n\t\t\tbreak;\n\t}\n\tif (keyIDs) gf_free(keyIDs);\n\n\n\tif (pssh) {\n\t\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\t\ttkw->dyn_pssh = gf_malloc(sizeof(u8) * pssh->value.data.size);\n\t\tif (!tkw->dyn_pssh) return;\n\t\tmemcpy(tkw->dyn_pssh, pssh->value.data.ptr, sizeof(u8) * pssh->value.data.size);\n\t\ttkw->dyn_pssh_len = pssh->value.data.size;\n\t}\n\n}\n\nstatic GF_Err mp4_mux_cenc_update(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, u32 act_type, u32 pck_size, u32 injected_hdr_size)\n{\n\tconst GF_PropertyValue *p;\n\tGF_Err e;\n\tBool pck_is_encrypted;\n\tu32 IV_size=0;\n\tu8 *fake_sai = NULL;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0;\n\tBool needs_seig = GF_FALSE;\n\tu32 sample_num;\n\n\tif (tkw->cenc_state == CENC_SETUP_ERROR)\n\t\treturn GF_SERVICE_ERROR;\n\n\n\tif (pck) {\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (p) {\n\t\t\tsai = p->value.data.ptr;\n\t\t\tsai_size = p->value.data.size;\n\t\t}\n\t}\n\n\n\t//initial setup\n\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\tu32 scheme_type=0;\n\t\tu32 scheme_version=0;\n\t\tu32 cenc_stsd_mode=0;\n\t\tu32 container_type = GF_ISOM_BOX_TYPE_SENC;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STSD_MODE);\n\t\tif (p) cenc_stsd_mode = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ENCRYPTED);\n\t\tif (p) pck_is_encrypted = p->value.boolean;\n\t\telse pck_is_encrypted = GF_FALSE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STORE);\n\t\tif (p && p->value.uint) container_type = p->value.uint;\n\n\t\ttkw->clear_stsd_idx = 0;\n\t\tif (cenc_stsd_mode) {\n\t\t\tu32 clone_stsd_idx;\n\t\t\te = gf_isom_clone_sample_description(ctx->file, tkw->track_num, ctx->file, tkw->track_num, tkw->stsd_idx, NULL, NULL, &clone_stsd_idx);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to clone sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t//current stsd reused, use clone one for encrypted stsd\n\t\t\tif (tkw->reused_stsd) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//before\n\t\t\telse if (cenc_stsd_mode==1) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//after\n\t\t\telse {\n\t\t\t\ttkw->clear_stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t}\n\t\ttkw->def_crypt_byte_block = tkw->crypt_byte_block;\n\t\ttkw->def_skip_byte_block = tkw->skip_byte_block;\n\n\t\ttkw->cenc_state = CENC_SETUP_DONE;\n\t\ttkw->def_cenc_key_info_crc = tkw->cenc_key_info_crc;\n\t\tif (tkw->cenc_ki) {\n\t\t\te = gf_isom_set_cenc_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, pck_is_encrypted, tkw->def_crypt_byte_block, tkw->def_skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Missing CENC Key config, cannot mux\\n\"));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn e;\n\t\t}\n\n\t\t//purge duplicates\n\t\tu32 k, nb_sdesc = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tif (nb_sdesc>2) {\n\t\t\tfor (k=0; k<nb_sdesc; k++) {\n\t\t\t\tif (k+1 == tkw->stsd_idx) continue;\n\n\t\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, k+1) ) {\n\t\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\ttkw->stsd_idx = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((ctx->psshs == MP4MX_PSSH_MOOV) || (ctx->psshs == MP4MX_PSSH_BOTH))\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\n\t\tif (!tkw->has_brands && (scheme_type==GF_ISOM_OMADRM_SCHEME))\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_OPF2, GF_TRUE);\n\n\t\tif (container_type) {\n\t\t\tif (container_type==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\t\te = gf_isom_piff_allocate_storage(ctx->file, tkw->track_num, 0, 0, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_cenc_allocate_storage(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC storage: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\tif (act_type==CENC_CONFIG) return GF_OK;\n\n\tpck_is_encrypted = GF_FALSE;\n\tif (pck)\n\t\tpck_is_encrypted = gf_filter_pck_get_crypt_flags(pck);\n\n\t//!! tkw->nb_samples / tkw->samples_in_frag not yet incremented !!\n\tif (act_type == CENC_ADD_FRAG) {\n\t\tsample_num = tkw->samples_in_frag + 1;\n\n\t\tif (ctx->cmaf) {\n\t\t\tif (!tkw->samples_in_frag) {\n\t\t\t\ttkw->cenc_frag_protected = pck_is_encrypted;\n\t\t\t} else {\n\t\t\t\tif (tkw->cenc_frag_protected != pck_is_encrypted) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] CMAF forbids mixing protected and unprotected samples in a single fragment, please re-encrypt or change target segment duration\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsample_num = tkw->nb_samples + 1;\n\t}\n\tif (!pck_is_encrypted) {\n\t\tif (tkw->clear_stsd_idx) {\n\t\t\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\treturn gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n#else\n\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\treturn gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t\t}\n\t\t} else {\n\t\t\tchar dumb_key[20];\n\t\t\tmemset(dumb_key, 0, 20); //dumb key, IV size 0, not protected\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, GF_FALSE, 0, 0, dumb_key, 20);\n\t\t\tIV_size = 0;\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t}\n\t} else {\n\t\n\t\te = GF_OK;\n\t\t//multikey ALWAYS uses seig\n\t\tif (tkw->cenc_ki->value.data.ptr[0])\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_crypt_byte_block != tkw->crypt_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_skip_byte_block != tkw->skip_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_cenc_key_info_crc != tkw->cenc_key_info_crc)\n\t\t\tneeds_seig = GF_TRUE;\n\n\t\tif (needs_seig) {\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, 1, tkw->crypt_byte_block, tkw->skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t} else if (tkw->has_seig) {\n\t\t\te = gf_isom_set_sample_cenc_default_group(ctx->file, tkw->track_num, sample_num);\n\t\t}\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample encryption group entry: %s)\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr) {\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, p, 0);\n\t\t} else {\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, sample_num, GF_4CC('P','S','S','H'), 0, p->value.data.ptr, p->value.data.size, 0);\n\t\t}\n\t}\n\n\tif (!sai) {\n\t\tif (tkw->constant_IV_size && !tkw->cenc_subsamples)\n\t\t\treturn GF_OK;\n\n\t\tif (IV_size) {\n\t\t\t//generate clear SAI data with a non-0 IV\n\t\t\tu32 olen = pck_size;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 9, GF_BITSTREAM_WRITE);\n\t\t\tif (tkw->cenc_multikey) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_long_int(bs, 0, IV_size*8);\n\t\t\t}\n\n\t\t\tif (tkw->cenc_subsamples) {\n\t\t\t\tu32 i;\n\t\t\t\tu32 subsample_count = 1;\n\t\t\t\twhile (olen>0xFFFF) {\n\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\tsubsample_count ++;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u16(bs, subsample_count);\n\t\t\t\tolen = pck_size;\n\t\t\t\tfor (i = 0; i < subsample_count; i++) {\n\t\t\t\t\tu32 clear_size;\n\t\t\t\t\tif (olen<0xFFFF) {\n\t\t\t\t\t\tclear_size = olen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclear_size = 0xFFFF;\n\t\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tkw->cenc_multikey)\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\tgf_bs_write_u16(bs, clear_size);\n\t\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, &fake_sai, &sai_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tsai = fake_sai;\n\t\t}\n\t}\n\t//we injected xPS at the beginning of the sample (AVC/HEVC/VVC), we must patch the first subsample\n\t//of SAI data\n\telse if (injected_hdr_size) {\n\t\tu32 offset = 0;\n\t\tu32 first_sub_clear, sub_count_size;\n\t\tu8 *sai_d;\n\t\tu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\n\t\tassert(tkw->cenc_subsamples);\n\n\t\t//multi-key skip all IV inits\n\t\tif (tkw->cenc_ki->value.data.ptr[0]) {\n\t\t\tu32 remain;\n\t\t\tu32 j, nb_iv_init = sai[0];\n\t\t\tnb_iv_init <<= 8;\n\t\t\tnb_iv_init |= sai[1];\n\t\t\tu8 *sai_p = sai + 2;\n\t\t\tremain = sai_size-2;\n\n\t\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\t\tu32 mk_iv_size;\n\t\t\t\tu32 idx = sai_p[0];\n\t\t\t\tidx<<=8;\n\t\t\t\tidx |= sai_p[1];\n\n\t\t\t\tmk_iv_size = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\t\tmk_iv_size += 2; //idx\n\t\t\t\tif (mk_iv_size > remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t\tsai_p += mk_iv_size;\n\t\t\t\tremain -= mk_iv_size;\n\t\t\t\tif (remain && (remain<=2)) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = (u32) (sai_p - sai);\n\t\t\tsub_count_size = 4; //32bit sub count\n\n\t\t} else {\n\t\t\toffset = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\t\tsub_count_size = 2; //16bit sub count\n\t\t}\n\t\tif (sai_size < offset + sub_count_size + 6) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC SAI !\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\t//get size of first subsample\n\t\toffset += sub_count_size;\n\t\tsai_d = sai + offset;\n\t\tfirst_sub_clear = sai_d[0];\n\t\tfirst_sub_clear<<=8;\n\t\tfirst_sub_clear |= sai_d[1];\n\t\tfirst_sub_clear += injected_hdr_size;\n\t\t//fits, only patch first subsample size\n\t\tif (first_sub_clear < 0xFFFF) {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * sai_size);\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * sai_size);\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (first_sub_clear>>8) & 0xFF;\n\t\t\tsai_d[1] = (first_sub_clear) & 0xFF;\n\t\t\tsai = fake_sai;\n\t\t}\n\t\t//injected header size does not fit in first subsample, add a new subsample\n\t\telse {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * (sai_size+6));\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\t//copy till start of first subsample (including subsample_count)\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * offset);\n\t\t\t//copy all subsamples\n\t\t\tmemcpy(fake_sai+offset+6, sai+offset, sizeof(u8) * (sai_size - offset) );\n\t\t\t//insert subsample\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (injected_hdr_size>>8) & 0xFF;\n\t\t\tsai_d[1] = (injected_hdr_size) & 0xFF;\n\t\t\tsai_d[2] = sai_d[3] = sai_d[4] = sai_d[5] = 0;\n\t\t\t//update subsample count\n\t\t\tsai_d = fake_sai + offset - sub_count_size;\n\t\t\tif (sub_count_size==2) {\n\t\t\t\tu32 cnt = ((u32) sai_d[0]) << 8 | (u32) sai_d[1];\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt) & 0xFF;\n\t\t\t} else {\n\t\t\t\tu32 cnt = GF_4CC( sai_d[0], sai_d[1], sai_d[2], sai_d[3]);\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>24) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt>>16) & 0xFF;\n\t\t\t\tsai_d[2] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[3] = (cnt) & 0xFF;\n\t\t\t}\n\t\t\tsai = fake_sai;\n\t\t\tsai_size += 6;\n\t\t}\n\t}\n\n\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (pck_is_encrypted) {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (sai) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else if (!pck_is_encrypted) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n\t}\n\tif (fake_sai) gf_free(fake_sai);\n\treturn e;\n}\n\nGF_FilterSAPType mp4_mux_get_sap(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\tif (!sap) return sap;\n\tif (ctx->forcesync) return GF_FILTER_SAP_1;\n\treturn sap;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset);\nGF_Err gf_isom_fragment_append_data_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits, void **ref, u32 ref_offset);\n#endif\n\nstatic GF_Err mp4_mux_process_sample(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, Bool for_fragment)\n{\n\tGF_Err e=GF_OK;\n\tu64 cts, prev_dts;\n\tu32 prev_size=0;\n\tu32 duration = 0;\n\tu32 timescale = 0;\n\tconst GF_PropertyValue *subs;\n\tGF_FilterSAPType sap_type;\n\tu32 insert_subsample_dsi_size = 0;\n\tu32 first_nal_is_audelim = GF_FALSE;\n\tu32 sample_desc_index = tkw->stsd_idx;\n\tBool sample_timing_ok = GF_TRUE;\n\n\ttimescale = gf_filter_pck_get_timescale(pck);\n\n\tprev_dts = tkw->nb_samples ? tkw->sample.DTS : GF_FILTER_NO_TS;\n\tprev_size = tkw->sample.dataLength;\n\ttkw->sample.CTS_Offset = 0;\n\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\ttkw->dgl_copy = gf_filter_pck_dangling_copy(pck, tkw->dgl_copy);\n\t\tif (!tkw->dgl_copy) return GF_IO_ERR;\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(tkw->dgl_copy, &tkw->sample.dataLength);\n\t} else {\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(pck, &tkw->sample.dataLength);\n\t}\n\n\tctx->update_report = GF_TRUE;\n\tctx->total_bytes_in += tkw->sample.dataLength;\n\tctx->total_samples++;\n\n\ttkw->sample.DTS = gf_filter_pck_get_dts(pck);\n\tcts = gf_filter_pck_get_cts(pck);\n\n\tif (tkw->sample.DTS == GF_FILTER_NO_TS) {\n\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Sample with no DTS/CTS, cannot add (last DTS \"LLU\", last size %d)\\n\", prev_dts, prev_size ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\tu32 min_pck_dur = gf_filter_pid_get_min_pck_duration(tkw->ipid);\n\t\t\tif (min_pck_dur) {\n\t\t\t\ttkw->sample.DTS = prev_dts;\n\t\t\t\t//transform back to inpput timescale\n\t\t\t\tif (timescale != tkw->tk_timescale) {\n\t\t\t\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, tkw->tk_timescale, timescale);\n\t\t\t\t}\n\t\t\t\ttkw->sample.DTS += min_pck_dur;\n\t\t\t} else {\n\t\t\t\ttkw->sample.DTS = cts;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttkw->sample.CTS_Offset = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t}\n\n\t//do our best to patch init ts if timing config aborted\n\tif (tkw->si_min_ts_plus_one) {\n\t\tu64 si_min_ts = tkw->si_min_ts_plus_one - 1;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t\ttkw->ts_shift = tkw->sample.DTS;\n\t\tmp4_mux_update_init_edit(ctx, tkw, si_min_ts, GF_FALSE);\n\t}\n\t//tkw->ts_shift is in source timescale, apply it before rescaling TSs/duration\n\tif (tkw->ts_shift) {\n\t\tif (ctx->is_rewind) {\n\t\t\tif (tkw->sample.DTS <= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS = tkw->ts_shift - tkw->sample.DTS;\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" less than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tkw->sample.DTS >= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS -= tkw->ts_shift;\n\t\t\t\tcts -= tkw->ts_shift;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" greater than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//sample-accurate seek info, start logging min CTS of packets marked as non-sync\n\tif (tkw->check_seek_ts && !gf_filter_pck_get_seek_flag(pck)) {\n\t\tu64 ts_check = cts;\n\t\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (subs)\n\t\t\tts_check += subs->value.uint;\n\n\t\tif (!tkw->min_ts_seek_plus_one) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else if (tkw->min_ts_seek_plus_one > ts_check + 1) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else {\n\t\t\t//TS is greater than last non-seek packet TS, we're done seeking\n\t\t\ttkw->check_seek_ts = GF_FALSE;\n\t\t}\n\t}\n\n\tduration = gf_filter_pck_get_duration(pck);\n\tif (timescale != tkw->tk_timescale) {\n\t\ts64 ctso;\n\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, timescale, tkw->tk_timescale);\n\n\t\tctso = (s64) tkw->sample.CTS_Offset;\n\t\tctso *= tkw->tk_timescale;\n\t\tctso /= timescale;\n\t\ttkw->sample.CTS_Offset = (s32) ctso;\n\t\tduration *= tkw->tk_timescale;\n\t\tduration /= timescale;\n\n\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\tcts = gf_timestamp_rescale(cts, timescale, tkw->tk_timescale);\n\t\t}\n\t}\n\n\ttkw->sample.IsRAP = 0;\n\tif (tkw->codecid==GF_CODECID_RAW) {\n\t\tsap_type = GF_FILTER_SAP_1;\n\t} else {\n\t\tsap_type = mp4_mux_get_sap(ctx, pck);\n\n\t\t//if pps inband mode is used, turn sap3 into sap1\n\t\tif ((tkw->xps_inband==XPS_IB_PPS) && sap_type==GF_FILTER_SAP_3)\n\t\t\tsap_type=GF_FILTER_SAP_1;\n\t}\n\tif (sap_type==GF_FILTER_SAP_1)\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\telse if (sap_type==GF_FILTER_SAP_2)\n\t\ttkw->sample.IsRAP = SAP_TYPE_2;\n\telse if ( (sap_type == GF_FILTER_SAP_4) && (tkw->stream_type != GF_STREAM_VISUAL) )\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\n\t/*RFC8216bis is not clear here:\n\t\"if the Partial Segment contains an independent frame.\"\n\t\t-> this would allow SAP1,2,3 (independent being only defined for segments)\n\n\tbut\n\n\t\"Partial Segment containing an independent frame SHOULD carry it to increase the efficiency with which clients can join and switch Renditions\"\n\t\t-> if used for switching, this only allows SAP 1 and 2\n\n\tSpec should be fixed to allow for both cases (fast tune-in or in-segment switching\u00e0)\n\t*/\n\tif ((tkw->sample.IsRAP == SAP_TYPE_1) || (tkw->sample.IsRAP == SAP_TYPE_2))\n\t\tctx->frag_has_intra = GF_TRUE;\n\n\ttkw->sample.DTS += tkw->dts_patch;\n\tif (tkw->nb_samples && (prev_dts >= tkw->sample.DTS) ) {\n\t\t//the fragmented API will patch the duration on the fly\n\t\tif (!for_fragment && ctx->patch_dts) {\n\t\t\tgf_isom_patch_last_sample_duration(ctx->file, tkw->track_num, prev_dts ? prev_dts : 1);\n\t\t}\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID %s ID %d Sample %d with DTS \"LLU\" less than previous sample DTS \"LLU\", patching DTS%s\\n\", gf_filter_pid_get_name(tkw->ipid), tkw->track_id, tkw->nb_samples+1, tkw->sample.DTS, prev_dts, ctx->patch_dts ? \"and adjusting prev sample duration\" : \"\" ));\n\t\tsample_timing_ok = GF_FALSE;\n\n\t\tif (prev_dts) {\n\t\t\ttkw->dts_patch = prev_dts - tkw->sample.DTS;\n\t\t\ttkw->sample.DTS += tkw->dts_patch+1; //+1 to avoid 0-dur samples\n\t\t} else {\n\t\t\ttkw->sample.DTS += 1;\n\t\t\tif (tkw->sample.CTS_Offset) tkw->sample.CTS_Offset -= 1;\n\t\t\tduration-=1;\n\t\t}\n\t}\n\n\n\tif (tkw->negctts_shift)\n\t\ttkw->sample.CTS_Offset -= tkw->negctts_shift;\n\n\tif (sample_timing_ok) {\n\t\tif (tkw->probe_min_ctts) {\n\t\t\ts32 diff = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t\t\tif (diff < tkw->min_neg_ctts)\n\t\t\t\ttkw->min_neg_ctts = diff;\n\t\t}\n\t\tif (tkw->sample.CTS_Offset) tkw->has_ctts = GF_TRUE;\n\n\t\tif (tkw->sample.CTS_Offset < tkw->min_neg_ctts)\n\t\t\ttkw->min_neg_ctts = tkw->sample.CTS_Offset;\n\t}\n\n\ttkw->sample.nb_pack = 0;\n\tif (tkw->raw_audio_bytes_per_sample) {\n\t\ttkw->sample.nb_pack = tkw->sample.dataLength / tkw->raw_audio_bytes_per_sample;\n\t\tif (tkw->sample.nb_pack) {\n\t\t\tduration = 1;\n\t\t\tif (tkw->raw_samplerate && (tkw->tk_timescale != tkw->raw_samplerate)) {\n\t\t\t\tduration *= tkw->tk_timescale;\n\t\t\t\tduration /= tkw->raw_samplerate;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->cenc_state && tkw->clear_stsd_idx && !gf_filter_pck_get_crypt_flags(pck)) {\n\t\tsample_desc_index = tkw->clear_stsd_idx;\n\t}\n\n\tif (tkw->sparse_inject && (prev_dts!=GF_FILTER_NO_TS) && (tkw->sample.DTS!=GF_FILTER_NO_TS) && tkw->prev_duration) {\n\t\tu64 est_time = prev_dts + tkw->prev_duration;\n\t\tif (est_time < tkw->sample.DTS) {\n\t\t\tu32 ins_dur;\n\t\t\tGF_ISOSample s;\n\t\t\tmemset(&s, 0, sizeof(GF_ISOSample));\n\t\t\ts.DTS = est_time;\n\n\t\t\ts.IsRAP = SAP_TYPE_1;\n\t\t\tins_dur = (u32) (tkw->sample.DTS - est_time);\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &s, tkw->stsd_idx, ins_dur, 0, 0, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, tkw->stsd_idx, &s);\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, ins_dur);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->use_dref) {\n\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\tif (data_offset != GF_FILTER_NO_BO) {\n\t\t\te = gf_isom_add_sample_reference(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample, data_offset);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s as reference: %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), gf_error_to_string(e) ));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add sample reference at DTS \"LLU\" , input sample data is not continous in source\\n\", tkw->sample.DTS ));\n\t\t}\n\t} else if (tkw->nb_frames_per_sample && (tkw->nb_samples % tkw->nb_frames_per_sample)) {\n\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t \te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, tkw->sample.data, tkw->sample.dataLength, 0);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t} else {\n\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, tkw->sample.data, tkw->sample.dataLength);\n\t\t}\n\t\ttkw->has_append = GF_TRUE;\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to append sample DTS \"LLU\" data: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t}\n\t} else {\n\t\tBool inject_pps = ctx->pps_inband;\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_XPS_MASK);\n\t\t\tif (p && (p->value.uint & (1<<2) ) )\n\t\t\t\tinject_pps = GF_TRUE;\n\t\t}\n\n\t\tif ((tkw->sample.IsRAP || tkw->force_inband_inject || inject_pps) && tkw->xps_inband) {\n\t\t\tu8 *inband_xps;\n\t\t\tu32 inband_xps_size;\n\t\t\tchar *au_delim=NULL;\n\t\t\tu32 au_delim_size=0;\n\t\t\tchar *pck_data = tkw->sample.data;\n\t\t\tu32 pck_data_len = tkw->sample.dataLength;\n\t\t\tif (tkw->sample.IsRAP || tkw->force_inband_inject) {\n\t\t\t\tinband_xps = tkw->inband_hdr;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_size;\n\t\t\t\ttkw->force_inband_inject = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tinband_xps = tkw->inband_hdr_non_rap;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_non_rap_size;\n\t\t\t}\n\t\t\ttkw->sample.data = inband_xps;\n\t\t\ttkw->sample.dataLength = inband_xps_size;\n\n\t\t\tif (tkw->is_nalu==NALU_AVC) {\n\t\t\t\tif (pck_data_len >= 2 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif ((nal[0] & 0x1F) == GF_AVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 2 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pck_data_len >= 3 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif (((nal[0] & 0x7E)>>1) == GF_HEVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 3 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (au_delim) {\n\t\t\t\ttkw->sample.data = au_delim;\n\t\t\t\ttkw->sample.dataLength = au_delim_size;\n\t\t\t\tpck_data += au_delim_size;\n\t\t\t\tpck_data_len -= au_delim_size;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t//force using ref mode\n\t\t\t\tvoid *ref=NULL;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, &ref, 0);\n\t\t\t\tif (!e && au_delim) {\n\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, inband_xps, inband_xps_size, 0);\n\t\t\t\t}\n\t\t\t\tif (!e) {\n\t\t\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, pck_data, pck_data_len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\t\t\te = gf_isom_fragment_append_data_ex(ctx->file, tkw->track_id, pck_data, pck_data_len, 0, (void**)&ref, au_delim ? au_delim_size : 0);\n\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\t\tif (au_delim && !e) {\n\t\t\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, inband_xps, inband_xps_size);\n\t\t\t\t}\n\t\t\t\tif (!e) e = gf_isom_append_sample_data(ctx->file, tkw->track_num, pck_data, pck_data_len);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = inband_xps_size;\n\t\t} else if (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, (void**) &ref, 0);\n\t\t\t\tif (!ref) {\n\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t} else {\n\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\tif (!e && !duration) {\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, 0);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s - prev DTS \"LLU\": %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), prev_dts, gf_error_to_string(e) ));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] added sample DTS \"LLU\" - prev DTS \"LLU\" - prev size %d\\n\", tkw->sample.DTS, prev_dts, prev_size));\n\t\t}\n\n\t\tif (!e && tkw->cenc_state) {\n\t\t\te = mp4_mux_cenc_update(ctx, tkw, pck, for_fragment ? CENC_ADD_FRAG : CENC_ADD_NORMAL, tkw->sample.dataLength, insert_subsample_dsi_size);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->nb_samples++;\n\ttkw->samples_in_stsd++;\n\ttkw->samples_in_frag++;\n\n\tif (e) return e;\n\n\tif (!for_fragment && sample_timing_ok) {\n\t\tu64 samp_cts;\n\t\tif (!tkw->clamp_ts_plus_one) {\n\t\t\tconst GF_PropertyValue *skp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_PRES);\n\t\t\tif (skp && skp->value.boolean) {\n\t\t\t\ttkw->clamp_ts_plus_one = 1 + tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\t\t}\n\t\t}\n\t\t//store min max cts for edit list updates\n\t\tsamp_cts = tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\tif (!tkw->clamp_ts_plus_one || (samp_cts + 1 < tkw->clamp_ts_plus_one)) {\n\t\t\tif (samp_cts > tkw->max_cts) {\n\t\t\t\ttkw->max_cts = samp_cts;\n\t\t\t\ttkw->max_cts_samp_dur = duration;\n\t\t\t}\n\n\t\t\tif (tkw->min_cts > samp_cts)\n\t\t\t\ttkw->min_cts = samp_cts;\n\t\t}\n\t}\n\n\t//compat with old arch: write sample to group info for all samples\n\tif ((sap_type==3) || tkw->has_open_gop)  {\n\t\tif (!ctx->norap) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_rap_group(ctx->file, tkw->track_id, tkw->samples_in_frag, (sap_type==3) ? GF_TRUE : GF_FALSE, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else if (sap_type==3) {\n\t\t\t\te = gf_isom_set_sample_rap_group(ctx->file, tkw->track_num, tkw->nb_samples, GF_TRUE /*(sap_type==3) ? GF_TRUE : GF_FALSE*/, 0);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 3 in RAP group: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\ttkw->has_open_gop = GF_TRUE;\n\t}\n\tif (!ctx->noroll) {\n\t\tif ((sap_type==GF_FILTER_SAP_4) || (sap_type==GF_FILTER_SAP_4_PROL) || tkw->gdr_type) {\n\t\t\tGF_ISOSampleRollType roll_type = 0;\n\t\t\ts16 roll = gf_filter_pck_get_roll_info(pck);\n\t\t\tif (sap_type==GF_FILTER_SAP_4) roll_type = GF_ISOM_SAMPLE_ROLL;\n\t\t\telse if (sap_type==GF_FILTER_SAP_4_PROL) roll_type = GF_ISOM_SAMPLE_PREROLL;\n\t\t\telse if (tkw->gdr_type==GF_FILTER_SAP_4_PROL) {\n\t\t\t\troll_type = GF_ISOM_SAMPLE_PREROLL_NONE;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_roll_group(ctx->file, tkw->track_id, tkw->samples_in_frag, roll_type, roll);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_set_sample_roll_group(ctx->file, tkw->track_num, tkw->nb_samples, roll_type, roll);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 4 roll %s in roll group: %s\\n\", tkw->sample.DTS, roll, gf_error_to_string(e) ));\n\t\t\t}\n\t\t\tif (sap_type && !tkw->gdr_type)\n\t\t\t\ttkw->gdr_type = sap_type;\n\t\t}\n\t}\n\t\n\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);\n\tif (subs) {\n\t\t//if no AUDelim nal and inband header injection, push new subsample\n\t\tif (!first_nal_is_audelim && insert_subsample_dsi_size) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = 0;\n\t\t}\n\t\ttkw->has_subs = GF_TRUE;\n\n\t\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(subs->value.data.ptr, subs->value.data.size, GF_BITSTREAM_READ);\n\t\telse gf_bs_reassign_buffer(ctx->bs_r, subs->value.data.ptr, subs->value.data.size);\n\n\t\twhile (gf_bs_available(ctx->bs_r)) {\n\t\t\tu32 flags = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 subs_size = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 reserved = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu8 priority = gf_bs_read_u8(ctx->bs_r);\n\t\t\tu8 discardable = gf_bs_read_u8(ctx->bs_r);\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, flags, subs_size, priority, reserved, discardable);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, flags, subs_size, priority, reserved, discardable);\n\t\t\t}\n\n\t\t\t//we have AUDelim nal and inband header injection, push new subsample for inband header once we have pushed the first subsample (au delim)\n\t\t\tif (insert_subsample_dsi_size) {\n\t\t\t\tif (first_nal_is_audelim != subs_size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] inserting inband param after AU delimiter NALU, but sample has subsample information not aligned on NALU (got %d subsample size but expecting %d) - file might be broken!\\n\", subs_size, first_nal_is_audelim));\n\t\t\t\t}\n\t\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tinsert_subsample_dsi_size = GF_FALSE;\n\t\t\t}\n\t\t}\n\t} else if (for_fragment && tkw->has_subs && ctx->cmaf && (tkw->codecid==GF_CODECID_SUBS_XML)) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//tentative implemntation of CMAF 7.5.20 which is just nonsense text !!:\n\t\t//\"the value of subsample_count shall equal 1 for the first image sub-sample, and the subsample_count of the TTML document shall equal 0.\"\n\t\t//\n\t\t//we simply signal a single subsample\n\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, tkw->sample.dataLength, 0, 0, 0);\n#endif\n\t}\n\n\tif (ctx->deps) {\n\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\tif (dep_flags) {\n\t\t\tu32 is_leading = (dep_flags>>6) & 0x3;\n\t\t\tu32 depends_on = (dep_flags>>4) & 0x3;\n\t\t\tu32 depended_on = (dep_flags>>2) & 0x3;\n\t\t\tu32 redundant = (dep_flags) & 0x3;\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_flags(ctx->file, tkw->track_id, is_leading, depends_on, depended_on, redundant);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_set_sample_flags(ctx->file, tkw->track_num, tkw->nb_samples, is_leading, depends_on, depended_on, redundant);\n\t\t\t}\n\t\t}\n\t}\n\n\tu32 idx = 0;\n\twhile (1) {\n\t\tBool is_sample_group=GF_FALSE;\n\t\tu32 aux_type=0, aux_info=0, sg_flags=0;\n\t\tu32 p4cc;\n\t\tconst char *pname=NULL;\n\t\tconst GF_PropertyValue *p = gf_filter_pck_enum_properties(pck, &idx, &p4cc, &pname);\n\t\tif (!p) break;\n\t\tif ((p->type!=GF_PROP_DATA) && (p->type!=GF_PROP_CONST_DATA)) continue;\n\t\tif (!p->value.data.size || !p->value.data.ptr) continue;\n\t\tif (!pname) continue;\n\n\t\tif (!strncmp(pname, \"sai_\", 4)) {\n\n\t\t} else if (!strncmp(pname, \"grp_\", 4)) {\n\t\t\t//discard emsg if fragmented, otherwise add as internal sample group - TODO, support for EventMessage tracks\n\t\t\tif (!strcmp(pname, \"grp_EMSG\") && (ctx->store>=MP4MX_MODE_FRAG)) continue;\n\t\t\tis_sample_group = GF_TRUE;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpname+=4;\n\t\tu32 plen = (u32) strlen(pname);\n\t\tif (plen==3) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], ' ');\n\t\t\tpname+=3;\n\t\t} else if (plen >= 4) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], pname[3]);\n\t\t\tpname+=4;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pname[0] == '_') {\n\t\t\tif (is_sample_group) {\n\t\t\t\tchar *flags = strstr(pname, \"_z\");\n\t\t\t\tif (flags) flags[0]=0;\n\t\t\t\tif (pname[0]) aux_info = atoi(pname);\n\t\t\t\tif (flags) {\n\t\t\t\t\tsscanf(flags+2, \"%x\", &sg_flags);\n\t\t\t\t\tflags[0]='_';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taux_info = atoi(pname);\n\t\t\t}\n\t\t}\n\t\tif (!aux_type) continue;\n\n\t\tif (is_sample_group) {\n\t\t\tif (aux_type==GF_ISOM_SAMPLE_GROUP_ESGH) {\n\t\t\t\tGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type);\n\t\t\t\tgf_isom_set_sample_description_restricted(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC( 'e', 's', 's', 'g'));\n\n\t\t\t\tsg_flags |= 0x40000000;\n\t\t\t}\n\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, for_fragment ? 0 : tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size, sg_flags);\n\n\t\t} else {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_aux_info(ctx->file, tkw->track_id, tkw->samples_in_frag, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_sample_aux_info(ctx->file, tkw->track_num, tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->prev_duration = duration;\n\tif (duration && !for_fragment && !tkw->raw_audio_bytes_per_sample)\n\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, duration);\n\n\tif (ctx->dur.num) {\n\t\tBool abort = GF_FALSE;\n\t\tif (ctx->dur.num>0) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t\t\tmdur = tkw->sample.DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//adjust if shift is below half sec (to take AV delay into account)\n\t\t\t//if larger, we imported from non-0 initial ts, do not compensate\n\t\t\telse if (tkw->ts_shift<tkw->tk_timescale/2) {\n\t\t\t\tmdur += tkw->ts_shift;\n\t\t\t}\n\n\t\t\tif (ctx->importer) {\n\t\t\t\ttkw->prog_done = mdur * ctx->dur.den;\n\t\t\t\ttkw->prog_total =  ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t}\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (gf_timestamp_greater(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (gf_timestamp_greater_or_equal(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((s32) tkw->nb_samples >= -ctx->dur.num)\n\t\t\t\tabort = GF_TRUE;\n\t\t}\n\n\t\tif (abort) {\n\t\t\tGF_FilterEvent evt;\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, tkw->ipid);\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\t\ttkw->aborted = GF_TRUE;\n\t\t}\n\t} else if (ctx->importer) {\n\t\tif (tkw->nb_frames) {\n\t\t\ttkw->prog_done = tkw->nb_samples + tkw->frame_offset;\n\t\t\ttkw->prog_total = tkw->nb_frames;\n\t\t} else {\n\t\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (data_offset == GF_FILTER_NO_BO) {\n\t\t\t\tdata_offset = tkw->down_bytes;\n\t\t\t}\n\t\t\tif ((data_offset != GF_FILTER_NO_BO) && tkw->down_size) {\n\t\t\t\ttkw->prog_done = data_offset;\n\t\t\t\ttkw->prog_total = tkw->down_size;\n\t\t\t} else {\n\t\t\t\tif (tkw->pid_dur.den && tkw->pid_dur.num) {\n\t\t\t\t\ttkw->prog_done = tkw->sample.DTS * tkw->pid_dur.den;\n\t\t\t\t\ttkw->prog_total = tkw->pid_dur.num * tkw->tk_timescale;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->prog_done = 0;\n\t\t\t\t\ttkw->prog_total = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_item(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 meta_type, item_id, size, item_type, nb_items, media_brand = GF_ISOM_BRAND_HEIF;\n\tGF_ImageItemProperties image_props;\n\tGF_ImageItemProtection cenc_info;\n\tconst char *data, *item_name=NULL;\n\tconst GF_PropertyValue *p, *dsi, *dsi_enh;\n\tGF_Box *config_box = NULL;\n\n\n\tif (ctx->init_movie_done) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item to a finalized movie, not supported\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (tkw->stream_type != GF_STREAM_VISUAL) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item other than visual, not supported - use MP4Box for this\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tctx->update_report = GF_TRUE;\n\n\tmeta_type = gf_isom_get_meta_type(ctx->file, GF_TRUE, 0);\n\tif (!meta_type) {\n\t\te = gf_isom_set_meta_type(ctx->file, GF_TRUE, 0, GF_META_ITEM_TYPE_PICT);\n\t} else if (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] File already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\te= GF_BAD_PARAM;\n\t} else {\n\t\te = GF_OK;\n\t}\n\tif (e) return e;\n\n\tdata = (char *)gf_filter_pck_get_data(pck, &size);\n\tif (!data) {\n\t\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add items from raw decoder outputs, not supported\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tctx->total_bytes_in += size;\n\tctx->total_samples++;\n\n\n\titem_id = 0;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ITEM_ID);\n\tif (p) item_id = p->value.uint;\n\n\titem_name = \"Image\";\n\tp = gf_filter_pid_get_property_str(tkw->ipid, \"meta:name\");\n\tif (p && p->value.string) item_name = p->value.string;\n\n\tmemset(&image_props, 0, sizeof(GF_ImageItemProperties));\n\n\tdsi = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG);\n\tdsi_enh = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tBool free_config_ba = GF_FALSE;\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AVC:\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tif (!dsi) return GF_OK;\n\n\t\tif (tkw->codecid==GF_CODECID_AVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t} else if (tkw->codecid==GF_CODECID_MVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t} else {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t}\n\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\timage_props.num_channels = 3;\n\t\timage_props.bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\timage_props.bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\timage_props.bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tmedia_brand = GF_ISOM_BRAND_AVCI;\n\t\tbreak;\n\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_HEVC_TILES:\n\tcase GF_CODECID_LHVC:\n\t\tif (tkw->codecid == GF_CODECID_LHVC) {\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t\tif (!dsi) return GF_OK;\n\t\t}\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\n\t\tif (dsi_enh) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_TRUE);\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t} else {\n\t\t\tif ((tkw->codecid == GF_CODECID_HEVC) && !dsi) return GF_OK;\n\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_FALSE);\n\t\t\titem_type = (tkw->codecid == GF_CODECID_HEVC_TILES) ? GF_ISOM_SUBTYPE_HVT1 : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\tif ((tkw->codecid != GF_CODECID_HEVC_TILES) && !dsi) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_HEIC;\n\t\tif (tkw->codecid==GF_CODECID_LHVC) {\n\t\t\tmedia_brand = GF_ISOM_BRAND_HEIM;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tif (!dsi) return GF_OK;\n\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\timage_props.num_channels = 1;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = 0;\n\t\t\timage_props.bits_per_channel[2] = 0;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = depth;\n\t\t\timage_props.bits_per_channel[2] = depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_AVIF;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\titem_type = GF_ISOM_SUBTYPE_JPEG;\n\t\tmedia_brand = GF_ISOM_SUBTYPE_JPEG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\titem_type = GF_ISOM_SUBTYPE_JP2K;\n\t\tmedia_brand = GF_4CC('j', '2', 'k', 'i');\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\titem_type = GF_ISOM_SUBTYPE_PNG;\n\t\t//not defined !\n\t\tmedia_brand = GF_ISOM_SUBTYPE_PNG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\n\tcase GF_CODECID_VVC:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\n\t\tif ((tkw->codecid == GF_CODECID_VVC) && !dsi) return GF_OK;\n\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_VVIC;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PIXFMT);\n\t\tif (p && (p->value.uint==GF_PIXEL_UNCV)) {\n\t\t\timage_props.config_ba = dsi->value.data.ptr;\n\t\t\timage_props.config_ba_size = dsi->value.data.size;\n\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (gf_pixel_fmt_get_uncc(p->value.uint, ctx->uncv-1, &image_props.config_ba, &image_props.config_ba_size)==GF_TRUE) {\n\t\t\t\tfree_config_ba = GF_TRUE;\n\t\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Codec %s not supported to create HEIF image items\\n\", gf_codecid_name(tkw->codecid) ));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_WIDTH);\n\tif (p) image_props.width = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HEIGHT);\n\tif (p) image_props.height = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\tif (p) image_props.alpha = p->value.boolean;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SAR);\n\tif (p) {\n\t\timage_props.hSpacing = p->value.frac.num;\n\t\timage_props.vSpacing = p->value.frac.den;\n\t} else {\n\t\timage_props.hSpacing = image_props.vSpacing = 1;\n\t}\n\timage_props.config = config_box;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HIDDEN);\n\tif (p) image_props.hidden = p->value.boolean;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MIRROR);\n\tif (p && p->value.uint) image_props.mirror = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ROTATE);\n\tif (p) image_props.angle = p->value.uint;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_W);\n\tif (p) { image_props.clap_wnum = p->value.frac.num; image_props.clap_wden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_H);\n\tif (p) { image_props.clap_hnum = p->value.frac.num; image_props.clap_hden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_X);\n\tif (p) { image_props.clap_honum = p->value.frac.num; image_props.clap_hoden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_Y);\n\tif (p) { image_props.clap_vonum = p->value.frac.num; image_props.clap_voden = p->value.frac.den; }\n\n\tp = gf_filter_pck_get_property_str(pck, \"grp_ilce\");\n\tif (p && ((p->type==GF_PROP_DATA)||(p->type==GF_PROP_CONST_DATA)) && p->value.data.ptr) {\n\t\timage_props.interlace_type = p->value.data.ptr[0];\n\t}\n\tif (tkw->codecid==GF_CODECID_HEVC_TILES) {\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CROP_POS);\n\t\tif (p) {\n\t\t\timage_props.hOffset = p->value.vec2i.x;\n\t\t\timage_props.vOffset = p->value.vec2i.y;\n\t\t}\n\t}\n\n\t//setup crypto\n\tif (tkw->is_encrypted && gf_filter_pck_get_crypt_flags(pck)) {\n\t\tmemset(&cenc_info, 0, sizeof(GF_ImageItemProtection));\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC SAI on protected packet\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.sai_data = p->value.data.ptr;\n\t\tcenc_info.sai_data_size = p->value.data.size;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme type on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_type = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme version on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (!p || (p->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(p->value.data.ptr, p->value.data.size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: %s CENC Key info on protected item\\n\", p ? \"Corrupted\" : \"Missing\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tcenc_info.key_info = p->value.data.ptr;\n\t\tcenc_info.key_info_size = p->value.data.size;\n\n\t\timage_props.cenc_info = &cenc_info;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\t\tif (p) {\n\t\t\tcenc_info.skip_byte_block = p->value.frac.num;\n\t\t\tcenc_info.crypt_byte_block = p->value.frac.den;\n\t\t}\n\n\n\t\tif (tkw->insert_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\t\t\ttkw->insert_pssh = GF_FALSE;\n\t\t}\n\t}\n\n\tnb_items = gf_isom_get_meta_item_count(ctx->file, GF_TRUE, 0);\n\n\te = gf_isom_add_meta_item_memory(ctx->file, GF_TRUE, 0, item_name, &item_id, item_type, NULL, NULL, &image_props, (u8 *)data, size, NULL);\n\n\tif (config_box) gf_isom_box_del(config_box);\n\tif (free_config_ba) gf_free(image_props.config_ba);\n\n\tif (e) return e;\n\n\n\t//retrieve the final itemID\n\tgf_isom_get_meta_item_info(ctx->file, GF_TRUE, 0, nb_items+1, &item_id, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\ttkw->item_id = item_id;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PRIMARY_ITEM);\n\tif (p && p->value.boolean) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\t//if primary item is not set, assign one\n\telse if (! gf_isom_get_meta_primary_item_id(ctx->file, GF_TRUE, 0)) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\n\tif (!ctx->major_brand_set) {\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\tctx->major_brand_set = 2;\n\t}\n\tif (media_brand && (ctx->major_brand_set==2)) {\n\t\tgf_isom_modify_alternate_brand(ctx->file, media_brand, 1);\n\t}\n\n\tif (tkw->codecid==GF_CODECID_HEVC_TILES) {\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:tbas\");\n\t\tif (p && (p->value.uint_list.nb_items==1)) {\n\t\t\tgf_isom_meta_add_item_ref(ctx->file, GF_TRUE, 0, item_id, p->value.uint_list.vals[0], GF_ISOM_REF_TBAS, NULL);\n\t\t}\n\t}\n\n#if 0\n\tif (e == GF_OK && meta->ref_type) {\n\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, meta->ref_item_id, meta->ref_type, NULL);\n\t}\n#endif\n\treturn GF_OK;\n}\n\nstatic void mp4mux_send_output(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->dst_pck) {\n\t\tif (ctx->notify_filename) {\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, GF_TRUE, GF_FALSE);\n\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->cur_file_idx_plus_one-1) );\n\t\t\tif (ctx->cur_file_suffix) {\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILESUF, &PROP_STRING_NO_COPY(ctx->cur_file_suffix) );\n\t\t\t\tctx->cur_file_suffix = NULL;\n\t\t\t}\n\t\t\tctx->notify_filename = 0;\n\t\t\tif (ctx->dash_seg_start.den)\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_MPD_SEGSTART, &PROP_FRAC64(ctx->dash_seg_start) );\n\t\t}\n\t\tgf_filter_pck_send(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t}\n}\n\nstatic void mp4_mux_flush_frag_hls(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\t//send event on first track only\n\ttkw = gf_list_get(ctx->tracks, 0);\n\tGF_FEVT_INIT(evt, GF_FEVT_FRAGMENT_SIZE, tkw->ipid);\n\tevt.frag_size.is_last = ctx->flush_seg ? GF_TRUE : GF_FALSE;\n\tevt.frag_size.offset = ctx->frag_offset;\n\tevt.frag_size.size = ctx->frag_size;\n\tevt.frag_size.duration.num = (s64) ctx->frag_duration;\n\tevt.frag_size.duration.den = ctx->frag_timescale;\n\tevt.frag_size.independent = ctx->frag_has_intra;\n\n\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\tctx->frag_offset += ctx->frag_size;\n\tctx->frag_size = 0;\n\tctx->frag_duration = 0;\n\tctx->frag_has_intra = GF_FALSE;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic);\n\nstatic void mp4_mux_flush_seg(GF_MP4MuxCtx *ctx, Bool is_init, u64 idx_start_range, u64 idx_end_range, Bool signal_flush)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\tif (ctx->dst_pck) {\n\t\tif (!ctx->single_file) {\n\t\t\tBool s, e;\n\t\t\tgf_filter_pck_get_framing(ctx->dst_pck, &s, &e);\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, s, GF_TRUE);\n\t\t\tif (!is_init) {\n\t\t\t\tu64 dur = ctx->next_seg_start - (ctx->min_cts_plus_one-1);\n\t\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) dur);\n\t\t\t}\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t\tctx->current_offset = 0;\n\t\t\tif (is_init && s)\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_INIT, &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\tif (is_init) {\n\t\t\tgf_filter_pck_set_dependency_flags(ctx->dst_pck, 0xFF);\n\t\t\tgf_filter_pck_set_carousel_version(ctx->dst_pck, 1);\n\t\t}\n\t\t//also inject m4cc after init seg - cf issue 2482\n\t\tif (is_init && ctx->eos_marker) {\n\t\t\tu8 data[8];\n\t\t\tmemset(data, 0, 8);\n\t\t\tdata[3] = 8;\n\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t}\n\t\tmp4mux_send_output(ctx);\n\t\tif (signal_flush)\n\t\t\tgf_filter_pid_send_flush(ctx->opid);\n\t}\n\tif (!is_init && ctx->llhls_mode && ctx->frag_size) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\tif (ctx->dash_mode) {\n\t\t//send event on first track only\n\t\ttkw = gf_list_get(ctx->tracks, 0);\n\t\tGF_FEVT_INIT(evt, GF_FEVT_SEGMENT_SIZE, tkw->ipid);\n\t\tevt.seg_size.seg_url = NULL;\n\t\tevt.seg_size.is_init = is_init ? 1 : 0;\n\t\tif (!is_init || !idx_end_range) {\n\t\t\tevt.seg_size.media_range_start = ctx->current_offset;\n\t\t\tevt.seg_size.media_range_end = ctx->current_offset + ctx->current_size - 1;\n\t\t}\n\t\tif (idx_end_range && (ctx->vodcache==MP4MX_VODCACHE_INSERT))\n\t\t\tevt.seg_size.is_shift = 1;\n\n\t\tevt.seg_size.idx_range_start = idx_start_range;\n\t\tevt.seg_size.idx_range_end = idx_end_range;\n\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\tctx->current_offset += ctx->current_size;\n\t\tctx->current_size = 0;\n\t\tctx->frag_offset = 0;\n\t\tctx->frag_size = 0;\n\t\tctx->frag_num = 0;\n\t\tctx->frag_has_intra = GF_FALSE;\n\t\t//changing file\n\t\tif (ctx->seg_name) {\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t}\n\t}\n}\n\nstatic void mp4mux_check_mpd_start_time(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_MPD_SEGSTART);\n\tif (p) {\n\t\tctx->dash_seg_start = p->value.lfrac;\n\t} else {\n\t\tctx->dash_seg_start.num = 0;\n\t\tctx->dash_seg_start.den = 0;\n\t}\n}\n\nstatic GF_Err mp4_mux_initialize_movie(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tTrackWriter *ref_tkw = NULL;\n\tu64 min_dts = 0;\n\tu32 min_dts_scale=0;\n\tu32 def_fake_dur=0;\n\tu32 def_fake_scale=0;\n#ifdef GF_ENABLE_CTRN\n\tu32 traf_inherit_base_id=0;\n#endif\n\tu32 nb_segments=0;\n\tGF_Fraction64 max_dur;\n\tctx->single_file = GF_TRUE;\n\tctx->current_offset = ctx->current_size = 0;\n\tmax_dur.den = 1;\n\tmax_dur.num = 0;\n\n\tif (ctx->sseg && ctx->noinit)\n\t\tctx->single_file = GF_FALSE;\n\n\tif (ctx->dur.num && ctx->dur.den) {\n\t\tmax_dur.num = ctx->dur.num;\n\t\tmax_dur.den = ctx->dur.den;\n\t}\n\n\t//make sure we have one sample from each PID. This will trigger potential pending reconfigure\n\t//for filters updating the PID caps before the first packet dispatch\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck;\n\t\tif (tkw->fake_track) continue;\n\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), continue setup\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->dash_mode && !ctx->cur_file_idx_plus_one) {\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t}\n\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\t\t}\n\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\tif (p && strlen(p->value.string)) ctx->single_file = GF_FALSE;\n\n\t\tdef_fake_dur = gf_filter_pck_get_duration(pck);\n\t\tdef_fake_scale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t\tif (gf_timestamp_less(max_dur.num, max_dur.den, tkw->pid_dur.num, tkw->pid_dur.den)) {\n\t\t\t\tmax_dur.num = tkw->pid_dur.num;\n\t\t\t\tmax_dur.den = tkw->pid_dur.den;\n\t\t\t}\n\t\t}\n#ifdef GF_ENABLE_CTRN\n\t\tif (tkw->codecid==GF_CODECID_HEVC)\n\t\t\ttraf_inherit_base_id = tkw->track_id;\n#endif\n\t}\n\t//good to go, finalize for fragments\n\tfor (i=0; i<count; i++) {\n\t\tu32 def_pck_dur;\n\t\tu32 def_samp_size=0;\n\t\tu8 def_is_rap;\n#ifdef GF_ENABLE_CTRN\n\t\tu32 inherit_traf_from_track = 0;\n#endif\n\t\tu64 dts;\n\t\tconst GF_PropertyValue *p;\n\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (tkw->fake_track) {\n\t\t\tif (def_fake_scale) {\n\t\t\t\tdef_pck_dur = def_fake_dur;\n\t\t\t\tdef_pck_dur *= tkw->src_timescale;\n\t\t\t\tdef_pck_dur /= def_fake_scale;\n\t\t\t} else {\n\t\t\t\tdef_pck_dur = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t//can be null if eos\n\t\t\tif (pck) {\n\t\t\t\tu32 tscale;\n\t\t\t\t//otherwise setup fragmentation, using first sample desc as default idx\n\t\t\t\t//first pck dur as default\n\t\t\t\tdef_pck_dur = gf_filter_pck_get_duration(pck);\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts == GF_FILTER_NO_TS)\n\t\t\t\t\tdts = gf_filter_pck_get_cts(pck);\n\t\t\t\ttscale = gf_filter_pck_get_timescale(pck);\n\n\t\t\t\tif (!min_dts || gf_timestamp_greater(min_dts, min_dts_scale, dts, tscale)) {\n\t\t\t\t\tmin_dts = dts;\n\t\t\t\t\tmin_dts_scale = tscale;\n\t\t\t\t}\n\t\t\t\tif (tkw->raw_audio_bytes_per_sample) {\n\t\t\t\t\tu32 pck_size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &pck_size);\n\t\t\t\t\tpck_size /= tkw->raw_audio_bytes_per_sample;\n\t\t\t\t\tif (pck_size)\n\t\t\t\t\t\tdef_pck_dur /= pck_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//check if we have a default constant duration set, if so use it\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONSTANT_DURATION);\n\t\t\t\tdef_pck_dur = p ? p->value.uint : 0;\n\t\t\t}\n\t\t\tif (tkw->raw_audio_bytes_per_sample)\n\t\t\t\tdef_samp_size = tkw->raw_audio_bytes_per_sample;\n\t\t}\n\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\tdef_pck_dur *= tkw->tk_timescale;\n\t\t\tdef_pck_dur /= tkw->src_timescale;\n\t\t}\n\n\t\t//and consider audio & text all RAPs, the rest not rap - this will need refinement later on\n\t\t//but won't break the generated files\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_AUDIO:\n\t\tcase GF_STREAM_TEXT:\n\t\t\tdef_is_rap = GF_ISOM_FRAG_DEF_IS_SYNC;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HAS_SYNC);\n\t\t\tif (p && p->value.boolean)\n\t\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tswitch (tkw->codecid) {\n\t\t\tcase GF_CODECID_PNG:\n\t\t\tcase GF_CODECID_JPEG:\n\t\t\tcase GF_CODECID_J2K:\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_HEVC_TILES:\n#ifdef GF_ENABLE_CTRN\n\t\t\t\tif (ctx->ctrn && ctx->ctrni)\n\t\t\t\t\tinherit_traf_from_track = traf_inherit_base_id;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!ref_tkw) ref_tkw = tkw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\t}\n\t\t//CMAF 7.5.17, if non-sync sample are present stss SHALL be present and empty...\n\t\tif (ctx->cmaf && !def_is_rap) {\n\t\t\tdef_is_rap |= GF_ISOM_FRAG_USE_SYNC_TABLE;\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\t//use 1 for the default sample description index. If no multi stsd, this is always the case\n\t\t//otherwise we need to update the stsd idx in the traf headers\n\t\te = gf_isom_setup_track_fragment(ctx->file, tkw->track_id, tkw->stsd_idx, def_pck_dur, def_samp_size, def_is_rap, 0, 0, ctx->nofragdef ? GF_TRUE : GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to setup fragmentation for track ID %d: %s\\n\", tkw->track_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->refrag) {\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t} else if (!ctx->nofragdef) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Refragmentation with default track fragment flags signaling but no TREX found in source track %d, using defaults computed from PID, result might be broken\\n\", tkw->track_id));\n\t\t\t}\n\t\t}\n#endif\n\n\n\t\tif (ctx->tfdt.den && ctx->tfdt.num) {\n\t\t\ttkw->tfdt_offset = gf_timestamp_rescale(ctx->tfdt.num, ctx->tfdt.den, tkw->tk_timescale);\n\t\t}\n\n\t\tif (tkw->fake_track) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ref_tkw==tkw) ref_tkw=NULL;\n\t\t\tmp4_mux_track_writer_del(tkw);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n#ifdef GF_ENABLE_CTRN\n\t\tif (inherit_traf_from_track)\n\t\t\tgf_isom_enable_traf_inherit(ctx->file, tkw->track_id, inherit_traf_from_track);\n#endif\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_SEGMENTS);\n\t\tif (p && (p->value.uint>nb_segments))\n\t\t\tnb_segments = p->value.uint;\n\n\t\tif (!ctx->dash_mode)\n\t\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t}\n\n\tif (max_dur.num && max_dur.den) {\n\t\tu64 mdur = max_dur.num;\n\t\tif (ctx->moovts != max_dur.den) {\n\t\t\tmdur *= (u32) ctx->moovts;\n\t\t\tmdur /= max_dur.den;\n\t\t}\n\t\tgf_isom_set_movie_duration(ctx->file, mdur, GF_FALSE);\n\t}\n\telse if (ctx->cmaf) {\n\t\t//CMAF 7.3.2.1.c.6) \"The MovieExtendsBox may contain a MovieExtendsHeaderBox,\n\t\t//as defined in ISO/IEC 14496-12, and if so, shall provide the overall duration\n\t\t//of the CMAF track. If the duration is unknown, this box shall be omitted.\"\n\t\tgf_isom_set_movie_duration(ctx->file, 0, GF_TRUE);\n\t}\n\n\t//if we have an explicit track reference for fragmenting, move it first in our list\n\tif (ref_tkw) {\n\t\tgf_list_del_item(ctx->tracks, ref_tkw);\n\t\tgf_list_insert(ctx->tracks, ref_tkw, 0);\n\t}\n\tctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\n\tif (!ctx->abs_offset) {\n\t\tu32 mval = ctx->dash_mode ? '6' : '5';\n\t\tu32 mbrand, mcount, found=0;\n\t\tu8 szB[GF_4CC_MSIZE];\n\t\tgf_isom_set_fragment_option(ctx->file, 0, GF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET, 1);\n\n\t\tgf_isom_get_brand_info(ctx->file, &mbrand, NULL, &mcount);\n\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\ti=0;\n\t\twhile (!found && (i<mcount)) {\n\t\t\ti++;\n\t\t\tgf_isom_get_alternate_brand(ctx->file, i, &mbrand);\n\t\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\t}\n\n\t\t/*because of movie fragments MOOF based offset, ISOM <4 is forbidden*/\n\t\tif (!found) {\n\t\t\tgf_isom_set_brand_info(ctx->file, ctx->dash_mode ? GF_ISOM_BRAND_ISO6 : GF_ISOM_BRAND_ISO5, 1);\n\t\t}\n\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP41, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP42, GF_FALSE);\n\t}\n\n\tif (ctx->dash_mode) {\n\t\t/*DASH self-init media segment*/\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DSMS, GF_TRUE);\n\t\t} else {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DASH, GF_TRUE);\n\t\t}\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MSIX, ((ctx->dash_mode==MP4MX_DASH_VOD) && (ctx->subs_sidx>=0)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\te = gf_isom_finalize_for_fragment(ctx->file, ctx->dash_mode ? 1 : 0, ctx->mvex);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to finalize moov for fragmentation: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tctx->init_movie_done = GF_TRUE;\n\n\tif (min_dts_scale) {\n\t\tu64 rs_dts = gf_timestamp_rescale(min_dts, min_dts_scale, ctx->cdur.den);\n\t\tctx->next_frag_start = rs_dts;\n\t}\n\tctx->next_frag_start += ctx->cdur.num;\n\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->noinit) {\n\t\tif (ctx->dst_pck) gf_filter_pck_discard(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t\tctx->current_size = ctx->current_offset = 0;\n\t\tctx->first_pck_sent = GF_FALSE;\n\t} else {\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, 0, 0, GF_TRUE);\n\t}\n\tassert(!ctx->dst_pck);\n\n\t//change major brand for segments\n\tif (ctx->styp && (strlen(ctx->styp)>=4)) {\n\t\tu32 styp_brand = GF_4CC(ctx->styp[0], ctx->styp[1], ctx->styp[2], ctx->styp[3]);\n\t\tu32 version = 0;\n\t\tchar *sep = strchr(ctx->styp, '.');\n\t\tif (sep) version = atoi(sep+1);\n\t\tgf_isom_set_brand_info(ctx->file, styp_brand, version);\n\t}\n\n\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\tif ((ctx->vodcache==MP4MX_VODCACHE_REPLACE) && !nb_segments && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Media duration unknown, cannot use replace mode of vodcache, using temp file for VoD storage\\n\"));\n\t\t\tctx->vodcache = MP4MX_VODCACHE_ON;\n\t\t\te = mp4mx_setup_dash_vod(ctx, NULL);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\tGF_BitStream *bs;\n\t\t\tu8 *output;\n\t\t\tchar *msg;\n\t\t\tGF_FilterPacket *pck;\n\t\t\tu32 len;\n\t\t\tBool exact_sidx = GF_TRUE;\n\n\t\t\tif (!nb_segments) {\n\t\t\t\texact_sidx = GF_FALSE;\n\t\t\t\tnb_segments = (u32) ( ctx->media_dur * ctx->dash_dur.den / ctx->dash_dur.num);\n\t\t\t\t//always add an extra segment\n\t\t\t\tnb_segments ++;\n\t\t\t\t//and safety alloc of 10%\n\t\t\t\tif (nb_segments>10)\n\t\t\t\t\tnb_segments += 10*nb_segments/100;\n\t\t\t\telse\n\t\t\t\t\tnb_segments ++;\n\t\t\t}\n\n\t\t\t//max sidx size: full box + sidx fields + timing 64 bit + nb segs (each 12 bytes)\n\t\t\tctx->sidx_max_size = 12 + (12 + 16) + 12 * nb_segments;\n\n\t\t\t//we produce an ssix, add full box + nb subsegs + nb_segments * (range_count=2 + 2*(range+size))\n\t\t\tif (ctx->ssix) {\n\t\t\t\tctx->sidx_max_size += 12 + 4 + nb_segments * 12;\n\t\t\t}\n\n\t\t\tif (!exact_sidx) {\n\t\t\t\t//and a free box\n\t\t\t\tctx->sidx_max_size += 8;\n\t\t\t\tctx->sidx_size_exact = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tctx->sidx_size_exact = GF_TRUE;\n\t\t\t}\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t\t//send a dummy packet\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\t//format as free box for now\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, ctx->sidx_max_size);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\tmsg = \"GPAC \" GPAC_VERSION\" SIDX placeholder\";\n\t\t\tlen = (u32) strlen(msg);\n\t\t\tif (len+8>ctx->sidx_max_size) len = ctx->sidx_max_size - 8;\n\t\t\tgf_bs_write_data(bs, msg, len );\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\n\t\t\tctx->current_offset += ctx->sidx_max_size;\n\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_ON) {\n\t\t\tctx->store_output = GF_TRUE;\n\t\t} else {\n\t\t\tctx->store_output = GF_FALSE;\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t}\n\t\tgf_isom_allocate_sidx(ctx->file, ctx->subs_sidx, ctx->chain_sidx, 0, NULL, NULL, NULL, ctx->ssix);\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nstatic GF_Err mp4_mux_start_fragment(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tBool has_tfdt=GF_FALSE;\n\tGF_ISOStartFragmentFlags flags=0;\n\n\t//setup some default\n\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\tctx->msn += ctx->msninc;\n\tctx->min_cts_plus_one = 0;\n\n\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\n\te = gf_isom_start_fragment(ctx->file, flags);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tif (pck) {\n\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_MOOF_TEMPLATE);\n\t\tif (p && p->value.data.ptr) {\n\t\t\tGF_SegmentIndexBox *out_sidx = NULL;\n\t\t\tgf_isom_set_fragment_template(ctx->file, p->value.data.ptr, p->value.data.size, &has_tfdt, &out_sidx);\n\t\t\tif (out_sidx) {\n\t\t\t\tif (ctx->cloned_sidx) gf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = out_sidx;\n\t\t\t\tctx->cloned_sidx_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//setup some default\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\te = GF_OK;\n\t\tif (ctx->strun) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 0);\n\t\t}\n\t\t//fragment at sap boundaries for video, but not in dash mode (compatibility with old arch)\n\t\telse if (ctx->fsap && (tkw->stream_type == GF_STREAM_VISUAL) && !ctx->dash_mode) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 1);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable set fragment options: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\ttkw->fragment_done = GF_FALSE;\n\t\ttkw->insert_tfdt = (has_tfdt || ctx->tfdt_traf || tkw->tfdt_offset) ? GF_TRUE : ctx->insert_tfdt;\n\t\ttkw->dur_in_frag = 0;\n\n\t\tif (ctx->trun_inter) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, 0);\n\t\t}\n\t\tif (ctx->truns_first) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUNS_FIRST, 1);\n\t\t}\n\n\t\tif (ctx->trunv1 ||\n\t\t\t//7.7 cmf2 For video CMAF Tracks not contained in Track Files, Version 1 shall be used.\n\t\t\t((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL))\n\t\t) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUN_V1, 1);\n\t\t}\n\t\tif (ctx->sdtp_traf)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\n\t\tif (ctx->tfdt64)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_LARGE_TFDT, ctx->tfdt64);\n\n\t\tif (tkw->dyn_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 2);\n\t\t}\n\t\telse if (ctx->insert_pssh)\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 1);\n\t}\n\tctx->fragment_started = GF_TRUE;\n\tctx->insert_tfdt = GF_FALSE;\n\tctx->insert_pssh = GF_FALSE;\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tu32 nb_read, blocksize = ctx->block_size;\n\tif (ctx->flush_done + blocksize>ctx->flush_size) {\n\t\tblocksize = (u32) (ctx->flush_size - ctx->flush_done);\n\t}\n\tif (!blocksize) return GF_EOS;\n\tpck = gf_filter_pck_new_alloc(ctx->opid, blocksize, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tnb_read = (u32) gf_fread(output, blocksize, ctx->tmp_store);\n\tif (nb_read != blocksize) {\n\t\tchar tmp[1];\n\t\t//weird behavior on some file systems, dump debug info\n\t\tgf_fread(tmp, 1, ctx->tmp_store);\n\t\tBool is_eof = gf_feof(ctx->tmp_store);\n\t\tGF_LOG(is_eof ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error reading from VOD temp cache, read %d bytes but asked %d bytes\\n\\tCache EOF %d - cache size \"LLU\" - read pos \"LLU\" - file pos \"LLU\"\\n\", nb_read, blocksize, is_eof, ctx->flush_size, ctx->flush_done, gf_ftell(ctx->tmp_store)));\n\t}\n\tctx->flush_done += nb_read;\n\tif (ctx->flush_done==ctx->flush_size) {\n\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\t\tgf_filter_pck_send(pck);\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_send(pck);\n\t//we are not done flushing but we have no more input packets, signal we still need processing\n\tgf_filter_ask_rt_reschedule(ctx->filter, 1);\n\treturn GF_OK;\n}\n\nstatic void mp4mx_frag_box_patch(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\t//no box patched set (todo, do we want to allow changing boxpatch props ?)\n\t\tif (!tkw->box_patched) continue;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\tif (p && p->value.string) {\n\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_TRUE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track fragment %d: %s\\n\",\n\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->boxpatch) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_TRUE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to fragment: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n}\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter);\n\nGF_Err mp4mx_reload_output(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\n\t//done with the file\n\tif (ctx->file) {\n\t\te = mp4_mux_done(ctx, GF_FALSE);\n\t\tif (e) return e;\n\t\tctx->file = NULL;\n\t}\n\tctx->init_movie_done = GF_FALSE;\n\te = mp4_mux_initialize(ctx->filter);\n\tif (e) return e;\n\tctx->config_timing = GF_TRUE;\n\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\ttkw->suspended = GF_FALSE;\n\t\ttkw->track_num = 0;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->max_cts = 0;\n\t\ttkw->min_cts = (u64) -1;\n\t\te = mp4_mux_configure_pid(ctx->filter, tkw->ipid, GF_FALSE);\n\t\tif (e) return e;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->sample.DTS = 0;\n\t\ttkw->sample.CTS_Offset = 0;\n\t\ttkw->samples_in_stsd = 0;\n\t\ttkw->samples_in_frag = 0;\n\t}\n\tassert(ctx->next_file_idx);\n\tctx->cur_file_idx_plus_one = ctx->next_file_idx;\n\tctx->next_file_idx = 0;\n\tctx->notify_filename = GF_TRUE;\n\tassert(!ctx->cur_file_suffix);\n\tif (ctx->next_file_suffix) {\n\t\tctx->cur_file_suffix = gf_strdup(ctx->next_file_suffix);\n\t\tctx->next_file_suffix = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_fragmented(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e = GF_OK;\n\tu32 nb_eos, nb_done, nb_suspended, i, count;\n\n\tif (ctx->flush_size) {\n\t\treturn mp4_mux_flush_fragmented(ctx);\n\t}\n\n\tif (!ctx->file)\n\t\treturn GF_EOS;\n\n\t//init movie not yet produced\n\tif (!ctx->init_movie_done) {\n\t\te = mp4_mux_initialize_movie(ctx);\n\t\tif (e) return e;\n\t\tif (!ctx->init_movie_done)\n\t\t\treturn GF_OK;\n\t}\n\t/*get count after init, some tracks may have been remove*/\n\tcount = gf_list_count(ctx->tracks);\n\n\t//process pid by pid\n\tnb_eos=0;\n\tnb_done = 0;\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu64 cts, dts, ncts;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (ctx->fragment_started && tkw->fragment_done) {\n\t\t\tnb_done ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tkw->suspended) {\n\t\t\tif (ctx->fragment_started) nb_done++;\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tu32 orig_frag_bounds=0;\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\t\tif (!pck) {\n\t\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\t\tif (ctx->next_file_idx)\n\t\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (!gf_filter_pid_is_flush_eos(tkw->ipid))\n\t\t\t\t\t\tnb_eos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tnb_eos++;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//we create dash segment only when we know we have a packet, not before this loop.\n\t\t\t//This allows taking into account flush signals, otherwise we would create empty segments\n\t\t\tif (ctx->dash_mode && !ctx->segment_started) {\n\t\t\t\tctx->segment_started = GF_TRUE;\n\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\tswitch (ctx->psshs) {\n\t\t\t\tcase MP4MX_PSSH_MOOF:\n\t\t\t\tcase MP4MX_PSSH_BOTH:\n\t\t\t\t\tctx->insert_pssh = GF_TRUE; break;\n\t\t\t\tdefault:\n\t\t\t\t\tctx->insert_pssh = GF_FALSE; break;\n\t\t\t\t}\n\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t}\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\n\t\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_EODS);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\ttkw->next_seg_cts = tkw->cts_next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MuxIsom] Packet with no CTS assigned, cannot store to track, ignoring\\n\"));\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\tif (p) {\n\t\t\t\torig_frag_bounds = p->value.uint;\n\n\t\t\t\tif (orig_frag_bounds==2) {\n\t\t\t\t\tif (!ctx->segment_started) {\n\t\t\t\t\t\tctx->dash_mode = 1;\n\t\t\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t\t\t} else if (tkw->samples_in_frag) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//get dash/file segment number\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\n\t\t\t//not dash and file end, we need to wait for all streams and resetup\n\t\t\tif (!ctx->dash_mode && p) {\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!ctx->fragment_started) {\n\t\t\t\te = mp4_mux_start_fragment(ctx, orig_frag_bounds ? pck : NULL);\n\t\t\t\tif (e) return e;\n\n\t\t\t\t//push emsgonce the segment is started\n\t\t\t\tconst GF_PropertyValue *emsg = gf_filter_pck_get_property_str(pck, \"grp_EMSG\");\n\t\t\t\tif (emsg && (emsg->type==GF_PROP_DATA) && emsg->value.data.ptr) {\n\t\t\t\t\tGF_Err gf_isom_set_emsg(GF_ISOFile *movie, u8 *data, u32 size);\n\n\t\t\t\t\tgf_isom_set_emsg(ctx->file, emsg->value.data.ptr, emsg->value.data.size);\n\t\t\t\t}\n\n\t\t\t\tctx->nb_frags++;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->nb_frags_in_seg++;\n\n\t\t\t}\n\n\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tif (p) {\n\t\t\t\t\tmp4mux_check_mpd_start_time(ctx, pck);\n\t\t\t\t\t//start of next segment, abort fragmentation for this track and flush all other writers\n\t\t\t\t\tif (ctx->dash_seg_num_plus_one && (ctx->dash_seg_num_plus_one != 1 + p->value.uint) ) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//start of current segment, remember segment number and name\n\t\t\t\t\tctx->dash_seg_num_plus_one = 1 + p->value.uint;\n\t\t\t\t\t//get file name prop if any - only send on one pid for muxed content\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\t\t\t\t\t\tctx->seg_name = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\t//store PRFT only for reference track at segment start\n\t\t\t\t\tif (tkw==ctx->ref_tkw) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SENDER_NTP);\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tgf_isom_set_fragment_reference_time(ctx->file, tkw->track_id, p->value.longuint, cts);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[MuxIsom] Segment %s, storing NTP TS \"LLU\" for CTS \"LLU\" at \"LLU\" us, at UTC \"LLU\"\\n\", ctx->seg_name ? ctx->seg_name : \"singlefile\", p->value.longuint, cts, gf_sys_clock_high_res(), gf_net_get_utc()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\t\t\t\tif (tkw->first_dts_in_seg_plus_one && (tkw->first_dts_in_seg_plus_one - 1 > dts))\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + dts;\n\t\t\t}\n\t\t\tncts = cts + gf_filter_pck_get_duration(pck);\n\t\t\tif (tkw->cts_next < ncts)\n\t\t\t\ttkw->cts_next = ncts;\n\n\t\t\t//compute ts after delay/skip for fragment interleaving\n\t\t\tu64 check_ts;\n\t\t\tif ((tkw->ts_delay<0) && (cts < -tkw->ts_delay))\n\t\t\t\tcheck_ts = 0;\n\t\t\telse\n\t\t\t\tcheck_ts = cts+tkw->ts_delay;\n\n\t\t\t//we have samples and either a request to flush fragment or a emsg, start new fragment\n\t\t\tif (tkw->samples_in_frag && (orig_frag_bounds || (gf_filter_pck_get_property_str(pck, \"grp_EMSG\")!=NULL))) {\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (ctx->fragdur && (!ctx->dash_mode || !tkw->fragment_done) ) {\n\t\t\t\tBool frag_done = GF_FALSE;\n\t\t\t\tu32 dur = gf_filter_pck_get_duration(pck);\n\t\t\t\tif (tkw->dur_in_frag && gf_timestamp_greater_or_equal(tkw->dur_in_frag, tkw->src_timescale, ctx->cdur.num, ctx->cdur.den)) {\n\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t} else if ((ctx->store==MP4MX_MODE_SFRAG)\n\t\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t\t) {\n\t\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t\tif ((sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (frag_done) {\n\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkw->dur_in_frag += dur;\n\t\t\t\tif (ctx->llhls_mode && (ctx->frag_duration * tkw->src_timescale <= tkw->dur_in_frag * ctx->frag_timescale)) {\n\t\t\t\t\tctx->frag_duration = tkw->dur_in_frag;\n\t\t\t\t\tctx->frag_timescale = tkw->src_timescale;\n\t\t\t\t}\n\t\t\t} else if (!ctx->flush_seg && !ctx->dash_mode\n\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t ) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t//consider roll SAP as sap1 for the fragmentation\n\t\t\t\tif ((sap==GF_FILTER_SAP_4) && (tkw->stream_type==GF_STREAM_AUDIO))\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\n\t\t\t\tif ((ctx->store==MP4MX_MODE_FRAG) || (sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->store>=MP4MX_MODE_FRAG) && tkw->samples_in_frag) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr && !ctx->flush_seg && !ctx->dash_mode) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tkw->insert_tfdt) {\n\t\t\t\tu64 odts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (odts==GF_FILTER_NO_TS)\n\t\t\t\t\todts = gf_filter_pck_get_cts(pck);\n\n\t\t\t\tif (tkw->tfdt_offset) {\n\t\t\t\t\t//first sample, set offset dts such that first sample dts - offset_dts = target time\n\t\t\t\t\tif (tkw->nb_samples==0) {\n\t\t\t\t\t\tu64 target = tkw->tfdt_offset;\n\t\t\t\t\t\ttkw->tfdt_offset = odts - target;\n\n\t\t\t\t\t}\n\t\t\t\t\todts = odts - tkw->tfdt_offset;\n\t\t\t\t}\n\n\t\t\t\ttkw->insert_tfdt = GF_FALSE;\n\t\t\t\tif (tkw->patch_tfdt)\n\t\t\t\t\t//if patch_tfdt is true, tkw->ts_delay is always >0\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts + tkw->ts_delay);\n\t\t\t\telse\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts);\n\n\t\t\t\tif (!tkw->first_dts_in_seg_plus_one)\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + (u64) odts;\n\t\t\t}\n\n\t\t\tif (ctx->trun_inter) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\ts32 tid_group = 0;\n\t\t\t\tif (sap) {\n\t\t\t\t\ttkw->prev_tid_group = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dts_diff;\n\t\t\t\t\ts64 p_dts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\ts64 p_cts = gf_filter_pck_get_cts(pck);\n\t\t\t\t\ts64 cts_o = p_cts - p_dts;\n\t\t\t\t\tdts_diff = p_dts - tkw->sample.DTS;\n\t\t\t\t\ttid_group = (s32) (cts_o / dts_diff);\n\t\t\t\t\ttid_group = 20 - tid_group;\n\t\t\t\t\tif (tid_group != tkw->prev_tid_group) {\n\t\t\t\t\t\ttkw->prev_tid_group = tid_group;\n\t\t\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, tid_group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//process packet\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_TRUE);\n\n\t\t\t//discard\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\n\t\t\tcts = gf_timestamp_rescale(cts, tkw->src_timescale, 1000);\n\t\t\tif (!ctx->min_cts_plus_one) ctx->min_cts_plus_one = cts + 1;\n\t\t\telse if (ctx->min_cts_plus_one-1 > cts) ctx->min_cts_plus_one = cts + 1;\n\n\t\t\tif (e) return e;\n\t\t}\n\t\t//done with this track - if single track per moof, request new fragment but don't touch the\n\t\t//fragmentation state of the track writers\n\t\tif (ctx->straf && (i+1 < count)) {\n\t\t\tGF_ISOStartFragmentFlags flags = 0;\n\t\t\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\t\t\te = gf_isom_start_fragment(ctx->file, flags);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\t\t\tctx->msn++;\n\t\t\tif (ctx->sdtp_traf)\n\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\t\t}\n\t}\n\n\t//all suspended tracks done, flush fragment\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tnb_done = count;\n\t}\n\n\n\tif (nb_done==count) {\n\t\t//nothing open (this happens when flushing segments/fragments)\n\t\tif (!ctx->segment_started && !ctx->fragment_started)\n\t\t\tgoto check_eos;\n\n\t\tBool is_eos = (count == nb_eos) ? GF_TRUE : GF_FALSE;\n\t\tu32 ref_timescale;\n\t\tBool flush_refs = ctx->dash_mode ? GF_FALSE : GF_TRUE;\n\t\tu64 next_ref_ts = ctx->ref_tkw->next_seg_cts;\n\t\tif (is_eos)\n\t\t\tnext_ref_ts = ctx->ref_tkw->cts_next;\n\n\t\tref_timescale = ctx->ref_tkw->src_timescale;\n\t\t//both in ms\n\t\tctx->next_seg_start = (u64) gf_timestamp_rescale(next_ref_ts, ref_timescale, 1000);\n\t\tctx->min_cts_next_frag = (u64) gf_timestamp_rescale(ctx->next_frag_start, ctx->cdur.den, 1000);\n\n\t\tctx->next_frag_start += ctx->cdur.num;\n\t\twhile (ctx->next_frag_start <= ctx->adjusted_next_frag_start) {\n\t\t\tctx->next_frag_start += ctx->cdur.num;\n\t\t}\n\t\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\n\t\tmp4mx_frag_box_patch(ctx);\n\n\t\t//end of DASH segment\n\t\tif (ctx->dash_mode && (ctx->flush_seg || is_eos) ) {\n\t\t\tu64 offset = ctx->single_file ? ctx->current_offset : 0;\n\t\t\tu64 idx_start_range, idx_end_range, segment_size_in_bytes;\n\t\t\ts32 subs_sidx = -1;\n\t\t\tu32 track_ref_id = 0;\n\n\t\t\tidx_start_range = idx_end_range = 0;\n\t\t\tif (ctx->subs_sidx>=0) {\n\t\t\t\tsubs_sidx = ctx->subs_sidx;\n\t\t\t\ttrack_ref_id = ctx->ref_tkw->track_id;\n\t\t\t}\n\t\t\tif (ctx->cloned_sidx && (ctx->subs_sidx!=-2) ) {\n\t\t\t\tsubs_sidx = (s32) ctx->cloned_sidx->nb_refs;\n\t\t\t\ttrack_ref_id = ctx->cloned_sidx->reference_ID;\n\t\t\t\tgf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_close_segment(ctx->file, subs_sidx, track_ref_id, ctx->ref_tkw->first_dts_in_seg_plus_one ? ctx->ref_tkw->first_dts_in_seg_plus_one-1 : 0,\n\t\t\t\tctx->ref_tkw->negctts_shift ? 0 : ctx->ref_tkw->ts_delay,\n\t\t\t\tnext_ref_ts, ctx->chain_sidx, ctx->ssix, ctx->sseg ? GF_FALSE : is_eos, GF_FALSE, ctx->eos_marker, &idx_start_range, &idx_end_range, &segment_size_in_bytes);\n\t\t\tctx->ref_tkw->first_dts_in_seg_plus_one = 0;\n\t\t\tif (e) return e;\n\t\t\tflush_refs = GF_TRUE;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing segment %d - estimated next fragment times start %g end %g\\n\", ctx->dash_seg_num_plus_one - 1, ((Double)next_ref_ts)/ref_timescale, ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\tif (ctx->dash_mode != MP4MX_DASH_VOD) {\n\t\t\t\t//we need to wait for packet to be written\n\t\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\t\tctx->flush_idx_start_range = offset + idx_start_range;\n\t\t\t\t\tctx->flush_idx_end_range = idx_end_range ? offset + idx_end_range : 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, offset + idx_start_range, idx_end_range ? offset + idx_end_range : 0, !is_eos);\n\t\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tif (ctx->nb_seg_sizes == ctx->alloc_seg_sizes) {\n\t\t\t\t\t ctx->alloc_seg_sizes *= 2;\n\t\t\t\t\t if (!ctx->alloc_seg_sizes) ctx->alloc_seg_sizes = 10;\n\t\t\t\t\t ctx->seg_sizes = gf_realloc(ctx->seg_sizes, sizeof(u32) * ctx->alloc_seg_sizes);\n\t\t\t\t}\n\t\t\t\tassert(segment_size_in_bytes);\n\t\t\t\tctx->seg_sizes[ctx->nb_seg_sizes] = (u32) segment_size_in_bytes;\n\t\t\t\tctx->nb_seg_sizes++;\n\t\t\t}\n\t\t\t//we still need to send seg size info for for HLS !\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT)\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t}\n\t\t//cannot flush in DASH mode if using sidx (vod single sidx or live 1 sidx/seg)\n\t\telse if (!ctx->dash_mode || ((ctx->subs_sidx<0) && (ctx->dash_mode<MP4MX_DASH_VOD) && !ctx->cloned_sidx) ) {\n\t\t\tgf_isom_flush_fragments(ctx->file, GF_FALSE);\n\t\t\tflush_refs = GF_TRUE;\n\t\t\t//if not in dash and EOS marker is set, inject marker after each fragment\n\t\t\tif (!ctx->dash_mode && ctx->eos_marker && ctx->fragment_started) {\n\t\t\t\tu8 data[8];\n\t\t\t\tmemset(data, 0, 8);\n\t\t\t\tdata[3] = 8;\n\t\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing fragment - next fragment start time %g\\n\", ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\t//we need to wait for packet to be written\n\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\tif (ctx->llhls_mode) ctx->flush_ll_hls = GF_TRUE;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tif (ctx->llhls_mode) {\n\t\t\t\tmp4_mux_flush_frag_hls(ctx);\n\t\t\t}\n\n\t\t\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t\t}\n\t\t}\n\t\tctx->fragment_started = GF_FALSE;\n\n\t\tif (ctx->flush_seg) {\n\t\t\tctx->segment_started = GF_FALSE;\n\t\t\tctx->flush_seg = GF_FALSE;\n\t\t\tctx->dash_seg_num_plus_one = 0;\n\t\t\tctx->nb_segs++;\n\t\t\tctx->nb_frags_in_seg=0;\n\t\t}\n\t\t//destroy any pending refs\n\t\tif (flush_refs) {\n\t\t\twhile (gf_list_count(ctx->ref_pcks)) {\n\t\t\t\tGF_FilterPacket *pckr = gf_list_pop_back(ctx->ref_pcks);\n\t\t\t\tgf_filter_pck_unref(pckr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tctx->nb_segs=0;\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\ncheck_eos:\n\tif (count == nb_eos) {\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tif (ctx->vodcache!=MP4MX_VODCACHE_ON) {\n\t\t\t\tctx->final_sidx_flush = GF_TRUE;\n\t\t\t\t//flush SIDX in given space - this will reserve 8 bytes for free box if not fitting\n\t\t\t\tgf_isom_flush_sidx(ctx->file, ctx->sidx_max_size, (ctx->sidx_size_exact || ctx->tfdt64) ? GF_TRUE : GF_FALSE);\n\t\t\t} else {\n\t\t\t\tu64 start_offset;\n\t\t\t\t//reenable packet dispatch\n\t\t\t\tctx->store_output = GF_FALSE;\n\t\t\t\tgf_isom_flush_sidx(ctx->file, 0, ctx->tfdt64);\n\t\t\t\t//flush sidx packet\n\t\t\t\tmp4mux_send_output(ctx);\n\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->current_offset, ctx->current_offset + ctx->current_size - 1, GF_FALSE);\n\n\t\t\t\tgf_fflush(ctx->tmp_store);\n\t\t\t\tctx->flush_size = gf_ftell(ctx->tmp_store);\n\t\t\t\tctx->flush_done = 0;\n\t\t\t\tgf_fseek(ctx->tmp_store, 0, SEEK_SET);\n\n\t\t\t\tif (ctx->seg_sizes) {\n\t\t\t\t\tstart_offset = ctx->current_offset;\n\t\t\t\t\tfor (i=0; i<ctx->nb_seg_sizes; i++) {\n\t\t\t\t\t\tctx->current_size = ctx->seg_sizes[i];\n\t\t\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\tctx->current_offset = start_offset;\n\t\t\t\t\tctx->current_size = 0;\n\n\t\t\t\t\tgf_free(ctx->seg_sizes);\n\t\t\t\t\tctx->seg_sizes = NULL;\n\t\t\t\t\tctx->alloc_seg_sizes = ctx->nb_seg_sizes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//only destroy file if not dash or not onDemand, otherwise (regular dash) the file will be needed to append further segments\n\t\tif (ctx->dash_mode!=MP4MX_DASH_ON) {\n\t\t\t//only delete file in vod mode\n\t\t\tif (ctx->file) {\n\t\t\t\tgf_isom_close(ctx->file);\n\t\t\t\tctx->file = NULL;\n\t\t\t}\n\t\t}\n\n\t\tmp4mux_send_output(ctx);\n\n\t\tif (!ctx->flush_size) gf_filter_pid_set_eos(ctx->opid);\n\n\t\treturn ctx->flush_size ? GF_OK : GF_EOS;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nstruct _service_info\n{\n\tu32 service_id;\n\tu64 first_ts_min;\n\tu32 nb_non_sparse, nb_non_sparse_ready;\n\tu32 nb_sparse, nb_sparse_ready;\n};\nstatic struct _service_info *get_service_info(GF_List *services, TrackWriter *tkw)\n{\n\tstruct _service_info *si;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SERVICE_ID);\n\tu32 ID, i, count=gf_list_count(services);\n\tID = p ? p->value.uint : 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsi = gf_list_get(services, i);\n\t\tif (si->service_id == ID) return si;\n\t}\n\tGF_SAFEALLOC(si, struct _service_info)\n\tsi->service_id = ID;\n\tsi->first_ts_min = (u64) -1;\n\tgf_list_add(services, si);\n\treturn si;\n}\nstatic void del_service_info(GF_List *services)\n{\n\twhile (gf_list_count(services)) {\n\t\tstruct _service_info *si = gf_list_pop_back(services);\n\t\tgf_free(si);\n\t}\n\tgf_list_del(services);\n}\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust)\n{\n\t//compute offsets\n\ts64 dts_diff = ctx->tsalign ? gf_timestamp_rescale(min_ts_service, 1000000, tkw->src_timescale) : 0;\n\n\tif (!skip_adjust) {\n\t\tdts_diff = (s64) tkw->ts_shift - dts_diff;\n\t}\n\tif (ctx->is_rewind) dts_diff = -dts_diff;\n\t//negative could happen due to rounding, ignore them\n\tif (dts_diff <= (gf_sys_old_arch_compat() ? 0 : 1)) return;\n\n\t// dts_diff > 0, we need to delay the track\n\tu64 dur = gf_timestamp_rescale(dts_diff, tkw->src_timescale, ctx->moovts);\n\tif (dur) {\n\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, dts_diff, GF_ISOM_EDIT_EMPTY);\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\ttkw->empty_init_dur = (u64) dur;\n\t}\n}\n\nstatic void mp4_mux_config_timing(GF_MP4MuxCtx *ctx)\n{\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign) {\n\t\tctx->config_timing = GF_FALSE;\n\t\treturn;\n\t}\n\tGF_List *services = gf_list_new();\n\tu32 i, count;\n\tBool not_ready, blocking_refs, has_ready;\n\nretry_all:\n\tcount = gf_list_count(ctx->tracks);\n\tnot_ready = GF_FALSE;\n\tblocking_refs = GF_FALSE;\n\thas_ready = GF_FALSE;\n\n\tfor (i=0; i<gf_list_count(services);i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tsi->nb_non_sparse = si->nb_non_sparse_ready = 0;\n\t\tsi->nb_sparse = si->nb_sparse_ready = 0;\n\t}\n\n\t//compute min dts of first packet on each track - this assume all tracks are synchronized, might need adjustment for MPEG4 Systems\n\tfor (i=0; i<count; i++) {\n\t\tu64 ts, dts_min;\n\t\tGF_FilterPacket *pck;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (tkw->fake_track) continue;\n\t\t//get associated service\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\n\t\t//already setup (happens when new PIDs are declared after a packet has already been written on other PIDs)\n\t\tif (tkw->nb_samples) {\n\t\t\tdts_min = gf_timestamp_rescale(tkw->ts_shift, tkw->src_timescale, 1000000);\n\n\t\t\tif (si->first_ts_min > dts_min) {\n\t\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nretry_pck:\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t//check this after fetching a packet since it may reconfigure the track\n\t\tif (!tkw->track_num) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID has no input packet and configuration not known after 10 retries, aborting initial timing sync\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnot_ready = GF_TRUE;\n\t\t\ttkw->ts_shift = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pck) {\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck))\n\t\t\t\tblocking_refs = GF_TRUE;\n\t\t\tif (tkw->wait_sap) {\n\t\t\t\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\t\t\t\tBool seek = gf_filter_pck_get_seek_flag(pck);\n\t\t\t\tif (seek || !sap) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->wait_sap = GF_FALSE;\n\n\t\t\t\t\tif (!ctx->wait_dts_plus_one) {\n\t\t\t\t\t\tctx->wait_dts_plus_one = 1 + gf_filter_pck_get_dts(pck);\n\t\t\t\t\t\tctx->wait_dts_timescale = tkw->src_timescale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ctx->wait_dts_plus_one) {\n\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts=0;\n\n\t\t\t\tif (gf_timestamp_less(ts, tkw->src_timescale, (ctx->wait_dts_plus_one-1), ctx->wait_dts_timescale)) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), setup cenc\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\t\t\tmp4_mux_cenc_update(ctx, tkw, NULL, CENC_CONFIG, 0, 0);\n\n\t\t\t\tif (!tkw->nb_samples) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tsi->nb_non_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsi->nb_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttkw->ts_shift = 0;\n\t\t\ttkw->si_min_ts_plus_one = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t//we may have reorder tracks after the get_packet, redo\n\t\tif (gf_list_find(ctx->tracks, tkw) != i) {\n\t\t\tgoto retry_all;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts=0;\n\n\t\tdts_min = gf_timestamp_rescale(ts, tkw->src_timescale, 1000000);\n\n\t\tif (si->first_ts_min > dts_min) {\n\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\thas_ready = GF_TRUE;\n\t\t}\n\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse_ready++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse_ready++;\n\t\t\tbreak;\n\t\t}\n\n\t\ttkw->ts_shift = ts;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t}\n\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\t//if some non-sparse streams are not ready, try to wait\n\t\tif (si->nb_non_sparse) {\n\t\t\tif (si->nb_non_sparse > si->nb_non_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t\t//otherwise (only sparse stream), wait until first\n\t\telse if (si->nb_sparse) {\n\t\t\tif (!si->nb_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t}\n\n\tif (not_ready) {\n\t\tif (blocking_refs && has_ready) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Blocking input packets present, aborting initial timing sync\\n\"));\n\t\t}\n\t\t//this may be quite long until we have a packet in case input pid is video encoding \n\t\telse if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No input packets present on one or more inputs for more than 10s, aborting initial timing sync\\n\"));\n\t\t} else {\n\t\t\tctx->config_retry_start = gf_sys_clock();\n\t\t\tdel_service_info(services);\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->config_retry_start = 0;\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tif (si->first_ts_min==(u64)-1)\n\t\t\tsi->first_ts_min = 0;\n\t}\n\n\t//for all packets with dts greater than min dts, we need to add a pause\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\t\tif (tkw->si_min_ts_plus_one) {\n\t\t\ttkw->si_min_ts_plus_one = si->first_ts_min + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//if single text track don't reset back to 0\n\t\tmp4_mux_update_init_edit(ctx, tkw, si->first_ts_min, ((count==1) && (tkw->stream_type == GF_STREAM_TEXT)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tctx->config_timing = GF_FALSE;\n\tdel_service_info(services);\n}\n\nvoid mp4_mux_format_report(GF_MP4MuxCtx *ctx, u64 done, u64 total)\n{\n\tBool status_changed=GF_FALSE;\n\tu32 total_pc = 0;\n\tchar *status = NULL, szTmp[2048], szTK[20];\n\tif (!gf_filter_reporting_enabled(ctx->filter))\n\t\treturn;\n\tif (!ctx->update_report)\n\t\treturn;\n\n\tctx->update_report = GF_FALSE;\n\n\tif (ctx->config_timing) {\n\t\tgf_dynstrcat(&status, \"waiting for clock init\", NULL);\n\t\tstatus_changed = GF_TRUE;\n\t} else if (total) {\n\t\tif (done>=total) {\n\t\t\tDouble ohead = 0;\n\t\t\tif (ctx->total_bytes_in) ohead =  ((Double) (ctx->total_bytes_out - ctx->total_bytes_in)*100 / ctx->total_bytes_in);\n\n\t\t\tsprintf(szTmp, \"done %d samples - bytes \"LLU\" in \"LLU\" out - overhead %02.02f%% (%02.02g B/sample)\", ctx->total_samples, ctx->total_bytes_in, ctx->total_bytes_out, ohead, ((Double)(ctx->total_bytes_out-ctx->total_bytes_in))/ctx->total_samples);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t\ttotal_pc = 10000;\n\n\t\t} else {\n\t\t\tu32 pc = (u32) ((done*10000)/total);\n\t\t\tif (ctx->last_mux_pc == pc + 1) return;\n\t\t\tctx->last_mux_pc = pc + 1;\n\t\t\tsprintf(szTmp, \"mux %d%%\", pc);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t} else {\n\t\tu32 i, count = gf_list_count(ctx->tracks);\n\t\tBool is_frag = GF_FALSE;\n\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tDouble next = ((Double)ctx->next_frag_start)/ctx->cdur.den;\n\t\t\tis_frag = GF_TRUE;\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tsprintf(szTmp, \"mux segments %d (frags %d) next %02.3f\", ctx->nb_segs, ctx->nb_frags_in_seg, next);\n\t\t\t} else {\n\t\t\t\tsprintf(szTmp, \"mux frags %d next %02.3f\", ctx->nb_frags, next);\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(szTmp, \"%s\", ((ctx->store==MP4MX_MODE_FLAT) || (ctx->store==MP4MX_MODE_FASTSTART)) ? \"mux\" : \"import\");\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 pc=0;\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->aborted) {\n\t\t\t\tpc=10000;\n\t\t\t} else if (ctx->dur.num) {\n\t\t\t\tif (ctx->dur.num>0) {\n\t\t\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\t\t\tu64 tk_done = mdur * ctx->dur.den;\n\t\t\t\t\tu64 tk_total = ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t\t\tpc = (u32) ((tk_done*10000)/tk_total);\n\t\t\t\t} else {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset) ) / (-ctx->dur.num) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tkw->nb_frames) {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset)) / tkw->nb_frames);\n\t\t\t\t} else {\n\t\t\t\t\tif (tkw->pid_dur.num && tkw->pid_dur.den) {\n\t\t\t\t\t\tpc = (u32) ((tkw->sample.DTS*10000 * tkw->pid_dur.den) / (tkw->pid_dur.num * tkw->tk_timescale));\n\t\t\t\t\t} else if (tkw->down_bytes && tkw->down_size) {\n\t\t\t\t\t\tpc = (u32) (((tkw->down_bytes*10000) / tkw->down_size));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pc>10000)\n\t\t\t\tpc=0;\n\t\t\tif (tkw->last_import_pc != pc + 1) {\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\ttkw->last_import_pc = pc + 1;\n\t\t\t}\n\t\t\tif (!total_pc || (total_pc > pc))\n\t\t\t\ttotal_pc = pc;\n\n\t\t\tif (is_frag) {\n\t\t\t\tsprintf(szTK, \" TK%d(%c): %d\", tkw->track_id, tkw->status_type, tkw->samples_in_frag);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\tif (pc) {\n\t\t\t\t\tsprintf(szTK, \" %d %%\", pc/100);\n\t\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsprintf(szTK, \" %s%d(%c): %d %%\", tkw->is_item ? \"IT\" : \"TK\", tkw->track_id, tkw->status_type, pc/100);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (status_changed) {\n\t\tgf_filter_update_status(ctx->filter, total_pc, status);\n\t}\n\tif (status) gf_free(status);\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx);\n\nGF_Err mp4_mux_process(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tu32 nb_skip, nb_eos, nb_suspended, i, count = gf_list_count(ctx->tracks);\n\tnb_skip = 0;\n\tnb_eos = 0;\n\n\tif (ctx->config_timing) {\n\t\tmp4_mux_config_timing(ctx);\n\t\tif (ctx->config_timing) {\n\t\t\tmp4_mux_format_report(ctx, 0, 0);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//fragmented mode\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tu32 done=0;\n\t\t//postpone until no pending connections, otherwise we will create init segment without all tracks\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tif (ctx->seg_flush_state==1) return GF_OK;\n\t\telse if (ctx->seg_flush_state==2)\n\t\t\tmp4_mux_flush_seg_events(ctx);\n\n\t\tGF_Err e = mp4_mux_process_fragmented(ctx);\n\t\tif (e==GF_EOS) done=100;\n\t\tmp4_mux_format_report(ctx, done, done);\n\t\treturn e;\n\t}\n\n\t//regular mode\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\tif (tkw->suspended) {\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid) && !gf_filter_pid_is_flush_eos(tkw->ipid)) {\n\t\t\t\ttkw->suspended = GF_FALSE;\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tnb_skip++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tkw->aborted) {\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\tnb_eos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->owns_mov) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tmp4mux_check_mpd_start_time(ctx, pck);\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//basic regulation in case we do on-the-fly interleaving\n\t\t//we need to regulate because sources do not produce packets at the same rate\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tu64 cts = gf_filter_pck_get_cts(pck);\n\t\t\tif (ctx->is_rewind)\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\telse\n\t\t\t\tcts -= tkw->ts_shift;\n\n\t\t\tif (!ctx->faststart_ts_regulate.num) {\n\t\t\t\tctx->faststart_ts_regulate = ctx->cdur;\n\t\t\t}\n\t\t\t//ahead of our interleaving window, don't write yet\n\t\t\telse if (gf_timestamp_greater(cts, tkw->src_timescale, ctx->faststart_ts_regulate.num, ctx->faststart_ts_regulate.den)) {\n\t\t\t\tnb_skip++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\n\t\tif (tkw->is_item) {\n\t\t\te = mp4_mux_process_item(ctx, tkw, pck);\n\t\t} else {\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_FALSE);\n\t\t}\n\n\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\tif (tkw->aborted) {\n\t\t\tnb_eos++;\n\t\t}\n\t\tif (e) return e;\n\t}\n\tmp4_mux_format_report(ctx, 0, 0);\n\n\tif (nb_suspended && (nb_suspended+nb_eos==count)) {\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\n\tif (count == nb_eos) {\n\t\tif (ctx->file) {\n\t\t\tGF_Err e = mp4_mux_done(ctx, GF_TRUE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_EOS;\n\t}\n\t//done with this interleaving window, start next one\n\telse if (nb_skip + nb_eos >= count) {\n\t\tctx->faststart_ts_regulate.num += ctx->cdur.num;\n\t} else if (ctx->importer) {\n\t\tu64 prog_done=0, prog_total=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tprog_done += tkw->prog_done;\n\t\t\tprog_total += tkw->prog_total;\n\t\t}\n\t\tgf_set_progress(\"Import\", prog_done, prog_total);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_on_data_patch(void *cbk, u8 *data, u32 block_size, u64 file_offset, Bool is_insert)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (is_insert)\n\t\tgf_filter_pck_set_interlaced(pck, 1);\n\tgf_filter_pck_set_byte_offset(pck, file_offset);\n\tgf_filter_pck_send(pck);\n\treturn GF_OK;\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->flush_ll_hls) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\n\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\tmp4_mux_flush_seg(ctx, GF_FALSE, ctx->flush_idx_start_range, ctx->flush_idx_end_range, GF_FALSE);\n\t}\n\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->flush_seg) {\n\t\tctx->segment_started = GF_FALSE;\n\t\tctx->flush_seg = GF_FALSE;\n\t\tctx->dash_seg_num_plus_one = 0;\n\t\tctx->nb_segs++;\n\t\tctx->nb_frags_in_seg=0;\n\t}\n\tctx->seg_flush_state = 0;\n\tctx->flush_idx_start_range = 0;\n\tctx->flush_idx_end_range = 0;\n\tctx->flush_ll_hls = GF_FALSE;\n}\n\nstatic void mp4_mux_on_packet_destruct(GF_Filter *filter, GF_FilterPid *PID, GF_FilterPacket *pck)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\t//no need to lock filter here, only this callback modifies the state\n\tctx->seg_flush_state = 2;\n\tgf_filter_post_process_task(filter);\n}\n\nstatic void mp4_mux_on_last_block_start(void *cbk)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tif (ctx->force_seg_sync)\n\t\tctx->seg_flush_state = 1;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\tu32 src_pck_dur=0;\n\n\tctx->total_bytes_out += block_size;\n\n\t//flush pending packet in frag mode\n\tmp4mux_send_output(ctx);\n\n\tif (ctx->final_sidx_flush) {\n\t\tGF_FilterPacket *pck;\n\t\tu32 free_size=0;\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tmemcpy(output, data, block_size);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tgf_filter_pck_set_interlaced(pck, 1);\n\t\t\tgf_filter_pck_send(pck);\n\t\t} else {\n\t\t\tGF_BitStream *bs;\n\t\t\tassert(!ctx->dst_pck);\n\n\t\t\tif (block_size > ctx->sidx_max_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Final SIDX chunk larger than preallocated block, will not flush SIDX (output file still readable). Try disabling nocache mode\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tfree_size = ctx->sidx_max_size - block_size;\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tif (free_size) {\n\t\t\t\tgf_bs_write_u32(bs, free_size);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\t\tgf_bs_skip_bytes(bs, free_size-8);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, data, block_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->sidx_chunk_offset+free_size, ctx->sidx_chunk_offset+free_size + block_size - 1, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (ctx->store_output) {\n\t\tu32 nb_write = (u32) gf_fwrite(data, block_size, ctx->tmp_store);\n\t\tif (nb_write != block_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error writing to temp cache: %d bytes write instead of %d\\n\", nb_write, block_size));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tGF_FilterPacket *srcp = (GF_FilterPacket *)cbk_data;\n\tif (srcp && gf_list_find(ctx->ref_pcks, srcp)<0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Data callback on non-existing packet reference !\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\n\tif (srcp) {\n\t\tif (ctx->seg_flush_state) {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref_destructor(ctx->opid, cbk_magic, block_size, srcp, mp4_mux_on_packet_destruct);\n\t\t} else {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref(ctx->opid, cbk_magic, block_size, srcp);\n\t\t}\n\t\tgf_list_del_item(ctx->ref_pcks, srcp);\n\t\tsrc_pck_dur = (u32) gf_timestamp_rescale(gf_filter_pck_get_duration(srcp), gf_filter_pck_get_timescale(srcp), 1000);\n\t\tgf_filter_pck_unref(srcp);\n\t}\n\t//allocate new one\n\telse if (ctx->seg_flush_state) {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc_destructor(ctx->opid, block_size, &output, mp4_mux_on_packet_destruct);\n\t} else {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t}\n\tif (!ctx->dst_pck) return GF_OUT_OF_MEM;\n\n\tif (!cbk_data)\n\t\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(ctx->dst_pck, !ctx->first_pck_sent, GF_FALSE);\n\n\t//set packet prop as string since we may discard the seg_name  packet before this packet is processed\n\tif (!ctx->first_pck_sent && ctx->seg_name) {\n\t\tctx->current_offset = 0;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENAME, &PROP_STRING(ctx->seg_name) );\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->dash_seg_num_plus_one-1) );\n\t\tif (ctx->dash_seg_start.den)\n\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_MPD_SEGSTART, &PROP_FRAC64(ctx->dash_seg_start) );\n\t}\n\n\tif (ctx->min_cts_plus_one) {\n\t\tu64 orig = ctx->min_cts_plus_one-1;\n\t\tgf_filter_pck_set_cts(ctx->dst_pck, orig);\n\t\t//if we have a source packet duration, use it\n\t\tif (src_pck_dur)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, src_pck_dur);\n\t\t//it may happen that we don't know precisely the min_cts_next_frag, this is a rough compute based on desire frag dur\n\t\t//if duration is wrong, signal to send asap (dur = 1)\n\t\telse if (ctx->min_cts_next_frag > orig)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) (ctx->min_cts_next_frag - orig) );\n\t\telse\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, 1);\n\t}\n\n\tif ((ctx->llhls_mode>1) && ctx->fragment_started && !ctx->frag_size && ctx->dst_pck) {\n\t\tctx->frag_num++;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_HLS_FRAG_NUM, &PROP_UINT(ctx->frag_num));\n\t}\n\tctx->frag_size += block_size;\n\n\tctx->first_pck_sent = GF_TRUE;\n\tctx->current_size += block_size;\n\t//non-frag mode, send right away\n\tif ((ctx->store<MP4MX_MODE_FRAG) || ctx->seg_flush_state) {\n\t\tmp4mux_send_output(ctx);\n\t}\n\treturn GF_OK;\n}\n\nvoid mp4_mux_progress_cbk(void *udta, u64 done, u64 total)\n{\n\tGF_Filter *filter = (GF_Filter *)udta;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->update_report = GF_TRUE;\n\tmp4_mux_format_report(ctx, done, total);\n}\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tgf_filter_set_max_extra_input_pids(filter, -1);\n\tctx->filter = filter;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented mode, disabled in build\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n#endif\n\tif (ctx->file) {\n\t\tif (gf_isom_get_mode(ctx->file) < GF_ISOM_OPEN_WRITE) return GF_BAD_PARAM;\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented output on already opened ISOBMF file\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->owns_mov = GF_FALSE;\n\t\tgf_filter_act_as_sink(filter);\n\t} else {\n\t\tu32 open_mode = GF_ISOM_OPEN_WRITE;\n\t\tctx->owns_mov = GF_TRUE;\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\topen_mode = GF_ISOM_WRITE_EDIT;\n\t\t\tbreak;\n\t\t}\n\t\tctx->file = gf_isom_open(\"_gpac_isobmff_redirect\", open_mode, NULL);\n\t\tif (!ctx->file) return GF_OUT_OF_MEM;\n\n\t\tgf_isom_set_write_callback(ctx->file, mp4_mux_on_data, mp4_mux_on_data_patch, mp4_mux_on_last_block_start, ctx, ctx->block_size);\n\n\t\tgf_isom_set_progress_callback(ctx->file, mp4_mux_progress_cbk, filter);\n\n\t\tif (ctx->dref && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use data reference in movie fragments, not supported. Ignoring it\\n\"));\n\t\t\tctx->dref = GF_FALSE;\n\t\t}\n\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tgf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t}\n\t}\n\n\tif (!ctx->moovts)\n\t\tctx->moovts=600;\n\n\tif ((ctx->store==MP4MX_MODE_FASTSTART) && (!ctx->cdur.num || !ctx->cdur.den)) {\n\t\tctx->cdur.num = 1;\n\t\tctx->cdur.den = 1;\n\t}\n\tif (!ctx->cdur.den) {\n\t\tctx->cdur.num = 0;\n\t\tctx->cdur.den = 1000;\n\t}\n\t//we need at least ms precision for sfrag mode\n\tif (ctx->cdur.den < 1000) {\n\t\tctx->cdur.num = (s32) ( ((s64)ctx->cdur.num) * 1000 / ctx->cdur.den);\n\t\tctx->cdur.den = 1000;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->mfra && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\tGF_Err e = gf_isom_enable_mfra(ctx->file);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!ctx->tracks)\n\t\tctx->tracks = gf_list_new();\n\n\tif (!ctx->ref_pcks)\n\t\tctx->ref_pcks = gf_list_new();\n\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrni)\n\t\tctx->ctrn = GF_TRUE;\n#endif\n\n\tif (ctx->m4cc) {\n\t\tif (strlen(ctx->m4cc)==4)\n\t\t\tctx->eos_marker = GF_4CC(ctx->m4cc[0], ctx->m4cc[1], ctx->m4cc[2], ctx->m4cc[3]);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid segment marker 4cc %s, ignoring\\n\", ctx->m4cc));\n\t\t}\n\t}\n\tif (ctx->compress) {\n\t\tu32 flags = 0;\n\t\tif (ctx->fcomp) flags |= GF_ISOM_COMP_FORCE_ALL;\n\t\tif (ctx->otyp) flags |= GF_ISOM_COMP_WRAP_FTYPE;\n\t\tgf_isom_enable_compression(ctx->file, ctx->compress, flags);\n\t}\n\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign)\n\t\tctx->insert_tfdt = GF_TRUE;\n\n\tif (ctx->cmaf) {\n\t\t//cf table 3, 4, 5 of CMAF\n\t\tctx->mvex = GF_TRUE;\n\t\tctx->truns_first = GF_TRUE;\n\t\t//single trun, single traf (table 5 of CMAF)\n\t\tctx->strun = GF_TRUE;\n\t\tctx->straf = GF_TRUE;\n\t\t//7.5.16 Every TrackFragmentBox shall contain a TrackFragmentBaseMediaDecodeTimeBox\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\t//7.3.3 : If SegmentIndexBoxes exist, each subsegment referenced in the SegmentIndexBox shall be a single CMAF fragment\n\t\tctx->chain_sidx = GF_FALSE;\n\t\tif (ctx->subs_sidx>0)\n\t\t\tctx->subs_sidx = 0;\n\n\t\tif (ctx->cmaf==MP4MX_CMAF_CMF2) {\n\t\t\t/*7.7 cmf2\n- default_sample_flags, sample_flags and first_sample_flags shall be set in the TrackFragmentHeaderBox and/or TrackRunBox to provide sample dependency information within each CMAF chunk and CMAF fragment.\n- Default values or per sample values of sample duration and sample size shall be stored in each CMAF chunk\u2019s TrackRunBox and/or TrackFragmentHeaderBox\n\t\t\t*/\n\t\t\tctx->nofragdef = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void mp4_mux_update_edit_list_for_bframes(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u32 ctts_mode)\n{\n\tu64 max_cts, min_cts;\n\ts64 moffset;\n\n\tif (ctts_mode > MP4MX_CT_EDIT) return;\n\n\t//if we have a complex edit list (due to track template), don't override\n\tif (gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) return;\n\n\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\tmax_cts = tkw->max_cts - tkw->min_neg_ctts;\n\tmin_cts = tkw->min_cts - tkw->min_neg_ctts;\n\n\tif (min_cts || tkw->empty_init_dur) {\n\t\tmax_cts -= min_cts;\n\t\tu32 count = gf_isom_get_sample_count(ctx->file, tkw->track_num);\n\t\tmax_cts += gf_isom_get_sample_duration(ctx->file, tkw->track_num, count);\n\n\t\tmax_cts = gf_timestamp_rescale(max_cts, tkw->tk_timescale, ctx->moovts);\n\n\t\tif (tkw->empty_init_dur) {\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t}\n\t\t//old arch compat: if we had a simple edit list in source try to keep the original segduration indicated\n\t\t//we tolerate a diff of 100ms\n\t\telse if (gf_sys_old_arch_compat() && tkw->imported_edit_sdur && (tkw->imported_edit_offset==min_cts)) {\n\t\t\ts32 diff;\n\t\t\tu64 old_dur_ms = gf_timestamp_rescale(tkw->imported_edit_sdur, tkw->src_timescale, 1000);\n\t\t\tu64 new_dur_ms = gf_timestamp_rescale(max_cts, tkw->tk_timescale, 1000);\n\t\t\tdiff = (s32) new_dur_ms - (s32) old_dur_ms;\n\t\t\tif (ABS(diff)<100)\n\t\t\t\tmax_cts = tkw->imported_edit_sdur;\n\t\t}\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, max_cts, min_cts, GF_ISOM_EDIT_NORMAL);\n\t}\n}\n\n//todo: move from media_import.c to here once done\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 avc_base_track, hevc_base_track, ref_track_id;\n\tavc_base_track = hevc_base_track = 0;\n\tu32 i;\n\tu32 min_lid = 0;\n\tGF_PropertyEntry *pe=NULL;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:oinf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t}\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:linf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t\tgf_isom_set_track_group(ctx->file, tkw->track_num, 1000+gf_isom_get_track_id(ctx->file, tkw->track_num), GF_ISOM_BOX_TYPE_CSTG, GF_TRUE);\n\t}\n\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:min_lid\", &pe);\n\tif (p) min_lid = p->value.uint;\n\n\tgf_filter_release_property(pe);\n\n\tif (!min_lid && (tkw->codecid!=GF_CODECID_LHVC)) {\n\t\treturn;\n\t}\n\t//set linf\n\tfor (i=0; i < gf_isom_get_track_count(ctx->file); i++) {\n\t\tu32 subtype = gf_isom_get_media_subtype(ctx->file, i+1, 1);\n\t\tswitch (subtype) {\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tif (!avc_base_track) {\n\t\t\t\tavc_base_track = i+1;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one AVC bitstream found, use track %d as base layer\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (!hevc_base_track) {\n\t\t\t\thevc_base_track = i+1;\n\t\t\t\tif (avc_base_track) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: Found both AVC and HEVC tracks, using HEVC track %d as base layer\\n\", hevc_base_track));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one HEVC bitstream found, use track %d as base layer\\n\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hevc_base_track && !avc_base_track) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Using LHVC external base layer, but no base layer not found - NOT SETTING SBAS TRACK REFERENCE!\\n\"));\n\t} else {\n\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track ? hevc_base_track : avc_base_track);\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE, ref_track_id);\n\n\t\tif (hevc_base_track) {\n\t\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track);\n\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF, ref_track_id);\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\t}\n\t}\n}\n\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, count;\n\tGF_PropertyEntry *pe=NULL;\n\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tu32 ctts_mode = ctx->ctmode;\n\t\tconst GF_PropertyValue *p;\n\t\tBool has_bframes = GF_FALSE;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) ctts_mode = MP4MX_CT_NEGCTTS;\n\n\t\tif (tkw->min_neg_ctts<0) {\n\t\t\t//use ctts v1 negative offsets\n\t\t\tif (ctts_mode==MP4MX_CT_NEGCTTS) {\n\t\t\t\tgf_isom_set_ctts_v1(ctx->file, tkw->track_num, (u32) -tkw->min_neg_ctts);\n\t\t\t}\n\t\t\t//ctts v0\n\t\t\telse {\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t\tgf_isom_shift_cts_offset(ctx->file, tkw->track_num, (s32) tkw->min_neg_ctts);\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\n\t\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\t\t\t}\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->has_ctts && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->ts_delay || tkw->empty_init_dur) {\n\t\t\tgf_isom_update_edit_list_duration(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tif (tkw->min_ts_seek_plus_one) {\n\t\t\tu64 min_ts = tkw->min_ts_seek_plus_one - 1;\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu32 delay = 0;\n\t\t\tif (tkw->clamp_ts_plus_one) {\n\t\t\t\tmdur = tkw->max_cts - tkw->min_cts;\n\t\t\t\tmdur += tkw->max_cts_samp_dur;\n\t\t\t}\n\t\t\tif (mdur > min_ts)\n\t\t\t\tmdur -= min_ts;\n\t\t\telse\n\t\t\t\tmdur = 0;\n\n\t\t\tif ((ctts_mode != MP4MX_CT_NEGCTTS) && (tkw->ts_delay<0) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\tdelay = (u32) -tkw->ts_delay;\n\t\t\t}\n\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tmin_ts = gf_timestamp_rescale(min_ts, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t\tdelay = (u32) gf_timestamp_rescale(delay, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tmdur += delay;\n\n\t\t\tif (ctx->moovts != tkw->tk_timescale) {\n\t\t\t\tmdur = gf_timestamp_rescale(mdur, tkw->tk_timescale, ctx->moovts);\n\t\t\t}\n\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\tif (tkw->empty_init_dur)\n\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, mdur, min_ts, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\n\t\tif (tkw->force_ctts) {\n\t\t\tGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track);\n\t\t\tgf_isom_force_ctts(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t\t\n\t\tif (ctx->importer && ctx->dur.num && ctx->dur.den) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num);\n\t\t\tif (pdur==mdur) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - media duration %g - track duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale, ((Double)pdur)/ctx->moovts ));\n\t\t\t}\n\t\t}\n\n\t\t/*this is plain ugly but since some encoders (divx) don't use the video PL correctly\n\t\t we force the system video_pl to ASP@L5 since we have I, P, B in base layer*/\n\t\tif (tkw->codecid == GF_CODECID_MPEG4_PART2) {\n\t\t\tBool force_rewrite = GF_FALSE;\n\t\t\tu32 PL = tkw->media_profile_level;\n\t\t\tif (!PL) PL = 0x01;\n\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Indicated Profile: %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t}\n\n\t\t\tif (has_bframes && (tkw->media_profile_level <= 3)) {\n\t\t\t\tPL = 0xF5;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Indicated profile doesn't include B-VOPs - forcing %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t\tforce_rewrite = GF_TRUE;\n\t\t\t}\n\t\t\tif (PL != tkw->media_profile_level) {\n\t\t\t\tif (force_rewrite) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_ESD *esd = gf_isom_get_esd(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tassert(esd);\n\t\t\t\t\tgf_m4v_rewrite_pl(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, (u8) PL);\n\t\t\t\t\tgf_isom_change_mpeg4_description(ctx->file, tkw->track_num, tkw->stsd_idx, esd);\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n#endif\n\n\t\t\t\t}\n\t\t\t\tif (!ctx->make_qt)\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, PL);\n\t\t\t}\n\t\t}\n\n\n\t\tif (tkw->has_append)\n\t\t\tgf_isom_refresh_size_info(ctx->file, tkw->track_num);\n\n\t\tif ((tkw->nb_samples == 1) && (ctx->dur.num>0) && ctx->dur.den) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, tkw->tk_timescale);\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, dur);\n\t\t}\n\n\t\tif (tkw->has_open_gop) {\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"OpenGOP detected - adjusting file brand\\n\"));\n\t\t\t}\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:rem_last\", &pe);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_remove_sample(ctx->file, tkw->track_num, tkw->nb_samples);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:last_dur\", &pe);\n\t\tif (p) {\n\t\t\tu64 val = p->value.uint;\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tval = gf_timestamp_rescale(val, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, (u32) val);\n\t\t}\n\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_FORCED_SUB, &pe);\n\t\tif (p) {\n\t\t\tgf_isom_set_forced_text(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint);\n\t\t}\n\n\t\tif (tkw->is_nalu && ctx->pack_nal && (gf_isom_get_mode(ctx->file)!=GF_ISOM_OPEN_WRITE)) {\n\t\t\tu32 msize = 0;\n\t\t\tBool do_rewrite = GF_FALSE;\n\t\t\tu32 j, stsd_count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_MAX_NALU_SIZE, &pe);\n\t\t\tmsize = gf_get_bit_size(p->value.uint);\n\t\t\tif (msize<8) msize = 8;\n\t\t\telse if (msize<16) msize = 16;\n\t\t\telse msize = 32;\n\n\t\t\tif (msize<=0xFFFF) {\n\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\tu32 k = 8 * gf_isom_get_nalu_length_field(ctx->file, tkw->track_num, j+1);\n\t\t\t\t\tif (k > msize) {\n\t\t\t\t\t\tdo_rewrite = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_rewrite) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Adjusting NALU SizeLength to %d bits\\n\", msize ));\n\t\t\t\t\tgf_media_nal_rewrite_samples(ctx->file, tkw->track_num, msize);\n\t\t\t\t\tmsize /= 8;\n\t\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\t\tgf_isom_set_nalu_length_field(ctx->file, tkw->track_num, j+1, msize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//don't update bitrate info for single sample tracks, unless MPEG-4 Systems - compatibility with old arch\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update && ((tkw->nb_samples>1) || ctx->m4sys) )\n\t\t\tgf_media_update_bitrate(ctx->file, tkw->track_num);\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\t}\n\n\tgf_filter_release_property(pe);\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\n\tif (ctx->owns_mov) {\n\t\tif (ctx->moovpad)\n\t\t\tgf_isom_set_inplace_padding(ctx->file, ctx->moovpad);\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\t\tif (ctx->cdur.num==0) {\n\t\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_STREAMABLE);\n\t\t\t} else {\n\t\t\t\tif (ctx->cdur.num < 0) ctx->cdur.num = 1000;\n\t\t\t\te = gf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FLAT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FLAT);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_TIGHT);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set storage mode: %s\\n\", gf_error_to_string(e) ));\n\t\t\tgf_isom_delete(ctx->file);\n\t\t} else {\n\t\t\te = gf_isom_close(ctx->file);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to write file: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tctx->file = NULL;\n\t\tif (is_final)\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t} else {\n\t\tctx->file = NULL;\n\t}\n\treturn e;\n}\n\nstatic void mp4_mux_finalize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->owns_mov && (ctx->file || (ctx->store>=MP4MX_MODE_FRAG))) {\n\t\tif (ctx->store < MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Session aborted before writing to file, use fragmented storage mode to record session\\n\"));\n\t\t}\n\t\tgf_isom_delete(ctx->file);\n\t}\n\n\twhile (gf_list_count(ctx->tracks)) {\n\t\tTrackWriter *tkw = gf_list_pop_back(ctx->tracks);\n\t\tmp4_mux_track_writer_del(tkw);\n\t}\n\tgf_list_del(ctx->tracks);\n\t//in case we aborted, release refs\n\twhile (gf_list_count(ctx->ref_pcks)) {\n\t\tGF_FilterPacket *pckr = gf_list_pop_back(ctx->ref_pcks);\n\t\tgf_filter_pck_unref(pckr);\n\t}\n\tgf_list_del(ctx->ref_pcks);\n\tif (ctx->bs_r) gf_bs_del(ctx->bs_r);\n\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\tif (ctx->tmp_store) gf_fclose(ctx->tmp_store);\n\tif (ctx->seg_sizes) gf_free(ctx->seg_sizes);\n\n\tif (ctx->cur_file_suffix) gf_free(ctx->cur_file_suffix);\n\n}\n\nstatic const GF_FilterCapability MP4MuxCaps[] =\n{\n\t//for now don't accept files as input, although we could store them as items, to refine\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\t//we want framed media only\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t//and any codecid\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_FILE_EXT, ISOM_FILE_EXT),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_MIME, ISOM_FILE_MIME),\n\t{0},\n\t//for scene / OD / text, we don't want raw codecid (filters modifying a scene graph we don't expose)\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MP4MuxCtx, _n)\nstatic const GF_FilterArgs MP4MuxArgs[] =\n{\n\t{ OFFS(m4sys), \"force MPEG-4 Systems signaling of tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dref), \"only reference data from source file - not compatible with all media sources\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctmode), \"set composition offset mode for video tracks\\n\"\n\t\"- edit: uses edit lists to shift first frame to presentation time 0\\n\"\n\t\"- noedit: ignore edit lists and does not shift timeline\\n\"\n\t\"- negctts: uses ctts v1 with possibly negative offsets and no edit lists\", GF_PROP_UINT, \"edit\", \"edit|noedit|negctts\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dur), \"only import the specified duration. If negative, specify the number of coded frames to import\", GF_PROP_FRACTION, \"0\", NULL, 0},\n\t{ OFFS(pack3gp), \"pack a given number of 3GPP audio frames in one sample\", GF_PROP_UINT, \"1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import progress\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pack_nal), \"repack NALU size length to minimum possible size for NALU-based video (AVC/HEVC/...)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(xps_inband), \"use inband (in sample data) parameter set for NALU-based video (AVC/HEVC/...)\\n\"\n\t\"- no: parameter sets are not inband, several sample descriptions might be created\\n\"\n\t\"- pps: picture parameter sets are inband, all other parameter sets are in sample description\\n\"\n\t\"- all: parameter sets are inband, no parameter sets in sample description\\n\"\n\t\"- both: parameter sets are inband, signaled as inband, and also first set is kept in sample description\\n\"\n\t\"- mix: creates non-standard files using single sample entry with first PSs found, and moves other PS inband\\n\"\n\t\"- auto: keep source config, or defaults to no if source is not ISOBMFF\", GF_PROP_UINT, \"no\", \"no|pps|all|both|mix|auto\", 0},\n\t{ OFFS(store), \"file storage mode\\n\"\n\t\"- inter: perform precise interleave of the file using [-cdur]() (requires temporary storage of all media)\\n\"\n\t\"- flat: write samples as they arrive and `moov` at end (fastest mode)\\n\"\n\t\"- fstart: write samples as they arrive and `moov` before `mdat`\\n\"\n\t\"- tight: uses per-sample interleaving of all tracks (requires temporary storage of all media)\\n\"\n\t\"- frag: fragments the file using cdur duration\\n\"\n\t\"- sfrag: fragments the file using cdur duration but adjusting to start with SAP1/3\", GF_PROP_UINT, \"inter\", \"inter|flat|fstart|tight|frag|sfrag\", 0},\n\t{ OFFS(cdur), \"chunk duration for flat and interleaving modes or fragment duration for fragmentation modes\\n\"\n\t\"- 0: no specific interleaving but moov first\\n\"\n\t\"- negative: defaults to 1.0 unless overridden by storage profile\", GF_PROP_FRACTION, \"-1/1\", NULL, 0},\n\t{ OFFS(moovts), \"timescale to use for movie. A negative value picks the media timescale of the first track added\", GF_PROP_SINT, \"600\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moof_first), \"generate fragments starting with moof then mdat\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(abs_offset), \"use absolute file offset in fragments rather than offsets from moof\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fsap), \"split truns in video fragments at SAPs to reduce file size\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(file), \"pointer to a write/edit ISOBMF file used internally by importers and exporters\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(subs_sidx), \"number of subsegments per sidx. negative value disables sidx, -2 removes sidx if present in source PID\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(m4cc), \"4 character code of empty box to append at the end of a segment (DASH mode) or of a fragment (non-DASH mode)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chain_sidx), \"use daisy-chaining of SIDX\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(msn), \"sequence number of first moof to N\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(msninc), \"sequence number increase between `moof` boxes\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(tfdt), \"set initial decode time (`tfdt`) of first traf\", GF_PROP_FRACTION64, \"0\", NULL, 0},\n\t{ OFFS(tfdt_traf), \"force `tfdt` box in each traf\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(nofragdef), \"disable default flags in fragments\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(straf), \"use a single traf per moof (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(strun), \"use a single trun per traf (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(psshs), \"set `pssh` boxes store mode\\n\"\n\t\"- moof: in first moof of each segments\\n\"\n\t\"- moov: in movie box\\n\"\n\t\"- both: in movie box and in first moof of each segment\\n\"\n\t\"- none: pssh is discarded\", GF_PROP_UINT, \"moov\", \"moov|moof|both|none\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sgpd_traf), \"store sample group descriptions in traf (duplicated for each traf). If not used, sample group descriptions are stored in the movie box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(vodcache), \"enable temp storage for VoD dash modes\\n\"\n\t\t\"- on: use temp storage of complete file for sidx and ssix injection\\n\"\n\t\t\"- insert: insert sidx and ssix by shifting bytes in output file\\n\"\n\t\t\"- replace: precompute pace requirements for sidx and ssix and rewrite file range at end\", GF_PROP_UINT, \"replace\", \"on|insert|replace\", 0},\n\t{ OFFS(noinit), \"do not produce initial `moov, used for DASH bitstream switching mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tktpl), \"use track box from input if any as a template to create new track\\n\"\n\t\"- no: disables template\\n\"\n\t\"- yes: clones the track (except edits and decoder config)\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mudta), \"use `udta` and other `moov` extension boxes from input if any\\n\"\n\t\"- no: disables import\\n\"\n\t\"- yes: clones all extension boxes\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mvex), \"set `mvex` boxes after `trak` boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sdtp_traf), \"use `sdtp` box in `traf` box rather than using flags in trun sample entries\\n\"\n\t\t\"- no: do not use `sdtp`\\n\"\n\t\t\"- sdtp: use `sdtp` box to indicate sample dependencies and do not write info in `trun` sample flags\\n\"\n\t\t\"- both: use `sdtp` box to indicate sample dependencies and also write info in `trun` sample flags\", GF_PROP_UINT, \"no\", \"no|sdtp|both\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(trackid), \"track ID of created track for single track. Default 0 uses next available trackID\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fragdur), \"fragment based on fragment duration rather than CTS. Mostly used for `MP4Box -frag` option\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(btrt), \"set `btrt` box in sample description\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(styp), \"set segment `styp` major brand (and optionally version) to the given 4CC[.version]\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(mediats), \"set media timescale. A value of 0 means inherit from PID, a value of -1 means derive from samplerate or frame rate\", GF_PROP_SINT, \"0\", NULL, 0},\n\t{ OFFS(ase), \"set audio sample entry mode for more than stereo layouts\\n\"\n\t\t\t\"- v0: use v0 signaling but channel count from stream, recommended for backward compatibility\\n\"\n\t\t\t\"- v0s: use v0 signaling and force channel count to 2 (stereo) if more than 2 channels\\n\"\n\t\t\t\"- v1: use v1 signaling, ISOBMFF style (will mux raw PCM as ISOBMFF style)\\n\"\n\t\t\t\"- v1qt: use v1 signaling, QTFF style\\n\"\n\t\t\t\"- v2qt: use v2 signaling, QTFF style (lpcm entry type)\"\n\t\t, GF_PROP_UINT, \"v0\", \"|v0|v0s|v1|v1qt|v2qt\", 0},\n\t{ OFFS(ssix), \"create `ssix` box when `sidx` box is present, level 1 mapping I-frames byte ranges, level 0xFF mapping the rest\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ccst), \"insert coding constraint box for video tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(maxchunk), \"set max chunk size in bytes for runs (only used in non-fragmented mode). 0 means no constraints\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noroll), \"disable roll sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(norap), \"disable rap sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(saio32), \"use 32 bit offset for side data location instead of 64 bit offset\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(tfdt64), \"use 64 bit tfdt and sidx even for 32 bits timestamps\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#ifdef GF_ENABLE_CTRN\n\t{ OFFS(ctrn), \"use compact track run (experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctrni), \"use inheritance in compact track run for HEVC tile tracks (highly experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#endif\n\t{ OFFS(sseg), \"set single segment mode for dash\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_HIDE},\n\n\t{ OFFS(compress), \"set top-level box compression mode\\n\"\n\t\t\t\t\t\t\"- no: disable box compression\\n\"\n\t\t\t\t\t\t\"- moov: compress only moov box (uses cmov for QT)\\n\"\n\t\t\t\t\t\t\"- moof: compress only moof boxes\\n\"\n\t\t\t\t\t\t\"- sidx: compress moof and sidx boxes\\n\"\n\t\t\t\t\t\t\"- ssix: compress moof, sidx and ssix boxes\\n\"\n\t\t\t\t\t\t\"- all: compress moov, moof, sidx and ssix boxes\", GF_PROP_UINT, \"no\", \"no|moov|moof|sidx|ssix|all\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(fcomp), \"force using compress box even when compressed size is larger than uncompressed\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(otyp), \"inject original file type when using compressed boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(trun_inter), \"interleave samples in `trun` based on the temporal level, the lowest level are stored first (this will create as many `trun` boxes as required)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(truns_first), \"store track runs before sample group description and sample encryption information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(block_size), \"target output block size, 0 for default internal value (10k)\", GF_PROP_UINT, \"10000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(boxpatch), \"apply box patch before writing\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(deps), \"add samples dependencies information\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mfra), \"enable movie fragment random access when fragmenting (ignored when dashing)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(forcesync), \"force all SAP types to be considered sync samples (might produce non-compliant files)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(refrag), \"use track fragment defaults from initial file if any rather than computing them from PID properties (used when processing standalone segments/fragments)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itags), \"tag injection mode\\n\"\n\t\t\t\"- none: do not inject tags\\n\"\n\t\t\t\"- strict: only inject recognized itunes tags\\n\"\n\t\t\t\"- all: inject all possible tags\"\n\t\t\t, GF_PROP_UINT, \"strict\", \"none|strict|all\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(keep_utc), \"force all new files and tracks to keep the source UTC creation and modification times\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pps_inband), \"when [-xps_inband]() is set, inject PPS in each non SAP 1/2/3 sample\", GF_PROP_BOOL, \"no\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moovpad), \"insert `free` box of given size after `moov` for future in-place editing\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cmaf), \"use CMAF guidelines (turns on `mvex`, `truns_first`, `strun`, `straf`, `tfdt_traf`, `chain_sidx` and restricts `subs_sidx` to -1 or 0)\\n\"\n\t\t\"- no: CMAF not enforced\\n\"\n\t\t\"- cmfc: use CMAF `cmfc` guidelines\\n\"\n\t\t\"- cmf2: use CMAF `cmf2` guidelines (turns on `nofragdef`)\"\n\t\t, GF_PROP_UINT, \"no\", \"no|cmfc|cmf2\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(start), \"set playback start offset for MP4Box import only. A negative value means percent of media duration with -1 equal to duration\", GF_PROP_DOUBLE, \"0.0\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(pad_sparse), \"inject sample with no data (size 0) to keep durations in unknown sparse text and metadata tracks\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(force_dv), \"force DV sample entry types even when AVC/HEVC compatibility is signaled\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dvsingle), \"ignore DolbyVision profile 8 in xps inband mode if profile 5 is already set\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tsalign), \"enable timeline realignment to 0 for first sample - if false, this will keep original timing with empty edit (possibly long) at begin)\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chapm), \"chapter storage mode\\n\"\n\t\"- off: disable chapters\\n\"\n\t\"- tk: use chapter track (QT-style)\\n\"\n\t\"- udta: use user-data box chapters\\n\"\n\t\"- both: use both chapter tracks and udta\"\n\t, GF_PROP_UINT, \"both\", \"off|tk|udta|both\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(patch_dts), \"patch previous samples duration when dts do not increase monotonically\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(uncv), \"use uncv (ISO 23001-17) for raw video\\n\"\n\t\"- off: disabled (always the case when muxing to QT)\\n\"\n\t\"- gen: enabled, do not write profile\\n\"\n\t\"- prof: enabled and write profile if known\\n\"\n\t\"- tiny: enabled and write reduced version if profile known and compatible\", GF_PROP_UINT, \"prof\", \"off|gen|prof|tiny\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(trunv1), \"force using version 1 of trun regardless of media type or CMAF brand\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister MP4MuxRegister = {\n\t.name = \"mp4mx\",\n\tGF_FS_SET_DESCRIPTION(\"ISOBMFF/QT multiplexer\")\n\tGF_FS_SET_HELP(\"This filter multiplexes streams to ISOBMFF (14496-12 and derived specifications) or QuickTime\\n\"\n\t\"  \\n\"\n\t\"# Tracks and Items\\n\"\n\t\"By default all input PIDs with ItemID property set are multiplexed as items, otherwise they are multiplexed as tracks.\\n\"\n\t\"To prevent source items to be multiplexed as items, use [-itemid](mp4dmx) option from ISOBMFF demultiplexer.\\n\"\n\t\"EX gpac -i source.mp4:itemid=false -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"To force non-item streams to be multiplexed as items, use __#ItemID__ option on that PID:\\n\"\n\t\"EX gpac -i source.jpg:#ItemID=1 -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"# Storage\\n\"\n\t\"The [-store]() option allows controlling if the file is fragmented or not, and when not fragmented, how interleaving is done. For cases where disk requirements are tight and fragmentation cannot be used, it is recommended to use either `flat` or `fstart` modes.\\n\"\n\t\"  \\n\"\n\t\"The [-vodcache]() option allows controlling how DASH onDemand segments are generated:\\n\"\n\t\"- If set to `on`, file data is stored to a temporary file on disk and flushed upon completion, no padding is present.\\n\"\n\t\"- If set to `insert`, SIDX/SSIX will be injected upon completion of the file by shifting bytes in file. In this case, no padding is required but this might not be compatible with all output sinks and will take longer to write the file.\\n\"\n\t\"- If set to `replace`, SIDX/SSIX size will be estimated based on duration and DASH segment length, and padding will be used in the file __before__ the final SIDX. If input PIDs have the properties `DSegs` set, this will used be as the number of segments.\\n\"\n\t\"The `on` and `insert` modes will produce exactly the same file, while the mode `replace` may inject a `free` box before the sidx.\\n\"\n\t\"  \\n\"\n\t\"# Custom boxes\\n\"\n\t\"Custom boxes can be specified as box patches:\\n\"\n\t\"For movie-level patch, the [-boxpatch]() option of the filter should be used.\\n\"\n\t\"Per PID box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"Per Item box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:1ItemID=1:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"  \\n\"\n\t\"The box patch is applied before writing the initial `moov box in fragmented mode, or when writing the complete file otherwise.\\n\"\n\t\"The box patch can either be a filename or the full XML string.\\n\"\n\t\"  \\n\"\n\t\"# Tagging\\n\"\n\t\"When tagging is enabled, the filter will watch the property `CoverArt` and all custom properties on incoming PID.\\n\"\n\t\"The built-in tag names are indicated by `MP4Box -h tags`.\\n\"\n\t\"QT tags can be specified using `qtt_NAME` property names, and will be added using formatting specified in `MP4Box -h tags`.\\n\"\n\t\"Other tag class may be specified using `tag_NAME` property names, and will be added if [-tags]() is set to `all` using:\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is four characters long\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is 3 characters long, and will be prefixed by 0xA9\\n\"\n\t\"- the CRC32 of the `NAME` as a box 4CC if `NAME` is not four characters long\\n\"\n\t\"  \\n\"\n\t\"# User data\\n\"\n\t\"The filter will look for the following PID properties to create user data entries:\\n\"\n\t\"- `udtab`: set the track user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `mudtab`: set the movie user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `udta_U4CC`: set track user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `mudta_U4CC`: set movie user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `tkgp_T4CC`: set/remove membership to track group with type `T4CC` and ID given by property value. A negative value N removes from track group with ID -N\\n\"\n\t\"  \\n\"\n\t\"EX gpac -i src.mp4:#udta_tagc='My Awesome Tag' -o tag.mp4\\n\"\n\t\"EX gpac -i src.mp4:#mudtab=data@box.bin -o tag.mp4\\n\"\n\t\"  \\n\"\n\t\"# Custom sample group descriptions and sample auxiliary info\\n\"\n\t\"The filter watches the following custom data properties on incoming packets:\\n\"\n\t\"- `grp_A4CC`: maps packet to sample group description of type `A4CC` and entry set to property payload\\n\"\n\t\"- `grp_A4CC_param`: same as above and sets sample to group `grouping_type_parameter` to `param`\\n\"\n\t\"- `sai_A4CC`: adds property payload as sample auxiliary information of type `A4CC`\\n\"\n\t\"- `sai_A4CC_param`: same as above and sets `aux_info_type_parameter`to `param`\\n\"\n\t\"  \\n\"\n\t\"The property `grp_EMSG` consists in one or more `EventMessageBox` as defined in MPEG-DASH.\\n\"\n\t\"- in fragmented mode, presence of these boxes in a packet will start a new fragment, with the boxes written before the `moof`\\n\"\n\t\"- in regular mode, an internal sample group of type `EMSG` is currently used for `emsg` box storage\\n\"\n\t\"  \\n\"\n\t\"# Notes\\n\"\n\t\"The filter watches the property `FileNumber` on incoming packets to create new files (regular mode) or new segments (DASH mode).\\n\"\n\t\"  \\n\"\n\t\"The filter watches the property `DSIWrap` (4CC as int or string) on incoming PID to wrap decoder configuration in a box of given type (unknown wrapping)\\n\"\n\t\"EX -i unkn.mkv:#ISOMSubtype=VIUK:#DSIWrap=cfgv -o t.mp4\\n\"\n\t\"This will wrap the unknown stream using `VIUK` code point in `stsd` and wrap any decoder configuration data in a `cfgv` box.\\n\"\n\t\"\\n\"\n\t\"If [-pad_sparse]() is set, the filter watches the property `Sparse` on incoming PID to decide whether empty packets should be injected to keep packet duration info.\\n\"\n\t\"Such packets are only injected when a whole in the timeline is detected.\\n\"\n\t\"- if `Sparse` is absent, empty packet is inserted for unknown text and metadata streams\\n\"\n\t\"- if `Sparse` is true, empty packet is inserted for all stream types\\n\"\n\t\"- if `Sparse` is false, empty packet is never injected\\n\"\n\t\"  \\n\"\n\t\"The default media type used for a PID can be overriden using property `StreamSubtype`. \\n\"\n\t\"EX -i src.srt:#StreamSubtype=sbtl [-i ...]  -o test.mp4 \\n\"\n\t\"This will force the text stream to use `sbtl` handler type instead of default `text` one.\"\n\t\"\\n\"\n\t\"Subtitle streams may be used as chapters by setting the property `IsChap` on the desired PID.\\n\"\n\t\"EX -i src.srt:#IsChap  [-i ...] -o test.mp4 \\n\"\n\t\"This will force the text stream to be used as a QT chapter track.\"\n\t\"  \\n\"\n\t)\n\t.private_size = sizeof(GF_MP4MuxCtx),\n\t.args = MP4MuxArgs,\n\t.initialize = mp4_mux_initialize,\n\t.finalize = mp4_mux_finalize,\n\t.flags = GF_FS_REG_DYNAMIC_REDIRECT,\n\tSETCAPS(MP4MuxCaps),\n\t.configure_pid = mp4_mux_configure_pid,\n\t.process = mp4_mux_process,\n\t.process_event = mp4_mux_process_event\n};\n\n\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn &MP4MuxRegister;\n}\n#else\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex)\n{\n\tGF_SampleDescriptionBox *stsd;\n\tGF_SampleEntryBox *entry = NULL;\n\n\tif (!mdia) return GF_ISOM_INVALID_FILE;\n\n\tstsd = mdia->information->sampleTable->SampleDescription;\n\tif (!stsd) return GF_ISOM_INVALID_FILE;\n\tif (!SampleDescIndex || (SampleDescIndex > gf_list_count(stsd->child_boxes)) ) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, SampleDescIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (out_entry) *out_entry = entry;\n\tif (dataRefIndex) *dataRefIndex = entry->dataReferenceIndex;\n\treturn GF_OK;\n}\n\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, num;\n\tu64 offset;\n\tif (sampleDescIndex == NULL) return GF_BAD_PARAM;\n\n\t//find the sample for this time\n\te = stbl_findEntryForTime(mdia->information->sampleTable, (u32) DTS, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t//we have to assume the track was created to be used... If we have a sampleDesc, OK\n\t\tif (gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes)) {\n\t\t\t(*sampleDescIndex) = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn stbl_GetSampleInfos(mdia->information->sampleTable, ( sampleNumber ? sampleNumber : prevSampleNumber), &offset, &num, sampleDescIndex, NULL);\n}\n\nstatic GF_Err gf_isom_get_3gpp_audio_esd(GF_SampleTableBox *stbl, u32 type, GF_GenericAudioSampleEntryBox *entry, GF_ESD **out_esd)\n{\n\t(*out_esd) = gf_odf_desc_esd_new(2);\n\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t/*official mapping to MPEG-4*/\n\tswitch (type) {\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_EVRC;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t{\n\t\tu32 block_size, sample_rate, sample_size, i;\n\t\tGF_SttsEntry *ent;\n\t\tGF_BitStream *bs;\n\t\tchar szName[80];\n\t\t/*only map CBR*/\n\t\tsample_size = stbl->SampleSize->sampleSize;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_QCELP;\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(bs, \"QLCMfmt \", 8);\n\t\tgf_bs_write_u32_le(bs, 150);/*fmt chunk size*/\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_write_u8(bs, 0);\n\t\t/*QCELP GUID*/\n\t\tgf_bs_write_data(bs, \"\\x41\\x6D\\x7F\\x5E\\x15\\xB1\\xD0\\x11\\xBA\\x91\\x00\\x80\\x5F\\xB4\\xB9\\x7E\", 16);\n\t\tgf_bs_write_u16_le(bs, 1);\n\t\tmemset(szName, 0, 80);\n\t\tstrcpy(szName, \"QCELP-13K(GPAC-emulated)\");\n\t\tgf_bs_write_data(bs, szName, 80);\n\t\tent = stbl->TimeToSample->nb_entries ? &stbl->TimeToSample->entries[0] : NULL;\n\t\tsample_rate = entry->samplerate_hi;\n\t\tblock_size = ent ? ent->sampleDelta : 160;\n\t\tgf_bs_write_u16_le(bs, 8*sample_size*sample_rate/block_size);\n\t\tgf_bs_write_u16_le(bs, sample_size);\n\t\tgf_bs_write_u16_le(bs, block_size);\n\t\tgf_bs_write_u16_le(bs, sample_rate);\n\t\tgf_bs_write_u16_le(bs, entry->bitspersample);\n\t\tgf_bs_write_u32_le(bs, sample_size ? 0 : 7);\n\t\t/**/\n\t\tfor (i=0; i<7; i++) {\n\t\t\tstatic const u32 qcelp_r2s [] = {0, 1, 1, 4, 2, 8, 3, 17, 4, 35, 5, 8, 14, 1};\n\t\t\tif (sample_size) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i+1]);\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i]);\n\t\t\t}\n\t\t}\n\t\tgf_bs_write_u16(bs, 0);\n\t\tmemset(szName, 0, 80);\n\t\tgf_bs_write_data(bs, szName, 20);/*reserved*/\n\t\tgf_bs_get_content(bs, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t}\n\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_SMV;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR_WB;\n\t\treturn GF_OK;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] unsupported sample description type %s\\n\", gf_4cc_to_str(entry->type)));\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tu32 type;\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\ttype = entry->type;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_264B:\n\tcase GF_ISOM_BOX_TYPE_265B:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP08:\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) {\n\t\t\t\tesd = (GF_ESD *) ESDa->desc;\n            } else if (!true_desc_only) {\n\t\t\t\tBool make_mp4a = GF_FALSE;\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\t\tif (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (make_mp4a) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_M4ADecSpecInfo aacinfo;\n\t\t\t\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\t\t\taacinfo.nb_chan = ase->channel_count;\n\t\t\t\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\t\t\t\taacinfo.base_sr = ase->samplerate_hi;\n\t\t\t\t\t*out_esd = gf_odf_desc_esd_new(0);\n\t\t\t\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\t\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\t\t\t\tgf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n#else\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t\t}\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) {\n\t\t\tESDa = entry->esd;\n\t\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT;\n\t\tif (vtte->config) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string);\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_OpusSpecificBox *opus_c;\n\t\tif (true_desc_only)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\topus_c = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tif (!opus_c) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ESD not found for Opus\\n)\"));\n\t\t\tbreak;\n\t\t}\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\t\tgf_odf_opus_cfg_write(&opus_c->opcfg, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_H263;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tif (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry;\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tif ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA;\n\t\t\telse\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS;\n\t\t\tif (ptr->cfg_mha) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->configuration_version);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout);\n\t\t\t\tgf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0);\n\t\t\t\tif (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size)\n\t\t\t\t\tgf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size);\n\n\t\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}\n\nBool Media_IsSampleSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber)\n{\n\tu32 i;\n\tGF_StshEntry *ent;\n\tif (!stsh) return 0;\n\ti=0;\n\twhile ((ent = (GF_StshEntry*)gf_list_enum(stsh->entries, &i))) {\n\t\tif ((u32) ent->syncSampleNumber == sampleNumber) return 1;\n\t\telse if ((u32) ent->syncSampleNumber > sampleNumber) return 0;\n\t}\n\treturn 0;\n}\n\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset, Bool ext_realloc)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS_and_Duration(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS, &(*samp)->duration);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\tif (! (*samp)->data)\n\t\t\t(*samp)->alloc_size = 0;\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ext_realloc) {\n\t\t\t\t(*samp)->data = mdia->mediaTrack->sample_alloc_cbk(data_size + mdia->mediaTrack->padding_bytes, mdia->mediaTrack->sample_alloc_udta);\n\t\t\t} else {\n\t\t\t\t(*samp)->data = (u8 *) gf_malloc(data_size + mdia->mediaTrack->padding_bytes);\n\t\t\t}\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)) {\n\t\tGF_ISOSAPType gf_isom_nalu_get_sample_sap(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, GF_MPEGVisualSampleEntryBox *entry);\n\n\t\tif (!gf_isom_is_encrypted_entry(entry->type)) {\n\t\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\tGF_ISOSAPType sap = gf_isom_nalu_get_sample_sap(mdia, sampleNumber, *samp, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\t\tif (sap && ! (*samp)->IsRAP) (*samp)->IsRAP = sap;\n\t\t\telse if ((*samp)->IsRAP < sap) (*samp)->IsRAP = sap;\n\t\t}\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we only support alias and URL boxes\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_URL:\n\tcase GF_QT_BOX_TYPE_ALIS:\n\tcase GF_QT_BOX_TYPE_CIOS:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}\n\n\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex)\n{\n\tu32 drefIndex=0;\n\tGF_FullBox *a=NULL;\n\tGF_SampleEntryBox *se = NULL;\n\n\tMedia_GetSampleDesc(mdia, StreamDescIndex, &se, &drefIndex);\n\tif (!drefIndex) return 0;\n\tif (mdia\n\t\t&& mdia->information\n\t\t&& mdia->information->dataInformation\n\t\t&& mdia->information->dataInformation->dref\n\t) {\n\t\ta = (GF_FullBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!a) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] broken file: Data reference index set to %d but no data reference entry found\\n\", drefIndex));\n\t\treturn 1;\n\t}\n\tif (a->flags & 1) return 1;\n\t/*QT specific*/\n\tif (a->type == GF_QT_BOX_TYPE_ALIS) return 1;\n\tif (a->type == GF_QT_BOX_TYPE_CIOS) return 1;\n\treturn 0;\n}\n\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia)\n{\n\tu32 nb_ext, nb_self;\n\tu32 i, count;\n\n\tnb_ext = nb_self = 0;\n\tcount = mdia->information->sampleTable->SampleDescription ? gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (Media_IsSelfContained(mdia, i+1)) nb_self++;\n\t\telse nb_ext++;\n\t}\n\tif (nb_ext==count) return ISOM_DREF_EXT;\n\tif (nb_self==count) return ISOM_DREF_SELF;\n\treturn ISOM_DREF_MIXED;\n}\n\n\n\n//look for a sync sample from a given point in media time\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromSample, u32 *sampleNumber, u8 mode)\n{\n\tGF_ISOSAPType isRAP;\n\tu32 next, prev, next_in_sap, prev_in_sap;\n\tif (!stbl || !stbl->SyncSample) return GF_BAD_PARAM;\n\n\t//set to current sample if we don't find a RAP\n\t*sampleNumber = searchFromSample;\n\n\t//this is not the exact sample, but the prev move to next sample if enough samples....\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_FORWARD) && (searchFromSample == stbl->SampleSize->sampleCount) ) {\n\t\treturn GF_OK;\n\t}\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_BACKWARD) && !searchFromSample) {\n\t\t*sampleNumber = 1;\n\t\treturn GF_OK;\n\t}\n\t//get the entry\n\tstbl_GetSampleRAP(stbl->SyncSample, searchFromSample, &isRAP, &prev, &next);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\t/*check sample groups - prev & next are overwritten if RAP group is found, but are not re-initialized otherwise*/\n\tstbl_SearchSAPs(stbl, searchFromSample, &isRAP, &prev_in_sap, &next_in_sap);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\tif (prev_in_sap > prev)\n\t\tprev = prev_in_sap;\n\tif (next_in_sap && next_in_sap < next)\n\t\tnext = next_in_sap;\n\n\t//nothing yet, go for next time...\n\tif (mode == GF_ISOM_SEARCH_SYNC_FORWARD) {\n\t\tif (next) *sampleNumber = next;\n\t} else {\n\t\tif (prev) *sampleNumber = prev;\n\t}\n\n\treturn GF_OK;\n}\n\n//create a DataReference if not existing (only for WRITE-edit mode)\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tu32 i;\n\tGF_DataEntryURLBox *entry;\n\n\tif (!dref) return GF_BAD_PARAM;\n\t*dataRefIndex = 0;\n\ti=0;\n\twhile ((entry = (GF_DataEntryURLBox*)gf_list_enum(dref->child_boxes, &i))) {\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t\t//self-contained case\n\t\t\tif (entry->flags == 1) {\n\t\t\t\t//if nothing specified, get the dataRef\n\t\t\t\tif (!URLname && !URNname) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//OK, check if we have URL\n\t\t\t\tif (URLname && !strcmp(URLname, entry->location)) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//this is a URN one, only check the URN name (URL optional)\n\t\t\tif (URNname && !strcmp(URNname, ((GF_DataEntryURNBox *)entry)->nameURN)) {\n\t\t\t\t*dataRefIndex = i;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//Get the total media duration based on the TimeToSample table\nGF_Err Media_SetDuration(GF_TrackBox *trak)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu64 DTS;\n\tu32 nbSamp, dur;\n\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tnbSamp = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\tif (nbSamp == 0) {\n\t\ttrak->Media->mediaHeader->duration = 0;\n\t\tif (Track_IsMPEG4Stream(trak->Media->handler->handlerType)) {\n\t\t\tMedia_GetESD(trak->Media, 1, &esd, 1);\n\t\t\tif (esd && esd->URLString) trak->Media->mediaHeader->duration = (u64) -1;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//get last sample\n\te = stbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, nbSamp, &DTS, &dur);\n\tif (e < 0) return e;\n\tDTS += dur;\n\n\t//do not do that for old arch compat which was not taking into account cts offset\n\tif (gf_sys_old_arch_compat() || !trak->Media->information->sampleTable->CompositionOffset) {\n\t\ttrak->Media->mediaHeader->duration = DTS;\n\t\treturn GF_OK;\n\t}\n\t//try to set duration according to spec: \"should be the largest composition timestamp plus the duration of that sample\"\n\ts32 cts_o;\n\tstbl_GetSampleCTS(trak->Media->information->sampleTable->CompositionOffset, nbSamp, &cts_o);\n\tif (cts_o>0) DTS += cts_o;\n\tif (DTS>trak->Media->mediaHeader->duration)\n\t\ttrak->Media->mediaHeader->duration = DTS;\n\n\t//this can be more precise in some corner cases but takes way too long - we keep code for reference\n#if 0\n\t//browse from sample_num_max_cts_delta (updated in read and edit to point to sample number with max cts offset)\n\tu32 s_idx, min = trak->Media->information->sampleTable->CompositionOffset->sample_num_max_cts_delta;\n\tif (!min) return GF_OK;\n\tfor (s_idx=min; s_idx<=nbSamp; s_idx++) {\n\t\tu64 a_dts;\n\t\tu32 a_dur;\n\t\ts32 cts_o;\n\t\tstbl_GetSampleCTS(trak->Media->information->sampleTable->CompositionOffset, s_idx, &cts_o);\n\t\tif (cts_o<=0) continue;\n\t\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, s_idx, &a_dts, &a_dur);\n\t\tif (a_dts + a_dur + (u32) cts_o > DTS) {\n\t\t\tDTS = a_dts + (u32) cts_o + a_dur;\n\t\t}\n\t}\n\ttrak->Media->mediaHeader->duration = DTS;\n#endif\n\treturn GF_OK;\n}\n\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err Media_SetDrefURL(GF_DataEntryURLBox *dref_entry, const char *origName, const char *finalName)\n{\n\t//for now we only support dref created in same folder for relative URLs\n\tif (strstr(origName, \"://\") || ((origName[1]==':') && (origName[2]=='\\\\'))\n\t\t|| (origName[0]=='/') || (origName[0]=='\\\\')\n\t) {\n\t\tdref_entry->location = gf_strdup(origName);\n\t} else {\n\t\tchar *fname = strrchr(origName, '/');\n\t\tif (!fname) fname = strrchr(origName, '\\\\');\n\t\tif (fname) fname++;\n\n\t\tif (!fname) {\n\t\t\tdref_entry->location = gf_strdup(origName);\n\t\t} else {\n\t\t\tu32 len = (u32) (fname - origName);\n\t\t\tif (!finalName || strncmp(origName, finalName, len)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Concatenation of relative path %s with relative path %s not supported, use absolute URLs\\n\", origName, finalName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tdref_entry->location = gf_strdup(fname);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_CreateDataRef(GF_ISOFile *movie, GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tGF_Err e;\n\tBool use_alis=GF_FALSE;\n\tGF_DataEntryURLBox *entry;\n\n\tif (URLname && !strcmp(URLname, \"alis\")) {\n\t\tURLname = NULL;\n\t\tuse_alis=GF_TRUE;\n\t}\n\n\tif (!URLname && !URNname) {\n\t\t//THIS IS SELF CONTAIN, create a regular entry if needed\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, use_alis ? GF_QT_BOX_TYPE_ALIS : GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 1;\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else if (!URNname && URLname) {\n\t\t//THIS IS URL\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 0;\n\n\t\te = Media_SetDrefURL(entry, URLname, movie->fileName ? movie->fileName : movie->finalName);\n\t\tif (! entry->location) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn e ? e : GF_OUT_OF_MEM;\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else {\n\t\t//THIS IS URN\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URN);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t((GF_DataEntryURNBox *)entry)->flags = 0;\n\t\t((GF_DataEntryURNBox *)entry)->nameURN = (char*)gf_malloc(strlen(URNname)+1);\n\t\tif (! ((GF_DataEntryURNBox *)entry)->nameURN) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tstrcpy(((GF_DataEntryURNBox *)entry)->nameURN, URNname);\n\t\t//check for URL\n\t\tif (URLname) {\n\t\t\t((GF_DataEntryURNBox *)entry)->location = (char*)gf_malloc(strlen(URLname)+1);\n\t\t\tif (! ((GF_DataEntryURNBox *)entry)->location) {\n\t\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tstrcpy(((GF_DataEntryURNBox *)entry)->location, URLname);\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\tu32 sampleNumber, i;\n\tif (!mdia || !sample) return GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\t//get a valid sampleNumber for this new guy\n\te = stbl_AddDTS(stbl, sample->DTS, &sampleNumber, mdia->mediaHeader->timeScale, sample->nb_pack);\n\tif (e) return e;\n\n\t//add size\n\te = stbl_AddSize(stbl->SampleSize, sampleNumber, sample->dataLength, sample->nb_pack);\n\tif (e) return e;\n\n\t//adds CTS offset\n\tif (sample->CTS_Offset) {\n\t\t//if we don't have a CTS table, add it...\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\t//then add our CTS (the prev samples with no CTS offset will be automatically added...\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t} else if (stbl->CompositionOffset) {\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t}\n\n\t//The first non sync sample we see must create a syncTable\n\tif (sample->IsRAP) {\n\t\t//insert it only if we have a sync table and if we have an IDR slice\n\t\tif (stbl->SyncSample && ((sample->IsRAP == RAP) || (sample->IsRAP == SAP_TYPE_2))) {\n\t\t\te = stbl_AddRAP(stbl->SyncSample, sampleNumber);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\t//non-sync sample. Create a SyncSample table if needed\n\t\tif (!stbl->SyncSample) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//all the prev samples are sync\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) {\n\t\t\t\t\te = stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (sample->IsRAP==RAP_REDUNDANT) {\n\t\te = stbl_AddRedundant(stbl, sampleNumber);\n\t\tif (e) return e;\n\t}\n\n\tif (!mdia->mediaTrack->chunk_cache) {\n\t\t//and update the chunks\n\t\te = stbl_AddChunkOffset(mdia, sampleNumber, StreamDescIndex, data_offset, sample->nb_pack);\n\t\tif (e) return e;\n\t}\n\t\n\tif (!syncShadowNumber) return GF_OK;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\treturn stbl_AddShadow(mdia->information->sampleTable->ShadowSync, sampleNumber, syncShadowNumber);\n}\n\n\nstatic GF_Err UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, u32 size, s32 CTS, u64 offset, u8 isRap)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl = mdia->information->sampleTable;\n\n\t//set size, offset, RAP, CTS ...\n\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, size);\n\tstbl_SetChunkOffset(mdia, sampleNumber, offset);\n\n\t//do we have a CTS?\n\tif (stbl->CompositionOffset) {\n\t\tstbl_SetSampleCTS(stbl, sampleNumber, CTS);\n\t} else {\n\t\t//do we need one ??\n\t\tif (CTS) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t\tstbl_AddCTS(stbl, sampleNumber, CTS);\n\t\t}\n\t}\n\t//do we have a sync ???\n\tif (stbl->SyncSample) {\n\t\tstbl_SetSampleRAP(stbl->SyncSample, sampleNumber, isRap);\n\t} else {\n\t\t//do we need one\n\t\tif (! isRap) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//what a pain: all the sample we had have to be sync ...\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t}\n\t\t}\n\t}\n\tif (isRap==2) {\n\t\tstbl_SetRedundant(stbl, sampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 newOffset, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia || !sample || !sampleNumber || !mdia->mediaTrack->moov->mov->editFileMap)\n\t\treturn GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\tif (!data_only) {\n\t\t//check we have the sampe dts\n\t\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\t\tif (e) return e;\n\t\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\t}\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &newOffset, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\tif (Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//MEDIA DATA EDIT: write this new sample to the edit temp file\n\tnewOffset = gf_isom_datamap_get_offset(mdia->mediaTrack->moov->mov->editFileMap);\n\tif (sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(mdia->mediaTrack->moov->mov->editFileMap, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\tif (data_only) {\n\t\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, sample->dataLength);\n\t\treturn stbl_SetChunkOffset(mdia, sampleNumber, newOffset);\n\t}\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, newOffset, sample->IsRAP);\n}\n\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 off, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia) return GF_BAD_PARAM;\n\tstbl = mdia->information->sampleTable;\n\n\t//check we have the sampe dts\n\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tif (e) return e;\n\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &off, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\t//we only modify self-contained data\n\tif (Dentry->flags == 1) return GF_ISOM_INVALID_MODE;\n\n\t//and we don't modify the media data\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, data_offset, sample->IsRAP);\n}\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nstatic u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = 0; //todo, expose qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#if 0 //unused\n/*! updates text sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param desc the text sample descriptor to use\n\\return error if any\n*/\nGF_Err gf_isom_update_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor *desc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tBool is_qt_text = GF_FALSE;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qtt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qtt->textName) gf_free(qtt->textName);\n\t\tqtt->textName = NULL;\n\t\tif (desc->font_count) {\n\t\t\tqtt->textName = gf_strdup(desc->fonts[0].fontName);\n\t\t}\n\t} else {\n\t\tif (txt->font_table) gf_isom_box_del_parent(&txt->child_boxes, (GF_Box*)txt->font_table);\n\n\t\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\t\ttxt->font_table->entry_count = desc->font_count;\n\t\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\t\tfor (i=0; i<desc->font_count; i++) {\n\t\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t\t}\n\t}\n\treturn e;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_new_text_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex, i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt = (GF_Tx3gSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_TX3G);\n\tif (!txt) return GF_OUT_OF_MEM;\n\ttxt->dataReferenceIndex = dataRefIndex;\n\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, txt);\n\tif (outDescriptionIndex) *outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\tif (!txt->font_table) return GF_OUT_OF_MEM;\n\ttxt->font_table->entry_count = desc->font_count;\n\n\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\tif (!txt->font_table->fonts) return GF_OUT_OF_MEM;\n\tfor (i=0; i<desc->font_count; i++) {\n\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t}\n\treturn e;\n}\n\n\n/*blindly adds text - note we don't rely on terminaison characters to handle utf8 and utf16 data\nin the same way. It is the user responsibility to signal UTF16*/\nGF_EXPORT\nGF_Err gf_isom_text_add_text(GF_TextSample *samp, char *text_data, u32 text_len)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!text_len) return GF_OK;\n\tsamp->text = (char*)gf_realloc(samp->text, sizeof(char) * (samp->len + text_len) );\n\tmemcpy(samp->text + samp->len, text_data, sizeof(char) * text_len);\n\tsamp->len += text_len;\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*! sets UTF16 marker for text data. This MUST be called on an empty sample. If text data added later\non (cf below) is not formatted as UTF16 data(2 bytes char) the resulting text sample won't be compliant,\nbut this library won't warn\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_set_utf16_marker(GF_TextSample *samp)\n{\n\t/*we MUST have an empty sample*/\n\tif (!samp || samp->text) return GF_BAD_PARAM;\n\tsamp->text = (char*)gf_malloc(sizeof(char) * 2);\n\tif (!samp->text) return GF_OUT_OF_MEM;\n\tsamp->text[0] = (char) 0xFE;\n\tsamp->text[1] = (char) 0xFF;\n\tsamp->len = 2;\n\treturn GF_OK;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_text_add_style(GF_TextSample *samp, GF_StyleRecord *rec)\n{\n\tif (!samp || !rec) return GF_BAD_PARAM;\n\n\tif (!samp->styles) {\n\t\tsamp->styles = (GF_TextStyleBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STYL);\n\t\tif (!samp->styles) return GF_OUT_OF_MEM;\n\t}\n\tsamp->styles->styles = (GF_StyleRecord*)gf_realloc(samp->styles->styles, sizeof(GF_StyleRecord)*(samp->styles->entry_count+1));\n\tif (!samp->styles->styles) return GF_OUT_OF_MEM;\n\tsamp->styles->styles[samp->styles->entry_count] = *rec;\n\tsamp->styles->entry_count++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_highlight(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextHighlightBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\tif (start_char == end_char) return GF_BAD_PARAM;\n\n\ta = (GF_TextHighlightBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HLIT);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_highlight_color(GF_TextSample *samp, u32 argb)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\n\tif (!samp->highlight_color) {\n\t\tsamp->highlight_color = (GF_TextHighlightColorBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HCLR);\n\t\tif (!samp->highlight_color) return GF_OUT_OF_MEM;\n\t}\n\tsamp->highlight_color->hil_color = argb;\n\treturn GF_OK;\n}\n\n/*3GPP spec is quite obscur here*/\nGF_EXPORT\nGF_Err gf_isom_text_add_karaoke(GF_TextSample *samp, u32 start_time)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tsamp->cur_karaoke = (GF_TextKaraokeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_KROK);\n\tif (!samp->cur_karaoke) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->highlight_starttime = start_time;\n\treturn gf_list_add(samp->others, samp->cur_karaoke);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_karaoke_segment(GF_TextSample *samp, u32 end_time, u16 start_char, u16 end_char)\n{\n\tif (!samp || !samp->cur_karaoke) return GF_BAD_PARAM;\n\tsamp->cur_karaoke->records = (KaraokeRecord*)gf_realloc(samp->cur_karaoke->records, sizeof(KaraokeRecord)*(samp->cur_karaoke->nb_entries+1));\n\tif (!samp->cur_karaoke->records) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].end_charoffset = end_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].start_charoffset = start_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].highlight_endtime = end_time;\n\tsamp->cur_karaoke->nb_entries++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_scroll_delay(GF_TextSample *samp, u32 scroll_delay)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->scroll_delay) {\n\t\tsamp->scroll_delay = (GF_TextScrollDelayBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_DLAY);\n\t\tif (!samp->scroll_delay) return GF_OUT_OF_MEM;\n\t}\n\tsamp->scroll_delay->scroll_delay = scroll_delay;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_hyperlink(GF_TextSample *samp, char *URL, char *altString, u16 start_char, u16 end_char)\n{\n\tGF_TextHyperTextBox*a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextHyperTextBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_HREF);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\ta->URL = URL ? gf_strdup(URL) : NULL;\n\ta->URL_hint = altString ? gf_strdup(altString) : NULL;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_box(GF_TextSample *samp, s16 top, s16 left, s16 bottom, s16 right)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->box) {\n\t\tsamp->box = (GF_TextBoxBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TBOX);\n\t\tif (!samp->box) return GF_OUT_OF_MEM;\n\t}\n\tsamp->box->box.top = top;\n\tsamp->box->box.left = left;\n\tsamp->box->box.bottom = bottom;\n\tsamp->box->box.right = right;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_blink(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextBlinkBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextBlinkBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_BLNK);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_wrap(GF_TextSample *samp, u8 wrap_flags)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->wrap) {\n\t\tsamp->wrap = (GF_TextWrapBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TWRP);\n\t\tif (!samp->wrap) return GF_OUT_OF_MEM;\n\t}\n\tsamp->wrap->wrap_flag = wrap_flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_forced(GF_TextSample *samp, Bool is_forced)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tsamp->is_forced = is_forced;\n\treturn GF_OK;\n}\n\nstatic GFINLINE GF_Err gpp_write_modifier(GF_BitStream *bs, GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_OK;\n\te = gf_isom_box_size(a);\n\tif (!e) e = gf_isom_box_write(a, bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_sample_write_bs(const GF_TextSample *samp, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tif (!samp) return GF_BAD_PARAM;\n\n\tgf_bs_write_u16(bs, samp->len);\n\tif (samp->len) gf_bs_write_data(bs, samp->text, samp->len);\n\n\te = gpp_write_modifier(bs, (GF_Box *)samp->styles);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->highlight_color);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->scroll_delay);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->box);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->wrap);\n\n\tif (!e && samp->is_forced) {\n\t\tgf_bs_write_u32(bs, 8);\n\t\tgf_bs_write_u32(bs, GF_QT_BOX_TYPE_FRCD);\n\t}\n\n\tif (!e) {\n\t\tGF_Box *a;\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\t\te = gpp_write_modifier(bs, a);\n\t\t\tif (e) break;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_text_to_sample(const GF_TextSample *samp)\n{\n\tGF_Err e;\n\tGF_ISOSample *res;\n\tGF_BitStream *bs;\n\tif (!samp) return NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\te = gf_isom_text_sample_write_bs(samp, bs);\n\n\tif (e) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tres = gf_isom_sample_new();\n\tif (!res) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tgf_bs_get_content(bs, &res->data, &res->dataLength);\n\tgf_bs_del(bs);\n\tres->IsRAP = RAP;\n\treturn res;\n}\n\nu32 gf_isom_text_sample_size(GF_TextSample *samp)\n{\n\tGF_Box *a;\n\tu32 i, size;\n\tif (!samp) return 0;\n\n\tsize = 2 + samp->len;\n\tif (samp->styles) {\n\t\tgf_isom_box_size((GF_Box *)samp->styles);\n\t\tsize += (u32) samp->styles->size;\n\t}\n\tif (samp->highlight_color) {\n\t\tgf_isom_box_size((GF_Box *)samp->highlight_color);\n\t\tsize += (u32) samp->highlight_color->size;\n\t}\n\tif (samp->scroll_delay) {\n\t\tgf_isom_box_size((GF_Box *)samp->scroll_delay);\n\t\tsize += (u32) samp->scroll_delay->size;\n\t}\n\tif (samp->box) {\n\t\tgf_isom_box_size((GF_Box *)samp->box);\n\t\tsize += (u32) samp->box->size;\n\t}\n\tif (samp->wrap) {\n\t\tgf_isom_box_size((GF_Box *)samp->wrap);\n\t\tsize += (u32) samp->wrap->size;\n\t}\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\tgf_isom_box_size((GF_Box *)a);\n\t\tsize += (u32) a->size;\n\t}\n\treturn size;\n}\n\n#if 0 //unused\n/*! checks if this text description is already inserted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the 3GPP text sample description to check\n\\param outDescIdx set to 0 if not found, or index of the matching sample description\n\\param same_styles indicates if default styles matches\n\\param same_box indicates if default box matches\n*/\nGF_Err gf_isom_text_has_similar_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, u32 *outDescIdx, Bool *same_box, Bool *same_styles)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 i, j, count;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\t*same_box = *same_styles = 0;\n\t*outDescIdx = 0;\n\n\tif (!desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tBool same_fonts;\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!txt) continue;\n\t\tif ((txt->type != GF_ISOM_BOX_TYPE_TX3G) && (txt->type != GF_ISOM_BOX_TYPE_TEXT)) continue;\n\t\tif (txt->back_color != desc->back_color) continue;\n\t\tif (txt->displayFlags != desc->displayFlags) continue;\n\t\tif (txt->vertical_justification != desc->vert_justif) continue;\n\t\tif (txt->horizontal_justification != desc->horiz_justif) continue;\n\t\tif (txt->font_table->entry_count != desc->font_count) continue;\n\n\t\tsame_fonts = 1;\n\t\tfor (j=0; j<desc->font_count; j++) {\n\t\t\tif (txt->font_table->fonts[j].fontID != desc->fonts[j].fontID) same_fonts = 0;\n\t\t\telse if (strcmp(desc->fonts[j].fontName, txt->font_table->fonts[j].fontName)) same_fonts = 0;\n\t\t}\n\t\tif (same_fonts) {\n\t\t\t*outDescIdx = i+1;\n\t\t\tif (!memcmp(&txt->default_box, &desc->default_pos, sizeof(GF_BoxRecord))) *same_box = 1;\n\t\t\tif (!memcmp(&txt->default_style, &desc->default_style, sizeof(GF_StyleRecord))) *same_styles = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_TextSample *gf_isom_new_text_sample()\n{\n\tGF_TextSample *res;\n\tGF_SAFEALLOC(res, GF_TextSample);\n\tif (!res) return NULL;\n\tres->others = gf_list_new();\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset_styles(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->box) gf_isom_box_del((GF_Box *)samp->box);\n\tsamp->box = NULL;\n\tif (samp->highlight_color) gf_isom_box_del((GF_Box *)samp->highlight_color);\n\tsamp->highlight_color = NULL;\n\tif (samp->scroll_delay) gf_isom_box_del((GF_Box *)samp->scroll_delay);\n\tsamp->scroll_delay = NULL;\n\tif (samp->wrap) gf_isom_box_del((GF_Box *)samp->wrap);\n\tsamp->wrap = NULL;\n\tif (samp->styles) gf_isom_box_del((GF_Box *)samp->styles);\n\tsamp->styles = NULL;\n\tsamp->cur_karaoke = NULL;\n\twhile (gf_list_count(samp->others)) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(samp->others, 0);\n\t\tgf_list_rem(samp->others, 0);\n\t\tgf_isom_box_del(a);\n\t}\n\tsamp->is_forced = GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->text) gf_free(samp->text);\n\tsamp->text = NULL;\n\tsamp->len = 0;\n\treturn gf_isom_text_reset_styles(samp);\n}\n\nGF_EXPORT\nvoid gf_isom_delete_text_sample(GF_TextSample * tx_samp)\n{\n\tgf_isom_text_reset(tx_samp);\n\tgf_list_del(tx_samp->others);\n\tgf_free(tx_samp);\n}\n\nGF_EXPORT\nGF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs)\n{\n\tGF_TextSample *s = gf_isom_new_text_sample();\n\n\t/*empty sample*/\n\tif (!bs || !gf_bs_available(bs)) return s;\n\n\ts->len = gf_bs_read_u16(bs);\n\tif (s->len) {\n\t\t/*2 extra bytes for UTF-16 term char just in case (we don't know if a BOM marker is present or\n\t\tnot since this may be a sample carried over RTP*/\n\t\ts->text = (char *) gf_malloc(sizeof(char)*(s->len+2) );\n\t\tif (!s->text) return NULL;\n\t\ts->text[s->len] = 0;\n\t\ts->text[s->len+1] = 0;\n\t\tgf_bs_read_data(bs, s->text, s->len);\n\t}\n\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\tGF_Err e = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_STYL:\n\t\t\tif (s->styles) {\n\t\t\t\tGF_TextStyleBox *st2 = (GF_TextStyleBox *)a;\n\t\t\t\tif (!s->styles->entry_count) {\n\t\t\t\t\tgf_isom_box_del((GF_Box*)s->styles);\n\t\t\t\t\ts->styles = st2;\n\t\t\t\t} else {\n\t\t\t\t\ts->styles->styles = (GF_StyleRecord*)gf_realloc(s->styles->styles, sizeof(GF_StyleRecord) * (s->styles->entry_count + st2->entry_count));\n\t\t\t\t\tmemcpy(&s->styles->styles[s->styles->entry_count], st2->styles, sizeof(GF_StyleRecord) * st2->entry_count);\n\t\t\t\t\ts->styles->entry_count += st2->entry_count;\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts->styles = (GF_TextStyleBox*)a;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_KROK:\n\t\t\ts->cur_karaoke = (GF_TextKaraokeBox*)a;\n\t\tcase GF_ISOM_BOX_TYPE_HLIT:\n\t\tcase GF_ISOM_BOX_TYPE_HREF:\n\t\tcase GF_ISOM_BOX_TYPE_BLNK:\n\t\t\tgf_list_add(s->others, a);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HCLR:\n\t\t\tif (s->highlight_color) gf_isom_box_del(a);\n\t\t\telse s->highlight_color = (GF_TextHighlightColorBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DLAY:\n\t\t\tif (s->scroll_delay) gf_isom_box_del(a);\n\t\t\telse s->scroll_delay= (GF_TextScrollDelayBox*) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TBOX:\n\t\t\tif (s->box) gf_isom_box_del(a);\n\t\t\telse s->box= (GF_TextBoxBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TWRP:\n\t\t\tif (s->wrap) gf_isom_box_del(a);\n\t\t\telse s->wrap= (GF_TextWrapBox*) a;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRCD:\n\t\t\ts->is_forced = GF_TRUE;\n\t\t\tgf_isom_box_del(a);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_isom_box_del(a);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}\n\n#if 0 //unused\nGF_TextSample *gf_isom_parse_text_sample_from_data(u8 *data, u32 dataLength)\n{\n\tGF_TextSample *s;\n\tGF_BitStream *bs;\n\t/*empty text sample*/\n\tif (!data || !dataLength) {\n\t\treturn gf_isom_new_text_sample();\n\t}\n\n\tbs = gf_bs_new(data, dataLength, GF_BITSTREAM_READ);\n\ts = gf_isom_parse_text_sample(bs);\n\tgf_bs_del(bs);\n\treturn s;\n}\n#endif\n\n\n/*out-of-band sample desc (128 and 255 reserved in RFC)*/\n#define SAMPLE_INDEX_OFFSET\t\t129\n\n\nstatic void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = 0; //todo expose qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd)\n{\n\tGF_BitStream *bs;\n\tu32 count, i;\n\tBool has_v_info;\n\tGF_List *sampleDesc;\n\tGF_ESD *esd;\n\tGF_TrackBox *tk;\n\n\t*out_esd = NULL;\n\tsampleDesc = mdia->information->sampleTable->SampleDescription->child_boxes;\n\tcount = gf_list_count(sampleDesc);\n\tif (!count) return GF_ISOM_INVALID_MEDIA;\n\n\tesd = gf_odf_desc_esd_new(2);\n\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\tesd->decoderConfig->objectTypeIndication = GF_CODECID_TEXT_MPEG4;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\n\t/*Base3GPPFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*MPEGExtendedFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*profileLevel*/\n\tgf_bs_write_u8(bs, 0x10);\n\tgf_bs_write_u24(bs, mdia->mediaHeader->timeScale);\n\tgf_bs_write_int(bs, 0, 1);\t/*no alt formats*/\n\tgf_bs_write_int(bs, 2, 2);\t/*only out-of-band-band sample desc*/\n\tgf_bs_write_int(bs, 1, 1);\t/*we will write sample desc*/\n\n\t/*write v info if any visual track in this movie*/\n\thas_v_info = 0;\n\ti=0;\n\twhile ((tk = (GF_TrackBox*)gf_list_enum(mdia->mediaTrack->moov->trackList, &i))) {\n\t\tif (tk->Media->handler && (tk->Media->handler->handlerType == GF_ISOM_MEDIA_VISUAL)) {\n\t\t\thas_v_info = 1;\n\t\t}\n\t}\n\tgf_bs_write_int(bs, has_v_info, 1);\n\n\tgf_bs_write_int(bs, 0, 3);\t/*reserved, spec doesn't say the values*/\n\tgf_bs_write_u8(bs, mdia->mediaTrack->Header->layer);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->width>>16);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->height>>16);\n\n\t/*write desc*/\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Tx3gSampleEntryBox *a;\n\t\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(sampleDesc, i);\n\t\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT) ) continue;\n\t\tgf_isom_write_tx3g(a, bs, i+1, SAMPLE_INDEX_OFFSET);\n\t}\n\tif (has_v_info) {\n\t\tu32 trans;\n\t\t/*which video shall we pick for MPEG-4, and how is the associations indicated in 3GP ???*/\n\t\tgf_bs_write_u16(bs, 0);\n\t\tgf_bs_write_u16(bs, 0);\n\t\ttrans = mdia->mediaTrack->Header->matrix[6];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t\ttrans = mdia->mediaTrack->Header->matrix[7];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t}\n\n\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\tgf_bs_del(bs);\n\t*out_esd = esd;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur)\n{\n\tGF_BitStream *bs;\n\tu32 pay_start, txt_size;\n\tBool is_utf_16 = 0;\n\tif (!samp || !samp->data || !samp->dataLength) return GF_OK;\n\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\ttxt_size = gf_bs_read_u16(bs);\n\tgf_bs_del(bs);\n\n\t/*remove BOM*/\n\tpay_start = 2;\n\tif (txt_size>2) {\n\t\t/*seems 3GP only accepts BE UTF-16 (no LE, no UTF32)*/\n\t\tif (((u8) samp->data[2]==(u8) 0xFE) && ((u8)samp->data[3]==(u8) 0xFF)) {\n\t\t\tis_utf_16 = 1;\n\t\t\tpay_start = 4;\n\t\t\ttxt_size -= 2;\n\t\t}\n\t}\n\n\t/*rewrite as TTU(1)*/\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_write_int(bs, is_utf_16, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_int(bs, 1, 3);\n\tgf_bs_write_u16(bs, 8 + samp->dataLength - pay_start);\n\tgf_bs_write_u8(bs, sampleDescriptionIndex + SAMPLE_INDEX_OFFSET);\n\tgf_bs_write_u24(bs, sample_dur);\n\t/*write text size*/\n\tgf_bs_write_u16(bs, txt_size);\n\tif (txt_size) gf_bs_write_data(bs, samp->data + pay_start, samp->dataLength - pay_start);\n\n\tgf_free(samp->data);\n\tsamp->data = NULL;\n\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\t*tx3g = NULL;\n\t*tx3g_size = 0;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_write_tx3g(a, bs, sidx, sidx_offset);\n\tgf_bs_get_content(bs, tx3g, tx3g_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_forced_text(GF_ISOFile *file, u32 track, u32 stsd_idx, u32 flags)\n{\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tswitch (flags) {\n\tcase 2:\n\t\ta->displayFlags |= GF_TXT_SOME_SAMPLES_FORCED | GF_TXT_ALL_SAMPLES_FORCED;\n\t\tbreak;\n\tcase 1:\n\t\ta->displayFlags |= GF_TXT_SOME_SAMPLES_FORCED;\n\t\ta->displayFlags &= ~GF_TXT_ALL_SAMPLES_FORCED;\n\t\tbreak;\n\tdefault:\n\t\ta->displayFlags &= ~GF_TXT_SOME_SAMPLES_FORCED;\n\t\ta->displayFlags &= ~GF_TXT_ALL_SAMPLES_FORCED;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMFF reader filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include \"isoffin.h\"\n#include <gpac/iso639.h>\n#include <gpac/base_coding.h>\n#include <gpac/media_tools.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n\nstatic void isor_get_chapters(GF_ISOFile *file, GF_FilterPid *opid)\n{\n\tu32 i, count;\n\tGF_PropertyValue p;\n\tGF_PropUIntList times;\n\tGF_PropStringList names;\n\tcount = gf_isom_get_chapter_count(file, 0);\n\tif (count) {\n\t\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\t\tnames.vals = gf_malloc(sizeof(char *)*count);\n\t\ttimes.nb_items = names.nb_items = count;\n\n\t\tfor (i=0; i<count; i++) {\n\t\t\tconst char *name;\n\t\t\tu64 start;\n\t\t\tgf_isom_get_chapter(file, 0, i+1, &start, &name);\n\t\t\ttimes.vals[i] = (u32) start;\n\t\t\tnames.vals[i] = gf_strdup(name);\n\t\t}\n\t\tp.type = GF_PROP_UINT_LIST;\n\t\tp.value.uint_list = times;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\t\tgf_free(times.vals);\n\n\t\tp.type = GF_PROP_STRING_LIST;\n\t\tp.value.string_list = names;\n\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\t\t//no free for string lists\n\t\treturn;\n\t}\n\n\tu32 chap_tk=0;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 nb_ref = gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_CHAP);\n\t\tif (nb_ref) {\n\t\t\tgf_isom_get_reference(file, i+1, GF_ISOM_REF_CHAP, 1, &chap_tk);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (chap_tk) {\n\t\tcount = gf_isom_get_sample_count(file, chap_tk);\n\t\tif (!count) chap_tk=0;\n\t}\n\tif (!chap_tk) return;\n\n\ttimes.vals = gf_malloc(sizeof(u32)*count);\n\tnames.vals = gf_malloc(sizeof(char *)*count);\n\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n\n\tp.type = GF_PROP_STRING_LIST;\n\tp.value.string_list = names;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_NAMES, &p);\n\n}\n\nstatic void isor_export_ref(ISOMReader *read, ISOMChannel *ch, u32 rtype, char *rname)\n{\n\tu32 nb_refs = gf_isom_get_reference_count(read->mov, ch->track, rtype);\n\tif (nb_refs) {\n\t\tu32 j;\n\t\tGF_PropertyValue prop;\n\t\tprop.type = GF_PROP_UINT_LIST;\n\t\tprop.value.uint_list.nb_items = nb_refs;\n\t\tprop.value.uint_list.vals = gf_malloc(sizeof(u32)*nb_refs);\n\t\tfor (j=0; j<nb_refs; j++) {\n\t\t\tu32 ref_tk;\n\t\t\tgf_isom_get_reference(read->mov, ch->track, rtype, j+1, &ref_tk );\n\t\t\tprop.value.uint_list.vals[j] = gf_isom_get_track_id(read->mov, ref_tk);\n\t\t}\n\t\tgf_filter_pid_set_property_str(ch->pid, rname, &prop);\n\t\tgf_free(prop.value.uint_list.vals);\n\t}\n}\n\nstatic void isor_declare_track(ISOMReader *read, ISOMChannel *ch, u32 track, u32 stsd_idx, u32 streamtype, Bool use_iod)\n{\n\tu32 w, h, sr, nb_ch, nb_bps, codec_id, depends_on_id, esid, avg_rate, max_rate, buffer_size, sample_count, max_size, base_track, audio_fmt, pix_fmt;\n\tGF_ESD *an_esd;\n\tconst char *mime, *encoding, *stxtcfg, *namespace, *schemaloc, *mime_cfg;\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\tu8 *tk_template;\n\tu32 tk_template_size;\n#endif\n\tGF_Language *lang_desc = NULL;\n\tBool external_base=GF_FALSE;\n\tBool has_scalable_layers = GF_FALSE;\n\tu8 *dsi = NULL, *enh_dsi = NULL;\n\tu32 dsi_size = 0, enh_dsi_size = 0;\n\tDouble track_dur=0;\n\tu32 srd_id=0, srd_indep=0, srd_x=0, srd_y=0, srd_w=0, srd_h=0;\n\tu32 base_tile_track=0;\n\tBool srd_full_frame=GF_FALSE;\n\tu32 mtype, m_subtype;\n\tGF_GenericSampleDescription *udesc = NULL;\n\tGF_Err e;\n\tu32 ocr_es_id;\n\tu32 meta_codec_id = 0;\n\tchar *meta_codec_name = NULL;\n\tu32 meta_opaque=0;\n\tBool first_config = GF_FALSE;\n\tu32 force_subs = 0;\n\n\n\tdepends_on_id = avg_rate = max_rate = buffer_size = 0;\n\tmime = encoding = stxtcfg = namespace = schemaloc = mime_cfg = NULL;\n\n\tif ( gf_isom_is_media_encrypted(read->mov, track, stsd_idx)) {\n\t\tgf_isom_get_original_format_type(read->mov, track, stsd_idx, &m_subtype);\n\t} else {\n\t\tm_subtype = gf_isom_get_media_subtype(read->mov, track, stsd_idx);\n\t}\n\n\tif (m_subtype==GF_ISOM_SUBTYPE_MPEG4) {\n\t\tu32 stsd_type = gf_isom_get_mpeg4_subtype(read->mov, track, stsd_idx);\n\t\tif (stsd_type==GF_ISOM_SUBTYPE_RESV)\n\t\t\tgf_isom_get_original_format_type(read->mov, track, stsd_idx, &m_subtype);\n\t}\n\n\taudio_fmt = 0;\n\tpix_fmt = 0;\n\tocr_es_id = 0;\n\tan_esd = gf_media_map_esd(read->mov, track, stsd_idx);\n\tif (an_esd && an_esd->decoderConfig) {\n\t\tif (an_esd->decoderConfig->streamType==GF_STREAM_INTERACT) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)an_esd);\n\t\t\treturn;\n\t\t}\n\t\tstreamtype = an_esd->decoderConfig->streamType;\n\t\tif (an_esd->decoderConfig->objectTypeIndication < GF_CODECID_LAST_MPEG4_MAPPING) {\n\t\t\tcodec_id = gf_codecid_from_oti(streamtype, an_esd->decoderConfig->objectTypeIndication);\n\t\t} else {\n\t\t\tcodec_id = an_esd->decoderConfig->objectTypeIndication;\n\t\t}\n\t\tocr_es_id = an_esd->OCRESID;\n\t\tdepends_on_id = an_esd->dependsOnESID;\n\t\tlang_desc = an_esd->langDesc;\n\t\tan_esd->langDesc = NULL;\n\t\tesid = an_esd->ESID;\n\n\t\tif (an_esd->decoderConfig->decoderSpecificInfo && an_esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tdsi = an_esd->decoderConfig->decoderSpecificInfo->data;\n\t\t\tdsi_size = an_esd->decoderConfig->decoderSpecificInfo->dataLength;\n\t\t\tan_esd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\tan_esd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t}\n\n\t\tgf_odf_desc_del((GF_Descriptor *)an_esd);\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (dsi && (codec_id==GF_CODECID_AAC_MPEG4)) {\n\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\tgf_m4a_get_config(dsi, dsi_size, &acfg);\n\t\t\tif (acfg.base_object_type == GF_M4A_USAC)\n\t\t\t\tcodec_id = GF_CODECID_USAC;\n\t\t}\n#endif\n\n\t} else {\n\t\tu32 i, pcm_flags, pcm_size, pcm_ch;\n\t\tDouble pcm_sr;\n\t\tBool load_default = GF_FALSE;\n\t\tBool is_float = GF_FALSE;\n\n\t\tif (an_esd)\n\t\t\tgf_odf_desc_del((GF_Descriptor *)an_esd);\n\n\t\tlang_desc = (GF_Language *) gf_odf_desc_new(GF_ODF_LANG_TAG);\n\t\tgf_isom_get_media_language(read->mov, track, &lang_desc->full_lang_code);\n\t\tesid = gf_isom_get_track_id(read->mov, track);\n\n\t\tif (!streamtype) streamtype = gf_codecid_type(m_subtype);\n\t\tcodec_id = 0;\n\n\t\tswitch (m_subtype) {\n\t\tcase GF_ISOM_SUBTYPE_STXT:\n\t\tcase GF_ISOM_SUBTYPE_METT:\n\t\tcase GF_ISOM_SUBTYPE_SBTT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\n\t\t\tcodec_id = GF_CODECID_SIMPLE_TEXT;\n\t\t\tgf_isom_stxt_get_description(read->mov, track, stsd_idx, &mime, &encoding, &stxtcfg);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_STPP:\n\t\t\tcodec_id = GF_CODECID_SUBS_XML;\n\t\t\tgf_isom_xml_subtitle_get_description(read->mov, track, stsd_idx, &namespace, &schemaloc, &mime);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_METX:\n\t\t\tcodec_id = GF_CODECID_META_XML;\n\t\t\tgf_isom_xml_subtitle_get_description(read->mov, track, stsd_idx, &namespace, &schemaloc, &mime);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_WVTT:\n\t\t\tcodec_id = GF_CODECID_WEBVTT;\n#ifndef GPAC_DISABLE_VTT\n\t\t\tstxtcfg = gf_isom_get_webvtt_config(read->mov, track, stsd_idx);\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MJP2:\n\t\t\tcodec_id = GF_CODECID_J2K;\n\t\t\tgf_isom_get_jp2_config(read->mov, track, stsd_idx, &dsi, &dsi_size);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\tcodec_id = GF_CODECID_HEVC_TILES;\n\t\t\tgf_isom_get_reference(read->mov, track, GF_ISOM_REF_TBAS, 1, &base_tile_track);\n\t\t\tif (base_tile_track) {\n\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_tile_track);\n\t\t\t}\n\t\t\tgf_isom_get_tile_info(read->mov, track, 1, NULL, &srd_id, &srd_indep, &srd_full_frame, &srd_x, &srd_y, &srd_w, &srd_h);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_TEXT:\n\t\tcase GF_ISOM_SUBTYPE_TX3G:\n\t\t{\n\t\t\tGF_TextSampleDescriptor *txtcfg = NULL;\n\t\t\tcodec_id = GF_CODECID_TX3G;\n\t\t\te = gf_isom_get_text_description(read->mov, track, stsd_idx, &txtcfg);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d unable to fetch TX3G config\\n\", track));\n\t\t\t}\n\t\t\tif (txtcfg) {\n\t\t\t\tif (txtcfg->displayFlags & GF_TXT_ALL_SAMPLES_FORCED) force_subs = 2;\n\t\t\t\telse if (txtcfg->displayFlags & GF_TXT_SOME_SAMPLES_FORCED) force_subs = 1;\n\n\t\t\t\tgf_odf_tx3g_write(txtcfg, &dsi, &dsi_size);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) txtcfg);\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_FLAC:\n\t\t\tcodec_id = GF_CODECID_FLAC;\n\t\t\tgf_isom_flac_config_get(read->mov, track, stsd_idx, &dsi, &dsi_size);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\t\tcodec_id = GF_CODECID_OPUS;\n\t\t\tgf_isom_opus_config_get(read->mov, track, stsd_idx, &dsi, &dsi_size);\n\t\t\tbreak;\n\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\t\tis_float = GF_TRUE;\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\t\tif (gf_isom_get_pcm_config(read->mov, track, stsd_idx, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\tif (pcm_size==16) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_S16 : GF_AUDIO_FMT_S16_BE;\n\t\t\t\telse if (pcm_size==24) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_S24 : GF_AUDIO_FMT_S24_BE;\n\t\t\t\telse if (!is_float && (pcm_size==32)) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_S32 : GF_AUDIO_FMT_S32_BE;\n\t\t\t\telse if (is_float && (pcm_size==32)) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_FLT : GF_AUDIO_FMT_FLT_BE;\n\t\t\t\telse if (is_float && (pcm_size==64)) audio_fmt = (pcm_flags&1) ? GF_AUDIO_FMT_DBL : GF_AUDIO_FMT_DBL_BE;\n\t\t\t\telse codec_id = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TIMECODE:\n\t\t\tcodec_id = GF_CODECID_TMCD;\n\t\t\tstreamtype = GF_STREAM_METADATA;\n\t\t\tbreak;\n\n\t\tcase GF_QT_SUBTYPE_RAW:\n\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\tif (streamtype==GF_STREAM_AUDIO)\n \t\t\t\taudio_fmt = GF_AUDIO_FMT_U8;\n\t\t\telse\n \t\t\t\tpix_fmt = GF_PIXEL_RGB;\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_IPCM:\n\t\t\tif (gf_isom_get_pcm_config(read->mov, track, stsd_idx, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\tif (pcm_size==16) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_S16 : GF_AUDIO_FMT_S16_BE;\n\t\t\t\telse if (pcm_size==24) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_S24 : GF_AUDIO_FMT_S24_BE;\n\t\t\t\telse if (pcm_size==32) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_S32 : GF_AUDIO_FMT_S32_BE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_FPCM:\n\t\t\tif (gf_isom_get_pcm_config(read->mov, track, stsd_idx, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\tif (pcm_size==64) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_DBL : GF_AUDIO_FMT_DBL_BE;\n\t\t\t\telse if (pcm_size==32) audio_fmt = (pcm_flags & 1) ? GF_AUDIO_FMT_FLT : GF_AUDIO_FMT_FLT_BE;\n\t\t\t\telse codec_id = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_QT_SUBTYPE_LPCM:\n\t\t\tif (gf_isom_get_lpcm_config(read->mov, track, stsd_idx, &pcm_sr, &pcm_ch, &pcm_flags, &pcm_size) == GF_OK) {\n\t\t\t\taudio_fmt = 0;\n\t\t\t\tBool is_be = (pcm_flags & (1<<1)) ? GF_TRUE : GF_FALSE;\n\t\t\t\tif (pcm_flags >> 4) {}\n\t\t\t\t//we don't support non-packed audio\n\t\t\t\telse if (!(pcm_flags & (1<<3))) {}\n\t\t\t\telse if (pcm_sr != (u32) gf_ceil(pcm_sr)) {}\n\t\t\t\telse {\n\t\t\t\t\tsr = (u32) gf_ceil(pcm_sr);\n\t\t\t\t\tnb_ch = pcm_ch;\n\t\t\t\t\t//float formats\n\t\t\t\t\tif (pcm_flags & 1) {\n\t\t\t\t\t\tif (pcm_size==64) audio_fmt = is_be ? GF_AUDIO_FMT_DBL_BE : GF_AUDIO_FMT_DBL;\n\t\t\t\t\t\telse if (pcm_size==32) audio_fmt = is_be ? GF_AUDIO_FMT_FLT_BE : GF_AUDIO_FMT_FLT;\n\t\t\t\t\t}\n\t\t\t\t\t//signed int formats\n\t\t\t\t\telse if (pcm_flags & 4) {\n\t\t\t\t\t\tif (pcm_size==16) audio_fmt = is_be ? GF_AUDIO_FMT_S16_BE : GF_AUDIO_FMT_S16;\n\t\t\t\t\t\telse if (pcm_size==24) audio_fmt = is_be ? GF_AUDIO_FMT_S24_BE : GF_AUDIO_FMT_S24;\n\t\t\t\t\t\telse if (pcm_size==32) audio_fmt = is_be ? GF_AUDIO_FMT_S32_BE : GF_AUDIO_FMT_S32;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (pcm_size==8) audio_fmt = GF_AUDIO_FMT_U8;\n\t\t\t\t\t}\n\t\t\t\t\tif (audio_fmt) {\n\t\t\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\t\t\tnb_bps = pcm_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_VVC1:\n\t\tcase GF_ISOM_SUBTYPE_VVI1:\n\t\t{\n\t\t\tGF_VVCConfig *vvccfg = gf_isom_vvc_config_get(read->mov, track, stsd_idx);\n\t\t\tif (vvccfg) {\n\t\t\t\tgf_odf_vvc_cfg_write(vvccfg, &dsi, &dsi_size);\n\t\t\t\tgf_odf_vvc_cfg_del(vvccfg);\n\t\t\t}\n\t\t\tcodec_id = GF_CODECID_VVC;\n\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_VVS1:\n\t\t\tbase_tile_track = 0;\n\t\t\tcodec_id = gf_isom_get_track_group(read->mov, track, GF_4CC('a','l','t','e') );\n\t\t\tfor (i=0; i<gf_isom_get_track_count(read->mov); i++) {\n\t\t\t\tu32 j, nb_refs = gf_isom_get_reference_count(read->mov, i+1, GF_ISOM_REF_SUBPIC);\n\t\t\t\tfor (j=0; j<nb_refs; j++) {\n\t\t\t\t\tu32 ref_tk=0;\n\t\t\t\t\tgf_isom_get_reference_ID(read->mov, i+1, GF_ISOM_REF_SUBPIC, j+1, &ref_tk);\n\t\t\t\t\tif ((ref_tk == esid) || (ref_tk == codec_id)) {\n\t\t\t\t\t\tbase_tile_track = i+1;\n\t\t\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_tile_track);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (base_tile_track) break;\n\t\t\t}\n\t\t\tif (!base_tile_track) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] VVC subpicture track ID %d with no base VVC track referencing it, ignoring\\n\", esid));\n\t\t\t\tif (lang_desc) gf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\t\t\tif (dsi) gf_free(dsi);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcodec_id = GF_CODECID_VVC_SUBPIC;\n\t\t\tgf_isom_get_tile_info(read->mov, track, 1, NULL, &srd_id, &srd_indep, &srd_full_frame, &srd_x, &srd_y, &srd_w, &srd_h);\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\tcase GF_ISOM_SUBTYPE_EC3:\n\t\t{\n\t\t\tGF_AC3Config *ac3cfg = gf_isom_ac3_config_get(read->mov, track, stsd_idx);\n\t\t\tcodec_id = (m_subtype==GF_ISOM_SUBTYPE_AC3) ? GF_CODECID_AC3 : GF_CODECID_EAC3;\n\t\t\tif (ac3cfg) {\n\t\t\t\tgf_odf_ac3_cfg_write(ac3cfg, &dsi, &dsi_size);\n\t\t\t\tgf_free(ac3cfg);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d missing AC3/EC3 configuration !\\n\", track));\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_SUBTYPE_MLPA:\n\t\t{\n\t\t\tu32 fmt, prate;\n\t\t\tif (gf_isom_truehd_config_get(read->mov, track, stsd_idx, &fmt, &prate) == GF_OK) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tgf_bs_write_u32(bs, fmt);\n\t\t\t\tgf_bs_write_int(bs, prate, 15);\n\t\t\t\tgf_bs_write_int(bs, 0, 1);\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\tgf_bs_get_content(bs, &dsi, &dsi_size);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tcodec_id = GF_CODECID_TRUEHD;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d missing TrueHD configuration !\\n\", track));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GF_ISOM_SUBTYPE_DVB_SUBS:\n\t\t\tcodec_id = GF_CODECID_DVB_SUBS;\n\t\t\tload_default = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_DVB_TELETEXT:\n\t\t\tcodec_id = GF_CODECID_DVB_TELETEXT;\n\t\t\tload_default = GF_TRUE;\n\t\t\tbreak;\n\n\t\tcase GF_4CC('G','M','C','W'):\n\t\t\tcodec_id = m_subtype;\n\t\t\tload_default = GF_TRUE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcodec_id = gf_codec_id_from_isobmf(m_subtype);\n\t\t\tif (!codec_id || (codec_id==GF_CODECID_RAW)) {\n\t\t\t\tpix_fmt=0;\n\t\t\t\tif (streamtype==GF_STREAM_VISUAL) {\n\t\t\t\t\tpix_fmt = gf_pixel_fmt_from_qt_type(m_subtype);\n\t\t\t\t\tif (!pix_fmt && gf_pixel_fmt_probe(m_subtype, NULL))\n\t\t\t\t\t\tpix_fmt = m_subtype;\n\t\t\t\t}\n\n \t\t\t\tif (pix_fmt) {\n\t\t\t\t\tcodec_id = GF_CODECID_RAW;\n\t\t\t\t\tif (pix_fmt==GF_PIXEL_UNCV) {\n\t\t\t\t\t\tload_default = GF_TRUE;\n\t\t\t\t\t\tcodec_id = GF_CODECID_RAW_UNCV;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tload_default = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//load dsi in any other case\n\t\t\telse {\n\t\t\t//if ((codec_id==GF_CODECID_FFV1) || (codec_id==GF_CODECID_ALAC))\n\t\t\t\tload_default = GF_TRUE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (load_default) {\n\t\t\tif (!codec_id) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d type %s not natively handled\\n\", track, gf_4cc_to_str(m_subtype) ));\n\n\t\t\t\tcodec_id = m_subtype;\n\t\t\t}\n\t\t\tudesc = gf_isom_get_generic_sample_description(read->mov, track, stsd_idx);\n\t\t\tif (udesc) {\n\t\t\t\tif ((codec_id==GF_CODECID_FFV1) && (udesc->extension_buf_size>8)) {\n\t\t\t\t\tdsi = gf_malloc(udesc->extension_buf_size-8);\n\t\t\t\t\tif (dsi) memcpy(dsi, udesc->extension_buf+8, udesc->extension_buf_size-8);\n\t\t\t\t\tdsi_size = udesc->extension_buf_size - 8;\n\t\t\t\t} else if ((codec_id==GF_4CC('G','M','C','W')) && (udesc->extension_buf_size>=16)) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(udesc->extension_buf, udesc->extension_buf_size, GF_BITSTREAM_READ);\n\t\t\t\t\tif (udesc->ext_box_wrap == GF_4CC('G','M','C','C')) {\n\t\t\t\t\t\tcodec_id = gf_bs_read_u32(bs);\n\t\t\t\t\t\tmeta_codec_id = gf_bs_read_u32(bs);\n\t\t\t\t\t\tmeta_codec_name = gf_bs_read_utf8(bs);\n\t\t\t\t\t\tmeta_opaque = gf_bs_read_u32(bs);\n\t\t\t\t\t\tif (gf_bs_available(bs)) {\n\t\t\t\t\t\t\tu32 pos = (u32) gf_bs_get_position(bs);\n\t\t\t\t\t\t\tdsi = udesc->extension_buf+pos;\n\t\t\t\t\t\t\tdsi_size = udesc->extension_buf_size-pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\tdsi = udesc->extension_buf;\n\t\t\t\t\tdsi_size = udesc->extension_buf_size;\n\t\t\t\t\tudesc->extension_buf = NULL;\n\t\t\t\t\tudesc->extension_buf_size = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!streamtype || !codec_id) {\n\t\tif (udesc) gf_free(udesc);\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to %s pid for track %d, could not extract codec/streamtype info\\n\", ch ? \"update\" : \"create\", track));\n\t\tif (lang_desc) gf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\tif (dsi) gf_free(dsi);\n\t\treturn;\n\t}\n\n\tmime_cfg = gf_isom_subtitle_get_mime(read->mov, track, stsd_idx);\n\n\t//first setup, creation of PID and channel\n\tif (!ch) {\n\t\tBool use_sidx_dur = GF_FALSE;\n\t\tGF_FilterPid *pid;\n\t\tfirst_config = GF_TRUE;\n\n\t\tgf_isom_get_reference(read->mov, track, GF_ISOM_REF_BASE, 1, &base_track);\n\n\t\tif (base_track) {\n\t\t\tu32 base_subtype=0;\n\t\t\tif (read->smode==MP4DMX_SINGLE)\n\t\t\t\tdepends_on_id = 0;\n\n\t\t\tswitch (m_subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\t\tbase_subtype = gf_isom_get_media_subtype(read->mov, base_track, stsd_idx);\n\t\t\t\tswitch (base_subtype) {\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\t\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\texternal_base=GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (external_base) {\n\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_track);\n\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tswitch (gf_isom_get_hevc_lhvc_type(read->mov, track, stsd_idx)) {\n\t\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t//this is likely temporal sublayer of base\n\t\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_ONLY:\n\t\t\t\t\thas_scalable_layers = GF_FALSE;\n\t\t\t\t\tif (gf_isom_get_reference_count(read->mov, track, GF_ISOM_REF_SCAL)<=0) {\n\t\t\t\t\t\tdepends_on_id = gf_isom_get_track_id(read->mov, base_track);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (gf_isom_get_hevc_lhvc_type(read->mov, track, stsd_idx)) {\n\t\t\tcase GF_ISOM_HEVCTYPE_HEVC_LHVC:\n\t\t\tcase GF_ISOM_HEVCTYPE_LHVC_ONLY:\n\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!has_scalable_layers) {\n\t\t\t\tu32 i;\n\t\t\t\tGF_ISOTrackID track_id = gf_isom_get_track_id(read->mov, track);\n\t\t\t\tfor (i=0; i<gf_isom_get_track_count(read->mov); i++) {\n\t\t\t\t\tif (gf_isom_get_reference_count(read->mov, i+1, GF_ISOM_REF_BASE)>=0) {\n\t\t\t\t\t\tGF_ISOTrackID tkid;\n\t\t\t\t\t\tgf_isom_get_reference_ID(read->mov, i+1, GF_ISOM_REF_BASE, 1, &tkid);\n\t\t\t\t\t\tif (tkid==track_id) {\n\t\t\t\t\t\t\thas_scalable_layers = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (base_track && !ocr_es_id) {\n\t\t\tocr_es_id = gf_isom_get_track_id(read->mov, base_track);\n\t\t}\n\t\tif (!ocr_es_id) ocr_es_id = esid;\n\n\t\t//OK declare PID\n\t\tpid = gf_filter_pid_new(read->filter);\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esid));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(ocr_es_id));\n\t\tif (depends_on_id && (depends_on_id != esid))\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(depends_on_id));\n\n\t\tif (gf_isom_get_track_count(read->mov)>1) {\n\t\t\tchar szPName[1024];\n\t\t\tconst char *szST = gf_stream_type_name(streamtype);\n\t\t\tsprintf(szPName, \"%c%d\", szST[0], esid);\n\t\t\tgf_filter_pid_set_name(pid, szPName);\n\t\t}\n\n\t\t//MPEG-4 systems present\n\t\tif (use_iod)\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ESID, &PROP_UINT(esid));\n\n\t\tif (gf_isom_is_track_in_root_od(read->mov, track) && !read->lightp) {\n\t\t\tswitch (streamtype) {\n\t\t\tcase GF_STREAM_SCENE:\n\t\t\tcase GF_STREAM_OD:\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(streamtype));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT( gf_isom_get_media_timescale(read->mov, track) ) );\n\n\t\tif (!gf_sys_is_test_mode())\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TRACK_NUM, &PROP_UINT(track) );\n\n\t\t//Dolby Vision - check for any video type\n\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(read->mov, track, stsd_idx);\n\t\tif (dovi) {\n\t\t\tu8 *data = NULL;\n\t\t\tu32 size = 0;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_odf_dovi_cfg_write_bs(dovi, bs);\n\t\t\tgf_bs_get_content(bs, &data, &size);\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA_NO_COPY(data, size));\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_odf_dovi_cfg_del(dovi);\n\n\t\t\tif (gf_isom_get_reference_count(read->mov, track, GF_4CC('v','d','e','p'))) {\n\t\t\t\tGF_ISOTrackID ref_id=0;\n\t\t\t\tgf_isom_get_reference_ID(read->mov, track, GF_4CC('v','d','e','p'), 1, &ref_id);\n\t\t\t\tif (ref_id) gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(ref_id));\n\t\t\t}\n\t\t}\n\n\t\t//create our channel\n\t\tch = isor_create_channel(read, pid, track, 0, (codec_id==GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\n\t\tif (lang_desc) {\n\t\t\tchar *lang=NULL;\n\t\t\tgf_isom_get_media_language(read->mov, track, &lang);\n\t\t\t//s32 idx = gf_lang_find(lang);\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_LANGUAGE, &PROP_STRING( lang ));\n\t\t\tif (lang) gf_free(lang);\n\t\t\tgf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\t\tlang_desc = NULL;\n\t\t}\n\n\t\tch->streamType = streamtype;\n//\t\tch->clock_id = ocr_es_id;\n\n\t\tif (!read->lightp) {\n\t\t\tif (has_scalable_layers)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_SCALABLE, &PROP_BOOL(GF_TRUE));\n\n\t\t\tif (gf_isom_get_reference_count(read->mov, track, GF_ISOM_REF_SABT)>0) {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\t\t\telse if (gf_isom_get_reference_count(read->mov, track, GF_ISOM_REF_SUBPIC)>0) {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\n\t\t\tif (srd_w && srd_h) {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(srd_x, srd_y) );\n\t\t\t\tif (base_tile_track) {\n\t\t\t\t\tgf_isom_get_visual_info(read->mov, base_tile_track, stsd_idx, &w, &h);\n\t\t\t\t\tif (w && h) {\n\t\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_SIZE, &PROP_VEC2I_INT(w, h) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu8 *srdg=NULL;\n\t\t\t\tu32 srdg_s=0;\n\t\t\t\tgf_isom_get_user_data(read->mov, track, GF_ISOM_UDTA_GPAC_SRD, NULL, 1, &srdg, &srdg_s);\n\t\t\t\tif (srdg && srdg_s>=21) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(srdg, srdg_s, GF_BITSTREAM_READ);\n\t\t\t\t\tgf_bs_skip_bytes(bs, 5);\n\t\t\t\t\tsrd_x = (s32) gf_bs_read_u32(bs);\n\t\t\t\t\tsrd_y = (s32) gf_bs_read_u32(bs);\n\t\t\t\t\tsrd_w = gf_bs_read_u32(bs);\n\t\t\t\t\tsrd_h = gf_bs_read_u32(bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(srd_x, srd_y) );\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_SIZE, &PROP_VEC2I_INT(srd_w, srd_h) );\n\t\t\t\t}\n\t\t\t\tif (srdg) gf_free(srdg);\n\t\t\t}\n\n\n\t\t\tif (codec_id !=GF_CODECID_LHVC)\n\t\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_SCAL, \"isom:scal\");\n\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_SABT, \"isom:sabt\");\n\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_TBAS, \"isom:tbas\");\n\t\t\tisor_export_ref(read, ch, GF_ISOM_REF_SUBPIC, \"isom:subp\");\n\t\t}\n\n\t\tif (read->lightp) {\n\t\t\tch->duration = gf_isom_get_track_duration_orig(read->mov, ch->track);\n\t\t} else {\n\t\t\tch->duration = gf_isom_get_track_duration(read->mov, ch->track);\n\t\t}\n\t\tif (!ch->duration) {\n\t\t\tch->duration = gf_isom_get_duration(read->mov);\n\t\t}\n\t\tsample_count = gf_isom_get_sample_count(read->mov, ch->track);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (read->frag_type && !read->input_loaded) {\n\t\t\tu32 ts;\n\t\t\tu64 dur;\n\t\t\tif (gf_isom_get_sidx_duration(read->mov, &dur, &ts)==GF_OK) {\n\t\t\t\tdur *= read->timescale;\n\t\t\t\tdur /= ts;\n\t\t\t\tch->duration = dur;\n\t\t\t\tuse_sidx_dur = GF_TRUE;\n\t\t\t\tsample_count = 0;\n\t\t\t}\n\t\t}\n#endif\n\n\t\tif (!read->mem_load_mode || ch->duration) {\n\t\t\t//if no edit list (whether complex or simple TS offset) and no sidx, use media duration\n\t\t\tif (!ch->has_edit_list && !use_sidx_dur && !ch->ts_offset) {\n\t\t\t\t//no specific edit list type but edit present, use the duration in the edit\n\t\t\t\tif (gf_isom_get_edits_count(read->mov, ch->track)) {\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));\n\t\t\t\t} else {\n\t\t\t\t\tu64 dur = gf_isom_get_media_duration(read->mov, ch->track);\n\t\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(dur, ch->timescale));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//otherwise trust track duration\n\t\t\telse {\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DURATION, &PROP_FRAC64_INT(ch->duration, read->timescale));\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_NB_FRAMES, &PROP_UINT(sample_count));\n\t\t}\n\n\t\tif (sample_count && (streamtype==GF_STREAM_VISUAL)) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(read->mov, track);\n\t\t\t//if ts_offset is negative (skip), update media dur before computing fps\n\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\tu32 sdur = gf_isom_get_avg_sample_delta(read->mov, ch->track);\n\t\t\t\tif (sdur) {\n\t\t\t\t\tmdur = sdur;\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->ts_offset<0)\n\t\t\t\t\t\tmdur -= (u32) -ch->ts_offset;\n\t\t\t\t\tmdur /= sample_count;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmdur /= sample_count;\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_FPS, &PROP_FRAC_INT(ch->timescale, (u32) mdur));\n\t\t}\n\n\t\ttrack_dur = (Double) (s64) ch->duration;\n\t\ttrack_dur /= read->timescale;\n\t\t//move channel duration in media timescale\n\t\tch->duration = (u64) (track_dur * ch->timescale);\n\n\n\t\t//set stream subtype\n\t\tmtype = gf_isom_get_media_type(read->mov, track);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SUBTYPE, &PROP_4CC(mtype) );\n\n\t\tif (!read->mem_load_mode) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MEDIA_DATA_SIZE, &PROP_LONGUINT(gf_isom_get_media_data_size(read->mov, track) ) );\n\t\t}\n\t\t//in no cache mode, depending on fetch speed we may have fetched a fragment or not, resulting in has_rap set\n\t\t//always for HAS_SYNC to false\n\t\telse if (gf_sys_is_test_mode() && !sample_count) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(GF_FALSE) );\n\t\t}\n\n\t\tif (read->lightp) goto props_done;\n\n\t\tw = gf_isom_get_constant_sample_size(read->mov, track);\n\t\tif (w)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_FRAME_SIZE, &PROP_UINT(w));\n\n\t\t//mem mode, cannot read backwards\n\t\tif (read->mem_load_mode) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_PLAYBACK_MODE);\n\t\t\tif (!p)\n\t\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_REWIND) );\n\t\t}\n\n\t\tGF_PropertyValue brands;\n\t\tbrands.type = GF_PROP_4CC_LIST;\n\t\tu32 major_brand=0;\n\t\tgf_isom_get_brand_info(read->mov, &major_brand, NULL, &brands.value.uint_list.nb_items);\n\t\tbrands.value.uint_list.vals = (u32 *) gf_isom_get_brands(read->mov);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_BRANDS, &brands);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_MBRAND, &PROP_4CC(major_brand) );\n\n\t\t//we cannot expose average size/dur in mem mode with fragmented files (sample_count=0)\n\t\tif (sample_count) {\n\t\t\tmax_size = gf_isom_get_max_sample_size(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_MAX_FRAME_SIZE, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_avg_sample_size(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_AVG_FRAME_SIZE, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_max_sample_delta(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_MAX_TS_DELTA, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_max_sample_cts_offset(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_MAX_CTS_OFFSET, &PROP_UINT(max_size) );\n\n\t\t\tmax_size = gf_isom_get_constant_sample_duration(read->mov, ch->track);\n\t\t\tif (max_size) gf_filter_pid_set_property(pid, GF_PROP_PID_CONSTANT_DURATION, &PROP_UINT(max_size) );\n\t\t}\n\n\n\t\tu32 media_pl=0;\n\t\tif (streamtype==GF_STREAM_VISUAL) {\n\t\t\tmedia_pl = gf_isom_get_pl_indication(read->mov, GF_ISOM_PL_VISUAL);\n\t\t} else if (streamtype==GF_STREAM_AUDIO) {\n\t\t\tmedia_pl = gf_isom_get_pl_indication(read->mov, GF_ISOM_PL_AUDIO);\n\t\t}\n\t\tif (media_pl && (media_pl!=0xFF) ) gf_filter_pid_set_property(pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT(media_pl) );\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\t\te = gf_isom_get_track_template(read->mov, ch->track, &tk_template, &tk_template_size);\n\t\tif (e == GF_OK) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_TEMPLATE, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to serialize track box: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\n\t\te = gf_isom_get_trex_template(read->mov, ch->track, &tk_template, &tk_template_size);\n\t\tif (e == GF_OK) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TREX_TEMPLATE, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\t\t}\n\n\t\te = gf_isom_get_raw_user_data(read->mov, &tk_template, &tk_template_size);\n\t\tif (e==GF_OK) {\n\t\t\tif (tk_template_size)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_UDTA, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to serialize moov UDTA box: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n#endif\n\n\t\tGF_Fraction64 moov_time;\n\t\tmoov_time.num = gf_isom_get_duration(read->mov);\n\t\tmoov_time.den = gf_isom_get_timescale(read->mov);\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_MOVIE_TIME, &PROP_FRAC64(moov_time) );\n\n\n\t\tu32 i;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\t\tgf_isom_get_track_layout_info(read->mov, ch->track, &w, &h, &tx, &ty, &l);\n\t\tif (w && h) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_TRANS_X, &PROP_SINT(tx) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_TRANS_Y, &PROP_SINT(ty) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ZORDER, &PROP_SINT(l) );\n\t\t}\n\t\tif (codec_id==GF_CODECID_TX3G) {\n\t\t\tu32 m_w = w;\n\t\t\tu32 m_h = h;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(read->mov); i++) {\n\t\t\t\tswitch (gf_isom_get_media_type(read->mov, i+1)) {\n\t\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\t\tgf_isom_get_track_layout_info(read->mov, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_WIDTH_MAX, &PROP_UINT(m_w) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HEIGHT_MAX, &PROP_UINT(m_h) );\n\t\t\tchar *tx3g_config_sdp = NULL;\n\t\t\tfor (i=0; i<gf_isom_get_sample_description_count(read->mov, ch->track); i++) {\n\t\t\t\tu8 *tx3g;\n\t\t\t\tu32 l1;\n\t\t\t\tu32 tx3g_len, len;\n\t\t\t\te = gf_isom_text_get_encoded_tx3g(read->mov, ch->track, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\tchar buffer[2000];\n\t\t\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\t\t\tgf_free(tx3g);\n\t\t\t\t\tbuffer[len] = 0;\n\n\t\t\t\t\tl1 = tx3g_config_sdp ? (u32) strlen(tx3g_config_sdp) : 0;\n\t\t\t\t\ttx3g_config_sdp = gf_realloc(tx3g_config_sdp, len+3+l1);\n\t\t\t\t\ttx3g_config_sdp[l1] = 0;\n\t\t\t\t\tif (i) strcat(tx3g_config_sdp, \", \");\n\t\t\t\t\tstrcat(tx3g_config_sdp, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tx3g_config_sdp) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_STRING_NO_COPY(tx3g_config_sdp) );\n\t\t\t}\n\t\t}\n\n\t\tu32 idx=0;\n\t\twhile (1) {\n\t\t\tu32 data_len, int_val2, flags;\n\t\t\tu64 int_val;\n\t\t\tconst char *name;\n\t\t\tconst u8 *data;\n\t\t\tGF_ISOiTunesTag itag;\n\t\t\tu32 itype = 0;\n\t\t\ts32 tag_idx;\n\n\t\t\te = gf_isom_apple_enum_tag(read->mov, idx, &itag, &data, &data_len, &int_val, &int_val2, &flags);\n\t\t\tif (e) break;\n\t\t\tidx++;\n\n\t\t\t//do not expose tool\n\t\t\tif (!gf_sys_is_test_mode() && (itag == GF_ISOM_ITUNE_TOOL))\n\t\t\t\tcontinue;\n\n\t\t\ttag_idx = gf_itags_find_by_itag(itag);\n\t\t\tif (tag_idx>=0)\n\t\t\t\titype = gf_itags_get_type(tag_idx);\n\n\t\t\tname = gf_itags_get_name(tag_idx);\n\t\t\tswitch (itype) {\n\t\t\tcase GF_ITAG_BOOL:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_BOOL((Bool) int_val ) );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_INT8:\n\t\t\tcase GF_ITAG_INT16:\n\t\t\tcase GF_ITAG_INT32:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_UINT((u32) int_val ) );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_INT64:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_LONGUINT(int_val) );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FRAC8:\n\t\t\tcase GF_ITAG_FRAC6:\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_FRAC_INT((s32) int_val, int_val2)  );\n\t\t\t\tbreak;\n\t\t\tcase GF_ITAG_FILE:\n\t\t\t\tif (data && data_len)\n\t\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_DATA((u8 *)data, data_len)  );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (data && data_len) {\n\t\t\t\t\tif (gf_utf8_is_legal(data, data_len))\n\t\t\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_STRING(data) );\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_filter_pid_set_property_str(ch->pid, name, &PROP_DATA((u8 *)data, data_len)  );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (codec_id==GF_CODECID_TMCD) {\n\t\t\tu32 tmcd_flags=0, tmcd_fps_num=0, tmcd_fps_den=0, tmcd_fpt=0;\n\t\t\tgf_isom_get_tmcd_config(read->mov, track, stsd_idx, &tmcd_flags, &tmcd_fps_num, &tmcd_fps_den, &tmcd_fpt);\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"tmcd:flags\", &PROP_UINT(tmcd_flags) );\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"tmcd:framerate\", &PROP_FRAC_INT(tmcd_fps_num, tmcd_fps_den) );\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"tmcd:frames_per_tick\", &PROP_UINT(tmcd_fpt) );\n\n\t\t}\n\n\t\tif (gf_sys_old_arch_compat()) {\n\t\t\tBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber);\n\t\t\tif (gf_isom_has_time_offset_table(read->mov, ch->track))\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, \"isom_force_ctts\", &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\tif (read->nodata==2)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"nodata\", &PROP_BOOL(GF_TRUE) );\n\n\t\tif (!gf_sys_is_test_mode()) {\n\t\t\tu32 nb_udta, alt_grp=0;\n\t\t\tconst char *hdlr = NULL;\n\t\t\tgf_isom_get_handler_name(read->mov, ch->track, &hdlr);\n\t\t\tif (hdlr)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_HANDLER, &PROP_STRING(hdlr));\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_FLAGS, &PROP_UINT( gf_isom_get_track_flags(read->mov, ch->track) ));\n\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_FLAGS, &PROP_UINT( gf_isom_get_track_flags(read->mov, ch->track) ));\n\n\t\t\tgf_isom_get_track_switch_group_count(read->mov, ch->track, &alt_grp, NULL);\n\t\t\tif (alt_grp)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_ALT_GROUP, &PROP_UINT( alt_grp ));\n\n\n\t\t\tif (streamtype==GF_STREAM_VISUAL) {\n\t\t\t\tGF_PropertyValue p;\n\t\t\t\tu32 vals[9];\n\t\t\t\tmemset(vals, 0, sizeof(u32)*9);\n\t\t\t\tmemset(&p, 0, sizeof(GF_PropertyValue));\n\t\t\t\tp.type = GF_PROP_SINT_LIST;\n\t\t\t\tp.value.uint_list.nb_items = 9;\n\t\t\t\tp.value.uint_list.vals = vals;\n\t\t\t\tgf_isom_get_track_matrix(read->mov, ch->track, vals);\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_TRACK_MATRIX, &p);\n\t\t\t}\n\n\n\t\t\tnb_udta =  gf_isom_get_udta_count(read->mov, ch->track);\n\t\t\tif (nb_udta) {\n\t\t\t\tfor (i=0; i<nb_udta; i++) {\n\t\t\t\t\tu32 j, type, nb_items;\n\t\t\t\t\tbin128 uuid;\n\t\t\t\t\tgf_isom_get_udta_type(read->mov, ch->track, i+1, &type, &uuid);\n\t\t\t\t\tnb_items = gf_isom_get_user_data_count(read->mov, ch->track, type, uuid);\n\t\t\t\t\t//we only export 4CC udta boxes\n\t\t\t\t\tif (!type) continue;\n\n\t\t\t\t\tfor (j=0; j<nb_items; j++) {\n\t\t\t\t\t\tchar szName[31];\n\t\t\t\t\t\tu8 *udta=NULL;\n\t\t\t\t\t\tu32 udta_size;\n\t\t\t\t\t\tgf_isom_get_user_data(read->mov, ch->track, type, uuid, j+1, &udta, &udta_size);\n\t\t\t\t\t\tif (!udta || !udta_size) continue;\n\t\t\t\t\t\tif (nb_items>1)\n\t\t\t\t\t\t\tsnprintf(szName, 30, \"udta_%s_%d\", gf_4cc_to_str(type), j+1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsnprintf(szName, 30, \"udta_%s\", gf_4cc_to_str(type));\n\t\t\t\t\t\tszName[30]=0;\n\t\t\t\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\t\t\t\tif (!udta[udta_size-1]) {\n\t\t\t\t\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_STRING_NO_COPY(udta));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchar *data = gf_malloc(udta_size+1);\n\t\t\t\t\t\t\t\tmemcpy(data, udta, udta_size);\n\t\t\t\t\t\t\t\tdata[udta_size]=0;\n\t\t\t\t\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_STRING_NO_COPY(data));\n\t\t\t\t\t\t\t\tgf_free(udta);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szName, &PROP_DATA_NO_COPY(udta, udta_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//delcare track groups\n\t\t\tu32 idx=0;\n\t\t\twhile (1) {\n\t\t\t\tchar szTK[100];\n\t\t\t\tu32 track_group_type, track_group_id;\n\t\t\t\tif (!gf_isom_enum_track_group(read->mov, ch->track, &idx, &track_group_type, &track_group_id)) break;\n\t\t\t\tsprintf(szTK, \"tkgp_%s\", gf_4cc_to_str(track_group_type));\n\t\t\t\tgf_filter_pid_set_property_dyn(ch->pid, szTK, &PROP_SINT(track_group_id));\n\t\t\t}\n\t\t}\n\nprops_done:\n\n\t\tif (read->sigfrag) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tu64 start, end;\n\t\t\tif (gf_isom_get_root_sidx_offsets(read->mov, &start, &end)) {\n\t\t\t\tif (end)\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(start , end));\n\t\t\t}\n#endif\n\t\t\tif (!read->frag_type) {\n\t\t\t\tgf_filter_pid_set_property_str(ch->pid, \"nofrag\", &PROP_BOOL(GF_TRUE));\n\t\t\t}\n\t\t}\n\t}\n\n\t//update decoder configs\n\tch->check_avc_ps = ch->check_hevc_ps = ch->check_vvc_ps = 0;\n\tif (ch->avcc) gf_odf_avc_cfg_del(ch->avcc);\n\tch->avcc = NULL;\n\tif (ch->hvcc) gf_odf_hevc_cfg_del(ch->hvcc);\n\tch->hvcc = NULL;\n\tif (ch->vvcc) gf_odf_vvc_cfg_del(ch->vvcc);\n\tch->vvcc = NULL;\n\n\tif (lang_desc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)lang_desc);\n\t\tlang_desc = NULL;\n\t}\n\n\tif (read->smode != MP4DMX_SINGLE) {\n\t\tif ((codec_id==GF_CODECID_LHVC) || (codec_id==GF_CODECID_HEVC)) {\n\t\t\tBool signal_lhv = (read->smode==MP4DMX_SPLIT) ? GF_TRUE : GF_FALSE;\n\t\t\tGF_HEVCConfig *hvcc = gf_isom_hevc_config_get(read->mov, track, stsd_idx);\n\t\t\tGF_HEVCConfig *lhcc = gf_isom_lhvc_config_get(read->mov, track, stsd_idx);\n\n\t\t\tif (hvcc || lhcc) {\n\t\t\t\tif (dsi) gf_free(dsi);\n\t\t\t\tdsi = NULL;\n\t\t\t\t//no base layer config\n\t\t\t\tif (!hvcc) signal_lhv = GF_TRUE;\n\n\t\t\t\tif (signal_lhv && lhcc) {\n\t\t\t\t\tif (hvcc) {\n\t\t\t\t\t\thvcc->is_lhvc = GF_FALSE;\n\t\t\t\t\t\tgf_odf_hevc_cfg_write(hvcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tlhcc->is_lhvc = GF_TRUE;\n\t\t\t\t\tgf_odf_hevc_cfg_write(lhcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\tcodec_id = GF_CODECID_LHVC;\n\t\t\t\t} else {\n\t\t\t\t\tif (hvcc) {\n\t\t\t\t\t\thvcc->is_lhvc = GF_FALSE;\n\t\t\t\t\t\tgf_odf_hevc_cfg_write(hvcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tif (lhcc) {\n\t\t\t\t\t\tlhcc->is_lhvc = GF_TRUE;\n\t\t\t\t\t\tgf_odf_hevc_cfg_write(lhcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tcodec_id = GF_CODECID_HEVC;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hvcc) gf_odf_hevc_cfg_del(hvcc);\n\t\t\tif (lhcc) gf_odf_hevc_cfg_del(lhcc);\n\t\t}\n\t\tif ((codec_id==GF_CODECID_AVC) || (codec_id==GF_CODECID_SVC) || (codec_id==GF_CODECID_MVC)) {\n\t\t\tBool is_mvc = GF_FALSE;\n\t\t\tBool signal_svc = (read->smode==MP4DMX_SPLIT) ? GF_TRUE : GF_FALSE;\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(read->mov, track, stsd_idx);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(read->mov, track, stsd_idx);\n\t\t\tif (!svcc) {\n\t\t\t\tsvcc = gf_isom_mvc_config_get(read->mov, track, stsd_idx);\n\t\t\t\tis_mvc = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (avcc || svcc) {\n\t\t\t\tif (dsi) gf_free(dsi);\n\t\t\t\tdsi = NULL;\n\t\t\t\t//no base layer config\n\t\t\t\tif (!avcc) signal_svc = GF_TRUE;\n\n\t\t\t\tif (signal_svc && svcc) {\n\t\t\t\t\tif (avcc) {\n\t\t\t\t\t\tgf_odf_avc_cfg_write(avcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_avc_cfg_write(svcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\tcodec_id = is_mvc ? GF_CODECID_MVC : GF_CODECID_SVC;\n\t\t\t\t} else {\n\t\t\t\t\tif (avcc) {\n\t\t\t\t\t\tgf_odf_avc_cfg_write(avcc, &dsi, &dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tif (svcc) {\n\t\t\t\t\t\tgf_odf_avc_cfg_write(svcc, &enh_dsi, &enh_dsi_size);\n\t\t\t\t\t}\n\t\t\t\t\tcodec_id = GF_CODECID_AVC;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (avcc) gf_odf_avc_cfg_del(avcc);\n\t\t\tif (svcc) gf_odf_avc_cfg_del(svcc);\n\t\t}\n\n\t\tif (!gf_sys_is_test_mode()) {\n\t\t\tu64 create_date, modif_date;\n\t\t\tgf_isom_get_creation_time(read->mov, &create_date, &modif_date);\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"isom:creation_date\", &PROP_LONGUINT(create_date));\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"isom:modification_date\", &PROP_LONGUINT(modif_date));\n\t\t}\n\n\t\tisor_get_chapters(read->mov, ch->pid);\n\n\t\tif (!gf_sys_is_test_mode()) {\n\t\t\tBool has_roll=GF_FALSE;\n\t\t\tgf_isom_has_cenc_sample_group(read->mov, track, NULL, &has_roll);\n\t\t\tif (has_roll)\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CENC_HAS_ROLL, &PROP_BOOL(GF_TRUE));\n\t\t}\n\t}\n\n\t//all stsd specific init/reconfig\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CODECID, &PROP_UINT(codec_id));\n\n\tif (meta_codec_name || meta_codec_id) {\n\t\tif (meta_codec_id)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT(meta_codec_id));\n\n\t\tif (meta_codec_name) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_META_DEMUX_CODEC_NAME, &PROP_STRING(meta_codec_name ) );\n\t\t\tgf_free(meta_codec_name);\n\t\t}\n\t\tif (meta_opaque)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(meta_opaque));\n\n\t\tif (dsi) {\n\t\t\tch->dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(dsi, dsi_size)); //copy\n\t\t\tdsi = NULL; //do not free it\n\t\t}\n\t\tm_subtype = 0;\n\t\tif (udesc) {\n\t\t\tif (udesc->extension_buf) gf_free(udesc->extension_buf);\n\t\t\tgf_free(udesc);\n\t\t\tudesc = NULL;\n\t\t}\n\t}\n\n\tif (dsi) {\n\t\tch->dsi_crc = gf_crc_32(dsi, dsi_size);\n\t\t//strip box header for these codecs\n\t\tif (codec_id==GF_CODECID_SMPTE_VC1) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(dsi+8, dsi_size-8));\n\t\t\tgf_free(dsi);\n\t\t\tdsi=NULL;\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size));\n\t\t}\n\t}\n\tif (enh_dsi) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_DATA_NO_COPY(enh_dsi, enh_dsi_size));\n\t}\n\tif (audio_fmt) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(audio_fmt));\n\t\tif (codec_id == GF_CODECID_RAW) {\n\t\t\tgf_isom_enable_raw_pack(read->mov, track, read->frame_size);\n\t\t}\n\t}\n\tif (pix_fmt) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PIXFMT, &PROP_UINT(pix_fmt));\n\t}\n\n\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_FORCED_SUB, force_subs ? &PROP_UINT(force_subs) : NULL );\n\n\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CONFIG_IDX, &PROP_UINT(stsd_idx) );\n\n\tw = h = 0;\n\tgf_isom_get_visual_info(read->mov, track, stsd_idx, &w, &h);\n\tif (w && h) {\n\t\tGF_ISOM_Y3D_Info yt3d;\n\t\tu32 hspace, vspace;\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_WIDTH, &PROP_UINT(w));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HEIGHT, &PROP_UINT(h));\n\n\t\tgf_isom_get_pixel_aspect_ratio(read->mov, track, stsd_idx, &hspace, &vspace);\n\t\tif (hspace != vspace)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SAR, &PROP_FRAC_INT(hspace, vspace) );\n\n\t\t{\n\t\t\tconst u8 *icc;\n\t\t\tu32 icc_size;\n\t\t\tu32 colour_type;\n\t\t\tu16 colour_primaries, transfer_characteristics, matrix_coefficients;\n\t\t\tBool full_range_flag;\n\t\t\tif (GF_OK == gf_isom_get_color_info(read->mov, track, stsd_idx,\n\t\t\t\t&colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag)) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_PRIMARIES, &PROP_UINT(colour_primaries));\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_TRANSFER, &PROP_UINT(transfer_characteristics));\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_MX, &PROP_UINT(matrix_coefficients));\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_COLR_RANGE, &PROP_BOOL(full_range_flag));\n\t\t\t}\n\t\t\tif (gf_isom_get_icc_profile(read->mov, track, stsd_idx, NULL, &icc, &icc_size)==GF_OK) {\n\t\t\t\tif (icc && icc_size)\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ICC_PROFILE, &PROP_DATA((u8*)icc, icc_size) );\n\t\t\t}\n\t\t}\n\n\t\te = gf_isom_get_y3d_info(ch->owner->mov, ch->track, stsd_idx, &yt3d);\n\t\tif (e==GF_OK) {\n\t\t\tif (yt3d.stereo_type) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_STEREO_TYPE, &PROP_UINT(yt3d.stereo_type));\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_STEREO_TYPE, NULL);\n\t\t\t}\n\n\t\t\tif (yt3d.projection_type) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROJECTION_TYPE, &PROP_UINT(yt3d.projection_type));\n\t\t\t\tif (yt3d.projection_type==GF_PROJ360_CUBE_MAP) {\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CUBE_MAP_PAD, yt3d.padding ? &PROP_UINT(yt3d.padding) : NULL);\n\t\t\t\t}\n\t\t\t\telse if (yt3d.projection_type==GF_PROJ360_EQR) {\n\t\t\t\t\tif (yt3d.top || yt3d.bottom || yt3d.left || yt3d.right)\n\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_EQR_CLAMP, &PROP_VEC4I_INT(yt3d.top, yt3d.bottom , yt3d.left , yt3d.right));\n\t\t\t\t\telse\n\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_EQR_CLAMP, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROJECTION_TYPE, NULL);\n\t\t\t}\n\t\t\tif (yt3d.pose_present) {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_VR_POSE, &PROP_VEC3I_INT(yt3d.yaw, yt3d.pitch, yt3d.roll) );\n\t\t\t} else {\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_VR_POSE, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (m_subtype!=GF_QT_SUBTYPE_LPCM) {\n\t\tsr = nb_ch = nb_bps = 0;\n\t\tgf_isom_get_audio_info(read->mov,track, stsd_idx, &sr, &nb_ch, &nb_bps);\n\t}\n\tif (streamtype==GF_STREAM_AUDIO) {\n\t\tif (!sr) sr = gf_isom_get_media_timescale(read->mov, track);\n\t}\n\t//nb_ch may be set to 0 for \"not applicable\" (3D / object coding audio)\n\tif (sr) {\n\t\tu32 d1, d2;\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(sr));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(nb_ch));\n\n\t\t//to remove once we deprecate master\n\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\tGF_AudioChannelLayout layout;\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_BPS, &PROP_UINT(nb_bps));\n\n\t\t\tif (gf_isom_get_audio_layout(read->mov, track, stsd_idx, &layout)==GF_OK) {\n\t\t\t\tif (layout.definedLayout) {\n\t\t\t\t\tu64 lay = gf_audio_fmt_get_layout_from_cicp(layout.definedLayout);\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(lay));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (first_config ) {\n\t\t\td1 = gf_isom_get_sample_duration(read->mov, ch->track, 1);\n\t\t\td2 = gf_isom_get_sample_duration(read->mov, ch->track, 2);\n\t\t\tif (d1 && d2 && (d1==d2)) {\n\t\t\t\td1 *= sr;\n\t\t\t\td1 /= ch->timescale;\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_SAMPLES_PER_FRAME, &PROP_UINT(d1));\n\t\t\t}\n\t\t}\n\n\t\tif ((codec_id==GF_CODECID_MPHA) || (codec_id==GF_CODECID_MHAS)) {\n\t\t\tu32 nb_profiles;\n\t\t\tconst u8 *prof_compat = gf_isom_get_mpegh_compatible_profiles(read->mov, ch->track, stsd_idx, &nb_profiles);\n\t\t\tif (prof_compat) {\n\t\t\t\tu32 j;\n\t\t\t\tGF_PropertyValue prop;\n\t\t\t\tprop.type = GF_PROP_UINT_LIST;\n\t\t\t\tprop.value.uint_list.nb_items = nb_profiles;\n\t\t\t\tprop.value.uint_list.vals = gf_malloc(sizeof(u32)*nb_profiles);\n\t\t\t\tfor (j=0; j<nb_profiles; j++)\n\t\t\t\t\tprop.value.uint_list.vals[j] = prof_compat[j];\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES, &prop);\n\t\t\t\tgf_free(prop.value.uint_list.vals);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tgf_isom_get_bitrate(read->mov, ch->track, stsd_idx, &avg_rate, &max_rate, &buffer_size);\n\n\tif (!avg_rate) {\n\t\tif (first_config && ch->duration) {\n\t\t\tu64 avgrate = 8 * gf_isom_get_media_data_size(read->mov, ch->track);\n\t\t\tavgrate = (u64) (avgrate / track_dur);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_BITRATE, &PROP_UINT((u32) avgrate));\n\t\t}\n\t} else {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_BITRATE, &PROP_UINT((u32) avg_rate));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MAXRATE, &PROP_UINT((u32) max_rate));\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_DBSIZE, &PROP_UINT((u32) buffer_size));\n\t}\n\n\tif (mime) gf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(mime) );\n\tif (encoding) gf_filter_pid_set_property_str(ch->pid, \"meta:encoding\", &PROP_STRING(encoding) );\n\tif (namespace) gf_filter_pid_set_property_str(ch->pid, \"meta:xmlns\", &PROP_STRING(namespace) );\n\tif (schemaloc) gf_filter_pid_set_property_str(ch->pid, \"meta:schemaloc\", &PROP_STRING(schemaloc) );\n\tif (mime_cfg) gf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\telse if ((m_subtype==GF_ISOM_SUBTYPE_STPP) && namespace && strstr(namespace, \"ns/ttml\")) {\n\t\tmime_cfg = \"application/ttml+xml;codecs=im1t\";\n\t\tif (gf_isom_sample_has_subsamples(read->mov, track, 0, 0) )\n\t\t\tmime_cfg = \"application/ttml+xml;codecs=im1i\";\n\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\t}\n\n\tif (!gf_sys_is_test_mode() && (m_subtype==GF_ISOM_SUBTYPE_MPEG4))\n\t\tm_subtype = gf_isom_get_mpeg4_subtype(read->mov, ch->track, stsd_idx);\n\n\tif (m_subtype)\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_SUBTYPE, &PROP_4CC(m_subtype) );\n\n\tif (stxtcfg) gf_filter_pid_set_property(ch->pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *)stxtcfg, (u32) strlen(stxtcfg) ));\n\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\ttk_template=NULL;\n\ttk_template_size=0;\n\te = gf_isom_get_stsd_template(read->mov, ch->track, stsd_idx, &tk_template, &tk_template_size);\n\tif (e == GF_OK) {\n\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_STSD_TEMPLATE, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\n\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t//if more than one sample desc, export all of them\n\t\t\tif (gf_isom_get_sample_description_count(read->mov, ch->track)>1) {\n\t\t\t\ttk_template=NULL;\n\t\t\t\ttk_template_size=0;\n\t\t\t\te = gf_isom_get_stsd_template(read->mov, ch->track, 0, &tk_template, &tk_template_size);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, &PROP_DATA_NO_COPY(tk_template, tk_template_size) );\n\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_ISOM_STSD_TEMPLATE_IDX, &PROP_UINT(stsd_idx) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to serialize stsd box: %s\\n\", gf_error_to_string(e) ));\n\t}\n#endif\n\n\tif (codec_id == GF_CODECID_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tmemset(&dims, 0, sizeof(GF_DIMSDescription));\n\n\t\tgf_isom_get_dims_description(read->mov, ch->track, stsd_idx, &dims);\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:profile\", &PROP_UINT(dims.profile));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:level\", &PROP_UINT(dims.level));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:pathComponents\", &PROP_UINT(dims.pathComponents));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:fullRequestHost\", &PROP_BOOL(dims.fullRequestHost));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:streamType\", &PROP_BOOL(dims.streamType));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:redundant\", &PROP_BOOL(dims.containsRedundant));\n\t\tif (dims.content_script_types)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"dims:scriptTypes\", &PROP_STRING(dims.content_script_types));\n\t\tif (dims.textEncoding)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:encoding\", &PROP_STRING(dims.textEncoding));\n\t\tif (dims.contentEncoding)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:content_encoding\", &PROP_STRING(dims.contentEncoding));\n\t\tif (dims.xml_schema_loc)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:schemaloc\", &PROP_STRING(dims.xml_schema_loc));\n\t\tif (dims.mime_type)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"meta:mime\", &PROP_STRING(dims.mime_type));\n\t}\n\telse if (codec_id==GF_CODECID_AVC)\n\t\tch->check_avc_ps = (ch->owner->xps_check==MP4DMX_XPS_REMOVE) ? 1 : 0;\n\telse if (codec_id==GF_CODECID_HEVC)\n\t\tch->check_hevc_ps = (ch->owner->xps_check==MP4DMX_XPS_REMOVE) ? 1 : 0;\n\telse if (codec_id==GF_CODECID_VVC)\n\t\tch->check_vvc_ps = (ch->owner->xps_check==MP4DMX_XPS_REMOVE) ? 1 : 0;\n\telse if (codec_id==GF_CODECID_MHAS) {\n\t\tif (!dsi) {\n\t\t\tch->check_mhas_pl = 1;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(ch->owner->mov, ch->track, 1, NULL);\n\t\t\tif (samp) {\n\t\t\t\tu64 ch_layout=0;\n\t\t\t\ts32 PL = gf_mpegh_get_mhas_pl(samp->data, samp->dataLength, &ch_layout);\n\t\t\t\tif (PL>0) {\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_PROFILE_LEVEL, &PROP_UINT((u32) PL));\n\t\t\t\t\tch->check_mhas_pl = 0;\n\t\t\t\t\tif (ch_layout)\n\t\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CHANNEL_LAYOUT, &PROP_LONGUINT(ch_layout));\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n#endif\n\t\t}\n\t}\n\n\tif (udesc) {\n\t\tgf_filter_pid_set_property_str(ch->pid, \"codec_vendor\", &PROP_UINT(udesc->vendor_code));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"codec_version\", &PROP_UINT(udesc->version));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"codec_revision\", &PROP_UINT(udesc->revision));\n\t\tgf_filter_pid_set_property_str(ch->pid, \"compressor_name\", &PROP_STRING(udesc->compressor_name));\n\t\tif (udesc->temporal_quality)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"temporal_quality\", &PROP_UINT(udesc->temporal_quality));\n\n\t\tif (udesc->spatial_quality)\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"spatial_quality\", &PROP_UINT(udesc->spatial_quality));\n\n\t\tif (udesc->h_res) {\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"hres\", &PROP_UINT(udesc->h_res));\n\t\t\tgf_filter_pid_set_property_str(ch->pid, \"vres\", &PROP_UINT(udesc->v_res));\n\t\t} else if (udesc->nb_channels) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(udesc->nb_channels));\n\t\t\tswitch (udesc->bits_per_sample) {\n\t\t\tcase 8:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_U8));\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S16));\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S24));\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S32));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d unsupported audio bit depth %d\\n\", track, udesc->bits_per_sample ));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (udesc->depth)\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_BIT_DEPTH_Y, &PROP_UINT(udesc->depth));\n\n\t\tgf_free(udesc);\n\t}\n\n\n\tif (ch->check_avc_ps) {\n\t\tch->avcc = gf_isom_avc_config_get(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t}\n\telse if (ch->check_hevc_ps) {\n\t\tch->hvcc = gf_isom_hevc_config_get(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t}\n\telse if (ch->check_vvc_ps) {\n\t\tch->vvcc = gf_isom_vvc_config_get(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t}\n\n\tif (streamtype==GF_STREAM_VISUAL) {\n\t\tu32 cwn, cwd, chn, chd, cxn, cxd, cyn, cyd;\n\t\tgf_isom_get_clean_aperture(ch->owner->mov, ch->track, ch->last_sample_desc_index ? ch->last_sample_desc_index : 1, &cwn, &cwd, &chn, &chd, &cxn, &cxd, &cyn, &cyd);\n\n\t\tif (cwd && chd && cxd && cyd) {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_W, &PROP_FRAC_INT(cwn, cwd) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_H, &PROP_FRAC_INT(chn, chd) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_X, &PROP_FRAC_INT(cxn, cxd) );\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_Y, &PROP_FRAC_INT(cyn, cyd) );\n\t\t} else {\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_W, NULL);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_H, NULL);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_X, NULL);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CLAP_Y, NULL);\n\t\t}\n\n\t\tconst GF_MasteringDisplayColourVolumeInfo *mdcv = gf_isom_get_mastering_display_colour_info(ch->owner->mov, ch->track,ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t\tif (mdcv) {\n\t\t\tu8 *pdata;\n\t\t\tu32 psize, c;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\tfor(c=0;c<3;c++) {\n\t\t\t\tgf_bs_write_u16(bs, mdcv->display_primaries[c].x);\n\t\t\t\tgf_bs_write_u16(bs, mdcv->display_primaries[c].y);\n\t\t\t}\n\t\t\tgf_bs_write_u16(bs, mdcv->white_point_x);\n\t\t\tgf_bs_write_u16(bs, mdcv->white_point_y);\n\t\t\tgf_bs_write_u32(bs, mdcv->max_display_mastering_luminance);\n\t\t\tgf_bs_write_u32(bs, mdcv->min_display_mastering_luminance);\n\t\t\tgf_bs_get_content(bs, &pdata, &psize);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_MASTER_DISPLAY_COLOUR, &PROP_DATA_NO_COPY(pdata, psize));\n\t\t}\n\n\t\tconst GF_ContentLightLevelInfo *clli = gf_isom_get_content_light_level_info(ch->owner->mov, ch->track,ch->last_sample_desc_index ? ch->last_sample_desc_index : 1);\n\t\tif (clli) {\n\t\t\tu8 *pdata;\n\t\t\tu32 psize;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u16(bs, clli->max_content_light_level);\n\t\t\tgf_bs_write_u16(bs, clli->max_pic_average_light_level);\n\t\t\tgf_bs_get_content(bs, &pdata, &psize);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA_NO_COPY(pdata, psize));\n\t\t}\n\t}\n}\n\nvoid isor_update_channel_config(ISOMChannel *ch)\n{\n\tisor_declare_track(ch->owner, ch, ch->track, ch->last_sample_desc_index, ch->streamType, GF_FALSE);\n}\n\nGF_Err isor_declare_objects(ISOMReader *read)\n{\n\tconst u8 *tag;\n\tu32 tlen;\n\tu32 i, count, j, track_id;\n\tBool highest_stream;\n\tBool single_media_found = GF_FALSE;\n\tBool use_iod = GF_FALSE;\n\tBool tk_found = GF_FALSE;\n\tGF_Err e;\n\tBool isom_contains_video = GF_FALSE;\n\tGF_Descriptor *od = gf_isom_get_root_od(read->mov);\n\tif (od && gf_list_count(((GF_ObjectDescriptor*)od)->ESDescriptors)) {\n\t\tuse_iod = GF_TRUE;\n\t}\n\tif (od) gf_odf_desc_del(od);\n\n\t/*TODO\n\t check for alternate tracks\n    */\n\tcount = gf_isom_get_track_count(read->mov);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype, m_subtype, streamtype, stsd_idx;\n\n\t\tmtype = gf_isom_get_media_type(read->mov, i+1);\n\n\t\tif (read->tkid) {\n\t\t\tu32 for_id=0;\n\t\t\tif (sscanf(read->tkid, \"%d\", &for_id)) {\n\t\t\t\tu32 id = gf_isom_get_track_id(read->mov, i+1);\n\t\t\t\tif (id != for_id) continue;\n\t\t\t} else if (!strcmp(read->tkid, \"audio\")) {\n\t\t\t\tif (mtype!=GF_ISOM_MEDIA_AUDIO) continue;\n\t\t\t} else if (!strcmp(read->tkid, \"video\")) {\n\t\t\t\tif (mtype!=GF_ISOM_MEDIA_VISUAL) continue;\n\t\t\t} else if (!strcmp(read->tkid, \"text\")) {\n\t\t\t\tif ((mtype!=GF_ISOM_MEDIA_TEXT) && (mtype!=GF_ISOM_MEDIA_SUBT) && (mtype!=GF_ISOM_MEDIA_MPEG_SUBT)) continue;\n\t\t\t} else if (strlen(read->tkid)==4) {\n\t\t\t\tu32 t = GF_4CC(read->tkid[0], read->tkid[1], read->tkid[2], read->tkid[3]);\n\t\t\t\tif (mtype!=t) continue;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Bad format for tkid option %s, no match\\n\", read->tkid));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\ttk_found = GF_TRUE;\n\t\t}\n\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tstreamtype = GF_STREAM_AUDIO;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_QTVR:\n\t\t\tstreamtype = GF_STREAM_VISUAL;\n\t\t\tisom_contains_video = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\tcase GF_ISOM_MEDIA_SUBPIC:\n\t\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tcase GF_ISOM_MEDIA_CLOSED_CAPTION:\n\t\t\tstreamtype = GF_STREAM_TEXT;\n\t\t\tmtype = GF_ISOM_MEDIA_TEXT;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_FLASH:\n\t\tcase GF_ISOM_MEDIA_DIMS:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tstreamtype = GF_STREAM_SCENE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tstreamtype = GF_STREAM_OD;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_META:\n\t\tcase GF_ISOM_MEDIA_TIMECODE:\n\t\t\tstreamtype = GF_STREAM_METADATA;\n\t\t\tbreak;\n\t\t/*hint tracks are never exported*/\n\t\tcase GF_ISOM_MEDIA_HINT:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tif (!read->allt) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d type %s not supported, ignoring track - you may retry by specifying allt option\\n\", i+1, gf_4cc_to_str(mtype) ));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstreamtype = GF_STREAM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!read->alltk && !read->tkid && !gf_isom_is_track_enabled(read->mov, i+1)) {\n\t\t\tif (count>1) {\n\t\t\t\tu32 type = gf_isom_get_media_type(read->mov, i+1);\n\n\t\t\t\t//we don't warn for disabled text tracks due to chapters and forced subs\n\t\t\t\tif ((type==GF_ISOM_SUBTYPE_TEXT) || (type==GF_ISOM_MEDIA_SUBT))\n\t\t\t\t\tcontinue;\n\t\t\t\t//disabled tracks using QT chapter refs, do not warn\n\t\t\t\tif (gf_isom_is_track_referenced(read->mov, i+1, GF_ISOM_REF_CHAP)) continue;\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d is disabled, ignoring track - you may retry by specifying alltk option\\n\", i+1));\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track %d is disabled but single track in file, considering it enabled\\n\", i+1 ));\n\t\t\t}\n\t\t}\n\n\t\tstsd_idx = read->stsd ? read->stsd : 1;\n\t\t//some subtypes are not declared as readable objects\n\t\tm_subtype = gf_isom_get_media_subtype(read->mov, i+1, stsd_idx);\n\t\tswitch (m_subtype) {\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\tif (read->smode == MP4DMX_SINGLE)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t/*we declare only the highest video track (i.e the track we play)*/\n\t\thighest_stream = GF_TRUE;\n\t\ttrack_id = gf_isom_get_track_id(read->mov, i+1);\n\t\tif (read->play_only_track_id && (read->play_only_track_id != track_id)) continue;\n\n\t\tif (read->play_only_first_media) {\n\t\t\tif (read->play_only_first_media != mtype) continue;\n\t\t\tif (single_media_found) continue;\n\t\t\tsingle_media_found = GF_TRUE;\n\t\t}\n\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tif (gf_isom_has_track_reference(read->mov, j+1, GF_ISOM_REF_SCAL, track_id) > 0) {\n\t\t\t\thighest_stream = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (gf_isom_has_track_reference(read->mov, j+1, GF_ISOM_REF_BASE, track_id) > 0) {\n\t\t\t\thighest_stream = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((read->smode==MP4DMX_SINGLE) && (gf_isom_get_media_type(read->mov, i+1) == GF_ISOM_MEDIA_VISUAL) && !highest_stream)\n\t\t\tcontinue;\n\n\n\t\tisor_declare_track(read, NULL, i+1, stsd_idx, streamtype, use_iod);\n\n\t\tif (read->tkid)\n\t\t\tbreak;\n\t}\n\n\tif (!read->tkid) {\n\t\t/*declare image items*/\n\t\tcount = gf_isom_get_meta_item_count(read->mov, GF_TRUE, 0);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (! isor_declare_item_properties(read, NULL, i+1))\n\t\t\t\tcontinue;\n\n\t\t\tif (read->itt) break;\n\t\t}\n\t} else {\n\t\tif (!tk_found) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] TrackID %s not found in file\\n\", read->tkid ));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\tif (! gf_list_count(read->channels)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] No suitable tracks in file\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\t/*if cover art, declare a video pid*/\n\tif (gf_isom_apple_get_tag(read->mov, GF_ISOM_ITUNE_COVER_ART, &tag, &tlen)==GF_OK) {\n\n\t\t/*write cover data*/\n\t\tassert(!(tlen & 0x80000000));\n\t\ttlen &= 0x7FFFFFFF;\n\n\t\tif (read->expart && !isom_contains_video) {\n\t\t\tGF_FilterPid *cover_pid=NULL;\n\t\t\te = gf_filter_pid_raw_new(read->filter, NULL, NULL, NULL, NULL, (char *) tag, tlen, GF_FALSE, &cover_pid);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] error setting up video pid for cover art: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t\tif (cover_pid) {\n\t\t\t\tu8 *out_buffer;\n\t\t\t\tGF_FilterPacket *dst_pck;\n\t\t\t\tgf_filter_pid_set_property(cover_pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\t\t\t\tgf_filter_pid_set_name(cover_pid, \"CoverArt\");\n\t\t\t\tdst_pck = gf_filter_pck_new_alloc(cover_pid, tlen, &out_buffer);\n\t\t\t\tif (dst_pck) {\n\t\t\t\t\tgf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);\n\t\t\t\t\tmemcpy(out_buffer, tag, tlen);\n\t\t\t\t\tgf_filter_pck_send(dst_pck);\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_set_eos(cover_pid);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nBool isor_declare_item_properties(ISOMReader *read, ISOMChannel *ch, u32 item_idx)\n{\n\tGF_ImageItemProperties props;\n\tGF_FilterPid *pid;\n\tGF_ESD *esd;\n\tu32 item_id=0;\n\tu32 scheme_type=0, scheme_version=0, item_type;\n\tu32 item_codecid=0;\n\tconst char *item_name, *item_mime_type, *item_encoding;\n\nretry:\n\n\tif (item_idx>gf_isom_get_meta_item_count(read->mov, GF_TRUE, 0))\n\t\treturn GF_FALSE;\n\n\titem_name = item_mime_type = item_encoding = NULL;\n\tgf_isom_get_meta_item_info(read->mov, GF_TRUE, 0, item_idx, &item_id, &item_type, &scheme_type, &scheme_version, NULL, NULL, NULL, &item_name, &item_mime_type, &item_encoding);\n\n\tif (!item_id) return GF_FALSE;\n\tif (item_type==GF_ISOM_ITEM_TYPE_AUXI) return GF_FALSE;\n\tif (read->play_only_track_id && (read->play_only_track_id!=item_id)) return GF_FALSE;\n\n\tgf_isom_get_meta_image_props(read->mov, GF_TRUE, 0, item_id, &props, NULL);\n\n\t//check we support the protection scheme\n\tswitch (scheme_type) {\n\tcase GF_ISOM_CBC_SCHEME:\n\tcase GF_ISOM_CENS_SCHEME:\n\tcase GF_ISOM_CBCS_SCHEME:\n\tcase GF_ISOM_CENC_SCHEME:\n\tcase GF_ISOM_PIFF_SCHEME:\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\n\n\tesd = gf_media_map_item_esd(read->mov, item_id);\n\tif (!esd) {\n\t\tswitch (item_type) {\n\t\tcase GF_ISOM_SUBTYPE_HVT1:\n\t\t\titem_codecid = GF_CODECID_HEVC_TILES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//unsupported item, try next\n\t\t\titem_idx++;\n\t\t\tgoto retry;\n\t\t}\n\t} else {\n\t\titem_codecid = esd->decoderConfig->objectTypeIndication;\n\t}\n\n\t//OK declare PID\n\tif (!ch)\n\t\tpid = gf_filter_pid_new(read->filter);\n\telse {\n\t\tpid = ch->pid;\n\t\tch->item_id = item_id;\n\t}\n\n\n\t//do not override PID ID if itt is set\n\tif (!ch) {\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n\n\t//TODO: no support for LHEVC images\n\t//gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID));\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(item_codecid));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\tif (esd) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\t\tif (esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength));\n\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data=NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength=0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t}\n\n\tif (props.width && props.height) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_WIDTH, &PROP_UINT(props.width));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_HEIGHT, &PROP_UINT(props.height));\n\t}\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_HIDDEN, props.hidden ? &PROP_BOOL(GF_TRUE) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_ALPHA, props.alpha ? &PROP_BOOL(GF_TRUE) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_MIRROR, props.mirror ? &PROP_UINT(props.mirror) : NULL);\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_ROTATE, props.alpha ? &PROP_UINT(props.angle) : NULL);\n\n\tif (props.clap_wden) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_W, &PROP_FRAC_INT(props.clap_wnum,props.clap_wden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_H, &PROP_FRAC_INT(props.clap_hnum,props.clap_hden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_X, &PROP_FRAC_INT(props.clap_honum,props.clap_hoden) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_Y, &PROP_FRAC_INT(props.clap_vonum,props.clap_voden) );\n\t} else {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_W, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_H, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_X, NULL);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CLAP_Y, NULL);\n\t}\n\n\tif (gf_isom_get_meta_primary_item_id(read->mov, GF_TRUE, 0) == item_id) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PRIMARY_ITEM, &PROP_BOOL(GF_TRUE));\n\t} else {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PRIMARY_ITEM, &PROP_BOOL(GF_FALSE));\n\t}\n\n\tif (!gf_sys_is_test_mode() && !read->itt)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_NUM, &PROP_UINT(item_idx) );\n\n\tgf_filter_pid_set_property_str(pid, \"meta:mime\", item_mime_type ? &PROP_STRING(item_mime_type) : NULL );\n\tgf_filter_pid_set_property_str(pid, \"meta:name\", item_name ? &PROP_STRING(item_name) : NULL );\n\tgf_filter_pid_set_property_str(pid, \"meta:encoding\", item_encoding ? &PROP_STRING(item_encoding) : NULL );\n\n\tif ((item_type == GF_ISOM_SUBTYPE_UNCV) || (item_type == GF_ISOM_ITEM_TYPE_UNCI)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PIXFMT, &PROP_UINT(GF_PIXEL_UNCV) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW_UNCV) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ISOM_SUBTYPE,  &PROP_4CC(GF_ISOM_ITEM_TYPE_UNCI) );\n\t}\n\n\tif (item_codecid == GF_CODECID_HEVC_TILES) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_CROP_POS, &PROP_VEC2I_INT(props.hOffset, props.vOffset) );\n\n\t\tu32 base_id = gf_isom_meta_get_item_ref_id(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS, 1);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, base_id ? &PROP_UINT(base_id) : NULL );\n\t}\n\n\t//setup cenc\n\tif (scheme_type) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_4CC(scheme_type) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION, &PROP_UINT(scheme_version) );\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ENCRYPTED, &PROP_BOOL(GF_TRUE) );\n\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_ENCRYPTED) );\n\t}\n\n\tif (!ch) {\n\t\tch = isor_create_channel(read, pid, 0, item_id, GF_FALSE);\n\t\tif (ch && scheme_type) {\n\t\t\tch->is_cenc = 1;\n\t\t\tch->is_encrypted = 1;\n\n\t\t\tisor_declare_pssh(ch);\n\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n#endif // !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_MP4DMX)\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2017-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISOBMF mux filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/internal/media_dev.h>\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MP4MX)\n\n#define TEXT_DEFAULT_WIDTH\t400\n#define TEXT_DEFAULT_HEIGHT\t60\n#define TEXT_DEFAULT_FONT_SIZE\t18\n\n#define GF_VENDOR_GPAC\t\tGF_4CC('G','P','A','C')\n\n#define GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF (GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF+1)\n\n#define ISOM_FILE_EXT \"mp4|mpg4|m4a|m4i|3gp|3gpp|3g2|3gp2|iso|ismv|m4s|heif|heic|iff|avci|avif|mj2|mov|qt\"\n#define ISOM_FILE_MIME \"video/mp4|audio/mp4|application/mp4|video/3gpp|audio/3gpp|video/3gp2|audio/3gp2|video/iso.segment|audio/iso.segment|image/heif|image/heic|image/avci|video/jp2|video/quicktime\"\n\nenum{\n\tNALU_NONE,\n\tNALU_AVC,\n\tNALU_HEVC,\n\tNALU_VVC\n};\n\n\nenum\n{\n\tCENC_NONE=0,\n\tCENC_NEED_SETUP,\n\tCENC_SETUP_DONE,\n\tCENC_SETUP_ERROR\n};\n\nenum{\n\tTAG_NONE,\n\tTAG_STRICT,\n\tTAG_ALL\n};\n\nenum\n{\n\tXPS_IB_NO = 0,\n\tXPS_IB_PPS,\n\tXPS_IB_ALL,\n\tXPS_IB_BOTH,\n\tXPS_IB_MIX,\n\tXPS_IB_AUTO\n};\n\ntypedef struct\n{\n\tGF_FilterPid *ipid;\n\tu32 track_num, track_id;\n\tGF_ISOSample sample;\n\tu32 prev_duration;\n\n\tu32 src_timescale;\n\tu32 tk_timescale;\n\tu32 stream_type;\n\tu32 codecid;\n\tBool is_encrypted;\n\n\tu32 cfg_crc, enh_cfg_crc;\n\tu32 dep_id;\n\tu32 stsd_idx;\n\tu32 clear_stsd_idx;\n\tBool reused_stsd;\n\n\tBool use_dref;\n\tBool aborted;\n\tBool suspended;\n\tBool has_append;\n\tBool has_ctts;\n\ts64 min_neg_ctts;\n\tu32 nb_samples, samples_in_stsd;\n\tu32 nb_frames_per_sample;\n\tu64 ts_shift;\n\tu64 si_min_ts_plus_one;\n\tBool has_subs;\n\n\tBool skip_bitrate_update;\n\tBool has_open_gop;\n\tGF_FilterSAPType gdr_type;\n\n\tu32 media_profile_level;\n\n\tBool import_msg_header_done;\n\n\tu32 nal_unit_size;\n\n\tGF_AVCConfig *avcc, *svcc;\n\tGF_HEVCConfig *hvcc, *lvcc;\n\tGF_VVCConfig *vvcc;\n\n\tu8 *inband_hdr, *inband_hdr_non_rap;\n\tu32 inband_hdr_size, inband_hdr_non_rap_size;\n\tu32 is_nalu;\n\tBool is_av1, is_vpx;\n\tBool fragment_done;\n\ts32 ts_delay, negctts_shift;\n\tBool insert_tfdt, probe_min_ctts;\n\tu64 first_dts_in_seg_plus_one, next_seg_cts, cts_next;\n\ts64 tfdt_offset;\n\tu32 samples_in_frag;\n\tBool patch_tfdt;\n\n\t//0: not cenc, 1: needs setup of stsd entry, 2: setup done\n\tu32 cenc_state;\n\tBool cenc_subsamples;\n\tu32 scheme_type;\n\tu32 def_skip_byte_block, def_crypt_byte_block;\n\tu32 def_cenc_key_info_crc;\n\tconst GF_PropertyValue *cenc_ki;\n\tu32 cenc_key_info_crc;\n\tu32 constant_IV_size;\n\tBool cenc_multikey;\n\tBool cenc_frag_protected;\n\tu32 skip_byte_block, crypt_byte_block;\n\n\tBool fake_track;\n\n\tBool has_brands;\n\tBool force_inband_inject;\n\n\tu64 dur_in_frag;\n\n\tu32 amr_mode_set;\n\tBool has_seig;\n\tu64 empty_init_dur;\n\tu32 raw_audio_bytes_per_sample, raw_samplerate;\n\tu64 dts_patch;\n\n\tBool is_item;\n\tu32 item_id;\n\tchar status_type;\n\tu32 last_import_pc;\n\n\tu32 nb_frames, frame_offset;\n\tu64 down_bytes, down_size;\n\tGF_Fraction64 pid_dur;\n\t//for import message\n\tu64 prog_done, prog_total;\n\n\tu32 prev_tid_group;\n\n\tBool box_patched;\n\n\tu64 imported_edit_sdur, imported_edit_offset;\n\n\tBool force_ctts;\n\n\tBool is_hevc_tile_base;\n\tBool insert_pssh;\n\n\tBool wait_sap;\n\tu64 min_ts_seek_plus_one;\n\tu64 clamp_ts_plus_one;\n\tBool check_seek_ts;\n\n\tu64 max_cts, min_cts;\n\tu32 max_cts_samp_dur;\n\n\tu32 w_or_sr, h_or_ch, pf_or_af;\n\tu32 xps_inband;\n\n\tu8 *dyn_pssh;\n\tu32 dyn_pssh_len;\n\n\tBool sparse_inject;\n\tBool is_chap;\n\n\tGF_FilterPacket *dgl_copy;\n\tu32 all_stsd_crc;\n} TrackWriter;\n\nenum\n{\n\tMP4MX_MODE_INTER=0,\n\tMP4MX_MODE_FLAT,\n\tMP4MX_MODE_FASTSTART,\n\tMP4MX_MODE_TIGHT,\n\tMP4MX_MODE_FRAG,\n\tMP4MX_MODE_SFRAG,\n};\n\n\nenum\n{\n\tMP4MX_DASH_OFF=0,\n\tMP4MX_DASH_ON,\n\tMP4MX_DASH_VOD,\n};\n\nenum\n{\n\tMP4MX_PSSH_MOOV=0,\n\tMP4MX_PSSH_MOOF,\n\tMP4MX_PSSH_BOTH,\n\tMP4MX_PSSH_SKIP,\n};\n\nenum\n{\n\tMP4MX_CT_EDIT=0,\n\tMP4MX_CT_NOEDIT,\n\tMP4MX_CT_NEGCTTS,\n};\n\nenum\n{\n\tMP4MX_VODCACHE_ON=0,\n\tMP4MX_VODCACHE_INSERT,\n\tMP4MX_VODCACHE_REPLACE,\n};\n\nenum\n{\n\tMP4MX_CMAF_NO=0,\n\tMP4MX_CMAF_CMFC,\n\tMP4MX_CMAF_CMF2,\n};\n\nenum\n{\n\tMP4MX_CHAPM_OFF=0,\n\tMP4MX_CHAPM_TRACK,\n\tMP4MX_CHAPM_UDTA,\n\tMP4MX_CHAPM_BOTH\n};\n\nenum\n{\n\tMP4MX_UNCV_OFF=0,\n\tMP4MX_UNCV_NOPROF,\n\tMP4MX_UNCV_PROF,\n\tMP4MX_UNCV_PROF_ONLY\n};\n\n\ntypedef struct\n{\n\t//filter args\n\tGF_ISOFile *file;\n\tBool m4sys, dref;\n\tGF_Fraction dur;\n\tu32 pack3gp, ctmode;\n\tBool importer, pack_nal, moof_first, abs_offset, fsap, tfdt_traf, keep_utc, pps_inband;\n\tu32 xps_inband, moovpad;\n\tu32 block_size;\n\tu32 store, tktpl, mudta;\n\ts32 subs_sidx;\n\tGF_Fraction cdur;\n\ts32 moovts;\n\tchar *m4cc;\n\tBool chain_sidx;\n\tu32 msn, msninc;\n\tGF_Fraction64 tfdt;\n\tBool nofragdef, straf, strun, sgpd_traf, noinit;\n\tu32 vodcache;\n\tu32 psshs;\n\tu32 trackid;\n\tBool fragdur;\n\tBool btrt;\n\tBool ssix;\n\tBool ccst;\n\ts32 mediats;\n\tGF_AudioSampleEntryImportMode ase;\n\tchar *styp;\n\tBool sseg;\n\tBool noroll, norap;\n\tBool saio32, tfdt64;\n\tu32 compress;\n\tBool trun_inter;\n\tBool truns_first;\n\tchar *boxpatch;\n\tBool fcomp, otyp;\n\tBool deps;\n\tBool mvex;\n\tBool trunv1;\n\tu32 sdtp_traf;\n\tu32 cmaf;\n#ifdef GF_ENABLE_CTRN\n\tBool ctrn;\n\tBool ctrni;\n#endif\n\tBool mfra;\n\tu32 uncv;\n\tBool forcesync, refrag, pad_sparse;\n\tBool force_dv, tsalign, dvsingle, patch_dts;\n\tu32 itags;\n\tDouble start;\n\tu32 chapm;\n\n\n\t//internal\n\tGF_Filter *filter;\n\tBool owns_mov;\n\tGF_FilterPid *opid;\n\tBool first_pck_sent;\n\n\tGF_List *tracks;\n\n\tGF_BitStream *bs_r;\n\t//fragmentation state\n\tBool init_movie_done, fragment_started, segment_started, insert_tfdt, insert_pssh, cdur_set;\n\n\tu64 next_frag_start, adjusted_next_frag_start;\n\n\tu64 current_offset;\n\tu64 current_size;\n\n\tu32 nb_segs, nb_frags, nb_frags_in_seg;\n\n\tGF_FilterPacket *dst_pck;\n\tchar *seg_name;\n\tu32 dash_seg_num_plus_one;\n\tGF_Fraction64 dash_seg_start;\n\n\tBool flush_seg;\n\tu32 eos_marker;\n\tTrackWriter *ref_tkw;\n\tBool single_file;\n\tBool store_output;\n\tFILE *tmp_store;\n\tu64 flush_size, flush_done;\n\n\tu32 dash_mode, llhls_mode;\n\tGF_Fraction dash_dur;\n\tDouble media_dur;\n\tu32 sidx_max_size, sidx_chunk_offset;\n\tBool final_sidx_flush;\n\tBool sidx_size_exact;\n\n\tu32 *seg_sizes;\n\tu32 nb_seg_sizes, alloc_seg_sizes, config_retry_start;\n\tBool config_timing;\n\n\tu32 major_brand_set;\n\tBool def_brand_patched;\n\n\tBool force_play;\n\n\tBool moov_inserted;\n\tBool update_report;\n\tu64 total_bytes_in, total_bytes_out;\n\tu32 total_samples, last_mux_pc;\n\n\tu32 maxchunk;\n\tu32 make_qt;\n\tTrackWriter *prores_track;\n\n\tGF_SegmentIndexBox *cloned_sidx;\n\tu32 cloned_sidx_index;\n\tGF_Fraction faststart_ts_regulate;\n\n\tBool is_rewind;\n\tBool box_patched;\n\tu32 cur_file_idx_plus_one;\n\tchar *cur_file_suffix;\n\tBool notify_filename;\n\n\tu32 next_file_idx;\n\tconst char *next_file_suffix;\n\n\t//for route scheduling\n\tu64 min_cts_plus_one, next_seg_start;\n\tu64 min_cts_next_frag;\n\n\tu64 frag_size, frag_offset;\n\tu32 frag_num;\n\tu64 frag_duration;\n\tu32 frag_timescale;\n\tBool frag_has_intra;\n\n\tu64 wait_dts_plus_one;\n\tu32 wait_dts_timescale;\n\tBool force_seg_sync;\n\tu32 seg_flush_state;\n\tu64 flush_idx_start_range, flush_idx_end_range;\n\tBool flush_ll_hls;\n\n\tBool has_def_vid, has_def_aud, has_def_txt;\n\n\t//created from chapters prop\n\tu32 chap_track_num;\n\tBool has_chap_tracks;\n\n\tGF_List *ref_pcks;\n} GF_MP4MuxCtx;\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust);\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw);\n\nstatic GF_Err mp4mx_setup_dash_vod(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tif (tkw) {\n\t\tconst GF_PropertyValue *p;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_DUR);\n\t\tif (p) {\n\t\t\tctx->dash_dur = p->value.frac;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\tDouble mdur = (Double) p->value.lfrac.num;\n\t\t\tif (mdur<0) mdur = -mdur;\n\t\t\tmdur /= p->value.lfrac.den;\n\t\t\tif (ctx->media_dur < mdur) ctx->media_dur = mdur;\n\t\t}\n\t}\n\tctx->dash_mode = MP4MX_DASH_VOD;\n\tctx->llhls_mode = 0;\n\tif ((ctx->vodcache==MP4MX_VODCACHE_ON) && !ctx->tmp_store) {\n\t\tctx->tmp_store = gf_file_temp(NULL);\n\t\tif (!ctx->tmp_store) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot allocate temp file for VOD sidx generation\\n\"));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tif (!ctx->block_size) ctx->block_size = 10000;\n\t}\n\n\treturn GF_OK;\n}\n\n\nstatic u32 gf_isom_stream_type_to_media_type(u32 stream_type, u32 codecid)\n{\n\tswitch (stream_type) {\n\tcase GF_STREAM_SCENE: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_OD: return GF_ISOM_MEDIA_OD;\n\tcase GF_STREAM_OCR: return GF_ISOM_MEDIA_OCR;\n\tcase GF_STREAM_OCI: return GF_ISOM_MEDIA_OCI;\n\tcase GF_STREAM_MPEG7: return GF_ISOM_MEDIA_MPEG7;\n\tcase GF_STREAM_METADATA: return GF_ISOM_MEDIA_META;\n\tcase GF_STREAM_VISUAL: return GF_ISOM_MEDIA_VISUAL;\n\tcase GF_STREAM_AUDIO: return GF_ISOM_MEDIA_AUDIO;\n\tcase GF_STREAM_TEXT:\n\t\tif (codecid==GF_ISOM_SUBTYPE_STPP)\n\t\t\treturn GF_ISOM_MEDIA_MPEG_SUBT;\n\t\tif (codecid == GF_CODECID_SUBPIC)\n\t\t\treturn GF_ISOM_MEDIA_SUBPIC;\n\t\treturn GF_ISOM_MEDIA_TEXT;\n\tcase GF_STREAM_INTERACT: return GF_ISOM_MEDIA_SCENE;\n\tcase GF_STREAM_IPMP: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_MPEGJ: return GF_ISOM_MEDIA_MPEGJ;\n\tcase GF_STREAM_IPMP_TOOL: return GF_ISOM_MEDIA_IPMP;\n\tcase GF_STREAM_FONT: return GF_ISOM_MEDIA_MPEGJ;//TOCHECK !!\n\n\tcase GF_STREAM_PRIVATE_SCENE:\n\tcase GF_STREAM_ENCRYPTED:\n\tcase GF_STREAM_FILE:\n\t\treturn 0;\n\tdefault:\n\t\treturn stream_type;\n\t}\n\treturn 0;\n}\n\nstatic void mp4_mux_write_ps_list(GF_BitStream *bs, GF_List *list, u32 nalu_size_length)\n{\n\tu32 i, count = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = gf_list_get(list, i);\n\t\tgf_bs_write_int(bs, sl->size, 8*nalu_size_length);\n\t\tgf_bs_write_data(bs, sl->data, sl->size);\n\t}\n}\n\nstatic GF_List *mp4_mux_get_nalus_ps(GF_List *list, u8 type)\n{\n\tu32 i, count = gf_list_count(list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParamArray *pa = gf_list_get(list, i);\n\t\tif (pa->type == type) return pa->nalus;\n\t}\n\treturn NULL;\n}\n\nstatic void mp4_mux_make_inband_header(GF_MP4MuxCtx *ctx, TrackWriter *tkw, Bool for_non_rap)\n{\n\tGF_BitStream *bs;\n\tif (for_non_rap) {\n\t\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\t\ttkw->inband_hdr_non_rap = NULL;\n\t} else {\n\t\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\t\ttkw->inband_hdr = NULL;\n\t}\n\n\ttkw->nal_unit_size = 0;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (tkw->avcc || tkw->svcc) {\n\t\tif (tkw->avcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSets, tkw->avcc->nal_unit_size);\n\t\t\t/*if (!tkw->nal_unit_size) */tkw->nal_unit_size = tkw->avcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->svcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSets, tkw->svcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->svcc->nal_unit_size;\n\t\t}\n\n\t\tif (tkw->avcc && tkw->avcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->sequenceParameterSetExtensions, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc && tkw->svcc->sequenceParameterSetExtensions && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->sequenceParameterSetExtensions, tkw->svcc->nal_unit_size);\n\n\t\tif (tkw->avcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->avcc->pictureParameterSets, tkw->avcc->nal_unit_size);\n\n\t\tif (tkw->svcc)\n\t\t\tmp4_mux_write_ps_list(bs, tkw->svcc->pictureParameterSets, tkw->svcc->nal_unit_size);\n\t}\n\tif (tkw->hvcc || tkw->lvcc) {\n\t\tif (tkw->hvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->hvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->hvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tif (!for_non_rap)\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_VID_PARAM), tkw->lvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->lvcc->nal_unit_size;\n\t\t}\n\t\tif (tkw->hvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc && !for_non_rap)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_SEQ_PARAM), tkw->lvcc->nal_unit_size);\n\t\tif (tkw->hvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->hvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->hvcc->nal_unit_size);\n\t\tif (tkw->lvcc)\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->lvcc->param_array, GF_HEVC_NALU_PIC_PARAM), tkw->lvcc->nal_unit_size);\n\t}\n\n\tif (tkw->vvcc) {\n\t\tif (tkw->xps_inband==XPS_IB_PPS) {\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t} else {\n\t\t\tif (!for_non_rap) {\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_OPI), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_DEC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_VID_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_SEQ_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\t}\n\t\t\tif (!tkw->nal_unit_size) tkw->nal_unit_size = tkw->vvcc->nal_unit_size;\n\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_PIC_PARAM), tkw->vvcc->nal_unit_size);\n\t\t\tmp4_mux_write_ps_list(bs, mp4_mux_get_nalus_ps(tkw->vvcc->param_array, GF_VVC_NALU_APS_PREFIX), tkw->vvcc->nal_unit_size);\n\t\t}\n\t}\n\n\tif (for_non_rap) {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr_non_rap, &tkw->inband_hdr_non_rap_size);\n\t} else {\n\t\tgf_bs_get_content(bs, &tkw->inband_hdr, &tkw->inband_hdr_size);\n\t}\n\tgf_bs_del(bs);\n\t//we may have cases where the param sets are updated before a non-IDR/SAP3 picture, we must inject asap at least once\n\ttkw->force_inband_inject = GF_TRUE;\n}\n\nvoid mp4_mux_get_video_size(GF_MP4MuxCtx *ctx, u32 *width, u32 *height)\n{\n\tu32 w, h, f_w, f_h, i;\n\n\tf_w = f_h = 0;\n\tfor (i=0; i<gf_isom_get_track_count(ctx->file); i++) {\n\t\tswitch (gf_isom_get_media_type(ctx->file, i+1)) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tgf_isom_get_visual_info(ctx->file, i+1, 1, &w, &h);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\t//fallthrough\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\t\tgf_isom_get_track_layout_info(ctx->file, i+1, &w, &h, NULL, NULL, NULL);\n\t\t\tif (w > f_w) f_w = w;\n\t\t\tif (h > f_h) f_h = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\t(*width) = f_w ? f_w : TEXT_DEFAULT_WIDTH;\n\t(*height) = f_h ? f_h : TEXT_DEFAULT_HEIGHT;\n}\n\nstatic void mp4_mux_track_writer_del(TrackWriter *tkw)\n{\n\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\tif (tkw->inband_hdr) gf_free(tkw->inband_hdr);\n\tif (tkw->inband_hdr_non_rap) gf_free(tkw->inband_hdr_non_rap);\n\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\tif (tkw->dgl_copy) gf_filter_pck_discard(tkw->dgl_copy);\n\tgf_free(tkw);\n}\n\nstatic void mp4_mux_write_track_refs(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const char *rname, u32 rtype, Bool remove_from_pres)\n{\n\tu32 i;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(tkw->ipid, rname);\n\tif (!p) return;\n\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, rtype, p->value.uint_list.vals[i]);\n\t\tif (remove_from_pres) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t}\n\t}\n}\n\nstatic void mp4mux_track_reorder(void *udta, u32 old_track_num, u32 new_track_num)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) udta;\n\tu32 i, count;\n\n\tif (ctx->chap_track_num==old_track_num) {\n\t\tctx->chap_track_num = new_track_num;\n\t\treturn;\n\t}\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\tif (tkw->track_num==old_track_num) {\n\t\t\ttkw->track_num = new_track_num;\n\t\t\t//prevent any further changes, trackID is restored in mp4mux_reorder_tracks\n\t\t\ttkw->track_id = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void mp4mux_reorder_tracks(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, count, prev_num, prev_pos;\n\tGF_List *new_tracks = gf_list_new();\n\tprev_num = prev_pos = 0;\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id)\n\t\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tif (tkw->track_num<prev_num) {\n\t\t\tgf_list_insert(new_tracks, tkw, prev_pos);\n\t\t} else {\n\t\t\tgf_list_add(new_tracks, tkw);\n\t\t}\n\t\tprev_pos = gf_list_count(new_tracks) - 1;\n\t\tprev_num = tkw->track_num;\n\t}\n\tif (gf_list_count(new_tracks)!=count) {\n\t\tgf_list_del(new_tracks);\n\t\treturn;\n\t}\n\tgf_list_del(ctx->tracks);\n\tctx->tracks = new_tracks;\n}\n\nstatic void mp4mx_set_track_group(GF_MP4MuxCtx *ctx, TrackWriter *tkw, char *name, const GF_PropertyValue *p)\n{\n\ts32 grp_id=0;\n\tu32 grp_type;\n\tu32 len = (u32) strlen(name);\n\tBool do_add=GF_TRUE;\n\tif (len!=4) return;\n\n\tif ((p->type==GF_PROP_STRING) || (p->type==GF_PROP_NAME)) {\n\t\tgrp_id = atoi(p->value.string);\n\t} else {\n\t\tgrp_id = p->value.sint;\n\t}\n\tif (grp_id<0) {\n\t\tgrp_id = -grp_id;\n\t\tdo_add = GF_FALSE;\n\t}\n\tgrp_type = GF_4CC(name[0], name[1], name[2], name[3]);\n\tgf_isom_set_track_group(ctx->file, tkw->track_num, grp_id, grp_type, do_add);\n}\n\n\n#include <gpac/revision.h>\nstatic void mp4_mux_set_tags(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\n\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat() ) {\n\t\tconst char *tool = \"GPAC-\"GPAC_VERSION\"-rev\"GPAC_GIT_REVISION;\n\t\tu32 len = (u32) strlen(tool);\n\t\tgf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_TOOL, tool, len, 0, 0);\n\t}\n\n\tif (ctx->itags==TAG_NONE) return;\n\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 len;\n\t\tu32 prop_4cc=0;\n\t\tu32 itag;\n\t\ts32 tag_idx;\n\t\tconst char *tag_name=NULL;\n\t\tconst GF_PropertyValue *tag = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &tag_name);\n\t\tif (!tag) break;\n\n\t\tif (prop_4cc==GF_PROP_PID_COVER_ART) {\n\t\t\te = gf_isom_apple_set_tag(ctx->file, GF_ISOM_ITUNE_COVER_ART, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set cover art: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t}\n\t\tif (!tag_name)\n\t\t\tcontinue;\n\n\t\tif (!strncmp(tag_name, \"tkgp_\", 5)) {\n\t\t\tmp4mx_set_track_group(ctx, tkw, (char*) tag_name+5, tag);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttag_idx = gf_itags_find_by_name(tag_name);\n\t\tif (tag_idx>=0) {\n\t\t\titag = gf_itags_get_itag(tag_idx);\n\t\t} else if (!strnicmp(tag_name, \"qtt_\", 4)) {\n\t\t\ttag_name += 4;\n\n\t\t\tswitch (tag->type) {\n\t\t\tcase GF_PROP_DATA:\n\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\t{\n\t\t\t\tGF_QT_UDTAKey key;\n\t\t\t\tkey.type = GF_QT_KEY_OPAQUE;\n\t\t\t\tkey.name = tag_name;\n\t\t\t\tkey.ns = GF_4CC('m','d','t','a');\n\t\t\t\tchar *sep = strchr(tag_name, '@');\n\t\t\t\tif (sep) {\n\t\t\t\t\tkey.name = sep+1;\n\t\t\t\t\tkey.ns = GF_4CC(tag_name[0], tag_name[1],tag_name[2],tag_name[3]);\n\t\t\t\t}\n\t\t\t\tkey.value.data.data = tag->value.data.ptr;\n\t\t\t\tkey.value.data.data_len = tag->value.data.size;\n\t\t\t\te = gf_isom_set_qt_key(ctx->file, &key);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_POINTER:\n\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\t\t\t\tconst char *str = gf_props_dump_val(tag, szDump, GF_PROP_DUMP_DATA_NONE, NULL);\n\t\t\t\te = gf_media_isom_apply_qt_key(ctx->file, tag_name, str);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set QT tag: %s\\n\", gf_error_to_string(e)));\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (ctx->itags==TAG_STRICT)\n\t\t\t\tcontinue;\n\n\t\t\tif (strnicmp(tag_name, \"tag_\", 4))\n\t\t\t\tcontinue;\n\n\t\t\ttag_name += 4;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized tag %s: %s\\n\", tag_name, tag->value.string));\n\n\t\t\tif (strlen(tag_name)==4) {\n\t\t\t\titag = GF_4CC(tag_name[0], tag_name[1], tag_name[2], tag_name[3]);\n\t\t\t} else if (strlen(tag_name)==3) {\n\t\t\t\titag = GF_4CC(0xA9, tag_name[0], tag_name[1], tag_name[2]);\n\t\t\t} else {\n\t\t\t\titag = gf_crc_32(tag_name, (u32) strlen(tag_name));\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] Tag name %s is not a 4CC, using CRC32 %08X as value\\n\", tag_name, itag));\n\t\t\t}\n\t\t}\n\n\t\tif (itag==GF_ISOM_ITUNE_TOOL) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (tag->type) {\n\t\tcase GF_PROP_STRING:\n\t\tcase GF_PROP_NAME:\n\t\t\tlen = tag->value.string ? (u32) strlen(tag->value.string) : 0;\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.string, len, 0, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_BOOL:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.boolean, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_UINT:\n\t\tcase GF_PROP_4CC:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.uint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_LUINT:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.longuint, 0);\n\t\t\tbreak;\n\t\tcase GF_PROP_FRACTION:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, NULL, 0, tag->value.frac.num, tag->value.frac.den);\n\t\t\tbreak;\n\t\tcase GF_PROP_DATA:\n\t\tcase GF_PROP_CONST_DATA:\n\t\t\te = gf_isom_apple_set_tag(ctx->file, itag, tag->value.data.ptr, tag->value.data.size, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: invalid data format\\n\", gf_itags_get_name(tag_idx) ));\n\t\t\te = GF_OK;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set tag %s: %s\\n\", tag_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void mp4_mux_set_udta(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 idx=0;\n\twhile (1) {\n\t\tGF_Err e;\n\t\tu32 prop_4cc=0;\n\t\tconst char *udta_name=NULL;\n\t\tconst GF_PropertyValue *udta = gf_filter_pid_enum_properties(tkw->ipid, &idx, &prop_4cc, &udta_name);\n\t\tif (!udta) break;\n\t\tif (!udta_name)\n\t\t\tcontinue;\n\t\tif (!strncmp(udta_name, \"udta_\", 5) || !strncmp(udta_name, \"mudta_\", 6) ) {\n\t\t\tu32 udta_type;\n\t\t\tu8 *data=NULL;\n\t\t\tu32 size=0;\n\t\t\tu32 track_num = 0;\n\n\t\t\tif (!strncmp(udta_name, \"udta_\", 5)) {\n\t\t\t\tudta_name += 5;\n\t\t\t\ttrack_num = tkw->track_num;\n\t\t\t} else {\n\t\t\t\tudta_name += 6;\n\t\t\t}\n\n\t\t\tif (strlen(udta_name) != 4) continue;\n\t\t\tudta_type = GF_4CC(udta_name[0], udta_name[1], udta_name[2], udta_name[3]);\n\n\t\t\tif (udta->type==GF_PROP_DATA) {\n\t\t\t\tdata = (u8 *) udta->value.data.ptr;\n\t\t\t\tsize = udta->value.data.size;\n\t\t\t} else if ((udta->type == GF_PROP_STRING) && udta->value.string) {\n\t\t\t\tdata = (u8 *) udta->value.string;\n\t\t\t\tsize = (u32) strlen(udta->value.string)+1;\n\t\t\t}\n\t\t\tif (!data) {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_user_data(ctx->file, track_num, udta_type, NULL, data, size);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(udta_name, \"udtab\") || !strcmp(udta_name, \"mudtab\")) {\n\t\t\tu32 track_num = (!strcmp(udta_name, \"mudtab\")) ? 0 : tkw->track_num;\n\t\t\tif (udta->type == GF_PROP_DATA) {\n\t\t\t\te = gf_isom_add_user_data_boxes(ctx->file, track_num, udta->value.data.ptr, udta->value.data.size);\n\t\t\t} else {\n\t\t\t\te = GF_BAD_PARAM;\n\t\t\t}\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set udta %s: %s\\n\", udta_name, gf_error_to_string(e)));\n\t\t}\n\t}\n}\n\nstatic void update_chap_refs(GF_MP4MuxCtx *ctx)\n{\n\tu32 i, j, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->is_chap) continue;\n\t\tfor (j=0; j<count; j++) {\n\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\tif (atkw->is_chap) continue;\n\t\t\tif ((atkw->stream_type==GF_STREAM_AUDIO) || (atkw->stream_type==GF_STREAM_VISUAL))\n\t\t\t\tgf_isom_set_track_reference(ctx->file, atkw->track_num, GF_ISOM_REF_CHAP, tkw->track_id);\n\t\t}\n\t}\n}\n\n\n\nstatic GF_Err mp4_mux_setup_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_true_pid)\n{\n\tvoid mux_assign_mime_file_ext(GF_FilterPid *ipid, GF_FilterPid *opid, const char *file_exts, const char *mime_types, const char *def_ext);\n\tBool use_m4sys = GF_FALSE;\n\tBool use_tx3g = GF_FALSE;\n\tBool use_webvtt = GF_FALSE;\n\tBool needs_track = GF_FALSE;\n\tu32 needs_sample_entry = 0; //1: change of codecID, 2 change of decoder config\n\tBool use_gen_sample_entry = GF_FALSE;\n\tBool skip_crypto = GF_FALSE;\n\tBool use_3gpp_config = GF_FALSE;\n\tBool use_ac3_entry = GF_FALSE;\n\tBool use_flac_entry = GF_FALSE;\n\tBool use_avc = GF_FALSE;\n\tBool use_hevc = GF_FALSE;\n\tBool use_vvc = GF_FALSE;\n\tBool use_hvt1 = GF_FALSE;\n\tBool use_av1 = GF_FALSE;\n\tBool use_vpX = GF_FALSE;\n\tBool use_mj2 = GF_FALSE;\n\tBool use_opus = GF_FALSE;\n\tBool use_dref = GF_FALSE;\n\tBool skip_dsi = GF_FALSE;\n\tBool is_text_subs = GF_FALSE;\n\tBool force_colr = GF_FALSE;\n\tu32 gen_dsi_wrap = 0;\n\tu32 m_subtype=0;\n\tu32 m_subtype_src=0;\n\tu32 m_subtype_alt_raw=0;\n\tu32 override_stype=0;\n\tu32 width, height, sr, nb_chan, nb_bps, z_order, txt_fsize;\n\tu32 afmt_flags = 0;\n\tu64 ch_layout;\n\tGF_Fraction fps, sar;\n\tGF_List *multi_pid_stsd = NULL;\n\tu32 multi_pid_idx = 0;\n\tGF_FilterPid *orig_pid = NULL;\n\tu32 codec_id, pix_fmt=0;\n\tu32 frames_per_sample_backup=0;\n\tu32 is_nalu_backup = NALU_NONE;\n\tBool is_tile_base = GF_FALSE;\n\tBool unknown_generic = GF_FALSE;\n\tu32 multi_pid_final_stsd_idx = 0;\n\tu32 audio_pli=0;\n\tu32 prev_codecid=0;\n\tBool force_tk_layout = GF_FALSE;\n\tBool force_mix_xps = GF_FALSE;\n\tBool make_inband_headers = GF_FALSE;\n\tBool is_prores = GF_FALSE;\n\tconst char *lang_name = NULL;\n\tconst char *comp_name = NULL;\n\tconst char *imp_name = NULL;\n\tconst char *src_url = NULL;\n\tconst char *meta_mime = NULL;\n\tconst char *meta_encoding = NULL;\n\tconst char *meta_config = NULL;\n\tconst char *meta_xmlns = NULL;\n\tconst char *meta_schemaloc = NULL;\n\tconst char *meta_auxmimes = NULL;\n\tconst char *meta_content_encoding = NULL;\n\tchar *txt_font = NULL;\n\n\tu32 i, count, reuse_stsd = 0;\n\tGF_Err e;\n\tconst GF_PropertyValue *dsi=NULL;\n\tconst GF_PropertyValue *enh_dsi=NULL;\n\tconst GF_PropertyValue *p;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tGF_AudioSampleEntryImportMode ase_mode = ctx->ase;\n\tTrackWriter *tkw;\n\tu32 xps_inband = XPS_IB_NO;\n\n\tif (ctx->owns_mov && !ctx->opid) {\n\t\tchar *dst;\n\t\tctx->opid = gf_filter_pid_new(filter);\n\n\t\tdst = gf_filter_get_dst_name(filter);\n\t\tif (dst) {\n\t\t\tchar *ext = gf_file_ext_start(dst);\n\t\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\t\tctx->make_qt = 1;\n\t\t\t}\n\t\t\tgf_free(dst);\n\t\t}\n\t} else {\n\t\tconst char *fname = gf_isom_get_filename(ctx->file);\n\t\tchar *ext = fname ? gf_file_ext_start(fname) : NULL;\n\t\tif (ext && (!stricmp(ext, \".mov\") || !stricmp(ext, \".qt\")) ) {\n\t\t\tctx->make_qt = 1;\n\t\t}\n\t}\n\t//copy properties at init or reconfig\n\tif (ctx->opid && is_true_pid) {\n\t\tgf_filter_pid_copy_properties(ctx->opid, pid);\n\t\tif (gf_list_count(ctx->tracks)>1)\n\t\t\tgf_filter_pid_set_name(ctx->opid, \"isobmf_mux\");\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\n\t\tmux_assign_mime_file_ext(pid, ctx->opid, ISOM_FILE_EXT, ISOM_FILE_MIME, NULL);\n\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DASH_MODE, NULL);\n\t\t//we dispatch timing in milliseconds\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(1000));\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_FLAT:\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\tgf_filter_pid_allow_direct_dispatch(ctx->opid);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\tif (p && p->value.boolean)\n\t\tis_tile_base = GF_TRUE;\n\n\tif (is_true_pid && !is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tu32 j, count2;\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tconst GF_PropertyValue *a_pidid = gf_filter_pid_get_property(a_ipid, GF_PROP_PID_ID);\n\t\t\t\tcount2 = gf_list_count(ctx->tracks);\n\t\t\t\tfor (j=0; j<count2; j++) {\n\t\t\t\t\tTrackWriter *atkw = gf_list_get(ctx->tracks, j);\n\t\t\t\t\tconst GF_PropertyValue *c_pidid = gf_filter_pid_get_property(atkw->ipid, GF_PROP_PID_ID);\n\t\t\t\t\tif (gf_props_equal(a_pidid, c_pidid)) {\n\t\t\t\t\t\ta_ipid = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a_ipid)\n\t\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\taudio_pli = gf_isom_get_pl_indication(ctx->file, GF_ISOM_PL_AUDIO);\n\n\t//new pid ?\n\ttkw = gf_filter_pid_get_udta(pid);\n\tif (!tkw) {\n\t\tGF_FilterEvent evt;\n\t\tGF_SAFEALLOC(tkw, TrackWriter);\n\t\tif (!tkw) return GF_OUT_OF_MEM;\n\n\t\tgf_list_add(ctx->tracks, tkw);\n\t\ttkw->ipid = pid;\n\t\ttkw->fake_track = !is_true_pid;\n\t\ttkw->min_cts = (u64) -1;\n\n\t\tif (is_true_pid) {\n\t\t\tgf_filter_pid_set_udta(pid, tkw);\n\n\t\t\ttkw->is_hevc_tile_base = is_tile_base;\n#ifdef GPAC_ENABLE_COVERAGE\n\t\t\tif (gf_sys_is_cov_mode()) {\n\t\t\t\tgf_filter_pid_get_min_pck_duration(pid);\n\t\t\t}\n#endif\n\t\t\tif (!ctx->owns_mov || ctx->force_play) {\n\t\t\t\tif (!ctx->owns_mov) {\n\t\t\t\t\tif (ctx->start != 0)\n\t\t\t\t\t\ttkw->wait_sap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_init_play_event(pid, &evt, ctx->start, 0, \"MP4Mux\");\n\t\t\t\t} else {\n\t\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_send_event(pid, &evt);\n\t\t\t}\n\t\t\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ITEM_ID);\n\t\t\tif (p) {\n\t\t\t\ttkw->is_item = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tctx->config_timing = GF_TRUE;\n\t\t\t\tctx->update_report = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check change of pid config\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->dep_id) needs_track = GF_TRUE;\n\t\ttkw->dep_id = p->value.uint;\n\t}\n\n\t//check change of pid config\n\tprev_codecid = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\tif (p) {\n\t\tif (p->value.uint!=tkw->codecid) needs_sample_entry = 1;\n\t\ttkw->codecid = p->value.uint;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);\n\tif (p) {\n\t\tu32 stype = p->value.uint;\n\t\tif (tkw->is_encrypted && (p->value.uint==GF_STREAM_ENCRYPTED) ) {\n\t\t\tstype = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tif (stype != tkw->stream_type) {\n\t\t\tneeds_track = GF_TRUE;\n\t\t\ttkw->stream_type = stype;\n\t\t\tconst char *name = gf_stream_type_name(stype);\n\t\t\ttkw->status_type = name ? name[0] : 'U';\n\t\t}\n\t}\n\n\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\tif (dsi) {\n\t\tu32 cfg_crc = gf_crc_32(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->cfg_crc = cfg_crc;\n\t} else if (tkw->cfg_crc) {\n\t\ttkw->cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tif (enh_dsi && (enh_dsi->type==GF_PROP_DATA) ) {\n\t\tu32 cfg_crc = gf_crc_32(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\tif ((cfg_crc!=tkw->enh_cfg_crc) && !needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t\ttkw->enh_cfg_crc = cfg_crc;\n\t} else if (tkw->enh_cfg_crc) {\n\t\ttkw->enh_cfg_crc = 0;\n\t\tif (!needs_sample_entry)\n\t\t\tneeds_sample_entry = 2;\n\t}\n\n\t//store current cenc pattern if any\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\tif (p) {\n\t\ttkw->skip_byte_block = p->value.frac.num;\n\t\ttkw->crypt_byte_block = p->value.frac.den;\n\t} else {\n\t\ttkw->skip_byte_block = tkw->crypt_byte_block = 0;\n\t}\n\n\t//TODO: try to merge PPS/SPS for AVC and HEVC rather than creating a new sample description\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\tcase GF_CODECID_USAC:\n\tcase GF_CODECID_MPEG4_PART2:\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\tcase GF_CODECID_VP8:\n\tcase GF_CODECID_VP9:\n\tcase GF_CODECID_AV1:\n\tcase GF_CODECID_AC3:\n\tcase GF_CODECID_EAC3:\n\tcase GF_CODECID_OPUS:\n\tcase GF_CODECID_TRUEHD:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_APCH:\n\tcase GF_CODECID_APCO:\n\tcase GF_CODECID_APCN:\n\tcase GF_CODECID_APCS:\n\tcase GF_CODECID_AP4X:\n\tcase GF_CODECID_AP4H:\n\t\tif (!ctx->make_qt) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (\"[MP4Mux] ProRes track detected, muxing to QTFF even though ISOBMFF was asked\\n\"));\n\t\t\tctx->make_qt = 2;\n\t\t}\n\t\tif (ctx->prores_track && (ctx->prores_track != tkw)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] More than one ProRes track detected, result might be non compliant\\n\"));\n\t\t}\n\t\tis_prores = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_TX3G:\n\tcase GF_CODECID_WEBVTT:\n\tcase GF_CODECID_DVB_SUBS:\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) return GF_OK;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (!tkw->track_num) {\n\t\tneeds_sample_entry = 1;\n\t\tneeds_track = GF_TRUE;\n\t}\n\n\tif (ctx->make_qt) {\n\t\tgf_isom_remove_root_od(ctx->file);\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_QT, 512);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\ttkw->has_brands = GF_TRUE;\n\t\tctx->major_brand_set = GF_ISOM_BRAND_QT;\n\t\tctx->btrt = GF_FALSE;\n\n\t\tif (is_prores && !ctx->prores_track) {\n\t\t\tctx->prores_track = tkw;\n\t\t}\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\tif (p) src_url = p->value.string;\n\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MODE);\n\tif (p) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t\tif (p->value.uint==2) {\n\t\t\te = mp4mx_setup_dash_vod(ctx, tkw);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\t//we consider that when muxing single segments, we are always in DASH, not VoD mode\n\telse if (ctx->noinit) {\n\t\tctx->dash_mode = MP4MX_DASH_ON;\n\t}\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LLHLS);\n\tctx->llhls_mode = p ? p->value.uint : 0;\n\t//insert tfdt in each traf for LL-HLS so that correct timing can be found when doing in-segment tune-in\n\tif (ctx->llhls_mode) {\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\tctx->store = MP4MX_MODE_SFRAG;\n\t}\n\n\tif (ctx->dash_mode == MP4MX_DASH_ON) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FORCE_SEG_SYNC);\n\t\tif (p && p->value.boolean)\n\t\t\tctx->force_seg_sync = GF_TRUE;\n\t}\n\n\tif (!ctx->cdur_set) {\n\t\tctx->cdur_set = GF_TRUE;\n\t\tif (ctx->cdur.num<0) {\n\t\t\tif (ctx->make_qt) {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 2000;\n\t\t\t} else {\n\t\t\t\tctx->cdur.num = 1000;\n\t\t\t\tctx->cdur.den = 1000;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->fragdur = GF_FALSE;\n\t\t\t}\n\t\t} else if (ctx->dash_mode)\n\t\t\tctx->fragdur = GF_TRUE;\n\t}\n\n\tif (needs_track) {\n\t\tif (ctx->init_movie_done) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add track to already finalized movie in fragmented file, will request a new muxer for that track\\n\"));\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (tkw->is_item) {\n\t\t\tneeds_track = GF_FALSE;\n\n\t\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t\t\ttkw->insert_pssh = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (needs_track) {\n\t\tu32 tkid=0;\n\t\tu32 tk_idx=0;\n\t\tu32 mtype=0;\n\t\tu32 target_timescale = 0;\n\t\tBool hdlr_name_set=GF_FALSE;\n\n\t\tif (ctx->make_qt && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p) {\n\t\t\t\tu32 ts=p->value.frac.num, inc=p->value.frac.den;\n\t\t\t\tif (inc * 24000 == ts * 1001) target_timescale = 24000;\n\t\t\t\telse if (inc * 2400 == ts * 100) target_timescale = 2400;\n\t\t\t\telse if (inc * 2500 == ts * 100) target_timescale = 2500;\n\t\t\t\telse if (inc * 30000 == ts * 1001) target_timescale = 30000;\n\t\t\t\telse if (inc * 2997 == ts * 100) target_timescale = 30000;\n\t\t\t\telse if (inc * 3000 == ts * 100) target_timescale = 3000;\n\t\t\t\telse if (inc * 5000 == ts * 100) target_timescale = 5000;\n\t\t\t\telse if (inc * 60000 == ts * 1001) target_timescale = 60000;\n\t\t\t\telse if (inc * 5994 == ts * 100) target_timescale = 60000;\n\t\t\t\telse if (is_prores) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (\"[ProRes] Unrecognized frame rate %g\\n\", ((Double)ts)/inc ));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ctx->prores_track)\n\t\t\t\tctx->prores_track = tkw;\n\t\t}\n\n\t\tif (!ctx->moov_inserted) {\n\t\t\tif (target_timescale) {\n\t\t\t\tctx->moovts = target_timescale;\n\t\t\t\tgf_isom_set_timescale(ctx->file, target_timescale);\n\t\t\t} else if (ctx->moovts>=0) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MOVIE_TIME);\n\t\t\t\tif (p && p->value.lfrac.den) {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, (u32) p->value.lfrac.den);\n\t\t\t\t\tctx->moovts = (u32) p->value.lfrac.den;\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_timescale(ctx->file, ctx->moovts);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tgf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t}\n\n\t\t//assign some defaults\n\t\ttkw->src_timescale = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\n\t\tu32 mtimescale = 1000;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\tif (p) mtimescale = p->value.uint;\n\t\telse {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\t\t\tif (p && p->value.frac.den) mtimescale = p->value.frac.den;\n\t\t}\n\t\tif (!tkw->src_timescale) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No timescale specified, guessing from media: %d\\n\", mtimescale));\n\t\t\ttkw->src_timescale = mtimescale;\n\t\t}\n\t\tif (target_timescale) tkw->tk_timescale = target_timescale;\n\t\telse if (ctx->mediats>0) tkw->tk_timescale = ctx->mediats;\n\t\telse if (ctx->mediats<0) tkw->tk_timescale = mtimescale;\n\t\telse tkw->tk_timescale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);\n\t\tif (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_ID);\n\t\tif (p) tkid = p->value.uint;\n\n\t\tif (tkw->stream_type == GF_STREAM_ENCRYPTED) {\n\t\t\ttkw->is_encrypted = GF_TRUE;\n\t\t\ttkw->stream_type = gf_codecid_type(tkw->codecid);\n\t\t}\n\t\tmtype = gf_isom_stream_type_to_media_type(tkw->stream_type, tkw->codecid);\n\n\t\tif (ctx->moovts<0) {\n\t\t\tctx->moovts = tkw->tk_timescale;\n\t\t\tgf_isom_set_timescale(ctx->file, (u32) ctx->moovts);\n\t\t}\n\t\tif (ctx->pad_sparse) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SPARSE);\n\t\t\tif (p) {\n\t\t\t\ttkw->sparse_inject = p->value.boolean;\n\t\t\t} else {\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tcase GF_STREAM_METADATA:\n\t\t\t\t\tswitch (tkw->codecid) {\n\t\t\t\t\tcase GF_CODECID_TEXT_MPEG4:\n\t\t\t\t\tcase GF_CODECID_TX3G:\n\t\t\t\t\tcase GF_CODECID_WEBVTT:\n\t\t\t\t\tcase GF_CODECID_SUBS_XML:\n\t\t\t\t\tcase GF_CODECID_SUBPIC:\n\t\t\t\t\tcase GF_CODECID_TMCD:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ttkw->sparse_inject = GF_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MUX_INDEX);\n\t\tif (p) {\n\t\t\ttk_idx = p->value.uint;\n\t\t\tif (!ctx->owns_mov) {\n\t\t\t\tu32 nb_dst_tk = gf_isom_get_track_count(ctx->file);\n\t\t\t\tif (tk_idx < nb_dst_tk) {\n\t\t\t\t\t//tk_idx = nb_dst_tk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->keep_utc) {\n\t\t\tif (!gf_isom_get_track_count(ctx->file)) {\n\t\t\t\tu64 create_date=0, modif_date=0;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:creation_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) create_date = p->value.longuint;\n\t\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:modification_date\");\n\t\t\t\tif (p && (p->type==GF_PROP_LUINT)) modif_date = p->value.longuint;\n\n\t\t\t\tif (create_date && modif_date)\n\t\t\t\t\tgf_isom_set_creation_time(ctx->file, create_date, modif_date);\n\t\t\t}\n\t\t\tgf_isom_keep_utc_times(ctx->file, GF_TRUE);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_TRACK_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tBool udta_only = (ctx->tktpl==2) ? GF_TRUE : GF_FALSE;\n\n\n\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, tkid, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track_from_template(ctx->file, 0, mtype, tkw->tk_timescale, p->value.data.ptr, p->value.data.size, udta_only);\n\t\t\t}\n\t\t\t//purge all track references we inject internally\n\t\t\tif (tkw->track_num) {\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SCAL);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_SABT);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_TBAS);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF);\n\t\t\t\tgf_isom_remove_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE);\n\t\t\t}\n\n\t\t\tif (!ctx->btrt) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, 0, 0, 0, 0);\n\t\t\t}\n\t\t\tif (!udta_only) {\n\t\t\t\tGF_Err gf_isom_set_track_stsd_templates(GF_ISOFile *movie, u32 trackNumber, u8 *stsd_data, u32 stsd_data_size);\n\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_stsd_templates(ctx->file, tkw->track_num, p->value.data.ptr, p->value.data.size);\n\t\t\t\t\ttkw->all_stsd_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (!mtype) {\n\t\t\t\tmtype = GF_4CC('u','n','k','n');\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to find ISOM media type for stream type %s codec %s\\n\", gf_stream_type_name(tkw->stream_type), gf_codecid_name(tkw->codecid) ));\n\t\t\t}\n\t\t\tif (!tkid) tkid = tk_idx;\n\n\t\t\tif (ctx->trackid) {\n\t\t\t\tif (ctx->trackid==(u32)-1) tkid = 0;\n\t\t\t\telse tkid = ctx->trackid;\n\t\t\t}\n\n\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, tkid, mtype, tkw->tk_timescale);\n\t\t\tif (!tkw->track_num) {\n\t\t\t\ttkw->track_num = gf_isom_new_track(ctx->file, 0, mtype, tkw->tk_timescale);\n\t\t\t}\n\t\t\t//FIXME once we finally merge to filters, there is an old bug in isobmff initializing the width and height to 320x240 which breaks text import\n\t\t\t//this should be removed and hashes regenerated\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 0, 0, 0, 0, 0);\n\n\t\t\tif (!gf_sys_is_test_mode() && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER)) {\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_URL);\n\t\t\t\tif (tkw->track_num && p && p->value.string) {\n\t\t\t\t\tchar szHName[1025];\n\t\t\t\t\tchar *f = gf_file_basename(p->value.string);\n\t\t\t\t\tszHName[1024]=0;\n\t\t\t\t\tsnprintf(szHName, 1024, \"*%s@GPAC%s\", f ? f : \"\", gf_gpac_version() );\n\t\t\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, szHName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!tkw->track_num) {\n\t\t\te = gf_isom_last_error(ctx->file);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to create new track: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->track_id = gf_isom_get_track_id(ctx->file, tkw->track_num);\n\n\t\tBool is_disabled = GF_FALSE;\n\t\t//cmaf mandates these flags and only them are set\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_ENABLED|GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t}\n\t\telse {\n\t\t\t//unless in test mode or old arch compat, set track to be enabled, in movie and in preview\n\t\t\tif (!gf_sys_is_test_mode() && !gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t}\n\n\t\t\t//override flags if provided\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_FLAGS);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, p->value.uint, GF_ISOM_TKFLAGS_SET);\n\t\t\t} else {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DISABLED);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tis_disabled = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t//if we have a subtype set for the pid, use it\n\t\tp = NULL;\n\t\tif ((tkw->stream_type==GF_STREAM_TEXT) && (tkw->codecid==GF_CODECID_TX3G)) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IS_CHAP);\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tmtype = GF_ISOM_MEDIA_TEXT;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t\ttkw->is_chap = GF_TRUE;\n\t\t\t\tctx->has_chap_tracks = GF_TRUE;\n\t\t\t\tgf_isom_set_track_enabled(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tp = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!p) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tmtype = p->value.uint;\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, mtype);\n\t\t\t}\n\t\t}\n\t\tif (ctx->has_chap_tracks)\n\t\t\tupdate_chap_refs(ctx);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_HANDLER);\n\t\tif (p && p->value.string) {\n\t\t\tgf_isom_set_handler_name(ctx->file, tkw->track_num, p->value.string);\n\t\t\thdlr_name_set = GF_TRUE;\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_ALT_GROUP);\n\t\tif (p && p->value.uint) {\n\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, p->value.uint);\n\t\t} else if (!p && !gf_sys_is_test_mode()) {\n\t\t\t//we by default set groups for audio and subs if group is not present\n\t\t\tif (mtype==GF_ISOM_SUBTYPE_SUBTITLE) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 2);\n\t\t\t}\n\t\t\tif (tkw->stream_type==GF_STREAM_AUDIO) {\n\t\t\t\tgf_isom_set_alternate_group_id(ctx->file, tkw->track_num, 1);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have default flag set\n\t\tif (!is_disabled && !ctx->cmaf) {\n\t\t\tBool *has_def = NULL;\n\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) has_def = &ctx->has_def_vid;\n\t\t\telse if (tkw->stream_type==GF_STREAM_AUDIO) has_def = &ctx->has_def_aud;\n\t\t\telse if (tkw->stream_type==GF_STREAM_TEXT) has_def = &ctx->has_def_txt;\n\n\t\t\tBool set_def = GF_FALSE;\n\t\t\tBool set_all_def = GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_IS_DEFAULT);\n\t\t\t//first track of this kind set to default, deactivate all except this track\n\t\t\tif (has_def && ! *has_def && p && p->value.boolean) {\n\t\t\t\t*has_def = GF_TRUE;\n\t\t\t\tset_def = GF_TRUE;\n\t\t\t}\n\t\t\t//second or more track of this kind set to default, re-activate all\n\t\t\telse if (has_def && *has_def && p && p->value.boolean) {\n\t\t\t\tset_all_def = GF_TRUE;\n\t\t\t}\n\t\t\tif (set_def || set_all_def) {\n\t\t\t\tu32 nb_tk = gf_list_count(ctx->tracks);\n\t\t\t\tfor (i=0; i<nb_tk; i++) {\n\t\t\t\t\tTrackWriter *atk = gf_list_get(ctx->tracks, i);\n\t\t\t\t\tif (atk->stream_type != tkw->stream_type) continue;\n\t\t\t\t\tif (set_all_def || (tkw == atk)) {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_ADD);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_isom_set_track_flags(ctx->file, atk->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//no default prop and a default exists for this kind, update flags\n\t\t\telse if (has_def && *has_def) {\n\t\t\t\tgf_isom_set_track_flags(ctx->file, tkw->track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_REM);\n\t\t\t}\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TRACK_MATRIX);\n\t\tif (p && (p->value.sint_list.nb_items==9)) {\n\t\t\tgf_isom_set_track_matrix(ctx->file, tkw->track_num, (s32 *) p->value.sint_list.vals);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SRC_MAGIC);\n\t\tif (p) {\n\t\t\tu64 magic = 0;\n\t\t\tif (hdlr_name_set) {\n\t\t\t\tmagic |= 1;\n\t\t\t\tmagic <<= 32;\n\t\t\t}\n\t\t\tmagic |= p->value.longuint;\n\t\t\tgf_isom_set_track_magic(ctx->file, tkw->track_num, magic);\n\t\t}\n\t\tif (tk_idx) {\n\t\t\tgf_isom_set_track_index(ctx->file, tkw->track_num, tk_idx, mp4mux_track_reorder, ctx);\n\t\t\tmp4mux_reorder_tracks(ctx);\n\t\t}\n\n\t\t//by default use cttsv1 (negative ctts)\n\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\tp = ctx->make_qt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_PROFILE_LEVEL);\n\t\tif (p) {\n\t\t\ttkw->media_profile_level = p->value.uint;\n\t\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, p->value.uint);\n\t\t\t\t}\n\t\t\t} else if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\t\t//patch to align old arch (IOD not written in dash) with new\n\t\t\t\tif (!ctx->dash_mode) {\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, p->value.uint);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->mudta && gf_isom_get_track_count(ctx->file)==1) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_UDTA);\n\t\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\t\tgf_isom_load_extra_boxes(ctx->file, p->value.data.ptr, p->value.data.size, (ctx->mudta==2) ? GF_TRUE : GF_FALSE);\n\t\t\t}\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->sgpd_traf)\n\t\t\tgf_isom_set_sample_group_in_traf(ctx->file);\n#endif\n\t\tif (ctx->noroll) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_ROLL);\n\t\t}\n\t\tif (ctx->norap) {\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_RAP);\n\t\t}\n\n\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tBool use_cache = (ctx->vodcache == MP4MX_VODCACHE_ON) ? GF_TRUE : GF_FALSE;\n\t\t\tif ((ctx->vodcache == MP4MX_VODCACHE_REPLACE) && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\t\tuse_cache = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_INSERT) );\n\t\t\t}\n\t\t\telse if (!use_cache) {\n\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DISABLE_PROGRESSIVE, &PROP_UINT(GF_PID_FILE_PATCH_REPLACE) );\n\t\t\t}\n\t\t}\n\n\t\tif (gf_sys_old_arch_compat()) {\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"isom_force_ctts\");\n\t\t\tif (p && p->value.boolean) tkw->force_ctts = GF_TRUE;\n\t\t}\n\t} else {\n\n\t\tu32 old_timescale = tkw->src_timescale;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);\n\t\tif (p) tkw->src_timescale = p->value.uint;\n\t\tif (old_timescale && (tkw->src_timescale != old_timescale)) {\n\t\t\tif (tkw->ts_shift)\n\t\t\t\ttkw->ts_shift = gf_timestamp_rescale(tkw->ts_shift, old_timescale, tkw->src_timescale);\n\t\t}\n\t}\n\n\tif (!tkw->has_brands) {\n\t\tBool ignore_alt = GF_FALSE;\n\t\tBool is_isom = GF_FALSE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_MBRAND);\n\t\tif (p) {\n\t\t\tu32 brand = p->value.uint;\n\t\t\t//remove QT brand\n\t\t\tif ((brand==GF_ISOM_BRAND_QT) && !ctx->make_qt) {\n\t\t\t\tis_isom = GF_TRUE;\n\t\t\t\tctx->major_brand_set = brand = GF_ISOM_BRAND_ISOM;\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_QT, GF_FALSE);\n\t\t\t\tignore_alt = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!ctx->major_brand_set) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, brand, 1);\n\t\t\t\tctx->major_brand_set = brand;\n\t\t\t} else {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, brand, GF_TRUE);\n\t\t\t}\n\t\t\tif (p->value.uint == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t}\n\t\tp = ignore_alt ? NULL : gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_BRANDS);\n\t\tif (p && p->value.uint_list.nb_items) {\n\t\t\ttkw->has_brands = GF_TRUE;\n\t\t\tif (!ctx->major_brand_set) {\n\t\t\t\tctx->major_brand_set = p->value.uint_list.vals[0];\n\t\t\t\tgf_isom_set_brand_info(ctx->file, p->value.uint_list.vals[0], 1);\n\t\t\t}\n\t\t\t//reset alt brands, push old ones\n\t\t\tgf_isom_reset_alt_brands_ex(ctx->file, GF_TRUE);\n\t\t\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, p->value.uint_list.vals[i], GF_TRUE);\n\t\t\t\tif (p->value.uint_list.vals[i] == GF_ISOM_BRAND_ISOM) is_isom = GF_TRUE;\n\t\t\t}\n\t\t\t//and in case it was not present add major brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, ctx->major_brand_set, GF_TRUE);\n\t\t}\n\t\tif (!ctx->m4sys && !is_isom && !ctx->def_brand_patched) {\n\t\t\t//remove default brand\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tctx->def_brand_patched = GF_TRUE;\n\t\t}\n\n\t\tif (ctx->cmaf) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, (ctx->cmaf==MP4MX_CMAF_CMF2) ? GF_ISOM_BRAND_CMF2 : GF_ISOM_BRAND_CMFC, GF_TRUE);\n\t\t}\n\t}\n\n\twidth = height = sr = nb_chan = z_order = txt_fsize = 0;\n\tnb_bps = 16;\n\tch_layout = 0;\n\tfps.num = 25;\n\tfps.den = 1;\n\tsar.num = sar.den = 0;\n\tcodec_id = tkw->codecid;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_PID);\n\tif (p) {\n\t\tmulti_pid_stsd = p->value.ptr;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_MULTI_PID_IDX);\n\t\tassert(p);\n\t\tmulti_pid_final_stsd_idx = p->value.uint;\n\n\t\t//should never be the case\n\t\ttkw->xps_inband = XPS_IB_NO;\n\t\tctx->dref = GF_FALSE;\n\t\torig_pid = pid;\n\t\tgoto multipid_stsd_setup;\n\t}\n\n\n\t//WARNING !! from this point on until the goto multipid_stsd_setup, use pid and not tkw->ipid\n\t//so that we setup the sample entry properly for each PIDs\nsample_entry_setup:\n\n\tuse_m4sys = ctx->m4sys;\n\tuse_gen_sample_entry = GF_TRUE;\n\tuse_dref = ctx->dref;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_WIDTH);\n\tif (p) width = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_HEIGHT);\n\tif (p) height = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FPS);\n\tif (p) fps = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAR);\n\tif (p) sar = p->value.frac;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ZORDER);\n\tif (p) z_order = p->value.uint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\tif (p) sr = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NUM_CHANNELS);\n\tif (p) nb_chan = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_BPS);\n\tif (p) nb_bps = p->value.uint;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHANNEL_LAYOUT);\n\tif (p) ch_layout = p->value.longuint;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_LANGUAGE);\n\tif (p) lang_name = p->value.string;\n\n\tif (is_true_pid) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_NB_FRAMES);\n\t\ttkw->nb_frames = p ? p->value.uint : 0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_FRAME_OFFSET);\n\t\ttkw->frame_offset = p ? p->value.uint : 0;\n\t}\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\tif (p) m_subtype_src = p->value.uint;\n\n\t//if crypto scheme type changes, we will need a new sample entry\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\tif (p && (tkw->scheme_type != p->value.uint))\n\t\tneeds_sample_entry = 1;\n\telse if (!p && tkw->scheme_type)\n\t\tneeds_sample_entry = 1;\n\telse if (tkw->scheme_type) {\n\t\tif (codec_id == prev_codecid)\n\t\t\tskip_crypto = GF_TRUE;\n\t}\n\n\t//get our subtype\n\tswitch (codec_id) {\n\tcase GF_CODECID_MPEG_AUDIO:\n\tcase GF_CODECID_MPEG2_PART3:\n\tcase GF_CODECID_MPEG_AUDIO_L1:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MP3;\n\t\tcomp_name = \"MP3\";\n\t\t//if source had a DSI, this was mpeg4 systems signaling, reuse that\n\t\tif (dsi)\n\t\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AAC_MPEG4:\n\tcase GF_CODECID_AAC_MPEG2_MP:\n\tcase GF_CODECID_AAC_MPEG2_LCP:\n\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"AAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\n\t\tif (ctx->importer) {\n\t\t\tconst char *pid_args = gf_filter_pid_get_args(pid);\n\t\t\tif (pid_args) {\n\t\t\t\tBool sbr_i = strstr(pid_args, \"sbr=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool sbr_x = strstr(pid_args, \"sbr=exp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_i = strstr(pid_args, \"ps=imp\") ? GF_TRUE : GF_FALSE;\n\t\t\t\tBool ps_x = strstr(pid_args, \"ps=exp\") ? GF_TRUE : GF_FALSE;\n\n\t\t\t\tif (sbr_x) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC explicit SBR implict PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit SBR+PS\";\n\t\t\t\t\telse imp_name = \"AAC explicit SBR\";\n\t\t\t\t} else if (sbr_i) {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit SBR+PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC implicit SBR explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC implicit SBR\";\n\t\t\t\t} else {\n\t\t\t\t\tif (ps_i) imp_name = \"AAC implicit PS\";\n\t\t\t\t\telse if (ps_x) imp_name = \"AAC explicit PS\";\n\t\t\t\t\telse imp_name = \"AAC \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_USAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"xHE-AAC / USAC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_JPEG;\n\t\tcomp_name = \"JPEG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tif (!use_m4sys)\n\t\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_PNG;\n\t\tcomp_name = \"PNG\";\n\t\t//use generic sample desc, but don't inject dsi\n\t\tdsi = NULL;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\tm_subtype = GF_ISOM_BOX_TYPE_MJP2;\n\t\tcomp_name = \"JPEG2000\";\n\t\tuse_mj2 = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_AMR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR;\n\t\tcomp_name = \"AMR\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AMR_WB:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_AMR_WB;\n\t\tcomp_name = \"AMR-WB\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AMR_MODE_SET);\n\t\tif (p && (p->value.uint!=tkw->amr_mode_set)) {\n\t\t\ttkw->amr_mode_set = p->value.uint;\n\t\t\tif (!needs_sample_entry)\n\t\t\t\tneeds_sample_entry = 2;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_EVRC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_EVRC;\n\t\tcomp_name = \"EVRC\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_SMV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_SMV;\n\t\tcomp_name = \"SMV\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_QCELP:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_QCELP;\n\t\tcomp_name = \"QCELP\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_S263:\n\tcase GF_CODECID_H263:\n\t\tm_subtype = GF_ISOM_SUBTYPE_3GP_H263;\n\t\tcomp_name = \"H263\";\n\t\tuse_3gpp_config = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_AC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_AC3;\n\t\tcomp_name = \"AC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_EAC3:\n\t\tm_subtype = GF_ISOM_SUBTYPE_EC3;\n\t\tcomp_name = \"EAC-3\";\n\t\tuse_ac3_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPHA:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHA1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H Audio\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_MHAS:\n\t\tif ((m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM1) && (m_subtype_src!=GF_ISOM_SUBTYPE_MH3D_MHM2))\n\t\t\tm_subtype = GF_ISOM_SUBTYPE_MH3D_MHM1;\n\t\telse\n\t\t\tm_subtype = m_subtype_src;\n\t\tcomp_name = \"MPEG-H AudioMux\";\n\t\tnb_chan = 0;\n\t\tbreak;\n\tcase GF_CODECID_FLAC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_FLAC;\n\t\tcomp_name = \"FLAC\";\n\t\tuse_flac_entry = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_OPUS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_OPUS;\n\t\tcomp_name = \"Opus\";\n\t\tuse_opus = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG4_PART2:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-4 Visual Part 2\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_AVC:\n\tcase GF_CODECID_SVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_DVAV:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_AVC3_H264 : GF_ISOM_SUBTYPE_AVC_H264;\n\t\t}\n\t\tuse_avc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_SVC) ? \"MPEG-4 SVC\" : \"MPEG-4 AVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_AVC_H264) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_LHVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tswitch (m_subtype_src) {\n\t\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\t\tcase GF_ISOM_SUBTYPE_DVHE:\n\t\t\t\tm_subtype = m_subtype_src;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_HVC1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_HEV1  : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tuse_hevc = GF_TRUE;\n\t\tcomp_name = (codec_id == GF_CODECID_LHVC) ? \"L-HEVC\" : \"HEVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (m_subtype != GF_ISOM_SUBTYPE_HVC1) {\n\t\t\tuse_m4sys = GF_FALSE;\n\t\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_HEVC_TILES:\n\t\tm_subtype = GF_ISOM_SUBTYPE_HVT1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_hvt1 = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"HEVC Tiles\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_VVC:\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tif (m_subtype_src == GF_ISOM_SUBTYPE_VVI1) {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVI1;\n\t\t\t\txps_inband = XPS_IB_ALL;\n\t\t\t} else {\n\t\t\t\tm_subtype = GF_ISOM_SUBTYPE_VVC1;\n\t\t\t}\n\t\t} else {\n\t\t\txps_inband = ctx->xps_inband;\n\t\t\tm_subtype = ((xps_inband==XPS_IB_PPS) || (xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_BOTH)) ? GF_ISOM_SUBTYPE_VVI1  : GF_ISOM_SUBTYPE_VVC1;\n\t\t}\n\t\tuse_vvc = GF_TRUE;\n\t\tcomp_name = \"VVC\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tif (xps_inband==XPS_IB_ALL) skip_dsi = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_VVC_SUBPIC:\n\t\tm_subtype = GF_ISOM_SUBTYPE_VVS1;\n\t\tskip_dsi = GF_TRUE;\n\t\tuse_vvc = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tcomp_name = \"VVC Subpicture\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase GF_CODECID_MPEG1:\n\tcase GF_CODECID_MPEG2_422:\n\tcase GF_CODECID_MPEG2_SNR:\n\tcase GF_CODECID_MPEG2_HIGH:\n\tcase GF_CODECID_MPEG2_MAIN:\n\tcase GF_CODECID_MPEG2_SIMPLE:\n\tcase GF_CODECID_MPEG2_SPATIAL:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MPEG4;\n\t\tuse_m4sys = GF_TRUE;\n\t\tcomp_name = \"MPEG-2 Video\";\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tbreak;\n\tcase 0:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] muxing codecID %d not yet implemented - patch welcome\\n\", codec_id));\n\t\treturn GF_NOT_SUPPORTED;\n\n\tcase GF_ISOM_SUBTYPE_TX3G:\n\t\tm_subtype = GF_ISOM_SUBTYPE_TX3G;\n\t\tuse_tx3g = GF_TRUE;\n\t\tcomp_name = \"Timed Text\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_ISOM_SUBTYPE_WVTT:\n\t\tm_subtype = GF_ISOM_SUBTYPE_WVTT;\n\t\tuse_webvtt = GF_TRUE;\n\t\tcomp_name = \"WebVTT\";\n\t\tis_text_subs = GF_TRUE;\n\t\tbreak;\n\tcase GF_CODECID_DVB_SUBS:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_SUBS;\n\t\tgen_dsi_wrap = GF_4CC('d', 'v', 's', 'C');\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_DVB_TELETEXT:\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tcomp_name = \"DVB Subtitles\";\n\t\tm_subtype = GF_ISOM_SUBTYPE_DVB_TELETEXT;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SUBT);\n\t\tif (!width && !height) {\n\t\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_SUBPIC:\n\t\tuse_m4sys = GF_TRUE;\n\t\toverride_stype = GF_STREAM_ND_SUBPIC;\n\t\tcomp_name = \"VobSub\";\n\t\tbreak;\n\tcase GF_CODECID_TEXT_MPEG4:\n\t\tuse_m4sys = GF_TRUE;\n\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_MEDIA_SCENE);\n\t\tcomp_name = \"MPEG4 Streaming Text\";\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_AV01;\n\t\tuse_av1 = GF_TRUE;\n\t\tcomp_name = \"AOM AV1 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VP8:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP08;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP8 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP9:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP09;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP9 Video\";\n\t\tbreak;\n\tcase GF_CODECID_VP10:\n\t\tuse_gen_sample_entry = GF_FALSE;\n\t\tm_subtype = GF_ISOM_SUBTYPE_VP10;\n\t\tuse_vpX = GF_TRUE;\n\t\tcomp_name = \"VP10 Video\";\n\t\tbreak;\n\n\tcase GF_CODECID_VORBIS:\n\tcase GF_CODECID_THEORA:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_TRUEHD:\n\t\tm_subtype = GF_ISOM_SUBTYPE_MLPA;\n\t\tcomp_name = \"Dolby TrueHD\";\n\t\tbreak;\n\n\tcase GF_CODECID_DTS_CA:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSC;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_HR_MASTER:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSH;\n\t\tbreak;\n\tcase GF_CODECID_DTS_HD_LOSSLESS:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSL;\n\t\tbreak;\n\tcase GF_CODECID_DTS_EXPRESS_LBR:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSE;\n\t\tbreak;\n\tcase GF_CODECID_DTS_X:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSX;\n\t\tbreak;\n\tcase GF_CODECID_DTS_Y:\n\t\tm_subtype = GF_ISOM_SUBTYPE_DTSY;\n\t\tbreak;\n\tcase GF_CODECID_ALAC:\n\t\tm_subtype = GF_QT_SUBTYPE_ALAC;\n\t\tbreak;\n\n\tcase GF_CODECID_BIFS:\n/* ==  GF_CODECID_OD_V1:*/\n\tcase GF_CODECID_BIFS_V2:\n/*\t== GF_CODECID_OD_V2:*/\n\tcase GF_CODECID_BIFS_EXTENDED:\n\tcase GF_CODECID_LASER:\n\t\tuse_m4sys = GF_TRUE;\n\t\tbreak;\n\n\tcase GF_CODECID_RAW:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\tif (tkw->stream_type == GF_STREAM_AUDIO) {\n\t\t\tu32 afmt;\n\t\t\tu32 req_non_planar_type = 0;\n\t\t\tBool qt_only=GF_FALSE;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\tif (!p) break;\n\t\t\tcomp_name = \"RawAudio\";\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\t\tafmt = p->value.uint;\n\t\t\tafmt_flags |= 1<<2; //signed\n\t\t\t//m_subtype used for QTFF-style raw media, m_subtype_alt_raw for ISOBMFF raw audio\n\t\t\tswitch (afmt) {\n\t\t\tcase GF_AUDIO_FMT_U8P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_U8;\n\t\t\tcase GF_AUDIO_FMT_U8:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_RAW;\n\t\t\t\tafmt_flags &= ~(1<<2); //unsigned\n\t\t\t\tqt_only = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S16;\n\t\t\tcase GF_AUDIO_FMT_S16:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_SOWT;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S16_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_TWOS;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S24;\n\t\t\tcase GF_AUDIO_FMT_S24:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S24_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN24;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32P:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_S32P;\n\t\t\tcase GF_AUDIO_FMT_S32:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_S32_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_IN32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_IPCM;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLTP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_FLTP;\n\t\t\tcase GF_AUDIO_FMT_FLT:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_FLT_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL32;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBLP:\n\t\t\t \treq_non_planar_type = GF_AUDIO_FMT_DBL;\n\t\t\tcase GF_AUDIO_FMT_DBL:\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tcase GF_AUDIO_FMT_DBL_BE:\n\t\t\t\tafmt_flags |= 1<<1;\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_FL64;\n\t\t\t\tm_subtype_alt_raw = GF_ISOM_SUBTYPE_FPCM;\n\t\t\t\tafmt_flags |= 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF)) {\n\t\t\t\tm_subtype = GF_QT_SUBTYPE_LPCM;\n\t\t\t}\n\t\t\t//if qt-only sample desc available, force ase mode\n\t\t\telse if (!ctx->make_qt && qt_only) {\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\n\t\t\tif (req_non_planar_type) {\n\t\t\t\tif (is_true_pid)\n\t\t\t\t\tgf_filter_pid_negociate_property(pid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(GF_AUDIO_FMT_S16));\n\t\t\t\telse {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] raw audio format planar in DASH multi-stsd mode is not supported, try assigning a resampler before the dasher\\n\"));\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnb_bps = gf_audio_fmt_bit_depth(afmt);\n\t\t\ttkw->raw_audio_bytes_per_sample = nb_bps;\n\t\t\ttkw->raw_audio_bytes_per_sample *= nb_chan;\n\t\t\ttkw->raw_audio_bytes_per_sample /= 8;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SAMPLE_RATE);\n\t\t\ttkw->raw_samplerate = p ? p->value.uint : 0;\n\t\t\t//force timescale to be samplerate, except if explicit overwrite\n\t\t\tif (ctx->mediats==0)\n\t\t\t\ttkw->tk_timescale = tkw->raw_samplerate;\n\n\t\t\tif ((sr == tkw->w_or_sr) && (nb_chan==tkw->h_or_ch) && (afmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = sr;\n\t\t\t\ttkw->h_or_ch = nb_chan;\n\t\t\t\ttkw->pf_or_af = afmt;\n\t\t\t}\n\t\t}\n\t\telse if (tkw->stream_type == GF_STREAM_VISUAL) {\n\t\t\tu32 pfmt;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PIXFMT);\n\t\t\tif (!p) break;\n\t\t\tpfmt = p->value.uint;\n\t\t\tcomp_name = \"RawVideo\";\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t\t\tpix_fmt = p->value.uint;\n\n\t\t\tm_subtype = gf_pixel_fmt_to_qt_type(pix_fmt);\n\t\t\tif (m_subtype) {\n\t\t\t\tif (gf_pixel_fmt_is_yuv(p->value.uint))\n\t\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tunknown_generic = GF_TRUE;\n\t\t\t\tm_subtype = pix_fmt;\n\t\t\t}\n\n\t\t\tif ((width == tkw->w_or_sr) && (height==tkw->h_or_ch) && (pfmt==tkw->pf_or_af)) {\n\n\t\t\t} else {\n\t\t\t\tif (!needs_sample_entry)\n\t\t\t\t\tneeds_sample_entry = 2;\n\t\t\t\ttkw->w_or_sr = width;\n\t\t\t\ttkw->h_or_ch = height;\n\t\t\t\ttkw->pf_or_af = pfmt;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase GF_CODECID_RAW_UNCV:\n\t\tm_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\tunknown_generic = GF_FALSE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tbreak;\n\n\tdefault:\n\t\tm_subtype = codec_id;\n\t\tunknown_generic = GF_TRUE;\n\t\tuse_gen_sample_entry = GF_TRUE;\n\t\tuse_m4sys = GF_FALSE;\n\t\tif (is_prores)\n\t\t\tunknown_generic = GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:mime\");\n\t\tif (p) meta_mime = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:encoding\");\n\t\tif (p) meta_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:content_encoding\");\n\t\tif (p) meta_content_encoding = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:xmlns\");\n\t\tif (p) meta_xmlns = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:schemaloc\");\n\t\tif (p) meta_schemaloc = p->value.string;\n\t\tp = gf_filter_pid_get_property_str(pid, \"meta:aux_mimes\");\n\t\tif (p) meta_auxmimes = p->value.string;\n\t\tbreak;\n\t}\n\tif (!comp_name) comp_name = gf_codecid_name(codec_id);\n\tif (!comp_name) comp_name = gf_4cc_to_str(m_subtype);\n\n\tif (dsi)\n\t\tmeta_config = dsi->value.data.ptr;\n\n\tif (is_text_subs && !width && !height) {\n\t\tmp4_mux_get_video_size(ctx, &width, &height);\n\t}\n\n\t//if not LPCM and qt v2 is requested, move to qtv1\n\tif ((ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v2_QTFF) && (m_subtype != GF_QT_SUBTYPE_LPCM) ) {\n\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t}\n\n\n\tif (!ctx->init_movie_done && !tkw->nb_samples && (ctx->mediats<0) && (tkw->tk_timescale==1000)) {\n\t\tif (sr) {\n\t\t\ttkw->tk_timescale = sr;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, sr, 0, 1);\n\t\t}\n\t\telse if (width && fps.den) {\n\t\t\ttkw->tk_timescale = fps.den;\n\t\t\tgf_isom_set_media_timescale(ctx->file, tkw->track_num, fps.den, 0, 1);\n\t\t}\n\t}\n\tif (!needs_sample_entry || tkw->is_item) {\n\t\tgoto sample_entry_done;\n\t}\n\n\t//we are fragmented, init movie done, we cannot update the sample description\n\tif (ctx->init_movie_done) {\n\t\tif (needs_sample_entry==1) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (codec change) for finalized movie in fragmented mode\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\tforce_mix_xps = GF_TRUE;\n\t} else if (ctx->store < MP4MX_MODE_FRAG) {\n\t\tif ((needs_sample_entry==2) && (xps_inband==XPS_IB_BOTH)) {\n\t\t\tforce_mix_xps = GF_TRUE;\n\t\t}\n\t\telse if ((needs_sample_entry==2) && ((xps_inband==XPS_IB_ALL) || (xps_inband==XPS_IB_MIX)) ) {\n\t\t\tneeds_sample_entry = 0;\n\t\t\tmake_inband_headers = GF_TRUE;\n\t\t}\n\t}\n\n\tif (force_mix_xps) {\n\t\tif (tkw->all_stsd_crc) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\tu32 crc = p ? gf_crc_32(p->value.data.ptr, p->value.data.size) : 0;\n\t\t\tif (crc == tkw->all_stsd_crc) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE_IDX);\n\t\t\t\tif (p) {\n\t\t\t\t\ttkw->stsd_idx = p->value.uint;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//for AVC and HEVC, move to inband params if config changed\n\t\tif (use_avc && dsi) {\n\t\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\n\t\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] AVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_hevc && dsi) {\n\t\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\n\t\t\tif (enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t}\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] HEVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\telse if (use_vvc && dsi) {\n\t\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\t\tif (!xps_inband) {\n\t\t\t\tif (ctx->init_movie_done) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] VVC config update after movie has been finalized, moving all SPS/PPS inband (file might not be compliant)\\n\"));\n\t\t\t\t}\n\t\t\t\ttkw->xps_inband = XPS_IB_BOTH;\n\t\t\t}\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot create a new sample description entry (config changed) for finalized movie in fragmented mode\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\ttkw->xps_inband = xps_inband;\n\tp = needs_sample_entry ? gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DSI_SUPERSET) : NULL;\n\n\t//if dsi is a superset of previous one, remove stream description\n\tif ((p && p->value.boolean)\n\t\t//little optim here: if no samples were added on the stream description remove it\n\t\t|| (!tkw->samples_in_stsd && tkw->stsd_idx && needs_sample_entry)\n\t) {\n\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t}\n\n\tif (!use_dref) src_url = NULL;\n\n\tif (use_m4sys && !gf_codecid_oti(codec_id)) {\n\t\tuse_m4sys = GF_FALSE;\n\t}\n\t//nope, create sample entry\n\tif (use_m4sys) {\n\t\tGF_ESD *esd = gf_odf_desc_esd_new(2);\n\t\tesd->decoderConfig->streamType = override_stype ? override_stype : tkw->stream_type;\n\t\tesd->decoderConfig->objectTypeIndication = gf_codecid_oti(codec_id);\n\t\tif (!esd->decoderConfig->objectTypeIndication) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Codec %s does not have an official MPEG-4 systems mapping, cannot mux\\n\", gf_codecid_name(codec_id) ));\n\t\t\treturn GF_NOT_SUPPORTED;\n\n\t\t}\n\t\tesd->slConfig->timestampResolution = tkw->tk_timescale;\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = dsi->value.data.ptr;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = dsi->value.data.size;\n\t\t}\n\n\t\te = gf_isom_new_mpeg4_description(ctx->file, tkw->track_num, esd, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (dsi && !skip_dsi) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = NULL;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = 0;\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-4 Systems sample description for stream type %d OTI %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_IN_IOD);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_add_track_to_root_od(ctx->file, tkw->track_num);\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (dsi && (tkw->stream_type==GF_STREAM_AUDIO)) {\n\t\t\tGF_M4ADecSpecInfo acfg;\n\t\t\tgf_m4a_get_config(dsi->value.data.ptr, dsi->value.data.size, &acfg);\n\t\t\taudio_pli = acfg.audioPL;\n\t\t}\n\t\t//patch to align old arch (IOD not written in dash) with new\n\t\tif (audio_pli && !ctx->dash_mode)\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_AUDIO, audio_pli);\n#endif\n\n\t} else if (use_avc) {\n\t\t//not yet known\n\t\tif (!dsi && !enh_dsi) return GF_OK;\n\n\t\tif (!dsi) {\n\t\t\tdsi = enh_dsi;\n\t\t\tenh_dsi = NULL;\n\t\t}\n\t\tif (tkw->avcc) gf_odf_avc_cfg_del(tkw->avcc);\n\t\ttkw->avcc = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->codecid == GF_CODECID_SVC) {\n\t\t\t\te = gf_isom_svc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else if (tkw->codecid == GF_CODECID_MVC) {\n\t\t\t\te = gf_isom_mvc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t} else {\n\t\t\t\te = gf_isom_avc_config_new(ctx->file, tkw->track_num, tkw->avcc, NULL, NULL, &tkw->stsd_idx);\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->svcc) gf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\ttkw->svcc = gf_odf_avc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size);\n\t\t\t\tif (tkw->svcc) {\n\t\t\t\t\tif ((tkw->svcc->AVCProfileIndication==118) || (tkw->svcc->AVCProfileIndication==128)) {\n\t\t\t\t\t\te = gf_isom_mvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = gf_isom_svc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->svcc, GF_TRUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\t\t\t\ttkw->svcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (xps_inband) {\n\t\t\t\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_avc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\tif (xps_inband==XPS_IB_BOTH) make_inband_headers = GF_TRUE;\n\t\t} else {\n\t\t\tgf_odf_avc_cfg_del(tkw->avcc);\n\t\t\ttkw->avcc = NULL;\n\t\t}\n\t\t//patch to align old arch with filters\n\t\tif (!ctx->dash_mode && !ctx->make_qt && !gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE) )\n\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, 0x7F);\n\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_TRUE);\n\n\t\ttkw->is_nalu = NALU_AVC;\n\n\t\ttkw->use_dref = GF_FALSE;\n\n\t} else if (use_hvt1) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (!e) {\n\t\t\tgf_isom_hevc_set_tile_config(ctx->file, tkw->track_num, tkw->stsd_idx, NULL, GF_FALSE);\n\t\t}\n\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\ttkw->hvcc = NULL;\n\t\ttkw->is_nalu = NALU_HEVC;\n\t\ttkw->use_dref = GF_FALSE;\n\t\tif (!tkw->has_brands)\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_HVTI, GF_TRUE);\n\t} else if (use_hevc) {\n\t\tif (tkw->hvcc) gf_odf_hevc_cfg_del(tkw->hvcc);\n\n\t\tif (!dsi && !enh_dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (dsi) {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size,  (codec_id == GF_CODECID_LHVC) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\ttkw->hvcc = gf_odf_hevc_cfg_new();\n\t\t}\n\t\ttkw->is_nalu = NALU_HEVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\te = gf_isom_hevc_config_new(ctx->file, tkw->track_num, tkw->hvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!e && enh_dsi) {\n\t\t\t\tif (tkw->lvcc) gf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\ttkw->lvcc = gf_odf_hevc_cfg_read(enh_dsi->value.data.ptr, enh_dsi->value.data.size, GF_TRUE);\n\t\t\t\tif (tkw->lvcc) {\n\t\t\t\t\te = gf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->lvcc, dsi ? GF_ISOM_LEHVC_WITH_BASE_BACKWARD : GF_ISOM_LEHVC_ONLY);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\t\t\t\ttkw->lvcc = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!dsi && tkw->xps_inband) {\n\t\t\t\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (codec_id == GF_CODECID_LHVC) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_LEHVC_ONLY);\n\t\t\t} else if (is_tile_base) {\n\t\t\t\tgf_isom_lhvc_config_update(ctx->file, tkw->track_num, tkw->stsd_idx, tkw->hvcc, GF_ISOM_HEVC_TILE_BASE);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (dsi && tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in avcC / svcC\n\t\t\tgf_isom_hevc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, (tkw->xps_inband==XPS_IB_BOTH) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_hevc_cfg_del(tkw->hvcc);\n\t\t\ttkw->hvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_vvc) {\n\t\tif (tkw->vvcc) gf_odf_vvc_cfg_del(tkw->vvcc);\n\n\t\tif (!dsi) {\n\t\t\t//not yet known\n\t\t\treturn GF_OK;\n\t\t}\n\t\ttkw->vvcc = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\ttkw->is_nalu = NALU_VVC;\n\n\t\tif (needs_sample_entry) {\n\t\t\tif (tkw->xps_inband == XPS_IB_PPS) {\n\t\t\t\tu32 k; count=gf_list_count(tkw->vvcc->param_array);\n\t\t\t\tfor (k=0;k<count;k++) {\n\t\t\t\t\tGF_NALUFFParamArray *pa = gf_list_get(tkw->vvcc->param_array, k);\n\t\t\t\t\tif (pa->type==GF_VVC_NALU_PIC_PARAM)\n\t\t\t\t\t\tpa->array_completeness = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\te = gf_isom_vvc_config_new(ctx->file, tkw->track_num, tkw->vvcc, NULL, NULL, &tkw->stsd_idx);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t}\n\t\t\t//patch for old arch\n\t\t\telse if (ctx->dash_mode) {\n\t\t\t\tBool force_brand=GF_FALSE;\n\t\t\t\tif (((ctx->major_brand_set>>24)=='i') && (((ctx->major_brand_set>>16)&0xFF)=='s') && (((ctx->major_brand_set>>8)&0xFF)=='o')) {\n\t\t\t\t\tif ( (ctx->major_brand_set&0xFF) <'6') force_brand=GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tif (!force_brand && ctx->major_brand_set) {\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO6, 1);\n\t\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new HEVC sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->xps_inband) {\n\t\t\t//this will cleanup all PS in vvcC\n\t\t\tgf_isom_vvc_set_inband_config(ctx->file, tkw->track_num, tkw->stsd_idx, ((tkw->xps_inband==XPS_IB_PPS) || (tkw->xps_inband==XPS_IB_BOTH)) ? GF_TRUE : GF_FALSE);\n\t\t} else {\n\t\t\tgf_odf_vvc_cfg_del(tkw->vvcc);\n\t\t\ttkw->vvcc = NULL;\n\t\t}\n\n\t\ttkw->use_dref = GF_FALSE;\n\t} else if (use_av1) {\n\t\tGF_AV1Config *av1c;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for AV1\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tav1c = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!av1c) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser AV1 decoder specific info\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_av1_config_new(ctx->file, tkw->track_num, av1c, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AV1 sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_av1 = GF_TRUE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_ISO4, 1);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AV01, GF_TRUE);\n\t\t}\n\n\t\tgf_odf_av1_cfg_del(av1c);\n\t} else if (use_vpX) {\n\t\tGF_VPConfig *vpc;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for %s\\n\", gf_4cc_to_str(codec_id) ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tvpc = gf_odf_vp_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!vpc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parser %s decoder specific info\\n\", gf_4cc_to_str(codec_id)));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\te = gf_isom_vp_config_new(ctx->file, tkw->track_num, vpc, (char *) src_url, NULL, &tkw->stsd_idx, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(codec_id), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->is_vpx = GF_TRUE;\n\t\tgf_odf_vp_cfg_del(vpc);\n\t} else if (use_3gpp_config) {\n\t\tGF_3GPConfig gpp_cfg;\n\t\tmemset(&gpp_cfg, 0, sizeof(GF_3GPConfig));\n\t\tgpp_cfg.type = m_subtype;\n\t\tgpp_cfg.vendor = GF_VENDOR_GPAC;\n\n\t\tif (use_dref) {\n\t\t\tgpp_cfg.frames_per_sample  = 1;\n\t\t} else {\n\t\t\tgpp_cfg.frames_per_sample = ctx->pack3gp;\n\t\t\tif (!gpp_cfg.frames_per_sample) gpp_cfg.frames_per_sample  = 1;\n\t\t\telse if (gpp_cfg.frames_per_sample >15) gpp_cfg.frames_per_sample = 15;\n\t\t}\n\t\tgpp_cfg.AMR_mode_set = tkw->amr_mode_set;\n\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t/*FIXME - we need more in-depth parsing of the bitstream to detect P3@L10 (streaming wireless)*/\n\t\t\tgpp_cfg.H263_profile = 0;\n\t\t\tgpp_cfg.H263_level = 10;\n\t\t\tgpp_cfg.frames_per_sample = 0;\n\t\t}\n\t\ttkw->nb_frames_per_sample = gpp_cfg.frames_per_sample;\n\n\t\te = gf_isom_3gp_config_new(ctx->file, tkw->track_num, &gpp_cfg, (char *) src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new 3GPP audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t\tif (!tkw->has_brands) {\n\t\t\tswitch (gpp_cfg.type) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_3G2A, 65536);\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG6, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_3GG5, GF_TRUE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_ac3_entry) {\n\t\tGF_AC3Config ac3cfg;\n\t\tmemset(&ac3cfg, 0, sizeof(GF_AC3Config));\n\n\t\tif (dsi) {\n\t\t\tgf_odf_ac3_config_parse(dsi->value.data.ptr, dsi->value.data.size, (codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3cfg);\n\t\t} else {\n\t\t\tif (codec_id==GF_CODECID_EAC3) ac3cfg.is_ec3 = GF_TRUE;\n\t\t}\n\t\te = gf_isom_ac3_config_new(ctx->file, tkw->track_num, &ac3cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new AC3 audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_flac_entry) {\n\t\te = gf_isom_flac_config_new(ctx->file, tkw->track_num, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0, (char *)src_url, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new FLAC audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (use_opus) {\n\t\tGF_OpusConfig opus_cfg;\n\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for opus\\n\" ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\te = gf_odf_opus_cfg_parse(dsi->value.data.ptr, dsi->value.data.size, &opus_cfg);\n\t\tif (!e)\n\t\t\te = gf_isom_opus_config_new(ctx->file, tkw->track_num, &opus_cfg, (char *)src_url, NULL, &tkw->stsd_idx);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new Opus audio sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METX) {\n\t\tcomp_name = \"XML Metadata\";\n\t\te = gf_isom_new_xml_metadata_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_encoding, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METX sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_METT) {\n\t\tcomp_name = \"Text Metadata\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, GF_ISOM_SUBTYPE_METT, meta_mime, meta_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new METT sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (m_subtype == GF_ISOM_SUBTYPE_STPP) {\n\t\tif (meta_xmlns && !strcmp(meta_xmlns, \"http://www.w3.org/ns/ttml\")) {\n\t\t\tcomp_name = \"TTML\";\n\t\t} else {\n\t\t\tcomp_name = \"XML Subtitle\";\n\t\t}\n\t\te = gf_isom_new_xml_subtitle_description(ctx->file, tkw->track_num, meta_xmlns, meta_schemaloc, meta_auxmimes, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new XML subtitle sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n\t\t//CMAF 11.3.2\n\t\tif (ctx->cmaf) {\n\t\t\tif (!meta_mime) meta_mime = gf_isom_subtitle_get_mime(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (!meta_mime || (!strstr(meta_mime, \"im1t\") && !strstr(meta_mime, \"im1i\"))) {\n\t\t\t\tgf_isom_subtitle_set_mime(ctx->file, tkw->track_num, tkw->stsd_idx, \"application/ttml+xml;codecs=im1t\");\n\t\t\t}\n\t\t}\n\n\n\t} else if ((m_subtype == GF_ISOM_SUBTYPE_SBTT) || (m_subtype == GF_ISOM_SUBTYPE_STXT) ) {\n\t\tcomp_name = (m_subtype == GF_ISOM_SUBTYPE_STXT) ? \"Simple Timed Text\" : \"Textual Subtitle\";\n\t\te = gf_isom_new_stxt_description(ctx->file, tkw->track_num, m_subtype, meta_mime, meta_content_encoding, meta_config, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (m_subtype == GF_ISOM_SUBTYPE_STXT) force_tk_layout = GF_TRUE;\n\t} else if (use_tx3g) {\n\t\tGF_TextSampleDescriptor *txtc;\n\t\tif (!dsi) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] No decoder specific info found for TX3G\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\ttxtc = gf_odf_tx3g_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (!txtc) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to parse TX3G config\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\n\t\tif (!txtc->default_pos.right) txtc->default_pos.right = width + txtc->default_pos.left;\n\t\tif (!txtc->default_pos.bottom) txtc->default_pos.bottom = height + txtc->default_pos.top;\n\n\n\t\te = gf_isom_new_text_description(ctx->file, tkw->track_num, txtc, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->importer) {\n\t\t\ttxt_fsize = txtc->default_style.font_size;\n\t\t\tif (txtc->font_count && txtc->fonts[0].fontName) txt_font = gf_strdup(txtc->fonts[0].fontName);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *)txtc);\n\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_webvtt) {\n#ifndef GPAC_DISABLE_VTT\n\t\te = gf_isom_new_webvtt_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e)));\n\t\t\treturn e;\n\t\t}\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\ttkw->skip_bitrate_update = GF_TRUE;\n\t} else if (use_mj2) {\n\t\te = gf_isom_new_mj2k_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, dsi ? dsi->value.data.ptr : NULL, dsi ? dsi->value.data.size : 0);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new %s sample description: %s\\n\", gf_4cc_to_str(m_subtype), gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_TMCD) {\n\t\tu32 tmcd_flags=0, tmcd_fps_num=0, tmcd_fps_den=0;\n\t\ts32 tmcd_fpt=0;\n\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:flags\");\n\t\tif (p) tmcd_flags = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:framerate\");\n\t\tif (p) {\n\t\t\ttmcd_fps_num = p->value.frac.num;\n\t\t\ttmcd_fps_den = p->value.frac.den;\n\t\t}\n\t\tp = gf_filter_pid_get_property_str(pid, \"tmcd:frames_per_tick\");\n\t\tif (p) tmcd_fpt = p->value.uint;\n\t\tif (tkw->tk_timescale != tmcd_fps_num) {\n\t\t\ttmcd_fps_den *= tmcd_fps_num;\n\t\t\ttmcd_fps_den /= tkw->tk_timescale;\n\t\t}\n\n\t\te = gf_isom_tmcd_config_new(ctx->file, tkw->track_num, tmcd_fps_num, tmcd_fps_den, tmcd_fpt, (tmcd_flags & 0x1), (tmcd_flags & 0x8), &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new tmcd sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (codec_id==GF_CODECID_DIMS) {\n\t\tGF_DIMSDescription dims_c;\n\t\tmemset(&dims_c, 0, sizeof(GF_DIMSDescription));\n\t\tdims_c.contentEncoding = meta_content_encoding;\n\t\tdims_c.mime_type = meta_mime;\n\t\tdims_c.textEncoding = meta_encoding;\n\t\tdims_c.xml_schema_loc = meta_xmlns;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:profile\");\n\t\tif (p) dims_c.profile = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:level\");\n\t\tif (p) dims_c.level = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:pathComponents\");\n\t\tif (p) dims_c.pathComponents = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:fullRequestHost\");\n\t\tif (p) dims_c.fullRequestHost = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:streamType\");\n\t\tif (p) dims_c.streamType = p->value.boolean;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:redundant\");\n\t\tif (p) dims_c.containsRedundant = p->value.uint;\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"dims:scriptTypes\");\n\t\tif (p) dims_c.content_script_types = p->value.string;\n\n\t\te = gf_isom_new_dims_description(ctx->file, tkw->track_num, &dims_c, NULL, NULL, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new DIMS sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if ((codec_id==GF_CODECID_MPHA) || (codec_id==GF_CODECID_MHAS)) {\n\t\t//not ready yet\n\t\tu8 *pdsi=NULL;\n\t\tu32 dsi_len=0;\n\t\tif (codec_id==GF_CODECID_MPHA) {\n\t\t\tif (!dsi) return GF_OK;\n\t\t\tpdsi = dsi->value.data.ptr;\n\t\t\tdsi_len = dsi->value.data.size;\n\t\t}\n\t\te = gf_isom_new_mpha_description(ctx->file, tkw->track_num, NULL, NULL, &tkw->stsd_idx, pdsi, dsi_len, m_subtype);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new MPEG-H Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\tif (p) {\n\t\t\tgf_isom_set_mpegh_compatible_profiles(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint_list.vals, p->value.uint_list.nb_items);\n\t\t}\n\t} else if (codec_id==GF_CODECID_TRUEHD) {\n\t\tu32 fmt=0, prate=0;\n\t\t//not ready yet\n\t\tif (!dsi) return GF_OK;\n\t\tif (dsi->value.data.size < 6) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\tfmt = dsi->value.data.ptr[0];\n\t\tfmt <<= 8;\n\t\tfmt |= dsi->value.data.ptr[1];\n\t\tprate = dsi->value.data.ptr[2];\n\t\tprate <<= 8;\n\t\tprate |= dsi->value.data.ptr[3];\n\t\tprate >>= 1;\n\n\t\te = gf_isom_truehd_config_new(ctx->file, tkw->track_num, (char *)src_url, NULL, fmt, prate, &tkw->stsd_idx);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new TrueHD Audio sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t} else if (use_gen_sample_entry) {\n\t\tu8 isor_ext_buf[14], *gpac_meta_dsi=NULL;\n\t\tu32 len = 0;\n\t\tGF_GenericSampleDescription udesc;\n\t\tmemset(&udesc, 0, sizeof(GF_GenericSampleDescription));\n\n\t\tif (!comp_name) comp_name = \"Unknown\";\n\t\tlen = (u32) strlen(comp_name);\n\t\tif (len>32) len = 32;\n\t\tudesc.compressor_name[0] = len;\n\t\tmemcpy(udesc.compressor_name+1, comp_name, len);\n\t\tif ((codec_id==GF_CODECID_RAW) || unknown_generic)\n\t\t\tudesc.vendor_code = GF_4CC('G','P','A','C');\n\n\t\tudesc.samplerate = sr;\n\t\tudesc.nb_channels = nb_chan;\n\t\tudesc.bits_per_sample = nb_bps;\n\t\tudesc.lpcm_flags = afmt_flags | (1<<3); //add packed flag\n\t\t//for raw audio, select qt vs isom and set version\n\t\tif (sr && (codec_id==GF_CODECID_RAW)) {\n\t\t\tif (ctx->make_qt && (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS)) {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\t//if extensions or not 'raw ' or 'twos', use v1\n\t\t\t\tif (dsi ||\n\t\t\t\t\t((m_subtype!=GF_QT_SUBTYPE_TWOS) && (m_subtype!=GF_QT_SUBTYPE_RAW))\n\t\t\t\t) {\n\t\t\t\t\tudesc.version = 1;\n\t\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ase_mode<=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG) {\n\t\t\t\tm_subtype = m_subtype_alt_raw;\n\t\t\t\tudesc.extension_buf_size = 14;\n\t\t\t\tudesc.extension_buf = isor_ext_buf;\n\t\t\t\tmemset(isor_ext_buf, 0, sizeof(u8)*14);\n\t\t\t\tisor_ext_buf[3] = 14;\n\t\t\t\tisor_ext_buf[4] = 'p';\n\t\t\t\tisor_ext_buf[5] = 'c';\n\t\t\t\tisor_ext_buf[6] = 'm';\n\t\t\t\tisor_ext_buf[7] = 'C';\n\t\t\t\tisor_ext_buf[12] = (afmt_flags & (1<<1)) ? 0 : 1; //big/little endian\n\t\t\t\tisor_ext_buf[13] = nb_bps;\n\t\t\t\tif (ase_mode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG)\n\t\t\t\t\tudesc.version = 1;\n\t\t\t} else {\n\t\t\t\tudesc.is_qtff = GF_TRUE;\n\t\t\t\tudesc.version = 1;\n\t\t\t\tase_mode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;\n\t\t\t}\n\t\t}\n\n\t\tif (codec_id == GF_CODECID_FFMPEG) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_SUBTYPE);\n\t\t\tif (p) {\n\t\t\t\tm_subtype = p->value.uint;\n\t\t\t} else {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\t\tif (p && p->type==GF_PROP_UINT)\n\t\t\t\t\tm_subtype = p->value.uint;\n\t\t\t}\n\t\t}\n\n\t\tudesc.codec_tag = m_subtype;\n\t\tudesc.width = width;\n\t\tudesc.height = height;\n\t\tif (width) {\n\t\t\tudesc.v_res = 72;\n\t\t\tudesc.h_res = 72;\n\t\t\tudesc.depth = 24;\n\t\t}\n\t\tif (dsi) {\n\t\t\tudesc.extension_buf = dsi->value.data.ptr;\n\t\t\tudesc.extension_buf_size = dsi->value.data.size;\n\t\t\tudesc.ext_box_wrap = gen_dsi_wrap;\n\t\t\tp = gf_filter_pid_get_property_str(pid, \"DSIWrap\");\n\t\t\tif (p) {\n\t\t\t\tif (p->type==GF_PROP_UINT) udesc.ext_box_wrap = p->value.uint;\n\t\t\t\telse if (p->type==GF_PROP_STRING) udesc.ext_box_wrap = gf_4cc_parse(p->value.string);\n\t\t\t}\n\t\t}\n\t\tif (codec_id==GF_CODECID_FFV1) {\n\t\t\tudesc.codec_tag = GF_4CC('F', 'F', 'V', '1');\n\t\t\tudesc.ext_box_wrap = GF_4CC('g', 'l', 'b', 'l');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t}\n\t\tif (codec_id==GF_CODECID_SMPTE_VC1) {\n\t\t\tudesc.codec_tag = GF_4CC('v', 'c', '-', '1');\n\t\t\tunknown_generic = GF_FALSE;\n\t\t\tif (udesc.extension_buf)\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('d', 'v', 'c', '1');\n\t\t}\n\t\t//move to uncv\n\t\tif ((codec_id==GF_CODECID_RAW) && !ctx->make_qt && ctx->uncv && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tif ( gf_pixel_fmt_get_uncc(pix_fmt, ctx->uncv-1, &gpac_meta_dsi, &udesc.extension_buf_size) == GF_TRUE) {\n\t\t\t\tunknown_generic = GF_FALSE;\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.codec_tag = m_subtype = GF_ISOM_SUBTYPE_UNCV;\n\t\t\t}\n\t\t}\n\n\t\tif (unknown_generic) {\n\t\t\t//check if this is a meta codec (unmapped codec from ffmpeg or other)\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_ID);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_CODEC_NAME);\n\t\t\tif (p || p2) {\n\t\t\t\tu32 cid = (p && (p->type==GF_PROP_UINT)) ? p->value.uint : m_subtype;\n\t\t\t\tconst char *cname = p2 ? p2->value.string : NULL;\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u32(bs, codec_id);\n\t\t\t\tgf_bs_write_u32(bs, cid);\n\t\t\t\tgf_bs_write_utf8(bs, cname ? cname : gf_4cc_to_str(cid));\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_META_DEMUX_OPAQUE);\n\t\t\t\tgf_bs_write_u32(bs, p ? p->value.uint : 0);\n\n\t\t\t\tif (dsi && (dsi->type != GF_PROP_DATA) && (dsi->type != GF_PROP_CONST_DATA))\n\t\t\t\t\tdsi = NULL;\n\n\t\t\t\tif (dsi) {\n\t\t\t\t\tgf_bs_write_data(bs, dsi->value.data.ptr, dsi->value.data.size);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(bs, &gpac_meta_dsi, &udesc.extension_buf_size);\n\t\t\t\tudesc.extension_buf = gpac_meta_dsi;\n\t\t\t\tudesc.ext_box_wrap = GF_FALSE;\n\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing %s, using generic sample entry with 4CC \\\"GMCW\\\" and \\\"GMCC\\\" config box\\n\", gf_codecid_name(codec_id)));\n\t\t\t\tudesc.codec_tag = GF_4CC('G', 'M', 'C', 'W');\n\t\t\t\tudesc.ext_box_wrap = GF_4CC('G', 'M', 'C', 'C');\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] muxing unknown codec ID %s, using generic sample entry with 4CC \\\"%s\\\"\\n\", gf_codecid_name(codec_id), gf_4cc_to_str(m_subtype) ));\n\t\t\t}\n\t\t}\n\n\t\te = gf_isom_new_generic_sample_description(ctx->file, tkw->track_num, (char *)src_url, NULL, &udesc, &tkw->stsd_idx);\n\t\tif (gpac_meta_dsi) gf_free(gpac_meta_dsi);\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error creating new sample description for stream type %d codecid %d: %s\\n\", tkw->stream_type, codec_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\t\ttkw->use_dref = src_url ? GF_TRUE : GF_FALSE;\n\n\t} else {\n\t\tassert(0);\n\t}\n\n\tif (!tkw->all_stsd_crc) {\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update) {\n\t\t\tu32 avg_rate, max_rate, dbsize;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_BITRATE);\n\t\t\tavg_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_MAXRATE);\n\t\t\tmax_rate = p ? p->value.uint : 0;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DBSIZE);\n\t\t\tdbsize = p ? p->value.uint : 0;\n\n\t\t\tif (avg_rate && max_rate) {\n\t\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, avg_rate, max_rate, dbsize);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_isom_update_bitrate(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0);\n\t\t}\n\t}\n\nmultipid_stsd_setup:\n\tif (multi_pid_stsd) {\n\t\tif (multi_pid_idx<gf_list_count(multi_pid_stsd)) {\n\n\t\t\tif (multi_pid_final_stsd_idx == multi_pid_idx) {\n\t\t\t\tframes_per_sample_backup = tkw->nb_frames_per_sample;\n\t\t\t\tis_nalu_backup = tkw->is_nalu;\n\t\t\t}\n\t\t\tpid = gf_list_get(multi_pid_stsd, multi_pid_idx);\n\t\t\tmulti_pid_idx ++;\n\t\t\t//reload codecID, decoder config and enhancement decoder config\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);\n\t\t\tif (p) codec_id = p->value.uint;\n\t\t\tdsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\t\t\tenh_dsi = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\t\t\t//force stsd idx to be 0 to avoid removing the stsd\n\t\t\ttkw->stsd_idx = 0;\n\t\t\tgoto sample_entry_setup;\n\t\t}\n\t\ttkw->stsd_idx = multi_pid_final_stsd_idx;\n\t\t//restore input pid\n\t\tpid = orig_pid;\n\t\tcodec_id = tkw->codecid;\n\n\t\ttkw->is_nalu = is_nalu_backup;\n\t\ttkw->nb_frames_per_sample = frames_per_sample_backup;\n\t}\n\n\n\t//final opt: we couldn't detect before if the same stsd was possible, now that we have create a new one, check again\n\tif (needs_sample_entry) {\n\t\treuse_stsd = 0;\n\t\t//don't try to reuse STSDs in multi STSD setup for DASH\n\t\tif (multi_pid_stsd) count = 0;\n\t\telse count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tif (i+1 == tkw->stsd_idx) continue;\n\n\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, i+1) ) {\n\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\ttkw->stsd_idx = i+1;\n\t\t\t\treuse_stsd = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttkw->reused_stsd = reuse_stsd;\n\t\tif (!reuse_stsd) {\n\t\t\ttkw->samples_in_stsd = 0;\n\t\t} else if (use_3gpp_config) {\n\t\t\tGF_3GPConfig *gpp_cfg = gf_isom_3gp_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\tif (gpp_cfg) {\n\t\t\t\tgpp_cfg->AMR_mode_set = tkw->amr_mode_set;\n\t\t\t\tgf_isom_3gp_config_update(ctx->file, tkw->track_num, gpp_cfg, tkw->stsd_idx);\n\t\t\t\tgf_free(gpp_cfg);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted && !skip_crypto) {\n\t\tconst char *scheme_uri=NULL;\n\t\tconst char *kms_uri=NULL;\n\t\tu32 scheme_version=0;\n\t\tu32 scheme_type = 0;\n\t\tBool is_sel_enc = GF_FALSE;\n\t\tu32 KI_length=0;\n\t\tu32 IV_length=0;\n\t\t/*todo !*/\n\t\tconst char *oma_contentID=0;\n\t\tu32 oma_encryption_type=0;\n\t\tu64 oma_plainTextLength=0;\n\t\tconst char *oma_textual_headers=NULL;\n\t\tu32 textual_headers_len=0;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_SCHEME_URI);\n\t\tif (p) scheme_uri = p->value.string;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PROTECTION_KMS_URI);\n\t\tif (p) kms_uri = p->value.string;\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_SELECTIVE_ENC);\n\t\tif (p) is_sel_enc = p->value.boolean;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_IV_LENGTH);\n\t\tif (p) IV_length = p->value.uint;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISMA_KI_LENGTH);\n\t\tif (p) KI_length = p->value.uint;\n\n\t\ttkw->scheme_type = scheme_type;\n\t\tswitch (scheme_type) {\n\t\tcase GF_ISOM_ISMACRYP_SCHEME:\n\t\t\tgf_isom_set_ismacryp_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char *) scheme_uri, (char *) kms_uri, is_sel_enc, KI_length, IV_length);\n\t\t\tbreak;\n\t\tcase GF_ISOM_OMADRM_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CRYPT_TYPE);\n\t\t\tif (p) oma_encryption_type = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CID);\n\t\t\tif (p) oma_contentID = p->value.string;\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_TXT_HDR);\n\t\t\tif (p) oma_textual_headers = p->value.string;\n\t\t\tif (oma_textual_headers) textual_headers_len = (u32) strlen(oma_textual_headers);\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_OMA_CLEAR_LEN);\n\t\t\tif (p) oma_plainTextLength = p->value.longuint;\n\t\t\tgf_isom_set_oma_protection(ctx->file, tkw->track_num, tkw->stsd_idx, (char *) oma_contentID, (char*) kms_uri, oma_encryption_type, oma_plainTextLength, (char*)oma_textual_headers, textual_headers_len,\n                                  is_sel_enc, KI_length, IV_length);\n\n\t\t\tbreak;\n\t\tcase GF_ISOM_ADOBE_SCHEME:\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ADOBE_CRYPT_META);\n\t\t\tgf_isom_set_adobe_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, 1/*scheme_version*/, 1/*is_sel_enc*/,p ? p->value.data.ptr : NULL, p ? p->value.data.size : 0);\n\t\t\tbreak;\n\t\tcase GF_ISOM_PIFF_SCHEME:\n\t\tcase GF_ISOM_CENC_SCHEME:\n\t\tcase GF_ISOM_CENS_SCHEME:\n\t\tcase GF_ISOM_CBC_SCHEME:\n\t\tcase GF_ISOM_CBCS_SCHEME:\n\t\tcase GF_HLS_SAMPLE_AES_SCHEME:\n\t\t\ttkw->cenc_state = CENC_NEED_SETUP;\n\t\t\tif (tkw->is_nalu || tkw->is_av1 || tkw->is_vpx) tkw->cenc_subsamples = GF_TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unrecognized protection scheme type %s, using generic signaling\\n\", gf_4cc_to_str(scheme_type) ));\n\t\t\tswitch (tkw->stream_type) {\n\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCV);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCA);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_TEXT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCT);\n\t\t\t\tbreak;\n\t\t\tcase GF_STREAM_FONT:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCF);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgf_isom_set_media_type(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_ENCS);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgf_isom_set_generic_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, (char*)scheme_uri, (char*)kms_uri);\n\t\t}\n\t} else if (!tkw->is_encrypted) {\n\t\t//in case we used track template\n\t\tgf_isom_remove_samp_enc_box(ctx->file, tkw->track_num);\n\t\tgf_isom_remove_samp_group_box(ctx->file, tkw->track_num);\n\t}\n\n\tif (is_true_pid) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:scal\", GF_ISOM_REF_SCAL, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:sbas\", GF_ISOM_REF_BASE, GF_FALSE);\n\t\t//whenever we add a new tile track, rewrite sabt on main tile track\n\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\tcount = gf_list_count(ctx->tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tTrackWriter *base_tk = gf_list_get(ctx->tracks, i);\n\t\t\t\tif (base_tk->is_hevc_tile_base)\n\t\t\t\t\tmp4_mux_write_track_refs(ctx, base_tk, \"isom:sabt\", GF_ISOM_REF_SABT, GF_FALSE);\n\t\t\t}\n\t\t}\n\n\t\t//check if we have sample-accurate seek info for the pid. If so, enable seek ts checking\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (p && p->value.sint)\n\t\t\ttkw->check_seek_ts = GF_TRUE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t}\n\n\t} else if (codec_id==GF_CODECID_HEVC_TILES) {\n\t\tmp4_mux_write_track_refs(ctx, tkw, \"isom:tbas\", GF_ISOM_REF_TBAS, GF_TRUE);\n\t}\n\n\tif (is_true_pid && ctx->dash_mode && is_tile_base) {\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_MULTI_TRACK);\n\t\tif (p) {\n\t\t\tGF_List *multi_tracks = p->value.ptr;\n\t\t\tcount = gf_list_count(multi_tracks);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_FilterPid *a_ipid = gf_list_get(multi_tracks, i);\n\t\t\t\tmp4_mux_setup_pid(filter, a_ipid, GF_FALSE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (width) {\n\t\tif (ctx->ccst) {\n\t\t\te = gf_isom_set_image_sequence_coding_constraints(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE, GF_FALSE, GF_TRUE, 15);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set coding constraints parameter: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\t\tif (p && p->value.boolean) {\n\t\t\te = gf_isom_set_image_sequence_alpha(ctx->file, tkw->track_num, tkw->stsd_idx, GF_FALSE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set alpha config: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\nsample_entry_done:\n\tif (!tkw->is_item) {\n\t\tif (ctx->maxchunk)\n\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, ctx->maxchunk);\n\n\t\tif (ctx->store==MP4MX_MODE_FLAT)\n\t\t\tgf_isom_hint_max_chunk_duration(ctx->file, tkw->track_num, tkw->tk_timescale * ctx->cdur.num / ctx->cdur.den);\n\n\t\tif (sr) {\n\t\t\tif (use_flac_entry) {\n\t\t\t\twhile (sr>65535) {\n\t\t\t\t\tu32 val = sr/2;\n\t\t\t\t\tif (val*2 != sr) {\n\t\t\t\t\t\tsr=65535;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsr = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m_subtype!=GF_QT_SUBTYPE_LPCM) {\n\t\t\t\tgf_isom_set_audio_info(ctx->file, tkw->track_num, tkw->stsd_idx, sr, nb_chan, nb_bps, ctx->make_qt ? GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF : ase_mode);\n\t\t\t}\n\n\t\t\tif ((m_subtype==GF_ISOM_SUBTYPE_IPCM) || (m_subtype==GF_ISOM_SUBTYPE_FPCM)) {\n\t\t\t\tGF_AudioChannelLayout layout;\n\t\t\t\tmemset(&layout, 0, sizeof(GF_AudioChannelLayout));\n\t\t\t\tlayout.stream_structure = 1;\n\t\t\t\tlayout.channels_count = nb_chan;\n\t\t\t\tif (ch_layout)\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_from_layout(ch_layout);\n\t\t\t\telse\n\t\t\t\t\tlayout.definedLayout = gf_audio_fmt_get_cicp_layout(nb_chan, 0, 0);\n\t\t\t\tgf_isom_set_audio_layout(ctx->file, tkw->track_num, tkw->stsd_idx, &layout);\n\t\t\t}\n\t\t}\n\t\telse if (width) {\n\t\t\tu32 colour_type=0;\n\t\t\tu16 colour_primaries=0, transfer_characteristics=0, matrix_coefficients=0;\n\t\t\tBool full_range_flag=GF_FALSE;\n\n\t\t\tgf_isom_set_visual_info(ctx->file, tkw->track_num, tkw->stsd_idx, width, height);\n\t\t\tif (sar.den) {\n\t\t\t\tif (sar.num != sar.den) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, sar.num, sar.den, GF_FALSE);\n\t\t\t\t\twidth = width * sar.num / sar.den;\n\t\t\t\t}\n\t\t\t\t//old importer did not set PASP for\n\t\t\t\telse if (!gf_sys_old_arch_compat() || (codec_id!=GF_CODECID_MPEG4_PART2) ) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, 1, 1, GF_TRUE);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, width<<16, height<<16, 0, 0, z_order);\n\t\t\tif (codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ORIG_SIZE);\n\t\t\t\tif (p) {\n\t\t\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, p->value.vec2i.x<<16, p->value.vec2i.y<<16, 0, 0, z_order);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_PRIMARIES);\n\t\t\tif (p) colour_primaries = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_TRANSFER);\n\t\t\tif (p) transfer_characteristics = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_MX);\n\t\t\tif (p) matrix_coefficients = p->value.uint;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_COLR_RANGE);\n\t\t\tif (p) full_range_flag = p->value.boolean;\n\n\t\t\tif (ctx->cmaf) {\n\t\t\t\tu32 hspac=0, vspac=0;\n\t\t\t\tforce_colr = GF_TRUE;\n\t\t\t\tgf_isom_get_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, &hspac, &vspac);\n\t\t\t\tif (hspac && vspac) {\n\t\t\t\t\tsar.num = hspac;\n\t\t\t\t\tsar.den = vspac;\n\t\t\t\t} else {\n\t\t\t\t\tsar.den = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->prores_track == tkw) || force_colr) {\n\t\t\t\tu32 colr_mode;\n\n\t\t\t\tif ((ctx->prores_track == tkw) || ctx->make_qt)\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','c');\n\t\t\t\telse\n\t\t\t\t\tcolr_mode = GF_4CC('n','c','l','x');\n\n\t\t\t\t//other conditions were set above, here we force 1:1 pasp box even if no sar or 1:1\n\t\t\t\tif (!sar.den || (sar.num == 1)) {\n\t\t\t\t\tgf_isom_set_pixel_aspect_ratio(ctx->file, tkw->track_num, tkw->stsd_idx, -1, -1, GF_TRUE);\n\t\t\t\t}\n\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, GF_FALSE, NULL, 0);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\te = gf_media_get_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, &colour_type, &colour_primaries, &transfer_characteristics, &matrix_coefficients, &full_range_flag);\n\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t\te = GF_NOT_FOUND;\n\t\t\t\t\t}\n\t\t\t\t\tif (e==GF_NOT_FOUND) {\n\t\t\t\t\t\tcolour_primaries = 1;\n\t\t\t\t\t\ttransfer_characteristics = 1;\n\t\t\t\t\t\tmatrix_coefficients = 1;\n\t\t\t\t\t\tfull_range_flag = GF_FALSE;\n\t\t\t\t\t\tif (ctx->make_qt==1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ProRes] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ctx->cmaf) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[CMAF] No color info present in visual track, defaulting to BT709\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, colr_mode, colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->prores_track == tkw) {\n\t\t\t\t\tu32 chunk_size;\n\t\t\t\t\tif ((width<=720) && (height<=576)) chunk_size = 2000000;\n\t\t\t\t\telse chunk_size = 4000000;\n\t\t\t\t\tgf_isom_hint_max_chunk_size(ctx->file, tkw->track_num, chunk_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (colour_primaries || transfer_characteristics || matrix_coefficients) {\n\t\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC('n','c','l','x'), colour_primaries, transfer_characteristics, matrix_coefficients, full_range_flag, NULL, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//check if we have an icc profile\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ICC_PROFILE);\n\t\t\tif (p && (p->type==GF_PROP_DATA) && p->value.data.ptr) {\n\t\t\t\tgf_isom_set_visual_color_info(ctx->file, tkw->track_num, tkw->stsd_idx, 0, 0, 0, 0, GF_FALSE, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\n\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONTENT_LIGHT_LEVEL);\n\t\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MASTER_DISPLAY_COLOUR);\n\t\t\tif (p || p2) {\n\t\t\t\tGF_MasteringDisplayColourVolumeInfo mdcv;\n\t\t\t\tGF_ContentLightLevelInfo clli;\n\t\t\t\tGF_BitStream *bs;\n\t\t\t\tif (p) {\n\t\t\t\t\tbs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\t\tclli.max_content_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tclli.max_pic_average_light_level = gf_bs_read_int(bs, 16);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tif (p2) {\n\t\t\t\t\tbs = gf_bs_new(p2->value.data.ptr, p2->value.data.size, GF_BITSTREAM_READ);\n\n\t\t\t\t\tfor(u32 c=0;c<3;c++) {\n\t\t\t\t\t\tmdcv.display_primaries[c].x = gf_bs_read_int(bs, 16);\n\t\t\t\t\t\tmdcv.display_primaries[c].y = gf_bs_read_int(bs, 16);\n\t\t\t\t\t}\n\t\t\t\t\tmdcv.white_point_x = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.white_point_y = gf_bs_read_int(bs, 16);\n\t\t\t\t\tmdcv.max_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tmdcv.min_display_mastering_luminance = gf_bs_read_int(bs, 32);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t}\n\t\t\t\tgf_isom_set_high_dynamic_range_info(ctx->file, tkw->track_num, tkw->stsd_idx, p2 ? &mdcv : NULL, p ? &clli : NULL);\n\t\t\t}\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DOLBY_VISION);\n\t\t\tif (p) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\t\t\t\tGF_DOVIDecoderConfigurationRecord *dvcc = gf_odf_dovi_cfg_read_bs(bs);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t\tif (dvcc && tkw->xps_inband && (dvcc->dv_profile==8) && ctx->dvsingle) {\n\t\t\t\t\tGF_DOVIDecoderConfigurationRecord *dovi = gf_isom_dovi_config_get(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tif (dovi) {\n\t\t\t\t\t\tif (dovi->dv_profile==5) {\n\t\t\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t\t\t\tdvcc = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_odf_dovi_cfg_del(dovi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dvcc) {\n\t\t\t\t\tif (ctx->force_dv)\n\t\t\t\t\t\tdvcc->force_dv = 1;\n\n\t\t\t\t\tgf_isom_set_dolby_vision_profile(ctx->file, tkw->track_num, tkw->stsd_idx, dvcc);\n\n\t\t\t\t\tif (!dvcc->bl_present_flag) {\n\t\t\t\t\t\tu32 ref_id = 0;\n\n\t\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DEPENDENCY_ID);\n\t\t\t\t\t\tif (p) ref_id = p->value.uint;\n\t\t\t\t\t\tfor (i=0; i<gf_list_count(ctx->tracks); i++) {\n\t\t\t\t\t\t\tTrackWriter *tkw_base = gf_list_get(ctx->tracks, i);\n\t\t\t\t\t\t\tif (tkw_base == tkw) continue;\n\t\t\t\t\t\t\tif (tkw->codecid!=tkw_base->codecid) continue;\n\t\t\t\t\t\t\tif (ref_id) {\n\t\t\t\t\t\t\t\tp = gf_filter_pid_get_property(tkw_base->ipid, GF_PROP_PID_ID);\n\t\t\t\t\t\t\t\tif (!p || (p->value.uint!=ref_id)) continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tref_id = gf_isom_get_track_id(ctx->file, tkw_base->track_num);\n\t\t\t\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_4CC('v','d','e','p'), ref_id);\n\n\t\t\t\t\t\t\t//dolby requires seperate moof for each track fragment for base and el\n\t\t\t\t\t\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\t\t\t\t\t\tctx->straf = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_dovi_cfg_del(dvcc);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = (codec_id==GF_CODECID_HEVC) ? gf_filter_pid_get_property_str(pid, \"hevc_split\") : NULL;\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CROP_POS);\n\t\t\t\tp2 = gf_filter_pid_get_property(pid, GF_PROP_PID_ORIG_SIZE);\n\t\t\t\tif (p && p2) {\n#define GPAC_SRD_SIZE\t21\n\t\t\t\t\tu8 srdg[GPAC_SRD_SIZE];\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new(srdg, GPAC_SRD_SIZE, GF_BITSTREAM_WRITE);\n\t\t\t\t\tgf_bs_write_int(bs, 1, 1);//mergeable\n\t\t\t\t\tgf_bs_write_int(bs, 0, 7);//unused\n\t\t\t\t\tgf_bs_write_u32(bs, 1);//groupID\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.x);//offx\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.y);//offy\n\t\t\t\t\tgf_bs_write_u32(bs, p2->value.vec2i.x);//osize_w\n\t\t\t\t\tgf_bs_write_u32(bs, p2->value.vec2i.y);//osize_h\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t//stored as track user data for now\n\t\t\t\t\tgf_isom_add_user_data(ctx->file, tkw->track_num, GF_ISOM_UDTA_GPAC_SRD, NULL, srdg, GPAC_SRD_SIZE);\n\n\t\t\t\t\ts32 mx[9];\n\t\t\t\t\tmemset(mx, 0, sizeof(s32)*9);\n\t\t\t\t\tmx[0] = mx[4] = 0x00010000;\n\t\t\t\t\tmx[8] = 0x40000000;\n\t\t\t\t\tmx[6] = 65536*p->value.vec2i.x;\n\t\t\t\t\tmx[7] = 65536*p->value.vec2i.y;\n\t\t\t\t\tgf_isom_set_track_matrix(ctx->file, tkw->track_num, mx);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t//default for old arch\n\t\telse if (force_tk_layout\n\t\t\t|| (use_m4sys && (tkw->stream_type==GF_STREAM_VISUAL) && !width && !height)\n\t\t)  {\n\t\t\tgf_isom_set_track_layout_info(ctx->file, tkw->track_num, 320<<16, 240<<16, 0, 0, 0);\n\t\t}\n\n\t\tif (lang_name) gf_isom_set_media_language(ctx->file, tkw->track_num, (char*)lang_name);\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_TEMPLATE);\n\t\tif (ctx->tktpl && p && p->value.data.ptr) {\n\t\t\tgf_isom_update_sample_description_from_template(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.data.ptr, p->value.data.size);\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_TIMES);\n\t\tconst GF_PropertyValue *p2 = gf_filter_pid_get_property(pid, GF_PROP_PID_CHAP_NAMES);\n\t\tif (p && p2 && (p->value.uint_list.nb_items == p2->value.string_list.nb_items)) {\n\t\t\tBool add_chap=GF_FALSE;\n\t\t\tBool add_tk=GF_FALSE;\n\t\t\tu32 trak_di=0;\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_UDTA)) {\n\t\t\t\tgf_isom_remove_chapter(ctx->file, 0, 0);\n\t\t\t\tadd_chap = GF_TRUE;\n\t\t\t}\n\t\t\tif (((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK))\n\t\t\t\t&& !ctx->chap_track_num\n\t\t\t) {\n\t\t\t\tGF_FontRecord frec;\n\t\t\t\tGF_TextSampleDescriptor txtdesc;\n\t\t\t\tctx->chap_track_num = gf_isom_new_track(ctx->file, 0xFFFE, GF_ISOM_MEDIA_TEXT, 1000);\n\t\t\t\tgf_isom_set_track_flags (ctx->file, ctx->chap_track_num, GF_ISOM_TK_IN_MOVIE|GF_ISOM_TK_IN_PREVIEW, GF_ISOM_TKFLAGS_SET);\n\t\t\t\t//move chapter track last\n\t\t\t\tgf_isom_set_track_index(ctx->file, ctx->chap_track_num, 0xFFFE, mp4mux_track_reorder, ctx);\n\t\t\t\tmemset(&txtdesc, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttxtdesc.font_count = 1;\n\t\t\t\ttxtdesc.fonts = &frec;\n\t\t\t\tfrec.fontName = \"SANS\";\n\t\t\t\tfrec.fontID=1;\n\t\t\t\ttxtdesc.default_style.fontID=1;\n\t\t\t\ttxtdesc.default_style.font_size = 32;\n\t\t\t\t//txtdesc.default_style.text_color = 0xFFFFFFFF;\n\t\t\t\t//txtdesc.horiz_justif = 1;\n\t\t\t\t//txtdesc.vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\t\t\t\tgf_isom_new_text_description(ctx->file, ctx->chap_track_num, &txtdesc, NULL, NULL, &trak_di);\n\t\t\t\tadd_tk = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (add_tk || add_chap) {\n\t\t\t\tu32 j;\n\t\t\t\tu64 maxts = (ctx->dur.num && ctx->dur.den) ? gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, 1000) : 0;\n\t\t\t\tfor (j=0; j<p->value.uint_list.nb_items; j++) {\n\t\t\t\t\tu32 start_time = p->value.uint_list.vals[j];\n\t\t\t\t\tif (ctx->start > start_time) {\n\t\t\t\t\t\tif (j+1 < p->value.uint_list.nb_items) {\n\t\t\t\t\t\t\tu64 next = p->value.uint_list.vals[j+1];\n\t\t\t\t\t\t\tif (ctx->start>=next)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (start_time > (u32) ctx->start) start_time -= (u32) ctx->start;\n\t\t\t\t\t\telse start_time=0;\n\t\t\t\t\t}\n\t\t\t\t\tif (maxts && (maxts<=start_time))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (add_chap) {\n\t\t\t\t\t\tgf_isom_add_chapter(ctx->file, 0, start_time, p2->value.string_list.vals[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (add_tk && p2->value.string_list.vals[j]) {\n\t\t\t\t\t\tGF_TextSample tx;\n\t\t\t\t\t\tmemset(&tx, 0, sizeof(tx));\n\t\t\t\t\t\ttx.text = p2->value.string_list.vals[j];\n\t\t\t\t\t\ttx.len = (u32) strlen(p2->value.string_list.vals[j])+1;\n\t\t\t\t\t\tGF_ISOSample *samp = gf_isom_text_to_sample(&tx);\n\t\t\t\t\t\tsamp->DTS = start_time;\n\t\t\t\t\t\tsamp->IsRAP = 1;\n\n\t\t\t\t\t\t//force fist chapter to start at 0\n\t\t\t\t\t\tif (!j && samp->DTS) {\n\t\t\t\t\t\t\tsamp->DTS = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_add_sample(ctx->file, ctx->chap_track_num, trak_di, samp);\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->chapm==MP4MX_CHAPM_BOTH) || (ctx->chapm==MP4MX_CHAPM_TRACK)) {\n\t\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_CHAP, gf_isom_get_track_id(ctx->file, ctx->chap_track_num));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->is_encrypted) {\n\t\ttkw->cenc_ki = gf_filter_pid_get_property(pid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (tkw->cenc_ki && ((tkw->cenc_ki->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size))\n\t\t) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC key info\\n\"));\n\t\t\ttkw->cenc_ki = NULL;\n\t\t}\n\n\t\ttkw->constant_IV_size = 0;\n\t\tif (tkw->cenc_ki && tkw->cenc_ki->value.data.ptr) {\n\t\t\ttkw->cenc_multikey = tkw->cenc_ki->value.data.ptr[0] ? GF_TRUE : GF_FALSE;\n\n\t\t\tif (!tkw->cenc_ki->value.data.ptr[3])\n\t\t\t\ttkw->constant_IV_size = !tkw->cenc_ki->value.data.ptr[20];\n\n\t\t\ttkw->cenc_key_info_crc = gf_crc_32(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t}\n\t}\n\n\tif (is_true_pid) {\n\t\tconst GF_PropertyValue *ster = gf_filter_pid_get_property(pid, GF_PROP_PID_STEREO_TYPE);\n\t\tconst GF_PropertyValue *proj = gf_filter_pid_get_property(pid, GF_PROP_PID_PROJECTION_TYPE);\n\t\tconst GF_PropertyValue *pose = gf_filter_pid_get_property(pid, GF_PROP_PID_VR_POSE);\n\n\t\tif (ster || proj) {\n\t\t\tGF_ISOM_Y3D_Info yt3d;\n\t\t\tmemset(&yt3d, 0, sizeof(GF_ISOM_Y3D_Info));\n\t\t\tyt3d.projection_type = proj ? proj->value.uint : 0;\n\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\tif (pose) {\n\t\t\t\tyt3d.pose_present = GF_TRUE;\n\t\t\t\tyt3d.yaw = pose->value.vec3i.x;\n\t\t\t\tyt3d.pitch = pose->value.vec3i.y;\n\t\t\t\tyt3d.roll = pose->value.vec3i.z;\n\t\t\t\tyt3d.stereo_type = ster ? ster->value.uint : 0;\n\t\t\t}\n\t\t\tif (yt3d.projection_type==GF_PROJ360_CUBE_MAP) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_CUBE_MAP_PAD);\n\t\t\t\tyt3d.padding = proj ? proj->value.uint : 0;\n\t\t\t}\n\t\t\telse if (yt3d.projection_type==GF_PROJ360_EQR) {\n\t\t\t\tproj = gf_filter_pid_get_property(pid, GF_PROP_PID_EQR_CLAMP);\n\t\t\t\tif (proj) {\n\t\t\t\t\tyt3d.top = proj->value.vec4i.x;\n\t\t\t\t\tyt3d.bottom = proj->value.vec4i.y;\n\t\t\t\t\tyt3d.left = proj->value.vec4i.z;\n\t\t\t\t\tyt3d.right = proj->value.vec4i.w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_set_y3d_info(ctx->file, tkw->track_num, tkw->stsd_idx, &yt3d);\n\t\t}\n\t}\n\n\n\tif (is_true_pid && ctx->importer && !tkw->import_msg_header_done) {\n#ifndef GPAC_DISABLE_LOG\n\t\tconst char *dst_type = tkw->is_item ? \"Item Importing\" : \"Track Importing\";\n#endif\n\t\ttkw->import_msg_header_done = GF_TRUE;\n\t\tif (!imp_name) imp_name = comp_name;\n\t\tif (sr) {\n\t\t\tif (nb_chan) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d Num Channels %d\\n\", dst_type, imp_name, sr, nb_chan));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - SampleRate %d\\n\", dst_type, imp_name, sr));\n\t\t\t}\n\t\t} else if (is_text_subs) {\n\t\t\tif (txt_fsize || txt_font) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d font %s (size %d) layer %d\\n\", dst_type, imp_name, width, height, txt_font ? txt_font : \"unspecified\", txt_fsize, z_order));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Text track %d x %d layer %d\\n\", dst_type, imp_name, width, height, z_order));\n\n\t\t\t}\n\t\t} else if (width) {\n\t\t\tif (sar.den && sar.num) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d SAR %d/%u\\n\", dst_type, imp_name, width, height, fps.num, fps.den, sar.num, sar.den));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s - Width %d Height %d FPS %d/%d\\n\", dst_type, imp_name, width, height, fps.num, fps.den));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"%s %s\\n\", dst_type, imp_name));\n\t\t}\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tif (tkw->svcc) {\n\t\t\tAVCState avc;\n\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\tcount = gf_list_count(tkw->svcc->sequenceParameterSets);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_NALUFFParam *sl = gf_list_get(tkw->svcc->sequenceParameterSets, i);\n\t\t\t\tu8 nal_type = sl->data[0] & 0x1F;\n\t\t\t\tBool is_subseq = (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) ? GF_TRUE : GF_FALSE;\n\t\t\t\ts32 ps_idx = gf_avc_read_sps(sl->data, sl->size, &avc, is_subseq, NULL);\n\t\t\t\tif (ps_idx>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"SVC Detected - SSPS ID %d - frame size %d x %d\\n\", ps_idx-GF_SVC_SSPS_ID_SHIFT, avc.sps[ps_idx].width, avc.sps[ps_idx].height ));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t}\n\tif (txt_font) gf_free(txt_font);\n\tif (!tkw->xps_inband || tkw->is_item) {\n\t\tif (tkw->svcc) {\n\t\t\tgf_odf_avc_cfg_del(tkw->svcc);\n\t\t\ttkw->svcc = NULL;\n\t\t}\n\t\tif (tkw->lvcc) {\n\t\t\tgf_odf_hevc_cfg_del(tkw->lvcc);\n\t\t\ttkw->lvcc = NULL;\n\t\t}\n\t} else if (needs_sample_entry || make_inband_headers) {\n\t\tmp4_mux_make_inband_header(ctx, tkw, GF_FALSE);\n\t\tif (ctx->pps_inband || tkw->xps_inband)\n\t\t\tmp4_mux_make_inband_header(ctx, tkw, GF_TRUE);\n\t}\n\n\ttkw->negctts_shift = 0;\n\ttkw->probe_min_ctts = GF_FALSE;\n\tif (is_true_pid && !tkw->nb_samples && !tkw->is_item) {\n\t\tBool use_negccts = GF_FALSE;\n\t\tBool remove_edits = GF_FALSE;\n\t\ts64 moffset=0;\n\t\tctx->config_timing = GF_TRUE;\n\t\tctx->update_report = GF_TRUE;\n\n\t\t//if we have an edit list (due to track template) only providing media offset, trash it\n\t\tif (!gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) {\n\t\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t} else {\n\t\t\t\t//old arch compat: if we had a simple edit list in source, keep dur and offset\n\t\t\t\t//and avoid rewriting it when recomputing edit for b-frames\n\t\t\t\tu64 etime, sdur;\n\t\t\t\tGF_ISOEditType etype;\n\t\t\t\tgf_isom_get_edit(ctx->file, tkw->track_num, 1, &etime, &sdur, &moffset, &etype);\n\t\t\t\tif (!etime && sdur) {\n\t\t\t\t\ttkw->imported_edit_sdur = sdur;\n\t\t\t\t\ttkw->imported_edit_offset = moffset;\n\t\t\t\t}\n\t\t\t\tremove_edits = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) use_negccts = GF_TRUE;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DELAY);\n\t\tif (p) {\n\t\t\t//media skip\n\t\t\tif (p->value.longsint < 0) {\n\t\t\t\t//if cmf2, remove edits and use negctss\n\t\t\t\tif ((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tctx->ctmode = MP4MX_CT_NEGCTTS;\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ctx->ctmode==MP4MX_CT_NEGCTTS) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\t\tuse_negccts = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, 0, -p->value.longsint, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//media delay\n\t\t\telse if (p->value.longsint > 0) {\n\t\t\t\t//if cmaf (whether cmfc or cmf2), remove edits and add delay to tfdt\n\t\t\t\tif (ctx->cmaf) {\n\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\ttkw->patch_tfdt = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dur = gf_timestamp_rescale_signed(p->value.longsint, tkw->src_timescale, ctx->moovts);\n\t\t\t\t\ts64 diff_low = (s64) p->value.longuint - dur * tkw->src_timescale / ctx->moovts;\n\t\t\t\t\t//we are loosing precision, check if true value is closer to next representable value in movie timescale\n\t\t\t\t\tif (diff_low>0) {\n\t\t\t\t\t\ts64 diff_high = (dur+1) * tkw->src_timescale / ctx->moovts - (s64) p->value.longuint;\n\t\t\t\t\t\tif (diff_high < diff_low) dur++;\n\t\t\t\t\t}\n\t\t\t\t\tif (remove_edits) {\n\t\t\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t\t\t}\n\t\t\t\t\tif (dur) {\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->ts_delay = (s32) p->value.longsint;\n\t\t} else if (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\ttkw->probe_min_ctts = GF_TRUE;\n\t\t}\n\t\t//for old arch compatibility\n\t\telse if (remove_edits) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"reframer_rem_edits\");\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t}\n\t\tif (use_negccts) {\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_TRUE);\n\n\t\t\tif (!tkw->has_brands) {\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\t\t}\n\n\t\t\ttkw->negctts_shift = (tkw->ts_delay<0) ? -tkw->ts_delay : 0;\n\t\t} else {\n\t\t\t//this will remove any cslg in the track due to template\n\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\t\t}\n\n\t\tif (!ctx->noinit) {\n\t\t\tmp4_mux_set_tags(ctx, tkw);\n\t\t\tmp4_mux_set_udta(ctx, tkw);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx);\n#endif\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final);\n\nstatic GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ctx->ref_tkw == tkw) ctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\t//removing last pid\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\t//non-frag file, flush file\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t//delete output pid (to flush destruction of filter chain)\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}\n\nstatic Bool mp4_mux_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_INFO_UPDATE) ) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(evt->base.on_pid);\n\t\tif (tkw) {\n\t\t\tGF_PropertyEntry *pe=NULL;\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_BYTES, &pe);\n\t\t\tif (p) tkw->down_bytes = p->value.longuint;\n\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_DOWN_SIZE, &pe);\n\t\t\tif (p) tkw->down_size = p->value.longuint;\n\n\t\t\tgf_filter_release_property(pe);\n\t\t}\n\n\t\treturn GF_FALSE;\n\t}\n\tif (!evt->base.on_pid && (evt->base.type==GF_FEVT_STOP) ) {\n\t\tif (ctx->file && ctx->owns_mov) {\n\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t}\n\t}\n\tif (evt->base.on_pid && (evt->base.type==GF_FEVT_PLAY) ) {\n\t\tu32 i, count;\n\t\tGF_FilterEvent anevt;\n\t\tctx->force_play = GF_TRUE;\n\t\tif (evt->play.speed<0)\n\t\t\tctx->is_rewind = GF_TRUE;\n\n\t\tif (ctx->start == 0)\n\t\t\treturn GF_FALSE;\n\n\t\tcount = gf_list_count(ctx->tracks);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->fake_track) continue;\n\n\t\t\tanevt.play = evt->play;\n\t\t\tgf_filter_pid_init_play_event(tkw->ipid, &anevt, ctx->start, 0, \"MP4Mux\");\n\t\t\tif (anevt.play.start_range > 0)\n\t\t\t\ttkw->wait_sap = GF_TRUE;\n\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &anevt);\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nenum\n{\n\tCENC_CONFIG=0,\n\tCENC_ADD_NORMAL,\n\tCENC_ADD_FRAG,\n};\n\nstatic void mp4_mux_cenc_insert_pssh(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const GF_PropertyValue *pssh, u32 dyn_pssh_mode)\n{\n\tbin128 *keyIDs=NULL;\n\tu32 max_keys = 0;\n\tu32 i, nb_pssh;\n\tGF_PropertyValue _the_prop;\n\n\t//set pssh\n\tconst GF_PropertyValue *p=NULL;\n\n\t//only inject if pssh in packet\n\tif (dyn_pssh_mode==2) {\n\t\tGF_FilterPacket *pck;\n\t\t//nothing to inject\n\t\tif (!tkw->dyn_pssh) return;\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (pck) {\n\t\t\tpssh = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t//change of dynamic pssh is pending, don't inject the old one\n\t\t\tif (pssh) return;\n\t\t}\n\t\t_the_prop.type = GF_PROP_DATA;\n\t\t_the_prop.value.data.ptr = tkw->dyn_pssh;\n\t\t_the_prop.value.data.size = tkw->dyn_pssh_len;\n\t\tp = &_the_prop;\n\t} else {\n\t\tif (pssh) {\n\t\t\tp = pssh;\n\t\t} else {\n\t\t\t//inject pssh from packet if any, or from PID (used for keyroll of master+leaf schemes)\n\t\t\tif (dyn_pssh_mode) {\n\t\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t\tif (pck) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p)\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PSSH);\n\t\t}\n\t\tif (!p) return;\n\t}\n\n\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);\n\telse gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size);\n\n\tnb_pssh = gf_bs_read_u32(ctx->bs_r);\n\tfor (i = 0; i < nb_pssh; i++) {\n\t\tu32 mode;\n\t\tbin128 sysID;\n\t\tu32 j, kid_count, version=0;\n\t\tchar *data;\n\t\tu32 len;\n\n\t\tgf_bs_read_data(ctx->bs_r, sysID, 16);\n\t\tversion = gf_bs_read_u32(ctx->bs_r);\n\t\tkid_count = version ? gf_bs_read_u32(ctx->bs_r) : 0;\n\n\t\tif (kid_count>=max_keys) {\n\t\t\tmax_keys = kid_count;\n\t\t\tkeyIDs = gf_realloc(keyIDs, sizeof(bin128)*max_keys);\n\t\t}\n\t\tfor (j=0; j<kid_count; j++) {\n\t\t\tgf_bs_read_data(ctx->bs_r, keyIDs[j], 16);\n\t\t}\n\t\tlen = gf_bs_read_u32(ctx->bs_r);\n\t\tdata = p->value.data.ptr + gf_bs_get_position(ctx->bs_r);\n\n\t\tif (tkw->is_item) mode = 2;\n\t\telse if (tkw->scheme_type==GF_ISOM_PIFF_SCHEME) mode = 1;\n\t\telse mode = 0;\n\n\t\tgf_cenc_set_pssh(ctx->file, sysID, version, kid_count, keyIDs, data, len, mode);\n\t\tgf_bs_skip_bytes(ctx->bs_r, len);\n\t\tif (gf_bs_is_overflow(ctx->bs_r))\n\t\t\tbreak;\n\t}\n\tif (keyIDs) gf_free(keyIDs);\n\n\n\tif (pssh) {\n\t\tif (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);\n\t\ttkw->dyn_pssh = gf_malloc(sizeof(u8) * pssh->value.data.size);\n\t\tif (!tkw->dyn_pssh) return;\n\t\tmemcpy(tkw->dyn_pssh, pssh->value.data.ptr, sizeof(u8) * pssh->value.data.size);\n\t\ttkw->dyn_pssh_len = pssh->value.data.size;\n\t}\n\n}\n\nstatic GF_Err mp4_mux_cenc_update(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, u32 act_type, u32 pck_size, u32 injected_hdr_size)\n{\n\tconst GF_PropertyValue *p;\n\tGF_Err e;\n\tBool pck_is_encrypted;\n\tu32 IV_size=0;\n\tu8 *fake_sai = NULL;\n\tu8 *sai = NULL;\n\tu32 sai_size = 0;\n\tBool needs_seig = GF_FALSE;\n\tu32 sample_num;\n\n\tif (tkw->cenc_state == CENC_SETUP_ERROR)\n\t\treturn GF_SERVICE_ERROR;\n\n\n\tif (pck) {\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (p) {\n\t\t\tsai = p->value.data.ptr;\n\t\t\tsai_size = p->value.data.size;\n\t\t}\n\t}\n\n\n\t//initial setup\n\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\tu32 scheme_type=0;\n\t\tu32 scheme_version=0;\n\t\tu32 cenc_stsd_mode=0;\n\t\tu32 container_type = GF_ISOM_BOX_TYPE_SENC;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) scheme_type = p->value.uint;\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (p) scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STSD_MODE);\n\t\tif (p) cenc_stsd_mode = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ENCRYPTED);\n\t\tif (p) pck_is_encrypted = p->value.boolean;\n\t\telse pck_is_encrypted = GF_FALSE;\n\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STORE);\n\t\tif (p && p->value.uint) container_type = p->value.uint;\n\n\t\ttkw->clear_stsd_idx = 0;\n\t\tif (cenc_stsd_mode) {\n\t\t\tu32 clone_stsd_idx;\n\t\t\te = gf_isom_clone_sample_description(ctx->file, tkw->track_num, ctx->file, tkw->track_num, tkw->stsd_idx, NULL, NULL, &clone_stsd_idx);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to clone sample description: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\t//current stsd reused, use clone one for encrypted stsd\n\t\t\tif (tkw->reused_stsd) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//before\n\t\t\telse if (cenc_stsd_mode==1) {\n\t\t\t\ttkw->clear_stsd_idx = tkw->stsd_idx;\n\t\t\t\ttkw->stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t\t//after\n\t\t\telse {\n\t\t\t\ttkw->clear_stsd_idx = clone_stsd_idx;\n\t\t\t}\n\t\t}\n\t\ttkw->def_crypt_byte_block = tkw->crypt_byte_block;\n\t\ttkw->def_skip_byte_block = tkw->skip_byte_block;\n\n\t\ttkw->cenc_state = CENC_SETUP_DONE;\n\t\ttkw->def_cenc_key_info_crc = tkw->cenc_key_info_crc;\n\t\tif (tkw->cenc_ki) {\n\t\t\te = gf_isom_set_cenc_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, pck_is_encrypted, tkw->def_crypt_byte_block, tkw->def_skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Missing CENC Key config, cannot mux\\n\"));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\treturn e;\n\t\t}\n\n\t\t//purge duplicates\n\t\tu32 k, nb_sdesc = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\tif (nb_sdesc>2) {\n\t\t\tfor (k=0; k<nb_sdesc; k++) {\n\t\t\t\tif (k+1 == tkw->stsd_idx) continue;\n\n\t\t\t\tif (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, k+1) ) {\n\t\t\t\t\tgf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\ttkw->stsd_idx = k+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((ctx->psshs == MP4MX_PSSH_MOOV) || (ctx->psshs == MP4MX_PSSH_BOTH))\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\n\t\tif (!tkw->has_brands && (scheme_type==GF_ISOM_OMADRM_SCHEME))\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_OPF2, GF_TRUE);\n\n\t\tif (container_type) {\n\t\t\tif (container_type==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\t\te = gf_isom_piff_allocate_storage(ctx->file, tkw->track_num, 0, 0, NULL);\n\t\t\t} else {\n\t\t\t\te = gf_isom_cenc_allocate_storage(ctx->file, tkw->track_num);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to setup CENC storage: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\ttkw->cenc_state = CENC_SETUP_ERROR;\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\tif (act_type==CENC_CONFIG) return GF_OK;\n\n\tpck_is_encrypted = GF_FALSE;\n\tif (pck)\n\t\tpck_is_encrypted = gf_filter_pck_get_crypt_flags(pck);\n\n\t//!! tkw->nb_samples / tkw->samples_in_frag not yet incremented !!\n\tif (act_type == CENC_ADD_FRAG) {\n\t\tsample_num = tkw->samples_in_frag + 1;\n\n\t\tif (ctx->cmaf) {\n\t\t\tif (!tkw->samples_in_frag) {\n\t\t\t\ttkw->cenc_frag_protected = pck_is_encrypted;\n\t\t\t} else {\n\t\t\t\tif (tkw->cenc_frag_protected != pck_is_encrypted) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] CMAF forbids mixing protected and unprotected samples in a single fragment, please re-encrypt or change target segment duration\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsample_num = tkw->nb_samples + 1;\n\t}\n\tif (!pck_is_encrypted) {\n\t\tif (tkw->clear_stsd_idx) {\n\t\t\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\treturn gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n#else\n\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\treturn gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t\t}\n\t\t} else {\n\t\t\tchar dumb_key[20];\n\t\t\tmemset(dumb_key, 0, 20); //dumb key, IV size 0, not protected\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, GF_FALSE, 0, 0, dumb_key, 20);\n\t\t\tIV_size = 0;\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t}\n\t} else {\n\n\t\te = GF_OK;\n\t\t//multikey ALWAYS uses seig\n\t\tif (tkw->cenc_ki->value.data.ptr[0])\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_crypt_byte_block != tkw->crypt_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_skip_byte_block != tkw->skip_byte_block)\n\t\t\tneeds_seig = GF_TRUE;\n\t\telse if (tkw->def_cenc_key_info_crc != tkw->cenc_key_info_crc)\n\t\t\tneeds_seig = GF_TRUE;\n\n\t\tif (needs_seig) {\n\t\t\te = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, 1, tkw->crypt_byte_block, tkw->skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);\n\t\t\ttkw->has_seig = GF_TRUE;\n\t\t} else if (tkw->has_seig) {\n\t\t\te = gf_isom_set_sample_cenc_default_group(ctx->file, tkw->track_num, sample_num);\n\t\t}\n\t}\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample encryption group entry: %s)\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\n\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr) {\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, p, 0);\n\t\t} else {\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, sample_num, GF_4CC('P','S','S','H'), 0, p->value.data.ptr, p->value.data.size, 0);\n\t\t}\n\t}\n\n\tif (!sai) {\n\t\tif (tkw->constant_IV_size && !tkw->cenc_subsamples)\n\t\t\treturn GF_OK;\n\n\t\tif (IV_size) {\n\t\t\t//generate clear SAI data with a non-0 IV\n\t\t\tu32 olen = pck_size;\n\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 9, GF_BITSTREAM_WRITE);\n\t\t\tif (tkw->cenc_multikey) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_long_int(bs, 0, IV_size*8);\n\t\t\t}\n\n\t\t\tif (tkw->cenc_subsamples) {\n\t\t\t\tu32 i;\n\t\t\t\tu32 subsample_count = 1;\n\t\t\t\twhile (olen>0xFFFF) {\n\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\tsubsample_count ++;\n\t\t\t\t}\n\t\t\t\tgf_bs_write_u16(bs, subsample_count);\n\t\t\t\tolen = pck_size;\n\t\t\t\tfor (i = 0; i < subsample_count; i++) {\n\t\t\t\t\tu32 clear_size;\n\t\t\t\t\tif (olen<0xFFFF) {\n\t\t\t\t\t\tclear_size = olen;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclear_size = 0xFFFF;\n\t\t\t\t\t\tolen -= 0xFFFF;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tkw->cenc_multikey)\n\t\t\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t\t\tgf_bs_write_u16(bs, clear_size);\n\t\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_bs_get_content(bs, &fake_sai, &sai_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tsai = fake_sai;\n\t\t}\n\t}\n\t//we injected xPS at the beginning of the sample (AVC/HEVC/VVC), we must patch the first subsample\n\t//of SAI data\n\telse if (injected_hdr_size) {\n\t\tu32 offset = 0;\n\t\tu32 first_sub_clear, sub_count_size;\n\t\tu8 *sai_d;\n\t\tu8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);\n\n\t\tassert(tkw->cenc_subsamples);\n\n\t\t//multi-key skip all IV inits\n\t\tif (tkw->cenc_ki->value.data.ptr[0]) {\n\t\t\tu32 remain;\n\t\t\tu32 j, nb_iv_init = sai[0];\n\t\t\tnb_iv_init <<= 8;\n\t\t\tnb_iv_init |= sai[1];\n\t\t\tu8 *sai_p = sai + 2;\n\t\t\tremain = sai_size-2;\n\n\t\t\tfor (j=0; j<nb_iv_init; j++) {\n\t\t\t\tu32 mk_iv_size;\n\t\t\t\tu32 idx = sai_p[0];\n\t\t\t\tidx<<=8;\n\t\t\t\tidx |= sai_p[1];\n\n\t\t\t\tmk_iv_size = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, idx, NULL, NULL);\n\t\t\t\tmk_iv_size += 2; //idx\n\t\t\t\tif (mk_iv_size > remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t\tsai_p += mk_iv_size;\n\t\t\t\tremain -= mk_iv_size;\n\t\t\t\tif (remain && (remain<=2)) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\\n\"));\n\t\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = (u32) (sai_p - sai);\n\t\t\tsub_count_size = 4; //32bit sub count\n\n\t\t} else {\n\t\t\toffset = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, 1, NULL, NULL);\n\t\t\tsub_count_size = 2; //16bit sub count\n\t\t}\n\t\tif (sai_size < offset + sub_count_size + 6) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid CENC SAI !\\n\"));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\t//get size of first subsample\n\t\toffset += sub_count_size;\n\t\tsai_d = sai + offset;\n\t\tfirst_sub_clear = sai_d[0];\n\t\tfirst_sub_clear<<=8;\n\t\tfirst_sub_clear |= sai_d[1];\n\t\tfirst_sub_clear += injected_hdr_size;\n\t\t//fits, only patch first subsample size\n\t\tif (first_sub_clear < 0xFFFF) {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * sai_size);\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * sai_size);\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (first_sub_clear>>8) & 0xFF;\n\t\t\tsai_d[1] = (first_sub_clear) & 0xFF;\n\t\t\tsai = fake_sai;\n\t\t}\n\t\t//injected header size does not fit in first subsample, add a new subsample\n\t\telse {\n\t\t\tfake_sai = gf_malloc(sizeof(u8) * (sai_size+6));\n\t\t\tif (!fake_sai) return GF_OUT_OF_MEM;\n\t\t\t//copy till start of first subsample (including subsample_count)\n\t\t\tmemcpy(fake_sai, sai, sizeof(u8) * offset);\n\t\t\t//copy all subsamples\n\t\t\tmemcpy(fake_sai+offset+6, sai+offset, sizeof(u8) * (sai_size - offset) );\n\t\t\t//insert subsample\n\t\t\tsai_d = fake_sai + offset;\n\t\t\tsai_d[0] = (injected_hdr_size>>8) & 0xFF;\n\t\t\tsai_d[1] = (injected_hdr_size) & 0xFF;\n\t\t\tsai_d[2] = sai_d[3] = sai_d[4] = sai_d[5] = 0;\n\t\t\t//update subsample count\n\t\t\tsai_d = fake_sai + offset - sub_count_size;\n\t\t\tif (sub_count_size==2) {\n\t\t\t\tu32 cnt = ((u32) sai_d[0]) << 8 | (u32) sai_d[1];\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt) & 0xFF;\n\t\t\t} else {\n\t\t\t\tu32 cnt = GF_4CC( sai_d[0], sai_d[1], sai_d[2], sai_d[3]);\n\t\t\t\tcnt++;\n\t\t\t\tsai_d[0] = (cnt>>24) & 0xFF;\n\t\t\t\tsai_d[1] = (cnt>>16) & 0xFF;\n\t\t\t\tsai_d[2] = (cnt>>8) & 0xFF;\n\t\t\t\tsai_d[3] = (cnt) & 0xFF;\n\t\t\t}\n\t\t\tsai = fake_sai;\n\t\t\tsai_size += 6;\n\t\t}\n\t}\n\n\tif (act_type==CENC_ADD_FRAG) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (pck_is_encrypted) {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else {\n\t\t\te = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n#else\n\t\te = GF_NOT_SUPPORTED;\n#endif\n\t} else {\n\t\tif (sai) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t} else if (!pck_is_encrypted) {\n\t\t\te = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);\n\t\t}\n\t}\n\tif (fake_sai) gf_free(fake_sai);\n\treturn e;\n}\n\nGF_FilterSAPType mp4_mux_get_sap(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\tif (!sap) return sap;\n\tif (ctx->forcesync) return GF_FILTER_SAP_1;\n\treturn sap;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_fragment_add_sample_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, const GF_ISOSample *sample, u32 DescIndex,\n                                   u32 Duration, u8 PaddingBits, u16 DegradationPriority, Bool redundant_coding, void **ref, u32 ref_offset);\nGF_Err gf_isom_fragment_append_data_ex(GF_ISOFile *movie, GF_ISOTrackID TrackID, u8 *data, u32 data_size, u8 PaddingBits, void **ref, u32 ref_offset);\n#endif\n\nstatic GF_Err mp4_mux_process_sample(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, Bool for_fragment)\n{\n\tGF_Err e=GF_OK;\n\tu64 cts, prev_dts;\n\tu32 prev_size=0;\n\tu32 duration = 0;\n\tu32 timescale = 0;\n\tconst GF_PropertyValue *subs;\n\tGF_FilterSAPType sap_type;\n\tu32 insert_subsample_dsi_size = 0;\n\tu32 first_nal_is_audelim = GF_FALSE;\n\tu32 sample_desc_index = tkw->stsd_idx;\n\tBool sample_timing_ok = GF_TRUE;\n\n\ttimescale = gf_filter_pck_get_timescale(pck);\n\n\tprev_dts = tkw->nb_samples ? tkw->sample.DTS : GF_FILTER_NO_TS;\n\tprev_size = tkw->sample.dataLength;\n\ttkw->sample.CTS_Offset = 0;\n\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\ttkw->dgl_copy = gf_filter_pck_dangling_copy(pck, tkw->dgl_copy);\n\t\tif (!tkw->dgl_copy) return GF_IO_ERR;\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(tkw->dgl_copy, &tkw->sample.dataLength);\n\t} else {\n\t\ttkw->sample.data = (char *)gf_filter_pck_get_data(pck, &tkw->sample.dataLength);\n\t}\n\n\tctx->update_report = GF_TRUE;\n\tctx->total_bytes_in += tkw->sample.dataLength;\n\tctx->total_samples++;\n\n\ttkw->sample.DTS = gf_filter_pck_get_dts(pck);\n\tcts = gf_filter_pck_get_cts(pck);\n\n\tif (tkw->sample.DTS == GF_FILTER_NO_TS) {\n\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Sample with no DTS/CTS, cannot add (last DTS \"LLU\", last size %d)\\n\", prev_dts, prev_size ));\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\tu32 min_pck_dur = gf_filter_pid_get_min_pck_duration(tkw->ipid);\n\t\t\tif (min_pck_dur) {\n\t\t\t\ttkw->sample.DTS = prev_dts;\n\t\t\t\t//transform back to inpput timescale\n\t\t\t\tif (timescale != tkw->tk_timescale) {\n\t\t\t\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, tkw->tk_timescale, timescale);\n\t\t\t\t}\n\t\t\t\ttkw->sample.DTS += min_pck_dur;\n\t\t\t} else {\n\t\t\t\ttkw->sample.DTS = cts;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttkw->sample.CTS_Offset = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t}\n\n\t//do our best to patch init ts if timing config aborted\n\tif (tkw->si_min_ts_plus_one) {\n\t\tu64 si_min_ts = tkw->si_min_ts_plus_one - 1;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t\ttkw->ts_shift = tkw->sample.DTS;\n\t\tmp4_mux_update_init_edit(ctx, tkw, si_min_ts, GF_FALSE);\n\t}\n\t//tkw->ts_shift is in source timescale, apply it before rescaling TSs/duration\n\tif (tkw->ts_shift) {\n\t\tif (ctx->is_rewind) {\n\t\t\tif (tkw->sample.DTS <= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS = tkw->ts_shift - tkw->sample.DTS;\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" less than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tkw->sample.DTS >= tkw->ts_shift) {\n\t\t\t\ttkw->sample.DTS -= tkw->ts_shift;\n\t\t\t\tcts -= tkw->ts_shift;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] broken timing in track, initial ts \"LLU\" greater than TS \"LLU\"\\n\", tkw->ts_shift, tkw->sample.DTS));\n\t\t\t\tsample_timing_ok = GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\n\t//sample-accurate seek info, start logging min CTS of packets marked as non-sync\n\tif (tkw->check_seek_ts && !gf_filter_pck_get_seek_flag(pck)) {\n\t\tu64 ts_check = cts;\n\t\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_BEGIN);\n\t\tif (subs)\n\t\t\tts_check += subs->value.uint;\n\n\t\tif (!tkw->min_ts_seek_plus_one) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else if (tkw->min_ts_seek_plus_one > ts_check + 1) {\n\t\t\ttkw->min_ts_seek_plus_one = ts_check + 1;\n\t\t} else {\n\t\t\t//TS is greater than last non-seek packet TS, we're done seeking\n\t\t\ttkw->check_seek_ts = GF_FALSE;\n\t\t}\n\t}\n\n\tduration = gf_filter_pck_get_duration(pck);\n\tif (timescale != tkw->tk_timescale) {\n\t\ts64 ctso;\n\t\ttkw->sample.DTS = gf_timestamp_rescale(tkw->sample.DTS, timescale, tkw->tk_timescale);\n\n\t\tctso = (s64) tkw->sample.CTS_Offset;\n\t\tctso *= tkw->tk_timescale;\n\t\tctso /= timescale;\n\t\ttkw->sample.CTS_Offset = (s32) ctso;\n\t\tduration *= tkw->tk_timescale;\n\t\tduration /= timescale;\n\n\t\tif (cts != GF_FILTER_NO_TS) {\n\t\t\tcts = gf_timestamp_rescale(cts, timescale, tkw->tk_timescale);\n\t\t}\n\t}\n\n\ttkw->sample.IsRAP = 0;\n\tif (tkw->codecid==GF_CODECID_RAW) {\n\t\tsap_type = GF_FILTER_SAP_1;\n\t} else {\n\t\tsap_type = mp4_mux_get_sap(ctx, pck);\n\n\t\t//if pps inband mode is used, turn sap3 into sap1\n\t\tif ((tkw->xps_inband==XPS_IB_PPS) && sap_type==GF_FILTER_SAP_3)\n\t\t\tsap_type=GF_FILTER_SAP_1;\n\t}\n\tif (sap_type==GF_FILTER_SAP_1)\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\telse if (sap_type==GF_FILTER_SAP_2)\n\t\ttkw->sample.IsRAP = SAP_TYPE_2;\n\telse if ( (sap_type == GF_FILTER_SAP_4) && (tkw->stream_type != GF_STREAM_VISUAL) )\n\t\ttkw->sample.IsRAP = SAP_TYPE_1;\n\n\t/*RFC8216bis is not clear here:\n\t\"if the Partial Segment contains an independent frame.\"\n\t\t-> this would allow SAP1,2,3 (independent being only defined for segments)\n\n\tbut\n\n\t\"Partial Segment containing an independent frame SHOULD carry it to increase the efficiency with which clients can join and switch Renditions\"\n\t\t-> if used for switching, this only allows SAP 1 and 2\n\n\tSpec should be fixed to allow for both cases (fast tune-in or in-segment switching\u00e0)\n\t*/\n\tif ((tkw->sample.IsRAP == SAP_TYPE_1) || (tkw->sample.IsRAP == SAP_TYPE_2))\n\t\tctx->frag_has_intra = GF_TRUE;\n\n\ttkw->sample.DTS += tkw->dts_patch;\n\tif (tkw->nb_samples && (prev_dts >= tkw->sample.DTS) ) {\n\t\t//the fragmented API will patch the duration on the fly\n\t\tif (!for_fragment && ctx->patch_dts) {\n\t\t\tgf_isom_patch_last_sample_duration(ctx->file, tkw->track_num, prev_dts ? prev_dts : 1);\n\t\t}\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID %s ID %d Sample %d with DTS \"LLU\" less than previous sample DTS \"LLU\", patching DTS%s\\n\", gf_filter_pid_get_name(tkw->ipid), tkw->track_id, tkw->nb_samples+1, tkw->sample.DTS, prev_dts, ctx->patch_dts ? \"and adjusting prev sample duration\" : \"\" ));\n\t\tsample_timing_ok = GF_FALSE;\n\n\t\tif (prev_dts) {\n\t\t\ttkw->dts_patch = prev_dts - tkw->sample.DTS;\n\t\t\ttkw->sample.DTS += tkw->dts_patch+1; //+1 to avoid 0-dur samples\n\t\t} else {\n\t\t\ttkw->sample.DTS += 1;\n\t\t\tif (tkw->sample.CTS_Offset) tkw->sample.CTS_Offset -= 1;\n\t\t\tduration-=1;\n\t\t}\n\t}\n\n\n\tif (tkw->negctts_shift)\n\t\ttkw->sample.CTS_Offset -= tkw->negctts_shift;\n\n\tif (sample_timing_ok) {\n\t\tif (tkw->probe_min_ctts) {\n\t\t\ts32 diff = (s32) ((s64) cts - (s64) tkw->sample.DTS);\n\t\t\tif (diff < tkw->min_neg_ctts)\n\t\t\t\ttkw->min_neg_ctts = diff;\n\t\t}\n\t\tif (tkw->sample.CTS_Offset) tkw->has_ctts = GF_TRUE;\n\n\t\tif (tkw->sample.CTS_Offset < tkw->min_neg_ctts)\n\t\t\ttkw->min_neg_ctts = tkw->sample.CTS_Offset;\n\t}\n\n\ttkw->sample.nb_pack = 0;\n\tif (tkw->raw_audio_bytes_per_sample) {\n\t\ttkw->sample.nb_pack = tkw->sample.dataLength / tkw->raw_audio_bytes_per_sample;\n\t\tif (tkw->sample.nb_pack) {\n\t\t\tduration = 1;\n\t\t\tif (tkw->raw_samplerate && (tkw->tk_timescale != tkw->raw_samplerate)) {\n\t\t\t\tduration *= tkw->tk_timescale;\n\t\t\t\tduration /= tkw->raw_samplerate;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->cenc_state && tkw->clear_stsd_idx && !gf_filter_pck_get_crypt_flags(pck)) {\n\t\tsample_desc_index = tkw->clear_stsd_idx;\n\t}\n\n\tif (tkw->sparse_inject && (prev_dts!=GF_FILTER_NO_TS) && (tkw->sample.DTS!=GF_FILTER_NO_TS) && tkw->prev_duration) {\n\t\tu64 est_time = prev_dts + tkw->prev_duration;\n\t\tif (est_time < tkw->sample.DTS) {\n\t\t\tu32 ins_dur;\n\t\t\tGF_ISOSample s;\n\t\t\tmemset(&s, 0, sizeof(GF_ISOSample));\n\t\t\ts.DTS = est_time;\n\n\t\t\ts.IsRAP = SAP_TYPE_1;\n\t\t\tins_dur = (u32) (tkw->sample.DTS - est_time);\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &s, tkw->stsd_idx, ins_dur, 0, 0, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, tkw->stsd_idx, &s);\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, ins_dur);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tkw->use_dref) {\n\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\tif (data_offset != GF_FILTER_NO_BO) {\n\t\t\te = gf_isom_add_sample_reference(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample, data_offset);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s as reference: %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), gf_error_to_string(e) ));\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add sample reference at DTS \"LLU\" , input sample data is not continous in source\\n\", tkw->sample.DTS ));\n\t\t}\n\t} else if (tkw->nb_frames_per_sample && (tkw->nb_samples % tkw->nb_frames_per_sample)) {\n\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t \te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, tkw->sample.data, tkw->sample.dataLength, 0);\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t} else {\n\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, tkw->sample.data, tkw->sample.dataLength);\n\t\t}\n\t\ttkw->has_append = GF_TRUE;\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to append sample DTS \"LLU\" data: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t}\n\t} else {\n\t\tBool inject_pps = ctx->pps_inband;\n\t\tif (ctx->xps_inband==XPS_IB_AUTO) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_XPS_MASK);\n\t\t\tif (p && (p->value.uint & (1<<2) ) )\n\t\t\t\tinject_pps = GF_TRUE;\n\t\t}\n\n\t\tif ((tkw->sample.IsRAP || tkw->force_inband_inject || inject_pps) && tkw->xps_inband) {\n\t\t\tu8 *inband_xps;\n\t\t\tu32 inband_xps_size;\n\t\t\tchar *au_delim=NULL;\n\t\t\tu32 au_delim_size=0;\n\t\t\tchar *pck_data = tkw->sample.data;\n\t\t\tu32 pck_data_len = tkw->sample.dataLength;\n\t\t\tif (tkw->sample.IsRAP || tkw->force_inband_inject) {\n\t\t\t\tinband_xps = tkw->inband_hdr;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_size;\n\t\t\t\ttkw->force_inband_inject = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tinband_xps = tkw->inband_hdr_non_rap;\n\t\t\t\tinband_xps_size = tkw->inband_hdr_non_rap_size;\n\t\t\t}\n\t\t\ttkw->sample.data = inband_xps;\n\t\t\ttkw->sample.dataLength = inband_xps_size;\n\n\t\t\tif (tkw->is_nalu==NALU_AVC) {\n\t\t\t\tif (pck_data_len >= 2 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif ((nal[0] & 0x1F) == GF_AVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 2 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pck_data_len >= 3 + tkw->nal_unit_size) {\n\t\t\t\t\tchar *nal = pck_data + tkw->nal_unit_size;\n\t\t\t\t\tif (((nal[0] & 0x7E)>>1) == GF_HEVC_NALU_ACCESS_UNIT) {\n\t\t\t\t\t\tfirst_nal_is_audelim = au_delim_size = 3 + tkw->nal_unit_size;\n\t\t\t\t\t\tau_delim = pck_data;\n\t\t\t\t\t\tif (au_delim_size >= pck_data_len) au_delim = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (au_delim) {\n\t\t\t\ttkw->sample.data = au_delim;\n\t\t\t\ttkw->sample.dataLength = au_delim_size;\n\t\t\t\tpck_data += au_delim_size;\n\t\t\t\tpck_data_len -= au_delim_size;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t//force using ref mode\n\t\t\t\tvoid *ref=NULL;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, &ref, 0);\n\t\t\t\tif (!e && au_delim) {\n\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, inband_xps, inband_xps_size, 0);\n\t\t\t\t}\n\t\t\t\tif (!e) {\n\t\t\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\t\t\te = gf_isom_fragment_append_data(ctx->file, tkw->track_id, pck_data, pck_data_len, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\t\t\te = gf_isom_fragment_append_data_ex(ctx->file, tkw->track_id, pck_data, pck_data_len, 0, (void**)&ref, au_delim ? au_delim_size : 0);\n\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t} else {\n\t\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\t\tif (au_delim && !e) {\n\t\t\t\t\te = gf_isom_append_sample_data(ctx->file, tkw->track_num, inband_xps, inband_xps_size);\n\t\t\t\t}\n\t\t\t\tif (!e) e = gf_isom_append_sample_data(ctx->file, tkw->track_num, pck_data, pck_data_len);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = inband_xps_size;\n\t\t} else if (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\te = gf_isom_fragment_add_sample(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\tGF_FilterPacket *ref = pck;\n\t\t\t\te = gf_isom_fragment_add_sample_ex(ctx->file, tkw->track_id, &tkw->sample, sample_desc_index, duration, 0, 0, 0, (void**) &ref, 0);\n\t\t\t\tif (!ref) {\n\t\t\t\t\tgf_list_add(ctx->ref_pcks, pck);\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_unref(pck);\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\te = GF_NOT_SUPPORTED;\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t} else {\n\t\t\te = gf_isom_add_sample(ctx->file, tkw->track_num, sample_desc_index, &tkw->sample);\n\t\t\tif (!e && !duration) {\n\t\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, 0);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to add sample DTS \"LLU\" from %s - prev DTS \"LLU\": %s\\n\", tkw->sample.DTS, gf_filter_pid_get_name(tkw->ipid), prev_dts, gf_error_to_string(e) ));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] added sample DTS \"LLU\" - prev DTS \"LLU\" - prev size %d\\n\", tkw->sample.DTS, prev_dts, prev_size));\n\t\t}\n\n\t\tif (!e && tkw->cenc_state) {\n\t\t\te = mp4_mux_cenc_update(ctx, tkw, pck, for_fragment ? CENC_ADD_FRAG : CENC_ADD_NORMAL, tkw->sample.dataLength, insert_subsample_dsi_size);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample CENC information: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->nb_samples++;\n\ttkw->samples_in_stsd++;\n\ttkw->samples_in_frag++;\n\n\tif (e) return e;\n\n\tif (!for_fragment && sample_timing_ok) {\n\t\tu64 samp_cts;\n\t\tif (!tkw->clamp_ts_plus_one) {\n\t\t\tconst GF_PropertyValue *skp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SKIP_PRES);\n\t\t\tif (skp && skp->value.boolean) {\n\t\t\t\ttkw->clamp_ts_plus_one = 1 + tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\t\t}\n\t\t}\n\t\t//store min max cts for edit list updates\n\t\tsamp_cts = tkw->sample.DTS + tkw->sample.CTS_Offset;\n\t\tif (!tkw->clamp_ts_plus_one || (samp_cts + 1 < tkw->clamp_ts_plus_one)) {\n\t\t\tif (samp_cts > tkw->max_cts) {\n\t\t\t\ttkw->max_cts = samp_cts;\n\t\t\t\ttkw->max_cts_samp_dur = duration;\n\t\t\t}\n\n\t\t\tif (tkw->min_cts > samp_cts)\n\t\t\t\ttkw->min_cts = samp_cts;\n\t\t}\n\t}\n\n\t//compat with old arch: write sample to group info for all samples\n\tif ((sap_type==3) || tkw->has_open_gop)  {\n\t\tif (!ctx->norap) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_rap_group(ctx->file, tkw->track_id, tkw->samples_in_frag, (sap_type==3) ? GF_TRUE : GF_FALSE, 0);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else if (sap_type==3) {\n\t\t\t\te = gf_isom_set_sample_rap_group(ctx->file, tkw->track_num, tkw->nb_samples, GF_TRUE /*(sap_type==3) ? GF_TRUE : GF_FALSE*/, 0);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 3 in RAP group: %s\\n\", tkw->sample.DTS, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\ttkw->has_open_gop = GF_TRUE;\n\t}\n\tif (!ctx->noroll) {\n\t\tif ((sap_type==GF_FILTER_SAP_4) || (sap_type==GF_FILTER_SAP_4_PROL) || tkw->gdr_type) {\n\t\t\tGF_ISOSampleRollType roll_type = 0;\n\t\t\ts16 roll = gf_filter_pck_get_roll_info(pck);\n\t\t\tif (sap_type==GF_FILTER_SAP_4) roll_type = GF_ISOM_SAMPLE_ROLL;\n\t\t\telse if (sap_type==GF_FILTER_SAP_4_PROL) roll_type = GF_ISOM_SAMPLE_PREROLL;\n\t\t\telse if (tkw->gdr_type==GF_FILTER_SAP_4_PROL) {\n\t\t\t\troll_type = GF_ISOM_SAMPLE_PREROLL_NONE;\n\t\t\t}\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\te = gf_isom_fragment_set_sample_roll_group(ctx->file, tkw->track_id, tkw->samples_in_frag, roll_type, roll);\n#else\n\t\t\t\te = GF_NOT_SUPPORTED;\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_isom_set_sample_roll_group(ctx->file, tkw->track_num, tkw->nb_samples, roll_type, roll);\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set sample DTS \"LLU\" SAP 4 roll %s in roll group: %s\\n\", tkw->sample.DTS, roll, gf_error_to_string(e) ));\n\t\t\t}\n\t\t\tif (sap_type && !tkw->gdr_type)\n\t\t\t\ttkw->gdr_type = sap_type;\n\t\t}\n\t}\n\n\tsubs = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS);\n\tif (subs) {\n\t\t//if no AUDelim nal and inband header injection, push new subsample\n\t\tif (!first_nal_is_audelim && insert_subsample_dsi_size) {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t}\n\t\t\tinsert_subsample_dsi_size = 0;\n\t\t}\n\t\ttkw->has_subs = GF_TRUE;\n\n\t\tif (!ctx->bs_r) ctx->bs_r = gf_bs_new(subs->value.data.ptr, subs->value.data.size, GF_BITSTREAM_READ);\n\t\telse gf_bs_reassign_buffer(ctx->bs_r, subs->value.data.ptr, subs->value.data.size);\n\n\t\twhile (gf_bs_available(ctx->bs_r)) {\n\t\t\tu32 flags = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 subs_size = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu32 reserved = gf_bs_read_u32(ctx->bs_r);\n\t\t\tu8 priority = gf_bs_read_u8(ctx->bs_r);\n\t\t\tu8 discardable = gf_bs_read_u8(ctx->bs_r);\n\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, flags, subs_size, priority, reserved, discardable);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, flags, subs_size, priority, reserved, discardable);\n\t\t\t}\n\n\t\t\t//we have AUDelim nal and inband header injection, push new subsample for inband header once we have pushed the first subsample (au delim)\n\t\t\tif (insert_subsample_dsi_size) {\n\t\t\t\tif (first_nal_is_audelim != subs_size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] inserting inband param after AU delimiter NALU, but sample has subsample information not aligned on NALU (got %d subsample size but expecting %d) - file might be broken!\\n\", subs_size, first_nal_is_audelim));\n\t\t\t\t}\n\t\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, insert_subsample_dsi_size, 0, 0, 0);\n#endif\n\t\t\t\t} else {\n\t\t\t\t\tgf_isom_add_subsample(ctx->file, tkw->track_num, tkw->nb_samples, 0, insert_subsample_dsi_size, 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tinsert_subsample_dsi_size = GF_FALSE;\n\t\t\t}\n\t\t}\n\t} else if (for_fragment && tkw->has_subs && ctx->cmaf && (tkw->codecid==GF_CODECID_SUBS_XML)) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//tentative implemntation of CMAF 7.5.20 which is just nonsense text !!:\n\t\t//\"the value of subsample_count shall equal 1 for the first image sub-sample, and the subsample_count of the TTML document shall equal 0.\"\n\t\t//\n\t\t//we simply signal a single subsample\n\t\tgf_isom_fragment_add_subsample(ctx->file, tkw->track_id, 0, tkw->sample.dataLength, 0, 0, 0);\n#endif\n\t}\n\n\tif (ctx->deps) {\n\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\tif (dep_flags) {\n\t\t\tu32 is_leading = (dep_flags>>6) & 0x3;\n\t\t\tu32 depends_on = (dep_flags>>4) & 0x3;\n\t\t\tu32 depended_on = (dep_flags>>2) & 0x3;\n\t\t\tu32 redundant = (dep_flags) & 0x3;\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_flags(ctx->file, tkw->track_id, is_leading, depends_on, depended_on, redundant);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_set_sample_flags(ctx->file, tkw->track_num, tkw->nb_samples, is_leading, depends_on, depended_on, redundant);\n\t\t\t}\n\t\t}\n\t}\n\n\tu32 idx = 0;\n\twhile (1) {\n\t\tBool is_sample_group=GF_FALSE;\n\t\tu32 aux_type=0, aux_info=0, sg_flags=0;\n\t\tu32 p4cc;\n\t\tconst char *pname=NULL;\n\t\tconst GF_PropertyValue *p = gf_filter_pck_enum_properties(pck, &idx, &p4cc, &pname);\n\t\tif (!p) break;\n\t\tif ((p->type!=GF_PROP_DATA) && (p->type!=GF_PROP_CONST_DATA)) continue;\n\t\tif (!p->value.data.size || !p->value.data.ptr) continue;\n\t\tif (!pname) continue;\n\n\t\tif (!strncmp(pname, \"sai_\", 4)) {\n\n\t\t} else if (!strncmp(pname, \"grp_\", 4)) {\n\t\t\t//discard emsg if fragmented, otherwise add as internal sample group - TODO, support for EventMessage tracks\n\t\t\tif (!strcmp(pname, \"grp_EMSG\") && (ctx->store>=MP4MX_MODE_FRAG)) continue;\n\t\t\tis_sample_group = GF_TRUE;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpname+=4;\n\t\tu32 plen = (u32) strlen(pname);\n\t\tif (plen==3) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], ' ');\n\t\t\tpname+=3;\n\t\t} else if (plen >= 4) {\n\t\t\taux_type = GF_4CC(pname[0], pname[1], pname[2], pname[3]);\n\t\t\tpname+=4;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tif (pname[0] == '_') {\n\t\t\tif (is_sample_group) {\n\t\t\t\tchar *flags = strstr(pname, \"_z\");\n\t\t\t\tif (flags) flags[0]=0;\n\t\t\t\tif (pname[0]) aux_info = atoi(pname);\n\t\t\t\tif (flags) {\n\t\t\t\t\tsscanf(flags+2, \"%x\", &sg_flags);\n\t\t\t\t\tflags[0]='_';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\taux_info = atoi(pname);\n\t\t\t}\n\t\t}\n\t\tif (!aux_type) continue;\n\n\t\tif (is_sample_group) {\n\t\t\tif (aux_type==GF_ISOM_SAMPLE_GROUP_ESGH) {\n\t\t\t\tGF_Err gf_isom_set_sample_description_restricted(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 scheme_type);\n\t\t\t\tgf_isom_set_sample_description_restricted(ctx->file, tkw->track_num, tkw->stsd_idx, GF_4CC( 'e', 's', 's', 'g'));\n\n\t\t\t\tsg_flags |= 0x40000000;\n\t\t\t}\n\n\t\t\tgf_isom_set_sample_group_description(ctx->file, tkw->track_num, for_fragment ? 0 : tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size, sg_flags);\n\n\t\t} else {\n\t\t\tif (for_fragment) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\tgf_isom_fragment_set_sample_aux_info(ctx->file, tkw->track_id, tkw->samples_in_frag, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n#endif\n\t\t\t} else {\n\t\t\t\tgf_isom_add_sample_aux_info(ctx->file, tkw->track_num, tkw->nb_samples, aux_type, aux_info, p->value.data.ptr, p->value.data.size);\n\t\t\t}\n\t\t}\n\t}\n\n\ttkw->prev_duration = duration;\n\tif (duration && !for_fragment && !tkw->raw_audio_bytes_per_sample)\n\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, duration);\n\n\tif (ctx->dur.num) {\n\t\tBool abort = GF_FALSE;\n\t\tif (ctx->dur.num>0) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (tkw->stream_type==GF_STREAM_VISUAL) {\n\t\t\t\t\tmdur = tkw->sample.DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//adjust if shift is below half sec (to take AV delay into account)\n\t\t\t//if larger, we imported from non-0 initial ts, do not compensate\n\t\t\telse if (tkw->ts_shift<tkw->tk_timescale/2) {\n\t\t\t\tmdur += tkw->ts_shift;\n\t\t\t}\n\n\t\t\tif (ctx->importer) {\n\t\t\t\ttkw->prog_done = mdur * ctx->dur.den;\n\t\t\t\ttkw->prog_total =  ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t}\n\n\t\t\t/*patch to align to old arch */\n\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\tif (gf_timestamp_greater(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tif (gf_timestamp_greater_or_equal(mdur, tkw->tk_timescale, ctx->dur.num, ctx->dur.den))\n\t\t\t\t\tabort = GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((s32) tkw->nb_samples >= -ctx->dur.num)\n\t\t\t\tabort = GF_TRUE;\n\t\t}\n\n\t\tif (abort) {\n\t\t\tGF_FilterEvent evt;\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, tkw->ipid);\n\t\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\t\ttkw->aborted = GF_TRUE;\n\t\t}\n\t} else if (ctx->importer) {\n\t\tif (tkw->nb_frames) {\n\t\t\ttkw->prog_done = tkw->nb_samples + tkw->frame_offset;\n\t\t\ttkw->prog_total = tkw->nb_frames;\n\t\t} else {\n\t\t\tu64 data_offset = gf_filter_pck_get_byte_offset(pck);\n\t\t\tif (data_offset == GF_FILTER_NO_BO) {\n\t\t\t\tdata_offset = tkw->down_bytes;\n\t\t\t}\n\t\t\tif ((data_offset != GF_FILTER_NO_BO) && tkw->down_size) {\n\t\t\t\ttkw->prog_done = data_offset;\n\t\t\t\ttkw->prog_total = tkw->down_size;\n\t\t\t} else {\n\t\t\t\tif (tkw->pid_dur.den && tkw->pid_dur.num) {\n\t\t\t\t\ttkw->prog_done = tkw->sample.DTS * tkw->pid_dur.den;\n\t\t\t\t\ttkw->prog_total = tkw->pid_dur.num * tkw->tk_timescale;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->prog_done = 0;\n\t\t\t\t\ttkw->prog_total = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_item(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 meta_type, item_id, size, item_type, nb_items, media_brand = GF_ISOM_BRAND_HEIF;\n\tGF_ImageItemProperties image_props;\n\tGF_ImageItemProtection cenc_info;\n\tconst char *data, *item_name=NULL;\n\tconst GF_PropertyValue *p, *dsi, *dsi_enh;\n\tGF_Box *config_box = NULL;\n\n\n\tif (ctx->init_movie_done) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item to a finalized movie, not supported\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (tkw->stream_type != GF_STREAM_VISUAL) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add item other than visual, not supported - use MP4Box for this\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tctx->update_report = GF_TRUE;\n\n\tmeta_type = gf_isom_get_meta_type(ctx->file, GF_TRUE, 0);\n\tif (!meta_type) {\n\t\te = gf_isom_set_meta_type(ctx->file, GF_TRUE, 0, GF_META_ITEM_TYPE_PICT);\n\t} else if (meta_type != GF_META_ITEM_TYPE_PICT) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] File already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));\n\t\te= GF_BAD_PARAM;\n\t} else {\n\t\te = GF_OK;\n\t}\n\tif (e) return e;\n\n\tdata = (char *)gf_filter_pck_get_data(pck, &size);\n\tif (!data) {\n\t\tif (gf_filter_pck_get_frame_interface(pck)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot add items from raw decoder outputs, not supported\\n\"));\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tctx->total_bytes_in += size;\n\tctx->total_samples++;\n\n\n\titem_id = 0;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ITEM_ID);\n\tif (p) item_id = p->value.uint;\n\n\titem_name = \"Image\";\n\tp = gf_filter_pid_get_property_str(tkw->ipid, \"meta:name\");\n\tif (p && p->value.string) item_name = p->value.string;\n\n\tmemset(&image_props, 0, sizeof(GF_ImageItemProperties));\n\n\tdsi = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG);\n\tdsi_enh = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\tBool free_config_ba = GF_FALSE;\n\n\tswitch (tkw->codecid) {\n\tcase GF_CODECID_AVC:\n\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\tif (!dsi) return GF_OK;\n\n\t\tif (tkw->codecid==GF_CODECID_AVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_AVC_H264;\n\t\t} else if (tkw->codecid==GF_CODECID_MVC) {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_MVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t} else {\n\t\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);\n\t\t\titem_type = GF_ISOM_SUBTYPE_SVC_H264;\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t}\n\n\t\t((GF_AVCConfigurationBox *)config_box)->config = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\tif (! ((GF_AVCConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\timage_props.num_channels = 3;\n\t\timage_props.bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\timage_props.bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\timage_props.bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\tmedia_brand = GF_ISOM_BRAND_AVCI;\n\t\tbreak;\n\n\tcase GF_CODECID_HEVC:\n\tcase GF_CODECID_HEVC_TILES:\n\tcase GF_CODECID_LHVC:\n\t\tif (tkw->codecid == GF_CODECID_LHVC) {\n\t\t\tif (dsi_enh) dsi = dsi_enh;\n\t\t\tif (!dsi) return GF_OK;\n\t\t}\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);\n\n\t\tif (dsi_enh) {\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_TRUE);\n\t\t\titem_type = GF_ISOM_SUBTYPE_LHV1;\n\t\t} else {\n\t\t\tif ((tkw->codecid == GF_CODECID_HEVC) && !dsi) return GF_OK;\n\n\t\t\t((GF_HEVCConfigurationBox *)config_box)->config = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_FALSE);\n\t\t\titem_type = (tkw->codecid == GF_CODECID_HEVC_TILES) ? GF_ISOM_SUBTYPE_HVT1 : GF_ISOM_SUBTYPE_HVC1;\n\t\t}\n\t\tif (! ((GF_HEVCConfigurationBox *)config_box)->config) {\n\t\t\tif ((tkw->codecid != GF_CODECID_HEVC_TILES) && !dsi) return GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_HEIC;\n\t\tif (tkw->codecid==GF_CODECID_LHVC) {\n\t\t\tmedia_brand = GF_ISOM_BRAND_HEIM;\n\t\t}\n\t\tbreak;\n\tcase GF_CODECID_AV1:\n\t\tif (!dsi) return GF_OK;\n\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);\n\t\t((GF_AV1ConfigurationBox *)config_box)->config = gf_odf_av1_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\n\t\tif (! ((GF_AV1ConfigurationBox *)config_box)->config) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\titem_type = GF_ISOM_SUBTYPE_AV01;\n\t\tu8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;\n\t\tif (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {\n\t\t\timage_props.num_channels = 1;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = 0;\n\t\t\timage_props.bits_per_channel[2] = 0;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = depth;\n\t\t\timage_props.bits_per_channel[1] = depth;\n\t\t\timage_props.bits_per_channel[2] = depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_AVIF;\n\t\tbreak;\n\tcase GF_CODECID_JPEG:\n\t\titem_type = GF_ISOM_SUBTYPE_JPEG;\n\t\tmedia_brand = GF_ISOM_SUBTYPE_JPEG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\tcase GF_CODECID_J2K:\n\t\titem_type = GF_ISOM_SUBTYPE_JP2K;\n\t\tmedia_brand = GF_4CC('j', '2', 'k', 'i');\n\t\tbreak;\n\tcase GF_CODECID_PNG:\n\t\titem_type = GF_ISOM_SUBTYPE_PNG;\n\t\t//not defined !\n\t\tmedia_brand = GF_ISOM_SUBTYPE_PNG /* == GF_4CC('j', 'p', 'e', 'g') */;\n\t\tbreak;\n\n\tcase GF_CODECID_VVC:\n\t\tconfig_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);\n\n\t\tif ((tkw->codecid == GF_CODECID_VVC) && !dsi) return GF_OK;\n\n\t\t((GF_VVCConfigurationBox *)config_box)->config = gf_odf_vvc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\titem_type = GF_ISOM_SUBTYPE_VVC1;\n\n\t\tif (! ((GF_VVCConfigurationBox *)config_box)->config) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t} else {\n\t\t\timage_props.num_channels = 3;\n\t\t\timage_props.bits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[1] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t\timage_props.bits_per_channel[2] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;\n\t\t}\n\t\tmedia_brand = GF_ISOM_BRAND_VVIC;\n\t\tbreak;\n\tcase GF_CODECID_RAW:\n\tcase GF_CODECID_RAW_UNCV:\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PIXFMT);\n\t\tif (p && (p->value.uint==GF_PIXEL_UNCV)) {\n\t\t\timage_props.config_ba = dsi->value.data.ptr;\n\t\t\timage_props.config_ba_size = dsi->value.data.size;\n\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\tbreak;\n\t\t} else {\n\t\t\tif (gf_pixel_fmt_get_uncc(p->value.uint, ctx->uncv-1, &image_props.config_ba, &image_props.config_ba_size)==GF_TRUE) {\n\t\t\t\tfree_config_ba = GF_TRUE;\n\t\t\t\titem_type = GF_4CC('u','n','c','i');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Codec %s not supported to create HEIF image items\\n\", gf_codecid_name(tkw->codecid) ));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_WIDTH);\n\tif (p) image_props.width = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HEIGHT);\n\tif (p) image_props.height = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ALPHA);\n\tif (p) image_props.alpha = p->value.boolean;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SAR);\n\tif (p) {\n\t\timage_props.hSpacing = p->value.frac.num;\n\t\timage_props.vSpacing = p->value.frac.den;\n\t} else {\n\t\timage_props.hSpacing = image_props.vSpacing = 1;\n\t}\n\timage_props.config = config_box;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HIDDEN);\n\tif (p) image_props.hidden = p->value.boolean;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_MIRROR);\n\tif (p && p->value.uint) image_props.mirror = p->value.uint;\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ROTATE);\n\tif (p) image_props.angle = p->value.uint;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_W);\n\tif (p) { image_props.clap_wnum = p->value.frac.num; image_props.clap_wden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_H);\n\tif (p) { image_props.clap_hnum = p->value.frac.num; image_props.clap_hden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_X);\n\tif (p) { image_props.clap_honum = p->value.frac.num; image_props.clap_hoden = p->value.frac.den; }\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CLAP_Y);\n\tif (p) { image_props.clap_vonum = p->value.frac.num; image_props.clap_voden = p->value.frac.den; }\n\n\tp = gf_filter_pck_get_property_str(pck, \"grp_ilce\");\n\tif (p && ((p->type==GF_PROP_DATA)||(p->type==GF_PROP_CONST_DATA)) && p->value.data.ptr) {\n\t\timage_props.interlace_type = p->value.data.ptr[0];\n\t}\n\tif (tkw->codecid==GF_CODECID_HEVC_TILES) {\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CROP_POS);\n\t\tif (p) {\n\t\t\timage_props.hOffset = p->value.vec2i.x;\n\t\t\timage_props.vOffset = p->value.vec2i.y;\n\t\t}\n\t}\n\n\t//setup crypto\n\tif (tkw->is_encrypted && gf_filter_pck_get_crypt_flags(pck)) {\n\t\tmemset(&cenc_info, 0, sizeof(GF_ImageItemProtection));\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC SAI on protected packet\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.sai_data = p->value.data.ptr;\n\t\tcenc_info.sai_data_size = p->value.data.size;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme type on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_type = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);\n\t\tif (!p) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: Missing CENC scheme version on protected item\\n\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_SERVICE_ERROR;\n\t\t}\n\t\tcenc_info.scheme_version = p->value.uint;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\tif (!p || (p->type != GF_PROP_DATA) || !gf_cenc_validate_key_info(p->value.data.ptr, p->value.data.size)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Error: %s CENC Key info on protected item\\n\", p ? \"Corrupted\" : \"Missing\"));\n\t\t\tif (config_box) gf_isom_box_del(config_box);\n\t\t\tif (free_config_ba) gf_free(image_props.config_ba);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tcenc_info.key_info = p->value.data.ptr;\n\t\tcenc_info.key_info_size = p->value.data.size;\n\n\t\timage_props.cenc_info = &cenc_info;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PATTERN);\n\t\tif (p) {\n\t\t\tcenc_info.skip_byte_block = p->value.frac.num;\n\t\t\tcenc_info.crypt_byte_block = p->value.frac.den;\n\t\t}\n\n\n\t\tif (tkw->insert_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);\n\t\t\ttkw->insert_pssh = GF_FALSE;\n\t\t}\n\t}\n\n\tnb_items = gf_isom_get_meta_item_count(ctx->file, GF_TRUE, 0);\n\n\te = gf_isom_add_meta_item_memory(ctx->file, GF_TRUE, 0, item_name, &item_id, item_type, NULL, NULL, &image_props, (u8 *)data, size, NULL);\n\n\tif (config_box) gf_isom_box_del(config_box);\n\tif (free_config_ba) gf_free(image_props.config_ba);\n\n\tif (e) return e;\n\n\n\t//retrieve the final itemID\n\tgf_isom_get_meta_item_info(ctx->file, GF_TRUE, 0, nb_items+1, &item_id, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);\n\ttkw->item_id = item_id;\n\n\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PRIMARY_ITEM);\n\tif (p && p->value.boolean) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\t//if primary item is not set, assign one\n\telse if (! gf_isom_get_meta_primary_item_id(ctx->file, GF_TRUE, 0)) {\n\t\te = gf_isom_set_meta_primary_item(ctx->file, GF_TRUE, 0, item_id);\n\t\tif (e) return e;\n\t}\n\n\tif (!ctx->major_brand_set) {\n\t\tgf_isom_set_brand_info(ctx->file, GF_ISOM_BRAND_MIF1, 0);\n\t\tgf_isom_reset_alt_brands(ctx->file);\n\t\tctx->major_brand_set = 2;\n\t}\n\tif (media_brand && (ctx->major_brand_set==2)) {\n\t\tgf_isom_modify_alternate_brand(ctx->file, media_brand, 1);\n\t}\n\n\tif (tkw->codecid==GF_CODECID_HEVC_TILES) {\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"isom:tbas\");\n\t\tif (p && (p->value.uint_list.nb_items==1)) {\n\t\t\tgf_isom_meta_add_item_ref(ctx->file, GF_TRUE, 0, item_id, p->value.uint_list.vals[0], GF_ISOM_REF_TBAS, NULL);\n\t\t}\n\t}\n\n#if 0\n\tif (e == GF_OK && meta->ref_type) {\n\t\te = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, meta->ref_item_id, meta->ref_type, NULL);\n\t}\n#endif\n\treturn GF_OK;\n}\n\nstatic void mp4mux_send_output(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->dst_pck) {\n\t\tif (ctx->notify_filename) {\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, GF_TRUE, GF_FALSE);\n\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->cur_file_idx_plus_one-1) );\n\t\t\tif (ctx->cur_file_suffix) {\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILESUF, &PROP_STRING_NO_COPY(ctx->cur_file_suffix) );\n\t\t\t\tctx->cur_file_suffix = NULL;\n\t\t\t}\n\t\t\tctx->notify_filename = 0;\n\t\t\tif (ctx->dash_seg_start.den)\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_MPD_SEGSTART, &PROP_FRAC64(ctx->dash_seg_start) );\n\t\t}\n\t\tgf_filter_pck_send(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t}\n}\n\nstatic void mp4_mux_flush_frag_hls(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\t//send event on first track only\n\ttkw = gf_list_get(ctx->tracks, 0);\n\tGF_FEVT_INIT(evt, GF_FEVT_FRAGMENT_SIZE, tkw->ipid);\n\tevt.frag_size.is_last = ctx->flush_seg ? GF_TRUE : GF_FALSE;\n\tevt.frag_size.offset = ctx->frag_offset;\n\tevt.frag_size.size = ctx->frag_size;\n\tevt.frag_size.duration.num = (s64) ctx->frag_duration;\n\tevt.frag_size.duration.den = ctx->frag_timescale;\n\tevt.frag_size.independent = ctx->frag_has_intra;\n\n\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\tctx->frag_offset += ctx->frag_size;\n\tctx->frag_size = 0;\n\tctx->frag_duration = 0;\n\tctx->frag_has_intra = GF_FALSE;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic);\n\nstatic void mp4_mux_flush_seg(GF_MP4MuxCtx *ctx, Bool is_init, u64 idx_start_range, u64 idx_end_range, Bool signal_flush)\n{\n\tGF_FilterEvent evt;\n\tTrackWriter *tkw = NULL;\n\n\tif (ctx->dst_pck) {\n\t\tif (!ctx->single_file) {\n\t\t\tBool s, e;\n\t\t\tgf_filter_pck_get_framing(ctx->dst_pck, &s, &e);\n\t\t\tgf_filter_pck_set_framing(ctx->dst_pck, s, GF_TRUE);\n\t\t\tif (!is_init) {\n\t\t\t\tu64 dur = ctx->next_seg_start - (ctx->min_cts_plus_one-1);\n\t\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) dur);\n\t\t\t}\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t\tctx->current_offset = 0;\n\t\t\tif (is_init && s)\n\t\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_INIT, &PROP_BOOL(GF_TRUE) );\n\t\t}\n\t\tif (is_init) {\n\t\t\tgf_filter_pck_set_dependency_flags(ctx->dst_pck, 0xFF);\n\t\t\tgf_filter_pck_set_carousel_version(ctx->dst_pck, 1);\n\t\t}\n\t\t//also inject m4cc after init seg - cf issue 2482\n\t\tif (is_init && ctx->eos_marker) {\n\t\t\tu8 data[8];\n\t\t\tmemset(data, 0, 8);\n\t\t\tdata[3] = 8;\n\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t}\n\t\tmp4mux_send_output(ctx);\n\t\tif (signal_flush)\n\t\t\tgf_filter_pid_send_flush(ctx->opid);\n\t}\n\tif (!is_init && ctx->llhls_mode && ctx->frag_size) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\tif (ctx->dash_mode) {\n\t\t//send event on first track only\n\t\ttkw = gf_list_get(ctx->tracks, 0);\n\t\tGF_FEVT_INIT(evt, GF_FEVT_SEGMENT_SIZE, tkw->ipid);\n\t\tevt.seg_size.seg_url = NULL;\n\t\tevt.seg_size.is_init = is_init ? 1 : 0;\n\t\tif (!is_init || !idx_end_range) {\n\t\t\tevt.seg_size.media_range_start = ctx->current_offset;\n\t\t\tevt.seg_size.media_range_end = ctx->current_offset + ctx->current_size - 1;\n\t\t}\n\t\tif (idx_end_range && (ctx->vodcache==MP4MX_VODCACHE_INSERT))\n\t\t\tevt.seg_size.is_shift = 1;\n\n\t\tevt.seg_size.idx_range_start = idx_start_range;\n\t\tevt.seg_size.idx_range_end = idx_end_range;\n\t\tgf_filter_pid_send_event(tkw->ipid, &evt);\n\n\t\tctx->current_offset += ctx->current_size;\n\t\tctx->current_size = 0;\n\t\tctx->frag_offset = 0;\n\t\tctx->frag_size = 0;\n\t\tctx->frag_num = 0;\n\t\tctx->frag_has_intra = GF_FALSE;\n\t\t//changing file\n\t\tif (ctx->seg_name) {\n\t\t\tctx->first_pck_sent = GF_FALSE;\n\t\t}\n\t}\n}\n\nstatic void mp4mux_check_mpd_start_time(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_MPD_SEGSTART);\n\tif (p) {\n\t\tctx->dash_seg_start = p->value.lfrac;\n\t} else {\n\t\tctx->dash_seg_start.num = 0;\n\t\tctx->dash_seg_start.den = 0;\n\t}\n}\n\nstatic GF_Err mp4_mux_initialize_movie(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tTrackWriter *ref_tkw = NULL;\n\tu64 min_dts = 0;\n\tu32 min_dts_scale=0;\n\tu32 def_fake_dur=0;\n\tu32 def_fake_scale=0;\n#ifdef GF_ENABLE_CTRN\n\tu32 traf_inherit_base_id=0;\n#endif\n\tu32 nb_segments=0;\n\tGF_Fraction64 max_dur;\n\tctx->single_file = GF_TRUE;\n\tctx->current_offset = ctx->current_size = 0;\n\tmax_dur.den = 1;\n\tmax_dur.num = 0;\n\n\tif (ctx->sseg && ctx->noinit)\n\t\tctx->single_file = GF_FALSE;\n\n\tif (ctx->dur.num && ctx->dur.den) {\n\t\tmax_dur.num = ctx->dur.num;\n\t\tmax_dur.den = ctx->dur.den;\n\t}\n\n\t//make sure we have one sample from each PID. This will trigger potential pending reconfigure\n\t//for filters updating the PID caps before the first packet dispatch\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck;\n\t\tif (tkw->fake_track) continue;\n\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), continue setup\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\tif (!ctx->dash_mode && !ctx->cur_file_idx_plus_one) {\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t}\n\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP) {\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\t\t}\n\n\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\tif (p && strlen(p->value.string)) ctx->single_file = GF_FALSE;\n\n\t\tdef_fake_dur = gf_filter_pck_get_duration(pck);\n\t\tdef_fake_scale = tkw->src_timescale;\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DURATION);\n\t\tif (p && p->value.lfrac.den) {\n\t\t\ttkw->pid_dur = p->value.lfrac;\n\t\t\tif (tkw->pid_dur.num<0) tkw->pid_dur.num = -tkw->pid_dur.num;\n\t\t\tif (gf_timestamp_less(max_dur.num, max_dur.den, tkw->pid_dur.num, tkw->pid_dur.den)) {\n\t\t\t\tmax_dur.num = tkw->pid_dur.num;\n\t\t\t\tmax_dur.den = tkw->pid_dur.den;\n\t\t\t}\n\t\t}\n#ifdef GF_ENABLE_CTRN\n\t\tif (tkw->codecid==GF_CODECID_HEVC)\n\t\t\ttraf_inherit_base_id = tkw->track_id;\n#endif\n\t}\n\t//good to go, finalize for fragments\n\tfor (i=0; i<count; i++) {\n\t\tu32 def_pck_dur;\n\t\tu32 def_samp_size=0;\n\t\tu8 def_is_rap;\n#ifdef GF_ENABLE_CTRN\n\t\tu32 inherit_traf_from_track = 0;\n#endif\n\t\tu64 dts;\n\t\tconst GF_PropertyValue *p;\n\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (tkw->fake_track) {\n\t\t\tif (def_fake_scale) {\n\t\t\t\tdef_pck_dur = def_fake_dur;\n\t\t\t\tdef_pck_dur *= tkw->src_timescale;\n\t\t\t\tdef_pck_dur /= def_fake_scale;\n\t\t\t} else {\n\t\t\t\tdef_pck_dur = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t\t//can be null if eos\n\t\t\tif (pck) {\n\t\t\t\tu32 tscale;\n\t\t\t\t//otherwise setup fragmentation, using first sample desc as default idx\n\t\t\t\t//first pck dur as default\n\t\t\t\tdef_pck_dur = gf_filter_pck_get_duration(pck);\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts == GF_FILTER_NO_TS)\n\t\t\t\t\tdts = gf_filter_pck_get_cts(pck);\n\t\t\t\ttscale = gf_filter_pck_get_timescale(pck);\n\n\t\t\t\tif (!min_dts || gf_timestamp_greater(min_dts, min_dts_scale, dts, tscale)) {\n\t\t\t\t\tmin_dts = dts;\n\t\t\t\t\tmin_dts_scale = tscale;\n\t\t\t\t}\n\t\t\t\tif (tkw->raw_audio_bytes_per_sample) {\n\t\t\t\t\tu32 pck_size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &pck_size);\n\t\t\t\t\tpck_size /= tkw->raw_audio_bytes_per_sample;\n\t\t\t\t\tif (pck_size)\n\t\t\t\t\t\tdef_pck_dur /= pck_size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//check if we have a default constant duration set, if so use it\n\t\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CONSTANT_DURATION);\n\t\t\t\tdef_pck_dur = p ? p->value.uint : 0;\n\t\t\t}\n\t\t\tif (tkw->raw_audio_bytes_per_sample)\n\t\t\t\tdef_samp_size = tkw->raw_audio_bytes_per_sample;\n\t\t}\n\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\tdef_pck_dur *= tkw->tk_timescale;\n\t\t\tdef_pck_dur /= tkw->src_timescale;\n\t\t}\n\n\t\t//and consider audio & text all RAPs, the rest not rap - this will need refinement later on\n\t\t//but won't break the generated files\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_AUDIO:\n\t\tcase GF_STREAM_TEXT:\n\t\t\tdef_is_rap = GF_ISOM_FRAG_DEF_IS_SYNC;\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_HAS_SYNC);\n\t\t\tif (p && p->value.boolean)\n\t\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\t\tswitch (tkw->codecid) {\n\t\t\tcase GF_CODECID_PNG:\n\t\t\tcase GF_CODECID_JPEG:\n\t\t\tcase GF_CODECID_J2K:\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_HEVC_TILES:\n#ifdef GF_ENABLE_CTRN\n\t\t\t\tif (ctx->ctrn && ctx->ctrni)\n\t\t\t\t\tinherit_traf_from_track = traf_inherit_base_id;\n#endif\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!ref_tkw) ref_tkw = tkw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdef_is_rap = 0;\n\t\t\tbreak;\n\t\t}\n\t\t//CMAF 7.5.17, if non-sync sample are present stss SHALL be present and empty...\n\t\tif (ctx->cmaf && !def_is_rap) {\n\t\t\tdef_is_rap |= GF_ISOM_FRAG_USE_SYNC_TABLE;\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\t//use 1 for the default sample description index. If no multi stsd, this is always the case\n\t\t//otherwise we need to update the stsd idx in the traf headers\n\t\te = gf_isom_setup_track_fragment(ctx->file, tkw->track_id, tkw->stsd_idx, def_pck_dur, def_samp_size, def_is_rap, 0, 0, ctx->nofragdef ? GF_TRUE : GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to setup fragmentation for track ID %d: %s\\n\", tkw->track_id, gf_error_to_string(e) ));\n\t\t\treturn e;\n\t\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (ctx->refrag) {\n\t\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\tif (p) {\n\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t} else if (!ctx->nofragdef) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Refragmentation with default track fragment flags signaling but no TREX found in source track %d, using defaults computed from PID, result might be broken\\n\", tkw->track_id));\n\t\t\t}\n\t\t}\n#endif\n\n\n\t\tif (ctx->tfdt.den && ctx->tfdt.num) {\n\t\t\ttkw->tfdt_offset = gf_timestamp_rescale(ctx->tfdt.num, ctx->tfdt.den, tkw->tk_timescale);\n\t\t}\n\n\t\tif (tkw->fake_track) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ref_tkw==tkw) ref_tkw=NULL;\n\t\t\tmp4_mux_track_writer_del(tkw);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n#ifdef GF_ENABLE_CTRN\n\t\tif (inherit_traf_from_track)\n\t\t\tgf_isom_enable_traf_inherit(ctx->file, tkw->track_id, inherit_traf_from_track);\n#endif\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_DASH_SEGMENTS);\n\t\tif (p && (p->value.uint>nb_segments))\n\t\t\tnb_segments = p->value.uint;\n\n\t\tif (!ctx->dash_mode)\n\t\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\t}\n\n\tif (max_dur.num && max_dur.den) {\n\t\tu64 mdur = max_dur.num;\n\t\tif (ctx->moovts != max_dur.den) {\n\t\t\tmdur *= (u32) ctx->moovts;\n\t\t\tmdur /= max_dur.den;\n\t\t}\n\t\tgf_isom_set_movie_duration(ctx->file, mdur, GF_FALSE);\n\t}\n\telse if (ctx->cmaf) {\n\t\t//CMAF 7.3.2.1.c.6) \"The MovieExtendsBox may contain a MovieExtendsHeaderBox,\n\t\t//as defined in ISO/IEC 14496-12, and if so, shall provide the overall duration\n\t\t//of the CMAF track. If the duration is unknown, this box shall be omitted.\"\n\t\tgf_isom_set_movie_duration(ctx->file, 0, GF_TRUE);\n\t}\n\n\t//if we have an explicit track reference for fragmenting, move it first in our list\n\tif (ref_tkw) {\n\t\tgf_list_del_item(ctx->tracks, ref_tkw);\n\t\tgf_list_insert(ctx->tracks, ref_tkw, 0);\n\t}\n\tctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\n\tif (!ctx->abs_offset) {\n\t\tu32 mval = ctx->dash_mode ? '6' : '5';\n\t\tu32 mbrand, mcount, found=0;\n\t\tu8 szB[GF_4CC_MSIZE];\n\t\tgf_isom_set_fragment_option(ctx->file, 0, GF_ISOM_TFHD_FORCE_MOOF_BASE_OFFSET, 1);\n\n\t\tgf_isom_get_brand_info(ctx->file, &mbrand, NULL, &mcount);\n\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\ti=0;\n\t\twhile (!found && (i<mcount)) {\n\t\t\ti++;\n\t\t\tgf_isom_get_alternate_brand(ctx->file, i, &mbrand);\n\t\t\tstrcpy(szB, gf_4cc_to_str(mbrand));\n\t\t\tif (!strncmp(szB, \"iso\", 3) && (szB[3] >= mval) && (szB[3] <= 'F') ) found = 1;\n\t\t}\n\n\t\t/*because of movie fragments MOOF based offset, ISOM <4 is forbidden*/\n\t\tif (!found) {\n\t\t\tgf_isom_set_brand_info(ctx->file, ctx->dash_mode ? GF_ISOM_BRAND_ISO6 : GF_ISOM_BRAND_ISO5, 1);\n\t\t}\n\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISOM, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO2, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO3, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_AVC1, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP41, GF_FALSE);\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MP42, GF_FALSE);\n\t}\n\n\tif (ctx->dash_mode) {\n\t\t/*DASH self-init media segment*/\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DSMS, GF_TRUE);\n\t\t} else {\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_DASH, GF_TRUE);\n\t\t}\n\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_MSIX, ((ctx->dash_mode==MP4MX_DASH_VOD) && (ctx->subs_sidx>=0)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\te = gf_isom_finalize_for_fragment(ctx->file, ctx->dash_mode ? 1 : 0, ctx->mvex);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to finalize moov for fragmentation: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tctx->init_movie_done = GF_TRUE;\n\n\tif (min_dts_scale) {\n\t\tu64 rs_dts = gf_timestamp_rescale(min_dts, min_dts_scale, ctx->cdur.den);\n\t\tctx->next_frag_start = rs_dts;\n\t}\n\tctx->next_frag_start += ctx->cdur.num;\n\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->noinit) {\n\t\tif (ctx->dst_pck) gf_filter_pck_discard(ctx->dst_pck);\n\t\tctx->dst_pck = NULL;\n\t\tctx->current_size = ctx->current_offset = 0;\n\t\tctx->first_pck_sent = GF_FALSE;\n\t} else {\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, 0, 0, GF_TRUE);\n\t}\n\tassert(!ctx->dst_pck);\n\n\t//change major brand for segments\n\tif (ctx->styp && (strlen(ctx->styp)>=4)) {\n\t\tu32 styp_brand = GF_4CC(ctx->styp[0], ctx->styp[1], ctx->styp[2], ctx->styp[3]);\n\t\tu32 version = 0;\n\t\tchar *sep = strchr(ctx->styp, '.');\n\t\tif (sep) version = atoi(sep+1);\n\t\tgf_isom_set_brand_info(ctx->file, styp_brand, version);\n\t}\n\n\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\tif ((ctx->vodcache==MP4MX_VODCACHE_REPLACE) && !nb_segments && (!ctx->media_dur || !ctx->dash_dur.num) ) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Media duration unknown, cannot use replace mode of vodcache, using temp file for VoD storage\\n\"));\n\t\t\tctx->vodcache = MP4MX_VODCACHE_ON;\n\t\t\te = mp4mx_setup_dash_vod(ctx, NULL);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\tGF_BitStream *bs;\n\t\t\tu8 *output;\n\t\t\tchar *msg;\n\t\t\tGF_FilterPacket *pck;\n\t\t\tu32 len;\n\t\t\tBool exact_sidx = GF_TRUE;\n\n\t\t\tif (!nb_segments) {\n\t\t\t\texact_sidx = GF_FALSE;\n\t\t\t\tnb_segments = (u32) ( ctx->media_dur * ctx->dash_dur.den / ctx->dash_dur.num);\n\t\t\t\t//always add an extra segment\n\t\t\t\tnb_segments ++;\n\t\t\t\t//and safety alloc of 10%\n\t\t\t\tif (nb_segments>10)\n\t\t\t\t\tnb_segments += 10*nb_segments/100;\n\t\t\t\telse\n\t\t\t\t\tnb_segments ++;\n\t\t\t}\n\n\t\t\t//max sidx size: full box + sidx fields + timing 64 bit + nb segs (each 12 bytes)\n\t\t\tctx->sidx_max_size = 12 + (12 + 16) + 12 * nb_segments;\n\n\t\t\t//we produce an ssix, add full box + nb subsegs + nb_segments * (range_count=2 + 2*(range+size))\n\t\t\tif (ctx->ssix) {\n\t\t\t\tctx->sidx_max_size += 12 + 4 + nb_segments * 12;\n\t\t\t}\n\n\t\t\tif (!exact_sidx) {\n\t\t\t\t//and a free box\n\t\t\t\tctx->sidx_max_size += 8;\n\t\t\t\tctx->sidx_size_exact = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tctx->sidx_size_exact = GF_TRUE;\n\t\t\t}\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t\t//send a dummy packet\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\t//format as free box for now\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tgf_bs_write_u32(bs, ctx->sidx_max_size);\n\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\tmsg = \"GPAC \" GPAC_VERSION\" SIDX placeholder\";\n\t\t\tlen = (u32) strlen(msg);\n\t\t\tif (len+8>ctx->sidx_max_size) len = ctx->sidx_max_size - 8;\n\t\t\tgf_bs_write_data(bs, msg, len );\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\n\t\t\tctx->current_offset += ctx->sidx_max_size;\n\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_ON) {\n\t\t\tctx->store_output = GF_TRUE;\n\t\t} else {\n\t\t\tctx->store_output = GF_FALSE;\n\t\t\tctx->sidx_chunk_offset = (u32) (ctx->current_offset + ctx->current_size);\n\t\t}\n\t\tgf_isom_allocate_sidx(ctx->file, ctx->subs_sidx, ctx->chain_sidx, 0, NULL, NULL, NULL, ctx->ssix);\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\nstatic GF_Err mp4_mux_start_fragment(GF_MP4MuxCtx *ctx, GF_FilterPacket *pck)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tBool has_tfdt=GF_FALSE;\n\tGF_ISOStartFragmentFlags flags=0;\n\n\t//setup some default\n\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\tctx->msn += ctx->msninc;\n\tctx->min_cts_plus_one = 0;\n\n\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\n\te = gf_isom_start_fragment(ctx->file, flags);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\treturn e;\n\t}\n\tif (pck) {\n\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_MOOF_TEMPLATE);\n\t\tif (p && p->value.data.ptr) {\n\t\t\tGF_SegmentIndexBox *out_sidx = NULL;\n\t\t\tgf_isom_set_fragment_template(ctx->file, p->value.data.ptr, p->value.data.size, &has_tfdt, &out_sidx);\n\t\t\tif (out_sidx) {\n\t\t\t\tif (ctx->cloned_sidx) gf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = out_sidx;\n\t\t\t\tctx->cloned_sidx_index = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//setup some default\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\te = GF_OK;\n\t\tif (ctx->strun) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 0);\n\t\t}\n\t\t//fragment at sap boundaries for video, but not in dash mode (compatibility with old arch)\n\t\telse if (ctx->fsap && (tkw->stream_type == GF_STREAM_VISUAL) && !ctx->dash_mode) {\n\t\t\te = gf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_RANDOM_ACCESS, 1);\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable set fragment options: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t\ttkw->fragment_done = GF_FALSE;\n\t\ttkw->insert_tfdt = (has_tfdt || ctx->tfdt_traf || tkw->tfdt_offset) ? GF_TRUE : ctx->insert_tfdt;\n\t\ttkw->dur_in_frag = 0;\n\n\t\tif (ctx->trun_inter) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, 0);\n\t\t}\n\t\tif (ctx->truns_first) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUNS_FIRST, 1);\n\t\t}\n\n\t\tif (ctx->trunv1 ||\n\t\t\t//7.7 cmf2 For video CMAF Tracks not contained in Track Files, Version 1 shall be used.\n\t\t\t((ctx->cmaf==MP4MX_CMAF_CMF2) && (tkw->stream_type==GF_STREAM_VISUAL))\n\t\t) {\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_TRUN_V1, 1);\n\t\t}\n\t\tif (ctx->sdtp_traf)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\n\t\tif (ctx->tfdt64)\n\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_LARGE_TFDT, ctx->tfdt64);\n\n\t\tif (tkw->dyn_pssh) {\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 2);\n\t\t}\n\t\telse if (ctx->insert_pssh)\n\t\t\tmp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 1);\n\t}\n\tctx->fragment_started = GF_TRUE;\n\tctx->insert_tfdt = GF_FALSE;\n\tctx->insert_pssh = GF_FALSE;\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_flush_fragmented(GF_MP4MuxCtx *ctx)\n{\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tu32 nb_read, blocksize = ctx->block_size;\n\tif (ctx->flush_done + blocksize>ctx->flush_size) {\n\t\tblocksize = (u32) (ctx->flush_size - ctx->flush_done);\n\t}\n\tif (!blocksize) return GF_EOS;\n\tpck = gf_filter_pck_new_alloc(ctx->opid, blocksize, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tnb_read = (u32) gf_fread(output, blocksize, ctx->tmp_store);\n\tif (nb_read != blocksize) {\n\t\tchar tmp[1];\n\t\t//weird behavior on some file systems, dump debug info\n\t\tgf_fread(tmp, 1, ctx->tmp_store);\n\t\tBool is_eof = gf_feof(ctx->tmp_store);\n\t\tGF_LOG(is_eof ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error reading from VOD temp cache, read %d bytes but asked %d bytes\\n\\tCache EOF %d - cache size \"LLU\" - read pos \"LLU\" - file pos \"LLU\"\\n\", nb_read, blocksize, is_eof, ctx->flush_size, ctx->flush_done, gf_ftell(ctx->tmp_store)));\n\t}\n\tctx->flush_done += nb_read;\n\tif (ctx->flush_done==ctx->flush_size) {\n\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\t\tgf_filter_pck_send(pck);\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_send(pck);\n\t//we are not done flushing but we have no more input packets, signal we still need processing\n\tgf_filter_ask_rt_reschedule(ctx->filter, 1);\n\treturn GF_OK;\n}\n\nstatic void mp4mx_frag_box_patch(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tconst GF_PropertyValue *p;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (!tkw->track_id) continue;\n\t\t//no box patched set (todo, do we want to allow changing boxpatch props ?)\n\t\tif (!tkw->box_patched) continue;\n\n\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\tif (p && p->value.string) {\n\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_TRUE);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track fragment %d: %s\\n\",\n\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->boxpatch) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_TRUE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to fragment: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n}\n#endif // GPAC_DISABLE_ISOM_FRAGMENTS\n\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter);\n\nGF_Err mp4mx_reload_output(GF_MP4MuxCtx *ctx)\n{\n\tGF_Err e;\n\tu32 i, count = gf_list_count(ctx->tracks);\n\n\t//done with the file\n\tif (ctx->file) {\n\t\te = mp4_mux_done(ctx, GF_FALSE);\n\t\tif (e) return e;\n\t\tctx->file = NULL;\n\t}\n\tctx->init_movie_done = GF_FALSE;\n\te = mp4_mux_initialize(ctx->filter);\n\tif (e) return e;\n\tctx->config_timing = GF_TRUE;\n\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\ttkw->suspended = GF_FALSE;\n\t\ttkw->track_num = 0;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->max_cts = 0;\n\t\ttkw->min_cts = (u64) -1;\n\t\te = mp4_mux_configure_pid(ctx->filter, tkw->ipid, GF_FALSE);\n\t\tif (e) return e;\n\t\ttkw->nb_samples = 0;\n\t\ttkw->sample.DTS = 0;\n\t\ttkw->sample.CTS_Offset = 0;\n\t\ttkw->samples_in_stsd = 0;\n\t\ttkw->samples_in_frag = 0;\n\t}\n\tassert(ctx->next_file_idx);\n\tctx->cur_file_idx_plus_one = ctx->next_file_idx;\n\tctx->next_file_idx = 0;\n\tctx->notify_filename = GF_TRUE;\n\tassert(!ctx->cur_file_suffix);\n\tif (ctx->next_file_suffix) {\n\t\tctx->cur_file_suffix = gf_strdup(ctx->next_file_suffix);\n\t\tctx->next_file_suffix = NULL;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_process_fragmented(GF_MP4MuxCtx *ctx)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e = GF_OK;\n\tu32 nb_eos, nb_done, nb_suspended, i, count;\n\n\tif (ctx->flush_size) {\n\t\treturn mp4_mux_flush_fragmented(ctx);\n\t}\n\n\tif (!ctx->file)\n\t\treturn GF_EOS;\n\n\t//init movie not yet produced\n\tif (!ctx->init_movie_done) {\n\t\te = mp4_mux_initialize_movie(ctx);\n\t\tif (e) return e;\n\t\tif (!ctx->init_movie_done)\n\t\t\treturn GF_OK;\n\t}\n\t/*get count after init, some tracks may have been remove*/\n\tcount = gf_list_count(ctx->tracks);\n\n\t//process pid by pid\n\tnb_eos=0;\n\tnb_done = 0;\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tu64 cts, dts, ncts;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tif (ctx->fragment_started && tkw->fragment_done) {\n\t\t\tnb_done ++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tkw->suspended) {\n\t\t\tif (ctx->fragment_started) nb_done++;\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (1) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tu32 orig_frag_bounds=0;\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\t\tif (!pck) {\n\t\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\t\tif (ctx->next_file_idx)\n\t\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif (!gf_filter_pid_is_flush_eos(tkw->ipid))\n\t\t\t\t\t\tnb_eos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tnb_eos++;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tif (ctx->dash_mode) ctx->flush_seg = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//we create dash segment only when we know we have a packet, not before this loop.\n\t\t\t//This allows taking into account flush signals, otherwise we would create empty segments\n\t\t\tif (ctx->dash_mode && !ctx->segment_started) {\n\t\t\t\tctx->segment_started = GF_TRUE;\n\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\tswitch (ctx->psshs) {\n\t\t\t\tcase MP4MX_PSSH_MOOF:\n\t\t\t\tcase MP4MX_PSSH_BOTH:\n\t\t\t\t\tctx->insert_pssh = GF_TRUE; break;\n\t\t\t\tdefault:\n\t\t\t\t\tctx->insert_pssh = GF_FALSE; break;\n\t\t\t\t}\n\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t}\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\n\t\t\tif (cts == GF_FILTER_NO_TS) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_EODS);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\ttkw->next_seg_cts = tkw->cts_next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MuxIsom] Packet with no CTS assigned, cannot store to track, ignoring\\n\"));\n\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\tif (p) {\n\t\t\t\torig_frag_bounds = p->value.uint;\n\n\t\t\t\tif (orig_frag_bounds==2) {\n\t\t\t\t\tif (!ctx->segment_started) {\n\t\t\t\t\t\tctx->dash_mode = 1;\n\t\t\t\t\t\tctx->insert_tfdt = GF_TRUE;\n\t\t\t\t\t\tgf_isom_start_segment(ctx->file, ctx->single_file ? NULL : \"_gpac_isobmff_redirect\", GF_FALSE);\n\t\t\t\t\t} else if (tkw->samples_in_frag) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//get dash/file segment number\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\n\t\t\t//not dash and file end, we need to wait for all streams and resetup\n\t\t\tif (!ctx->dash_mode && p) {\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!ctx->fragment_started) {\n\t\t\t\te = mp4_mux_start_fragment(ctx, orig_frag_bounds ? pck : NULL);\n\t\t\t\tif (e) return e;\n\n\t\t\t\t//push emsgonce the segment is started\n\t\t\t\tconst GF_PropertyValue *emsg = gf_filter_pck_get_property_str(pck, \"grp_EMSG\");\n\t\t\t\tif (emsg && (emsg->type==GF_PROP_DATA) && emsg->value.data.ptr) {\n\t\t\t\t\tGF_Err gf_isom_set_emsg(GF_ISOFile *movie, u8 *data, u32 size);\n\n\t\t\t\t\tgf_isom_set_emsg(ctx->file, emsg->value.data.ptr, emsg->value.data.size);\n\t\t\t\t}\n\n\t\t\t\tctx->nb_frags++;\n\t\t\t\tif (ctx->dash_mode)\n\t\t\t\t\tctx->nb_frags_in_seg++;\n\n\t\t\t}\n\n\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tif (p) {\n\t\t\t\t\tmp4mux_check_mpd_start_time(ctx, pck);\n\t\t\t\t\t//start of next segment, abort fragmentation for this track and flush all other writers\n\t\t\t\t\tif (ctx->dash_seg_num_plus_one && (ctx->dash_seg_num_plus_one != 1 + p->value.uint) ) {\n\t\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\t\tnb_done ++;\n\t\t\t\t\t\t//make sure we flush until the end of the segment\n\t\t\t\t\t\tctx->flush_seg = GF_TRUE;\n\t\t\t\t\t\t//store CTS of next packet (first in next segment) for sidx compute\n\t\t\t\t\t\ttkw->next_seg_cts = cts;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//start of current segment, remember segment number and name\n\t\t\t\t\tctx->dash_seg_num_plus_one = 1 + p->value.uint;\n\t\t\t\t\t//get file name prop if any - only send on one pid for muxed content\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENAME);\n\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\t\t\t\t\t\tctx->seg_name = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\t//store PRFT only for reference track at segment start\n\t\t\t\t\tif (tkw==ctx->ref_tkw) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SENDER_NTP);\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tgf_isom_set_fragment_reference_time(ctx->file, tkw->track_id, p->value.longuint, cts);\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[MuxIsom] Segment %s, storing NTP TS \"LLU\" for CTS \"LLU\" at \"LLU\" us, at UTC \"LLU\"\\n\", ctx->seg_name ? ctx->seg_name : \"singlefile\", p->value.longuint, cts, gf_sys_clock_high_res(), gf_net_get_utc()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\t\t\t\tif (tkw->first_dts_in_seg_plus_one && (tkw->first_dts_in_seg_plus_one - 1 > dts))\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + dts;\n\t\t\t}\n\t\t\tncts = cts + gf_filter_pck_get_duration(pck);\n\t\t\tif (tkw->cts_next < ncts)\n\t\t\t\ttkw->cts_next = ncts;\n\n\t\t\t//compute ts after delay/skip for fragment interleaving\n\t\t\tu64 check_ts;\n\t\t\tif ((tkw->ts_delay<0) && (cts < -tkw->ts_delay))\n\t\t\t\tcheck_ts = 0;\n\t\t\telse\n\t\t\t\tcheck_ts = cts+tkw->ts_delay;\n\n\t\t\t//we have samples and either a request to flush fragment or a emsg, start new fragment\n\t\t\tif (tkw->samples_in_frag && (orig_frag_bounds || (gf_filter_pck_get_property_str(pck, \"grp_EMSG\")!=NULL))) {\n\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\tnb_done ++;\n\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\tbreak;\n\t\t\t} else if (ctx->fragdur && (!ctx->dash_mode || !tkw->fragment_done) ) {\n\t\t\t\tBool frag_done = GF_FALSE;\n\t\t\t\tu32 dur = gf_filter_pck_get_duration(pck);\n\t\t\t\tif (tkw->dur_in_frag && gf_timestamp_greater_or_equal(tkw->dur_in_frag, tkw->src_timescale, ctx->cdur.num, ctx->cdur.den)) {\n\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t} else if ((ctx->store==MP4MX_MODE_SFRAG)\n\t\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t\t) {\n\t\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t\tif ((sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\t\tfrag_done = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (frag_done) {\n\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\ttkw->dur_in_frag = 0;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttkw->dur_in_frag += dur;\n\t\t\t\tif (ctx->llhls_mode && (ctx->frag_duration * tkw->src_timescale <= tkw->dur_in_frag * ctx->frag_timescale)) {\n\t\t\t\t\tctx->frag_duration = tkw->dur_in_frag;\n\t\t\t\t\tctx->frag_timescale = tkw->src_timescale;\n\t\t\t\t}\n\t\t\t} else if (!ctx->flush_seg && !ctx->dash_mode\n\t\t\t\t&& gf_timestamp_greater_or_equal(check_ts, tkw->src_timescale, ctx->adjusted_next_frag_start, ctx->cdur.den)\n\t\t\t ) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\t//consider roll SAP as sap1 for the fragmentation\n\t\t\t\tif ((sap==GF_FILTER_SAP_4) && (tkw->stream_type==GF_STREAM_AUDIO))\n\t\t\t\t\tsap = GF_FILTER_SAP_1;\n\n\t\t\t\tif ((ctx->store==MP4MX_MODE_FRAG) || (sap && sap<GF_FILTER_SAP_3)) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->store>=MP4MX_MODE_FRAG) && tkw->samples_in_frag) {\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);\n\t\t\t\tif (p && (p->type == GF_PROP_DATA) && p->value.data.ptr && !ctx->flush_seg && !ctx->dash_mode) {\n\t\t\t\t\ttkw->fragment_done = GF_TRUE;\n\t\t\t\t\ttkw->samples_in_frag = 0;\n\t\t\t\t\tnb_done ++;\n\t\t\t\t\tif (ctx->store==MP4MX_MODE_SFRAG) {\n\t\t\t\t\t\tctx->adjusted_next_frag_start = gf_timestamp_rescale(check_ts, tkw->src_timescale, ctx->cdur.den);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tkw->insert_tfdt) {\n\t\t\t\tu64 odts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (odts==GF_FILTER_NO_TS)\n\t\t\t\t\todts = gf_filter_pck_get_cts(pck);\n\n\t\t\t\tif (tkw->tfdt_offset) {\n\t\t\t\t\t//first sample, set offset dts such that first sample dts - offset_dts = target time\n\t\t\t\t\tif (tkw->nb_samples==0) {\n\t\t\t\t\t\tu64 target = tkw->tfdt_offset;\n\t\t\t\t\t\ttkw->tfdt_offset = odts - target;\n\n\t\t\t\t\t}\n\t\t\t\t\todts = odts - tkw->tfdt_offset;\n\t\t\t\t}\n\n\t\t\t\ttkw->insert_tfdt = GF_FALSE;\n\t\t\t\tif (tkw->patch_tfdt)\n\t\t\t\t\t//if patch_tfdt is true, tkw->ts_delay is always >0\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts + tkw->ts_delay);\n\t\t\t\telse\n\t\t\t\t\tgf_isom_set_traf_base_media_decode_time(ctx->file, tkw->track_id, odts);\n\n\t\t\t\tif (!tkw->first_dts_in_seg_plus_one)\n\t\t\t\t\ttkw->first_dts_in_seg_plus_one = 1 + (u64) odts;\n\t\t\t}\n\n\t\t\tif (ctx->trun_inter) {\n\t\t\t\tGF_FilterSAPType sap = mp4_mux_get_sap(ctx, pck);\n\t\t\t\ts32 tid_group = 0;\n\t\t\t\tif (sap) {\n\t\t\t\t\ttkw->prev_tid_group = 0;\n\t\t\t\t} else {\n\t\t\t\t\ts64 dts_diff;\n\t\t\t\t\ts64 p_dts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\ts64 p_cts = gf_filter_pck_get_cts(pck);\n\t\t\t\t\ts64 cts_o = p_cts - p_dts;\n\t\t\t\t\tdts_diff = p_dts - tkw->sample.DTS;\n\t\t\t\t\ttid_group = (s32) (cts_o / dts_diff);\n\t\t\t\t\ttid_group = 20 - tid_group;\n\t\t\t\t\tif (tid_group != tkw->prev_tid_group) {\n\t\t\t\t\t\ttkw->prev_tid_group = tid_group;\n\t\t\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRUN_SET_INTERLEAVE_ID, tid_group);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//process packet\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_TRUE);\n\n\t\t\t//discard\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\n\t\t\tcts = gf_timestamp_rescale(cts, tkw->src_timescale, 1000);\n\t\t\tif (!ctx->min_cts_plus_one) ctx->min_cts_plus_one = cts + 1;\n\t\t\telse if (ctx->min_cts_plus_one-1 > cts) ctx->min_cts_plus_one = cts + 1;\n\n\t\t\tif (e) return e;\n\t\t}\n\t\t//done with this track - if single track per moof, request new fragment but don't touch the\n\t\t//fragmentation state of the track writers\n\t\tif (ctx->straf && (i+1 < count)) {\n\t\t\tGF_ISOStartFragmentFlags flags = 0;\n\t\t\tif (ctx->moof_first) flags |= GF_ISOM_FRAG_MOOF_FIRST;\n#ifdef GF_ENABLE_CTRN\n\t\t\tif (ctx->ctrn) flags |= GF_ISOM_FRAG_USE_COMPACT;\n#endif\n\t\t\te = gf_isom_start_fragment(ctx->file, flags);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to start new fragment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\treturn e;\n\t\t\t}\n\t\t\tgf_isom_set_next_moof_number(ctx->file, ctx->msn);\n\t\t\tctx->msn++;\n\t\t\tif (ctx->sdtp_traf)\n\t\t\t\tgf_isom_set_fragment_option(ctx->file, tkw->track_id, GF_ISOM_TRAF_USE_SAMPLE_DEPS_BOX, ctx->sdtp_traf);\n\t\t}\n\t}\n\n\t//all suspended tracks done, flush fragment\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tnb_done = count;\n\t}\n\n\n\tif (nb_done==count) {\n\t\t//nothing open (this happens when flushing segments/fragments)\n\t\tif (!ctx->segment_started && !ctx->fragment_started)\n\t\t\tgoto check_eos;\n\n\t\tBool is_eos = (count == nb_eos) ? GF_TRUE : GF_FALSE;\n\t\tu32 ref_timescale;\n\t\tBool flush_refs = ctx->dash_mode ? GF_FALSE : GF_TRUE;\n\t\tu64 next_ref_ts = ctx->ref_tkw->next_seg_cts;\n\t\tif (is_eos)\n\t\t\tnext_ref_ts = ctx->ref_tkw->cts_next;\n\n\t\tref_timescale = ctx->ref_tkw->src_timescale;\n\t\t//both in ms\n\t\tctx->next_seg_start = (u64) gf_timestamp_rescale(next_ref_ts, ref_timescale, 1000);\n\t\tctx->min_cts_next_frag = (u64) gf_timestamp_rescale(ctx->next_frag_start, ctx->cdur.den, 1000);\n\n\t\tctx->next_frag_start += ctx->cdur.num;\n\t\twhile (ctx->next_frag_start <= ctx->adjusted_next_frag_start) {\n\t\t\tctx->next_frag_start += ctx->cdur.num;\n\t\t}\n\t\tctx->adjusted_next_frag_start = ctx->next_frag_start;\n\n\t\tmp4mx_frag_box_patch(ctx);\n\n\t\t//end of DASH segment\n\t\tif (ctx->dash_mode && (ctx->flush_seg || is_eos) ) {\n\t\t\tu64 offset = ctx->single_file ? ctx->current_offset : 0;\n\t\t\tu64 idx_start_range, idx_end_range, segment_size_in_bytes;\n\t\t\ts32 subs_sidx = -1;\n\t\t\tu32 track_ref_id = 0;\n\n\t\t\tidx_start_range = idx_end_range = 0;\n\t\t\tif (ctx->subs_sidx>=0) {\n\t\t\t\tsubs_sidx = ctx->subs_sidx;\n\t\t\t\ttrack_ref_id = ctx->ref_tkw->track_id;\n\t\t\t}\n\t\t\tif (ctx->cloned_sidx && (ctx->subs_sidx!=-2) ) {\n\t\t\t\tsubs_sidx = (s32) ctx->cloned_sidx->nb_refs;\n\t\t\t\ttrack_ref_id = ctx->cloned_sidx->reference_ID;\n\t\t\t\tgf_isom_box_del((GF_Box *)ctx->cloned_sidx);\n\t\t\t\tctx->cloned_sidx = NULL;\n\t\t\t}\n\n\t\t\te = gf_isom_close_segment(ctx->file, subs_sidx, track_ref_id, ctx->ref_tkw->first_dts_in_seg_plus_one ? ctx->ref_tkw->first_dts_in_seg_plus_one-1 : 0,\n\t\t\t\tctx->ref_tkw->negctts_shift ? 0 : ctx->ref_tkw->ts_delay,\n\t\t\t\tnext_ref_ts, ctx->chain_sidx, ctx->ssix, ctx->sseg ? GF_FALSE : is_eos, GF_FALSE, ctx->eos_marker, &idx_start_range, &idx_end_range, &segment_size_in_bytes);\n\t\t\tctx->ref_tkw->first_dts_in_seg_plus_one = 0;\n\t\t\tif (e) return e;\n\t\t\tflush_refs = GF_TRUE;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing segment %d - estimated next fragment times start %g end %g\\n\", ctx->dash_seg_num_plus_one - 1, ((Double)next_ref_ts)/ref_timescale, ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\tif (ctx->dash_mode != MP4MX_DASH_VOD) {\n\t\t\t\t//we need to wait for packet to be written\n\t\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\t\tctx->flush_idx_start_range = offset + idx_start_range;\n\t\t\t\t\tctx->flush_idx_end_range = idx_end_range ? offset + idx_end_range : 0;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, offset + idx_start_range, idx_end_range ? offset + idx_end_range : 0, !is_eos);\n\t\t\t} else if (ctx->vodcache==MP4MX_VODCACHE_REPLACE) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t} else {\n\t\t\t\tif (ctx->nb_seg_sizes == ctx->alloc_seg_sizes) {\n\t\t\t\t\t ctx->alloc_seg_sizes *= 2;\n\t\t\t\t\t if (!ctx->alloc_seg_sizes) ctx->alloc_seg_sizes = 10;\n\t\t\t\t\t ctx->seg_sizes = gf_realloc(ctx->seg_sizes, sizeof(u32) * ctx->alloc_seg_sizes);\n\t\t\t\t}\n\t\t\t\tassert(segment_size_in_bytes);\n\t\t\t\tctx->seg_sizes[ctx->nb_seg_sizes] = (u32) segment_size_in_bytes;\n\t\t\t\tctx->nb_seg_sizes++;\n\t\t\t}\n\t\t\t//we still need to send seg size info for for HLS !\n\t\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT)\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t}\n\t\t//cannot flush in DASH mode if using sidx (vod single sidx or live 1 sidx/seg)\n\t\telse if (!ctx->dash_mode || ((ctx->subs_sidx<0) && (ctx->dash_mode<MP4MX_DASH_VOD) && !ctx->cloned_sidx) ) {\n\t\t\tgf_isom_flush_fragments(ctx->file, GF_FALSE);\n\t\t\tflush_refs = GF_TRUE;\n\t\t\t//if not in dash and EOS marker is set, inject marker after each fragment\n\t\t\tif (!ctx->dash_mode && ctx->eos_marker && ctx->fragment_started) {\n\t\t\t\tu8 data[8];\n\t\t\t\tmemset(data, 0, 8);\n\t\t\t\tdata[3] = 8;\n\t\t\t\tdata[4] = ctx->m4cc[0];\n\t\t\t\tdata[5] = ctx->m4cc[1];\n\t\t\t\tdata[6] = ctx->m4cc[2];\n\t\t\t\tdata[7] = ctx->m4cc[3];\n\t\t\t\tmp4_mux_on_data(ctx, data, 8, NULL, 0);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[MP4Mux] Done writing fragment - next fragment start time %g\\n\", ((Double)ctx->next_frag_start)/ctx->cdur.den ));\n\n\t\t\t//we need to wait for packet to be written\n\t\t\tif (ctx->seg_flush_state) {\n\t\t\t\tif (ctx->llhls_mode) ctx->flush_ll_hls = GF_TRUE;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\n\t\t\tif (ctx->llhls_mode) {\n\t\t\t\tmp4_mux_flush_frag_hls(ctx);\n\t\t\t}\n\n\t\t\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, !is_eos);\n\t\t\t}\n\t\t}\n\t\tctx->fragment_started = GF_FALSE;\n\n\t\tif (ctx->flush_seg) {\n\t\t\tctx->segment_started = GF_FALSE;\n\t\t\tctx->flush_seg = GF_FALSE;\n\t\t\tctx->dash_seg_num_plus_one = 0;\n\t\t\tctx->nb_segs++;\n\t\t\tctx->nb_frags_in_seg=0;\n\t\t}\n\t\t//destroy any pending refs\n\t\tif (flush_refs) {\n\t\t\twhile (gf_list_count(ctx->ref_pcks)) {\n\t\t\t\tGF_FilterPacket *pckr = gf_list_pop_back(ctx->ref_pcks);\n\t\t\t\tgf_filter_pck_unref(pckr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nb_suspended && (nb_suspended==count)) {\n\t\tctx->nb_segs=0;\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\ncheck_eos:\n\tif (count == nb_eos) {\n\t\tif (ctx->dash_mode==MP4MX_DASH_VOD) {\n\t\t\tif (ctx->vodcache!=MP4MX_VODCACHE_ON) {\n\t\t\t\tctx->final_sidx_flush = GF_TRUE;\n\t\t\t\t//flush SIDX in given space - this will reserve 8 bytes for free box if not fitting\n\t\t\t\tgf_isom_flush_sidx(ctx->file, ctx->sidx_max_size, (ctx->sidx_size_exact || ctx->tfdt64) ? GF_TRUE : GF_FALSE);\n\t\t\t} else {\n\t\t\t\tu64 start_offset;\n\t\t\t\t//reenable packet dispatch\n\t\t\t\tctx->store_output = GF_FALSE;\n\t\t\t\tgf_isom_flush_sidx(ctx->file, 0, ctx->tfdt64);\n\t\t\t\t//flush sidx packet\n\t\t\t\tmp4mux_send_output(ctx);\n\n\t\t\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->current_offset, ctx->current_offset + ctx->current_size - 1, GF_FALSE);\n\n\t\t\t\tgf_fflush(ctx->tmp_store);\n\t\t\t\tctx->flush_size = gf_ftell(ctx->tmp_store);\n\t\t\t\tctx->flush_done = 0;\n\t\t\t\tgf_fseek(ctx->tmp_store, 0, SEEK_SET);\n\n\t\t\t\tif (ctx->seg_sizes) {\n\t\t\t\t\tstart_offset = ctx->current_offset;\n\t\t\t\t\tfor (i=0; i<ctx->nb_seg_sizes; i++) {\n\t\t\t\t\t\tctx->current_size = ctx->seg_sizes[i];\n\t\t\t\t\t\tmp4_mux_flush_seg(ctx, GF_FALSE, 0, 0, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\tctx->current_offset = start_offset;\n\t\t\t\t\tctx->current_size = 0;\n\n\t\t\t\t\tgf_free(ctx->seg_sizes);\n\t\t\t\t\tctx->seg_sizes = NULL;\n\t\t\t\t\tctx->alloc_seg_sizes = ctx->nb_seg_sizes = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//only destroy file if not dash or not onDemand, otherwise (regular dash) the file will be needed to append further segments\n\t\tif (ctx->dash_mode!=MP4MX_DASH_ON) {\n\t\t\t//only delete file in vod mode\n\t\t\tif (ctx->file) {\n\t\t\t\tgf_isom_close(ctx->file);\n\t\t\t\tctx->file = NULL;\n\t\t\t}\n\t\t}\n\n\t\tmp4mux_send_output(ctx);\n\n\t\tif (!ctx->flush_size) gf_filter_pid_set_eos(ctx->opid);\n\n\t\treturn ctx->flush_size ? GF_OK : GF_EOS;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nstruct _service_info\n{\n\tu32 service_id;\n\tu64 first_ts_min;\n\tu32 nb_non_sparse, nb_non_sparse_ready;\n\tu32 nb_sparse, nb_sparse_ready;\n};\nstatic struct _service_info *get_service_info(GF_List *services, TrackWriter *tkw)\n{\n\tstruct _service_info *si;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_SERVICE_ID);\n\tu32 ID, i, count=gf_list_count(services);\n\tID = p ? p->value.uint : 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsi = gf_list_get(services, i);\n\t\tif (si->service_id == ID) return si;\n\t}\n\tGF_SAFEALLOC(si, struct _service_info)\n\tsi->service_id = ID;\n\tsi->first_ts_min = (u64) -1;\n\tgf_list_add(services, si);\n\treturn si;\n}\nstatic void del_service_info(GF_List *services)\n{\n\twhile (gf_list_count(services)) {\n\t\tstruct _service_info *si = gf_list_pop_back(services);\n\t\tgf_free(si);\n\t}\n\tgf_list_del(services);\n}\n\nstatic void mp4_mux_update_init_edit(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u64 min_ts_service, Bool skip_adjust)\n{\n\t//compute offsets\n\ts64 dts_diff = ctx->tsalign ? gf_timestamp_rescale(min_ts_service, 1000000, tkw->src_timescale) : 0;\n\n\tif (!skip_adjust) {\n\t\tdts_diff = (s64) tkw->ts_shift - dts_diff;\n\t}\n\tif (ctx->is_rewind) dts_diff = -dts_diff;\n\t//negative could happen due to rounding, ignore them\n\tif (dts_diff <= (gf_sys_old_arch_compat() ? 0 : 1)) return;\n\n\t// dts_diff > 0, we need to delay the track\n\tu64 dur = gf_timestamp_rescale(dts_diff, tkw->src_timescale, ctx->moovts);\n\tif (dur) {\n\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, dur, dts_diff, GF_ISOM_EDIT_EMPTY);\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, dur, 0, 0, GF_ISOM_EDIT_NORMAL);\n\t\ttkw->empty_init_dur = (u64) dur;\n\t}\n}\n\nstatic void mp4_mux_config_timing(GF_MP4MuxCtx *ctx)\n{\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign) {\n\t\tctx->config_timing = GF_FALSE;\n\t\treturn;\n\t}\n\tGF_List *services = gf_list_new();\n\tu32 i, count;\n\tBool not_ready, blocking_refs, has_ready;\n\nretry_all:\n\tcount = gf_list_count(ctx->tracks);\n\tnot_ready = GF_FALSE;\n\tblocking_refs = GF_FALSE;\n\thas_ready = GF_FALSE;\n\n\tfor (i=0; i<gf_list_count(services);i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tsi->nb_non_sparse = si->nb_non_sparse_ready = 0;\n\t\tsi->nb_sparse = si->nb_sparse_ready = 0;\n\t}\n\n\t//compute min dts of first packet on each track - this assume all tracks are synchronized, might need adjustment for MPEG4 Systems\n\tfor (i=0; i<count; i++) {\n\t\tu64 ts, dts_min;\n\t\tGF_FilterPacket *pck;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tif (tkw->fake_track) continue;\n\t\t//get associated service\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\n\t\t//already setup (happens when new PIDs are declared after a packet has already been written on other PIDs)\n\t\tif (tkw->nb_samples) {\n\t\t\tdts_min = gf_timestamp_rescale(tkw->ts_shift, tkw->src_timescale, 1000000);\n\n\t\t\tif (si->first_ts_min > dts_min) {\n\t\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nretry_pck:\n\t\tpck = gf_filter_pid_get_packet(tkw->ipid);\n\t\t//check this after fetching a packet since it may reconfigure the track\n\t\tif (!tkw->track_num) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] PID has no input packet and configuration not known after 10 retries, aborting initial timing sync\\n\"));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnot_ready = GF_TRUE;\n\t\t\ttkw->ts_shift = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pck) {\n\t\t\tif (gf_filter_pck_is_blocking_ref(pck))\n\t\t\t\tblocking_refs = GF_TRUE;\n\t\t\tif (tkw->wait_sap) {\n\t\t\t\tGF_FilterSAPType sap = gf_filter_pck_get_sap(pck);\n\t\t\t\tBool seek = gf_filter_pck_get_seek_flag(pck);\n\t\t\t\tif (seek || !sap) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t} else {\n\t\t\t\t\ttkw->wait_sap = GF_FALSE;\n\n\t\t\t\t\tif (!ctx->wait_dts_plus_one) {\n\t\t\t\t\t\tctx->wait_dts_plus_one = 1 + gf_filter_pck_get_dts(pck);\n\t\t\t\t\t\tctx->wait_dts_timescale = tkw->src_timescale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ctx->wait_dts_plus_one) {\n\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\t\t\tts=0;\n\n\t\t\t\tif (gf_timestamp_less(ts, tkw->src_timescale, (ctx->wait_dts_plus_one-1), ctx->wait_dts_timescale)) {\n\t\t\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\t\t\tgoto retry_pck;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\t//eos (wether real or flush event), setup cenc\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid)) {\n\t\t\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\t\t\tmp4_mux_cenc_update(ctx, tkw, NULL, CENC_CONFIG, 0, 0);\n\n\t\t\t\tif (!tkw->nb_samples) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_TREX_TEMPLATE);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tgf_isom_setup_track_fragment_template(ctx->file, tkw->track_id, p->value.data.ptr, p->value.data.size, ctx->nofragdef);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n\t\t\t\tif (tkw->dgl_copy) {\n\t\t\t\t\tgf_filter_pck_discard(tkw->dgl_copy);\n\t\t\t\t\ttkw->dgl_copy = NULL;\n\t\t\t\t}\n\t\t\t\tswitch (tkw->stream_type) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tsi->nb_non_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsi->nb_sparse_ready++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttkw->ts_shift = 0;\n\t\t\ttkw->si_min_ts_plus_one = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t//we may have reorder tracks after the get_packet, redo\n\t\tif (gf_list_find(ctx->tracks, tkw) != i) {\n\t\t\tgoto retry_all;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts = gf_filter_pck_get_cts(pck);\n\t\tif (ts==GF_FILTER_NO_TS)\n\t\t\tts=0;\n\n\t\tdts_min = gf_timestamp_rescale(ts, tkw->src_timescale, 1000000);\n\n\t\tif (si->first_ts_min > dts_min) {\n\t\t\tsi->first_ts_min = (u64) dts_min;\n\t\t\thas_ready = GF_TRUE;\n\t\t}\n\n\t\tswitch (tkw->stream_type) {\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tsi->nb_non_sparse_ready++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi->nb_sparse_ready++;\n\t\t\tbreak;\n\t\t}\n\n\t\ttkw->ts_shift = ts;\n\t\ttkw->si_min_ts_plus_one = 0;\n\t}\n\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\t//if some non-sparse streams are not ready, try to wait\n\t\tif (si->nb_non_sparse) {\n\t\t\tif (si->nb_non_sparse > si->nb_non_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t\t//otherwise (only sparse stream), wait until first\n\t\telse if (si->nb_sparse) {\n\t\t\tif (!si->nb_sparse_ready) not_ready = GF_TRUE;\n\t\t}\n\t}\n\n\tif (not_ready) {\n\t\tif (blocking_refs && has_ready) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Blocking input packets present, aborting initial timing sync\\n\"));\n\t\t}\n\t\t//this may be quite long until we have a packet in case input pid is video encoding\n\t\telse if (ctx->config_retry_start && (gf_sys_clock() - ctx->config_retry_start > 10000)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] No input packets present on one or more inputs for more than 10s, aborting initial timing sync\\n\"));\n\t\t} else {\n\t\t\tctx->config_retry_start = gf_sys_clock();\n\t\t\tdel_service_info(services);\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->config_retry_start = 0;\n\tfor (i=0; i<gf_list_count(services); i++) {\n\t\tstruct _service_info *si = gf_list_get(services, i);\n\t\tif (si->first_ts_min==(u64)-1)\n\t\t\tsi->first_ts_min = 0;\n\t}\n\n\t//for all packets with dts greater than min dts, we need to add a pause\n\tfor (i=0; i<count; i++) {\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tstruct _service_info *si = get_service_info(services, tkw);\n\t\tif (tkw->si_min_ts_plus_one) {\n\t\t\ttkw->si_min_ts_plus_one = si->first_ts_min + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//if single text track don't reset back to 0\n\t\tmp4_mux_update_init_edit(ctx, tkw, si->first_ts_min, ((count==1) && (tkw->stream_type == GF_STREAM_TEXT)) ? GF_TRUE : GF_FALSE);\n\t}\n\n\tctx->config_timing = GF_FALSE;\n\tdel_service_info(services);\n}\n\nvoid mp4_mux_format_report(GF_MP4MuxCtx *ctx, u64 done, u64 total)\n{\n\tBool status_changed=GF_FALSE;\n\tu32 total_pc = 0;\n\tchar *status = NULL, szTmp[2048], szTK[20];\n\tif (!gf_filter_reporting_enabled(ctx->filter))\n\t\treturn;\n\tif (!ctx->update_report)\n\t\treturn;\n\n\tctx->update_report = GF_FALSE;\n\n\tif (ctx->config_timing) {\n\t\tgf_dynstrcat(&status, \"waiting for clock init\", NULL);\n\t\tstatus_changed = GF_TRUE;\n\t} else if (total) {\n\t\tif (done>=total) {\n\t\t\tDouble ohead = 0;\n\t\t\tif (ctx->total_bytes_in) ohead =  ((Double) (ctx->total_bytes_out - ctx->total_bytes_in)*100 / ctx->total_bytes_in);\n\n\t\t\tsprintf(szTmp, \"done %d samples - bytes \"LLU\" in \"LLU\" out - overhead %02.02f%% (%02.02g B/sample)\", ctx->total_samples, ctx->total_bytes_in, ctx->total_bytes_out, ohead, ((Double)(ctx->total_bytes_out-ctx->total_bytes_in))/ctx->total_samples);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t\ttotal_pc = 10000;\n\n\t\t} else {\n\t\t\tu32 pc = (u32) ((done*10000)/total);\n\t\t\tif (ctx->last_mux_pc == pc + 1) return;\n\t\t\tctx->last_mux_pc = pc + 1;\n\t\t\tsprintf(szTmp, \"mux %d%%\", pc);\n\t\t\tstatus_changed = GF_TRUE;\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t} else {\n\t\tu32 i, count = gf_list_count(ctx->tracks);\n\t\tBool is_frag = GF_FALSE;\n\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tDouble next = ((Double)ctx->next_frag_start)/ctx->cdur.den;\n\t\t\tis_frag = GF_TRUE;\n\t\t\tif (ctx->dash_mode) {\n\t\t\t\tsprintf(szTmp, \"mux segments %d (frags %d) next %02.3f\", ctx->nb_segs, ctx->nb_frags_in_seg, next);\n\t\t\t} else {\n\t\t\t\tsprintf(szTmp, \"mux frags %d next %02.3f\", ctx->nb_frags, next);\n\t\t\t}\n\t\t} else {\n\t\t\tsprintf(szTmp, \"%s\", ((ctx->store==MP4MX_MODE_FLAT) || (ctx->store==MP4MX_MODE_FASTSTART)) ? \"mux\" : \"import\");\n\t\t}\n\t\tgf_dynstrcat(&status, szTmp, NULL);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 pc=0;\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tif (tkw->aborted) {\n\t\t\t\tpc=10000;\n\t\t\t} else if (ctx->dur.num) {\n\t\t\t\tif (ctx->dur.num>0) {\n\t\t\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\t\t\tu64 tk_done = mdur * ctx->dur.den;\n\t\t\t\t\tu64 tk_total = ((u64)tkw->tk_timescale) * ctx->dur.num;\n\t\t\t\t\tpc = (u32) ((tk_done*10000)/tk_total);\n\t\t\t\t} else {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset) ) / (-ctx->dur.num) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tkw->nb_frames) {\n\t\t\t\t\tpc = (u32) ( (10000 * (u64) (tkw->nb_samples + tkw->frame_offset)) / tkw->nb_frames);\n\t\t\t\t} else {\n\t\t\t\t\tif (tkw->pid_dur.num && tkw->pid_dur.den) {\n\t\t\t\t\t\tpc = (u32) ((tkw->sample.DTS*10000 * tkw->pid_dur.den) / (tkw->pid_dur.num * tkw->tk_timescale));\n\t\t\t\t\t} else if (tkw->down_bytes && tkw->down_size) {\n\t\t\t\t\t\tpc = (u32) (((tkw->down_bytes*10000) / tkw->down_size));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pc>10000)\n\t\t\t\tpc=0;\n\t\t\tif (tkw->last_import_pc != pc + 1) {\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\ttkw->last_import_pc = pc + 1;\n\t\t\t}\n\t\t\tif (!total_pc || (total_pc > pc))\n\t\t\t\ttotal_pc = pc;\n\n\t\t\tif (is_frag) {\n\t\t\t\tsprintf(szTK, \" TK%d(%c): %d\", tkw->track_id, tkw->status_type, tkw->samples_in_frag);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\tstatus_changed = GF_TRUE;\n\t\t\t\tif (pc) {\n\t\t\t\t\tsprintf(szTK, \" %d %%\", pc/100);\n\t\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsprintf(szTK, \" %s%d(%c): %d %%\", tkw->is_item ? \"IT\" : \"TK\", tkw->track_id, tkw->status_type, pc/100);\n\t\t\t\tgf_dynstrcat(&status, szTK, NULL);\n\t\t\t}\n\t\t}\n\t}\n\tif (status_changed) {\n\t\tgf_filter_update_status(ctx->filter, total_pc, status);\n\t}\n\tif (status) gf_free(status);\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx);\n\nGF_Err mp4_mux_process(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tu32 nb_skip, nb_eos, nb_suspended, i, count = gf_list_count(ctx->tracks);\n\tnb_skip = 0;\n\tnb_eos = 0;\n\n\tif (ctx->config_timing) {\n\t\tmp4_mux_config_timing(ctx);\n\t\tif (ctx->config_timing) {\n\t\t\tmp4_mux_format_report(ctx, 0, 0);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//fragmented mode\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tu32 done=0;\n\t\t//postpone until no pending connections, otherwise we will create init segment without all tracks\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tif (ctx->seg_flush_state==1) return GF_OK;\n\t\telse if (ctx->seg_flush_state==2)\n\t\t\tmp4_mux_flush_seg_events(ctx);\n\n\t\tGF_Err e = mp4_mux_process_fragmented(ctx);\n\t\tif (e==GF_EOS) done=100;\n\t\tmp4_mux_format_report(ctx, done, done);\n\t\treturn e;\n\t}\n\n\t//regular mode\n\tnb_suspended = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);\n\n\t\tif (tkw->suspended) {\n\t\t\tnb_suspended++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pck) {\n\t\t\tif (gf_filter_pid_is_eos(tkw->ipid) && !gf_filter_pid_is_flush_eos(tkw->ipid)) {\n\t\t\t\ttkw->suspended = GF_FALSE;\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (tkw->aborted) {\n\t\t\t\tnb_eos++;\n\t\t\t}\n\t\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\t\tnb_skip++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tkw->aborted) {\n\t\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\t\tnb_eos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->owns_mov) {\n\t\t\tconst GF_PropertyValue *p;\n\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);\n\t\t\tif (p) {\n\t\t\t\tmp4mux_check_mpd_start_time(ctx, pck);\n\t\t\t\tif (!ctx->cur_file_idx_plus_one) {\n\t\t\t\t\tctx->cur_file_idx_plus_one = p->value.uint + 1;\n\t\t\t\t\tif (!ctx->cur_file_suffix) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\t\tif (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t\tctx->notify_filename = GF_TRUE;\n\t\t\t\t} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {\n\t\t\t\t} else if (!tkw->suspended) {\n\t\t\t\t\ttkw->suspended = GF_TRUE;\n\t\t\t\t\tnb_suspended++;\n\t\t\t\t\tctx->next_file_idx =  p->value.uint + 1;\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);\n\t\t\t\t\tif (p && p->value.string)\n\t\t\t\t\t\tctx->next_file_suffix = p->value.string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//basic regulation in case we do on-the-fly interleaving\n\t\t//we need to regulate because sources do not produce packets at the same rate\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tu64 cts = gf_filter_pck_get_cts(pck);\n\t\t\tif (ctx->is_rewind)\n\t\t\t\tcts = tkw->ts_shift - cts;\n\t\t\telse\n\t\t\t\tcts -= tkw->ts_shift;\n\n\t\t\tif (!ctx->faststart_ts_regulate.num) {\n\t\t\t\tctx->faststart_ts_regulate = ctx->cdur;\n\t\t\t}\n\t\t\t//ahead of our interleaving window, don't write yet\n\t\t\telse if (gf_timestamp_greater(cts, tkw->src_timescale, ctx->faststart_ts_regulate.num, ctx->faststart_ts_regulate.den)) {\n\t\t\t\tnb_skip++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (tkw->cenc_state==CENC_NEED_SETUP)\n\t\t\tmp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);\n\n\t\tif (tkw->is_item) {\n\t\t\te = mp4_mux_process_item(ctx, tkw, pck);\n\t\t} else {\n\t\t\te = mp4_mux_process_sample(ctx, tkw, pck, GF_FALSE);\n\t\t}\n\n\t\tgf_filter_pid_drop_packet(tkw->ipid);\n\t\tif (tkw->aborted) {\n\t\t\tnb_eos++;\n\t\t}\n\t\tif (e) return e;\n\t}\n\tmp4_mux_format_report(ctx, 0, 0);\n\n\tif (nb_suspended && (nb_suspended+nb_eos==count)) {\n\t\treturn mp4mx_reload_output(ctx);\n\t}\n\n\tif (count == nb_eos) {\n\t\tif (ctx->file) {\n\t\t\tGF_Err e = mp4_mux_done(ctx, GF_TRUE);\n\t\t\tif (e) return e;\n\t\t}\n\t\treturn GF_EOS;\n\t}\n\t//done with this interleaving window, start next one\n\telse if (nb_skip + nb_eos >= count) {\n\t\tctx->faststart_ts_regulate.num += ctx->cdur.num;\n\t} else if (ctx->importer) {\n\t\tu64 prog_done=0, prog_total=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\t\t\tprog_done += tkw->prog_done;\n\t\t\tprog_total += tkw->prog_total;\n\t\t}\n\t\tgf_set_progress(\"Import\", prog_done, prog_total);\n\t}\n\n\treturn GF_OK;\n}\n\nstatic GF_Err mp4_mux_on_data_patch(void *cbk, u8 *data, u32 block_size, u64 file_offset, Bool is_insert)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\n\tGF_FilterPacket *pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (is_insert)\n\t\tgf_filter_pck_set_interlaced(pck, 1);\n\tgf_filter_pck_set_byte_offset(pck, file_offset);\n\tgf_filter_pck_send(pck);\n\treturn GF_OK;\n}\n\nstatic void mp4_mux_flush_seg_events(GF_MP4MuxCtx *ctx)\n{\n\tif (ctx->flush_ll_hls) {\n\t\tmp4_mux_flush_frag_hls(ctx);\n\t}\n\n\tif (!ctx->dash_mode || ctx->flush_seg) {\n\t\tmp4_mux_flush_seg(ctx, GF_FALSE, ctx->flush_idx_start_range, ctx->flush_idx_end_range, GF_FALSE);\n\t}\n\n\tctx->fragment_started = GF_FALSE;\n\n\tif (ctx->flush_seg) {\n\t\tctx->segment_started = GF_FALSE;\n\t\tctx->flush_seg = GF_FALSE;\n\t\tctx->dash_seg_num_plus_one = 0;\n\t\tctx->nb_segs++;\n\t\tctx->nb_frags_in_seg=0;\n\t}\n\tctx->seg_flush_state = 0;\n\tctx->flush_idx_start_range = 0;\n\tctx->flush_idx_end_range = 0;\n\tctx->flush_ll_hls = GF_FALSE;\n}\n\nstatic void mp4_mux_on_packet_destruct(GF_Filter *filter, GF_FilterPid *PID, GF_FilterPacket *pck)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\t//no need to lock filter here, only this callback modifies the state\n\tctx->seg_flush_state = 2;\n\tgf_filter_post_process_task(filter);\n}\n\nstatic void mp4_mux_on_last_block_start(void *cbk)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tif (ctx->force_seg_sync)\n\t\tctx->seg_flush_state = 1;\n}\n\nstatic GF_Err mp4_mux_on_data(void *cbk, u8 *data, u32 block_size, void *cbk_data, u32 cbk_magic)\n{\n\tGF_MP4MuxCtx *ctx = (GF_MP4MuxCtx *) cbk;\n\tu8 *output;\n\tu32 src_pck_dur=0;\n\n\tctx->total_bytes_out += block_size;\n\n\t//flush pending packet in frag mode\n\tmp4mux_send_output(ctx);\n\n\tif (ctx->final_sidx_flush) {\n\t\tGF_FilterPacket *pck;\n\t\tu32 free_size=0;\n\n\t\tif (ctx->vodcache==MP4MX_VODCACHE_INSERT) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tmemcpy(output, data, block_size);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tgf_filter_pck_set_interlaced(pck, 1);\n\t\t\tgf_filter_pck_send(pck);\n\t\t} else {\n\t\t\tGF_BitStream *bs;\n\t\t\tassert(!ctx->dst_pck);\n\n\t\t\tif (block_size > ctx->sidx_max_size) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Final SIDX chunk larger than preallocated block, will not flush SIDX (output file still readable). Try disabling nocache mode\\n\"));\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tfree_size = ctx->sidx_max_size - block_size;\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, ctx->sidx_max_size, &output);\n\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_FALSE);\n\t\t\tgf_filter_pck_set_byte_offset(pck, ctx->sidx_chunk_offset);\n\t\t\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\t\t\tbs = gf_bs_new(output, ctx->sidx_max_size, GF_BITSTREAM_WRITE);\n\t\t\tif (free_size) {\n\t\t\t\tgf_bs_write_u32(bs, free_size);\n\t\t\t\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FREE);\n\t\t\t\tgf_bs_skip_bytes(bs, free_size-8);\n\t\t\t}\n\t\t\tgf_bs_write_data(bs, data, block_size);\n\t\t\tgf_bs_del(bs);\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t\tmp4_mux_flush_seg(ctx, GF_TRUE, ctx->sidx_chunk_offset+free_size, ctx->sidx_chunk_offset+free_size + block_size - 1, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (ctx->store_output) {\n\t\tu32 nb_write = (u32) gf_fwrite(data, block_size, ctx->tmp_store);\n\t\tif (nb_write != block_size) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Error writing to temp cache: %d bytes write instead of %d\\n\", nb_write, block_size));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tGF_FilterPacket *srcp = (GF_FilterPacket *)cbk_data;\n\tif (srcp && gf_list_find(ctx->ref_pcks, srcp)<0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Data callback on non-existing packet reference !\\n\"));\n\t\treturn GF_IO_ERR;\n\t}\n\n\tif (srcp) {\n\t\tif (ctx->seg_flush_state) {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref_destructor(ctx->opid, cbk_magic, block_size, srcp, mp4_mux_on_packet_destruct);\n\t\t} else {\n\t\t\tctx->dst_pck = gf_filter_pck_new_ref(ctx->opid, cbk_magic, block_size, srcp);\n\t\t}\n\t\tgf_list_del_item(ctx->ref_pcks, srcp);\n\t\tsrc_pck_dur = (u32) gf_timestamp_rescale(gf_filter_pck_get_duration(srcp), gf_filter_pck_get_timescale(srcp), 1000);\n\t\tgf_filter_pck_unref(srcp);\n\t}\n\t//allocate new one\n\telse if (ctx->seg_flush_state) {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc_destructor(ctx->opid, block_size, &output, mp4_mux_on_packet_destruct);\n\t} else {\n\t\tctx->dst_pck = gf_filter_pck_new_alloc(ctx->opid, block_size, &output);\n\t}\n\tif (!ctx->dst_pck) return GF_OUT_OF_MEM;\n\n\tif (!cbk_data)\n\t\tmemcpy(output, data, block_size);\n\tgf_filter_pck_set_framing(ctx->dst_pck, !ctx->first_pck_sent, GF_FALSE);\n\n\t//set packet prop as string since we may discard the seg_name  packet before this packet is processed\n\tif (!ctx->first_pck_sent && ctx->seg_name) {\n\t\tctx->current_offset = 0;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENAME, &PROP_STRING(ctx->seg_name) );\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_FILENUM, &PROP_UINT(ctx->dash_seg_num_plus_one-1) );\n\t\tif (ctx->dash_seg_start.den)\n\t\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_MPD_SEGSTART, &PROP_FRAC64(ctx->dash_seg_start) );\n\t}\n\n\tif (ctx->min_cts_plus_one) {\n\t\tu64 orig = ctx->min_cts_plus_one-1;\n\t\tgf_filter_pck_set_cts(ctx->dst_pck, orig);\n\t\t//if we have a source packet duration, use it\n\t\tif (src_pck_dur)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, src_pck_dur);\n\t\t//it may happen that we don't know precisely the min_cts_next_frag, this is a rough compute based on desire frag dur\n\t\t//if duration is wrong, signal to send asap (dur = 1)\n\t\telse if (ctx->min_cts_next_frag > orig)\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, (u32) (ctx->min_cts_next_frag - orig) );\n\t\telse\n\t\t\tgf_filter_pck_set_duration(ctx->dst_pck, 1);\n\t}\n\n\tif ((ctx->llhls_mode>1) && ctx->fragment_started && !ctx->frag_size && ctx->dst_pck) {\n\t\tctx->frag_num++;\n\t\tgf_filter_pck_set_property(ctx->dst_pck, GF_PROP_PCK_HLS_FRAG_NUM, &PROP_UINT(ctx->frag_num));\n\t}\n\tctx->frag_size += block_size;\n\n\tctx->first_pck_sent = GF_TRUE;\n\tctx->current_size += block_size;\n\t//non-frag mode, send right away\n\tif ((ctx->store<MP4MX_MODE_FRAG) || ctx->seg_flush_state) {\n\t\tmp4mux_send_output(ctx);\n\t}\n\treturn GF_OK;\n}\n\nvoid mp4_mux_progress_cbk(void *udta, u64 done, u64 total)\n{\n\tGF_Filter *filter = (GF_Filter *)udta;\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tctx->update_report = GF_TRUE;\n\tmp4_mux_format_report(ctx, done, total);\n}\n\nstatic GF_Err mp4_mux_initialize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tgf_filter_set_max_extra_input_pids(filter, -1);\n\tctx->filter = filter;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented mode, disabled in build\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n#endif\n\tif (ctx->file) {\n\t\tif (gf_isom_get_mode(ctx->file) < GF_ISOM_OPEN_WRITE) return GF_BAD_PARAM;\n\t\tif (ctx->store>=MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use fragmented output on already opened ISOBMF file\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\tctx->owns_mov = GF_FALSE;\n\t\tgf_filter_act_as_sink(filter);\n\t} else {\n\t\tu32 open_mode = GF_ISOM_OPEN_WRITE;\n\t\tctx->owns_mov = GF_TRUE;\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\topen_mode = GF_ISOM_WRITE_EDIT;\n\t\t\tbreak;\n\t\t}\n\t\tctx->file = gf_isom_open(\"_gpac_isobmff_redirect\", open_mode, NULL);\n\t\tif (!ctx->file) return GF_OUT_OF_MEM;\n\n\t\tgf_isom_set_write_callback(ctx->file, mp4_mux_on_data, mp4_mux_on_data_patch, mp4_mux_on_last_block_start, ctx, ctx->block_size);\n\n\t\tgf_isom_set_progress_callback(ctx->file, mp4_mux_progress_cbk, filter);\n\n\t\tif (ctx->dref && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Cannot use data reference in movie fragments, not supported. Ignoring it\\n\"));\n\t\t\tctx->dref = GF_FALSE;\n\t\t}\n\n\t\tif (ctx->store==MP4MX_MODE_FASTSTART) {\n\t\t\tgf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t}\n\t}\n\n\tif (!ctx->moovts)\n\t\tctx->moovts=600;\n\n\tif ((ctx->store==MP4MX_MODE_FASTSTART) && (!ctx->cdur.num || !ctx->cdur.den)) {\n\t\tctx->cdur.num = 1;\n\t\tctx->cdur.den = 1;\n\t}\n\tif (!ctx->cdur.den) {\n\t\tctx->cdur.num = 0;\n\t\tctx->cdur.den = 1000;\n\t}\n\t//we need at least ms precision for sfrag mode\n\tif (ctx->cdur.den < 1000) {\n\t\tctx->cdur.num = (s32) ( ((s64)ctx->cdur.num) * 1000 / ctx->cdur.den);\n\t\tctx->cdur.den = 1000;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (ctx->mfra && (ctx->store>=MP4MX_MODE_FRAG)) {\n\t\tGF_Err e = gf_isom_enable_mfra(ctx->file);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!ctx->tracks)\n\t\tctx->tracks = gf_list_new();\n\n\tif (!ctx->ref_pcks)\n\t\tctx->ref_pcks = gf_list_new();\n\n#ifdef GF_ENABLE_CTRN\n\tif (ctx->ctrni)\n\t\tctx->ctrn = GF_TRUE;\n#endif\n\n\tif (ctx->m4cc) {\n\t\tif (strlen(ctx->m4cc)==4)\n\t\t\tctx->eos_marker = GF_4CC(ctx->m4cc[0], ctx->m4cc[1], ctx->m4cc[2], ctx->m4cc[3]);\n\t\telse {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Invalid segment marker 4cc %s, ignoring\\n\", ctx->m4cc));\n\t\t}\n\t}\n\tif (ctx->compress) {\n\t\tu32 flags = 0;\n\t\tif (ctx->fcomp) flags |= GF_ISOM_COMP_FORCE_ALL;\n\t\tif (ctx->otyp) flags |= GF_ISOM_COMP_WRAP_FTYPE;\n\t\tgf_isom_enable_compression(ctx->file, ctx->compress, flags);\n\t}\n\n\tif ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign)\n\t\tctx->insert_tfdt = GF_TRUE;\n\n\tif (ctx->cmaf) {\n\t\t//cf table 3, 4, 5 of CMAF\n\t\tctx->mvex = GF_TRUE;\n\t\tctx->truns_first = GF_TRUE;\n\t\t//single trun, single traf (table 5 of CMAF)\n\t\tctx->strun = GF_TRUE;\n\t\tctx->straf = GF_TRUE;\n\t\t//7.5.16 Every TrackFragmentBox shall contain a TrackFragmentBaseMediaDecodeTimeBox\n\t\tctx->tfdt_traf = GF_TRUE;\n\t\t//7.3.3 : If SegmentIndexBoxes exist, each subsegment referenced in the SegmentIndexBox shall be a single CMAF fragment\n\t\tctx->chain_sidx = GF_FALSE;\n\t\tif (ctx->subs_sidx>0)\n\t\t\tctx->subs_sidx = 0;\n\n\t\tif (ctx->cmaf==MP4MX_CMAF_CMF2) {\n\t\t\t/*7.7 cmf2\n- default_sample_flags, sample_flags and first_sample_flags shall be set in the TrackFragmentHeaderBox and/or TrackRunBox to provide sample dependency information within each CMAF chunk and CMAF fragment.\n- Default values or per sample values of sample duration and sample size shall be stored in each CMAF chunk\u2019s TrackRunBox and/or TrackFragmentHeaderBox\n\t\t\t*/\n\t\t\tctx->nofragdef = GF_TRUE;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nstatic void mp4_mux_update_edit_list_for_bframes(GF_MP4MuxCtx *ctx, TrackWriter *tkw, u32 ctts_mode)\n{\n\tu64 max_cts, min_cts;\n\ts64 moffset;\n\n\tif (ctts_mode > MP4MX_CT_EDIT) return;\n\n\t//if we have a complex edit list (due to track template), don't override\n\tif (gf_isom_get_edit_list_type(ctx->file, tkw->track_num, &moffset)) return;\n\n\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\n\tmax_cts = tkw->max_cts - tkw->min_neg_ctts;\n\tmin_cts = tkw->min_cts - tkw->min_neg_ctts;\n\n\tif (min_cts || tkw->empty_init_dur) {\n\t\tmax_cts -= min_cts;\n\t\tu32 count = gf_isom_get_sample_count(ctx->file, tkw->track_num);\n\t\tmax_cts += gf_isom_get_sample_duration(ctx->file, tkw->track_num, count);\n\n\t\tmax_cts = gf_timestamp_rescale(max_cts, tkw->tk_timescale, ctx->moovts);\n\n\t\tif (tkw->empty_init_dur) {\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t}\n\t\t//old arch compat: if we had a simple edit list in source try to keep the original segduration indicated\n\t\t//we tolerate a diff of 100ms\n\t\telse if (gf_sys_old_arch_compat() && tkw->imported_edit_sdur && (tkw->imported_edit_offset==min_cts)) {\n\t\t\ts32 diff;\n\t\t\tu64 old_dur_ms = gf_timestamp_rescale(tkw->imported_edit_sdur, tkw->src_timescale, 1000);\n\t\t\tu64 new_dur_ms = gf_timestamp_rescale(max_cts, tkw->tk_timescale, 1000);\n\t\t\tdiff = (s32) new_dur_ms - (s32) old_dur_ms;\n\t\t\tif (ABS(diff)<100)\n\t\t\t\tmax_cts = tkw->imported_edit_sdur;\n\t\t}\n\n\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, max_cts, min_cts, GF_ISOM_EDIT_NORMAL);\n\t}\n}\n\n//todo: move from media_import.c to here once done\nvoid gf_media_update_bitrate(GF_ISOFile *file, u32 track);\n\n\nstatic void mp4_mux_set_hevc_groups(GF_MP4MuxCtx *ctx, TrackWriter *tkw)\n{\n\tu32 avc_base_track, hevc_base_track, ref_track_id;\n\tavc_base_track = hevc_base_track = 0;\n\tu32 i;\n\tu32 min_lid = 0;\n\tGF_PropertyEntry *pe=NULL;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:oinf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t}\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:linf\", &pe);\n\tif (p) {\n\t\tu32 gi=0;\n\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF);\n\t\tgf_isom_add_sample_group_info(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_LINF, p->value.data.ptr, p->value.data.size, GF_TRUE, &gi);\n\t\tgf_isom_set_track_group(ctx->file, tkw->track_num, 1000+gf_isom_get_track_id(ctx->file, tkw->track_num), GF_ISOM_BOX_TYPE_CSTG, GF_TRUE);\n\t}\n\n\tp = gf_filter_pid_get_info_str(tkw->ipid, \"hevc:min_lid\", &pe);\n\tif (p) min_lid = p->value.uint;\n\n\tgf_filter_release_property(pe);\n\n\tif (!min_lid && (tkw->codecid!=GF_CODECID_LHVC)) {\n\t\treturn;\n\t}\n\t//set linf\n\tfor (i=0; i < gf_isom_get_track_count(ctx->file); i++) {\n\t\tu32 subtype = gf_isom_get_media_subtype(ctx->file, i+1, 1);\n\t\tswitch (subtype) {\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\tif (!avc_base_track) {\n\t\t\t\tavc_base_track = i+1;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one AVC bitstream found, use track %d as base layer\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (!hevc_base_track) {\n\t\t\t\thevc_base_track = i+1;\n\t\t\t\tif (avc_base_track) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: Found both AVC and HEVC tracks, using HEVC track %d as base layer\\n\", hevc_base_track));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Warning: More than one HEVC bitstream found, use track %d as base layer\\n\", avc_base_track));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!hevc_base_track && !avc_base_track) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Using LHVC external base layer, but no base layer not found - NOT SETTING SBAS TRACK REFERENCE!\\n\"));\n\t} else {\n\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track ? hevc_base_track : avc_base_track);\n\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_BASE, ref_track_id);\n\n\t\tif (hevc_base_track) {\n\t\t\tref_track_id = gf_isom_get_track_id(ctx->file, hevc_base_track);\n\t\t\tgf_isom_set_track_reference(ctx->file, tkw->track_num, GF_ISOM_REF_OREF, ref_track_id);\n\t\t\tgf_isom_remove_sample_group(ctx->file, tkw->track_num, GF_ISOM_SAMPLE_GROUP_OINF);\n\t\t}\n\t}\n}\n\nstatic GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final)\n{\n\tGF_Err e = GF_OK;\n\tu32 i, count;\n\tGF_PropertyEntry *pe=NULL;\n\n\tcount = gf_list_count(ctx->tracks);\n\tfor (i=0; i<count; i++) {\n\t\tu32 ctts_mode = ctx->ctmode;\n\t\tconst GF_PropertyValue *p;\n\t\tBool has_bframes = GF_FALSE;\n\t\tTrackWriter *tkw = gf_list_get(ctx->tracks, i);\n\n\t\tp = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS);\n\t\tif (p && p->value.boolean) ctts_mode = MP4MX_CT_NEGCTTS;\n\n\t\tif (tkw->min_neg_ctts<0) {\n\t\t\t//use ctts v1 negative offsets\n\t\t\tif (ctts_mode==MP4MX_CT_NEGCTTS) {\n\t\t\t\tgf_isom_set_ctts_v1(ctx->file, tkw->track_num, (u32) -tkw->min_neg_ctts);\n\t\t\t}\n\t\t\t//ctts v0\n\t\t\telse {\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_TRUE);\n\t\t\t\tgf_isom_shift_cts_offset(ctx->file, tkw->track_num, (s32) tkw->min_neg_ctts);\n\t\t\t\tgf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_FALSE);\n\t\t\t\tgf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE);\n\n\t\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\t\t\t}\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->has_ctts && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tmp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode);\n\n\t\t\thas_bframes = GF_TRUE;\n\t\t} else if (tkw->ts_delay || tkw->empty_init_dur) {\n\t\t\tgf_isom_update_edit_list_duration(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tif (tkw->min_ts_seek_plus_one) {\n\t\t\tu64 min_ts = tkw->min_ts_seek_plus_one - 1;\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu32 delay = 0;\n\t\t\tif (tkw->clamp_ts_plus_one) {\n\t\t\t\tmdur = tkw->max_cts - tkw->min_cts;\n\t\t\t\tmdur += tkw->max_cts_samp_dur;\n\t\t\t}\n\t\t\tif (mdur > min_ts)\n\t\t\t\tmdur -= min_ts;\n\t\t\telse\n\t\t\t\tmdur = 0;\n\n\t\t\tif ((ctts_mode != MP4MX_CT_NEGCTTS) && (tkw->ts_delay<0) && (tkw->stream_type==GF_STREAM_VISUAL)) {\n\t\t\t\tdelay = (u32) -tkw->ts_delay;\n\t\t\t}\n\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tmin_ts = gf_timestamp_rescale(min_ts, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t\tdelay = (u32) gf_timestamp_rescale(delay, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tmdur += delay;\n\n\t\t\tif (ctx->moovts != tkw->tk_timescale) {\n\t\t\t\tmdur = gf_timestamp_rescale(mdur, tkw->tk_timescale, ctx->moovts);\n\t\t\t}\n\t\t\tgf_isom_remove_edits(ctx->file, tkw->track_num);\n\t\t\tif (tkw->empty_init_dur)\n\t\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY);\n\t\t\tgf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, mdur, min_ts, GF_ISOM_EDIT_NORMAL);\n\t\t}\n\n\t\tif (tkw->force_ctts) {\n\t\t\tGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track);\n\t\t\tgf_isom_force_ctts(ctx->file, tkw->track_num);\n\t\t}\n\n\t\tgf_isom_purge_track_reference(ctx->file, tkw->track_num);\n\n\t\tif (ctx->importer && ctx->dur.num && ctx->dur.den) {\n\t\t\tu64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num);\n\t\t\tu64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num);\n\t\t\tif (pdur==mdur) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale ));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Imported %d frames - media duration %g - track duration %g\\n\", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale, ((Double)pdur)/ctx->moovts ));\n\t\t\t}\n\t\t}\n\n\t\t/*this is plain ugly but since some encoders (divx) don't use the video PL correctly\n\t\t we force the system video_pl to ASP@L5 since we have I, P, B in base layer*/\n\t\tif (tkw->codecid == GF_CODECID_MPEG4_PART2) {\n\t\t\tBool force_rewrite = GF_FALSE;\n\t\t\tu32 PL = tkw->media_profile_level;\n\t\t\tif (!PL) PL = 0x01;\n\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"Indicated Profile: %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t}\n\n\t\t\tif (has_bframes && (tkw->media_profile_level <= 3)) {\n\t\t\t\tPL = 0xF5;\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Indicated profile doesn't include B-VOPs - forcing %s\\n\", gf_m4v_get_profile_name((u8) PL) ));\n\t\t\t\tforce_rewrite = GF_TRUE;\n\t\t\t}\n\t\t\tif (PL != tkw->media_profile_level) {\n\t\t\t\tif (force_rewrite) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_ESD *esd = gf_isom_get_esd(ctx->file, tkw->track_num, tkw->stsd_idx);\n\t\t\t\t\tassert(esd);\n\t\t\t\t\tgf_m4v_rewrite_pl(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, (u8) PL);\n\t\t\t\t\tgf_isom_change_mpeg4_description(ctx->file, tkw->track_num, tkw->stsd_idx, esd);\n\t\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n#endif\n\n\t\t\t\t}\n\t\t\t\tif (!ctx->make_qt)\n\t\t\t\t\tgf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, PL);\n\t\t\t}\n\t\t}\n\n\n\t\tif (tkw->has_append)\n\t\t\tgf_isom_refresh_size_info(ctx->file, tkw->track_num);\n\n\t\tif ((tkw->nb_samples == 1) && (ctx->dur.num>0) && ctx->dur.den) {\n\t\t\tu32 dur = (u32) gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, tkw->tk_timescale);\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, dur);\n\t\t}\n\n\t\tif (tkw->has_open_gop) {\n\t\t\tif (ctx->importer) {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"OpenGOP detected - adjusting file brand\\n\"));\n\t\t\t}\n\t\t\tgf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE);\n\t\t}\n\n\t\tmp4_mux_set_hevc_groups(ctx, tkw);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:rem_last\", &pe);\n\t\tif (p && p->value.boolean)\n\t\t\tgf_isom_remove_sample(ctx->file, tkw->track_num, tkw->nb_samples);\n\n\t\tp = gf_filter_pid_get_info_str(tkw->ipid, \"ttxt:last_dur\", &pe);\n\t\tif (p) {\n\t\t\tu64 val = p->value.uint;\n\t\t\tif (tkw->src_timescale != tkw->tk_timescale) {\n\t\t\t\tval = gf_timestamp_rescale(val, tkw->src_timescale, tkw->tk_timescale);\n\t\t\t}\n\t\t\tgf_isom_set_last_sample_duration(ctx->file, tkw->track_num, (u32) val);\n\t\t}\n\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_FORCED_SUB, &pe);\n\t\tif (p) {\n\t\t\tgf_isom_set_forced_text(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint);\n\t\t}\n\n\t\tif (tkw->is_nalu && ctx->pack_nal && (gf_isom_get_mode(ctx->file)!=GF_ISOM_OPEN_WRITE)) {\n\t\t\tu32 msize = 0;\n\t\t\tBool do_rewrite = GF_FALSE;\n\t\t\tu32 j, stsd_count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);\n\t\t\tp = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_MAX_NALU_SIZE, &pe);\n\t\t\tmsize = gf_get_bit_size(p->value.uint);\n\t\t\tif (msize<8) msize = 8;\n\t\t\telse if (msize<16) msize = 16;\n\t\t\telse msize = 32;\n\n\t\t\tif (msize<=0xFFFF) {\n\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\tu32 k = 8 * gf_isom_get_nalu_length_field(ctx->file, tkw->track_num, j+1);\n\t\t\t\t\tif (k > msize) {\n\t\t\t\t\t\tdo_rewrite = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (do_rewrite) {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[MP4Mux] Adjusting NALU SizeLength to %d bits\\n\", msize ));\n\t\t\t\t\tgf_media_nal_rewrite_samples(ctx->file, tkw->track_num, msize);\n\t\t\t\t\tmsize /= 8;\n\t\t\t\t\tfor (j=0; j<stsd_count; j++) {\n\t\t\t\t\t\tgf_isom_set_nalu_length_field(ctx->file, tkw->track_num, j+1, msize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//don't update bitrate info for single sample tracks, unless MPEG-4 Systems - compatibility with old arch\n\t\tif (ctx->btrt && !tkw->skip_bitrate_update && ((tkw->nb_samples>1) || ctx->m4sys) )\n\t\t\tgf_media_update_bitrate(ctx->file, tkw->track_num);\n\n\t\tif (!tkw->box_patched) {\n\t\t\tp = gf_filter_pid_get_property_str(tkw->ipid, \"boxpatch\");\n\t\t\tif (p && p->value.string) {\n\t\t\t\te = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_FALSE);\n\t\t\t\tif (e) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s to track %d: %s\\n\",\n\t\t\t\t\t\tp->value.string, tkw->track_id, gf_error_to_string(e) ));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttkw->box_patched = GF_TRUE;\n\t\t}\n\t}\n\n\tgf_filter_release_property(pe);\n\n\tif (ctx->boxpatch && !ctx->box_patched) {\n\t\te = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Unable to apply box patch %s: %s\\n\", ctx->boxpatch, gf_error_to_string(e) ));\n\t\t}\n\t\tctx->box_patched = GF_TRUE;\n\t}\n\n\n\tif (ctx->owns_mov) {\n\t\tif (ctx->moovpad)\n\t\t\tgf_isom_set_inplace_padding(ctx->file, ctx->moovpad);\n\n\t\tswitch (ctx->store) {\n\t\tcase MP4MX_MODE_INTER:\n\t\t\tif (ctx->cdur.num==0) {\n\t\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_STREAMABLE);\n\t\t\t} else {\n\t\t\t\tif (ctx->cdur.num < 0) ctx->cdur.num = 1000;\n\t\t\t\te = gf_isom_make_interleave_ex(ctx->file, &ctx->cdur);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FLAT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FLAT);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_FASTSTART:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);\n\t\t\tbreak;\n\t\tcase MP4MX_MODE_TIGHT:\n\t\t\te = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_TIGHT);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to set storage mode: %s\\n\", gf_error_to_string(e) ));\n\t\t\tgf_isom_delete(ctx->file);\n\t\t} else {\n\t\t\te = gf_isom_close(ctx->file);\n\t\t\tif (e) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[MP4Mux] Failed to write file: %s\\n\", gf_error_to_string(e) ));\n\t\t\t}\n\t\t}\n\t\tctx->file = NULL;\n\t\tif (is_final)\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t} else {\n\t\tctx->file = NULL;\n\t}\n\treturn e;\n}\n\nstatic void mp4_mux_finalize(GF_Filter *filter)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (ctx->owns_mov && (ctx->file || (ctx->store>=MP4MX_MODE_FRAG))) {\n\t\tif (ctx->store < MP4MX_MODE_FRAG) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[MP4Mux] Session aborted before writing to file, use fragmented storage mode to record session\\n\"));\n\t\t}\n\t\tgf_isom_delete(ctx->file);\n\t}\n\n\twhile (gf_list_count(ctx->tracks)) {\n\t\tTrackWriter *tkw = gf_list_pop_back(ctx->tracks);\n\t\tmp4_mux_track_writer_del(tkw);\n\t}\n\tgf_list_del(ctx->tracks);\n\t//in case we aborted, release refs\n\twhile (gf_list_count(ctx->ref_pcks)) {\n\t\tGF_FilterPacket *pckr = gf_list_pop_back(ctx->ref_pcks);\n\t\tgf_filter_pck_unref(pckr);\n\t}\n\tgf_list_del(ctx->ref_pcks);\n\tif (ctx->bs_r) gf_bs_del(ctx->bs_r);\n\tif (ctx->seg_name) gf_free(ctx->seg_name);\n\tif (ctx->tmp_store) gf_fclose(ctx->tmp_store);\n\tif (ctx->seg_sizes) gf_free(ctx->seg_sizes);\n\n\tif (ctx->cur_file_suffix) gf_free(ctx->cur_file_suffix);\n\n}\n\nstatic const GF_FilterCapability MP4MuxCaps[] =\n{\n\t//for now don't accept files as input, although we could store them as items, to refine\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\t//we want framed media only\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\t//and any codecid\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_FILE_EXT, ISOM_FILE_EXT),\n\tCAP_STRING(GF_CAPS_OUTPUT_STATIC,  GF_PROP_PID_MIME, ISOM_FILE_MIME),\n\t{0},\n\t//for scene / OD / text, we don't want raw codecid (filters modifying a scene graph we don't expose)\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_SCENE),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_OD),\n\tCAP_UINT(GF_CAPS_INPUT,GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_MP4MuxCtx, _n)\nstatic const GF_FilterArgs MP4MuxArgs[] =\n{\n\t{ OFFS(m4sys), \"force MPEG-4 Systems signaling of tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dref), \"only reference data from source file - not compatible with all media sources\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctmode), \"set composition offset mode for video tracks\\n\"\n\t\"- edit: uses edit lists to shift first frame to presentation time 0\\n\"\n\t\"- noedit: ignore edit lists and does not shift timeline\\n\"\n\t\"- negctts: uses ctts v1 with possibly negative offsets and no edit lists\", GF_PROP_UINT, \"edit\", \"edit|noedit|negctts\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dur), \"only import the specified duration. If negative, specify the number of coded frames to import\", GF_PROP_FRACTION, \"0\", NULL, 0},\n\t{ OFFS(pack3gp), \"pack a given number of 3GPP audio frames in one sample\", GF_PROP_UINT, \"1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(importer), \"compatibility with old importer, displays import progress\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pack_nal), \"repack NALU size length to minimum possible size for NALU-based video (AVC/HEVC/...)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(xps_inband), \"use inband (in sample data) parameter set for NALU-based video (AVC/HEVC/...)\\n\"\n\t\"- no: parameter sets are not inband, several sample descriptions might be created\\n\"\n\t\"- pps: picture parameter sets are inband, all other parameter sets are in sample description\\n\"\n\t\"- all: parameter sets are inband, no parameter sets in sample description\\n\"\n\t\"- both: parameter sets are inband, signaled as inband, and also first set is kept in sample description\\n\"\n\t\"- mix: creates non-standard files using single sample entry with first PSs found, and moves other PS inband\\n\"\n\t\"- auto: keep source config, or defaults to no if source is not ISOBMFF\", GF_PROP_UINT, \"no\", \"no|pps|all|both|mix|auto\", 0},\n\t{ OFFS(store), \"file storage mode\\n\"\n\t\"- inter: perform precise interleave of the file using [-cdur]() (requires temporary storage of all media)\\n\"\n\t\"- flat: write samples as they arrive and `moov` at end (fastest mode)\\n\"\n\t\"- fstart: write samples as they arrive and `moov` before `mdat`\\n\"\n\t\"- tight: uses per-sample interleaving of all tracks (requires temporary storage of all media)\\n\"\n\t\"- frag: fragments the file using cdur duration\\n\"\n\t\"- sfrag: fragments the file using cdur duration but adjusting to start with SAP1/3\", GF_PROP_UINT, \"inter\", \"inter|flat|fstart|tight|frag|sfrag\", 0},\n\t{ OFFS(cdur), \"chunk duration for flat and interleaving modes or fragment duration for fragmentation modes\\n\"\n\t\"- 0: no specific interleaving but moov first\\n\"\n\t\"- negative: defaults to 1.0 unless overridden by storage profile\", GF_PROP_FRACTION, \"-1/1\", NULL, 0},\n\t{ OFFS(moovts), \"timescale to use for movie. A negative value picks the media timescale of the first track added\", GF_PROP_SINT, \"600\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moof_first), \"generate fragments starting with moof then mdat\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(abs_offset), \"use absolute file offset in fragments rather than offsets from moof\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fsap), \"split truns in video fragments at SAPs to reduce file size\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(file), \"pointer to a write/edit ISOBMF file used internally by importers and exporters\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(subs_sidx), \"number of subsegments per sidx. negative value disables sidx, -2 removes sidx if present in source PID\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(m4cc), \"4 character code of empty box to append at the end of a segment (DASH mode) or of a fragment (non-DASH mode)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chain_sidx), \"use daisy-chaining of SIDX\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(msn), \"sequence number of first moof to N\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(msninc), \"sequence number increase between `moof` boxes\", GF_PROP_UINT, \"1\", NULL, 0},\n\t{ OFFS(tfdt), \"set initial decode time (`tfdt`) of first traf\", GF_PROP_FRACTION64, \"0\", NULL, 0},\n\t{ OFFS(tfdt_traf), \"force `tfdt` box in each traf\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(nofragdef), \"disable default flags in fragments\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(straf), \"use a single traf per moof (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(strun), \"use a single trun per traf (smooth streaming and co)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(psshs), \"set `pssh` boxes store mode\\n\"\n\t\"- moof: in first moof of each segments\\n\"\n\t\"- moov: in movie box\\n\"\n\t\"- both: in movie box and in first moof of each segment\\n\"\n\t\"- none: pssh is discarded\", GF_PROP_UINT, \"moov\", \"moov|moof|both|none\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sgpd_traf), \"store sample group descriptions in traf (duplicated for each traf). If not used, sample group descriptions are stored in the movie box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(vodcache), \"enable temp storage for VoD dash modes\\n\"\n\t\t\"- on: use temp storage of complete file for sidx and ssix injection\\n\"\n\t\t\"- insert: insert sidx and ssix by shifting bytes in output file\\n\"\n\t\t\"- replace: precompute pace requirements for sidx and ssix and rewrite file range at end\", GF_PROP_UINT, \"replace\", \"on|insert|replace\", 0},\n\t{ OFFS(noinit), \"do not produce initial `moov, used for DASH bitstream switching mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tktpl), \"use track box from input if any as a template to create new track\\n\"\n\t\"- no: disables template\\n\"\n\t\"- yes: clones the track (except edits and decoder config)\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mudta), \"use `udta` and other `moov` extension boxes from input if any\\n\"\n\t\"- no: disables import\\n\"\n\t\"- yes: clones all extension boxes\\n\"\n\t\"- udta: only loads udta\", GF_PROP_UINT, \"yes\", \"no|yes|udta\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mvex), \"set `mvex` boxes after `trak` boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sdtp_traf), \"use `sdtp` box in `traf` box rather than using flags in trun sample entries\\n\"\n\t\t\"- no: do not use `sdtp`\\n\"\n\t\t\"- sdtp: use `sdtp` box to indicate sample dependencies and do not write info in `trun` sample flags\\n\"\n\t\t\"- both: use `sdtp` box to indicate sample dependencies and also write info in `trun` sample flags\", GF_PROP_UINT, \"no\", \"no|sdtp|both\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(trackid), \"track ID of created track for single track. Default 0 uses next available trackID\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fragdur), \"fragment based on fragment duration rather than CTS. Mostly used for `MP4Box -frag` option\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(btrt), \"set `btrt` box in sample description\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(styp), \"set segment `styp` major brand (and optionally version) to the given 4CC[.version]\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(mediats), \"set media timescale. A value of 0 means inherit from PID, a value of -1 means derive from samplerate or frame rate\", GF_PROP_SINT, \"0\", NULL, 0},\n\t{ OFFS(ase), \"set audio sample entry mode for more than stereo layouts\\n\"\n\t\t\t\"- v0: use v0 signaling but channel count from stream, recommended for backward compatibility\\n\"\n\t\t\t\"- v0s: use v0 signaling and force channel count to 2 (stereo) if more than 2 channels\\n\"\n\t\t\t\"- v1: use v1 signaling, ISOBMFF style (will mux raw PCM as ISOBMFF style)\\n\"\n\t\t\t\"- v1qt: use v1 signaling, QTFF style\\n\"\n\t\t\t\"- v2qt: use v2 signaling, QTFF style (lpcm entry type)\"\n\t\t, GF_PROP_UINT, \"v0\", \"|v0|v0s|v1|v1qt|v2qt\", 0},\n\t{ OFFS(ssix), \"create `ssix` box when `sidx` box is present, level 1 mapping I-frames byte ranges, level 0xFF mapping the rest\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ccst), \"insert coding constraint box for video tracks\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(maxchunk), \"set max chunk size in bytes for runs (only used in non-fragmented mode). 0 means no constraints\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noroll), \"disable roll sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(norap), \"disable rap sample grouping\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(saio32), \"use 32 bit offset for side data location instead of 64 bit offset\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(tfdt64), \"use 64 bit tfdt and sidx even for 32 bits timestamps\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#ifdef GF_ENABLE_CTRN\n\t{ OFFS(ctrn), \"use compact track run (experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ctrni), \"use inheritance in compact track run for HEVC tile tracks (highly experimental)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n#endif\n\t{ OFFS(sseg), \"set single segment mode for dash\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_HIDE},\n\n\t{ OFFS(compress), \"set top-level box compression mode\\n\"\n\t\t\t\t\t\t\"- no: disable box compression\\n\"\n\t\t\t\t\t\t\"- moov: compress only moov box (uses cmov for QT)\\n\"\n\t\t\t\t\t\t\"- moof: compress only moof boxes\\n\"\n\t\t\t\t\t\t\"- sidx: compress moof and sidx boxes\\n\"\n\t\t\t\t\t\t\"- ssix: compress moof, sidx and ssix boxes\\n\"\n\t\t\t\t\t\t\"- all: compress moov, moof, sidx and ssix boxes\", GF_PROP_UINT, \"no\", \"no|moov|moof|sidx|ssix|all\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(fcomp), \"force using compress box even when compressed size is larger than uncompressed\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(otyp), \"inject original file type when using compressed boxes\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(trun_inter), \"interleave samples in `trun` based on the temporal level, the lowest level are stored first (this will create as many `trun` boxes as required)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(truns_first), \"store track runs before sample group description and sample encryption information\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(block_size), \"target output block size, 0 for default internal value (10k)\", GF_PROP_UINT, \"10000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(boxpatch), \"apply box patch before writing\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(deps), \"add samples dependencies information\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mfra), \"enable movie fragment random access when fragmenting (ignored when dashing)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(forcesync), \"force all SAP types to be considered sync samples (might produce non-compliant files)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(refrag), \"use track fragment defaults from initial file if any rather than computing them from PID properties (used when processing standalone segments/fragments)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(itags), \"tag injection mode\\n\"\n\t\t\t\"- none: do not inject tags\\n\"\n\t\t\t\"- strict: only inject recognized itunes tags\\n\"\n\t\t\t\"- all: inject all possible tags\"\n\t\t\t, GF_PROP_UINT, \"strict\", \"none|strict|all\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(keep_utc), \"force all new files and tracks to keep the source UTC creation and modification times\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pps_inband), \"when [-xps_inband]() is set, inject PPS in each non SAP 1/2/3 sample\", GF_PROP_BOOL, \"no\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(moovpad), \"insert `free` box of given size after `moov` for future in-place editing\", GF_PROP_UINT, \"0\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cmaf), \"use CMAF guidelines (turns on `mvex`, `truns_first`, `strun`, `straf`, `tfdt_traf`, `chain_sidx` and restricts `subs_sidx` to -1 or 0)\\n\"\n\t\t\"- no: CMAF not enforced\\n\"\n\t\t\"- cmfc: use CMAF `cmfc` guidelines\\n\"\n\t\t\"- cmf2: use CMAF `cmf2` guidelines (turns on `nofragdef`)\"\n\t\t, GF_PROP_UINT, \"no\", \"no|cmfc|cmf2\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(start), \"set playback start offset for MP4Box import only. A negative value means percent of media duration with -1 equal to duration\", GF_PROP_DOUBLE, \"0.0\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(pad_sparse), \"inject sample with no data (size 0) to keep durations in unknown sparse text and metadata tracks\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(force_dv), \"force DV sample entry types even when AVC/HEVC compatibility is signaled\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(dvsingle), \"ignore DolbyVision profile 8 in xps inband mode if profile 5 is already set\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tsalign), \"enable timeline realignment to 0 for first sample - if false, this will keep original timing with empty edit (possibly long) at begin)\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chapm), \"chapter storage mode\\n\"\n\t\"- off: disable chapters\\n\"\n\t\"- tk: use chapter track (QT-style)\\n\"\n\t\"- udta: use user-data box chapters\\n\"\n\t\"- both: use both chapter tracks and udta\"\n\t, GF_PROP_UINT, \"both\", \"off|tk|udta|both\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(patch_dts), \"patch previous samples duration when dts do not increase monotonically\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(uncv), \"use uncv (ISO 23001-17) for raw video\\n\"\n\t\"- off: disabled (always the case when muxing to QT)\\n\"\n\t\"- gen: enabled, do not write profile\\n\"\n\t\"- prof: enabled and write profile if known\\n\"\n\t\"- tiny: enabled and write reduced version if profile known and compatible\", GF_PROP_UINT, \"prof\", \"off|gen|prof|tiny\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(trunv1), \"force using version 1 of trun regardless of media type or CMAF brand\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{0}\n};\n\n\nGF_FilterRegister MP4MuxRegister = {\n\t.name = \"mp4mx\",\n\tGF_FS_SET_DESCRIPTION(\"ISOBMFF/QT multiplexer\")\n\tGF_FS_SET_HELP(\"This filter multiplexes streams to ISOBMFF (14496-12 and derived specifications) or QuickTime\\n\"\n\t\"  \\n\"\n\t\"# Tracks and Items\\n\"\n\t\"By default all input PIDs with ItemID property set are multiplexed as items, otherwise they are multiplexed as tracks.\\n\"\n\t\"To prevent source items to be multiplexed as items, use [-itemid](mp4dmx) option from ISOBMFF demultiplexer.\\n\"\n\t\"EX gpac -i source.mp4:itemid=false -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"To force non-item streams to be multiplexed as items, use __#ItemID__ option on that PID:\\n\"\n\t\"EX gpac -i source.jpg:#ItemID=1 -o file.mp4\\n\"\n\t\"  \\n\"\n\t\"# Storage\\n\"\n\t\"The [-store]() option allows controlling if the file is fragmented or not, and when not fragmented, how interleaving is done. For cases where disk requirements are tight and fragmentation cannot be used, it is recommended to use either `flat` or `fstart` modes.\\n\"\n\t\"  \\n\"\n\t\"The [-vodcache]() option allows controlling how DASH onDemand segments are generated:\\n\"\n\t\"- If set to `on`, file data is stored to a temporary file on disk and flushed upon completion, no padding is present.\\n\"\n\t\"- If set to `insert`, SIDX/SSIX will be injected upon completion of the file by shifting bytes in file. In this case, no padding is required but this might not be compatible with all output sinks and will take longer to write the file.\\n\"\n\t\"- If set to `replace`, SIDX/SSIX size will be estimated based on duration and DASH segment length, and padding will be used in the file __before__ the final SIDX. If input PIDs have the properties `DSegs` set, this will used be as the number of segments.\\n\"\n\t\"The `on` and `insert` modes will produce exactly the same file, while the mode `replace` may inject a `free` box before the sidx.\\n\"\n\t\"  \\n\"\n\t\"# Custom boxes\\n\"\n\t\"Custom boxes can be specified as box patches:\\n\"\n\t\"For movie-level patch, the [-boxpatch]() option of the filter should be used.\\n\"\n\t\"Per PID box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"Per Item box patch can be specified through the PID property `boxpatch`.\\n\"\n\t\"EX gpac -i source:1ItemID=1:#boxpatch=myfile.xml -o mux.mp4\\n\"\n\t\"  \\n\"\n\t\"The box patch is applied before writing the initial `moov box in fragmented mode, or when writing the complete file otherwise.\\n\"\n\t\"The box patch can either be a filename or the full XML string.\\n\"\n\t\"  \\n\"\n\t\"# Tagging\\n\"\n\t\"When tagging is enabled, the filter will watch the property `CoverArt` and all custom properties on incoming PID.\\n\"\n\t\"The built-in tag names are indicated by `MP4Box -h tags`.\\n\"\n\t\"QT tags can be specified using `qtt_NAME` property names, and will be added using formatting specified in `MP4Box -h tags`.\\n\"\n\t\"Other tag class may be specified using `tag_NAME` property names, and will be added if [-tags]() is set to `all` using:\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is four characters long\\n\"\n\t\"- `NAME` as a box 4CC if `NAME` is 3 characters long, and will be prefixed by 0xA9\\n\"\n\t\"- the CRC32 of the `NAME` as a box 4CC if `NAME` is not four characters long\\n\"\n\t\"  \\n\"\n\t\"# User data\\n\"\n\t\"The filter will look for the following PID properties to create user data entries:\\n\"\n\t\"- `udtab`: set the track user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `mudtab`: set the movie user-data box to the property value which __must__ be a serialized box array blob\\n\"\n\t\"- `udta_U4CC`: set track user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `mudta_U4CC`: set movie user-data box entry of type `U4CC` to property value\\n\"\n\t\"- `tkgp_T4CC`: set/remove membership to track group with type `T4CC` and ID given by property value. A negative value N removes from track group with ID -N\\n\"\n\t\"  \\n\"\n\t\"EX gpac -i src.mp4:#udta_tagc='My Awesome Tag' -o tag.mp4\\n\"\n\t\"EX gpac -i src.mp4:#mudtab=data@box.bin -o tag.mp4\\n\"\n\t\"  \\n\"\n\t\"# Custom sample group descriptions and sample auxiliary info\\n\"\n\t\"The filter watches the following custom data properties on incoming packets:\\n\"\n\t\"- `grp_A4CC`: maps packet to sample group description of type `A4CC` and entry set to property payload\\n\"\n\t\"- `grp_A4CC_param`: same as above and sets sample to group `grouping_type_parameter` to `param`\\n\"\n\t\"- `sai_A4CC`: adds property payload as sample auxiliary information of type `A4CC`\\n\"\n\t\"- `sai_A4CC_param`: same as above and sets `aux_info_type_parameter`to `param`\\n\"\n\t\"  \\n\"\n\t\"The property `grp_EMSG` consists in one or more `EventMessageBox` as defined in MPEG-DASH.\\n\"\n\t\"- in fragmented mode, presence of these boxes in a packet will start a new fragment, with the boxes written before the `moof`\\n\"\n\t\"- in regular mode, an internal sample group of type `EMSG` is currently used for `emsg` box storage\\n\"\n\t\"  \\n\"\n\t\"# Notes\\n\"\n\t\"The filter watches the property `FileNumber` on incoming packets to create new files (regular mode) or new segments (DASH mode).\\n\"\n\t\"  \\n\"\n\t\"The filter watches the property `DSIWrap` (4CC as int or string) on incoming PID to wrap decoder configuration in a box of given type (unknown wrapping)\\n\"\n\t\"EX -i unkn.mkv:#ISOMSubtype=VIUK:#DSIWrap=cfgv -o t.mp4\\n\"\n\t\"This will wrap the unknown stream using `VIUK` code point in `stsd` and wrap any decoder configuration data in a `cfgv` box.\\n\"\n\t\"\\n\"\n\t\"If [-pad_sparse]() is set, the filter watches the property `Sparse` on incoming PID to decide whether empty packets should be injected to keep packet duration info.\\n\"\n\t\"Such packets are only injected when a whole in the timeline is detected.\\n\"\n\t\"- if `Sparse` is absent, empty packet is inserted for unknown text and metadata streams\\n\"\n\t\"- if `Sparse` is true, empty packet is inserted for all stream types\\n\"\n\t\"- if `Sparse` is false, empty packet is never injected\\n\"\n\t\"  \\n\"\n\t\"The default media type used for a PID can be overriden using property `StreamSubtype`. \\n\"\n\t\"EX -i src.srt:#StreamSubtype=sbtl [-i ...]  -o test.mp4 \\n\"\n\t\"This will force the text stream to use `sbtl` handler type instead of default `text` one.\"\n\t\"\\n\"\n\t\"Subtitle streams may be used as chapters by setting the property `IsChap` on the desired PID.\\n\"\n\t\"EX -i src.srt:#IsChap  [-i ...] -o test.mp4 \\n\"\n\t\"This will force the text stream to be used as a QT chapter track.\"\n\t\"  \\n\"\n\t)\n\t.private_size = sizeof(GF_MP4MuxCtx),\n\t.args = MP4MuxArgs,\n\t.initialize = mp4_mux_initialize,\n\t.finalize = mp4_mux_finalize,\n\t.flags = GF_FS_REG_DYNAMIC_REDIRECT,\n\tSETCAPS(MP4MuxCaps),\n\t.configure_pid = mp4_mux_configure_pid,\n\t.process = mp4_mux_process,\n\t.process_event = mp4_mux_process_event\n};\n\n\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn &MP4MuxRegister;\n}\n#else\nconst GF_FilterRegister *mp4mx_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nGF_Err Media_GetSampleDesc(GF_MediaBox *mdia, u32 SampleDescIndex, GF_SampleEntryBox **out_entry, u32 *dataRefIndex)\n{\n\tGF_SampleDescriptionBox *stsd;\n\tGF_SampleEntryBox *entry = NULL;\n\n\tif (!mdia) return GF_ISOM_INVALID_FILE;\n\n\tstsd = mdia->information->sampleTable->SampleDescription;\n\tif (!stsd) return GF_ISOM_INVALID_FILE;\n\tif (!SampleDescIndex || (SampleDescIndex > gf_list_count(stsd->child_boxes)) ) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, SampleDescIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (out_entry) *out_entry = entry;\n\tif (dataRefIndex) *dataRefIndex = entry->dataReferenceIndex;\n\treturn GF_OK;\n}\n\nGF_Err Media_GetSampleDescIndex(GF_MediaBox *mdia, u64 DTS, u32 *sampleDescIndex)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, num;\n\tu64 offset;\n\tif (sampleDescIndex == NULL) return GF_BAD_PARAM;\n\n\t//find the sample for this time\n\te = stbl_findEntryForTime(mdia->information->sampleTable, (u32) DTS, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\t//we have to assume the track was created to be used... If we have a sampleDesc, OK\n\t\tif (gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes)) {\n\t\t\t(*sampleDescIndex) = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn stbl_GetSampleInfos(mdia->information->sampleTable, ( sampleNumber ? sampleNumber : prevSampleNumber), &offset, &num, sampleDescIndex, NULL);\n}\n\nstatic GF_Err gf_isom_get_3gpp_audio_esd(GF_SampleTableBox *stbl, u32 type, GF_GenericAudioSampleEntryBox *entry, GF_ESD **out_esd)\n{\n\t(*out_esd) = gf_odf_desc_esd_new(2);\n\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t/*official mapping to MPEG-4*/\n\tswitch (type) {\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_EVRC;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t{\n\t\tu32 block_size, sample_rate, sample_size, i;\n\t\tGF_SttsEntry *ent;\n\t\tGF_BitStream *bs;\n\t\tchar szName[80];\n\t\t/*only map CBR*/\n\t\tsample_size = stbl->SampleSize->sampleSize;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_QCELP;\n\t\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(bs, \"QLCMfmt \", 8);\n\t\tgf_bs_write_u32_le(bs, 150);/*fmt chunk size*/\n\t\tgf_bs_write_u8(bs, 1);\n\t\tgf_bs_write_u8(bs, 0);\n\t\t/*QCELP GUID*/\n\t\tgf_bs_write_data(bs, \"\\x41\\x6D\\x7F\\x5E\\x15\\xB1\\xD0\\x11\\xBA\\x91\\x00\\x80\\x5F\\xB4\\xB9\\x7E\", 16);\n\t\tgf_bs_write_u16_le(bs, 1);\n\t\tmemset(szName, 0, 80);\n\t\tstrcpy(szName, \"QCELP-13K(GPAC-emulated)\");\n\t\tgf_bs_write_data(bs, szName, 80);\n\t\tent = stbl->TimeToSample->nb_entries ? &stbl->TimeToSample->entries[0] : NULL;\n\t\tsample_rate = entry->samplerate_hi;\n\t\tblock_size = ent ? ent->sampleDelta : 160;\n\t\tgf_bs_write_u16_le(bs, 8*sample_size*sample_rate/block_size);\n\t\tgf_bs_write_u16_le(bs, sample_size);\n\t\tgf_bs_write_u16_le(bs, block_size);\n\t\tgf_bs_write_u16_le(bs, sample_rate);\n\t\tgf_bs_write_u16_le(bs, entry->bitspersample);\n\t\tgf_bs_write_u32_le(bs, sample_size ? 0 : 7);\n\t\t/**/\n\t\tfor (i=0; i<7; i++) {\n\t\t\tstatic const u32 qcelp_r2s [] = {0, 1, 1, 4, 2, 8, 3, 17, 4, 35, 5, 8, 14, 1};\n\t\t\tif (sample_size) {\n\t\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i+1]);\n\t\t\t\tgf_bs_write_u8(bs, qcelp_r2s[2*i]);\n\t\t\t}\n\t\t}\n\t\tgf_bs_write_u16(bs, 0);\n\t\tmemset(szName, 0, 80);\n\t\tgf_bs_write_data(bs, szName, 20);/*reserved*/\n\t\tgf_bs_get_content(bs, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tgf_bs_del(bs);\n\t}\n\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_SMV;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR;\n\t\treturn GF_OK;\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AMR_WB;\n\t\treturn GF_OK;\n\tdefault:\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] unsupported sample description type %s\\n\", gf_4cc_to_str(entry->type)));\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only)\n{\n\tu32 type;\n\tGF_ESD *esd;\n\tGF_MPEGSampleEntryBox *entry = NULL;\n\tGF_ESDBox *ESDa;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\n\n\t*out_esd = NULL;\n\tif (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) )\n\t\treturn GF_BAD_PARAM;\n\n\tesd = NULL;\n\tentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\n\tif (! entry) return GF_ISOM_INVALID_MEDIA;\n\n\t*out_esd = NULL;\n\tESDa = NULL;\n\ttype = entry->type;\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\tcase GF_ISOM_BOX_TYPE_ENCF:\n\tcase GF_ISOM_BOX_TYPE_ENCM:\n\tcase GF_ISOM_BOX_TYPE_ENCT:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);\n\t\tif (sinf && sinf->original_format) {\n\t\t\ttype = sinf->original_format->data_format;\n\t\t}\n\t\tbreak;\n\t}\n\n\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd;\n\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t/*avc1 encrypted*/\n\t\telse esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVC2:\n\tcase GF_ISOM_BOX_TYPE_HEV2:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\tcase GF_ISOM_BOX_TYPE_264B:\n\tcase GF_ISOM_BOX_TYPE_265B:\n\tcase GF_ISOM_BOX_TYPE_DVHE:\n\tcase GF_ISOM_BOX_TYPE_DVH1:\n\tcase GF_ISOM_BOX_TYPE_DVA1:\n\tcase GF_ISOM_BOX_TYPE_DVAV:\n\tcase GF_ISOM_BOX_TYPE_VVC1:\n\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tAVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_LHE1:\n\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT)\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia);\n\t\telse\n\t\t\tHEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_DAV1:\n\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tAV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_VP08:\n\tcase GF_ISOM_BOX_TYPE_VP09:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tVP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia);\n\t\tesd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n        {\n            GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry;\n            ESDa = ase->esd;\n            if (ESDa) {\n\t\t\t\tesd = (GF_ESD *) ESDa->desc;\n            } else if (!true_desc_only) {\n\t\t\t\tBool make_mp4a = GF_FALSE;\n\t\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\n\t\t\t\tif (sinf && sinf->original_format) {\n\t\t\t\t\tif (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) {\n\t\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Assuming that if no ESD is provided the stream is Basic MPEG-4 AAC LC\n\t\t\t\t\tmake_mp4a = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (make_mp4a) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\t\t\tGF_M4ADecSpecInfo aacinfo;\n\t\t\t\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\t\t\t\taacinfo.nb_chan = ase->channel_count;\n\t\t\t\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\t\t\t\taacinfo.base_sr = ase->samplerate_hi;\n\t\t\t\t\t*out_esd = gf_odf_desc_esd_new(0);\n\t\t\t\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\t\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\t\t\t\tgf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n#else\n\t\t\t\t\treturn GF_NOT_SUPPORTED;\n#endif\n\t\t\t\t}\n            }\n        }\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) {\n\t\t\tESDa = entry->esd;\n\t\t\tif (ESDa) esd = (GF_ESD *) ESDa->desc;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_TTXT\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) {\n\t\t\tGF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n#endif\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry;\n\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t*out_esd = esd;\n\t\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT;\n\t\tif (vtte->config) {\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string);\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t}\n\t}\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_STPP:\n\tcase GF_ISOM_BOX_TYPE_SBTT:\n\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\tbreak;\n#endif\n\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (!true_desc_only) {\n\t\t\tGF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t} else return GF_ISOM_INVALID_MEDIA;\n\n\tcase GF_ISOM_SUBTYPE_OPUS:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t{\n\t\tGF_OpusSpecificBox *opus_c;\n\t\tif (true_desc_only)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\topus_c = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus;\n\t\tif (!opus_c) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ESD not found for Opus\\n)\"));\n\t\t\tbreak;\n\t\t}\n\t\t*out_esd = gf_odf_desc_esd_new(2);\n\t\t(*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t(*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS;\n\t\tgf_odf_opus_cfg_write(&opus_c->opcfg, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength);\n\t\tbreak;\n\t}\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_H263;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_MP3:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO;\n\t\t\tbreak;\n\t\t}\n\n\tcase GF_ISOM_SUBTYPE_LSR1:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_GENERIC)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry;\n\t\t\tif (!ptr || !ptr->lsr_config || !ptr->lsr_config->hdr_size)\n\t\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t\tesd =  gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_SCENE;\n\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_LASER;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size;\n\t\t\tesd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tif (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size);\n\t\t\tbreak;\n\t\t}\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHA2:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM1:\n\tcase GF_ISOM_SUBTYPE_MH3D_MHM2:\n\t\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO)\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\n\t\tif (true_desc_only) {\n\t\t\treturn GF_ISOM_INVALID_MEDIA;\n\t\t} else {\n\t\t\tGF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry;\n\t\t\tesd = gf_odf_desc_esd_new(2);\n\t\t\t*out_esd = esd;\n\t\t\tesd->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\t\tif ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2))\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA;\n\t\t\telse\n\t\t\t\tesd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS;\n\t\t\tif (ptr->cfg_mha) {\n\t\t\t\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->configuration_version);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication);\n\t\t\t\tgf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout);\n\t\t\t\tgf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0);\n\t\t\t\tif (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size)\n\t\t\t\t\tgf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size);\n\n\t\t\t\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn GF_ISOM_INVALID_MEDIA;\n\t}\n\n\tif (true_desc_only) {\n\t\tif (!esd) return GF_ISOM_INVALID_MEDIA;\n\t\t*out_esd = esd;\n\t\treturn GF_OK;\n\t} else {\n\t\tif (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA;\n\t\tif (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd);\n\t}\n\treturn GF_OK;\n}\n\nBool Media_IsSampleSyncShadow(GF_ShadowSyncBox *stsh, u32 sampleNumber)\n{\n\tu32 i;\n\tGF_StshEntry *ent;\n\tif (!stsh) return 0;\n\ti=0;\n\twhile ((ent = (GF_StshEntry*)gf_list_enum(stsh->entries, &i))) {\n\t\tif ((u32) ent->syncSampleNumber == sampleNumber) return 1;\n\t\telse if ((u32) ent->syncSampleNumber > sampleNumber) return 0;\n\t}\n\treturn 0;\n}\n\nGF_Err Media_GetSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample **samp, u32 *sIDX, Bool no_data, u64 *out_offset, Bool ext_realloc)\n{\n\tGF_Err e;\n\tu32 bytesRead;\n\tu32 dataRefIndex, chunkNumber;\n\tu64 offset, new_size;\n\tu32 sdesc_idx, data_size;\n\tGF_SampleEntryBox *entry;\n\tGF_StscEntry *stsc_entry;\n\n\tif (!mdia || !mdia->information->sampleTable) return GF_BAD_PARAM;\n\tif (!mdia->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\t//OK, here we go....\n\tif (sampleNumber > mdia->information->sampleTable->SampleSize->sampleCount) return GF_BAD_PARAM;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n\n\te = stbl_GetSampleInfos(mdia->information->sampleTable, sampleNumber, &offset, &chunkNumber, &sdesc_idx, &stsc_entry);\n\tif (e) return e;\n\tif (sIDX) (*sIDX) = sdesc_idx;\n\n\tif (out_offset) *out_offset = offset;\n\tif (!samp ) return GF_OK;\n\n\tif (mdia->information->sampleTable->TimeToSample) {\n\t\t//get the DTS\n\t\te = stbl_GetSampleDTS_and_Duration(mdia->information->sampleTable->TimeToSample, sampleNumber, &(*samp)->DTS, &(*samp)->duration);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->DTS=0;\n\t}\n\t//the CTS offset\n\tif (mdia->information->sampleTable->CompositionOffset) {\n\t\te = stbl_GetSampleCTS(mdia->information->sampleTable->CompositionOffset , sampleNumber, &(*samp)->CTS_Offset);\n\t\tif (e) return e;\n\t} else {\n\t\t(*samp)->CTS_Offset = 0;\n\t}\n\t//the size\n\te = stbl_GetSampleSize(mdia->information->sampleTable->SampleSize, sampleNumber, &data_size);\n\tif (e) return e;\n\t//the RAP\n\tif (mdia->information->sampleTable->SyncSample) {\n\t\te = stbl_GetSampleRAP(mdia->information->sampleTable->SyncSample, sampleNumber, &(*samp)->IsRAP, NULL, NULL);\n\t\tif (e) return e;\n\t} else {\n\t\t//if no SyncSample, all samples are sync (cf spec)\n\t\t(*samp)->IsRAP = RAP;\n\t}\n\n\tif (mdia->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\t\te = stbl_GetSampleDepType(mdia->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (!e) {\n\t\t\tif (dependsOn==1) (*samp)->IsRAP = RAP_NO;\n\t\t\t//commenting following code since it is wrong - an I frame is not always a SAP1, it can be a SAP2 or SAP3.\n\t\t\t//Keeping this code breaks AVC / HEVC openGOP import when writing sample dependencies\n\t\t\t//else if (dependsOn==2) (*samp)->IsRAP = RAP;\n\n\t\t\t/*if not depended upon and redundant, mark as carousel sample*/\n\t\t\tif ((dependedOn==2) && (redundant==1)) (*samp)->IsRAP = RAP_REDUNDANT;\n\t\t\t/*TODO FIXME - we must enhance the IsRAP semantics to carry disposable info ... */\n\t\t}\n\t}\n\n\t/*get sync shadow*/\n\tif (Media_IsSampleSyncShadow(mdia->information->sampleTable->ShadowSync, sampleNumber)) (*samp)->IsRAP = RAP_REDUNDANT;\n\n\t//the data info\n\tif (!sIDX && !no_data) return GF_BAD_PARAM;\n//\tif (!sIDX && !out_offset) return GF_OK;\n\tif (!sIDX) {\n\t\t(*samp)->dataLength = data_size;\n\t\treturn GF_OK;\n\t}\n\t(*sIDX) = sdesc_idx;\n\n\t//then get the DataRef\n\te = Media_GetSampleDesc(mdia, sdesc_idx, &entry, &dataRefIndex);\n\tif (e) return e;\n\n\t//if moov is compressed, remove offset if sample is after moov in this file\n\tif (mdia->mediaTrack->moov->compressed_diff) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1) && (offset>=mdia->mediaTrack->moov->file_offset)) {\n\t\t\toffset -= mdia->mediaTrack->moov->compressed_diff;\n\t\t}\n\t}\n\n\n\tif (no_data) {\n\t\t(*samp)->dataLength = data_size;\n\t\tif ( ((*samp)->dataLength != 0) && mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\t(*samp)->dataLength *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t// Open the data handler - check our mode, don't reopen in read only if this is\n\t//the same entry. In other modes we have no choice because the main data map is\n\t//divided into the original and the edition files\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_READ) {\n\t\t//same as last call in read mode\n\t\tif (!mdia->information->dataHandler) {\n\t\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\t\tif (e) return e;\n\t\t}\n\t\tmdia->information->dataEntryIndex = dataRefIndex;\n\t} else {\n\t\te = gf_isom_datamap_open(mdia, dataRefIndex, stsc_entry->isEdited);\n\t\tif (e) return e;\n\t}\n\n\tif ( mdia->mediaTrack->moov->mov->read_byte_offset || mdia->mediaTrack->moov->mov->bytes_removed) {\n\t\tGF_DataEntryBox *ent = (GF_DataEntryBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\t\tif (ent && (ent->flags&1)) {\n\t\t\tu64 real_offset = mdia->mediaTrack->moov->mov->read_byte_offset + mdia->mediaTrack->moov->mov->bytes_removed;\n\t\t\tif (offset < real_offset)\n\t\t\t\treturn GF_IO_ERR;\n\n\t\t\tif (mdia->information->dataHandler->last_read_offset != mdia->mediaTrack->moov->mov->read_byte_offset) {\n\t\t\t\tmdia->information->dataHandler->last_read_offset = mdia->mediaTrack->moov->mov->read_byte_offset;\n\t\t\t\tgf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\t}\n\n\t\t\toffset -= real_offset;\n\t\t}\n\t}\n\n\tif (data_size != 0) {\n\t\tif (mdia->mediaTrack->pack_num_samples) {\n\t\t\tu32 idx_in_chunk = sampleNumber - mdia->information->sampleTable->SampleToChunk->firstSampleInCurrentChunk;\n\t\t\tu32 left_in_chunk = stsc_entry->samplesPerChunk - idx_in_chunk;\n\t\t\tif (left_in_chunk > mdia->mediaTrack->pack_num_samples)\n\t\t\t\tleft_in_chunk = mdia->mediaTrack->pack_num_samples;\n\t\t\tdata_size *= left_in_chunk;\n\t\t\t(*samp)->nb_pack = left_in_chunk;\n\t\t}\n\t\tif (! (*samp)->data)\n\t\t\t(*samp)->alloc_size = 0;\n\n\t\t/*and finally get the data, include padding if needed*/\n\t\tif ((*samp)->alloc_size) {\n\t\t\tif ((*samp)->alloc_size < data_size + mdia->mediaTrack->padding_bytes) {\n\t\t\t\t(*samp)->data = (char *) gf_realloc((*samp)->data, sizeof(char) * ( data_size + mdia->mediaTrack->padding_bytes) );\n\t\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\n\t\t\t\t(*samp)->alloc_size = data_size + mdia->mediaTrack->padding_bytes;\n\t\t\t}\n\t\t} else {\n\t\t\tif (ext_realloc) {\n\t\t\t\t(*samp)->data = mdia->mediaTrack->sample_alloc_cbk(data_size + mdia->mediaTrack->padding_bytes, mdia->mediaTrack->sample_alloc_udta);\n\t\t\t} else {\n\t\t\t\t(*samp)->data = (u8 *) gf_malloc(data_size + mdia->mediaTrack->padding_bytes);\n\t\t\t}\n\t\t\tif (! (*samp)->data) return GF_OUT_OF_MEM;\n\t\t}\n\t\t(*samp)->dataLength = data_size;\n\t\tif (mdia->mediaTrack->padding_bytes)\n\t\t\tmemset((*samp)->data + data_size, 0, sizeof(char) * mdia->mediaTrack->padding_bytes);\n\n\t\t//check if we can get the sample (make sure we have enougth data...)\n\t\tnew_size = gf_bs_get_size(mdia->information->dataHandler->bs);\n\t\tif (offset + data_size > new_size) {\n\t\t\t//always refresh the size to avoid wrong info on http/ftp\n\t\t\tnew_size = gf_bs_get_refreshed_size(mdia->information->dataHandler->bs);\n\t\t\tif (offset + data_size > new_size) {\n\t\t\t\tmdia->BytesMissing = offset + data_size - new_size;\n\t\t\t\treturn GF_ISOM_INCOMPLETE_FILE;\n\t\t\t}\n\t\t}\n\n\t\tbytesRead = gf_isom_datamap_get_data(mdia->information->dataHandler, (*samp)->data, (*samp)->dataLength, offset);\n\t\t//if bytesRead != sampleSize, we have an IO err\n\t\tif (bytesRead < data_size) {\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tmdia->BytesMissing = 0;\n\t} else {\n\t\t(*samp)->dataLength = 0;\n\t}\n\n\t//finally rewrite the sample if this is an OD Access Unit or NAL-based one\n\t//we do this even if sample size is zero because of sample implicit reconstruction rules (especially tile tracks)\n\tif (mdia->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tif (!mdia->mediaTrack->moov->mov->disable_odf_translate) {\n\t\t\te = Media_RewriteODFrame(mdia, *samp);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\telse if (gf_isom_is_nalu_based_entry(mdia, entry)) {\n\t\tGF_ISOSAPType gf_isom_nalu_get_sample_sap(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, GF_MPEGVisualSampleEntryBox *entry);\n\n\t\tif (!gf_isom_is_encrypted_entry(entry->type)) {\n\t\t\te = gf_isom_nalu_sample_rewrite(mdia, *samp, sampleNumber, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\t\tif (e) return e;\n\t\t}\n\t\tif (!gf_sys_old_arch_compat()) {\n\t\t\tGF_ISOSAPType sap = gf_isom_nalu_get_sample_sap(mdia, sampleNumber, *samp, (GF_MPEGVisualSampleEntryBox *)entry);\n\t\t\tif (sap && ! (*samp)->IsRAP) (*samp)->IsRAP = sap;\n\t\t\telse if ((*samp)->IsRAP < sap) (*samp)->IsRAP = sap;\n\t\t}\n\t}\n\telse if (mdia->mediaTrack->moov->mov->convert_streaming_text\n\t         && ((mdia->handler->handlerType == GF_ISOM_MEDIA_TEXT) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SCENE) || (mdia->handler->handlerType == GF_ISOM_MEDIA_SUBT))\n\t         && (entry->type == GF_ISOM_BOX_TYPE_TX3G || entry->type == GF_ISOM_BOX_TYPE_TEXT)\n\t        ) {\n\t\tu64 dur;\n\t\tif (sampleNumber == mdia->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tdur = mdia->mediaHeader->duration - (*samp)->DTS;\n\t\t} else {\n\t\t\tstbl_GetSampleDTS(mdia->information->sampleTable->TimeToSample, sampleNumber+1, &dur);\n\t\t\tdur -= (*samp)->DTS;\n\t\t}\n\t\te = gf_isom_rewrite_text_sample(*samp, sdesc_idx, (u32) dur);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\n\n\nGF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t//ok, not self contained, let's go for it...\n\t//we only support alias and URL boxes\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_URL:\n\tcase GF_QT_BOX_TYPE_ALIS:\n\tcase GF_QT_BOX_TYPE_CIOS:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}\n\n\nBool Media_IsSelfContained(GF_MediaBox *mdia, u32 StreamDescIndex)\n{\n\tu32 drefIndex=0;\n\tGF_FullBox *a=NULL;\n\tGF_SampleEntryBox *se = NULL;\n\n\tMedia_GetSampleDesc(mdia, StreamDescIndex, &se, &drefIndex);\n\tif (!drefIndex) return 0;\n\tif (mdia\n\t\t&& mdia->information\n\t\t&& mdia->information->dataInformation\n\t\t&& mdia->information->dataInformation->dref\n\t) {\n\t\ta = (GF_FullBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!a) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] broken file: Data reference index set to %d but no data reference entry found\\n\", drefIndex));\n\t\treturn 1;\n\t}\n\tif (a->flags & 1) return 1;\n\t/*QT specific*/\n\tif (a->type == GF_QT_BOX_TYPE_ALIS) return 1;\n\tif (a->type == GF_QT_BOX_TYPE_CIOS) return 1;\n\treturn 0;\n}\n\nGF_ISOMDataRefAllType Media_SelfContainedType(GF_MediaBox *mdia)\n{\n\tu32 nb_ext, nb_self;\n\tu32 i, count;\n\n\tnb_ext = nb_self = 0;\n\tcount = mdia->information->sampleTable->SampleDescription ? gf_list_count(mdia->information->sampleTable->SampleDescription->child_boxes) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tif (Media_IsSelfContained(mdia, i+1)) nb_self++;\n\t\telse nb_ext++;\n\t}\n\tif (nb_ext==count) return ISOM_DREF_EXT;\n\tif (nb_self==count) return ISOM_DREF_SELF;\n\treturn ISOM_DREF_MIXED;\n}\n\n\n\n//look for a sync sample from a given point in media time\nGF_Err Media_FindSyncSample(GF_SampleTableBox *stbl, u32 searchFromSample, u32 *sampleNumber, u8 mode)\n{\n\tGF_ISOSAPType isRAP;\n\tu32 next, prev, next_in_sap, prev_in_sap;\n\tif (!stbl || !stbl->SyncSample) return GF_BAD_PARAM;\n\n\t//set to current sample if we don't find a RAP\n\t*sampleNumber = searchFromSample;\n\n\t//this is not the exact sample, but the prev move to next sample if enough samples....\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_FORWARD) && (searchFromSample == stbl->SampleSize->sampleCount) ) {\n\t\treturn GF_OK;\n\t}\n\tif ( (mode == GF_ISOM_SEARCH_SYNC_BACKWARD) && !searchFromSample) {\n\t\t*sampleNumber = 1;\n\t\treturn GF_OK;\n\t}\n\t//get the entry\n\tstbl_GetSampleRAP(stbl->SyncSample, searchFromSample, &isRAP, &prev, &next);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\t/*check sample groups - prev & next are overwritten if RAP group is found, but are not re-initialized otherwise*/\n\tstbl_SearchSAPs(stbl, searchFromSample, &isRAP, &prev_in_sap, &next_in_sap);\n\tif (isRAP) {\n\t\t(*sampleNumber) = searchFromSample;\n\t\treturn GF_OK;\n\t}\n\n\tif (prev_in_sap > prev)\n\t\tprev = prev_in_sap;\n\tif (next_in_sap && next_in_sap < next)\n\t\tnext = next_in_sap;\n\n\t//nothing yet, go for next time...\n\tif (mode == GF_ISOM_SEARCH_SYNC_FORWARD) {\n\t\tif (next) *sampleNumber = next;\n\t} else {\n\t\tif (prev) *sampleNumber = prev;\n\t}\n\n\treturn GF_OK;\n}\n\n//create a DataReference if not existing (only for WRITE-edit mode)\nGF_Err Media_FindDataRef(GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tu32 i;\n\tGF_DataEntryURLBox *entry;\n\n\tif (!dref) return GF_BAD_PARAM;\n\t*dataRefIndex = 0;\n\ti=0;\n\twhile ((entry = (GF_DataEntryURLBox*)gf_list_enum(dref->child_boxes, &i))) {\n\t\tif (entry->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t\t//self-contained case\n\t\t\tif (entry->flags == 1) {\n\t\t\t\t//if nothing specified, get the dataRef\n\t\t\t\tif (!URLname && !URNname) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//OK, check if we have URL\n\t\t\t\tif (URLname && !strcmp(URLname, entry->location)) {\n\t\t\t\t\t*dataRefIndex = i;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t//this is a URN one, only check the URN name (URL optional)\n\t\t\tif (URNname && !strcmp(URNname, ((GF_DataEntryURNBox *)entry)->nameURN)) {\n\t\t\t\t*dataRefIndex = i;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n//Get the total media duration based on the TimeToSample table\nGF_Err Media_SetDuration(GF_TrackBox *trak)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tu64 DTS;\n\tu32 nbSamp, dur;\n\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->TimeToSample)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tnbSamp = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\tif (nbSamp == 0) {\n\t\ttrak->Media->mediaHeader->duration = 0;\n\t\tif (Track_IsMPEG4Stream(trak->Media->handler->handlerType)) {\n\t\t\tMedia_GetESD(trak->Media, 1, &esd, 1);\n\t\t\tif (esd && esd->URLString) trak->Media->mediaHeader->duration = (u64) -1;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//get last sample\n\te = stbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, nbSamp, &DTS, &dur);\n\tif (e < 0) return e;\n\tDTS += dur;\n\n\t//do not do that for old arch compat which was not taking into account cts offset\n\tif (gf_sys_old_arch_compat() || !trak->Media->information->sampleTable->CompositionOffset) {\n\t\ttrak->Media->mediaHeader->duration = DTS;\n\t\treturn GF_OK;\n\t}\n\t//try to set duration according to spec: \"should be the largest composition timestamp plus the duration of that sample\"\n\ts32 cts_o;\n\tstbl_GetSampleCTS(trak->Media->information->sampleTable->CompositionOffset, nbSamp, &cts_o);\n\tif (cts_o>0) DTS += cts_o;\n\tif (DTS>trak->Media->mediaHeader->duration)\n\t\ttrak->Media->mediaHeader->duration = DTS;\n\n\t//this can be more precise in some corner cases but takes way too long - we keep code for reference\n#if 0\n\t//browse from sample_num_max_cts_delta (updated in read and edit to point to sample number with max cts offset)\n\tu32 s_idx, min = trak->Media->information->sampleTable->CompositionOffset->sample_num_max_cts_delta;\n\tif (!min) return GF_OK;\n\tfor (s_idx=min; s_idx<=nbSamp; s_idx++) {\n\t\tu64 a_dts;\n\t\tu32 a_dur;\n\t\ts32 cts_o;\n\t\tstbl_GetSampleCTS(trak->Media->information->sampleTable->CompositionOffset, s_idx, &cts_o);\n\t\tif (cts_o<=0) continue;\n\t\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, s_idx, &a_dts, &a_dur);\n\t\tif (a_dts + a_dur + (u32) cts_o > DTS) {\n\t\t\tDTS = a_dts + (u32) cts_o + a_dur;\n\t\t}\n\t}\n\ttrak->Media->mediaHeader->duration = DTS;\n#endif\n\treturn GF_OK;\n}\n\n\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\nGF_Err Media_SetDrefURL(GF_DataEntryURLBox *dref_entry, const char *origName, const char *finalName)\n{\n\t//for now we only support dref created in same folder for relative URLs\n\tif (strstr(origName, \"://\") || ((origName[1]==':') && (origName[2]=='\\\\'))\n\t\t|| (origName[0]=='/') || (origName[0]=='\\\\')\n\t) {\n\t\tdref_entry->location = gf_strdup(origName);\n\t} else {\n\t\tchar *fname = strrchr(origName, '/');\n\t\tif (!fname) fname = strrchr(origName, '\\\\');\n\t\tif (fname) fname++;\n\n\t\tif (!fname) {\n\t\t\tdref_entry->location = gf_strdup(origName);\n\t\t} else {\n\t\t\tu32 len = (u32) (fname - origName);\n\t\t\tif (!finalName || strncmp(origName, finalName, len)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Concatenation of relative path %s with relative path %s not supported, use absolute URLs\\n\", origName, finalName));\n\t\t\t\treturn GF_NOT_SUPPORTED;\n\t\t\t} else {\n\t\t\t\tdref_entry->location = gf_strdup(fname);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_CreateDataRef(GF_ISOFile *movie, GF_DataReferenceBox *dref, char *URLname, char *URNname, u32 *dataRefIndex)\n{\n\tGF_Err e;\n\tBool use_alis=GF_FALSE;\n\tGF_DataEntryURLBox *entry;\n\n\tif (URLname && !strcmp(URLname, \"alis\")) {\n\t\tURLname = NULL;\n\t\tuse_alis=GF_TRUE;\n\t}\n\n\tif (!URLname && !URNname) {\n\t\t//THIS IS SELF CONTAIN, create a regular entry if needed\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, use_alis ? GF_QT_BOX_TYPE_ALIS : GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 1;\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else if (!URNname && URLname) {\n\t\t//THIS IS URL\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URL);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\tentry->flags = 0;\n\n\t\te = Media_SetDrefURL(entry, URLname, movie->fileName ? movie->fileName : movie->finalName);\n\t\tif (! entry->location) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn e ? e : GF_OUT_OF_MEM;\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t} else {\n\t\t//THIS IS URN\n\t\tentry = (GF_DataEntryURLBox *) gf_isom_box_new_parent(&dref->child_boxes, GF_ISOM_BOX_TYPE_URN);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t((GF_DataEntryURNBox *)entry)->flags = 0;\n\t\t((GF_DataEntryURNBox *)entry)->nameURN = (char*)gf_malloc(strlen(URNname)+1);\n\t\tif (! ((GF_DataEntryURNBox *)entry)->nameURN) {\n\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tstrcpy(((GF_DataEntryURNBox *)entry)->nameURN, URNname);\n\t\t//check for URL\n\t\tif (URLname) {\n\t\t\t((GF_DataEntryURNBox *)entry)->location = (char*)gf_malloc(strlen(URLname)+1);\n\t\t\tif (! ((GF_DataEntryURNBox *)entry)->location) {\n\t\t\t\tgf_isom_box_del_parent(&dref->child_boxes, (GF_Box *)entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tstrcpy(((GF_DataEntryURNBox *)entry)->location, URLname);\n\t\t}\n\t\t*dataRefIndex = gf_list_count(dref->child_boxes);\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err Media_AddSample(GF_MediaBox *mdia, u64 data_offset, const GF_ISOSample *sample, u32 StreamDescIndex, u32 syncShadowNumber)\n{\n\tGF_Err e;\n\tGF_SampleTableBox *stbl;\n\tu32 sampleNumber, i;\n\tif (!mdia || !sample) return GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\t//get a valid sampleNumber for this new guy\n\te = stbl_AddDTS(stbl, sample->DTS, &sampleNumber, mdia->mediaHeader->timeScale, sample->nb_pack);\n\tif (e) return e;\n\n\t//add size\n\te = stbl_AddSize(stbl->SampleSize, sampleNumber, sample->dataLength, sample->nb_pack);\n\tif (e) return e;\n\n\t//adds CTS offset\n\tif (sample->CTS_Offset) {\n\t\t//if we don't have a CTS table, add it...\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\t//then add our CTS (the prev samples with no CTS offset will be automatically added...\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t} else if (stbl->CompositionOffset) {\n\t\te = stbl_AddCTS(stbl, sampleNumber, sample->CTS_Offset);\n\t\tif (e) return e;\n\t}\n\n\t//The first non sync sample we see must create a syncTable\n\tif (sample->IsRAP) {\n\t\t//insert it only if we have a sync table and if we have an IDR slice\n\t\tif (stbl->SyncSample && ((sample->IsRAP == RAP) || (sample->IsRAP == SAP_TYPE_2))) {\n\t\t\te = stbl_AddRAP(stbl->SyncSample, sampleNumber);\n\t\t\tif (e) return e;\n\t\t}\n\t} else {\n\t\t//non-sync sample. Create a SyncSample table if needed\n\t\tif (!stbl->SyncSample) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//all the prev samples are sync\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) {\n\t\t\t\t\te = stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (sample->IsRAP==RAP_REDUNDANT) {\n\t\te = stbl_AddRedundant(stbl, sampleNumber);\n\t\tif (e) return e;\n\t}\n\n\tif (!mdia->mediaTrack->chunk_cache) {\n\t\t//and update the chunks\n\t\te = stbl_AddChunkOffset(mdia, sampleNumber, StreamDescIndex, data_offset, sample->nb_pack);\n\t\tif (e) return e;\n\t}\n\n\tif (!syncShadowNumber) return GF_OK;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\treturn stbl_AddShadow(mdia->information->sampleTable->ShadowSync, sampleNumber, syncShadowNumber);\n}\n\n\nstatic GF_Err UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, u32 size, s32 CTS, u64 offset, u8 isRap)\n{\n\tu32 i;\n\tGF_SampleTableBox *stbl = mdia->information->sampleTable;\n\n\t//set size, offset, RAP, CTS ...\n\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, size);\n\tstbl_SetChunkOffset(mdia, sampleNumber, offset);\n\n\t//do we have a CTS?\n\tif (stbl->CompositionOffset) {\n\t\tstbl_SetSampleCTS(stbl, sampleNumber, CTS);\n\t} else {\n\t\t//do we need one ??\n\t\tif (CTS) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t\tstbl_AddCTS(stbl, sampleNumber, CTS);\n\t\t}\n\t}\n\t//do we have a sync ???\n\tif (stbl->SyncSample) {\n\t\tstbl_SetSampleRAP(stbl->SyncSample, sampleNumber, isRap);\n\t} else {\n\t\t//do we need one\n\t\tif (! isRap) {\n\t\t\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\t\t\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\t\t\t//what a pain: all the sample we had have to be sync ...\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++) {\n\t\t\t\tif (i+1 != sampleNumber) stbl_AddRAP(stbl->SyncSample, i+1);\n\t\t\t}\n\t\t}\n\t}\n\tif (isRap==2) {\n\t\tstbl_SetRedundant(stbl, sampleNumber);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err Media_UpdateSample(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 newOffset, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia || !sample || !sampleNumber || !mdia->mediaTrack->moov->mov->editFileMap)\n\t\treturn GF_BAD_PARAM;\n\n\tstbl = mdia->information->sampleTable;\n\n\tif (!data_only) {\n\t\t//check we have the sampe dts\n\t\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\t\tif (e) return e;\n\t\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\t}\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &newOffset, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\tif (Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//MEDIA DATA EDIT: write this new sample to the edit temp file\n\tnewOffset = gf_isom_datamap_get_offset(mdia->mediaTrack->moov->mov->editFileMap);\n\tif (sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(mdia->mediaTrack->moov->mov->editFileMap, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\tif (data_only) {\n\t\tstbl_SetSampleSize(stbl->SampleSize, sampleNumber, sample->dataLength);\n\t\treturn stbl_SetChunkOffset(mdia, sampleNumber, newOffset);\n\t}\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, newOffset, sample->IsRAP);\n}\n\nGF_Err Media_UpdateSampleReference(GF_MediaBox *mdia, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tu32 drefIndex, chunkNum, descIndex;\n\tu64 off, DTS;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_SampleTableBox *stbl;\n\n\tif (!mdia) return GF_BAD_PARAM;\n\tstbl = mdia->information->sampleTable;\n\n\t//check we have the sampe dts\n\te = stbl_GetSampleDTS(stbl->TimeToSample, sampleNumber, &DTS);\n\tif (e) return e;\n\tif (DTS != sample->DTS) return GF_BAD_PARAM;\n\n\t//get our infos\n\tstbl_GetSampleInfos(stbl, sampleNumber, &off, &chunkNum, &descIndex, NULL);\n\n\t//then check the data ref\n\te = Media_GetSampleDesc(mdia, descIndex, NULL, &drefIndex);\n\tif (e) return e;\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\tif (!Dentry) return GF_ISOM_INVALID_FILE;\n\n\t//we only modify self-contained data\n\tif (Dentry->flags == 1) return GF_ISOM_INVALID_MODE;\n\n\t//and we don't modify the media data\n\treturn UpdateSample(mdia, sampleNumber, sample->dataLength, sample->CTS_Offset, data_offset, sample->IsRAP);\n}\n\n\n#endif\t/*GPAC_DISABLE_ISOM_WRITE*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nstatic u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = 0; //todo, expose qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\tif (txt->font_table && txt->font_table->entry_count) {\n\t\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#if 0 //unused\n/*! updates text sample description\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param sampleDescriptionIndex the target sample description index\n\\param desc the text sample descriptor to use\n\\return error if any\n*/\nGF_Err gf_isom_update_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor *desc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tBool is_qt_text = GF_FALSE;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qtt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qtt->textName) gf_free(qtt->textName);\n\t\tqtt->textName = NULL;\n\t\tif (desc->font_count) {\n\t\t\tqtt->textName = gf_strdup(desc->fonts[0].fontName);\n\t\t}\n\t} else {\n\t\tif (txt->font_table) gf_isom_box_del_parent(&txt->child_boxes, (GF_Box*)txt->font_table);\n\n\t\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\t\ttxt->font_table->entry_count = desc->font_count;\n\t\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\t\tfor (i=0; i<desc->font_count; i++) {\n\t\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t\t}\n\t}\n\treturn e;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_new_text_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex, i;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\ttxt = (GF_Tx3gSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_TX3G);\n\tif (!txt) return GF_OUT_OF_MEM;\n\ttxt->dataReferenceIndex = dataRefIndex;\n\tgf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, txt);\n\tif (outDescriptionIndex) *outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\ttxt->back_color = desc->back_color;\n\ttxt->default_box = desc->default_pos;\n\ttxt->default_style = desc->default_style;\n\ttxt->displayFlags = desc->displayFlags;\n\ttxt->vertical_justification = desc->vert_justif;\n\ttxt->horizontal_justification = desc->horiz_justif;\n\ttxt->font_table = (GF_FontTableBox *)gf_isom_box_new_parent(&txt->child_boxes, GF_ISOM_BOX_TYPE_FTAB);\n\tif (!txt->font_table) return GF_OUT_OF_MEM;\n\ttxt->font_table->entry_count = desc->font_count;\n\n\ttxt->font_table->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * desc->font_count);\n\tif (!txt->font_table->fonts) return GF_OUT_OF_MEM;\n\tfor (i=0; i<desc->font_count; i++) {\n\t\ttxt->font_table->fonts[i].fontID = desc->fonts[i].fontID;\n\t\tif (desc->fonts[i].fontName) txt->font_table->fonts[i].fontName = gf_strdup(desc->fonts[i].fontName);\n\t}\n\treturn e;\n}\n\n\n/*blindly adds text - note we don't rely on terminaison characters to handle utf8 and utf16 data\nin the same way. It is the user responsibility to signal UTF16*/\nGF_EXPORT\nGF_Err gf_isom_text_add_text(GF_TextSample *samp, char *text_data, u32 text_len)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!text_len) return GF_OK;\n\tsamp->text = (char*)gf_realloc(samp->text, sizeof(char) * (samp->len + text_len) );\n\tmemcpy(samp->text + samp->len, text_data, sizeof(char) * text_len);\n\tsamp->len += text_len;\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*! sets UTF16 marker for text data. This MUST be called on an empty sample. If text data added later\non (cf below) is not formatted as UTF16 data(2 bytes char) the resulting text sample won't be compliant,\nbut this library won't warn\n\\param tx_samp the target text sample\n\\return error if any\n*/\nGF_Err gf_isom_text_set_utf16_marker(GF_TextSample *samp)\n{\n\t/*we MUST have an empty sample*/\n\tif (!samp || samp->text) return GF_BAD_PARAM;\n\tsamp->text = (char*)gf_malloc(sizeof(char) * 2);\n\tif (!samp->text) return GF_OUT_OF_MEM;\n\tsamp->text[0] = (char) 0xFE;\n\tsamp->text[1] = (char) 0xFF;\n\tsamp->len = 2;\n\treturn GF_OK;\n}\n#endif //unused\n\nGF_EXPORT\nGF_Err gf_isom_text_add_style(GF_TextSample *samp, GF_StyleRecord *rec)\n{\n\tif (!samp || !rec) return GF_BAD_PARAM;\n\n\tif (!samp->styles) {\n\t\tsamp->styles = (GF_TextStyleBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STYL);\n\t\tif (!samp->styles) return GF_OUT_OF_MEM;\n\t}\n\tsamp->styles->styles = (GF_StyleRecord*)gf_realloc(samp->styles->styles, sizeof(GF_StyleRecord)*(samp->styles->entry_count+1));\n\tif (!samp->styles->styles) return GF_OUT_OF_MEM;\n\tsamp->styles->styles[samp->styles->entry_count] = *rec;\n\tsamp->styles->entry_count++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_highlight(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextHighlightBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\tif (start_char == end_char) return GF_BAD_PARAM;\n\n\ta = (GF_TextHighlightBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HLIT);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_highlight_color(GF_TextSample *samp, u32 argb)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\n\tif (!samp->highlight_color) {\n\t\tsamp->highlight_color = (GF_TextHighlightColorBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_HCLR);\n\t\tif (!samp->highlight_color) return GF_OUT_OF_MEM;\n\t}\n\tsamp->highlight_color->hil_color = argb;\n\treturn GF_OK;\n}\n\n/*3GPP spec is quite obscur here*/\nGF_EXPORT\nGF_Err gf_isom_text_add_karaoke(GF_TextSample *samp, u32 start_time)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tsamp->cur_karaoke = (GF_TextKaraokeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_KROK);\n\tif (!samp->cur_karaoke) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->highlight_starttime = start_time;\n\treturn gf_list_add(samp->others, samp->cur_karaoke);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_karaoke_segment(GF_TextSample *samp, u32 end_time, u16 start_char, u16 end_char)\n{\n\tif (!samp || !samp->cur_karaoke) return GF_BAD_PARAM;\n\tsamp->cur_karaoke->records = (KaraokeRecord*)gf_realloc(samp->cur_karaoke->records, sizeof(KaraokeRecord)*(samp->cur_karaoke->nb_entries+1));\n\tif (!samp->cur_karaoke->records) return GF_OUT_OF_MEM;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].end_charoffset = end_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].start_charoffset = start_char;\n\tsamp->cur_karaoke->records[samp->cur_karaoke->nb_entries].highlight_endtime = end_time;\n\tsamp->cur_karaoke->nb_entries++;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_scroll_delay(GF_TextSample *samp, u32 scroll_delay)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->scroll_delay) {\n\t\tsamp->scroll_delay = (GF_TextScrollDelayBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_DLAY);\n\t\tif (!samp->scroll_delay) return GF_OUT_OF_MEM;\n\t}\n\tsamp->scroll_delay->scroll_delay = scroll_delay;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_hyperlink(GF_TextSample *samp, char *URL, char *altString, u16 start_char, u16 end_char)\n{\n\tGF_TextHyperTextBox*a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextHyperTextBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_HREF);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\ta->URL = URL ? gf_strdup(URL) : NULL;\n\ta->URL_hint = altString ? gf_strdup(altString) : NULL;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_box(GF_TextSample *samp, s16 top, s16 left, s16 bottom, s16 right)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->box) {\n\t\tsamp->box = (GF_TextBoxBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TBOX);\n\t\tif (!samp->box) return GF_OUT_OF_MEM;\n\t}\n\tsamp->box->box.top = top;\n\tsamp->box->box.left = left;\n\tsamp->box->box.bottom = bottom;\n\tsamp->box->box.right = right;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_add_blink(GF_TextSample *samp, u16 start_char, u16 end_char)\n{\n\tGF_TextBlinkBox *a;\n\tif (!samp) return GF_BAD_PARAM;\n\ta = (GF_TextBlinkBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_BLNK);\n\tif (!a) return GF_OUT_OF_MEM;\n\ta->startcharoffset = start_char;\n\ta->endcharoffset = end_char;\n\treturn gf_list_add(samp->others, a);\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_wrap(GF_TextSample *samp, u8 wrap_flags)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->wrap) {\n\t\tsamp->wrap = (GF_TextWrapBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TWRP);\n\t\tif (!samp->wrap) return GF_OUT_OF_MEM;\n\t}\n\tsamp->wrap->wrap_flag = wrap_flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_forced(GF_TextSample *samp, Bool is_forced)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tsamp->is_forced = is_forced;\n\treturn GF_OK;\n}\n\nstatic GFINLINE GF_Err gpp_write_modifier(GF_BitStream *bs, GF_Box *a)\n{\n\tGF_Err e;\n\tif (!a) return GF_OK;\n\te = gf_isom_box_size(a);\n\tif (!e) e = gf_isom_box_write(a, bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_sample_write_bs(const GF_TextSample *samp, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tif (!samp) return GF_BAD_PARAM;\n\n\tgf_bs_write_u16(bs, samp->len);\n\tif (samp->len) gf_bs_write_data(bs, samp->text, samp->len);\n\n\te = gpp_write_modifier(bs, (GF_Box *)samp->styles);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->highlight_color);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->scroll_delay);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->box);\n\tif (!e) e = gpp_write_modifier(bs, (GF_Box *)samp->wrap);\n\n\tif (!e && samp->is_forced) {\n\t\tgf_bs_write_u32(bs, 8);\n\t\tgf_bs_write_u32(bs, GF_QT_BOX_TYPE_FRCD);\n\t}\n\n\tif (!e) {\n\t\tGF_Box *a;\n\t\ti=0;\n\t\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\t\te = gpp_write_modifier(bs, a);\n\t\t\tif (e) break;\n\t\t}\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_text_to_sample(const GF_TextSample *samp)\n{\n\tGF_Err e;\n\tGF_ISOSample *res;\n\tGF_BitStream *bs;\n\tif (!samp) return NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\te = gf_isom_text_sample_write_bs(samp, bs);\n\n\tif (e) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tres = gf_isom_sample_new();\n\tif (!res) {\n\t\tgf_bs_del(bs);\n\t\treturn NULL;\n\t}\n\tgf_bs_get_content(bs, &res->data, &res->dataLength);\n\tgf_bs_del(bs);\n\tres->IsRAP = RAP;\n\treturn res;\n}\n\nu32 gf_isom_text_sample_size(GF_TextSample *samp)\n{\n\tGF_Box *a;\n\tu32 i, size;\n\tif (!samp) return 0;\n\n\tsize = 2 + samp->len;\n\tif (samp->styles) {\n\t\tgf_isom_box_size((GF_Box *)samp->styles);\n\t\tsize += (u32) samp->styles->size;\n\t}\n\tif (samp->highlight_color) {\n\t\tgf_isom_box_size((GF_Box *)samp->highlight_color);\n\t\tsize += (u32) samp->highlight_color->size;\n\t}\n\tif (samp->scroll_delay) {\n\t\tgf_isom_box_size((GF_Box *)samp->scroll_delay);\n\t\tsize += (u32) samp->scroll_delay->size;\n\t}\n\tif (samp->box) {\n\t\tgf_isom_box_size((GF_Box *)samp->box);\n\t\tsize += (u32) samp->box->size;\n\t}\n\tif (samp->wrap) {\n\t\tgf_isom_box_size((GF_Box *)samp->wrap);\n\t\tsize += (u32) samp->wrap->size;\n\t}\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(samp->others, &i))) {\n\t\tgf_isom_box_size((GF_Box *)a);\n\t\tsize += (u32) a->size;\n\t}\n\treturn size;\n}\n\n#if 0 //unused\n/*! checks if this text description is already inserted\n\\param isom_file the target ISO file\n\\param trackNumber the target track\n\\param desc the 3GPP text sample description to check\n\\param outDescIdx set to 0 if not found, or index of the matching sample description\n\\param same_styles indicates if default styles matches\n\\param same_box indicates if default box matches\n*/\nGF_Err gf_isom_text_has_similar_description(GF_ISOFile *movie, u32 trackNumber, GF_TextSampleDescriptor *desc, u32 *outDescIdx, Bool *same_box, Bool *same_styles)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 i, j, count;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\t*same_box = *same_styles = 0;\n\t*outDescIdx = 0;\n\n\tif (!desc) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !desc->font_count) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\tcase GF_ISOM_MEDIA_MPEG_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tBool same_fonts;\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!txt) continue;\n\t\tif ((txt->type != GF_ISOM_BOX_TYPE_TX3G) && (txt->type != GF_ISOM_BOX_TYPE_TEXT)) continue;\n\t\tif (txt->back_color != desc->back_color) continue;\n\t\tif (txt->displayFlags != desc->displayFlags) continue;\n\t\tif (txt->vertical_justification != desc->vert_justif) continue;\n\t\tif (txt->horizontal_justification != desc->horiz_justif) continue;\n\t\tif (txt->font_table->entry_count != desc->font_count) continue;\n\n\t\tsame_fonts = 1;\n\t\tfor (j=0; j<desc->font_count; j++) {\n\t\t\tif (txt->font_table->fonts[j].fontID != desc->fonts[j].fontID) same_fonts = 0;\n\t\t\telse if (strcmp(desc->fonts[j].fontName, txt->font_table->fonts[j].fontName)) same_fonts = 0;\n\t\t}\n\t\tif (same_fonts) {\n\t\t\t*outDescIdx = i+1;\n\t\t\tif (!memcmp(&txt->default_box, &desc->default_pos, sizeof(GF_BoxRecord))) *same_box = 1;\n\t\t\tif (!memcmp(&txt->default_style, &desc->default_style, sizeof(GF_StyleRecord))) *same_styles = 1;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\nGF_EXPORT\nGF_TextSample *gf_isom_new_text_sample()\n{\n\tGF_TextSample *res;\n\tGF_SAFEALLOC(res, GF_TextSample);\n\tif (!res) return NULL;\n\tres->others = gf_list_new();\n\treturn res;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset_styles(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->box) gf_isom_box_del((GF_Box *)samp->box);\n\tsamp->box = NULL;\n\tif (samp->highlight_color) gf_isom_box_del((GF_Box *)samp->highlight_color);\n\tsamp->highlight_color = NULL;\n\tif (samp->scroll_delay) gf_isom_box_del((GF_Box *)samp->scroll_delay);\n\tsamp->scroll_delay = NULL;\n\tif (samp->wrap) gf_isom_box_del((GF_Box *)samp->wrap);\n\tsamp->wrap = NULL;\n\tif (samp->styles) gf_isom_box_del((GF_Box *)samp->styles);\n\tsamp->styles = NULL;\n\tsamp->cur_karaoke = NULL;\n\twhile (gf_list_count(samp->others)) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(samp->others, 0);\n\t\tgf_list_rem(samp->others, 0);\n\t\tgf_isom_box_del(a);\n\t}\n\tsamp->is_forced = GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_reset(GF_TextSample *samp)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (samp->text) gf_free(samp->text);\n\tsamp->text = NULL;\n\tsamp->len = 0;\n\treturn gf_isom_text_reset_styles(samp);\n}\n\nGF_EXPORT\nvoid gf_isom_delete_text_sample(GF_TextSample * tx_samp)\n{\n\tgf_isom_text_reset(tx_samp);\n\tgf_list_del(tx_samp->others);\n\tgf_free(tx_samp);\n}\n\nGF_EXPORT\nGF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs)\n{\n\tGF_TextSample *s = gf_isom_new_text_sample();\n\n\t/*empty sample*/\n\tif (!bs || !gf_bs_available(bs)) return s;\n\n\ts->len = gf_bs_read_u16(bs);\n\tif (s->len) {\n\t\t/*2 extra bytes for UTF-16 term char just in case (we don't know if a BOM marker is present or\n\t\tnot since this may be a sample carried over RTP*/\n\t\ts->text = (char *) gf_malloc(sizeof(char)*(s->len+2) );\n\t\tif (!s->text) return NULL;\n\t\ts->text[s->len] = 0;\n\t\ts->text[s->len+1] = 0;\n\t\tgf_bs_read_data(bs, s->text, s->len);\n\t}\n\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a = NULL;\n\t\tGF_Err e = gf_isom_box_parse(&a, bs);\n\t\tif (e) {\n\t\t\tif (a) gf_isom_box_del(a);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (a->type) {\n\t\tcase GF_ISOM_BOX_TYPE_STYL:\n\t\t\tif (s->styles) {\n\t\t\t\tGF_TextStyleBox *st2 = (GF_TextStyleBox *)a;\n\t\t\t\tif (!s->styles->entry_count) {\n\t\t\t\t\tgf_isom_box_del((GF_Box*)s->styles);\n\t\t\t\t\ts->styles = st2;\n\t\t\t\t} else {\n\t\t\t\t\ts->styles->styles = (GF_StyleRecord*)gf_realloc(s->styles->styles, sizeof(GF_StyleRecord) * (s->styles->entry_count + st2->entry_count));\n\t\t\t\t\tmemcpy(&s->styles->styles[s->styles->entry_count], st2->styles, sizeof(GF_StyleRecord) * st2->entry_count);\n\t\t\t\t\ts->styles->entry_count += st2->entry_count;\n\t\t\t\t\tgf_isom_box_del(a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts->styles = (GF_TextStyleBox*)a;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_KROK:\n\t\t\ts->cur_karaoke = (GF_TextKaraokeBox*)a;\n\t\tcase GF_ISOM_BOX_TYPE_HLIT:\n\t\tcase GF_ISOM_BOX_TYPE_HREF:\n\t\tcase GF_ISOM_BOX_TYPE_BLNK:\n\t\t\tgf_list_add(s->others, a);\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HCLR:\n\t\t\tif (s->highlight_color) gf_isom_box_del(a);\n\t\t\telse s->highlight_color = (GF_TextHighlightColorBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_DLAY:\n\t\t\tif (s->scroll_delay) gf_isom_box_del(a);\n\t\t\telse s->scroll_delay= (GF_TextScrollDelayBox*) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TBOX:\n\t\t\tif (s->box) gf_isom_box_del(a);\n\t\t\telse s->box= (GF_TextBoxBox *) a;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_TWRP:\n\t\t\tif (s->wrap) gf_isom_box_del(a);\n\t\t\telse s->wrap= (GF_TextWrapBox*) a;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRCD:\n\t\t\ts->is_forced = GF_TRUE;\n\t\t\tgf_isom_box_del(a);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgf_isom_box_del(a);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn s;\n}\n\n#if 0 //unused\nGF_TextSample *gf_isom_parse_text_sample_from_data(u8 *data, u32 dataLength)\n{\n\tGF_TextSample *s;\n\tGF_BitStream *bs;\n\t/*empty text sample*/\n\tif (!data || !dataLength) {\n\t\treturn gf_isom_new_text_sample();\n\t}\n\n\tbs = gf_bs_new(data, dataLength, GF_BITSTREAM_READ);\n\ts = gf_isom_parse_text_sample(bs);\n\tgf_bs_del(bs);\n\treturn s;\n}\n#endif\n\n\n/*out-of-band sample desc (128 and 255 reserved in RFC)*/\n#define SAMPLE_INDEX_OFFSET\t\t129\n\n\nstatic void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = 0; //todo expose qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nGF_Err gf_isom_get_ttxt_esd(GF_MediaBox *mdia, GF_ESD **out_esd)\n{\n\tGF_BitStream *bs;\n\tu32 count, i;\n\tBool has_v_info;\n\tGF_List *sampleDesc;\n\tGF_ESD *esd;\n\tGF_TrackBox *tk;\n\n\t*out_esd = NULL;\n\tsampleDesc = mdia->information->sampleTable->SampleDescription->child_boxes;\n\tcount = gf_list_count(sampleDesc);\n\tif (!count) return GF_ISOM_INVALID_MEDIA;\n\n\tesd = gf_odf_desc_esd_new(2);\n\tesd->decoderConfig->streamType = GF_STREAM_TEXT;\n\tesd->decoderConfig->objectTypeIndication = GF_CODECID_TEXT_MPEG4;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\n\t/*Base3GPPFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*MPEGExtendedFormat*/\n\tgf_bs_write_u8(bs, 0x10);\n\t/*profileLevel*/\n\tgf_bs_write_u8(bs, 0x10);\n\tgf_bs_write_u24(bs, mdia->mediaHeader->timeScale);\n\tgf_bs_write_int(bs, 0, 1);\t/*no alt formats*/\n\tgf_bs_write_int(bs, 2, 2);\t/*only out-of-band-band sample desc*/\n\tgf_bs_write_int(bs, 1, 1);\t/*we will write sample desc*/\n\n\t/*write v info if any visual track in this movie*/\n\thas_v_info = 0;\n\ti=0;\n\twhile ((tk = (GF_TrackBox*)gf_list_enum(mdia->mediaTrack->moov->trackList, &i))) {\n\t\tif (tk->Media->handler && (tk->Media->handler->handlerType == GF_ISOM_MEDIA_VISUAL)) {\n\t\t\thas_v_info = 1;\n\t\t}\n\t}\n\tgf_bs_write_int(bs, has_v_info, 1);\n\n\tgf_bs_write_int(bs, 0, 3);\t/*reserved, spec doesn't say the values*/\n\tgf_bs_write_u8(bs, mdia->mediaTrack->Header->layer);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->width>>16);\n\tgf_bs_write_u16(bs, mdia->mediaTrack->Header->height>>16);\n\n\t/*write desc*/\n\tgf_bs_write_u8(bs, count);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Tx3gSampleEntryBox *a;\n\t\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(sampleDesc, i);\n\t\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT) ) continue;\n\t\tgf_isom_write_tx3g(a, bs, i+1, SAMPLE_INDEX_OFFSET);\n\t}\n\tif (has_v_info) {\n\t\tu32 trans;\n\t\t/*which video shall we pick for MPEG-4, and how is the associations indicated in 3GP ???*/\n\t\tgf_bs_write_u16(bs, 0);\n\t\tgf_bs_write_u16(bs, 0);\n\t\ttrans = mdia->mediaTrack->Header->matrix[6];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t\ttrans = mdia->mediaTrack->Header->matrix[7];\n\t\ttrans >>= 16;\n\t\tgf_bs_write_u16(bs, trans);\n\t}\n\n\tgf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);\n\tgf_bs_del(bs);\n\t*out_esd = esd;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_rewrite_text_sample(GF_ISOSample *samp, u32 sampleDescriptionIndex, u32 sample_dur)\n{\n\tGF_BitStream *bs;\n\tu32 pay_start, txt_size;\n\tBool is_utf_16 = 0;\n\tif (!samp || !samp->data || !samp->dataLength) return GF_OK;\n\n\tbs = gf_bs_new(samp->data, samp->dataLength, GF_BITSTREAM_READ);\n\ttxt_size = gf_bs_read_u16(bs);\n\tgf_bs_del(bs);\n\n\t/*remove BOM*/\n\tpay_start = 2;\n\tif (txt_size>2) {\n\t\t/*seems 3GP only accepts BE UTF-16 (no LE, no UTF32)*/\n\t\tif (((u8) samp->data[2]==(u8) 0xFE) && ((u8)samp->data[3]==(u8) 0xFF)) {\n\t\t\tis_utf_16 = 1;\n\t\t\tpay_start = 4;\n\t\t\ttxt_size -= 2;\n\t\t}\n\t}\n\n\t/*rewrite as TTU(1)*/\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_bs_write_int(bs, is_utf_16, 1);\n\tgf_bs_write_int(bs, 0, 4);\n\tgf_bs_write_int(bs, 1, 3);\n\tgf_bs_write_u16(bs, 8 + samp->dataLength - pay_start);\n\tgf_bs_write_u8(bs, sampleDescriptionIndex + SAMPLE_INDEX_OFFSET);\n\tgf_bs_write_u24(bs, sample_dur);\n\t/*write text size*/\n\tgf_bs_write_u16(bs, txt_size);\n\tif (txt_size) gf_bs_write_data(bs, samp->data + pay_start, samp->dataLength - pay_start);\n\n\tgf_free(samp->data);\n\tsamp->data = NULL;\n\tgf_bs_get_content(bs, &samp->data, &samp->dataLength);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\t*tx3g = NULL;\n\t*tx3g_size = 0;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_write_tx3g(a, bs, sidx, sidx_offset);\n\tgf_bs_get_content(bs, tx3g, tx3g_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_forced_text(GF_ISOFile *file, u32 track, u32 stsd_idx, u32 flags)\n{\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tswitch (flags) {\n\tcase 2:\n\t\ta->displayFlags |= GF_TXT_SOME_SAMPLES_FORCED | GF_TXT_ALL_SAMPLES_FORCED;\n\t\tbreak;\n\tcase 1:\n\t\ta->displayFlags |= GF_TXT_SOME_SAMPLES_FORCED;\n\t\ta->displayFlags &= ~GF_TXT_ALL_SAMPLES_FORCED;\n\t\tbreak;\n\tdefault:\n\t\ta->displayFlags &= ~GF_TXT_SOME_SAMPLES_FORCED;\n\t\ta->displayFlags &= ~GF_TXT_ALL_SAMPLES_FORCED;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/filters/isoffin_load.c", "src/filters/mux_isom.c", "src/isomedia/media.c", "src/isomedia/tx3g.c"], "buggy_code_start_loc": [92, 1030, 394, 105], "buggy_code_end_loc": [1954, 8396, 1075, 669], "fixing_code_start_loc": [92, 1030, 395, 105], "fixing_code_end_loc": [1950, 8394, 1077, 674], "type": "NVD-CWE-noinfo", "message": "Denial of Service in GitHub repository gpac/gpac prior to 2.3.0-DEV.", "other": {"cve": {"id": "CVE-2023-5595", "sourceIdentifier": "security@huntr.dev", "published": "2023-10-16T09:15:12.090", "lastModified": "2023-10-20T15:09:44.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Denial of Service in GitHub repository gpac/gpac prior to 2.3.0-DEV."}, {"lang": "es", "value": "Denegaci\u00f3n de Servicio en el repositorio de GitHub gpac/gpac anterior a la versi\u00f3n 2.3.0-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 2.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3.0", "matchCriteriaId": "8427BDFE-346D-45C9-B0BD-1F06E8825368"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/7a6f636db3360bb16d18078d51e8c596f31302a1", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/0064cf76-ece1-495d-82b4-e4a1bebeb28e", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/7a6f636db3360bb16d18078d51e8c596f31302a1"}}