{"buggy_code": ["// imagew-bmp.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n#include \"imagew-config.h\"\n\n#include <stdio.h> // for SEEK_SET\n#include <stdlib.h>\n#include <string.h>\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\n#define IWBMP_BI_RGB       0 // = uncompressed\n#define IWBMP_BI_RLE8      1\n#define IWBMP_BI_RLE4      2\n#define IWBMP_BI_BITFIELDS 3\n#define IWBMP_BI_JPEG      4\n#define IWBMP_BI_PNG       5\n\n#define IWBMPCS_CALIBRATED_RGB    0\n#define IWBMPCS_DEVICE_RGB        1 // (Unconfirmed)\n#define IWBMPCS_DEVICE_CMYK       2 // (Unconfirmed)\n#define IWBMPCS_SRGB              0x73524742\n#define IWBMPCS_WINDOWS           0x57696e20\n#define IWBMPCS_PROFILE_LINKED    0x4c494e4b\n#define IWBMPCS_PROFILE_EMBEDDED  0x4d424544\n\nstatic size_t iwbmp_calc_bpr(int bpp, size_t width)\n{\n\treturn ((bpp*width+31)/32)*4;\n}\n\nstruct iwbmprcontext {\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\tint bmpversion;\n\tint width, height;\n\tint topdown;\n\tint has_fileheader;\n\tunsigned int bitcount; // bits per pixel\n\tunsigned int compression; // IWBMP_BI_*\n\tint uses_bitfields; // 'compression' is BI_BITFIELDS\n\tint has_alpha_channel;\n\tint bitfields_set;\n\tint need_16bit;\n\tunsigned int palette_entries;\n\tsize_t fileheader_size;\n\tsize_t infoheader_size;\n\tsize_t bitfields_nbytes; // Bytes consumed by BITFIELDs, if not part of the header.\n\tsize_t palette_nbytes;\n\tsize_t bfOffBits;\n\tstruct iw_palette palette;\n\n\t// For 16- & 32-bit images:\n\tunsigned int bf_mask[4];\n\tint bf_high_bit[4];\n\tint bf_low_bit[4];\n\tint bf_bits_count[4]; // number of bits in each channel\n\n\tstruct iw_csdescr csdescr;\n};\n\nstatic int iwbmp_read(struct iwbmprcontext *rctx,\n\t\tiw_byte *buf, size_t buflen)\n{\n\tint ret;\n\tsize_t bytesread = 0;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\tbuf,buflen,&bytesread);\n\tif(!ret || bytesread!=buflen) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwbmp_skip_bytes(struct iwbmprcontext *rctx, size_t n)\n{\n\tiw_byte buf[1024];\n\tsize_t still_to_read;\n\tsize_t num_to_read;\n\n\tstill_to_read = n;\n\twhile(still_to_read>0) {\n\t\tnum_to_read = still_to_read;\n\t\tif(num_to_read>1024) num_to_read=1024;\n\t\tif(!iwbmp_read(rctx,buf,num_to_read)) {\n\t\t\treturn 0;\n\t\t}\n\t\tstill_to_read -= num_to_read;\n\t}\n\treturn 1;\n}\n\nstatic int iwbmp_read_file_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[14];\n\n\tif(!iwbmp_read(rctx,buf,14)) return 0;\n\trctx->fileheader_size = 14;\n\n\tif(buf[0]=='B' && buf[1]=='A') { // OS/2 Bitmap Array\n\t\t// TODO: This type of file can contain more than one BMP image.\n\t\t// We only support the first one.\n\t\tif(!iwbmp_read(rctx,buf,14)) return 0;\n\t\trctx->fileheader_size += 14;\n\t}\n\n\tif(buf[0]=='B' && buf[1]=='M') {\n\t\t;\n\t}\n\telse if((buf[0]=='C' && buf[1]=='I') || // OS/2 Color Icon\n\t   (buf[0]=='C' && buf[1]=='P') || // OS/2 Color Pointer\n\t   (buf[0]=='I' && buf[1]=='C') || // OS/2 Icon\n\t   (buf[0]=='P' && buf[1]=='T'))   // OS/2 Pointer\n\t{\n\t\tiw_set_error(rctx->ctx,\"This type of BMP file is not supported\");\n\t\treturn 0;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\"Not a BMP file\");\n\t\treturn 0;\n\t}\n\n\trctx->bfOffBits = iw_get_ui32le(&buf[10]);\n\treturn 1;\n}\n\n// Read the 12-byte header of a Windows v2 BMP (also known as OS/2 v1 BMP).\nstatic int decode_v2_header(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\n\trctx->width = iw_get_ui16le(&buf[4]);\n\trctx->height = iw_get_ui16le(&buf[6]);\n\tnplanes = iw_get_ui16le(&buf[8]);\n\tif(nplanes!=1) return 0;\n\trctx->bitcount = iw_get_ui16le(&buf[10]);\n\tif(rctx->bitcount!=1 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=24)\n\t{\n\t\treturn 0;\n\t}\n\tif(rctx->bitcount<=8) {\n\t\tsize_t palette_start, palette_end;\n\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\n\t\t// Since v2 BMPs have no direct way to indicate that the palette is not\n\t\t// full-sized, assume the palette ends no later than the start of the\n\t\t// bitmap bits.\n\t\tpalette_start = rctx->fileheader_size + rctx->infoheader_size;\n\t\tpalette_end = palette_start + rctx->palette_nbytes;\n\t\tif(rctx->bfOffBits >= palette_start+3 && rctx->bfOffBits < palette_end) {\n\t\t\trctx->palette_entries = (unsigned int)((rctx->bfOffBits - palette_start)/3);\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\treturn 1;\n}\n\n// Read a Windows v3 or OS/2 v2 header.\nstatic int decode_v3_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\tint biXPelsPerMeter, biYPelsPerMeter;\n\tunsigned int biClrUsed = 0;\n\t//unsigned int biSizeImage;\n\n\trctx->width = iw_get_i32le(&buf[4]);\n\trctx->height = iw_get_i32le(&buf[8]);\n\tif(rctx->height<0) {\n\t\trctx->height = -rctx->height;\n\t\trctx->topdown = 1;\n\t}\n\n\tnplanes = iw_get_ui16le(&buf[12]);\n\tif(nplanes!=1) return 0;\n\n\trctx->bitcount = iw_get_ui16le(&buf[14]);\n\t// We allow bitcount=2 because it's legal in Windows CE BMPs.\n\tif(rctx->bitcount!=1 && rctx->bitcount!=2 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=16 && rctx->bitcount!=24 &&\n\t\trctx->bitcount!=32)\n\t{\n\t\tiw_set_errorf(rctx->ctx,\"Bad or unsupported bit count (%d)\",(int)rctx->bitcount);\n\t\treturn 0;\n\t}\n\n\tif(rctx->infoheader_size<=16) {\n\t\tgoto infoheaderdone;\n\t}\n\n\trctx->compression = iw_get_ui32le(&buf[16]);\n\tif(rctx->compression==IWBMP_BI_BITFIELDS) {\n\t\tif(rctx->bitcount==1) {\n\t\t\tiw_set_error(rctx->ctx,\"Huffman 1D compression not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(rctx->bitcount!=16 && rctx->bitcount!=32) {\n\t\t\tiw_set_error(rctx->ctx,\"Bad or unsupported image type\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// The compression field is overloaded: BITFIELDS is not a type of\n\t\t// compression. Un-overload it.\n\t\trctx->uses_bitfields = 1;\n\n\t\t// The v4/v5 documentation for the \"BitCount\" field says that the\n\t\t// BITFIELDS data comes after the header, the same as with v3.\n\t\t// The v4/v5 documentation for the \"Compression\" field says that the\n\t\t// BITFIELDS data is stored in the \"Mask\" fields of the header.\n\t\t// Am I supposed to conclude that it is redundantly stored in both\n\t\t// places?\n\t\t// Evidence and common sense suggests the \"BitCount\" documentation is\n\t\t// incorrect, and v4/v5 BMPs never have a separate \"bitfields\" segment.\n\t\tif(rctx->bmpversion==3) {\n\t\t\trctx->bitfields_nbytes = 12;\n\t\t}\n\n\t\trctx->compression=IWBMP_BI_RGB;\n\t}\n\n\t//biSizeImage = iw_get_ui32le(&buf[20]);\n\tbiXPelsPerMeter = iw_get_i32le(&buf[24]);\n\tbiYPelsPerMeter = iw_get_i32le(&buf[28]);\n\n\trctx->img->density_code = IW_DENSITY_UNITS_PER_METER;\n\trctx->img->density_x = (double)biXPelsPerMeter;\n\trctx->img->density_y = (double)biYPelsPerMeter;\n\tif(!iw_is_valid_density(rctx->img->density_x,rctx->img->density_y,rctx->img->density_code)) {\n\t\trctx->img->density_code=IW_DENSITY_UNKNOWN;\n\t}\n\n\tbiClrUsed = iw_get_ui32le(&buf[32]);\n\tif(biClrUsed>100000) return 0;\n\ninfoheaderdone:\n\t// The documentation of the biClrUsed field is not very clear.\n\t// I'm going to assume that if biClrUsed is 0 and bitcount<=8, then\n\t// the number of palette colors is the maximum that would be useful\n\t// for that bitcount. In all other cases, the number of palette colors\n\t// equals biClrUsed.\n\tif(biClrUsed==0 && rctx->bitcount<=8) {\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t}\n\telse {\n\t\trctx->palette_entries = biClrUsed;\n\t}\n\trctx->palette_nbytes = 4*rctx->palette_entries;\n\treturn 1;\n}\n\nstatic int process_bf_mask(struct iwbmprcontext *rctx, int k);\n\n// Decode the fields that are in v4 and not in v3.\nstatic int decode_v4_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tint k;\n\tunsigned int cstype;\n\n\tif(rctx->uses_bitfields) {\n\t\t// Set the bitfields masks here, instead of in iwbmp_read_bitfields().\n\t\tfor(k=0;k<4;k++) {\n\t\t\trctx->bf_mask[k] = 0;\n\t\t}\n\t\tfor(k=0;k<4;k++) {\n\t\t\tif(rctx->infoheader_size < (size_t)(40+k*4+4)) break;\n\t\t\trctx->bf_mask[k] = iw_get_ui32le(&buf[40+k*4]);\n\t\t\tif(!process_bf_mask(rctx,k)) return 0;\n\t\t}\n\t\trctx->bitfields_set=1; // Remember not to overwrite the bf_* fields.\n\n\t\tif(rctx->bf_mask[3]!=0) {\n\t\t\t// The documentation says this is the mask that \"specifies the\n\t\t\t// alpha component of each pixel.\"\n\t\t\t// It doesn't say whther it's associated, or unassociated alpha.\n\t\t\t// It doesn't say whether 0=transparent, or 0=opaque.\n\t\t\t// It doesn't say how to tell whether an image has an alpha\n\t\t\t// channel.\n\t\t\t// These are the answers I'm going with:\n\t\t\t// - Unassociated alpha\n\t\t\t// - 0=transparent\n\t\t\t// - 16- and 32-bit images have an alpha channel if 'compression'\n\t\t\t// is set to BI_BITFIELDS, and this alpha mask is nonzero.\n\t\t\trctx->has_alpha_channel = 1;\n\t\t}\n\t}\n\n\tif(rctx->infoheader_size < 108) return 1;\n\n\tcstype = iw_get_ui32le(&buf[56]);\n\tswitch(cstype) {\n\tcase IWBMPCS_CALIBRATED_RGB:\n\t\t//  \"indicates that endpoints and gamma values are given in the\n\t\t//    appropriate fields.\"  (TODO)\n\t\tbreak;\n\n\tcase IWBMPCS_DEVICE_RGB:\n\tcase IWBMPCS_SRGB:\n\tcase IWBMPCS_WINDOWS:\n\t\tbreak;\n\n\tcase IWBMPCS_PROFILE_LINKED:\n\tcase IWBMPCS_PROFILE_EMBEDDED:\n\t\tif(rctx->bmpversion<5) {\n\t\t\tiw_warning(rctx->ctx,\"Invalid colorspace type for BMPv4\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tiw_warningf(rctx->ctx,\"Unrecognized or unsupported colorspace type (0x%x)\",cstype);\n\t}\n\n\t// Read Gamma fields\n\tif(cstype==IWBMPCS_CALIBRATED_RGB) {\n\t\tunsigned int bmpgamma;\n\t\tdouble gamma[3];\n\t\tdouble avggamma;\n\n\t\tfor(k=0;k<3;k++) {\n\t\t\tbmpgamma = iw_get_ui32le(&buf[96+k*4]);\n\t\t\tgamma[k] = ((double)bmpgamma)/65536.0;\n\t\t}\n\t\tavggamma = (gamma[0] + gamma[1] + gamma[2])/3.0;\n\n\t\tif(avggamma>=0.1 && avggamma<=10.0) {\n\t\t\tiw_make_gamma_csdescr(&rctx->csdescr,1.0/avggamma);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n// Decode the fields that are in v5 and not in v4.\nstatic int decode_v5_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int intent_bmp_style;\n\tint intent_iw_style;\n\n\tintent_bmp_style = iw_get_ui32le(&buf[108]);\n\tintent_iw_style = IW_INTENT_UNKNOWN;\n\tswitch(intent_bmp_style) {\n\t\tcase 1: intent_iw_style = IW_INTENT_SATURATION; break; // LCS_GM_BUSINESS\n\t\tcase 2: intent_iw_style = IW_INTENT_RELATIVE; break; // LCS_GM_GRAPHICS\n\t\tcase 4: intent_iw_style = IW_INTENT_PERCEPTUAL; break; // LCS_GM_IMAGES\n\t\tcase 8: intent_iw_style = IW_INTENT_ABSOLUTE; break; // LCS_GM_ABS_COLORIMETRIC\n\t}\n\trctx->img->rendering_intent = intent_iw_style;\n\n\t// The profile may either be after the color table, or after the bitmap bits.\n\t// I'm assuming that we will never need to use the profile size in order to\n\t// find the bitmap bits; i.e. that if the bfOffBits field in the file header\n\t// is not available, the profile must be after the bits.\n\t//profile_offset = iw_get_ui32le(&buf[112]); // bV5ProfileData;\n\t//profile_size = iw_get_ui32le(&buf[116]); // bV5ProfileSize;\n\n\treturn 1;\n}\n\nstatic int iwbmp_read_info_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[124];\n\tint retval = 0;\n\tsize_t n;\n\n\t// First, read just the \"size\" field. It tells the size of the header\n\t// structure, and identifies the BMP version.\n\tif(!iwbmp_read(rctx,buf,4)) goto done;\n\trctx->infoheader_size = iw_get_ui32le(&buf[0]);\n\tif(rctx->infoheader_size<12) goto done;\n\n\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \"Windows BMP v2\" or \"OS/2 BMP v1\" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\"Unsupported BMP version\");\n\t\tgoto done;\n\t}\n\n\tif(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {\n\t\tgoto done;\n\t}\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}\n\n// Find the highest/lowest bit that is set.\nstatic int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}\nstatic int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}\n\n// Given .bf_mask[k], set high_bit[k], low_bit[k], etc.\nstatic int process_bf_mask(struct iwbmprcontext *rctx, int k)\n{\n\t// The bits representing the mask for each channel are required to be\n\t// contiguous, so all we need to do is find the highest and lowest bit.\n\trctx->bf_high_bit[k] = find_high_bit(rctx->bf_mask[k]);\n\trctx->bf_low_bit[k] = find_low_bit(rctx->bf_mask[k]);\n\trctx->bf_bits_count[k] = 1+rctx->bf_high_bit[k]-rctx->bf_low_bit[k];\n\n\t// Check if the mask specifies an invalid bit\n\tif(rctx->bf_high_bit[k] > (int)(rctx->bitcount-1)) return 0;\n\n\tif(rctx->bf_bits_count[k]>16) {\n\t\t// We only support up to 16 bits. Ignore any bits after the 16th.\n\t\trctx->bf_low_bit[k] = rctx->bf_high_bit[k]-15;\n\t\trctx->bf_bits_count[k] = 16;\n\t}\n\n\tif(rctx->bf_bits_count[k]>8) {\n\t\trctx->need_16bit = 1;\n\t}\n\n\treturn 1;\n}\n\nstatic int iwbmp_read_bitfields(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[12];\n\tint k;\n\n\tif(!iwbmp_read(rctx,buf,12)) return 0;\n\n\tfor(k=0;k<3;k++) {\n\t\trctx->bf_mask[k] = iw_get_ui32le(&buf[k*4]);\n\t\tif(rctx->bf_mask[k]==0) return 0;\n\n\t\t// Find the high bit, low bit, etc.\n\t\tif(!process_bf_mask(rctx,k)) return 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void iwbmp_set_default_bitfields(struct iwbmprcontext *rctx)\n{\n\tint k;\n\n\tif(rctx->bitfields_set) return;\n\n\tif(rctx->bitcount==16) {\n\t\t// Default is 5 bits for each channel.\n\t\trctx->bf_mask[0]=0x7c00; // 01111100 00000000 (red)\n\t\trctx->bf_mask[1]=0x03e0; // 00000011 11100000 (green)\n\t\trctx->bf_mask[2]=0x001f; // 00000000 00011111 (blue)\n\t}\n\telse if(rctx->bitcount==32) {\n\t\trctx->bf_mask[0]=0x00ff0000;\n\t\trctx->bf_mask[1]=0x0000ff00;\n\t\trctx->bf_mask[2]=0x000000ff;\n\t}\n\telse {\n\t\treturn;\n\t}\n\n\tfor(k=0;k<3;k++) {\n\t\tprocess_bf_mask(rctx,k);\n\t}\n}\n\nstatic int iwbmp_read_palette(struct iwbmprcontext *rctx)\n{\n\tsize_t i;\n\tiw_byte buf[4*256];\n\tsize_t b;\n\tunsigned int valid_palette_entries;\n\tsize_t valid_palette_nbytes;\n\n\tb = (rctx->bmpversion==2) ? 3 : 4; // bytes per palette entry\n\n\tif(rctx->infoheader_size==64) {\n\t\t// According to what little documentation I can find, OS/2v2 BMP files\n\t\t// have 4 bytes per palette entry. But some of the files I've seen have\n\t\t// only 3. This is a little hack to support them.\n\t\tif(rctx->fileheader_size + rctx->infoheader_size + rctx->palette_entries*3 ==\n\t\t\trctx->bfOffBits)\n\t\t{\n\t\t\tiw_warning(rctx->ctx,\"BMP bitmap overlaps colormap; assuming colormap uses 3 bytes per entry instead of 4\");\n\t\t\tb = 3;\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\n\t// If the palette has >256 colors, only use the first 256.\n\tvalid_palette_entries = (rctx->palette_entries<=256) ? rctx->palette_entries : 256;\n\tvalid_palette_nbytes = valid_palette_entries * b;\n\n\n\tif(!iwbmp_read(rctx,buf,valid_palette_nbytes)) return 0;\n\trctx->palette.num_entries = valid_palette_entries;\n\tfor(i=0;i<valid_palette_entries;i++) {\n\t\trctx->palette.entry[i].b = buf[i*b+0];\n\t\trctx->palette.entry[i].g = buf[i*b+1];\n\t\trctx->palette.entry[i].r = buf[i*b+2];\n\t\trctx->palette.entry[i].a = 255;\n\t}\n\n\t// If the palette is oversized, skip over the unused part of it.\n\tif(rctx->palette_nbytes > valid_palette_nbytes) {\n\t\tiwbmp_skip_bytes(rctx, rctx->palette_nbytes - valid_palette_nbytes);\n\t}\n\treturn 1;\n}\n\nstatic void bmpr_convert_row_32_16(struct iwbmprcontext *rctx, const iw_byte *src, size_t row)\n{\n\tint i,k;\n\tunsigned int v,x;\n\tint numchannels;\n\n\tnumchannels = rctx->has_alpha_channel ? 4 : 3;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tif(rctx->bitcount==32) {\n\t\t\tx = ((unsigned int)src[i*4+0]) | ((unsigned int)src[i*4+1])<<8 |\n\t\t\t\t((unsigned int)src[i*4+2])<<16 | ((unsigned int)src[i*4+3])<<24;\n\t\t}\n\t\telse { // 16\n\t\t\tx = ((unsigned int)src[i*2+0]) | ((unsigned int)src[i*2+1])<<8;\n\t\t}\n\t\tv = 0;\n\t\tfor(k=0;k<numchannels;k++) { // For red, green, blue [, alpha]:\n\t\t\tv = x & rctx->bf_mask[k];\n\t\t\tif(rctx->bf_low_bit[k]>0)\n\t\t\t\tv >>= rctx->bf_low_bit[k];\n\t\t\tif(rctx->img->bit_depth==16) {\n\t\t\t\trctx->img->pixels[row*rctx->img->bpr + i*numchannels*2 + k*2+0] = (iw_byte)(v>>8);\n\t\t\t\trctx->img->pixels[row*rctx->img->bpr + i*numchannels*2 + k*2+1] = (iw_byte)(v&0xff);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trctx->img->pixels[row*rctx->img->bpr + i*numchannels + k] = (iw_byte)v;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bmpr_convert_row_24(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tfor(i=0;i<rctx->width;i++) {\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = src[i*3+2];\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = src[i*3+1];\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = src[i*3+0];\n\t}\n}\n\nstatic void bmpr_convert_row_8(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tfor(i=0;i<rctx->width;i++) {\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[src[i]].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[src[i]].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[src[i]].b;\n\t}\n}\n\nstatic void bmpr_convert_row_4(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tint pal_index;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tpal_index = (i&0x1) ? src[i/2]&0x0f : src[i/2]>>4;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;\n\t}\n}\n\nstatic void bmpr_convert_row_2(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tint pal_index;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tpal_index = (src[i/4]>>(2*(3-i%4)))&0x03;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;\n\t}\n}\n\nstatic void bmpr_convert_row_1(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tint pal_index;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tpal_index = (src[i/8] & (1<<(7-i%8))) ? 1 : 0;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;\n\t}\n}\n\nstatic int bmpr_read_uncompressed(struct iwbmprcontext *rctx)\n{\n\tiw_byte *rowbuf = NULL;\n\tsize_t bmp_bpr;\n\tint j;\n\tint retval = 0;\n\n\tif(rctx->has_alpha_channel) {\n\t\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\t\t\n\t\trctx->img->bit_depth = rctx->need_16bit ? 16 : 8;\n\t\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,4*rctx->img->bit_depth);\n\t}\n\telse {\n\t\trctx->img->imgtype = IW_IMGTYPE_RGB;\n\t\trctx->img->bit_depth = rctx->need_16bit ? 16 : 8;\n\t\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,3*rctx->img->bit_depth);\n\t}\n\n\tbmp_bpr = iwbmp_calc_bpr(rctx->bitcount,rctx->width);\n\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\n\trowbuf = iw_malloc(rctx->ctx,bmp_bpr);\n\n\tfor(j=0;j<rctx->img->height;j++) {\n\t\t// Read a row of the BMP file.\n\t\tif(!iwbmp_read(rctx,rowbuf,bmp_bpr)) {\n\t\t\tgoto done;\n\t\t}\n\t\tswitch(rctx->bitcount) {\n\t\tcase 32:\n\t\tcase 16:\n\t\t\tbmpr_convert_row_32_16(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tbmpr_convert_row_24(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tbmpr_convert_row_8(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tbmpr_convert_row_4(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbmpr_convert_row_2(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbmpr_convert_row_1(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tretval = 1;\ndone:\n\tif(rowbuf) iw_free(rctx->ctx,rowbuf);\n\treturn retval;\n}\n\n// Read and decompress RLE8 or RLE4-compressed bits, and write pixels to\n// rctx->img->pixels.\nstatic int bmpr_read_rle_internal(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\tint pos_x, pos_y;\n\tiw_byte buf[255];\n\tsize_t n_pix;\n\tsize_t n_bytes;\n\tsize_t i;\n\tsize_t pal_index;\n\n\t// The position of the next pixel to set.\n\t// pos_y is in IW coordinates (top=0), not BMP coordinates (bottom=0).\n\tpos_x = 0;\n\tpos_y = 0;\n\n\t// Initially make all pixels transparent, so that any any pixels we\n\t// don't modify will be transparent.\n\tiw_zeromem(rctx->img->pixels,rctx->img->bpr*rctx->img->height);\n\n\twhile(1) {\n\t\t// If we've reached the end of the bitmap, stop.\n\t\tif(pos_y>rctx->img->height-1) break;\n\t\tif(pos_y==rctx->img->height-1 && pos_x>=rctx->img->width) break;\n\n\t\tif(!iwbmp_read(rctx,buf,2)) goto done;\n\t\tif(buf[0]==0) {\n\t\t\tif(buf[1]==0) {\n\t\t\t\t// End of Line\n\t\t\t\tpos_y++;\n\t\t\t\tpos_x=0;\n\t\t\t}\n\t\t\telse if(buf[1]==1) {\n\t\t\t\t// (Premature) End of Bitmap\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(buf[1]==2) {\n\t\t\t\t// DELTA: The next two bytes are unsigned values representing\n\t\t\t\t// the relative position of the next pixel from the \"current\n\t\t\t\t// position\".\n\t\t\t\t// I interpret \"current position\" to mean the position at which\n\t\t\t\t// the next pixel would normally have been.\n\t\t\t\tif(!iwbmp_read(rctx,buf,2)) goto done;\n\n\t\t\t\tif(pos_x<rctx->img->width) pos_x += buf[0];\n\t\t\t\tpos_y += buf[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A uncompressed segment\n\t\t\t\tn_pix = (size_t)buf[1]; // Number of uncompressed pixels which follow\n\t\t\t\tif(rctx->compression==IWBMP_BI_RLE4) {\n\t\t\t\t\tn_bytes = ((n_pix+3)/4)*2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tn_bytes = ((n_pix+1)/2)*2;\n\t\t\t\t}\n\t\t\t\tif(!iwbmp_read(rctx,buf,n_bytes)) goto done;\n\t\t\t\tfor(i=0;i<n_pix;i++) {\n\t\t\t\t\tif(pos_x<rctx->img->width) {\n\t\t\t\t\t\tif(rctx->compression==IWBMP_BI_RLE4) {\n\t\t\t\t\t\t\tpal_index = (i%2) ? buf[i/2]&0x0f : buf[i/2]>>4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpal_index = buf[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;\n\t\t\t\t\t\tpos_x++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// An RLE-compressed segment\n\t\t\tn_pix = (size_t)buf[0];\n\t\t\tfor(i=0;i<n_pix;i++) {\n\t\t\t\tif(pos_x<rctx->img->width) {\n\t\t\t\t\tif(rctx->compression==IWBMP_BI_RLE4) {\n\t\t\t\t\t\tpal_index = (i%2) ? buf[1]&0x0f : buf[1]>>4;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpal_index = buf[1];\n\t\t\t\t\t}\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;\n\t\t\t\t\tpos_x++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic int bmpr_has_transparency(struct iw_image *img)\n{\n\tint i,j;\n\n\tif(img->imgtype!=IW_IMGTYPE_RGBA) return 0;\n\n\tfor(j=0;j<img->height;j++) {\n\t\tfor(i=0;i<img->width;i++) {\n\t\t\tif(img->pixels[j*img->bpr + i*4 + 3] != 255)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// Remove the alpha channel.\n// This doesn't free the extra memory used by the alpha channel, it just\n// moves the pixels around in-place.\nstatic void bmpr_strip_alpha(struct iw_image *img)\n{\n\tint i,j;\n\tsize_t oldbpr;\n\n\timg->imgtype = IW_IMGTYPE_RGB;\n\toldbpr = img->bpr;\n\timg->bpr = iw_calc_bytesperrow(img->width,24);\n\n\tfor(j=0;j<img->height;j++) {\n\t\tfor(i=0;i<img->width;i++) {\n\t\t\timg->pixels[j*img->bpr + i*3 + 0] = img->pixels[j*oldbpr + i*4 + 0];\n\t\t\timg->pixels[j*img->bpr + i*3 + 1] = img->pixels[j*oldbpr + i*4 + 1];\n\t\t\timg->pixels[j*img->bpr + i*3 + 2] = img->pixels[j*oldbpr + i*4 + 2];\n\t\t}\n\t}\n}\n\nstatic int bmpr_read_rle(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\n\tif(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&\n\t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n\t{\n\t\tiw_set_error(rctx->ctx,\"Compression type incompatible with image type\");\n\t}\n\n\tif(rctx->topdown) {\n\t\t// The documentation says that top-down images may not be compressed.\n\t\tiw_set_error(rctx->ctx,\"Compression not allowed with top-down images\");\n\t}\n\n\t// RLE-compressed BMP images don't have to assign a color to every pixel,\n\t// and it's reasonable to interpret undefined pixels as transparent.\n\t// I'm not going to worry about handling compressed BMP images as\n\t// efficiently as possible, so start with an RGBA image, and convert to\n\t// RGB format later if (as is almost always the case) there was no\n\t// transparency.\n\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\trctx->img->bit_depth = 8;\n\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);\n\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\n\tif(!bmpr_read_rle_internal(rctx)) goto done;\n\n\tif(!bmpr_has_transparency(rctx->img)) {\n\t\tbmpr_strip_alpha(rctx->img);\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic int iwbmp_read_bits(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\n\trctx->img->width = rctx->width;\n\trctx->img->height = rctx->height;\n\n\t// If applicable, use the fileheader's \"bits offset\" field to locate the\n\t// bitmap bits.\n\tif(rctx->fileheader_size>0) {\n\t\tsize_t expected_offbits;\n\n\t\texpected_offbits = rctx->fileheader_size + rctx->infoheader_size +\n\t\t\trctx->bitfields_nbytes + rctx->palette_nbytes;\n\n\t\tif(rctx->bfOffBits==expected_offbits) {\n\t\t\t;\n\t\t}\n\t\telse if(rctx->bfOffBits>expected_offbits && rctx->bfOffBits<1000000) {\n\t\t\t// Apparently, there's some extra space between the header data and\n\t\t\t// the bits. If it's not unreasonably large, skip over it.\n\t\t\tif(!iwbmp_skip_bytes(rctx, rctx->bfOffBits - expected_offbits)) goto done;\n\t\t}\n\t\telse {\n\t\t\tiw_set_error(rctx->ctx,\"Invalid BMP bits offset\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif(rctx->compression==IWBMP_BI_RGB) {\n\t\tif(!bmpr_read_uncompressed(rctx)) goto done;\n\t}\n\telse if(rctx->compression==IWBMP_BI_RLE8 || rctx->compression==IWBMP_BI_RLE4) {\n\t\tif(!bmpr_read_rle(rctx)) goto done;\n\t}\n\telse {\n\t\tiw_set_errorf(rctx->ctx,\"Unsupported BMP compression or image type (%d)\",(int)rctx->compression);\n\t\tgoto done;\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic void iwbmpr_misc_config(struct iw_context *ctx, struct iwbmprcontext *rctx)\n{\n\t// Have IW flip the image, if necessary.\n\tif(!rctx->topdown) {\n\t\tiw_reorient_image(ctx,IW_REORIENT_FLIP_V);\n\t}\n\n\t// Tell IW the colorspace.\n\tiw_set_input_colorspace(ctx,&rctx->csdescr);\n\n\t// Tell IW the significant bits.\n\tif(rctx->bitcount==16 || rctx->bitcount==32) {\n\t\tif(rctx->bf_bits_count[0]!=8 || rctx->bf_bits_count[1]!=8 || rctx->bf_bits_count[2]!=8 ||\n\t\t\t(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype) && rctx->bf_bits_count[3]!=8))\n\t\t{\n\t\t\tiw_set_input_max_color_code(ctx,0, (1 << rctx->bf_bits_count[0])-1 );\n\t\t\tiw_set_input_max_color_code(ctx,1, (1 << rctx->bf_bits_count[1])-1 );\n\t\t\tiw_set_input_max_color_code(ctx,2, (1 << rctx->bf_bits_count[2])-1 );\n\t\t\tif(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype)) {\n\t\t\t\tiw_set_input_max_color_code(ctx,3, (1 << rctx->bf_bits_count[3])-1 );\n\t\t\t}\n\t\t}\n\t}\n}\n\nIW_IMPL(int) iw_read_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iwbmprcontext rctx;\n\tstruct iw_image img;\n\tint retval = 0;\n\n\tiw_zeromem(&rctx,sizeof(struct iwbmprcontext));\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\n\trctx.ctx = ctx;\n\trctx.img = &img;\n\trctx.iodescr = iodescr;\n\n\t// Start with a default sRGB colorspace. This may be overridden later.\n\tiw_make_srgb_csdescr_2(&rctx.csdescr);\n\n\trctx.has_fileheader = !iw_get_value(ctx,IW_VAL_BMP_NO_FILEHEADER);\n\tif(rctx.has_fileheader) {\n\t\tif(!iwbmp_read_file_header(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_info_header(&rctx)) goto done;\n\n\tiwbmp_set_default_bitfields(&rctx);\n\tif(rctx.bitfields_nbytes>0) {\n\t\tif(!iwbmp_read_bitfields(&rctx)) goto done;\n\t}\n\n\tif(rctx.palette_entries>0) {\n\t\tif(!iwbmp_read_palette(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_bits(&rctx)) goto done;\n\n\tiw_set_input_image(ctx, &img);\n\n\tiwbmpr_misc_config(ctx, &rctx);\n\n\tretval = 1;\ndone:\n\tif(!retval) {\n\t\tiw_set_error(ctx,\"BMP read failed\");\n\t\t// If we didn't call iw_set_input_image, 'img' still belongs to us,\n\t\t// so free its contents.\n\t\tiw_free(ctx, img.pixels);\n\t}\n\treturn retval;\n}\n\nstruct iwbmpwcontext {\n\tint bmpversion;\n\tint include_file_header;\n\tint bitcount;\n\tint palentries;\n\tint compressed;\n\tint uses_bitfields;\n\tsize_t header_size;\n\tsize_t bitfields_size;\n\tsize_t palsize;\n\tsize_t unc_dst_bpr;\n\tsize_t unc_bitssize;\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\tconst struct iw_palette *pal;\n\tsize_t total_written;\n\tint bf_amt_to_shift[4]; // For 16-bit images\n\tunsigned int bf_mask[4];\n\tunsigned int maxcolor[4]; // R, G, B -- For 16-bit images.\n\tstruct iw_csdescr csdescr;\n\tint no_cslabel;\n};\n\nstatic void iwbmp_write(struct iwbmpwcontext *wctx, const void *buf, size_t n)\n{\n\t(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,buf,n);\n\twctx->total_written+=n;\n}\n\nstatic void bmpw_convert_row_1(const iw_byte *srcrow, iw_byte *dstrow, int width)\n{\n\tint i;\n\tint m;\n\n\tfor(i=0;i<width;i++) {\n\t\tm = i%8;\n\t\tif(m==0)\n\t\t\tdstrow[i/8] = srcrow[i]<<7;\n\t\telse\n\t\t\tdstrow[i/8] |= srcrow[i]<<(7-m);\n\t}\n}\n\nstatic void bmpw_convert_row_4(const iw_byte *srcrow, iw_byte *dstrow, int width)\n{\n\tint i;\n\n\tfor(i=0;i<width;i++) {\n\t\tif(i%2==0)\n\t\t\tdstrow[i/2] = srcrow[i]<<4;\n\t\telse\n\t\t\tdstrow[i/2] |= srcrow[i];\n\t}\n}\n\nstatic void bmpw_convert_row_8(const iw_byte *srcrow, iw_byte *dstrow, int width)\n{\n\tmemcpy(dstrow,srcrow,width);\n}\n\nstatic void bmpw_convert_row_16_32(struct iwbmpwcontext *wctx, const iw_byte *srcrow,\n\tiw_byte *dstrow, int width)\n{\n\tint i,k;\n\tunsigned int v;\n\tint num_src_samples;\n\tunsigned int src_sample[4];\n\n\tfor(k=0;k<4;k++) src_sample[k]=0;\n\n\tnum_src_samples = iw_imgtype_num_channels(wctx->img->imgtype);\n\n\tfor(i=0;i<width;i++) {\n\n\t\t// Read the source samples into a convenient format.\n\t\tfor(k=0;k<num_src_samples;k++) {\n\t\t\tif(wctx->img->bit_depth==16) {\n\t\t\t\tsrc_sample[k] = (srcrow[num_src_samples*2*i + k*2]<<8) | srcrow[num_src_samples*2*i + k*2 +1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrc_sample[k] = srcrow[num_src_samples*i + k];\n\t\t\t}\n\t\t}\n\n\t\t// Pack the pixels' bits into a single int.\n\t\tswitch(wctx->img->imgtype) {\n\t\tcase IW_IMGTYPE_GRAY:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[2];\n\t\t\tbreak;\n\t\tcase IW_IMGTYPE_RGBA:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[2] << wctx->bf_amt_to_shift[2];\n\t\t\tv |= src_sample[3] << wctx->bf_amt_to_shift[3];\n\t\t\tbreak;\n\t\tcase IW_IMGTYPE_GRAYA:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[2];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[2] << wctx->bf_amt_to_shift[2];\n\t\t}\n\n\t\t// Split the int into bytes, and write it to the target image.\n\t\tif(wctx->bitcount==32) {\n\t\t\tdstrow[i*4+0] = (iw_byte)(v&0xff);\n\t\t\tdstrow[i*4+1] = (iw_byte)((v&0x0000ff00)>>8);\n\t\t\tdstrow[i*4+2] = (iw_byte)((v&0x00ff0000)>>16);\n\t\t\tdstrow[i*4+3] = (iw_byte)((v&0xff000000)>>24);\n\t\t}\n\t\telse {\n\t\t\tdstrow[i*2+0] = (iw_byte)(v&0xff);\n\t\t\tdstrow[i*2+1] = (iw_byte)(v>>8);\n\t\t}\n\t}\n}\n\nstatic void bmpw_convert_row_24(struct iwbmpwcontext *wctx, const iw_byte *srcrow,\n\tiw_byte *dstrow, int width)\n{\n\tint i;\n\n\tif(wctx->img->imgtype==IW_IMGTYPE_GRAY) {\n\t\tfor(i=0;i<width;i++) {\n\t\t\tdstrow[i*3+0] = srcrow[i];\n\t\t\tdstrow[i*3+1] = srcrow[i];\n\t\t\tdstrow[i*3+2] = srcrow[i];\n\t\t}\n\t}\n\telse { // RGB\n\t\tfor(i=0;i<width;i++) {\n\t\t\tdstrow[i*3+0] = srcrow[i*3+2];\n\t\t\tdstrow[i*3+1] = srcrow[i*3+1];\n\t\t\tdstrow[i*3+2] = srcrow[i*3+0];\n\t\t}\n\t}\n}\n\nstatic void iwbmp_write_file_header(struct iwbmpwcontext *wctx)\n{\n\tiw_byte fileheader[14];\n\n\tif(!wctx->include_file_header) return;\n\n\tiw_zeromem(fileheader,sizeof(fileheader));\n\tfileheader[0] = 66; // 'B'\n\tfileheader[1] = 77; // 'M'\n\n\t// This will be overwritten later, if the bitmap was compressed.\n\tiw_set_ui32le(&fileheader[ 2], (unsigned int)(14+wctx->header_size+\n\t\twctx->bitfields_size+wctx->palsize+wctx->unc_bitssize)); // bfSize\n\tiw_set_ui32le(&fileheader[10],(unsigned int)(14+wctx->header_size+\n\t\twctx->bitfields_size+wctx->palsize)); // bfOffBits\n\tiwbmp_write(wctx,fileheader,14);\n}\n\nstatic int iwbmp_write_bmp_v2header(struct iwbmpwcontext *wctx)\n{\n\tiw_byte header[12];\n\n\tif(wctx->img->width>65535 || wctx->img->height>65535) {\n\t\tiw_set_error(wctx->ctx,\"Output image is too large for this BMP version\");\n\t\treturn 0;\n\t}\n\n\tiw_zeromem(header,sizeof(header));\n\tiw_set_ui32le(&header[ 0],12);                // bcSize\n\tiw_set_ui16le(&header[ 4],wctx->img->width);  // bcWidth\n\tiw_set_ui16le(&header[ 6],wctx->img->height); // bcHeight\n\tiw_set_ui16le(&header[ 8],1);                 // bcPlanes\n\tiw_set_ui16le(&header[10],wctx->bitcount);    // bcBitCount\n\n\tiwbmp_write(wctx,header,12);\n\treturn 1;\n}\n\nstatic int iwbmp_write_bmp_v3header(struct iwbmpwcontext *wctx)\n{\n\tunsigned int dens_x, dens_y;\n\tunsigned int cmpr;\n\tiw_byte header[40];\n\n\tiw_zeromem(header,sizeof(header));\n\n\tiw_set_ui32le(&header[ 0],(unsigned int)wctx->header_size); // biSize\n\tiw_set_ui32le(&header[ 4],wctx->img->width);  // biWidth\n\tiw_set_ui32le(&header[ 8],wctx->img->height); // biHeight\n\tiw_set_ui16le(&header[12],1);    // biPlanes\n\tiw_set_ui16le(&header[14],wctx->bitcount);   // biBitCount\n\n\tcmpr = IWBMP_BI_RGB;\n\tif(wctx->compressed) {\n\t\tif(wctx->bitcount==8) cmpr = IWBMP_BI_RLE8;\n\t\telse if(wctx->bitcount==4) cmpr = IWBMP_BI_RLE4;\n\t}\n\telse if(wctx->uses_bitfields) {\n\t\tcmpr = IWBMP_BI_BITFIELDS;\n\t}\n\tiw_set_ui32le(&header[16],cmpr); // biCompression\n\n\tiw_set_ui32le(&header[20],(unsigned int)wctx->unc_bitssize); // biSizeImage\n\n\tif(wctx->img->density_code==IW_DENSITY_UNITS_PER_METER) {\n\t\tdens_x = (unsigned int)(0.5+wctx->img->density_x);\n\t\tdens_y = (unsigned int)(0.5+wctx->img->density_y);\n\t}\n\telse {\n\t\tdens_x = dens_y = 2835;\n\t}\n\tiw_set_ui32le(&header[24],dens_x); // biXPelsPerMeter\n\tiw_set_ui32le(&header[28],dens_y); // biYPelsPerMeter\n\n\tiw_set_ui32le(&header[32],wctx->palentries);    // biClrUsed\n\t//iw_set_ui32le(&header[36],0);    // biClrImportant\n\tiwbmp_write(wctx,header,40);\n\treturn 1;\n}\n\nstatic int iwbmp_write_bmp_v45header_fields(struct iwbmpwcontext *wctx)\n{\n\tiw_byte header[124];\n\tunsigned int intent_bmp_style;\n\n\tiw_zeromem(header,sizeof(header));\n\n\tif(wctx->uses_bitfields) {\n\t\tiw_set_ui32le(&header[40],wctx->bf_mask[0]);\n\t\tiw_set_ui32le(&header[44],wctx->bf_mask[1]);\n\t\tiw_set_ui32le(&header[48],wctx->bf_mask[2]);\n\t\tiw_set_ui32le(&header[52],wctx->bf_mask[3]);\n\t}\n\n\t// Colorspace Type\n\t// TODO: We could support CSTYPE_GAMMA by using LCS_CALIBRATED_RGB,\n\t// but documentation about how to do that is hard to find.\n\tif(wctx->csdescr.cstype==IW_CSTYPE_SRGB && !wctx->no_cslabel)\n\t\tiw_set_ui32le(&header[56],IWBMPCS_SRGB);\n\telse\n\t\tiw_set_ui32le(&header[56],IWBMPCS_DEVICE_RGB);\n\n\t// Intent\n\t//intent_bmp_style = 4; // Perceptual\n\t//if(wctx->csdescr.cstype==IW_CSTYPE_SRGB && !wctx->no_cslabel) {\n\tswitch(wctx->img->rendering_intent) {\n\tcase IW_INTENT_PERCEPTUAL: intent_bmp_style = 4; break;\n\tcase IW_INTENT_RELATIVE:   intent_bmp_style = 2; break;\n\tcase IW_INTENT_SATURATION: intent_bmp_style = 1; break;\n\tcase IW_INTENT_ABSOLUTE:   intent_bmp_style = 8; break;\n\tdefault: intent_bmp_style = 4;\n\t}\n\t//}\n\tiw_set_ui32le(&header[108],intent_bmp_style);\n\n\tiwbmp_write(wctx,&header[40],124-40);\n\treturn 1;\n}\n\nstatic int iwbmp_write_bmp_header(struct iwbmpwcontext *wctx)\n{\n\tif(wctx->bmpversion==2) {\n\t\treturn iwbmp_write_bmp_v2header(wctx);\n\t}\n\telse if(wctx->bmpversion==5) {\n\t\tif(!iwbmp_write_bmp_v3header(wctx)) return 0;\n\t\treturn iwbmp_write_bmp_v45header_fields(wctx);\n\t}\n\treturn iwbmp_write_bmp_v3header(wctx);\n}\n\n// Given wctx->maxcolor[*], sets -> bf_mask[*] and bf_amt_to_shift[*],\n// and sets wctx->bitcount (to 16 or 32).\nstatic int iwbmp_calc_bitfields_masks(struct iwbmpwcontext *wctx, int num_masks)\n{\n\tint k;\n\tint bits[4]; // R, G, B, A\n\tint tot_bits = 0;\n\n\tfor(k=0;k<num_masks;k++) {\n\t\tbits[k] = iw_max_color_to_bitdepth(wctx->maxcolor[k]);\n\t\ttot_bits += bits[k];\n\t}\n\n\tif(tot_bits > 32) {\n\t\tiw_set_error(wctx->ctx,\"Cannot write a BMP image in this color format\");\n\t\treturn 0;\n\t}\n\t\n\twctx->bitcount = (tot_bits>16) ? 32 : 16;\n\n\twctx->bf_amt_to_shift[0] = bits[1] + bits[2];\n\twctx->bf_amt_to_shift[1] = bits[2];\n\twctx->bf_amt_to_shift[2] = 0;\n\tif(num_masks>3) wctx->bf_amt_to_shift[3] =  bits[0] + bits[1] + bits[2];\n\n\tfor(k=0;k<num_masks;k++) {\n\t\twctx->bf_mask[k] = wctx->maxcolor[k] << wctx->bf_amt_to_shift[k];\n\t}\n\n\treturn 1;\n}\n\n// Write the BITFIELDS segment, and set the wctx->bf_amt_to_shift[] values.\nstatic int iwbmp_write_bitfields(struct iwbmpwcontext *wctx)\n{\n\tiw_byte buf[12];\n\tint k;\n\n\tif(wctx->bitcount!=16 && wctx->bitcount!=32) return 0;\n\n\tfor(k=0;k<3;k++) {\n\t\tiw_set_ui32le(&buf[4*k],wctx->bf_mask[k]);\n\t}\n\tiwbmp_write(wctx,buf,12);\n\treturn 1;\n}\n\nstatic void iwbmp_write_palette(struct iwbmpwcontext *wctx)\n{\n\tint i,k;\n\tiw_byte buf[4];\n\n\tif(wctx->palentries<1) return;\n\n\tbuf[3] = 0; // Reserved field; always 0.\n\n\tfor(i=0;i<wctx->palentries;i++) {\n\t\tif(i<wctx->pal->num_entries) {\n\t\t\tif(wctx->pal->entry[i].a == 0) {\n\t\t\t\t// A transparent color. Because of the way we handle writing\n\t\t\t\t// transparent BMP images, the first palette entry may be a\n\t\t\t\t// fully transparent color, whose index will not be used when\n\t\t\t\t// we write the image. But many apps will interpret our\n\t\t\t\t// \"transparent\" pixels as having color #0. So, set it to\n\t\t\t\t// the background label color if available, otherwise to an\n\t\t\t\t// arbitrary high-contrast color (magenta).\n\t\t\t\tif(wctx->img->has_bkgdlabel) {\n\t\t\t\t\tfor(k=0;k<3;k++) {\n\t\t\t\t\t\tbuf[k] = (iw_byte)iw_color_get_int_sample(&wctx->img->bkgdlabel,2-k,255);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf[0] = 255;\n\t\t\t\t\tbuf[1] = 0;\n\t\t\t\t\tbuf[2] = 255;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf[0] = wctx->pal->entry[i].b;\n\t\t\t\tbuf[1] = wctx->pal->entry[i].g;\n\t\t\t\tbuf[2] = wctx->pal->entry[i].r;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbuf[0] = buf[1] = buf[2] = 0;\n\t\t}\n\t\tif(wctx->bmpversion==2)\n\t\t\tiwbmp_write(wctx,buf,3); // v2 BMPs don't have the 'reserved' field.\n\t\telse\n\t\t\tiwbmp_write(wctx,buf,4);\n\t}\n}\n\nstruct rle_context {\n\tstruct iw_context *ctx;\n\tstruct iwbmpwcontext *wctx;\n\tconst iw_byte *srcrow;\n\n\tsize_t img_width;\n\tint cur_row; // current row; 0=top (last)\n\n\t// Position in srcrow of the first byte that hasn't been written to the\n\t// output file\n\tsize_t pending_data_start;\n\n\t// Current number of uncompressible bytes that haven't been written yet\n\t// (starting at pending_data_start)\n\tsize_t unc_len;\n\n\t// Current number of identical bytes that haven't been written yet\n\t// (starting at pending_data_start+unc_len)\n\tsize_t run_len;\n\n\t// The value of the bytes referred to by run_len.\n\t// Valid if run_len>0.\n\tiw_byte run_byte;\n\n\tsize_t total_bytes_written; // Bytes written, after compression\n};\n\n//============================ RLE8 encoder ============================\n\n// TODO: The RLE8 and RLE4 encoders are more different than they should be.\n// The RLE8 encoder could probably be made more similar to the (more\n// complicated) RLE4 encoder.\n\nstatic void rle8_write_unc(struct rle_context *rlectx)\n{\n\tsize_t i;\n\tiw_byte dstbuf[2];\n\n\tif(rlectx->unc_len<1) return;\n\tif(rlectx->unc_len>=3 && (rlectx->unc_len&1)) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 4\");\n\t\treturn;\n\t}\n\tif(rlectx->unc_len>254) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 5\");\n\t\treturn;\n\t}\n\n\tif(rlectx->unc_len<3) {\n\t\t// The minimum length for a noncompressed run is 3. For shorter runs\n\t\t// write them \"compressed\".\n\t\tfor(i=0;i<rlectx->unc_len;i++) {\n\t\t\tdstbuf[0] = 0x01;  // count\n\t\t\tdstbuf[1] = rlectx->srcrow[i+rlectx->pending_data_start]; // value\n\t\t\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\t\t\trlectx->total_bytes_written+=2;\n\t\t}\n\t}\n\telse {\n\t\tdstbuf[0] = 0x00;\n\t\tdstbuf[1] = (iw_byte)rlectx->unc_len;\n\t\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\t\trlectx->total_bytes_written+=2;\n\t\tiwbmp_write(rlectx->wctx,&rlectx->srcrow[rlectx->pending_data_start],rlectx->unc_len);\n\t\trlectx->total_bytes_written+=rlectx->unc_len;\n\t\tif(rlectx->unc_len&0x1) {\n\t\t\t// Need a padding byte if the length was odd. (This shouldn't\n\t\t\t// happen, because we never write odd-length UNC segments.)\n\t\t\tdstbuf[0] = 0x00;\n\t\t\tiwbmp_write(rlectx->wctx,dstbuf,1);\n\t\t\trlectx->total_bytes_written+=1;\n\t\t}\n\t}\n\n\trlectx->pending_data_start+=rlectx->unc_len;\n\trlectx->unc_len=0;\n}\n\nstatic void rle8_write_unc_and_run(struct rle_context *rlectx)\n{\n\tiw_byte dstbuf[2];\n\n\trle8_write_unc(rlectx);\n\n\tif(rlectx->run_len<1) {\n\t\treturn;\n\t}\n\tif(rlectx->run_len>255) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 6\");\n\t\treturn;\n\t}\n\n\tdstbuf[0] = (iw_byte)rlectx->run_len;\n\tdstbuf[1] = rlectx->run_byte;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\trlectx->pending_data_start+=rlectx->run_len;\n\trlectx->run_len=0;\n}\n\nstatic void rle_write_trns(struct rle_context *rlectx, int num_trns)\n{\n\tiw_byte dstbuf[4];\n\tint num_remaining = num_trns;\n\tint num_to_write;\n\n\twhile(num_remaining>0) {\n\t\tnum_to_write = num_remaining;\n\t\tif(num_to_write>255) num_to_write=255;\n\t\tdstbuf[0]=0x00; // 00 02 = Delta\n\t\tdstbuf[1]=0x02;\n\t\tdstbuf[2]=(iw_byte)num_to_write; // X offset\n\t\tdstbuf[3]=0x00; // Y offset\n\t\tiwbmp_write(rlectx->wctx,dstbuf,4);\n\t\trlectx->total_bytes_written+=4;\n\t\tnum_remaining -= num_to_write;\n\t}\n\trlectx->pending_data_start += num_trns;\n}\n\n// The RLE format used by BMP files is pretty simple, but I've gone to some\n// effort to optimize it for file size, which makes for a complicated\n// algorithm.\n// The overall idea:\n// We defer writing data until certain conditions are met. In the meantime,\n// we split the unwritten data into two segments:\n//  \"UNC\": data classified as uncompressible\n//  \"RUN\": data classified as compressible. All bytes in this segment must be\n//    identical.\n// The RUN segment always follows the UNC segment.\n// For each byte in turn, we examine the current state, and do one of a number\n// of things, such as:\n//    - add it to RUN\n//    - add it to UNC (if there is no RUN)\n//    - move RUN into UNC, then add it to RUN (or to UNC)\n//    - move UNC and RUN to the file, then make it the new RUN\n// Then, we check to see if we've accumulated enough data that something needs\n// to be written out.\nstatic int rle8_compress_row(struct rle_context *rlectx)\n{\n\tsize_t i;\n\tiw_byte dstbuf[2];\n\tiw_byte next_byte;\n\tint next_pix_is_trns;\n\tint num_trns = 0; // number of consecutive transparent pixels seen\n\tint retval = 0;\n\n\trlectx->pending_data_start=0;\n\trlectx->unc_len=0;\n\trlectx->run_len=0;\n\n\tfor(i=0;i<rlectx->img_width;i++) {\n\n\t\t// Read the next byte.\n\t\tnext_byte = rlectx->srcrow[i];\n\n\t\tnext_pix_is_trns = (rlectx->wctx->pal->entry[next_byte].a==0);\n\n\t\tif(num_trns>0 && !next_pix_is_trns) {\n\t\t\trle_write_trns(rlectx,num_trns);\n\t\t\tnum_trns=0;\n\t\t}\n\t\telse if(next_pix_is_trns) {\n\t\t\tif (rlectx->unc_len>0 || rlectx->run_len>0) {\n\t\t\t\trle8_write_unc_and_run(rlectx);\n\t\t\t}\n\t\t\tnum_trns++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Add the byte we just read to either the UNC or the RUN data.\n\n\t\tif(rlectx->run_len>0 && next_byte==rlectx->run_byte) {\n\t\t\t// Byte fits in the current run; add it.\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->run_len==0) {\n\t\t\t// We don't have a RUN, so we can put this byte there.\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_byte;\n\t\t}\n\t\telse if(rlectx->unc_len==0 && rlectx->run_len==1) {\n\t\t\t// We have one previous byte, and it's different from this one.\n\t\t\t// Move it to UNC, and make this one the RUN.\n\t\t\trlectx->unc_len++;\n\t\t\trlectx->run_byte = next_byte;\n\t\t}\n\t\telse if(rlectx->unc_len>0 && rlectx->run_len<(rlectx->unc_len==1 ? 3U : 4U)) {\n\t\t\t// We have a run, but it's not long enough to be beneficial.\n\t\t\t// Convert it to uncompressed bytes.\n\t\t\t// A good rule is that a run length of 4 or more (3 or more if\n\t\t\t// unc_len=1) should always be run-legth encoded.\n\t\t\trlectx->unc_len += rlectx->run_len;\n\t\t\trlectx->run_len = 0;\n\t\t\t// If UNC is now odd and >1, add the next byte to it to make it even.\n\t\t\t// Otherwise, add it to RUN.\n\t\t\tif(rlectx->unc_len>=3 && (rlectx->unc_len&0x1)) {\n\t\t\t\trlectx->unc_len++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trlectx->run_len = 1;\n\t\t\t\trlectx->run_byte = next_byte;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Nowhere to put the byte: write out everything, and start fresh.\n\t\t\trle8_write_unc_and_run(rlectx);\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_byte;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// If we hit certain high water marks, write out the current data.\n\n\t\tif(rlectx->unc_len>=254) {\n\t\t\t// Our maximum size for an UNC segment.\n\t\t\trle8_write_unc(rlectx);\n\t\t}\n\t\telse if(rlectx->unc_len>0 && (rlectx->unc_len+rlectx->run_len)>254) {\n\t\t\t// It will not be possible to coalesce the RUN into the UNC (it\n\t\t\t// would be too big) so write out the UNC.\n\t\t\trle8_write_unc(rlectx);\n\t\t}\n\t\telse if(rlectx->run_len>=255) {\n\t\t\t// The maximum size for an RLE segment.\n\t\t\trle8_write_unc_and_run(rlectx);\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Sanity checks. These can be removed if we're sure the algorithm\n\t\t// is bug-free.\n\n\t\t// We don't allow unc_len to be odd (except temporarily), except\n\t\t// that it can be 1.\n\t\t// What's special about 1 is that if we add another byte to it, it\n\t\t// increases the cost. For 3,5,...,253, we can add another byte for\n\t\t// free, so we should never fail to do that.\n\t\tif((rlectx->unc_len&0x1) && rlectx->unc_len!=1) {\n\t\t\tiw_set_errorf(rlectx->ctx,\"Internal: BMP RLE encode error 1\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t// unc_len can be at most 252 at this point.\n\t\t// If it were 254, it should have been written out already.\n\t\tif(rlectx->unc_len>252) {\n\t\t\tiw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 2\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t// run_len can be at most 254 at this point.\n\t\t// If it were 255, it should have been written out already.\n\t\tif(rlectx->run_len>254) {\n\t\t\tiw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 3\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t// End of row. Write out anything left over.\n\trle8_write_unc_and_run(rlectx);\n\n\t// Write an end-of-line marker (0 0), or if this is the last row,\n\t// an end-of-bitmap marker (0 1).\n\tdstbuf[0]=0x00;\n\tdstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}\n\n//============================ RLE4 encoder ============================\n\n// Calculate the most efficient way to split a run of uncompressible pixels.\n// This only finds the first place to split the run. If the run is still\n// over 255 pixels, call it again to find the next split.\nstatic size_t rle4_get_best_unc_split(size_t n)\n{\n\t// For <=255 pixels, we can never do better than storing it as one run.\n\tif(n<=255) return n;\n\n\t// With runs of 252, we can store 252/128 = 1.96875 pixels/byte.\n\t// With runs of 255, we can store 255/130 = 1.96153 pixels/byte.\n\t// Hence, using runs of 252 is the most efficient way to store a large\n\t// number of uncompressible pixels.\n\t// (Lengths other than 252 or 255 are no help.)\n\t// However, there are three exceptional cases where, if we split at 252,\n\t// the most efficient encoding will no longer be possible:\n\tif(n==257 || n==510 || n==765) return 255;\n\n\treturn 252;\n}\n\n// Returns the incremental cost of adding a pixel to the current UNC\n// (which is always either 0 or 2).\n// To derive this function, I calculated the optimal cost of every length,\n// and enumerated the exceptions to the (n%4)?0:2 rule.\n// The exceptions are mostly caused by the cases where\n// rle4_get_best_unc_split() returns 255 instead of 252.\nstatic int rle4_get_incr_unc_cost(struct rle_context *rlectx)\n{\n\tint n;\n\tint m;\n\n\tn = (int)rlectx->unc_len;\n\n\tif(n==2 || n==255 || n==257 || n==507 || n==510) return 2;\n\tif(n==256 || n==508) return 0;\n\n\tif(n>=759) {\n\t\tm = n%252;\n\t\tif(m==3 || m==6 || m==9) return 2;\n\t\tif(m==4 || m==8) return 0;\n\t}\n\n\treturn (n%4)?0:2;\n}\n\nstatic void rle4_write_unc(struct rle_context *rlectx)\n{\n\tiw_byte dstbuf[128];\n\tsize_t pixels_to_write;\n\tsize_t bytes_to_write;\n\n\tif(rlectx->unc_len<1) return;\n\n\t// Note that, unlike the RLE8 encoder, we allow this function to be called\n\t// with uncompressed runs of arbitrary length.\n\n\twhile(rlectx->unc_len>0) {\n\t\tpixels_to_write = rle4_get_best_unc_split(rlectx->unc_len);\n\n\t\tif(pixels_to_write<3) {\n\t\t\t// The minimum length for an uncompressed run is 3. For shorter runs\n\t\t\t// write them \"compressed\".\n\t\t\tdstbuf[0] = (iw_byte)pixels_to_write;\n\t\t\tdstbuf[1] = (rlectx->srcrow[rlectx->pending_data_start]<<4);\n\t\t\tif(pixels_to_write>1)\n\t\t\t\tdstbuf[1] |= (rlectx->srcrow[rlectx->pending_data_start+1]);\n\n\t\t\t// The actual writing will occur below. Just indicate how many bytes\n\t\t\t// of dstbuf[] to write.\n\t\t\tbytes_to_write = 2;\n\t\t}\n\t\telse {\n\t\t\tsize_t i;\n\n\t\t\t// Write the length of the uncompressed run.\n\t\t\tdstbuf[0] = 0x00;\n\t\t\tdstbuf[1] = (iw_byte)pixels_to_write;\n\t\t\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\t\t\trlectx->total_bytes_written+=2;\n\n\t\t\t// Put the data to write in dstbuf[].\n\t\t\tbytes_to_write = 2*((pixels_to_write+3)/4);\n\t\t\tiw_zeromem(dstbuf,bytes_to_write);\n\n\t\t\tfor(i=0;i<pixels_to_write;i++) {\n\t\t\t\tif(i&0x1) dstbuf[i/2] |= rlectx->srcrow[rlectx->pending_data_start+i];\n\t\t\t\telse dstbuf[i/2] = rlectx->srcrow[rlectx->pending_data_start+i]<<4;\n\t\t\t}\n\t\t}\n\n\t\tiwbmp_write(rlectx->wctx,dstbuf,bytes_to_write);\n\t\trlectx->total_bytes_written += bytes_to_write;\n\t\trlectx->unc_len -= pixels_to_write;\n\t\trlectx->pending_data_start += pixels_to_write;\n\t}\n}\n\nstatic void rle4_write_unc_and_run(struct rle_context *rlectx)\n{\n\tiw_byte dstbuf[2];\n\n\trle4_write_unc(rlectx);\n\n\tif(rlectx->run_len<1) {\n\t\treturn;\n\t}\n\tif(rlectx->run_len>255) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 6\");\n\t\treturn;\n\t}\n\n\tdstbuf[0] = (iw_byte)rlectx->run_len;\n\tdstbuf[1] = rlectx->run_byte;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\trlectx->pending_data_start+=rlectx->run_len;\n\trlectx->run_len=0;\n}\n\n// Should we move the pending compressible data to the \"uncompressed\"\n// segment (return 1), or should we write it to disk as a compressed run of\n// pixels (0)?\nstatic int ok_to_move_to_unc(struct rle_context *rlectx)\n{\n\t// This logic is probably not optimal in every case.\n\t// One possible improvement might be to adjust the thresholds when\n\t// unc_len+run_len is around 255 or higher.\n\t// Other improvements might require looking ahead at pixels we haven't\n\t// read yet.\n\n\tif(rlectx->unc_len==0) {\n\t\treturn (rlectx->run_len<4);\n\t}\n\telse if(rlectx->unc_len<=2) {\n\t\treturn (rlectx->run_len<6);\n\t}\n\telse {\n\t\treturn (rlectx->run_len<8);\n\t}\n\treturn 0;\n}\n\nstatic int rle4_compress_row(struct rle_context *rlectx)\n{\n\tsize_t i;\n\tiw_byte dstbuf[2];\n\tiw_byte next_pix;\n\tint next_pix_is_trns;\n\tint num_trns = 0; // number of consecutive transparent pixels seen\n\tint retval = 0;\n\tiw_byte tmpb;\n\n\trlectx->pending_data_start=0;\n\trlectx->unc_len=0;\n\trlectx->run_len=0;\n\n\tfor(i=0;i<rlectx->img_width;i++) {\n\n\t\t// Read the next pixel\n\t\tnext_pix = rlectx->srcrow[i];\n\n\t\tnext_pix_is_trns = (rlectx->wctx->pal->entry[next_pix].a==0);\n\t\tif(num_trns>0 && !next_pix_is_trns) {\n\t\t\trle_write_trns(rlectx,num_trns);\n\t\t\tnum_trns=0;\n\t\t}\n\t\telse if(next_pix_is_trns) {\n\t\t\tif (rlectx->unc_len>0 || rlectx->run_len>0) {\n\t\t\t\trle4_write_unc_and_run(rlectx);\n\t\t\t}\n\t\t\tnum_trns++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Add the pixel we just read to either the UNC or the RUN data.\n\n\t\tif(rlectx->run_len==0) {\n\t\t\t// We don't have a RUN, so we can put this pixel there.\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_pix<<4;\n\t\t}\n\t\telse if(rlectx->run_len==1) {\n\t\t\t// If the run is 1, we can always add a 2nd pixel\n\t\t\trlectx->run_byte |= next_pix;\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->run_len>=2 && (rlectx->run_len&1)==0 && next_pix==(rlectx->run_byte>>4)) {\n\t\t\t// pixel fits in the current run; add it.\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->run_len>=3 && (rlectx->run_len&1) && next_pix==(rlectx->run_byte&0x0f)) {\n\t\t\t// pixel fits in the current run; add it.\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->unc_len==0 && rlectx->run_len==2) {\n\t\t\t// We have one previous byte, and it's different from this one.\n\t\t\t// Move it to UNC, and make this one the RUN.\n\t\t\trlectx->unc_len+=rlectx->run_len;\n\t\t\trlectx->run_byte = next_pix<<4;\n\t\t\trlectx->run_len = 1;\n\t\t}\n\t\telse if(ok_to_move_to_unc(rlectx)) {\n\t\t\t// We have a compressible run, but we think it's not long enough to be\n\t\t\t// beneficial. Convert it to uncompressed bytes -- except for the last\n\t\t\t// pixel, which can be left in the run.\n\t\t\trlectx->unc_len += rlectx->run_len-1;\n \n\t\t\tif((rlectx->run_len&1)==0)\n\t\t\t\trlectx->run_byte = (rlectx->run_byte&0x0f)<<4;\n\t\t\telse\n\t\t\t\trlectx->run_byte = (rlectx->run_byte&0xf0);\n\n\t\t\t// Put the next byte in RLE. (It might get moved to UNC, below.)\n\t\t\trlectx->run_len = 2;\n\t\t\trlectx->run_byte |= next_pix;\n\t\t}\n\t\telse {\n\t\t\t// Nowhere to put the byte: write out everything, and start fresh.\n\t\t\trle4_write_unc_and_run(rlectx);\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_pix<<4;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// If any RUN bytes that can be added to UNC for free, do so.\n\t\twhile(rlectx->unc_len>0 && rlectx->run_len>0 && rle4_get_incr_unc_cost(rlectx)==0) {\n\t\t\trlectx->unc_len++;\n\t\t\trlectx->run_len--;\n\t\t\ttmpb = rlectx->run_byte;\n\t\t\t// Reverse the two pixels stored in run_byte.\n\t\t\trlectx->run_byte = (tmpb>>4) | ((tmpb&0x0f)<<4);\n\t\t\tif(rlectx->run_len==1) rlectx->run_byte &= 0xf0;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// If we hit certain high water marks, write out the current data.\n\n\t\tif(rlectx->run_len>=255) {\n\t\t\t// The maximum size for an RLE segment.\n\t\t\trle4_write_unc_and_run(rlectx);\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Sanity check(s). This can be removed if we're sure the algorithm\n\t\t// is bug-free.\n\n\t\t// run_len can be at most 254 at this point.\n\t\t// If it were 255, it should have been written out already.\n\t\tif(rlectx->run_len>255) {\n\t\t\tiw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 3\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t// End of row. Write out anything left over.\n\trle4_write_unc_and_run(rlectx);\n\n\t// Write an end-of-line marker (0 0), or if this is the last row,\n\t// an end-of-bitmap marker (0 1).\n\tdstbuf[0]=0x00;\n\tdstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}\n\n//======================================================================\n\n// Seek back and write the \"file size\" and \"bits size\" fields.\nstatic int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)\n{\n\tiw_byte buf[4];\n\tsize_t fileheader_size;\n\tint ret;\n\n\tif(!wctx->iodescr->seek_fn) {\n\t\tiw_set_error(wctx->ctx,\"Writing compressed BMP requires a seek function\");\n\t\treturn 0;\n\t}\n\n\tif(wctx->include_file_header) {\n\t\t// Patch the file size in the file header\n\t\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);\n\t\tif(!ret) return 0;\n\t\tiw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));\n\t\tiwbmp_write(wctx,buf,4);\n\t\tfileheader_size = 14;\n\t}\n\telse {\n\t\tfileheader_size = 0;\n\t}\n\n\t// Patch the \"bits\" size\n\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);\n\tif(!ret) return 0;\n\tiw_set_ui32le(buf,(unsigned int)rlesize);\n\tiwbmp_write(wctx,buf,4);\n\n\t(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);\n\treturn 1;\n}\n\nstatic int iwbmp_write_pixels_compressed(struct iwbmpwcontext *wctx,\n\tstruct iw_image *img)\n{\n\tstruct rle_context rlectx;\n\tint j;\n\tint retval = 0;\n\n\tiw_zeromem(&rlectx,sizeof(struct rle_context));\n\n\trlectx.ctx = wctx->ctx;\n\trlectx.wctx = wctx;\n\trlectx.total_bytes_written = 0;\n\trlectx.img_width = img->width;\n\n\tfor(j=img->height-1;j>=0;j--) {\n\t\t// Compress and write a row of pixels\n\t\trlectx.srcrow = &img->pixels[j*img->bpr];\n\t\trlectx.cur_row = j;\n\n\t\tif(wctx->bitcount==4) {\n\t\t\tif(!rle4_compress_row(&rlectx)) goto done;\n\t\t}\n\t\telse if(wctx->bitcount==8) {\n\t\t\tif(!rle8_compress_row(&rlectx)) goto done;\n\t\t}\n\t\telse {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t// Back-patch the 'file size' and 'bits size' fields\n\tif(!rle_patch_file_size(wctx,rlectx.total_bytes_written)) goto done;\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic void iwbmp_write_pixels_uncompressed(struct iwbmpwcontext *wctx,\n\tstruct iw_image *img)\n{\n\tint j;\n\tiw_byte *dstrow = NULL;\n\tconst iw_byte *srcrow;\n\n\tdstrow = iw_mallocz(wctx->ctx,wctx->unc_dst_bpr);\n\tif(!dstrow) goto done;\n\n\tfor(j=img->height-1;j>=0;j--) {\n\t\tsrcrow = &img->pixels[j*img->bpr];\n\t\tswitch(wctx->bitcount) {\n\t\tcase 32: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;\n\t\tcase 24: bmpw_convert_row_24(wctx,srcrow,dstrow,img->width); break;\n\t\tcase 16: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;\n\t\tcase 8: bmpw_convert_row_8(srcrow,dstrow,img->width); break;\n\t\tcase 4: bmpw_convert_row_4(srcrow,dstrow,img->width); break;\n\t\tcase 1: bmpw_convert_row_1(srcrow,dstrow,img->width); break;\n\t\t}\n\t\tiwbmp_write(wctx,dstrow,wctx->unc_dst_bpr);\n\t}\n\ndone:\n\tif(dstrow) iw_free(wctx->ctx,dstrow);\n\treturn;\n}\n\n// 0 = no transparency\n// 1 = binary transparency\n// 2 = partial transparency\nstatic int check_palette_transparency(const struct iw_palette *p)\n{\n\tint i;\n\tint retval = 0;\n\n\tfor(i=0;i<p->num_entries;i++) {\n\t\tif(p->entry[i].a!=255) retval=1;\n\t\tif(p->entry[i].a!=255 && p->entry[i].a!=0) return 2;\n\t}\n\treturn retval;\n}\n\n// Do some preparations needed to write a 16-bit or 32-bit BMP.\nstatic int setup_16_32bit(struct iwbmpwcontext *wctx,\n\tint mcc_r, int mcc_g, int mcc_b, int mcc_a)\n{\n\tint has_alpha;\n\n\thas_alpha = IW_IMGTYPE_HAS_ALPHA(wctx->img->imgtype);\n\n\tif(wctx->bmpversion<3) {\n\t\tiw_set_errorf(wctx->ctx,\"Bit depth incompatible with BMP version %d\",\n\t\t\twctx->bmpversion);\n\t\treturn 0;\n\t}\n\n\tif(has_alpha && wctx->bmpversion<5) {\n\t\tiw_set_error(wctx->ctx,\"Internal: Attempt to write v3 16- or 32-bit image with transparency\");\n\t\treturn 0;\n\t}\n\n\t// Make our own copy of the max color codes, so that we don't have to\n\t// do \"if(grayscale)\" so much.\n\twctx->maxcolor[0] = mcc_r;\n\twctx->maxcolor[1] = mcc_g;\n\twctx->maxcolor[2] = mcc_b;\n\tif(has_alpha) wctx->maxcolor[3] = mcc_a;\n\n\tif(!iwbmp_calc_bitfields_masks(wctx,has_alpha?4:3)) return 0;\n\n\tif(mcc_r==31 && mcc_g==31 && mcc_b==31 && !has_alpha) {\n\t\t// For the default 5-5-5, set the 'compression' to BI_RGB\n\t\t// instead of BITFIELDS, and don't write a BITFIELDS segment\n\t\t// (or for v5 BMP, don't set the Mask fields).\n\t\twctx->bitfields_size = 0;\n\t}\n\telse {\n\t\twctx->uses_bitfields = 1;\n\t\twctx->bitfields_size = (wctx->bmpversion==3) ? 12 : 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwbmp_write_main(struct iwbmpwcontext *wctx)\n{\n\tstruct iw_image *img;\n\tint cmpr_req;\n\tint retval = 0;\n\tint x;\n\tconst char *optv;\n\n\timg = wctx->img;\n\n\twctx->bmpversion = 0;\n\toptv = iw_get_option(wctx->ctx, \"bmp:version\");\n\tif(optv) {\n\t\twctx->bmpversion = iw_parse_int(optv);\n\t}\n\n\tif(wctx->bmpversion==0) wctx->bmpversion=3;\n\tif(wctx->bmpversion==4) {\n\t\tiw_warning(wctx->ctx,\"Writing BMP v4 is not supported; using v3 instead\");\n\t\twctx->bmpversion=3;\n\t}\n\tif(wctx->bmpversion!=2 && wctx->bmpversion!=3 && wctx->bmpversion!=5) {\n\t\tiw_set_errorf(wctx->ctx,\"Unsupported BMP version: %d\",wctx->bmpversion);\n\t\tgoto done;\n\t}\n\n\tif(wctx->bmpversion>=3)\n\t\tcmpr_req = iw_get_value(wctx->ctx,IW_VAL_COMPRESSION);\n\telse\n\t\tcmpr_req = IW_COMPRESSION_NONE;\n\n\tif(wctx->bmpversion==2)\n\t\twctx->header_size = 12;\n\telse if(wctx->bmpversion==5)\n\t\twctx->header_size = 124;\n\telse\n\t\twctx->header_size = 40;\n\n\twctx->no_cslabel = iw_get_value(wctx->ctx,IW_VAL_NO_CSLABEL);\n\n\t// If any kind of compression was requested, use RLE if possible.\n\tif(cmpr_req==IW_COMPRESSION_AUTO || cmpr_req==IW_COMPRESSION_NONE)\n\t\tcmpr_req = IW_COMPRESSION_NONE;\n\telse\n\t\tcmpr_req = IW_COMPRESSION_RLE;\n\n\tif(img->imgtype==IW_IMGTYPE_RGB) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE],0))\n\t\t\t{\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twctx->bitcount=24;\n\t\t}\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_PALETTE) {\n\t\tif(!wctx->pal) goto done;\n\n\t\tx = check_palette_transparency(wctx->pal);\n\n\t\tif(x!=0 && wctx->bmpversion<3) {\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save as a transparent BMP: Incompatible BMP version\");\n\t\t\tgoto done;\n\t\t}\n\t\telse if(x==2) {\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save this image as a transparent BMP: Has partial transparency\");\n\t\t\tgoto done;\n\t\t}\n\t\telse if(x!=0 && cmpr_req!=IW_COMPRESSION_RLE) {\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save as a transparent BMP: RLE compression required\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif(wctx->pal->num_entries<=2 && cmpr_req!=IW_COMPRESSION_RLE)\n\t\t\twctx->bitcount=1;\n\t\telse if(wctx->pal->num_entries<=16)\n\t\t\twctx->bitcount=4;\n\t\telse\n\t\t\twctx->bitcount=8;\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA]))\n\t\t\t{\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(!setup_16_32bit(wctx,255,255,255,255)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_GRAYA) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA]))\n\t\t\t{\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(!setup_16_32bit(wctx,255,255,255,255)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_GRAY) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(img->maxcolorcode[IW_CHANNELTYPE_GRAY]<=1023) {\n\t\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],0))\n\t\t\t\t{\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiw_set_error(wctx->ctx,\"Cannot write grayscale BMP at this bit depth\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We normally won't get here, because a grayscale image should have\n\t\t\t// been optimized and converted to a palette image.\n\t\t\t// But maybe that optimization was disabled.\n\t\t\twctx->bitcount=24;\n\t\t}\n\t}\n\telse {\n\t\tiw_set_error(wctx->ctx,\"Internal: Bad image type for BMP\");\n\t\tgoto done;\n\t}\n\n\tif(cmpr_req==IW_COMPRESSION_RLE && (wctx->bitcount==4 || wctx->bitcount==8)) {\n\t\twctx->compressed = 1;\n\t}\n\n\twctx->unc_dst_bpr = iwbmp_calc_bpr(wctx->bitcount,img->width);\n\twctx->unc_bitssize = wctx->unc_dst_bpr * img->height;\n\twctx->palentries = 0;\n\n\tif(wctx->pal) {\n\t\tif(wctx->bmpversion==2) {\n\t\t\twctx->palentries = 1<<wctx->bitcount;\n\t\t\twctx->palsize = wctx->palentries*3;\n\t\t}\n\t\telse {\n\t\t\tif(wctx->bitcount==1) {\n\t\t\t\t// The documentation says that if the bitdepth is 1, the palette\n\t\t\t\t// contains exactly two entries.\n\t\t\t\twctx->palentries=2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twctx->palentries = wctx->pal->num_entries;\n\t\t\t}\n\t\t\twctx->palsize = wctx->palentries*4;\n\t\t}\n\t}\n\n\t// File header\n\tiwbmp_write_file_header(wctx);\n\n\t// Bitmap header (\"BITMAPINFOHEADER\")\n\tif(!iwbmp_write_bmp_header(wctx)) {\n\t\tgoto done;\n\t}\n\n\tif(wctx->bitfields_size>0) {\n\t\tif(!iwbmp_write_bitfields(wctx)) goto done;\n\t}\n\n\t// Palette\n\tiwbmp_write_palette(wctx);\n\n\t// Pixels\n\tif(wctx->compressed) {\n\t\tif(!iwbmp_write_pixels_compressed(wctx,img)) goto done;\n\t}\n\telse {\n\t\tiwbmp_write_pixels_uncompressed(wctx,img);\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nIW_IMPL(int) iw_write_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iwbmpwcontext wctx;\n\tint retval=0;\n\tstruct iw_image img1;\n\n\tiw_zeromem(&img1,sizeof(struct iw_image));\n\n\tiw_zeromem(&wctx,sizeof(struct iwbmpwcontext));\n\n\twctx.ctx = ctx;\n\twctx.include_file_header = 1;\n\n\twctx.iodescr=iodescr;\n\n\tiw_get_output_image(ctx,&img1);\n\twctx.img = &img1;\n\n\tif(wctx.img->imgtype==IW_IMGTYPE_PALETTE) {\n\t\twctx.pal = iw_get_output_palette(ctx);\n\t\tif(!wctx.pal) goto done;\n\t}\n\n\tiw_get_output_colorspace(ctx,&wctx.csdescr);\n\n\tif(!iwbmp_write_main(&wctx)) {\n\t\tiw_set_error(ctx,\"BMP write failed\");\n\t\tgoto done;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n", "// imagew-util.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n// This file is mainly for portability wrappers, and any code that\n// may require unusual header files (malloc.h, strsafe.h).\n\n#include \"imagew-config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef IW_WINDOWS\n#include <malloc.h>\n#endif\n#include <stdarg.h>\n#include <time.h>\n\n#include \"imagew-internals.h\"\n#ifdef IW_WINDOWS\n#include <strsafe.h>\n#endif\n\n\nvoid* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)\n{\n\tif(flags & IW_MALLOCFLAG_ZEROMEM) {\n\t\treturn calloc(n,1);\n\t}\n\treturn malloc(n);\n}\n\nvoid iwpvt_default_free(void *userdata, void *mem)\n{\n\tfree(mem);\n}\n\nIW_IMPL(void*) iw_malloc_ex(struct iw_context *ctx, unsigned int flags, size_t n)\n{\n\tvoid *mem;\n\n\tif(n>ctx->max_malloc) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\n\tmem = (*ctx->mallocfn)(ctx->userdata,flags,n);\n\n\tif(!mem) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\treturn mem;\n}\n\nIW_IMPL(void*) iw_malloc(struct iw_context *ctx, size_t n)\n{\n\treturn iw_malloc_ex(ctx,0,n);\n}\n\nIW_IMPL(void*) iw_mallocz(struct iw_context *ctx, size_t n)\n{\n\treturn iw_malloc_ex(ctx,IW_MALLOCFLAG_ZEROMEM,n);\n}\n\n// Allocate a large block of memory, presumably for image data.\n// Use this if integer overflow is a possibility when multiplying\n// two factors together.\nIW_IMPL(void*) iw_malloc_large(struct iw_context *ctx, size_t n1, size_t n2)\n{\n\tif(n1 > ctx->max_malloc/n2) {\n\t\tiw_set_error(ctx,\"Image too large to process\");\n\t\treturn NULL;\n\t}\n\treturn iw_malloc_ex(ctx,0,n1*n2);\n}\n\n// Emulate realloc using malloc, by always allocating a new memory block.\nstatic void* emulated_realloc(struct iw_context *ctx, unsigned int flags,\n\tvoid *oldmem, size_t oldmem_size, size_t newmem_size)\n{\n\tvoid *newmem;\n\n\tnewmem = (*ctx->mallocfn)(ctx->userdata,flags,newmem_size);\n\tif(oldmem && newmem) {\n\t\tif(oldmem_size<newmem_size)\n\t\t\tmemcpy(newmem,oldmem,oldmem_size);\n\t\telse\n\t\t\tmemcpy(newmem,oldmem,newmem_size);\n\t}\n\tif(oldmem) {\n\t\t// Our realloc functions always free the old memory, even on failure.\n\t\t(*ctx->freefn)(ctx->userdata,oldmem);\n\t}\n\treturn newmem;\n}\n\nIW_IMPL(void*) iw_realloc_ex(struct iw_context *ctx, unsigned int flags,\n\tvoid *oldmem, size_t oldmem_size, size_t newmem_size)\n{\n\tvoid *mem;\n\n\tif(!oldmem) {\n\t\treturn iw_malloc_ex(ctx,flags,newmem_size);\n\t}\n\n\tif(newmem_size>ctx->max_malloc) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\n\tmem = emulated_realloc(ctx,flags,oldmem,oldmem_size,newmem_size);\n\n\tif(!mem) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\treturn mem;\n}\n\nIW_IMPL(void*) iw_realloc(struct iw_context *ctx, void *oldmem,\n\tsize_t oldmem_size, size_t newmem_size)\n{\n\treturn iw_realloc_ex(ctx,0,oldmem,oldmem_size,newmem_size);\n}\n\nIW_IMPL(void) iw_free(struct iw_context *ctx, void *mem)\n{\n\tif(!mem) return;\n\t// Note that this function can be used to free the ctx struct itself,\n\t// so we're not allowed to use ctx after freeing the memory.\n\t(*ctx->freefn)(ctx->userdata,mem);\n}\n\nIW_IMPL(char*) iw_strdup(struct iw_context *ctx, const char *s)\n{\n\tsize_t len;\n\tchar *s2;\n\tif(!s) return NULL;\n\tlen = strlen(s);\n\ts2 = iw_malloc(ctx, len+1);\n\tif(!s2) return NULL;\n\tmemcpy(s2, s, len+1);\n\treturn s2;\n}\n\nchar* iwpvt_strdup_dbl(struct iw_context *ctx, double n)\n{\n\tchar buf[100];\n\tiw_snprintf(buf, sizeof(buf), \"%.20f\", n);\n\treturn iw_strdup(ctx, buf);\n}\n\nIW_IMPL(void) iw_strlcpy(char *dst, const char *src, size_t dstlen)\n{\n\tsize_t n;\n\tn = strlen(src);\n\tif(n>dstlen-1) n=dstlen-1;\n\tmemcpy(dst,src,n);\n\tdst[n]='\\0';\n}\n\nIW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)\n{\n#ifdef IW_WINDOWS\n\tStringCchVPrintfA(buf,buflen,fmt,ap);\n#else\n\tvsnprintf(buf,buflen,fmt,ap);\n\tbuf[buflen-1]='\\0';\n#endif\n}\n\nIW_IMPL(void) iw_snprintf(char *buf, size_t buflen, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tiw_vsnprintf(buf,buflen,fmt,ap);\n\tva_end(ap);\n}\n\nIW_IMPL(int) iw_stricmp(const char *s1, const char *s2)\n{\n#ifdef IW_WINDOWS\n\treturn _stricmp(s1,s2);\n#else\n\treturn strcasecmp(s1,s2);\n#endif\n}\n\nIW_IMPL(void) iw_zeromem(void *mem, size_t n)\n{\n\tmemset(mem,0,n);\n}\n\n////////////////////////////////////////////\n// A simple carry-with-multiply pseudorandom number generator (PRNG).\n\nstruct iw_prng {\n\tiw_uint32 multiply;\n\tiw_uint32 carry;\n};\n\nstruct iw_prng *iwpvt_prng_create(struct iw_context *ctx)\n{\n\tstruct iw_prng *prng;\n\tprng = (struct iw_prng*)iw_mallocz(ctx,sizeof(struct iw_prng));\n\tif(!prng) return NULL;\n\treturn prng;\n}\n\nvoid iwpvt_prng_destroy(struct iw_context *ctx, struct iw_prng *prng)\n{\n\tif(prng) iw_free(ctx,(void*)prng);\n}\n\nvoid iwpvt_prng_set_random_seed(struct iw_prng *prng, int s)\n{\n\tprng->multiply = ((iw_uint32)0x03333333) + s;\n\tprng->carry    = ((iw_uint32)0x05555555) + s;\n}\n\niw_uint32 iwpvt_prng_rand(struct iw_prng *prng)\n{\n\tiw_uint64 x;\n\tx = ((iw_uint64)0xfff0bf23) * prng->multiply + prng->carry;\n\tprng->carry = (iw_uint32)(x>>32);\n\tprng->multiply = 0xffffffff - (0xffffffff & x);\n\treturn prng->multiply;\n}\n\n////////////////////////////////////////////\n\nint iwpvt_util_randomize(struct iw_prng *prng)\n{\n\tint s;\n\ts = (int)time(NULL);\n\tiwpvt_prng_set_random_seed(prng, s);\n\treturn s;\n}\n\nIW_IMPL(int) iw_file_to_memory(struct iw_context *ctx, struct iw_iodescr *iodescr,\n  void **pmem, iw_int64 *psize)\n{\n\tint ret;\n\tsize_t bytesread;\n\n\t*pmem=NULL;\n\t*psize=0;\n\n\tif(!iodescr->getfilesize_fn) return 0;\n\n\tret = (*iodescr->getfilesize_fn)(ctx,iodescr,psize);\n\t// TODO: Don't require a getfilesize function.\n\tif(!ret) return 0;\n\n\t*pmem = iw_malloc(ctx,(size_t)*psize);\n\n\tret = (*iodescr->read_fn)(ctx,iodescr,*pmem,(size_t)*psize,&bytesread);\n\tif(!ret) return 0;\n\tif((iw_int64)bytesread != *psize) return 0;\n\treturn 1;\n}\n\nstruct iw_utf8cvt_struct {\n\tchar *dst;\n\tint dstlen;\n\tint dp;\n};\n\nstatic void utf8cvt_emitoctet(struct iw_utf8cvt_struct *s, unsigned char c)\n{\n\tif(s->dp > s->dstlen-2) return;\n\ts->dst[s->dp] = (char)c;\n\ts->dp++;\n}\n\n// Map Unicode characters to ASCII substitutions.\n// Not used for codepoints <=127.\nstatic void utf8cvt_emitunichar(struct iw_utf8cvt_struct *s, unsigned int c)\n{\n\tint i;\n\tint pos;\n\tstruct charmap_struct {\n\t\tunsigned int code;\n\t\tconst char *s;\n\t};\n\tstatic const struct charmap_struct chartable[] = {\n\t {0, \"?\" }, // Default character\n\t {0x00a9, \"(c)\" },\n\t {0x00d7, \"x\" }, // multiplication sign\n\t {0x2013, \"-\" }, // en dash\n\t {0x2018, \"'\" }, // left single quote\n\t {0x2019, \"'\" }, // right single quote\n\t {0x201c, \"\\\"\" }, // left double quote\n\t {0x201d, \"\\\"\" }, // right double quote\n\t {0x2192, \"->\" },\n\t {0xfeff, \"\" }, // zero-width no-break space\n\t {0, NULL}\n\t};\n\n\t// Try to find the codepoint in the table.\n\tpos = 0;\n\tfor(i=1;chartable[i].code;i++) {\n\t\tif(c==chartable[i].code) {\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Write out the ASCII translation of this code.\n\tfor(i=0;chartable[pos].s[i];i++) {\n\t\tutf8cvt_emitoctet(s,(unsigned char)chartable[pos].s[i]);\n\t}\n}\n\n// This UTF-8 converter is intended to be safe to use with malformed data, but\n// it may not handle it in the best possible way. It mostly just skips over it.\nIW_IMPL(void) iw_utf8_to_ascii(const char *src, char *dst, int dstlen)\n{\n\tstruct iw_utf8cvt_struct s;\n\tint sp;\n\tunsigned char c;\n\tunsigned int pending_char;\n\tint bytes_expected;\n\n\ts.dst = dst;\n\ts.dstlen = dstlen;\n\ts.dp = 0;\n\tpending_char=0;\n\tbytes_expected=0;\n\n\tfor(sp=0;src[sp];sp++) {\n\t\tc = (unsigned char)src[sp];\n\t\tif(c<128) { // Only byte of a 1-byte sequence\n\t\t\tutf8cvt_emitoctet(&s,c);\n\t\t\tbytes_expected=0;\n\t\t}\n\t\telse if(c<0xc0) { // Continuation byte\n\t\t\tif(bytes_expected>0) {\n\t\t\t\tpending_char = (pending_char<<6)|(c&0x3f);\n\t\t\t\tbytes_expected--;\n\t\t\t\tif(bytes_expected<1) {\n\t\t\t\t\tutf8cvt_emitunichar(&s,pending_char);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(c<0xe0) { // 1st byte of a 2-byte sequence\n\t\t\tpending_char = c&0x1f;\n\t\t\tbytes_expected=1;\n\t\t}\n\t\telse if(c<0xf0) { // 1st byte of a 3-byte sequence\n\t\t\tpending_char = c&0x0f;\n\t\t\tbytes_expected=2;\n\t\t}\n\t\telse if(c<0xf8) { // 1st byte of a 4-byte sequence\n\t\t\tpending_char = c&0x07;\n\t\t\tbytes_expected=3;\n\t\t}\n\t}\n\tdst[s.dp] = '\\0';\n}\n\nIW_IMPL(int) iw_get_host_endianness(void)\n{\n\tiw_byte b;\n\tunsigned int x = 1;\n\tmemcpy(&b,&x,1);\n\treturn b==0 ? IW_ENDIAN_BIG : IW_ENDIAN_LITTLE;\n}\n\nIW_IMPL(void) iw_set_ui16le(iw_byte *b, unsigned int n)\n{\n\tb[0] = n&0xff;\n\tb[1] = (n>>8)&0xff;\n}\n\nIW_IMPL(void) iw_set_ui32le(iw_byte *b, unsigned int n)\n{\n\tb[0] = n&0xff;\n\tb[1] = (n>>8)&0xff;\n\tb[2] = (n>>16)&0xff;\n\tb[3] = (n>>24)&0xff;\n}\n\nIW_IMPL(void) iw_set_ui16be(iw_byte *b, unsigned int n)\n{\n\tb[0] = (n>>8)&0xff;\n\tb[1] = n&0xff;\n}\n\nIW_IMPL(void) iw_set_ui32be(iw_byte *b, unsigned int n)\n{\n\tb[0] = (n>>24)&0xff;\n\tb[1] = (n>>16)&0xff;\n\tb[2] = (n>>8)&0xff;\n\tb[3] = n&0xff;\n}\n\nIW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}\n\nIW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}\n\nIW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}\n\nIW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}\n\nIW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}\n\n// Accepts a flag indicating the endianness.\nIW_IMPL(unsigned int) iw_get_ui16_e(const iw_byte *b, int endian)\n{\n\tif(endian==IW_ENDIAN_LITTLE)\n\t\treturn iw_get_ui16le(b);\n\treturn iw_get_ui16be(b);\n}\n\nIW_IMPL(unsigned int) iw_get_ui32_e(const iw_byte *b, int endian)\n{\n\tif(endian==IW_ENDIAN_LITTLE)\n\t\treturn iw_get_ui32le(b);\n\treturn iw_get_ui32be(b);\n}\n\nIW_IMPL(int) iw_max_color_to_bitdepth(unsigned int mc)\n{\n\tunsigned int bd;\n\n\tfor(bd=1;bd<=15;bd++) {\n\t\tif(mc < (1U<<bd)) return bd;\n\t}\n\treturn 16;\n}\n\nIW_IMPL(int) iw_detect_fmt_from_filename(const char *fn)\n{\n\tchar *s;\n\tint i;\n\tstruct fmttable_struct {\n\t\tconst char *ext;\n\t\tint fmt;\n\t};\n\tstatic const struct fmttable_struct fmttable[] = {\n\t {\"png\", IW_FORMAT_PNG},\n\t {\"jpg\", IW_FORMAT_JPEG},\n\t {\"jpeg\", IW_FORMAT_JPEG},\n\t {\"bmp\", IW_FORMAT_BMP},\n\t {\"tif\", IW_FORMAT_TIFF},\n\t {\"tiff\", IW_FORMAT_TIFF},\n\t {\"miff\", IW_FORMAT_MIFF},\n\t {\"webp\", IW_FORMAT_WEBP},\n\t {\"gif\", IW_FORMAT_GIF},\n\t {\"pnm\", IW_FORMAT_PNM},\n\t {\"pbm\", IW_FORMAT_PBM},\n\t {\"pgm\", IW_FORMAT_PGM},\n\t {\"ppm\", IW_FORMAT_PPM},\n\t {\"pam\", IW_FORMAT_PAM},\n\t {NULL, 0}\n\t};\n\n\ts=strrchr(fn,'.');\n\tif(!s) return IW_FORMAT_UNKNOWN;\n\ts++;\n\n\tfor(i=0;fmttable[i].ext;i++) {\n\t\tif(!iw_stricmp(s,fmttable[i].ext)) return fmttable[i].fmt;\n\t}\n\t\n\treturn IW_FORMAT_UNKNOWN;\n}\n\nIW_IMPL(const char*) iw_get_fmt_name(int fmt)\n{\n\tstatic const char *n;\n\tn=NULL;\n\tswitch(fmt) {\n\tcase IW_FORMAT_PNG:  n=\"PNG\";  break;\n\tcase IW_FORMAT_JPEG: n=\"JPEG\"; break;\n\tcase IW_FORMAT_BMP:  n=\"BMP\";  break;\n\tcase IW_FORMAT_TIFF: n=\"TIFF\"; break;\n\tcase IW_FORMAT_MIFF: n=\"MIFF\"; break;\n\tcase IW_FORMAT_WEBP: n=\"WebP\"; break;\n\tcase IW_FORMAT_GIF:  n=\"GIF\";  break;\n\tcase IW_FORMAT_PNM:  n=\"PNM\";  break;\n\tcase IW_FORMAT_PBM:  n=\"PBM\";  break;\n\tcase IW_FORMAT_PGM:  n=\"PGM\";  break;\n\tcase IW_FORMAT_PPM:  n=\"PPM\";  break;\n\tcase IW_FORMAT_PAM:  n=\"PAM\";  break;\n\t}\n\treturn n;\n}\n\nIW_IMPL(int) iw_detect_fmt_of_file(const iw_byte *buf, size_t n)\n{\n\tint fmt = IW_FORMAT_UNKNOWN;\n\n\tif(n<2) return fmt;\n\n\tif(buf[0]==0x89 && buf[1]==0x50) {\n\t\tfmt=IW_FORMAT_PNG;\n\t}\n\telse if(n>=3 && buf[0]=='G' && buf[1]=='I' && buf[2]=='F') {\n\t\tfmt=IW_FORMAT_GIF;\n\t}\n\telse if(buf[0]==0xff && buf[1]==0xd8) {\n\t\tfmt=IW_FORMAT_JPEG;\n\t}\n\telse if(buf[0]=='B' && buf[1]=='M') {\n\t\tfmt=IW_FORMAT_BMP;\n\t}\n\telse if(buf[0]=='B' && buf[1]=='A') {\n\t\tfmt=IW_FORMAT_BMP;\n\t}\n\telse if((buf[0]==0x49 || buf[0]==0x4d) && buf[1]==buf[0]) {\n\t\tfmt=IW_FORMAT_TIFF;\n\t}\n\telse if(buf[0]==0x69 && buf[1]==0x64) {\n\t\tfmt=IW_FORMAT_MIFF;\n\t}\n\telse if(n>=12 && buf[0]==0x52 && buf[1]==0x49 && buf[2]==0x46 && buf[3]==0x46 &&\n\t   buf[8]==0x57 && buf[9]==0x45 && buf[10]==0x42 && buf[11]==0x50)\n\t{\n\t\tfmt=IW_FORMAT_WEBP;\n\t}\n\telse if(buf[0]=='P' && (buf[1]>='1' && buf[1]<='6')) {\n\t\treturn IW_FORMAT_PNM;\n\t}\n\telse if(buf[0]=='P' && (buf[1]=='7' && buf[2]==0x0a)) {\n\t\treturn IW_FORMAT_PAM;\n\t}\n\n\treturn fmt;\n}\n\nIW_IMPL(unsigned int) iw_get_profile_by_fmt(int fmt)\n{\n\tunsigned int p;\n\n\tswitch(fmt) {\n\n\tcase IW_FORMAT_PNG:\n\t\tp = IW_PROFILE_TRANSPARENCY | IW_PROFILE_GRAYSCALE | IW_PROFILE_PALETTETRNS |\n\t\t    IW_PROFILE_GRAY1 | IW_PROFILE_GRAY2 | IW_PROFILE_GRAY4 | IW_PROFILE_16BPS |\n\t\t    IW_PROFILE_BINARYTRNS | IW_PROFILE_PAL1 | IW_PROFILE_PAL2 | IW_PROFILE_PAL4 |\n\t\t    IW_PROFILE_PAL8 | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_PNG_BKGD;\n\t\tbreak;\n\n\tcase IW_FORMAT_BMP:\n\t\tp = IW_PROFILE_PAL1 | IW_PROFILE_PAL4 | IW_PROFILE_PAL8 |\n\t\t\tIW_PROFILE_REDUCEDBITDEPTHS;\n\t\tbreak;\n\n\tcase IW_FORMAT_JPEG:\n\t\tp = IW_PROFILE_GRAYSCALE;\n\t\tbreak;\n\n\tcase IW_FORMAT_TIFF:\n\t\tp = IW_PROFILE_TRANSPARENCY | IW_PROFILE_GRAYSCALE | IW_PROFILE_GRAY1 |\n\t\t    IW_PROFILE_GRAY4 | IW_PROFILE_16BPS | IW_PROFILE_PAL4 | IW_PROFILE_PAL8;\n\t\tbreak;\n\n\tcase IW_FORMAT_MIFF:\n\t\tp = IW_PROFILE_TRANSPARENCY | IW_PROFILE_GRAYSCALE | IW_PROFILE_ALWAYSLINEAR |\n\t\t    IW_PROFILE_HDRI | IW_PROFILE_RGB16_BKGD;\n\t\tbreak;\n\n\tcase IW_FORMAT_WEBP:\n\t\tp = 0;\n#if IW_WEBP_SUPPORT_TRANSPARENCY\n\t\tp |= IW_PROFILE_TRANSPARENCY;\n#endif\n\t\tbreak;\n\n\tcase IW_FORMAT_PAM:\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_GRAYSCALE |\n\t\t\tIW_PROFILE_GRAY1 | IW_PROFILE_TRANSPARENCY;\n\t\tbreak;\n\n\tcase IW_FORMAT_PNM:\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_GRAYSCALE |\n\t\t\tIW_PROFILE_GRAY1;\n\t\tbreak;\n\n\tcase IW_FORMAT_PPM:\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS;\n\t\tbreak;\n\n\tcase IW_FORMAT_PGM:\n\t\t// No reason to set GRAY[124], because we can't optimize for them. Each pixel\n\t\t// uses a minimum of one byte.\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_GRAYSCALE;\n\t\tbreak;\n\n\tcase IW_FORMAT_PBM:\n\t\tp = IW_PROFILE_GRAY1;\n\t\tbreak;\n\n\tdefault:\n\t\tp = 0;\n\t}\n\n\treturn p;\n}\n\n// The imagew-allfmts.c file is probably a more logical place for the\n// iw_is_*_fmt_supported() functions, but putting them there could create\n// unnecessary dependencies on third-party libraries.\n\nIW_IMPL(int) iw_is_input_fmt_supported(int fmt)\n{\n\tswitch(fmt) {\n#if IW_SUPPORT_PNG == 1\n\tcase IW_FORMAT_PNG:\n#endif\n#if IW_SUPPORT_JPEG == 1\n\tcase IW_FORMAT_JPEG:\n#endif\n#if IW_SUPPORT_WEBP == 1\n\tcase IW_FORMAT_WEBP:\n#endif\n\tcase IW_FORMAT_MIFF:\n\tcase IW_FORMAT_GIF:\n\tcase IW_FORMAT_BMP:\n\tcase IW_FORMAT_PNM:\n\tcase IW_FORMAT_PAM:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nIW_IMPL(int) iw_is_output_fmt_supported(int fmt)\n{\n\tswitch(fmt) {\n#if IW_SUPPORT_PNG == 1\n\tcase IW_FORMAT_PNG:\n#endif\n#if IW_SUPPORT_JPEG == 1\n\tcase IW_FORMAT_JPEG:\n#endif\n#if IW_SUPPORT_WEBP == 1\n\tcase IW_FORMAT_WEBP:\n#endif\n\tcase IW_FORMAT_BMP:\n\tcase IW_FORMAT_TIFF:\n\tcase IW_FORMAT_MIFF:\n\tcase IW_FORMAT_PNM:\n\tcase IW_FORMAT_PPM:\n\tcase IW_FORMAT_PGM:\n\tcase IW_FORMAT_PBM:\n\tcase IW_FORMAT_PAM:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n// Find where a number ends (at a comma, or the end of string),\n// and record if it contained a slash.\nstatic int iw_get_number_len(const char *s, int *pslash_pos)\n{\n\tint i;\n\tfor(i=0;s[i];i++) {\n\t\tif(s[i]=='/') {\n\t\t\t*pslash_pos = i;\n\t\t}\n\t\tif(s[i]!=',') continue;\n\t\treturn i;\n\t}\n\treturn i;\n}\n\n// Returns 0 if no valid number found.\nstatic int iw_parse_number_internal(const char *s,\n\t\t   double *presult, int *pcharsread)\n{\n\tint len;\n\tint slash_pos = -1;\n\n\t*presult = 0.0;\n\t*pcharsread = 0;\n\n\tlen = iw_get_number_len(s,&slash_pos);\n\tif(len<1) return 0;\n\t*pcharsread = len;\n\n\tif(slash_pos>=0) {\n\t\t// a rational number\n\t\tdouble numer, denom;\n\t\tnumer = atof(s);\n\t\tdenom = atof(s+slash_pos+1);\n\t\tif(denom==0.0)\n\t\t\t*presult = 0.0;\n\t\telse\n\t\t\t*presult = numer/denom;\n\t}\n\telse {\n\t\t*presult = atof(s);\n\t}\n\treturn 1;\n}\n\n// Returns number of numbers parsed.\n// If there are not enough numbers, leaves some contents of 'results' unchanged.\nIW_IMPL(int) iw_parse_number_list(const char *s,\n\tint max_numbers, // max number of numbers to parse\n\tdouble *results) // array of doubles to hold the results\n{\n\tint n;\n\tint charsread;\n\tint curpos=0;\n\tint ret;\n\tint numresults = 0;\n\n\tfor(n=0;n<max_numbers;n++) {\n\t\tret=iw_parse_number_internal(&s[curpos], &results[n], &charsread);\n\t\tif(!ret) break;\n\t\tnumresults++;\n\t\tcurpos+=charsread;\n\t\tif(s[curpos]==',') {\n\t\t\tcurpos++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn numresults;\n}\n\nIW_IMPL(double) iw_parse_number(const char *s)\n{\n\tdouble result;\n\tint charsread;\n\tiw_parse_number_internal(s, &result, &charsread);\n\treturn result;\n}\n\nIW_IMPL(int) iw_round_to_int(double x)\n{\n\tif(x<0.0) return -(int)(0.5-x);\n\treturn (int)(0.5+x);\n}\n\nIW_IMPL(int) iw_parse_int(const char *s)\n{\n\tdouble result;\n\tint charsread;\n\tiw_parse_number_internal(s, &result, &charsread);\n\treturn iw_round_to_int(result);\n}\n"], "fixing_code": ["// imagew-bmp.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n#include \"imagew-config.h\"\n\n#include <stdio.h> // for SEEK_SET\n#include <stdlib.h>\n#include <string.h>\n\n#define IW_INCLUDE_UTIL_FUNCTIONS\n#include \"imagew.h\"\n\n#define IWBMP_BI_RGB       0 // = uncompressed\n#define IWBMP_BI_RLE8      1\n#define IWBMP_BI_RLE4      2\n#define IWBMP_BI_BITFIELDS 3\n#define IWBMP_BI_JPEG      4\n#define IWBMP_BI_PNG       5\n\n#define IWBMPCS_CALIBRATED_RGB    0\n#define IWBMPCS_DEVICE_RGB        1 // (Unconfirmed)\n#define IWBMPCS_DEVICE_CMYK       2 // (Unconfirmed)\n#define IWBMPCS_SRGB              0x73524742\n#define IWBMPCS_WINDOWS           0x57696e20\n#define IWBMPCS_PROFILE_LINKED    0x4c494e4b\n#define IWBMPCS_PROFILE_EMBEDDED  0x4d424544\n\nstatic size_t iwbmp_calc_bpr(int bpp, size_t width)\n{\n\treturn ((bpp*width+31)/32)*4;\n}\n\nstruct iwbmprcontext {\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\tint bmpversion;\n\tint width, height;\n\tint topdown;\n\tint has_fileheader;\n\tunsigned int bitcount; // bits per pixel\n\tunsigned int compression; // IWBMP_BI_*\n\tint uses_bitfields; // 'compression' is BI_BITFIELDS\n\tint has_alpha_channel;\n\tint bitfields_set;\n\tint need_16bit;\n\tunsigned int palette_entries;\n\tsize_t fileheader_size;\n\tsize_t infoheader_size;\n\tsize_t bitfields_nbytes; // Bytes consumed by BITFIELDs, if not part of the header.\n\tsize_t palette_nbytes;\n\tsize_t bfOffBits;\n\tstruct iw_palette palette;\n\n\t// For 16- & 32-bit images:\n\tunsigned int bf_mask[4];\n\tint bf_high_bit[4];\n\tint bf_low_bit[4];\n\tint bf_bits_count[4]; // number of bits in each channel\n\n\tstruct iw_csdescr csdescr;\n};\n\nstatic int iwbmp_read(struct iwbmprcontext *rctx,\n\t\tiw_byte *buf, size_t buflen)\n{\n\tint ret;\n\tsize_t bytesread = 0;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\tbuf,buflen,&bytesread);\n\tif(!ret || bytesread!=buflen) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwbmp_skip_bytes(struct iwbmprcontext *rctx, size_t n)\n{\n\tiw_byte buf[1024];\n\tsize_t still_to_read;\n\tsize_t num_to_read;\n\n\tstill_to_read = n;\n\twhile(still_to_read>0) {\n\t\tnum_to_read = still_to_read;\n\t\tif(num_to_read>1024) num_to_read=1024;\n\t\tif(!iwbmp_read(rctx,buf,num_to_read)) {\n\t\t\treturn 0;\n\t\t}\n\t\tstill_to_read -= num_to_read;\n\t}\n\treturn 1;\n}\n\nstatic int iwbmp_read_file_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[14];\n\n\tif(!iwbmp_read(rctx,buf,14)) return 0;\n\trctx->fileheader_size = 14;\n\n\tif(buf[0]=='B' && buf[1]=='A') { // OS/2 Bitmap Array\n\t\t// TODO: This type of file can contain more than one BMP image.\n\t\t// We only support the first one.\n\t\tif(!iwbmp_read(rctx,buf,14)) return 0;\n\t\trctx->fileheader_size += 14;\n\t}\n\n\tif(buf[0]=='B' && buf[1]=='M') {\n\t\t;\n\t}\n\telse if((buf[0]=='C' && buf[1]=='I') || // OS/2 Color Icon\n\t   (buf[0]=='C' && buf[1]=='P') || // OS/2 Color Pointer\n\t   (buf[0]=='I' && buf[1]=='C') || // OS/2 Icon\n\t   (buf[0]=='P' && buf[1]=='T'))   // OS/2 Pointer\n\t{\n\t\tiw_set_error(rctx->ctx,\"This type of BMP file is not supported\");\n\t\treturn 0;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\"Not a BMP file\");\n\t\treturn 0;\n\t}\n\n\trctx->bfOffBits = iw_get_ui32le(&buf[10]);\n\treturn 1;\n}\n\n// Read the 12-byte header of a Windows v2 BMP (also known as OS/2 v1 BMP).\nstatic int decode_v2_header(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\n\trctx->width = iw_get_ui16le(&buf[4]);\n\trctx->height = iw_get_ui16le(&buf[6]);\n\tnplanes = iw_get_ui16le(&buf[8]);\n\tif(nplanes!=1) return 0;\n\trctx->bitcount = iw_get_ui16le(&buf[10]);\n\tif(rctx->bitcount!=1 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=24)\n\t{\n\t\treturn 0;\n\t}\n\tif(rctx->bitcount<=8) {\n\t\tsize_t palette_start, palette_end;\n\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\n\t\t// Since v2 BMPs have no direct way to indicate that the palette is not\n\t\t// full-sized, assume the palette ends no later than the start of the\n\t\t// bitmap bits.\n\t\tpalette_start = rctx->fileheader_size + rctx->infoheader_size;\n\t\tpalette_end = palette_start + rctx->palette_nbytes;\n\t\tif(rctx->bfOffBits >= palette_start+3 && rctx->bfOffBits < palette_end) {\n\t\t\trctx->palette_entries = (unsigned int)((rctx->bfOffBits - palette_start)/3);\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\treturn 1;\n}\n\n// Read a Windows v3 or OS/2 v2 header.\nstatic int decode_v3_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int nplanes;\n\tint biXPelsPerMeter, biYPelsPerMeter;\n\tunsigned int biClrUsed = 0;\n\t//unsigned int biSizeImage;\n\n\trctx->width = iw_get_i32le(&buf[4]);\n\trctx->height = iw_get_i32le(&buf[8]);\n\tif(rctx->height<0) {\n\t\trctx->height = -rctx->height;\n\t\trctx->topdown = 1;\n\t}\n\n\tnplanes = iw_get_ui16le(&buf[12]);\n\tif(nplanes!=1) return 0;\n\n\trctx->bitcount = iw_get_ui16le(&buf[14]);\n\t// We allow bitcount=2 because it's legal in Windows CE BMPs.\n\tif(rctx->bitcount!=1 && rctx->bitcount!=2 && rctx->bitcount!=4 &&\n\t\trctx->bitcount!=8 && rctx->bitcount!=16 && rctx->bitcount!=24 &&\n\t\trctx->bitcount!=32)\n\t{\n\t\tiw_set_errorf(rctx->ctx,\"Bad or unsupported bit count (%d)\",(int)rctx->bitcount);\n\t\treturn 0;\n\t}\n\n\tif(rctx->infoheader_size<=16) {\n\t\tgoto infoheaderdone;\n\t}\n\n\trctx->compression = iw_get_ui32le(&buf[16]);\n\tif(rctx->compression==IWBMP_BI_BITFIELDS) {\n\t\tif(rctx->bitcount==1) {\n\t\t\tiw_set_error(rctx->ctx,\"Huffman 1D compression not supported\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if(rctx->bitcount!=16 && rctx->bitcount!=32) {\n\t\t\tiw_set_error(rctx->ctx,\"Bad or unsupported image type\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// The compression field is overloaded: BITFIELDS is not a type of\n\t\t// compression. Un-overload it.\n\t\trctx->uses_bitfields = 1;\n\n\t\t// The v4/v5 documentation for the \"BitCount\" field says that the\n\t\t// BITFIELDS data comes after the header, the same as with v3.\n\t\t// The v4/v5 documentation for the \"Compression\" field says that the\n\t\t// BITFIELDS data is stored in the \"Mask\" fields of the header.\n\t\t// Am I supposed to conclude that it is redundantly stored in both\n\t\t// places?\n\t\t// Evidence and common sense suggests the \"BitCount\" documentation is\n\t\t// incorrect, and v4/v5 BMPs never have a separate \"bitfields\" segment.\n\t\tif(rctx->bmpversion==3) {\n\t\t\trctx->bitfields_nbytes = 12;\n\t\t}\n\n\t\trctx->compression=IWBMP_BI_RGB;\n\t}\n\n\t//biSizeImage = iw_get_ui32le(&buf[20]);\n\tbiXPelsPerMeter = iw_get_i32le(&buf[24]);\n\tbiYPelsPerMeter = iw_get_i32le(&buf[28]);\n\n\trctx->img->density_code = IW_DENSITY_UNITS_PER_METER;\n\trctx->img->density_x = (double)biXPelsPerMeter;\n\trctx->img->density_y = (double)biYPelsPerMeter;\n\tif(!iw_is_valid_density(rctx->img->density_x,rctx->img->density_y,rctx->img->density_code)) {\n\t\trctx->img->density_code=IW_DENSITY_UNKNOWN;\n\t}\n\n\tbiClrUsed = iw_get_ui32le(&buf[32]);\n\tif(biClrUsed>100000) return 0;\n\ninfoheaderdone:\n\t// The documentation of the biClrUsed field is not very clear.\n\t// I'm going to assume that if biClrUsed is 0 and bitcount<=8, then\n\t// the number of palette colors is the maximum that would be useful\n\t// for that bitcount. In all other cases, the number of palette colors\n\t// equals biClrUsed.\n\tif(biClrUsed==0 && rctx->bitcount<=8) {\n\t\trctx->palette_entries = 1<<rctx->bitcount;\n\t}\n\telse {\n\t\trctx->palette_entries = biClrUsed;\n\t}\n\trctx->palette_nbytes = 4*rctx->palette_entries;\n\treturn 1;\n}\n\nstatic int process_bf_mask(struct iwbmprcontext *rctx, int k);\n\n// Decode the fields that are in v4 and not in v3.\nstatic int decode_v4_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tint k;\n\tunsigned int cstype;\n\n\tif(rctx->uses_bitfields) {\n\t\t// Set the bitfields masks here, instead of in iwbmp_read_bitfields().\n\t\tfor(k=0;k<4;k++) {\n\t\t\trctx->bf_mask[k] = 0;\n\t\t}\n\t\tfor(k=0;k<4;k++) {\n\t\t\tif(rctx->infoheader_size < (size_t)(40+k*4+4)) break;\n\t\t\trctx->bf_mask[k] = iw_get_ui32le(&buf[40+k*4]);\n\t\t\tif(!process_bf_mask(rctx,k)) return 0;\n\t\t}\n\t\trctx->bitfields_set=1; // Remember not to overwrite the bf_* fields.\n\n\t\tif(rctx->bf_mask[3]!=0) {\n\t\t\t// The documentation says this is the mask that \"specifies the\n\t\t\t// alpha component of each pixel.\"\n\t\t\t// It doesn't say whther it's associated, or unassociated alpha.\n\t\t\t// It doesn't say whether 0=transparent, or 0=opaque.\n\t\t\t// It doesn't say how to tell whether an image has an alpha\n\t\t\t// channel.\n\t\t\t// These are the answers I'm going with:\n\t\t\t// - Unassociated alpha\n\t\t\t// - 0=transparent\n\t\t\t// - 16- and 32-bit images have an alpha channel if 'compression'\n\t\t\t// is set to BI_BITFIELDS, and this alpha mask is nonzero.\n\t\t\trctx->has_alpha_channel = 1;\n\t\t}\n\t}\n\n\tif(rctx->infoheader_size < 108) return 1;\n\n\tcstype = iw_get_ui32le(&buf[56]);\n\tswitch(cstype) {\n\tcase IWBMPCS_CALIBRATED_RGB:\n\t\t//  \"indicates that endpoints and gamma values are given in the\n\t\t//    appropriate fields.\"  (TODO)\n\t\tbreak;\n\n\tcase IWBMPCS_DEVICE_RGB:\n\tcase IWBMPCS_SRGB:\n\tcase IWBMPCS_WINDOWS:\n\t\tbreak;\n\n\tcase IWBMPCS_PROFILE_LINKED:\n\tcase IWBMPCS_PROFILE_EMBEDDED:\n\t\tif(rctx->bmpversion<5) {\n\t\t\tiw_warning(rctx->ctx,\"Invalid colorspace type for BMPv4\");\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tiw_warningf(rctx->ctx,\"Unrecognized or unsupported colorspace type (0x%x)\",cstype);\n\t}\n\n\t// Read Gamma fields\n\tif(cstype==IWBMPCS_CALIBRATED_RGB) {\n\t\tunsigned int bmpgamma;\n\t\tdouble gamma[3];\n\t\tdouble avggamma;\n\n\t\tfor(k=0;k<3;k++) {\n\t\t\tbmpgamma = iw_get_ui32le(&buf[96+k*4]);\n\t\t\tgamma[k] = ((double)bmpgamma)/65536.0;\n\t\t}\n\t\tavggamma = (gamma[0] + gamma[1] + gamma[2])/3.0;\n\n\t\tif(avggamma>=0.1 && avggamma<=10.0) {\n\t\t\tiw_make_gamma_csdescr(&rctx->csdescr,1.0/avggamma);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n// Decode the fields that are in v5 and not in v4.\nstatic int decode_v5_header_fields(struct iwbmprcontext *rctx, const iw_byte *buf)\n{\n\tunsigned int intent_bmp_style;\n\tint intent_iw_style;\n\n\tintent_bmp_style = iw_get_ui32le(&buf[108]);\n\tintent_iw_style = IW_INTENT_UNKNOWN;\n\tswitch(intent_bmp_style) {\n\t\tcase 1: intent_iw_style = IW_INTENT_SATURATION; break; // LCS_GM_BUSINESS\n\t\tcase 2: intent_iw_style = IW_INTENT_RELATIVE; break; // LCS_GM_GRAPHICS\n\t\tcase 4: intent_iw_style = IW_INTENT_PERCEPTUAL; break; // LCS_GM_IMAGES\n\t\tcase 8: intent_iw_style = IW_INTENT_ABSOLUTE; break; // LCS_GM_ABS_COLORIMETRIC\n\t}\n\trctx->img->rendering_intent = intent_iw_style;\n\n\t// The profile may either be after the color table, or after the bitmap bits.\n\t// I'm assuming that we will never need to use the profile size in order to\n\t// find the bitmap bits; i.e. that if the bfOffBits field in the file header\n\t// is not available, the profile must be after the bits.\n\t//profile_offset = iw_get_ui32le(&buf[112]); // bV5ProfileData;\n\t//profile_size = iw_get_ui32le(&buf[116]); // bV5ProfileSize;\n\n\treturn 1;\n}\n\nstatic int iwbmp_read_info_header(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[124];\n\tint retval = 0;\n\tsize_t n;\n\n\t// First, read just the \"size\" field. It tells the size of the header\n\t// structure, and identifies the BMP version.\n\tif(!iwbmp_read(rctx,buf,4)) goto done;\n\trctx->infoheader_size = iw_get_ui32le(&buf[0]);\n\tif(rctx->infoheader_size<12) goto done;\n\n\t// Read the rest of the header.\n\tn = rctx->infoheader_size;\n\tif(n>sizeof(buf)) n=sizeof(buf);\n\tif(!iwbmp_read(rctx,&buf[4],n-4)) goto done;\n\n\tif(rctx->infoheader_size==12) {\n\t\t// This is a \"Windows BMP v2\" or \"OS/2 BMP v1\" bitmap.\n\t\trctx->bmpversion=2;\n\t\tif(!decode_v2_header(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==16 || rctx->infoheader_size==40 || rctx->infoheader_size==64) {\n\t\t// A Windows v3 or OS/2 v2 BMP.\n\t\t// OS/2 v2 BMPs can technically have other header sizes between 16 and 64,\n\t\t// but it's not clear if such files actually exist.\n\t\trctx->bmpversion=3;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==108 || rctx->infoheader_size==52 || rctx->infoheader_size==56) {\n\t\t// We assume a a 52- or 56-byte header is for BITMAPV2INFOHEADER/BITMAPV3INFOHEADER,\n\t\t// and not OS/2v2 format. But if it OS/2v2, it will probably either work (because\n\t\t// the formats are similar enough), or fail due to an unsupported combination of\n\t\t// compression and bits/pixel.\n\t\trctx->bmpversion=4;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t}\n\telse if(rctx->infoheader_size==124) {\n\t\trctx->bmpversion=5;\n\t\tif(!decode_v3_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v4_header_fields(rctx,buf)) goto done;\n\t\tif(!decode_v5_header_fields(rctx,buf)) goto done;\n\t}\n\telse {\n\t\tiw_set_error(rctx->ctx,\"Unsupported BMP version\");\n\t\tgoto done;\n\t}\n\n\tif(!iw_check_image_dimensions(rctx->ctx,rctx->width,rctx->height)) {\n\t\tgoto done;\n\t}\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}\n\n// Find the highest/lowest bit that is set.\nstatic int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}\nstatic int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}\n\n// Given .bf_mask[k], set high_bit[k], low_bit[k], etc.\nstatic int process_bf_mask(struct iwbmprcontext *rctx, int k)\n{\n\t// The bits representing the mask for each channel are required to be\n\t// contiguous, so all we need to do is find the highest and lowest bit.\n\trctx->bf_high_bit[k] = find_high_bit(rctx->bf_mask[k]);\n\trctx->bf_low_bit[k] = find_low_bit(rctx->bf_mask[k]);\n\trctx->bf_bits_count[k] = 1+rctx->bf_high_bit[k]-rctx->bf_low_bit[k];\n\n\t// Check if the mask specifies an invalid bit\n\tif(rctx->bf_high_bit[k] > (int)(rctx->bitcount-1)) return 0;\n\n\tif(rctx->bf_bits_count[k]>16) {\n\t\t// We only support up to 16 bits. Ignore any bits after the 16th.\n\t\trctx->bf_low_bit[k] = rctx->bf_high_bit[k]-15;\n\t\trctx->bf_bits_count[k] = 16;\n\t}\n\n\tif(rctx->bf_bits_count[k]>8) {\n\t\trctx->need_16bit = 1;\n\t}\n\n\treturn 1;\n}\n\nstatic int iwbmp_read_bitfields(struct iwbmprcontext *rctx)\n{\n\tiw_byte buf[12];\n\tint k;\n\n\tif(!iwbmp_read(rctx,buf,12)) return 0;\n\n\tfor(k=0;k<3;k++) {\n\t\trctx->bf_mask[k] = iw_get_ui32le(&buf[k*4]);\n\t\tif(rctx->bf_mask[k]==0) return 0;\n\n\t\t// Find the high bit, low bit, etc.\n\t\tif(!process_bf_mask(rctx,k)) return 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void iwbmp_set_default_bitfields(struct iwbmprcontext *rctx)\n{\n\tint k;\n\n\tif(rctx->bitfields_set) return;\n\n\tif(rctx->bitcount==16) {\n\t\t// Default is 5 bits for each channel.\n\t\trctx->bf_mask[0]=0x7c00; // 01111100 00000000 (red)\n\t\trctx->bf_mask[1]=0x03e0; // 00000011 11100000 (green)\n\t\trctx->bf_mask[2]=0x001f; // 00000000 00011111 (blue)\n\t}\n\telse if(rctx->bitcount==32) {\n\t\trctx->bf_mask[0]=0x00ff0000;\n\t\trctx->bf_mask[1]=0x0000ff00;\n\t\trctx->bf_mask[2]=0x000000ff;\n\t}\n\telse {\n\t\treturn;\n\t}\n\n\tfor(k=0;k<3;k++) {\n\t\tprocess_bf_mask(rctx,k);\n\t}\n}\n\nstatic int iwbmp_read_palette(struct iwbmprcontext *rctx)\n{\n\tsize_t i;\n\tiw_byte buf[4*256];\n\tsize_t b;\n\tunsigned int valid_palette_entries;\n\tsize_t valid_palette_nbytes;\n\n\tb = (rctx->bmpversion==2) ? 3 : 4; // bytes per palette entry\n\n\tif(rctx->infoheader_size==64) {\n\t\t// According to what little documentation I can find, OS/2v2 BMP files\n\t\t// have 4 bytes per palette entry. But some of the files I've seen have\n\t\t// only 3. This is a little hack to support them.\n\t\tif(rctx->fileheader_size + rctx->infoheader_size + rctx->palette_entries*3 ==\n\t\t\trctx->bfOffBits)\n\t\t{\n\t\t\tiw_warning(rctx->ctx,\"BMP bitmap overlaps colormap; assuming colormap uses 3 bytes per entry instead of 4\");\n\t\t\tb = 3;\n\t\t\trctx->palette_nbytes = 3*rctx->palette_entries;\n\t\t}\n\t}\n\n\t// If the palette has >256 colors, only use the first 256.\n\tvalid_palette_entries = (rctx->palette_entries<=256) ? rctx->palette_entries : 256;\n\tvalid_palette_nbytes = valid_palette_entries * b;\n\n\n\tif(!iwbmp_read(rctx,buf,valid_palette_nbytes)) return 0;\n\trctx->palette.num_entries = valid_palette_entries;\n\tfor(i=0;i<valid_palette_entries;i++) {\n\t\trctx->palette.entry[i].b = buf[i*b+0];\n\t\trctx->palette.entry[i].g = buf[i*b+1];\n\t\trctx->palette.entry[i].r = buf[i*b+2];\n\t\trctx->palette.entry[i].a = 255;\n\t}\n\n\t// If the palette is oversized, skip over the unused part of it.\n\tif(rctx->palette_nbytes > valid_palette_nbytes) {\n\t\tiwbmp_skip_bytes(rctx, rctx->palette_nbytes - valid_palette_nbytes);\n\t}\n\treturn 1;\n}\n\nstatic void bmpr_convert_row_32_16(struct iwbmprcontext *rctx, const iw_byte *src, size_t row)\n{\n\tint i,k;\n\tunsigned int v,x;\n\tint numchannels;\n\n\tnumchannels = rctx->has_alpha_channel ? 4 : 3;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tif(rctx->bitcount==32) {\n\t\t\tx = ((unsigned int)src[i*4+0]) | ((unsigned int)src[i*4+1])<<8 |\n\t\t\t\t((unsigned int)src[i*4+2])<<16 | ((unsigned int)src[i*4+3])<<24;\n\t\t}\n\t\telse { // 16\n\t\t\tx = ((unsigned int)src[i*2+0]) | ((unsigned int)src[i*2+1])<<8;\n\t\t}\n\t\tv = 0;\n\t\tfor(k=0;k<numchannels;k++) { // For red, green, blue [, alpha]:\n\t\t\tv = x & rctx->bf_mask[k];\n\t\t\tif(rctx->bf_low_bit[k]>0)\n\t\t\t\tv >>= rctx->bf_low_bit[k];\n\t\t\tif(rctx->img->bit_depth==16) {\n\t\t\t\trctx->img->pixels[row*rctx->img->bpr + i*numchannels*2 + k*2+0] = (iw_byte)(v>>8);\n\t\t\t\trctx->img->pixels[row*rctx->img->bpr + i*numchannels*2 + k*2+1] = (iw_byte)(v&0xff);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trctx->img->pixels[row*rctx->img->bpr + i*numchannels + k] = (iw_byte)v;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void bmpr_convert_row_24(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tfor(i=0;i<rctx->width;i++) {\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = src[i*3+2];\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = src[i*3+1];\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = src[i*3+0];\n\t}\n}\n\nstatic void bmpr_convert_row_8(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tfor(i=0;i<rctx->width;i++) {\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[src[i]].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[src[i]].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[src[i]].b;\n\t}\n}\n\nstatic void bmpr_convert_row_4(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tint pal_index;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tpal_index = (i&0x1) ? src[i/2]&0x0f : src[i/2]>>4;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;\n\t}\n}\n\nstatic void bmpr_convert_row_2(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tint pal_index;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tpal_index = (src[i/4]>>(2*(3-i%4)))&0x03;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;\n\t}\n}\n\nstatic void bmpr_convert_row_1(struct iwbmprcontext *rctx,const iw_byte *src, size_t row)\n{\n\tint i;\n\tint pal_index;\n\n\tfor(i=0;i<rctx->width;i++) {\n\t\tpal_index = (src[i/8] & (1<<(7-i%8))) ? 1 : 0;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 0] = rctx->palette.entry[pal_index].r;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 1] = rctx->palette.entry[pal_index].g;\n\t\trctx->img->pixels[row*rctx->img->bpr + i*3 + 2] = rctx->palette.entry[pal_index].b;\n\t}\n}\n\nstatic int bmpr_read_uncompressed(struct iwbmprcontext *rctx)\n{\n\tiw_byte *rowbuf = NULL;\n\tsize_t bmp_bpr;\n\tint j;\n\tint retval = 0;\n\n\tif(rctx->has_alpha_channel) {\n\t\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\t\t\n\t\trctx->img->bit_depth = rctx->need_16bit ? 16 : 8;\n\t\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,4*rctx->img->bit_depth);\n\t}\n\telse {\n\t\trctx->img->imgtype = IW_IMGTYPE_RGB;\n\t\trctx->img->bit_depth = rctx->need_16bit ? 16 : 8;\n\t\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,3*rctx->img->bit_depth);\n\t}\n\n\tbmp_bpr = iwbmp_calc_bpr(rctx->bitcount,rctx->width);\n\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\n\trowbuf = iw_malloc(rctx->ctx,bmp_bpr);\n\n\tfor(j=0;j<rctx->img->height;j++) {\n\t\t// Read a row of the BMP file.\n\t\tif(!iwbmp_read(rctx,rowbuf,bmp_bpr)) {\n\t\t\tgoto done;\n\t\t}\n\t\tswitch(rctx->bitcount) {\n\t\tcase 32:\n\t\tcase 16:\n\t\t\tbmpr_convert_row_32_16(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tbmpr_convert_row_24(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tbmpr_convert_row_8(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tbmpr_convert_row_4(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbmpr_convert_row_2(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbmpr_convert_row_1(rctx,rowbuf,j);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tretval = 1;\ndone:\n\tif(rowbuf) iw_free(rctx->ctx,rowbuf);\n\treturn retval;\n}\n\n// Read and decompress RLE8 or RLE4-compressed bits, and write pixels to\n// rctx->img->pixels.\nstatic int bmpr_read_rle_internal(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\tint pos_x, pos_y;\n\tiw_byte buf[255];\n\tsize_t n_pix;\n\tsize_t n_bytes;\n\tsize_t i;\n\tsize_t pal_index;\n\n\t// The position of the next pixel to set.\n\t// pos_y is in IW coordinates (top=0), not BMP coordinates (bottom=0).\n\tpos_x = 0;\n\tpos_y = 0;\n\n\t// Initially make all pixels transparent, so that any any pixels we\n\t// don't modify will be transparent.\n\tiw_zeromem(rctx->img->pixels,rctx->img->bpr*rctx->img->height);\n\n\twhile(1) {\n\t\t// If we've reached the end of the bitmap, stop.\n\t\tif(pos_y>rctx->img->height-1) break;\n\t\tif(pos_y==rctx->img->height-1 && pos_x>=rctx->img->width) break;\n\n\t\tif(!iwbmp_read(rctx,buf,2)) goto done;\n\t\tif(buf[0]==0) {\n\t\t\tif(buf[1]==0) {\n\t\t\t\t// End of Line\n\t\t\t\tpos_y++;\n\t\t\t\tpos_x=0;\n\t\t\t}\n\t\t\telse if(buf[1]==1) {\n\t\t\t\t// (Premature) End of Bitmap\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(buf[1]==2) {\n\t\t\t\t// DELTA: The next two bytes are unsigned values representing\n\t\t\t\t// the relative position of the next pixel from the \"current\n\t\t\t\t// position\".\n\t\t\t\t// I interpret \"current position\" to mean the position at which\n\t\t\t\t// the next pixel would normally have been.\n\t\t\t\tif(!iwbmp_read(rctx,buf,2)) goto done;\n\n\t\t\t\tif(pos_x<rctx->img->width) pos_x += buf[0];\n\t\t\t\tpos_y += buf[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// A uncompressed segment\n\t\t\t\tn_pix = (size_t)buf[1]; // Number of uncompressed pixels which follow\n\t\t\t\tif(rctx->compression==IWBMP_BI_RLE4) {\n\t\t\t\t\tn_bytes = ((n_pix+3)/4)*2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tn_bytes = ((n_pix+1)/2)*2;\n\t\t\t\t}\n\t\t\t\tif(!iwbmp_read(rctx,buf,n_bytes)) goto done;\n\t\t\t\tfor(i=0;i<n_pix;i++) {\n\t\t\t\t\tif(pos_x<rctx->img->width) {\n\t\t\t\t\t\tif(rctx->compression==IWBMP_BI_RLE4) {\n\t\t\t\t\t\t\tpal_index = (i%2) ? buf[i/2]&0x0f : buf[i/2]>>4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpal_index = buf[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;\n\t\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;\n\t\t\t\t\t\tpos_x++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// An RLE-compressed segment\n\t\t\tn_pix = (size_t)buf[0];\n\t\t\tfor(i=0;i<n_pix;i++) {\n\t\t\t\tif(pos_x<rctx->img->width) {\n\t\t\t\t\tif(rctx->compression==IWBMP_BI_RLE4) {\n\t\t\t\t\t\tpal_index = (i%2) ? buf[1]&0x0f : buf[1]>>4;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpal_index = buf[1];\n\t\t\t\t\t}\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 0] = rctx->palette.entry[pal_index].r;\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 1] = rctx->palette.entry[pal_index].g;\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 2] = rctx->palette.entry[pal_index].b;\n\t\t\t\t\trctx->img->pixels[rctx->img->bpr*pos_y + pos_x*4 + 3] = 255;\n\t\t\t\t\tpos_x++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic int bmpr_has_transparency(struct iw_image *img)\n{\n\tint i,j;\n\n\tif(img->imgtype!=IW_IMGTYPE_RGBA) return 0;\n\n\tfor(j=0;j<img->height;j++) {\n\t\tfor(i=0;i<img->width;i++) {\n\t\t\tif(img->pixels[j*img->bpr + i*4 + 3] != 255)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// Remove the alpha channel.\n// This doesn't free the extra memory used by the alpha channel, it just\n// moves the pixels around in-place.\nstatic void bmpr_strip_alpha(struct iw_image *img)\n{\n\tint i,j;\n\tsize_t oldbpr;\n\n\timg->imgtype = IW_IMGTYPE_RGB;\n\toldbpr = img->bpr;\n\timg->bpr = iw_calc_bytesperrow(img->width,24);\n\n\tfor(j=0;j<img->height;j++) {\n\t\tfor(i=0;i<img->width;i++) {\n\t\t\timg->pixels[j*img->bpr + i*3 + 0] = img->pixels[j*oldbpr + i*4 + 0];\n\t\t\timg->pixels[j*img->bpr + i*3 + 1] = img->pixels[j*oldbpr + i*4 + 1];\n\t\t\timg->pixels[j*img->bpr + i*3 + 2] = img->pixels[j*oldbpr + i*4 + 2];\n\t\t}\n\t}\n}\n\nstatic int bmpr_read_rle(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\n\tif(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&\n\t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n\t{\n\t\tiw_set_error(rctx->ctx,\"Compression type incompatible with image type\");\n\t}\n\n\tif(rctx->topdown) {\n\t\t// The documentation says that top-down images may not be compressed.\n\t\tiw_set_error(rctx->ctx,\"Compression not allowed with top-down images\");\n\t}\n\n\t// RLE-compressed BMP images don't have to assign a color to every pixel,\n\t// and it's reasonable to interpret undefined pixels as transparent.\n\t// I'm not going to worry about handling compressed BMP images as\n\t// efficiently as possible, so start with an RGBA image, and convert to\n\t// RGB format later if (as is almost always the case) there was no\n\t// transparency.\n\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\trctx->img->bit_depth = 8;\n\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);\n\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\n\tif(!bmpr_read_rle_internal(rctx)) goto done;\n\n\tif(!bmpr_has_transparency(rctx->img)) {\n\t\tbmpr_strip_alpha(rctx->img);\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic int iwbmp_read_bits(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\n\trctx->img->width = rctx->width;\n\trctx->img->height = rctx->height;\n\n\t// If applicable, use the fileheader's \"bits offset\" field to locate the\n\t// bitmap bits.\n\tif(rctx->fileheader_size>0) {\n\t\tsize_t expected_offbits;\n\n\t\texpected_offbits = rctx->fileheader_size + rctx->infoheader_size +\n\t\t\trctx->bitfields_nbytes + rctx->palette_nbytes;\n\n\t\tif(rctx->bfOffBits==expected_offbits) {\n\t\t\t;\n\t\t}\n\t\telse if(rctx->bfOffBits>expected_offbits && rctx->bfOffBits<1000000) {\n\t\t\t// Apparently, there's some extra space between the header data and\n\t\t\t// the bits. If it's not unreasonably large, skip over it.\n\t\t\tif(!iwbmp_skip_bytes(rctx, rctx->bfOffBits - expected_offbits)) goto done;\n\t\t}\n\t\telse {\n\t\t\tiw_set_error(rctx->ctx,\"Invalid BMP bits offset\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif(rctx->compression==IWBMP_BI_RGB) {\n\t\tif(!bmpr_read_uncompressed(rctx)) goto done;\n\t}\n\telse if(rctx->compression==IWBMP_BI_RLE8 || rctx->compression==IWBMP_BI_RLE4) {\n\t\tif(!bmpr_read_rle(rctx)) goto done;\n\t}\n\telse {\n\t\tiw_set_errorf(rctx->ctx,\"Unsupported BMP compression or image type (%d)\",(int)rctx->compression);\n\t\tgoto done;\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic void iwbmpr_misc_config(struct iw_context *ctx, struct iwbmprcontext *rctx)\n{\n\t// Have IW flip the image, if necessary.\n\tif(!rctx->topdown) {\n\t\tiw_reorient_image(ctx,IW_REORIENT_FLIP_V);\n\t}\n\n\t// Tell IW the colorspace.\n\tiw_set_input_colorspace(ctx,&rctx->csdescr);\n\n\t// Tell IW the significant bits.\n\tif(rctx->bitcount==16 || rctx->bitcount==32) {\n\t\tif(rctx->bf_bits_count[0]!=8 || rctx->bf_bits_count[1]!=8 || rctx->bf_bits_count[2]!=8 ||\n\t\t\t(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype) && rctx->bf_bits_count[3]!=8))\n\t\t{\n\t\t\tiw_set_input_max_color_code(ctx,0, (1 << rctx->bf_bits_count[0])-1 );\n\t\t\tiw_set_input_max_color_code(ctx,1, (1 << rctx->bf_bits_count[1])-1 );\n\t\t\tiw_set_input_max_color_code(ctx,2, (1 << rctx->bf_bits_count[2])-1 );\n\t\t\tif(IW_IMGTYPE_HAS_ALPHA(rctx->img->imgtype)) {\n\t\t\t\tiw_set_input_max_color_code(ctx,3, (1 << rctx->bf_bits_count[3])-1 );\n\t\t\t}\n\t\t}\n\t}\n}\n\nIW_IMPL(int) iw_read_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iwbmprcontext rctx;\n\tstruct iw_image img;\n\tint retval = 0;\n\n\tiw_zeromem(&rctx,sizeof(struct iwbmprcontext));\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\n\trctx.ctx = ctx;\n\trctx.img = &img;\n\trctx.iodescr = iodescr;\n\n\t// Start with a default sRGB colorspace. This may be overridden later.\n\tiw_make_srgb_csdescr_2(&rctx.csdescr);\n\n\trctx.has_fileheader = !iw_get_value(ctx,IW_VAL_BMP_NO_FILEHEADER);\n\tif(rctx.has_fileheader) {\n\t\tif(!iwbmp_read_file_header(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_info_header(&rctx)) goto done;\n\n\tiwbmp_set_default_bitfields(&rctx);\n\tif(rctx.bitfields_nbytes>0) {\n\t\tif(!iwbmp_read_bitfields(&rctx)) goto done;\n\t}\n\n\tif(rctx.palette_entries>0) {\n\t\tif(!iwbmp_read_palette(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_bits(&rctx)) goto done;\n\n\tiw_set_input_image(ctx, &img);\n\n\tiwbmpr_misc_config(ctx, &rctx);\n\n\tretval = 1;\ndone:\n\tif(!retval) {\n\t\tiw_set_error(ctx,\"BMP read failed\");\n\t\t// If we didn't call iw_set_input_image, 'img' still belongs to us,\n\t\t// so free its contents.\n\t\tiw_free(ctx, img.pixels);\n\t}\n\treturn retval;\n}\n\nstruct iwbmpwcontext {\n\tint bmpversion;\n\tint include_file_header;\n\tint bitcount;\n\tint palentries;\n\tint compressed;\n\tint uses_bitfields;\n\tsize_t header_size;\n\tsize_t bitfields_size;\n\tsize_t palsize;\n\tsize_t unc_dst_bpr;\n\tsize_t unc_bitssize;\n\tstruct iw_iodescr *iodescr;\n\tstruct iw_context *ctx;\n\tstruct iw_image *img;\n\tconst struct iw_palette *pal;\n\tsize_t total_written;\n\tint bf_amt_to_shift[4]; // For 16-bit images\n\tunsigned int bf_mask[4];\n\tunsigned int maxcolor[4]; // R, G, B -- For 16-bit images.\n\tstruct iw_csdescr csdescr;\n\tint no_cslabel;\n};\n\nstatic void iwbmp_write(struct iwbmpwcontext *wctx, const void *buf, size_t n)\n{\n\t(*wctx->iodescr->write_fn)(wctx->ctx,wctx->iodescr,buf,n);\n\twctx->total_written+=n;\n}\n\nstatic void bmpw_convert_row_1(const iw_byte *srcrow, iw_byte *dstrow, int width)\n{\n\tint i;\n\tint m;\n\n\tfor(i=0;i<width;i++) {\n\t\tm = i%8;\n\t\tif(m==0)\n\t\t\tdstrow[i/8] = srcrow[i]<<7;\n\t\telse\n\t\t\tdstrow[i/8] |= srcrow[i]<<(7-m);\n\t}\n}\n\nstatic void bmpw_convert_row_4(const iw_byte *srcrow, iw_byte *dstrow, int width)\n{\n\tint i;\n\n\tfor(i=0;i<width;i++) {\n\t\tif(i%2==0)\n\t\t\tdstrow[i/2] = srcrow[i]<<4;\n\t\telse\n\t\t\tdstrow[i/2] |= srcrow[i];\n\t}\n}\n\nstatic void bmpw_convert_row_8(const iw_byte *srcrow, iw_byte *dstrow, int width)\n{\n\tmemcpy(dstrow,srcrow,width);\n}\n\nstatic void bmpw_convert_row_16_32(struct iwbmpwcontext *wctx, const iw_byte *srcrow,\n\tiw_byte *dstrow, int width)\n{\n\tint i,k;\n\tunsigned int v;\n\tint num_src_samples;\n\tunsigned int src_sample[4];\n\n\tfor(k=0;k<4;k++) src_sample[k]=0;\n\n\tnum_src_samples = iw_imgtype_num_channels(wctx->img->imgtype);\n\n\tfor(i=0;i<width;i++) {\n\n\t\t// Read the source samples into a convenient format.\n\t\tfor(k=0;k<num_src_samples;k++) {\n\t\t\tif(wctx->img->bit_depth==16) {\n\t\t\t\tsrc_sample[k] = (srcrow[num_src_samples*2*i + k*2]<<8) | srcrow[num_src_samples*2*i + k*2 +1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsrc_sample[k] = srcrow[num_src_samples*i + k];\n\t\t\t}\n\t\t}\n\n\t\t// Pack the pixels' bits into a single int.\n\t\tswitch(wctx->img->imgtype) {\n\t\tcase IW_IMGTYPE_GRAY:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[2];\n\t\t\tbreak;\n\t\tcase IW_IMGTYPE_RGBA:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[2] << wctx->bf_amt_to_shift[2];\n\t\t\tv |= src_sample[3] << wctx->bf_amt_to_shift[3];\n\t\t\tbreak;\n\t\tcase IW_IMGTYPE_GRAYA:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[0] << wctx->bf_amt_to_shift[2];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tv = src_sample[0] << wctx->bf_amt_to_shift[0];\n\t\t\tv |= src_sample[1] << wctx->bf_amt_to_shift[1];\n\t\t\tv |= src_sample[2] << wctx->bf_amt_to_shift[2];\n\t\t}\n\n\t\t// Split the int into bytes, and write it to the target image.\n\t\tif(wctx->bitcount==32) {\n\t\t\tdstrow[i*4+0] = (iw_byte)(v&0xff);\n\t\t\tdstrow[i*4+1] = (iw_byte)((v&0x0000ff00)>>8);\n\t\t\tdstrow[i*4+2] = (iw_byte)((v&0x00ff0000)>>16);\n\t\t\tdstrow[i*4+3] = (iw_byte)((v&0xff000000)>>24);\n\t\t}\n\t\telse {\n\t\t\tdstrow[i*2+0] = (iw_byte)(v&0xff);\n\t\t\tdstrow[i*2+1] = (iw_byte)(v>>8);\n\t\t}\n\t}\n}\n\nstatic void bmpw_convert_row_24(struct iwbmpwcontext *wctx, const iw_byte *srcrow,\n\tiw_byte *dstrow, int width)\n{\n\tint i;\n\n\tif(wctx->img->imgtype==IW_IMGTYPE_GRAY) {\n\t\tfor(i=0;i<width;i++) {\n\t\t\tdstrow[i*3+0] = srcrow[i];\n\t\t\tdstrow[i*3+1] = srcrow[i];\n\t\t\tdstrow[i*3+2] = srcrow[i];\n\t\t}\n\t}\n\telse { // RGB\n\t\tfor(i=0;i<width;i++) {\n\t\t\tdstrow[i*3+0] = srcrow[i*3+2];\n\t\t\tdstrow[i*3+1] = srcrow[i*3+1];\n\t\t\tdstrow[i*3+2] = srcrow[i*3+0];\n\t\t}\n\t}\n}\n\nstatic void iwbmp_write_file_header(struct iwbmpwcontext *wctx)\n{\n\tiw_byte fileheader[14];\n\n\tif(!wctx->include_file_header) return;\n\n\tiw_zeromem(fileheader,sizeof(fileheader));\n\tfileheader[0] = 66; // 'B'\n\tfileheader[1] = 77; // 'M'\n\n\t// This will be overwritten later, if the bitmap was compressed.\n\tiw_set_ui32le(&fileheader[ 2], (unsigned int)(14+wctx->header_size+\n\t\twctx->bitfields_size+wctx->palsize+wctx->unc_bitssize)); // bfSize\n\tiw_set_ui32le(&fileheader[10],(unsigned int)(14+wctx->header_size+\n\t\twctx->bitfields_size+wctx->palsize)); // bfOffBits\n\tiwbmp_write(wctx,fileheader,14);\n}\n\nstatic int iwbmp_write_bmp_v2header(struct iwbmpwcontext *wctx)\n{\n\tiw_byte header[12];\n\n\tif(wctx->img->width>65535 || wctx->img->height>65535) {\n\t\tiw_set_error(wctx->ctx,\"Output image is too large for this BMP version\");\n\t\treturn 0;\n\t}\n\n\tiw_zeromem(header,sizeof(header));\n\tiw_set_ui32le(&header[ 0],12);                // bcSize\n\tiw_set_ui16le(&header[ 4],wctx->img->width);  // bcWidth\n\tiw_set_ui16le(&header[ 6],wctx->img->height); // bcHeight\n\tiw_set_ui16le(&header[ 8],1);                 // bcPlanes\n\tiw_set_ui16le(&header[10],wctx->bitcount);    // bcBitCount\n\n\tiwbmp_write(wctx,header,12);\n\treturn 1;\n}\n\nstatic int iwbmp_write_bmp_v3header(struct iwbmpwcontext *wctx)\n{\n\tunsigned int dens_x, dens_y;\n\tunsigned int cmpr;\n\tiw_byte header[40];\n\n\tiw_zeromem(header,sizeof(header));\n\n\tiw_set_ui32le(&header[ 0],(unsigned int)wctx->header_size); // biSize\n\tiw_set_ui32le(&header[ 4],wctx->img->width);  // biWidth\n\tiw_set_ui32le(&header[ 8],wctx->img->height); // biHeight\n\tiw_set_ui16le(&header[12],1);    // biPlanes\n\tiw_set_ui16le(&header[14],wctx->bitcount);   // biBitCount\n\n\tcmpr = IWBMP_BI_RGB;\n\tif(wctx->compressed) {\n\t\tif(wctx->bitcount==8) cmpr = IWBMP_BI_RLE8;\n\t\telse if(wctx->bitcount==4) cmpr = IWBMP_BI_RLE4;\n\t}\n\telse if(wctx->uses_bitfields) {\n\t\tcmpr = IWBMP_BI_BITFIELDS;\n\t}\n\tiw_set_ui32le(&header[16],cmpr); // biCompression\n\n\tiw_set_ui32le(&header[20],(unsigned int)wctx->unc_bitssize); // biSizeImage\n\n\tif(wctx->img->density_code==IW_DENSITY_UNITS_PER_METER) {\n\t\tdens_x = (unsigned int)(0.5+wctx->img->density_x);\n\t\tdens_y = (unsigned int)(0.5+wctx->img->density_y);\n\t}\n\telse {\n\t\tdens_x = dens_y = 2835;\n\t}\n\tiw_set_ui32le(&header[24],dens_x); // biXPelsPerMeter\n\tiw_set_ui32le(&header[28],dens_y); // biYPelsPerMeter\n\n\tiw_set_ui32le(&header[32],wctx->palentries);    // biClrUsed\n\t//iw_set_ui32le(&header[36],0);    // biClrImportant\n\tiwbmp_write(wctx,header,40);\n\treturn 1;\n}\n\nstatic int iwbmp_write_bmp_v45header_fields(struct iwbmpwcontext *wctx)\n{\n\tiw_byte header[124];\n\tunsigned int intent_bmp_style;\n\n\tiw_zeromem(header,sizeof(header));\n\n\tif(wctx->uses_bitfields) {\n\t\tiw_set_ui32le(&header[40],wctx->bf_mask[0]);\n\t\tiw_set_ui32le(&header[44],wctx->bf_mask[1]);\n\t\tiw_set_ui32le(&header[48],wctx->bf_mask[2]);\n\t\tiw_set_ui32le(&header[52],wctx->bf_mask[3]);\n\t}\n\n\t// Colorspace Type\n\t// TODO: We could support CSTYPE_GAMMA by using LCS_CALIBRATED_RGB,\n\t// but documentation about how to do that is hard to find.\n\tif(wctx->csdescr.cstype==IW_CSTYPE_SRGB && !wctx->no_cslabel)\n\t\tiw_set_ui32le(&header[56],IWBMPCS_SRGB);\n\telse\n\t\tiw_set_ui32le(&header[56],IWBMPCS_DEVICE_RGB);\n\n\t// Intent\n\t//intent_bmp_style = 4; // Perceptual\n\t//if(wctx->csdescr.cstype==IW_CSTYPE_SRGB && !wctx->no_cslabel) {\n\tswitch(wctx->img->rendering_intent) {\n\tcase IW_INTENT_PERCEPTUAL: intent_bmp_style = 4; break;\n\tcase IW_INTENT_RELATIVE:   intent_bmp_style = 2; break;\n\tcase IW_INTENT_SATURATION: intent_bmp_style = 1; break;\n\tcase IW_INTENT_ABSOLUTE:   intent_bmp_style = 8; break;\n\tdefault: intent_bmp_style = 4;\n\t}\n\t//}\n\tiw_set_ui32le(&header[108],intent_bmp_style);\n\n\tiwbmp_write(wctx,&header[40],124-40);\n\treturn 1;\n}\n\nstatic int iwbmp_write_bmp_header(struct iwbmpwcontext *wctx)\n{\n\tif(wctx->bmpversion==2) {\n\t\treturn iwbmp_write_bmp_v2header(wctx);\n\t}\n\telse if(wctx->bmpversion==5) {\n\t\tif(!iwbmp_write_bmp_v3header(wctx)) return 0;\n\t\treturn iwbmp_write_bmp_v45header_fields(wctx);\n\t}\n\treturn iwbmp_write_bmp_v3header(wctx);\n}\n\n// Given wctx->maxcolor[*], sets -> bf_mask[*] and bf_amt_to_shift[*],\n// and sets wctx->bitcount (to 16 or 32).\nstatic int iwbmp_calc_bitfields_masks(struct iwbmpwcontext *wctx, int num_masks)\n{\n\tint k;\n\tint bits[4]; // R, G, B, A\n\tint tot_bits = 0;\n\n\tfor(k=0;k<num_masks;k++) {\n\t\tbits[k] = iw_max_color_to_bitdepth(wctx->maxcolor[k]);\n\t\ttot_bits += bits[k];\n\t}\n\n\tif(tot_bits > 32) {\n\t\tiw_set_error(wctx->ctx,\"Cannot write a BMP image in this color format\");\n\t\treturn 0;\n\t}\n\t\n\twctx->bitcount = (tot_bits>16) ? 32 : 16;\n\n\twctx->bf_amt_to_shift[0] = bits[1] + bits[2];\n\twctx->bf_amt_to_shift[1] = bits[2];\n\twctx->bf_amt_to_shift[2] = 0;\n\tif(num_masks>3) wctx->bf_amt_to_shift[3] =  bits[0] + bits[1] + bits[2];\n\n\tfor(k=0;k<num_masks;k++) {\n\t\twctx->bf_mask[k] = wctx->maxcolor[k] << wctx->bf_amt_to_shift[k];\n\t}\n\n\treturn 1;\n}\n\n// Write the BITFIELDS segment, and set the wctx->bf_amt_to_shift[] values.\nstatic int iwbmp_write_bitfields(struct iwbmpwcontext *wctx)\n{\n\tiw_byte buf[12];\n\tint k;\n\n\tif(wctx->bitcount!=16 && wctx->bitcount!=32) return 0;\n\n\tfor(k=0;k<3;k++) {\n\t\tiw_set_ui32le(&buf[4*k],wctx->bf_mask[k]);\n\t}\n\tiwbmp_write(wctx,buf,12);\n\treturn 1;\n}\n\nstatic void iwbmp_write_palette(struct iwbmpwcontext *wctx)\n{\n\tint i,k;\n\tiw_byte buf[4];\n\n\tif(wctx->palentries<1) return;\n\n\tbuf[3] = 0; // Reserved field; always 0.\n\n\tfor(i=0;i<wctx->palentries;i++) {\n\t\tif(i<wctx->pal->num_entries) {\n\t\t\tif(wctx->pal->entry[i].a == 0) {\n\t\t\t\t// A transparent color. Because of the way we handle writing\n\t\t\t\t// transparent BMP images, the first palette entry may be a\n\t\t\t\t// fully transparent color, whose index will not be used when\n\t\t\t\t// we write the image. But many apps will interpret our\n\t\t\t\t// \"transparent\" pixels as having color #0. So, set it to\n\t\t\t\t// the background label color if available, otherwise to an\n\t\t\t\t// arbitrary high-contrast color (magenta).\n\t\t\t\tif(wctx->img->has_bkgdlabel) {\n\t\t\t\t\tfor(k=0;k<3;k++) {\n\t\t\t\t\t\tbuf[k] = (iw_byte)iw_color_get_int_sample(&wctx->img->bkgdlabel,2-k,255);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf[0] = 255;\n\t\t\t\t\tbuf[1] = 0;\n\t\t\t\t\tbuf[2] = 255;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf[0] = wctx->pal->entry[i].b;\n\t\t\t\tbuf[1] = wctx->pal->entry[i].g;\n\t\t\t\tbuf[2] = wctx->pal->entry[i].r;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbuf[0] = buf[1] = buf[2] = 0;\n\t\t}\n\t\tif(wctx->bmpversion==2)\n\t\t\tiwbmp_write(wctx,buf,3); // v2 BMPs don't have the 'reserved' field.\n\t\telse\n\t\t\tiwbmp_write(wctx,buf,4);\n\t}\n}\n\nstruct rle_context {\n\tstruct iw_context *ctx;\n\tstruct iwbmpwcontext *wctx;\n\tconst iw_byte *srcrow;\n\n\tsize_t img_width;\n\tint cur_row; // current row; 0=top (last)\n\n\t// Position in srcrow of the first byte that hasn't been written to the\n\t// output file\n\tsize_t pending_data_start;\n\n\t// Current number of uncompressible bytes that haven't been written yet\n\t// (starting at pending_data_start)\n\tsize_t unc_len;\n\n\t// Current number of identical bytes that haven't been written yet\n\t// (starting at pending_data_start+unc_len)\n\tsize_t run_len;\n\n\t// The value of the bytes referred to by run_len.\n\t// Valid if run_len>0.\n\tiw_byte run_byte;\n\n\tsize_t total_bytes_written; // Bytes written, after compression\n};\n\n//============================ RLE8 encoder ============================\n\n// TODO: The RLE8 and RLE4 encoders are more different than they should be.\n// The RLE8 encoder could probably be made more similar to the (more\n// complicated) RLE4 encoder.\n\nstatic void rle8_write_unc(struct rle_context *rlectx)\n{\n\tsize_t i;\n\tiw_byte dstbuf[2];\n\n\tif(rlectx->unc_len<1) return;\n\tif(rlectx->unc_len>=3 && (rlectx->unc_len&1)) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 4\");\n\t\treturn;\n\t}\n\tif(rlectx->unc_len>254) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 5\");\n\t\treturn;\n\t}\n\n\tif(rlectx->unc_len<3) {\n\t\t// The minimum length for a noncompressed run is 3. For shorter runs\n\t\t// write them \"compressed\".\n\t\tfor(i=0;i<rlectx->unc_len;i++) {\n\t\t\tdstbuf[0] = 0x01;  // count\n\t\t\tdstbuf[1] = rlectx->srcrow[i+rlectx->pending_data_start]; // value\n\t\t\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\t\t\trlectx->total_bytes_written+=2;\n\t\t}\n\t}\n\telse {\n\t\tdstbuf[0] = 0x00;\n\t\tdstbuf[1] = (iw_byte)rlectx->unc_len;\n\t\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\t\trlectx->total_bytes_written+=2;\n\t\tiwbmp_write(rlectx->wctx,&rlectx->srcrow[rlectx->pending_data_start],rlectx->unc_len);\n\t\trlectx->total_bytes_written+=rlectx->unc_len;\n\t\tif(rlectx->unc_len&0x1) {\n\t\t\t// Need a padding byte if the length was odd. (This shouldn't\n\t\t\t// happen, because we never write odd-length UNC segments.)\n\t\t\tdstbuf[0] = 0x00;\n\t\t\tiwbmp_write(rlectx->wctx,dstbuf,1);\n\t\t\trlectx->total_bytes_written+=1;\n\t\t}\n\t}\n\n\trlectx->pending_data_start+=rlectx->unc_len;\n\trlectx->unc_len=0;\n}\n\nstatic void rle8_write_unc_and_run(struct rle_context *rlectx)\n{\n\tiw_byte dstbuf[2];\n\n\trle8_write_unc(rlectx);\n\n\tif(rlectx->run_len<1) {\n\t\treturn;\n\t}\n\tif(rlectx->run_len>255) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 6\");\n\t\treturn;\n\t}\n\n\tdstbuf[0] = (iw_byte)rlectx->run_len;\n\tdstbuf[1] = rlectx->run_byte;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\trlectx->pending_data_start+=rlectx->run_len;\n\trlectx->run_len=0;\n}\n\nstatic void rle_write_trns(struct rle_context *rlectx, int num_trns)\n{\n\tiw_byte dstbuf[4];\n\tint num_remaining = num_trns;\n\tint num_to_write;\n\n\twhile(num_remaining>0) {\n\t\tnum_to_write = num_remaining;\n\t\tif(num_to_write>255) num_to_write=255;\n\t\tdstbuf[0]=0x00; // 00 02 = Delta\n\t\tdstbuf[1]=0x02;\n\t\tdstbuf[2]=(iw_byte)num_to_write; // X offset\n\t\tdstbuf[3]=0x00; // Y offset\n\t\tiwbmp_write(rlectx->wctx,dstbuf,4);\n\t\trlectx->total_bytes_written+=4;\n\t\tnum_remaining -= num_to_write;\n\t}\n\trlectx->pending_data_start += num_trns;\n}\n\n// The RLE format used by BMP files is pretty simple, but I've gone to some\n// effort to optimize it for file size, which makes for a complicated\n// algorithm.\n// The overall idea:\n// We defer writing data until certain conditions are met. In the meantime,\n// we split the unwritten data into two segments:\n//  \"UNC\": data classified as uncompressible\n//  \"RUN\": data classified as compressible. All bytes in this segment must be\n//    identical.\n// The RUN segment always follows the UNC segment.\n// For each byte in turn, we examine the current state, and do one of a number\n// of things, such as:\n//    - add it to RUN\n//    - add it to UNC (if there is no RUN)\n//    - move RUN into UNC, then add it to RUN (or to UNC)\n//    - move UNC and RUN to the file, then make it the new RUN\n// Then, we check to see if we've accumulated enough data that something needs\n// to be written out.\nstatic int rle8_compress_row(struct rle_context *rlectx)\n{\n\tsize_t i;\n\tiw_byte dstbuf[2];\n\tiw_byte next_byte;\n\tint next_pix_is_trns;\n\tint num_trns = 0; // number of consecutive transparent pixels seen\n\tint retval = 0;\n\n\trlectx->pending_data_start=0;\n\trlectx->unc_len=0;\n\trlectx->run_len=0;\n\n\tfor(i=0;i<rlectx->img_width;i++) {\n\n\t\t// Read the next byte.\n\t\tnext_byte = rlectx->srcrow[i];\n\n\t\tnext_pix_is_trns = (rlectx->wctx->pal->entry[next_byte].a==0);\n\n\t\tif(num_trns>0 && !next_pix_is_trns) {\n\t\t\trle_write_trns(rlectx,num_trns);\n\t\t\tnum_trns=0;\n\t\t}\n\t\telse if(next_pix_is_trns) {\n\t\t\tif (rlectx->unc_len>0 || rlectx->run_len>0) {\n\t\t\t\trle8_write_unc_and_run(rlectx);\n\t\t\t}\n\t\t\tnum_trns++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Add the byte we just read to either the UNC or the RUN data.\n\n\t\tif(rlectx->run_len>0 && next_byte==rlectx->run_byte) {\n\t\t\t// Byte fits in the current run; add it.\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->run_len==0) {\n\t\t\t// We don't have a RUN, so we can put this byte there.\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_byte;\n\t\t}\n\t\telse if(rlectx->unc_len==0 && rlectx->run_len==1) {\n\t\t\t// We have one previous byte, and it's different from this one.\n\t\t\t// Move it to UNC, and make this one the RUN.\n\t\t\trlectx->unc_len++;\n\t\t\trlectx->run_byte = next_byte;\n\t\t}\n\t\telse if(rlectx->unc_len>0 && rlectx->run_len<(rlectx->unc_len==1 ? 3U : 4U)) {\n\t\t\t// We have a run, but it's not long enough to be beneficial.\n\t\t\t// Convert it to uncompressed bytes.\n\t\t\t// A good rule is that a run length of 4 or more (3 or more if\n\t\t\t// unc_len=1) should always be run-legth encoded.\n\t\t\trlectx->unc_len += rlectx->run_len;\n\t\t\trlectx->run_len = 0;\n\t\t\t// If UNC is now odd and >1, add the next byte to it to make it even.\n\t\t\t// Otherwise, add it to RUN.\n\t\t\tif(rlectx->unc_len>=3 && (rlectx->unc_len&0x1)) {\n\t\t\t\trlectx->unc_len++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trlectx->run_len = 1;\n\t\t\t\trlectx->run_byte = next_byte;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Nowhere to put the byte: write out everything, and start fresh.\n\t\t\trle8_write_unc_and_run(rlectx);\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_byte;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// If we hit certain high water marks, write out the current data.\n\n\t\tif(rlectx->unc_len>=254) {\n\t\t\t// Our maximum size for an UNC segment.\n\t\t\trle8_write_unc(rlectx);\n\t\t}\n\t\telse if(rlectx->unc_len>0 && (rlectx->unc_len+rlectx->run_len)>254) {\n\t\t\t// It will not be possible to coalesce the RUN into the UNC (it\n\t\t\t// would be too big) so write out the UNC.\n\t\t\trle8_write_unc(rlectx);\n\t\t}\n\t\telse if(rlectx->run_len>=255) {\n\t\t\t// The maximum size for an RLE segment.\n\t\t\trle8_write_unc_and_run(rlectx);\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Sanity checks. These can be removed if we're sure the algorithm\n\t\t// is bug-free.\n\n\t\t// We don't allow unc_len to be odd (except temporarily), except\n\t\t// that it can be 1.\n\t\t// What's special about 1 is that if we add another byte to it, it\n\t\t// increases the cost. For 3,5,...,253, we can add another byte for\n\t\t// free, so we should never fail to do that.\n\t\tif((rlectx->unc_len&0x1) && rlectx->unc_len!=1) {\n\t\t\tiw_set_errorf(rlectx->ctx,\"Internal: BMP RLE encode error 1\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t// unc_len can be at most 252 at this point.\n\t\t// If it were 254, it should have been written out already.\n\t\tif(rlectx->unc_len>252) {\n\t\t\tiw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 2\");\n\t\t\tgoto done;\n\t\t}\n\n\t\t// run_len can be at most 254 at this point.\n\t\t// If it were 255, it should have been written out already.\n\t\tif(rlectx->run_len>254) {\n\t\t\tiw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 3\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t// End of row. Write out anything left over.\n\trle8_write_unc_and_run(rlectx);\n\n\t// Write an end-of-line marker (0 0), or if this is the last row,\n\t// an end-of-bitmap marker (0 1).\n\tdstbuf[0]=0x00;\n\tdstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}\n\n//============================ RLE4 encoder ============================\n\n// Calculate the most efficient way to split a run of uncompressible pixels.\n// This only finds the first place to split the run. If the run is still\n// over 255 pixels, call it again to find the next split.\nstatic size_t rle4_get_best_unc_split(size_t n)\n{\n\t// For <=255 pixels, we can never do better than storing it as one run.\n\tif(n<=255) return n;\n\n\t// With runs of 252, we can store 252/128 = 1.96875 pixels/byte.\n\t// With runs of 255, we can store 255/130 = 1.96153 pixels/byte.\n\t// Hence, using runs of 252 is the most efficient way to store a large\n\t// number of uncompressible pixels.\n\t// (Lengths other than 252 or 255 are no help.)\n\t// However, there are three exceptional cases where, if we split at 252,\n\t// the most efficient encoding will no longer be possible:\n\tif(n==257 || n==510 || n==765) return 255;\n\n\treturn 252;\n}\n\n// Returns the incremental cost of adding a pixel to the current UNC\n// (which is always either 0 or 2).\n// To derive this function, I calculated the optimal cost of every length,\n// and enumerated the exceptions to the (n%4)?0:2 rule.\n// The exceptions are mostly caused by the cases where\n// rle4_get_best_unc_split() returns 255 instead of 252.\nstatic int rle4_get_incr_unc_cost(struct rle_context *rlectx)\n{\n\tint n;\n\tint m;\n\n\tn = (int)rlectx->unc_len;\n\n\tif(n==2 || n==255 || n==257 || n==507 || n==510) return 2;\n\tif(n==256 || n==508) return 0;\n\n\tif(n>=759) {\n\t\tm = n%252;\n\t\tif(m==3 || m==6 || m==9) return 2;\n\t\tif(m==4 || m==8) return 0;\n\t}\n\n\treturn (n%4)?0:2;\n}\n\nstatic void rle4_write_unc(struct rle_context *rlectx)\n{\n\tiw_byte dstbuf[128];\n\tsize_t pixels_to_write;\n\tsize_t bytes_to_write;\n\n\tif(rlectx->unc_len<1) return;\n\n\t// Note that, unlike the RLE8 encoder, we allow this function to be called\n\t// with uncompressed runs of arbitrary length.\n\n\twhile(rlectx->unc_len>0) {\n\t\tpixels_to_write = rle4_get_best_unc_split(rlectx->unc_len);\n\n\t\tif(pixels_to_write<3) {\n\t\t\t// The minimum length for an uncompressed run is 3. For shorter runs\n\t\t\t// write them \"compressed\".\n\t\t\tdstbuf[0] = (iw_byte)pixels_to_write;\n\t\t\tdstbuf[1] = (rlectx->srcrow[rlectx->pending_data_start]<<4);\n\t\t\tif(pixels_to_write>1)\n\t\t\t\tdstbuf[1] |= (rlectx->srcrow[rlectx->pending_data_start+1]);\n\n\t\t\t// The actual writing will occur below. Just indicate how many bytes\n\t\t\t// of dstbuf[] to write.\n\t\t\tbytes_to_write = 2;\n\t\t}\n\t\telse {\n\t\t\tsize_t i;\n\n\t\t\t// Write the length of the uncompressed run.\n\t\t\tdstbuf[0] = 0x00;\n\t\t\tdstbuf[1] = (iw_byte)pixels_to_write;\n\t\t\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\t\t\trlectx->total_bytes_written+=2;\n\n\t\t\t// Put the data to write in dstbuf[].\n\t\t\tbytes_to_write = 2*((pixels_to_write+3)/4);\n\t\t\tiw_zeromem(dstbuf,bytes_to_write);\n\n\t\t\tfor(i=0;i<pixels_to_write;i++) {\n\t\t\t\tif(i&0x1) dstbuf[i/2] |= rlectx->srcrow[rlectx->pending_data_start+i];\n\t\t\t\telse dstbuf[i/2] = rlectx->srcrow[rlectx->pending_data_start+i]<<4;\n\t\t\t}\n\t\t}\n\n\t\tiwbmp_write(rlectx->wctx,dstbuf,bytes_to_write);\n\t\trlectx->total_bytes_written += bytes_to_write;\n\t\trlectx->unc_len -= pixels_to_write;\n\t\trlectx->pending_data_start += pixels_to_write;\n\t}\n}\n\nstatic void rle4_write_unc_and_run(struct rle_context *rlectx)\n{\n\tiw_byte dstbuf[2];\n\n\trle4_write_unc(rlectx);\n\n\tif(rlectx->run_len<1) {\n\t\treturn;\n\t}\n\tif(rlectx->run_len>255) {\n\t\tiw_set_error(rlectx->ctx,\"Internal: RLE encode error 6\");\n\t\treturn;\n\t}\n\n\tdstbuf[0] = (iw_byte)rlectx->run_len;\n\tdstbuf[1] = rlectx->run_byte;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\trlectx->pending_data_start+=rlectx->run_len;\n\trlectx->run_len=0;\n}\n\n// Should we move the pending compressible data to the \"uncompressed\"\n// segment (return 1), or should we write it to disk as a compressed run of\n// pixels (0)?\nstatic int ok_to_move_to_unc(struct rle_context *rlectx)\n{\n\t// This logic is probably not optimal in every case.\n\t// One possible improvement might be to adjust the thresholds when\n\t// unc_len+run_len is around 255 or higher.\n\t// Other improvements might require looking ahead at pixels we haven't\n\t// read yet.\n\n\tif(rlectx->unc_len==0) {\n\t\treturn (rlectx->run_len<4);\n\t}\n\telse if(rlectx->unc_len<=2) {\n\t\treturn (rlectx->run_len<6);\n\t}\n\telse {\n\t\treturn (rlectx->run_len<8);\n\t}\n\treturn 0;\n}\n\nstatic int rle4_compress_row(struct rle_context *rlectx)\n{\n\tsize_t i;\n\tiw_byte dstbuf[2];\n\tiw_byte next_pix;\n\tint next_pix_is_trns;\n\tint num_trns = 0; // number of consecutive transparent pixels seen\n\tint retval = 0;\n\tiw_byte tmpb;\n\n\trlectx->pending_data_start=0;\n\trlectx->unc_len=0;\n\trlectx->run_len=0;\n\n\tfor(i=0;i<rlectx->img_width;i++) {\n\n\t\t// Read the next pixel\n\t\tnext_pix = rlectx->srcrow[i];\n\n\t\tnext_pix_is_trns = (rlectx->wctx->pal->entry[next_pix].a==0);\n\t\tif(num_trns>0 && !next_pix_is_trns) {\n\t\t\trle_write_trns(rlectx,num_trns);\n\t\t\tnum_trns=0;\n\t\t}\n\t\telse if(next_pix_is_trns) {\n\t\t\tif (rlectx->unc_len>0 || rlectx->run_len>0) {\n\t\t\t\trle4_write_unc_and_run(rlectx);\n\t\t\t}\n\t\t\tnum_trns++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Add the pixel we just read to either the UNC or the RUN data.\n\n\t\tif(rlectx->run_len==0) {\n\t\t\t// We don't have a RUN, so we can put this pixel there.\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_pix<<4;\n\t\t}\n\t\telse if(rlectx->run_len==1) {\n\t\t\t// If the run is 1, we can always add a 2nd pixel\n\t\t\trlectx->run_byte |= next_pix;\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->run_len>=2 && (rlectx->run_len&1)==0 && next_pix==(rlectx->run_byte>>4)) {\n\t\t\t// pixel fits in the current run; add it.\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->run_len>=3 && (rlectx->run_len&1) && next_pix==(rlectx->run_byte&0x0f)) {\n\t\t\t// pixel fits in the current run; add it.\n\t\t\trlectx->run_len++;\n\t\t}\n\t\telse if(rlectx->unc_len==0 && rlectx->run_len==2) {\n\t\t\t// We have one previous byte, and it's different from this one.\n\t\t\t// Move it to UNC, and make this one the RUN.\n\t\t\trlectx->unc_len+=rlectx->run_len;\n\t\t\trlectx->run_byte = next_pix<<4;\n\t\t\trlectx->run_len = 1;\n\t\t}\n\t\telse if(ok_to_move_to_unc(rlectx)) {\n\t\t\t// We have a compressible run, but we think it's not long enough to be\n\t\t\t// beneficial. Convert it to uncompressed bytes -- except for the last\n\t\t\t// pixel, which can be left in the run.\n\t\t\trlectx->unc_len += rlectx->run_len-1;\n \n\t\t\tif((rlectx->run_len&1)==0)\n\t\t\t\trlectx->run_byte = (rlectx->run_byte&0x0f)<<4;\n\t\t\telse\n\t\t\t\trlectx->run_byte = (rlectx->run_byte&0xf0);\n\n\t\t\t// Put the next byte in RLE. (It might get moved to UNC, below.)\n\t\t\trlectx->run_len = 2;\n\t\t\trlectx->run_byte |= next_pix;\n\t\t}\n\t\telse {\n\t\t\t// Nowhere to put the byte: write out everything, and start fresh.\n\t\t\trle4_write_unc_and_run(rlectx);\n\t\t\trlectx->run_len = 1;\n\t\t\trlectx->run_byte = next_pix<<4;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// If any RUN bytes that can be added to UNC for free, do so.\n\t\twhile(rlectx->unc_len>0 && rlectx->run_len>0 && rle4_get_incr_unc_cost(rlectx)==0) {\n\t\t\trlectx->unc_len++;\n\t\t\trlectx->run_len--;\n\t\t\ttmpb = rlectx->run_byte;\n\t\t\t// Reverse the two pixels stored in run_byte.\n\t\t\trlectx->run_byte = (tmpb>>4) | ((tmpb&0x0f)<<4);\n\t\t\tif(rlectx->run_len==1) rlectx->run_byte &= 0xf0;\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// If we hit certain high water marks, write out the current data.\n\n\t\tif(rlectx->run_len>=255) {\n\t\t\t// The maximum size for an RLE segment.\n\t\t\trle4_write_unc_and_run(rlectx);\n\t\t}\n\n\t\t// --------------------------------------------------------------\n\t\t// Sanity check(s). This can be removed if we're sure the algorithm\n\t\t// is bug-free.\n\n\t\t// run_len can be at most 254 at this point.\n\t\t// If it were 255, it should have been written out already.\n\t\tif(rlectx->run_len>255) {\n\t\t\tiw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 3\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t// End of row. Write out anything left over.\n\trle4_write_unc_and_run(rlectx);\n\n\t// Write an end-of-line marker (0 0), or if this is the last row,\n\t// an end-of-bitmap marker (0 1).\n\tdstbuf[0]=0x00;\n\tdstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;\n\tiwbmp_write(rlectx->wctx,dstbuf,2);\n\trlectx->total_bytes_written+=2;\n\n\tretval = 1;\n\ndone:\n\treturn retval;\n}\n\n//======================================================================\n\n// Seek back and write the \"file size\" and \"bits size\" fields.\nstatic int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)\n{\n\tiw_byte buf[4];\n\tsize_t fileheader_size;\n\tint ret;\n\n\tif(!wctx->iodescr->seek_fn) {\n\t\tiw_set_error(wctx->ctx,\"Writing compressed BMP requires a seek function\");\n\t\treturn 0;\n\t}\n\n\tif(wctx->include_file_header) {\n\t\t// Patch the file size in the file header\n\t\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);\n\t\tif(!ret) return 0;\n\t\tiw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));\n\t\tiwbmp_write(wctx,buf,4);\n\t\tfileheader_size = 14;\n\t}\n\telse {\n\t\tfileheader_size = 0;\n\t}\n\n\t// Patch the \"bits\" size\n\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);\n\tif(!ret) return 0;\n\tiw_set_ui32le(buf,(unsigned int)rlesize);\n\tiwbmp_write(wctx,buf,4);\n\n\t(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);\n\treturn 1;\n}\n\nstatic int iwbmp_write_pixels_compressed(struct iwbmpwcontext *wctx,\n\tstruct iw_image *img)\n{\n\tstruct rle_context rlectx;\n\tint j;\n\tint retval = 0;\n\n\tiw_zeromem(&rlectx,sizeof(struct rle_context));\n\n\trlectx.ctx = wctx->ctx;\n\trlectx.wctx = wctx;\n\trlectx.total_bytes_written = 0;\n\trlectx.img_width = img->width;\n\n\tfor(j=img->height-1;j>=0;j--) {\n\t\t// Compress and write a row of pixels\n\t\trlectx.srcrow = &img->pixels[j*img->bpr];\n\t\trlectx.cur_row = j;\n\n\t\tif(wctx->bitcount==4) {\n\t\t\tif(!rle4_compress_row(&rlectx)) goto done;\n\t\t}\n\t\telse if(wctx->bitcount==8) {\n\t\t\tif(!rle8_compress_row(&rlectx)) goto done;\n\t\t}\n\t\telse {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t// Back-patch the 'file size' and 'bits size' fields\n\tif(!rle_patch_file_size(wctx,rlectx.total_bytes_written)) goto done;\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nstatic void iwbmp_write_pixels_uncompressed(struct iwbmpwcontext *wctx,\n\tstruct iw_image *img)\n{\n\tint j;\n\tiw_byte *dstrow = NULL;\n\tconst iw_byte *srcrow;\n\n\tdstrow = iw_mallocz(wctx->ctx,wctx->unc_dst_bpr);\n\tif(!dstrow) goto done;\n\n\tfor(j=img->height-1;j>=0;j--) {\n\t\tsrcrow = &img->pixels[j*img->bpr];\n\t\tswitch(wctx->bitcount) {\n\t\tcase 32: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;\n\t\tcase 24: bmpw_convert_row_24(wctx,srcrow,dstrow,img->width); break;\n\t\tcase 16: bmpw_convert_row_16_32(wctx,srcrow,dstrow,img->width); break;\n\t\tcase 8: bmpw_convert_row_8(srcrow,dstrow,img->width); break;\n\t\tcase 4: bmpw_convert_row_4(srcrow,dstrow,img->width); break;\n\t\tcase 1: bmpw_convert_row_1(srcrow,dstrow,img->width); break;\n\t\t}\n\t\tiwbmp_write(wctx,dstrow,wctx->unc_dst_bpr);\n\t}\n\ndone:\n\tif(dstrow) iw_free(wctx->ctx,dstrow);\n\treturn;\n}\n\n// 0 = no transparency\n// 1 = binary transparency\n// 2 = partial transparency\nstatic int check_palette_transparency(const struct iw_palette *p)\n{\n\tint i;\n\tint retval = 0;\n\n\tfor(i=0;i<p->num_entries;i++) {\n\t\tif(p->entry[i].a!=255) retval=1;\n\t\tif(p->entry[i].a!=255 && p->entry[i].a!=0) return 2;\n\t}\n\treturn retval;\n}\n\n// Do some preparations needed to write a 16-bit or 32-bit BMP.\nstatic int setup_16_32bit(struct iwbmpwcontext *wctx,\n\tint mcc_r, int mcc_g, int mcc_b, int mcc_a)\n{\n\tint has_alpha;\n\n\thas_alpha = IW_IMGTYPE_HAS_ALPHA(wctx->img->imgtype);\n\n\tif(wctx->bmpversion<3) {\n\t\tiw_set_errorf(wctx->ctx,\"Bit depth incompatible with BMP version %d\",\n\t\t\twctx->bmpversion);\n\t\treturn 0;\n\t}\n\n\tif(has_alpha && wctx->bmpversion<5) {\n\t\tiw_set_error(wctx->ctx,\"Internal: Attempt to write v3 16- or 32-bit image with transparency\");\n\t\treturn 0;\n\t}\n\n\t// Make our own copy of the max color codes, so that we don't have to\n\t// do \"if(grayscale)\" so much.\n\twctx->maxcolor[0] = mcc_r;\n\twctx->maxcolor[1] = mcc_g;\n\twctx->maxcolor[2] = mcc_b;\n\tif(has_alpha) wctx->maxcolor[3] = mcc_a;\n\n\tif(!iwbmp_calc_bitfields_masks(wctx,has_alpha?4:3)) return 0;\n\n\tif(mcc_r==31 && mcc_g==31 && mcc_b==31 && !has_alpha) {\n\t\t// For the default 5-5-5, set the 'compression' to BI_RGB\n\t\t// instead of BITFIELDS, and don't write a BITFIELDS segment\n\t\t// (or for v5 BMP, don't set the Mask fields).\n\t\twctx->bitfields_size = 0;\n\t}\n\telse {\n\t\twctx->uses_bitfields = 1;\n\t\twctx->bitfields_size = (wctx->bmpversion==3) ? 12 : 0;\n\t}\n\treturn 1;\n}\n\nstatic int iwbmp_write_main(struct iwbmpwcontext *wctx)\n{\n\tstruct iw_image *img;\n\tint cmpr_req;\n\tint retval = 0;\n\tint x;\n\tconst char *optv;\n\n\timg = wctx->img;\n\n\twctx->bmpversion = 0;\n\toptv = iw_get_option(wctx->ctx, \"bmp:version\");\n\tif(optv) {\n\t\twctx->bmpversion = iw_parse_int(optv);\n\t}\n\n\tif(wctx->bmpversion==0) wctx->bmpversion=3;\n\tif(wctx->bmpversion==4) {\n\t\tiw_warning(wctx->ctx,\"Writing BMP v4 is not supported; using v3 instead\");\n\t\twctx->bmpversion=3;\n\t}\n\tif(wctx->bmpversion!=2 && wctx->bmpversion!=3 && wctx->bmpversion!=5) {\n\t\tiw_set_errorf(wctx->ctx,\"Unsupported BMP version: %d\",wctx->bmpversion);\n\t\tgoto done;\n\t}\n\n\tif(wctx->bmpversion>=3)\n\t\tcmpr_req = iw_get_value(wctx->ctx,IW_VAL_COMPRESSION);\n\telse\n\t\tcmpr_req = IW_COMPRESSION_NONE;\n\n\tif(wctx->bmpversion==2)\n\t\twctx->header_size = 12;\n\telse if(wctx->bmpversion==5)\n\t\twctx->header_size = 124;\n\telse\n\t\twctx->header_size = 40;\n\n\twctx->no_cslabel = iw_get_value(wctx->ctx,IW_VAL_NO_CSLABEL);\n\n\t// If any kind of compression was requested, use RLE if possible.\n\tif(cmpr_req==IW_COMPRESSION_AUTO || cmpr_req==IW_COMPRESSION_NONE)\n\t\tcmpr_req = IW_COMPRESSION_NONE;\n\telse\n\t\tcmpr_req = IW_COMPRESSION_RLE;\n\n\tif(img->imgtype==IW_IMGTYPE_RGB) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE],0))\n\t\t\t{\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\twctx->bitcount=24;\n\t\t}\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_PALETTE) {\n\t\tif(!wctx->pal) goto done;\n\n\t\tx = check_palette_transparency(wctx->pal);\n\n\t\tif(x!=0 && wctx->bmpversion<3) {\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save as a transparent BMP: Incompatible BMP version\");\n\t\t\tgoto done;\n\t\t}\n\t\telse if(x==2) {\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save this image as a transparent BMP: Has partial transparency\");\n\t\t\tgoto done;\n\t\t}\n\t\telse if(x!=0 && cmpr_req!=IW_COMPRESSION_RLE) {\n\t\t\tiw_set_error(wctx->ctx,\"Cannot save as a transparent BMP: RLE compression required\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif(wctx->pal->num_entries<=2 && cmpr_req!=IW_COMPRESSION_RLE)\n\t\t\twctx->bitcount=1;\n\t\telse if(wctx->pal->num_entries<=16)\n\t\t\twctx->bitcount=4;\n\t\telse\n\t\t\twctx->bitcount=8;\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_RGBA) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_RED],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GREEN],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_BLUE],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA]))\n\t\t\t{\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(!setup_16_32bit(wctx,255,255,255,255)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_GRAYA) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_ALPHA]))\n\t\t\t{\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(!setup_16_32bit(wctx,255,255,255,255)) {\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\telse if(img->imgtype==IW_IMGTYPE_GRAY) {\n\t\tif(img->reduced_maxcolors) {\n\t\t\tif(img->maxcolorcode[IW_CHANNELTYPE_GRAY]<=1023) {\n\t\t\t\tif(!setup_16_32bit(wctx,img->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],\n\t\t\t\t\timg->maxcolorcode[IW_CHANNELTYPE_GRAY],0))\n\t\t\t\t{\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiw_set_error(wctx->ctx,\"Cannot write grayscale BMP at this bit depth\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// We normally won't get here, because a grayscale image should have\n\t\t\t// been optimized and converted to a palette image.\n\t\t\t// But maybe that optimization was disabled.\n\t\t\twctx->bitcount=24;\n\t\t}\n\t}\n\telse {\n\t\tiw_set_error(wctx->ctx,\"Internal: Bad image type for BMP\");\n\t\tgoto done;\n\t}\n\n\tif(cmpr_req==IW_COMPRESSION_RLE && (wctx->bitcount==4 || wctx->bitcount==8)) {\n\t\twctx->compressed = 1;\n\t}\n\n\twctx->unc_dst_bpr = iwbmp_calc_bpr(wctx->bitcount,img->width);\n\twctx->unc_bitssize = wctx->unc_dst_bpr * img->height;\n\twctx->palentries = 0;\n\n\tif(wctx->pal) {\n\t\tif(wctx->bmpversion==2) {\n\t\t\twctx->palentries = 1<<wctx->bitcount;\n\t\t\twctx->palsize = wctx->palentries*3;\n\t\t}\n\t\telse {\n\t\t\tif(wctx->bitcount==1) {\n\t\t\t\t// The documentation says that if the bitdepth is 1, the palette\n\t\t\t\t// contains exactly two entries.\n\t\t\t\twctx->palentries=2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twctx->palentries = wctx->pal->num_entries;\n\t\t\t}\n\t\t\twctx->palsize = wctx->palentries*4;\n\t\t}\n\t}\n\n\t// File header\n\tiwbmp_write_file_header(wctx);\n\n\t// Bitmap header (\"BITMAPINFOHEADER\")\n\tif(!iwbmp_write_bmp_header(wctx)) {\n\t\tgoto done;\n\t}\n\n\tif(wctx->bitfields_size>0) {\n\t\tif(!iwbmp_write_bitfields(wctx)) goto done;\n\t}\n\n\t// Palette\n\tiwbmp_write_palette(wctx);\n\n\t// Pixels\n\tif(wctx->compressed) {\n\t\tif(!iwbmp_write_pixels_compressed(wctx,img)) goto done;\n\t}\n\telse {\n\t\tiwbmp_write_pixels_uncompressed(wctx,img);\n\t}\n\n\tretval = 1;\ndone:\n\treturn retval;\n}\n\nIW_IMPL(int) iw_write_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iwbmpwcontext wctx;\n\tint retval=0;\n\tstruct iw_image img1;\n\n\tiw_zeromem(&img1,sizeof(struct iw_image));\n\n\tiw_zeromem(&wctx,sizeof(struct iwbmpwcontext));\n\n\twctx.ctx = ctx;\n\twctx.include_file_header = 1;\n\n\twctx.iodescr=iodescr;\n\n\tiw_get_output_image(ctx,&img1);\n\twctx.img = &img1;\n\n\tif(wctx.img->imgtype==IW_IMGTYPE_PALETTE) {\n\t\twctx.pal = iw_get_output_palette(ctx);\n\t\tif(!wctx.pal) goto done;\n\t}\n\n\tiw_get_output_colorspace(ctx,&wctx.csdescr);\n\n\tif(!iwbmp_write_main(&wctx)) {\n\t\tiw_set_error(ctx,\"BMP write failed\");\n\t\tgoto done;\n\t}\n\n\tretval=1;\n\ndone:\n\treturn retval;\n}\n", "// imagew-util.c\n// Part of ImageWorsener, Copyright (c) 2011 by Jason Summers.\n// For more information, see the readme.txt file.\n\n// This file is mainly for portability wrappers, and any code that\n// may require unusual header files (malloc.h, strsafe.h).\n\n#include \"imagew-config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef IW_WINDOWS\n#include <malloc.h>\n#endif\n#include <stdarg.h>\n#include <time.h>\n\n#include \"imagew-internals.h\"\n#ifdef IW_WINDOWS\n#include <strsafe.h>\n#endif\n\n\nvoid* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)\n{\n\tif(flags & IW_MALLOCFLAG_ZEROMEM) {\n\t\treturn calloc(n,1);\n\t}\n\treturn malloc(n);\n}\n\nvoid iwpvt_default_free(void *userdata, void *mem)\n{\n\tfree(mem);\n}\n\nIW_IMPL(void*) iw_malloc_ex(struct iw_context *ctx, unsigned int flags, size_t n)\n{\n\tvoid *mem;\n\n\tif(n>ctx->max_malloc) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\n\tmem = (*ctx->mallocfn)(ctx->userdata,flags,n);\n\n\tif(!mem) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\treturn mem;\n}\n\nIW_IMPL(void*) iw_malloc(struct iw_context *ctx, size_t n)\n{\n\treturn iw_malloc_ex(ctx,0,n);\n}\n\nIW_IMPL(void*) iw_mallocz(struct iw_context *ctx, size_t n)\n{\n\treturn iw_malloc_ex(ctx,IW_MALLOCFLAG_ZEROMEM,n);\n}\n\n// Allocate a large block of memory, presumably for image data.\n// Use this if integer overflow is a possibility when multiplying\n// two factors together.\nIW_IMPL(void*) iw_malloc_large(struct iw_context *ctx, size_t n1, size_t n2)\n{\n\tif(n1 > ctx->max_malloc/n2) {\n\t\tiw_set_error(ctx,\"Image too large to process\");\n\t\treturn NULL;\n\t}\n\treturn iw_malloc_ex(ctx,0,n1*n2);\n}\n\n// Emulate realloc using malloc, by always allocating a new memory block.\nstatic void* emulated_realloc(struct iw_context *ctx, unsigned int flags,\n\tvoid *oldmem, size_t oldmem_size, size_t newmem_size)\n{\n\tvoid *newmem;\n\n\tnewmem = (*ctx->mallocfn)(ctx->userdata,flags,newmem_size);\n\tif(oldmem && newmem) {\n\t\tif(oldmem_size<newmem_size)\n\t\t\tmemcpy(newmem,oldmem,oldmem_size);\n\t\telse\n\t\t\tmemcpy(newmem,oldmem,newmem_size);\n\t}\n\tif(oldmem) {\n\t\t// Our realloc functions always free the old memory, even on failure.\n\t\t(*ctx->freefn)(ctx->userdata,oldmem);\n\t}\n\treturn newmem;\n}\n\nIW_IMPL(void*) iw_realloc_ex(struct iw_context *ctx, unsigned int flags,\n\tvoid *oldmem, size_t oldmem_size, size_t newmem_size)\n{\n\tvoid *mem;\n\n\tif(!oldmem) {\n\t\treturn iw_malloc_ex(ctx,flags,newmem_size);\n\t}\n\n\tif(newmem_size>ctx->max_malloc) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\n\tmem = emulated_realloc(ctx,flags,oldmem,oldmem_size,newmem_size);\n\n\tif(!mem) {\n\t\tif(!(flags&IW_MALLOCFLAG_NOERRORS))\n\t\t\tiw_set_error(ctx,\"Out of memory\");\n\t\treturn NULL;\n\t}\n\treturn mem;\n}\n\nIW_IMPL(void*) iw_realloc(struct iw_context *ctx, void *oldmem,\n\tsize_t oldmem_size, size_t newmem_size)\n{\n\treturn iw_realloc_ex(ctx,0,oldmem,oldmem_size,newmem_size);\n}\n\nIW_IMPL(void) iw_free(struct iw_context *ctx, void *mem)\n{\n\tif(!mem) return;\n\t// Note that this function can be used to free the ctx struct itself,\n\t// so we're not allowed to use ctx after freeing the memory.\n\t(*ctx->freefn)(ctx->userdata,mem);\n}\n\nIW_IMPL(char*) iw_strdup(struct iw_context *ctx, const char *s)\n{\n\tsize_t len;\n\tchar *s2;\n\tif(!s) return NULL;\n\tlen = strlen(s);\n\ts2 = iw_malloc(ctx, len+1);\n\tif(!s2) return NULL;\n\tmemcpy(s2, s, len+1);\n\treturn s2;\n}\n\nchar* iwpvt_strdup_dbl(struct iw_context *ctx, double n)\n{\n\tchar buf[100];\n\tiw_snprintf(buf, sizeof(buf), \"%.20f\", n);\n\treturn iw_strdup(ctx, buf);\n}\n\nIW_IMPL(void) iw_strlcpy(char *dst, const char *src, size_t dstlen)\n{\n\tsize_t n;\n\tn = strlen(src);\n\tif(n>dstlen-1) n=dstlen-1;\n\tmemcpy(dst,src,n);\n\tdst[n]='\\0';\n}\n\nIW_IMPL(void) iw_vsnprintf(char *buf, size_t buflen, const char *fmt, va_list ap)\n{\n#ifdef IW_WINDOWS\n\tStringCchVPrintfA(buf,buflen,fmt,ap);\n#else\n\tvsnprintf(buf,buflen,fmt,ap);\n\tbuf[buflen-1]='\\0';\n#endif\n}\n\nIW_IMPL(void) iw_snprintf(char *buf, size_t buflen, const char *fmt, ...)\n{\n\tva_list ap;\n\tva_start(ap, fmt);\n\tiw_vsnprintf(buf,buflen,fmt,ap);\n\tva_end(ap);\n}\n\nIW_IMPL(int) iw_stricmp(const char *s1, const char *s2)\n{\n#ifdef IW_WINDOWS\n\treturn _stricmp(s1,s2);\n#else\n\treturn strcasecmp(s1,s2);\n#endif\n}\n\nIW_IMPL(void) iw_zeromem(void *mem, size_t n)\n{\n\tmemset(mem,0,n);\n}\n\n////////////////////////////////////////////\n// A simple carry-with-multiply pseudorandom number generator (PRNG).\n\nstruct iw_prng {\n\tiw_uint32 multiply;\n\tiw_uint32 carry;\n};\n\nstruct iw_prng *iwpvt_prng_create(struct iw_context *ctx)\n{\n\tstruct iw_prng *prng;\n\tprng = (struct iw_prng*)iw_mallocz(ctx,sizeof(struct iw_prng));\n\tif(!prng) return NULL;\n\treturn prng;\n}\n\nvoid iwpvt_prng_destroy(struct iw_context *ctx, struct iw_prng *prng)\n{\n\tif(prng) iw_free(ctx,(void*)prng);\n}\n\nvoid iwpvt_prng_set_random_seed(struct iw_prng *prng, int s)\n{\n\tprng->multiply = ((iw_uint32)0x03333333) + s;\n\tprng->carry    = ((iw_uint32)0x05555555) + s;\n}\n\niw_uint32 iwpvt_prng_rand(struct iw_prng *prng)\n{\n\tiw_uint64 x;\n\tx = ((iw_uint64)0xfff0bf23) * prng->multiply + prng->carry;\n\tprng->carry = (iw_uint32)(x>>32);\n\tprng->multiply = 0xffffffff - (0xffffffff & x);\n\treturn prng->multiply;\n}\n\n////////////////////////////////////////////\n\nint iwpvt_util_randomize(struct iw_prng *prng)\n{\n\tint s;\n\ts = (int)time(NULL);\n\tiwpvt_prng_set_random_seed(prng, s);\n\treturn s;\n}\n\nIW_IMPL(int) iw_file_to_memory(struct iw_context *ctx, struct iw_iodescr *iodescr,\n  void **pmem, iw_int64 *psize)\n{\n\tint ret;\n\tsize_t bytesread;\n\n\t*pmem=NULL;\n\t*psize=0;\n\n\tif(!iodescr->getfilesize_fn) return 0;\n\n\tret = (*iodescr->getfilesize_fn)(ctx,iodescr,psize);\n\t// TODO: Don't require a getfilesize function.\n\tif(!ret) return 0;\n\n\t*pmem = iw_malloc(ctx,(size_t)*psize);\n\n\tret = (*iodescr->read_fn)(ctx,iodescr,*pmem,(size_t)*psize,&bytesread);\n\tif(!ret) return 0;\n\tif((iw_int64)bytesread != *psize) return 0;\n\treturn 1;\n}\n\nstruct iw_utf8cvt_struct {\n\tchar *dst;\n\tint dstlen;\n\tint dp;\n};\n\nstatic void utf8cvt_emitoctet(struct iw_utf8cvt_struct *s, unsigned char c)\n{\n\tif(s->dp > s->dstlen-2) return;\n\ts->dst[s->dp] = (char)c;\n\ts->dp++;\n}\n\n// Map Unicode characters to ASCII substitutions.\n// Not used for codepoints <=127.\nstatic void utf8cvt_emitunichar(struct iw_utf8cvt_struct *s, unsigned int c)\n{\n\tint i;\n\tint pos;\n\tstruct charmap_struct {\n\t\tunsigned int code;\n\t\tconst char *s;\n\t};\n\tstatic const struct charmap_struct chartable[] = {\n\t {0, \"?\" }, // Default character\n\t {0x00a9, \"(c)\" },\n\t {0x00d7, \"x\" }, // multiplication sign\n\t {0x2013, \"-\" }, // en dash\n\t {0x2018, \"'\" }, // left single quote\n\t {0x2019, \"'\" }, // right single quote\n\t {0x201c, \"\\\"\" }, // left double quote\n\t {0x201d, \"\\\"\" }, // right double quote\n\t {0x2192, \"->\" },\n\t {0xfeff, \"\" }, // zero-width no-break space\n\t {0, NULL}\n\t};\n\n\t// Try to find the codepoint in the table.\n\tpos = 0;\n\tfor(i=1;chartable[i].code;i++) {\n\t\tif(c==chartable[i].code) {\n\t\t\tpos=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Write out the ASCII translation of this code.\n\tfor(i=0;chartable[pos].s[i];i++) {\n\t\tutf8cvt_emitoctet(s,(unsigned char)chartable[pos].s[i]);\n\t}\n}\n\n// This UTF-8 converter is intended to be safe to use with malformed data, but\n// it may not handle it in the best possible way. It mostly just skips over it.\nIW_IMPL(void) iw_utf8_to_ascii(const char *src, char *dst, int dstlen)\n{\n\tstruct iw_utf8cvt_struct s;\n\tint sp;\n\tunsigned char c;\n\tunsigned int pending_char;\n\tint bytes_expected;\n\n\ts.dst = dst;\n\ts.dstlen = dstlen;\n\ts.dp = 0;\n\tpending_char=0;\n\tbytes_expected=0;\n\n\tfor(sp=0;src[sp];sp++) {\n\t\tc = (unsigned char)src[sp];\n\t\tif(c<128) { // Only byte of a 1-byte sequence\n\t\t\tutf8cvt_emitoctet(&s,c);\n\t\t\tbytes_expected=0;\n\t\t}\n\t\telse if(c<0xc0) { // Continuation byte\n\t\t\tif(bytes_expected>0) {\n\t\t\t\tpending_char = (pending_char<<6)|(c&0x3f);\n\t\t\t\tbytes_expected--;\n\t\t\t\tif(bytes_expected<1) {\n\t\t\t\t\tutf8cvt_emitunichar(&s,pending_char);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(c<0xe0) { // 1st byte of a 2-byte sequence\n\t\t\tpending_char = c&0x1f;\n\t\t\tbytes_expected=1;\n\t\t}\n\t\telse if(c<0xf0) { // 1st byte of a 3-byte sequence\n\t\t\tpending_char = c&0x0f;\n\t\t\tbytes_expected=2;\n\t\t}\n\t\telse if(c<0xf8) { // 1st byte of a 4-byte sequence\n\t\t\tpending_char = c&0x07;\n\t\t\tbytes_expected=3;\n\t\t}\n\t}\n\tdst[s.dp] = '\\0';\n}\n\nIW_IMPL(int) iw_get_host_endianness(void)\n{\n\tiw_byte b;\n\tunsigned int x = 1;\n\tmemcpy(&b,&x,1);\n\treturn b==0 ? IW_ENDIAN_BIG : IW_ENDIAN_LITTLE;\n}\n\nIW_IMPL(void) iw_set_ui16le(iw_byte *b, unsigned int n)\n{\n\tb[0] = n&0xff;\n\tb[1] = (n>>8)&0xff;\n}\n\nIW_IMPL(void) iw_set_ui32le(iw_byte *b, unsigned int n)\n{\n\tb[0] = n&0xff;\n\tb[1] = (n>>8)&0xff;\n\tb[2] = (n>>16)&0xff;\n\tb[3] = (n>>24)&0xff;\n}\n\nIW_IMPL(void) iw_set_ui16be(iw_byte *b, unsigned int n)\n{\n\tb[0] = (n>>8)&0xff;\n\tb[1] = n&0xff;\n}\n\nIW_IMPL(void) iw_set_ui32be(iw_byte *b, unsigned int n)\n{\n\tb[0] = (n>>24)&0xff;\n\tb[1] = (n>>16)&0xff;\n\tb[2] = (n>>8)&0xff;\n\tb[3] = n&0xff;\n}\n\nIW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8);\n}\n\nIW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24);\n}\n\nIW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));\n}\n\nIW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn ((unsigned int)b[0]<<8) | (unsigned int)b[1];\n}\n\nIW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn ((unsigned int)b[0]<<24) | ((unsigned int)b[1]<<16) |\n\t\t((unsigned int)b[2]<<8) | (unsigned int)b[3];\n}\n\n// Accepts a flag indicating the endianness.\nIW_IMPL(unsigned int) iw_get_ui16_e(const iw_byte *b, int endian)\n{\n\tif(endian==IW_ENDIAN_LITTLE)\n\t\treturn iw_get_ui16le(b);\n\treturn iw_get_ui16be(b);\n}\n\nIW_IMPL(unsigned int) iw_get_ui32_e(const iw_byte *b, int endian)\n{\n\tif(endian==IW_ENDIAN_LITTLE)\n\t\treturn iw_get_ui32le(b);\n\treturn iw_get_ui32be(b);\n}\n\nIW_IMPL(int) iw_max_color_to_bitdepth(unsigned int mc)\n{\n\tunsigned int bd;\n\n\tfor(bd=1;bd<=15;bd++) {\n\t\tif(mc < (1U<<bd)) return bd;\n\t}\n\treturn 16;\n}\n\nIW_IMPL(int) iw_detect_fmt_from_filename(const char *fn)\n{\n\tchar *s;\n\tint i;\n\tstruct fmttable_struct {\n\t\tconst char *ext;\n\t\tint fmt;\n\t};\n\tstatic const struct fmttable_struct fmttable[] = {\n\t {\"png\", IW_FORMAT_PNG},\n\t {\"jpg\", IW_FORMAT_JPEG},\n\t {\"jpeg\", IW_FORMAT_JPEG},\n\t {\"bmp\", IW_FORMAT_BMP},\n\t {\"tif\", IW_FORMAT_TIFF},\n\t {\"tiff\", IW_FORMAT_TIFF},\n\t {\"miff\", IW_FORMAT_MIFF},\n\t {\"webp\", IW_FORMAT_WEBP},\n\t {\"gif\", IW_FORMAT_GIF},\n\t {\"pnm\", IW_FORMAT_PNM},\n\t {\"pbm\", IW_FORMAT_PBM},\n\t {\"pgm\", IW_FORMAT_PGM},\n\t {\"ppm\", IW_FORMAT_PPM},\n\t {\"pam\", IW_FORMAT_PAM},\n\t {NULL, 0}\n\t};\n\n\ts=strrchr(fn,'.');\n\tif(!s) return IW_FORMAT_UNKNOWN;\n\ts++;\n\n\tfor(i=0;fmttable[i].ext;i++) {\n\t\tif(!iw_stricmp(s,fmttable[i].ext)) return fmttable[i].fmt;\n\t}\n\t\n\treturn IW_FORMAT_UNKNOWN;\n}\n\nIW_IMPL(const char*) iw_get_fmt_name(int fmt)\n{\n\tstatic const char *n;\n\tn=NULL;\n\tswitch(fmt) {\n\tcase IW_FORMAT_PNG:  n=\"PNG\";  break;\n\tcase IW_FORMAT_JPEG: n=\"JPEG\"; break;\n\tcase IW_FORMAT_BMP:  n=\"BMP\";  break;\n\tcase IW_FORMAT_TIFF: n=\"TIFF\"; break;\n\tcase IW_FORMAT_MIFF: n=\"MIFF\"; break;\n\tcase IW_FORMAT_WEBP: n=\"WebP\"; break;\n\tcase IW_FORMAT_GIF:  n=\"GIF\";  break;\n\tcase IW_FORMAT_PNM:  n=\"PNM\";  break;\n\tcase IW_FORMAT_PBM:  n=\"PBM\";  break;\n\tcase IW_FORMAT_PGM:  n=\"PGM\";  break;\n\tcase IW_FORMAT_PPM:  n=\"PPM\";  break;\n\tcase IW_FORMAT_PAM:  n=\"PAM\";  break;\n\t}\n\treturn n;\n}\n\nIW_IMPL(int) iw_detect_fmt_of_file(const iw_byte *buf, size_t n)\n{\n\tint fmt = IW_FORMAT_UNKNOWN;\n\n\tif(n<2) return fmt;\n\n\tif(buf[0]==0x89 && buf[1]==0x50) {\n\t\tfmt=IW_FORMAT_PNG;\n\t}\n\telse if(n>=3 && buf[0]=='G' && buf[1]=='I' && buf[2]=='F') {\n\t\tfmt=IW_FORMAT_GIF;\n\t}\n\telse if(buf[0]==0xff && buf[1]==0xd8) {\n\t\tfmt=IW_FORMAT_JPEG;\n\t}\n\telse if(buf[0]=='B' && buf[1]=='M') {\n\t\tfmt=IW_FORMAT_BMP;\n\t}\n\telse if(buf[0]=='B' && buf[1]=='A') {\n\t\tfmt=IW_FORMAT_BMP;\n\t}\n\telse if((buf[0]==0x49 || buf[0]==0x4d) && buf[1]==buf[0]) {\n\t\tfmt=IW_FORMAT_TIFF;\n\t}\n\telse if(buf[0]==0x69 && buf[1]==0x64) {\n\t\tfmt=IW_FORMAT_MIFF;\n\t}\n\telse if(n>=12 && buf[0]==0x52 && buf[1]==0x49 && buf[2]==0x46 && buf[3]==0x46 &&\n\t   buf[8]==0x57 && buf[9]==0x45 && buf[10]==0x42 && buf[11]==0x50)\n\t{\n\t\tfmt=IW_FORMAT_WEBP;\n\t}\n\telse if(buf[0]=='P' && (buf[1]>='1' && buf[1]<='6')) {\n\t\treturn IW_FORMAT_PNM;\n\t}\n\telse if(buf[0]=='P' && (buf[1]=='7' && buf[2]==0x0a)) {\n\t\treturn IW_FORMAT_PAM;\n\t}\n\n\treturn fmt;\n}\n\nIW_IMPL(unsigned int) iw_get_profile_by_fmt(int fmt)\n{\n\tunsigned int p;\n\n\tswitch(fmt) {\n\n\tcase IW_FORMAT_PNG:\n\t\tp = IW_PROFILE_TRANSPARENCY | IW_PROFILE_GRAYSCALE | IW_PROFILE_PALETTETRNS |\n\t\t    IW_PROFILE_GRAY1 | IW_PROFILE_GRAY2 | IW_PROFILE_GRAY4 | IW_PROFILE_16BPS |\n\t\t    IW_PROFILE_BINARYTRNS | IW_PROFILE_PAL1 | IW_PROFILE_PAL2 | IW_PROFILE_PAL4 |\n\t\t    IW_PROFILE_PAL8 | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_PNG_BKGD;\n\t\tbreak;\n\n\tcase IW_FORMAT_BMP:\n\t\tp = IW_PROFILE_PAL1 | IW_PROFILE_PAL4 | IW_PROFILE_PAL8 |\n\t\t\tIW_PROFILE_REDUCEDBITDEPTHS;\n\t\tbreak;\n\n\tcase IW_FORMAT_JPEG:\n\t\tp = IW_PROFILE_GRAYSCALE;\n\t\tbreak;\n\n\tcase IW_FORMAT_TIFF:\n\t\tp = IW_PROFILE_TRANSPARENCY | IW_PROFILE_GRAYSCALE | IW_PROFILE_GRAY1 |\n\t\t    IW_PROFILE_GRAY4 | IW_PROFILE_16BPS | IW_PROFILE_PAL4 | IW_PROFILE_PAL8;\n\t\tbreak;\n\n\tcase IW_FORMAT_MIFF:\n\t\tp = IW_PROFILE_TRANSPARENCY | IW_PROFILE_GRAYSCALE | IW_PROFILE_ALWAYSLINEAR |\n\t\t    IW_PROFILE_HDRI | IW_PROFILE_RGB16_BKGD;\n\t\tbreak;\n\n\tcase IW_FORMAT_WEBP:\n\t\tp = 0;\n#if IW_WEBP_SUPPORT_TRANSPARENCY\n\t\tp |= IW_PROFILE_TRANSPARENCY;\n#endif\n\t\tbreak;\n\n\tcase IW_FORMAT_PAM:\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_GRAYSCALE |\n\t\t\tIW_PROFILE_GRAY1 | IW_PROFILE_TRANSPARENCY;\n\t\tbreak;\n\n\tcase IW_FORMAT_PNM:\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_GRAYSCALE |\n\t\t\tIW_PROFILE_GRAY1;\n\t\tbreak;\n\n\tcase IW_FORMAT_PPM:\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS;\n\t\tbreak;\n\n\tcase IW_FORMAT_PGM:\n\t\t// No reason to set GRAY[124], because we can't optimize for them. Each pixel\n\t\t// uses a minimum of one byte.\n\t\tp = IW_PROFILE_16BPS | IW_PROFILE_REDUCEDBITDEPTHS | IW_PROFILE_GRAYSCALE;\n\t\tbreak;\n\n\tcase IW_FORMAT_PBM:\n\t\tp = IW_PROFILE_GRAY1;\n\t\tbreak;\n\n\tdefault:\n\t\tp = 0;\n\t}\n\n\treturn p;\n}\n\n// The imagew-allfmts.c file is probably a more logical place for the\n// iw_is_*_fmt_supported() functions, but putting them there could create\n// unnecessary dependencies on third-party libraries.\n\nIW_IMPL(int) iw_is_input_fmt_supported(int fmt)\n{\n\tswitch(fmt) {\n#if IW_SUPPORT_PNG == 1\n\tcase IW_FORMAT_PNG:\n#endif\n#if IW_SUPPORT_JPEG == 1\n\tcase IW_FORMAT_JPEG:\n#endif\n#if IW_SUPPORT_WEBP == 1\n\tcase IW_FORMAT_WEBP:\n#endif\n\tcase IW_FORMAT_MIFF:\n\tcase IW_FORMAT_GIF:\n\tcase IW_FORMAT_BMP:\n\tcase IW_FORMAT_PNM:\n\tcase IW_FORMAT_PAM:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nIW_IMPL(int) iw_is_output_fmt_supported(int fmt)\n{\n\tswitch(fmt) {\n#if IW_SUPPORT_PNG == 1\n\tcase IW_FORMAT_PNG:\n#endif\n#if IW_SUPPORT_JPEG == 1\n\tcase IW_FORMAT_JPEG:\n#endif\n#if IW_SUPPORT_WEBP == 1\n\tcase IW_FORMAT_WEBP:\n#endif\n\tcase IW_FORMAT_BMP:\n\tcase IW_FORMAT_TIFF:\n\tcase IW_FORMAT_MIFF:\n\tcase IW_FORMAT_PNM:\n\tcase IW_FORMAT_PPM:\n\tcase IW_FORMAT_PGM:\n\tcase IW_FORMAT_PBM:\n\tcase IW_FORMAT_PAM:\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n// Find where a number ends (at a comma, or the end of string),\n// and record if it contained a slash.\nstatic int iw_get_number_len(const char *s, int *pslash_pos)\n{\n\tint i;\n\tfor(i=0;s[i];i++) {\n\t\tif(s[i]=='/') {\n\t\t\t*pslash_pos = i;\n\t\t}\n\t\tif(s[i]!=',') continue;\n\t\treturn i;\n\t}\n\treturn i;\n}\n\n// Returns 0 if no valid number found.\nstatic int iw_parse_number_internal(const char *s,\n\t\t   double *presult, int *pcharsread)\n{\n\tint len;\n\tint slash_pos = -1;\n\n\t*presult = 0.0;\n\t*pcharsread = 0;\n\n\tlen = iw_get_number_len(s,&slash_pos);\n\tif(len<1) return 0;\n\t*pcharsread = len;\n\n\tif(slash_pos>=0) {\n\t\t// a rational number\n\t\tdouble numer, denom;\n\t\tnumer = atof(s);\n\t\tdenom = atof(s+slash_pos+1);\n\t\tif(denom==0.0)\n\t\t\t*presult = 0.0;\n\t\telse\n\t\t\t*presult = numer/denom;\n\t}\n\telse {\n\t\t*presult = atof(s);\n\t}\n\treturn 1;\n}\n\n// Returns number of numbers parsed.\n// If there are not enough numbers, leaves some contents of 'results' unchanged.\nIW_IMPL(int) iw_parse_number_list(const char *s,\n\tint max_numbers, // max number of numbers to parse\n\tdouble *results) // array of doubles to hold the results\n{\n\tint n;\n\tint charsread;\n\tint curpos=0;\n\tint ret;\n\tint numresults = 0;\n\n\tfor(n=0;n<max_numbers;n++) {\n\t\tret=iw_parse_number_internal(&s[curpos], &results[n], &charsread);\n\t\tif(!ret) break;\n\t\tnumresults++;\n\t\tcurpos+=charsread;\n\t\tif(s[curpos]==',') {\n\t\t\tcurpos++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn numresults;\n}\n\nIW_IMPL(double) iw_parse_number(const char *s)\n{\n\tdouble result;\n\tint charsread;\n\tiw_parse_number_internal(s, &result, &charsread);\n\treturn result;\n}\n\nIW_IMPL(int) iw_round_to_int(double x)\n{\n\tif(x<0.0) return -(int)(0.5-x);\n\treturn (int)(0.5+x);\n}\n\nIW_IMPL(int) iw_parse_int(const char *s)\n{\n\tdouble result;\n\tint charsread;\n\tiw_parse_number_internal(s, &result, &charsread);\n\treturn iw_round_to_int(result);\n}\n"], "filenames": ["src/imagew-bmp.c", "src/imagew-util.c"], "buggy_code_start_loc": [428, 405], "buggy_code_end_loc": [437, 426], "fixing_code_start_loc": [428, 405], "fixing_code_end_loc": [437, 429], "type": "CWE-682", "message": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.", "other": {"cve": {"id": "CVE-2017-8326", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-29T20:59:00.227", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c."}, {"lang": "es", "value": "libimageworsener.a en ImageWorsener anterior a la versi\u00f3n 1.3.1 presenta \"desplazamiento a la izquierda no puede representarse con el tipo entero\", problemas de comportamiento no definidos, lo que podr\u00eda permitir a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda de la aplicaci\u00f3n) o posiblemente tener otro impacto no especificado a trav\u00e9s de una imagen manipulada, relacionado con imagew-bmp.c y imagew-util.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-682"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:entropymine:imageworsener:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.3.0", "matchCriteriaId": "7DBC0041-62D4-4318-BA84-2B941F8D93F9"}]}]}], "references": [{"url": "https://blogs.gentoo.org/ago/2017/04/27/imageworsener-two-left-shift/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201706-06", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738"}}