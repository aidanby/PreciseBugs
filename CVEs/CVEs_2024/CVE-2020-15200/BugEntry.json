{"buggy_code": ["/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"absl/container/flat_hash_map.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\ntemplate <class T>\nusing BatchedMap = std::vector<absl::flat_hash_map<int64, T>>;\n\nnamespace {\n// TODO(momernick): Extend this function to work with outputs of rank > 2.\ntemplate <class T>\nStatus OutputSparse(const BatchedMap<T>& per_batch_counts, int num_values,\n                    bool is_1d, OpKernelContext* context) {\n  int total_values = 0;\n  int num_batches = per_batch_counts.size();\n  for (const auto& per_batch_count : per_batch_counts) {\n    total_values += per_batch_count.size();\n  }\n\n  Tensor* indices;\n  int inner_dim = is_1d ? 1 : 2;\n  TF_RETURN_IF_ERROR(context->allocate_output(\n      0, TensorShape({total_values, inner_dim}), &indices));\n\n  Tensor* values;\n  TF_RETURN_IF_ERROR(\n      context->allocate_output(1, TensorShape({total_values}), &values));\n\n  auto output_indices = indices->matrix<int64>();\n  auto output_values = values->flat<T>();\n  int64 value_loc = 0;\n  for (int b = 0; b < num_batches; ++b) {\n    const auto& per_batch_count = per_batch_counts[b];\n    std::vector<std::pair<int, T>> pairs(per_batch_count.begin(),\n                                         per_batch_count.end());\n    std::sort(pairs.begin(), pairs.end());\n    for (const auto& x : pairs) {\n      if (is_1d) {\n        output_indices(value_loc, 0) = x.first;\n      } else {\n        output_indices(value_loc, 0) = b;\n        output_indices(value_loc, 1) = x.first;\n      }\n      output_values(value_loc) = x.second;\n      ++value_loc;\n    }\n  }\n  Tensor* dense_shape;\n  if (is_1d) {\n    TF_RETURN_IF_ERROR(\n        context->allocate_output(2, TensorShape({1}), &dense_shape));\n    dense_shape->flat<int64>().data()[0] = num_values;\n  } else {\n    TF_RETURN_IF_ERROR(\n        context->allocate_output(2, TensorShape({2}), &dense_shape));\n    dense_shape->flat<int64>().data()[0] = num_batches;\n    dense_shape->flat<int64>().data()[1] = num_values;\n  }\n\n  return Status::OK();\n}\n\nint GetOutputSize(int max_seen, int max_length, int min_length) {\n  return max_length > 0 ? max_length : std::max((max_seen + 1), min_length);\n}\n\n}  // namespace\n\ntemplate <class T, class W>\nclass DenseCount : public OpKernel {\n public:\n  explicit DenseCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n\n    T max_value = 0;\n\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n\n private:\n  int maxlength_;\n  int minlength_;\n  bool binary_output_;\n};\n\ntemplate <class T, class W>\nclass SparseCount : public OpKernel {\n public:\n  explicit SparseCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape.flat<int64>()(0);\n    int num_values = values.NumElements();\n\n    const auto indices_values = indices.matrix<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n\n private:\n  int maxlength_;\n  int minlength_;\n  bool binary_output_;\n  bool validate_;\n};\n\ntemplate <class T, class W>\nclass RaggedCount : public OpKernel {\n public:\n  explicit RaggedCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& splits = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& weights = context->input(2);\n    bool use_weights = weights.NumElements() > 0;\n    bool is_1d = false;\n\n    const auto splits_values = splits.flat<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int num_batches = splits.NumElements() - 1;\n    int num_values = values.NumElements();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n    T max_value = 0;\n    int batch_idx = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits_values(batch_idx)) {\n        batch_idx++;\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch_idx - 1][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch_idx - 1][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch_idx - 1][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n\n private:\n  int maxlength_;\n  int minlength_;\n  bool binary_output_;\n  bool validate_;\n};\n\n#define REGISTER_W(W_TYPE) \\\n  REGISTER(int32, W_TYPE)  \\\n  REGISTER(int64, W_TYPE)\n\n#define REGISTER(I_TYPE, W_TYPE)                                     \\\n                                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseCountSparseOutput\")             \\\n                              .TypeConstraint<I_TYPE>(\"T\")           \\\n                              .TypeConstraint<W_TYPE>(\"output_type\") \\\n                              .Device(DEVICE_CPU),                   \\\n                          DenseCount<I_TYPE, W_TYPE>)                \\\n                                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseCountSparseOutput\")            \\\n                              .TypeConstraint<I_TYPE>(\"T\")           \\\n                              .TypeConstraint<W_TYPE>(\"output_type\") \\\n                              .Device(DEVICE_CPU),                   \\\n                          SparseCount<I_TYPE, W_TYPE>)               \\\n                                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"RaggedCountSparseOutput\")            \\\n                              .TypeConstraint<I_TYPE>(\"T\")           \\\n                              .TypeConstraint<W_TYPE>(\"output_type\") \\\n                              .Device(DEVICE_CPU),                   \\\n                          RaggedCount<I_TYPE, W_TYPE>)\n\nTF_CALL_INTEGRAL_TYPES(REGISTER_W);\nTF_CALL_float(REGISTER_W);\nTF_CALL_double(REGISTER_W);\n\n#undef REGISTER_W\n#undef REGISTER\n\n}  // namespace tensorflow\n", "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# maxlengthations under the License.\n# ==============================================================================\n\"\"\"Tests for bincount ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.ops import bincount_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import test\n\n\nclass TestSparseCount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 6]\n      }, {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 2],\n          \"expected_shape\": [2, 7]\n      }, {\n          \"testcase_name\": \"_minlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 9]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 8]\n      }, {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 6],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 7],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 9],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 8],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [2, 1, 0.5, 9, 3],\n          \"expected_shape\": [2, 6],\n          \"weights\": [[0.5, 1, 2], [3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [2, 1, 0.5, 3, 9],\n          \"expected_shape\": [2, 7],\n          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 9],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 8],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3]],\n          \"expected_values\": [2, 1, 1],\n          \"expected_shape\": [4]\n      }, {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3], [4], [5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None\n      })\n  def test_dense_input(self,\n                       x,\n                       expected_indices,\n                       expected_values,\n                       expected_shape,\n                       minlength=None,\n                       maxlength=None,\n                       binary_output=False,\n                       weights=None,\n                       axis=-1):\n    y = bincount_ops.sparse_bincount(\n        x,\n        weights=weights,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\":\n              \"_no_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 6],\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 6],\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 6],\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [3]],\n          \"expected_values\": [2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\":\n              \"_all_axes\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[1], [3], [4], [5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\":\n              None,\n      },\n  )\n  def test_sparse_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_sparse = sparse_ops.from_dense(x)\n    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_sparse,\n        weights=w_sparse,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 6],\n      },\n      {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 7],\n      },\n      {\n          \"testcase_name\": \"_minlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 9],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 6],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 7],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 9],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"binary_output\": True,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 6],\n          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 7],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 9],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 8],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": [3, 0, 1, 1],\n          \"expected_indices\": [[0], [1], [3]],\n          \"expected_values\": [1, 2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[0], [1], [3], [4], [5]],\n          \"expected_values\": [2, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None,\n      },\n  )\n  def test_ragged_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_ragged = ragged_factory_ops.constant(x)\n    w = ragged_factory_ops.constant(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_ragged,\n        weights=w,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n\nclass TestDenseBincount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n    weight_vals = np.random.random((n_elems,))\n    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,\n                                                [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(\n            sparse_inp, sparse_weights, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_binary(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_count(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n                                    dtype)\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 2, 1]]\n    # pyformat: enable\n    self.assertAllEqual(expected_output,\n                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_binary(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 1]]\n    # pyformat: enable\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_with_weights(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],\n                                           [.2, .5, .6, .3]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.2, .3, 0, .1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.5, 0, 0, 0, .9, .2]]\n    # pyformat: enable\n    self.assertAllClose(\n        expected_output,\n        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(\n                arr=x, weights=weights, minlength=size, axis=-1)))\n\n\nclass TestSparseCountFailureModes(test.TestCase):\n\n  def test_dense_input_sparse_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_ragged_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_wrong_shape_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = np.array([[3, 2], [5, 4], [4, 3]])\n    # Note: Eager mode and graph mode throw different errors here. Graph mode\n    # will fail with a ValueError from the shape checking logic, while Eager\n    # will fail with an InvalidArgumentError from the kernel itself.\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  \"must have the same shape\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n    else:\n      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_dense_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_ragged_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same indices\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_too_many_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Incompatible shapes\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_shape_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],\n                 dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same dense shape\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_dense_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_sparse_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_different_shape_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same row splits\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include \"absl/container/flat_hash_map.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/register_types.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/types.h\"\n\nnamespace tensorflow {\n\ntemplate <class T>\nusing BatchedMap = std::vector<absl::flat_hash_map<int64, T>>;\n\nnamespace {\n// TODO(momernick): Extend this function to work with outputs of rank > 2.\ntemplate <class T>\nStatus OutputSparse(const BatchedMap<T>& per_batch_counts, int num_values,\n                    bool is_1d, OpKernelContext* context) {\n  int total_values = 0;\n  int num_batches = per_batch_counts.size();\n  for (const auto& per_batch_count : per_batch_counts) {\n    total_values += per_batch_count.size();\n  }\n\n  Tensor* indices;\n  int inner_dim = is_1d ? 1 : 2;\n  TF_RETURN_IF_ERROR(context->allocate_output(\n      0, TensorShape({total_values, inner_dim}), &indices));\n\n  Tensor* values;\n  TF_RETURN_IF_ERROR(\n      context->allocate_output(1, TensorShape({total_values}), &values));\n\n  auto output_indices = indices->matrix<int64>();\n  auto output_values = values->flat<T>();\n  int64 value_loc = 0;\n  for (int b = 0; b < num_batches; ++b) {\n    const auto& per_batch_count = per_batch_counts[b];\n    std::vector<std::pair<int, T>> pairs(per_batch_count.begin(),\n                                         per_batch_count.end());\n    std::sort(pairs.begin(), pairs.end());\n    for (const auto& x : pairs) {\n      if (is_1d) {\n        output_indices(value_loc, 0) = x.first;\n      } else {\n        output_indices(value_loc, 0) = b;\n        output_indices(value_loc, 1) = x.first;\n      }\n      output_values(value_loc) = x.second;\n      ++value_loc;\n    }\n  }\n  Tensor* dense_shape;\n  if (is_1d) {\n    TF_RETURN_IF_ERROR(\n        context->allocate_output(2, TensorShape({1}), &dense_shape));\n    dense_shape->flat<int64>().data()[0] = num_values;\n  } else {\n    TF_RETURN_IF_ERROR(\n        context->allocate_output(2, TensorShape({2}), &dense_shape));\n    dense_shape->flat<int64>().data()[0] = num_batches;\n    dense_shape->flat<int64>().data()[1] = num_values;\n  }\n\n  return Status::OK();\n}\n\nint GetOutputSize(int max_seen, int max_length, int min_length) {\n  return max_length > 0 ? max_length : std::max((max_seen + 1), min_length);\n}\n\n}  // namespace\n\ntemplate <class T, class W>\nclass DenseCount : public OpKernel {\n public:\n  explicit DenseCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n\n    T max_value = 0;\n\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n\n private:\n  int maxlength_;\n  int minlength_;\n  bool binary_output_;\n};\n\ntemplate <class T, class W>\nclass SparseCount : public OpKernel {\n public:\n  explicit SparseCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape.flat<int64>()(0);\n    int num_values = values.NumElements();\n\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", num_values,\n                    \" values, indices shape: \", indices.shape().DebugString()));\n\n    const auto indices_values = indices.matrix<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n\n    T max_value = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n\n private:\n  int maxlength_;\n  int minlength_;\n  bool binary_output_;\n  bool validate_;\n};\n\ntemplate <class T, class W>\nclass RaggedCount : public OpKernel {\n public:\n  explicit RaggedCount(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"minlength\", &minlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"maxlength\", &maxlength_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"binary_output\", &binary_output_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    const Tensor& splits = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& weights = context->input(2);\n    bool use_weights = weights.NumElements() > 0;\n    bool is_1d = false;\n\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n\n    const auto splits_values = splits.flat<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int num_batches = splits.NumElements() - 1;\n    int num_values = values.NumElements();\n\n    OP_REQUIRES(\n        context, num_batches > 0,\n        errors::InvalidArgument(\n            \"Must provide at least 2 elements for the splits argument\"));\n    OP_REQUIRES(context, splits_values(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits_values(0)));\n    OP_REQUIRES(context, splits_values(num_batches) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits_values(num_batches), \" instead of \", num_values));\n\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n    T max_value = 0;\n    int batch_idx = 0;\n\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits_values(batch_idx)) {\n        batch_idx++;\n      }\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch_idx - 1][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch_idx - 1][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch_idx - 1][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }\n\n private:\n  int maxlength_;\n  int minlength_;\n  bool binary_output_;\n  bool validate_;\n};\n\n#define REGISTER_W(W_TYPE) \\\n  REGISTER(int32, W_TYPE)  \\\n  REGISTER(int64, W_TYPE)\n\n#define REGISTER(I_TYPE, W_TYPE)                                     \\\n                                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"DenseCountSparseOutput\")             \\\n                              .TypeConstraint<I_TYPE>(\"T\")           \\\n                              .TypeConstraint<W_TYPE>(\"output_type\") \\\n                              .Device(DEVICE_CPU),                   \\\n                          DenseCount<I_TYPE, W_TYPE>)                \\\n                                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"SparseCountSparseOutput\")            \\\n                              .TypeConstraint<I_TYPE>(\"T\")           \\\n                              .TypeConstraint<W_TYPE>(\"output_type\") \\\n                              .Device(DEVICE_CPU),                   \\\n                          SparseCount<I_TYPE, W_TYPE>)               \\\n                                                                     \\\n  REGISTER_KERNEL_BUILDER(Name(\"RaggedCountSparseOutput\")            \\\n                              .TypeConstraint<I_TYPE>(\"T\")           \\\n                              .TypeConstraint<W_TYPE>(\"output_type\") \\\n                              .Device(DEVICE_CPU),                   \\\n                          RaggedCount<I_TYPE, W_TYPE>)\n\nTF_CALL_INTEGRAL_TYPES(REGISTER_W);\nTF_CALL_float(REGISTER_W);\nTF_CALL_double(REGISTER_W);\n\n#undef REGISTER_W\n#undef REGISTER\n\n}  // namespace tensorflow\n", "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# maxlengthations under the License.\n# ==============================================================================\n\"\"\"Tests for bincount ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.eager import context\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import ops\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import bincount_ops\nfrom tensorflow.python.ops import gen_count_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.ops.ragged import ragged_factory_ops\nfrom tensorflow.python.ops.ragged import ragged_tensor\nfrom tensorflow.python.platform import test\n\n\nclass TestSparseCount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 6]\n      }, {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 2],\n          \"expected_shape\": [2, 7]\n      }, {\n          \"testcase_name\": \"_minlength\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 9]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [2, 8]\n      }, {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 6],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 7],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 9],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [2, 8],\n          \"binary_output\": True,\n      }, {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 4], [1, 5]],\n          \"expected_values\": [2, 1, 0.5, 9, 3],\n          \"expected_shape\": [2, 6],\n          \"weights\": [[0.5, 1, 2], [3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"maxlength\": 7,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [1, 0], [1, 4]],\n          \"expected_values\": [2, 1, 0.5, 3, 9],\n          \"expected_shape\": [2, 7],\n          \"weights\": [[0.5, 1, 2, 11], [7, 3, 4, 5]]\n      }, {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 9,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 9],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": np.array([[3, 2, 1, 7], [7, 0, 4, 4]], dtype=np.int32),\n          \"minlength\": 3,\n          \"expected_indices\": [[0, 1], [0, 2], [0, 3], [0, 7], [1, 0], [1, 4],\n                               [1, 7]],\n          \"expected_values\": [2, 1, 0.5, 3, 5, 13, 4],\n          \"expected_shape\": [2, 8],\n          \"weights\": [[0.5, 1, 2, 3], [4, 5, 6, 7]]\n      }, {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 2, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3]],\n          \"expected_values\": [2, 1, 1],\n          \"expected_shape\": [4]\n      }, {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32),\n          \"expected_indices\": [[1], [2], [3], [4], [5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None\n      })\n  def test_dense_input(self,\n                       x,\n                       expected_indices,\n                       expected_values,\n                       expected_shape,\n                       minlength=None,\n                       maxlength=None,\n                       binary_output=False,\n                       weights=None,\n                       axis=-1):\n    y = bincount_ops.sparse_bincount(\n        x,\n        weights=weights,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\":\n              \"_no_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 6],\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 2, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 6],\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_binary\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"binary_output\":\n              True,\n      },\n      {\n          \"testcase_name\":\n              \"_no_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 6],\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 0, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_maxlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 7, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 7, 10],\n          \"expected_shape\": [3, 7],\n          \"maxlength\":\n              7,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [0, 0, 14, 0], [10, 0, 3.5, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 9],\n          \"minlength\":\n              9,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\":\n              \"_minlength_larger_values_weights\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [7, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[0, 1], [0, 3], [1, 7], [2, 4], [2, 5]],\n          \"expected_values\": [2, 6, 14, 6.5, 10],\n          \"expected_shape\": [3, 8],\n          \"minlength\":\n              3,\n          \"weights\":\n              np.array([[6, 0, 2, 0], [14, 0, 0, 0], [10, 0, 3, 3.5]]),\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": np.array([3, 0, 1, 1], dtype=np.int32),\n          \"expected_indices\": [[1], [3]],\n          \"expected_values\": [2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\":\n              \"_all_axes\",\n          \"x\":\n              np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]],\n                       dtype=np.int32),\n          \"expected_indices\": [[1], [3], [4], [5]],\n          \"expected_values\": [1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\":\n              None,\n      },\n  )\n  def test_sparse_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_sparse = sparse_ops.from_dense(x)\n    w_sparse = sparse_ops.from_dense(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_sparse,\n        weights=w_sparse,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n  @parameterized.named_parameters(\n      {\n          \"testcase_name\": \"_no_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 6],\n      },\n      {\n          \"testcase_name\": \"_maxlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 7],\n      },\n      {\n          \"testcase_name\": \"_minlength\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 9],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 2, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 6],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_maxlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 7],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 9],\n          \"binary_output\": True,\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_binary\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"binary_output\": True,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [1, 1, 1, 1, 1, 1, 1],\n          \"expected_shape\": [5, 8],\n      },\n      {\n          \"testcase_name\": \"_no_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 6],\n          \"weights\": [[], [], [6, 0.5, 2], [], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_maxlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"maxlength\": 7,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [4, 0], [4, 4], [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 0.25, 8, 10],\n          \"expected_shape\": [5, 7],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 9,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 9],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_minlength_larger_values_weights\",\n          \"x\": [[], [], [3, 0, 1], [7], [5, 0, 4, 4]],\n          \"minlength\": 3,\n          \"expected_indices\": [[2, 0], [2, 1], [2, 3], [3, 7], [4, 0], [4, 4],\n                               [4, 5]],\n          \"expected_values\": [0.5, 2, 6, 14, 0.25, 8, 10],\n          \"expected_shape\": [5, 8],\n          \"weights\": [[], [], [6, 0.5, 2], [14], [10, 0.25, 5, 3]],\n      },\n      {\n          \"testcase_name\": \"_1d\",\n          \"x\": [3, 0, 1, 1],\n          \"expected_indices\": [[0], [1], [3]],\n          \"expected_values\": [1, 2, 1],\n          \"expected_shape\": [4],\n      },\n      {\n          \"testcase_name\": \"_all_axes\",\n          \"x\": [[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n          \"expected_indices\": [[0], [1], [3], [4], [5]],\n          \"expected_values\": [2, 1, 1, 2, 1],\n          \"expected_shape\": [6],\n          \"axis\": None,\n      },\n  )\n  def test_ragged_input(self,\n                        x,\n                        expected_indices,\n                        expected_values,\n                        expected_shape,\n                        maxlength=None,\n                        minlength=None,\n                        binary_output=False,\n                        weights=None,\n                        axis=-1):\n    x_ragged = ragged_factory_ops.constant(x)\n    w = ragged_factory_ops.constant(weights) if weights is not None else None\n    y = bincount_ops.sparse_bincount(\n        x_ragged,\n        weights=w,\n        minlength=minlength,\n        maxlength=maxlength,\n        binary_output=binary_output,\n        axis=axis)\n    self.assertAllEqual(expected_indices, y.indices)\n    self.assertAllEqual(expected_values, y.values)\n    self.assertAllEqual(expected_shape, y.dense_shape)\n\n\nclass TestDenseBincount(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(sparse_inp, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_count_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 1000\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n    weight_vals = np.random.random((n_elems,))\n    sparse_weights = sparse_tensor.SparseTensor(inp_indices, weight_vals,\n                                                [num_rows, 1])\n\n    np_out = np.bincount(inp_vals, minlength=size, weights=weight_vals)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(\n            sparse_inp, sparse_weights, axis=0)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_all_binary(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    size = 10\n    n_elems = 4096\n    inp_indices = np.random.randint(0, num_rows, (n_elems, 1))\n    inp_indices = np.concatenate([inp_indices, np.zeros((n_elems, 1))], axis=1)\n    inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)\n    sparse_inp = sparse_tensor.SparseTensor(inp_indices, inp_vals,\n                                            [num_rows, 1])\n\n    np_out = np.ones((size,))\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(sparse_inp, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_count(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out, self.evaluate(bincount_ops.bincount(arr=inp_sparse, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_sparse_input_col_reduce_binary(self, dtype):\n    num_rows = 128\n    num_cols = 27\n    size = 100\n    np.random.seed(42)\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate([\n            np.where(np.bincount(inp[j, :], minlength=size) > 0, 1, 0)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    # from_dense will filter out 0s.\n    inp = inp + 1\n    # from_dense will cause OOM in GPU.\n    with ops.device(\"/CPU:0\"):\n      inp_sparse = sparse_ops.from_dense(inp)\n      inp_sparse = sparse_tensor.SparseTensor(inp_sparse.indices,\n                                              inp_sparse.values - 1,\n                                              inp_sparse.dense_shape)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(arr=inp_sparse, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]],\n                                    dtype)\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 2, 1]]\n    # pyformat: enable\n    self.assertAllEqual(expected_output,\n                        self.evaluate(bincount_ops.bincount(arr=x, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_binary(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 1, 1]]\n    # pyformat: enable\n    self.assertAllEqual(\n        expected_output,\n        self.evaluate(\n            bincount_ops.bincount(arr=x, axis=-1, binary_output=True)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_with_weights(self, dtype):\n    x = ragged_factory_ops.constant([[], [], [3, 0, 1], [], [5, 0, 4, 4]])\n    weights = ragged_factory_ops.constant([[], [], [.1, .2, .3], [],\n                                           [.2, .5, .6, .3]])\n    # pyformat: disable\n    expected_output = [\n        [0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.2, .3, 0, .1, 0, 0],\n        [0, 0, 0, 0, 0, 0],\n        [.5, 0, 0, 0, .9, .2]]\n    # pyformat: enable\n    self.assertAllClose(\n        expected_output,\n        self.evaluate(bincount_ops.bincount(arr=x, weights=weights, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_out = np.reshape(\n        np.concatenate(\n            [np.bincount(inp[j, :], minlength=size) for j in range(num_rows)],\n            axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(bincount_ops.bincount(arr=x, minlength=size, axis=-1)))\n\n  @parameterized.parameters([{\n      \"dtype\": np.int32,\n  }, {\n      \"dtype\": np.int64,\n  }])\n  def test_ragged_input_count_np_with_weights(self, dtype):\n    np.random.seed(42)\n    num_rows = 128\n    num_cols = 27\n    size = 1000\n    inp = np.random.randint(0, size, (num_rows, num_cols), dtype=dtype)\n    np_weight = np.random.random((num_rows, num_cols))\n    np_out = np.reshape(\n        np.concatenate([\n            np.bincount(inp[j, :], weights=np_weight[j, :], minlength=size)\n            for j in range(num_rows)\n        ],\n                       axis=0), (num_rows, size))\n    x = ragged_tensor.RaggedTensor.from_tensor(inp)\n    weights = ragged_tensor.RaggedTensor.from_tensor(np_weight)\n    self.assertAllEqual(\n        np_out,\n        self.evaluate(\n            bincount_ops.bincount(\n                arr=x, weights=weights, minlength=size, axis=-1)))\n\n\nclass TestSparseCountFailureModes(test.TestCase):\n\n  def test_dense_input_sparse_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_ragged_weights_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a tf.Tensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_dense_input_wrong_shape_fails(self):\n    x = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    weights = np.array([[3, 2], [5, 4], [4, 3]])\n    # Note: Eager mode and graph mode throw different errors here. Graph mode\n    # will fail with a ValueError from the shape checking logic, while Eager\n    # will fail with an InvalidArgumentError from the kernel itself.\n    if context.executing_eagerly():\n      with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                  \"must have the same shape\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n    else:\n      with self.assertRaisesRegex(ValueError, \"both shapes must be equal\"):\n        self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_dense_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_ragged_weights_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [14], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(ValueError, \"must be a SparseTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 0, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same indices\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_too_many_indices_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 1, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Incompatible shapes\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_sparse_input_wrong_shape_fails(self):\n    x = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4], [0, 0, 0, 0]],\n                 dtype=np.int32))\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same dense shape\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_dense_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = np.array([[3, 2, 1], [5, 4, 4]], dtype=np.int32)\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_sparse_weights_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = sparse_ops.from_dense(\n        np.array([[3, 0, 1, 0], [0, 0, 0, 0], [5, 0, 4, 4]], dtype=np.int32))\n    with self.assertRaisesRegex(ValueError, \"must be a RaggedTensor\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n  def test_ragged_input_different_shape_fails(self):\n    x = ragged_factory_ops.constant([[6, 1, 2], [14], [10, 1, 5, 3]])\n    weights = ragged_factory_ops.constant([[6, 0.5, 2], [], [10, 0.25, 5, 3]])\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"must have the same row splits\"):\n      self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))\n\n\n@test_util.run_all_in_graph_and_eager_modes\n@test_util.disable_tfrt\nclass RawOpsTest(test.TestCase, parameterized.TestCase):\n\n  def testSparseCountSparseOutputBadIndicesShape(self):\n    indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Input indices must be a 2-dimensional tensor\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadWeightsShape(self):\n    indices = [[0, 0], [0, 1], [1, 0], [1, 2]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testSparseCountSparseOutputBadNumberOfValues(self):\n    indices = [[0, 0], [0, 1], [1, 0]]\n    values = [1, 1, 1, 10]\n    weights = [1, 2, 4, 6]\n    dense_shape = [2, 3]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Number of values must match first dimension of indices\"):\n      self.evaluate(\n          gen_count_ops.SparseCountSparseOutput(\n              indices=indices,\n              values=values,\n              dense_shape=dense_shape,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutput(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    output_indices, output_values, output_shape = self.evaluate(\n        gen_count_ops.RaggedCountSparseOutput(\n            splits=splits, values=values, weights=weights, binary_output=False))\n    self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],\n                        output_indices)\n    self.assertAllEqual([7, 3, 5, 7, 6], output_values)\n    self.assertAllEqual([2, 11], output_shape)\n\n  def testRaggedCountSparseOutputBadWeightsShape(self):\n    splits = [0, 4, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Weights and values must have the same shape\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputEmptySplits(self):\n    splits = []\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(\n        errors.InvalidArgumentError,\n        \"Must provide at least 2 elements for the splits argument\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsStart(self):\n    splits = [1, 7]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must start with 0\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n  def testRaggedCountSparseOutputBadSplitsEnd(self):\n    splits = [0, 5]\n    values = [1, 1, 2, 1, 2, 10, 5]\n    weights = [1, 2, 3, 4, 5, 6, 7]\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                \"Splits must end with the number of values\"):\n      self.evaluate(\n          gen_count_ops.RaggedCountSparseOutput(\n              splits=splits,\n              values=values,\n              weights=weights,\n              binary_output=False))\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/count_ops.cc", "tensorflow/python/ops/bincount_ops_test.py"], "buggy_code_start_loc": [180, 27], "buggy_code_end_loc": [242, 836], "fixing_code_start_loc": [181, 28], "fixing_code_end_loc": [284, 955], "type": "CWE-787", "message": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.", "other": {"cve": {"id": "CVE-2020-15200", "sourceIdentifier": "security-advisories@github.com", "published": "2020-09-25T19:15:15.260", "lastModified": "2021-11-18T17:24:30.770", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Tensorflow before version 2.3.1, the `RaggedCountSparseOutput` implementation does not validate that the input arguments form a valid ragged tensor. In particular, there is no validation that the values in the `splits` tensor generate a valid partitioning of the `values` tensor. Thus, the code sets up conditions to cause a heap buffer overflow. A `BatchedMap` is equivalent to a vector where each element is a hashmap. However, if the first element of `splits_values` is not 0, `batch_idx` will never be 1, hence there will be no hashmap at index 0 in `per_batch_counts`. Trying to access that in the user code results in a segmentation fault. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1."}, {"lang": "es", "value": "En Tensorflow anteriores a la versi\u00f3n 2.3.1, la implementaci\u00f3n de \"RaggedCountSparseOutput\" no comprueba que los argumentos de entrada formen un tensor irregular v\u00e1lido.&#xa0;En particular, no existe comprobaci\u00f3n de que los valores en el tensor \"splits\" generen una partici\u00f3n v\u00e1lida del tensor \"values\".&#xa0;Por lo tanto, el c\u00f3digo establece las condiciones para causar un desbordamiento del b\u00fafer de la pila.&#xa0;Un \"BatchedMap\" es equivalente a un vector donde cada elemento es un mapa de hash.&#xa0;Sin embargo, si el primer elemento de \"splits_values\" no es 0, \"batch_idx\" nunca ser\u00e1 1, por lo que no habr\u00e1 un hashmap en el \u00edndice 0 en \"per_batch_counts\".&#xa0;Intentar acceder a eso en el c\u00f3digo de usuario resulta en un fallo de segmentaci\u00f3n.&#xa0;El problema es parcheado en el commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 y es publicado en TensorFlow versi\u00f3n 2.3.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}, {"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.3.0:*:*:*:-:*:*:*", "matchCriteriaId": "D0A7B69E-9388-48F0-B744-49453EBAF5D5"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/3cbb917b4714766030b28eba9fb41bb97ce9ee02", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/releases/tag/v2.3.1", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-x7rp-74x2-mjf3", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/3cbb917b4714766030b28eba9fb41bb97ce9ee02"}}