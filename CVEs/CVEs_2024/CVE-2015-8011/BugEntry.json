{"buggy_code": ["/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n\ninline static int\nlldpd_af_to_lldp_proto(int af)\n{\n\tswitch (af) {\n\tcase LLDPD_AF_IPV4:\n\t\treturn LLDP_MGMT_ADDR_IP4;\n\tcase LLDPD_AF_IPV6:\n\t\treturn LLDP_MGMT_ADDR_IP6;\n\tdefault:\n\t\treturn LLDP_MGMT_ADDR_NONE;\n\t}\n}\n\ninline static int\nlldpd_af_from_lldp_proto(int proto)\n{\n\tswitch (proto) {\n\tcase LLDP_MGMT_ADDR_IP4:\n\t\treturn LLDPD_AF_IPV4;\n\tcase LLDP_MGMT_ADDR_IP6:\n\t\treturn LLDPD_AF_IPV6;\n\tdefault:\n\t\treturn LLDPD_AF_UNSPEC;\n\t}\n}\n\nstatic int _lldp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware,\n    u_int8_t c_id_subtype,\n    char *c_id,\n    int c_id_len,\n    u_int8_t p_id_subtype,\n    char *p_id,\n    int p_id_len,\n    int shutdown)\n{\n\tstruct lldpd_port *port;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_frame *frame;\n\tint length;\n\tu_int8_t *packet, *pos, *tlv;\n\tstruct lldpd_mgmt *mgmt;\n\tint proto;\n\n\tu_int8_t mcastaddr[] = LLDP_MULTICAST_ADDR;\n#ifdef ENABLE_DOT1\n\tconst u_int8_t dot1[] = LLDP_TLV_ORG_DOT1;\n\tstruct lldpd_vlan *vlan;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi;\n#endif\n#ifdef ENABLE_DOT3\n\tconst u_int8_t dot3[] = LLDP_TLV_ORG_DOT3;\n#endif\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tconst u_int8_t med[] = LLDP_TLV_ORG_MED;\n#endif\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom;\n#endif\n\tport = &hardware->h_lport;\n\tchassis = port->p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* LLDP multicast address */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC address */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* LLDP frame */\n\t      POKE_UINT16(ETHERTYPE_LLDP)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_CHASSIS_ID) &&\n\t      POKE_UINT8(c_id_subtype) &&\n\t      POKE_BYTES(c_id, c_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_PORT_ID) &&\n\t      POKE_UINT8(p_id_subtype) &&\n\t      POKE_BYTES(p_id, p_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Time to live */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_TTL) &&\n\t      POKE_UINT16(shutdown?0:chassis->c_ttl) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (shutdown)\n\t\tgoto end;\n\n\t/* System name */\n\tif (chassis->c_name && *chassis->c_name != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_NAME) &&\n\t\t\t    POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System description (skip it if empty) */\n\tif (chassis->c_descr && *chassis->c_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_DESCR) &&\n\t\t\t    POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System capabilities */\n\tif (global->g_config.c_cap_advertise && chassis->c_cap_available) {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tassert(proto != LLDP_MGMT_ADDR_NONE);\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {\n\t\t\tif (!(\n\t\t\t\t  /* We don't know the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_UNKNOWN) &&\n\t\t\t\t  POKE_UINT32(0)))\n\t\t\t\tgoto toobig;\n\t\t} else {\n\t\t\tif (!(\n\t\t\t\t  /* We have the index of the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_IFINDEX) &&\n\t\t\t\t  POKE_UINT32(mgmt->m_iface)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(\n\t\t\t  /* We don't provide an OID for management */\n\t\t\t  POKE_UINT8(0) &&\n\t\t\t  POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port description */\n\tif (port->p_descr && *port->p_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_PORT_DESCR) &&\n\t\t\t    POKE_BYTES(port->p_descr, strlen(port->p_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n#ifdef ENABLE_DOT1\n\t/* Port VLAN ID */\n\tif(port->p_pvid != 0) {\n\t\tif (!(\n\t\t    POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t    POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t    POKE_UINT8(LLDP_TLV_DOT1_PVID) &&\n\t\t    POKE_UINT16(port->p_pvid) &&\n\t\t    POKE_END_LLDP_TLV)) {\n\t\t    goto toobig;\n\t\t}\n\t}\n\t/* Port and Protocol VLAN IDs */\n\tTAILQ_FOREACH(ppvid, &port->p_ppvids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PPVID) &&\n\t\t      POKE_UINT8(ppvid->p_cap_status) &&\n\t\t      POKE_UINT16(ppvid->p_ppvid) &&\n\t\t      POKE_END_LLDP_TLV)) {\n\t\t\tgoto toobig;\n\t\t}\n\t}\n\t/* VLANs */\n\tTAILQ_FOREACH(vlan, &port->p_vlans, v_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_VLANNAME) &&\n\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t      POKE_UINT8(strlen(vlan->v_name)) &&\n\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Protocol Identities */\n\tTAILQ_FOREACH(pi, &port->p_pids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PI) &&\n\t\t      POKE_UINT8(pi->p_pi_len) &&\n\t\t      POKE_BYTES(pi->p_pi, pi->p_pi_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_DOT3\n\t/* Aggregation status */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_LA) &&\n\t      /* Bit 0 = capability ; Bit 1 = status */\n\t      POKE_UINT8((port->p_aggregid) ? 3:1) &&\n\t      POKE_UINT32(port->p_aggregid) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MAC/PHY */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_MAC) &&\n\t      POKE_UINT8(port->p_macphy.autoneg_support |\n\t\t\t (port->p_macphy.autoneg_enabled << 1)) &&\n\t      POKE_UINT16(port->p_macphy.autoneg_advertised) &&\n\t      POKE_UINT16(port->p_macphy.mau_type) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MFS */\n\tif (port->p_mfs) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_MFS) &&\n\t\t      POKE_UINT16(port->p_mfs) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Power */\n\tif (port->p_power.devicetype) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_POWER) &&\n\t\t      POKE_UINT8((\n\t\t\t\t  (((2 - port->p_power.devicetype)    %(1<< 1))<<0) |\n\t\t\t\t  (( port->p_power.supported          %(1<< 1))<<1) |\n\t\t\t\t  (( port->p_power.enabled            %(1<< 1))<<2) |\n\t\t\t\t  (( port->p_power.paircontrol        %(1<< 1))<<3))) &&\n\t\t      POKE_UINT8(port->p_power.pairs) &&\n\t\t      POKE_UINT8(port->p_power.class)))\n\t\t\tgoto toobig;\n\t\t/* 802.3at */\n\t\tif (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) {\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t\t  (((port->p_power.powertype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_8023AT_TYPE1)?1:0) << 7) |\n\t\t\t\t\t   (((port->p_power.devicetype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_PSE)?0:1) << 6) |\n\t\t\t\t\t   ((port->p_power.source   %(1<< 2))<<4) |\n\t\t\t\t\t   ((port->p_power.priority %(1<< 2))<<0))) &&\n\t\t\t      POKE_UINT16(port->p_power.requested) &&\n\t\t\t      POKE_UINT16(port->p_power.allocated)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_LLDPMED\n\tif (port->p_med_cap_enabled) {\n\t\t/* LLDP-MED cap */\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t      POKE_UINT8(LLDP_TLV_MED_CAP) &&\n\t\t      POKE_UINT16(chassis->c_med_cap_available) &&\n\t\t      POKE_UINT8(chassis->c_med_type) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\n\t\t/* LLDP-MED inventory */\n#define LLDP_INVENTORY(value, subtype)\t\t\t\t\t\\\n\t\tif (value) {\t\t\t\t\t\t\\\n\t\t    if (!(\t\t\t\t\t\t\\\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\t\t\\\n\t\t\t  POKE_BYTES(med, sizeof(med)) &&\t\t\\\n\t\t\t  POKE_UINT8(subtype) &&\t\t\t\\\n\t\t\t  POKE_BYTES(value,\t\t\t\t\\\n\t\t\t\t(strlen(value)>32)?32:strlen(value)) &&\t\\\n\t\t\t  POKE_END_LLDP_TLV))\t\t\t\t\\\n\t\t\t    goto toobig;\t\t\t\t\\\n\t\t}\n\n\t\tif (port->p_med_cap_enabled & LLDP_MED_CAP_IV) {\n\t\t\tLLDP_INVENTORY(chassis->c_med_hw,\n\t\t\t    LLDP_TLV_MED_IV_HW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_fw,\n\t\t\t    LLDP_TLV_MED_IV_FW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sw,\n\t\t\t    LLDP_TLV_MED_IV_SW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sn,\n\t\t\t    LLDP_TLV_MED_IV_SN);\n\t\t\tLLDP_INVENTORY(chassis->c_med_manuf,\n\t\t\t    LLDP_TLV_MED_IV_MANUF);\n\t\t\tLLDP_INVENTORY(chassis->c_med_model,\n\t\t\t    LLDP_TLV_MED_IV_MODEL);\n\t\t\tLLDP_INVENTORY(chassis->c_med_asset,\n\t\t\t    LLDP_TLV_MED_IV_ASSET);\n\t\t}\n\n\t\t/* LLDP-MED location */\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++) {\n\t\t\tif (port->p_med_location[i].format == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_LOCATION) &&\n\t\t\t\t      POKE_UINT8(port->p_med_location[i].format) &&\n\t\t\t\t      POKE_BYTES(port->p_med_location[i].data,\n\t\t\t\t\t  port->p_med_location[i].data_len) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED network policy */\n\t\tfor (i = 0; i < LLDP_MED_APPTYPE_LAST; i++) {\n\t\t\tif (port->p_med_policy[i].type == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_POLICY) &&\n\t\t\t\t      POKE_UINT32((\n\t\t\t\t\t((port->p_med_policy[i].type     %(1<< 8))<<24) |\n\t\t\t\t\t((port->p_med_policy[i].unknown  %(1<< 1))<<23) |\n\t\t\t\t\t((port->p_med_policy[i].tagged   %(1<< 1))<<22) |\n\t\t\t\t      /*((0                              %(1<< 1))<<21) |*/\n\t\t\t\t\t((port->p_med_policy[i].vid      %(1<<12))<< 9) |\n\t\t\t\t\t((port->p_med_policy[i].priority %(1<< 3))<< 6) |\n\t\t\t\t\t((port->p_med_policy[i].dscp     %(1<< 6))<< 0) )) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED POE-MDI */\n\t\tif ((port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PSE) ||\n\t\t    (port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PD)) {\n\t\t\tint devicetype = 0, source = 0;\n\t\t\tif (!(\n\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t      POKE_UINT8(LLDP_TLV_MED_MDI)))\n\t\t\t\tgoto toobig;\n\t\t\tswitch (port->p_med_power.devicetype) {\n\t\t\tcase LLDP_MED_POW_TYPE_PSE:\n\t\t\t\tdevicetype = 0;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PRIMARY: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BACKUP: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_RESERVED: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LLDP_MED_POW_TYPE_PD:\n\t\t\t\tdevicetype = 1;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PSE: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_LOCAL: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BOTH: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t((devicetype                   %(1<< 2))<<6) |\n\t\t\t\t((source                       %(1<< 2))<<4) |\n\t\t\t\t((port->p_med_power.priority   %(1<< 4))<<0) )) &&\n\t\t\t      POKE_UINT16(port->p_med_power.val) &&\n\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\tgoto toobig;\n\t\t}\n\t}\n#endif\n\n#ifdef ENABLE_CUSTOM\n\tTAILQ_FOREACH(custom, &port->p_custom_list, next) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(custom->oui, sizeof(custom->oui)) &&\n\t\t      POKE_UINT8(custom->subtype) &&\n\t\t      POKE_BYTES(custom->oui_info, custom->oui_info_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\nend:\n\t/* END */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_END) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, pos - packet) == -1) {\n\t\tlog_warn(\"lldp\", \"unable to send packet on real device for %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\t/* We assume that LLDP frame is the reference */\n\tif (!shutdown && (frame = (struct lldpd_frame*)malloc(\n\t\t\tsizeof(int) + pos - packet)) != NULL) {\n\t\tframe->size = pos - packet;\n\t\tmemcpy(&frame->frame, packet, frame->size);\n\t\tif ((hardware->h_lport.p_lastframe == NULL) ||\n\t\t    (hardware->h_lport.p_lastframe->size != frame->size) ||\n\t\t    (memcmp(hardware->h_lport.p_lastframe->frame, frame->frame,\n\t\t\tframe->size) != 0)) {\n\t\t\tfree(hardware->h_lport.p_lastframe);\n\t\t\thardware->h_lport.p_lastframe = frame;\n\t\t\thardware->h_lport.p_lastchange = time(NULL);\n\t\t} else free(frame);\n\t}\n\n\tfree(packet);\n\treturn 0;\n\ntoobig:\n\tfree(packet);\n\treturn E2BIG;\n}\n\n/* Send a shutdown LLDPDU. */\nint\nlldp_send_shutdown(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\tif (hardware->h_lchassis_previous_id == NULL ||\n\t    hardware->h_lport_previous_id == NULL)\n\t\treturn 0;\n\treturn _lldp_send(global, hardware,\n\t    hardware->h_lchassis_previous_id_subtype,\n\t    hardware->h_lchassis_previous_id,\n\t    hardware->h_lchassis_previous_id_len,\n\t    hardware->h_lport_previous_id_subtype,\n\t    hardware->h_lport_previous_id,\n\t    hardware->h_lport_previous_id_len,\n\t    1);\n}\n\nint\nlldp_send(struct lldpd *global,\n\t  struct lldpd_hardware *hardware)\n{\n\tstruct lldpd_port *port = &hardware->h_lport;\n\tstruct lldpd_chassis *chassis = port->p_chassis;\n\tint ret;\n\n\t/* Check if we have a change. */\n\tif (hardware->h_lchassis_previous_id != NULL &&\n\t    hardware->h_lport_previous_id != NULL &&\n\t    (hardware->h_lchassis_previous_id_subtype != chassis->c_id_subtype ||\n\t\thardware->h_lchassis_previous_id_len != chassis->c_id_len ||\n\t\thardware->h_lport_previous_id_subtype != port->p_id_subtype ||\n\t\thardware->h_lport_previous_id_len != port->p_id_len ||\n\t\tmemcmp(hardware->h_lchassis_previous_id,\n\t\t    chassis->c_id, chassis->c_id_len) ||\n\t\tmemcmp(hardware->h_lport_previous_id,\n\t\t    port->p_id, port->p_id_len))) {\n\t\tlog_info(\"lldp\", \"MSAP has changed for port %s, sending a shutdown LLDPDU\",\n\t\t    hardware->h_ifname);\n\t\tif ((ret = lldp_send_shutdown(global, hardware)) != 0)\n\t\t\treturn ret;\n\t}\n\n\tlog_debug(\"lldp\", \"send LLDP PDU to %s\",\n\t    hardware->h_ifname);\n\n\tif ((ret = _lldp_send(global, hardware,\n\t\t    chassis->c_id_subtype,\n\t\t    chassis->c_id,\n\t\t    chassis->c_id_len,\n\t\t    port->p_id_subtype,\n\t\t    port->p_id,\n\t\t    port->p_id_len,\n\t\t    0)) != 0)\n\t\treturn ret;\n\n\t/* Record current chassis and port ID */\n\tfree(hardware->h_lchassis_previous_id);\n\thardware->h_lchassis_previous_id_subtype = chassis->c_id_subtype;\n\thardware->h_lchassis_previous_id_len = chassis->c_id_len;\n\tif ((hardware->h_lchassis_previous_id = malloc(chassis->c_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lchassis_previous_id, chassis->c_id,\n\t\t    chassis->c_id_len);\n\tfree(hardware->h_lport_previous_id);\n\thardware->h_lport_previous_id_subtype = port->p_id_subtype;\n\thardware->h_lport_previous_id_len = port->p_id_len;\n\tif ((hardware->h_lport_previous_id = malloc(port->p_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lport_previous_id, port->p_id,\n\t\t    port->p_id_len);\n\n\treturn 0;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_size < (x)) {\t\t\t   \\\n\t\t\tlog_warnx(\"lldp\", name \" TLV too short received on %s\",\t\\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n\nint\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\"lldp\", \"receive LLDP PDU on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\"lldp\", \"non LLDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\"lldp\", \"tlv header too short received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"frame too short for tlv received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\"lldp\", \"lldp end received with size not null on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"lldp\", \"extra data after lldp end on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \"Port Id\");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for id tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \"TTL\");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\"lldp\", \"empty tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for string tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\t\t\t\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(4, \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"PVID\");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"PPVID\");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc ppvid \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"PI\");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc PI \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc pid name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"MAC/PHY\");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"Link aggregation\");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"MFS\");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"Power\");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \"LLDP-MED policy\");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown policy field %d \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"LLDP-MED Location\");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown location type \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t    \"for LLDP-MED location for \"\n\t\t\t\t\t\t    \"frame received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate \"\n\t\t\t\t\t\t\t    \"memory for LLDP-MED \"\n\t\t\t\t\t\t\t    \"inventory for frame \"\n\t\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t    \"unable to allocate memory for custom TLV\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t\t    \"unable to allocate memory for custom TLV data\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"BUG: already past TLV!\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n"], "fixing_code": ["/* -*- mode: c; c-file-style: \"openbsd\" -*- */\n/*\n * Copyright (c) 2008 Vincent Bernat <bernat@luffy.cx>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"lldpd.h\"\n#include \"frame.h\"\n\n#include <unistd.h>\n#include <errno.h>\n#include <assert.h>\n#include <time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n\ninline static int\nlldpd_af_to_lldp_proto(int af)\n{\n\tswitch (af) {\n\tcase LLDPD_AF_IPV4:\n\t\treturn LLDP_MGMT_ADDR_IP4;\n\tcase LLDPD_AF_IPV6:\n\t\treturn LLDP_MGMT_ADDR_IP6;\n\tdefault:\n\t\treturn LLDP_MGMT_ADDR_NONE;\n\t}\n}\n\ninline static int\nlldpd_af_from_lldp_proto(int proto)\n{\n\tswitch (proto) {\n\tcase LLDP_MGMT_ADDR_IP4:\n\t\treturn LLDPD_AF_IPV4;\n\tcase LLDP_MGMT_ADDR_IP6:\n\t\treturn LLDPD_AF_IPV6;\n\tdefault:\n\t\treturn LLDPD_AF_UNSPEC;\n\t}\n}\n\nstatic int _lldp_send(struct lldpd *global,\n    struct lldpd_hardware *hardware,\n    u_int8_t c_id_subtype,\n    char *c_id,\n    int c_id_len,\n    u_int8_t p_id_subtype,\n    char *p_id,\n    int p_id_len,\n    int shutdown)\n{\n\tstruct lldpd_port *port;\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_frame *frame;\n\tint length;\n\tu_int8_t *packet, *pos, *tlv;\n\tstruct lldpd_mgmt *mgmt;\n\tint proto;\n\n\tu_int8_t mcastaddr[] = LLDP_MULTICAST_ADDR;\n#ifdef ENABLE_DOT1\n\tconst u_int8_t dot1[] = LLDP_TLV_ORG_DOT1;\n\tstruct lldpd_vlan *vlan;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi;\n#endif\n#ifdef ENABLE_DOT3\n\tconst u_int8_t dot3[] = LLDP_TLV_ORG_DOT3;\n#endif\n#ifdef ENABLE_LLDPMED\n\tint i;\n\tconst u_int8_t med[] = LLDP_TLV_ORG_MED;\n#endif\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom;\n#endif\n\tport = &hardware->h_lport;\n\tchassis = port->p_chassis;\n\tlength = hardware->h_mtu;\n\tif ((packet = (u_int8_t*)calloc(1, length)) == NULL)\n\t\treturn ENOMEM;\n\tpos = packet;\n\n\t/* Ethernet header */\n\tif (!(\n\t      /* LLDP multicast address */\n\t      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&\n\t      /* Source MAC address */\n\t      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&\n\t      /* LLDP frame */\n\t      POKE_UINT16(ETHERTYPE_LLDP)))\n\t\tgoto toobig;\n\n\t/* Chassis ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_CHASSIS_ID) &&\n\t      POKE_UINT8(c_id_subtype) &&\n\t      POKE_BYTES(c_id, c_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Port ID */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_PORT_ID) &&\n\t      POKE_UINT8(p_id_subtype) &&\n\t      POKE_BYTES(p_id, p_id_len) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* Time to live */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_TTL) &&\n\t      POKE_UINT16(shutdown?0:chassis->c_ttl) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (shutdown)\n\t\tgoto end;\n\n\t/* System name */\n\tif (chassis->c_name && *chassis->c_name != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_NAME) &&\n\t\t\t    POKE_BYTES(chassis->c_name, strlen(chassis->c_name)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System description (skip it if empty) */\n\tif (chassis->c_descr && *chassis->c_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_DESCR) &&\n\t\t\t    POKE_BYTES(chassis->c_descr, strlen(chassis->c_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* System capabilities */\n\tif (global->g_config.c_cap_advertise && chassis->c_cap_available) {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tassert(proto != LLDP_MGMT_ADDR_NONE);\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {\n\t\t\tif (!(\n\t\t\t\t  /* We don't know the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_UNKNOWN) &&\n\t\t\t\t  POKE_UINT32(0)))\n\t\t\t\tgoto toobig;\n\t\t} else {\n\t\t\tif (!(\n\t\t\t\t  /* We have the index of the management interface */\n\t\t\t\t  POKE_UINT8(LLDP_MGMT_IFACE_IFINDEX) &&\n\t\t\t\t  POKE_UINT32(mgmt->m_iface)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(\n\t\t\t  /* We don't provide an OID for management */\n\t\t\t  POKE_UINT8(0) &&\n\t\t\t  POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Port description */\n\tif (port->p_descr && *port->p_descr != '\\0') {\n\t\tif (!(\n\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_PORT_DESCR) &&\n\t\t\t    POKE_BYTES(port->p_descr, strlen(port->p_descr)) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n#ifdef ENABLE_DOT1\n\t/* Port VLAN ID */\n\tif(port->p_pvid != 0) {\n\t\tif (!(\n\t\t    POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t    POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t    POKE_UINT8(LLDP_TLV_DOT1_PVID) &&\n\t\t    POKE_UINT16(port->p_pvid) &&\n\t\t    POKE_END_LLDP_TLV)) {\n\t\t    goto toobig;\n\t\t}\n\t}\n\t/* Port and Protocol VLAN IDs */\n\tTAILQ_FOREACH(ppvid, &port->p_ppvids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PPVID) &&\n\t\t      POKE_UINT8(ppvid->p_cap_status) &&\n\t\t      POKE_UINT16(ppvid->p_ppvid) &&\n\t\t      POKE_END_LLDP_TLV)) {\n\t\t\tgoto toobig;\n\t\t}\n\t}\n\t/* VLANs */\n\tTAILQ_FOREACH(vlan, &port->p_vlans, v_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_VLANNAME) &&\n\t\t      POKE_UINT16(vlan->v_vid) &&\n\t\t      POKE_UINT8(strlen(vlan->v_name)) &&\n\t\t      POKE_BYTES(vlan->v_name, strlen(vlan->v_name)) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Protocol Identities */\n\tTAILQ_FOREACH(pi, &port->p_pids, p_entries) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot1, sizeof(dot1)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT1_PI) &&\n\t\t      POKE_UINT8(pi->p_pi_len) &&\n\t\t      POKE_BYTES(pi->p_pi, pi->p_pi_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_DOT3\n\t/* Aggregation status */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_LA) &&\n\t      /* Bit 0 = capability ; Bit 1 = status */\n\t      POKE_UINT8((port->p_aggregid) ? 3:1) &&\n\t      POKE_UINT32(port->p_aggregid) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MAC/PHY */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t      POKE_UINT8(LLDP_TLV_DOT3_MAC) &&\n\t      POKE_UINT8(port->p_macphy.autoneg_support |\n\t\t\t (port->p_macphy.autoneg_enabled << 1)) &&\n\t      POKE_UINT16(port->p_macphy.autoneg_advertised) &&\n\t      POKE_UINT16(port->p_macphy.mau_type) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\t/* MFS */\n\tif (port->p_mfs) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_MFS) &&\n\t\t      POKE_UINT16(port->p_mfs) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\t/* Power */\n\tif (port->p_power.devicetype) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(dot3, sizeof(dot3)) &&\n\t\t      POKE_UINT8(LLDP_TLV_DOT3_POWER) &&\n\t\t      POKE_UINT8((\n\t\t\t\t  (((2 - port->p_power.devicetype)    %(1<< 1))<<0) |\n\t\t\t\t  (( port->p_power.supported          %(1<< 1))<<1) |\n\t\t\t\t  (( port->p_power.enabled            %(1<< 1))<<2) |\n\t\t\t\t  (( port->p_power.paircontrol        %(1<< 1))<<3))) &&\n\t\t      POKE_UINT8(port->p_power.pairs) &&\n\t\t      POKE_UINT8(port->p_power.class)))\n\t\t\tgoto toobig;\n\t\t/* 802.3at */\n\t\tif (port->p_power.powertype != LLDP_DOT3_POWER_8023AT_OFF) {\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t\t  (((port->p_power.powertype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_8023AT_TYPE1)?1:0) << 7) |\n\t\t\t\t\t   (((port->p_power.devicetype ==\n\t\t\t\t\t      LLDP_DOT3_POWER_PSE)?0:1) << 6) |\n\t\t\t\t\t   ((port->p_power.source   %(1<< 2))<<4) |\n\t\t\t\t\t   ((port->p_power.priority %(1<< 2))<<0))) &&\n\t\t\t      POKE_UINT16(port->p_power.requested) &&\n\t\t\t      POKE_UINT16(port->p_power.allocated)))\n\t\t\t\tgoto toobig;\n\t\t}\n\t\tif (!(POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\n#ifdef ENABLE_LLDPMED\n\tif (port->p_med_cap_enabled) {\n\t\t/* LLDP-MED cap */\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t      POKE_UINT8(LLDP_TLV_MED_CAP) &&\n\t\t      POKE_UINT16(chassis->c_med_cap_available) &&\n\t\t      POKE_UINT8(chassis->c_med_type) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\n\t\t/* LLDP-MED inventory */\n#define LLDP_INVENTORY(value, subtype)\t\t\t\t\t\\\n\t\tif (value) {\t\t\t\t\t\t\\\n\t\t    if (!(\t\t\t\t\t\t\\\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\t\t\\\n\t\t\t  POKE_BYTES(med, sizeof(med)) &&\t\t\\\n\t\t\t  POKE_UINT8(subtype) &&\t\t\t\\\n\t\t\t  POKE_BYTES(value,\t\t\t\t\\\n\t\t\t\t(strlen(value)>32)?32:strlen(value)) &&\t\\\n\t\t\t  POKE_END_LLDP_TLV))\t\t\t\t\\\n\t\t\t    goto toobig;\t\t\t\t\\\n\t\t}\n\n\t\tif (port->p_med_cap_enabled & LLDP_MED_CAP_IV) {\n\t\t\tLLDP_INVENTORY(chassis->c_med_hw,\n\t\t\t    LLDP_TLV_MED_IV_HW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_fw,\n\t\t\t    LLDP_TLV_MED_IV_FW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sw,\n\t\t\t    LLDP_TLV_MED_IV_SW);\n\t\t\tLLDP_INVENTORY(chassis->c_med_sn,\n\t\t\t    LLDP_TLV_MED_IV_SN);\n\t\t\tLLDP_INVENTORY(chassis->c_med_manuf,\n\t\t\t    LLDP_TLV_MED_IV_MANUF);\n\t\t\tLLDP_INVENTORY(chassis->c_med_model,\n\t\t\t    LLDP_TLV_MED_IV_MODEL);\n\t\t\tLLDP_INVENTORY(chassis->c_med_asset,\n\t\t\t    LLDP_TLV_MED_IV_ASSET);\n\t\t}\n\n\t\t/* LLDP-MED location */\n\t\tfor (i = 0; i < LLDP_MED_LOCFORMAT_LAST; i++) {\n\t\t\tif (port->p_med_location[i].format == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_LOCATION) &&\n\t\t\t\t      POKE_UINT8(port->p_med_location[i].format) &&\n\t\t\t\t      POKE_BYTES(port->p_med_location[i].data,\n\t\t\t\t\t  port->p_med_location[i].data_len) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED network policy */\n\t\tfor (i = 0; i < LLDP_MED_APPTYPE_LAST; i++) {\n\t\t\tif (port->p_med_policy[i].type == i + 1) {\n\t\t\t\tif (!(\n\t\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t\t      POKE_UINT8(LLDP_TLV_MED_POLICY) &&\n\t\t\t\t      POKE_UINT32((\n\t\t\t\t\t((port->p_med_policy[i].type     %(1<< 8))<<24) |\n\t\t\t\t\t((port->p_med_policy[i].unknown  %(1<< 1))<<23) |\n\t\t\t\t\t((port->p_med_policy[i].tagged   %(1<< 1))<<22) |\n\t\t\t\t      /*((0                              %(1<< 1))<<21) |*/\n\t\t\t\t\t((port->p_med_policy[i].vid      %(1<<12))<< 9) |\n\t\t\t\t\t((port->p_med_policy[i].priority %(1<< 3))<< 6) |\n\t\t\t\t\t((port->p_med_policy[i].dscp     %(1<< 6))<< 0) )) &&\n\t\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\t\tgoto toobig;\n\t\t\t}\n\t\t}\n\n\t\t/* LLDP-MED POE-MDI */\n\t\tif ((port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PSE) ||\n\t\t    (port->p_med_power.devicetype == LLDP_MED_POW_TYPE_PD)) {\n\t\t\tint devicetype = 0, source = 0;\n\t\t\tif (!(\n\t\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t\t      POKE_BYTES(med, sizeof(med)) &&\n\t\t\t      POKE_UINT8(LLDP_TLV_MED_MDI)))\n\t\t\t\tgoto toobig;\n\t\t\tswitch (port->p_med_power.devicetype) {\n\t\t\tcase LLDP_MED_POW_TYPE_PSE:\n\t\t\t\tdevicetype = 0;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PRIMARY: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BACKUP: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_RESERVED: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LLDP_MED_POW_TYPE_PD:\n\t\t\t\tdevicetype = 1;\n\t\t\t\tswitch (port->p_med_power.source) {\n\t\t\t\tcase LLDP_MED_POW_SOURCE_PSE: source = 1; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_LOCAL: source = 2; break;\n\t\t\t\tcase LLDP_MED_POW_SOURCE_BOTH: source = 3; break;\n\t\t\t\tdefault: source = 0; break;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(\n\t\t\t      POKE_UINT8((\n\t\t\t\t((devicetype                   %(1<< 2))<<6) |\n\t\t\t\t((source                       %(1<< 2))<<4) |\n\t\t\t\t((port->p_med_power.priority   %(1<< 4))<<0) )) &&\n\t\t\t      POKE_UINT16(port->p_med_power.val) &&\n\t\t\t      POKE_END_LLDP_TLV))\n\t\t\t\tgoto toobig;\n\t\t}\n\t}\n#endif\n\n#ifdef ENABLE_CUSTOM\n\tTAILQ_FOREACH(custom, &port->p_custom_list, next) {\n\t\tif (!(\n\t\t      POKE_START_LLDP_TLV(LLDP_TLV_ORG) &&\n\t\t      POKE_BYTES(custom->oui, sizeof(custom->oui)) &&\n\t\t      POKE_UINT8(custom->subtype) &&\n\t\t      POKE_BYTES(custom->oui_info, custom->oui_info_len) &&\n\t\t      POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n#endif\n\nend:\n\t/* END */\n\tif (!(\n\t      POKE_START_LLDP_TLV(LLDP_TLV_END) &&\n\t      POKE_END_LLDP_TLV))\n\t\tgoto toobig;\n\n\tif (interfaces_send_helper(global, hardware,\n\t\t(char *)packet, pos - packet) == -1) {\n\t\tlog_warn(\"lldp\", \"unable to send packet on real device for %s\",\n\t\t    hardware->h_ifname);\n\t\tfree(packet);\n\t\treturn ENETDOWN;\n\t}\n\n\thardware->h_tx_cnt++;\n\n\t/* We assume that LLDP frame is the reference */\n\tif (!shutdown && (frame = (struct lldpd_frame*)malloc(\n\t\t\tsizeof(int) + pos - packet)) != NULL) {\n\t\tframe->size = pos - packet;\n\t\tmemcpy(&frame->frame, packet, frame->size);\n\t\tif ((hardware->h_lport.p_lastframe == NULL) ||\n\t\t    (hardware->h_lport.p_lastframe->size != frame->size) ||\n\t\t    (memcmp(hardware->h_lport.p_lastframe->frame, frame->frame,\n\t\t\tframe->size) != 0)) {\n\t\t\tfree(hardware->h_lport.p_lastframe);\n\t\t\thardware->h_lport.p_lastframe = frame;\n\t\t\thardware->h_lport.p_lastchange = time(NULL);\n\t\t} else free(frame);\n\t}\n\n\tfree(packet);\n\treturn 0;\n\ntoobig:\n\tfree(packet);\n\treturn E2BIG;\n}\n\n/* Send a shutdown LLDPDU. */\nint\nlldp_send_shutdown(struct lldpd *global,\n    struct lldpd_hardware *hardware)\n{\n\tif (hardware->h_lchassis_previous_id == NULL ||\n\t    hardware->h_lport_previous_id == NULL)\n\t\treturn 0;\n\treturn _lldp_send(global, hardware,\n\t    hardware->h_lchassis_previous_id_subtype,\n\t    hardware->h_lchassis_previous_id,\n\t    hardware->h_lchassis_previous_id_len,\n\t    hardware->h_lport_previous_id_subtype,\n\t    hardware->h_lport_previous_id,\n\t    hardware->h_lport_previous_id_len,\n\t    1);\n}\n\nint\nlldp_send(struct lldpd *global,\n\t  struct lldpd_hardware *hardware)\n{\n\tstruct lldpd_port *port = &hardware->h_lport;\n\tstruct lldpd_chassis *chassis = port->p_chassis;\n\tint ret;\n\n\t/* Check if we have a change. */\n\tif (hardware->h_lchassis_previous_id != NULL &&\n\t    hardware->h_lport_previous_id != NULL &&\n\t    (hardware->h_lchassis_previous_id_subtype != chassis->c_id_subtype ||\n\t\thardware->h_lchassis_previous_id_len != chassis->c_id_len ||\n\t\thardware->h_lport_previous_id_subtype != port->p_id_subtype ||\n\t\thardware->h_lport_previous_id_len != port->p_id_len ||\n\t\tmemcmp(hardware->h_lchassis_previous_id,\n\t\t    chassis->c_id, chassis->c_id_len) ||\n\t\tmemcmp(hardware->h_lport_previous_id,\n\t\t    port->p_id, port->p_id_len))) {\n\t\tlog_info(\"lldp\", \"MSAP has changed for port %s, sending a shutdown LLDPDU\",\n\t\t    hardware->h_ifname);\n\t\tif ((ret = lldp_send_shutdown(global, hardware)) != 0)\n\t\t\treturn ret;\n\t}\n\n\tlog_debug(\"lldp\", \"send LLDP PDU to %s\",\n\t    hardware->h_ifname);\n\n\tif ((ret = _lldp_send(global, hardware,\n\t\t    chassis->c_id_subtype,\n\t\t    chassis->c_id,\n\t\t    chassis->c_id_len,\n\t\t    port->p_id_subtype,\n\t\t    port->p_id,\n\t\t    port->p_id_len,\n\t\t    0)) != 0)\n\t\treturn ret;\n\n\t/* Record current chassis and port ID */\n\tfree(hardware->h_lchassis_previous_id);\n\thardware->h_lchassis_previous_id_subtype = chassis->c_id_subtype;\n\thardware->h_lchassis_previous_id_len = chassis->c_id_len;\n\tif ((hardware->h_lchassis_previous_id = malloc(chassis->c_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lchassis_previous_id, chassis->c_id,\n\t\t    chassis->c_id_len);\n\tfree(hardware->h_lport_previous_id);\n\thardware->h_lport_previous_id_subtype = port->p_id_subtype;\n\thardware->h_lport_previous_id_len = port->p_id_len;\n\tif ((hardware->h_lport_previous_id = malloc(port->p_id_len)) != NULL)\n\t\tmemcpy(hardware->h_lport_previous_id, port->p_id,\n\t\t    port->p_id_len);\n\n\treturn 0;\n}\n\n#define CHECK_TLV_SIZE(x, name)\t\t\t\t   \\\n\tdo { if (tlv_size < (x)) {\t\t\t   \\\n\t\t\tlog_warnx(\"lldp\", name \" TLV too short received on %s\",\t\\\n\t       hardware->h_ifname);\t\t\t   \\\n\t   goto malformed;\t\t\t\t   \\\n\t} } while (0)\n\nint\nlldp_decode(struct lldpd *cfg, char *frame, int s,\n    struct lldpd_hardware *hardware,\n    struct lldpd_chassis **newchassis, struct lldpd_port **newport)\n{\n\tstruct lldpd_chassis *chassis;\n\tstruct lldpd_port *port;\n\tconst char lldpaddr[] = LLDP_MULTICAST_ADDR;\n\tconst char dot1[] = LLDP_TLV_ORG_DOT1;\n\tconst char dot3[] = LLDP_TLV_ORG_DOT3;\n\tconst char med[] = LLDP_TLV_ORG_MED;\n\tconst char dcbx[] = LLDP_TLV_ORG_DCBX;\n\tunsigned char orgid[3];\n\tint length, gotend = 0, ttl_received = 0;\n\tint tlv_size, tlv_type, tlv_subtype;\n\tu_int8_t *pos, *tlv;\n\tchar *b;\n#ifdef ENABLE_DOT1\n\tstruct lldpd_vlan *vlan = NULL;\n\tint vlan_len;\n\tstruct lldpd_ppvid *ppvid;\n\tstruct lldpd_pi *pi = NULL;\n#endif\n\tstruct lldpd_mgmt *mgmt;\n\tint af;\n\tu_int8_t addr_str_length, addr_str_buffer[32];\n\tu_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;\n\tu_int32_t iface_number, iface;\n#ifdef ENABLE_CUSTOM\n\tstruct lldpd_custom *custom = NULL;\n#endif\n\n\tlog_debug(\"lldp\", \"receive LLDP PDU on %s\",\n\t    hardware->h_ifname);\n\n\tif ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote chassis\");\n\t\treturn -1;\n\t}\n\tTAILQ_INIT(&chassis->c_mgmt);\n\tif ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {\n\t\tlog_warn(\"lldp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n\tTAILQ_INIT(&port->p_ppvids);\n\tTAILQ_INIT(&port->p_pids);\n#endif\n#ifdef ENABLE_CUSTOM\n\tTAILQ_INIT(&port->p_custom_list);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\n\tif (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"lldp\", \"too short frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {\n\t\tlog_info(\"lldp\", \"frame not targeted at LLDP multicast address received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tPEEK_DISCARD(ETHER_ADDR_LEN);\t/* Skip source address */\n\tif (PEEK_UINT16 != ETHERTYPE_LLDP) {\n\t\tlog_info(\"lldp\", \"non LLDP frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\n\twhile (length && (!gotend)) {\n\t\tif (length < 2) {\n\t\t\tlog_warnx(\"lldp\", \"tlv header too short received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\ttlv_size = PEEK_UINT16;\n\t\ttlv_type = tlv_size >> 9;\n\t\ttlv_size = tlv_size & 0x1ff;\n\t\t(void)PEEK_SAVE(tlv);\n\t\tif (length < tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"frame too short for tlv received on %s\",\n\t\t\t    hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tswitch (tlv_type) {\n\t\tcase LLDP_TLV_END:\n\t\t\tif (tlv_size != 0) {\n\t\t\t\tlog_warnx(\"lldp\", \"lldp end received with size not null on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif (length)\n\t\t\t\tlog_debug(\"lldp\", \"extra data after lldp end on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\tgotend = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_CHASSIS_ID:\n\t\tcase LLDP_TLV_PORT_ID:\n\t\t\tCHECK_TLV_SIZE(2, \"Port Id\");\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif ((tlv_subtype == 0) || (tlv_subtype > 7)) {\n\t\t\t\tlog_warnx(\"lldp\", \"unknown subtype for tlv id received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for id tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size - 1);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_ID) {\n\t\t\t\tport->p_id_subtype = tlv_subtype;\n\t\t\t\tport->p_id = b;\n\t\t\t\tport->p_id_len = tlv_size - 1;\n\t\t\t} else {\n\t\t\t\tchassis->c_id_subtype = tlv_subtype;\n\t\t\t\tchassis->c_id = b;\n\t\t\t\tchassis->c_id_len = tlv_size - 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LLDP_TLV_TTL:\n\t\t\tCHECK_TLV_SIZE(2, \"TTL\");\n\t\t\tchassis->c_ttl = PEEK_UINT16;\n\t\t\tttl_received = 1;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_PORT_DESCR:\n\t\tcase LLDP_TLV_SYSTEM_NAME:\n\t\tcase LLDP_TLV_SYSTEM_DESCR:\n\t\t\tif (tlv_size < 1) {\n\t\t\t\tlog_debug(\"lldp\", \"empty tlv received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory for string tlv \"\n\t\t\t\t    \"received on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tPEEK_BYTES(b, tlv_size);\n\t\t\tif (tlv_type == LLDP_TLV_PORT_DESCR)\n\t\t\t\tport->p_descr = b;\n\t\t\telse if (tlv_type == LLDP_TLV_SYSTEM_NAME)\n\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");\n\t\t\t\t\tif ((vlan = (struct lldpd_vlan *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_vlan))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tvlan->v_vid = PEEK_UINT16;\n\t\t\t\t\tvlan_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(7 + vlan_len, \"VLAN\");\n\t\t\t\t\tif ((vlan->v_name =\n\t\t\t\t\t\t(char *)calloc(1, vlan_len + 1)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc vlan name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(vlan->v_name, vlan_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_vlans,\n\t\t\t\t\t    vlan, v_entries);\n\t\t\t\t\tvlan = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PVID:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"PVID\");\n\t\t\t\t\tport->p_pvid = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PPVID:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"PPVID\");\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PPVID has to be unique if more than\n\t\t\t\t\t   one PPVID TLVs are received  - \n\t\t\t\t\t   discard if duplicate */\n\t\t\t\t\t/* if support bit is not set and \n\t\t\t\t\t   enabled bit is set - PPVID TLV is\n\t\t\t\t\t   considered error  and discarded */\n\t\t\t\t\t/* if PPVID > 4096 - bad and discard */\n\t\t\t\t\tif ((ppvid = (struct lldpd_ppvid *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_ppvid))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc ppvid \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tppvid->p_cap_status = PEEK_UINT8;\n\t\t\t\t\tppvid->p_ppvid = PEEK_UINT16;\t\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_ppvids,\n\t\t\t\t\t    ppvid, p_entries);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT1_PI:\n\t\t\t\t\t/* validation needed */\n\t\t\t\t\t/* PI has to be unique if more than \n\t\t\t\t\t   one PI TLVs are received  - discard\n\t\t\t\t\t   if duplicate ?? */\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"PI\");\n\t\t\t\t\tif ((pi = (struct lldpd_pi *)calloc(1,\n\t\t\t\t\t\t    sizeof(struct lldpd_pi))) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc PI \"\n\t\t\t\t\t\t    \"structure for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tpi->p_pi_len = PEEK_UINT8;\n\t\t\t\t\tCHECK_TLV_SIZE(5 + pi->p_pi_len, \"PI\");\n\t\t\t\t\tif ((pi->p_pi =\n\t\t\t\t\t\t(char *)calloc(1, pi->p_pi_len)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to alloc pid name for \"\n\t\t\t\t\t\t    \"tlv received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(pi->p_pi, pi->p_pi_len);\n\t\t\t\t\tTAILQ_INSERT_TAIL(&port->p_pids,\n\t\t\t\t\t    pi, p_entries);\n\t\t\t\t\tpi = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot1 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT3\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot3 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT3_MAC:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"MAC/PHY\");\n\t\t\t\t\tport->p_macphy.autoneg_support = PEEK_UINT8;\n\t\t\t\t\tport->p_macphy.autoneg_enabled =\n\t\t\t\t\t    (port->p_macphy.autoneg_support & 0x2) >> 1;\n\t\t\t\t\tport->p_macphy.autoneg_support =\n\t\t\t\t\t    port->p_macphy.autoneg_support & 0x1;\n\t\t\t\t\tport->p_macphy.autoneg_advertised =\n\t\t\t\t\t    PEEK_UINT16;\n\t\t\t\t\tport->p_macphy.mau_type = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_LA:\n\t\t\t\t\tCHECK_TLV_SIZE(9, \"Link aggregation\");\n\t\t\t\t\tPEEK_DISCARD_UINT8;\n\t\t\t\t\tport->p_aggregid = PEEK_UINT32;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_MFS:\n\t\t\t\t\tCHECK_TLV_SIZE(6, \"MFS\");\n\t\t\t\t\tport->p_mfs = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_DOT3_POWER:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"Power\");\n\t\t\t\t\tport->p_power.devicetype = PEEK_UINT8;\n\t\t\t\t\tport->p_power.supported =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x2) >> 1;\n\t\t\t\t\tport->p_power.enabled =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x4) >> 2;\n\t\t\t\t\tport->p_power.paircontrol =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x8) >> 3;\n\t\t\t\t\tport->p_power.devicetype =\n\t\t\t\t\t\t(port->p_power.devicetype & 0x1)?\n\t\t\t\t\t\tLLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;\n\t\t\t\t\tport->p_power.pairs = PEEK_UINT8;\n\t\t\t\t\tport->p_power.class = PEEK_UINT8;\n\t\t\t\t\t/* 802.3at? */\n\t\t\t\t\tif (tlv_size >= 12) {\n\t\t\t\t\t\tport->p_power.powertype = PEEK_UINT8;\n\t\t\t\t\t\tport->p_power.source =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;\n\t\t\t\t\t\tport->p_power.priority =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<1 | 1<<0));\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    (port->p_power.powertype & (1<<7))?\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE1:\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_TYPE2;\n\t\t\t\t\t\tport->p_power.requested = PEEK_UINT16;\n\t\t\t\t\t\tport->p_power.allocated = PEEK_UINT16;\n\t\t\t\t\t} else\n\t\t\t\t\t\tport->p_power.powertype =\n\t\t\t\t\t\t    LLDP_DOT3_POWER_8023AT_OFF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown Dot3 TLV, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif\n\t\t\t} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {\n\t\t\t\t/* LLDP-MED */\n#ifndef ENABLE_LLDPMED\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\tu_int32_t policy;\n\t\t\t\tunsigned loctype;\n\t\t\t\tunsigned power;\n\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_MED_CAP:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED capabilities\");\n\t\t\t\t\tchassis->c_med_cap_available = PEEK_UINT16;\n\t\t\t\t\tchassis->c_med_type = PEEK_UINT8;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_CAP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_POLICY:\n\t\t\t\t\tCHECK_TLV_SIZE(8, \"LLDP-MED policy\");\n\t\t\t\t\tpolicy = PEEK_UINT32;\n\t\t\t\t\tif (((policy >> 24) < 1) ||\n\t\t\t\t\t    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown policy field %d \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    policy,\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].type =\n\t\t\t\t\t    (policy >> 24);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].unknown =\n\t\t\t\t\t    ((policy & 0x800000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].tagged =\n\t\t\t\t\t    ((policy & 0x400000) != 0);\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].vid =\n\t\t\t\t\t    (policy & 0x001FFE00) >> 9;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].priority =\n\t\t\t\t\t    (policy & 0x1C0) >> 6;\n\t\t\t\t\tport->p_med_policy[(policy >> 24) - 1].dscp =\n\t\t\t\t\t    policy & 0x3F;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_POLICY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_LOCATION:\n\t\t\t\t\tCHECK_TLV_SIZE(5, \"LLDP-MED Location\");\n\t\t\t\t\tloctype = PEEK_UINT8;\n\t\t\t\t\tif ((loctype < 1) ||\n\t\t\t\t\t    (loctype > LLDP_MED_LOCFORMAT_LAST)) {\n\t\t\t\t\t\tlog_info(\"lldp\", \"unknown location type \"\n\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((port->p_med_location[loctype - 1].data =\n\t\t\t\t\t\t(char*)malloc(tlv_size - 5)) == NULL) {\n\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t    \"for LLDP-MED location for \"\n\t\t\t\t\t\t    \"frame received on %s\",\n\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(port->p_med_location[loctype - 1].data,\n\t\t\t\t\t    tlv_size - 5);\n\t\t\t\t\tport->p_med_location[loctype - 1].data_len =\n\t\t\t\t\t    tlv_size - 5;\n\t\t\t\t\tport->p_med_location[loctype - 1].format = loctype;\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_LOCATION;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_MDI:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"LLDP-MED PoE-MDI\");\n\t\t\t\t\tpower = PEEK_UINT8;\n\t\t\t\t\tswitch (power & 0xC0) {\n\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PSE;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PRIMARY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BACKUP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_RESERVED;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0x40:\n\t\t\t\t\t\tport->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;\n\t\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t\t    LLDP_MED_CAP_MDI_PD;\n\t\t\t\t\t\tswitch (power & 0x30) {\n\t\t\t\t\t\tcase 0x0:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_UNKNOWN;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x10:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_PSE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x20:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_LOCAL;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tport->p_med_power.source =\n\t\t\t\t\t\t\t    LLDP_MED_POW_SOURCE_BOTH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tport->p_med_power.devicetype =\n\t\t\t\t\t\t    LLDP_MED_POW_TYPE_RESERVED;\n\t\t\t\t\t}\n\t\t\t\t\tif ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    LLDP_MED_POW_PRIO_UNKNOWN;\n\t\t\t\t\telse\n\t\t\t\t\t\tport->p_med_power.priority =\n\t\t\t\t\t\t    power & 0x0F;\n\t\t\t\t\tport->p_med_power.val = PEEK_UINT16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\tif (tlv_size <= 4)\n\t\t\t\t\t\tb = NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif ((b = (char*)malloc(tlv_size - 3)) ==\n\t\t\t\t\t\t    NULL) {\n\t\t\t\t\t\t\tlog_warn(\"lldp\", \"unable to allocate \"\n\t\t\t\t\t\t\t    \"memory for LLDP-MED \"\n\t\t\t\t\t\t\t    \"inventory for frame \"\n\t\t\t\t\t\t\t    \"received on %s\",\n\t\t\t\t\t\t\t    hardware->h_ifname);\n\t\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tPEEK_BYTES(b, tlv_size - 4);\n\t\t\t\t\t\tb[tlv_size - 4] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\t\tcase LLDP_TLV_MED_IV_HW:\n\t\t\t\t\t\tchassis->c_med_hw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_FW:\n\t\t\t\t\t\tchassis->c_med_fw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SW:\n\t\t\t\t\t\tchassis->c_med_sw = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_SN:\n\t\t\t\t\t\tchassis->c_med_sn = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MANUF:\n\t\t\t\t\t\tchassis->c_med_manuf = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_MODEL:\n\t\t\t\t\t\tchassis->c_med_model = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LLDP_TLV_MED_IV_ASSET:\n\t\t\t\t\t\tchassis->c_med_asset = b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tport->p_med_cap_enabled |=\n\t\t\t\t\t    LLDP_MED_CAP_IV;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* Unknown LLDP MED, ignore it */\n\t\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t\t}\n#endif /* ENABLE_LLDPMED */\n\t\t\t} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {\n\t\t\t\tlog_debug(\"lldp\", \"unsupported DCBX tlv received on %s - ignore\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n\t\t\t} else {\n\t\t\t\tlog_debug(\"lldp\", \"unknown org tlv [%02x:%02x:%02x] received on %s\",\n\t\t\t\t    orgid[0], orgid[1], orgid[2],\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#ifdef ENABLE_CUSTOM\n\t\t\t\tcustom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));\n\t\t\t\tif (!custom) {\n\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t    \"unable to allocate memory for custom TLV\");\n\t\t\t\t\tgoto malformed;\n\t\t\t\t}\n\t\t\t\tcustom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;\n\t\t\t\tmemcpy(custom->oui, orgid, sizeof(custom->oui));\n\t\t\t\tcustom->subtype = tlv_subtype;\n\t\t\t\tif (custom->oui_info_len > 0) {\n\t\t\t\t\tcustom->oui_info = malloc(custom->oui_info_len);\n\t\t\t\t\tif (!custom->oui_info) {\n\t\t\t\t\t\tlog_warn(\"lldp\",\n\t\t\t\t\t\t    \"unable to allocate memory for custom TLV data\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t\t\t}\n\t\t\t\t\tPEEK_BYTES(custom->oui_info, custom->oui_info_len);\n\t\t\t\t}\n\t\t\t\tTAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);\n\t\t\t\tcustom = NULL;\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_warnx(\"lldp\", \"unknown tlv (%d) received on %s\",\n\t\t\t    tlv_type, hardware->h_ifname);\n\t\t\tgoto malformed;\n\t\t}\n\t\tif (pos > tlv + tlv_size) {\n\t\t\tlog_warnx(\"lldp\", \"BUG: already past TLV!\");\n\t\t\tgoto malformed;\n\t\t}\n\t\tPEEK_DISCARD(tlv + tlv_size - pos);\n\t}\n\n\t/* Some random check */\n\tif ((chassis->c_id == NULL) ||\n\t    (port->p_id == NULL) ||\n\t    (!ttl_received) ||\n\t    (gotend == 0)) {\n\t\tlog_warnx(\"lldp\", \"some mandatory tlv are missing for frame received on %s\",\n\t\t    hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\t*newchassis = chassis;\n\t*newport = port;\n\treturn 1;\nmalformed:\n#ifdef ENABLE_CUSTOM\n\tfree(custom);\n#endif\n#ifdef ENABLE_DOT1\n\tfree(vlan);\n\tfree(pi);\n#endif\n\tlldpd_chassis_cleanup(chassis, 1);\n\tlldpd_port_cleanup(port, 1);\n\tfree(port);\n\treturn -1;\n}\n"], "filenames": ["src/daemon/protocols/lldp.c"], "buggy_code_start_loc": [728], "buggy_code_end_loc": [756], "fixing_code_start_loc": [729], "fixing_code_end_loc": [761], "type": "CWE-120", "message": "Buffer overflow in the lldp_decode function in daemon/protocols/lldp.c in lldpd before 0.8.0 allows remote attackers to cause a denial of service (daemon crash) and possibly execute arbitrary code via vectors involving large management addresses and TLV boundaries.", "other": {"cve": {"id": "CVE-2015-8011", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-28T19:15:12.733", "lastModified": "2021-08-02T17:15:12.020", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the lldp_decode function in daemon/protocols/lldp.c in lldpd before 0.8.0 allows remote attackers to cause a denial of service (daemon crash) and possibly execute arbitrary code via vectors involving large management addresses and TLV boundaries."}, {"lang": "es", "value": "Un desbordamiento del b\u00fafer en la funci\u00f3n lldp_decode en el archivo daemon/protocolos/lldp.c en lldpd versiones anteriores a 0.8.0, permite a atacantes remotos causar una denegaci\u00f3n de servicio (bloqueo de daemon) y posiblemente ejecutar c\u00f3digo arbitrario por medio de vectores que involucran grandes direcciones de administraci\u00f3n y l\u00edmites de TLV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lldpd_project:lldpd:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.5.6", "versionEndExcluding": "0.8.0", "matchCriteriaId": "FF2A20FC-7DE0-45D3-8E22-F71859962F82"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/10/16/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/10/30/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-941426.pdf", "source": "cve@mitre.org"}, {"url": "https://github.com/vincentbernat/lldpd/commit/dd4f16e7e816f2165fba76e3d162cd8d2978dcb2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UJ4DXFJWMZ325ECZXPZOSK7BOEDJZHPR/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://us-cert.cisa.gov/ics/advisories/icsa-21-194-07", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2021/dsa-4836", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vincentbernat/lldpd/commit/dd4f16e7e816f2165fba76e3d162cd8d2978dcb2"}}