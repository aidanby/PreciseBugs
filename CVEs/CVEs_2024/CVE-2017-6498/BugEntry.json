{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT   GGGG   AAA                               %\n%                              T    G      A   A                              %\n%                              T    G  GG  AAAAA                              %\n%                              T    G   G  A   A                              %\n%                              T     GGG   A   A                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Truevision Targa Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  TGAColormap = 1,\n  TGARGB = 2,\n  TGAMonochrome = 3,\n  TGARLEColormap = 9,\n  TGARLERGB = 10,\n  TGARLEMonochrome = 11\n} TGAImageType;\n\n/*\n  Typedef declaractions.\n*/\ntypedef struct _TGAInfo\n{\n  TGAImageType\n    image_type;\n\n  unsigned char\n    id_length,\n    colormap_type;\n\n  unsigned short\n    colormap_index,\n    colormap_length;\n\n  unsigned char\n    colormap_size;\n\n  unsigned short\n    x_origin,\n    y_origin,\n    width,\n    height;\n\n  unsigned char\n    bits_per_pixel,\n    attributes;\n} TGAInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTGAImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T G A I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTGAImage() reads a Truevision TGA image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadTGAImage method is:\n%\n%      Image *ReadTGAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    pixel;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->matte=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  MagickTrue : MagickFalse;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MaxTextExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MaxTextExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  if (tga_info.attributes & (1UL << 4))\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopRight\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomRight\");\n    }\n  else\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopLeft\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomLeft\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.opacity=(Quantum) OpaqueOpacity;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,range);\n            pixel.green=ScaleAnyToQuantum((1UL*(k & 0x03) << 3)+\n              (1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.opacity=(Quantum) (QuantumRange-ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image)));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=(IndexPacket) 0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(IndexPacket) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                1UL*index)];\n            else\n              {\n                pixel.red=ScaleCharToQuantum((unsigned char) index);\n                pixel.green=ScaleCharToQuantum((unsigned char) index);\n                pixel.blue=ScaleCharToQuantum((unsigned char) index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB;\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,range);\n            pixel.green=ScaleAnyToQuantum((1UL*(k & 0x03) << 3)+\n              (1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->matte != MagickFalse)\n              pixel.opacity=(k & 0x80) == 0 ? (Quantum) TransparentOpacity :\n                (Quantum) OpaqueOpacity;\n            if (image->storage_class == PseudoClass)\n              index=ConstrainColormapIndex(image,((size_t) k << 8)+j);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=ScaleCharToQuantum(pixels[0]);\n            pixel.green=ScaleCharToQuantum(pixels[1]);\n            pixel.red=ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=ScaleCharToQuantum(pixels[0]);\n            pixel.green=ScaleCharToQuantum(pixels[1]);\n            pixel.red=ScaleCharToQuantum(pixels[2]);\n            pixel.opacity=(Quantum) (QuantumRange-ScaleCharToQuantum(\n              pixels[3]));\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(indexes+x,index);\n      SetPixelRed(q,pixel.red);\n      SetPixelGreen(q,pixel.green);\n      SetPixelBlue(q,pixel.blue);\n      if (image->matte != MagickFalse)\n        SetPixelOpacity(q,pixel.opacity);\n      q++;\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T G A I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTGAImage() adds properties for the TGA image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTGAImage method is:\n%\n%      size_t RegisterTGAImage(void)\n%\n*/\nModuleExport size_t RegisterTGAImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"ICB\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TGA\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"VDA\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"VST\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T G A I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTGAImage() removes format registrations made by the\n%  TGA module from the list of supported formats.\n%\n%  The format of the UnregisterTGAImage method is:\n%\n%      UnregisterTGAImage(void)\n%\n*/\nModuleExport void UnregisterTGAImage(void)\n{\n  (void) UnregisterMagickInfo(\"ICB\");\n  (void) UnregisterMagickInfo(\"TGA\");\n  (void) UnregisterMagickInfo(\"VDA\");\n  (void) UnregisterMagickInfo(\"VST\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T G A I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTGAImage() writes a image in the Truevision Targa rasterfile\n%  format.\n%\n%  The format of the WriteTGAImage method is:\n%\n%      MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic inline void WriteTGAPixel(Image *image,TGAImageType image_type,\n  const IndexPacket *indexes,const PixelPacket *p,const QuantumAny range,\n  const double midpoint)\n{\n  if (image_type == TGAColormap || image_type == TGARLEColormap)\n    (void) WriteBlobByte(image,(unsigned char) GetPixelIndex(indexes));\n  else\n    {\n      if (image_type == TGAMonochrome || image_type == TGARLEMonochrome)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          GetPixelLuma(image,p))));\n      else\n        if (image->depth == 5)\n          {\n            unsigned char\n              green,\n              value;\n\n              green=(unsigned char) ScaleQuantumToAny(GetPixelGreen(p),range);\n              value=((unsigned char) ScaleQuantumToAny(GetPixelBlue(p),range)) |\n                ((green & 0x07) << 5);\n              (void) WriteBlobByte(image,value);\n              value=(unsigned char) ((((image->matte != MagickFalse) && \n                ((double) GetPixelOpacity(p) < midpoint)) ? 0x80 : 0) |\n                ((unsigned char) ScaleQuantumToAny(GetPixelRed(p),range) << 2) |\n                ((green & 0x18) >> 3));\n              (void) WriteBlobByte(image,value);\n          }\n        else\n          {\n            (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(p)));\n            if (image->matte != MagickFalse)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(p)));\n          }\n    }\n}\n\nstatic MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  range=GetQuantumRange(5UL);\n  tga_info.id_length=0;\n  value=GetImageProperty(image,\"comment\");\n  if (value != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);\n  tga_info.colormap_type=0;\n  tga_info.colormap_index=0;\n  tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorMatteType) &&\n      (image_info->type != PaletteType) &&\n      (image->matte == MagickFalse) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->matte != MagickFalse)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->matte != MagickFalse)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  value=GetImageArtifact(image,\"tga:image-origin\");\n  if (value != (const char *) NULL)\n    {\n      OrientationType\n        origin;\n\n      origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,\n        MagickFalse,value);\n      if (origin == BottomRightOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 4);\n      if (origin == TopLeftOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 5);\n    }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n  (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n  (void) WriteBlobByte(image,tga_info.attributes);\n  if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);\n  if (tga_info.colormap_type != 0)\n    {\n      unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(\n        *targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,\n              range);\n            *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,\n              range)) | ((green & 0x07) << 5);\n            *q++=(((image->matte != MagickFalse) && (\n              (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,\n              range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))\n                  break;\n              }\n            else\n              if (tga_info.image_type == TGARLEMonochrome)\n                {\n                  if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))\n                    break;\n                }\n              else\n                {\n                  if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||\n                      (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||\n                      (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))\n                    break;\n                  if ((image->matte != MagickFalse) &&\n                      (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))\n                    break;\n                }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=i;\n              indexes+=i;\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),\n                      p-(count+1),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);\n              p+=i;\n              indexes+=i;\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            TTTTT   GGGG   AAA                               %\n%                              T    G      A   A                              %\n%                              T    G  GG  AAAAA                              %\n%                              T    G   G  A   A                              %\n%                              T     GGG   A   A                              %\n%                                                                             %\n%                                                                             %\n%                    Read/Write Truevision Targa Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/artifact.h\"\n#include \"magick/attribute.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colormap.h\"\n#include \"magick/colormap-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/image.h\"\n#include \"magick/image-private.h\"\n#include \"magick/list.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/monitor.h\"\n#include \"magick/monitor-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/property.h\"\n#include \"magick/quantum-private.h\"\n#include \"magick/static.h\"\n#include \"magick/string_.h\"\n#include \"magick/module.h\"\n\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  TGAColormap = 1,\n  TGARGB = 2,\n  TGAMonochrome = 3,\n  TGARLEColormap = 9,\n  TGARLERGB = 10,\n  TGARLEMonochrome = 11\n} TGAImageType;\n\n/*\n  Typedef declaractions.\n*/\ntypedef struct _TGAInfo\n{\n  TGAImageType\n    image_type;\n\n  unsigned char\n    id_length,\n    colormap_type;\n\n  unsigned short\n    colormap_index,\n    colormap_length;\n\n  unsigned char\n    colormap_size;\n\n  unsigned short\n    x_origin,\n    y_origin,\n    width,\n    height;\n\n  unsigned char\n    bits_per_pixel,\n    attributes;\n} TGAInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteTGAImage(const ImageInfo *,Image *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d T G A I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadTGAImage() reads a Truevision TGA image file and returns it.\n%  It allocates the memory necessary for the new Image structure and returns\n%  a pointer to the new image.\n%\n%  The format of the ReadTGAImage method is:\n%\n%      Image *ReadTGAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PixelPacket\n    pixel;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->matte=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  MagickTrue : MagickFalse;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MaxTextExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MaxTextExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  if (tga_info.attributes & (1UL << 4))\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopRight\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomRight\");\n    }\n  else\n    {\n      if (tga_info.attributes & (1UL << 5))\n        SetImageArtifact(image,\"tga:image-origin\",\"TopLeft\");\n      else\n        SetImageArtifact(image,\"tga:image-origin\",\"BottomLeft\");\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.opacity=(Quantum) OpaqueOpacity;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,range);\n            pixel.green=ScaleAnyToQuantum((1UL*(k & 0x03) << 3)+\n              (1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n            pixel.opacity=(Quantum) (QuantumRange-ScaleCharToQuantum(\n              (unsigned char) ReadBlobByte(image)));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=(IndexPacket) 0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(IndexPacket) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                1UL*index)];\n            else\n              {\n                pixel.red=ScaleCharToQuantum((unsigned char) index);\n                pixel.green=ScaleCharToQuantum((unsigned char) index);\n                pixel.blue=ScaleCharToQuantum((unsigned char) index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB;\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,range);\n            pixel.green=ScaleAnyToQuantum((1UL*(k & 0x03) << 3)+\n              (1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->matte != MagickFalse)\n              pixel.opacity=(k & 0x80) == 0 ? (Quantum) TransparentOpacity :\n                (Quantum) OpaqueOpacity;\n            if (image->storage_class == PseudoClass)\n              index=ConstrainColormapIndex(image,((size_t) k << 8)+j);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=ScaleCharToQuantum(pixels[0]);\n            pixel.green=ScaleCharToQuantum(pixels[1]);\n            pixel.red=ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=ScaleCharToQuantum(pixels[0]);\n            pixel.green=ScaleCharToQuantum(pixels[1]);\n            pixel.red=ScaleCharToQuantum(pixels[2]);\n            pixel.opacity=(Quantum) (QuantumRange-ScaleCharToQuantum(\n              pixels[3]));\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(indexes+x,index);\n      SetPixelRed(q,pixel.red);\n      SetPixelGreen(q,pixel.green);\n      SetPixelBlue(q,pixel.blue);\n      if (image->matte != MagickFalse)\n        SetPixelOpacity(q,pixel.opacity);\n      q++;\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r T G A I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterTGAImage() adds properties for the TGA image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterTGAImage method is:\n%\n%      size_t RegisterTGAImage(void)\n%\n*/\nModuleExport size_t RegisterTGAImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=SetMagickInfo(\"ICB\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"TGA\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"VDA\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  entry=SetMagickInfo(\"VST\");\n  entry->decoder=(DecodeImageHandler *) ReadTGAImage;\n  entry->encoder=(EncodeImageHandler *) WriteTGAImage;\n  entry->adjoin=MagickFalse;\n  entry->description=ConstantString(\"Truevision Targa image\");\n  entry->module=ConstantString(\"TGA\");\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r T G A I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterTGAImage() removes format registrations made by the\n%  TGA module from the list of supported formats.\n%\n%  The format of the UnregisterTGAImage method is:\n%\n%      UnregisterTGAImage(void)\n%\n*/\nModuleExport void UnregisterTGAImage(void)\n{\n  (void) UnregisterMagickInfo(\"ICB\");\n  (void) UnregisterMagickInfo(\"TGA\");\n  (void) UnregisterMagickInfo(\"VDA\");\n  (void) UnregisterMagickInfo(\"VST\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e T G A I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteTGAImage() writes a image in the Truevision Targa rasterfile\n%  format.\n%\n%  The format of the WriteTGAImage method is:\n%\n%      MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n*/\nstatic inline void WriteTGAPixel(Image *image,TGAImageType image_type,\n  const IndexPacket *indexes,const PixelPacket *p,const QuantumAny range,\n  const double midpoint)\n{\n  if (image_type == TGAColormap || image_type == TGARLEColormap)\n    (void) WriteBlobByte(image,(unsigned char) GetPixelIndex(indexes));\n  else\n    {\n      if (image_type == TGAMonochrome || image_type == TGARLEMonochrome)\n        (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n          GetPixelLuma(image,p))));\n      else\n        if (image->depth == 5)\n          {\n            unsigned char\n              green,\n              value;\n\n              green=(unsigned char) ScaleQuantumToAny(GetPixelGreen(p),range);\n              value=((unsigned char) ScaleQuantumToAny(GetPixelBlue(p),range)) |\n                ((green & 0x07) << 5);\n              (void) WriteBlobByte(image,value);\n              value=(unsigned char) ((((image->matte != MagickFalse) && \n                ((double) GetPixelOpacity(p) < midpoint)) ? 0x80 : 0) |\n                ((unsigned char) ScaleQuantumToAny(GetPixelRed(p),range) << 2) |\n                ((green & 0x18) >> 3));\n              (void) WriteBlobByte(image,value);\n          }\n        else\n          {\n            (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(p)));\n            (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(p)));\n            if (image->matte != MagickFalse)\n              (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(p)));\n          }\n    }\n}\n\nstatic MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n{\n  CompressionType\n    compression;\n\n  const char\n    *comment,\n    *value;\n\n  const double\n    midpoint = QuantumRange/2.0;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize TGA raster file header.\n  */\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  compression=image->compression;\n  if (image_info->compression != UndefinedCompression)\n    compression=image_info->compression;\n  range=GetQuantumRange(5UL);\n  tga_info.id_length=0;\n  comment=GetImageProperty(image,\"comment\");\n  if (comment != (const char *) NULL)\n    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);\n  tga_info.colormap_type=0;\n  tga_info.colormap_index=0;\n  tga_info.colormap_length=0;\n  tga_info.colormap_size=0;\n  tga_info.x_origin=0;\n  tga_info.y_origin=0;\n  tga_info.width=(unsigned short) image->columns;\n  tga_info.height=(unsigned short) image->rows;\n  tga_info.bits_per_pixel=8;\n  tga_info.attributes=0;\n  if ((image_info->type != TrueColorType) &&\n      (image_info->type != TrueColorMatteType) &&\n      (image_info->type != PaletteType) &&\n      (image->matte == MagickFalse) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    tga_info.image_type=compression == RLECompression ? TGARLEMonochrome :\n      TGAMonochrome;\n  else\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Full color TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLERGB : TGARGB;\n        if (image_info->depth == 5)\n          {\n            tga_info.bits_per_pixel=16;\n            if (image->matte != MagickFalse)\n              tga_info.attributes=1;  /* # of alpha bits */\n          }\n        else\n          {\n            tga_info.bits_per_pixel=24;\n            if (image->matte != MagickFalse)\n              {\n                tga_info.bits_per_pixel=32;\n                tga_info.attributes=8;  /* # of alpha bits */\n              }\n          }\n      }\n    else\n      {\n        /*\n          Colormapped TGA raster.\n        */\n        tga_info.image_type=compression == RLECompression ? TGARLEColormap :\n          TGAColormap;\n        tga_info.colormap_type=1;\n        tga_info.colormap_length=(unsigned short) image->colors;\n        if (image_info->depth == 5)\n          tga_info.colormap_size=16;\n        else\n          tga_info.colormap_size=24;\n      }\n  value=GetImageArtifact(image,\"tga:image-origin\");\n  if (value != (const char *) NULL)\n    {\n      OrientationType\n        origin;\n\n      origin=(OrientationType) ParseCommandOption(MagickOrientationOptions,\n        MagickFalse,value);\n      if (origin == BottomRightOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 4);\n      if (origin == TopLeftOrientation || origin == TopRightOrientation)\n        tga_info.attributes|=(1UL << 5);\n    }\n  /*\n    Write TGA header.\n  */\n  (void) WriteBlobByte(image,tga_info.id_length);\n  (void) WriteBlobByte(image,tga_info.colormap_type);\n  (void) WriteBlobByte(image,(unsigned char) tga_info.image_type);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_index);\n  (void) WriteBlobLSBShort(image,tga_info.colormap_length);\n  (void) WriteBlobByte(image,tga_info.colormap_size);\n  (void) WriteBlobLSBShort(image,tga_info.x_origin);\n  (void) WriteBlobLSBShort(image,tga_info.y_origin);\n  (void) WriteBlobLSBShort(image,tga_info.width);\n  (void) WriteBlobLSBShort(image,tga_info.height);\n  (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n  (void) WriteBlobByte(image,tga_info.attributes);\n  if (tga_info.id_length != 0)\n    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);\n  if (tga_info.colormap_type != 0)\n    {\n      unsigned char\n        green,\n        *targa_colormap;\n\n      /*\n        Dump colormap to file (blue, green, red byte order).\n      */\n      targa_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n        tga_info.colormap_length,(tga_info.colormap_size/8)*sizeof(\n        *targa_colormap));\n      if (targa_colormap == (unsigned char *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      q=targa_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if (image_info->depth == 5)\n          {\n            green=(unsigned char) ScaleQuantumToAny(image->colormap[i].green,\n              range);\n            *q++=((unsigned char) ScaleQuantumToAny(image->colormap[i].blue,\n              range)) | ((green & 0x07) << 5);\n            *q++=(((image->matte != MagickFalse) && (\n              (double) image->colormap[i].opacity < midpoint)) ? 0x80 : 0) |\n              ((unsigned char) ScaleQuantumToAny(image->colormap[i].red,\n              range) << 2) | ((green & 0x18) >> 3);\n          }\n        else\n          {\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          }\n      }\n      (void) WriteBlob(image,(size_t) ((tga_info.colormap_size/8)*\n        tga_info.colormap_length),targa_colormap);\n      targa_colormap=(unsigned char *) RelinquishMagickMemory(targa_colormap);\n    }\n  /*\n    Convert MIFF to TGA raster pixels.\n  */\n  for (y=(ssize_t) (image->rows-1); y >= 0; y--)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    if (compression == RLECompression)\n      {\n        x=0;\n        count=0;\n        while (x < (ssize_t) image->columns)\n        {\n          i=1;\n          while ((i < 128) && (count + i < 128) &&\n                 ((x + i) < (ssize_t) image->columns))\n          {\n            if (tga_info.image_type == TGARLEColormap)\n              {\n                if (GetPixelIndex(indexes+i) != GetPixelIndex(indexes+(i-1)))\n                  break;\n              }\n            else\n              if (tga_info.image_type == TGARLEMonochrome)\n                {\n                  if (GetPixelLuma(image,p+i) != GetPixelLuma(image,p+(i-1)))\n                    break;\n                }\n              else\n                {\n                  if ((GetPixelBlue(p+i) != GetPixelBlue(p+(i-1))) ||\n                      (GetPixelGreen(p+i) != GetPixelGreen(p+(i-1))) ||\n                      (GetPixelRed(p+i) != GetPixelRed(p+(i-1))))\n                    break;\n                  if ((image->matte != MagickFalse) &&\n                      (GetPixelAlpha(p+i) != GetPixelAlpha(p+(i-1))))\n                    break;\n                }\n            i++;\n          }\n          if (i < 3)\n            {\n              count+=i;\n              p+=i;\n              indexes+=i;\n            }\n          if ((i >= 3) || (count == 128) ||\n              ((x + i) == (ssize_t) image->columns))\n            {\n              if (count > 0)\n                {\n                  (void) WriteBlobByte(image,(unsigned char) (--count));\n                  while (count >= 0)\n                  {\n                    WriteTGAPixel(image,tga_info.image_type,indexes-(count+1),\n                      p-(count+1),range,midpoint);\n                    count--;\n                  }\n                  count=0;\n                }\n            }\n          if (i >= 3)\n            {\n              (void) WriteBlobByte(image,(unsigned char) ((i-1) | 0x80));\n              WriteTGAPixel(image,tga_info.image_type,indexes,p,range,midpoint);\n              p+=i;\n              indexes+=i;\n            }\n          x+=i;\n        }\n      }\n    else\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n          WriteTGAPixel(image,tga_info.image_type,indexes+x,p++,range,midpoint);\n      }\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/tga.c"], "buggy_code_start_loc": [718], "buggy_code_end_loc": [862], "fixing_code_start_loc": [719], "fixing_code_end_loc": [863], "type": "CWE-20", "message": "An issue was discovered in ImageMagick 6.9.7. Incorrect TGA files could trigger assertion failures, thus leading to DoS.", "other": {"cve": {"id": "CVE-2017-6498", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-06T02:59:00.557", "lastModified": "2019-03-13T13:48:25.033", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in ImageMagick 6.9.7. Incorrect TGA files could trigger assertion failures, thus leading to DoS."}, {"lang": "es", "value": "Ha sido descubierto un problema en ImageMagick 6.9.7.. Archivos TGA incorrectos podr\u00edan desencadenar fallos de aserci\u00f3n, lo que conducir\u00eda a DoS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:6.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "E5CFF56F-ED8D-4546-AD6C-47F9CC215B28"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3808", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96591", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/856878", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/65f75a32a93ae4044c528a987a68366ecd4b46b9", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/pull/359", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/65f75a32a93ae4044c528a987a68366ecd4b46b9"}}