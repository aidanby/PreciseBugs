{"buggy_code": ["/*\n * Copyright 2004 Richard Wilson <richard.wilson@netsurf-browser.org>\n * Copyright 2008 Sean Fox <dyntryx@gmail.com>\n *\n * This file is part of NetSurf's libnsgif, http://www.netsurf-browser.org/\n * Licenced under the MIT License,\n *                http://www.opensource.org/licenses/mit-license.php\n */\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"libnsgif.h\"\n#include \"log.h\"\n\n#include \"lzw.h\"\n\n/**\n *\n * \\file\n * \\brief GIF image decoder\n *\n * The GIF format is thoroughly documented; a full description can be found at\n * http://www.w3.org/Graphics/GIF/spec-gif89a.txt\n *\n * \\todo Plain text and comment extensions should be implemented.\n */\n\n\n/** Maximum colour table size */\n#define GIF_MAX_COLOURS 256\n\n/** Internal flag that the colour table needs to be processed */\n#define GIF_PROCESS_COLOURS 0xaa000000\n\n/** Internal flag that a frame is invalid/unprocessed */\n#define GIF_INVALID_FRAME -1\n\n/** Transparent colour */\n#define GIF_TRANSPARENT_COLOUR 0x00\n\n/* GIF Flags */\n#define GIF_FRAME_COMBINE 1\n#define GIF_FRAME_CLEAR 2\n#define GIF_FRAME_RESTORE 3\n#define GIF_FRAME_QUIRKS_RESTORE 4\n\n#define GIF_IMAGE_SEPARATOR 0x2c\n#define GIF_INTERLACE_MASK 0x40\n#define GIF_COLOUR_TABLE_MASK 0x80\n#define GIF_COLOUR_TABLE_SIZE_MASK 0x07\n#define GIF_EXTENSION_INTRODUCER 0x21\n#define GIF_EXTENSION_GRAPHIC_CONTROL 0xf9\n#define GIF_DISPOSAL_MASK 0x1c\n#define GIF_TRANSPARENCY_MASK 0x01\n#define GIF_EXTENSION_COMMENT 0xfe\n#define GIF_EXTENSION_PLAIN_TEXT 0x01\n#define GIF_EXTENSION_APPLICATION 0xff\n#define GIF_BLOCK_TERMINATOR 0x00\n#define GIF_TRAILER 0x3b\n\n/** standard GIF header size */\n#define GIF_STANDARD_HEADER_SIZE 13\n\n\n/**\n * Updates the sprite memory size\n *\n * \\param gif The animation context\n * \\param width The width of the sprite\n * \\param height The height of the sprite\n * \\return GIF_INSUFFICIENT_MEMORY for a memory error GIF_OK for success\n */\nstatic gif_result\ngif_initialise_sprite(gif_animation *gif,\n                      unsigned int width,\n                      unsigned int height)\n{\n        unsigned int max_width;\n        unsigned int max_height;\n        struct bitmap *buffer;\n\n        /* Check if we've changed */\n        if ((width <= gif->width) && (height <= gif->height)) {\n                return GIF_OK;\n        }\n\n        /* Get our maximum values */\n        max_width = (width > gif->width) ? width : gif->width;\n        max_height = (height > gif->height) ? height : gif->height;\n\n        /* Allocate some more memory */\n        assert(gif->bitmap_callbacks.bitmap_create);\n        buffer = gif->bitmap_callbacks.bitmap_create(max_width, max_height);\n        if (buffer == NULL) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        assert(gif->bitmap_callbacks.bitmap_destroy);\n        gif->bitmap_callbacks.bitmap_destroy(gif->frame_image);\n        gif->frame_image = buffer;\n        gif->width = max_width;\n        gif->height = max_height;\n\n        /* Invalidate our currently decoded image */\n        gif->decoded_frame = GIF_INVALID_FRAME;\n        return GIF_OK;\n}\n\n\n/**\n * Attempts to initialise the frame's extensions\n *\n * \\param gif The animation context\n * \\param frame The frame number\n * @return GIF_INSUFFICIENT_FRAME_DATA for insufficient data to complete the\n *         frame GIF_OK for successful initialisation.\n */\nstatic gif_result\ngif_initialise_frame_extensions(gif_animation *gif, const int frame)\n{\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        ssize_t block_size;\n\n        /* Get our buffer position etc.\t*/\n        gif_data = (const unsigned char *)(gif->gif_data + gif->buffer_position);\n        gif_end = (const unsigned char *)(gif->gif_data + gif->buffer_size);\n\n        /* Initialise the extensions */\n        while (gif_data < gif_end && gif_data[0] == GIF_EXTENSION_INTRODUCER) {\n                ++gif_data;\n                if ((gif_bytes = (gif_end - gif_data)) < 1) {\n                        return GIF_INSUFFICIENT_FRAME_DATA;\n                }\n\n                /* Switch on extension label */\n                switch (gif_data[0]) {\n                case GIF_EXTENSION_GRAPHIC_CONTROL:\n                        /* 6-byte Graphic Control Extension is:\n                         *\n                         *\t+0\tCHAR\tGraphic Control Label\n                         *\t+1\tCHAR\tBlock Size\n                         *\t+2\tCHAR\t__Packed Fields__\n                         *\t\t\t3BITS\tReserved\n                         *\t\t\t3BITS\tDisposal Method\n                         *\t\t\t1BIT\tUser Input Flag\n                         *\t\t\t1BIT\tTransparent Color Flag\n                         *\t+3\tSHORT\tDelay Time\n                         *\t+5\tCHAR\tTransparent Color Index\n                         */\n                        if (gif_bytes < 6) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n\n                        gif->frames[frame].frame_delay = gif_data[3] | (gif_data[4] << 8);\n                        if (gif_data[2] & GIF_TRANSPARENCY_MASK) {\n                                gif->frames[frame].transparency = true;\n                                gif->frames[frame].transparency_index = gif_data[5];\n                        }\n                        gif->frames[frame].disposal_method = ((gif_data[2] & GIF_DISPOSAL_MASK) >> 2);\n                        /* I have encountered documentation and GIFs in the\n                         * wild that use 0x04 to restore the previous frame,\n                         * rather than the officially documented 0x03.  I\n                         * believe some (older?)  software may even actually\n                         * export this way.  We handle this as a type of\n                         * \"quirks\" mode.\n                         */\n                        if (gif->frames[frame].disposal_method == GIF_FRAME_QUIRKS_RESTORE) {\n                                gif->frames[frame].disposal_method = GIF_FRAME_RESTORE;\n                        }\n                        gif_data += (2 + gif_data[1]);\n                        break;\n\n                case GIF_EXTENSION_APPLICATION:\n                        /* 14-byte+ Application Extension is:\n                         *\n                         *\t+0    CHAR    Application Extension Label\n                         *\t+1    CHAR    Block Size\n                         *\t+2    8CHARS  Application Identifier\n                         *\t+10   3CHARS  Appl. Authentication Code\n                         *\t+13   1-256   Application Data (Data sub-blocks)\n                         */\n                        if (gif_bytes < 17) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        if ((gif_data[1] == 0x0b) &&\n                            (strncmp((const char *) gif_data + 2,\n                                     \"NETSCAPE2.0\", 11) == 0) &&\n                            (gif_data[13] == 0x03) &&\n                            (gif_data[14] == 0x01)) {\n                                gif->loop_count = gif_data[15] | (gif_data[16] << 8);\n                        }\n                        gif_data += (2 + gif_data[1]);\n                        break;\n\n                case GIF_EXTENSION_COMMENT:\n                        /* Move the pointer to the first data sub-block Skip 1\n                         * byte for the extension label\n                         */\n                        ++gif_data;\n                        break;\n\n                default:\n                        /* Move the pointer to the first data sub-block Skip 2\n                         * bytes for the extension label and size fields Skip\n                         * the extension size itself\n                         */\n                        if (gif_bytes < 2) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += (2 + gif_data[1]);\n                }\n\n                /* Repeatedly skip blocks until we get a zero block or run out\n                 * of data This data is ignored by this gif decoder\n                 */\n                gif_bytes = (gif_end - gif_data);\n                block_size = 0;\n                while (gif_data < gif_end && gif_data[0] != GIF_BLOCK_TERMINATOR) {\n                        block_size = gif_data[0] + 1;\n                        if ((gif_bytes -= block_size) < 0) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += block_size;\n                }\n                ++gif_data;\n        }\n\n        /* Set buffer position and return */\n        gif->buffer_position = (gif_data - gif->gif_data);\n        return GIF_OK;\n}\n\n\n/**\n * Attempts to initialise the next frame\n *\n * \\param gif The animation context\n * \\return error code\n *         - GIF_INSUFFICIENT_DATA for insufficient data to do anything\n *         - GIF_FRAME_DATA_ERROR for GIF frame data error\n *         - GIF_INSUFFICIENT_MEMORY for insufficient memory to process\n *         - GIF_INSUFFICIENT_FRAME_DATA for insufficient data to complete the frame\n *         - GIF_DATA_ERROR for GIF error (invalid frame header)\n *         - GIF_OK for successful decoding\n *         - GIF_WORKING for successful decoding if more frames are expected\n*/\nstatic gif_result gif_initialise_frame(gif_animation *gif)\n{\n        int frame;\n        gif_frame *temp_buf;\n\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int flags = 0;\n        unsigned int width, height, offset_x, offset_y;\n        ssize_t block_size, colour_table_size;\n        bool first_image = true;\n        gif_result return_value;\n        bool premature_eof = false;\n\n        /* Get the frame to decode and our data position */\n        frame = gif->frame_count;\n\n        /* Get our buffer position etc. */\n        gif_data = (const unsigned char *)(gif->gif_data + gif->buffer_position);\n        gif_end = (const unsigned char *)(gif->gif_data + gif->buffer_size);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Check if we've finished */\n        if ((gif_bytes > 0) && (gif_data[0] == GIF_TRAILER)) {\n                return GIF_OK;\n        }\n\n        /* Check if there is enough data remaining. The shortest block of data\n         * is a 4-byte comment extension + 1-byte block terminator + 1-byte gif\n         * trailer\n         */\n        if (gif_bytes < 6) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* We could theoretically get some junk data that gives us millions of\n         * frames, so we ensure that we don't have a silly number\n         */\n        if (frame > 262143)\n                return GIF_FRAME_DATA_ERROR;\n\n        /* Get some memory to store our pointers in etc. */\n        if ((int)gif->frame_holders <= frame) {\n                /* Allocate more memory */\n                temp_buf = (gif_frame *)realloc(gif->frames, (frame + 1) * sizeof(gif_frame));\n                if (temp_buf == NULL) {\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n                gif->frames = temp_buf;\n                gif->frame_holders = frame + 1;\n        }\n\n        /* Store our frame pointer. We would do it when allocating except we\n         * start off with one frame allocated so we can always use realloc.\n         */\n        gif->frames[frame].frame_pointer = gif->buffer_position;\n        gif->frames[frame].display = false;\n        gif->frames[frame].virgin = true;\n        gif->frames[frame].disposal_method = 0;\n        gif->frames[frame].transparency = false;\n        gif->frames[frame].frame_delay = 0;\n        gif->frames[frame].redraw_required = false;\n\n        /* Invalidate any previous decoding we have of this frame */\n        if (gif->decoded_frame == frame) {\n                gif->decoded_frame = GIF_INVALID_FRAME;\n        }\n\n        /* We pretend to initialise the frames, but really we just skip over\n         * all the data contained within. This is all basically a cut down\n         * version of gif_decode_frame that doesn't have any of the LZW bits in\n         * it.\n         */\n\n        /* Initialise any extensions */\n        gif->buffer_position = gif_data - gif->gif_data;\n        return_value = gif_initialise_frame_extensions(gif, frame);\n        if (return_value != GIF_OK) {\n                return return_value;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Check if we've finished */\n        if ((gif_bytes = (gif_end - gif_data)) < 1) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        if (gif_data[0] == GIF_TRAILER) {\n                gif->buffer_position = (gif_data - gif->gif_data);\n                gif->frame_count = frame + 1;\n                return GIF_OK;\n        }\n\n        /* If we're not done, there should be an image descriptor */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return GIF_FRAME_DATA_ERROR;\n        }\n\n        /* Do some simple boundary checking */\n        if (gif_bytes < 10) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Set up the redraw characteristics. We have to check for extending\n         * the area due to multi-image frames.\n         */\n        if (!first_image) {\n                if (gif->frames[frame].redraw_x > offset_x) {\n                        gif->frames[frame].redraw_width += (gif->frames[frame].redraw_x - offset_x);\n                        gif->frames[frame].redraw_x = offset_x;\n                }\n\n                if (gif->frames[frame].redraw_y > offset_y) {\n                        gif->frames[frame].redraw_height += (gif->frames[frame].redraw_y - offset_y);\n                        gif->frames[frame].redraw_y = offset_y;\n                }\n\n                if ((offset_x + width) > (gif->frames[frame].redraw_x + gif->frames[frame].redraw_width)) {\n                        gif->frames[frame].redraw_width = (offset_x + width) - gif->frames[frame].redraw_x;\n                }\n\n                if ((offset_y + height) > (gif->frames[frame].redraw_y + gif->frames[frame].redraw_height)) {\n                        gif->frames[frame].redraw_height = (offset_y + height) - gif->frames[frame].redraw_y;\n                }\n        } else {\n                first_image = false;\n                gif->frames[frame].redraw_x = offset_x;\n                gif->frames[frame].redraw_y = offset_y;\n                gif->frames[frame].redraw_width = width;\n                gif->frames[frame].redraw_height = height;\n        }\n\n        /* if we are clearing the background then we need to redraw enough to\n         * cover the previous frame too\n         */\n        gif->frames[frame].redraw_required = ((gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) ||\n                                                (gif->frames[frame].disposal_method == GIF_FRAME_RESTORE));\n\n        /* Boundary checking - shouldn't ever happen except with junk data */\n        if (gif_initialise_sprite(gif, (offset_x + width), (offset_y + height))) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n\n        /* Move our data onwards and remember we've got a bit of this frame */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n        gif->frame_count_partial = frame + 1;\n\n        /* Skip the local colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                gif_data += 3 * colour_table_size;\n                if ((gif_bytes = (gif_end - gif_data)) < 0) {\n                        return GIF_INSUFFICIENT_FRAME_DATA;\n                }\n        }\n\n        /* Ensure we have a correct code size */\n        if (gif_bytes < 1) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n        if (gif_data[0] > LZW_CODE_MAX) {\n                return GIF_DATA_ERROR;\n        }\n\n        /* Move our pointer to the actual image data */\n        gif_data++;\n        --gif_bytes;\n\n        /* Repeatedly skip blocks until we get a zero block or run out of data\n         * These blocks of image data are processed later by gif_decode_frame()\n         */\n        block_size = 0;\n        while (block_size != 1) {\n                if (gif_bytes < 1) return GIF_INSUFFICIENT_FRAME_DATA;\n                block_size = gif_data[0] + 1;\n                /* Check if the frame data runs off the end of the file\t*/\n                if ((ssize_t)(gif_bytes - block_size) < 0) {\n                        /* Try to recover by signaling the end of the gif.\n                         * Once we get garbage data, there is no logical way to\n                         * determine where the next frame is.  It's probably\n                         * better to partially load the gif than not at all.\n                         */\n                        if (gif_bytes >= 2) {\n                                gif_bytes = 1;\n                                ++gif_data;\n                                premature_eof = true;\n                                break;\n                        } else {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                } else {\n                        gif_bytes -= block_size;\n                        gif_data += block_size;\n                }\n        }\n\n        /* Add the frame and set the display flag */\n        gif->buffer_position = gif_data - gif->gif_data;\n        gif->frame_count = frame + 1;\n        gif->frames[frame].display = true;\n\n        /* Check if we've finished */\n        if (gif_bytes < 1) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        } else {\n                if (premature_eof || gif_data[0] == GIF_TRAILER) {\n                        return GIF_OK;\n                }\n        }\n        return GIF_WORKING;\n}\n\n\n\n\n/**\n * Skips the frame's extensions (which have been previously initialised)\n *\n * \\param gif The animation context\n * \\return GIF_INSUFFICIENT_FRAME_DATA for insufficient data to complete the\n *         frame GIF_OK for successful decoding\n */\nstatic gif_result gif_skip_frame_extensions(gif_animation *gif)\n{\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        ssize_t block_size;\n\n        /* Get our buffer position etc.\t*/\n        gif_data = (const unsigned char *)(gif->gif_data + gif->buffer_position);\n        gif_end = (const unsigned char *)(gif->gif_data + gif->buffer_size);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Skip the extensions */\n        while (gif_data < gif_end && gif_data[0] == GIF_EXTENSION_INTRODUCER) {\n                ++gif_data;\n                if (gif_data >= gif_end) {\n                        return GIF_INSUFFICIENT_FRAME_DATA;\n                }\n\n                /* Switch on extension label */\n                switch(gif_data[0]) {\n                case GIF_EXTENSION_COMMENT:\n                        /* Move the pointer to the first data sub-block\n                         * 1 byte for the extension label\n                         */\n                        ++gif_data;\n                        break;\n\n                default:\n                        /* Move the pointer to the first data sub-block 2 bytes\n                         * for the extension label and size fields Skip the\n                         * extension size itself\n                         */\n                        if (gif_data + 1 >= gif_end) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += (2 + gif_data[1]);\n                }\n\n                /* Repeatedly skip blocks until we get a zero block or run out\n                 * of data This data is ignored by this gif decoder\n                 */\n                gif_bytes = (gif_end - gif_data);\n                block_size = 0;\n                while (gif_data < gif_end && gif_data[0] != GIF_BLOCK_TERMINATOR) {\n                        block_size = gif_data[0] + 1;\n                        if ((gif_bytes -= block_size) < 0) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += block_size;\n                }\n                ++gif_data;\n        }\n\n        /* Set buffer position and return */\n        gif->buffer_position = (gif_data - gif->gif_data);\n        return GIF_OK;\n}\n\nstatic unsigned int gif_interlaced_line(int height, int y) {\n        if ((y << 3) < height) {\n                return (y << 3);\n        }\n        y -= ((height + 7) >> 3);\n        if ((y << 3) < (height - 4)) {\n                return (y << 3) + 4;\n        }\n        y -= ((height + 3) >> 3);\n        if ((y << 2) < (height - 2)) {\n                return (y << 2) + 2;\n        }\n        y -= ((height + 1) >> 2);\n        return (y << 1) + 1;\n}\n\n\nstatic gif_result gif_error_from_lzw(lzw_result l_res)\n{\n        static const gif_result g_res[] = {\n                [LZW_OK]        = GIF_OK,\n                [LZW_OK_EOD]    = GIF_END_OF_FRAME,\n                [LZW_NO_MEM]    = GIF_INSUFFICIENT_MEMORY,\n                [LZW_NO_DATA]   = GIF_INSUFFICIENT_FRAME_DATA,\n                [LZW_EOI_CODE]  = GIF_FRAME_DATA_ERROR,\n                [LZW_BAD_ICODE] = GIF_FRAME_DATA_ERROR,\n                [LZW_BAD_CODE]  = GIF_FRAME_DATA_ERROR,\n        };\n        return g_res[l_res];\n}\n\n\n/**\n * decode a gif frame\n *\n * \\param gif gif animation context.\n * \\param frame The frame number to decode.\n * \\param clear_image flag for image data being cleared instead of plotted.\n */\nstatic gif_result\ngif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure the frame is in range to decode */\n        if (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data to proceed.  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking - shouldn't ever happen except unless the data has\n         * been modified since initialisation.\n         */\n        if ((offset_x + width > gif->width) ||\n            (offset_y + height > gif->height)) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer to next block either colour table or image\n         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n                colour_table = gif->local_colour_table;\n                if (!clear_image) {\n                        for (index = 0; index < colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry =\n                                        (unsigned char *) &colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                } else {\n                        gif_data += 3 * colour_table_size;\n                }\n                gif_bytes = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* check for an end marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* If we are clearing the image we just clear, if not decode */\n        if (!clear_image) {\n                lzw_result res;\n                const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\n                /* Ensure we have enough data for a 1-byte LZW code size +\n                 * 1-byte gif trailer\n                 */\n                if (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n                 * we're finished\n                 */\n                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value = GIF_OK;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If the previous frame's disposal method requires we restore\n                 * the background colour or this is the first frame, clear\n                 * the frame data\n                 */\n                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                        memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n                               gif->width * gif->height * sizeof(int));\n                        gif->decoded_frame = frame;\n                        /* The line below would fill the image with its\n                         * background color, but because GIFs support\n                         * transparency we likely wouldn't want to do that. */\n                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value = gif_internal_decode_frame(gif,\n                                                                 (frame - 1),\n                                                                 true);\n                        if (return_value != GIF_OK) {\n                                goto gif_decode_frame_exit;\n                        }\n\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                        /*\n                         * If the previous frame's disposal method requires we\n                         * restore the previous image, find the last image set\n                         * to \"do not dispose\" and get that frame data\n                         */\n                        int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n                        }\n\n                        /* If we don't find one, clear the frame data */\n                        if (last_undisposed_frame == -1) {\n                                /* see notes above on transparency\n                                 * vs. background color\n                                 */\n                                memset((char*)frame_data,\n                                       GIF_TRANSPARENT_COLOUR,\n                                       gif->width * gif->height * sizeof(int));\n                        } else {\n                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                if (return_value != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n                                }\n                                /* Get this frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                if (!frame_data) {\n                                        return GIF_INSUFFICIENT_MEMORY;\n                                }\n                        }\n                }\n                gif->decoded_frame = frame;\n                gif->buffer_position = (gif_data - gif->gif_data) + 1;\n\n                /* Initialise the LZW decoding */\n                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                gif->buffer_size, gif->buffer_position,\n                                gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n\n                /* Decompress the data */\n                for (y = 0; y < height; y++) {\n                        if (interlace) {\n                                decode_y = gif_interlaced_line(height, y) + offset_y;\n                        } else {\n                                decode_y = y + offset_y;\n                        }\n                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n\n                        /* Rather than decoding pixel by pixel, we try to burst\n                         * out streams of data to remove the need for end-of\n                         * data checks every pixel.\n                         */\n                        x = width;\n                        while (x > 0) {\n                                burst_bytes = (stack_pos - stack_base);\n                                if (burst_bytes > 0) {\n                                        if (burst_bytes > x) {\n                                                burst_bytes = x;\n                                        }\n                                        x -= burst_bytes;\n                                        while (burst_bytes-- > 0) {\n                                                colour = *--stack_pos;\n                                                if (((gif->frames[frame].transparency) &&\n                                                     (colour != gif->frames[frame].transparency_index)) ||\n                                                    (!gif->frames[frame].transparency)) {\n                                                        *frame_scanline = colour_table[colour];\n                                                }\n                                                frame_scanline++;\n                                        }\n                                } else {\n                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                        if (res != LZW_OK) {\n                                                /* Unexpected end of frame, try to recover */\n                                                if (res == LZW_OK_EOD) {\n                                                        return_value = GIF_OK;\n                                                } else {\n                                                        return_value = gif_error_from_lzw(res);\n                                                }\n                                                goto gif_decode_frame_exit;\n                                        }\n                                }\n                        }\n                }\n        } else {\n                /* Clear our frame */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                        for (y = 0; y < height; y++) {\n                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                if (gif->frames[frame].transparency) {\n                                        memset(frame_scanline,\n                                               GIF_TRANSPARENT_COLOUR,\n                                               width * 4);\n                                } else {\n                                        memset(frame_scanline,\n                                               colour_table[gif->background_index],\n                                               width * 4);\n                                }\n                        }\n                }\n        }\ngif_decode_frame_exit:\n\n        /* Check if we should test for optimisation */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                } else {\n                        gif->frames[frame].opaque = false;\n                }\n                gif->frames[frame].virgin = false;\n        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\n        return return_value;\n}\n\n\n/* exported function documented in libnsgif.h */\nvoid gif_create(gif_animation *gif, gif_bitmap_callback_vt *bitmap_callbacks)\n{\n        memset(gif, 0, sizeof(gif_animation));\n        gif->bitmap_callbacks = *bitmap_callbacks;\n        gif->decoded_frame = GIF_INVALID_FRAME;\n}\n\n\n/* exported function documented in libnsgif.h */\ngif_result gif_initialise(gif_animation *gif, size_t size, unsigned char *data)\n{\n        const unsigned char *gif_data;\n        unsigned int index;\n        gif_result return_value;\n\n        /* Initialize values */\n        gif->buffer_size = size;\n        gif->gif_data = data;\n\n        if (gif->lzw_ctx == NULL) {\n                lzw_result res = lzw_context_create(\n                                (struct lzw_ctx **)&gif->lzw_ctx);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n        }\n\n        /* Check for sufficient data to be a GIF (6-byte header + 7-byte\n         * logical screen descriptor)\n         */\n        if (gif->buffer_size < GIF_STANDARD_HEADER_SIZE) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Get our current processing position */\n        gif_data = gif->gif_data + gif->buffer_position;\n\n        /* See if we should initialise the GIF */\n        if (gif->buffer_position == 0) {\n                /* We want everything to be NULL before we start so we've no\n                 * chance of freeing bad pointers (paranoia)\n                 */\n                gif->frame_image = NULL;\n                gif->frames = NULL;\n                gif->local_colour_table = NULL;\n                gif->global_colour_table = NULL;\n\n                /* The caller may have been lazy and not reset any values */\n                gif->frame_count = 0;\n                gif->frame_count_partial = 0;\n                gif->decoded_frame = GIF_INVALID_FRAME;\n\n                /* 6-byte GIF file header is:\n                 *\n                 *\t+0\t3CHARS\tSignature ('GIF')\n                 *\t+3\t3CHARS\tVersion ('87a' or '89a')\n                 */\n                if (strncmp((const char *) gif_data, \"GIF\", 3) != 0) {\n                        return GIF_DATA_ERROR;\n                }\n                gif_data += 3;\n\n                /* Ensure GIF reports version 87a or 89a */\n                /*\n                if ((strncmp(gif_data, \"87a\", 3) != 0) &&\n                    (strncmp(gif_data, \"89a\", 3) != 0))\n                               LOG((\"Unknown GIF format - proceeding anyway\"));\n                */\n                gif_data += 3;\n\n                /* 7-byte Logical Screen Descriptor is:\n                 *\n                 *\t+0\tSHORT\tLogical Screen Width\n                 *\t+2\tSHORT\tLogical Screen Height\n                 *\t+4\tCHAR\t__Packed Fields__\n                 *                      1BIT\tGlobal Colour Table Flag\n                 *                      3BITS\tColour Resolution\n                 *                      1BIT\tSort Flag\n                 *                      3BITS\tSize of Global Colour Table\n                 *\t+5\tCHAR\tBackground Colour Index\n                 *\t+6\tCHAR\tPixel Aspect Ratio\n                 */\n                gif->width = gif_data[0] | (gif_data[1] << 8);\n                gif->height = gif_data[2] | (gif_data[3] << 8);\n                gif->global_colours = (gif_data[4] & GIF_COLOUR_TABLE_MASK);\n                gif->colour_table_size = (2 << (gif_data[4] & GIF_COLOUR_TABLE_SIZE_MASK));\n                gif->background_index = gif_data[5];\n                gif->aspect_ratio = gif_data[6];\n                gif->loop_count = 1;\n                gif_data += 7;\n\n                /* Some broken GIFs report the size as the screen size they\n                 * were created in. As such, we detect for the common cases and\n                 * set the sizes as 0 if they are found which results in the\n                 * GIF being the maximum size of the frames.\n                 */\n                if (((gif->width == 640) && (gif->height == 480)) ||\n                    ((gif->width == 640) && (gif->height == 512)) ||\n                    ((gif->width == 800) && (gif->height == 600)) ||\n                    ((gif->width == 1024) && (gif->height == 768)) ||\n                    ((gif->width == 1280) && (gif->height == 1024)) ||\n                    ((gif->width == 1600) && (gif->height == 1200)) ||\n                    ((gif->width == 0) || (gif->height == 0)) ||\n                    ((gif->width > 2048) || (gif->height > 2048))) {\n                        gif->width = 1;\n                        gif->height = 1;\n                }\n\n                /* Allocate some data irrespective of whether we've got any\n                 * colour tables. We always get the maximum size in case a GIF\n                 * is lying to us. It's far better to give the wrong colours\n                 * than to trample over some memory somewhere.\n                */\n                gif->global_colour_table = calloc(GIF_MAX_COLOURS, sizeof(unsigned int));\n                gif->local_colour_table = calloc(GIF_MAX_COLOURS, sizeof(unsigned int));\n                if ((gif->global_colour_table == NULL) ||\n                    (gif->local_colour_table == NULL)) {\n                        gif_finalise(gif);\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n\n                /* Set the first colour to a value that will never occur in\n                 * reality so we know if we've processed it\n                */\n                gif->global_colour_table[0] = GIF_PROCESS_COLOURS;\n\n                /* Check if the GIF has no frame data (13-byte header + 1-byte\n                 * termination block) Although generally useless, the GIF\n                 * specification does not expressly prohibit this\n                 */\n                if (gif->buffer_size == (GIF_STANDARD_HEADER_SIZE + 1)) {\n                        if (gif_data[0] == GIF_TRAILER) {\n                                return GIF_OK;\n                        } else {\n                                return GIF_INSUFFICIENT_DATA;\n                        }\n                }\n\n                /* Initialise enough workspace for a frame */\n                if ((gif->frames = (gif_frame *)malloc(sizeof(gif_frame))) == NULL) {\n                        gif_finalise(gif);\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n                gif->frame_holders = 1;\n\n                /* Initialise the bitmap header */\n                assert(gif->bitmap_callbacks.bitmap_create);\n                gif->frame_image = gif->bitmap_callbacks.bitmap_create(gif->width, gif->height);\n                if (gif->frame_image == NULL) {\n                        gif_finalise(gif);\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n\n                /* Remember we've done this now */\n                gif->buffer_position = gif_data - gif->gif_data;\n        }\n\n        /*  Do the colour map if we haven't already. As the top byte is always\n         *  0xff or 0x00 depending on the transparency we know if it's been\n         *  filled in.\n         */\n        if (gif->global_colour_table[0] == GIF_PROCESS_COLOURS) {\n                /* Check for a global colour map signified by bit 7 */\n                if (gif->global_colours) {\n                        if (gif->buffer_size < (gif->colour_table_size * 3 + GIF_STANDARD_HEADER_SIZE)) {\n                                return GIF_INSUFFICIENT_DATA;\n                        }\n                        for (index = 0; index < gif->colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry = (unsigned char *) &gif->\n                                                       global_colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                        gif->buffer_position = (gif_data - gif->gif_data);\n                } else {\n                        /* Create a default colour table with the first two\n                         * colours as black and white\n                         */\n                        unsigned int *entry = gif->global_colour_table;\n\n                        entry[0] = 0x00000000;\n                        /* Force Alpha channel to opaque */\n                        ((unsigned char *) entry)[3] = 0xff;\n\n                        entry[1] = 0xffffffff;\n                }\n        }\n\n        /* Repeatedly try to initialise frames */\n        while ((return_value = gif_initialise_frame(gif)) == GIF_WORKING);\n\n        /* If there was a memory error tell the caller */\n        if ((return_value == GIF_INSUFFICIENT_MEMORY) ||\n            (return_value == GIF_DATA_ERROR)) {\n                return return_value;\n        }\n\n        /* If we didn't have some frames then a GIF_INSUFFICIENT_DATA becomes a\n         * GIF_INSUFFICIENT_FRAME_DATA\n         */\n        if ((return_value == GIF_INSUFFICIENT_DATA) &&\n            (gif->frame_count_partial > 0)) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Return how many we got */\n        return return_value;\n}\n\n\n/* exported function documented in libnsgif.h */\ngif_result gif_decode_frame(gif_animation *gif, unsigned int frame)\n{\n        return gif_internal_decode_frame(gif, frame, false);\n}\n\n\n/* exported function documented in libnsgif.h */\nvoid gif_finalise(gif_animation *gif)\n{\n        /* Release all our memory blocks */\n        if (gif->frame_image) {\n                assert(gif->bitmap_callbacks.bitmap_destroy);\n                gif->bitmap_callbacks.bitmap_destroy(gif->frame_image);\n        }\n\n        gif->frame_image = NULL;\n        free(gif->frames);\n        gif->frames = NULL;\n        free(gif->local_colour_table);\n        gif->local_colour_table = NULL;\n        free(gif->global_colour_table);\n        gif->global_colour_table = NULL;\n\n        lzw_context_destroy(gif->lzw_ctx);\n        gif->lzw_ctx = NULL;\n}\n"], "fixing_code": ["/*\n * Copyright 2004 Richard Wilson <richard.wilson@netsurf-browser.org>\n * Copyright 2008 Sean Fox <dyntryx@gmail.com>\n *\n * This file is part of NetSurf's libnsgif, http://www.netsurf-browser.org/\n * Licenced under the MIT License,\n *                http://www.opensource.org/licenses/mit-license.php\n */\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"libnsgif.h\"\n#include \"log.h\"\n\n#include \"lzw.h\"\n\n/**\n *\n * \\file\n * \\brief GIF image decoder\n *\n * The GIF format is thoroughly documented; a full description can be found at\n * http://www.w3.org/Graphics/GIF/spec-gif89a.txt\n *\n * \\todo Plain text and comment extensions should be implemented.\n */\n\n\n/** Maximum colour table size */\n#define GIF_MAX_COLOURS 256\n\n/** Internal flag that the colour table needs to be processed */\n#define GIF_PROCESS_COLOURS 0xaa000000\n\n/** Internal flag that a frame is invalid/unprocessed */\n#define GIF_INVALID_FRAME -1\n\n/** Transparent colour */\n#define GIF_TRANSPARENT_COLOUR 0x00\n\n/* GIF Flags */\n#define GIF_FRAME_COMBINE 1\n#define GIF_FRAME_CLEAR 2\n#define GIF_FRAME_RESTORE 3\n#define GIF_FRAME_QUIRKS_RESTORE 4\n\n#define GIF_IMAGE_SEPARATOR 0x2c\n#define GIF_INTERLACE_MASK 0x40\n#define GIF_COLOUR_TABLE_MASK 0x80\n#define GIF_COLOUR_TABLE_SIZE_MASK 0x07\n#define GIF_EXTENSION_INTRODUCER 0x21\n#define GIF_EXTENSION_GRAPHIC_CONTROL 0xf9\n#define GIF_DISPOSAL_MASK 0x1c\n#define GIF_TRANSPARENCY_MASK 0x01\n#define GIF_EXTENSION_COMMENT 0xfe\n#define GIF_EXTENSION_PLAIN_TEXT 0x01\n#define GIF_EXTENSION_APPLICATION 0xff\n#define GIF_BLOCK_TERMINATOR 0x00\n#define GIF_TRAILER 0x3b\n\n/** standard GIF header size */\n#define GIF_STANDARD_HEADER_SIZE 13\n\n\n/**\n * Updates the sprite memory size\n *\n * \\param gif The animation context\n * \\param width The width of the sprite\n * \\param height The height of the sprite\n * \\return GIF_INSUFFICIENT_MEMORY for a memory error GIF_OK for success\n */\nstatic gif_result\ngif_initialise_sprite(gif_animation *gif,\n                      unsigned int width,\n                      unsigned int height)\n{\n        unsigned int max_width;\n        unsigned int max_height;\n        struct bitmap *buffer;\n\n        /* Check if we've changed */\n        if ((width <= gif->width) && (height <= gif->height)) {\n                return GIF_OK;\n        }\n\n        /* Get our maximum values */\n        max_width = (width > gif->width) ? width : gif->width;\n        max_height = (height > gif->height) ? height : gif->height;\n\n        /* Allocate some more memory */\n        assert(gif->bitmap_callbacks.bitmap_create);\n        buffer = gif->bitmap_callbacks.bitmap_create(max_width, max_height);\n        if (buffer == NULL) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        assert(gif->bitmap_callbacks.bitmap_destroy);\n        gif->bitmap_callbacks.bitmap_destroy(gif->frame_image);\n        gif->frame_image = buffer;\n        gif->width = max_width;\n        gif->height = max_height;\n\n        /* Invalidate our currently decoded image */\n        gif->decoded_frame = GIF_INVALID_FRAME;\n        return GIF_OK;\n}\n\n\n/**\n * Attempts to initialise the frame's extensions\n *\n * \\param gif The animation context\n * \\param frame The frame number\n * @return GIF_INSUFFICIENT_FRAME_DATA for insufficient data to complete the\n *         frame GIF_OK for successful initialisation.\n */\nstatic gif_result\ngif_initialise_frame_extensions(gif_animation *gif, const int frame)\n{\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        ssize_t block_size;\n\n        /* Get our buffer position etc.\t*/\n        gif_data = (const unsigned char *)(gif->gif_data + gif->buffer_position);\n        gif_end = (const unsigned char *)(gif->gif_data + gif->buffer_size);\n\n        /* Initialise the extensions */\n        while (gif_data < gif_end && gif_data[0] == GIF_EXTENSION_INTRODUCER) {\n                ++gif_data;\n                if ((gif_bytes = (gif_end - gif_data)) < 1) {\n                        return GIF_INSUFFICIENT_FRAME_DATA;\n                }\n\n                /* Switch on extension label */\n                switch (gif_data[0]) {\n                case GIF_EXTENSION_GRAPHIC_CONTROL:\n                        /* 6-byte Graphic Control Extension is:\n                         *\n                         *\t+0\tCHAR\tGraphic Control Label\n                         *\t+1\tCHAR\tBlock Size\n                         *\t+2\tCHAR\t__Packed Fields__\n                         *\t\t\t3BITS\tReserved\n                         *\t\t\t3BITS\tDisposal Method\n                         *\t\t\t1BIT\tUser Input Flag\n                         *\t\t\t1BIT\tTransparent Color Flag\n                         *\t+3\tSHORT\tDelay Time\n                         *\t+5\tCHAR\tTransparent Color Index\n                         */\n                        if (gif_bytes < 6) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n\n                        gif->frames[frame].frame_delay = gif_data[3] | (gif_data[4] << 8);\n                        if (gif_data[2] & GIF_TRANSPARENCY_MASK) {\n                                gif->frames[frame].transparency = true;\n                                gif->frames[frame].transparency_index = gif_data[5];\n                        }\n                        gif->frames[frame].disposal_method = ((gif_data[2] & GIF_DISPOSAL_MASK) >> 2);\n                        /* I have encountered documentation and GIFs in the\n                         * wild that use 0x04 to restore the previous frame,\n                         * rather than the officially documented 0x03.  I\n                         * believe some (older?)  software may even actually\n                         * export this way.  We handle this as a type of\n                         * \"quirks\" mode.\n                         */\n                        if (gif->frames[frame].disposal_method == GIF_FRAME_QUIRKS_RESTORE) {\n                                gif->frames[frame].disposal_method = GIF_FRAME_RESTORE;\n                        }\n                        gif_data += (2 + gif_data[1]);\n                        break;\n\n                case GIF_EXTENSION_APPLICATION:\n                        /* 14-byte+ Application Extension is:\n                         *\n                         *\t+0    CHAR    Application Extension Label\n                         *\t+1    CHAR    Block Size\n                         *\t+2    8CHARS  Application Identifier\n                         *\t+10   3CHARS  Appl. Authentication Code\n                         *\t+13   1-256   Application Data (Data sub-blocks)\n                         */\n                        if (gif_bytes < 17) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        if ((gif_data[1] == 0x0b) &&\n                            (strncmp((const char *) gif_data + 2,\n                                     \"NETSCAPE2.0\", 11) == 0) &&\n                            (gif_data[13] == 0x03) &&\n                            (gif_data[14] == 0x01)) {\n                                gif->loop_count = gif_data[15] | (gif_data[16] << 8);\n                        }\n                        gif_data += (2 + gif_data[1]);\n                        break;\n\n                case GIF_EXTENSION_COMMENT:\n                        /* Move the pointer to the first data sub-block Skip 1\n                         * byte for the extension label\n                         */\n                        ++gif_data;\n                        break;\n\n                default:\n                        /* Move the pointer to the first data sub-block Skip 2\n                         * bytes for the extension label and size fields Skip\n                         * the extension size itself\n                         */\n                        if (gif_bytes < 2) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += (2 + gif_data[1]);\n                }\n\n                /* Repeatedly skip blocks until we get a zero block or run out\n                 * of data This data is ignored by this gif decoder\n                 */\n                gif_bytes = (gif_end - gif_data);\n                block_size = 0;\n                while (gif_data < gif_end && gif_data[0] != GIF_BLOCK_TERMINATOR) {\n                        block_size = gif_data[0] + 1;\n                        if ((gif_bytes -= block_size) < 0) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += block_size;\n                }\n                ++gif_data;\n        }\n\n        /* Set buffer position and return */\n        gif->buffer_position = (gif_data - gif->gif_data);\n        return GIF_OK;\n}\n\n\n/**\n * Attempts to initialise the next frame\n *\n * \\param gif The animation context\n * \\return error code\n *         - GIF_INSUFFICIENT_DATA for insufficient data to do anything\n *         - GIF_FRAME_DATA_ERROR for GIF frame data error\n *         - GIF_INSUFFICIENT_MEMORY for insufficient memory to process\n *         - GIF_INSUFFICIENT_FRAME_DATA for insufficient data to complete the frame\n *         - GIF_DATA_ERROR for GIF error (invalid frame header)\n *         - GIF_OK for successful decoding\n *         - GIF_WORKING for successful decoding if more frames are expected\n*/\nstatic gif_result gif_initialise_frame(gif_animation *gif)\n{\n        int frame;\n        gif_frame *temp_buf;\n\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int flags = 0;\n        unsigned int width, height, offset_x, offset_y;\n        ssize_t block_size, colour_table_size;\n        bool first_image = true;\n        gif_result return_value;\n        bool premature_eof = false;\n\n        /* Get the frame to decode and our data position */\n        frame = gif->frame_count;\n\n        /* Get our buffer position etc. */\n        gif_data = (const unsigned char *)(gif->gif_data + gif->buffer_position);\n        gif_end = (const unsigned char *)(gif->gif_data + gif->buffer_size);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Check if we've finished */\n        if ((gif_bytes > 0) && (gif_data[0] == GIF_TRAILER)) {\n                return GIF_OK;\n        }\n\n        /* Check if there is enough data remaining. The shortest block of data\n         * is a 4-byte comment extension + 1-byte block terminator + 1-byte gif\n         * trailer\n         */\n        if (gif_bytes < 6) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* We could theoretically get some junk data that gives us millions of\n         * frames, so we ensure that we don't have a silly number\n         */\n        if (frame > 262143)\n                return GIF_FRAME_DATA_ERROR;\n\n        /* Get some memory to store our pointers in etc. */\n        if ((int)gif->frame_holders <= frame) {\n                /* Allocate more memory */\n                temp_buf = (gif_frame *)realloc(gif->frames, (frame + 1) * sizeof(gif_frame));\n                if (temp_buf == NULL) {\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n                gif->frames = temp_buf;\n                gif->frame_holders = frame + 1;\n        }\n\n        /* Store our frame pointer. We would do it when allocating except we\n         * start off with one frame allocated so we can always use realloc.\n         */\n        gif->frames[frame].frame_pointer = gif->buffer_position;\n        gif->frames[frame].display = false;\n        gif->frames[frame].virgin = true;\n        gif->frames[frame].disposal_method = 0;\n        gif->frames[frame].transparency = false;\n        gif->frames[frame].frame_delay = 0;\n        gif->frames[frame].redraw_required = false;\n\n        /* Invalidate any previous decoding we have of this frame */\n        if (gif->decoded_frame == frame) {\n                gif->decoded_frame = GIF_INVALID_FRAME;\n        }\n\n        /* We pretend to initialise the frames, but really we just skip over\n         * all the data contained within. This is all basically a cut down\n         * version of gif_decode_frame that doesn't have any of the LZW bits in\n         * it.\n         */\n\n        /* Initialise any extensions */\n        gif->buffer_position = gif_data - gif->gif_data;\n        return_value = gif_initialise_frame_extensions(gif, frame);\n        if (return_value != GIF_OK) {\n                return return_value;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Check if we've finished */\n        if ((gif_bytes = (gif_end - gif_data)) < 1) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        if (gif_data[0] == GIF_TRAILER) {\n                gif->buffer_position = (gif_data - gif->gif_data);\n                gif->frame_count = frame + 1;\n                return GIF_OK;\n        }\n\n        /* If we're not done, there should be an image descriptor */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return GIF_FRAME_DATA_ERROR;\n        }\n\n        /* Do some simple boundary checking */\n        if (gif_bytes < 10) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Set up the redraw characteristics. We have to check for extending\n         * the area due to multi-image frames.\n         */\n        if (!first_image) {\n                if (gif->frames[frame].redraw_x > offset_x) {\n                        gif->frames[frame].redraw_width += (gif->frames[frame].redraw_x - offset_x);\n                        gif->frames[frame].redraw_x = offset_x;\n                }\n\n                if (gif->frames[frame].redraw_y > offset_y) {\n                        gif->frames[frame].redraw_height += (gif->frames[frame].redraw_y - offset_y);\n                        gif->frames[frame].redraw_y = offset_y;\n                }\n\n                if ((offset_x + width) > (gif->frames[frame].redraw_x + gif->frames[frame].redraw_width)) {\n                        gif->frames[frame].redraw_width = (offset_x + width) - gif->frames[frame].redraw_x;\n                }\n\n                if ((offset_y + height) > (gif->frames[frame].redraw_y + gif->frames[frame].redraw_height)) {\n                        gif->frames[frame].redraw_height = (offset_y + height) - gif->frames[frame].redraw_y;\n                }\n        } else {\n                first_image = false;\n                gif->frames[frame].redraw_x = offset_x;\n                gif->frames[frame].redraw_y = offset_y;\n                gif->frames[frame].redraw_width = width;\n                gif->frames[frame].redraw_height = height;\n        }\n\n        /* if we are clearing the background then we need to redraw enough to\n         * cover the previous frame too\n         */\n        gif->frames[frame].redraw_required = ((gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) ||\n                                                (gif->frames[frame].disposal_method == GIF_FRAME_RESTORE));\n\n        /* Boundary checking - shouldn't ever happen except with junk data */\n        if (gif_initialise_sprite(gif, (offset_x + width), (offset_y + height))) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n\n        /* Move our data onwards and remember we've got a bit of this frame */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n        gif->frame_count_partial = frame + 1;\n\n        /* Skip the local colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                gif_data += 3 * colour_table_size;\n                if ((gif_bytes = (gif_end - gif_data)) < 0) {\n                        return GIF_INSUFFICIENT_FRAME_DATA;\n                }\n        }\n\n        /* Ensure we have a correct code size */\n        if (gif_bytes < 1) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n        if (gif_data[0] > LZW_CODE_MAX) {\n                return GIF_DATA_ERROR;\n        }\n\n        /* Move our pointer to the actual image data */\n        gif_data++;\n        --gif_bytes;\n\n        /* Repeatedly skip blocks until we get a zero block or run out of data\n         * These blocks of image data are processed later by gif_decode_frame()\n         */\n        block_size = 0;\n        while (block_size != 1) {\n                if (gif_bytes < 1) return GIF_INSUFFICIENT_FRAME_DATA;\n                block_size = gif_data[0] + 1;\n                /* Check if the frame data runs off the end of the file\t*/\n                if ((ssize_t)(gif_bytes - block_size) < 0) {\n                        /* Try to recover by signaling the end of the gif.\n                         * Once we get garbage data, there is no logical way to\n                         * determine where the next frame is.  It's probably\n                         * better to partially load the gif than not at all.\n                         */\n                        if (gif_bytes >= 2) {\n                                gif_bytes = 1;\n                                ++gif_data;\n                                premature_eof = true;\n                                break;\n                        } else {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                } else {\n                        gif_bytes -= block_size;\n                        gif_data += block_size;\n                }\n        }\n\n        /* Add the frame and set the display flag */\n        gif->buffer_position = gif_data - gif->gif_data;\n        gif->frame_count = frame + 1;\n        gif->frames[frame].display = true;\n\n        /* Check if we've finished */\n        if (gif_bytes < 1) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        } else {\n                if (premature_eof || gif_data[0] == GIF_TRAILER) {\n                        return GIF_OK;\n                }\n        }\n        return GIF_WORKING;\n}\n\n\n\n\n/**\n * Skips the frame's extensions (which have been previously initialised)\n *\n * \\param gif The animation context\n * \\return GIF_INSUFFICIENT_FRAME_DATA for insufficient data to complete the\n *         frame GIF_OK for successful decoding\n */\nstatic gif_result gif_skip_frame_extensions(gif_animation *gif)\n{\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        ssize_t block_size;\n\n        /* Get our buffer position etc.\t*/\n        gif_data = (const unsigned char *)(gif->gif_data + gif->buffer_position);\n        gif_end = (const unsigned char *)(gif->gif_data + gif->buffer_size);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Skip the extensions */\n        while (gif_data < gif_end && gif_data[0] == GIF_EXTENSION_INTRODUCER) {\n                ++gif_data;\n                if (gif_data >= gif_end) {\n                        return GIF_INSUFFICIENT_FRAME_DATA;\n                }\n\n                /* Switch on extension label */\n                switch(gif_data[0]) {\n                case GIF_EXTENSION_COMMENT:\n                        /* Move the pointer to the first data sub-block\n                         * 1 byte for the extension label\n                         */\n                        ++gif_data;\n                        break;\n\n                default:\n                        /* Move the pointer to the first data sub-block 2 bytes\n                         * for the extension label and size fields Skip the\n                         * extension size itself\n                         */\n                        if (gif_data + 1 >= gif_end) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += (2 + gif_data[1]);\n                }\n\n                /* Repeatedly skip blocks until we get a zero block or run out\n                 * of data This data is ignored by this gif decoder\n                 */\n                gif_bytes = (gif_end - gif_data);\n                block_size = 0;\n                while (gif_data < gif_end && gif_data[0] != GIF_BLOCK_TERMINATOR) {\n                        block_size = gif_data[0] + 1;\n                        if ((gif_bytes -= block_size) < 0) {\n                                return GIF_INSUFFICIENT_FRAME_DATA;\n                        }\n                        gif_data += block_size;\n                }\n                ++gif_data;\n        }\n\n        /* Set buffer position and return */\n        gif->buffer_position = (gif_data - gif->gif_data);\n        return GIF_OK;\n}\n\nstatic unsigned int gif_interlaced_line(int height, int y) {\n        if ((y << 3) < height) {\n                return (y << 3);\n        }\n        y -= ((height + 7) >> 3);\n        if ((y << 3) < (height - 4)) {\n                return (y << 3) + 4;\n        }\n        y -= ((height + 3) >> 3);\n        if ((y << 2) < (height - 2)) {\n                return (y << 2) + 2;\n        }\n        y -= ((height + 1) >> 2);\n        return (y << 1) + 1;\n}\n\n\nstatic gif_result gif_error_from_lzw(lzw_result l_res)\n{\n        static const gif_result g_res[] = {\n                [LZW_OK]        = GIF_OK,\n                [LZW_OK_EOD]    = GIF_END_OF_FRAME,\n                [LZW_NO_MEM]    = GIF_INSUFFICIENT_MEMORY,\n                [LZW_NO_DATA]   = GIF_INSUFFICIENT_FRAME_DATA,\n                [LZW_EOI_CODE]  = GIF_FRAME_DATA_ERROR,\n                [LZW_BAD_ICODE] = GIF_FRAME_DATA_ERROR,\n                [LZW_BAD_CODE]  = GIF_FRAME_DATA_ERROR,\n        };\n        return g_res[l_res];\n}\n\n\n/**\n * decode a gif frame\n *\n * \\param gif gif animation context.\n * \\param frame The frame number to decode.\n * \\param clear_image flag for image data being cleared instead of plotted.\n */\nstatic gif_result\ngif_internal_decode_frame(gif_animation *gif,\n                          unsigned int frame,\n                          bool clear_image)\n{\n        unsigned int index = 0;\n        const unsigned char *gif_data, *gif_end;\n        ssize_t gif_bytes;\n        unsigned int width, height, offset_x, offset_y;\n        unsigned int flags, colour_table_size, interlace;\n        unsigned int *colour_table;\n        unsigned int *frame_data = 0;\t// Set to 0 for no warnings\n        unsigned int *frame_scanline;\n        ssize_t save_buffer_position;\n        unsigned int return_value = 0;\n        unsigned int x, y, decode_y, burst_bytes;\n        register unsigned char colour;\n\n        /* If the GIF has no frame data, frame holders will not be allocated in\n         * gif_initialise() */\n        if (gif->frames == NULL) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Ensure this frame is supposed to be decoded */\n        if (gif->frames[frame].display == false) {\n                return GIF_OK;\n        }\n\n        /* Ensure the frame is in range to decode */\n        if (frame > gif->frame_count_partial) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* done if frame is already decoded */\n        if ((!clear_image) &&\n            ((int)frame == gif->decoded_frame)) {\n                return GIF_OK;\n        }\n\n        /* Get the start of our frame data and the end of the GIF data */\n        gif_data = gif->gif_data + gif->frames[frame].frame_pointer;\n        gif_end = gif->gif_data + gif->buffer_size;\n        gif_bytes = (gif_end - gif_data);\n\n        /*\n         * Ensure there is a minimal amount of data to proceed.  The shortest\n         * block of data is a 10-byte image descriptor + 1-byte gif trailer\n         */\n        if (gif_bytes < 12) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Save the buffer position */\n        save_buffer_position = gif->buffer_position;\n        gif->buffer_position = gif_data - gif->gif_data;\n\n        /* Skip any extensions because they have allready been processed */\n        if ((return_value = gif_skip_frame_extensions(gif)) != GIF_OK) {\n                goto gif_decode_frame_exit;\n        }\n        gif_data = (gif->gif_data + gif->buffer_position);\n        gif_bytes = (gif_end - gif_data);\n\n        /* Ensure we have enough data for the 10-byte image descriptor + 1-byte\n         * gif trailer\n         */\n        if (gif_bytes < 12) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* 10-byte Image Descriptor is:\n         *\n         *\t+0\tCHAR\tImage Separator (0x2c)\n         *\t+1\tSHORT\tImage Left Position\n         *\t+3\tSHORT\tImage Top Position\n         *\t+5\tSHORT\tWidth\n         *\t+7\tSHORT\tHeight\n         *\t+9\tCHAR\t__Packed Fields__\n         *\t\t\t1BIT\tLocal Colour Table Flag\n         *\t\t\t1BIT\tInterlace Flag\n         *\t\t\t1BIT\tSort Flag\n         *\t\t\t2BITS\tReserved\n         *\t\t\t3BITS\tSize of Local Colour Table\n         */\n        if (gif_data[0] != GIF_IMAGE_SEPARATOR) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n        offset_x = gif_data[1] | (gif_data[2] << 8);\n        offset_y = gif_data[3] | (gif_data[4] << 8);\n        width = gif_data[5] | (gif_data[6] << 8);\n        height = gif_data[7] | (gif_data[8] << 8);\n\n        /* Boundary checking - shouldn't ever happen except unless the data has\n         * been modified since initialisation.\n         */\n        if ((offset_x + width > gif->width) ||\n            (offset_y + height > gif->height)) {\n                return_value = GIF_DATA_ERROR;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Decode the flags */\n        flags = gif_data[9];\n        colour_table_size = 2 << (flags & GIF_COLOUR_TABLE_SIZE_MASK);\n        interlace = flags & GIF_INTERLACE_MASK;\n\n        /* Advance data pointer to next block either colour table or image\n         * data.\n         */\n        gif_data += 10;\n        gif_bytes = (gif_end - gif_data);\n\n        /* Set up the colour table */\n        if (flags & GIF_COLOUR_TABLE_MASK) {\n                if (gif_bytes < (int)(3 * colour_table_size)) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n                colour_table = gif->local_colour_table;\n                if (!clear_image) {\n                        for (index = 0; index < colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry =\n                                        (unsigned char *) &colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                } else {\n                        gif_data += 3 * colour_table_size;\n                }\n                gif_bytes = (gif_end - gif_data);\n        } else {\n                colour_table = gif->global_colour_table;\n        }\n\n        /* Ensure sufficient data remains */\n        if (gif_bytes < 1) {\n                return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                goto gif_decode_frame_exit;\n        }\n\n        /* check for an end marker */\n        if (gif_data[0] == GIF_TRAILER) {\n                return_value = GIF_OK;\n                goto gif_decode_frame_exit;\n        }\n\n        /* Get the frame data */\n        assert(gif->bitmap_callbacks.bitmap_get_buffer);\n        frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n        if (!frame_data) {\n                return GIF_INSUFFICIENT_MEMORY;\n        }\n\n        /* If we are clearing the image we just clear, if not decode */\n        if (!clear_image) {\n                lzw_result res;\n                const uint8_t *stack_base;\n                const uint8_t *stack_pos;\n\n                /* Ensure we have enough data for a 1-byte LZW code size +\n                 * 1-byte gif trailer\n                 */\n                if (gif_bytes < 2) {\n                        return_value = GIF_INSUFFICIENT_FRAME_DATA;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If we only have a 1-byte LZW code size + 1-byte gif trailer,\n                 * we're finished\n                 */\n                if ((gif_bytes == 2) && (gif_data[1] == GIF_TRAILER)) {\n                        return_value = GIF_OK;\n                        goto gif_decode_frame_exit;\n                }\n\n                /* If the previous frame's disposal method requires we restore\n                 * the background colour or this is the first frame, clear\n                 * the frame data\n                 */\n                if ((frame == 0) || (gif->decoded_frame == GIF_INVALID_FRAME)) {\n                        memset((char*)frame_data,\n                               GIF_TRANSPARENT_COLOUR,\n                               gif->width * gif->height * sizeof(int));\n                        gif->decoded_frame = frame;\n                        /* The line below would fill the image with its\n                         * background color, but because GIFs support\n                         * transparency we likely wouldn't want to do that. */\n                        /* memset((char*)frame_data, colour_table[gif->background_index], gif->width * gif->height * sizeof(int)); */\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_CLEAR)) {\n                        return_value = gif_internal_decode_frame(gif,\n                                                                 (frame - 1),\n                                                                 true);\n                        if (return_value != GIF_OK) {\n                                goto gif_decode_frame_exit;\n                        }\n\n                } else if ((frame != 0) &&\n                           (gif->frames[frame - 1].disposal_method == GIF_FRAME_RESTORE)) {\n                        /*\n                         * If the previous frame's disposal method requires we\n                         * restore the previous image, find the last image set\n                         * to \"do not dispose\" and get that frame data\n                         */\n                        int last_undisposed_frame = frame - 2;\n                        while ((last_undisposed_frame >= 0) &&\n                               (gif->frames[last_undisposed_frame].disposal_method == GIF_FRAME_RESTORE)) {\n                                last_undisposed_frame--;\n                        }\n\n                        /* If we don't find one, clear the frame data */\n                        if (last_undisposed_frame == -1) {\n                                /* see notes above on transparency\n                                 * vs. background color\n                                 */\n                                memset((char*)frame_data,\n                                       GIF_TRANSPARENT_COLOUR,\n                                       gif->width * gif->height * sizeof(int));\n                        } else {\n                                return_value = gif_internal_decode_frame(gif, last_undisposed_frame, false);\n                                if (return_value != GIF_OK) {\n                                        goto gif_decode_frame_exit;\n                                }\n                                /* Get this frame's data */\n                                assert(gif->bitmap_callbacks.bitmap_get_buffer);\n                                frame_data = (void *)gif->bitmap_callbacks.bitmap_get_buffer(gif->frame_image);\n                                if (!frame_data) {\n                                        return GIF_INSUFFICIENT_MEMORY;\n                                }\n                        }\n                }\n                gif->decoded_frame = frame;\n                gif->buffer_position = (gif_data - gif->gif_data) + 1;\n\n                /* Initialise the LZW decoding */\n                res = lzw_decode_init(gif->lzw_ctx, gif->gif_data,\n                                gif->buffer_size, gif->buffer_position,\n                                gif_data[0], &stack_base, &stack_pos);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n\n                /* Decompress the data */\n                for (y = 0; y < height; y++) {\n                        if (interlace) {\n                                decode_y = gif_interlaced_line(height, y) + offset_y;\n                        } else {\n                                decode_y = y + offset_y;\n                        }\n                        frame_scanline = frame_data + offset_x + (decode_y * gif->width);\n\n                        /* Rather than decoding pixel by pixel, we try to burst\n                         * out streams of data to remove the need for end-of\n                         * data checks every pixel.\n                         */\n                        x = width;\n                        while (x > 0) {\n                                burst_bytes = (stack_pos - stack_base);\n                                if (burst_bytes > 0) {\n                                        if (burst_bytes > x) {\n                                                burst_bytes = x;\n                                        }\n                                        x -= burst_bytes;\n                                        while (burst_bytes-- > 0) {\n                                                colour = *--stack_pos;\n                                                if (((gif->frames[frame].transparency) &&\n                                                     (colour != gif->frames[frame].transparency_index)) ||\n                                                    (!gif->frames[frame].transparency)) {\n                                                        *frame_scanline = colour_table[colour];\n                                                }\n                                                frame_scanline++;\n                                        }\n                                } else {\n                                        res = lzw_decode(gif->lzw_ctx, &stack_pos);\n                                        if (res != LZW_OK) {\n                                                /* Unexpected end of frame, try to recover */\n                                                if (res == LZW_OK_EOD) {\n                                                        return_value = GIF_OK;\n                                                } else {\n                                                        return_value = gif_error_from_lzw(res);\n                                                }\n                                                goto gif_decode_frame_exit;\n                                        }\n                                }\n                        }\n                }\n        } else {\n                /* Clear our frame */\n                if (gif->frames[frame].disposal_method == GIF_FRAME_CLEAR) {\n                        for (y = 0; y < height; y++) {\n                                frame_scanline = frame_data + offset_x + ((offset_y + y) * gif->width);\n                                if (gif->frames[frame].transparency) {\n                                        memset(frame_scanline,\n                                               GIF_TRANSPARENT_COLOUR,\n                                               width * 4);\n                                } else {\n                                        memset(frame_scanline,\n                                               colour_table[gif->background_index],\n                                               width * 4);\n                                }\n                        }\n                }\n        }\ngif_decode_frame_exit:\n\n        /* Check if we should test for optimisation */\n        if (gif->frames[frame].virgin) {\n                if (gif->bitmap_callbacks.bitmap_test_opaque) {\n                        gif->frames[frame].opaque = gif->bitmap_callbacks.bitmap_test_opaque(gif->frame_image);\n                } else {\n                        gif->frames[frame].opaque = false;\n                }\n                gif->frames[frame].virgin = false;\n        }\n\n        if (gif->bitmap_callbacks.bitmap_set_opaque) {\n                gif->bitmap_callbacks.bitmap_set_opaque(gif->frame_image, gif->frames[frame].opaque);\n        }\n\n        if (gif->bitmap_callbacks.bitmap_modified) {\n                gif->bitmap_callbacks.bitmap_modified(gif->frame_image);\n        }\n\n        /* Restore the buffer position */\n        gif->buffer_position = save_buffer_position;\n\n        return return_value;\n}\n\n\n/* exported function documented in libnsgif.h */\nvoid gif_create(gif_animation *gif, gif_bitmap_callback_vt *bitmap_callbacks)\n{\n        memset(gif, 0, sizeof(gif_animation));\n        gif->bitmap_callbacks = *bitmap_callbacks;\n        gif->decoded_frame = GIF_INVALID_FRAME;\n}\n\n\n/* exported function documented in libnsgif.h */\ngif_result gif_initialise(gif_animation *gif, size_t size, unsigned char *data)\n{\n        const unsigned char *gif_data;\n        unsigned int index;\n        gif_result return_value;\n\n        /* Initialize values */\n        gif->buffer_size = size;\n        gif->gif_data = data;\n\n        if (gif->lzw_ctx == NULL) {\n                lzw_result res = lzw_context_create(\n                                (struct lzw_ctx **)&gif->lzw_ctx);\n                if (res != LZW_OK) {\n                        return gif_error_from_lzw(res);\n                }\n        }\n\n        /* Check for sufficient data to be a GIF (6-byte header + 7-byte\n         * logical screen descriptor)\n         */\n        if (gif->buffer_size < GIF_STANDARD_HEADER_SIZE) {\n                return GIF_INSUFFICIENT_DATA;\n        }\n\n        /* Get our current processing position */\n        gif_data = gif->gif_data + gif->buffer_position;\n\n        /* See if we should initialise the GIF */\n        if (gif->buffer_position == 0) {\n                /* We want everything to be NULL before we start so we've no\n                 * chance of freeing bad pointers (paranoia)\n                 */\n                gif->frame_image = NULL;\n                gif->frames = NULL;\n                gif->local_colour_table = NULL;\n                gif->global_colour_table = NULL;\n\n                /* The caller may have been lazy and not reset any values */\n                gif->frame_count = 0;\n                gif->frame_count_partial = 0;\n                gif->decoded_frame = GIF_INVALID_FRAME;\n\n                /* 6-byte GIF file header is:\n                 *\n                 *\t+0\t3CHARS\tSignature ('GIF')\n                 *\t+3\t3CHARS\tVersion ('87a' or '89a')\n                 */\n                if (strncmp((const char *) gif_data, \"GIF\", 3) != 0) {\n                        return GIF_DATA_ERROR;\n                }\n                gif_data += 3;\n\n                /* Ensure GIF reports version 87a or 89a */\n                /*\n                if ((strncmp(gif_data, \"87a\", 3) != 0) &&\n                    (strncmp(gif_data, \"89a\", 3) != 0))\n                               LOG((\"Unknown GIF format - proceeding anyway\"));\n                */\n                gif_data += 3;\n\n                /* 7-byte Logical Screen Descriptor is:\n                 *\n                 *\t+0\tSHORT\tLogical Screen Width\n                 *\t+2\tSHORT\tLogical Screen Height\n                 *\t+4\tCHAR\t__Packed Fields__\n                 *                      1BIT\tGlobal Colour Table Flag\n                 *                      3BITS\tColour Resolution\n                 *                      1BIT\tSort Flag\n                 *                      3BITS\tSize of Global Colour Table\n                 *\t+5\tCHAR\tBackground Colour Index\n                 *\t+6\tCHAR\tPixel Aspect Ratio\n                 */\n                gif->width = gif_data[0] | (gif_data[1] << 8);\n                gif->height = gif_data[2] | (gif_data[3] << 8);\n                gif->global_colours = (gif_data[4] & GIF_COLOUR_TABLE_MASK);\n                gif->colour_table_size = (2 << (gif_data[4] & GIF_COLOUR_TABLE_SIZE_MASK));\n                gif->background_index = gif_data[5];\n                gif->aspect_ratio = gif_data[6];\n                gif->loop_count = 1;\n                gif_data += 7;\n\n                /* Some broken GIFs report the size as the screen size they\n                 * were created in. As such, we detect for the common cases and\n                 * set the sizes as 0 if they are found which results in the\n                 * GIF being the maximum size of the frames.\n                 */\n                if (((gif->width == 640) && (gif->height == 480)) ||\n                    ((gif->width == 640) && (gif->height == 512)) ||\n                    ((gif->width == 800) && (gif->height == 600)) ||\n                    ((gif->width == 1024) && (gif->height == 768)) ||\n                    ((gif->width == 1280) && (gif->height == 1024)) ||\n                    ((gif->width == 1600) && (gif->height == 1200)) ||\n                    ((gif->width == 0) || (gif->height == 0)) ||\n                    ((gif->width > 2048) || (gif->height > 2048))) {\n                        gif->width = 1;\n                        gif->height = 1;\n                }\n\n                /* Allocate some data irrespective of whether we've got any\n                 * colour tables. We always get the maximum size in case a GIF\n                 * is lying to us. It's far better to give the wrong colours\n                 * than to trample over some memory somewhere.\n                */\n                gif->global_colour_table = calloc(GIF_MAX_COLOURS, sizeof(unsigned int));\n                gif->local_colour_table = calloc(GIF_MAX_COLOURS, sizeof(unsigned int));\n                if ((gif->global_colour_table == NULL) ||\n                    (gif->local_colour_table == NULL)) {\n                        gif_finalise(gif);\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n\n                /* Set the first colour to a value that will never occur in\n                 * reality so we know if we've processed it\n                */\n                gif->global_colour_table[0] = GIF_PROCESS_COLOURS;\n\n                /* Check if the GIF has no frame data (13-byte header + 1-byte\n                 * termination block) Although generally useless, the GIF\n                 * specification does not expressly prohibit this\n                 */\n                if (gif->buffer_size == (GIF_STANDARD_HEADER_SIZE + 1)) {\n                        if (gif_data[0] == GIF_TRAILER) {\n                                return GIF_OK;\n                        } else {\n                                return GIF_INSUFFICIENT_DATA;\n                        }\n                }\n\n                /* Initialise enough workspace for a frame */\n                if ((gif->frames = (gif_frame *)malloc(sizeof(gif_frame))) == NULL) {\n                        gif_finalise(gif);\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n                gif->frame_holders = 1;\n\n                /* Initialise the bitmap header */\n                assert(gif->bitmap_callbacks.bitmap_create);\n                gif->frame_image = gif->bitmap_callbacks.bitmap_create(gif->width, gif->height);\n                if (gif->frame_image == NULL) {\n                        gif_finalise(gif);\n                        return GIF_INSUFFICIENT_MEMORY;\n                }\n\n                /* Remember we've done this now */\n                gif->buffer_position = gif_data - gif->gif_data;\n        }\n\n        /*  Do the colour map if we haven't already. As the top byte is always\n         *  0xff or 0x00 depending on the transparency we know if it's been\n         *  filled in.\n         */\n        if (gif->global_colour_table[0] == GIF_PROCESS_COLOURS) {\n                /* Check for a global colour map signified by bit 7 */\n                if (gif->global_colours) {\n                        if (gif->buffer_size < (gif->colour_table_size * 3 + GIF_STANDARD_HEADER_SIZE)) {\n                                return GIF_INSUFFICIENT_DATA;\n                        }\n                        for (index = 0; index < gif->colour_table_size; index++) {\n                                /* Gif colour map contents are r,g,b.\n                                 *\n                                 * We want to pack them bytewise into the\n                                 * colour table, such that the red component\n                                 * is in byte 0 and the alpha component is in\n                                 * byte 3.\n                                 */\n                                unsigned char *entry = (unsigned char *) &gif->\n                                                       global_colour_table[index];\n\n                                entry[0] = gif_data[0];\t/* r */\n                                entry[1] = gif_data[1];\t/* g */\n                                entry[2] = gif_data[2];\t/* b */\n                                entry[3] = 0xff;\t/* a */\n\n                                gif_data += 3;\n                        }\n                        gif->buffer_position = (gif_data - gif->gif_data);\n                } else {\n                        /* Create a default colour table with the first two\n                         * colours as black and white\n                         */\n                        unsigned int *entry = gif->global_colour_table;\n\n                        entry[0] = 0x00000000;\n                        /* Force Alpha channel to opaque */\n                        ((unsigned char *) entry)[3] = 0xff;\n\n                        entry[1] = 0xffffffff;\n                }\n        }\n\n        /* Repeatedly try to initialise frames */\n        while ((return_value = gif_initialise_frame(gif)) == GIF_WORKING);\n\n        /* If there was a memory error tell the caller */\n        if ((return_value == GIF_INSUFFICIENT_MEMORY) ||\n            (return_value == GIF_DATA_ERROR)) {\n                return return_value;\n        }\n\n        /* If we didn't have some frames then a GIF_INSUFFICIENT_DATA becomes a\n         * GIF_INSUFFICIENT_FRAME_DATA\n         */\n        if ((return_value == GIF_INSUFFICIENT_DATA) &&\n            (gif->frame_count_partial > 0)) {\n                return GIF_INSUFFICIENT_FRAME_DATA;\n        }\n\n        /* Return how many we got */\n        return return_value;\n}\n\n\n/* exported function documented in libnsgif.h */\ngif_result gif_decode_frame(gif_animation *gif, unsigned int frame)\n{\n        return gif_internal_decode_frame(gif, frame, false);\n}\n\n\n/* exported function documented in libnsgif.h */\nvoid gif_finalise(gif_animation *gif)\n{\n        /* Release all our memory blocks */\n        if (gif->frame_image) {\n                assert(gif->bitmap_callbacks.bitmap_destroy);\n                gif->bitmap_callbacks.bitmap_destroy(gif->frame_image);\n        }\n\n        gif->frame_image = NULL;\n        free(gif->frames);\n        gif->frames = NULL;\n        free(gif->local_colour_table);\n        gif->local_colour_table = NULL;\n        free(gif->global_colour_table);\n        gif->global_colour_table = NULL;\n\n        lzw_context_destroy(gif->lzw_ctx);\n        gif->lzw_ctx = NULL;\n}\n"], "filenames": ["libnsgif/libnsgif.c"], "buggy_code_start_loc": [596], "buggy_code_end_loc": [596], "fixing_code_start_loc": [597], "fixing_code_end_loc": [603], "type": "CWE-476", "message": "chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file. in GitHub repository hpjansson/chafa prior to 1.10.2. chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file.", "other": {"cve": {"id": "CVE-2022-1507", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-27T17:15:07.197", "lastModified": "2022-07-01T18:55:16.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file. in GitHub repository hpjansson/chafa prior to 1.10.2. chafa: NULL Pointer Dereference in function gif_internal_decode_frame at libnsgif.c:599 allows attackers to cause a denial of service (crash) via a crafted input file."}, {"lang": "es", "value": "chafa: Una Desreferencia de Puntero NULL en la funci\u00f3n gif_internal_decode_frame at libnsgif.c:599 permite a atacantes causar una denegaci\u00f3n de servicio (bloqueo) por medio de un archivo de entrada dise\u00f1ado. en el repositorio de GitHub hpjansson/chafa versiones anteriores a 1.10.2. chafa: Una Desreferencia de Puntero NULL en la funci\u00f3n gif_internal_decode_frame at libnsgif.c:599 permite a atacantes causar una denegaci\u00f3n de servicio (bloqueo) por medio de un archivo de entrada dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chafa_project:chafa:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.2", "matchCriteriaId": "D7D5544D-B341-43D9-B9B6-79B8306AC122"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/hpjansson/chafa/commit/e4b777c7b7c144cd16a0ea96108267b1004fe6c9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/104d8c5d-cac5-4baa-9ac9-291ea0bcab95", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3PLHKTQYK6AO3M5NAVM3CDVQTZZS6MCO/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DIOAZPITFL2Y7Y6KHCZ4OIK7P7KWFN22/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/L54UEP5S254VP5FZWGFPHLTPMFJVOGYT/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hpjansson/chafa/commit/e4b777c7b7c144cd16a0ea96108267b1004fe6c9"}}