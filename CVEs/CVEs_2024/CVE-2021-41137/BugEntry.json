{"buggy_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n\tiampolicy \"github.com/minio/pkg/iam/policy\"\n)\n\n// http Header \"x-amz-content-sha256\" == \"UNSIGNED-PAYLOAD\" indicates that the\n// client did not calculate sha256 of the payload.\nconst unsignedPayload = \"UNSIGNED-PAYLOAD\"\n\n// skipContentSha256Cksum returns true if caller needs to skip\n// payload checksum, false if not.\nfunc skipContentSha256Cksum(r *http.Request) bool {\n\tvar (\n\t\tv  []string\n\t\tok bool\n\t)\n\n\tif isRequestPresignedSignatureV4(r) {\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// Skip if no header was set.\n\tif !ok {\n\t\treturn true\n\t}\n\n\t// If x-amz-content-sha256 is set and the value is not\n\t// 'UNSIGNED-PAYLOAD' we should validate the content sha256.\n\tswitch v[0] {\n\tcase unsignedPayload:\n\t\treturn true\n\tcase emptySHA256:\n\t\t// some broken clients set empty-sha256\n\t\t// with > 0 content-length in the body,\n\t\t// we should skip such clients and allow\n\t\t// blindly such insecure clients only if\n\t\t// S3 strict compatibility is disabled.\n\t\tif r.ContentLength > 0 && !globalCLIContext.StrictS3Compat {\n\t\t\t// We return true only in situations when\n\t\t\t// deployment has asked MinIO to allow for\n\t\t\t// such broken clients and content-length > 0.\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Returns SHA256 for calculating canonical-request.\nfunc getContentSha256Cksum(r *http.Request, stype serviceType) string {\n\tif stype == serviceSTS {\n\t\tpayload, err := ioutil.ReadAll(io.LimitReader(r.Body, stsRequestBodyLimit))\n\t\tif err != nil {\n\t\t\tlogger.CriticalIf(GlobalContext, err)\n\t\t}\n\t\tsum256 := sha256.Sum256(payload)\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\t\treturn hex.EncodeToString(sum256[:])\n\t}\n\n\tvar (\n\t\tdefaultSha256Cksum string\n\t\tv                  []string\n\t\tok                 bool\n\t)\n\n\t// For a presigned request we look at the query param for sha256.\n\tif isRequestPresignedSignatureV4(r) {\n\t\t// X-Amz-Content-Sha256, if not set in presigned requests, checksum\n\t\t// will default to 'UNSIGNED-PAYLOAD'.\n\t\tdefaultSha256Cksum = unsignedPayload\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\t// X-Amz-Content-Sha256, if not set in signed requests, checksum\n\t\t// will default to sha256([]byte(\"\")).\n\t\tdefaultSha256Cksum = emptySHA256\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// We found 'X-Amz-Content-Sha256' return the captured value.\n\tif ok {\n\t\treturn v[0]\n\t}\n\n\t// We couldn't find 'X-Amz-Content-Sha256'.\n\treturn defaultSha256Cksum\n}\n\n// isValidRegion - verify if incoming region value is valid with configured Region.\nfunc isValidRegion(reqRegion string, confRegion string) bool {\n\tif confRegion == \"\" {\n\t\treturn true\n\t}\n\tif confRegion == \"US\" {\n\t\tconfRegion = globalMinioDefaultRegion\n\t}\n\t// Some older s3 clients set region as \"US\" instead of\n\t// globalMinioDefaultRegion, handle it.\n\tif reqRegion == \"US\" {\n\t\treqRegion = globalMinioDefaultRegion\n\t}\n\treturn reqRegion == confRegion\n}\n\n// check if the access key is valid and recognized, additionally\n// also returns if the access key is owner/admin.\nfunc checkKeyValid(r *http.Request, accessKey string) (auth.Credentials, bool, APIErrorCode) {\n\tif !globalIAMSys.Initialized() && !globalIsGateway {\n\t\t// Check if server has initialized, then only proceed\n\t\t// to check for IAM users otherwise its okay for clients\n\t\t// to retry with 503 errors when server is coming up.\n\t\treturn auth.Credentials{}, false, ErrServerNotInitialized\n\t}\n\n\tvar owner = true\n\tvar cred = globalActiveCred\n\tif cred.AccessKey != accessKey {\n\t\t// Check if the access key is part of users credentials.\n\t\tucred, ok := globalIAMSys.GetUser(accessKey)\n\t\tif !ok {\n\t\t\treturn cred, false, ErrInvalidAccessKeyID\n\t\t}\n\t\tcred = ucred\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, false, s3Err\n\t}\n\n\tif len(claims) > 0 {\n\t\tcred.Claims = claims\n\n\t\t// Now check if we have a sessionPolicy.\n\t\tif _, ok := claims[iampolicy.SessionPolicyName]; ok {\n\t\t\towner = false\n\t\t} else {\n\t\t\towner = cred.AccessKey == cred.ParentUser\n\t\t}\n\t}\n\n\treturn cred, owner, ErrNone\n}\n\n// sumHMAC calculate hmac between two input byte array.\nfunc sumHMAC(key []byte, data []byte) []byte {\n\thash := hmac.New(sha256.New, key)\n\thash.Write(data)\n\treturn hash.Sum(nil)\n}\n\n// extractSignedHeaders extract signed headers from Authorization header\nfunc extractSignedHeaders(signedHeaders []string, r *http.Request) (http.Header, APIErrorCode) {\n\treqHeaders := r.Header\n\treqQueries := r.Form\n\t// find whether \"host\" is part of list of signed headers.\n\t// if not return ErrUnsignedHeaders. \"host\" is mandatory.\n\tif !contains(signedHeaders, \"host\") {\n\t\treturn nil, ErrUnsignedHeaders\n\t}\n\textractedSignedHeaders := make(http.Header)\n\tfor _, header := range signedHeaders {\n\t\t// `host` will not be found in the headers, can be found in r.Host.\n\t\t// but its alway necessary that the list of signed headers containing host in it.\n\t\tval, ok := reqHeaders[http.CanonicalHeaderKey(header)]\n\t\tif !ok {\n\t\t\t// try to set headers from Query String\n\t\t\tval, ok = reqQueries[header]\n\t\t}\n\t\tif ok {\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = val\n\t\t\tcontinue\n\t\t}\n\t\tswitch header {\n\t\tcase \"expect\":\n\t\t\t// Golang http server strips off 'Expect' header, if the\n\t\t\t// client sent this as part of signed headers we need to\n\t\t\t// handle otherwise we would see a signature mismatch.\n\t\t\t// `aws-cli` sets this as part of signed headers.\n\t\t\t//\n\t\t\t// According to\n\t\t\t// http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20\n\t\t\t// Expect header is always of form:\n\t\t\t//\n\t\t\t//   Expect       =  \"Expect\" \":\" 1#expectation\n\t\t\t//   expectation  =  \"100-continue\" | expectation-extension\n\t\t\t//\n\t\t\t// So it safe to assume that '100-continue' is what would\n\t\t\t// be sent, for the time being keep this work around.\n\t\t\t// Adding a *TODO* to remove this later when Golang server\n\t\t\t// doesn't filter out the 'Expect' header.\n\t\t\textractedSignedHeaders.Set(header, \"100-continue\")\n\t\tcase \"host\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders.Set(header, r.Host)\n\t\tcase \"transfer-encoding\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = r.TransferEncoding\n\t\tcase \"content-length\":\n\t\t\t// Signature-V4 spec excludes Content-Length from signed headers list for signature calculation.\n\t\t\t// But some clients deviate from this rule. Hence we consider Content-Length for signature\n\t\t\t// calculation to be compatible with such clients.\n\t\t\textractedSignedHeaders.Set(header, strconv.FormatInt(r.ContentLength, 10))\n\t\tdefault:\n\t\t\treturn nil, ErrUnsignedHeaders\n\t\t}\n\t}\n\treturn extractedSignedHeaders, ErrNone\n}\n\n// Trim leading and trailing spaces and replace sequential spaces with one space, following Trimall()\n// in http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\nfunc signV4TrimAll(input string) string {\n\t// Compress adjacent spaces (a space is determined by\n\t// unicode.IsSpace() internally here) to one space and return\n\treturn strings.Join(strings.Fields(input), \" \")\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\txhttp \"github.com/minio/minio/internal/http\"\n)\n\n// TestSkipContentSha256Cksum - Test validate the logic which decides whether\n// to skip checksum validation based on the request header.\nfunc TestSkipContentSha256Cksum(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputHeaderKey   string\n\t\tinputHeaderValue string\n\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\n\t\texpectedResult bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with \"X-Amz-Content-Sha256\" header set, but to empty value but we can't skip.\n\t\t{\"X-Amz-Content-Sha256\", \"\", \"\", \"\", false},\n\n\t\t// Test case - 2.\n\t\t// Test case with \"X-Amz-Content-Sha256\" not set so we can skip.\n\t\t{\"\", \"\", \"\", \"\", true},\n\n\t\t// Test case - 3.\n\t\t// Test case with \"X-Amz-Content-Sha256\" header set to  \"UNSIGNED-PAYLOAD\"\n\t\t// When \"X-Amz-Content-Sha256\" header is set to  \"UNSIGNED-PAYLOAD\", validation of content sha256 has to be skipped.\n\t\t{\"X-Amz-Content-Sha256\", unsignedPayload, \"X-Amz-Credential\", \"\", true},\n\n\t\t// Test case - 4.\n\t\t// Enabling PreSigned Signature v4, but X-Amz-Content-Sha256 not set has to be skipped.\n\t\t{\"\", \"\", \"X-Amz-Credential\", \"\", true},\n\n\t\t// Test case - 5.\n\t\t// Enabling PreSigned Signature v4, but X-Amz-Content-Sha256 set and its not UNSIGNED-PAYLOAD, we shouldn't skip.\n\t\t{\"X-Amz-Content-Sha256\", \"somevalue\", \"X-Amz-Credential\", \"\", false},\n\n\t\t// Test case - 6.\n\t\t// Test case with \"X-Amz-Content-Sha256\" header set to  \"UNSIGNED-PAYLOAD\" and its not presigned, we should skip.\n\t\t{\"X-Amz-Content-Sha256\", unsignedPayload, \"\", \"\", true},\n\n\t\t// Test case - 7.\n\t\t// \"X-Amz-Content-Sha256\" not set and  PreSigned Signature v4 not enabled, sha256 checksum calculation is not skipped.\n\t\t{\"\", \"\", \"X-Amz-Credential\", \"\", true},\n\n\t\t// Test case - 8.\n\t\t// \"X-Amz-Content-Sha256\" has a proper value cannot skip.\n\t\t{\"X-Amz-Content-Sha256\", \"somevalue\", \"\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the headers are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(http.MethodGet, \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tif testCase.inputQueryKey != \"\" {\n\t\t\tq := inputReq.URL.Query()\n\t\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\t\tif testCase.inputHeaderKey != \"\" {\n\t\t\t\tq.Add(testCase.inputHeaderKey, testCase.inputHeaderValue)\n\t\t\t}\n\t\t\tinputReq.URL.RawQuery = q.Encode()\n\t\t} else {\n\t\t\tif testCase.inputHeaderKey != \"\" {\n\t\t\t\tinputReq.Header.Set(testCase.inputHeaderKey, testCase.inputHeaderValue)\n\t\t\t}\n\t\t}\n\t\tinputReq.ParseForm()\n\n\t\tactualResult := skipContentSha256Cksum(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestIsValidRegion - Tests validate the comparison logic for asserting whether the region from http request is valid.\nfunc TestIsValidRegion(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputReqRegion  string\n\t\tinputConfRegion string\n\n\t\texpectedResult bool\n\t}{\n\n\t\t{\"\", \"\", true},\n\t\t{globalMinioDefaultRegion, \"\", true},\n\t\t{globalMinioDefaultRegion, \"US\", true},\n\t\t{\"us-west-1\", \"US\", false},\n\t\t{\"us-west-1\", \"us-west-1\", true},\n\t\t// \"US\" was old naming convention for 'us-east-1'.\n\t\t{\"US\", \"US\", true},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactualResult := isValidRegion(testCase.inputReqRegion, testCase.inputConfRegion)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestExtractSignedHeaders - Tests validate extraction of signed headers using list of signed header keys.\nfunc TestExtractSignedHeaders(t *testing.T) {\n\tsignedHeaders := []string{\"host\", \"x-amz-content-sha256\", \"x-amz-date\", \"transfer-encoding\"}\n\n\t// If the `expect` key exists in the signed headers then golang server would have stripped out the value, expecting the `expect` header set to `100-continue` in the result.\n\tsignedHeaders = append(signedHeaders, \"expect\")\n\t// expected header values.\n\texpectedHost := \"play.min.io:9000\"\n\texpectedContentSha256 := \"1234abcd\"\n\texpectedTime := UTCNow().Format(iso8601Format)\n\texpectedTransferEncoding := \"gzip\"\n\texpectedExpect := \"100-continue\"\n\n\tr, err := http.NewRequest(http.MethodGet, \"http://play.min.io:9000\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to create http.Request :\", err)\n\t}\n\tr.TransferEncoding = []string{expectedTransferEncoding}\n\n\t// Creating input http header.\n\tinputHeader := r.Header\n\tinputHeader.Set(\"x-amz-content-sha256\", expectedContentSha256)\n\tinputHeader.Set(\"x-amz-date\", expectedTime)\n\t// calling the function being tested.\n\textractedSignedHeaders, errCode := extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrNone {\n\t\tt.Fatalf(\"Expected the APIErrorCode to be %d, but got %d\", ErrNone, errCode)\n\t}\n\n\tinputQuery := r.URL.Query()\n\t// case where some headers need to get from request query\n\tsignedHeaders = append(signedHeaders, \"x-amz-server-side-encryption\")\n\t// expect to fail with `ErrUnsignedHeaders` because couldn't find some header\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrUnsignedHeaders {\n\t\tt.Fatalf(\"Expected the APIErrorCode to %d, but got %d\", ErrUnsignedHeaders, errCode)\n\t}\n\t// set headers value through Get parameter\n\tinputQuery.Add(\"x-amz-server-side-encryption\", xhttp.AmzEncryptionAES)\n\tr.URL.RawQuery = inputQuery.Encode()\n\tr.ParseForm()\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrNone {\n\t\tt.Fatalf(\"Expected the APIErrorCode to be %d, but got %d\", ErrNone, errCode)\n\t}\n\n\t// \"x-amz-content-sha256\" header value from the extracted result.\n\textractedContentSha256 := extractedSignedHeaders.Get(\"x-amz-content-sha256\")\n\t// \"host\" header value from the extracted result.\n\textractedHost := extractedSignedHeaders.Get(\"host\")\n\t//  \"x-amz-date\" header from the extracted result.\n\textractedDate := extractedSignedHeaders.Get(\"x-amz-date\")\n\t// extracted `expect` header.\n\textractedExpect := extractedSignedHeaders.Get(\"expect\")\n\n\textractedTransferEncoding := extractedSignedHeaders.Get(\"transfer-encoding\")\n\n\tif expectedHost != extractedHost {\n\t\tt.Errorf(\"host header mismatch: expected `%s`, got `%s`\", expectedHost, extractedHost)\n\t}\n\t// assert the result with the expected value.\n\tif expectedContentSha256 != extractedContentSha256 {\n\t\tt.Errorf(\"x-amz-content-sha256 header mismatch: expected `%s`, got `%s`\", expectedContentSha256, extractedContentSha256)\n\t}\n\tif expectedTime != extractedDate {\n\t\tt.Errorf(\"x-amz-date header mismatch: expected `%s`, got `%s`\", expectedTime, extractedDate)\n\t}\n\tif extractedTransferEncoding != expectedTransferEncoding {\n\t\tt.Errorf(\"transfer-encoding mismatch: expected %s, got %s\", expectedTransferEncoding, extractedTransferEncoding)\n\t}\n\n\t// Since the list of signed headers value contained `expect`, the default value of `100-continue` will be added to extracted signed headers.\n\tif extractedExpect != expectedExpect {\n\t\tt.Errorf(\"expect header incorrect value: expected `%s`, got `%s`\", expectedExpect, extractedExpect)\n\t}\n\n\t// case where the headers don't contain the one of the signed header in the signed headers list.\n\tsignedHeaders = append(signedHeaders, \"X-Amz-Credential\")\n\t// expected to fail with `ErrUnsignedHeaders`.\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrUnsignedHeaders {\n\t\tt.Fatalf(\"Expected the APIErrorCode to %d, but got %d\", ErrUnsignedHeaders, errCode)\n\t}\n\n\t// case where the list of signed headers doesn't contain the host field.\n\tsignedHeaders = signedHeaders[2:5]\n\t// expected to fail with `ErrUnsignedHeaders`.\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrUnsignedHeaders {\n\t\tt.Fatalf(\"Expected the APIErrorCode to %d, but got %d\", ErrUnsignedHeaders, errCode)\n\t}\n}\n\n// TestSignV4TrimAll - tests the logic of TrimAll() function\nfunc TestSignV4TrimAll(t *testing.T) {\n\ttestCases := []struct {\n\t\t// Input.\n\t\tinputStr string\n\t\t// Expected result.\n\t\tresult string\n\t}{\n\t\t{\"\u672c\u8a9e\", \"\u672c\u8a9e\"},\n\t\t{\" abc \", \"abc\"},\n\t\t{\" a b \", \"a b\"},\n\t\t{\"a b \", \"a b\"},\n\t\t{\"a  b\", \"a b\"},\n\t\t{\"a   b\", \"a b\"},\n\t\t{\"   a   b  c   \", \"a b c\"},\n\t\t{\"a \\t b  c   \", \"a b c\"},\n\t\t{\"\\\"a \\t b  c   \", \"\\\"a b c\"},\n\t\t{\" \\t\\n\\u000b\\r\\fa \\t\\n\\u000b\\r\\f b \\t\\n\\u000b\\r\\f c \\t\\n\\u000b\\r\\f\", \"a b c\"},\n\t}\n\n\t// Tests generated values from url encoded name.\n\tfor i, testCase := range testCases {\n\t\tresult := signV4TrimAll(testCase.inputStr)\n\t\tif testCase.result != result {\n\t\t\tt.Errorf(\"Test %d: Expected signV4TrimAll result to be \\\"%s\\\", but found it to be \\\"%s\\\" instead\", i+1, testCase.result, result)\n\t\t}\n\t}\n}\n\n// Test getContentSha256Cksum\nfunc TestGetContentSha256Cksum(t *testing.T) {\n\ttestCases := []struct {\n\t\th        string // header SHA256\n\t\tq        string // query SHA256\n\t\texpected string // expected SHA256\n\t}{\n\t\t{\"shastring\", \"\", \"shastring\"},\n\t\t{emptySHA256, \"\", emptySHA256},\n\t\t{\"\", \"\", emptySHA256},\n\t\t{\"\", \"X-Amz-Credential=random\", unsignedPayload},\n\t\t{\"\", \"X-Amz-Credential=random&X-Amz-Content-Sha256=\" + unsignedPayload, unsignedPayload},\n\t\t{\"\", \"X-Amz-Credential=random&X-Amz-Content-Sha256=shastring\", \"shastring\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tr, err := http.NewRequest(http.MethodGet, \"http://localhost/?\"+testCase.q, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif testCase.h != \"\" {\n\t\t\tr.Header.Set(\"x-amz-content-sha256\", testCase.h)\n\t\t}\n\t\tr.ParseForm()\n\t\tgot := getContentSha256Cksum(r, serviceS3)\n\t\tif got != testCase.expected {\n\t\t\tt.Errorf(\"Test %d: got:%s expected:%s\", i+1, got, testCase.expected)\n\t\t}\n\t}\n}\n"], "fixing_code": ["// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"bytes\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/minio/minio/internal/auth\"\n\txhttp \"github.com/minio/minio/internal/http\"\n\t\"github.com/minio/minio/internal/logger\"\n)\n\n// http Header \"x-amz-content-sha256\" == \"UNSIGNED-PAYLOAD\" indicates that the\n// client did not calculate sha256 of the payload.\nconst unsignedPayload = \"UNSIGNED-PAYLOAD\"\n\n// skipContentSha256Cksum returns true if caller needs to skip\n// payload checksum, false if not.\nfunc skipContentSha256Cksum(r *http.Request) bool {\n\tvar (\n\t\tv  []string\n\t\tok bool\n\t)\n\n\tif isRequestPresignedSignatureV4(r) {\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// Skip if no header was set.\n\tif !ok {\n\t\treturn true\n\t}\n\n\t// If x-amz-content-sha256 is set and the value is not\n\t// 'UNSIGNED-PAYLOAD' we should validate the content sha256.\n\tswitch v[0] {\n\tcase unsignedPayload:\n\t\treturn true\n\tcase emptySHA256:\n\t\t// some broken clients set empty-sha256\n\t\t// with > 0 content-length in the body,\n\t\t// we should skip such clients and allow\n\t\t// blindly such insecure clients only if\n\t\t// S3 strict compatibility is disabled.\n\t\tif r.ContentLength > 0 && !globalCLIContext.StrictS3Compat {\n\t\t\t// We return true only in situations when\n\t\t\t// deployment has asked MinIO to allow for\n\t\t\t// such broken clients and content-length > 0.\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Returns SHA256 for calculating canonical-request.\nfunc getContentSha256Cksum(r *http.Request, stype serviceType) string {\n\tif stype == serviceSTS {\n\t\tpayload, err := ioutil.ReadAll(io.LimitReader(r.Body, stsRequestBodyLimit))\n\t\tif err != nil {\n\t\t\tlogger.CriticalIf(GlobalContext, err)\n\t\t}\n\t\tsum256 := sha256.Sum256(payload)\n\t\tr.Body = ioutil.NopCloser(bytes.NewReader(payload))\n\t\treturn hex.EncodeToString(sum256[:])\n\t}\n\n\tvar (\n\t\tdefaultSha256Cksum string\n\t\tv                  []string\n\t\tok                 bool\n\t)\n\n\t// For a presigned request we look at the query param for sha256.\n\tif isRequestPresignedSignatureV4(r) {\n\t\t// X-Amz-Content-Sha256, if not set in presigned requests, checksum\n\t\t// will default to 'UNSIGNED-PAYLOAD'.\n\t\tdefaultSha256Cksum = unsignedPayload\n\t\tv, ok = r.Form[xhttp.AmzContentSha256]\n\t\tif !ok {\n\t\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t\t}\n\t} else {\n\t\t// X-Amz-Content-Sha256, if not set in signed requests, checksum\n\t\t// will default to sha256([]byte(\"\")).\n\t\tdefaultSha256Cksum = emptySHA256\n\t\tv, ok = r.Header[xhttp.AmzContentSha256]\n\t}\n\n\t// We found 'X-Amz-Content-Sha256' return the captured value.\n\tif ok {\n\t\treturn v[0]\n\t}\n\n\t// We couldn't find 'X-Amz-Content-Sha256'.\n\treturn defaultSha256Cksum\n}\n\n// isValidRegion - verify if incoming region value is valid with configured Region.\nfunc isValidRegion(reqRegion string, confRegion string) bool {\n\tif confRegion == \"\" {\n\t\treturn true\n\t}\n\tif confRegion == \"US\" {\n\t\tconfRegion = globalMinioDefaultRegion\n\t}\n\t// Some older s3 clients set region as \"US\" instead of\n\t// globalMinioDefaultRegion, handle it.\n\tif reqRegion == \"US\" {\n\t\treqRegion = globalMinioDefaultRegion\n\t}\n\treturn reqRegion == confRegion\n}\n\n// check if the access key is valid and recognized, additionally\n// also returns if the access key is owner/admin.\nfunc checkKeyValid(r *http.Request, accessKey string) (auth.Credentials, bool, APIErrorCode) {\n\tif !globalIAMSys.Initialized() && !globalIsGateway {\n\t\t// Check if server has initialized, then only proceed\n\t\t// to check for IAM users otherwise its okay for clients\n\t\t// to retry with 503 errors when server is coming up.\n\t\treturn auth.Credentials{}, false, ErrServerNotInitialized\n\t}\n\n\tcred := globalActiveCred\n\tif cred.AccessKey != accessKey {\n\t\t// Check if the access key is part of users credentials.\n\t\tucred, ok := globalIAMSys.GetUser(accessKey)\n\t\tif !ok {\n\t\t\treturn cred, false, ErrInvalidAccessKeyID\n\t\t}\n\t\tcred = ucred\n\t}\n\n\tclaims, s3Err := checkClaimsFromToken(r, cred)\n\tif s3Err != ErrNone {\n\t\treturn cred, false, s3Err\n\t}\n\tcred.Claims = claims\n\n\towner := cred.AccessKey == globalActiveCred.AccessKey\n\treturn cred, owner, ErrNone\n}\n\n// sumHMAC calculate hmac between two input byte array.\nfunc sumHMAC(key []byte, data []byte) []byte {\n\thash := hmac.New(sha256.New, key)\n\thash.Write(data)\n\treturn hash.Sum(nil)\n}\n\n// extractSignedHeaders extract signed headers from Authorization header\nfunc extractSignedHeaders(signedHeaders []string, r *http.Request) (http.Header, APIErrorCode) {\n\treqHeaders := r.Header\n\treqQueries := r.Form\n\t// find whether \"host\" is part of list of signed headers.\n\t// if not return ErrUnsignedHeaders. \"host\" is mandatory.\n\tif !contains(signedHeaders, \"host\") {\n\t\treturn nil, ErrUnsignedHeaders\n\t}\n\textractedSignedHeaders := make(http.Header)\n\tfor _, header := range signedHeaders {\n\t\t// `host` will not be found in the headers, can be found in r.Host.\n\t\t// but its alway necessary that the list of signed headers containing host in it.\n\t\tval, ok := reqHeaders[http.CanonicalHeaderKey(header)]\n\t\tif !ok {\n\t\t\t// try to set headers from Query String\n\t\t\tval, ok = reqQueries[header]\n\t\t}\n\t\tif ok {\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = val\n\t\t\tcontinue\n\t\t}\n\t\tswitch header {\n\t\tcase \"expect\":\n\t\t\t// Golang http server strips off 'Expect' header, if the\n\t\t\t// client sent this as part of signed headers we need to\n\t\t\t// handle otherwise we would see a signature mismatch.\n\t\t\t// `aws-cli` sets this as part of signed headers.\n\t\t\t//\n\t\t\t// According to\n\t\t\t// http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20\n\t\t\t// Expect header is always of form:\n\t\t\t//\n\t\t\t//   Expect       =  \"Expect\" \":\" 1#expectation\n\t\t\t//   expectation  =  \"100-continue\" | expectation-extension\n\t\t\t//\n\t\t\t// So it safe to assume that '100-continue' is what would\n\t\t\t// be sent, for the time being keep this work around.\n\t\t\t// Adding a *TODO* to remove this later when Golang server\n\t\t\t// doesn't filter out the 'Expect' header.\n\t\t\textractedSignedHeaders.Set(header, \"100-continue\")\n\t\tcase \"host\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders.Set(header, r.Host)\n\t\tcase \"transfer-encoding\":\n\t\t\t// Go http server removes \"host\" from Request.Header\n\t\t\textractedSignedHeaders[http.CanonicalHeaderKey(header)] = r.TransferEncoding\n\t\tcase \"content-length\":\n\t\t\t// Signature-V4 spec excludes Content-Length from signed headers list for signature calculation.\n\t\t\t// But some clients deviate from this rule. Hence we consider Content-Length for signature\n\t\t\t// calculation to be compatible with such clients.\n\t\t\textractedSignedHeaders.Set(header, strconv.FormatInt(r.ContentLength, 10))\n\t\tdefault:\n\t\t\treturn nil, ErrUnsignedHeaders\n\t\t}\n\t}\n\treturn extractedSignedHeaders, ErrNone\n}\n\n// Trim leading and trailing spaces and replace sequential spaces with one space, following Trimall()\n// in http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\nfunc signV4TrimAll(input string) string {\n\t// Compress adjacent spaces (a space is determined by\n\t// unicode.IsSpace() internally here) to one space and return\n\treturn strings.Join(strings.Fields(input), \" \")\n}\n", "// Copyright (c) 2015-2021 MinIO, Inc.\n//\n// This file is part of MinIO Object Storage stack\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage cmd\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/minio/madmin-go\"\n\t\"github.com/minio/minio/internal/auth\"\n\txhttp \"github.com/minio/minio/internal/http\"\n)\n\nfunc TestCheckValid(t *testing.T) {\n\tobjLayer, fsDir, err := prepareFS()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(fsDir)\n\tif err = newTestConfig(globalMinioDefaultRegion, objLayer); err != nil {\n\t\tt.Fatalf(\"unable initialize config file, %s\", err)\n\t}\n\n\tnewAllSubsystems()\n\n\tinitAllSubsystems(context.Background(), objLayer)\n\n\tglobalIAMSys.InitStore(objLayer)\n\n\treq, err := newTestRequest(http.MethodGet, \"http://example.com:9000/bucket/object\", 0, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = signRequestV4(req, globalActiveCred.AccessKey, globalActiveCred.SecretKey); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, owner, s3Err := checkKeyValid(req, globalActiveCred.AccessKey)\n\tif s3Err != ErrNone {\n\t\tt.Fatalf(\"Unexpected failure with %v\", errorCodes.ToAPIErr(s3Err))\n\t}\n\n\tif !owner {\n\t\tt.Fatalf(\"Expected owner to be 'true', found %t\", owner)\n\t}\n\n\t_, _, s3Err = checkKeyValid(req, \"does-not-exist\")\n\tif s3Err != ErrInvalidAccessKeyID {\n\t\tt.Fatalf(\"Expected error 'ErrInvalidAccessKeyID', found %v\", s3Err)\n\t}\n\n\tucreds, err := auth.CreateCredentials(\"myuser1\", \"mypassword1\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable create credential, %s\", err)\n\t}\n\n\tglobalIAMSys.CreateUser(ucreds.AccessKey, madmin.UserInfo{\n\t\tSecretKey: ucreds.SecretKey,\n\t\tStatus:    madmin.AccountEnabled,\n\t})\n\n\t_, owner, s3Err = checkKeyValid(req, ucreds.AccessKey)\n\tif s3Err != ErrNone {\n\t\tt.Fatalf(\"Unexpected failure with %v\", errorCodes.ToAPIErr(s3Err))\n\t}\n\n\tif owner {\n\t\tt.Fatalf(\"Expected owner to be 'false', found %t\", owner)\n\t}\n}\n\n// TestSkipContentSha256Cksum - Test validate the logic which decides whether\n// to skip checksum validation based on the request header.\nfunc TestSkipContentSha256Cksum(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputHeaderKey   string\n\t\tinputHeaderValue string\n\n\t\tinputQueryKey   string\n\t\tinputQueryValue string\n\n\t\texpectedResult bool\n\t}{\n\t\t// Test case - 1.\n\t\t// Test case with \"X-Amz-Content-Sha256\" header set, but to empty value but we can't skip.\n\t\t{\"X-Amz-Content-Sha256\", \"\", \"\", \"\", false},\n\n\t\t// Test case - 2.\n\t\t// Test case with \"X-Amz-Content-Sha256\" not set so we can skip.\n\t\t{\"\", \"\", \"\", \"\", true},\n\n\t\t// Test case - 3.\n\t\t// Test case with \"X-Amz-Content-Sha256\" header set to  \"UNSIGNED-PAYLOAD\"\n\t\t// When \"X-Amz-Content-Sha256\" header is set to  \"UNSIGNED-PAYLOAD\", validation of content sha256 has to be skipped.\n\t\t{\"X-Amz-Content-Sha256\", unsignedPayload, \"X-Amz-Credential\", \"\", true},\n\n\t\t// Test case - 4.\n\t\t// Enabling PreSigned Signature v4, but X-Amz-Content-Sha256 not set has to be skipped.\n\t\t{\"\", \"\", \"X-Amz-Credential\", \"\", true},\n\n\t\t// Test case - 5.\n\t\t// Enabling PreSigned Signature v4, but X-Amz-Content-Sha256 set and its not UNSIGNED-PAYLOAD, we shouldn't skip.\n\t\t{\"X-Amz-Content-Sha256\", \"somevalue\", \"X-Amz-Credential\", \"\", false},\n\n\t\t// Test case - 6.\n\t\t// Test case with \"X-Amz-Content-Sha256\" header set to  \"UNSIGNED-PAYLOAD\" and its not presigned, we should skip.\n\t\t{\"X-Amz-Content-Sha256\", unsignedPayload, \"\", \"\", true},\n\n\t\t// Test case - 7.\n\t\t// \"X-Amz-Content-Sha256\" not set and  PreSigned Signature v4 not enabled, sha256 checksum calculation is not skipped.\n\t\t{\"\", \"\", \"X-Amz-Credential\", \"\", true},\n\n\t\t// Test case - 8.\n\t\t// \"X-Amz-Content-Sha256\" has a proper value cannot skip.\n\t\t{\"X-Amz-Content-Sha256\", \"somevalue\", \"\", \"\", false},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\t// creating an input HTTP request.\n\t\t// Only the headers are relevant for this particular test.\n\t\tinputReq, err := http.NewRequest(http.MethodGet, \"http://example.com\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error initializing input HTTP request: %v\", err)\n\t\t}\n\t\tif testCase.inputQueryKey != \"\" {\n\t\t\tq := inputReq.URL.Query()\n\t\t\tq.Add(testCase.inputQueryKey, testCase.inputQueryValue)\n\t\t\tif testCase.inputHeaderKey != \"\" {\n\t\t\t\tq.Add(testCase.inputHeaderKey, testCase.inputHeaderValue)\n\t\t\t}\n\t\t\tinputReq.URL.RawQuery = q.Encode()\n\t\t} else {\n\t\t\tif testCase.inputHeaderKey != \"\" {\n\t\t\t\tinputReq.Header.Set(testCase.inputHeaderKey, testCase.inputHeaderValue)\n\t\t\t}\n\t\t}\n\t\tinputReq.ParseForm()\n\n\t\tactualResult := skipContentSha256Cksum(inputReq)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestIsValidRegion - Tests validate the comparison logic for asserting whether the region from http request is valid.\nfunc TestIsValidRegion(t *testing.T) {\n\ttestCases := []struct {\n\t\tinputReqRegion  string\n\t\tinputConfRegion string\n\n\t\texpectedResult bool\n\t}{\n\n\t\t{\"\", \"\", true},\n\t\t{globalMinioDefaultRegion, \"\", true},\n\t\t{globalMinioDefaultRegion, \"US\", true},\n\t\t{\"us-west-1\", \"US\", false},\n\t\t{\"us-west-1\", \"us-west-1\", true},\n\t\t// \"US\" was old naming convention for 'us-east-1'.\n\t\t{\"US\", \"US\", true},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactualResult := isValidRegion(testCase.inputReqRegion, testCase.inputConfRegion)\n\t\tif testCase.expectedResult != actualResult {\n\t\t\tt.Errorf(\"Test %d: Expected the result to `%v`, but instead got `%v`\", i+1, testCase.expectedResult, actualResult)\n\t\t}\n\t}\n}\n\n// TestExtractSignedHeaders - Tests validate extraction of signed headers using list of signed header keys.\nfunc TestExtractSignedHeaders(t *testing.T) {\n\tsignedHeaders := []string{\"host\", \"x-amz-content-sha256\", \"x-amz-date\", \"transfer-encoding\"}\n\n\t// If the `expect` key exists in the signed headers then golang server would have stripped out the value, expecting the `expect` header set to `100-continue` in the result.\n\tsignedHeaders = append(signedHeaders, \"expect\")\n\t// expected header values.\n\texpectedHost := \"play.min.io:9000\"\n\texpectedContentSha256 := \"1234abcd\"\n\texpectedTime := UTCNow().Format(iso8601Format)\n\texpectedTransferEncoding := \"gzip\"\n\texpectedExpect := \"100-continue\"\n\n\tr, err := http.NewRequest(http.MethodGet, \"http://play.min.io:9000\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to create http.Request :\", err)\n\t}\n\tr.TransferEncoding = []string{expectedTransferEncoding}\n\n\t// Creating input http header.\n\tinputHeader := r.Header\n\tinputHeader.Set(\"x-amz-content-sha256\", expectedContentSha256)\n\tinputHeader.Set(\"x-amz-date\", expectedTime)\n\t// calling the function being tested.\n\textractedSignedHeaders, errCode := extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrNone {\n\t\tt.Fatalf(\"Expected the APIErrorCode to be %d, but got %d\", ErrNone, errCode)\n\t}\n\n\tinputQuery := r.URL.Query()\n\t// case where some headers need to get from request query\n\tsignedHeaders = append(signedHeaders, \"x-amz-server-side-encryption\")\n\t// expect to fail with `ErrUnsignedHeaders` because couldn't find some header\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrUnsignedHeaders {\n\t\tt.Fatalf(\"Expected the APIErrorCode to %d, but got %d\", ErrUnsignedHeaders, errCode)\n\t}\n\t// set headers value through Get parameter\n\tinputQuery.Add(\"x-amz-server-side-encryption\", xhttp.AmzEncryptionAES)\n\tr.URL.RawQuery = inputQuery.Encode()\n\tr.ParseForm()\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrNone {\n\t\tt.Fatalf(\"Expected the APIErrorCode to be %d, but got %d\", ErrNone, errCode)\n\t}\n\n\t// \"x-amz-content-sha256\" header value from the extracted result.\n\textractedContentSha256 := extractedSignedHeaders.Get(\"x-amz-content-sha256\")\n\t// \"host\" header value from the extracted result.\n\textractedHost := extractedSignedHeaders.Get(\"host\")\n\t//  \"x-amz-date\" header from the extracted result.\n\textractedDate := extractedSignedHeaders.Get(\"x-amz-date\")\n\t// extracted `expect` header.\n\textractedExpect := extractedSignedHeaders.Get(\"expect\")\n\n\textractedTransferEncoding := extractedSignedHeaders.Get(\"transfer-encoding\")\n\n\tif expectedHost != extractedHost {\n\t\tt.Errorf(\"host header mismatch: expected `%s`, got `%s`\", expectedHost, extractedHost)\n\t}\n\t// assert the result with the expected value.\n\tif expectedContentSha256 != extractedContentSha256 {\n\t\tt.Errorf(\"x-amz-content-sha256 header mismatch: expected `%s`, got `%s`\", expectedContentSha256, extractedContentSha256)\n\t}\n\tif expectedTime != extractedDate {\n\t\tt.Errorf(\"x-amz-date header mismatch: expected `%s`, got `%s`\", expectedTime, extractedDate)\n\t}\n\tif extractedTransferEncoding != expectedTransferEncoding {\n\t\tt.Errorf(\"transfer-encoding mismatch: expected %s, got %s\", expectedTransferEncoding, extractedTransferEncoding)\n\t}\n\n\t// Since the list of signed headers value contained `expect`, the default value of `100-continue` will be added to extracted signed headers.\n\tif extractedExpect != expectedExpect {\n\t\tt.Errorf(\"expect header incorrect value: expected `%s`, got `%s`\", expectedExpect, extractedExpect)\n\t}\n\n\t// case where the headers don't contain the one of the signed header in the signed headers list.\n\tsignedHeaders = append(signedHeaders, \"X-Amz-Credential\")\n\t// expected to fail with `ErrUnsignedHeaders`.\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrUnsignedHeaders {\n\t\tt.Fatalf(\"Expected the APIErrorCode to %d, but got %d\", ErrUnsignedHeaders, errCode)\n\t}\n\n\t// case where the list of signed headers doesn't contain the host field.\n\tsignedHeaders = signedHeaders[2:5]\n\t// expected to fail with `ErrUnsignedHeaders`.\n\t_, errCode = extractSignedHeaders(signedHeaders, r)\n\tif errCode != ErrUnsignedHeaders {\n\t\tt.Fatalf(\"Expected the APIErrorCode to %d, but got %d\", ErrUnsignedHeaders, errCode)\n\t}\n}\n\n// TestSignV4TrimAll - tests the logic of TrimAll() function\nfunc TestSignV4TrimAll(t *testing.T) {\n\ttestCases := []struct {\n\t\t// Input.\n\t\tinputStr string\n\t\t// Expected result.\n\t\tresult string\n\t}{\n\t\t{\"\u672c\u8a9e\", \"\u672c\u8a9e\"},\n\t\t{\" abc \", \"abc\"},\n\t\t{\" a b \", \"a b\"},\n\t\t{\"a b \", \"a b\"},\n\t\t{\"a  b\", \"a b\"},\n\t\t{\"a   b\", \"a b\"},\n\t\t{\"   a   b  c   \", \"a b c\"},\n\t\t{\"a \\t b  c   \", \"a b c\"},\n\t\t{\"\\\"a \\t b  c   \", \"\\\"a b c\"},\n\t\t{\" \\t\\n\\u000b\\r\\fa \\t\\n\\u000b\\r\\f b \\t\\n\\u000b\\r\\f c \\t\\n\\u000b\\r\\f\", \"a b c\"},\n\t}\n\n\t// Tests generated values from url encoded name.\n\tfor i, testCase := range testCases {\n\t\tresult := signV4TrimAll(testCase.inputStr)\n\t\tif testCase.result != result {\n\t\t\tt.Errorf(\"Test %d: Expected signV4TrimAll result to be \\\"%s\\\", but found it to be \\\"%s\\\" instead\", i+1, testCase.result, result)\n\t\t}\n\t}\n}\n\n// Test getContentSha256Cksum\nfunc TestGetContentSha256Cksum(t *testing.T) {\n\ttestCases := []struct {\n\t\th        string // header SHA256\n\t\tq        string // query SHA256\n\t\texpected string // expected SHA256\n\t}{\n\t\t{\"shastring\", \"\", \"shastring\"},\n\t\t{emptySHA256, \"\", emptySHA256},\n\t\t{\"\", \"\", emptySHA256},\n\t\t{\"\", \"X-Amz-Credential=random\", unsignedPayload},\n\t\t{\"\", \"X-Amz-Credential=random&X-Amz-Content-Sha256=\" + unsignedPayload, unsignedPayload},\n\t\t{\"\", \"X-Amz-Credential=random&X-Amz-Content-Sha256=shastring\", \"shastring\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tr, err := http.NewRequest(http.MethodGet, \"http://localhost/?\"+testCase.q, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif testCase.h != \"\" {\n\t\t\tr.Header.Set(\"x-amz-content-sha256\", testCase.h)\n\t\t}\n\t\tr.ParseForm()\n\t\tgot := getContentSha256Cksum(r, serviceS3)\n\t\tif got != testCase.expected {\n\t\t\tt.Errorf(\"Test %d: got:%s expected:%s\", i+1, got, testCase.expected)\n\t\t}\n\t}\n}\n"], "filenames": ["cmd/signature-v4-utils.go", "cmd/signature-v4-utils_test.go"], "buggy_code_start_loc": [34, 20], "buggy_code_end_loc": [180, 25], "fixing_code_start_loc": [33, 21], "fixing_code_end_loc": [169, 89], "type": "NVD-CWE-Other", "message": "Minio is a Kubernetes native application for cloud storage. All users on release `RELEASE.2021-10-10T16-53-30Z` are affected by a vulnerability that involves bypassing policy restrictions on regular users. Normally, checkKeyValid() should return owner true for rootCreds. In the affected version, policy restriction did not work properly for users who did not have service (svc) or security token service (STS) accounts. This issue is fixed in `RELEASE.2021-10-13T00-23-17Z`. A downgrade back to release `RELEASE.2021-10-08T23-58-24Z` is available as a workaround.", "other": {"cve": {"id": "CVE-2021-41137", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-13T14:15:07.827", "lastModified": "2022-08-12T16:29:57.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Minio is a Kubernetes native application for cloud storage. All users on release `RELEASE.2021-10-10T16-53-30Z` are affected by a vulnerability that involves bypassing policy restrictions on regular users. Normally, checkKeyValid() should return owner true for rootCreds. In the affected version, policy restriction did not work properly for users who did not have service (svc) or security token service (STS) accounts. This issue is fixed in `RELEASE.2021-10-13T00-23-17Z`. A downgrade back to release `RELEASE.2021-10-08T23-58-24Z` is available as a workaround."}, {"lang": "es", "value": "Minio es una aplicaci\u00f3n nativa de Kubernetes para el almacenamiento en la nube. Todos los usuarios de la versi\u00f3n \"RELEASE.2021-10-10T16-53-30Z\" est\u00e1n afectados por una vulnerabilidad que implica omitir las restricciones de las pol\u00edticas de los usuarios normales. Normalmente, checkKeyValid() deber\u00eda devolver el propietario true para rootCreds. En la versi\u00f3n afectada, la restricci\u00f3n de pol\u00edticas no funcionaba correctamente para usuarios que no ten\u00edan cuentas de servicio (svc) o de servicio de token de seguridad (STS). Este problema es corregido en la versi\u00f3n \"RELEASE.2021-10-13T00-23-17Z\". Como soluci\u00f3n, es posible volver a la versi\u00f3n \"RELEASE.2021-10-08T23-58-24Z\""}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:minio:minio:2021-10-10t16-53-30z:*:*:*:*:*:*:*", "matchCriteriaId": "3AB9615C-F075-41E6-B11E-BF0E011832FB"}]}]}], "references": [{"url": "https://github.com/minio/minio/commit/415bbc74aacd53a120e54a663e941b1809982dbd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/13388", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/pull/13422", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/minio/minio/security/advisories/GHSA-v64v-g97p-577c", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/minio/minio/commit/415bbc74aacd53a120e54a663e941b1809982dbd"}}