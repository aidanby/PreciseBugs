{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n *\n * Vendor commands implementation based on net/wireless/nl80211.c\n * which is:\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/genetlink.h>\n#include <linux/nfc.h>\n#include <linux/slab.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const struct genl_multicast_group nfc_genl_mcgrps[] = {\n\t{ .name = NFC_GENL_MCAST_EVENT_NAME, },\n};\n\nstatic struct genl_family nfc_genl_family;\nstatic const struct nla_policy nfc_genl_policy[NFC_ATTR_MAX + 1] = {\n\t[NFC_ATTR_DEVICE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_DEVICE_NAME] = { .type = NLA_STRING,\n\t\t\t\t.len = NFC_DEVICE_NAME_MAXSIZE },\n\t[NFC_ATTR_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TARGET_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_COMM_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_RF_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_DEVICE_POWERED] = { .type = NLA_U8 },\n\t[NFC_ATTR_IM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_LLC_PARAM_LTO] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_RW] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_MIUX] = { .type = NLA_U16 },\n\t[NFC_ATTR_LLC_SDP] = { .type = NLA_NESTED },\n\t[NFC_ATTR_FIRMWARE_NAME] = { .type = NLA_STRING,\n\t\t\t\t     .len = NFC_FIRMWARE_NAME_MAXSIZE },\n\t[NFC_ATTR_SE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_SE_APDU] = { .type = NLA_BINARY },\n\t[NFC_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\n};\n\nstatic const struct nla_policy nfc_sdp_genl_policy[NFC_SDP_ATTR_MAX + 1] = {\n\t[NFC_SDP_ATTR_URI] = { .type = NLA_STRING,\n\t\t\t       .len = U8_MAX - 4 },\n\t[NFC_SDP_ATTR_SAP] = { .type = NLA_U8 },\n};\n\nstatic int nfc_genl_send_target(struct sk_buff *msg, struct nfc_target *target,\n\t\t\t\tstruct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &nfc_genl_family, flags, NFC_CMD_GET_TARGET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, target->supported_protocols) ||\n\t    nla_put_u16(msg, NFC_ATTR_TARGET_SENS_RES, target->sens_res) ||\n\t    nla_put_u8(msg, NFC_ATTR_TARGET_SEL_RES, target->sel_res))\n\t\tgoto nla_put_failure;\n\tif (target->nfcid1_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_NFCID1, target->nfcid1_len,\n\t\t    target->nfcid1))\n\t\tgoto nla_put_failure;\n\tif (target->sensb_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSB_RES, target->sensb_res_len,\n\t\t    target->sensb_res))\n\t\tgoto nla_put_failure;\n\tif (target->sensf_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSF_RES, target->sensf_res_len,\n\t\t    target->sensf_res))\n\t\tgoto nla_put_failure;\n\n\tif (target->is_iso15693) {\n\t\tif (nla_put_u8(msg, NFC_ATTR_TARGET_ISO15693_DSFID,\n\t\t\t       target->iso15693_dsfid) ||\n\t\t    nla_put(msg, NFC_ATTR_TARGET_ISO15693_UID,\n\t\t\t    sizeof(target->iso15693_uid), target->iso15693_uid))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dev;\n}\n\nstatic int nfc_genl_dump_targets(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint i = cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tint rc;\n\n\tif (!dev) {\n\t\tdev = __get_device_from_cb(cb);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\n\t\tcb->args[1] = (long) dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\n\tcb->seq = dev->targets_generation;\n\n\twhile (i < dev->n_targets) {\n\t\trc = nfc_genl_send_target(skb, &dev->targets[i], cb,\n\t\t\t\t\t  NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tcb->args[0] = i;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_targets_done(struct netlink_callback *cb)\n{\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\n\tif (dev)\n\t\tnfc_put_device(dev);\n\n\treturn 0;\n}\n\nint nfc_genl_targets_found(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tdev->genl_data.poll_req_portid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGETS_FOUND);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGET_LOST);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_activated(struct nfc_dev *dev, u32 protocol)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_ACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NFC_ATTR_TM_PROTOCOLS, protocol))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_deactivated(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_DEACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_setup_device_added(struct nfc_dev *dev, struct sk_buff *msg)\n{\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, dev->supported_protocols) ||\n\t    nla_put_u8(msg, NFC_ATTR_DEVICE_POWERED, dev->dev_up) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, dev->rf_mode))\n\t\treturn -1;\n\treturn 0;\n}\n\nint nfc_genl_device_added(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_device_removed(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_llc_send_sdres(struct nfc_dev *dev, struct hlist_head *sdres_list)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *sdp_attr, *uri_attr;\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tstruct hlist_node *n;\n\tvoid *hdr;\n\tint rc = -EMSGSIZE;\n\tint i;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_LLC_SDRES);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tsdp_attr = nla_nest_start_noflag(msg, NFC_ATTR_LLC_SDP);\n\tif (sdp_attr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto nla_put_failure;\n\t}\n\n\ti = 1;\n\thlist_for_each_entry_safe(sdres, n, sdres_list, node) {\n\t\tpr_debug(\"uri: %s, sap: %d\\n\", sdres->uri, sdres->sap);\n\n\t\turi_attr = nla_nest_start_noflag(msg, i++);\n\t\tif (uri_attr == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tif (nla_put_u8(msg, NFC_SDP_ATTR_SAP, sdres->sap))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(msg, NFC_SDP_ATTR_URI, sdres->uri))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, uri_attr);\n\n\t\thlist_del(&sdres->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdres);\n\t}\n\n\tnla_nest_end(msg, sdp_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\n\tnfc_llcp_free_sdp_tlv_list(sdres_list);\n\n\treturn rc;\n}\n\nint nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t\t    struct nfc_evt_transaction *evt_transaction)\n{\n\tstruct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_TRANSACTION);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type) ||\n\t    nla_put(msg, NFC_ATTR_SE_AID, evt_transaction->aid_len,\n\t\t    evt_transaction->aid) ||\n\t    nla_put(msg, NFC_ATTR_SE_PARAMS, evt_transaction->params_len,\n\t\t    evt_transaction->params))\n\t\tgoto nla_put_failure;\n\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t  NFC_CMD_GET_DEVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_devices(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_device(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nint nfc_genl_dep_link_up_event(struct nfc_dev *dev, u32 target_idx,\n\t\t\t       u8 comm_mode, u8 rf_mode)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is up\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0, NFC_CMD_DEP_LINK_UP);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (rf_mode == NFC_RF_INITIATOR &&\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, NFC_ATTR_COMM_MODE, comm_mode) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, rf_mode))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tdev->dep_link_up = true;\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_dep_link_down_event(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is down\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_DEP_LINK_DOWN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_get_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tint rc = -ENOBUFS;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto out_putdev;\n\t}\n\n\trc = nfc_genl_send_device(msg, dev, info->snd_portid, info->snd_seq,\n\t\t\t\t  NULL, 0);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tnfc_put_device(dev);\n\n\treturn genlmsg_reply(msg, info);\n\nout_free:\n\tnlmsg_free(msg);\nout_putdev:\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_up(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_start_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tu32 im_protocols = 0, tm_protocols = 0;\n\n\tpr_debug(\"Poll start\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    ((!info->attrs[NFC_ATTR_IM_PROTOCOLS] &&\n\t      !info->attrs[NFC_ATTR_PROTOCOLS]) &&\n\t      !info->attrs[NFC_ATTR_TM_PROTOCOLS]))\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tif (info->attrs[NFC_ATTR_TM_PROTOCOLS])\n\t\ttm_protocols = nla_get_u32(info->attrs[NFC_ATTR_TM_PROTOCOLS]);\n\n\tif (info->attrs[NFC_ATTR_IM_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_IM_PROTOCOLS]);\n\telse if (info->attrs[NFC_ATTR_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\trc = nfc_start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc)\n\t\tdev->genl_data.poll_req_portid = info->snd_portid;\n\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_stop_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!dev->polling) {\n\t\tdevice_unlock(&dev->dev);\n\t\tnfc_put_device(dev);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\tif (dev->genl_data.poll_req_portid != info->snd_portid) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trc = nfc_stop_poll(dev);\n\tdev->genl_data.poll_req_portid = 0;\n\nout:\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_activate_target(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx, protocol;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX] ||\n\t    !info->attrs[NFC_ATTR_PROTOCOLS])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\tprotocol = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tnfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\trc = nfc_activate_target(dev, target_idx, protocol);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc, tgt_idx;\n\tu32 idx;\n\tu8 comm;\n\n\tpr_debug(\"DEP link up\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_COMM_MODE])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tif (!info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\ttgt_idx = NFC_TARGET_IDX_ANY;\n\telse\n\t\ttgt_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\tcomm = nla_get_u8(info->attrs[NFC_ATTR_COMM_MODE]);\n\n\tif (comm != NFC_COMM_ACTIVE && comm != NFC_COMM_PASSIVE)\n\t\treturn -EINVAL;\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_up(dev, tgt_idx, comm);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_params(struct sk_buff *msg,\n\t\t\t\tstruct nfc_llcp_local *local,\n\t\t\t\tu32 portid, u32 seq)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_LLC_GET_PARAMS);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, local->dev->idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_LTO, local->lto) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_RW, local->rw) ||\n\t    nla_put_u16(msg, NFC_ATTR_LLC_PARAM_MIUX, be16_to_cpu(local->miux)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\n\t\treturn rc;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_llc_sdreq(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tstruct nlattr *attr, *sdp_attrs[NFC_SDP_ATTR_MAX+1];\n\tu32 idx;\n\tu8 tid;\n\tchar *uri;\n\tint rc = 0, rem;\n\tsize_t uri_len, tlvs_len;\n\tstruct hlist_head sdreq_list;\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_LLC_SDP])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -ENOLINK;\n\t\tgoto exit;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tINIT_HLIST_HEAD(&sdreq_list);\n\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_fw_download(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tchar firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] || !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tnla_strscpy(firmware_name, info->attrs[NFC_ATTR_FIRMWARE_NAME],\n\t\t    sizeof(firmware_name));\n\n\trc = nfc_fw_download(dev, firmware_name);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nint nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_enable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_enable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_disable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_disable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_se(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\tstruct nfc_se *se, *n;\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n\t\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t\t  NFC_CMD_GET_SE);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (cb)\n\t\t\tgenl_dump_check_consistent(cb, hdr);\n\n\t\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se->idx) ||\n\t\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_ses(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_se(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfc_se_io(struct nfc_dev *dev, u32 se_idx,\n\t\t     u8 *apdu, size_t apdu_length,\n\t\t     se_io_cb_t cb, void *cb_context)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->se_io) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state != NFC_SE_ENABLED) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->se_io(dev, se_idx, apdu,\n\t\t\tapdu_length, cb, cb_context);\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstruct se_io_ctx {\n\tu32 dev_idx;\n\tu32 se_idx;\n};\n\nstatic void se_io_cb(void *context, u8 *apdu, size_t apdu_len, int err)\n{\n\tstruct se_io_ctx *ctx = context;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tkfree(ctx);\n\t\treturn;\n\t}\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_SE_IO);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, ctx->dev_idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, ctx->se_idx) ||\n\t    nla_put(msg, NFC_ATTR_SE_APDU, apdu_len, apdu))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\tkfree(ctx);\n\n\treturn;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\tkfree(ctx);\n\n\treturn;\n}\n\nstatic int nfc_genl_se_io(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct se_io_ctx *ctx;\n\tu32 dev_idx, se_idx;\n\tu8 *apdu;\n\tsize_t apdu_len;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_APDU])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->ops || !dev->ops->se_io)\n\t\treturn -ENOTSUPP;\n\n\tapdu_len = nla_len(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (apdu_len == 0)\n\t\treturn -EINVAL;\n\n\tapdu = nla_data(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (!apdu)\n\t\treturn -EINVAL;\n\n\tctx = kzalloc(sizeof(struct se_io_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev_idx = dev_idx;\n\tctx->se_idx = se_idx;\n\n\treturn nfc_se_io(dev, se_idx, apdu, apdu_len, se_io_cb, ctx);\n}\n\nstatic int nfc_genl_vendor_cmd(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tconst struct nfc_vendor_cmd *cmd;\n\tu32 dev_idx, vid, subcmd;\n\tu8 *data;\n\tsize_t data_len;\n\tint i, err;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tvid = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_SUBCMD]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev || !dev->vendor_cmds || !dev->n_vendor_cmds)\n\t\treturn -ENODEV;\n\n\tif (info->attrs[NFC_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tif (data_len == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdata = NULL;\n\t\tdata_len = 0;\n\t}\n\n\tfor (i = 0; i < dev->n_vendor_cmds; i++) {\n\t\tcmd = &dev->vendor_cmds[i];\n\n\t\tif (cmd->vendor_id != vid || cmd->subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tdev->cur_cmd_info = info;\n\t\terr = cmd->doit(dev, data, data_len);\n\t\tdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* message building helper */\nstatic inline void *nfc_hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\tint flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nfc_genl_family, flags, cmd);\n}\n\nstatic struct sk_buff *\n__nfc_alloc_vendor_cmd_skb(struct nfc_dev *dev, int approxlen,\n\t\t\t   u32 portid, u32 seq,\n\t\t\t   enum nfc_attrs attr,\n\t\t\t   u32 oui, u32 subcmd, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nfc_hdr_put(skb, portid, seq, 0, NFC_CMD_VENDOR);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_ID, oui))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_SUBCMD, subcmd))\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = dev;\n\t((void **)skb->cb)[1] = hdr;\n\n\treturn skb;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__nfc_alloc_vendor_cmd_reply_skb(struct nfc_dev *dev,\n\t\t\t\t\t\t enum nfc_attrs attr,\n\t\t\t\t\t\t u32 oui, u32 subcmd,\n\t\t\t\t\t\t int approxlen)\n{\n\tif (WARN_ON(!dev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __nfc_alloc_vendor_cmd_skb(dev, approxlen,\n\t\t\t\t\t  dev->cur_cmd_info->snd_portid,\n\t\t\t\t\t  dev->cur_cmd_info->snd_seq, attr,\n\t\t\t\t\t  oui, subcmd, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__nfc_alloc_vendor_cmd_reply_skb);\n\nint nfc_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct nfc_dev *dev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!dev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, dev->cur_cmd_info);\n}\nEXPORT_SYMBOL(nfc_vendor_cmd_reply);\n\nstatic const struct genl_ops nfc_genl_ops[] = {\n\t{\n\t\t.cmd = NFC_CMD_GET_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_get_device,\n\t\t.dumpit = nfc_genl_dump_devices,\n\t\t.done = nfc_genl_dump_devices_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_START_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_start_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_STOP_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_stop_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t.dumpit = nfc_genl_dump_targets,\n\t\t.done = nfc_genl_dump_targets_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_GET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_get_params,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_set_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SDREQ,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_sdreq,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_FW_DOWNLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_fw_download,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ENABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_enable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DISABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_disable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nfc_genl_dump_ses,\n\t\t.done = nfc_genl_dump_ses_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_SE_IO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_se_io,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_activate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_vendor_cmd,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_deactivate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family nfc_genl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NFC_GENL_NAME,\n\t.version = NFC_GENL_VERSION,\n\t.maxattr = NFC_ATTR_MAX,\n\t.policy = nfc_genl_policy,\n\t.module = THIS_MODULE,\n\t.ops = nfc_genl_ops,\n\t.n_ops = ARRAY_SIZE(nfc_genl_ops),\n\t.mcgrps = nfc_genl_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nfc_genl_mcgrps),\n};\n\n\nstruct urelease_work {\n\tstruct\twork_struct w;\n\tu32\tportid;\n};\n\nstatic void nfc_urelease_event_work(struct work_struct *work)\n{\n\tstruct urelease_work *w = container_of(work, struct urelease_work, w);\n\tstruct class_dev_iter iter;\n\tstruct nfc_dev *dev;\n\n\tpr_debug(\"portid %d\\n\", w->portid);\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tnfc_device_iter_init(&iter);\n\tdev = nfc_device_iter_next(&iter);\n\n\twhile (dev) {\n\t\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\t\tif (dev->genl_data.poll_req_portid == w->portid) {\n\t\t\tnfc_stop_poll(dev);\n\t\t\tdev->genl_data.poll_req_portid = 0;\n\t\t}\n\n\t\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\t\tdev = nfc_device_iter_next(&iter);\n\t}\n\n\tnfc_device_iter_exit(&iter);\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tkfree(w);\n}\n\nstatic int nfc_genl_rcv_nl_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct netlink_notify *n = ptr;\n\tstruct urelease_work *w;\n\n\tif (event != NETLINK_URELEASE || n->protocol != NETLINK_GENERIC)\n\t\tgoto out;\n\n\tpr_debug(\"NETLINK_URELEASE event from id %d\\n\", n->portid);\n\n\tw = kmalloc(sizeof(*w), GFP_ATOMIC);\n\tif (w) {\n\t\tINIT_WORK(&w->w, nfc_urelease_event_work);\n\t\tw->portid = n->portid;\n\t\tschedule_work(&w->w);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nvoid nfc_genl_data_init(struct nfc_genl_data *genl_data)\n{\n\tgenl_data->poll_req_portid = 0;\n\tmutex_init(&genl_data->genl_data_mutex);\n}\n\nvoid nfc_genl_data_exit(struct nfc_genl_data *genl_data)\n{\n\tmutex_destroy(&genl_data->genl_data_mutex);\n}\n\nstatic struct notifier_block nl_notifier = {\n\t.notifier_call  = nfc_genl_rcv_nl_event,\n};\n\n/**\n * nfc_genl_init() - Initialize netlink interface\n *\n * This initialization function registers the nfc netlink family.\n */\nint __init nfc_genl_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&nfc_genl_family);\n\tif (rc)\n\t\treturn rc;\n\n\tnetlink_register_notifier(&nl_notifier);\n\n\treturn 0;\n}\n\n/**\n * nfc_genl_exit() - Deinitialize netlink interface\n *\n * This exit function unregisters the nfc netlink family.\n */\nvoid nfc_genl_exit(void)\n{\n\tnetlink_unregister_notifier(&nl_notifier);\n\tgenl_unregister_family(&nfc_genl_family);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (C) 2011 Instituto Nokia de Tecnologia\n *\n * Authors:\n *    Lauro Ramos Venancio <lauro.venancio@openbossa.org>\n *    Aloisio Almeida Jr <aloisio.almeida@openbossa.org>\n *\n * Vendor commands implementation based on net/wireless/nl80211.c\n * which is:\n *\n * Copyright 2006-2010\tJohannes Berg <johannes@sipsolutions.net>\n * Copyright 2013-2014  Intel Mobile Communications GmbH\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": %s: \" fmt, __func__\n\n#include <net/genetlink.h>\n#include <linux/nfc.h>\n#include <linux/slab.h>\n\n#include \"nfc.h\"\n#include \"llcp.h\"\n\nstatic const struct genl_multicast_group nfc_genl_mcgrps[] = {\n\t{ .name = NFC_GENL_MCAST_EVENT_NAME, },\n};\n\nstatic struct genl_family nfc_genl_family;\nstatic const struct nla_policy nfc_genl_policy[NFC_ATTR_MAX + 1] = {\n\t[NFC_ATTR_DEVICE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_DEVICE_NAME] = { .type = NLA_STRING,\n\t\t\t\t.len = NFC_DEVICE_NAME_MAXSIZE },\n\t[NFC_ATTR_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TARGET_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_COMM_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_RF_MODE] = { .type = NLA_U8 },\n\t[NFC_ATTR_DEVICE_POWERED] = { .type = NLA_U8 },\n\t[NFC_ATTR_IM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_TM_PROTOCOLS] = { .type = NLA_U32 },\n\t[NFC_ATTR_LLC_PARAM_LTO] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_RW] = { .type = NLA_U8 },\n\t[NFC_ATTR_LLC_PARAM_MIUX] = { .type = NLA_U16 },\n\t[NFC_ATTR_LLC_SDP] = { .type = NLA_NESTED },\n\t[NFC_ATTR_FIRMWARE_NAME] = { .type = NLA_STRING,\n\t\t\t\t     .len = NFC_FIRMWARE_NAME_MAXSIZE },\n\t[NFC_ATTR_SE_INDEX] = { .type = NLA_U32 },\n\t[NFC_ATTR_SE_APDU] = { .type = NLA_BINARY },\n\t[NFC_ATTR_VENDOR_ID] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_SUBCMD] = { .type = NLA_U32 },\n\t[NFC_ATTR_VENDOR_DATA] = { .type = NLA_BINARY },\n\n};\n\nstatic const struct nla_policy nfc_sdp_genl_policy[NFC_SDP_ATTR_MAX + 1] = {\n\t[NFC_SDP_ATTR_URI] = { .type = NLA_STRING,\n\t\t\t       .len = U8_MAX - 4 },\n\t[NFC_SDP_ATTR_SAP] = { .type = NLA_U8 },\n};\n\nstatic int nfc_genl_send_target(struct sk_buff *msg, struct nfc_target *target,\n\t\t\t\tstruct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &nfc_genl_family, flags, NFC_CMD_GET_TARGET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, target->supported_protocols) ||\n\t    nla_put_u16(msg, NFC_ATTR_TARGET_SENS_RES, target->sens_res) ||\n\t    nla_put_u8(msg, NFC_ATTR_TARGET_SEL_RES, target->sel_res))\n\t\tgoto nla_put_failure;\n\tif (target->nfcid1_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_NFCID1, target->nfcid1_len,\n\t\t    target->nfcid1))\n\t\tgoto nla_put_failure;\n\tif (target->sensb_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSB_RES, target->sensb_res_len,\n\t\t    target->sensb_res))\n\t\tgoto nla_put_failure;\n\tif (target->sensf_res_len > 0 &&\n\t    nla_put(msg, NFC_ATTR_TARGET_SENSF_RES, target->sensf_res_len,\n\t\t    target->sensf_res))\n\t\tgoto nla_put_failure;\n\n\tif (target->is_iso15693) {\n\t\tif (nla_put_u8(msg, NFC_ATTR_TARGET_ISO15693_DSFID,\n\t\t\t       target->iso15693_dsfid) ||\n\t\t    nla_put(msg, NFC_ATTR_TARGET_ISO15693_UID,\n\t\t\t    sizeof(target->iso15693_uid), target->iso15693_uid))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic struct nfc_dev *__get_device_from_cb(struct netlink_callback *cb)\n{\n\tconst struct genl_dumpit_info *info = genl_dumpit_info(cb);\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dev;\n}\n\nstatic int nfc_genl_dump_targets(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tint i = cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tint rc;\n\n\tif (!dev) {\n\t\tdev = __get_device_from_cb(cb);\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\n\t\tcb->args[1] = (long) dev;\n\t}\n\n\tdevice_lock(&dev->dev);\n\n\tcb->seq = dev->targets_generation;\n\n\twhile (i < dev->n_targets) {\n\t\trc = nfc_genl_send_target(skb, &dev->targets[i], cb,\n\t\t\t\t\t  NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ti++;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tcb->args[0] = i;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_targets_done(struct netlink_callback *cb)\n{\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\n\tif (dev)\n\t\tnfc_put_device(dev);\n\n\treturn 0;\n}\n\nint nfc_genl_targets_found(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tdev->genl_data.poll_req_portid = 0;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGETS_FOUND);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TARGET_LOST);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_activated(struct nfc_dev *dev, u32 protocol)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_ACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(msg, NFC_ATTR_TM_PROTOCOLS, protocol))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_tm_deactivated(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_TM_DEACTIVATED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_setup_device_added(struct nfc_dev *dev, struct sk_buff *msg)\n{\n\tif (nla_put_string(msg, NFC_ATTR_DEVICE_NAME, nfc_device_name(dev)) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_PROTOCOLS, dev->supported_protocols) ||\n\t    nla_put_u8(msg, NFC_ATTR_DEVICE_POWERED, dev->dev_up) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, dev->rf_mode))\n\t\treturn -1;\n\treturn 0;\n}\n\nint nfc_genl_device_added(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_device_removed(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_DEVICE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_llc_send_sdres(struct nfc_dev *dev, struct hlist_head *sdres_list)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *sdp_attr, *uri_attr;\n\tstruct nfc_llcp_sdp_tlv *sdres;\n\tstruct hlist_node *n;\n\tvoid *hdr;\n\tint rc = -EMSGSIZE;\n\tint i;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_LLC_SDRES);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tsdp_attr = nla_nest_start_noflag(msg, NFC_ATTR_LLC_SDP);\n\tif (sdp_attr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto nla_put_failure;\n\t}\n\n\ti = 1;\n\thlist_for_each_entry_safe(sdres, n, sdres_list, node) {\n\t\tpr_debug(\"uri: %s, sap: %d\\n\", sdres->uri, sdres->sap);\n\n\t\turi_attr = nla_nest_start_noflag(msg, i++);\n\t\tif (uri_attr == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tif (nla_put_u8(msg, NFC_SDP_ATTR_SAP, sdres->sap))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (nla_put_string(msg, NFC_SDP_ATTR_URI, sdres->uri))\n\t\t\tgoto nla_put_failure;\n\n\t\tnla_nest_end(msg, uri_attr);\n\n\t\thlist_del(&sdres->node);\n\n\t\tnfc_llcp_free_sdp_tlv(sdres);\n\t}\n\n\tnla_nest_end(msg, sdp_attr);\n\n\tgenlmsg_end(msg, hdr);\n\n\treturn genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\n\tnfc_llcp_free_sdp_tlv_list(sdres_list);\n\n\treturn rc;\n}\n\nint nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_ADDED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_REMOVED);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_transaction(struct nfc_dev *dev, u8 se_idx,\n\t\t\t    struct nfc_evt_transaction *evt_transaction)\n{\n\tstruct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_TRANSACTION);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type) ||\n\t    nla_put(msg, NFC_ATTR_SE_AID, evt_transaction->aid_len,\n\t\t    evt_transaction->aid) ||\n\t    nla_put(msg, NFC_ATTR_SE_PARAMS, evt_transaction->params_len,\n\t\t    evt_transaction->params))\n\t\tgoto nla_put_failure;\n\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\t/* evt_transaction is no more used */\n\tdevm_kfree(&dev->dev, evt_transaction);\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_se_connectivity(struct nfc_dev *dev, u8 se_idx)\n{\n\tconst struct nfc_se *se;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_EVENT_SE_CONNECTIVITY);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t  NFC_CMD_GET_DEVICE);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nfc_genl_setup_device_added(dev, msg))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_devices(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_device(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_devices_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nint nfc_genl_dep_link_up_event(struct nfc_dev *dev, u32 target_idx,\n\t\t\t       u8 comm_mode, u8 rf_mode)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is up\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0, NFC_CMD_DEP_LINK_UP);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (rf_mode == NFC_RF_INITIATOR &&\n\t    nla_put_u32(msg, NFC_ATTR_TARGET_INDEX, target_idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(msg, NFC_ATTR_COMM_MODE, comm_mode) ||\n\t    nla_put_u8(msg, NFC_ATTR_RF_MODE, rf_mode))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tdev->dep_link_up = true;\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nint nfc_genl_dep_link_down_event(struct nfc_dev *dev)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tpr_debug(\"DEP link is down\\n\");\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_DEP_LINK_DOWN);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_get_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct sk_buff *msg;\n\tstruct nfc_dev *dev;\n\tu32 idx;\n\tint rc = -ENOBUFS;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto out_putdev;\n\t}\n\n\trc = nfc_genl_send_device(msg, dev, info->snd_portid, info->snd_seq,\n\t\t\t\t  NULL, 0);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tnfc_put_device(dev);\n\n\treturn genlmsg_reply(msg, info);\n\nout_free:\n\tnlmsg_free(msg);\nout_putdev:\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_up(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dev_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dev_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_start_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tu32 im_protocols = 0, tm_protocols = 0;\n\n\tpr_debug(\"Poll start\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    ((!info->attrs[NFC_ATTR_IM_PROTOCOLS] &&\n\t      !info->attrs[NFC_ATTR_PROTOCOLS]) &&\n\t      !info->attrs[NFC_ATTR_TM_PROTOCOLS]))\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tif (info->attrs[NFC_ATTR_TM_PROTOCOLS])\n\t\ttm_protocols = nla_get_u32(info->attrs[NFC_ATTR_TM_PROTOCOLS]);\n\n\tif (info->attrs[NFC_ATTR_IM_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_IM_PROTOCOLS]);\n\telse if (info->attrs[NFC_ATTR_PROTOCOLS])\n\t\tim_protocols = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\trc = nfc_start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc)\n\t\tdev->genl_data.poll_req_portid = info->snd_portid;\n\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_stop_poll(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (!dev->polling) {\n\t\tdevice_unlock(&dev->dev);\n\t\tnfc_put_device(dev);\n\t\treturn -EINVAL;\n\t}\n\n\tdevice_unlock(&dev->dev);\n\n\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\tif (dev->genl_data.poll_req_portid != info->snd_portid) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trc = nfc_stop_poll(dev);\n\tdev->genl_data.poll_req_portid = 0;\n\nout:\n\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_activate_target(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx, protocol;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX] ||\n\t    !info->attrs[NFC_ATTR_PROTOCOLS])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\tprotocol = nla_get_u32(info->attrs[NFC_ATTR_PROTOCOLS]);\n\n\tnfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\trc = nfc_activate_target(dev, target_idx, protocol);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_up(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc, tgt_idx;\n\tu32 idx;\n\tu8 comm;\n\n\tpr_debug(\"DEP link up\\n\");\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_COMM_MODE])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tif (!info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\ttgt_idx = NFC_TARGET_IDX_ANY;\n\telse\n\t\ttgt_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\tcomm = nla_get_u8(info->attrs[NFC_ATTR_COMM_MODE]);\n\n\tif (comm != NFC_COMM_ACTIVE && comm != NFC_COMM_PASSIVE)\n\t\treturn -EINVAL;\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_up(dev, tgt_idx, comm);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_dep_link_down(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_dep_link_down(dev);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_params(struct sk_buff *msg,\n\t\t\t\tstruct nfc_llcp_local *local,\n\t\t\t\tu32 portid, u32 seq)\n{\n\tvoid *hdr;\n\n\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_LLC_GET_PARAMS);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, local->dev->idx) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_LTO, local->lto) ||\n\t    nla_put_u8(msg, NFC_ATTR_LLC_PARAM_RW, local->rw) ||\n\t    nla_put_u16(msg, NFC_ATTR_LLC_PARAM_MIUX, be16_to_cpu(local->miux)))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\n\t\treturn rc;\n\t}\n\n\treturn genlmsg_reply(msg, info);\n}\n\nstatic int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_llc_sdreq(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tstruct nlattr *attr, *sdp_attrs[NFC_SDP_ATTR_MAX+1];\n\tu32 idx;\n\tu8 tid;\n\tchar *uri;\n\tint rc = 0, rem;\n\tsize_t uri_len, tlvs_len;\n\tstruct hlist_head sdreq_list;\n\tstruct nfc_llcp_sdp_tlv *sdreq;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_LLC_SDP])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->dep_link_up == false) {\n\t\trc = -ENOLINK;\n\t\tgoto exit;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tINIT_HLIST_HEAD(&sdreq_list);\n\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}\n\nstatic int nfc_genl_fw_download(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx;\n\tchar firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] || !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tnla_strscpy(firmware_name, info->attrs[NFC_ATTR_FIRMWARE_NAME],\n\t\t    sizeof(firmware_name));\n\n\trc = nfc_fw_download(dev, firmware_name);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nint nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_enable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_enable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_disable_se(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tint rc;\n\tu32 idx, se_idx;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\trc = nfc_disable_se(dev, se_idx);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}\n\nstatic int nfc_genl_send_se(struct sk_buff *msg, struct nfc_dev *dev,\n\t\t\t\tu32 portid, u32 seq,\n\t\t\t\tstruct netlink_callback *cb,\n\t\t\t\tint flags)\n{\n\tvoid *hdr;\n\tstruct nfc_se *se, *n;\n\n\tlist_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n\t\thdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,\n\t\t\t\t  NFC_CMD_GET_SE);\n\t\tif (!hdr)\n\t\t\tgoto nla_put_failure;\n\n\t\tif (cb)\n\t\t\tgenl_dump_check_consistent(cb, hdr);\n\n\t\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||\n\t\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se->idx) ||\n\t\t    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))\n\t\t\tgoto nla_put_failure;\n\n\t\tgenlmsg_end(msg, hdr);\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int nfc_genl_dump_ses(struct sk_buff *skb,\n\t\t\t\t struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\tstruct nfc_dev *dev = (struct nfc_dev *) cb->args[1];\n\tbool first_call = false;\n\n\tif (!iter) {\n\t\tfirst_call = true;\n\t\titer = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);\n\t\tif (!iter)\n\t\t\treturn -ENOMEM;\n\t\tcb->args[0] = (long) iter;\n\t}\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tcb->seq = nfc_devlist_generation;\n\n\tif (first_call) {\n\t\tnfc_device_iter_init(iter);\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\twhile (dev) {\n\t\tint rc;\n\n\t\trc = nfc_genl_send_se(skb, dev, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tdev = nfc_device_iter_next(iter);\n\t}\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tcb->args[1] = (long) dev;\n\n\treturn skb->len;\n}\n\nstatic int nfc_genl_dump_ses_done(struct netlink_callback *cb)\n{\n\tstruct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];\n\n\tif (iter) {\n\t\tnfc_device_iter_exit(iter);\n\t\tkfree(iter);\n\t}\n\n\treturn 0;\n}\n\nstatic int nfc_se_io(struct nfc_dev *dev, u32 se_idx,\n\t\t     u8 *apdu, size_t apdu_length,\n\t\t     se_io_cb_t cb, void *cb_context)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->se_io) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (se->state != NFC_SE_ENABLED) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\trc = dev->ops->se_io(dev, se_idx, apdu,\n\t\t\tapdu_length, cb, cb_context);\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}\n\nstruct se_io_ctx {\n\tu32 dev_idx;\n\tu32 se_idx;\n};\n\nstatic void se_io_cb(void *context, u8 *apdu, size_t apdu_len, int err)\n{\n\tstruct se_io_ctx *ctx = context;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\tkfree(ctx);\n\t\treturn;\n\t}\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_SE_IO);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, ctx->dev_idx) ||\n\t    nla_put_u32(msg, NFC_ATTR_SE_INDEX, ctx->se_idx) ||\n\t    nla_put(msg, NFC_ATTR_SE_APDU, apdu_len, apdu))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\tkfree(ctx);\n\n\treturn;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\tkfree(ctx);\n\n\treturn;\n}\n\nstatic int nfc_genl_se_io(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct se_io_ctx *ctx;\n\tu32 dev_idx, se_idx;\n\tu8 *apdu;\n\tsize_t apdu_len;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_SE_APDU])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tse_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!dev->ops || !dev->ops->se_io)\n\t\treturn -ENOTSUPP;\n\n\tapdu_len = nla_len(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (apdu_len == 0)\n\t\treturn -EINVAL;\n\n\tapdu = nla_data(info->attrs[NFC_ATTR_SE_APDU]);\n\tif (!apdu)\n\t\treturn -EINVAL;\n\n\tctx = kzalloc(sizeof(struct se_io_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev_idx = dev_idx;\n\tctx->se_idx = se_idx;\n\n\treturn nfc_se_io(dev, se_idx, apdu, apdu_len, se_io_cb, ctx);\n}\n\nstatic int nfc_genl_vendor_cmd(struct sk_buff *skb,\n\t\t\t       struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tconst struct nfc_vendor_cmd *cmd;\n\tu32 dev_idx, vid, subcmd;\n\tu8 *data;\n\tsize_t data_len;\n\tint i, err;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_ID] ||\n\t    !info->attrs[NFC_ATTR_VENDOR_SUBCMD])\n\t\treturn -EINVAL;\n\n\tdev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tvid = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_ID]);\n\tsubcmd = nla_get_u32(info->attrs[NFC_ATTR_VENDOR_SUBCMD]);\n\n\tdev = nfc_get_device(dev_idx);\n\tif (!dev || !dev->vendor_cmds || !dev->n_vendor_cmds)\n\t\treturn -ENODEV;\n\n\tif (info->attrs[NFC_ATTR_VENDOR_DATA]) {\n\t\tdata = nla_data(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tdata_len = nla_len(info->attrs[NFC_ATTR_VENDOR_DATA]);\n\t\tif (data_len == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdata = NULL;\n\t\tdata_len = 0;\n\t}\n\n\tfor (i = 0; i < dev->n_vendor_cmds; i++) {\n\t\tcmd = &dev->vendor_cmds[i];\n\n\t\tif (cmd->vendor_id != vid || cmd->subcmd != subcmd)\n\t\t\tcontinue;\n\n\t\tdev->cur_cmd_info = info;\n\t\terr = cmd->doit(dev, data, data_len);\n\t\tdev->cur_cmd_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\n/* message building helper */\nstatic inline void *nfc_hdr_put(struct sk_buff *skb, u32 portid, u32 seq,\n\t\t\t\tint flags, u8 cmd)\n{\n\t/* since there is no private header just add the generic one */\n\treturn genlmsg_put(skb, portid, seq, &nfc_genl_family, flags, cmd);\n}\n\nstatic struct sk_buff *\n__nfc_alloc_vendor_cmd_skb(struct nfc_dev *dev, int approxlen,\n\t\t\t   u32 portid, u32 seq,\n\t\t\t   enum nfc_attrs attr,\n\t\t\t   u32 oui, u32 subcmd, gfp_t gfp)\n{\n\tstruct sk_buff *skb;\n\tvoid *hdr;\n\n\tskb = nlmsg_new(approxlen + 100, gfp);\n\tif (!skb)\n\t\treturn NULL;\n\n\thdr = nfc_hdr_put(skb, portid, seq, 0, NFC_CMD_VENDOR);\n\tif (!hdr) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tif (nla_put_u32(skb, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_ID, oui))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, NFC_ATTR_VENDOR_SUBCMD, subcmd))\n\t\tgoto nla_put_failure;\n\n\t((void **)skb->cb)[0] = dev;\n\t((void **)skb->cb)[1] = hdr;\n\n\treturn skb;\n\nnla_put_failure:\n\tkfree_skb(skb);\n\treturn NULL;\n}\n\nstruct sk_buff *__nfc_alloc_vendor_cmd_reply_skb(struct nfc_dev *dev,\n\t\t\t\t\t\t enum nfc_attrs attr,\n\t\t\t\t\t\t u32 oui, u32 subcmd,\n\t\t\t\t\t\t int approxlen)\n{\n\tif (WARN_ON(!dev->cur_cmd_info))\n\t\treturn NULL;\n\n\treturn __nfc_alloc_vendor_cmd_skb(dev, approxlen,\n\t\t\t\t\t  dev->cur_cmd_info->snd_portid,\n\t\t\t\t\t  dev->cur_cmd_info->snd_seq, attr,\n\t\t\t\t\t  oui, subcmd, GFP_KERNEL);\n}\nEXPORT_SYMBOL(__nfc_alloc_vendor_cmd_reply_skb);\n\nint nfc_vendor_cmd_reply(struct sk_buff *skb)\n{\n\tstruct nfc_dev *dev = ((void **)skb->cb)[0];\n\tvoid *hdr = ((void **)skb->cb)[1];\n\n\t/* clear CB data for netlink core to own from now on */\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\tif (WARN_ON(!dev->cur_cmd_info)) {\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tgenlmsg_end(skb, hdr);\n\treturn genlmsg_reply(skb, dev->cur_cmd_info);\n}\nEXPORT_SYMBOL(nfc_vendor_cmd_reply);\n\nstatic const struct genl_ops nfc_genl_ops[] = {\n\t{\n\t\t.cmd = NFC_CMD_GET_DEVICE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_get_device,\n\t\t.dumpit = nfc_genl_dump_devices,\n\t\t.done = nfc_genl_dump_devices_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEV_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dev_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_START_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_start_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_STOP_POLL,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_stop_poll,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_UP,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_up,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEP_LINK_DOWN,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_dep_link_down,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT |\n\t\t\t    GENL_DONT_VALIDATE_DUMP_STRICT,\n\t\t.dumpit = nfc_genl_dump_targets,\n\t\t.done = nfc_genl_dump_targets_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_GET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_get_params,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SET_PARAMS,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_set_params,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_LLC_SDREQ,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_llc_sdreq,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_FW_DOWNLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_fw_download,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ENABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_enable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DISABLE_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_disable_se,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_GET_SE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = nfc_genl_dump_ses,\n\t\t.done = nfc_genl_dump_ses_done,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_SE_IO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_se_io,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_ACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_activate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_VENDOR,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_vendor_cmd,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = NFC_CMD_DEACTIVATE_TARGET,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = nfc_genl_deactivate_target,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family nfc_genl_family __ro_after_init = {\n\t.hdrsize = 0,\n\t.name = NFC_GENL_NAME,\n\t.version = NFC_GENL_VERSION,\n\t.maxattr = NFC_ATTR_MAX,\n\t.policy = nfc_genl_policy,\n\t.module = THIS_MODULE,\n\t.ops = nfc_genl_ops,\n\t.n_ops = ARRAY_SIZE(nfc_genl_ops),\n\t.mcgrps = nfc_genl_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(nfc_genl_mcgrps),\n};\n\n\nstruct urelease_work {\n\tstruct\twork_struct w;\n\tu32\tportid;\n};\n\nstatic void nfc_urelease_event_work(struct work_struct *work)\n{\n\tstruct urelease_work *w = container_of(work, struct urelease_work, w);\n\tstruct class_dev_iter iter;\n\tstruct nfc_dev *dev;\n\n\tpr_debug(\"portid %d\\n\", w->portid);\n\n\tmutex_lock(&nfc_devlist_mutex);\n\n\tnfc_device_iter_init(&iter);\n\tdev = nfc_device_iter_next(&iter);\n\n\twhile (dev) {\n\t\tmutex_lock(&dev->genl_data.genl_data_mutex);\n\n\t\tif (dev->genl_data.poll_req_portid == w->portid) {\n\t\t\tnfc_stop_poll(dev);\n\t\t\tdev->genl_data.poll_req_portid = 0;\n\t\t}\n\n\t\tmutex_unlock(&dev->genl_data.genl_data_mutex);\n\n\t\tdev = nfc_device_iter_next(&iter);\n\t}\n\n\tnfc_device_iter_exit(&iter);\n\n\tmutex_unlock(&nfc_devlist_mutex);\n\n\tkfree(w);\n}\n\nstatic int nfc_genl_rcv_nl_event(struct notifier_block *this,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct netlink_notify *n = ptr;\n\tstruct urelease_work *w;\n\n\tif (event != NETLINK_URELEASE || n->protocol != NETLINK_GENERIC)\n\t\tgoto out;\n\n\tpr_debug(\"NETLINK_URELEASE event from id %d\\n\", n->portid);\n\n\tw = kmalloc(sizeof(*w), GFP_ATOMIC);\n\tif (w) {\n\t\tINIT_WORK(&w->w, nfc_urelease_event_work);\n\t\tw->portid = n->portid;\n\t\tschedule_work(&w->w);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}\n\nvoid nfc_genl_data_init(struct nfc_genl_data *genl_data)\n{\n\tgenl_data->poll_req_portid = 0;\n\tmutex_init(&genl_data->genl_data_mutex);\n}\n\nvoid nfc_genl_data_exit(struct nfc_genl_data *genl_data)\n{\n\tmutex_destroy(&genl_data->genl_data_mutex);\n}\n\nstatic struct notifier_block nl_notifier = {\n\t.notifier_call  = nfc_genl_rcv_nl_event,\n};\n\n/**\n * nfc_genl_init() - Initialize netlink interface\n *\n * This initialization function registers the nfc netlink family.\n */\nint __init nfc_genl_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&nfc_genl_family);\n\tif (rc)\n\t\treturn rc;\n\n\tnetlink_register_notifier(&nl_notifier);\n\n\treturn 0;\n}\n\n/**\n * nfc_genl_exit() - Deinitialize netlink interface\n *\n * This exit function unregisters the nfc netlink family.\n */\nvoid nfc_genl_exit(void)\n{\n\tnetlink_unregister_notifier(&nl_notifier);\n\tgenl_unregister_family(&nfc_genl_family);\n}\n"], "filenames": ["net/nfc/netlink.c"], "buggy_code_start_loc": [1247], "buggy_code_end_loc": [1264], "fixing_code_start_loc": [1247], "fixing_code_end_loc": [1264], "type": "NVD-CWE-noinfo", "message": "There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker to crash the Linux kernel by simulating a nfc device from user-space.", "other": {"cve": {"id": "CVE-2022-1975", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-31T16:15:10.063", "lastModified": "2022-09-07T16:49:27.080", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a sleep-in-atomic bug in /net/nfc/netlink.c that allows an attacker to crash the Linux kernel by simulating a nfc device from user-space."}, {"lang": "es", "value": "Se presenta un fallo de sleep-in-atomic en /net/nfc/netlink.c que permite a un atacante bloquear el kernel de Linux al simular un dispositivo nfc desde el espacio de usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-248"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.18:rc6:*:*:*:*:*:*", "matchCriteriaId": "EE723F14-047B-4FCF-B109-E0542EDFB063"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/4071bf121d59944d5cd2238de0642f3d7995a997", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4071bf121d59944d5cd2238de0642f3d7995a997"}}