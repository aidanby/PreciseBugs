{"buggy_code": ["// Copyright 2016 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\n// Package les implements the Light Ethereum Subprotocol.\npackage les\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/consensus\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/eth/downloader\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/event\"\n\t\"github.com/ethereum/go-ethereum/light\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/p2p\"\n\t\"github.com/ethereum/go-ethereum/p2p/discover\"\n\t\"github.com/ethereum/go-ethereum/p2p/discv5\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/ethereum/go-ethereum/rlp\"\n\t\"github.com/ethereum/go-ethereum/trie\"\n)\n\nconst (\n\tsoftResponseLimit = 2 * 1024 * 1024 // Target maximum size of returned blocks, headers or node data.\n\testHeaderRlpSize  = 500             // Approximate size of an RLP encoded block header\n\n\tethVersion = 63 // equivalent eth version for the downloader\n\n\tMaxHeaderFetch           = 192 // Amount of block headers to be fetched per retrieval request\n\tMaxBodyFetch             = 32  // Amount of block bodies to be fetched per retrieval request\n\tMaxReceiptFetch          = 128 // Amount of transaction receipts to allow fetching per request\n\tMaxCodeFetch             = 64  // Amount of contract codes to allow fetching per request\n\tMaxProofsFetch           = 64  // Amount of merkle proofs to be fetched per retrieval request\n\tMaxHelperTrieProofsFetch = 64  // Amount of merkle proofs to be fetched per retrieval request\n\tMaxTxSend                = 64  // Amount of transactions to be send per request\n\tMaxTxStatus              = 256 // Amount of transactions to queried per request\n\n\tdisableClientRemovePeer = false\n)\n\n// errIncompatibleConfig is returned if the requested protocols and configs are\n// not compatible (low protocol version restrictions and high requirements).\nvar errIncompatibleConfig = errors.New(\"incompatible configuration\")\n\nfunc errResp(code errCode, format string, v ...interface{}) error {\n\treturn fmt.Errorf(\"%v - %v\", code, fmt.Sprintf(format, v...))\n}\n\ntype BlockChain interface {\n\tConfig() *params.ChainConfig\n\tHasHeader(hash common.Hash, number uint64) bool\n\tGetHeader(hash common.Hash, number uint64) *types.Header\n\tGetHeaderByHash(hash common.Hash) *types.Header\n\tCurrentHeader() *types.Header\n\tGetTd(hash common.Hash, number uint64) *big.Int\n\tState() (*state.StateDB, error)\n\tInsertHeaderChain(chain []*types.Header, checkFreq int) (int, error)\n\tRollback(chain []common.Hash)\n\tGetHeaderByNumber(number uint64) *types.Header\n\tGetBlockHashesFromHash(hash common.Hash, max uint64) []common.Hash\n\tGenesis() *types.Block\n\tSubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription\n}\n\ntype txPool interface {\n\tAddRemotes(txs []*types.Transaction) []error\n\tStatus(hashes []common.Hash) []core.TxStatus\n}\n\ntype ProtocolManager struct {\n\tlightSync   bool\n\ttxpool      txPool\n\ttxrelay     *LesTxRelay\n\tnetworkId   uint64\n\tchainConfig *params.ChainConfig\n\tblockchain  BlockChain\n\tchainDb     ethdb.Database\n\todr         *LesOdr\n\tserver      *LesServer\n\tserverPool  *serverPool\n\tlesTopic    discv5.Topic\n\treqDist     *requestDistributor\n\tretriever   *retrieveManager\n\n\tdownloader *downloader.Downloader\n\tfetcher    *lightFetcher\n\tpeers      *peerSet\n\tmaxPeers   int\n\n\tSubProtocols []p2p.Protocol\n\n\teventMux *event.TypeMux\n\n\t// channels for fetcher, syncer, txsyncLoop\n\tnewPeerCh   chan *peer\n\tquitSync    chan struct{}\n\tnoMorePeers chan struct{}\n\n\t// wait group is used for graceful shutdowns during downloading\n\t// and processing\n\twg *sync.WaitGroup\n}\n\n// NewProtocolManager returns a new ethereum sub protocol manager. The Ethereum sub protocol manages peers capable\n// with the ethereum network.\nfunc NewProtocolManager(chainConfig *params.ChainConfig, lightSync bool, protocolVersions []uint, networkId uint64, mux *event.TypeMux, engine consensus.Engine, peers *peerSet, blockchain BlockChain, txpool txPool, chainDb ethdb.Database, odr *LesOdr, txrelay *LesTxRelay, quitSync chan struct{}, wg *sync.WaitGroup) (*ProtocolManager, error) {\n\t// Create the protocol manager with the base fields\n\tmanager := &ProtocolManager{\n\t\tlightSync:   lightSync,\n\t\teventMux:    mux,\n\t\tblockchain:  blockchain,\n\t\tchainConfig: chainConfig,\n\t\tchainDb:     chainDb,\n\t\todr:         odr,\n\t\tnetworkId:   networkId,\n\t\ttxpool:      txpool,\n\t\ttxrelay:     txrelay,\n\t\tpeers:       peers,\n\t\tnewPeerCh:   make(chan *peer),\n\t\tquitSync:    quitSync,\n\t\twg:          wg,\n\t\tnoMorePeers: make(chan struct{}),\n\t}\n\tif odr != nil {\n\t\tmanager.retriever = odr.retriever\n\t\tmanager.reqDist = odr.retriever.dist\n\t}\n\n\t// Initiate a sub-protocol for every implemented version we can handle\n\tmanager.SubProtocols = make([]p2p.Protocol, 0, len(protocolVersions))\n\tfor _, version := range protocolVersions {\n\t\t// Compatible, initialize the sub-protocol\n\t\tversion := version // Closure for the run\n\t\tmanager.SubProtocols = append(manager.SubProtocols, p2p.Protocol{\n\t\t\tName:    \"les\",\n\t\t\tVersion: version,\n\t\t\tLength:  ProtocolLengths[version],\n\t\t\tRun: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {\n\t\t\t\tvar entry *poolEntry\n\t\t\t\tpeer := manager.newPeer(int(version), networkId, p, rw)\n\t\t\t\tif manager.serverPool != nil {\n\t\t\t\t\taddr := p.RemoteAddr().(*net.TCPAddr)\n\t\t\t\t\tentry = manager.serverPool.connect(peer, addr.IP, uint16(addr.Port))\n\t\t\t\t}\n\t\t\t\tpeer.poolEntry = entry\n\t\t\t\tselect {\n\t\t\t\tcase manager.newPeerCh <- peer:\n\t\t\t\t\tmanager.wg.Add(1)\n\t\t\t\t\tdefer manager.wg.Done()\n\t\t\t\t\terr := manager.handle(peer)\n\t\t\t\t\tif entry != nil {\n\t\t\t\t\t\tmanager.serverPool.disconnect(entry)\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\tcase <-manager.quitSync:\n\t\t\t\t\tif entry != nil {\n\t\t\t\t\t\tmanager.serverPool.disconnect(entry)\n\t\t\t\t\t}\n\t\t\t\t\treturn p2p.DiscQuitting\n\t\t\t\t}\n\t\t\t},\n\t\t\tNodeInfo: func() interface{} {\n\t\t\t\treturn manager.NodeInfo()\n\t\t\t},\n\t\t\tPeerInfo: func(id discover.NodeID) interface{} {\n\t\t\t\tif p := manager.peers.Peer(fmt.Sprintf(\"%x\", id[:8])); p != nil {\n\t\t\t\t\treturn p.Info()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t}\n\tif len(manager.SubProtocols) == 0 {\n\t\treturn nil, errIncompatibleConfig\n\t}\n\n\tremovePeer := manager.removePeer\n\tif disableClientRemovePeer {\n\t\tremovePeer = func(id string) {}\n\t}\n\n\tif lightSync {\n\t\tmanager.downloader = downloader.New(downloader.LightSync, chainDb, manager.eventMux, nil, blockchain, removePeer)\n\t\tmanager.peers.notify((*downloaderPeerNotify)(manager))\n\t\tmanager.fetcher = newLightFetcher(manager)\n\t}\n\n\treturn manager, nil\n}\n\n// removePeer initiates disconnection from a peer by removing it from the peer set\nfunc (pm *ProtocolManager) removePeer(id string) {\n\tpm.peers.Unregister(id)\n}\n\nfunc (pm *ProtocolManager) Start(maxPeers int) {\n\tpm.maxPeers = maxPeers\n\n\tif pm.lightSync {\n\t\tgo pm.syncer()\n\t} else {\n\t\tgo func() {\n\t\t\tfor range pm.newPeerCh {\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc (pm *ProtocolManager) Stop() {\n\t// Showing a log message. During download / process this could actually\n\t// take between 5 to 10 seconds and therefor feedback is required.\n\tlog.Info(\"Stopping light Ethereum protocol\")\n\n\t// Quit the sync loop.\n\t// After this send has completed, no new peers will be accepted.\n\tpm.noMorePeers <- struct{}{}\n\n\tclose(pm.quitSync) // quits syncer, fetcher\n\n\t// Disconnect existing sessions.\n\t// This also closes the gate for any new registrations on the peer set.\n\t// sessions which are already established but not added to pm.peers yet\n\t// will exit when they try to register.\n\tpm.peers.Close()\n\n\t// Wait for any process action\n\tpm.wg.Wait()\n\n\tlog.Info(\"Light Ethereum protocol stopped\")\n}\n\nfunc (pm *ProtocolManager) newPeer(pv int, nv uint64, p *p2p.Peer, rw p2p.MsgReadWriter) *peer {\n\treturn newPeer(pv, nv, p, newMeteredMsgWriter(rw))\n}\n\n// handle is the callback invoked to manage the life cycle of a les peer. When\n// this function terminates, the peer is disconnected.\nfunc (pm *ProtocolManager) handle(p *peer) error {\n\t// Ignore maxPeers if this is a trusted peer\n\tif pm.peers.Len() >= pm.maxPeers && !p.Peer.Info().Network.Trusted {\n\t\treturn p2p.DiscTooManyPeers\n\t}\n\n\tp.Log().Debug(\"Light Ethereum peer connected\", \"name\", p.Name())\n\n\t// Execute the LES handshake\n\tvar (\n\t\tgenesis = pm.blockchain.Genesis()\n\t\thead    = pm.blockchain.CurrentHeader()\n\t\thash    = head.Hash()\n\t\tnumber  = head.Number.Uint64()\n\t\ttd      = pm.blockchain.GetTd(hash, number)\n\t)\n\tif err := p.Handshake(td, hash, number, genesis.Hash(), pm.server); err != nil {\n\t\tp.Log().Debug(\"Light Ethereum handshake failed\", \"err\", err)\n\t\treturn err\n\t}\n\tif rw, ok := p.rw.(*meteredMsgReadWriter); ok {\n\t\trw.Init(p.version)\n\t}\n\t// Register the peer locally\n\tif err := pm.peers.Register(p); err != nil {\n\t\tp.Log().Error(\"Light Ethereum peer registration failed\", \"err\", err)\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif pm.server != nil && pm.server.fcManager != nil && p.fcClient != nil {\n\t\t\tp.fcClient.Remove(pm.server.fcManager)\n\t\t}\n\t\tpm.removePeer(p.id)\n\t}()\n\t// Register the peer in the downloader. If the downloader considers it banned, we disconnect\n\tif pm.lightSync {\n\t\tp.lock.Lock()\n\t\thead := p.headInfo\n\t\tp.lock.Unlock()\n\t\tif pm.fetcher != nil {\n\t\t\tpm.fetcher.announce(p, head)\n\t\t}\n\n\t\tif p.poolEntry != nil {\n\t\t\tpm.serverPool.registered(p.poolEntry)\n\t\t}\n\t}\n\n\tstop := make(chan struct{})\n\tdefer close(stop)\n\tgo func() {\n\t\t// new block announce loop\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase announce := <-p.announceChn:\n\t\t\t\tp.SendAnnounce(announce)\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// main loop. handle incoming messages.\n\tfor {\n\t\tif err := pm.handleMsg(p); err != nil {\n\t\t\tp.Log().Debug(\"Light Ethereum message handling failed\", \"err\", err)\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nvar reqList = []uint64{GetBlockHeadersMsg, GetBlockBodiesMsg, GetCodeMsg, GetReceiptsMsg, GetProofsV1Msg, SendTxMsg, SendTxV2Msg, GetTxStatusMsg, GetHeaderProofsMsg, GetProofsV2Msg, GetHelperTrieProofsMsg}\n\n// handleMsg is invoked whenever an inbound message is received from a remote\n// peer. The remote connection is torn down upon returning any error.\nfunc (pm *ProtocolManager) handleMsg(p *peer) error {\n\t// Read the next message from the remote peer, and ensure it's fully consumed\n\tmsg, err := p.rw.ReadMsg()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.Log().Trace(\"Light Ethereum message arrived\", \"code\", msg.Code, \"bytes\", msg.Size)\n\n\tcosts := p.fcCosts[msg.Code]\n\treject := func(reqCnt, maxCnt uint64) bool {\n\t\tif p.fcClient == nil || reqCnt > maxCnt {\n\t\t\treturn true\n\t\t}\n\t\tbufValue, _ := p.fcClient.AcceptRequest()\n\t\tcost := costs.baseCost + reqCnt*costs.reqCost\n\t\tif cost > pm.server.defParams.BufLimit {\n\t\t\tcost = pm.server.defParams.BufLimit\n\t\t}\n\t\tif cost > bufValue {\n\t\t\trecharge := time.Duration((cost - bufValue) * 1000000 / pm.server.defParams.MinRecharge)\n\t\t\tp.Log().Error(\"Request came too early\", \"recharge\", common.PrettyDuration(recharge))\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tif msg.Size > ProtocolMaxMsgSize {\n\t\treturn errResp(ErrMsgTooLarge, \"%v > %v\", msg.Size, ProtocolMaxMsgSize)\n\t}\n\tdefer msg.Discard()\n\n\tvar deliverMsg *Msg\n\n\t// Handle the message depending on its contents\n\tswitch msg.Code {\n\tcase StatusMsg:\n\t\tp.Log().Trace(\"Received status message\")\n\t\t// Status messages should never arrive after the handshake\n\t\treturn errResp(ErrExtraStatusMsg, \"uncontrolled status message\")\n\n\t// Block header query, collect the requested headers and reply\n\tcase AnnounceMsg:\n\t\tp.Log().Trace(\"Received announce message\")\n\t\tif p.requestAnnounceType == announceTypeNone {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tvar req announceData\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"%v: %v\", msg, err)\n\t\t}\n\n\t\tif p.requestAnnounceType == announceTypeSigned {\n\t\t\tif err := req.checkSignature(p.pubKey); err != nil {\n\t\t\t\tp.Log().Trace(\"Invalid announcement signature\", \"err\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tp.Log().Trace(\"Valid announcement signature\")\n\t\t}\n\n\t\tp.Log().Trace(\"Announce message content\", \"number\", req.Number, \"hash\", req.Hash, \"td\", req.Td, \"reorg\", req.ReorgDepth)\n\t\tif pm.fetcher != nil {\n\t\t\tpm.fetcher.announce(p, &req)\n\t\t}\n\n\tcase GetBlockHeadersMsg:\n\t\tp.Log().Trace(\"Received block header request\")\n\t\t// Decode the complex header query\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tQuery getBlockHeadersData\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"%v: %v\", msg, err)\n\t\t}\n\n\t\tquery := req.Query\n\t\tif reject(query.Amount, MaxHeaderFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\thashMode := query.Origin.Hash != (common.Hash{})\n\n\t\t// Gather headers until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes   common.StorageSize\n\t\t\theaders []*types.Header\n\t\t\tunknown bool\n\t\t)\n\t\tfor !unknown && len(headers) < int(query.Amount) && bytes < softResponseLimit {\n\t\t\t// Retrieve the next header satisfying the query\n\t\t\tvar origin *types.Header\n\t\t\tif hashMode {\n\t\t\t\torigin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)\n\t\t\t} else {\n\t\t\t\torigin = pm.blockchain.GetHeaderByNumber(query.Origin.Number)\n\t\t\t}\n\t\t\tif origin == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnumber := origin.Number.Uint64()\n\t\t\theaders = append(headers, origin)\n\t\t\tbytes += estHeaderRlpSize\n\n\t\t\t// Advance to the next header of the query\n\t\t\tswitch {\n\t\t\tcase query.Origin.Hash != (common.Hash{}) && query.Reverse:\n\t\t\t\t// Hash based traversal towards the genesis block\n\t\t\t\tfor i := 0; i < int(query.Skip)+1; i++ {\n\t\t\t\t\tif header := pm.blockchain.GetHeader(query.Origin.Hash, number); header != nil {\n\t\t\t\t\t\tquery.Origin.Hash = header.ParentHash\n\t\t\t\t\t\tnumber--\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunknown = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase query.Origin.Hash != (common.Hash{}) && !query.Reverse:\n\t\t\t\t// Hash based traversal towards the leaf block\n\t\t\t\tif header := pm.blockchain.GetHeaderByNumber(origin.Number.Uint64() + query.Skip + 1); header != nil {\n\t\t\t\t\tif pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {\n\t\t\t\t\t\tquery.Origin.Hash = header.Hash()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunknown = true\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tunknown = true\n\t\t\t\t}\n\t\t\tcase query.Reverse:\n\t\t\t\t// Number based traversal towards the genesis block\n\t\t\t\tif query.Origin.Number >= query.Skip+1 {\n\t\t\t\t\tquery.Origin.Number -= query.Skip + 1\n\t\t\t\t} else {\n\t\t\t\t\tunknown = true\n\t\t\t\t}\n\n\t\t\tcase !query.Reverse:\n\t\t\t\t// Number based traversal towards the leaf block\n\t\t\t\tquery.Origin.Number += query.Skip + 1\n\t\t\t}\n\t\t}\n\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + query.Amount*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, query.Amount, rcost)\n\t\treturn p.SendBlockHeaders(req.ReqID, bv, headers)\n\n\tcase BlockHeadersMsg:\n\t\tif pm.downloader == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received block header response message\")\n\t\t// A batch of headers arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tHeaders   []*types.Header\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tif pm.fetcher != nil && pm.fetcher.requestedID(resp.ReqID) {\n\t\t\tpm.fetcher.deliverHeaders(p, resp.ReqID, resp.Headers)\n\t\t} else {\n\t\t\terr := pm.downloader.DeliverHeaders(p.id, resp.Headers)\n\t\t\tif err != nil {\n\t\t\t\tlog.Debug(fmt.Sprint(err))\n\t\t\t}\n\t\t}\n\n\tcase GetBlockBodiesMsg:\n\t\tp.Log().Trace(\"Received block bodies request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID  uint64\n\t\t\tHashes []common.Hash\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather blocks until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes  int\n\t\t\tbodies []rlp.RawValue\n\t\t)\n\t\treqCnt := len(req.Hashes)\n\t\tif reject(uint64(reqCnt), MaxBodyFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, hash := range req.Hashes {\n\t\t\tif bytes >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Retrieve the requested block body, stopping if enough was found\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, hash); number != nil {\n\t\t\t\tif data := rawdb.ReadBodyRLP(pm.chainDb, hash, *number); len(data) != 0 {\n\t\t\t\t\tbodies = append(bodies, data)\n\t\t\t\t\tbytes += len(data)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendBlockBodiesRLP(req.ReqID, bv, bodies)\n\n\tcase BlockBodiesMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received block bodies response\")\n\t\t// A batch of block bodies arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      []*types.Body\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgBlockBodies,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase GetCodeMsg:\n\t\tp.Log().Trace(\"Received code request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []CodeReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes int\n\t\t\tdata  [][]byte\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxCodeFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, req := range req.Reqs {\n\t\t\t// Retrieve the requested state entry, stopping if enough was found\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, req.BHash); number != nil {\n\t\t\t\tif header := rawdb.ReadHeader(pm.chainDb, req.BHash, *number); header != nil {\n\t\t\t\t\tstatedb, err := pm.blockchain.State()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\taccount, err := pm.getAccount(statedb, header.Root, common.BytesToHash(req.AccKey))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tcode, _ := statedb.Database().TrieDB().Node(common.BytesToHash(account.CodeHash))\n\n\t\t\t\t\tdata = append(data, code)\n\t\t\t\t\tif bytes += len(code); bytes >= softResponseLimit {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendCode(req.ReqID, bv, data)\n\n\tcase CodeMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received code response\")\n\t\t// A batch of node state data arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      [][]byte\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgCode,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase GetReceiptsMsg:\n\t\tp.Log().Trace(\"Received receipts request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID  uint64\n\t\t\tHashes []common.Hash\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes    int\n\t\t\treceipts []rlp.RawValue\n\t\t)\n\t\treqCnt := len(req.Hashes)\n\t\tif reject(uint64(reqCnt), MaxReceiptFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, hash := range req.Hashes {\n\t\t\tif bytes >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Retrieve the requested block's receipts, skipping if unknown to us\n\t\t\tvar results types.Receipts\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, hash); number != nil {\n\t\t\t\tresults = rawdb.ReadReceipts(pm.chainDb, hash, *number)\n\t\t\t}\n\t\t\tif results == nil {\n\t\t\t\tif header := pm.blockchain.GetHeaderByHash(hash); header == nil || header.ReceiptHash != types.EmptyRootHash {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If known, encode and queue for response packet\n\t\t\tif encoded, err := rlp.EncodeToBytes(results); err != nil {\n\t\t\t\tlog.Error(\"Failed to encode receipt\", \"err\", err)\n\t\t\t} else {\n\t\t\t\treceipts = append(receipts, encoded)\n\t\t\t\tbytes += len(encoded)\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendReceiptsRLP(req.ReqID, bv, receipts)\n\n\tcase ReceiptsMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received receipts response\")\n\t\t// A batch of receipts arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tReceipts  []types.Receipts\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgReceipts,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Receipts,\n\t\t}\n\n\tcase GetProofsV1Msg:\n\t\tp.Log().Trace(\"Received proofs request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []ProofReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes  int\n\t\t\tproofs proofsData\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, req := range req.Reqs {\n\t\t\t// Retrieve the requested state entry, stopping if enough was found\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, req.BHash); number != nil {\n\t\t\t\tif header := rawdb.ReadHeader(pm.chainDb, req.BHash, *number); header != nil {\n\t\t\t\t\tstatedb, err := pm.blockchain.State()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvar trie state.Trie\n\t\t\t\t\tif len(req.AccKey) > 0 {\n\t\t\t\t\t\taccount, err := pm.getAccount(statedb, header.Root, common.BytesToHash(req.AccKey))\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrie, _ = statedb.Database().OpenStorageTrie(common.BytesToHash(req.AccKey), account.Root)\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrie, _ = statedb.Database().OpenTrie(header.Root)\n\t\t\t\t\t}\n\t\t\t\t\tif trie != nil {\n\t\t\t\t\t\tvar proof light.NodeList\n\t\t\t\t\t\ttrie.Prove(req.Key, 0, &proof)\n\n\t\t\t\t\t\tproofs = append(proofs, proof)\n\t\t\t\t\t\tif bytes += proof.DataSize(); bytes >= softResponseLimit {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendProofs(req.ReqID, bv, proofs)\n\n\tcase GetProofsV2Msg:\n\t\tp.Log().Trace(\"Received les/2 proofs request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []ProofReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tlastBHash common.Hash\n\t\t\tstatedb   *state.StateDB\n\t\t\troot      common.Hash\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\tnodes := light.NewNodeSet()\n\n\t\tfor _, req := range req.Reqs {\n\t\t\t// Look up the state belonging to the request\n\t\t\tif statedb == nil || req.BHash != lastBHash {\n\t\t\t\tstatedb, root, lastBHash = nil, common.Hash{}, req.BHash\n\n\t\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, req.BHash); number != nil {\n\t\t\t\t\tif header := rawdb.ReadHeader(pm.chainDb, req.BHash, *number); header != nil {\n\t\t\t\t\t\tstatedb, _ = pm.blockchain.State()\n\t\t\t\t\t\troot = header.Root\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif statedb == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Pull the account or storage trie of the request\n\t\t\tvar trie state.Trie\n\t\t\tif len(req.AccKey) > 0 {\n\t\t\t\taccount, err := pm.getAccount(statedb, root, common.BytesToHash(req.AccKey))\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ttrie, _ = statedb.Database().OpenStorageTrie(common.BytesToHash(req.AccKey), account.Root)\n\t\t\t} else {\n\t\t\t\ttrie, _ = statedb.Database().OpenTrie(root)\n\t\t\t}\n\t\t\tif trie == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Prove the user's request from the account or stroage trie\n\t\t\ttrie.Prove(req.Key, req.FromLevel, nodes)\n\t\t\tif nodes.DataSize() >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendProofsV2(req.ReqID, bv, nodes.NodeList())\n\n\tcase ProofsV1Msg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received proofs response\")\n\t\t// A batch of merkle proofs arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      []light.NodeList\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgProofsV1,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase ProofsV2Msg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received les/2 proofs response\")\n\t\t// A batch of merkle proofs arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      light.NodeList\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgProofsV2,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase GetHeaderProofsMsg:\n\t\tp.Log().Trace(\"Received headers proof request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []ChtReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes  int\n\t\t\tproofs []ChtResp\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxHelperTrieProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\ttrieDb := trie.NewDatabase(ethdb.NewTable(pm.chainDb, light.ChtTablePrefix))\n\t\tfor _, req := range req.Reqs {\n\t\t\tif header := pm.blockchain.GetHeaderByNumber(req.BlockNum); header != nil {\n\t\t\t\tsectionHead := rawdb.ReadCanonicalHash(pm.chainDb, req.ChtNum*light.CHTFrequencyServer-1)\n\t\t\t\tif root := light.GetChtRoot(pm.chainDb, req.ChtNum-1, sectionHead); root != (common.Hash{}) {\n\t\t\t\t\ttrie, err := trie.New(root, trieDb)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvar encNumber [8]byte\n\t\t\t\t\tbinary.BigEndian.PutUint64(encNumber[:], req.BlockNum)\n\n\t\t\t\t\tvar proof light.NodeList\n\t\t\t\t\ttrie.Prove(encNumber[:], 0, &proof)\n\n\t\t\t\t\tproofs = append(proofs, ChtResp{Header: header, Proof: proof})\n\t\t\t\t\tif bytes += proof.DataSize() + estHeaderRlpSize; bytes >= softResponseLimit {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendHeaderProofs(req.ReqID, bv, proofs)\n\n\tcase GetHelperTrieProofsMsg:\n\t\tp.Log().Trace(\"Received helper trie proof request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []HelperTrieReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tauxBytes int\n\t\t\tauxData  [][]byte\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxHelperTrieProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\tvar (\n\t\t\tlastIdx  uint64\n\t\t\tlastType uint\n\t\t\troot     common.Hash\n\t\t\tauxTrie  *trie.Trie\n\t\t)\n\t\tnodes := light.NewNodeSet()\n\t\tfor _, req := range req.Reqs {\n\t\t\tif auxTrie == nil || req.Type != lastType || req.TrieIdx != lastIdx {\n\t\t\t\tauxTrie, lastType, lastIdx = nil, req.Type, req.TrieIdx\n\n\t\t\t\tvar prefix string\n\t\t\t\tif root, prefix = pm.getHelperTrie(req.Type, req.TrieIdx); root != (common.Hash{}) {\n\t\t\t\t\tauxTrie, _ = trie.New(root, trie.NewDatabase(ethdb.NewTable(pm.chainDb, prefix)))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif req.AuxReq == auxRoot {\n\t\t\t\tvar data []byte\n\t\t\t\tif root != (common.Hash{}) {\n\t\t\t\t\tdata = root[:]\n\t\t\t\t}\n\t\t\t\tauxData = append(auxData, data)\n\t\t\t\tauxBytes += len(data)\n\t\t\t} else {\n\t\t\t\tif auxTrie != nil {\n\t\t\t\t\tauxTrie.Prove(req.Key, req.FromLevel, nodes)\n\t\t\t\t}\n\t\t\t\tif req.AuxReq != 0 {\n\t\t\t\t\tdata := pm.getHelperTrieAuxData(req)\n\t\t\t\t\tauxData = append(auxData, data)\n\t\t\t\t\tauxBytes += len(data)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif nodes.DataSize()+auxBytes >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendHelperTrieProofs(req.ReqID, bv, HelperTrieResps{Proofs: nodes.NodeList(), AuxData: auxData})\n\n\tcase HeaderProofsMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received headers proof response\")\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      []ChtResp\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgHeaderProofs,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase HelperTrieProofsMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received helper trie proof response\")\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      HelperTrieResps\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgHelperTrieProofs,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase SendTxMsg:\n\t\tif pm.txpool == nil {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\t// Transactions arrived, parse all of them and deliver to the pool\n\t\tvar txs []*types.Transaction\n\t\tif err := msg.Decode(&txs); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\treqCnt := len(txs)\n\t\tif reject(uint64(reqCnt), MaxTxSend) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tpm.txpool.AddRemotes(txs)\n\n\t\t_, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\n\tcase SendTxV2Msg:\n\t\tif pm.txpool == nil {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\t// Transactions arrived, parse all of them and deliver to the pool\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tTxs   []*types.Transaction\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\treqCnt := len(req.Txs)\n\t\tif reject(uint64(reqCnt), MaxTxSend) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\thashes := make([]common.Hash, len(req.Txs))\n\t\tfor i, tx := range req.Txs {\n\t\t\thashes[i] = tx.Hash()\n\t\t}\n\t\tstats := pm.txStatus(hashes)\n\t\tfor i, stat := range stats {\n\t\t\tif stat.Status == core.TxStatusUnknown {\n\t\t\t\tif errs := pm.txpool.AddRemotes([]*types.Transaction{req.Txs[i]}); errs[0] != nil {\n\t\t\t\t\tstats[i].Error = errs[0].Error()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tstats[i] = pm.txStatus([]common.Hash{hashes[i]})[0]\n\t\t\t}\n\t\t}\n\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\n\t\treturn p.SendTxStatus(req.ReqID, bv, stats)\n\n\tcase GetTxStatusMsg:\n\t\tif pm.txpool == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\t\t// Transactions arrived, parse all of them and deliver to the pool\n\t\tvar req struct {\n\t\t\tReqID  uint64\n\t\t\tHashes []common.Hash\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\treqCnt := len(req.Hashes)\n\t\tif reject(uint64(reqCnt), MaxTxStatus) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\n\t\treturn p.SendTxStatus(req.ReqID, bv, pm.txStatus(req.Hashes))\n\n\tcase TxStatusMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received tx status response\")\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tStatus    []txStatus\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\n\tdefault:\n\t\tp.Log().Trace(\"Received unknown message\", \"code\", msg.Code)\n\t\treturn errResp(ErrInvalidMsgCode, \"%v\", msg.Code)\n\t}\n\n\tif deliverMsg != nil {\n\t\terr := pm.retriever.deliver(p, deliverMsg)\n\t\tif err != nil {\n\t\t\tp.responseErrors++\n\t\t\tif p.responseErrors > maxResponseErrors {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// getAccount retrieves an account from the state based at root.\nfunc (pm *ProtocolManager) getAccount(statedb *state.StateDB, root, hash common.Hash) (state.Account, error) {\n\ttrie, err := trie.New(root, statedb.Database().TrieDB())\n\tif err != nil {\n\t\treturn state.Account{}, err\n\t}\n\tblob, err := trie.TryGet(hash[:])\n\tif err != nil {\n\t\treturn state.Account{}, err\n\t}\n\tvar account state.Account\n\tif err = rlp.DecodeBytes(blob, &account); err != nil {\n\t\treturn state.Account{}, err\n\t}\n\treturn account, nil\n}\n\n// getHelperTrie returns the post-processed trie root for the given trie ID and section index\nfunc (pm *ProtocolManager) getHelperTrie(id uint, idx uint64) (common.Hash, string) {\n\tswitch id {\n\tcase htCanonical:\n\t\tsectionHead := rawdb.ReadCanonicalHash(pm.chainDb, (idx+1)*light.CHTFrequencyClient-1)\n\t\treturn light.GetChtV2Root(pm.chainDb, idx, sectionHead), light.ChtTablePrefix\n\tcase htBloomBits:\n\t\tsectionHead := rawdb.ReadCanonicalHash(pm.chainDb, (idx+1)*light.BloomTrieFrequency-1)\n\t\treturn light.GetBloomTrieRoot(pm.chainDb, idx, sectionHead), light.BloomTrieTablePrefix\n\t}\n\treturn common.Hash{}, \"\"\n}\n\n// getHelperTrieAuxData returns requested auxiliary data for the given HelperTrie request\nfunc (pm *ProtocolManager) getHelperTrieAuxData(req HelperTrieReq) []byte {\n\tswitch {\n\tcase req.Type == htCanonical && req.AuxReq == auxHeader && len(req.Key) == 8:\n\t\tblockNum := binary.BigEndian.Uint64(req.Key)\n\t\thash := rawdb.ReadCanonicalHash(pm.chainDb, blockNum)\n\t\treturn rawdb.ReadHeaderRLP(pm.chainDb, hash, blockNum)\n\t}\n\treturn nil\n}\n\nfunc (pm *ProtocolManager) txStatus(hashes []common.Hash) []txStatus {\n\tstats := make([]txStatus, len(hashes))\n\tfor i, stat := range pm.txpool.Status(hashes) {\n\t\t// Save the status we've got from the transaction pool\n\t\tstats[i].Status = stat\n\n\t\t// If the transaction is unknown to the pool, try looking it up locally\n\t\tif stat == core.TxStatusUnknown {\n\t\t\tif block, number, index := rawdb.ReadTxLookupEntry(pm.chainDb, hashes[i]); block != (common.Hash{}) {\n\t\t\t\tstats[i].Status = core.TxStatusIncluded\n\t\t\t\tstats[i].Lookup = &rawdb.TxLookupEntry{BlockHash: block, BlockIndex: number, Index: index}\n\t\t\t}\n\t\t}\n\t}\n\treturn stats\n}\n\n// NodeInfo represents a short summary of the Ethereum sub-protocol metadata\n// known about the host peer.\ntype NodeInfo struct {\n\tNetwork    uint64              `json:\"network\"`    // Ethereum network ID (1=Frontier, 2=Morden, Ropsten=3, Rinkeby=4)\n\tDifficulty *big.Int            `json:\"difficulty\"` // Total difficulty of the host's blockchain\n\tGenesis    common.Hash         `json:\"genesis\"`    // SHA3 hash of the host's genesis block\n\tConfig     *params.ChainConfig `json:\"config\"`     // Chain configuration for the fork rules\n\tHead       common.Hash         `json:\"head\"`       // SHA3 hash of the host's best owned block\n}\n\n// NodeInfo retrieves some protocol metadata about the running host node.\nfunc (self *ProtocolManager) NodeInfo() *NodeInfo {\n\thead := self.blockchain.CurrentHeader()\n\thash := head.Hash()\n\n\treturn &NodeInfo{\n\t\tNetwork:    self.networkId,\n\t\tDifficulty: self.blockchain.GetTd(hash, head.Number.Uint64()),\n\t\tGenesis:    self.blockchain.Genesis().Hash(),\n\t\tConfig:     self.blockchain.Config(),\n\t\tHead:       hash,\n\t}\n}\n\n// downloaderPeerNotify implements peerSetNotify\ntype downloaderPeerNotify ProtocolManager\n\ntype peerConnection struct {\n\tmanager *ProtocolManager\n\tpeer    *peer\n}\n\nfunc (pc *peerConnection) Head() (common.Hash, *big.Int) {\n\treturn pc.peer.HeadAndTd()\n}\n\nfunc (pc *peerConnection) RequestHeadersByHash(origin common.Hash, amount int, skip int, reverse bool) error {\n\treqID := genReqID()\n\trq := &distReq{\n\t\tgetCost: func(dp distPeer) uint64 {\n\t\t\tpeer := dp.(*peer)\n\t\t\treturn peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t},\n\t\tcanSend: func(dp distPeer) bool {\n\t\t\treturn dp.(*peer) == pc.peer\n\t\t},\n\t\trequest: func(dp distPeer) func() {\n\t\t\tpeer := dp.(*peer)\n\t\t\tcost := peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t\tpeer.fcServer.QueueRequest(reqID, cost)\n\t\t\treturn func() { peer.RequestHeadersByHash(reqID, cost, origin, amount, skip, reverse) }\n\t\t},\n\t}\n\t_, ok := <-pc.manager.reqDist.queue(rq)\n\tif !ok {\n\t\treturn ErrNoPeers\n\t}\n\treturn nil\n}\n\nfunc (pc *peerConnection) RequestHeadersByNumber(origin uint64, amount int, skip int, reverse bool) error {\n\treqID := genReqID()\n\trq := &distReq{\n\t\tgetCost: func(dp distPeer) uint64 {\n\t\t\tpeer := dp.(*peer)\n\t\t\treturn peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t},\n\t\tcanSend: func(dp distPeer) bool {\n\t\t\treturn dp.(*peer) == pc.peer\n\t\t},\n\t\trequest: func(dp distPeer) func() {\n\t\t\tpeer := dp.(*peer)\n\t\t\tcost := peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t\tpeer.fcServer.QueueRequest(reqID, cost)\n\t\t\treturn func() { peer.RequestHeadersByNumber(reqID, cost, origin, amount, skip, reverse) }\n\t\t},\n\t}\n\t_, ok := <-pc.manager.reqDist.queue(rq)\n\tif !ok {\n\t\treturn ErrNoPeers\n\t}\n\treturn nil\n}\n\nfunc (d *downloaderPeerNotify) registerPeer(p *peer) {\n\tpm := (*ProtocolManager)(d)\n\tpc := &peerConnection{\n\t\tmanager: pm,\n\t\tpeer:    p,\n\t}\n\tpm.downloader.RegisterLightPeer(p.id, ethVersion, pc)\n}\n\nfunc (d *downloaderPeerNotify) unregisterPeer(p *peer) {\n\tpm := (*ProtocolManager)(d)\n\tpm.downloader.UnregisterPeer(p.id)\n}\n"], "fixing_code": ["// Copyright 2016 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\n// Package les implements the Light Ethereum Subprotocol.\npackage les\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/consensus\"\n\t\"github.com/ethereum/go-ethereum/core\"\n\t\"github.com/ethereum/go-ethereum/core/rawdb\"\n\t\"github.com/ethereum/go-ethereum/core/state\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/eth/downloader\"\n\t\"github.com/ethereum/go-ethereum/ethdb\"\n\t\"github.com/ethereum/go-ethereum/event\"\n\t\"github.com/ethereum/go-ethereum/light\"\n\t\"github.com/ethereum/go-ethereum/log\"\n\t\"github.com/ethereum/go-ethereum/p2p\"\n\t\"github.com/ethereum/go-ethereum/p2p/discover\"\n\t\"github.com/ethereum/go-ethereum/p2p/discv5\"\n\t\"github.com/ethereum/go-ethereum/params\"\n\t\"github.com/ethereum/go-ethereum/rlp\"\n\t\"github.com/ethereum/go-ethereum/trie\"\n)\n\nconst (\n\tsoftResponseLimit = 2 * 1024 * 1024 // Target maximum size of returned blocks, headers or node data.\n\testHeaderRlpSize  = 500             // Approximate size of an RLP encoded block header\n\n\tethVersion = 63 // equivalent eth version for the downloader\n\n\tMaxHeaderFetch           = 192 // Amount of block headers to be fetched per retrieval request\n\tMaxBodyFetch             = 32  // Amount of block bodies to be fetched per retrieval request\n\tMaxReceiptFetch          = 128 // Amount of transaction receipts to allow fetching per request\n\tMaxCodeFetch             = 64  // Amount of contract codes to allow fetching per request\n\tMaxProofsFetch           = 64  // Amount of merkle proofs to be fetched per retrieval request\n\tMaxHelperTrieProofsFetch = 64  // Amount of merkle proofs to be fetched per retrieval request\n\tMaxTxSend                = 64  // Amount of transactions to be send per request\n\tMaxTxStatus              = 256 // Amount of transactions to queried per request\n\n\tdisableClientRemovePeer = false\n)\n\n// errIncompatibleConfig is returned if the requested protocols and configs are\n// not compatible (low protocol version restrictions and high requirements).\nvar errIncompatibleConfig = errors.New(\"incompatible configuration\")\n\nfunc errResp(code errCode, format string, v ...interface{}) error {\n\treturn fmt.Errorf(\"%v - %v\", code, fmt.Sprintf(format, v...))\n}\n\ntype BlockChain interface {\n\tConfig() *params.ChainConfig\n\tHasHeader(hash common.Hash, number uint64) bool\n\tGetHeader(hash common.Hash, number uint64) *types.Header\n\tGetHeaderByHash(hash common.Hash) *types.Header\n\tCurrentHeader() *types.Header\n\tGetTd(hash common.Hash, number uint64) *big.Int\n\tState() (*state.StateDB, error)\n\tInsertHeaderChain(chain []*types.Header, checkFreq int) (int, error)\n\tRollback(chain []common.Hash)\n\tGetHeaderByNumber(number uint64) *types.Header\n\tGetBlockHashesFromHash(hash common.Hash, max uint64) []common.Hash\n\tGenesis() *types.Block\n\tSubscribeChainHeadEvent(ch chan<- core.ChainHeadEvent) event.Subscription\n}\n\ntype txPool interface {\n\tAddRemotes(txs []*types.Transaction) []error\n\tStatus(hashes []common.Hash) []core.TxStatus\n}\n\ntype ProtocolManager struct {\n\tlightSync   bool\n\ttxpool      txPool\n\ttxrelay     *LesTxRelay\n\tnetworkId   uint64\n\tchainConfig *params.ChainConfig\n\tblockchain  BlockChain\n\tchainDb     ethdb.Database\n\todr         *LesOdr\n\tserver      *LesServer\n\tserverPool  *serverPool\n\tlesTopic    discv5.Topic\n\treqDist     *requestDistributor\n\tretriever   *retrieveManager\n\n\tdownloader *downloader.Downloader\n\tfetcher    *lightFetcher\n\tpeers      *peerSet\n\tmaxPeers   int\n\n\tSubProtocols []p2p.Protocol\n\n\teventMux *event.TypeMux\n\n\t// channels for fetcher, syncer, txsyncLoop\n\tnewPeerCh   chan *peer\n\tquitSync    chan struct{}\n\tnoMorePeers chan struct{}\n\n\t// wait group is used for graceful shutdowns during downloading\n\t// and processing\n\twg *sync.WaitGroup\n}\n\n// NewProtocolManager returns a new ethereum sub protocol manager. The Ethereum sub protocol manages peers capable\n// with the ethereum network.\nfunc NewProtocolManager(chainConfig *params.ChainConfig, lightSync bool, protocolVersions []uint, networkId uint64, mux *event.TypeMux, engine consensus.Engine, peers *peerSet, blockchain BlockChain, txpool txPool, chainDb ethdb.Database, odr *LesOdr, txrelay *LesTxRelay, quitSync chan struct{}, wg *sync.WaitGroup) (*ProtocolManager, error) {\n\t// Create the protocol manager with the base fields\n\tmanager := &ProtocolManager{\n\t\tlightSync:   lightSync,\n\t\teventMux:    mux,\n\t\tblockchain:  blockchain,\n\t\tchainConfig: chainConfig,\n\t\tchainDb:     chainDb,\n\t\todr:         odr,\n\t\tnetworkId:   networkId,\n\t\ttxpool:      txpool,\n\t\ttxrelay:     txrelay,\n\t\tpeers:       peers,\n\t\tnewPeerCh:   make(chan *peer),\n\t\tquitSync:    quitSync,\n\t\twg:          wg,\n\t\tnoMorePeers: make(chan struct{}),\n\t}\n\tif odr != nil {\n\t\tmanager.retriever = odr.retriever\n\t\tmanager.reqDist = odr.retriever.dist\n\t}\n\n\t// Initiate a sub-protocol for every implemented version we can handle\n\tmanager.SubProtocols = make([]p2p.Protocol, 0, len(protocolVersions))\n\tfor _, version := range protocolVersions {\n\t\t// Compatible, initialize the sub-protocol\n\t\tversion := version // Closure for the run\n\t\tmanager.SubProtocols = append(manager.SubProtocols, p2p.Protocol{\n\t\t\tName:    \"les\",\n\t\t\tVersion: version,\n\t\t\tLength:  ProtocolLengths[version],\n\t\t\tRun: func(p *p2p.Peer, rw p2p.MsgReadWriter) error {\n\t\t\t\tvar entry *poolEntry\n\t\t\t\tpeer := manager.newPeer(int(version), networkId, p, rw)\n\t\t\t\tif manager.serverPool != nil {\n\t\t\t\t\taddr := p.RemoteAddr().(*net.TCPAddr)\n\t\t\t\t\tentry = manager.serverPool.connect(peer, addr.IP, uint16(addr.Port))\n\t\t\t\t}\n\t\t\t\tpeer.poolEntry = entry\n\t\t\t\tselect {\n\t\t\t\tcase manager.newPeerCh <- peer:\n\t\t\t\t\tmanager.wg.Add(1)\n\t\t\t\t\tdefer manager.wg.Done()\n\t\t\t\t\terr := manager.handle(peer)\n\t\t\t\t\tif entry != nil {\n\t\t\t\t\t\tmanager.serverPool.disconnect(entry)\n\t\t\t\t\t}\n\t\t\t\t\treturn err\n\t\t\t\tcase <-manager.quitSync:\n\t\t\t\t\tif entry != nil {\n\t\t\t\t\t\tmanager.serverPool.disconnect(entry)\n\t\t\t\t\t}\n\t\t\t\t\treturn p2p.DiscQuitting\n\t\t\t\t}\n\t\t\t},\n\t\t\tNodeInfo: func() interface{} {\n\t\t\t\treturn manager.NodeInfo()\n\t\t\t},\n\t\t\tPeerInfo: func(id discover.NodeID) interface{} {\n\t\t\t\tif p := manager.peers.Peer(fmt.Sprintf(\"%x\", id[:8])); p != nil {\n\t\t\t\t\treturn p.Info()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t})\n\t}\n\tif len(manager.SubProtocols) == 0 {\n\t\treturn nil, errIncompatibleConfig\n\t}\n\n\tremovePeer := manager.removePeer\n\tif disableClientRemovePeer {\n\t\tremovePeer = func(id string) {}\n\t}\n\n\tif lightSync {\n\t\tmanager.downloader = downloader.New(downloader.LightSync, chainDb, manager.eventMux, nil, blockchain, removePeer)\n\t\tmanager.peers.notify((*downloaderPeerNotify)(manager))\n\t\tmanager.fetcher = newLightFetcher(manager)\n\t}\n\n\treturn manager, nil\n}\n\n// removePeer initiates disconnection from a peer by removing it from the peer set\nfunc (pm *ProtocolManager) removePeer(id string) {\n\tpm.peers.Unregister(id)\n}\n\nfunc (pm *ProtocolManager) Start(maxPeers int) {\n\tpm.maxPeers = maxPeers\n\n\tif pm.lightSync {\n\t\tgo pm.syncer()\n\t} else {\n\t\tgo func() {\n\t\t\tfor range pm.newPeerCh {\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc (pm *ProtocolManager) Stop() {\n\t// Showing a log message. During download / process this could actually\n\t// take between 5 to 10 seconds and therefor feedback is required.\n\tlog.Info(\"Stopping light Ethereum protocol\")\n\n\t// Quit the sync loop.\n\t// After this send has completed, no new peers will be accepted.\n\tpm.noMorePeers <- struct{}{}\n\n\tclose(pm.quitSync) // quits syncer, fetcher\n\n\t// Disconnect existing sessions.\n\t// This also closes the gate for any new registrations on the peer set.\n\t// sessions which are already established but not added to pm.peers yet\n\t// will exit when they try to register.\n\tpm.peers.Close()\n\n\t// Wait for any process action\n\tpm.wg.Wait()\n\n\tlog.Info(\"Light Ethereum protocol stopped\")\n}\n\nfunc (pm *ProtocolManager) newPeer(pv int, nv uint64, p *p2p.Peer, rw p2p.MsgReadWriter) *peer {\n\treturn newPeer(pv, nv, p, newMeteredMsgWriter(rw))\n}\n\n// handle is the callback invoked to manage the life cycle of a les peer. When\n// this function terminates, the peer is disconnected.\nfunc (pm *ProtocolManager) handle(p *peer) error {\n\t// Ignore maxPeers if this is a trusted peer\n\tif pm.peers.Len() >= pm.maxPeers && !p.Peer.Info().Network.Trusted {\n\t\treturn p2p.DiscTooManyPeers\n\t}\n\n\tp.Log().Debug(\"Light Ethereum peer connected\", \"name\", p.Name())\n\n\t// Execute the LES handshake\n\tvar (\n\t\tgenesis = pm.blockchain.Genesis()\n\t\thead    = pm.blockchain.CurrentHeader()\n\t\thash    = head.Hash()\n\t\tnumber  = head.Number.Uint64()\n\t\ttd      = pm.blockchain.GetTd(hash, number)\n\t)\n\tif err := p.Handshake(td, hash, number, genesis.Hash(), pm.server); err != nil {\n\t\tp.Log().Debug(\"Light Ethereum handshake failed\", \"err\", err)\n\t\treturn err\n\t}\n\tif rw, ok := p.rw.(*meteredMsgReadWriter); ok {\n\t\trw.Init(p.version)\n\t}\n\t// Register the peer locally\n\tif err := pm.peers.Register(p); err != nil {\n\t\tp.Log().Error(\"Light Ethereum peer registration failed\", \"err\", err)\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif pm.server != nil && pm.server.fcManager != nil && p.fcClient != nil {\n\t\t\tp.fcClient.Remove(pm.server.fcManager)\n\t\t}\n\t\tpm.removePeer(p.id)\n\t}()\n\t// Register the peer in the downloader. If the downloader considers it banned, we disconnect\n\tif pm.lightSync {\n\t\tp.lock.Lock()\n\t\thead := p.headInfo\n\t\tp.lock.Unlock()\n\t\tif pm.fetcher != nil {\n\t\t\tpm.fetcher.announce(p, head)\n\t\t}\n\n\t\tif p.poolEntry != nil {\n\t\t\tpm.serverPool.registered(p.poolEntry)\n\t\t}\n\t}\n\n\tstop := make(chan struct{})\n\tdefer close(stop)\n\tgo func() {\n\t\t// new block announce loop\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase announce := <-p.announceChn:\n\t\t\t\tp.SendAnnounce(announce)\n\t\t\tcase <-stop:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// main loop. handle incoming messages.\n\tfor {\n\t\tif err := pm.handleMsg(p); err != nil {\n\t\t\tp.Log().Debug(\"Light Ethereum message handling failed\", \"err\", err)\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nvar reqList = []uint64{GetBlockHeadersMsg, GetBlockBodiesMsg, GetCodeMsg, GetReceiptsMsg, GetProofsV1Msg, SendTxMsg, SendTxV2Msg, GetTxStatusMsg, GetHeaderProofsMsg, GetProofsV2Msg, GetHelperTrieProofsMsg}\n\n// handleMsg is invoked whenever an inbound message is received from a remote\n// peer. The remote connection is torn down upon returning any error.\nfunc (pm *ProtocolManager) handleMsg(p *peer) error {\n\t// Read the next message from the remote peer, and ensure it's fully consumed\n\tmsg, err := p.rw.ReadMsg()\n\tif err != nil {\n\t\treturn err\n\t}\n\tp.Log().Trace(\"Light Ethereum message arrived\", \"code\", msg.Code, \"bytes\", msg.Size)\n\n\tcosts := p.fcCosts[msg.Code]\n\treject := func(reqCnt, maxCnt uint64) bool {\n\t\tif p.fcClient == nil || reqCnt > maxCnt {\n\t\t\treturn true\n\t\t}\n\t\tbufValue, _ := p.fcClient.AcceptRequest()\n\t\tcost := costs.baseCost + reqCnt*costs.reqCost\n\t\tif cost > pm.server.defParams.BufLimit {\n\t\t\tcost = pm.server.defParams.BufLimit\n\t\t}\n\t\tif cost > bufValue {\n\t\t\trecharge := time.Duration((cost - bufValue) * 1000000 / pm.server.defParams.MinRecharge)\n\t\t\tp.Log().Error(\"Request came too early\", \"recharge\", common.PrettyDuration(recharge))\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tif msg.Size > ProtocolMaxMsgSize {\n\t\treturn errResp(ErrMsgTooLarge, \"%v > %v\", msg.Size, ProtocolMaxMsgSize)\n\t}\n\tdefer msg.Discard()\n\n\tvar deliverMsg *Msg\n\n\t// Handle the message depending on its contents\n\tswitch msg.Code {\n\tcase StatusMsg:\n\t\tp.Log().Trace(\"Received status message\")\n\t\t// Status messages should never arrive after the handshake\n\t\treturn errResp(ErrExtraStatusMsg, \"uncontrolled status message\")\n\n\t// Block header query, collect the requested headers and reply\n\tcase AnnounceMsg:\n\t\tp.Log().Trace(\"Received announce message\")\n\t\tif p.requestAnnounceType == announceTypeNone {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tvar req announceData\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"%v: %v\", msg, err)\n\t\t}\n\n\t\tif p.requestAnnounceType == announceTypeSigned {\n\t\t\tif err := req.checkSignature(p.pubKey); err != nil {\n\t\t\t\tp.Log().Trace(\"Invalid announcement signature\", \"err\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tp.Log().Trace(\"Valid announcement signature\")\n\t\t}\n\n\t\tp.Log().Trace(\"Announce message content\", \"number\", req.Number, \"hash\", req.Hash, \"td\", req.Td, \"reorg\", req.ReorgDepth)\n\t\tif pm.fetcher != nil {\n\t\t\tpm.fetcher.announce(p, &req)\n\t\t}\n\n\tcase GetBlockHeadersMsg:\n\t\tp.Log().Trace(\"Received block header request\")\n\t\t// Decode the complex header query\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tQuery getBlockHeadersData\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"%v: %v\", msg, err)\n\t\t}\n\n\t\tquery := req.Query\n\t\tif reject(query.Amount, MaxHeaderFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\thashMode := query.Origin.Hash != (common.Hash{})\n\n\t\t// Gather headers until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes   common.StorageSize\n\t\t\theaders []*types.Header\n\t\t\tunknown bool\n\t\t)\n\t\tfor !unknown && len(headers) < int(query.Amount) && bytes < softResponseLimit {\n\t\t\t// Retrieve the next header satisfying the query\n\t\t\tvar origin *types.Header\n\t\t\tif hashMode {\n\t\t\t\torigin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)\n\t\t\t} else {\n\t\t\t\torigin = pm.blockchain.GetHeaderByNumber(query.Origin.Number)\n\t\t\t}\n\t\t\tif origin == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnumber := origin.Number.Uint64()\n\t\t\theaders = append(headers, origin)\n\t\t\tbytes += estHeaderRlpSize\n\n\t\t\t// Advance to the next header of the query\n\t\t\tswitch {\n\t\t\tcase hashMode && query.Reverse:\n\t\t\t\t// Hash based traversal towards the genesis block\n\t\t\t\tfor i := 0; i < int(query.Skip)+1; i++ {\n\t\t\t\t\tif header := pm.blockchain.GetHeader(query.Origin.Hash, number); header != nil {\n\t\t\t\t\t\tquery.Origin.Hash = header.ParentHash\n\t\t\t\t\t\tnumber--\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunknown = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase hashMode && !query.Reverse:\n\t\t\t\t// Hash based traversal towards the leaf block\n\t\t\t\tvar (\n\t\t\t\t\tcurrent = origin.Number.Uint64()\n\t\t\t\t\tnext    = current + query.Skip + 1\n\t\t\t\t)\n\t\t\t\tif next <= current {\n\t\t\t\t\tinfos, _ := json.MarshalIndent(p.Peer.Info(), \"\", \"  \")\n\t\t\t\t\tp.Log().Warn(\"GetBlockHeaders skip overflow attack\", \"current\", current, \"skip\", query.Skip, \"next\", next, \"attacker\", infos)\n\t\t\t\t\tunknown = true\n\t\t\t\t} else {\n\t\t\t\t\tif header := pm.blockchain.GetHeaderByNumber(next); header != nil {\n\t\t\t\t\t\tif pm.blockchain.GetBlockHashesFromHash(header.Hash(), query.Skip+1)[query.Skip] == query.Origin.Hash {\n\t\t\t\t\t\t\tquery.Origin.Hash = header.Hash()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tunknown = true\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunknown = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase query.Reverse:\n\t\t\t\t// Number based traversal towards the genesis block\n\t\t\t\tif query.Origin.Number >= query.Skip+1 {\n\t\t\t\t\tquery.Origin.Number -= query.Skip + 1\n\t\t\t\t} else {\n\t\t\t\t\tunknown = true\n\t\t\t\t}\n\n\t\t\tcase !query.Reverse:\n\t\t\t\t// Number based traversal towards the leaf block\n\t\t\t\tquery.Origin.Number += query.Skip + 1\n\t\t\t}\n\t\t}\n\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + query.Amount*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, query.Amount, rcost)\n\t\treturn p.SendBlockHeaders(req.ReqID, bv, headers)\n\n\tcase BlockHeadersMsg:\n\t\tif pm.downloader == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received block header response message\")\n\t\t// A batch of headers arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tHeaders   []*types.Header\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tif pm.fetcher != nil && pm.fetcher.requestedID(resp.ReqID) {\n\t\t\tpm.fetcher.deliverHeaders(p, resp.ReqID, resp.Headers)\n\t\t} else {\n\t\t\terr := pm.downloader.DeliverHeaders(p.id, resp.Headers)\n\t\t\tif err != nil {\n\t\t\t\tlog.Debug(fmt.Sprint(err))\n\t\t\t}\n\t\t}\n\n\tcase GetBlockBodiesMsg:\n\t\tp.Log().Trace(\"Received block bodies request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID  uint64\n\t\t\tHashes []common.Hash\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather blocks until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes  int\n\t\t\tbodies []rlp.RawValue\n\t\t)\n\t\treqCnt := len(req.Hashes)\n\t\tif reject(uint64(reqCnt), MaxBodyFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, hash := range req.Hashes {\n\t\t\tif bytes >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Retrieve the requested block body, stopping if enough was found\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, hash); number != nil {\n\t\t\t\tif data := rawdb.ReadBodyRLP(pm.chainDb, hash, *number); len(data) != 0 {\n\t\t\t\t\tbodies = append(bodies, data)\n\t\t\t\t\tbytes += len(data)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendBlockBodiesRLP(req.ReqID, bv, bodies)\n\n\tcase BlockBodiesMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received block bodies response\")\n\t\t// A batch of block bodies arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      []*types.Body\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgBlockBodies,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase GetCodeMsg:\n\t\tp.Log().Trace(\"Received code request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []CodeReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes int\n\t\t\tdata  [][]byte\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxCodeFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, req := range req.Reqs {\n\t\t\t// Retrieve the requested state entry, stopping if enough was found\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, req.BHash); number != nil {\n\t\t\t\tif header := rawdb.ReadHeader(pm.chainDb, req.BHash, *number); header != nil {\n\t\t\t\t\tstatedb, err := pm.blockchain.State()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\taccount, err := pm.getAccount(statedb, header.Root, common.BytesToHash(req.AccKey))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tcode, _ := statedb.Database().TrieDB().Node(common.BytesToHash(account.CodeHash))\n\n\t\t\t\t\tdata = append(data, code)\n\t\t\t\t\tif bytes += len(code); bytes >= softResponseLimit {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendCode(req.ReqID, bv, data)\n\n\tcase CodeMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received code response\")\n\t\t// A batch of node state data arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      [][]byte\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgCode,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase GetReceiptsMsg:\n\t\tp.Log().Trace(\"Received receipts request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID  uint64\n\t\t\tHashes []common.Hash\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes    int\n\t\t\treceipts []rlp.RawValue\n\t\t)\n\t\treqCnt := len(req.Hashes)\n\t\tif reject(uint64(reqCnt), MaxReceiptFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, hash := range req.Hashes {\n\t\t\tif bytes >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Retrieve the requested block's receipts, skipping if unknown to us\n\t\t\tvar results types.Receipts\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, hash); number != nil {\n\t\t\t\tresults = rawdb.ReadReceipts(pm.chainDb, hash, *number)\n\t\t\t}\n\t\t\tif results == nil {\n\t\t\t\tif header := pm.blockchain.GetHeaderByHash(hash); header == nil || header.ReceiptHash != types.EmptyRootHash {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If known, encode and queue for response packet\n\t\t\tif encoded, err := rlp.EncodeToBytes(results); err != nil {\n\t\t\t\tlog.Error(\"Failed to encode receipt\", \"err\", err)\n\t\t\t} else {\n\t\t\t\treceipts = append(receipts, encoded)\n\t\t\t\tbytes += len(encoded)\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendReceiptsRLP(req.ReqID, bv, receipts)\n\n\tcase ReceiptsMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received receipts response\")\n\t\t// A batch of receipts arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tReceipts  []types.Receipts\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgReceipts,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Receipts,\n\t\t}\n\n\tcase GetProofsV1Msg:\n\t\tp.Log().Trace(\"Received proofs request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []ProofReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes  int\n\t\t\tproofs proofsData\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tfor _, req := range req.Reqs {\n\t\t\t// Retrieve the requested state entry, stopping if enough was found\n\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, req.BHash); number != nil {\n\t\t\t\tif header := rawdb.ReadHeader(pm.chainDb, req.BHash, *number); header != nil {\n\t\t\t\t\tstatedb, err := pm.blockchain.State()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvar trie state.Trie\n\t\t\t\t\tif len(req.AccKey) > 0 {\n\t\t\t\t\t\taccount, err := pm.getAccount(statedb, header.Root, common.BytesToHash(req.AccKey))\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrie, _ = statedb.Database().OpenStorageTrie(common.BytesToHash(req.AccKey), account.Root)\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrie, _ = statedb.Database().OpenTrie(header.Root)\n\t\t\t\t\t}\n\t\t\t\t\tif trie != nil {\n\t\t\t\t\t\tvar proof light.NodeList\n\t\t\t\t\t\ttrie.Prove(req.Key, 0, &proof)\n\n\t\t\t\t\t\tproofs = append(proofs, proof)\n\t\t\t\t\t\tif bytes += proof.DataSize(); bytes >= softResponseLimit {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendProofs(req.ReqID, bv, proofs)\n\n\tcase GetProofsV2Msg:\n\t\tp.Log().Trace(\"Received les/2 proofs request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []ProofReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tlastBHash common.Hash\n\t\t\tstatedb   *state.StateDB\n\t\t\troot      common.Hash\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\tnodes := light.NewNodeSet()\n\n\t\tfor _, req := range req.Reqs {\n\t\t\t// Look up the state belonging to the request\n\t\t\tif statedb == nil || req.BHash != lastBHash {\n\t\t\t\tstatedb, root, lastBHash = nil, common.Hash{}, req.BHash\n\n\t\t\t\tif number := rawdb.ReadHeaderNumber(pm.chainDb, req.BHash); number != nil {\n\t\t\t\t\tif header := rawdb.ReadHeader(pm.chainDb, req.BHash, *number); header != nil {\n\t\t\t\t\t\tstatedb, _ = pm.blockchain.State()\n\t\t\t\t\t\troot = header.Root\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif statedb == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Pull the account or storage trie of the request\n\t\t\tvar trie state.Trie\n\t\t\tif len(req.AccKey) > 0 {\n\t\t\t\taccount, err := pm.getAccount(statedb, root, common.BytesToHash(req.AccKey))\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ttrie, _ = statedb.Database().OpenStorageTrie(common.BytesToHash(req.AccKey), account.Root)\n\t\t\t} else {\n\t\t\t\ttrie, _ = statedb.Database().OpenTrie(root)\n\t\t\t}\n\t\t\tif trie == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Prove the user's request from the account or stroage trie\n\t\t\ttrie.Prove(req.Key, req.FromLevel, nodes)\n\t\t\tif nodes.DataSize() >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendProofsV2(req.ReqID, bv, nodes.NodeList())\n\n\tcase ProofsV1Msg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received proofs response\")\n\t\t// A batch of merkle proofs arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      []light.NodeList\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgProofsV1,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase ProofsV2Msg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received les/2 proofs response\")\n\t\t// A batch of merkle proofs arrived to one of our previous requests\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      light.NodeList\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgProofsV2,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase GetHeaderProofsMsg:\n\t\tp.Log().Trace(\"Received headers proof request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []ChtReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tbytes  int\n\t\t\tproofs []ChtResp\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxHelperTrieProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\ttrieDb := trie.NewDatabase(ethdb.NewTable(pm.chainDb, light.ChtTablePrefix))\n\t\tfor _, req := range req.Reqs {\n\t\t\tif header := pm.blockchain.GetHeaderByNumber(req.BlockNum); header != nil {\n\t\t\t\tsectionHead := rawdb.ReadCanonicalHash(pm.chainDb, req.ChtNum*light.CHTFrequencyServer-1)\n\t\t\t\tif root := light.GetChtRoot(pm.chainDb, req.ChtNum-1, sectionHead); root != (common.Hash{}) {\n\t\t\t\t\ttrie, err := trie.New(root, trieDb)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvar encNumber [8]byte\n\t\t\t\t\tbinary.BigEndian.PutUint64(encNumber[:], req.BlockNum)\n\n\t\t\t\t\tvar proof light.NodeList\n\t\t\t\t\ttrie.Prove(encNumber[:], 0, &proof)\n\n\t\t\t\t\tproofs = append(proofs, ChtResp{Header: header, Proof: proof})\n\t\t\t\t\tif bytes += proof.DataSize() + estHeaderRlpSize; bytes >= softResponseLimit {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendHeaderProofs(req.ReqID, bv, proofs)\n\n\tcase GetHelperTrieProofsMsg:\n\t\tp.Log().Trace(\"Received helper trie proof request\")\n\t\t// Decode the retrieval message\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tReqs  []HelperTrieReq\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\t// Gather state data until the fetch or network limits is reached\n\t\tvar (\n\t\t\tauxBytes int\n\t\t\tauxData  [][]byte\n\t\t)\n\t\treqCnt := len(req.Reqs)\n\t\tif reject(uint64(reqCnt), MaxHelperTrieProofsFetch) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\tvar (\n\t\t\tlastIdx  uint64\n\t\t\tlastType uint\n\t\t\troot     common.Hash\n\t\t\tauxTrie  *trie.Trie\n\t\t)\n\t\tnodes := light.NewNodeSet()\n\t\tfor _, req := range req.Reqs {\n\t\t\tif auxTrie == nil || req.Type != lastType || req.TrieIdx != lastIdx {\n\t\t\t\tauxTrie, lastType, lastIdx = nil, req.Type, req.TrieIdx\n\n\t\t\t\tvar prefix string\n\t\t\t\tif root, prefix = pm.getHelperTrie(req.Type, req.TrieIdx); root != (common.Hash{}) {\n\t\t\t\t\tauxTrie, _ = trie.New(root, trie.NewDatabase(ethdb.NewTable(pm.chainDb, prefix)))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif req.AuxReq == auxRoot {\n\t\t\t\tvar data []byte\n\t\t\t\tif root != (common.Hash{}) {\n\t\t\t\t\tdata = root[:]\n\t\t\t\t}\n\t\t\t\tauxData = append(auxData, data)\n\t\t\t\tauxBytes += len(data)\n\t\t\t} else {\n\t\t\t\tif auxTrie != nil {\n\t\t\t\t\tauxTrie.Prove(req.Key, req.FromLevel, nodes)\n\t\t\t\t}\n\t\t\t\tif req.AuxReq != 0 {\n\t\t\t\t\tdata := pm.getHelperTrieAuxData(req)\n\t\t\t\t\tauxData = append(auxData, data)\n\t\t\t\t\tauxBytes += len(data)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif nodes.DataSize()+auxBytes >= softResponseLimit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\t\treturn p.SendHelperTrieProofs(req.ReqID, bv, HelperTrieResps{Proofs: nodes.NodeList(), AuxData: auxData})\n\n\tcase HeaderProofsMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received headers proof response\")\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      []ChtResp\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgHeaderProofs,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase HelperTrieProofsMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received helper trie proof response\")\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tData      HelperTrieResps\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\t\tdeliverMsg = &Msg{\n\t\t\tMsgType: MsgHelperTrieProofs,\n\t\t\tReqID:   resp.ReqID,\n\t\t\tObj:     resp.Data,\n\t\t}\n\n\tcase SendTxMsg:\n\t\tif pm.txpool == nil {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\t// Transactions arrived, parse all of them and deliver to the pool\n\t\tvar txs []*types.Transaction\n\t\tif err := msg.Decode(&txs); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\treqCnt := len(txs)\n\t\tif reject(uint64(reqCnt), MaxTxSend) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tpm.txpool.AddRemotes(txs)\n\n\t\t_, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\n\tcase SendTxV2Msg:\n\t\tif pm.txpool == nil {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\t// Transactions arrived, parse all of them and deliver to the pool\n\t\tvar req struct {\n\t\t\tReqID uint64\n\t\t\tTxs   []*types.Transaction\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\treqCnt := len(req.Txs)\n\t\tif reject(uint64(reqCnt), MaxTxSend) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\n\t\thashes := make([]common.Hash, len(req.Txs))\n\t\tfor i, tx := range req.Txs {\n\t\t\thashes[i] = tx.Hash()\n\t\t}\n\t\tstats := pm.txStatus(hashes)\n\t\tfor i, stat := range stats {\n\t\t\tif stat.Status == core.TxStatusUnknown {\n\t\t\t\tif errs := pm.txpool.AddRemotes([]*types.Transaction{req.Txs[i]}); errs[0] != nil {\n\t\t\t\t\tstats[i].Error = errs[0].Error()\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tstats[i] = pm.txStatus([]common.Hash{hashes[i]})[0]\n\t\t\t}\n\t\t}\n\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\n\t\treturn p.SendTxStatus(req.ReqID, bv, stats)\n\n\tcase GetTxStatusMsg:\n\t\tif pm.txpool == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\t\t// Transactions arrived, parse all of them and deliver to the pool\n\t\tvar req struct {\n\t\t\tReqID  uint64\n\t\t\tHashes []common.Hash\n\t\t}\n\t\tif err := msg.Decode(&req); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\t\treqCnt := len(req.Hashes)\n\t\tif reject(uint64(reqCnt), MaxTxStatus) {\n\t\t\treturn errResp(ErrRequestRejected, \"\")\n\t\t}\n\t\tbv, rcost := p.fcClient.RequestProcessed(costs.baseCost + uint64(reqCnt)*costs.reqCost)\n\t\tpm.server.fcCostStats.update(msg.Code, uint64(reqCnt), rcost)\n\n\t\treturn p.SendTxStatus(req.ReqID, bv, pm.txStatus(req.Hashes))\n\n\tcase TxStatusMsg:\n\t\tif pm.odr == nil {\n\t\t\treturn errResp(ErrUnexpectedResponse, \"\")\n\t\t}\n\n\t\tp.Log().Trace(\"Received tx status response\")\n\t\tvar resp struct {\n\t\t\tReqID, BV uint64\n\t\t\tStatus    []txStatus\n\t\t}\n\t\tif err := msg.Decode(&resp); err != nil {\n\t\t\treturn errResp(ErrDecode, \"msg %v: %v\", msg, err)\n\t\t}\n\n\t\tp.fcServer.GotReply(resp.ReqID, resp.BV)\n\n\tdefault:\n\t\tp.Log().Trace(\"Received unknown message\", \"code\", msg.Code)\n\t\treturn errResp(ErrInvalidMsgCode, \"%v\", msg.Code)\n\t}\n\n\tif deliverMsg != nil {\n\t\terr := pm.retriever.deliver(p, deliverMsg)\n\t\tif err != nil {\n\t\t\tp.responseErrors++\n\t\t\tif p.responseErrors > maxResponseErrors {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// getAccount retrieves an account from the state based at root.\nfunc (pm *ProtocolManager) getAccount(statedb *state.StateDB, root, hash common.Hash) (state.Account, error) {\n\ttrie, err := trie.New(root, statedb.Database().TrieDB())\n\tif err != nil {\n\t\treturn state.Account{}, err\n\t}\n\tblob, err := trie.TryGet(hash[:])\n\tif err != nil {\n\t\treturn state.Account{}, err\n\t}\n\tvar account state.Account\n\tif err = rlp.DecodeBytes(blob, &account); err != nil {\n\t\treturn state.Account{}, err\n\t}\n\treturn account, nil\n}\n\n// getHelperTrie returns the post-processed trie root for the given trie ID and section index\nfunc (pm *ProtocolManager) getHelperTrie(id uint, idx uint64) (common.Hash, string) {\n\tswitch id {\n\tcase htCanonical:\n\t\tsectionHead := rawdb.ReadCanonicalHash(pm.chainDb, (idx+1)*light.CHTFrequencyClient-1)\n\t\treturn light.GetChtV2Root(pm.chainDb, idx, sectionHead), light.ChtTablePrefix\n\tcase htBloomBits:\n\t\tsectionHead := rawdb.ReadCanonicalHash(pm.chainDb, (idx+1)*light.BloomTrieFrequency-1)\n\t\treturn light.GetBloomTrieRoot(pm.chainDb, idx, sectionHead), light.BloomTrieTablePrefix\n\t}\n\treturn common.Hash{}, \"\"\n}\n\n// getHelperTrieAuxData returns requested auxiliary data for the given HelperTrie request\nfunc (pm *ProtocolManager) getHelperTrieAuxData(req HelperTrieReq) []byte {\n\tswitch {\n\tcase req.Type == htCanonical && req.AuxReq == auxHeader && len(req.Key) == 8:\n\t\tblockNum := binary.BigEndian.Uint64(req.Key)\n\t\thash := rawdb.ReadCanonicalHash(pm.chainDb, blockNum)\n\t\treturn rawdb.ReadHeaderRLP(pm.chainDb, hash, blockNum)\n\t}\n\treturn nil\n}\n\nfunc (pm *ProtocolManager) txStatus(hashes []common.Hash) []txStatus {\n\tstats := make([]txStatus, len(hashes))\n\tfor i, stat := range pm.txpool.Status(hashes) {\n\t\t// Save the status we've got from the transaction pool\n\t\tstats[i].Status = stat\n\n\t\t// If the transaction is unknown to the pool, try looking it up locally\n\t\tif stat == core.TxStatusUnknown {\n\t\t\tif block, number, index := rawdb.ReadTxLookupEntry(pm.chainDb, hashes[i]); block != (common.Hash{}) {\n\t\t\t\tstats[i].Status = core.TxStatusIncluded\n\t\t\t\tstats[i].Lookup = &rawdb.TxLookupEntry{BlockHash: block, BlockIndex: number, Index: index}\n\t\t\t}\n\t\t}\n\t}\n\treturn stats\n}\n\n// NodeInfo represents a short summary of the Ethereum sub-protocol metadata\n// known about the host peer.\ntype NodeInfo struct {\n\tNetwork    uint64              `json:\"network\"`    // Ethereum network ID (1=Frontier, 2=Morden, Ropsten=3, Rinkeby=4)\n\tDifficulty *big.Int            `json:\"difficulty\"` // Total difficulty of the host's blockchain\n\tGenesis    common.Hash         `json:\"genesis\"`    // SHA3 hash of the host's genesis block\n\tConfig     *params.ChainConfig `json:\"config\"`     // Chain configuration for the fork rules\n\tHead       common.Hash         `json:\"head\"`       // SHA3 hash of the host's best owned block\n}\n\n// NodeInfo retrieves some protocol metadata about the running host node.\nfunc (self *ProtocolManager) NodeInfo() *NodeInfo {\n\thead := self.blockchain.CurrentHeader()\n\thash := head.Hash()\n\n\treturn &NodeInfo{\n\t\tNetwork:    self.networkId,\n\t\tDifficulty: self.blockchain.GetTd(hash, head.Number.Uint64()),\n\t\tGenesis:    self.blockchain.Genesis().Hash(),\n\t\tConfig:     self.blockchain.Config(),\n\t\tHead:       hash,\n\t}\n}\n\n// downloaderPeerNotify implements peerSetNotify\ntype downloaderPeerNotify ProtocolManager\n\ntype peerConnection struct {\n\tmanager *ProtocolManager\n\tpeer    *peer\n}\n\nfunc (pc *peerConnection) Head() (common.Hash, *big.Int) {\n\treturn pc.peer.HeadAndTd()\n}\n\nfunc (pc *peerConnection) RequestHeadersByHash(origin common.Hash, amount int, skip int, reverse bool) error {\n\treqID := genReqID()\n\trq := &distReq{\n\t\tgetCost: func(dp distPeer) uint64 {\n\t\t\tpeer := dp.(*peer)\n\t\t\treturn peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t},\n\t\tcanSend: func(dp distPeer) bool {\n\t\t\treturn dp.(*peer) == pc.peer\n\t\t},\n\t\trequest: func(dp distPeer) func() {\n\t\t\tpeer := dp.(*peer)\n\t\t\tcost := peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t\tpeer.fcServer.QueueRequest(reqID, cost)\n\t\t\treturn func() { peer.RequestHeadersByHash(reqID, cost, origin, amount, skip, reverse) }\n\t\t},\n\t}\n\t_, ok := <-pc.manager.reqDist.queue(rq)\n\tif !ok {\n\t\treturn ErrNoPeers\n\t}\n\treturn nil\n}\n\nfunc (pc *peerConnection) RequestHeadersByNumber(origin uint64, amount int, skip int, reverse bool) error {\n\treqID := genReqID()\n\trq := &distReq{\n\t\tgetCost: func(dp distPeer) uint64 {\n\t\t\tpeer := dp.(*peer)\n\t\t\treturn peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t},\n\t\tcanSend: func(dp distPeer) bool {\n\t\t\treturn dp.(*peer) == pc.peer\n\t\t},\n\t\trequest: func(dp distPeer) func() {\n\t\t\tpeer := dp.(*peer)\n\t\t\tcost := peer.GetRequestCost(GetBlockHeadersMsg, amount)\n\t\t\tpeer.fcServer.QueueRequest(reqID, cost)\n\t\t\treturn func() { peer.RequestHeadersByNumber(reqID, cost, origin, amount, skip, reverse) }\n\t\t},\n\t}\n\t_, ok := <-pc.manager.reqDist.queue(rq)\n\tif !ok {\n\t\treturn ErrNoPeers\n\t}\n\treturn nil\n}\n\nfunc (d *downloaderPeerNotify) registerPeer(p *peer) {\n\tpm := (*ProtocolManager)(d)\n\tpc := &peerConnection{\n\t\tmanager: pm,\n\t\tpeer:    p,\n\t}\n\tpm.downloader.RegisterLightPeer(p.id, ethVersion, pc)\n}\n\nfunc (d *downloaderPeerNotify) unregisterPeer(p *peer) {\n\tpm := (*ProtocolManager)(d)\n\tpm.downloader.UnregisterPeer(p.id)\n}\n"], "filenames": ["les/handler.go"], "buggy_code_start_loc": [21], "buggy_code_end_loc": [465], "fixing_code_start_loc": [22], "fixing_code_end_loc": [475], "type": "CWE-129", "message": "The GetBlockHeadersMsg handler in the LES protocol implementation in Go Ethereum (aka geth) before 1.8.11 may lead to an access violation because of an integer signedness error for the array index, which allows attackers to launch a Denial of Service attack by sending a packet with a -1 query.Skip value. The vulnerable remote node would be crashed by such an attack immediately, aka the EPoD (Ethereum Packet of Death) issue.", "other": {"cve": {"id": "CVE-2018-12018", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-05T02:29:00.247", "lastModified": "2018-09-04T15:57:30.660", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The GetBlockHeadersMsg handler in the LES protocol implementation in Go Ethereum (aka geth) before 1.8.11 may lead to an access violation because of an integer signedness error for the array index, which allows attackers to launch a Denial of Service attack by sending a packet with a -1 query.Skip value. The vulnerable remote node would be crashed by such an attack immediately, aka the EPoD (Ethereum Packet of Death) issue."}, {"lang": "es", "value": "El manipulador GetBlockHeadersMsg en la implementaci\u00f3n del protocolo LES en Go Ethereum (tambi\u00e9n conocido como geth) en versiones anteriores a la1.8.11 puede conducir a una infracci\u00f3n de acceso debido a un error en la propiedad signedness de un n\u00famero entero para el \u00edndice del array, lo que permite que los atacantes lancen un ataque de denegaci\u00f3n de servicio (DoS) enviando un paquete con un valor -1 query.Skip. El nodo remoto vulnerable se cerrar\u00eda de manera inesperada por dicho ataque inmediatamente, tambi\u00e9n conocido como vulnerabilidad EPoD (Ethereum Packet of Death)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ethereum:go_ethereum:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.8.11", "matchCriteriaId": "CCDC4446-D7A9-4DCF-99A9-CBC521D3B46D"}]}]}], "references": [{"url": "https://github.com/ethereum/go-ethereum/commit/a5237a27eaf81946a3edb4fafe13ed6359d119e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ethereum/go-ethereum/pull/16891", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ethereum/go-ethereum/releases/tag/v1.8.11", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://peckshield.com/2018/06/27/EPoD/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ethereum/go-ethereum/commit/a5237a27eaf81946a3edb4fafe13ed6359d119e4"}}