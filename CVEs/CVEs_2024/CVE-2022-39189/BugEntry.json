{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This header defines architecture specific interfaces, x86 version\n */\n\n#ifndef _ASM_X86_KVM_HOST_H\n#define _ASM_X86_KVM_HOST_H\n\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/tracepoint.h>\n#include <linux/cpumask.h>\n#include <linux/irq_work.h>\n#include <linux/irq.h>\n#include <linux/workqueue.h>\n\n#include <linux/kvm.h>\n#include <linux/kvm_para.h>\n#include <linux/kvm_types.h>\n#include <linux/perf_event.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/clocksource.h>\n#include <linux/irqbypass.h>\n#include <linux/hyperv.h>\n\n#include <asm/apic.h>\n#include <asm/pvclock-abi.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/msr-index.h>\n#include <asm/asm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_vcpu_regs.h>\n#include <asm/hyperv-tlfs.h>\n\n#define __KVM_HAVE_ARCH_VCPU_DEBUGFS\n\n#define KVM_MAX_VCPUS 1024\n\n/*\n * In x86, the VCPU ID corresponds to the APIC ID, and APIC IDs\n * might be larger than the actual number of VCPUs because the\n * APIC ID encodes CPU topology information.\n *\n * In the worst case, we'll need less than one extra bit for the\n * Core ID, and less than one extra bit for the Package (Die) ID,\n * so ratio of 4 should be enough.\n */\n#define KVM_VCPU_ID_RATIO 4\n#define KVM_MAX_VCPU_IDS (KVM_MAX_VCPUS * KVM_VCPU_ID_RATIO)\n\n/* memory slots that are not exposed to userspace */\n#define KVM_PRIVATE_MEM_SLOTS 3\n\n#define KVM_HALT_POLL_NS_DEFAULT 200000\n\n#define KVM_IRQCHIP_NUM_PINS  KVM_IOAPIC_NUM_PINS\n\n#define KVM_DIRTY_LOG_MANUAL_CAPS   (KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE | \\\n\t\t\t\t\tKVM_DIRTY_LOG_INITIALLY_SET)\n\n#define KVM_BUS_LOCK_DETECTION_VALID_MODE\t(KVM_BUS_LOCK_DETECTION_OFF | \\\n\t\t\t\t\t\t KVM_BUS_LOCK_DETECTION_EXIT)\n\n/* x86-specific vcpu->requests bit members */\n#define KVM_REQ_MIGRATE_TIMER\t\tKVM_ARCH_REQ(0)\n#define KVM_REQ_REPORT_TPR_ACCESS\tKVM_ARCH_REQ(1)\n#define KVM_REQ_TRIPLE_FAULT\t\tKVM_ARCH_REQ(2)\n#define KVM_REQ_MMU_SYNC\t\tKVM_ARCH_REQ(3)\n#define KVM_REQ_CLOCK_UPDATE\t\tKVM_ARCH_REQ(4)\n#define KVM_REQ_LOAD_MMU_PGD\t\tKVM_ARCH_REQ(5)\n#define KVM_REQ_EVENT\t\t\tKVM_ARCH_REQ(6)\n#define KVM_REQ_APF_HALT\t\tKVM_ARCH_REQ(7)\n#define KVM_REQ_STEAL_UPDATE\t\tKVM_ARCH_REQ(8)\n#define KVM_REQ_NMI\t\t\tKVM_ARCH_REQ(9)\n#define KVM_REQ_PMU\t\t\tKVM_ARCH_REQ(10)\n#define KVM_REQ_PMI\t\t\tKVM_ARCH_REQ(11)\n#define KVM_REQ_SMI\t\t\tKVM_ARCH_REQ(12)\n#define KVM_REQ_MASTERCLOCK_UPDATE\tKVM_ARCH_REQ(13)\n#define KVM_REQ_MCLOCK_INPROGRESS \\\n\tKVM_ARCH_REQ_FLAGS(14, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_SCAN_IOAPIC \\\n\tKVM_ARCH_REQ_FLAGS(15, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_GLOBAL_CLOCK_UPDATE\tKVM_ARCH_REQ(16)\n#define KVM_REQ_APIC_PAGE_RELOAD \\\n\tKVM_ARCH_REQ_FLAGS(17, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_HV_CRASH\t\tKVM_ARCH_REQ(18)\n#define KVM_REQ_IOAPIC_EOI_EXIT\t\tKVM_ARCH_REQ(19)\n#define KVM_REQ_HV_RESET\t\tKVM_ARCH_REQ(20)\n#define KVM_REQ_HV_EXIT\t\t\tKVM_ARCH_REQ(21)\n#define KVM_REQ_HV_STIMER\t\tKVM_ARCH_REQ(22)\n#define KVM_REQ_LOAD_EOI_EXITMAP\tKVM_ARCH_REQ(23)\n#define KVM_REQ_GET_NESTED_STATE_PAGES\tKVM_ARCH_REQ(24)\n#define KVM_REQ_APICV_UPDATE \\\n\tKVM_ARCH_REQ_FLAGS(25, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_TLB_FLUSH_CURRENT\tKVM_ARCH_REQ(26)\n#define KVM_REQ_TLB_FLUSH_GUEST \\\n\tKVM_ARCH_REQ_FLAGS(27, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_APF_READY\t\tKVM_ARCH_REQ(28)\n#define KVM_REQ_MSR_FILTER_CHANGED\tKVM_ARCH_REQ(29)\n#define KVM_REQ_UPDATE_CPU_DIRTY_LOGGING \\\n\tKVM_ARCH_REQ_FLAGS(30, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_MMU_FREE_OBSOLETE_ROOTS \\\n\tKVM_ARCH_REQ_FLAGS(31, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n\n#define CR0_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR0_PE | X86_CR0_MP | X86_CR0_EM | X86_CR0_TS \\\n\t\t\t  | X86_CR0_ET | X86_CR0_NE | X86_CR0_WP | X86_CR0_AM \\\n\t\t\t  | X86_CR0_NW | X86_CR0_CD | X86_CR0_PG))\n\n#define CR4_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE\\\n\t\t\t  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \\\n\t\t\t  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \\\n\t\t\t  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \\\n\t\t\t  | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_VMXE \\\n\t\t\t  | X86_CR4_SMAP | X86_CR4_PKE | X86_CR4_UMIP))\n\n#define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)\n\n\n\n#define INVALID_PAGE (~(hpa_t)0)\n#define VALID_PAGE(x) ((x) != INVALID_PAGE)\n\n#define UNMAPPED_GVA (~(gpa_t)0)\n#define INVALID_GPA (~(gpa_t)0)\n\n/* KVM Hugepage definitions for x86 */\n#define KVM_MAX_HUGEPAGE_LEVEL\tPG_LEVEL_1G\n#define KVM_NR_PAGE_SIZES\t(KVM_MAX_HUGEPAGE_LEVEL - PG_LEVEL_4K + 1)\n#define KVM_HPAGE_GFN_SHIFT(x)\t(((x) - 1) * 9)\n#define KVM_HPAGE_SHIFT(x)\t(PAGE_SHIFT + KVM_HPAGE_GFN_SHIFT(x))\n#define KVM_HPAGE_SIZE(x)\t(1UL << KVM_HPAGE_SHIFT(x))\n#define KVM_HPAGE_MASK(x)\t(~(KVM_HPAGE_SIZE(x) - 1))\n#define KVM_PAGES_PER_HPAGE(x)\t(KVM_HPAGE_SIZE(x) / PAGE_SIZE)\n\n#define KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO 50\n#define KVM_MIN_ALLOC_MMU_PAGES 64UL\n#define KVM_MMU_HASH_SHIFT 12\n#define KVM_NUM_MMU_PAGES (1 << KVM_MMU_HASH_SHIFT)\n#define KVM_MIN_FREE_MMU_PAGES 5\n#define KVM_REFILL_PAGES 25\n#define KVM_MAX_CPUID_ENTRIES 256\n#define KVM_NR_FIXED_MTRR_REGION 88\n#define KVM_NR_VAR_MTRR 8\n\n#define ASYNC_PF_PER_VCPU 64\n\nenum kvm_reg {\n\tVCPU_REGS_RAX = __VCPU_REGS_RAX,\n\tVCPU_REGS_RCX = __VCPU_REGS_RCX,\n\tVCPU_REGS_RDX = __VCPU_REGS_RDX,\n\tVCPU_REGS_RBX = __VCPU_REGS_RBX,\n\tVCPU_REGS_RSP = __VCPU_REGS_RSP,\n\tVCPU_REGS_RBP = __VCPU_REGS_RBP,\n\tVCPU_REGS_RSI = __VCPU_REGS_RSI,\n\tVCPU_REGS_RDI = __VCPU_REGS_RDI,\n#ifdef CONFIG_X86_64\n\tVCPU_REGS_R8  = __VCPU_REGS_R8,\n\tVCPU_REGS_R9  = __VCPU_REGS_R9,\n\tVCPU_REGS_R10 = __VCPU_REGS_R10,\n\tVCPU_REGS_R11 = __VCPU_REGS_R11,\n\tVCPU_REGS_R12 = __VCPU_REGS_R12,\n\tVCPU_REGS_R13 = __VCPU_REGS_R13,\n\tVCPU_REGS_R14 = __VCPU_REGS_R14,\n\tVCPU_REGS_R15 = __VCPU_REGS_R15,\n#endif\n\tVCPU_REGS_RIP,\n\tNR_VCPU_REGS,\n\n\tVCPU_EXREG_PDPTR = NR_VCPU_REGS,\n\tVCPU_EXREG_CR0,\n\tVCPU_EXREG_CR3,\n\tVCPU_EXREG_CR4,\n\tVCPU_EXREG_RFLAGS,\n\tVCPU_EXREG_SEGMENTS,\n\tVCPU_EXREG_EXIT_INFO_1,\n\tVCPU_EXREG_EXIT_INFO_2,\n};\n\nenum {\n\tVCPU_SREG_ES,\n\tVCPU_SREG_CS,\n\tVCPU_SREG_SS,\n\tVCPU_SREG_DS,\n\tVCPU_SREG_FS,\n\tVCPU_SREG_GS,\n\tVCPU_SREG_TR,\n\tVCPU_SREG_LDTR,\n};\n\nenum exit_fastpath_completion {\n\tEXIT_FASTPATH_NONE,\n\tEXIT_FASTPATH_REENTER_GUEST,\n\tEXIT_FASTPATH_EXIT_HANDLED,\n};\ntypedef enum exit_fastpath_completion fastpath_t;\n\nstruct x86_emulate_ctxt;\nstruct x86_exception;\nenum x86_intercept;\nenum x86_intercept_stage;\n\n#define KVM_NR_DB_REGS\t4\n\n#define DR6_BUS_LOCK   (1 << 11)\n#define DR6_BD\t\t(1 << 13)\n#define DR6_BS\t\t(1 << 14)\n#define DR6_BT\t\t(1 << 15)\n#define DR6_RTM\t\t(1 << 16)\n/*\n * DR6_ACTIVE_LOW combines fixed-1 and active-low bits.\n * We can regard all the bits in DR6_FIXED_1 as active_low bits;\n * they will never be 0 for now, but when they are defined\n * in the future it will require no code change.\n *\n * DR6_ACTIVE_LOW is also used as the init/reset value for DR6.\n */\n#define DR6_ACTIVE_LOW\t0xffff0ff0\n#define DR6_VOLATILE\t0x0001e80f\n#define DR6_FIXED_1\t(DR6_ACTIVE_LOW & ~DR6_VOLATILE)\n\n#define DR7_BP_EN_MASK\t0x000000ff\n#define DR7_GE\t\t(1 << 9)\n#define DR7_GD\t\t(1 << 13)\n#define DR7_FIXED_1\t0x00000400\n#define DR7_VOLATILE\t0xffff2bff\n\n#define KVM_GUESTDBG_VALID_MASK \\\n\t(KVM_GUESTDBG_ENABLE | \\\n\tKVM_GUESTDBG_SINGLESTEP | \\\n\tKVM_GUESTDBG_USE_HW_BP | \\\n\tKVM_GUESTDBG_USE_SW_BP | \\\n\tKVM_GUESTDBG_INJECT_BP | \\\n\tKVM_GUESTDBG_INJECT_DB | \\\n\tKVM_GUESTDBG_BLOCKIRQ)\n\n\n#define PFERR_PRESENT_BIT 0\n#define PFERR_WRITE_BIT 1\n#define PFERR_USER_BIT 2\n#define PFERR_RSVD_BIT 3\n#define PFERR_FETCH_BIT 4\n#define PFERR_PK_BIT 5\n#define PFERR_SGX_BIT 15\n#define PFERR_GUEST_FINAL_BIT 32\n#define PFERR_GUEST_PAGE_BIT 33\n#define PFERR_IMPLICIT_ACCESS_BIT 48\n\n#define PFERR_PRESENT_MASK (1U << PFERR_PRESENT_BIT)\n#define PFERR_WRITE_MASK (1U << PFERR_WRITE_BIT)\n#define PFERR_USER_MASK (1U << PFERR_USER_BIT)\n#define PFERR_RSVD_MASK (1U << PFERR_RSVD_BIT)\n#define PFERR_FETCH_MASK (1U << PFERR_FETCH_BIT)\n#define PFERR_PK_MASK (1U << PFERR_PK_BIT)\n#define PFERR_SGX_MASK (1U << PFERR_SGX_BIT)\n#define PFERR_GUEST_FINAL_MASK (1ULL << PFERR_GUEST_FINAL_BIT)\n#define PFERR_GUEST_PAGE_MASK (1ULL << PFERR_GUEST_PAGE_BIT)\n#define PFERR_IMPLICIT_ACCESS (1ULL << PFERR_IMPLICIT_ACCESS_BIT)\n\n#define PFERR_NESTED_GUEST_PAGE (PFERR_GUEST_PAGE_MASK |\t\\\n\t\t\t\t PFERR_WRITE_MASK |\t\t\\\n\t\t\t\t PFERR_PRESENT_MASK)\n\n/* apic attention bits */\n#define KVM_APIC_CHECK_VAPIC\t0\n/*\n * The following bit is set with PV-EOI, unset on EOI.\n * We detect PV-EOI changes by guest by comparing\n * this bit with PV-EOI in guest memory.\n * See the implementation in apic_update_pv_eoi.\n */\n#define KVM_APIC_PV_EOI_PENDING\t1\n\nstruct kvm_kernel_irq_routing_entry;\n\n/*\n * kvm_mmu_page_role tracks the properties of a shadow page (where shadow page\n * also includes TDP pages) to determine whether or not a page can be used in\n * the given MMU context.  This is a subset of the overall kvm_cpu_role to\n * minimize the size of kvm_memory_slot.arch.gfn_track, i.e. allows allocating\n * 2 bytes per gfn instead of 4 bytes per gfn.\n *\n * Upper-level shadow pages having gptes are tracked for write-protection via\n * gfn_track.  As above, gfn_track is a 16 bit counter, so KVM must not create\n * more than 2^16-1 upper-level shadow pages at a single gfn, otherwise\n * gfn_track will overflow and explosions will ensure.\n *\n * A unique shadow page (SP) for a gfn is created if and only if an existing SP\n * cannot be reused.  The ability to reuse a SP is tracked by its role, which\n * incorporates various mode bits and properties of the SP.  Roughly speaking,\n * the number of unique SPs that can theoretically be created is 2^n, where n\n * is the number of bits that are used to compute the role.\n *\n * But, even though there are 19 bits in the mask below, not all combinations\n * of modes and flags are possible:\n *\n *   - invalid shadow pages are not accounted, so the bits are effectively 18\n *\n *   - quadrant will only be used if has_4_byte_gpte=1 (non-PAE paging);\n *     execonly and ad_disabled are only used for nested EPT which has\n *     has_4_byte_gpte=0.  Therefore, 2 bits are always unused.\n *\n *   - the 4 bits of level are effectively limited to the values 2/3/4/5,\n *     as 4k SPs are not tracked (allowed to go unsync).  In addition non-PAE\n *     paging has exactly one upper level, making level completely redundant\n *     when has_4_byte_gpte=1.\n *\n *   - on top of this, smep_andnot_wp and smap_andnot_wp are only set if\n *     cr0_wp=0, therefore these three bits only give rise to 5 possibilities.\n *\n * Therefore, the maximum number of possible upper-level shadow pages for a\n * single gfn is a bit less than 2^13.\n */\nunion kvm_mmu_page_role {\n\tu32 word;\n\tstruct {\n\t\tunsigned level:4;\n\t\tunsigned has_4_byte_gpte:1;\n\t\tunsigned quadrant:2;\n\t\tunsigned direct:1;\n\t\tunsigned access:3;\n\t\tunsigned invalid:1;\n\t\tunsigned efer_nx:1;\n\t\tunsigned cr0_wp:1;\n\t\tunsigned smep_andnot_wp:1;\n\t\tunsigned smap_andnot_wp:1;\n\t\tunsigned ad_disabled:1;\n\t\tunsigned guest_mode:1;\n\t\tunsigned passthrough:1;\n\t\tunsigned :5;\n\n\t\t/*\n\t\t * This is left at the top of the word so that\n\t\t * kvm_memslots_for_spte_role can extract it with a\n\t\t * simple shift.  While there is room, give it a whole\n\t\t * byte so it is also faster to load it from memory.\n\t\t */\n\t\tunsigned smm:8;\n\t};\n};\n\n/*\n * kvm_mmu_extended_role complements kvm_mmu_page_role, tracking properties\n * relevant to the current MMU configuration.   When loading CR0, CR4, or EFER,\n * including on nested transitions, if nothing in the full role changes then\n * MMU re-configuration can be skipped. @valid bit is set on first usage so we\n * don't treat all-zero structure as valid data.\n *\n * The properties that are tracked in the extended role but not the page role\n * are for things that either (a) do not affect the validity of the shadow page\n * or (b) are indirectly reflected in the shadow page's role.  For example,\n * CR4.PKE only affects permission checks for software walks of the guest page\n * tables (because KVM doesn't support Protection Keys with shadow paging), and\n * CR0.PG, CR4.PAE, and CR4.PSE are indirectly reflected in role.level.\n *\n * Note, SMEP and SMAP are not redundant with sm*p_andnot_wp in the page role.\n * If CR0.WP=1, KVM can reuse shadow pages for the guest regardless of SMEP and\n * SMAP, but the MMU's permission checks for software walks need to be SMEP and\n * SMAP aware regardless of CR0.WP.\n */\nunion kvm_mmu_extended_role {\n\tu32 word;\n\tstruct {\n\t\tunsigned int valid:1;\n\t\tunsigned int execonly:1;\n\t\tunsigned int cr4_pse:1;\n\t\tunsigned int cr4_pke:1;\n\t\tunsigned int cr4_smap:1;\n\t\tunsigned int cr4_smep:1;\n\t\tunsigned int cr4_la57:1;\n\t\tunsigned int efer_lma:1;\n\t};\n};\n\nunion kvm_cpu_role {\n\tu64 as_u64;\n\tstruct {\n\t\tunion kvm_mmu_page_role base;\n\t\tunion kvm_mmu_extended_role ext;\n\t};\n};\n\nstruct kvm_rmap_head {\n\tunsigned long val;\n};\n\nstruct kvm_pio_request {\n\tunsigned long linear_rip;\n\tunsigned long count;\n\tint in;\n\tint port;\n\tint size;\n};\n\n#define PT64_ROOT_MAX_LEVEL 5\n\nstruct rsvd_bits_validate {\n\tu64 rsvd_bits_mask[2][PT64_ROOT_MAX_LEVEL];\n\tu64 bad_mt_xwr;\n};\n\nstruct kvm_mmu_root_info {\n\tgpa_t pgd;\n\thpa_t hpa;\n};\n\n#define KVM_MMU_ROOT_INFO_INVALID \\\n\t((struct kvm_mmu_root_info) { .pgd = INVALID_PAGE, .hpa = INVALID_PAGE })\n\n#define KVM_MMU_NUM_PREV_ROOTS 3\n\n#define KVM_HAVE_MMU_RWLOCK\n\nstruct kvm_mmu_page;\nstruct kvm_page_fault;\n\n/*\n * x86 supports 4 paging modes (5-level 64-bit, 4-level 64-bit, 3-level 32-bit,\n * and 2-level 32-bit).  The kvm_mmu structure abstracts the details of the\n * current mmu mode.\n */\nstruct kvm_mmu {\n\tunsigned long (*get_guest_pgd)(struct kvm_vcpu *vcpu);\n\tu64 (*get_pdptr)(struct kvm_vcpu *vcpu, int index);\n\tint (*page_fault)(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault);\n\tvoid (*inject_page_fault)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_exception *fault);\n\tgpa_t (*gva_to_gpa)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gpa_t gva_or_gpa, u64 access,\n\t\t\t    struct x86_exception *exception);\n\tint (*sync_page)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_mmu_page *sp);\n\tvoid (*invlpg)(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root_hpa);\n\tstruct kvm_mmu_root_info root;\n\tunion kvm_cpu_role cpu_role;\n\tunion kvm_mmu_page_role root_role;\n\n\t/*\n\t* The pkru_mask indicates if protection key checks are needed.  It\n\t* consists of 16 domains indexed by page fault error code bits [4:1],\n\t* with PFEC.RSVD replaced by ACC_USER_MASK from the page tables.\n\t* Each domain has 2 bits which are ANDed with AD and WD from PKRU.\n\t*/\n\tu32 pkru_mask;\n\n\tstruct kvm_mmu_root_info prev_roots[KVM_MMU_NUM_PREV_ROOTS];\n\n\t/*\n\t * Bitmap; bit set = permission fault\n\t * Byte index: page fault error code [4:1]\n\t * Bit index: pte permissions in ACC_* format\n\t */\n\tu8 permissions[16];\n\n\tu64 *pae_root;\n\tu64 *pml4_root;\n\tu64 *pml5_root;\n\n\t/*\n\t * check zero bits on shadow page table entries, these\n\t * bits include not only hardware reserved bits but also\n\t * the bits spte never used.\n\t */\n\tstruct rsvd_bits_validate shadow_zero_check;\n\n\tstruct rsvd_bits_validate guest_rsvd_check;\n\n\tu64 pdptrs[4]; /* pae */\n};\n\nstruct kvm_tlb_range {\n\tu64 start_gfn;\n\tu64 pages;\n};\n\nenum pmc_type {\n\tKVM_PMC_GP = 0,\n\tKVM_PMC_FIXED,\n};\n\nstruct kvm_pmc {\n\tenum pmc_type type;\n\tu8 idx;\n\tu64 counter;\n\tu64 eventsel;\n\tstruct perf_event *perf_event;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * eventsel value for general purpose counters,\n\t * ctrl value for fixed counters.\n\t */\n\tu64 current_config;\n\tbool is_paused;\n\tbool intr;\n};\n\n#define KVM_PMC_MAX_FIXED\t3\nstruct kvm_pmu {\n\tunsigned nr_arch_gp_counters;\n\tunsigned nr_arch_fixed_counters;\n\tunsigned available_event_types;\n\tu64 fixed_ctr_ctrl;\n\tu64 global_ctrl;\n\tu64 global_status;\n\tu64 counter_bitmask[2];\n\tu64 global_ctrl_mask;\n\tu64 global_ovf_ctrl_mask;\n\tu64 reserved_bits;\n\tu64 raw_event_mask;\n\tu8 version;\n\tstruct kvm_pmc gp_counters[INTEL_PMC_MAX_GENERIC];\n\tstruct kvm_pmc fixed_counters[KVM_PMC_MAX_FIXED];\n\tstruct irq_work irq_work;\n\tDECLARE_BITMAP(reprogram_pmi, X86_PMC_IDX_MAX);\n\tDECLARE_BITMAP(all_valid_pmc_idx, X86_PMC_IDX_MAX);\n\tDECLARE_BITMAP(pmc_in_use, X86_PMC_IDX_MAX);\n\n\t/*\n\t * The gate to release perf_events not marked in\n\t * pmc_in_use only once in a vcpu time slice.\n\t */\n\tbool need_cleanup;\n\n\t/*\n\t * The total number of programmed perf_events and it helps to avoid\n\t * redundant check before cleanup if guest don't use vPMU at all.\n\t */\n\tu8 event_count;\n};\n\nstruct kvm_pmu_ops;\n\nenum {\n\tKVM_DEBUGREG_BP_ENABLED = 1,\n\tKVM_DEBUGREG_WONT_EXIT = 2,\n};\n\nstruct kvm_mtrr_range {\n\tu64 base;\n\tu64 mask;\n\tstruct list_head node;\n};\n\nstruct kvm_mtrr {\n\tstruct kvm_mtrr_range var_ranges[KVM_NR_VAR_MTRR];\n\tmtrr_type fixed_ranges[KVM_NR_FIXED_MTRR_REGION];\n\tu64 deftype;\n\n\tstruct list_head head;\n};\n\n/* Hyper-V SynIC timer */\nstruct kvm_vcpu_hv_stimer {\n\tstruct hrtimer timer;\n\tint index;\n\tunion hv_stimer_config config;\n\tu64 count;\n\tu64 exp_time;\n\tstruct hv_message msg;\n\tbool msg_pending;\n};\n\n/* Hyper-V synthetic interrupt controller (SynIC)*/\nstruct kvm_vcpu_hv_synic {\n\tu64 version;\n\tu64 control;\n\tu64 msg_page;\n\tu64 evt_page;\n\tatomic64_t sint[HV_SYNIC_SINT_COUNT];\n\tatomic_t sint_to_gsi[HV_SYNIC_SINT_COUNT];\n\tDECLARE_BITMAP(auto_eoi_bitmap, 256);\n\tDECLARE_BITMAP(vec_bitmap, 256);\n\tbool active;\n\tbool dont_zero_synic_pages;\n};\n\n/* Hyper-V per vcpu emulation context */\nstruct kvm_vcpu_hv {\n\tstruct kvm_vcpu *vcpu;\n\tu32 vp_index;\n\tu64 hv_vapic;\n\ts64 runtime_offset;\n\tstruct kvm_vcpu_hv_synic synic;\n\tstruct kvm_hyperv_exit exit;\n\tstruct kvm_vcpu_hv_stimer stimer[HV_SYNIC_STIMER_COUNT];\n\tDECLARE_BITMAP(stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tbool enforce_cpuid;\n\tstruct {\n\t\tu32 features_eax; /* HYPERV_CPUID_FEATURES.EAX */\n\t\tu32 features_ebx; /* HYPERV_CPUID_FEATURES.EBX */\n\t\tu32 features_edx; /* HYPERV_CPUID_FEATURES.EDX */\n\t\tu32 enlightenments_eax; /* HYPERV_CPUID_ENLIGHTMENT_INFO.EAX */\n\t\tu32 enlightenments_ebx; /* HYPERV_CPUID_ENLIGHTMENT_INFO.EBX */\n\t\tu32 syndbg_cap_eax; /* HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES.EAX */\n\t} cpuid_cache;\n};\n\n/* Xen HVM per vcpu emulation context */\nstruct kvm_vcpu_xen {\n\tu64 hypercall_rip;\n\tu32 current_runstate;\n\tu8 upcall_vector;\n\tstruct gfn_to_pfn_cache vcpu_info_cache;\n\tstruct gfn_to_pfn_cache vcpu_time_info_cache;\n\tstruct gfn_to_pfn_cache runstate_cache;\n\tu64 last_steal;\n\tu64 runstate_entry_time;\n\tu64 runstate_times[4];\n\tunsigned long evtchn_pending_sel;\n\tu32 vcpu_id; /* The Xen / ACPI vCPU ID */\n\tu32 timer_virq;\n\tu64 timer_expires; /* In guest epoch */\n\tatomic_t timer_pending;\n\tstruct hrtimer timer;\n\tint poll_evtchn;\n\tstruct timer_list poll_timer;\n};\n\nstruct kvm_vcpu_arch {\n\t/*\n\t * rip and regs accesses must go through\n\t * kvm_{register,rip}_{read,write} functions.\n\t */\n\tunsigned long regs[NR_VCPU_REGS];\n\tu32 regs_avail;\n\tu32 regs_dirty;\n\n\tunsigned long cr0;\n\tunsigned long cr0_guest_owned_bits;\n\tunsigned long cr2;\n\tunsigned long cr3;\n\tunsigned long cr4;\n\tunsigned long cr4_guest_owned_bits;\n\tunsigned long cr4_guest_rsvd_bits;\n\tunsigned long cr8;\n\tu32 host_pkru;\n\tu32 pkru;\n\tu32 hflags;\n\tu64 efer;\n\tu64 apic_base;\n\tstruct kvm_lapic *apic;    /* kernel irqchip context */\n\tbool apicv_active;\n\tbool load_eoi_exitmap_pending;\n\tDECLARE_BITMAP(ioapic_handled_vectors, 256);\n\tunsigned long apic_attention;\n\tint32_t apic_arb_prio;\n\tint mp_state;\n\tu64 ia32_misc_enable_msr;\n\tu64 smbase;\n\tu64 smi_count;\n\tbool tpr_access_reporting;\n\tbool xsaves_enabled;\n\tbool xfd_no_write_intercept;\n\tu64 ia32_xss;\n\tu64 microcode_version;\n\tu64 arch_capabilities;\n\tu64 perf_capabilities;\n\n\t/*\n\t * Paging state of the vcpu\n\t *\n\t * If the vcpu runs in guest mode with two level paging this still saves\n\t * the paging mode of the l1 guest. This context is always used to\n\t * handle faults.\n\t */\n\tstruct kvm_mmu *mmu;\n\n\t/* Non-nested MMU for L1 */\n\tstruct kvm_mmu root_mmu;\n\n\t/* L1 MMU when running nested */\n\tstruct kvm_mmu guest_mmu;\n\n\t/*\n\t * Paging state of an L2 guest (used for nested npt)\n\t *\n\t * This context will save all necessary information to walk page tables\n\t * of an L2 guest. This context is only initialized for page table\n\t * walking and not for faulting since we never handle l2 page faults on\n\t * the host.\n\t */\n\tstruct kvm_mmu nested_mmu;\n\n\t/*\n\t * Pointer to the mmu context currently used for\n\t * gva_to_gpa translations.\n\t */\n\tstruct kvm_mmu *walk_mmu;\n\n\tstruct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n\tstruct kvm_mmu_memory_cache mmu_shadow_page_cache;\n\tstruct kvm_mmu_memory_cache mmu_gfn_array_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_header_cache;\n\n\t/*\n\t * QEMU userspace and the guest each have their own FPU state.\n\t * In vcpu_run, we switch between the user and guest FPU contexts.\n\t * While running a VCPU, the VCPU thread will have the guest FPU\n\t * context.\n\t *\n\t * Note that while the PKRU state lives inside the fpu registers,\n\t * it is switched out separately at VMENTER and VMEXIT time. The\n\t * \"guest_fpstate\" state here contains the guest FPU context, with the\n\t * host PRKU bits.\n\t */\n\tstruct fpu_guest guest_fpu;\n\n\tu64 xcr0;\n\n\tstruct kvm_pio_request pio;\n\tvoid *pio_data;\n\tvoid *sev_pio_data;\n\tunsigned sev_pio_count;\n\n\tu8 event_exit_inst_len;\n\n\tstruct kvm_queued_exception {\n\t\tbool pending;\n\t\tbool injected;\n\t\tbool has_error_code;\n\t\tu8 nr;\n\t\tu32 error_code;\n\t\tunsigned long payload;\n\t\tbool has_payload;\n\t\tu8 nested_apf;\n\t} exception;\n\n\tstruct kvm_queued_interrupt {\n\t\tbool injected;\n\t\tbool soft;\n\t\tu8 nr;\n\t} interrupt;\n\n\tint halt_request; /* real mode on Intel only */\n\n\tint cpuid_nent;\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tu32 kvm_cpuid_base;\n\n\tu64 reserved_gpa_bits;\n\tint maxphyaddr;\n\n\t/* emulate context */\n\n\tstruct x86_emulate_ctxt *emulate_ctxt;\n\tbool emulate_regs_need_sync_to_vcpu;\n\tbool emulate_regs_need_sync_from_vcpu;\n\tint (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n\tgpa_t time;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tunsigned int hw_tsc_khz;\n\tstruct gfn_to_pfn_cache pv_time;\n\t/* set guest stopped flag in pvclock flags field */\n\tbool pvclock_set_guest_stopped_request;\n\n\tstruct {\n\t\tu8 preempted;\n\t\tu64 msr_val;\n\t\tu64 last_steal;\n\t\tstruct gfn_to_hva_cache cache;\n\t} st;\n\n\tu64 l1_tsc_offset;\n\tu64 tsc_offset; /* current tsc offset */\n\tu64 last_guest_tsc;\n\tu64 last_host_tsc;\n\tu64 tsc_offset_adjustment;\n\tu64 this_tsc_nsec;\n\tu64 this_tsc_write;\n\tu64 this_tsc_generation;\n\tbool tsc_catchup;\n\tbool tsc_always_catchup;\n\ts8 virtual_tsc_shift;\n\tu32 virtual_tsc_mult;\n\tu32 virtual_tsc_khz;\n\ts64 ia32_tsc_adjust_msr;\n\tu64 msr_ia32_power_ctl;\n\tu64 l1_tsc_scaling_ratio;\n\tu64 tsc_scaling_ratio; /* current scaling ratio */\n\n\tatomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n\tunsigned nmi_pending; /* NMI queued after currently running handler */\n\tbool nmi_injected;    /* Trying to inject an NMI this entry */\n\tbool smi_pending;    /* SMI queued after currently running handler */\n\tu8 handling_intr_from_guest;\n\n\tstruct kvm_mtrr mtrr_state;\n\tu64 pat;\n\n\tunsigned switch_db_regs;\n\tunsigned long db[KVM_NR_DB_REGS];\n\tunsigned long dr6;\n\tunsigned long dr7;\n\tunsigned long eff_db[KVM_NR_DB_REGS];\n\tunsigned long guest_debug_dr7;\n\tu64 msr_platform_info;\n\tu64 msr_misc_features_enables;\n\n\tu64 mcg_cap;\n\tu64 mcg_status;\n\tu64 mcg_ctl;\n\tu64 mcg_ext_ctl;\n\tu64 *mce_banks;\n\n\t/* Cache MMIO info */\n\tu64 mmio_gva;\n\tunsigned mmio_access;\n\tgfn_t mmio_gfn;\n\tu64 mmio_gen;\n\n\tstruct kvm_pmu pmu;\n\n\t/* used for guest single stepping over the given code position */\n\tunsigned long singlestep_rip;\n\n\tbool hyperv_enabled;\n\tstruct kvm_vcpu_hv *hyperv;\n\tstruct kvm_vcpu_xen xen;\n\n\tcpumask_var_t wbinvd_dirty_mask;\n\n\tunsigned long last_retry_eip;\n\tunsigned long last_retry_addr;\n\n\tstruct {\n\t\tbool halted;\n\t\tgfn_t gfns[ASYNC_PF_PER_VCPU];\n\t\tstruct gfn_to_hva_cache data;\n\t\tu64 msr_en_val; /* MSR_KVM_ASYNC_PF_EN */\n\t\tu64 msr_int_val; /* MSR_KVM_ASYNC_PF_INT */\n\t\tu16 vec;\n\t\tu32 id;\n\t\tbool send_user_only;\n\t\tu32 host_apf_flags;\n\t\tunsigned long nested_apf_token;\n\t\tbool delivery_as_pf_vmexit;\n\t\tbool pageready_pending;\n\t} apf;\n\n\t/* OSVW MSRs (AMD only) */\n\tstruct {\n\t\tu64 length;\n\t\tu64 status;\n\t} osvw;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tstruct gfn_to_hva_cache data;\n\t} pv_eoi;\n\n\tu64 msr_kvm_poll_control;\n\n\t/*\n\t * Indicates the guest is trying to write a gfn that contains one or\n\t * more of the PTEs used to translate the write itself, i.e. the access\n\t * is changing its own translation in the guest page tables.  KVM exits\n\t * to userspace if emulation of the faulting instruction fails and this\n\t * flag is set, as KVM cannot make forward progress.\n\t *\n\t * If emulation fails for a write to guest page tables, KVM unprotects\n\t * (zaps) the shadow page for the target gfn and resumes the guest to\n\t * retry the non-emulatable instruction (on hardware).  Unprotecting the\n\t * gfn doesn't allow forward progress for a self-changing access because\n\t * doing so also zaps the translation for the gfn, i.e. retrying the\n\t * instruction will hit a !PRESENT fault, which results in a new shadow\n\t * page and sends KVM back to square one.\n\t */\n\tbool write_fault_to_shadow_pgtable;\n\n\t/* set at EPT violation at this point */\n\tunsigned long exit_qualification;\n\n\t/* pv related host specific info */\n\tstruct {\n\t\tbool pv_unhalted;\n\t} pv;\n\n\tint pending_ioapic_eoi;\n\tint pending_external_vector;\n\n\t/* be preempted when it's in kernel-mode(cpl=0) */\n\tbool preempted_in_kernel;\n\n\t/* Flush the L1 Data cache for L1TF mitigation on VMENTER */\n\tbool l1tf_flush_l1d;\n\n\t/* Host CPU on which VM-entry was most recently attempted */\n\tint last_vmentry_cpu;\n\n\t/* AMD MSRC001_0015 Hardware Configuration */\n\tu64 msr_hwcr;\n\n\t/* pv related cpuid info */\n\tstruct {\n\t\t/*\n\t\t * value of the eax register in the KVM_CPUID_FEATURES CPUID\n\t\t * leaf.\n\t\t */\n\t\tu32 features;\n\n\t\t/*\n\t\t * indicates whether pv emulation should be disabled if features\n\t\t * are not present in the guest's cpuid\n\t\t */\n\t\tbool enforce;\n\t} pv_cpuid;\n\n\t/* Protected Guests */\n\tbool guest_state_protected;\n\n\t/*\n\t * Set when PDPTS were loaded directly by the userspace without\n\t * reading the guest memory\n\t */\n\tbool pdptrs_from_userspace;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\thpa_t hv_root_tdp;\n#endif\n};\n\nstruct kvm_lpage_info {\n\tint disallow_lpage;\n};\n\nstruct kvm_arch_memory_slot {\n\tstruct kvm_rmap_head *rmap[KVM_NR_PAGE_SIZES];\n\tstruct kvm_lpage_info *lpage_info[KVM_NR_PAGE_SIZES - 1];\n\tunsigned short *gfn_track[KVM_PAGE_TRACK_MAX];\n};\n\n/*\n * We use as the mode the number of bits allocated in the LDR for the\n * logical processor ID.  It happens that these are all powers of two.\n * This makes it is very easy to detect cases where the APICs are\n * configured for multiple modes; in that case, we cannot use the map and\n * hence cannot use kvm_irq_delivery_to_apic_fast either.\n */\n#define KVM_APIC_MODE_XAPIC_CLUSTER          4\n#define KVM_APIC_MODE_XAPIC_FLAT             8\n#define KVM_APIC_MODE_X2APIC                16\n\nstruct kvm_apic_map {\n\tstruct rcu_head rcu;\n\tu8 mode;\n\tu32 max_apic_id;\n\tunion {\n\t\tstruct kvm_lapic *xapic_flat_map[8];\n\t\tstruct kvm_lapic *xapic_cluster_map[16][4];\n\t};\n\tstruct kvm_lapic *phys_map[];\n};\n\n/* Hyper-V synthetic debugger (SynDbg)*/\nstruct kvm_hv_syndbg {\n\tstruct {\n\t\tu64 control;\n\t\tu64 status;\n\t\tu64 send_page;\n\t\tu64 recv_page;\n\t\tu64 pending_page;\n\t} control;\n\tu64 options;\n};\n\n/* Current state of Hyper-V TSC page clocksource */\nenum hv_tsc_page_status {\n\t/* TSC page was not set up or disabled */\n\tHV_TSC_PAGE_UNSET = 0,\n\t/* TSC page MSR was written by the guest, update pending */\n\tHV_TSC_PAGE_GUEST_CHANGED,\n\t/* TSC page update was triggered from the host side */\n\tHV_TSC_PAGE_HOST_CHANGED,\n\t/* TSC page was properly set up and is currently active  */\n\tHV_TSC_PAGE_SET,\n\t/* TSC page was set up with an inaccessible GPA */\n\tHV_TSC_PAGE_BROKEN,\n};\n\n/* Hyper-V emulation context */\nstruct kvm_hv {\n\tstruct mutex hv_lock;\n\tu64 hv_guest_os_id;\n\tu64 hv_hypercall;\n\tu64 hv_tsc_page;\n\tenum hv_tsc_page_status hv_tsc_page_status;\n\n\t/* Hyper-v based guest crash (NT kernel bugcheck) parameters */\n\tu64 hv_crash_param[HV_X64_MSR_CRASH_PARAMS];\n\tu64 hv_crash_ctl;\n\n\tstruct ms_hyperv_tsc_page tsc_ref;\n\n\tstruct idr conn_to_evt;\n\n\tu64 hv_reenlightenment_control;\n\tu64 hv_tsc_emulation_control;\n\tu64 hv_tsc_emulation_status;\n\n\t/* How many vCPUs have VP index != vCPU index */\n\tatomic_t num_mismatched_vp_indexes;\n\n\t/*\n\t * How many SynICs use 'AutoEOI' feature\n\t * (protected by arch.apicv_update_lock)\n\t */\n\tunsigned int synic_auto_eoi_used;\n\n\tstruct hv_partition_assist_pg *hv_pa_pg;\n\tstruct kvm_hv_syndbg hv_syndbg;\n};\n\nstruct msr_bitmap_range {\n\tu32 flags;\n\tu32 nmsrs;\n\tu32 base;\n\tunsigned long *bitmap;\n};\n\n/* Xen emulation context */\nstruct kvm_xen {\n\tu32 xen_version;\n\tbool long_mode;\n\tu8 upcall_vector;\n\tstruct gfn_to_pfn_cache shinfo_cache;\n\tstruct idr evtchn_ports;\n\tunsigned long poll_mask[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n};\n\nenum kvm_irqchip_mode {\n\tKVM_IRQCHIP_NONE,\n\tKVM_IRQCHIP_KERNEL,       /* created with KVM_CREATE_IRQCHIP */\n\tKVM_IRQCHIP_SPLIT,        /* created with KVM_CAP_SPLIT_IRQCHIP */\n};\n\nstruct kvm_x86_msr_filter {\n\tu8 count;\n\tbool default_allow:1;\n\tstruct msr_bitmap_range ranges[16];\n};\n\nenum kvm_apicv_inhibit {\n\tAPICV_INHIBIT_REASON_DISABLE,\n\tAPICV_INHIBIT_REASON_HYPERV,\n\tAPICV_INHIBIT_REASON_NESTED,\n\tAPICV_INHIBIT_REASON_IRQWIN,\n\tAPICV_INHIBIT_REASON_PIT_REINJ,\n\tAPICV_INHIBIT_REASON_X2APIC,\n\tAPICV_INHIBIT_REASON_BLOCKIRQ,\n\tAPICV_INHIBIT_REASON_ABSENT,\n\tAPICV_INHIBIT_REASON_SEV,\n};\n\nstruct kvm_arch {\n\tunsigned long n_used_mmu_pages;\n\tunsigned long n_requested_mmu_pages;\n\tunsigned long n_max_mmu_pages;\n\tunsigned int indirect_shadow_pages;\n\tu8 mmu_valid_gen;\n\tstruct hlist_head mmu_page_hash[KVM_NUM_MMU_PAGES];\n\tstruct list_head active_mmu_pages;\n\tstruct list_head zapped_obsolete_pages;\n\tstruct list_head lpage_disallowed_mmu_pages;\n\tstruct kvm_page_track_notifier_node mmu_sp_tracker;\n\tstruct kvm_page_track_notifier_head track_notifier_head;\n\t/*\n\t * Protects marking pages unsync during page faults, as TDP MMU page\n\t * faults only take mmu_lock for read.  For simplicity, the unsync\n\t * pages lock is always taken when marking pages unsync regardless of\n\t * whether mmu_lock is held for read or write.\n\t */\n\tspinlock_t mmu_unsync_pages_lock;\n\n\tstruct list_head assigned_dev_head;\n\tstruct iommu_domain *iommu_domain;\n\tbool iommu_noncoherent;\n#define __KVM_HAVE_ARCH_NONCOHERENT_DMA\n\tatomic_t noncoherent_dma_count;\n#define __KVM_HAVE_ARCH_ASSIGNED_DEVICE\n\tatomic_t assigned_device_count;\n\tstruct kvm_pic *vpic;\n\tstruct kvm_ioapic *vioapic;\n\tstruct kvm_pit *vpit;\n\tatomic_t vapics_in_nmi_mode;\n\tstruct mutex apic_map_lock;\n\tstruct kvm_apic_map __rcu *apic_map;\n\tatomic_t apic_map_dirty;\n\n\t/* Protects apic_access_memslot_enabled and apicv_inhibit_reasons */\n\tstruct rw_semaphore apicv_update_lock;\n\n\tbool apic_access_memslot_enabled;\n\tunsigned long apicv_inhibit_reasons;\n\n\tgpa_t wall_clock;\n\n\tbool mwait_in_guest;\n\tbool hlt_in_guest;\n\tbool pause_in_guest;\n\tbool cstate_in_guest;\n\n\tunsigned long irq_sources_bitmap;\n\ts64 kvmclock_offset;\n\n\t/*\n\t * This also protects nr_vcpus_matched_tsc which is read from a\n\t * preemption-disabled region, so it must be a raw spinlock.\n\t */\n\traw_spinlock_t tsc_write_lock;\n\tu64 last_tsc_nsec;\n\tu64 last_tsc_write;\n\tu32 last_tsc_khz;\n\tu64 last_tsc_offset;\n\tu64 cur_tsc_nsec;\n\tu64 cur_tsc_write;\n\tu64 cur_tsc_offset;\n\tu64 cur_tsc_generation;\n\tint nr_vcpus_matched_tsc;\n\n\tu32 default_tsc_khz;\n\n\tseqcount_raw_spinlock_t pvclock_sc;\n\tbool use_master_clock;\n\tu64 master_kernel_ns;\n\tu64 master_cycle_now;\n\tstruct delayed_work kvmclock_update_work;\n\tstruct delayed_work kvmclock_sync_work;\n\n\tstruct kvm_xen_hvm_config xen_hvm_config;\n\n\t/* reads protected by irq_srcu, writes by irq_lock */\n\tstruct hlist_head mask_notifier_list;\n\n\tstruct kvm_hv hyperv;\n\tstruct kvm_xen xen;\n\n\tbool backwards_tsc_observed;\n\tbool boot_vcpu_runs_old_kvmclock;\n\tu32 bsp_vcpu_id;\n\n\tu64 disabled_quirks;\n\tint cpu_dirty_logging_count;\n\n\tenum kvm_irqchip_mode irqchip_mode;\n\tu8 nr_reserved_ioapic_pins;\n\n\tbool disabled_lapic_found;\n\n\tbool x2apic_format;\n\tbool x2apic_broadcast_quirk_disabled;\n\n\tbool guest_can_read_msr_platform_info;\n\tbool exception_payload_enabled;\n\n\tbool bus_lock_detection_enabled;\n\tbool enable_pmu;\n\t/*\n\t * If exit_on_emulation_error is set, and the in-kernel instruction\n\t * emulator fails to emulate an instruction, allow userspace\n\t * the opportunity to look at it.\n\t */\n\tbool exit_on_emulation_error;\n\n\t/* Deflect RDMSR and WRMSR to user space when they trigger a #GP */\n\tu32 user_space_msr_mask;\n\tstruct kvm_x86_msr_filter __rcu *msr_filter;\n\n\tu32 hypercall_exit_enabled;\n\n\t/* Guest can access the SGX PROVISIONKEY. */\n\tbool sgx_provisioning_allowed;\n\n\tstruct kvm_pmu_event_filter __rcu *pmu_event_filter;\n\tstruct task_struct *nx_lpage_recovery_thread;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * Whether the TDP MMU is enabled for this VM. This contains a\n\t * snapshot of the TDP MMU module parameter from when the VM was\n\t * created and remains unchanged for the life of the VM. If this is\n\t * true, TDP MMU handler functions will run for various MMU\n\t * operations.\n\t */\n\tbool tdp_mmu_enabled;\n\n\t/*\n\t * List of struct kvm_mmu_pages being used as roots.\n\t * All struct kvm_mmu_pages in the list should have\n\t * tdp_mmu_page set.\n\t *\n\t * For reads, this list is protected by:\n\t *\tthe MMU lock in read mode + RCU or\n\t *\tthe MMU lock in write mode\n\t *\n\t * For writes, this list is protected by:\n\t *\tthe MMU lock in read mode + the tdp_mmu_pages_lock or\n\t *\tthe MMU lock in write mode\n\t *\n\t * Roots will remain in the list until their tdp_mmu_root_count\n\t * drops to zero, at which point the thread that decremented the\n\t * count to zero should removed the root from the list and clean\n\t * it up, freeing the root after an RCU grace period.\n\t */\n\tstruct list_head tdp_mmu_roots;\n\n\t/*\n\t * List of struct kvmp_mmu_pages not being used as roots.\n\t * All struct kvm_mmu_pages in the list should have\n\t * tdp_mmu_page set and a tdp_mmu_root_count of 0.\n\t */\n\tstruct list_head tdp_mmu_pages;\n\n\t/*\n\t * Protects accesses to the following fields when the MMU lock\n\t * is held in read mode:\n\t *  - tdp_mmu_roots (above)\n\t *  - tdp_mmu_pages (above)\n\t *  - the link field of struct kvm_mmu_pages used by the TDP MMU\n\t *  - lpage_disallowed_mmu_pages\n\t *  - the lpage_disallowed_link field of struct kvm_mmu_pages used\n\t *    by the TDP MMU\n\t * It is acceptable, but not necessary, to acquire this lock when\n\t * the thread holds the MMU lock in write mode.\n\t */\n\tspinlock_t tdp_mmu_pages_lock;\n\tstruct workqueue_struct *tdp_mmu_zap_wq;\n#endif /* CONFIG_X86_64 */\n\n\t/*\n\t * If set, at least one shadow root has been allocated. This flag\n\t * is used as one input when determining whether certain memslot\n\t * related allocations are necessary.\n\t */\n\tbool shadow_root_allocated;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\thpa_t\thv_root_tdp;\n\tspinlock_t hv_root_tdp_lock;\n#endif\n};\n\nstruct kvm_vm_stat {\n\tstruct kvm_vm_stat_generic generic;\n\tu64 mmu_shadow_zapped;\n\tu64 mmu_pte_write;\n\tu64 mmu_pde_zapped;\n\tu64 mmu_flooded;\n\tu64 mmu_recycled;\n\tu64 mmu_cache_miss;\n\tu64 mmu_unsync;\n\tunion {\n\t\tstruct {\n\t\t\tatomic64_t pages_4k;\n\t\t\tatomic64_t pages_2m;\n\t\t\tatomic64_t pages_1g;\n\t\t};\n\t\tatomic64_t pages[KVM_NR_PAGE_SIZES];\n\t};\n\tu64 nx_lpage_splits;\n\tu64 max_mmu_page_hash_collisions;\n\tu64 max_mmu_rmap_size;\n};\n\nstruct kvm_vcpu_stat {\n\tstruct kvm_vcpu_stat_generic generic;\n\tu64 pf_taken;\n\tu64 pf_fixed;\n\tu64 pf_emulate;\n\tu64 pf_spurious;\n\tu64 pf_fast;\n\tu64 pf_mmio_spte_created;\n\tu64 pf_guest;\n\tu64 tlb_flush;\n\tu64 invlpg;\n\n\tu64 exits;\n\tu64 io_exits;\n\tu64 mmio_exits;\n\tu64 signal_exits;\n\tu64 irq_window_exits;\n\tu64 nmi_window_exits;\n\tu64 l1d_flush;\n\tu64 halt_exits;\n\tu64 request_irq_exits;\n\tu64 irq_exits;\n\tu64 host_state_reload;\n\tu64 fpu_reload;\n\tu64 insn_emulation;\n\tu64 insn_emulation_fail;\n\tu64 hypercalls;\n\tu64 irq_injections;\n\tu64 nmi_injections;\n\tu64 req_event;\n\tu64 nested_run;\n\tu64 directed_yield_attempted;\n\tu64 directed_yield_successful;\n\tu64 guest_mode;\n};\n\nstruct x86_instruction_info;\n\nstruct msr_data {\n\tbool host_initiated;\n\tu32 index;\n\tu64 data;\n};\n\nstruct kvm_lapic_irq {\n\tu32 vector;\n\tu16 delivery_mode;\n\tu16 dest_mode;\n\tbool level;\n\tu16 trig_mode;\n\tu32 shorthand;\n\tu32 dest_id;\n\tbool msi_redir_hint;\n};\n\nstatic inline u16 kvm_lapic_irq_dest_mode(bool dest_mode_logical)\n{\n\treturn dest_mode_logical ? APIC_DEST_LOGICAL : APIC_DEST_PHYSICAL;\n}\n\nstruct kvm_x86_ops {\n\tconst char *name;\n\n\tint (*hardware_enable)(void);\n\tvoid (*hardware_disable)(void);\n\tvoid (*hardware_unsetup)(void);\n\tbool (*has_emulated_msr)(struct kvm *kvm, u32 index);\n\tvoid (*vcpu_after_set_cpuid)(struct kvm_vcpu *vcpu);\n\n\tunsigned int vm_size;\n\tint (*vm_init)(struct kvm *kvm);\n\tvoid (*vm_destroy)(struct kvm *kvm);\n\n\t/* Create, but do not attach this VCPU */\n\tint (*vcpu_create)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_free)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_reset)(struct kvm_vcpu *vcpu, bool init_event);\n\n\tvoid (*prepare_switch_to_guest)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_load)(struct kvm_vcpu *vcpu, int cpu);\n\tvoid (*vcpu_put)(struct kvm_vcpu *vcpu);\n\n\tvoid (*update_exception_bitmap)(struct kvm_vcpu *vcpu);\n\tint (*get_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\tint (*set_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\tu64 (*get_segment_base)(struct kvm_vcpu *vcpu, int seg);\n\tvoid (*get_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tint (*get_cpl)(struct kvm_vcpu *vcpu);\n\tvoid (*set_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tvoid (*get_cs_db_l_bits)(struct kvm_vcpu *vcpu, int *db, int *l);\n\tvoid (*set_cr0)(struct kvm_vcpu *vcpu, unsigned long cr0);\n\tvoid (*post_set_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);\n\tbool (*is_valid_cr4)(struct kvm_vcpu *vcpu, unsigned long cr0);\n\tvoid (*set_cr4)(struct kvm_vcpu *vcpu, unsigned long cr4);\n\tint (*set_efer)(struct kvm_vcpu *vcpu, u64 efer);\n\tvoid (*get_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*get_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*sync_dirty_debug_regs)(struct kvm_vcpu *vcpu);\n\tvoid (*set_dr7)(struct kvm_vcpu *vcpu, unsigned long value);\n\tvoid (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);\n\tunsigned long (*get_rflags)(struct kvm_vcpu *vcpu);\n\tvoid (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);\n\tbool (*get_if_flag)(struct kvm_vcpu *vcpu);\n\n\tvoid (*flush_tlb_all)(struct kvm_vcpu *vcpu);\n\tvoid (*flush_tlb_current)(struct kvm_vcpu *vcpu);\n\tint  (*tlb_remote_flush)(struct kvm *kvm);\n\tint  (*tlb_remote_flush_with_range)(struct kvm *kvm,\n\t\t\tstruct kvm_tlb_range *range);\n\n\t/*\n\t * Flush any TLB entries associated with the given GVA.\n\t * Does not need to flush GPA->HPA mappings.\n\t * Can potentially get non-canonical addresses through INVLPGs, which\n\t * the implementation may choose to ignore if appropriate.\n\t */\n\tvoid (*flush_tlb_gva)(struct kvm_vcpu *vcpu, gva_t addr);\n\n\t/*\n\t * Flush any TLB entries created by the guest.  Like tlb_flush_gva(),\n\t * does not need to flush GPA->HPA mappings.\n\t */\n\tvoid (*flush_tlb_guest)(struct kvm_vcpu *vcpu);\n\n\tint (*vcpu_pre_run)(struct kvm_vcpu *vcpu);\n\tenum exit_fastpath_completion (*vcpu_run)(struct kvm_vcpu *vcpu);\n\tint (*handle_exit)(struct kvm_vcpu *vcpu,\n\t\tenum exit_fastpath_completion exit_fastpath);\n\tint (*skip_emulated_instruction)(struct kvm_vcpu *vcpu);\n\tvoid (*update_emulated_instruction)(struct kvm_vcpu *vcpu);\n\tvoid (*set_interrupt_shadow)(struct kvm_vcpu *vcpu, int mask);\n\tu32 (*get_interrupt_shadow)(struct kvm_vcpu *vcpu);\n\tvoid (*patch_hypercall)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned char *hypercall_addr);\n\tvoid (*inject_irq)(struct kvm_vcpu *vcpu);\n\tvoid (*inject_nmi)(struct kvm_vcpu *vcpu);\n\tvoid (*queue_exception)(struct kvm_vcpu *vcpu);\n\tvoid (*cancel_injection)(struct kvm_vcpu *vcpu);\n\tint (*interrupt_allowed)(struct kvm_vcpu *vcpu, bool for_injection);\n\tint (*nmi_allowed)(struct kvm_vcpu *vcpu, bool for_injection);\n\tbool (*get_nmi_mask)(struct kvm_vcpu *vcpu);\n\tvoid (*set_nmi_mask)(struct kvm_vcpu *vcpu, bool masked);\n\tvoid (*enable_nmi_window)(struct kvm_vcpu *vcpu);\n\tvoid (*enable_irq_window)(struct kvm_vcpu *vcpu);\n\tvoid (*update_cr8_intercept)(struct kvm_vcpu *vcpu, int tpr, int irr);\n\tbool (*check_apicv_inhibit_reasons)(enum kvm_apicv_inhibit reason);\n\tvoid (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *vcpu);\n\tvoid (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);\n\tvoid (*hwapic_isr_update)(struct kvm_vcpu *vcpu, int isr);\n\tbool (*guest_apic_has_interrupt)(struct kvm_vcpu *vcpu);\n\tvoid (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);\n\tvoid (*set_virtual_apic_mode)(struct kvm_vcpu *vcpu);\n\tvoid (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu);\n\tvoid (*deliver_interrupt)(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t\t  int trig_mode, int vector);\n\tint (*sync_pir_to_irr)(struct kvm_vcpu *vcpu);\n\tint (*set_tss_addr)(struct kvm *kvm, unsigned int addr);\n\tint (*set_identity_map_addr)(struct kvm *kvm, u64 ident_addr);\n\tu64 (*get_mt_mask)(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio);\n\n\tvoid (*load_mmu_pgd)(struct kvm_vcpu *vcpu, hpa_t root_hpa,\n\t\t\t     int root_level);\n\n\tbool (*has_wbinvd_exit)(void);\n\n\tu64 (*get_l2_tsc_offset)(struct kvm_vcpu *vcpu);\n\tu64 (*get_l2_tsc_multiplier)(struct kvm_vcpu *vcpu);\n\tvoid (*write_tsc_offset)(struct kvm_vcpu *vcpu, u64 offset);\n\tvoid (*write_tsc_multiplier)(struct kvm_vcpu *vcpu, u64 multiplier);\n\n\t/*\n\t * Retrieve somewhat arbitrary exit information.  Intended to\n\t * be used only from within tracepoints or error paths.\n\t */\n\tvoid (*get_exit_info)(struct kvm_vcpu *vcpu, u32 *reason,\n\t\t\t      u64 *info1, u64 *info2,\n\t\t\t      u32 *exit_int_info, u32 *exit_int_info_err_code);\n\n\tint (*check_intercept)(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception);\n\tvoid (*handle_exit_irqoff)(struct kvm_vcpu *vcpu);\n\n\tvoid (*request_immediate_exit)(struct kvm_vcpu *vcpu);\n\n\tvoid (*sched_in)(struct kvm_vcpu *kvm, int cpu);\n\n\t/*\n\t * Size of the CPU's dirty log buffer, i.e. VMX's PML buffer.  A zero\n\t * value indicates CPU dirty logging is unsupported or disabled.\n\t */\n\tint cpu_dirty_log_size;\n\tvoid (*update_cpu_dirty_logging)(struct kvm_vcpu *vcpu);\n\n\tconst struct kvm_x86_nested_ops *nested_ops;\n\n\tvoid (*vcpu_blocking)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_unblocking)(struct kvm_vcpu *vcpu);\n\n\tint (*pi_update_irte)(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set);\n\tvoid (*pi_start_assignment)(struct kvm *kvm);\n\tvoid (*apicv_post_state_restore)(struct kvm_vcpu *vcpu);\n\tbool (*dy_apicv_has_pending_interrupt)(struct kvm_vcpu *vcpu);\n\n\tint (*set_hv_timer)(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,\n\t\t\t    bool *expired);\n\tvoid (*cancel_hv_timer)(struct kvm_vcpu *vcpu);\n\n\tvoid (*setup_mce)(struct kvm_vcpu *vcpu);\n\n\tint (*smi_allowed)(struct kvm_vcpu *vcpu, bool for_injection);\n\tint (*enter_smm)(struct kvm_vcpu *vcpu, char *smstate);\n\tint (*leave_smm)(struct kvm_vcpu *vcpu, const char *smstate);\n\tvoid (*enable_smi_window)(struct kvm_vcpu *vcpu);\n\n\tint (*mem_enc_ioctl)(struct kvm *kvm, void __user *argp);\n\tint (*mem_enc_register_region)(struct kvm *kvm, struct kvm_enc_region *argp);\n\tint (*mem_enc_unregister_region)(struct kvm *kvm, struct kvm_enc_region *argp);\n\tint (*vm_copy_enc_context_from)(struct kvm *kvm, unsigned int source_fd);\n\tint (*vm_move_enc_context_from)(struct kvm *kvm, unsigned int source_fd);\n\tvoid (*guest_memory_reclaimed)(struct kvm *kvm);\n\n\tint (*get_msr_feature)(struct kvm_msr_entry *entry);\n\n\tbool (*can_emulate_instruction)(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\t\tvoid *insn, int insn_len);\n\n\tbool (*apic_init_signal_blocked)(struct kvm_vcpu *vcpu);\n\tint (*enable_direct_tlbflush)(struct kvm_vcpu *vcpu);\n\n\tvoid (*migrate_timers)(struct kvm_vcpu *vcpu);\n\tvoid (*msr_filter_changed)(struct kvm_vcpu *vcpu);\n\tint (*complete_emulated_msr)(struct kvm_vcpu *vcpu, int err);\n\n\tvoid (*vcpu_deliver_sipi_vector)(struct kvm_vcpu *vcpu, u8 vector);\n\n\t/*\n\t * Returns vCPU specific APICv inhibit reasons\n\t */\n\tunsigned long (*vcpu_get_apicv_inhibit_reasons)(struct kvm_vcpu *vcpu);\n};\n\nstruct kvm_x86_nested_ops {\n\tvoid (*leave_nested)(struct kvm_vcpu *vcpu);\n\tint (*check_events)(struct kvm_vcpu *vcpu);\n\tbool (*handle_page_fault_workaround)(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct x86_exception *fault);\n\tbool (*hv_timer_pending)(struct kvm_vcpu *vcpu);\n\tvoid (*triple_fault)(struct kvm_vcpu *vcpu);\n\tint (*get_state)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_nested_state __user *user_kvm_nested_state,\n\t\t\t unsigned user_data_size);\n\tint (*set_state)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_nested_state __user *user_kvm_nested_state,\n\t\t\t struct kvm_nested_state *kvm_state);\n\tbool (*get_nested_state_pages)(struct kvm_vcpu *vcpu);\n\tint (*write_log_dirty)(struct kvm_vcpu *vcpu, gpa_t l2_gpa);\n\n\tint (*enable_evmcs)(struct kvm_vcpu *vcpu,\n\t\t\t    uint16_t *vmcs_version);\n\tuint16_t (*get_evmcs_version)(struct kvm_vcpu *vcpu);\n};\n\nstruct kvm_x86_init_ops {\n\tint (*cpu_has_kvm_support)(void);\n\tint (*disabled_by_bios)(void);\n\tint (*check_processor_compatibility)(void);\n\tint (*hardware_setup)(void);\n\tunsigned int (*handle_intel_pt_intr)(void);\n\n\tstruct kvm_x86_ops *runtime_ops;\n\tstruct kvm_pmu_ops *pmu_ops;\n};\n\nstruct kvm_arch_async_pf {\n\tu32 token;\n\tgfn_t gfn;\n\tunsigned long cr3;\n\tbool direct_map;\n};\n\nextern u32 __read_mostly kvm_nr_uret_msrs;\nextern u64 __read_mostly host_efer;\nextern bool __read_mostly allow_smaller_maxphyaddr;\nextern bool __read_mostly enable_apicv;\nextern struct kvm_x86_ops kvm_x86_ops;\n\n#define KVM_X86_OP(func) \\\n\tDECLARE_STATIC_CALL(kvm_x86_##func, *(((struct kvm_x86_ops *)0)->func));\n#define KVM_X86_OP_OPTIONAL KVM_X86_OP\n#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP\n#include <asm/kvm-x86-ops.h>\n\n#define __KVM_HAVE_ARCH_VM_ALLOC\nstatic inline struct kvm *kvm_arch_alloc_vm(void)\n{\n\treturn __vmalloc(kvm_x86_ops.vm_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n}\n\n#define __KVM_HAVE_ARCH_VM_FREE\nvoid kvm_arch_free_vm(struct kvm *kvm);\n\n#define __KVM_HAVE_ARCH_FLUSH_REMOTE_TLB\nstatic inline int kvm_arch_flush_remote_tlb(struct kvm *kvm)\n{\n\tif (kvm_x86_ops.tlb_remote_flush &&\n\t    !static_call(kvm_x86_tlb_remote_flush)(kvm))\n\t\treturn 0;\n\telse\n\t\treturn -ENOTSUPP;\n}\n\n#define kvm_arch_pmi_in_guest(vcpu) \\\n\t((vcpu) && (vcpu)->arch.handling_intr_from_guest)\n\nvoid kvm_mmu_x86_module_init(void);\nint kvm_mmu_vendor_module_init(void);\nvoid kvm_mmu_vendor_module_exit(void);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu);\nint kvm_mmu_create(struct kvm_vcpu *vcpu);\nint kvm_mmu_init_vm(struct kvm *kvm);\nvoid kvm_mmu_uninit_vm(struct kvm *kvm);\n\nvoid kvm_mmu_after_set_cpuid(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      const struct kvm_memory_slot *memslot,\n\t\t\t\t      int start_level);\nvoid kvm_mmu_slot_try_split_huge_pages(struct kvm *kvm,\n\t\t\t\t       const struct kvm_memory_slot *memslot,\n\t\t\t\t       int target_level);\nvoid kvm_mmu_try_split_huge_pages(struct kvm *kvm,\n\t\t\t\t  const struct kvm_memory_slot *memslot,\n\t\t\t\t  u64 start, u64 end,\n\t\t\t\t  int target_level);\nvoid kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot);\nvoid kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot);\nvoid kvm_mmu_zap_all(struct kvm *kvm);\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, u64 gen);\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned long kvm_nr_mmu_pages);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3);\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes);\n\nstruct kvm_irq_mask_notifier {\n\tvoid (*func)(struct kvm_irq_mask_notifier *kimn, bool masked);\n\tint irq;\n\tstruct hlist_node link;\n};\n\nvoid kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn);\nvoid kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn);\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask);\n\nextern bool tdp_enabled;\n\nu64 vcpu_tsc_khz(struct kvm_vcpu *vcpu);\n\n/* control of guest tsc rate supported? */\nextern bool kvm_has_tsc_control;\n/* maximum supported tsc_khz for guests */\nextern u32  kvm_max_guest_tsc_khz;\n/* number of bits of the fractional part of the TSC scaling ratio */\nextern u8   kvm_tsc_scaling_ratio_frac_bits;\n/* maximum allowed value of TSC scaling ratio */\nextern u64  kvm_max_tsc_scaling_ratio;\n/* 1ull << kvm_tsc_scaling_ratio_frac_bits */\nextern u64  kvm_default_tsc_scaling_ratio;\n/* bus lock detection supported? */\nextern bool kvm_has_bus_lock_exit;\n\nextern u64 kvm_mce_cap_supported;\n\n/*\n * EMULTYPE_NO_DECODE - Set when re-emulating an instruction (after completing\n *\t\t\tuserspace I/O) to indicate that the emulation context\n *\t\t\tshould be reused as is, i.e. skip initialization of\n *\t\t\temulation context, instruction fetch and decode.\n *\n * EMULTYPE_TRAP_UD - Set when emulating an intercepted #UD from hardware.\n *\t\t      Indicates that only select instructions (tagged with\n *\t\t      EmulateOnUD) should be emulated (to minimize the emulator\n *\t\t      attack surface).  See also EMULTYPE_TRAP_UD_FORCED.\n *\n * EMULTYPE_SKIP - Set when emulating solely to skip an instruction, i.e. to\n *\t\t   decode the instruction length.  For use *only* by\n *\t\t   kvm_x86_ops.skip_emulated_instruction() implementations if\n *\t\t   EMULTYPE_COMPLETE_USER_EXIT is not set.\n *\n * EMULTYPE_ALLOW_RETRY_PF - Set when the emulator should resume the guest to\n *\t\t\t     retry native execution under certain conditions,\n *\t\t\t     Can only be set in conjunction with EMULTYPE_PF.\n *\n * EMULTYPE_TRAP_UD_FORCED - Set when emulating an intercepted #UD that was\n *\t\t\t     triggered by KVM's magic \"force emulation\" prefix,\n *\t\t\t     which is opt in via module param (off by default).\n *\t\t\t     Bypasses EmulateOnUD restriction despite emulating\n *\t\t\t     due to an intercepted #UD (see EMULTYPE_TRAP_UD).\n *\t\t\t     Used to test the full emulator from userspace.\n *\n * EMULTYPE_VMWARE_GP - Set when emulating an intercepted #GP for VMware\n *\t\t\tbackdoor emulation, which is opt in via module param.\n *\t\t\tVMware backdoor emulation handles select instructions\n *\t\t\tand reinjects the #GP for all other cases.\n *\n * EMULTYPE_PF - Set when emulating MMIO by way of an intercepted #PF, in which\n *\t\t case the CR2/GPA value pass on the stack is valid.\n *\n * EMULTYPE_COMPLETE_USER_EXIT - Set when the emulator should update interruptibility\n *\t\t\t\t state and inject single-step #DBs after skipping\n *\t\t\t\t an instruction (after completing userspace I/O).\n */\n#define EMULTYPE_NO_DECODE\t    (1 << 0)\n#define EMULTYPE_TRAP_UD\t    (1 << 1)\n#define EMULTYPE_SKIP\t\t    (1 << 2)\n#define EMULTYPE_ALLOW_RETRY_PF\t    (1 << 3)\n#define EMULTYPE_TRAP_UD_FORCED\t    (1 << 4)\n#define EMULTYPE_VMWARE_GP\t    (1 << 5)\n#define EMULTYPE_PF\t\t    (1 << 6)\n#define EMULTYPE_COMPLETE_USER_EXIT (1 << 7)\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type);\nint kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,\n\t\t\t\t\tvoid *insn, int insn_len);\nvoid __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  u64 *data, u8 ndata);\nvoid kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu);\n\nvoid kvm_enable_efer_bits(u64);\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer);\nint __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data, bool host_initiated);\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data);\nint kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data);\nint kvm_emulate_rdmsr(struct kvm_vcpu *vcpu);\nint kvm_emulate_wrmsr(struct kvm_vcpu *vcpu);\nint kvm_emulate_as_nop(struct kvm_vcpu *vcpu);\nint kvm_emulate_invd(struct kvm_vcpu *vcpu);\nint kvm_emulate_mwait(struct kvm_vcpu *vcpu);\nint kvm_handle_invalid_op(struct kvm_vcpu *vcpu);\nint kvm_emulate_monitor(struct kvm_vcpu *vcpu);\n\nint kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in);\nint kvm_emulate_cpuid(struct kvm_vcpu *vcpu);\nint kvm_emulate_halt(struct kvm_vcpu *vcpu);\nint kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu);\nint kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu);\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu);\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg);\nint kvm_load_segment_descriptor(struct kvm_vcpu *vcpu, u16 selector, int seg);\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code);\n\nvoid kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0);\nvoid kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4);\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3);\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8);\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val);\nvoid kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val);\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu);\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw);\nint kvm_emulate_xsetbv(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu);\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nint kvm_emulate_rdpmc(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr, unsigned long payload);\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault);\nbool kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct x86_exception *fault);\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl);\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr);\n\nstatic inline int __kvm_irq_line_state(unsigned long *irq_state,\n\t\t\t\t       int irq_source_id, int level)\n{\n\t/* Logical OR for level trig interrupt */\n\tif (level)\n\t\t__set_bit(irq_source_id, irq_state);\n\telse\n\t\t__clear_bit(irq_source_id, irq_state);\n\n\treturn !!(*irq_state);\n}\n\n#define KVM_MMU_ROOT_CURRENT\t\tBIT(0)\n#define KVM_MMU_ROOT_PREVIOUS(i)\tBIT(1+i)\n#define KVM_MMU_ROOTS_ALL\t\t(~0UL)\n\nint kvm_pic_set_irq(struct kvm_pic *pic, int irq, int irq_source_id, int level);\nvoid kvm_pic_clear_all(struct kvm_pic *pic, int irq_source_id);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_update_dr7(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn);\nvoid kvm_mmu_free_roots(struct kvm *kvm, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free);\nvoid kvm_mmu_free_guest_mode_roots(struct kvm *kvm, struct kvm_mmu *mmu);\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception);\n\nbool kvm_apicv_activated(struct kvm *kvm);\nbool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu);\nvoid kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu);\nvoid __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t      enum kvm_apicv_inhibit reason, bool set);\nvoid kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t    enum kvm_apicv_inhibit reason, bool set);\n\nstatic inline void kvm_set_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t\t enum kvm_apicv_inhibit reason)\n{\n\tkvm_set_or_clear_apicv_inhibit(kvm, reason, true);\n}\n\nstatic inline void kvm_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t\t   enum kvm_apicv_inhibit reason)\n{\n\tkvm_set_or_clear_apicv_inhibit(kvm, reason, false);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len);\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva);\nvoid kvm_mmu_invalidate_gva(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gva_t gva, hpa_t root_hpa);\nvoid kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid);\nvoid kvm_mmu_new_pgd(struct kvm_vcpu *vcpu, gpa_t new_pgd);\n\nvoid kvm_configure_mmu(bool enable_tdp, int tdp_forced_root_level,\n\t\t       int tdp_max_root_level, int tdp_huge_page_level);\n\nstatic inline u16 kvm_read_ldt(void)\n{\n\tu16 ldt;\n\tasm(\"sldt %0\" : \"=g\"(ldt));\n\treturn ldt;\n}\n\nstatic inline void kvm_load_ldt(u16 sel)\n{\n\tasm(\"lldt %0\" : : \"rm\"(sel));\n}\n\n#ifdef CONFIG_X86_64\nstatic inline unsigned long read_msr(unsigned long msr)\n{\n\tu64 value;\n\n\trdmsrl(msr, value);\n\treturn value;\n}\n#endif\n\nstatic inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n{\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n}\n\n#define TSS_IOPB_BASE_OFFSET 0x66\n#define TSS_BASE_SIZE 0x68\n#define TSS_IOPB_SIZE (65536 / 8)\n#define TSS_REDIRECTION_SIZE (256 / 8)\n#define RMODE_TSS_SIZE\t\t\t\t\t\t\t\\\n\t(TSS_BASE_SIZE + TSS_REDIRECTION_SIZE + TSS_IOPB_SIZE + 1)\n\nenum {\n\tTASK_SWITCH_CALL = 0,\n\tTASK_SWITCH_IRET = 1,\n\tTASK_SWITCH_JMP = 2,\n\tTASK_SWITCH_GATE = 3,\n};\n\n#define HF_GIF_MASK\t\t(1 << 0)\n#define HF_NMI_MASK\t\t(1 << 3)\n#define HF_IRET_MASK\t\t(1 << 4)\n#define HF_GUEST_MASK\t\t(1 << 5) /* VCPU is in guest-mode */\n#define HF_SMM_MASK\t\t(1 << 6)\n#define HF_SMM_INSIDE_NMI_MASK\t(1 << 7)\n\n#define __KVM_VCPU_MULTIPLE_ADDRESS_SPACE\n#define KVM_ADDRESS_SPACE_NUM 2\n\n#define kvm_arch_vcpu_memslots_id(vcpu) ((vcpu)->arch.hflags & HF_SMM_MASK ? 1 : 0)\n#define kvm_memslots_for_spte_role(kvm, role) __kvm_memslots(kvm, (role).smm)\n\n#define KVM_ARCH_WANT_MMU_NOTIFIER\n\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v);\nint kvm_cpu_has_interrupt(struct kvm_vcpu *vcpu);\nint kvm_cpu_has_extint(struct kvm_vcpu *v);\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu);\nint kvm_cpu_get_interrupt(struct kvm_vcpu *v);\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event);\n\nint kvm_pv_send_ipi(struct kvm *kvm, unsigned long ipi_bitmap_low,\n\t\t    unsigned long ipi_bitmap_high, u32 min,\n\t\t    unsigned long icr, int op_64_bit);\n\nint kvm_add_user_return_msr(u32 msr);\nint kvm_find_user_return_msr(u32 msr);\nint kvm_set_user_return_msr(unsigned index, u64 val, u64 mask);\n\nstatic inline bool kvm_is_supported_user_return_msr(u32 msr)\n{\n\treturn kvm_find_user_return_msr(msr) >= 0;\n}\n\nu64 kvm_scale_tsc(u64 tsc, u64 ratio);\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc);\nu64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier);\nu64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier);\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu);\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip);\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm);\nvoid kvm_make_scan_ioapic_request_mask(struct kvm *kvm,\n\t\t\t\t       unsigned long *vcpu_bitmap);\n\nbool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work);\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work);\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_async_pf *work);\nvoid kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu);\nbool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu);\nextern bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu);\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err);\nvoid __kvm_request_immediate_exit(struct kvm_vcpu *vcpu);\n\nvoid __user *__x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,\n\t\t\t\t     u32 size);\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu);\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu);\n\nbool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t     struct kvm_vcpu **dest_vcpu);\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq);\n\nstatic inline bool kvm_irq_is_postable(struct kvm_lapic_irq *irq)\n{\n\t/* We can only post Fixed and LowPrio IRQs */\n\treturn (irq->delivery_mode == APIC_DM_FIXED ||\n\t\tirq->delivery_mode == APIC_DM_LOWEST);\n}\n\nstatic inline void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu)\n{\n\tstatic_call_cond(kvm_x86_vcpu_blocking)(vcpu);\n}\n\nstatic inline void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu)\n{\n\tstatic_call_cond(kvm_x86_vcpu_unblocking)(vcpu);\n}\n\nstatic inline int kvm_cpu_get_apicid(int mps_cpu)\n{\n#ifdef CONFIG_X86_LOCAL_APIC\n\treturn default_cpu_present_to_apicid(mps_cpu);\n#else\n\tWARN_ON_ONCE(1);\n\treturn BAD_APICID;\n#endif\n}\n\n#define put_smstate(type, buf, offset, val)                      \\\n\t*(type *)((buf) + (offset) - 0x7e00) = val\n\n#define GET_SMSTATE(type, buf, offset)\t\t\\\n\t(*(type *)((buf) + (offset) - 0x7e00))\n\nint kvm_cpu_dirty_log_size(void);\n\nint memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages);\n\n#define KVM_CLOCK_VALID_FLAGS\t\t\t\t\t\t\\\n\t(KVM_CLOCK_TSC_STABLE | KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC)\n\n#define KVM_X86_VALID_QUIRKS\t\t\t\\\n\t(KVM_X86_QUIRK_LINT0_REENABLED |\t\\\n\t KVM_X86_QUIRK_CD_NW_CLEARED |\t\t\\\n\t KVM_X86_QUIRK_LAPIC_MMIO_HOLE |\t\\\n\t KVM_X86_QUIRK_OUT_7E_INC_RIP |\t\t\\\n\t KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT |\t\\\n\t KVM_X86_QUIRK_FIX_HYPERCALL_INSN)\n\n#endif /* _ASM_X86_KVM_HOST_H */\n", "#define pr_fmt(fmt) \"SVM: \" fmt\n\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n#include \"pmu.h\"\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/amd-iommu.h>\n#include <linux/sched.h>\n#include <linux/trace_events.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n#include <linux/objtool.h>\n#include <linux/psp-sev.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/rwsem.h>\n#include <linux/cc_platform.h>\n\n#include <asm/apic.h>\n#include <asm/perf_event.h>\n#include <asm/tlbflush.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/kvm_para.h>\n#include <asm/irq_remapping.h>\n#include <asm/spec-ctrl.h>\n#include <asm/cpu_device_id.h>\n#include <asm/traps.h>\n#include <asm/fpu/api.h>\n\n#include <asm/virtext.h>\n#include \"trace.h\"\n\n#include \"svm.h\"\n#include \"svm_ops.h\"\n\n#include \"kvm_onhyperv.h\"\n#include \"svm_onhyperv.h\"\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef MODULE\nstatic const struct x86_cpu_id svm_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_SVM, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, svm_cpu_id);\n#endif\n\n#define SEG_TYPE_LDT 2\n#define SEG_TYPE_BUSY_TSS16 3\n\nstatic bool erratum_383_found __read_mostly;\n\nu32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;\n\n/*\n * Set osvw_len to higher value when updated Revision Guides\n * are published and we know what the new status bits are\n */\nstatic uint64_t osvw_len = 4, osvw_status;\n\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is initially cleared */\n} direct_access_msrs[MAX_DIRECT_ACCESS_MSRS] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_EIP,\t\t.always = false },\n\t{ .index = MSR_IA32_SYSENTER_ESP,\t\t.always = false },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_EFER,\t\t\t\t.always = false },\n\t{ .index = MSR_IA32_CR_PAT,\t\t\t.always = false },\n\t{ .index = MSR_AMD64_SEV_ES_GHCB,\t\t.always = true  },\n\t{ .index = MSR_TSC_AUX,\t\t\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * pause_filter_count: On processors that support Pause filtering(indicated\n *\tby CPUID Fn8000_000A_EDX), the VMCB provides a 16 bit pause filter\n *\tcount value. On VMRUN this value is loaded into an internal counter.\n *\tEach time a pause instruction is executed, this counter is decremented\n *\tuntil it reaches zero at which time a #VMEXIT is generated if pause\n *\tintercept is enabled. Refer to  AMD APM Vol 2 Section 15.14.4 Pause\n *\tIntercept Filtering for more details.\n *\tThis also indicate if ple logic enabled.\n *\n * pause_filter_thresh: In addition, some processor families support advanced\n *\tpause filtering (indicated by CPUID Fn8000_000A_EDX) upper bound on\n *\tthe amount of time a guest is allowed to execute in a pause loop.\n *\tIn this mode, a 16-bit pause filter threshold field is added in the\n *\tVMCB. The threshold value is a cycle count that is used to reset the\n *\tpause counter. As with simple pause filtering, VMRUN loads the pause\n *\tcount value from VMCB into an internal counter. Then, on each pause\n *\tinstruction the hardware checks the elapsed number of cycles since\n *\tthe most recent pause instruction against the pause filter threshold.\n *\tIf the elapsed cycle count is greater than the pause filter threshold,\n *\tthen the internal pause count is reloaded from the VMCB and execution\n *\tcontinues. If the elapsed cycle count is less than the pause filter\n *\tthreshold, then the internal pause count is decremented. If the count\n *\tvalue is less than zero and PAUSE intercept is enabled, a #VMEXIT is\n *\ttriggered. If advanced pause filtering is supported and pause filter\n *\tthreshold field is set to zero, the filter will operate in the simpler,\n *\tcount only mode.\n */\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nmodule_param(pause_filter_thresh, ushort, 0444);\n\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nmodule_param(pause_filter_count, ushort, 0444);\n\n/* Default doubles per-vcpu window every exit. */\nstatic unsigned short pause_filter_count_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(pause_filter_count_grow, ushort, 0444);\n\n/* Default resets per-vcpu window every exit to pause_filter_count. */\nstatic unsigned short pause_filter_count_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(pause_filter_count_shrink, ushort, 0444);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic unsigned short pause_filter_count_max = KVM_SVM_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(pause_filter_count_max, ushort, 0444);\n\n/*\n * Use nested page tables by default.  Note, NPT may get forced off by\n * svm_hardware_setup() if it's unsupported by hardware or the host kernel.\n */\nbool npt_enabled = true;\nmodule_param_named(npt, npt_enabled, bool, 0444);\n\n/* allow nested virtualization in KVM/SVM */\nstatic int nested = true;\nmodule_param(nested, int, S_IRUGO);\n\n/* enable/disable Next RIP Save */\nstatic int nrips = true;\nmodule_param(nrips, int, 0444);\n\n/* enable/disable Virtual VMLOAD VMSAVE */\nstatic int vls = true;\nmodule_param(vls, int, 0444);\n\n/* enable/disable Virtual GIF */\nint vgif = true;\nmodule_param(vgif, int, 0444);\n\n/* enable/disable LBR virtualization */\nstatic int lbrv = true;\nmodule_param(lbrv, int, 0444);\n\nstatic int tsc_scaling = true;\nmodule_param(tsc_scaling, int, 0444);\n\n/*\n * enable / disable AVIC.  Because the defaults differ for APICv\n * support between VMX and SVM we cannot use module_param_named.\n */\nstatic bool avic;\nmodule_param(avic, bool, 0444);\n\nstatic bool force_avic;\nmodule_param_unsafe(force_avic, bool, 0444);\n\nbool __read_mostly dump_invalid_vmcb;\nmodule_param(dump_invalid_vmcb, bool, 0644);\n\n\nbool intercept_smi = true;\nmodule_param(intercept_smi, bool, 0444);\n\n\nstatic bool svm_gp_erratum_intercept = true;\n\nstatic u8 rsm_ins_bytes[] = \"\\x0f\\xaa\";\n\nstatic unsigned long iopm_base;\n\nstruct kvm_ldttss_desc {\n\tu16 limit0;\n\tu16 base0;\n\tunsigned base1:8, type:5, dpl:2, p:1;\n\tunsigned limit1:4, zero0:3, g:1, base2:8;\n\tu32 base3;\n\tu32 zero1;\n} __attribute__((packed));\n\nDEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\n/*\n * Only MSR_TSC_AUX is switched via the user return hook.  EFER is switched via\n * the VMCB, and the SYSCALL/SYSENTER MSRs are handled by VMLOAD/VMSAVE.\n *\n * RDTSCP and RDPID are not used in the kernel, specifically to allow KVM to\n * defer the restoration of TSC_AUX until the CPU returns to userspace.\n */\nstatic int tsc_aux_uret_slot __read_mostly = -1;\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSRS_RANGE_SIZE 2048\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n\nu32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}\n\nstatic void svm_flush_tlb_current(struct kvm_vcpu *vcpu);\n\nstatic int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn pgtable_l5_enabled() ? PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}\n\nint svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 old_efer = vcpu->arch.efer;\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tif ((old_efer & EFER_SVME) != (efer & EFER_SVME)) {\n\t\tif (!(efer & EFER_SVME)) {\n\t\t\tsvm_leave_nested(vcpu);\n\t\t\tsvm_set_gif(svm, true);\n\t\t\t/* #GP intercept is still needed for vmware backdoor */\n\t\t\tif (!enable_vmware_backdoor)\n\t\t\t\tclr_exception_intercept(svm, GP_VECTOR);\n\n\t\t\t/*\n\t\t\t * Free the nested guest state, unless we are in SMM.\n\t\t\t * In this case we will return to the nested guest\n\t\t\t * as soon as we leave SMM.\n\t\t\t */\n\t\t\tif (!is_smm(vcpu))\n\t\t\t\tsvm_free_nested(svm);\n\n\t\t} else {\n\t\t\tint ret = svm_allocate_nested(svm);\n\n\t\t\tif (ret) {\n\t\t\t\tvcpu->arch.efer = old_efer;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Never intercept #GP for SEV guests, KVM can't\n\t\t\t * decrypt guest memory to workaround the erratum.\n\t\t\t */\n\t\t\tif (svm_gp_erratum_intercept && !sev_guest(vcpu->kvm))\n\t\t\t\tset_exception_intercept(svm, GP_VECTOR);\n\t\t}\n\t}\n\n\tsvm->vmcb->save.efer = efer | EFER_SVME;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n\treturn 0;\n}\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}\n\nstatic u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}\n\nstatic int svm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * SEV-ES does not expose the next RIP. The RIP update is controlled by\n\t * the type of exit and the #VC handler in the guest.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\tgoto done;\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\ndone:\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}\n\nstatic void svm_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\n\tkvm_deliver_exception_payload(vcpu);\n\n\tif (nr == BP_VECTOR && !nrips) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\t(void)svm_skip_emulated_instruction(vcpu);\n\t\trip = kvm_rip_read(vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tpr_info(\"KVM is unsupported when running as an SEV guest\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid __svm_write_tsc_multiplier(u64 multiplier)\n{\n\tpreempt_disable();\n\n\tif (multiplier == __this_cpu_read(current_tsc_ratio))\n\t\tgoto out;\n\n\twrmsrl(MSR_AMD64_TSC_RATIO, multiplier);\n\t__this_cpu_write(current_tsc_ratio, multiplier);\nout:\n\tpreempt_enable();\n}\n\nstatic void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (tsc_scaling)\n\t\t__svm_write_tsc_multiplier(SVM_TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}\n\nstatic int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\tsd->min_asid = max_sev_asid + 1;\n\n\tgdt = get_current_gdt_rw();\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, __sme_page_pa(sd->save_area));\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\t/*\n\t\t * Set the default value, even if we don't use TSC scaling\n\t\t * to avoid having stale value in the msr\n\t\t */\n\t\t__svm_write_tsc_multiplier(SVM_TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}\n\nstatic void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, cpu) = NULL;\n\tkfree(sd->sev_vmcbs);\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint ret = -ENOMEM;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn ret;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tret = sev_cpu_init(sd);\n\tif (ret)\n\t\tgoto free_save_area;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn ret;\n\n}\n\nstatic int direct_access_msr_slot(u32 msr)\n{\n\tu32 i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == msr)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic void set_shadow_msr_intercept(struct kvm_vcpu *vcpu, u32 msr, int read,\n\t\t\t\t     int write)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint slot = direct_access_msr_slot(msr);\n\n\tif (slot == -ENOENT)\n\t\treturn;\n\n\t/* Set the shadow bitmaps to the desired intercept states */\n\tif (read)\n\t\tset_bit(slot, svm->shadow_msr_intercept.read);\n\telse\n\t\tclear_bit(slot, svm->shadow_msr_intercept.read);\n\n\tif (write)\n\t\tset_bit(slot, svm->shadow_msr_intercept.write);\n\telse\n\t\tclear_bit(slot, svm->shadow_msr_intercept.write);\n}\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\treturn direct_access_msr_slot(index) != -ENOENT;\n}\n\nstatic bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tu8 bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\tu32 *msrpm;\n\n\tmsrpm = is_guest_mode(vcpu) ? to_svm(vcpu)->nested.msrpm:\n\t\t\t\t      to_svm(vcpu)->msrpm;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\treturn !!test_bit(bit_write,  &tmp);\n}\n\nstatic void set_msr_interception_bitmap(struct kvm_vcpu *vcpu, u32 *msrpm,\n\t\t\t\t\tu32 msr, int read, int write)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\t/* Enforce non allowed MSRs to trap */\n\tif (read && !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_READ))\n\t\tread = 0;\n\n\tif (write && !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_WRITE))\n\t\twrite = 0;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n\n\tsvm_hv_vmcb_dirty_nested_enlightenments(vcpu);\n\tsvm->nested.force_msr_bitmap_recalc = true;\n}\n\nvoid set_msr_interception(struct kvm_vcpu *vcpu, u32 *msrpm, u32 msr,\n\t\t\t  int read, int write)\n{\n\tset_shadow_msr_intercept(vcpu, msr, read, write);\n\tset_msr_interception_bitmap(vcpu, msrpm, msr, read, write);\n}\n\nu32 *svm_vcpu_alloc_msrpm(void)\n{\n\tunsigned int order = get_order(MSRPM_SIZE);\n\tstruct page *pages = alloc_pages(GFP_KERNEL_ACCOUNT, order);\n\tu32 *msrpm;\n\n\tif (!pages)\n\t\treturn NULL;\n\n\tmsrpm = page_address(pages);\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << order));\n\n\treturn msrpm;\n}\n\nvoid svm_vcpu_init_msrpm(struct kvm_vcpu *vcpu, u32 *msrpm)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\t\tset_msr_interception(vcpu, msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}\n\n\nvoid svm_vcpu_free_msrpm(u32 *msrpm)\n{\n\t__free_pages(virt_to_page(msrpm), get_order(MSRPM_SIZE));\n}\n\nstatic void svm_msr_filter_changed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 i;\n\n\t/*\n\t * Set intercept permissions for all direct access MSRs again. They\n\t * will automatically get filtered through the MSR filter, so we are\n\t * back in sync after this.\n\t */\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 msr = direct_access_msrs[i].index;\n\t\tu32 read = test_bit(i, svm->shadow_msr_intercept.read);\n\t\tu32 write = test_bit(i, svm->shadow_msr_intercept.write);\n\n\t\tset_msr_interception_bitmap(vcpu, svm->msrpm, msr, read, write);\n\t}\n}\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}\n\nvoid svm_copy_lbrs(struct vmcb *to_vmcb, struct vmcb *from_vmcb)\n{\n\tto_vmcb->save.dbgctl\t\t= from_vmcb->save.dbgctl;\n\tto_vmcb->save.br_from\t\t= from_vmcb->save.br_from;\n\tto_vmcb->save.br_to\t\t= from_vmcb->save.br_to;\n\tto_vmcb->save.last_excp_from\t= from_vmcb->save.last_excp_from;\n\tto_vmcb->save.last_excp_to\t= from_vmcb->save.last_excp_to;\n\n\tvmcb_mark_dirty(to_vmcb, VMCB_LBR);\n}\n\nstatic void svm_enable_lbrv(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n\n\t/* Move the LBR msrs to the vmcb02 so that the guest can see them. */\n\tif (is_guest_mode(vcpu))\n\t\tsvm_copy_lbrs(svm->vmcb, svm->vmcb01.ptr);\n}\n\nstatic void svm_disable_lbrv(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.virt_ext &= ~LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n\n\t/*\n\t * Move the LBR msrs back to the vmcb01 to avoid copying them\n\t * on nested guest entries.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\tsvm_copy_lbrs(svm->vmcb01.ptr, svm->vmcb);\n}\n\nstatic int svm_get_lbr_msr(struct vcpu_svm *svm, u32 index)\n{\n\t/*\n\t * If the LBR virtualization is disabled, the LBR msrs are always\n\t * kept in the vmcb01 to avoid copying them on nested guest entries.\n\t *\n\t * If nested, and the LBR virtualization is enabled/disabled, the msrs\n\t * are moved between the vmcb01 and vmcb02 as needed.\n\t */\n\tstruct vmcb *vmcb =\n\t\t(svm->vmcb->control.virt_ext & LBR_CTL_ENABLE_MASK) ?\n\t\t\tsvm->vmcb : svm->vmcb01.ptr;\n\n\tswitch (index) {\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\treturn vmcb->save.dbgctl;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\treturn vmcb->save.br_from;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\treturn vmcb->save.br_to;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\treturn vmcb->save.last_excp_from;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\treturn vmcb->save.last_excp_to;\n\tdefault:\n\t\tKVM_BUG(false, svm->vcpu.kvm,\n\t\t\t\"%s: Unknown MSR 0x%x\", __func__, index);\n\t\treturn 0;\n\t}\n}\n\nvoid svm_update_lbrv(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tbool enable_lbrv = svm_get_lbr_msr(svm, MSR_IA32_DEBUGCTLMSR) &\n\t\t\t\t\t   DEBUGCTLMSR_LBR;\n\n\tbool current_enable_lbrv = !!(svm->vmcb->control.virt_ext &\n\t\t\t\t      LBR_CTL_ENABLE_MASK);\n\n\tif (unlikely(is_guest_mode(vcpu) && svm->lbrv_enabled))\n\t\tif (unlikely(svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK))\n\t\t\tenable_lbrv = true;\n\n\tif (enable_lbrv == current_enable_lbrv)\n\t\treturn;\n\n\tif (enable_lbrv)\n\t\tsvm_enable_lbrv(vcpu);\n\telse\n\t\tsvm_disable_lbrv(vcpu);\n}\n\nvoid disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tif (kvm_pause_in_guest(vcpu->kvm) || !old)\n\t\treturn;\n\n\tcontrol->pause_filter_count = __grow_ple_window(old,\n\t\t\t\t\t\t\tpause_filter_count,\n\t\t\t\t\t\t\tpause_filter_count_grow,\n\t\t\t\t\t\t\tpause_filter_count_max);\n\n\tif (control->pause_filter_count != old) {\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tif (kvm_pause_in_guest(vcpu->kvm) || !old)\n\t\treturn;\n\n\tcontrol->pause_filter_count =\n\t\t\t\t__shrink_ple_window(old,\n\t\t\t\t\t\t    pause_filter_count,\n\t\t\t\t\t\t    pause_filter_count_shrink,\n\t\t\t\t\t\t    pause_filter_count);\n\tif (control->pause_filter_count != old) {\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}\n\nstatic void svm_hardware_unsetup(void)\n{\n\tint cpu;\n\n\tsev_hardware_unsetup();\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT),\n\tget_order(IOPM_SIZE));\n\tiopm_base = 0;\n}\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic u64 svm_get_l2_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.ctl.tsc_offset;\n}\n\nstatic u64 svm_get_l2_tsc_multiplier(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->tsc_ratio_msr;\n}\n\nstatic void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb01.ptr->control.tsc_offset = vcpu->arch.l1_tsc_offset;\n\tsvm->vmcb->control.tsc_offset = offset;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}\n\nstatic void svm_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 multiplier)\n{\n\t__svm_write_tsc_multiplier(multiplier);\n}\n\n\n/* Evaluate instruction intercepts that depend on guest CPUID features. */\nstatic void svm_recalc_instruction_intercepts(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct vcpu_svm *svm)\n{\n\t/*\n\t * Intercept INVPCID if shadow paging is enabled to sync/free shadow\n\t * roots, or if INVPCID is disabled in the guest to inject #UD.\n\t */\n\tif (kvm_cpu_cap_has(X86_FEATURE_INVPCID)) {\n\t\tif (!npt_enabled ||\n\t\t    !guest_cpuid_has(&svm->vcpu, X86_FEATURE_INVPCID))\n\t\t\tsvm_set_intercept(svm, INTERCEPT_INVPCID);\n\t\telse\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_INVPCID);\n\t}\n\n\tif (kvm_cpu_cap_has(X86_FEATURE_RDTSCP)) {\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_RDTSCP);\n\t\telse\n\t\t\tsvm_set_intercept(svm, INTERCEPT_RDTSCP);\n\t}\n}\n\nstatic inline void init_vmcb_after_set_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (guest_cpuid_is_intel(vcpu)) {\n\t\t/*\n\t\t * We must intercept SYSENTER_EIP and SYSENTER_ESP\n\t\t * accesses because the processor only stores 32 bits.\n\t\t * For the same reason we cannot use virtual VMLOAD/VMSAVE.\n\t\t */\n\t\tsvm_set_intercept(svm, INTERCEPT_VMLOAD);\n\t\tsvm_set_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext &= ~VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_EIP, 0, 0);\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_ESP, 0, 0);\n\n\t\tsvm->v_vmload_vmsave_enabled = false;\n\t} else {\n\t\t/*\n\t\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t\t */\n\t\tif (vls) {\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_VMLOAD);\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_VMSAVE);\n\t\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t\t}\n\t\t/* No need to intercept these MSRs */\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_EIP, 1, 1);\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_ESP, 1, 1);\n\t}\n}\n\nstatic void init_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb01.ptr;\n\tstruct vmcb_control_area *control = &vmcb->control;\n\tstruct vmcb_save_area *save = &vmcb->save;\n\n\tsvm_set_intercept(svm, INTERCEPT_CR0_READ);\n\tsvm_set_intercept(svm, INTERCEPT_CR3_READ);\n\tsvm_set_intercept(svm, INTERCEPT_CR4_READ);\n\tsvm_set_intercept(svm, INTERCEPT_CR0_WRITE);\n\tsvm_set_intercept(svm, INTERCEPT_CR3_WRITE);\n\tsvm_set_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\tsvm_set_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.  Don't intercept #GP for SEV guests as KVM can't\n\t * decrypt guest memory to decode the faulting instruction.\n\t */\n\tif (enable_vmware_backdoor && !sev_guest(vcpu->kvm))\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tsvm_set_intercept(svm, INTERCEPT_INTR);\n\tsvm_set_intercept(svm, INTERCEPT_NMI);\n\n\tif (intercept_smi)\n\t\tsvm_set_intercept(svm, INTERCEPT_SMI);\n\n\tsvm_set_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tsvm_set_intercept(svm, INTERCEPT_RDPMC);\n\tsvm_set_intercept(svm, INTERCEPT_CPUID);\n\tsvm_set_intercept(svm, INTERCEPT_INVD);\n\tsvm_set_intercept(svm, INTERCEPT_INVLPG);\n\tsvm_set_intercept(svm, INTERCEPT_INVLPGA);\n\tsvm_set_intercept(svm, INTERCEPT_IOIO_PROT);\n\tsvm_set_intercept(svm, INTERCEPT_MSR_PROT);\n\tsvm_set_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tsvm_set_intercept(svm, INTERCEPT_SHUTDOWN);\n\tsvm_set_intercept(svm, INTERCEPT_VMRUN);\n\tsvm_set_intercept(svm, INTERCEPT_VMMCALL);\n\tsvm_set_intercept(svm, INTERCEPT_VMLOAD);\n\tsvm_set_intercept(svm, INTERCEPT_VMSAVE);\n\tsvm_set_intercept(svm, INTERCEPT_STGI);\n\tsvm_set_intercept(svm, INTERCEPT_CLGI);\n\tsvm_set_intercept(svm, INTERCEPT_SKINIT);\n\tsvm_set_intercept(svm, INTERCEPT_WBINVD);\n\tsvm_set_intercept(svm, INTERCEPT_XSETBV);\n\tsvm_set_intercept(svm, INTERCEPT_RDPRU);\n\tsvm_set_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(vcpu->kvm)) {\n\t\tsvm_set_intercept(svm, INTERCEPT_MONITOR);\n\t\tsvm_set_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(vcpu->kvm))\n\t\tsvm_set_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.base = 0;\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.base = 0;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tsvm_clr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = vcpu->arch.pat;\n\t\tsave->cr3 = 0;\n\t}\n\tsvm->current_vmcb->asid_generation = 0;\n\tsvm->asid = 0;\n\n\tsvm->nested.vmcb12_gpa = INVALID_GPA;\n\tsvm->nested.last_vmcb12_gpa = INVALID_GPA;\n\n\tif (!kvm_pause_in_guest(vcpu->kvm)) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tsvm_set_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tsvm_clr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tsvm_recalc_instruction_intercepts(vcpu, svm);\n\n\t/*\n\t * If the host supports V_SPEC_CTRL then disable the interception\n\t * of MSR_IA32_SPEC_CTRL.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\tavic_init_vmcb(svm, vmcb);\n\n\tif (vgif) {\n\t\tsvm_clr_intercept(svm, INTERCEPT_STGI);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(vcpu->kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\n\t\tif (sev_es_guest(vcpu->kvm)) {\n\t\t\t/* Perform SEV-ES specific VMCB updates */\n\t\t\tsev_es_init_vmcb(svm);\n\t\t}\n\t}\n\n\tsvm_hv_init_vmcb(vmcb);\n\tinit_vmcb_after_set_cpuid(vcpu);\n\n\tvmcb_mark_all_dirty(vmcb);\n\n\tenable_gif(svm);\n}\n\nstatic void __svm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm_vcpu_init_msrpm(vcpu, svm->msrpm);\n\n\tsvm_init_osvw(vcpu);\n\tvcpu->arch.microcode_version = 0x01000065;\n\tsvm->tsc_ratio_msr = kvm_default_tsc_scaling_ratio;\n\n\tif (sev_es_guest(vcpu->kvm))\n\t\tsev_es_vcpu_reset(svm);\n}\n\nstatic void svm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->spec_ctrl = 0;\n\tsvm->virt_spec_ctrl = 0;\n\n\tinit_vmcb(vcpu);\n\n\tif (!init_event)\n\t\t__svm_vcpu_reset(vcpu);\n}\n\nvoid svm_switch_vmcb(struct vcpu_svm *svm, struct kvm_vmcb_info *target_vmcb)\n{\n\tsvm->current_vmcb = target_vmcb;\n\tsvm->vmcb = target_vmcb->ptr;\n}\n\nstatic int svm_vcpu_create(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *vmcb01_page;\n\tstruct page *vmsa_page = NULL;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_svm, vcpu) != 0);\n\tsvm = to_svm(vcpu);\n\n\terr = -ENOMEM;\n\tvmcb01_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!vmcb01_page)\n\t\tgoto out;\n\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\t/*\n\t\t * SEV-ES guests require a separate VMSA page used to contain\n\t\t * the encrypted register state of the guest.\n\t\t */\n\t\tvmsa_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\t\tif (!vmsa_page)\n\t\t\tgoto error_free_vmcb_page;\n\n\t\t/*\n\t\t * SEV-ES guests maintain an encrypted version of their FPU\n\t\t * state which is restored and saved on VMRUN and VMEXIT.\n\t\t * Mark vcpu->arch.guest_fpu->fpstate as scratch so it won't\n\t\t * do xsave/xrstor on it.\n\t\t */\n\t\tfpstate_set_confidential(&vcpu->arch.guest_fpu);\n\t}\n\n\terr = avic_init_vcpu(svm);\n\tif (err)\n\t\tgoto error_free_vmsa_page;\n\n\tsvm->msrpm = svm_vcpu_alloc_msrpm();\n\tif (!svm->msrpm) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free_vmsa_page;\n\t}\n\n\tsvm->vmcb01.ptr = page_address(vmcb01_page);\n\tsvm->vmcb01.pa = __sme_set(page_to_pfn(vmcb01_page) << PAGE_SHIFT);\n\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\tif (vmsa_page)\n\t\tsvm->sev_es.vmsa = page_address(vmsa_page);\n\n\tsvm->guest_state_loaded = false;\n\n\treturn 0;\n\nerror_free_vmsa_page:\n\tif (vmsa_page)\n\t\t__free_page(vmsa_page);\nerror_free_vmcb_page:\n\t__free_page(vmcb01_page);\nout:\n\treturn err;\n}\n\nstatic void svm_clear_current_vmcb(struct vmcb *vmcb)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcmpxchg(&per_cpu(svm_data, i)->current_vmcb, vmcb, NULL);\n}\n\nstatic void svm_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * The vmcb page can be recycled, causing a false negative in\n\t * svm_vcpu_load(). So, ensure that no logical CPU has this\n\t * vmcb page recorded as its current vmcb.\n\t */\n\tsvm_clear_current_vmcb(svm->vmcb);\n\n\tsvm_free_nested(svm);\n\n\tsev_free_vcpu(vcpu);\n\n\t__free_page(pfn_to_page(__sme_clr(svm->vmcb01.pa) >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), get_order(MSRPM_SIZE));\n}\n\nstatic void svm_prepare_switch_to_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\n\tif (sev_es_guest(vcpu->kvm))\n\t\tsev_es_unmap_ghcb(svm);\n\n\tif (svm->guest_state_loaded)\n\t\treturn;\n\n\t/*\n\t * Save additional host state that will be restored on VMEXIT (sev-es)\n\t * or subsequent vmload of host save area.\n\t */\n\tvmsave(__sme_page_pa(sd->save_area));\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\tstruct vmcb_save_area *hostsa;\n\t\thostsa = (struct vmcb_save_area *)(page_address(sd->save_area) + 0x400);\n\n\t\tsev_es_prepare_switch_to_guest(hostsa);\n\t}\n\n\tif (tsc_scaling)\n\t\t__svm_write_tsc_multiplier(vcpu->arch.tsc_scaling_ratio);\n\n\tif (likely(tsc_aux_uret_slot >= 0))\n\t\tkvm_set_user_return_msr(tsc_aux_uret_slot, svm->tsc_aux, -1ull);\n\n\tsvm->guest_state_loaded = true;\n}\n\nstatic void svm_prepare_host_switch(struct kvm_vcpu *vcpu)\n{\n\tto_svm(vcpu)->guest_state_loaded = false;\n}\n\nstatic void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (sd->current_vmcb != svm->vmcb) {\n\t\tsd->current_vmcb = svm->vmcb;\n\t\tindirect_branch_prediction_barrier();\n\t}\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t__avic_vcpu_load(vcpu, cpu);\n}\n\nstatic void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t__avic_vcpu_put(vcpu);\n\n\tsvm_prepare_host_switch(vcpu);\n\n\t++vcpu->stat.host_state_reload;\n}\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long rflags = svm->vmcb->save.rflags;\n\n\tif (svm->nmi_singlestep) {\n\t\t/* Hide our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\trflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\trflags &= ~X86_EFLAGS_RF;\n\t}\n\treturn rflags;\n}\n\nstatic void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (to_svm(vcpu)->nmi_singlestep)\n\t\trflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\n       /*\n        * Any change of EFLAGS.VM is accompanied by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}\n\nstatic bool svm_get_if_flag(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb *vmcb = to_svm(vcpu)->vmcb;\n\n\treturn sev_es_guest(vcpu->kvm)\n\t\t? vmcb->control.int_state & SVM_GUEST_INTERRUPT_MASK\n\t\t: kvm_get_rflags(vcpu) & X86_EFLAGS_IF;\n}\n\nstatic void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\t/*\n\t\t * When !npt_enabled, mmu->pdptrs[] is already available since\n\t\t * it is always updated per SDM when moving to CRs.\n\t\t */\n\t\tif (npt_enabled)\n\t\t\tload_pdptrs(vcpu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tKVM_BUG_ON(1, vcpu->kvm);\n\t}\n}\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control;\n\n\t/*\n\t * The following fields are ignored when AVIC is enabled\n\t */\n\tWARN_ON(kvm_vcpu_apicv_activated(&svm->vcpu));\n\n\tsvm_set_intercept(svm, INTERCEPT_VINTR);\n\n\t/*\n\t * This is just a dummy VINTR to actually cause a vmexit to happen.\n\t * Actual injection of virtual interrupts happens through EVENTINJ.\n\t */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = 0x0;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTR);\n}\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tsvm_clr_intercept(svm, INTERCEPT_VINTR);\n\n\t/* Drop int_ctl fields related to VINTR injection.  */\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_INJECTION_BITS_MASK;\n\tif (is_guest_mode(&svm->vcpu)) {\n\t\tsvm->vmcb01.ptr->control.int_ctl &= ~V_IRQ_INJECTION_BITS_MASK;\n\n\t\tWARN_ON((svm->vmcb->control.int_ctl & V_TPR_MASK) !=\n\t\t\t(svm->nested.ctl.int_ctl & V_TPR_MASK));\n\n\t\tsvm->vmcb->control.int_ctl |= svm->nested.ctl.int_ctl &\n\t\t\tV_IRQ_INJECTION_BITS_MASK;\n\n\t\tsvm->vmcb->control.int_vector = svm->nested.ctl.int_vector;\n\t}\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTR);\n}\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\tstruct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save01->fs;\n\tcase VCPU_SREG_GS: return &save01->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save01->tr;\n\tcase VCPU_SREG_LDTR: return &save01->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}\n\nstatic u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}\n\nstatic void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\t/* This is symmetric with svm_set_segment() */\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}\n\nstatic void svm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tsvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}\n\nstatic void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}\n\nstatic void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}\n\nstatic void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void sev_post_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * For guests that don't set guest_state_protected, the cr3 update is\n\t * handled via kvm_mmu_load() while entering the guest. For guests\n\t * that do (SEV-ES/SEV-SNP), the cr3 update needs to be written to\n\t * VMCB save area now, since the save area will become the initial\n\t * contents of the VMSA, and future VMCB save area updates won't be\n\t * seen.\n\t */\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\tsvm->vmcb->save.cr3 = cr3;\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n\t}\n}\n\nvoid svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 hcr0 = cr0;\n\tbool old_paging = is_paging(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME && !vcpu->arch.guest_state_protected) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled) {\n\t\thcr0 |= X86_CR0_PG | X86_CR0_WP;\n\t\tif (old_paging != is_paging(vcpu))\n\t\t\tsvm_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\thcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\n\tsvm->vmcb->save.cr0 = hcr0;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n\n\t/*\n\t * SEV-ES guests must always keep the CR intercepts cleared. CR\n\t * tracking is done using the CR write traps.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn;\n\n\tif (hcr0 == cr0) {\n\t\t/* Selective CR0 write remains on.  */\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tsvm_set_intercept(svm, INTERCEPT_CR0_READ);\n\t\tsvm_set_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}\n\nstatic bool svm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\treturn true;\n}\n\nvoid svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = vcpu->arch.cr4;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb_current(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled) {\n\t\tcr4 |= X86_CR4_PAE;\n\n\t\tif (!is_paging(vcpu))\n\t\t\tcr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tvmcb_mark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid_runtime(vcpu);\n}\n\nstatic void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\ts->attrib |= ((var->present & 1) && !var->unusable) << SVM_SELECTOR_P_SHIFT;\n\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\t/* This is symmetric with svm_get_segment() */\n\t\tsvm->vmcb->save.cpl = (var->dpl & 3);\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_SEG);\n}\n\nstatic void svm_update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t}\n}\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = sd->min_asid;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_ASID);\n\t}\n\n\tsvm->current_vmcb->asid_generation = sd->asid_generation;\n\tsvm->asid = sd->next_asid++;\n}\n\nstatic void svm_set_dr6(struct vcpu_svm *svm, unsigned long value)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (svm->vcpu.arch.guest_state_protected)\n\t\treturn;\n\n\tif (unlikely(value != vmcb->save.dr6)) {\n\t\tvmcb->save.dr6 = value;\n\t\tvmcb_mark_dirty(vmcb, VMCB_DR);\n\t}\n}\n\nstatic void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\t/*\n\t * We cannot reset svm->vmcb->save.dr6 to DR6_ACTIVE_LOW here,\n\t * because db_interception might need it.  We can do it before vmentry.\n\t */\n\tvcpu->arch.dr6 = svm->vmcb->save.dr6;\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}\n\nstatic void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tsvm->vmcb->save.dr7 = value;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_DR);\n}\n\nstatic int pf_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\treturn kvm_handle_page_fault(vcpu, error_code, fault_address,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}\n\nstatic int npf_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\ttrace_kvm_page_fault(fault_address, error_code);\n\treturn kvm_mmu_page_fault(vcpu, fault_address, error_code,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}\n\nstatic int db_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!(vcpu->guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tu32 payload = svm->vmcb->save.dr6 ^ DR6_ACTIVE_LOW;\n\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, payload);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tdisable_nmi_singlestep(svm);\n\t\t/* Make sure we check for pending NMIs upon entry */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\n\tif (vcpu->guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.dr6 = svm->vmcb->save.dr6;\n\t\tkvm_run->debug.arch.dr7 = svm->vmcb->save.dr7;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int bp_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}\n\nstatic int ud_interception(struct kvm_vcpu *vcpu)\n{\n\treturn handle_ud(vcpu);\n}\n\nstatic int ac_interception(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception_e(vcpu, AC_VECTOR, 0);\n\treturn 1;\n}\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}\n\nstatic void svm_handle_mce(struct kvm_vcpu *vcpu)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tkvm_machine_check();\n}\n\nstatic int mc_interception(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int shutdown_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * The VM save area has already been encrypted so it\n\t * cannot be reinitialized - just terminate.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn -EINVAL;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept.  INIT the vCPU to put\n\t * the VMCB in a known good state.  Unfortuately, KVM doesn't have\n\t * KVM_MP_STATE_SHUTDOWN and can't add it without potentially breaking\n\t * userspace.  At a platform view, INIT is acceptable behavior as\n\t * there exist bare metal platforms that automatically INIT the CPU\n\t * in response to shutdown.\n\t */\n\tclear_page(svm->vmcb);\n\tkvm_vcpu_reset(vcpu, true);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int io_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++vcpu->stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\n\tif (string) {\n\t\tif (sev_es_guest(vcpu->kvm))\n\t\t\treturn sev_es_string_io(svm, size, port, in);\n\t\telse\n\t\t\treturn kvm_emulate_instruction(vcpu, 0);\n\t}\n\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}\n\nstatic int nmi_interception(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int smi_interception(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int intr_interception(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int vmload_vmsave_interception(struct kvm_vcpu *vcpu, bool vmload)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb12;\n\tstruct kvm_host_map map;\n\tint ret;\n\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\tret = kvm_vcpu_map(vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tvmcb12 = map.hva;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\n\tif (vmload) {\n\t\tsvm_copy_vmloadsave_state(svm->vmcb, vmcb12);\n\t\tsvm->sysenter_eip_hi = 0;\n\t\tsvm->sysenter_esp_hi = 0;\n\t} else {\n\t\tsvm_copy_vmloadsave_state(vmcb12, svm->vmcb);\n\t}\n\n\tkvm_vcpu_unmap(vcpu, &map, true);\n\n\treturn ret;\n}\n\nstatic int vmload_interception(struct kvm_vcpu *vcpu)\n{\n\treturn vmload_vmsave_interception(vcpu, true);\n}\n\nstatic int vmsave_interception(struct kvm_vcpu *vcpu)\n{\n\treturn vmload_vmsave_interception(vcpu, false);\n}\n\nstatic int vmrun_interception(struct kvm_vcpu *vcpu)\n{\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\treturn nested_svm_vmrun(vcpu);\n}\n\nenum {\n\tNONE_SVM_INSTR,\n\tSVM_INSTR_VMRUN,\n\tSVM_INSTR_VMLOAD,\n\tSVM_INSTR_VMSAVE,\n};\n\n/* Return NONE_SVM_INSTR if not SVM instrs, otherwise return decode result */\nstatic int svm_instr_opcode(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tif (ctxt->b != 0x1 || ctxt->opcode_len != 2)\n\t\treturn NONE_SVM_INSTR;\n\n\tswitch (ctxt->modrm) {\n\tcase 0xd8: /* VMRUN */\n\t\treturn SVM_INSTR_VMRUN;\n\tcase 0xda: /* VMLOAD */\n\t\treturn SVM_INSTR_VMLOAD;\n\tcase 0xdb: /* VMSAVE */\n\t\treturn SVM_INSTR_VMSAVE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NONE_SVM_INSTR;\n}\n\nstatic int emulate_svm_instr(struct kvm_vcpu *vcpu, int opcode)\n{\n\tconst int guest_mode_exit_codes[] = {\n\t\t[SVM_INSTR_VMRUN] = SVM_EXIT_VMRUN,\n\t\t[SVM_INSTR_VMLOAD] = SVM_EXIT_VMLOAD,\n\t\t[SVM_INSTR_VMSAVE] = SVM_EXIT_VMSAVE,\n\t};\n\tint (*const svm_instr_handlers[])(struct kvm_vcpu *vcpu) = {\n\t\t[SVM_INSTR_VMRUN] = vmrun_interception,\n\t\t[SVM_INSTR_VMLOAD] = vmload_interception,\n\t\t[SVM_INSTR_VMSAVE] = vmsave_interception,\n\t};\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint ret;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* Returns '1' or -errno on failure, '0' on success. */\n\t\tret = nested_svm_simple_vmexit(svm, guest_mode_exit_codes[opcode]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn 1;\n\t}\n\treturn svm_instr_handlers[opcode](vcpu);\n}\n\n/*\n * #GP handling code. Note that #GP can be triggered under the following two\n * cases:\n *   1) SVM VM-related instructions (VMRUN/VMSAVE/VMLOAD) that trigger #GP on\n *      some AMD CPUs when EAX of these instructions are in the reserved memory\n *      regions (e.g. SMM memory on host).\n *   2) VMware backdoor\n */\nstatic int gp_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 error_code = svm->vmcb->control.exit_info_1;\n\tint opcode;\n\n\t/* Both #GP cases have zero error_code */\n\tif (error_code)\n\t\tgoto reinject;\n\n\t/* Decode the instruction for usage later */\n\tif (x86_decode_emulated_instruction(vcpu, 0, NULL, 0) != EMULATION_OK)\n\t\tgoto reinject;\n\n\topcode = svm_instr_opcode(vcpu);\n\n\tif (opcode == NONE_SVM_INSTR) {\n\t\tif (!enable_vmware_backdoor)\n\t\t\tgoto reinject;\n\n\t\t/*\n\t\t * VMware backdoor emulation on #GP interception only handles\n\t\t * IN{S}, OUT{S}, and RDPMC.\n\t\t */\n\t\tif (!is_guest_mode(vcpu))\n\t\t\treturn kvm_emulate_instruction(vcpu,\n\t\t\t\tEMULTYPE_VMWARE_GP | EMULTYPE_NO_DECODE);\n\t} else {\n\t\t/* All SVM instructions expect page aligned RAX */\n\t\tif (svm->vmcb->save.rax & ~PAGE_MASK)\n\t\t\tgoto reinject;\n\n\t\treturn emulate_svm_instr(vcpu, opcode);\n\t}\n\nreinject:\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\treturn 1;\n}\n\nvoid svm_set_gif(struct vcpu_svm *svm, bool value)\n{\n\tif (value) {\n\t\t/*\n\t\t * If VGIF is enabled, the STGI intercept is only added to\n\t\t * detect the opening of the SMI/NMI window; remove it now.\n\t\t * Likewise, clear the VINTR intercept, we will set it\n\t\t * again while processing KVM_REQ_EVENT if needed.\n\t\t */\n\t\tif (vgif)\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_STGI);\n\t\tif (svm_is_intercept(svm, INTERCEPT_VINTR))\n\t\t\tsvm_clear_vintr(svm);\n\n\t\tenable_gif(svm);\n\t\tif (svm->vcpu.arch.smi_pending ||\n\t\t    svm->vcpu.arch.nmi_pending ||\n\t\t    kvm_cpu_has_injectable_intr(&svm->vcpu))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t} else {\n\t\tdisable_gif(svm);\n\n\t\t/*\n\t\t * After a CLGI no interrupts should come.  But if vGIF is\n\t\t * in use, we still rely on the VINTR intercept (rather than\n\t\t * STGI) to detect an open interrupt window.\n\t\t*/\n\t\tif (!vgif)\n\t\t\tsvm_clear_vintr(svm);\n\t}\n}\n\nstatic int stgi_interception(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\tsvm_set_gif(to_svm(vcpu), true);\n\treturn ret;\n}\n\nstatic int clgi_interception(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\tsvm_set_gif(to_svm(vcpu), false);\n\treturn ret;\n}\n\nstatic int invlpga_interception(struct kvm_vcpu *vcpu)\n{\n\tgva_t gva = kvm_rax_read(vcpu);\n\tu32 asid = kvm_rcx_read(vcpu);\n\n\t/* FIXME: Handle an address size prefix. */\n\tif (!is_long_mode(vcpu))\n\t\tgva = (u32)gva;\n\n\ttrace_kvm_invlpga(to_svm(vcpu)->vmcb->save.rip, asid, gva);\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, gva);\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int skinit_interception(struct kvm_vcpu *vcpu)\n{\n\ttrace_kvm_skinit(to_svm(vcpu)->vmcb->save.rip, kvm_rax_read(vcpu));\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\n\nstatic int task_switch_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR))) {\n\t\tif (!svm_skip_emulated_instruction(vcpu))\n\t\t\treturn 0;\n\t}\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\treturn kvm_task_switch(vcpu, tss_selector, int_vec, reason,\n\t\t\t       has_error_code, error_code);\n}\n\nstatic int iret_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t++vcpu->stat.nmi_window_exits;\n\tvcpu->arch.hflags |= HF_IRET_MASK;\n\tif (!sev_es_guest(vcpu->kvm)) {\n\t\tsvm_clr_intercept(svm, INTERCEPT_IRET);\n\t\tsvm->nmi_iret_rip = kvm_rip_read(vcpu);\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 1;\n}\n\nstatic int invlpg_interception(struct kvm_vcpu *vcpu)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tkvm_mmu_invlpg(vcpu, to_svm(vcpu)->vmcb->control.exit_info_1);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int emulate_on_interception(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction(vcpu, 0);\n}\n\nstatic int rsm_interception(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction_from_buffer(vcpu, rsm_ins_bytes, 2);\n}\n\nstatic bool check_selective_cr0_intercepted(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned long val)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long cr0 = vcpu->arch.cr0;\n\tbool ret = false;\n\n\tif (!is_guest_mode(vcpu) ||\n\t    (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}\n\n#define CR_VALID (1ULL << 63)\n\nstatic int cr_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(vcpu);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(vcpu);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(vcpu, val))\n\t\t\t\terr = kvm_set_cr0(vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = vcpu->arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(vcpu, reg, val);\n\t\ttrace_kvm_cr_read(cr, val);\n\t}\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic int cr_trap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long old_value, new_value;\n\tunsigned int cr;\n\tint ret = 0;\n\n\tnew_value = (unsigned long)svm->vmcb->control.exit_info_1;\n\n\tcr = svm->vmcb->control.exit_code - SVM_EXIT_CR0_WRITE_TRAP;\n\tswitch (cr) {\n\tcase 0:\n\t\told_value = kvm_read_cr0(vcpu);\n\t\tsvm_set_cr0(vcpu, new_value);\n\n\t\tkvm_post_set_cr0(vcpu, old_value, new_value);\n\t\tbreak;\n\tcase 4:\n\t\told_value = kvm_read_cr4(vcpu);\n\t\tsvm_set_cr4(vcpu, new_value);\n\n\t\tkvm_post_set_cr4(vcpu, old_value, new_value);\n\t\tbreak;\n\tcase 8:\n\t\tret = kvm_set_cr8(vcpu, new_value);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unhandled CR%d write trap\", cr);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\treturn kvm_complete_insn_gp(vcpu, ret);\n}\n\nstatic int dr_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint reg, dr;\n\tunsigned long val;\n\tint err = 0;\n\n\tif (vcpu->guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(vcpu);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\tif (dr >= 16) { /* mov to DRn  */\n\t\tdr -= 16;\n\t\tval = kvm_register_read(vcpu, reg);\n\t\terr = kvm_set_dr(vcpu, dr, val);\n\t} else {\n\t\tkvm_get_dr(vcpu, dr, &val);\n\t\tkvm_register_write(vcpu, reg, val);\n\t}\n\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic int cr8_write_interception(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(vcpu);\n\tif (lapic_in_kernel(vcpu))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(vcpu))\n\t\treturn r;\n\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}\n\nstatic int efer_trap(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr_info;\n\tint ret;\n\n\t/*\n\t * Clear the EFER_SVME bit from EFER. The SVM code always sets this\n\t * bit in svm_set_efer(), but __kvm_valid_efer() checks it against\n\t * whether the guest has X86_FEATURE_SVM - this avoids a failure if\n\t * the guest doesn't have X86_FEATURE_SVM.\n\t */\n\tmsr_info.host_initiated = false;\n\tmsr_info.index = MSR_EFER;\n\tmsr_info.data = to_svm(vcpu)->vmcb->control.exit_info_1 & ~EFER_SVME;\n\tret = kvm_set_msr_common(vcpu, &msr_info);\n\n\treturn kvm_complete_insn_gp(vcpu, ret);\n}\n\nstatic int svm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tmsr->data = 0;\n\n\tswitch (msr->index) {\n\tcase MSR_F10H_DECFG:\n\t\tif (boot_cpu_has(X86_FEATURE_LFENCE_RDTSC))\n\t\t\tmsr->data |= MSR_F10H_DECFG_LFENCE_SERIALIZE;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\treturn 0;\n\tdefault:\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n\n\treturn 0;\n}\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_AMD64_TSC_RATIO:\n\t\tif (!msr_info->host_initiated && !svm->tsc_scaling_enabled)\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_ratio_msr;\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = (u32)svm->vmcb01.ptr->save.sysenter_eip;\n\t\tif (guest_cpuid_is_intel(vcpu))\n\t\t\tmsr_info->data |= (u64)svm->sysenter_eip_hi << 32;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.sysenter_esp;\n\t\tif (guest_cpuid_is_intel(vcpu))\n\t\t\tmsr_info->data |= (u64)svm->sysenter_esp_hi << 32;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm_get_lbr_msr(svm, msr_info->index);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\t\tmsr_info->data = svm->vmcb->save.spec_ctrl;\n\t\telse\n\t\t\tmsr_info->data = svm->spec_ctrl;\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = svm->virt_spec_ctrl;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tcase MSR_F10H_DECFG:\n\t\tmsr_info->data = svm->msr_decfg;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}\n\nstatic int svm_complete_emulated_msr(struct kvm_vcpu *vcpu, int err)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (!err || !sev_es_guest(vcpu->kvm) || WARN_ON_ONCE(!svm->sev_es.ghcb))\n\t\treturn kvm_complete_insn_gp(vcpu, err);\n\n\tghcb_set_sw_exit_info_1(svm->sev_es.ghcb, 1);\n\tghcb_set_sw_exit_info_2(svm->sev_es.ghcb,\n\t\t\t\tX86_TRAP_GP |\n\t\t\t\tSVM_EVTINJ_TYPE_EXEPT |\n\t\t\t\tSVM_EVTINJ_VALID);\n\treturn 1;\n}\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint r;\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_AMD64_TSC_RATIO:\n\n\t\tif (!svm->tsc_scaling_enabled) {\n\n\t\t\tif (!msr->host_initiated)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * In case TSC scaling is not enabled, always\n\t\t\t * leave this MSR at the default value.\n\t\t\t *\n\t\t\t * Due to bug in qemu 6.2.0, it would try to set\n\t\t\t * this msr to 0 if tsc scaling is not enabled.\n\t\t\t * Ignore this value as well.\n\t\t\t */\n\t\t\tif (data != 0 && data != svm->tsc_ratio_msr)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data & SVM_TSC_RATIO_RSVD)\n\t\t\treturn 1;\n\n\t\tsvm->tsc_ratio_msr = data;\n\n\t\tif (svm->tsc_scaling_enabled && is_guest_mode(vcpu))\n\t\t\tnested_svm_update_tsc_ratio_msr(vcpu);\n\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\treturn 1;\n\t\tvcpu->arch.pat = data;\n\t\tsvm->vmcb01.ptr->save.g_pat = data;\n\t\tif (is_guest_mode(vcpu))\n\t\t\tnested_vmcb02_compute_g_pat(svm);\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_NPT);\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (kvm_spec_ctrl_test_value(data))\n\t\t\treturn 1;\n\n\t\tif (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\t\tsvm->vmcb->save.spec_ctrl = data;\n\t\telse\n\t\t\tsvm->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_svm_vmrun_msrpm.\n\t\t * We update the L1 MSR bit as well since it will end up\n\t\t * touching the MSR anyway now.\n\t\t */\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);\n\t\tbreak;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_has_pred_cmd_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_IBPB))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_PRED_CMD, 0, 1);\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tif (data & ~SPEC_CTRL_SSBD)\n\t\t\treturn 1;\n\n\t\tsvm->virt_spec_ctrl = data;\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb01.ptr->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb01.ptr->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb01.ptr->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb01.ptr->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb01.ptr->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb01.ptr->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->vmcb01.ptr->save.sysenter_eip = (u32)data;\n\t\t/*\n\t\t * We only intercept the MSR_IA32_SYSENTER_{EIP|ESP} msrs\n\t\t * when we spoof an Intel vendor ID (for cross vendor migration).\n\t\t * In this case we use this intercept to track the high\n\t\t * 32 bit part of these msrs to support Intel's\n\t\t * implementation of SYSENTER/SYSEXIT.\n\t\t */\n\t\tsvm->sysenter_eip_hi = guest_cpuid_is_intel(vcpu) ? (data >> 32) : 0;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->vmcb01.ptr->save.sysenter_esp = (u32)data;\n\t\tsvm->sysenter_esp_hi = guest_cpuid_is_intel(vcpu) ? (data >> 32) : 0;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\t/*\n\t\t * TSC_AUX is usually changed only during boot and never read\n\t\t * directly.  Intercept TSC_AUX instead of exposing it to the\n\t\t * guest via direct_access_msrs, and switch it via user return.\n\t\t */\n\t\tpreempt_disable();\n\t\tr = kvm_set_user_return_msr(tsc_aux_uret_slot, data, -1ull);\n\t\tpreempt_enable();\n\t\tif (r)\n\t\t\treturn 1;\n\n\t\tsvm->tsc_aux = data;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!lbrv) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tif (svm->vmcb->control.virt_ext & LBR_CTL_ENABLE_MASK)\n\t\t\tsvm->vmcb->save.dbgctl = data;\n\t\telse\n\t\t\tsvm->vmcb01.ptr->save.dbgctl = data;\n\n\t\tsvm_update_lbrv(vcpu);\n\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\t/*\n\t\t * Old kernels did not validate the value written to\n\t\t * MSR_VM_HSAVE_PA.  Allow KVM_SET_MSR to set an invalid\n\t\t * value to allow live migrating buggy or malicious guests\n\t\t * originating from those kernels.\n\t\t */\n\t\tif (!msr->host_initiated && !page_address_valid(vcpu, data))\n\t\t\treturn 1;\n\n\t\tsvm->nested.hsave_msr = data & PAGE_MASK;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tcase MSR_F10H_DECFG: {\n\t\tstruct kvm_msr_entry msr_entry;\n\n\t\tmsr_entry.index = msr->index;\n\t\tif (svm_get_msr_feature(&msr_entry))\n\t\t\treturn 1;\n\n\t\t/* Check the supported bits */\n\t\tif (data & ~msr_entry.data)\n\t\t\treturn 1;\n\n\t\t/* Don't allow the guest to change a bit, #GP */\n\t\tif (!msr->host_initiated && (data ^ msr_entry.data))\n\t\t\treturn 1;\n\n\t\tsvm->msr_decfg = data;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}\n\nstatic int msr_interception(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_info_1)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse\n\t\treturn kvm_emulate_rdmsr(vcpu);\n}\n\nstatic int interrupt_window_interception(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tsvm_clear_vintr(to_svm(vcpu));\n\n\t/*\n\t * If not running nested, for AVIC, the only reason to end up here is ExtINTs.\n\t * In this case AVIC was temporarily disabled for\n\t * requesting the IRQ window and we have to re-enable it.\n\t *\n\t * If running nested, still remove the VM wide AVIC inhibit to\n\t * support case in which the interrupt window was requested when the\n\t * vCPU was not running nested.\n\n\t * All vCPUs which run still run nested, will remain to have their\n\t * AVIC still inhibited due to per-cpu AVIC inhibition.\n\t */\n\tkvm_clear_apicv_inhibit(vcpu->kvm, APICV_INHIBIT_REASON_IRQWIN);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}\n\nstatic int pause_interception(struct kvm_vcpu *vcpu)\n{\n\tbool in_kernel;\n\t/*\n\t * CPL is not made available for an SEV-ES guest, therefore\n\t * vcpu->arch.preempted_in_kernel can never be true.  Just\n\t * set in_kernel to false as well.\n\t */\n\tin_kernel = !sev_es_guest(vcpu->kvm) && svm_get_cpl(vcpu) == 0;\n\n\tgrow_ple_window(vcpu);\n\n\tkvm_vcpu_on_spin(vcpu, in_kernel);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int invpcid_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long type;\n\tgva_t gva;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * For an INVPCID intercept:\n\t * EXITINFO1 provides the linear address of the memory operand.\n\t * EXITINFO2 provides the contents of the register operand.\n\t */\n\ttype = svm->vmcb->control.exit_info_2;\n\tgva = svm->vmcb->control.exit_info_1;\n\n\treturn kvm_handle_invpcid(vcpu, type, gva);\n}\n\nstatic int (*const svm_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_EXCP_BASE + GP_VECTOR]\t= gp_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= smi_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= kvm_emulate_rdpmc,\n\t[SVM_EXIT_CPUID]\t\t\t= kvm_emulate_cpuid,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = kvm_emulate_invd,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= kvm_emulate_halt,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= kvm_emulate_hypercall,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_RDTSCP]\t\t\t= kvm_handle_invalid_op,\n\t[SVM_EXIT_WBINVD]                       = kvm_emulate_wbinvd,\n\t[SVM_EXIT_MONITOR]\t\t\t= kvm_emulate_monitor,\n\t[SVM_EXIT_MWAIT]\t\t\t= kvm_emulate_mwait,\n\t[SVM_EXIT_XSETBV]\t\t\t= kvm_emulate_xsetbv,\n\t[SVM_EXIT_RDPRU]\t\t\t= kvm_handle_invalid_op,\n\t[SVM_EXIT_EFER_WRITE_TRAP]\t\t= efer_trap,\n\t[SVM_EXIT_CR0_WRITE_TRAP]\t\t= cr_trap,\n\t[SVM_EXIT_CR4_WRITE_TRAP]\t\t= cr_trap,\n\t[SVM_EXIT_CR8_WRITE_TRAP]\t\t= cr_trap,\n\t[SVM_EXIT_INVPCID]                      = invpcid_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= npf_interception,\n\t[SVM_EXIT_RSM]                          = rsm_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n\t[SVM_EXIT_VMGEXIT]\t\t\t= sev_handle_vmgexit,\n};\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\tstruct vmcb_save_area *save01 = &svm->vmcb01.ptr->save;\n\n\tif (!dump_invalid_vmcb) {\n\t\tpr_warn_ratelimited(\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tpr_err(\"VMCB %p, last attempted VMRUN on CPU %d\\n\",\n\t       svm->current_vmcb->ptr, vcpu->arch.last_vmentry_cpu);\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercepts[INTERCEPT_CR] & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercepts[INTERCEPT_CR] >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercepts[INTERCEPT_DR] & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercepts[INTERCEPT_DR] >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercepts[INTERCEPT_EXCEPTION]);\n\tpr_err(\"%-20s%08x %08x\\n\", \"intercepts:\",\n              control->intercepts[INTERCEPT_WORD3],\n\t       control->intercepts[INTERCEPT_WORD4]);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%d\\n\", \"pause filter threshold:\",\n\t       control->pause_filter_thresh);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%016llx\\n\", \"ghcb:\", control->ghcb_gpa);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"virt_ext:\", control->virt_ext);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"vmsa_pa:\", control->vmsa_pa);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save01->fs.selector, save01->fs.attrib,\n\t       save01->fs.limit, save01->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save01->gs.selector, save01->gs.attrib,\n\t       save01->gs.limit, save01->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save01->ldtr.selector, save01->ldtr.attrib,\n\t       save01->ldtr.limit, save01->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save01->tr.selector, save01->tr.attrib,\n\t       save01->tr.limit, save01->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save01->star, \"lstar:\", save01->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save01->cstar, \"sfmask:\", save01->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save01->kernel_gs_base,\n\t       \"sysenter_cs:\", save01->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save01->sysenter_esp,\n\t       \"sysenter_eip:\", save01->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}\n\nstatic bool svm_check_exit_valid(u64 exit_code)\n{\n\treturn (exit_code < ARRAY_SIZE(svm_exit_handlers) &&\n\t\tsvm_exit_handlers[exit_code]);\n}\n\nstatic int svm_handle_invalid_exit(struct kvm_vcpu *vcpu, u64 exit_code)\n{\n\tvcpu_unimpl(vcpu, \"svm: unexpected exit reason 0x%llx\\n\", exit_code);\n\tdump_vmcb(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 2;\n\tvcpu->run->internal.data[0] = exit_code;\n\tvcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;\n\treturn 0;\n}\n\nint svm_invoke_exit_handler(struct kvm_vcpu *vcpu, u64 exit_code)\n{\n\tif (!svm_check_exit_valid(exit_code))\n\t\treturn svm_handle_invalid_exit(vcpu, exit_code);\n\n#ifdef CONFIG_RETPOLINE\n\tif (exit_code == SVM_EXIT_MSR)\n\t\treturn msr_interception(vcpu);\n\telse if (exit_code == SVM_EXIT_VINTR)\n\t\treturn interrupt_window_interception(vcpu);\n\telse if (exit_code == SVM_EXIT_INTR)\n\t\treturn intr_interception(vcpu);\n\telse if (exit_code == SVM_EXIT_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_code == SVM_EXIT_NPF)\n\t\treturn npf_interception(vcpu);\n#endif\n\treturn svm_exit_handlers[exit_code](vcpu);\n}\n\nstatic void svm_get_exit_info(struct kvm_vcpu *vcpu, u32 *reason,\n\t\t\t      u64 *info1, u64 *info2,\n\t\t\t      u32 *intr_info, u32 *error_code)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*reason = control->exit_code;\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n\t*intr_info = control->exit_int_info;\n\tif ((*intr_info & SVM_EXITINTINFO_VALID) &&\n\t    (*intr_info & SVM_EXITINTINFO_VALID_ERR))\n\t\t*error_code = control->exit_int_info_err;\n\telse\n\t\t*error_code = 0;\n}\n\nstatic int svm_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(vcpu, KVM_ISA_SVM);\n\n\t/* SEV-ES guests must use the CR write traps to track CR registers. */\n\tif (!sev_es_guest(vcpu->kvm)) {\n\t\tif (!svm_is_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\t\tif (npt_enabled)\n\t\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(vcpu, KVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tkvm_run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_fastpath != EXIT_FASTPATH_NONE)\n\t\treturn 1;\n\n\treturn svm_invoke_exit_handler(vcpu, exit_code);\n}\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}\n\nstatic void pre_svm_run(struct kvm_vcpu *vcpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * If the previous vmrun of the vmcb occurred on a different physical\n\t * cpu, then mark the vmcb dirty and assign a new asid.  Hardware's\n\t * vmcb clean bits are per logical CPU, as are KVM's asid assignments.\n\t */\n\tif (unlikely(svm->current_vmcb->cpu != vcpu->cpu)) {\n\t\tsvm->current_vmcb->asid_generation = 0;\n\t\tvmcb_mark_all_dirty(svm->vmcb);\n\t\tsvm->current_vmcb->cpu = vcpu->cpu;\n        }\n\n\tif (sev_guest(vcpu->kvm))\n\t\treturn pre_sev_run(svm, vcpu->cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->current_vmcb->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}\n\nstatic void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tif (!sev_es_guest(vcpu->kvm))\n\t\tsvm_set_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}\n\nstatic void svm_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}\n\nvoid svm_complete_interrupt_delivery(struct kvm_vcpu *vcpu, int delivery_mode,\n\t\t\t\t     int trig_mode, int vector)\n{\n\t/*\n\t * vcpu->arch.apicv_active must be read after vcpu->mode.\n\t * Pairs with smp_store_release in vcpu_enter_guest.\n\t */\n\tbool in_guest_mode = (smp_load_acquire(&vcpu->mode) == IN_GUEST_MODE);\n\n\tif (!READ_ONCE(vcpu->arch.apicv_active)) {\n\t\t/* Process the interrupt via inject_pending_event */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\treturn;\n\t}\n\n\ttrace_kvm_apicv_accept_irq(vcpu->vcpu_id, delivery_mode, trig_mode, vector);\n\tif (in_guest_mode) {\n\t\t/*\n\t\t * Signal the doorbell to tell hardware to inject the IRQ.  If\n\t\t * the vCPU exits the guest before the doorbell chimes, hardware\n\t\t * will automatically process AVIC interrupts at the next VMRUN.\n\t\t */\n\t\tavic_ring_doorbell(vcpu);\n\t} else {\n\t\t/*\n\t\t * Wake the vCPU if it was blocking.  KVM will then detect the\n\t\t * pending IRQ when checking if the vCPU has a wake event.\n\t\t */\n\t\tkvm_vcpu_wake_up(vcpu);\n\t}\n}\n\nstatic void svm_deliver_interrupt(struct kvm_lapic *apic,  int delivery_mode,\n\t\t\t\t  int trig_mode, int vector)\n{\n\tkvm_lapic_set_irr(vector, apic);\n\n\t/*\n\t * Pairs with the smp_mb_*() after setting vcpu->guest_mode in\n\t * vcpu_enter_guest() to ensure the write to the vIRR is ordered before\n\t * the read of guest_mode.  This guarantees that either VMRUN will see\n\t * and process the new vIRR entry, or that svm_complete_interrupt_delivery\n\t * will signal the doorbell if the CPU has already entered the guest.\n\t */\n\tsmp_mb__after_atomic();\n\tsvm_complete_interrupt_delivery(apic->vcpu, delivery_mode, trig_mode, vector);\n}\n\nstatic void svm_update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * SEV-ES guests must always keep the CR intercepts cleared. CR\n\t * tracking is done using the CR write traps.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn;\n\n\tif (nested_svm_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tsvm_set_intercept(svm, INTERCEPT_CR8_WRITE);\n}\n\nbool svm_nmi_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tbool ret;\n\n\tif (!gif_set(svm))\n\t\treturn true;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_nmi(svm))\n\t\treturn false;\n\n\tret = (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) ||\n\t      (vcpu->arch.hflags & HF_NMI_MASK);\n\n\treturn ret;\n}\n\nstatic int svm_nmi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\tif (svm_nmi_blocked(vcpu))\n\t\treturn 0;\n\n\t/* An NMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_nmi(svm))\n\t\treturn -EBUSY;\n\treturn 1;\n}\n\nstatic bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\treturn !!(vcpu->arch.hflags & HF_NMI_MASK);\n}\n\nstatic void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tvcpu->arch.hflags |= HF_NMI_MASK;\n\t\tif (!sev_es_guest(vcpu->kvm))\n\t\t\tsvm_set_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tvcpu->arch.hflags &= ~HF_NMI_MASK;\n\t\tif (!sev_es_guest(vcpu->kvm))\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_IRET);\n\t}\n}\n\nbool svm_interrupt_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (!gif_set(svm))\n\t\treturn true;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* As long as interrupts are being delivered...  */\n\t\tif ((svm->nested.ctl.int_ctl & V_INTR_MASKING_MASK)\n\t\t    ? !(svm->vmcb01.ptr->save.rflags & X86_EFLAGS_IF)\n\t\t    : !(kvm_get_rflags(vcpu) & X86_EFLAGS_IF))\n\t\t\treturn true;\n\n\t\t/* ... vmexits aren't blocked by the interrupt shadow  */\n\t\tif (nested_exit_on_intr(svm))\n\t\t\treturn false;\n\t} else {\n\t\tif (!svm_get_if_flag(vcpu))\n\t\t\treturn true;\n\t}\n\n\treturn (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK);\n}\n\nstatic int svm_interrupt_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\tif (svm_interrupt_blocked(vcpu))\n\t\treturn 0;\n\n\t/*\n\t * An IRQ must not be injected into L2 if it's supposed to VM-Exit,\n\t * e.g. if the IRQ arrived asynchronously after checking nested events.\n\t */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_intr(svm))\n\t\treturn -EBUSY;\n\n\treturn 1;\n}\n\nstatic void svm_enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept. However, if the vGIF feature is\n\t * enabled, the STGI interception will not occur. Enable the irq\n\t * window under the assumption that the hardware will set the GIF.\n\t */\n\tif (vgif || gif_set(svm)) {\n\t\t/*\n\t\t * IRQ window is not needed when AVIC is enabled,\n\t\t * unless we have pending ExtINT since it cannot be injected\n\t\t * via AVIC. In such case, KVM needs to temporarily disable AVIC,\n\t\t * and fallback to injecting IRQ via V_IRQ.\n\t\t *\n\t\t * If running nested, AVIC is already locally inhibited\n\t\t * on this vCPU, therefore there is no need to request\n\t\t * the VM wide AVIC inhibition.\n\t\t */\n\t\tif (!is_guest_mode(vcpu))\n\t\t\tkvm_set_apicv_inhibit(vcpu->kvm, APICV_INHIBIT_REASON_IRQWIN);\n\n\t\tsvm_set_vintr(svm);\n\t}\n}\n\nstatic void svm_enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((vcpu->arch.hflags & (HF_NMI_MASK | HF_IRET_MASK)) == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif)\n\t\t\tsvm_set_intercept(svm, INTERCEPT_STGI);\n\t\treturn; /* STGI will cause a vm exit */\n\t}\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep_guest_rflags = svm_get_rflags(vcpu);\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n}\n\nstatic void svm_flush_tlb_current(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * Flush only the current ASID even if the TLB flush was invoked via\n\t * kvm_flush_remote_tlbs().  Although flushing remote TLBs requires all\n\t * ASIDs to be flushed, KVM uses a single ASID for L1 and L2, and\n\t * unconditionally does a TLB flush on both nested VM-Enter and nested\n\t * VM-Exit (via kvm_mmu_reset_context()).\n\t */\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->current_vmcb->asid_generation--;\n}\n\nstatic void svm_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tinvlpga(gva, svm->vmcb->control.asid);\n}\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nested_svm_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!svm_is_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (nested_svm_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}\n\nstatic void svm_complete_interrupts(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((vcpu->arch.hflags & HF_IRET_MASK) &&\n\t    (sev_es_guest(vcpu->kvm) ||\n\t     kvm_rip_read(vcpu) != svm->nmi_iret_rip)) {\n\t\tvcpu->arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tvcpu->arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * Never re-inject a #VC exception.\n\t\t */\n\t\tif (vector == X86_TRAP_VC)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(vcpu,\n\t\t\t\t\t      kvm_rip_read(vcpu) - int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(vcpu);\n}\n\nstatic int svm_vcpu_pre_run(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic fastpath_t svm_exit_handlers_fastpath(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_MSR &&\n\t    to_svm(vcpu)->vmcb->control.exit_info_1)\n\t\treturn handle_fastpath_set_msr_irqoff(vcpu);\n\n\treturn EXIT_FASTPATH_NONE;\n}\n\nstatic noinstr void svm_vcpu_enter_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long vmcb_pa = svm->current_vmcb->pa;\n\n\tguest_state_enter_irqoff();\n\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\t__svm_sev_es_vcpu_run(vmcb_pa);\n\t} else {\n\t\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\n\t\t/*\n\t\t * Use a single vmcb (vmcb01 because it's always valid) for\n\t\t * context switching guest state via VMLOAD/VMSAVE, that way\n\t\t * the state doesn't need to be copied between vmcb01 and\n\t\t * vmcb02 when switching vmcbs for nested virtualization.\n\t\t */\n\t\tvmload(svm->vmcb01.pa);\n\t\t__svm_vcpu_run(vmcb_pa, (unsigned long *)&vcpu->arch.regs);\n\t\tvmsave(svm->vmcb01.pa);\n\n\t\tvmload(__sme_page_pa(sd->save_area));\n\t}\n\n\tguest_state_exit_irqoff();\n}\n\nstatic __no_kcsan fastpath_t svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\ttrace_kvm_entry(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * Disable singlestep if we're injecting an interrupt/exception.\n\t * We don't want our modified rflags to be pushed on the stack where\n\t * we might not be able to easily reset them if we disabled NMI\n\t * singlestep later.\n\t */\n\tif (svm->nmi_singlestep && svm->vmcb->control.event_inj) {\n\t\t/*\n\t\t * Event injection happens before external interrupts cause a\n\t\t * vmexit and interrupts are disabled here, so smp_send_reschedule\n\t\t * is enough to force an immediate vmexit.\n\t\t */\n\t\tdisable_nmi_singlestep(svm);\n\t\tsmp_send_reschedule(vcpu->cpu);\n\t}\n\n\tpre_svm_run(vcpu);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tif (unlikely(svm->asid != svm->vmcb->control.asid)) {\n\t\tsvm->vmcb->control.asid = svm->asid;\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_ASID);\n\t}\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tsvm_hv_update_vp_id(svm->vmcb, vcpu);\n\n\t/*\n\t * Run with all-zero DR6 unless needed, so that we can get the exact cause\n\t * of a #DB.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT))\n\t\tsvm_set_dr6(svm, vcpu->arch.dr6);\n\telse\n\t\tsvm_set_dr6(svm, DR6_ACTIVE_LOW);\n\n\tclgi();\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\tx86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tsvm_vcpu_enter_exit(vcpu);\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL) &&\n\t    unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tsvm->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tif (!sev_es_guest(vcpu->kvm))\n\t\treload_tss(vcpu);\n\n\tif (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\tx86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tif (!sev_es_guest(vcpu->kvm)) {\n\t\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\t\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\t}\n\tvcpu->arch.regs_dirty = 0;\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_interrupt(vcpu, KVM_HANDLING_NMI);\n\n\tkvm_load_host_xsave_state(vcpu);\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_interrupt(vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\tif (is_guest_mode(vcpu)) {\n\t\tnested_sync_control_from_vmcb02(svm);\n\n\t\t/* Track VMRUNs that have made past consistency checking */\n\t\tif (svm->nested.nested_run_pending &&\n\t\t    svm->vmcb->control.exit_code != SVM_EXIT_ERR)\n                        ++vcpu->stat.nested_run;\n\n\t\tsvm->nested.nested_run_pending = 0;\n\t}\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\tvmcb_mark_all_clean(svm->vmcb);\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tvcpu->arch.apf.host_apf_flags =\n\t\t\tkvm_read_and_reset_apf_flags();\n\n\tvcpu->arch.regs_avail &= ~SVM_REGS_LAZY_LOAD_SET;\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(vcpu);\n\n\tsvm_complete_interrupts(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn EXIT_FASTPATH_NONE;\n\n\treturn svm_exit_handlers_fastpath(vcpu);\n}\n\nstatic void svm_load_mmu_pgd(struct kvm_vcpu *vcpu, hpa_t root_hpa,\n\t\t\t     int root_level)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long cr3;\n\n\tif (npt_enabled) {\n\t\tsvm->vmcb->control.nested_cr3 = __sme_set(root_hpa);\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_NPT);\n\n\t\thv_track_root_tdp(vcpu, root_hpa);\n\n\t\tcr3 = vcpu->arch.cr3;\n\t} else if (vcpu->arch.mmu->root_role.level >= PT64_ROOT_4LEVEL) {\n\t\tcr3 = __sme_set(root_hpa) | kvm_get_active_pcid(vcpu);\n\t} else {\n\t\t/* PCID in the guest should be impossible with a 32-bit MMU. */\n\t\tWARN_ON_ONCE(kvm_get_active_pcid(vcpu));\n\t\tcr3 = root_hpa;\n\t}\n\n\tsvm->vmcb->save.cr3 = cr3;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n}\n\nstatic int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}\n\nstatic int __init svm_check_processor_compat(void)\n{\n\treturn 0;\n}\n\n/*\n * The kvm parameter can be NULL (module initialization, or invocation before\n * VM creation). Be sure to check the kvm parameter before using it.\n */\nstatic bool svm_has_emulated_msr(struct kvm *kvm, u32 index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_MCG_EXT_CTL:\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn false;\n\tcase MSR_IA32_SMBASE:\n\t\t/* SEV-ES guests do not support SMM, so report false */\n\t\tif (kvm && sev_es_guest(kvm))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}\n\nstatic void svm_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->arch.xsaves_enabled = guest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVES);\n\n\t/* Update nrips enabled cache */\n\tsvm->nrips_enabled = kvm_cpu_cap_has(X86_FEATURE_NRIPS) &&\n\t\t\t     guest_cpuid_has(vcpu, X86_FEATURE_NRIPS);\n\n\tsvm->tsc_scaling_enabled = tsc_scaling && guest_cpuid_has(vcpu, X86_FEATURE_TSCRATEMSR);\n\tsvm->lbrv_enabled = lbrv && guest_cpuid_has(vcpu, X86_FEATURE_LBRV);\n\n\tsvm->v_vmload_vmsave_enabled = vls && guest_cpuid_has(vcpu, X86_FEATURE_V_VMSAVE_VMLOAD);\n\n\tsvm->pause_filter_enabled = kvm_cpu_cap_has(X86_FEATURE_PAUSEFILTER) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PAUSEFILTER);\n\n\tsvm->pause_threshold_enabled = kvm_cpu_cap_has(X86_FEATURE_PFTHRESHOLD) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PFTHRESHOLD);\n\n\tsvm->vgif_enabled = vgif && guest_cpuid_has(vcpu, X86_FEATURE_VGIF);\n\n\tsvm_recalc_instruction_intercepts(vcpu, svm);\n\n\t/* For sev guests, the memory encryption bit is not reserved in CR3.  */\n\tif (sev_guest(vcpu->kvm)) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x8000001F, 0);\n\t\tif (best)\n\t\t\tvcpu->arch.reserved_gpa_bits &= ~(1UL << (best->ebx & 0x3f));\n\t}\n\n\tif (kvm_vcpu_apicv_active(vcpu)) {\n\t\t/*\n\t\t * AVIC does not work with an x2APIC mode guest. If the X2APIC feature\n\t\t * is exposed to the guest, disable AVIC.\n\t\t */\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))\n\t\t\tkvm_set_apicv_inhibit(kvm, APICV_INHIBIT_REASON_X2APIC);\n\t}\n\tinit_vmcb_after_set_cpuid(vcpu);\n}\n\nstatic bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}\n\n#define PRE_EX(exit)  { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_PRE_EXCEPT, }\n#define POST_EX(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_EXCEPT, }\n#define POST_MEM(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_MEMACCESS, }\n\nstatic const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_xsetbv]\t\t= PRE_EX(SVM_EXIT_XSETBV),\n};\n\n#undef PRE_EX\n#undef POST_EX\n#undef POST_MEM\n\nstatic int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tif (!(vmcb12_is_intercept(&svm->nested.ctl,\n\t\t\t\t\tINTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* TODO: Advertise NRIPS to guest hypervisor unconditionally */\n\tif (static_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}\n\nstatic void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n}\n\nstatic void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tshrink_ple_window(vcpu);\n}\n\nstatic void svm_setup_mce(struct kvm_vcpu *vcpu)\n{\n\t/* [63:9] are reserved. */\n\tvcpu->arch.mcg_cap &= 0x1ff;\n}\n\nbool svm_smi_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/* Per APM Vol.2 15.22.2 \"Response to SMI\" */\n\tif (!gif_set(svm))\n\t\treturn true;\n\n\treturn is_smm(vcpu);\n}\n\nstatic int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\tif (svm_smi_blocked(vcpu))\n\t\treturn 0;\n\n\t/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))\n\t\treturn -EBUSY;\n\n\treturn 1;\n}\n\nstatic int svm_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_host_map map_save;\n\tint ret;\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn 0;\n\n\t/* FED8h - SVM Guest */\n\tput_smstate(u64, smstate, 0x7ed8, 1);\n\t/* FEE0h - SVM Guest VMCB Physical Address */\n\tput_smstate(u64, smstate, 0x7ee0, svm->nested.vmcb12_gpa);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\tret = nested_svm_simple_vmexit(svm, SVM_EXIT_SW);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * KVM uses VMCB01 to store L1 host state while L2 runs but\n\t * VMCB01 is going to be used during SMM and thus the state will\n\t * be lost. Temporary save non-VMLOAD/VMSAVE state to the host save\n\t * area pointed to by MSR_VM_HSAVE_PA. APM guarantees that the\n\t * format of the area is identical to guest save area offsetted\n\t * by 0x400 (matches the offset of 'struct vmcb_save_area'\n\t * within 'struct vmcb'). Note: HSAVE area may also be used by\n\t * L1 hypervisor to save additional host context (e.g. KVM does\n\t * that, see svm_prepare_switch_to_guest()) which must be\n\t * preserved.\n\t */\n\tif (kvm_vcpu_map(vcpu, gpa_to_gfn(svm->nested.hsave_msr),\n\t\t\t &map_save) == -EINVAL)\n\t\treturn 1;\n\n\tBUILD_BUG_ON(offsetof(struct vmcb, save) != 0x400);\n\n\tsvm_copy_vmrun_state(map_save.hva + 0x400,\n\t\t\t     &svm->vmcb01.ptr->save);\n\n\tkvm_vcpu_unmap(vcpu, &map_save, true);\n\treturn 0;\n}\n\nstatic int svm_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_host_map map, map_save;\n\tu64 saved_efer, vmcb12_gpa;\n\tstruct vmcb *vmcb12;\n\tint ret;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\treturn 0;\n\n\t/* Non-zero if SMI arrived while vCPU was in guest mode. */\n\tif (!GET_SMSTATE(u64, smstate, 0x7ed8))\n\t\treturn 0;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SVM))\n\t\treturn 1;\n\n\tsaved_efer = GET_SMSTATE(u64, smstate, 0x7ed0);\n\tif (!(saved_efer & EFER_SVME))\n\t\treturn 1;\n\n\tvmcb12_gpa = GET_SMSTATE(u64, smstate, 0x7ee0);\n\tif (kvm_vcpu_map(vcpu, gpa_to_gfn(vmcb12_gpa), &map) == -EINVAL)\n\t\treturn 1;\n\n\tret = 1;\n\tif (kvm_vcpu_map(vcpu, gpa_to_gfn(svm->nested.hsave_msr), &map_save) == -EINVAL)\n\t\tgoto unmap_map;\n\n\tif (svm_allocate_nested(svm))\n\t\tgoto unmap_save;\n\n\t/*\n\t * Restore L1 host state from L1 HSAVE area as VMCB01 was\n\t * used during SMM (see svm_enter_smm())\n\t */\n\n\tsvm_copy_vmrun_state(&svm->vmcb01.ptr->save, map_save.hva + 0x400);\n\n\t/*\n\t * Enter the nested guest now\n\t */\n\n\tvmcb_mark_all_dirty(svm->vmcb01.ptr);\n\n\tvmcb12 = map.hva;\n\tnested_copy_vmcb_control_to_cache(svm, &vmcb12->control);\n\tnested_copy_vmcb_save_to_cache(svm, &vmcb12->save);\n\tret = enter_svm_guest_mode(vcpu, vmcb12_gpa, vmcb12, false);\n\n\tif (ret)\n\t\tgoto unmap_save;\n\n\tsvm->nested.nested_run_pending = 1;\n\nunmap_save:\n\tkvm_vcpu_unmap(vcpu, &map_save, true);\nunmap_map:\n\tkvm_vcpu_unmap(vcpu, &map, true);\n\treturn ret;\n}\n\nstatic void svm_enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif)\n\t\t\tsvm_set_intercept(svm, INTERCEPT_STGI);\n\t\t/* STGI will cause a vm exit */\n\t} else {\n\t\t/* We must be in SMM; RSM will cause a vmexit anyway.  */\n\t}\n}\n\nstatic bool svm_can_emulate_instruction(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\tbool smep, smap, is_user;\n\tunsigned long cr4;\n\tu64 error_code;\n\n\t/* Emulation is always possible when KVM has access to all guest state. */\n\tif (!sev_guest(vcpu->kvm))\n\t\treturn true;\n\n\t/* #UD and #GP should never be intercepted for SEV guests. */\n\tWARN_ON_ONCE(emul_type & (EMULTYPE_TRAP_UD |\n\t\t\t\t  EMULTYPE_TRAP_UD_FORCED |\n\t\t\t\t  EMULTYPE_VMWARE_GP));\n\n\t/*\n\t * Emulation is impossible for SEV-ES guests as KVM doesn't have access\n\t * to guest register state.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn false;\n\n\t/*\n\t * Emulation is possible if the instruction is already decoded, e.g.\n\t * when completing I/O after returning from userspace.\n\t */\n\tif (emul_type & EMULTYPE_NO_DECODE)\n\t\treturn true;\n\n\t/*\n\t * Emulation is possible for SEV guests if and only if a prefilled\n\t * buffer containing the bytes of the intercepted instruction is\n\t * available. SEV guest memory is encrypted with a guest specific key\n\t * and cannot be decrypted by KVM, i.e. KVM would read cyphertext and\n\t * decode garbage.\n\t *\n\t * Inject #UD if KVM reached this point without an instruction buffer.\n\t * In practice, this path should never be hit by a well-behaved guest,\n\t * e.g. KVM doesn't intercept #UD or #GP for SEV guests, but this path\n\t * is still theoretically reachable, e.g. via unaccelerated fault-like\n\t * AVIC access, and needs to be handled by KVM to avoid putting the\n\t * guest into an infinite loop.   Injecting #UD is somewhat arbitrary,\n\t * but its the least awful option given lack of insight into the guest.\n\t */\n\tif (unlikely(!insn)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Emulate for SEV guests if the insn buffer is not empty.  The buffer\n\t * will be empty if the DecodeAssist microcode cannot fetch bytes for\n\t * the faulting instruction because the code fetch itself faulted, e.g.\n\t * the guest attempted to fetch from emulated MMIO or a guest page\n\t * table used to translate CS:RIP resides in emulated MMIO.\n\t */\n\tif (likely(insn_len))\n\t\treturn true;\n\n\t/*\n\t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.\n\t *\n\t * Errata:\n\t * When CPU raises #NPF on guest data access and vCPU CR4.SMAP=1, it is\n\t * possible that CPU microcode implementing DecodeAssist will fail to\n\t * read guest memory at CS:RIP and vmcb.GuestIntrBytes will incorrectly\n\t * be '0'.  This happens because microcode reads CS:RIP using a _data_\n\t * loap uop with CPL=0 privileges.  If the load hits a SMAP #PF, ucode\n\t * gives up and does not fill the instruction bytes buffer.\n\t *\n\t * As above, KVM reaches this point iff the VM is an SEV guest, the CPU\n\t * supports DecodeAssist, a #NPF was raised, KVM's page fault handler\n\t * triggered emulation (e.g. for MMIO), and the CPU returned 0 in the\n\t * GuestIntrBytes field of the VMCB.\n\t *\n\t * This does _not_ mean that the erratum has been encountered, as the\n\t * DecodeAssist will also fail if the load for CS:RIP hits a legitimate\n\t * #PF, e.g. if the guest attempt to execute from emulated MMIO and\n\t * encountered a reserved/not-present #PF.\n\t *\n\t * To hit the erratum, the following conditions must be true:\n\t *    1. CR4.SMAP=1 (obviously).\n\t *    2. CR4.SMEP=0 || CPL=3.  If SMEP=1 and CPL<3, the erratum cannot\n\t *       have been hit as the guest would have encountered a SMEP\n\t *       violation #PF, not a #NPF.\n\t *    3. The #NPF is not due to a code fetch, in which case failure to\n\t *       retrieve the instruction bytes is legitimate (see abvoe).\n\t *\n\t * In addition, don't apply the erratum workaround if the #NPF occurred\n\t * while translating guest page tables (see below).\n\t */\n\terror_code = to_svm(vcpu)->vmcb->control.exit_info_1;\n\tif (error_code & (PFERR_GUEST_PAGE_MASK | PFERR_FETCH_MASK))\n\t\tgoto resume_guest;\n\n\tcr4 = kvm_read_cr4(vcpu);\n\tsmep = cr4 & X86_CR4_SMEP;\n\tsmap = cr4 & X86_CR4_SMAP;\n\tis_user = svm_get_cpl(vcpu) == 3;\n\tif (smap && (!smep || is_user)) {\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\n\t\t/*\n\t\t * If the fault occurred in userspace, arbitrarily inject #GP\n\t\t * to avoid killing the guest and to hopefully avoid confusing\n\t\t * the guest kernel too much, e.g. injecting #PF would not be\n\t\t * coherent with respect to the guest's page tables.  Request\n\t\t * triple fault if the fault occurred in the kernel as there's\n\t\t * no fault that KVM can inject without confusing the guest.\n\t\t * In practice, the triple fault is moot as no sane SEV kernel\n\t\t * will execute from user memory while also running with SMAP=1.\n\t\t */\n\t\tif (is_user)\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\telse\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\nresume_guest:\n\t/*\n\t * If the erratum was not hit, simply resume the guest and let it fault\n\t * again.  While awful, e.g. the vCPU may get stuck in an infinite loop\n\t * if the fault is at CPL=0, it's the lesser of all evils.  Exiting to\n\t * userspace will kill the guest, and letting the emulator read garbage\n\t * will yield random behavior and potentially corrupt the guest.\n\t *\n\t * Simply resuming the guest is technically not a violation of the SEV\n\t * architecture.  AMD's APM states that all code fetches and page table\n\t * accesses for SEV guest are encrypted, regardless of the C-Bit.  The\n\t * APM also states that encrypted accesses to MMIO are \"ignored\", but\n\t * doesn't explicitly define \"ignored\", i.e. doing nothing and letting\n\t * the guest spin is technically \"ignoring\" the access.\n\t */\n\treturn false;\n}\n\nstatic bool svm_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * TODO: Last condition latch INIT signals on vCPU when\n\t * vCPU is in guest-mode and vmcb12 defines intercept on INIT.\n\t * To properly emulate the INIT intercept,\n\t * svm_check_nested_events() should call nested_svm_vmexit()\n\t * if an INIT signal is pending.\n\t */\n\treturn !gif_set(svm) ||\n\t\t   (vmcb_is_intercept(&svm->vmcb->control, INTERCEPT_INIT));\n}\n\nstatic void svm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tif (!sev_es_guest(vcpu->kvm))\n\t\treturn kvm_vcpu_deliver_sipi_vector(vcpu, vector);\n\n\tsev_vcpu_deliver_sipi_vector(vcpu, vector);\n}\n\nstatic void svm_vm_destroy(struct kvm *kvm)\n{\n\tavic_vm_destroy(kvm);\n\tsev_vm_destroy(kvm);\n}\n\nstatic int svm_vm_init(struct kvm *kvm)\n{\n\tif (!pause_filter_count || !pause_filter_thresh)\n\t\tkvm->arch.pause_in_guest = true;\n\n\tif (enable_apicv) {\n\t\tint ret = avic_vm_init(kvm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct kvm_x86_ops svm_x86_ops __initdata = {\n\t.name = \"kvm_amd\",\n\n\t.hardware_unsetup = svm_hardware_unsetup,\n\t.hardware_enable = svm_hardware_enable,\n\t.hardware_disable = svm_hardware_disable,\n\t.has_emulated_msr = svm_has_emulated_msr,\n\n\t.vcpu_create = svm_vcpu_create,\n\t.vcpu_free = svm_vcpu_free,\n\t.vcpu_reset = svm_vcpu_reset,\n\n\t.vm_size = sizeof(struct kvm_svm),\n\t.vm_init = svm_vm_init,\n\t.vm_destroy = svm_vm_destroy,\n\n\t.prepare_switch_to_guest = svm_prepare_switch_to_guest,\n\t.vcpu_load = svm_vcpu_load,\n\t.vcpu_put = svm_vcpu_put,\n\t.vcpu_blocking = avic_vcpu_blocking,\n\t.vcpu_unblocking = avic_vcpu_unblocking,\n\n\t.update_exception_bitmap = svm_update_exception_bitmap,\n\t.get_msr_feature = svm_get_msr_feature,\n\t.get_msr = svm_get_msr,\n\t.set_msr = svm_set_msr,\n\t.get_segment_base = svm_get_segment_base,\n\t.get_segment = svm_get_segment,\n\t.set_segment = svm_set_segment,\n\t.get_cpl = svm_get_cpl,\n\t.get_cs_db_l_bits = svm_get_cs_db_l_bits,\n\t.set_cr0 = svm_set_cr0,\n\t.post_set_cr3 = sev_post_set_cr3,\n\t.is_valid_cr4 = svm_is_valid_cr4,\n\t.set_cr4 = svm_set_cr4,\n\t.set_efer = svm_set_efer,\n\t.get_idt = svm_get_idt,\n\t.set_idt = svm_set_idt,\n\t.get_gdt = svm_get_gdt,\n\t.set_gdt = svm_set_gdt,\n\t.set_dr7 = svm_set_dr7,\n\t.sync_dirty_debug_regs = svm_sync_dirty_debug_regs,\n\t.cache_reg = svm_cache_reg,\n\t.get_rflags = svm_get_rflags,\n\t.set_rflags = svm_set_rflags,\n\t.get_if_flag = svm_get_if_flag,\n\n\t.flush_tlb_all = svm_flush_tlb_current,\n\t.flush_tlb_current = svm_flush_tlb_current,\n\t.flush_tlb_gva = svm_flush_tlb_gva,\n\t.flush_tlb_guest = svm_flush_tlb_current,\n\n\t.vcpu_pre_run = svm_vcpu_pre_run,\n\t.vcpu_run = svm_vcpu_run,\n\t.handle_exit = svm_handle_exit,\n\t.skip_emulated_instruction = svm_skip_emulated_instruction,\n\t.update_emulated_instruction = NULL,\n\t.set_interrupt_shadow = svm_set_interrupt_shadow,\n\t.get_interrupt_shadow = svm_get_interrupt_shadow,\n\t.patch_hypercall = svm_patch_hypercall,\n\t.inject_irq = svm_inject_irq,\n\t.inject_nmi = svm_inject_nmi,\n\t.queue_exception = svm_queue_exception,\n\t.cancel_injection = svm_cancel_injection,\n\t.interrupt_allowed = svm_interrupt_allowed,\n\t.nmi_allowed = svm_nmi_allowed,\n\t.get_nmi_mask = svm_get_nmi_mask,\n\t.set_nmi_mask = svm_set_nmi_mask,\n\t.enable_nmi_window = svm_enable_nmi_window,\n\t.enable_irq_window = svm_enable_irq_window,\n\t.update_cr8_intercept = svm_update_cr8_intercept,\n\t.refresh_apicv_exec_ctrl = avic_refresh_apicv_exec_ctrl,\n\t.check_apicv_inhibit_reasons = avic_check_apicv_inhibit_reasons,\n\t.apicv_post_state_restore = avic_apicv_post_state_restore,\n\n\t.get_mt_mask = svm_get_mt_mask,\n\t.get_exit_info = svm_get_exit_info,\n\n\t.vcpu_after_set_cpuid = svm_vcpu_after_set_cpuid,\n\n\t.has_wbinvd_exit = svm_has_wbinvd_exit,\n\n\t.get_l2_tsc_offset = svm_get_l2_tsc_offset,\n\t.get_l2_tsc_multiplier = svm_get_l2_tsc_multiplier,\n\t.write_tsc_offset = svm_write_tsc_offset,\n\t.write_tsc_multiplier = svm_write_tsc_multiplier,\n\n\t.load_mmu_pgd = svm_load_mmu_pgd,\n\n\t.check_intercept = svm_check_intercept,\n\t.handle_exit_irqoff = svm_handle_exit_irqoff,\n\n\t.request_immediate_exit = __kvm_request_immediate_exit,\n\n\t.sched_in = svm_sched_in,\n\n\t.nested_ops = &svm_nested_ops,\n\n\t.deliver_interrupt = svm_deliver_interrupt,\n\t.pi_update_irte = avic_pi_update_irte,\n\t.setup_mce = svm_setup_mce,\n\n\t.smi_allowed = svm_smi_allowed,\n\t.enter_smm = svm_enter_smm,\n\t.leave_smm = svm_leave_smm,\n\t.enable_smi_window = svm_enable_smi_window,\n\n\t.mem_enc_ioctl = sev_mem_enc_ioctl,\n\t.mem_enc_register_region = sev_mem_enc_register_region,\n\t.mem_enc_unregister_region = sev_mem_enc_unregister_region,\n\t.guest_memory_reclaimed = sev_guest_memory_reclaimed,\n\n\t.vm_copy_enc_context_from = sev_vm_copy_enc_context_from,\n\t.vm_move_enc_context_from = sev_vm_move_enc_context_from,\n\n\t.can_emulate_instruction = svm_can_emulate_instruction,\n\n\t.apic_init_signal_blocked = svm_apic_init_signal_blocked,\n\n\t.msr_filter_changed = svm_msr_filter_changed,\n\t.complete_emulated_msr = svm_complete_emulated_msr,\n\n\t.vcpu_deliver_sipi_vector = svm_vcpu_deliver_sipi_vector,\n\t.vcpu_get_apicv_inhibit_reasons = avic_vcpu_get_apicv_inhibit_reasons,\n};\n\n/*\n * The default MMIO mask is a single bit (excluding the present bit),\n * which could conflict with the memory encryption bit. Check for\n * memory encryption support and override the default MMIO mask if\n * memory encryption is enabled.\n */\nstatic __init void svm_adjust_mmio_mask(void)\n{\n\tunsigned int enc_bit, mask_bit;\n\tu64 msr, mask;\n\n\t/* If there is no memory encryption support, use existing mask */\n\tif (cpuid_eax(0x80000000) < 0x8000001f)\n\t\treturn;\n\n\t/* If memory encryption is not enabled, use existing mask */\n\trdmsrl(MSR_AMD64_SYSCFG, msr);\n\tif (!(msr & MSR_AMD64_SYSCFG_MEM_ENCRYPT))\n\t\treturn;\n\n\tenc_bit = cpuid_ebx(0x8000001f) & 0x3f;\n\tmask_bit = boot_cpu_data.x86_phys_bits;\n\n\t/* Increment the mask bit if it is the same as the encryption bit */\n\tif (enc_bit == mask_bit)\n\t\tmask_bit++;\n\n\t/*\n\t * If the mask bit location is below 52, then some bits above the\n\t * physical addressing limit will always be reserved, so use the\n\t * rsvd_bits() function to generate the mask. This mask, along with\n\t * the present bit, will be used to generate a page fault with\n\t * PFER.RSV = 1.\n\t *\n\t * If the mask bit location is 52 (or above), then clear the mask.\n\t */\n\tmask = (mask_bit < 52) ? rsvd_bits(mask_bit, 51) | PT_PRESENT_MASK : 0;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, PT_WRITABLE_MASK | PT_USER_MASK);\n}\n\nstatic __init void svm_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\tsupported_xss = 0;\n\n\t/* CPUID 0x80000001 and 0x8000000A (SVM features) */\n\tif (nested) {\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVM);\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMCBCLEAN);\n\n\t\tif (nrips)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NRIPS);\n\n\t\tif (npt_enabled)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NPT);\n\n\t\tif (tsc_scaling)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_TSCRATEMSR);\n\n\t\tif (vls)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_V_VMSAVE_VMLOAD);\n\t\tif (lbrv)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_LBRV);\n\n\t\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER))\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_PAUSEFILTER);\n\n\t\tif (boot_cpu_has(X86_FEATURE_PFTHRESHOLD))\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_PFTHRESHOLD);\n\n\t\tif (vgif)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_VGIF);\n\n\t\t/* Nested VM can receive #VMEXIT instead of triggering #GP */\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVME_ADDR_CHK);\n\t}\n\n\t/* CPUID 0x80000008 */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||\n\t    boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n\n\t/* AMD PMU PERFCTR_CORE CPUID */\n\tif (enable_pmu && boot_cpu_has(X86_FEATURE_PERFCTR_CORE))\n\t\tkvm_cpu_cap_set(X86_FEATURE_PERFCTR_CORE);\n\n\t/* CPUID 0x8000001F (SME/SEV features) */\n\tsev_set_cpu_caps();\n}\n\nstatic __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\tunsigned int order = get_order(IOPM_SIZE);\n\n\t/*\n\t * NX is required for shadow paging and for NPT if the NX huge pages\n\t * mitigation is enabled.\n\t */\n\tif (!boot_cpu_has(X86_FEATURE_NX)) {\n\t\tpr_err_ratelimited(\"NX (Execute Disable) not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tkvm_enable_efer_bits(EFER_NX);\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, order);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << order));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (tsc_scaling) {\n\t\tif (!boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\t\ttsc_scaling = false;\n\t\t} else {\n\t\t\tpr_info(\"TSC scaling supported\\n\");\n\t\t\tkvm_has_tsc_control = true;\n\t\t}\n\t}\n\tkvm_max_tsc_scaling_ratio = SVM_TSC_RATIO_MAX;\n\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\n\ttsc_aux_uret_slot = kvm_add_user_return_msr(MSR_TSC_AUX);\n\n\t/* Check for pause filtering support */\n\tif (!boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tpause_filter_count = 0;\n\t\tpause_filter_thresh = 0;\n\t} else if (!boot_cpu_has(X86_FEATURE_PFTHRESHOLD)) {\n\t\tpause_filter_thresh = 0;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\t/*\n\t * KVM's MMU doesn't support using 2-level paging for itself, and thus\n\t * NPT isn't supported if the host is using 2-level paging since host\n\t * CR4 is unchanged on VMRUN.\n\t */\n\tif (!IS_ENABLED(CONFIG_X86_64) && !IS_ENABLED(CONFIG_X86_PAE))\n\t\tnpt_enabled = false;\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\t/* Force VM NPT level equal to the host's paging level */\n\tkvm_configure_mmu(npt_enabled, get_npt_level(),\n\t\t\t  get_npt_level(), PG_LEVEL_1G);\n\tpr_info(\"kvm: Nested Paging %sabled\\n\", npt_enabled ? \"en\" : \"dis\");\n\n\t/* Setup shadow_me_value and shadow_me_mask */\n\tkvm_mmu_set_me_spte_mask(sme_me_mask, sme_me_mask);\n\n\t/* Note, SEV setup consumes npt_enabled. */\n\tsev_hardware_setup();\n\n\tsvm_hv_hardware_setup();\n\n\tsvm_adjust_mmio_mask();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (nrips) {\n\t\tif (!boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tnrips = false;\n\t}\n\n\tenable_apicv = avic = avic && npt_enabled && (boot_cpu_has(X86_FEATURE_AVIC) || force_avic);\n\n\tif (enable_apicv) {\n\t\tif (!boot_cpu_has(X86_FEATURE_AVIC)) {\n\t\t\tpr_warn(\"AVIC is not supported in CPUID but force enabled\");\n\t\t\tpr_warn(\"Your system might crash and burn\");\n\t\t} else\n\t\t\tpr_info(\"AVIC enabled\\n\");\n\n\t\tamd_iommu_register_ga_log_notifier(&avic_ga_log_notifier);\n\t} else {\n\t\tsvm_x86_ops.vcpu_blocking = NULL;\n\t\tsvm_x86_ops.vcpu_unblocking = NULL;\n\t\tsvm_x86_ops.vcpu_get_apicv_inhibit_reasons = NULL;\n\t}\n\n\tif (vls) {\n\t\tif (!npt_enabled ||\n\t\t    !boot_cpu_has(X86_FEATURE_V_VMSAVE_VMLOAD) ||\n\t\t    !IS_ENABLED(CONFIG_X86_64)) {\n\t\t\tvls = false;\n\t\t} else {\n\t\t\tpr_info(\"Virtual VMLOAD VMSAVE supported\\n\");\n\t\t}\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_SVME_ADDR_CHK))\n\t\tsvm_gp_erratum_intercept = false;\n\n\tif (vgif) {\n\t\tif (!boot_cpu_has(X86_FEATURE_VGIF))\n\t\t\tvgif = false;\n\t\telse\n\t\t\tpr_info(\"Virtual GIF supported\\n\");\n\t}\n\n\tif (lbrv) {\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV))\n\t\t\tlbrv = false;\n\t\telse\n\t\t\tpr_info(\"LBR virtualization supported\\n\");\n\t}\n\n\tif (!enable_pmu)\n\t\tpr_info(\"PMU virtualization is disabled\\n\");\n\n\tsvm_set_cpu_caps();\n\n\t/*\n\t * It seems that on AMD processors PTE's accessed bit is\n\t * being set by the CPU hardware before the NPF vmexit.\n\t * This is not expected behaviour and our tests fail because\n\t * of it.\n\t * A workaround here is to disable support for\n\t * GUEST_MAXPHYADDR < HOST_MAXPHYADDR if NPT is enabled.\n\t * In this case userspace can know if there is support using\n\t * KVM_CAP_SMALLER_MAXPHYADDR extension and decide how to handle\n\t * it\n\t * If future AMD CPU models change the behaviour described above,\n\t * this variable can be changed accordingly\n\t */\n\tallow_smaller_maxphyaddr = !npt_enabled;\n\n\treturn 0;\n\nerr:\n\tsvm_hardware_unsetup();\n\treturn r;\n}\n\n\nstatic struct kvm_x86_init_ops svm_init_ops __initdata = {\n\t.cpu_has_kvm_support = has_svm,\n\t.disabled_by_bios = is_disabled,\n\t.hardware_setup = svm_hardware_setup,\n\t.check_processor_compatibility = svm_check_processor_compat,\n\n\t.runtime_ops = &svm_x86_ops,\n\t.pmu_ops = &amd_pmu_ops,\n};\n\nstatic int __init svm_init(void)\n{\n\t__unused_size_checks();\n\n\treturn kvm_init(&svm_init_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}\n\nstatic void __exit svm_exit(void)\n{\n\tkvm_exit();\n}\n\nmodule_init(svm_init)\nmodule_exit(svm_exit)\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n */\n\n#include <linux/highmem.h>\n#include <linux/hrtimer.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mm.h>\n#include <linux/objtool.h>\n#include <linux/sched.h>\n#include <linux/sched/smt.h>\n#include <linux/slab.h>\n#include <linux/tboot.h>\n#include <linux/trace_events.h>\n#include <linux/entry-kvm.h>\n\n#include <asm/apic.h>\n#include <asm/asm.h>\n#include <asm/cpu.h>\n#include <asm/cpu_device_id.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/fpu/api.h>\n#include <asm/fpu/xstate.h>\n#include <asm/idtentry.h>\n#include <asm/io.h>\n#include <asm/irq_remapping.h>\n#include <asm/kexec.h>\n#include <asm/perf_event.h>\n#include <asm/mmu_context.h>\n#include <asm/mshyperv.h>\n#include <asm/mwait.h>\n#include <asm/spec-ctrl.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n\n#include \"capabilities.h\"\n#include \"cpuid.h\"\n#include \"evmcs.h\"\n#include \"hyperv.h\"\n#include \"kvm_onhyperv.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include \"lapic.h\"\n#include \"mmu.h\"\n#include \"nested.h\"\n#include \"pmu.h\"\n#include \"sgx.h\"\n#include \"trace.h\"\n#include \"vmcs.h\"\n#include \"vmcs12.h\"\n#include \"vmx.h\"\n#include \"x86.h\"\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef MODULE\nstatic const struct x86_cpu_id vmx_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_VMX, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);\n#endif\n\nbool __read_mostly enable_vpid = 1;\nmodule_param_named(vpid, enable_vpid, bool, 0444);\n\nstatic bool __read_mostly enable_vnmi = 1;\nmodule_param_named(vnmi, enable_vnmi, bool, S_IRUGO);\n\nbool __read_mostly flexpriority_enabled = 1;\nmodule_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);\n\nbool __read_mostly enable_ept = 1;\nmodule_param_named(ept, enable_ept, bool, S_IRUGO);\n\nbool __read_mostly enable_unrestricted_guest = 1;\nmodule_param_named(unrestricted_guest,\n\t\t\tenable_unrestricted_guest, bool, S_IRUGO);\n\nbool __read_mostly enable_ept_ad_bits = 1;\nmodule_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);\n\nstatic bool __read_mostly emulate_invalid_guest_state = true;\nmodule_param(emulate_invalid_guest_state, bool, S_IRUGO);\n\nstatic bool __read_mostly fasteoi = 1;\nmodule_param(fasteoi, bool, S_IRUGO);\n\nmodule_param(enable_apicv, bool, S_IRUGO);\n\n/*\n * If nested=1, nested virtualization is supported, i.e., guests may use\n * VMX and be a hypervisor for its own guests. If nested=0, guests may not\n * use VMX instructions.\n */\nstatic bool __read_mostly nested = 1;\nmodule_param(nested, bool, S_IRUGO);\n\nbool __read_mostly enable_pml = 1;\nmodule_param_named(pml, enable_pml, bool, S_IRUGO);\n\nstatic bool __read_mostly dump_invalid_vmcs = 0;\nmodule_param(dump_invalid_vmcs, bool, 0644);\n\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n\n#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL\n\n/* Guest_tsc -> host_tsc conversion requires 64-bit division.  */\nstatic int __read_mostly cpu_preemption_timer_multi;\nstatic bool __read_mostly enable_preemption_timer = 1;\n#ifdef CONFIG_X86_64\nmodule_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);\n#endif\n\nextern bool __read_mostly allow_smaller_maxphyaddr;\nmodule_param(allow_smaller_maxphyaddr, bool, S_IRUGO);\n\n#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)\n\n#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\n#define MSR_IA32_RTIT_STATUS_MASK (~(RTIT_STATUS_FILTEREN | \\\n\tRTIT_STATUS_CONTEXTEN | RTIT_STATUS_TRIGGEREN | \\\n\tRTIT_STATUS_ERROR | RTIT_STATUS_STOPPED | \\\n\tRTIT_STATUS_BYTECNT))\n\n/*\n * List of MSRs that can be directly passed to the guest.\n * In addition to these x2apic and PT MSRs are handled specially.\n */\nstatic u32 vmx_possible_passthrough_msrs[MAX_POSSIBLE_PASSTHROUGH_MSRS] = {\n\tMSR_IA32_SPEC_CTRL,\n\tMSR_IA32_PRED_CMD,\n\tMSR_IA32_TSC,\n#ifdef CONFIG_X86_64\n\tMSR_FS_BASE,\n\tMSR_GS_BASE,\n\tMSR_KERNEL_GS_BASE,\n\tMSR_IA32_XFD,\n\tMSR_IA32_XFD_ERR,\n#endif\n\tMSR_IA32_SYSENTER_CS,\n\tMSR_IA32_SYSENTER_ESP,\n\tMSR_IA32_SYSENTER_EIP,\n\tMSR_CORE_C1_RES,\n\tMSR_CORE_C3_RESIDENCY,\n\tMSR_CORE_C6_RESIDENCY,\n\tMSR_CORE_C7_RESIDENCY,\n};\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * ple_gap:    upper bound on the amount of time between two successive\n *             executions of PAUSE in a loop. Also indicate if ple enabled.\n *             According to test, this time is usually smaller than 128 cycles.\n * ple_window: upper bound on the amount of time a guest is allowed to execute\n *             in a PAUSE loop. Tests indicate that most spinlocks are held for\n *             less than 2^12 cycles\n * Time is measured based on a counter that runs at the same rate as the TSC,\n * refer SDM volume 3b section 21.6.13 & 22.1.3.\n */\nstatic unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;\nmodule_param(ple_gap, uint, 0444);\n\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nmodule_param(ple_window, uint, 0444);\n\n/* Default doubles per-vcpu window every exit. */\nstatic unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(ple_window_grow, uint, 0444);\n\n/* Default resets per-vcpu window every exit to ple_window. */\nstatic unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(ple_window_shrink, uint, 0444);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(ple_window_max, uint, 0444);\n\n/* Default is SYSTEM mode, 1 for host-guest mode */\nint __read_mostly pt_mode = PT_MODE_SYSTEM;\nmodule_param(pt_mode, int, S_IRUGO);\n\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic DEFINE_MUTEX(vmx_l1d_flush_mutex);\n\n/* Storage for pre module init parameter parsing */\nstatic enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush_param = VMENTER_L1D_FLUSH_AUTO;\n\nstatic const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};\n\n#define L1D_CACHE_ORDER 4\nstatic void *vmx_l1d_flush_pages;\n\nstatic int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}\n\nstatic int vmentry_l1d_flush_parse(const char *s)\n{\n\tunsigned int i;\n\n\tif (s) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {\n\t\t\tif (vmentry_l1d_param[i].for_parse &&\n\t\t\t    sysfs_streq(s, vmentry_l1d_param[i].option))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)\n{\n\tint l1tf, ret;\n\n\tl1tf = vmentry_l1d_flush_parse(s);\n\tif (l1tf < 0)\n\t\treturn l1tf;\n\n\tif (!boot_cpu_has(X86_BUG_L1TF))\n\t\treturn 0;\n\n\t/*\n\t * Has vmx_init() run already? If not then this is the pre init\n\t * parameter parsing. In that case just store the value and let\n\t * vmx_init() do the proper setup after enable_ept has been\n\t * established.\n\t */\n\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {\n\t\tvmentry_l1d_flush_param = l1tf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&vmx_l1d_flush_mutex);\n\tret = vmx_setup_l1d_flush(l1tf);\n\tmutex_unlock(&vmx_l1d_flush_mutex);\n\treturn ret;\n}\n\nstatic int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)\n{\n\tif (WARN_ON_ONCE(l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)))\n\t\treturn sprintf(s, \"???\\n\");\n\n\treturn sprintf(s, \"%s\\n\", vmentry_l1d_param[l1tf_vmx_mitigation].option);\n}\n\nstatic const struct kernel_param_ops vmentry_l1d_flush_ops = {\n\t.set = vmentry_l1d_flush_set,\n\t.get = vmentry_l1d_flush_get,\n};\nmodule_param_cb(vmentry_l1d_flush, &vmentry_l1d_flush_ops, NULL, 0644);\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\n\nvoid vmx_vmexit(void);\n\n#define vmx_insn_failed(fmt...)\t\t\\\ndo {\t\t\t\t\t\\\n\tWARN_ONCE(1, fmt);\t\t\\\n\tpr_warn_ratelimited(fmt);\t\\\n} while (0)\n\nasmlinkage void vmread_error(unsigned long field, bool fault)\n{\n\tif (fault)\n\t\tkvm_spurious_fault();\n\telse\n\t\tvmx_insn_failed(\"kvm: vmread failed: field=%lx\\n\", field);\n}\n\nnoinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tvmx_insn_failed(\"kvm: vmwrite failed: field=%lx val=%lx err=%d\\n\",\n\t\t\tfield, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n}\n\nnoinline void vmclear_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmclear failed: %p/%llx\\n\", vmcs, phys_addr);\n}\n\nnoinline void vmptrld_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmptrld failed: %p/%llx\\n\", vmcs, phys_addr);\n}\n\nnoinline void invvpid_error(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tvmx_insn_failed(\"kvm: invvpid failed: ext=0x%lx vpid=%u gva=0x%lx\\n\",\n\t\t\text, vpid, gva);\n}\n\nnoinline void invept_error(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tvmx_insn_failed(\"kvm: invept failed: ext=0x%lx eptp=%llx gpa=0x%llx\\n\",\n\t\t\text, eptp, gpa);\n}\n\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);\n/*\n * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed\n * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.\n */\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nstruct vmcs_config vmcs_config;\nstruct vmx_capability vmx_capability;\n\n#define VMX_SEGMENT_FIELD(seg)\t\t\t\t\t\\\n\t[VCPU_SREG_##seg] = {                                   \\\n\t\t.selector = GUEST_##seg##_SELECTOR,\t\t\\\n\t\t.base = GUEST_##seg##_BASE,\t\t   \t\\\n\t\t.limit = GUEST_##seg##_LIMIT,\t\t   \t\\\n\t\t.ar_bytes = GUEST_##seg##_AR_BYTES,\t   \t\\\n\t}\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}\n\nstatic unsigned long host_idt_base;\n\n#if IS_ENABLED(CONFIG_HYPERV)\nstatic bool __read_mostly enlightened_vmcs = true;\nmodule_param(enlightened_vmcs, bool, 0444);\n\nstatic int hv_enable_direct_tlbflush(struct kvm_vcpu *vcpu)\n{\n\tstruct hv_enlightened_vmcs *evmcs;\n\tstruct hv_partition_assist_pg **p_hv_pa_pg =\n\t\t\t&to_kvm_hv(vcpu->kvm)->hv_pa_pg;\n\t/*\n\t * Synthetic VM-Exit is not enabled in current code and so All\n\t * evmcs in singe VM shares same assist page.\n\t */\n\tif (!*p_hv_pa_pg)\n\t\t*p_hv_pa_pg = kzalloc(PAGE_SIZE, GFP_KERNEL_ACCOUNT);\n\n\tif (!*p_hv_pa_pg)\n\t\treturn -ENOMEM;\n\n\tevmcs = (struct hv_enlightened_vmcs *)to_vmx(vcpu)->loaded_vmcs->vmcs;\n\n\tevmcs->partition_assist_page =\n\t\t__pa(*p_hv_pa_pg);\n\tevmcs->hv_vm_id = (unsigned long)vcpu->kvm;\n\tevmcs->hv_enlightenments_control.nested_flush_hypercall = 1;\n\n\treturn 0;\n}\n\n#endif /* IS_ENABLED(CONFIG_HYPERV) */\n\n/*\n * Comment's format: document - errata name - stepping - processor name.\n * Refer from\n * https://www.virtualbox.org/svn/vbox/trunk/src/VBox/VMM/VMMR0/HMR0.cpp\n */\nstatic u32 vmx_preemption_cpu_tfms[] = {\n/* 323344.pdf - BA86   - D0 - Xeon 7500 Series */\n0x000206E6,\n/* 323056.pdf - AAX65  - C2 - Xeon L3406 */\n/* 322814.pdf - AAT59  - C2 - i7-600, i5-500, i5-400 and i3-300 Mobile */\n/* 322911.pdf - AAU65  - C2 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020652,\n/* 322911.pdf - AAU65  - K0 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020655,\n/* 322373.pdf - AAO95  - B1 - Xeon 3400 Series */\n/* 322166.pdf - AAN92  - B1 - i7-800 and i5-700 Desktop */\n/*\n * 320767.pdf - AAP86  - B1 -\n * i7-900 Mobile Extreme, i7-800 and i7-700 Mobile\n */\n0x000106E5,\n/* 321333.pdf - AAM126 - C0 - Xeon 3500 */\n0x000106A0,\n/* 321333.pdf - AAM126 - C1 - Xeon 3500 */\n0x000106A1,\n/* 320836.pdf - AAJ124 - C0 - i7-900 Desktop Extreme and i7-900 Desktop */\n0x000106A4,\n /* 321333.pdf - AAM126 - D0 - Xeon 3500 */\n /* 321324.pdf - AAK139 - D0 - Xeon 5500 */\n /* 320836.pdf - AAJ124 - D0 - i7-900 Extreme and i7-900 Desktop */\n0x000106A5,\n /* Xeon E3-1220 V2 */\n0x000306A8,\n};\n\nstatic inline bool cpu_has_broken_vmx_preemption_timer(void)\n{\n\tu32 eax = cpuid_eax(0x00000001), i;\n\n\t/* Clear the reserved bits */\n\teax &= ~(0x3U << 14 | 0xfU << 28);\n\tfor (i = 0; i < ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)\n\t\tif (eax == vmx_preemption_cpu_tfms[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}\n\nstatic int possible_passthrough_msr_slot(u32 msr)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_possible_passthrough_msrs); i++)\n\t\tif (vmx_possible_passthrough_msrs[i] == msr)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic bool is_valid_passthrough_msr(u32 msr)\n{\n\tbool r;\n\n\tswitch (msr) {\n\tcase 0x800 ... 0x8ff:\n\t\t/* x2APIC MSRs. These are handled in vmx_update_msr_bitmap_x2apic() */\n\t\treturn true;\n\tcase MSR_IA32_RTIT_STATUS:\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\t/* PT MSRs. These are handled in pt_update_intercept_for_msr() */\n\tcase MSR_LBR_SELECT:\n\tcase MSR_LBR_TOS:\n\tcase MSR_LBR_INFO_0 ... MSR_LBR_INFO_0 + 31:\n\tcase MSR_LBR_NHM_FROM ... MSR_LBR_NHM_FROM + 31:\n\tcase MSR_LBR_NHM_TO ... MSR_LBR_NHM_TO + 31:\n\tcase MSR_LBR_CORE_FROM ... MSR_LBR_CORE_FROM + 8:\n\tcase MSR_LBR_CORE_TO ... MSR_LBR_CORE_TO + 8:\n\t\t/* LBR MSRs. These are handled in vmx_update_intercept_for_lbr_msrs() */\n\t\treturn true;\n\t}\n\n\tr = possible_passthrough_msr_slot(msr) != -ENOENT;\n\n\tWARN(!r, \"Invalid MSR %x, please adapt vmx_possible_passthrough_msrs[]\", msr);\n\n\treturn r;\n}\n\nstruct vmx_uret_msr *vmx_find_uret_msr(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = kvm_find_user_return_msr(msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_uret_msrs[i];\n\treturn NULL;\n}\n\nstatic int vmx_set_guest_uret_msr(struct vcpu_vmx *vmx,\n\t\t\t\t  struct vmx_uret_msr *msr, u64 data)\n{\n\tunsigned int slot = msr - vmx->guest_uret_msrs;\n\tint ret = 0;\n\n\tif (msr->load_into_hardware) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_user_return_msr(slot, data, msr->mask);\n\t\tpreempt_enable();\n\t}\n\tif (!ret)\n\t\tmsr->data = data;\n\treturn ret;\n}\n\n#ifdef CONFIG_KEXEC_CORE\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}\n#endif /* CONFIG_KEXEC_CORE */\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * Ensure all writes to loaded_vmcs, including deleting it from its\n\t * current percpu list, complete before setting loaded_vmcs->cpu to\n\t * -1, otherwise a different cpu can see loaded_vmcs->cpu == -1 first\n\t * and add loaded_vmcs to its percpu list before it's deleted from this\n\t * cpu's list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}\n\nvoid vmx_update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (!vmx_need_pf_intercept(vcpu))\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n        else {\n\t\tint mask = 0, match = 0;\n\n\t\tif (enable_ept && (eb & (1u << PF_VECTOR))) {\n\t\t\t/*\n\t\t\t * If EPT is enabled, #PF is currently only intercepted\n\t\t\t * if MAXPHYADDR is smaller on the guest than on the\n\t\t\t * host.  In that case we only care about present,\n\t\t\t * non-reserved faults.  For vmcs02, however, PFEC_MASK\n\t\t\t * and PFEC_MATCH are set in prepare_vmcs02_rare.\n\t\t\t */\n\t\t\tmask = PFERR_PRESENT_MASK | PFERR_RSVD_MASK;\n\t\t\tmatch = PFERR_PRESENT_MASK;\n\t\t}\n\t\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, mask);\n\t\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, match);\n\t}\n\n\t/*\n\t * Disabling xfd interception indicates that dynamic xfeatures\n\t * might be used in the guest. Always trap #NM in this case\n\t * to save guest xfd_err timely.\n\t */\n\tif (vcpu->arch.xfd_no_write_intercept)\n\t\teb |= (1u << NM_VECTOR);\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}\n\n/*\n * Check if MSR is intercepted for currently loaded MSR bitmap.\n */\nstatic bool msr_write_intercepted(struct vcpu_vmx *vmx, u32 msr)\n{\n\tif (!(exec_controls_get(vmx) & CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn true;\n\n\treturn vmx_test_msr_bitmap_write(vmx->loaded_vmcs->msr_bitmap,\n\t\t\t\t\t MSR_IA32_SPEC_CTRL);\n}\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}\n\nint vmx_find_loadstore_msr_slot(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_loadstore_msr_slot(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_loadstore_msr_slot(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tif (host_val_vmcs != HOST_IA32_EFER)\n\t\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_loadstore_msr_slot(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_loadstore_msr_slot(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == MAX_NR_LOADSTORE_MSRS) ||\n\t    (j < 0 &&  m->host.nr == MAX_NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\tint i;\n\n\t/* Shadow paging assumes NX to be available.  */\n\tif (!enable_ept)\n\t\tguest_efer |= EFER_NX;\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer() ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer, false);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t\treturn false;\n\t}\n\n\ti = kvm_find_user_return_msr(MSR_EFER);\n\tif (i < 0)\n\t\treturn false;\n\n\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\tguest_efer &= ~ignore_bits;\n\tguest_efer |= host_efer & ignore_bits;\n\n\tvmx->guest_uret_msrs[i].data = guest_efer;\n\tvmx->guest_uret_msrs[i].mask = ~ignore_bits;\n\n\treturn true;\n}\n\n#ifdef CONFIG_X86_32\n/*\n * On 32-bit kernels, VM exits still load the FS and GS bases from the\n * VMCS rather than the segment table.  KVM uses this helper to figure\n * out the current bases to poke them into the VMCS before entry.\n */\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}\n#endif\n\nstatic inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}\n\nstatic inline bool pt_output_base_valid(struct kvm_vcpu *vcpu, u64 base)\n{\n\t/* The base must be 128-byte aligned and a legal physical address. */\n\treturn kvm_vcpu_is_legal_aligned_gpa(vcpu, base, 128);\n}\n\nstatic inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}\n\nstatic inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}\n\nstatic void pt_guest_enter(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\t/*\n\t * GUEST_IA32_RTIT_CTL is already set in the VMCS.\n\t * Save host state before VM entry.\n\t */\n\trdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\twrmsrl(MSR_IA32_RTIT_CTL, 0);\n\t\tpt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.num_address_ranges);\n\t\tpt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.num_address_ranges);\n\t}\n}\n\nstatic void pt_guest_exit(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\tpt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.num_address_ranges);\n\t\tpt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.num_address_ranges);\n\t}\n\n\t/*\n\t * KVM requires VM_EXIT_CLEAR_IA32_RTIT_CTL to expose PT to the guest,\n\t * i.e. RTIT_CTL is always cleared on VM-Exit.  Restore it if necessary.\n\t */\n\tif (vmx->pt_desc.host.ctl)\n\t\twrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n}\n\nvoid vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base)\n{\n\tif (unlikely(fs_sel != host->fs_sel)) {\n\t\tif (!(fs_sel & 7))\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, fs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\thost->fs_sel = fs_sel;\n\t}\n\tif (unlikely(gs_sel != host->gs_sel)) {\n\t\tif (!(gs_sel & 7))\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, gs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\thost->gs_sel = gs_sel;\n\t}\n\tif (unlikely(fs_base != host->fs_base)) {\n\t\tvmcs_writel(HOST_FS_BASE, fs_base);\n\t\thost->fs_base = fs_base;\n\t}\n\tif (unlikely(gs_base != host->gs_base)) {\n\t\tvmcs_writel(HOST_GS_BASE, gs_base);\n\t\thost->gs_base = gs_base;\n\t}\n}\n\nvoid vmx_prepare_switch_to_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs_host_state *host_state;\n#ifdef CONFIG_X86_64\n\tint cpu = raw_smp_processor_id();\n#endif\n\tunsigned long fs_base, gs_base;\n\tu16 fs_sel, gs_sel;\n\tint i;\n\n\tvmx->req_immediate_exit = false;\n\n\t/*\n\t * Note that guest MSRs to be saved/restored can also be changed\n\t * when guest state is loaded. This happens when guest transitions\n\t * to/from long-mode by setting MSR_EFER.LMA.\n\t */\n\tif (!vmx->guest_uret_msrs_loaded) {\n\t\tvmx->guest_uret_msrs_loaded = true;\n\t\tfor (i = 0; i < kvm_nr_uret_msrs; ++i) {\n\t\t\tif (!vmx->guest_uret_msrs[i].load_into_hardware)\n\t\t\t\tcontinue;\n\n\t\t\tkvm_set_user_return_msr(i,\n\t\t\t\t\t\tvmx->guest_uret_msrs[i].data,\n\t\t\t\t\t\tvmx->guest_uret_msrs[i].mask);\n\t\t}\n\t}\n\n    \tif (vmx->nested.need_vmcs12_to_shadow_sync)\n\t\tnested_sync_vmcs12_to_shadow(vcpu);\n\n\tif (vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\thost_state->ldt_sel = kvm_read_ldt();\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, host_state->ds_sel);\n\tsavesegment(es, host_state->es_sel);\n\n\tgs_base = cpu_kernelmode_gs_base(cpu);\n\tif (likely(is_64bit_mm(current->mm))) {\n\t\tcurrent_save_fsgs();\n\t\tfs_sel = current->thread.fsindex;\n\t\tgs_sel = current->thread.gsindex;\n\t\tfs_base = current->thread.fsbase;\n\t\tvmx->msr_host_kernel_gs_base = current->thread.gsbase;\n\t} else {\n\t\tsavesegment(fs, fs_sel);\n\t\tsavesegment(gs, gs_sel);\n\t\tfs_base = read_msr(MSR_FS_BASE);\n\t\tvmx->msr_host_kernel_gs_base = read_msr(MSR_KERNEL_GS_BASE);\n\t}\n\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#else\n\tsavesegment(fs, fs_sel);\n\tsavesegment(gs, gs_sel);\n\tfs_base = segment_base(fs_sel);\n\tgs_base = segment_base(gs_sel);\n#endif\n\n\tvmx_set_host_fs_gs(host_state, fs_sel, gs_sel, fs_base, gs_base);\n\tvmx->guest_state_loaded = true;\n}\n\nstatic void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs_host_state *host_state;\n\n\tif (!vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (host_state->ldt_sel || (host_state->gs_sel & 7)) {\n\t\tkvm_load_ldt(host_state->ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(host_state->gs_sel);\n#else\n\t\tloadsegment(gs, host_state->gs_sel);\n#endif\n\t}\n\tif (host_state->fs_sel & 7)\n\t\tloadsegment(fs, host_state->fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(host_state->ds_sel | host_state->es_sel)) {\n\t\tloadsegment(ds, host_state->ds_sel);\n\t\tloadsegment(es, host_state->es_sel);\n\t}\n#endif\n\tinvalidate_tss_limit();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tload_fixmap_gdt(raw_smp_processor_id());\n\tvmx->guest_state_loaded = false;\n\tvmx->guest_uret_msrs_loaded = false;\n}\n\n#ifdef CONFIG_X86_64\nstatic u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\tpreempt_enable();\n\treturn vmx->msr_guest_kernel_gs_base;\n}\n\nstatic void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}\n#endif\n\nvoid vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu,\n\t\t\tstruct loaded_vmcs *buddy)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\tstruct vmcs *prev;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tprev = per_cpu(current_vmcs, cpu);\n\tif (prev != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\n\t\t/*\n\t\t * No indirect branch prediction barrier needed when switching\n\t\t * the active VMCS within a guest, e.g. on nested VM-Enter.\n\t\t * The L1 VMM can protect itself with retpolines, IBPB or IBRS.\n\t\t */\n\t\tif (!buddy || WARN_ON_ONCE(buddy->vmcs != prev))\n\t\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\n\t\t/*\n\t\t * Flush all EPTP/VPID contexts, the new pCPU may have stale\n\t\t * TLB entries from its previous association with the vCPU.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\tif (IS_ENABLED(CONFIG_IA32_EMULATION) || IS_ENABLED(CONFIG_X86_32)) {\n\t\t\t/* 22.2.3 */\n\t\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP,\n\t\t\t\t    (unsigned long)(cpu_entry_stack(cpu) + 1));\n\t\t}\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put(), but assumes\n * vcpu mutex is already taken.\n */\nstatic void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_vcpu_load_vmcs(vcpu, cpu, NULL);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\n\tvmx->host_debugctlmsr = get_debugctlmsr();\n}\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\tvmx_prepare_switch_to_host(to_vmx(vcpu));\n}\n\nbool vmx_emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !vmx_guest_state_valid(vcpu);\n}\n\nunsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}\n\nvoid vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long old_rflags;\n\n\tif (is_unrestricted_guest(vcpu)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\tvmx->rflags = rflags;\n\t\tvmcs_writel(GUEST_RFLAGS, rflags);\n\t\treturn;\n\t}\n\n\told_rflags = vmx_get_rflags(vcpu);\n\tvmx->rflags = rflags;\n\tif (vmx->rmode.vm86_active) {\n\t\tvmx->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n\n\tif ((old_rflags ^ vmx->rflags) & X86_EFLAGS_VM)\n\t\tvmx->emulation_required = vmx_emulation_required(vcpu);\n}\n\nstatic bool vmx_get_if_flag(struct kvm_vcpu *vcpu)\n{\n\treturn vmx_get_rflags(vcpu) & X86_EFLAGS_IF;\n}\n\nu32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n\nvoid vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n\nstatic int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long value;\n\n\t/*\n\t * Any MSR write that attempts to change bits marked reserved will\n\t * case a #GP fault.\n\t */\n\tif (data & vmx->pt_desc.ctl_bitmask)\n\t\treturn 1;\n\n\t/*\n\t * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will\n\t * result in a #GP unless the same write also clears TraceEn.\n\t */\n\tif ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&\n\t\t((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))\n\t\treturn 1;\n\n\t/*\n\t * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit\n\t * and FabricEn would cause #GP, if\n\t * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0\n\t */\n\tif ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&\n\t\t!(data & RTIT_CTL_FABRIC_EN) &&\n\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output))\n\t\treturn 1;\n\n\t/*\n\t * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that\n\t * utilize encodings marked reserved will cause a #GP fault.\n\t */\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc) &&\n\t\t\t!test_bit((data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cycle_thresholds);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET, &value))\n\t\treturn 1;\n\n\t/*\n\t * If ADDRx_CFG is reserved or the encodings is >2 will\n\t * cause a #GP fault.\n\t */\n\tvalue = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 1)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 2)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 3)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 4)) || (value > 2))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool vmx_can_emulate_instruction(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\t/*\n\t * Emulation of instructions in SGX enclaves is impossible as RIP does\n\t * not point at the failing instruction, and even if it did, the code\n\t * stream is inaccessible.  Inject #UD instead of exiting to userspace\n\t * so that guest userspace can't DoS the guest simply by triggering\n\t * emulation (enclaves are CPL3 only).\n\t */\n\tif (to_vmx(vcpu)->exit_reason.enclave_mode) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunion vmx_exit_reason exit_reason = to_vmx(vcpu)->exit_reason;\n\tunsigned long rip, orig_rip;\n\tu32 instr_len;\n\n\t/*\n\t * Using VMCS.VM_EXIT_INSTRUCTION_LEN on EPT misconfig depends on\n\t * undefined behavior: Intel's SDM doesn't mandate the VMCS field be\n\t * set when EPT misconfig occurs.  In practice, real hardware updates\n\t * VM_EXIT_INSTRUCTION_LEN on EPT misconfig, but other hypervisors\n\t * (namely Hyper-V) don't set it due to it being undefined behavior,\n\t * i.e. we end up advancing IP with some random value.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||\n\t    exit_reason.basic != EXIT_REASON_EPT_MISCONFIG) {\n\t\tinstr_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\n\t\t/*\n\t\t * Emulating an enclave's instructions isn't supported as KVM\n\t\t * cannot access the enclave's memory or its true RIP, e.g. the\n\t\t * vmcs.GUEST_RIP points at the exit point of the enclave, not\n\t\t * the RIP that actually triggered the VM-Exit.  But, because\n\t\t * most instructions that cause VM-Exit will #UD in an enclave,\n\t\t * most instruction-based VM-Exits simply do not occur.\n\t\t *\n\t\t * There are a few exceptions, notably the debug instructions\n\t\t * INT1ICEBRK and INT3, as they are allowed in debug enclaves\n\t\t * and generate #DB/#BP as expected, which KVM might intercept.\n\t\t * But again, the CPU does the dirty work and saves an instr\n\t\t * length of zero so VMMs don't shoot themselves in the foot.\n\t\t * WARN if KVM tries to skip a non-zero length instruction on\n\t\t * a VM-Exit from an enclave.\n\t\t */\n\t\tif (!instr_len)\n\t\t\tgoto rip_updated;\n\n\t\tWARN(exit_reason.enclave_mode,\n\t\t     \"KVM: skipping instruction after SGX enclave VM-Exit\");\n\n\t\torig_rip = kvm_rip_read(vcpu);\n\t\trip = orig_rip + instr_len;\n#ifdef CONFIG_X86_64\n\t\t/*\n\t\t * We need to mask out the high 32 bits of RIP if not in 64-bit\n\t\t * mode, but just finding out that we are in 64-bit mode is\n\t\t * quite expensive.  Only do it if there was a carry.\n\t\t */\n\t\tif (unlikely(((rip ^ orig_rip) >> 31) == 3) && !is_64_bit_mode(vcpu))\n\t\t\trip = (u32)rip;\n#endif\n\t\tkvm_rip_write(vcpu, rip);\n\t} else {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t}\n\nrip_updated:\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}\n\n/*\n * Recognizes a pending MTF VM-exit and records the nested state for later\n * delivery.\n */\nstatic void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn;\n\n\t/*\n\t * Per the SDM, MTF takes priority over debug-trap exceptions besides\n\t * T-bit traps. As instruction emulation is completed (i.e. at the\n\t * instruction boundary), any #DB exception pending delivery must be a\n\t * debug-trap. Record the pending MTF state to be delivered in\n\t * vmx_check_nested_events().\n\t */\n\tif (nested_cpu_has_mtf(vmcs12) &&\n\t    (!vcpu->arch.exception.pending ||\n\t     vcpu->arch.exception.nr == DB_VECTOR))\n\t\tvmx->nested.mtf_pending = true;\n\telse\n\t\tvmx->nested.mtf_pending = false;\n}\n\nstatic int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tkvm_deliver_exception_payload(vcpu);\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, nr, inc_eip);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(vmx->emulation_required);\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n\n\tvmx_clear_hlt(vcpu);\n}\n\nstatic void vmx_setup_uret_msr(struct vcpu_vmx *vmx, unsigned int msr,\n\t\t\t       bool load_into_hardware)\n{\n\tstruct vmx_uret_msr *uret_msr;\n\n\turet_msr = vmx_find_uret_msr(vmx, msr);\n\tif (!uret_msr)\n\t\treturn;\n\n\turet_msr->load_into_hardware = load_into_hardware;\n}\n\n/*\n * Configuring user return MSRs to automatically save, load, and restore MSRs\n * that need to be shoved into hardware when running the guest.  Note, omitting\n * an MSR here does _NOT_ mean it's not emulated, only that it will not be\n * loaded into hardware when running the guest.\n */\nstatic void vmx_setup_uret_msrs(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tbool load_syscall_msrs;\n\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tload_syscall_msrs = is_long_mode(&vmx->vcpu) &&\n\t\t\t    (vmx->vcpu.arch.efer & EFER_SCE);\n\n\tvmx_setup_uret_msr(vmx, MSR_STAR, load_syscall_msrs);\n\tvmx_setup_uret_msr(vmx, MSR_LSTAR, load_syscall_msrs);\n\tvmx_setup_uret_msr(vmx, MSR_SYSCALL_MASK, load_syscall_msrs);\n#endif\n\tvmx_setup_uret_msr(vmx, MSR_EFER, update_transition_efer(vmx));\n\n\tvmx_setup_uret_msr(vmx, MSR_TSC_AUX,\n\t\t\t   guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP) ||\n\t\t\t   guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDPID));\n\n\t/*\n\t * hle=0, rtm=0, tsx_ctrl=1 can be found with some combinations of new\n\t * kernel and old userspace.  If those guests run on a tsx=off host, do\n\t * allow guests to use TSX_CTRL, but don't change the value in hardware\n\t * so that TSX remains always disabled.\n\t */\n\tvmx_setup_uret_msr(vmx, MSR_IA32_TSX_CTRL, boot_cpu_has(X86_FEATURE_RTM));\n\n\t/*\n\t * The set of MSRs to load may have changed, reload MSRs before the\n\t * next VM-Enter.\n\t */\n\tvmx->guest_uret_msrs_loaded = false;\n}\n\nu64 vmx_get_l2_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vmcs12->tsc_offset;\n\n\treturn 0;\n}\n\nu64 vmx_get_l2_tsc_multiplier(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING) &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_TSC_SCALING))\n\t\treturn vmcs12->tsc_multiplier;\n\n\treturn kvm_default_tsc_scaling_ratio;\n}\n\nstatic void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tvmcs_write64(TSC_OFFSET, offset);\n}\n\nstatic void vmx_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 multiplier)\n{\n\tvmcs_write64(TSC_MULTIPLIER, multiplier);\n}\n\n/*\n * nested_vmx_allowed() checks whether a guest should be allowed to use VMX\n * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for\n * all guests if the \"nested\" module option is off, and can also be disabled\n * for a single guest by disabling its VMX cpuid bit.\n */\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}\n\nstatic inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}\n\nstatic int vmx_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested)\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(&vmcs_config.nested, msr->index, &msr->data);\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\tmsr->data = vmx_get_perf_capabilities();\n\t\treturn 0;\n\tdefault:\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n}\n\n/*\n * Reads an msr value (of 'msr_info->index') into 'msr_info->data'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmx_uret_msr *msr;\n\tu32 index;\n\n\tswitch (msr_info->index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = vmx_read_guest_kernel_gs_base(vmx);\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tgoto find_uret_msr;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vmx->msr_ia32_umwait_control;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = to_vmx(vcpu)->spec_ctrl;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vmx->msr_ia32_feature_control &\n\t\t      FEAT_CTL_LMCE_ENABLED))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.mcg_ext_ctl;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tmsr_info->data = vmx->msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_SGXLEPUBKEYHASH0 ... MSR_IA32_SGXLEPUBKEYHASH3:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))\n\t\t\treturn 1;\n\t\tmsr_info->data = to_vmx(vcpu)->msr_ia32_sgxlepubkeyhash\n\t\t\t[msr_info->index - MSR_IA32_SGXLEPUBKEYHASH0];\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\tif (vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,\n\t\t\t\t    &msr_info->data))\n\t\t\treturn 1;\n\t\t/*\n\t\t * Enlightened VMCS v1 doesn't have certain VMCS fields but\n\t\t * instead of just ignoring the features, different Hyper-V\n\t\t * versions are either trying to use them and fail or do some\n\t\t * sanity checking and refuse to boot. Filter all unsupported\n\t\t * features out.\n\t\t */\n\t\tif (!msr_info->host_initiated &&\n\t\t    vmx->nested.enlightened_vmcs_enabled)\n\t\t\tnested_evmcs_filter_control_msr(msr_info->index,\n\t\t\t\t\t\t\t&msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.ctl;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.status;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.cr3_match;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_base;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_mask;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t    (index >= 2 * vmx->pt_desc.num_address_ranges))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_b[index / 2];\n\t\telse\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_a[index / 2];\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\t\tbreak;\n\tdefault:\n\tfind_uret_msr:\n\t\tmsr = vmx_find_uret_msr(vmx, msr_info->index);\n\t\tif (msr) {\n\t\t\tmsr_info->data = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}\n\nstatic u64 nested_vmx_truncate_sysenter_addr(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t    u64 data)\n{\n#ifdef CONFIG_X86_64\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\treturn (u32)data;\n#endif\n\treturn (unsigned long)data;\n}\n\nstatic u64 vcpu_supported_debugctl(struct kvm_vcpu *vcpu)\n{\n\tu64 debugctl = vmx_supported_debugctl();\n\n\tif (!intel_pmu_lbr_is_enabled(vcpu))\n\t\tdebugctl &= ~DEBUGCTLMSR_LBR_MASK;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))\n\t\tdebugctl &= ~DEBUGCTLMSR_BUS_LOCK_DETECT;\n\n\treturn debugctl;\n}\n\n/*\n * Writes msr value into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmx_uret_msr *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\tu32 index;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_write_guest_kernel_gs_base(vmx, data);\n\t\tbreak;\n\tcase MSR_IA32_XFD:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\t/*\n\t\t * Always intercepting WRMSR could incur non-negligible\n\t\t * overhead given xfd might be changed frequently in\n\t\t * guest context switch. Disable write interception\n\t\t * upon the first write with a non-zero value (indicating\n\t\t * potential usage on dynamic xfeatures). Also update\n\t\t * exception bitmap to trap #NM for proper virtualization\n\t\t * of guest xfd_err.\n\t\t */\n\t\tif (!ret && data) {\n\t\t\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_XFD,\n\t\t\t\t\t\t      MSR_TYPE_RW);\n\t\t\tvcpu->arch.xfd_no_write_intercept = true;\n\t\t\tvmx_update_exception_bitmap(vcpu);\n\t\t}\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_cs = data;\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tdata = nested_vmx_truncate_sysenter_addr(vcpu, data);\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_eip = data;\n\t\t}\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tdata = nested_vmx_truncate_sysenter_addr(vcpu, data);\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_esp = data;\n\t\t}\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR: {\n\t\tu64 invalid = data & ~vcpu_supported_debugctl(vcpu);\n\t\tif (invalid & (DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR)) {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu, \"%s: BTF|LBR in IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t\t\t    __func__, data);\n\t\t\tdata &= ~(DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR);\n\t\t\tinvalid &= ~(DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR);\n\t\t}\n\n\t\tif (invalid)\n\t\t\treturn 1;\n\n\t\tif (is_guest_mode(vcpu) && get_vmcs12(vcpu)->vm_exit_controls &\n\t\t\t\t\t\tVM_EXIT_SAVE_DEBUG_CONTROLS)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_debugctl = data;\n\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, data);\n\t\tif (intel_pmu_lbr_is_enabled(vcpu) && !to_vmx(vcpu)->lbr_desc.event &&\n\t\t    (data & DEBUGCTLMSR_LBR))\n\t\t\tintel_pmu_create_guest_lbr_event(vcpu);\n\t\treturn 0;\n\t}\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data & PAGE_MASK, vcpu) ||\n\t\t    (data & MSR_IA32_BNDCFGS_RSVD))\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\t/* The reserved bit 1 and non-32 bit [63:32] should be zero */\n\t\tif (data & (BIT_ULL(1) | GENMASK_ULL(63, 32)))\n\t\t\treturn 1;\n\n\t\tvmx->msr_ia32_umwait_control = data;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (kvm_spec_ctrl_test_value(data))\n\t\t\treturn 1;\n\n\t\tvmx->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging. We update the vmcs01 here for L1 as well\n\t\t * since it will end up touching the MSR anyway now.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vcpu,\n\t\t\t\t\t      MSR_IA32_SPEC_CTRL,\n\t\t\t\t\t      MSR_TYPE_RW);\n\t\tbreak;\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tif (data & ~(TSX_CTRL_RTM_DISABLE | TSX_CTRL_CPUID_CLEAR))\n\t\t\treturn 1;\n\t\tgoto find_uret_msr;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_pred_cmd_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_IBPB))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_PRED_CMD, MSR_TYPE_W);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_pat_valid(data))\n\t\t\treturn 1;\n\n\t\tif (is_guest_mode(vcpu) &&\n\t\t    get_vmcs12(vcpu)->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_pat = data;\n\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif ((!msr_info->host_initiated &&\n\t\t     !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t       FEAT_CTL_LMCE_ENABLED)) ||\n\t\t    (data & ~MCG_EXT_CTL_LMCE_EN))\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ext_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tif (!vmx_feature_control_msr_valid(vcpu, data) ||\n\t\t    (to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t     FEAT_CTL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\n\t\t/* SGX may be enabled/disabled by guest's firmware */\n\t\tvmx_write_encls_bitmap(vcpu, NULL);\n\t\tbreak;\n\tcase MSR_IA32_SGXLEPUBKEYHASH0 ... MSR_IA32_SGXLEPUBKEYHASH3:\n\t\t/*\n\t\t * On real hardware, the LE hash MSRs are writable before\n\t\t * the firmware sets bit 0 in MSR 0x7a (\"activating\" SGX),\n\t\t * at which point SGX related bits in IA32_FEATURE_CONTROL\n\t\t * become writable.\n\t\t *\n\t\t * KVM does not emulate SGX activation for simplicity, so\n\t\t * allow writes to the LE hash MSRs if IA32_FEATURE_CONTROL\n\t\t * is unlocked.  This is technically not architectural\n\t\t * behavior, but it's close enough.\n\t\t */\n\t\tif (!msr_info->host_initiated &&\n\t\t    (!guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC) ||\n\t\t    ((vmx->msr_ia32_feature_control & FEAT_CTL_LOCKED) &&\n\t\t    !(vmx->msr_ia32_feature_control & FEAT_CTL_SGX_LC_ENABLED))))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_sgxlepubkeyhash\n\t\t\t[msr_index - MSR_IA32_SGXLEPUBKEYHASH0] = data;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1; /* they are read-only */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_set_vmx_msr(vcpu, msr_index, data);\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\tvmx_rtit_ctl_check(vcpu, data) ||\n\t\t\tvmx->nested.vmxon)\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, data);\n\t\tvmx->pt_desc.guest.ctl = data;\n\t\tpt_update_intercept_for_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (data & MSR_IA32_RTIT_STATUS_MASK)\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.status = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.cr3_match = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tif (!pt_output_base_valid(vcpu, data))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_base = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_mask = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (index >= 2 * vmx->pt_desc.num_address_ranges)\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data, vcpu))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tvmx->pt_desc.guest.addr_b[index / 2] = data;\n\t\telse\n\t\t\tvmx->pt_desc.guest.addr_a[index / 2] = data;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\tif (data && !vcpu_to_pmu(vcpu)->version)\n\t\t\treturn 1;\n\t\tif (data & PMU_CAP_LBR_FMT) {\n\t\t\tif ((data & PMU_CAP_LBR_FMT) !=\n\t\t\t    (vmx_get_perf_capabilities() & PMU_CAP_LBR_FMT))\n\t\t\t\treturn 1;\n\t\t\tif (!intel_pmu_lbr_is_compatible(vcpu))\n\t\t\t\treturn 1;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\n\tdefault:\n\tfind_uret_msr:\n\t\tmsr = vmx_find_uret_msr(vmx, msr_index);\n\t\tif (msr)\n\t\t\tret = vmx_set_guest_uret_msr(vmx, msr, data);\n\t\telse\n\t\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tunsigned long guest_owned_bits;\n\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tcase VCPU_EXREG_CR0:\n\t\tguest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\t\tvcpu->arch.cr0 &= ~guest_owned_bits;\n\t\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & guest_owned_bits;\n\t\tbreak;\n\tcase VCPU_EXREG_CR3:\n\t\t/*\n\t\t * When intercepting CR3 loads, e.g. for shadowing paging, KVM's\n\t\t * CR3 is loaded into hardware, not the guest's CR3.\n\t\t */\n\t\tif (!(exec_controls_get(to_vmx(vcpu)) & CPU_BASED_CR3_LOAD_EXITING))\n\t\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t\tbreak;\n\tcase VCPU_EXREG_CR4:\n\t\tguest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\t\tvcpu->arch.cr4 &= ~guest_owned_bits;\n\t\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & guest_owned_bits;\n\t\tbreak;\n\tdefault:\n\t\tKVM_BUG_ON(1, vcpu->kvm);\n\t\tbreak;\n\t}\n}\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\treturn !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t       !boot_cpu_has(X86_FEATURE_VMX);\n}\n\nstatic int kvm_cpu_vmxon(u64 vmxon_pointer)\n{\n\tu64 msr;\n\n\tcr4_set_bits(X86_CR4_VMXE);\n\n\tasm_volatile_goto(\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : : fault);\n\treturn 0;\n\nfault:\n\tWARN_ONCE(1, \"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\",\n\t\t  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);\n\tcr4_clear_bits(X86_CR4_VMXE);\n\n\treturn -EFAULT;\n}\n\nstatic int vmx_hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tint r;\n\n\tif (cr4_read_shadow() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\t/*\n\t * This can happen if we hot-added a CPU but failed to allocate\n\t * VP assist page for it.\n\t */\n\tif (static_branch_unlikely(&enable_evmcs) &&\n\t    !hv_get_vp_assist_page(cpu))\n\t\treturn -EFAULT;\n\n\tintel_pt_handle_vmx(1);\n\n\tr = kvm_cpu_vmxon(phys_addr);\n\tif (r) {\n\t\tintel_pt_handle_vmx(0);\n\t\treturn r;\n\t}\n\n\tif (enable_ept)\n\t\tept_sync_global();\n\n\treturn 0;\n}\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}\n\nstatic void vmx_hardware_disable(void)\n{\n\tvmclear_local_loaded_vmcss();\n\n\tif (cpu_vmxoff())\n\t\tkvm_spurious_fault();\n\n\tintel_pt_handle_vmx(0);\n}\n\n/*\n * There is no X86_FEATURE for SGX yet, but anyway we need to query CPUID\n * directly instead of going through cpu_has(), to ensure KVM is trapping\n * ENCLS whenever it's supported in hardware.  It does not matter whether\n * the host OS supports or has enabled SGX.\n */\nstatic bool cpu_has_sgx(void)\n{\n\treturn cpuid_eax(0) >= 0x12 && (cpuid_eax(0x12) & BIT(0));\n}\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}\n\nstatic __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,\n\t\t\t\t    struct vmx_capability *vmx_cap)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 min, opt, min2, opt2;\n\tu32 _pin_based_exec_control = 0;\n\tu32 _cpu_based_exec_control = 0;\n\tu32 _cpu_based_2nd_exec_control = 0;\n\tu32 _vmexit_control = 0;\n\tu32 _vmentry_control = 0;\n\n\tmemset(vmcs_conf, 0, sizeof(*vmcs_conf));\n\tmin = CPU_BASED_HLT_EXITING |\n#ifdef CONFIG_X86_64\n\t      CPU_BASED_CR8_LOAD_EXITING |\n\t      CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t      CPU_BASED_CR3_LOAD_EXITING |\n\t      CPU_BASED_CR3_STORE_EXITING |\n\t      CPU_BASED_UNCOND_IO_EXITING |\n\t      CPU_BASED_MOV_DR_EXITING |\n\t      CPU_BASED_USE_TSC_OFFSETTING |\n\t      CPU_BASED_MWAIT_EXITING |\n\t      CPU_BASED_MONITOR_EXITING |\n\t      CPU_BASED_INVLPG_EXITING |\n\t      CPU_BASED_RDPMC_EXITING;\n\n\topt = CPU_BASED_TPR_SHADOW |\n\t      CPU_BASED_USE_MSR_BITMAPS |\n\t      CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,\n\t\t\t\t&_cpu_based_exec_control) < 0)\n\t\treturn -EIO;\n#ifdef CONFIG_X86_64\n\tif (_cpu_based_exec_control & CPU_BASED_TPR_SHADOW)\n\t\t_cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &\n\t\t\t\t\t   ~CPU_BASED_CR8_STORE_EXITING;\n#endif\n\tif (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {\n\t\tmin2 = 0;\n\t\topt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\t\tSECONDARY_EXEC_ENABLE_EPT |\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING |\n\t\t\tSECONDARY_EXEC_DESC |\n\t\t\tSECONDARY_EXEC_ENABLE_RDTSCP |\n\t\t\tSECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\t\tSECONDARY_EXEC_XSAVES |\n\t\t\tSECONDARY_EXEC_RDSEED_EXITING |\n\t\t\tSECONDARY_EXEC_RDRAND_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_PML |\n\t\t\tSECONDARY_EXEC_TSC_SCALING |\n\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |\n\t\t\tSECONDARY_EXEC_PT_USE_GPA |\n\t\t\tSECONDARY_EXEC_PT_CONCEAL_VMX |\n\t\t\tSECONDARY_EXEC_ENABLE_VMFUNC |\n\t\t\tSECONDARY_EXEC_BUS_LOCK_DETECTION;\n\t\tif (cpu_has_sgx())\n\t\t\topt2 |= SECONDARY_EXEC_ENCLS_EXITING;\n\t\tif (adjust_vmx_controls(min2, opt2,\n\t\t\t\t\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\t\t\t\t\t&_cpu_based_2nd_exec_control) < 0)\n\t\t\treturn -EIO;\n\t}\n#ifndef CONFIG_X86_64\n\tif (!(_cpu_based_2nd_exec_control &\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;\n#endif\n\n\tif (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_2nd_exec_control &= ~(\n\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\n\trdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP,\n\t\t&vmx_cap->ept, &vmx_cap->vpid);\n\n\tif (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {\n\t\t/* CR3 accesses and invlpg don't need to cause VM Exits when EPT\n\t\t   enabled */\n\t\t_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t     CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\t\t     CPU_BASED_INVLPG_EXITING);\n\t} else if (vmx_cap->ept) {\n\t\tvmx_cap->ept = 0;\n\t\tpr_warn_once(\"EPT CAP should not exist if not support \"\n\t\t\t\t\"1-setting enable EPT VM-execution control\\n\");\n\t}\n\tif (!(_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_VPID) &&\n\t\tvmx_cap->vpid) {\n\t\tvmx_cap->vpid = 0;\n\t\tpr_warn_once(\"VPID CAP should not exist if not support \"\n\t\t\t\t\"1-setting enable VPID VM-execution control\\n\");\n\t}\n\n\tmin = VM_EXIT_SAVE_DEBUG_CONTROLS | VM_EXIT_ACK_INTR_ON_EXIT;\n#ifdef CONFIG_X86_64\n\tmin |= VM_EXIT_HOST_ADDR_SPACE_SIZE;\n#endif\n\topt = VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL |\n\t      VM_EXIT_LOAD_IA32_PAT |\n\t      VM_EXIT_LOAD_IA32_EFER |\n\t      VM_EXIT_CLEAR_BNDCFGS |\n\t      VM_EXIT_PT_CONCEAL_PIP |\n\t      VM_EXIT_CLEAR_IA32_RTIT_CTL;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t&_vmexit_control) < 0)\n\t\treturn -EIO;\n\n\tmin = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;\n\topt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR |\n\t\t PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,\n\t\t\t\t&_pin_based_exec_control) < 0)\n\t\treturn -EIO;\n\n\tif (cpu_has_broken_vmx_preemption_timer())\n\t\t_pin_based_exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (!(_cpu_based_2nd_exec_control &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))\n\t\t_pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tmin = VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\topt = VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL |\n\t      VM_ENTRY_LOAD_IA32_PAT |\n\t      VM_ENTRY_LOAD_IA32_EFER |\n\t      VM_ENTRY_LOAD_BNDCFGS |\n\t      VM_ENTRY_PT_CONCEAL_PIP |\n\t      VM_ENTRY_LOAD_IA32_RTIT_CTL;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\t&_vmentry_control) < 0)\n\t\treturn -EIO;\n\n\t/*\n\t * Some cpus support VM_{ENTRY,EXIT}_IA32_PERF_GLOBAL_CTRL but they\n\t * can't be used due to an errata where VM Exit may incorrectly clear\n\t * IA32_PERF_GLOBAL_CTRL[34:32].  Workaround the errata by using the\n\t * MSR load mechanism to switch IA32_PERF_GLOBAL_CTRL.\n\t */\n\tif (boot_cpu_data.x86 == 0x6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 26: /* AAK155 */\n\t\tcase 30: /* AAP115 */\n\t\tcase 37: /* AAT100 */\n\t\tcase 44: /* BC86,AAY89,BD102 */\n\t\tcase 46: /* BA97 */\n\t\t\t_vmentry_control &= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\t\t_vmexit_control &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\t\tpr_warn_once(\"kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL \"\n\t\t\t\t\t\"does not work properly. Using workaround\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\trdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);\n\n\t/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */\n\tif ((vmx_msr_high & 0x1fff) > PAGE_SIZE)\n\t\treturn -EIO;\n\n#ifdef CONFIG_X86_64\n\t/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */\n\tif (vmx_msr_high & (1u<<16))\n\t\treturn -EIO;\n#endif\n\n\t/* Require Write-Back (WB) memory type for VMCS accesses. */\n\tif (((vmx_msr_high >> 18) & 15) != 6)\n\t\treturn -EIO;\n\n\tvmcs_conf->size = vmx_msr_high & 0x1fff;\n\tvmcs_conf->basic_cap = vmx_msr_high & ~0x1fff;\n\n\tvmcs_conf->revision_id = vmx_msr_low;\n\n\tvmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;\n\tvmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;\n\tvmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;\n\tvmcs_conf->vmexit_ctrl         = _vmexit_control;\n\tvmcs_conf->vmentry_ctrl        = _vmentry_control;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (enlightened_vmcs)\n\t\tevmcs_sanitize_exec_ctrls(vmcs_conf);\n#endif\n\n\treturn 0;\n}\n\nstruct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, flags, 0);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\n\t/* KVM supports Enlightened VMCS v1 only */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tvmcs->hdr.revision_id = KVM_EVMCS_VERSION;\n\telse\n\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\tif (shadow)\n\t\tvmcs->hdr.shadow_vmcs = 1;\n\treturn vmcs;\n}\n\nvoid free_vmcs(struct vmcs *vmcs)\n{\n\tfree_page((unsigned long)vmcs);\n}\n\n/*\n * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded\n */\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}\n\nint alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tloaded_vmcs->vmcs = alloc_vmcs(false);\n\tif (!loaded_vmcs->vmcs)\n\t\treturn -ENOMEM;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\n\tloaded_vmcs->shadow_vmcs = NULL;\n\tloaded_vmcs->hv_timer_soft_disabled = false;\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tloaded_vmcs->msr_bitmap = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!loaded_vmcs->msr_bitmap)\n\t\t\tgoto out_vmcs;\n\t\tmemset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);\n\t}\n\n\tmemset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));\n\tmemset(&loaded_vmcs->controls_shadow, 0,\n\t\tsizeof(struct vmcs_controls_shadow));\n\n\treturn 0;\n\nout_vmcs:\n\tfree_loaded_vmcs(loaded_vmcs);\n\treturn -ENOMEM;\n}\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * When eVMCS is enabled, alloc_vmcs_cpu() sets\n\t\t * vmcs->revision_id to KVM_EVMCS_VERSION instead of\n\t\t * revision_id reported by MSR_IA32_VMX_BASIC.\n\t\t *\n\t\t * However, even though not explicitly documented by\n\t\t * TLFS, VMXArea passed as VMXON argument should\n\t\t * still be marked with revision_id reported by\n\t\t * physical CPU.\n\t\t */\n\t\tif (static_branch_unlikely(&enable_evmcs))\n\t\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\t__vmx_set_segment(vcpu, save, seg);\n}\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if segment\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\t__vmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tvmx_update_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!kvm_vmx->tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tvmx_update_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n}\n\nint vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/* Nothing to do if hardware doesn't support EFER. */\n\tif (!vmx_find_uret_msr(vmx, MSR_EFER))\n\t\treturn 0;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA)\n\t\tvm_entry_controls_setbit(vmx, VM_ENTRY_IA32E_MODE);\n\telse\n\t\tvm_entry_controls_clearbit(vmx, VM_ENTRY_IA32E_MODE);\n\n\tvmx_setup_uret_msrs(vmx);\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}\n\n#endif\n\nstatic void vmx_flush_tlb_all(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * INVEPT must be issued when EPT is enabled, irrespective of VPID, as\n\t * the CPU is not required to invalidate guest-physical mappings on\n\t * VM-Entry, even if VPID is disabled.  Guest-physical mappings are\n\t * associated with the root EPT structure and not any particular VPID\n\t * (INVVPID also isn't required to invalidate guest-physical mappings).\n\t */\n\tif (enable_ept) {\n\t\tept_sync_global();\n\t} else if (enable_vpid) {\n\t\tif (cpu_has_vmx_invvpid_global()) {\n\t\t\tvpid_sync_vcpu_global();\n\t\t} else {\n\t\t\tvpid_sync_vcpu_single(vmx->vpid);\n\t\t\tvpid_sync_vcpu_single(vmx->nested.vpid02);\n\t\t}\n\t}\n}\n\nstatic inline int vmx_get_current_vpid(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\treturn nested_get_vpid02(vcpu);\n\treturn to_vmx(vcpu)->vpid;\n}\n\nstatic void vmx_flush_tlb_current(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tu64 root_hpa = mmu->root.hpa;\n\n\t/* No flush required if the current context is invalid. */\n\tif (!VALID_PAGE(root_hpa))\n\t\treturn;\n\n\tif (enable_ept)\n\t\tept_sync_context(construct_eptp(vcpu, root_hpa,\n\t\t\t\t\t\tmmu->root_role.level));\n\telse\n\t\tvpid_sync_context(vmx_get_current_vpid(vcpu));\n}\n\nstatic void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\t/*\n\t * vpid_sync_vcpu_addr() is a nop if vpid==0, see the comment in\n\t * vmx_flush_tlb_guest() for an explanation of why this is ok.\n\t */\n\tvpid_sync_vcpu_addr(vmx_get_current_vpid(vcpu), addr);\n}\n\nstatic void vmx_flush_tlb_guest(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * vpid_sync_context() is a nop if vpid==0, e.g. if enable_vpid==0 or a\n\t * vpid couldn't be allocated for this vCPU.  VM-Enter and VM-Exit are\n\t * required to flush GVA->{G,H}PA mappings from the TLB if vpid is\n\t * disabled (VM-Enter with vpid enabled and vpid==0 is disallowed),\n\t * i.e. no explicit INVVPID is necessary.\n\t */\n\tvpid_sync_context(vmx_get_current_vpid(vcpu));\n}\n\nvoid vmx_ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n\nvoid ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (WARN_ON_ONCE(!is_pae_paging(vcpu)))\n\t\treturn;\n\n\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_PDPTR);\n}\n\n#define CR3_EXITING_BITS (CPU_BASED_CR3_LOAD_EXITING | \\\n\t\t\t  CPU_BASED_CR3_STORE_EXITING)\n\nvoid vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0, old_cr0_pg;\n\tu32 tmp;\n\n\told_cr0_pg = kvm_read_cr0_bits(vcpu, X86_CR0_PG);\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (is_unrestricted_guest(vcpu))\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\t\tif (!enable_ept)\n\t\t\thw_cr0 |= X86_CR0_WP;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR0);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!old_cr0_pg && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\telse if (old_cr0_pg && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !is_unrestricted_guest(vcpu)) {\n\t\t/*\n\t\t * Ensure KVM has an up-to-date snapshot of the guest's CR3.  If\n\t\t * the below code _enables_ CR3 exiting, vmx_cache_reg() will\n\t\t * (correctly) stop reading vmcs.GUEST_CR3 because it thinks\n\t\t * KVM's CR3 is installed.\n\t\t */\n\t\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\t\tvmx_cache_reg(vcpu, VCPU_EXREG_CR3);\n\n\t\t/*\n\t\t * When running with EPT but not unrestricted guest, KVM must\n\t\t * intercept CR3 accesses when paging is _disabled_.  This is\n\t\t * necessary because restricted guests can't actually run with\n\t\t * paging disabled, and so KVM stuffs its own CR3 in order to\n\t\t * run the guest when identity mapped page tables.\n\t\t *\n\t\t * Do _NOT_ check the old CR0.PG, e.g. to optimize away the\n\t\t * update, it may be stale with respect to CR3 interception,\n\t\t * e.g. after nested VM-Enter.\n\t\t *\n\t\t * Lastly, honor L1's desires, i.e. intercept CR3 loads and/or\n\t\t * stores to forward them to L1, even if KVM does not need to\n\t\t * intercept them to preserve its identity mapped page tables.\n\t\t */\n\t\tif (!(cr0 & X86_CR0_PG)) {\n\t\t\texec_controls_setbit(vmx, CR3_EXITING_BITS);\n\t\t} else if (!is_guest_mode(vcpu)) {\n\t\t\texec_controls_clearbit(vmx, CR3_EXITING_BITS);\n\t\t} else {\n\t\t\ttmp = exec_controls_get(vmx);\n\t\t\ttmp &= ~CR3_EXITING_BITS;\n\t\t\ttmp |= get_vmcs12(vcpu)->cpu_based_vm_exec_control & CR3_EXITING_BITS;\n\t\t\texec_controls_set(vmx, tmp);\n\t\t}\n\n\t\t/* Note, vmx_set_cr4() consumes the new vcpu->arch.cr0. */\n\t\tif ((old_cr0_pg ^ cr0) & X86_CR0_PG)\n\t\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\n\t\t/*\n\t\t * When !CR0_PG -> CR0_PG, vcpu->arch.cr3 becomes active, but\n\t\t * GUEST_CR3 is still vmx->ept_identity_map_addr if EPT + !URG.\n\t\t */\n\t\tif (!(old_cr0_pg & X86_CR0_PG) && (cr0 & X86_CR0_PG))\n\t\t\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\t}\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = vmx_emulation_required(vcpu);\n}\n\nstatic int vmx_get_max_tdp_level(void)\n{\n\tif (cpu_has_vmx_ept_5levels())\n\t\treturn 5;\n\treturn 4;\n}\n\nu64 construct_eptp(struct kvm_vcpu *vcpu, hpa_t root_hpa, int root_level)\n{\n\tu64 eptp = VMX_EPTP_MT_WB;\n\n\teptp |= (root_level == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;\n\n\tif (enable_ept_ad_bits &&\n\t    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))\n\t\teptp |= VMX_EPTP_AD_ENABLE_BIT;\n\teptp |= root_hpa;\n\n\treturn eptp;\n}\n\nstatic void vmx_load_mmu_pgd(struct kvm_vcpu *vcpu, hpa_t root_hpa,\n\t\t\t     int root_level)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tbool update_guest_cr3 = true;\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tif (enable_ept) {\n\t\teptp = construct_eptp(vcpu, root_hpa, root_level);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\n\t\thv_track_root_tdp(vcpu, root_hpa);\n\n\t\tif (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t\tguest_cr3 = to_kvm_vmx(kvm)->ept_identity_map_addr;\n\t\telse if (kvm_register_is_dirty(vcpu, VCPU_EXREG_CR3))\n\t\t\tguest_cr3 = vcpu->arch.cr3;\n\t\telse /* vmcs.GUEST_CR3 is already up-to-date. */\n\t\t\tupdate_guest_cr3 = false;\n\t\tvmx_ept_load_pdptrs(vcpu);\n\t} else {\n\t\tguest_cr3 = root_hpa | kvm_get_active_pcid(vcpu);\n\t}\n\n\tif (update_guest_cr3)\n\t\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n\n\nstatic bool vmx_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\t/*\n\t * We operate under the default treatment of SMM, so VMX cannot be\n\t * enabled under SMM.  Note, whether or not VMXE is allowed at all is\n\t * handled by kvm_is_valid_cr4().\n\t */\n\tif ((cr4 & X86_CR4_VMXE) && is_smm(vcpu))\n\t\treturn false;\n\n\tif (to_vmx(vcpu)->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = vcpu->arch.cr4;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (is_unrestricted_guest(vcpu))\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tvcpu->arch.cr4 = cr4;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR4);\n\n\tif (!is_unrestricted_guest(vcpu)) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid_runtime(vcpu);\n}\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}\n\nint vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn VMX_AR_DPL(ar);\n\t}\n}\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}\n\nvoid __vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\treturn;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (is_unrestricted_guest(vcpu) && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n}\n\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\t__vmx_set_segment(vcpu, var, seg);\n\n\tto_vmx(vcpu)->emulation_required = vmx_emulation_required(vcpu);\n}\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}\n\n/*\n * Check if guest state is valid. Returns true if valid, false if\n * not.\n * We assume that registers are always usable\n */\nbool __vmx_guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}\n\nstatic int init_rmode_tss(struct kvm *kvm, void __user *ua)\n{\n\tconst void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));\n\tu16 data;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (__copy_to_user(ua + PAGE_SIZE * i, zero_page, PAGE_SIZE))\n\t\t\treturn -EFAULT;\n\t}\n\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tif (__copy_to_user(ua + TSS_IOPB_BASE_OFFSET, &data, sizeof(u16)))\n\t\treturn -EFAULT;\n\n\tdata = ~0;\n\tif (__copy_to_user(ua + RMODE_TSS_SIZE - 1, &data, sizeof(u8)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);\n\tint i, r = 0;\n\tvoid __user *uaddr;\n\tu32 tmp;\n\n\t/* Protect kvm_vmx->ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm_vmx->ept_identity_pagetable_done))\n\t\tgoto out;\n\n\tif (!kvm_vmx->ept_identity_map_addr)\n\t\tkvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\n\tuaddr = __x86_set_memory_region(kvm,\n\t\t\t\t\tIDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t\tkvm_vmx->ept_identity_map_addr,\n\t\t\t\t\tPAGE_SIZE);\n\tif (IS_ERR(uaddr)) {\n\t\tr = PTR_ERR(uaddr);\n\t\tgoto out;\n\t}\n\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tif (__copy_to_user(uaddr + i * sizeof(tmp), &tmp, sizeof(tmp))) {\n\t\t\tr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkvm_vmx->ept_identity_pagetable_done = true;\n\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tvoid __user *hva;\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_memslot_enabled)\n\t\tgoto out;\n\thva = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (IS_ERR(hva)) {\n\t\tret = PTR_ERR(hva);\n\t\tgoto out;\n\t}\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_memslot_enabled = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}\n\nint allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}\n\nvoid free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}\n\nstatic void vmx_msr_bitmap_l01_changed(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * When KVM is a nested hypervisor on top of Hyper-V and uses\n\t * 'Enlightened MSR Bitmap' feature L0 needs to know that MSR\n\t * bitmap has changed.\n\t */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\tvmx->nested.force_msr_bitmap_recalc = true;\n}\n\nvoid vmx_disable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tvmx_msr_bitmap_l01_changed(vmx);\n\n\t/*\n\t * Mark the desired intercept state in shadow bitmap, this is needed\n\t * for resync when the MSR filters change.\n\t*/\n\tif (is_valid_passthrough_msr(msr)) {\n\t\tint idx = possible_passthrough_msr_slot(msr);\n\n\t\tif (idx != -ENOENT) {\n\t\t\tif (type & MSR_TYPE_R)\n\t\t\t\tclear_bit(idx, vmx->shadow_msr_intercept.read);\n\t\t\tif (type & MSR_TYPE_W)\n\t\t\t\tclear_bit(idx, vmx->shadow_msr_intercept.write);\n\t\t}\n\t}\n\n\tif ((type & MSR_TYPE_R) &&\n\t    !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_READ)) {\n\t\tvmx_set_msr_bitmap_read(msr_bitmap, msr);\n\t\ttype &= ~MSR_TYPE_R;\n\t}\n\n\tif ((type & MSR_TYPE_W) &&\n\t    !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_WRITE)) {\n\t\tvmx_set_msr_bitmap_write(msr_bitmap, msr);\n\t\ttype &= ~MSR_TYPE_W;\n\t}\n\n\tif (type & MSR_TYPE_R)\n\t\tvmx_clear_msr_bitmap_read(msr_bitmap, msr);\n\n\tif (type & MSR_TYPE_W)\n\t\tvmx_clear_msr_bitmap_write(msr_bitmap, msr);\n}\n\nvoid vmx_enable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tvmx_msr_bitmap_l01_changed(vmx);\n\n\t/*\n\t * Mark the desired intercept state in shadow bitmap, this is needed\n\t * for resync when the MSR filter changes.\n\t*/\n\tif (is_valid_passthrough_msr(msr)) {\n\t\tint idx = possible_passthrough_msr_slot(msr);\n\n\t\tif (idx != -ENOENT) {\n\t\t\tif (type & MSR_TYPE_R)\n\t\t\t\tset_bit(idx, vmx->shadow_msr_intercept.read);\n\t\t\tif (type & MSR_TYPE_W)\n\t\t\t\tset_bit(idx, vmx->shadow_msr_intercept.write);\n\t\t}\n\t}\n\n\tif (type & MSR_TYPE_R)\n\t\tvmx_set_msr_bitmap_read(msr_bitmap, msr);\n\n\tif (type & MSR_TYPE_W)\n\t\tvmx_set_msr_bitmap_write(msr_bitmap, msr);\n}\n\nstatic void vmx_reset_x2apic_msrs(struct kvm_vcpu *vcpu, u8 mode)\n{\n\tunsigned long *msr_bitmap = to_vmx(vcpu)->vmcs01.msr_bitmap;\n\tunsigned long read_intercept;\n\tint msr;\n\n\tread_intercept = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\tunsigned int read_idx = msr / BITS_PER_LONG;\n\t\tunsigned int write_idx = read_idx + (0x800 / sizeof(long));\n\n\t\tmsr_bitmap[read_idx] = read_intercept;\n\t\tmsr_bitmap[write_idx] = ~0ul;\n\t}\n}\n\nstatic void vmx_update_msr_bitmap_x2apic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu8 mode;\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (cpu_has_secondary_exec_ctrls() &&\n\t    (secondary_exec_controls_get(vmx) &\n\t     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tmode = MSR_BITMAP_MODE_X2APIC;\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu))\n\t\t\tmode |= MSR_BITMAP_MODE_X2APIC_APICV;\n\t} else {\n\t\tmode = 0;\n\t}\n\n\tif (mode == vmx->x2apic_msr_bitmap_mode)\n\t\treturn;\n\n\tvmx->x2apic_msr_bitmap_mode = mode;\n\n\tvmx_reset_x2apic_msrs(vcpu, mode);\n\n\t/*\n\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t * delivery is not in use.\n\t */\n\tvmx_set_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW,\n\t\t\t\t  !(mode & MSR_BITMAP_MODE_X2APIC));\n\n\tif (mode & MSR_BITMAP_MODE_X2APIC_APICV) {\n\t\tvmx_enable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_RW);\n\t\tvmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);\n\t\tvmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);\n\t}\n}\n\nvoid pt_update_intercept_for_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n\tu32 i;\n\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_STATUS, MSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_OUTPUT_BASE, MSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_OUTPUT_MASK, MSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_CR3_MATCH, MSR_TYPE_RW, flag);\n\tfor (i = 0; i < vmx->pt_desc.num_address_ranges; i++) {\n\t\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);\n\t\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);\n\t}\n}\n\nstatic bool vmx_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvoid *vapic_page;\n\tu32 vppr;\n\tint rvi;\n\n\tif (WARN_ON_ONCE(!is_guest_mode(vcpu)) ||\n\t\t!nested_cpu_has_vid(get_vmcs12(vcpu)) ||\n\t\tWARN_ON_ONCE(!vmx->nested.virtual_apic_map.gfn))\n\t\treturn false;\n\n\trvi = vmx_get_rvi();\n\n\tvapic_page = vmx->nested.virtual_apic_map.hva;\n\tvppr = *((u32 *)(vapic_page + APIC_PROCPRI));\n\n\treturn ((rvi & 0xf0) > (vppr & 0xf0));\n}\n\nstatic void vmx_msr_filter_changed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 i;\n\n\t/*\n\t * Set intercept permissions for all potentially passed through MSRs\n\t * again. They will automatically get filtered through the MSR filter,\n\t * so we are back in sync after this.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(vmx_possible_passthrough_msrs); i++) {\n\t\tu32 msr = vmx_possible_passthrough_msrs[i];\n\t\tbool read = test_bit(i, vmx->shadow_msr_intercept.read);\n\t\tbool write = test_bit(i, vmx->shadow_msr_intercept.write);\n\n\t\tvmx_set_intercept_for_msr(vcpu, msr, MSR_TYPE_R, read);\n\t\tvmx_set_intercept_for_msr(vcpu, msr, MSR_TYPE_W, write);\n\t}\n\n\tpt_update_intercept_for_msr(vcpu);\n}\n\nstatic inline void kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     int pi_vec)\n{\n#ifdef CONFIG_SMP\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of the virtual has already been set in the PIR.\n\t\t * Send a notification event to deliver the virtual interrupt\n\t\t * unless the vCPU is the currently running vCPU, i.e. the\n\t\t * event is being sent from a fastpath VM-Exit handler, in\n\t\t * which case the PIR will be synced to the vIRR before\n\t\t * re-entering the guest.\n\t\t *\n\t\t * When the target is not the running vCPU, the following\n\t\t * possibilities emerge:\n\t\t *\n\t\t * Case 1: vCPU stays in non-root mode. Sending a notification\n\t\t * event posts the interrupt to the vCPU.\n\t\t *\n\t\t * Case 2: vCPU exits to root mode and is still runnable. The\n\t\t * PIR will be synced to the vIRR before re-entering the guest.\n\t\t * Sending a notification event is ok as the host IRQ handler\n\t\t * will ignore the spurious event.\n\t\t *\n\t\t * Case 3: vCPU exits to root mode and is blocked. vcpu_block()\n\t\t * has already synced PIR to vIRR and never blocks the vCPU if\n\t\t * the vIRR is not empty. Therefore, a blocked vCPU here does\n\t\t * not wait for any requested interrupts in PIR, and sending a\n\t\t * notification event also results in a benign, spurious event.\n\t\t */\n\n\t\tif (vcpu != kvm_get_running_vcpu())\n\t\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn;\n\t}\n#endif\n\t/*\n\t * The vCPU isn't in the guest; wake the vCPU in case it is blocking,\n\t * otherwise do nothing as KVM will grab the highest priority pending\n\t * IRQ via ->sync_pir_to_irr() in vcpu_enter_guest().\n\t */\n\tkvm_vcpu_wake_up(vcpu);\n}\n\nstatic int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t\t/*\n\t\t * This pairs with the smp_mb_*() after setting vcpu->mode in\n\t\t * vcpu_enter_guest() to guarantee the vCPU sees the event\n\t\t * request if triggering a posted interrupt \"fails\" because\n\t\t * vcpu->mode != IN_GUEST_MODE.  The extra barrier is needed as\n\t\t * the smb_wmb() in kvm_make_request() only ensures everything\n\t\t * done before making the request is visible when the request\n\t\t * is visible, it doesn't ensure ordering between the store to\n\t\t * vcpu->requests and the load from vcpu->mode.\n\t\t */\n\t\tsmp_mb__after_atomic();\n\n\t\t/* the PIR and ON have been set by L1. */\n\t\tkvm_vcpu_trigger_posted_interrupt(vcpu, POSTED_INTR_NESTED_VECTOR);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n/*\n * Send interrupt to vcpu via posted interrupt way.\n * 1. If target vcpu is running(non-root mode), send posted interrupt\n * notification to vcpu and hardware will sync PIR to vIRR atomically.\n * 2. If target vcpu isn't running(root mode), kick it to pick up the\n * interrupt from PIR in next vmentry.\n */\nstatic int vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tr = vmx_deliver_nested_posted_interrupt(vcpu, vector);\n\tif (!r)\n\t\treturn 0;\n\n\tif (!vcpu->arch.apicv_active)\n\t\treturn -1;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn 0;\n\n\t/* If a previous notification has sent the IPI, nothing to do.  */\n\tif (pi_test_and_set_on(&vmx->pi_desc))\n\t\treturn 0;\n\n\t/*\n\t * The implied barrier in pi_test_and_set_on() pairs with the smp_mb_*()\n\t * after setting vcpu->mode in vcpu_enter_guest(), thus the vCPU is\n\t * guaranteed to see PID.ON=1 and sync the PIR to IRR if triggering a\n\t * posted interrupt \"fails\" because vcpu->mode != IN_GUEST_MODE.\n\t */\n\tkvm_vcpu_trigger_posted_interrupt(vcpu, POSTED_INTR_VECTOR);\n\treturn 0;\n}\n\nstatic void vmx_deliver_interrupt(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t\t  int trig_mode, int vector)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\tif (vmx_deliver_posted_interrupt(vcpu, vector)) {\n\t\tkvm_lapic_set_irr(vector, apic);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t} else {\n\t\ttrace_kvm_apicv_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t\t   trig_mode, vector);\n\t}\n}\n\n/*\n * Set up the vmcs's constant host-state fields, i.e., host-state fields that\n * will not change in the lifetime of the guest.\n * Note that host-state that does change is set elsewhere. E.g., host-state\n * that is set differently for each CPU is set in vmx_vcpu_load(), not here.\n */\nvoid vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tunsigned long cr0, cr3, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\n\t/*\n\t * Save the most likely value for this task's CR3 in the VMCS.\n\t * We can't use __get_current_cr3_fast() because we're not atomic.\n\t */\n\tcr3 = __read_cr3();\n\tvmcs_writel(HOST_CR3, cr3);\t\t/* 22.2.3  FIXME: shadow tables */\n\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * vmx_prepare_switch_to_host(), in case userspace uses\n\t * the null selectors too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tvmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */\n\n\tvmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\n\t/*\n\t * SYSENTER is used for 32-bit system calls on either 32-bit or\n\t * 64-bit kernels.  It is always zero If neither is allowed, otherwise\n\t * vmx_vcpu_load_vmcs loads it with the per-CPU entry stack (and may\n\t * have already done so!).\n\t */\n\tif (!IS_ENABLED(CONFIG_IA32_EMULATION) && !IS_ENABLED(CONFIG_X86_32))\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, 0);\n\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n\n\tif (cpu_has_load_ia32_efer())\n\t\tvmcs_write64(HOST_IA32_EFER, host_efer);\n}\n\nvoid set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tvcpu->arch.cr4_guest_owned_bits = KVM_POSSIBLE_CR4_GUEST_BITS &\n\t\t\t\t\t  ~vcpu->arch.cr4_guest_rsvd_bits;\n\tif (!enable_ept) {\n\t\tvcpu->arch.cr4_guest_owned_bits &= ~X86_CR4_TLBFLUSH_BITS;\n\t\tvcpu->arch.cr4_guest_owned_bits &= ~X86_CR4_PDPTR_BITS;\n\t}\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvcpu->arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vcpu->arch.cr4_guest_owned_bits);\n}\n\nstatic u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}\n\nstatic u32 vmx_vmentry_ctrl(void)\n{\n\tu32 vmentry_ctrl = vmcs_config.vmentry_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\tvmentry_ctrl &= ~(VM_ENTRY_PT_CONCEAL_PIP |\n\t\t\t\t  VM_ENTRY_LOAD_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmentry_ctrl &\n\t\t~(VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL | VM_ENTRY_LOAD_IA32_EFER);\n}\n\nstatic u32 vmx_vmexit_ctrl(void)\n{\n\tu32 vmexit_ctrl = vmcs_config.vmexit_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\tvmexit_ctrl &= ~(VM_EXIT_PT_CONCEAL_PIP |\n\t\t\t\t VM_EXIT_CLEAR_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmexit_ctrl &\n\t\t~(VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL | VM_EXIT_LOAD_IA32_EFER);\n}\n\nstatic void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.update_vmcs01_apicv_status = true;\n\t\treturn;\n\t}\n\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tsecondary_exec_controls_setbit(vmx,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tsecondary_exec_controls_clearbit(vmx,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tvmx_update_msr_bitmap_x2apic(vcpu);\n}\n\nstatic u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tif (kvm_mwait_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~(CPU_BASED_MWAIT_EXITING |\n\t\t\t\tCPU_BASED_MONITOR_EXITING);\n\tif (kvm_hlt_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~CPU_BASED_HLT_EXITING;\n\treturn exec_control;\n}\n\n/*\n * Adjust a single secondary execution control bit to intercept/allow an\n * instruction in the guest.  This is usually done based on whether or not a\n * feature has been exposed to the guest in order to correctly emulate faults.\n */\nstatic inline void\nvmx_adjust_secondary_exec_control(struct vcpu_vmx *vmx, u32 *exec_control,\n\t\t\t\t  u32 control, bool enabled, bool exiting)\n{\n\t/*\n\t * If the control is for an opt-in feature, clear the control if the\n\t * feature is not exposed to the guest, i.e. not enabled.  If the\n\t * control is opt-out, i.e. an exiting control, clear the control if\n\t * the feature _is_ exposed to the guest, i.e. exiting/interception is\n\t * disabled for the associated instruction.  Note, the caller is\n\t * responsible presetting exec_control to set all supported bits.\n\t */\n\tif (enabled == exiting)\n\t\t*exec_control &= ~control;\n\n\t/*\n\t * Update the nested MSR settings so that a nested VMM can/can't set\n\t * controls for features that are/aren't exposed to the guest.\n\t */\n\tif (nested) {\n\t\tif (enabled)\n\t\t\tvmx->nested.msrs.secondary_ctls_high |= control;\n\t\telse\n\t\t\tvmx->nested.msrs.secondary_ctls_high &= ~control;\n\t}\n}\n\n/*\n * Wrapper macro for the common case of adjusting a secondary execution control\n * based on a single guest CPUID bit, with a dedicated feature bit.  This also\n * verifies that the control is actually supported by KVM and hardware.\n */\n#define vmx_adjust_sec_exec_control(vmx, exec_control, name, feat_name, ctrl_name, exiting) \\\n({\t\t\t\t\t\t\t\t\t \\\n\tbool __enabled;\t\t\t\t\t\t\t \\\n\t\t\t\t\t\t\t\t\t \\\n\tif (cpu_has_vmx_##name()) {\t\t\t\t\t \\\n\t\t__enabled = guest_cpuid_has(&(vmx)->vcpu,\t\t \\\n\t\t\t\t\t    X86_FEATURE_##feat_name);\t \\\n\t\tvmx_adjust_secondary_exec_control(vmx, exec_control,\t \\\n\t\t\tSECONDARY_EXEC_##ctrl_name, __enabled, exiting); \\\n\t}\t\t\t\t\t\t\t\t \\\n})\n\n/* More macro magic for ENABLE_/opt-in versus _EXITING/opt-out controls. */\n#define vmx_adjust_sec_exec_feature(vmx, exec_control, lname, uname) \\\n\tvmx_adjust_sec_exec_control(vmx, exec_control, lname, uname, ENABLE_##uname, false)\n\n#define vmx_adjust_sec_exec_exiting(vmx, exec_control, lname, uname) \\\n\tvmx_adjust_sec_exec_control(vmx, exec_control, lname, uname, uname##_EXITING, true)\n\nstatic u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\t/*\n\t * PML is enabled/disabled when dirty logging of memsmlots changes, but\n\t * it needs to be set here when dirty logging is already active, e.g.\n\t * if this vCPU was created after dirty logging was enabled.\n\t */\n\tif (!vcpu->kvm->arch.cpu_dirty_logging_count)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (cpu_has_vmx_xsaves()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tvmx_adjust_secondary_exec_control(vmx, &exec_control,\n\t\t\t\t\t\t  SECONDARY_EXEC_XSAVES,\n\t\t\t\t\t\t  xsaves_enabled, false);\n\t}\n\n\t/*\n\t * RDPID is also gated by ENABLE_RDTSCP, turn on the control if either\n\t * feature is exposed to the guest.  This creates a virtualization hole\n\t * if both are supported in hardware but only one is exposed to the\n\t * guest, but letting the guest execute RDTSCP or RDPID when either one\n\t * is advertised is preferable to emulating the advertised instruction\n\t * in KVM on #UD, and obviously better than incorrectly injecting #UD.\n\t */\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdpid_or_rdtscp_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) ||\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_RDPID);\n\n\t\tvmx_adjust_secondary_exec_control(vmx, &exec_control,\n\t\t\t\t\t\t  SECONDARY_EXEC_ENABLE_RDTSCP,\n\t\t\t\t\t\t  rdpid_or_rdtscp_enabled, false);\n\t}\n\tvmx_adjust_sec_exec_feature(vmx, &exec_control, invpcid, INVPCID);\n\n\tvmx_adjust_sec_exec_exiting(vmx, &exec_control, rdrand, RDRAND);\n\tvmx_adjust_sec_exec_exiting(vmx, &exec_control, rdseed, RDSEED);\n\n\tvmx_adjust_sec_exec_control(vmx, &exec_control, waitpkg, WAITPKG,\n\t\t\t\t    ENABLE_USR_WAIT_PAUSE, false);\n\n\tif (!vcpu->kvm->arch.bus_lock_detection_enabled)\n\t\texec_control &= ~SECONDARY_EXEC_BUS_LOCK_DETECTION;\n\n\treturn exec_control;\n}\n\n#define VMX_XSS_EXIT_BITMAP 0\n\nstatic void init_vmcs(struct vcpu_vmx *vmx)\n{\n\tif (nested)\n\t\tnested_vmx_set_vmcs_shadowing_bitmap();\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));\n\n\tvmcs_write64(VMCS_LINK_POINTER, INVALID_GPA); /* 22.3.1.5 */\n\n\t/* Control */\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\n\texec_controls_set(vmx, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_controls_set(vmx, vmx_secondary_exec_control(vmx));\n\n\tif (enable_apicv && lapic_in_kernel(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (!kvm_pause_in_guest(vmx->vcpu.kvm)) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n\n\tif (cpu_has_vmx_vmfunc())\n\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tvm_exit_controls_set(vmx, vmx_vmexit_ctrl());\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_set(vmx, vmx_vmentry_ctrl());\n\n\tvmx->vcpu.arch.cr0_guest_owned_bits = KVM_POSSIBLE_CR0_GUEST_BITS;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr0_guest_owned_bits);\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tif (cpu_has_vmx_xsaves())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tvmx_write_encls_bitmap(&vmx->vcpu, NULL);\n\n\tif (vmx_pt_mode_is_host_guest()) {\n\t\tmemset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));\n\t\t/* Bit[6~0] are forced to 1, writes are ignored. */\n\t\tvmx->pt_desc.guest.output_mask = 0x7F;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, 0);\n\t}\n\n\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\n\tif (cpu_has_vmx_tpr_shadow()) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (cpu_need_tpr_shadow(&vmx->vcpu))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vmx->vcpu.arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tvmx_setup_uret_msrs(vmx);\n}\n\nstatic void __vmx_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tinit_vmcs(vmx);\n\n\tif (nested)\n\t\tmemcpy(&vmx->nested.msrs, &vmcs_config.nested, sizeof(vmx->nested.msrs));\n\n\tvcpu_setup_sgx_lepubkeyhash(vcpu);\n\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.vmxon_ptr = INVALID_GPA;\n\tvmx->nested.current_vmptr = INVALID_GPA;\n\tvmx->nested.hv_evmcs_vmptr = EVMPTR_INVALID;\n\n\tvcpu->arch.microcode_version = 0x100000000ULL;\n\tvmx->msr_ia32_feature_control_valid_bits = FEAT_CTL_LOCKED;\n\n\t/*\n\t * Enforce invariant: pi_desc.nv is always either POSTED_INTR_VECTOR\n\t * or POSTED_INTR_WAKEUP_VECTOR.\n\t */\n\tvmx->pi_desc.nv = POSTED_INTR_VECTOR;\n\tvmx->pi_desc.sn = 1;\n}\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!init_event)\n\t\t__vmx_vcpu_reset(vcpu);\n\n\tvmx->rmode.vm86_active = 0;\n\tvmx->spec_ctrl = 0;\n\n\tvmx->msr_ia32_umwait_control = 0;\n\n\tvmx->hv_deadline_tsc = -1;\n\tkvm_set_cr8(vcpu, 0);\n\n\tvmx_segment_cache_clear(vmx);\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_SEGMENTS);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_writel(GUEST_CS_BASE, 0xffff0000ul);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\tif (kvm_mpx_supported())\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tvpid_sync_context(vmx->vpid);\n}\n\nstatic void vmx_enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n}\n\nstatic void vmx_enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (!enable_vnmi ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tvmx_enable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n}\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, irq, inc_eip);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n\n\tvmx_clear_hlt(vcpu);\n}\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 1;\n\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->loaded_vmcs->nmi_known_unmasked = false;\n\n\tif (vmx->rmode.vm86_active) {\n\t\tkvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n\n\tvmx_clear_hlt(vcpu);\n}\n\nbool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool masked;\n\n\tif (!enable_vnmi)\n\t\treturn vmx->loaded_vmcs->soft_vnmi_blocked;\n\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\treturn false;\n\tmasked = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_NMI;\n\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\treturn masked;\n}\n\nvoid vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}\n\nbool vmx_nmi_blocked(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_exit_on_nmi(vcpu))\n\t\treturn false;\n\n\tif (!enable_vnmi && to_vmx(vcpu)->loaded_vmcs->soft_vnmi_blocked)\n\t\treturn true;\n\n\treturn (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t(GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI |\n\t\t GUEST_INTR_STATE_NMI));\n}\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\t/* An NMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_nmi(vcpu))\n\t\treturn -EBUSY;\n\n\treturn !vmx_nmi_blocked(vcpu);\n}\n\nbool vmx_interrupt_blocked(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn false;\n\n\treturn !(vmx_get_rflags(vcpu) & X86_EFLAGS_IF) ||\n\t       (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n       /*\n        * An IRQ must not be injected into L2 if it's supposed to VM-Exit,\n        * e.g. if the IRQ arrived asynchronously after checking nested events.\n        */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn -EBUSY;\n\n\treturn !vmx_interrupt_blocked(vcpu);\n}\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tvoid __user *ret;\n\n\tif (enable_unrestricted_guest)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tret = __x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t      PAGE_SIZE * 3);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tif (IS_ERR(ret))\n\t\treturn PTR_ERR(ret);\n\n\tto_kvm_vmx(kvm)->tss_addr = addr;\n\n\treturn init_rmode_tss(kvm, ret);\n}\n\nstatic int vmx_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)\n{\n\tto_kvm_vmx(kvm)->ept_identity_map_addr = ident_addr;\n\treturn 0;\n}\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DB_VECTOR:\n\t\treturn !(vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP));\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (kvm_emulate_instruction(vcpu, 0)) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_emulate_halt_noskip(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* handled by vmx_vcpu_run() */\n\treturn 1;\n}\n\n/*\n * If the host has split lock detection disabled, then #AC is\n * unconditionally injected into the guest, which is the pre split lock\n * detection behaviour.\n *\n * If the host has split lock detection enabled then #AC is\n * only injected into the guest when:\n *  - Guest CPL == 3 (user mode)\n *  - Guest has #AC detection enabled in CR0\n *  - Guest EFLAGS has AC bit set\n */\nbool vmx_guest_inject_ac(struct kvm_vcpu *vcpu)\n{\n\tif (!boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))\n\t\treturn true;\n\n\treturn vmx_get_cpl(vcpu) == 3 && kvm_read_cr0_bits(vcpu, X86_CR0_AM) &&\n\t       (kvm_get_rflags(vcpu) & X86_EFLAGS_AC);\n}\n\nstatic int handle_exception_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, dr6;\n\tu32 vect_info;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx_get_intr_info(vcpu);\n\n\tif (is_machine_check(intr_info) || is_nmi(intr_info))\n\t\treturn 1; /* handled by handle_exception_nmi_irqoff() */\n\n\t/*\n\t * Queue the exception here instead of in handle_nm_fault_irqoff().\n\t * This ensures the nested_vmx check is not skipped so vmexit can\n\t * be reflected to L1 (when it intercepts #NM) before reaching this\n\t * point.\n\t */\n\tif (is_nm_fault(intr_info)) {\n\t\tkvm_queue_exception(vcpu, NM_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info))\n\t\treturn handle_ud(vcpu);\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\tif (!vmx->rmode.vm86_active && is_gp_fault(intr_info)) {\n\t\tWARN_ON_ONCE(!enable_vmware_backdoor);\n\n\t\t/*\n\t\t * VMware backdoor emulation on #GP interception only handles\n\t\t * IN{S}, OUT{S}, and RDPMC, none of which generate a non-zero\n\t\t * error code on #GP.\n\t\t */\n\t\tif (error_code) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\t\t\treturn 1;\n\t\t}\n\t\treturn kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);\n\t}\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 4;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\tvcpu->run->internal.data[3] = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\tcr2 = vmx_get_exit_qual(vcpu);\n\t\tif (enable_ept && !vcpu->arch.apf.host_apf_flags) {\n\t\t\t/*\n\t\t\t * EPT will cause page fault only if we need to\n\t\t\t * detect illegal GPAs.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(!allow_smaller_maxphyaddr);\n\t\t\tkvm_fixup_and_inject_pf_error(vcpu, cr2, error_code);\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase DB_VECTOR:\n\t\tdr6 = vmx_get_exit_qual(vcpu);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\t/*\n\t\t\t * If the #DB was due to ICEBP, a.k.a. INT1, skip the\n\t\t\t * instruction.  ICEBP generates a trap-like #DB, but\n\t\t\t * despite its interception control being tied to #DB,\n\t\t\t * is an instruction intercept, i.e. the VM-Exit occurs\n\t\t\t * on the ICEBP itself.  Note, skipping ICEBP also\n\t\t\t * clears STI and MOVSS blocking.\n\t\t\t *\n\t\t\t * For all other #DBs, set vmcs.PENDING_DBG_EXCEPTIONS.BS\n\t\t\t * if single-step is enabled in RFLAGS and STI or MOVSS\n\t\t\t * blocking is active, as the CPU doesn't set the bit\n\t\t\t * on VM-Exit due to #DB interception.  VM-Entry has a\n\t\t\t * consistency check that a single-step #DB is pending\n\t\t\t * in this scenario as the previous instruction cannot\n\t\t\t * have toggled RFLAGS.TF 0=>1 (because STI and POP/MOV\n\t\t\t * don't modify RFLAGS), therefore the one instruction\n\t\t\t * delay when activating single-step breakpoints must\n\t\t\t * have already expired.  Note, the CPU sets/clears BS\n\t\t\t * as appropriate for all other VM-Exits types.\n\t\t\t */\n\t\t\tif (is_icebp(intr_info))\n\t\t\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\t\t\telse if ((vmx_get_rflags(vcpu) & X86_EFLAGS_TF) &&\n\t\t\t\t (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t\t  (GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS)))\n\t\t\t\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\t\t\t\t    vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS) | DR6_BS);\n\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\tfallthrough;\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tcase AC_VECTOR:\n\t\tif (vmx_guest_inject_ac(vcpu)) {\n\t\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * Handle split lock. Depending on detection mode this will\n\t\t * either warn and disable split lock detection for this\n\t\t * task or force SIGBUS on it.\n\t\t */\n\t\tif (handle_guest_split_lock(kvm_rip_read(vcpu)))\n\t\t\treturn 1;\n\t\tfallthrough;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\tvcpu->mmio_needed = 0;\n\treturn 0;\n}\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tstring = (exit_qualification & 16) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tin = (exit_qualification & 8) != 0;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}\n\n/* called to set cr0 as appropriate for a mov-to-cr0 exit. */\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}\n\nstatic int handle_desc(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(!(vcpu->arch.cr4 & X86_CR4_UMIP));\n\treturn kvm_emulate_instruction(vcpu, 0);\n}\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\tint ret;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_read(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tret = kvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn ret;\n\t\t\t\t/*\n\t\t\t\t * TODO: we might be squashing a\n\t\t\t\t * KVM_GUESTDBG_SINGLESTEP-triggered\n\t\t\t\t * KVM_EXIT_DEBUG here.\n\t\t\t\t */\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tKVM_BUG(1, vcpu->kvm, \"Guest always owns CR0.TS\");\n\t\treturn -EIO;\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, dr7, reg;\n\tint err = 1;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\n\t/* First, if DR does not exist, trigger UD */\n\tif (!kvm_require_dr(vcpu, dr))\n\t\treturn 1;\n\n\tif (vmx_get_cpl(vcpu) > 0)\n\t\tgoto out;\n\n\tdr7 = vmcs_readl(GUEST_DR7);\n\tif (dr7 & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = DR6_BD | DR6_ACTIVE_LOW;\n\t\t\tvcpu->run->debug.arch.dr7 = dr7;\n\t\t\tvcpu->run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BD);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tkvm_get_dr(vcpu, dr, &val);\n\t\tkvm_register_write(vcpu, reg, val);\n\t\terr = 0;\n\t} else {\n\t\terr = kvm_set_dr(vcpu, dr, kvm_register_read(vcpu, reg));\n\t}\n\nout:\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n\n\t/*\n\t * exc_debug expects dr6 to be cleared after it runs, avoid that it sees\n\t * a stale dr6 from the guest.\n\t */\n\tset_debugreg(DR6_RESERVED, 6);\n}\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_apic_update_ppr(vcpu);\n\treturn 1;\n}\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t}\n\treturn kvm_emulate_instruction(vcpu, 0);\n}\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\n\t/*\n\t * APIC-write VM-Exit is trap-like, KVM doesn't need to advance RIP and\n\t * hardware has done any necessary aliasing, offset adjustments, etc...\n\t * for the access.  I.e. the correct value has already been  written to\n\t * the vAPIC page for the correct 16-byte chunk.  KVM needs only to\n\t * retrieve the register value and emulate the access.\n\t */\n\tu32 offset = exit_qualification & 0xff0;\n\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\treturn kvm_task_switch(vcpu, tss_selector,\n\t\t\t       type == INTR_TYPE_SOFT_INTR ? idt_index : -1,\n\t\t\t       reason, has_error_code, error_code);\n}\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu64 error_code;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* Is it a read fault? */\n\terror_code = (exit_qualification & EPT_VIOLATION_ACC_READ)\n\t\t     ? PFERR_USER_MASK : 0;\n\t/* Is it a write fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_WRITE)\n\t\t      ? PFERR_WRITE_MASK : 0;\n\t/* Is it a fetch fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_INSTR)\n\t\t      ? PFERR_FETCH_MASK : 0;\n\t/* ept page table entry is present? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_RWX_MASK)\n\t\t      ? PFERR_PRESENT_MASK : 0;\n\n\terror_code |= (exit_qualification & EPT_VIOLATION_GVA_TRANSLATED) != 0 ?\n\t       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\n\t/*\n\t * Check that the GPA doesn't exceed physical memory limits, as that is\n\t * a guest page fault.  We have to emulate the instruction here, because\n\t * if the illegal address is that of a paging structure, then\n\t * EPT_VIOLATION_ACC_WRITE bit is set.  Alternatively, if supported we\n\t * would also use advanced VM-exit information for EPT violations to\n\t * reconstruct the page fault error code.\n\t */\n\tif (unlikely(allow_smaller_maxphyaddr && kvm_vcpu_is_illegal_gpa(vcpu, gpa)))\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tgpa_t gpa;\n\n\tif (!vmx_can_emulate_instruction(vcpu, EMULTYPE_PF, NULL, 0))\n\t\treturn 1;\n\n\t/*\n\t * A nested guest cannot optimize MMIO vmexits, because we have an\n\t * nGPA here instead of the required GPA.\n\t */\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!is_guest_mode(vcpu) &&\n\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);\n}\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (KVM_BUG_ON(!enable_vnmi, vcpu->kvm))\n\t\treturn -EIO;\n\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}\n\nstatic bool vmx_emulation_required_with_pending_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\treturn vmx->emulation_required && !vmx->rmode.vm86_active &&\n\t       (vcpu->arch.exception.pending || vcpu->arch.exception.injected);\n}\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tintr_window_requested = exec_controls_get(vmx) &\n\t\t\t\tCPU_BASED_INTR_WINDOW_EXITING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && !vmx_interrupt_blocked(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\tif (!kvm_emulate_instruction(vcpu, 0))\n\t\t\treturn 0;\n\n\t\tif (vmx_emulation_required_with_pending_exception(vcpu)) {\n\t\t\tkvm_prepare_emulation_failure_exit(vcpu);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\treturn kvm_emulate_halt_noskip(vcpu);\n\t\t}\n\n\t\t/*\n\t\t * Note, return 1 and not 0, vcpu_run() will invoke\n\t\t * xfer_to_guest_mode() which will create a proper return\n\t\t * code.\n\t\t */\n\t\tif (__xfer_to_guest_mode_work_pending())\n\t\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n\nstatic int vmx_vcpu_pre_run(struct kvm_vcpu *vcpu)\n{\n\tif (vmx_emulation_required_with_pending_exception(vcpu)) {\n\t\tkvm_prepare_emulation_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old, ple_window,\n\t\t\t\t\t    ple_window_grow,\n\t\t\t\t\t    ple_window_max);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}\n\n/*\n * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE\n * exiting, so only get here on cpu with PAUSE-Loop-Exiting.\n */\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tgrow_ple_window(vcpu);\n\n\t/*\n\t * Intel sdm vol3 ch-25.1.3 says: The \"PAUSE-loop exiting\"\n\t * VM-execution control is ignored if CPL > 0. OTOH, KVM\n\t * never set PAUSE_EXITING and just set PLE if supported,\n\t * so the vcpu must be CPL=0 if it gets a PAUSE exit.\n\t */\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int handle_invpcid(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct {\n\t\tu64 pcid;\n\t\tu64 gla;\n\t} operand;\n\tint gpr_index;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgpr_index = vmx_get_instr_info_reg2(vmx_instruction_info);\n\ttype = kvm_register_read(vcpu, gpr_index);\n\n\t/* According to the Intel instruction reference, the memory operand\n\t * is read even if it isn't needed (e.g., for type==all)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmx_get_exit_qual(vcpu),\n\t\t\t\tvmx_instruction_info, false,\n\t\t\t\tsizeof(operand), &gva))\n\t\treturn 1;\n\n\treturn kvm_handle_invpcid(vcpu, type, gva);\n}\n\nstatic int handle_pml_full(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\n\ttrace_kvm_pml_full(vcpu->vcpu_id);\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\n\t/*\n\t * PML buffer FULL happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\tGUEST_INTR_STATE_NMI);\n\n\t/*\n\t * PML buffer already flushed at beginning of VMEXIT. Nothing to do\n\t * here.., and there's no userspace involvement needed for PML.\n\t */\n\treturn 1;\n}\n\nstatic fastpath_t handle_fastpath_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->req_immediate_exit &&\n\t    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled)) {\n\t\tkvm_lapic_expired_hv_timer(vcpu);\n\t\treturn EXIT_FASTPATH_REENTER_GUEST;\n\t}\n\n\treturn EXIT_FASTPATH_NONE;\n}\n\nstatic int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\thandle_fastpath_preemption_timer(vcpu);\n\treturn 1;\n}\n\n/*\n * When nested=0, all VMX instruction VM Exits filter here.  The handlers\n * are overwritten by nested_vmx_setup() when nested=1.\n */\nstatic int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\n\n#ifndef CONFIG_X86_SGX_KVM\nstatic int handle_encls(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * SGX virtualization is disabled.  There is no software enable bit for\n\t * SGX, so KVM intercepts all ENCLS leafs and injects a #UD to prevent\n\t * the guest from executing ENCLS (when SGX is supported by hardware).\n\t */\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\n#endif /* CONFIG_X86_SGX_KVM */\n\nstatic int handle_bus_lock_vmexit(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Hardware may or may not set the BUS_LOCK_DETECTED flag on BUS_LOCK\n\t * VM-Exits. Unconditionally set the flag here and leave the handling to\n\t * vmx_handle_exit().\n\t */\n\tto_vmx(vcpu)->exit_reason.bus_lock_detected = true;\n\treturn 1;\n}\n\n/*\n * The exit handlers return 1 if the exit was handled fully and guest execution\n * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n * to be done to userspace and return 0.\n */\nstatic int (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception_nmi,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = kvm_emulate_cpuid,\n\t[EXIT_REASON_MSR_READ]                = kvm_emulate_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = kvm_emulate_wrmsr,\n\t[EXIT_REASON_INTERRUPT_WINDOW]        = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = kvm_emulate_halt,\n\t[EXIT_REASON_INVD]\t\t      = kvm_emulate_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_RDPMC]                   = kvm_emulate_rdpmc,\n\t[EXIT_REASON_VMCALL]                  = kvm_emulate_hypercall,\n\t[EXIT_REASON_VMCLEAR]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMLAUNCH]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMPTRLD]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMPTRST]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMREAD]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMRESUME]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMWRITE]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMOFF]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMON]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n\t[EXIT_REASON_WBINVD]                  = kvm_emulate_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = kvm_emulate_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_GDTR_IDTR]\t\t      = handle_desc,\n\t[EXIT_REASON_LDTR_TR]\t\t      = handle_desc,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = kvm_emulate_mwait,\n\t[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = kvm_emulate_monitor,\n\t[EXIT_REASON_INVEPT]                  = handle_vmx_instruction,\n\t[EXIT_REASON_INVVPID]                 = handle_vmx_instruction,\n\t[EXIT_REASON_RDRAND]                  = kvm_handle_invalid_op,\n\t[EXIT_REASON_RDSEED]                  = kvm_handle_invalid_op,\n\t[EXIT_REASON_PML_FULL]\t\t      = handle_pml_full,\n\t[EXIT_REASON_INVPCID]                 = handle_invpcid,\n\t[EXIT_REASON_VMFUNC]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_PREEMPTION_TIMER]\t      = handle_preemption_timer,\n\t[EXIT_REASON_ENCLS]\t\t      = handle_encls,\n\t[EXIT_REASON_BUS_LOCK]                = handle_bus_lock_vmexit,\n};\n\nstatic const int kvm_vmx_max_exit_handlers =\n\tARRAY_SIZE(kvm_vmx_exit_handlers);\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u32 *reason,\n\t\t\t      u64 *info1, u64 *info2,\n\t\t\t      u32 *intr_info, u32 *error_code)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t*reason = vmx->exit_reason.full;\n\t*info1 = vmx_get_exit_qual(vcpu);\n\tif (!(vmx->exit_reason.failed_vmentry)) {\n\t\t*info2 = vmx->idt_vectoring_info;\n\t\t*intr_info = vmx_get_intr_info(vcpu);\n\t\tif (is_exception_with_error_code(*intr_info))\n\t\t\t*error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\t\telse\n\t\t\t*error_code = 0;\n\t} else {\n\t\t*info2 = 0;\n\t\t*intr_info = 0;\n\t\t*error_code = 0;\n\t}\n}\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}\n\nstatic void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}\n\nstatic void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read16(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}\n\nstatic void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}\n\nstatic void vmx_dump_msrs(char *name, struct vmx_msrs *m)\n{\n\tunsigned int i;\n\tstruct vmx_msr_entry *e;\n\n\tpr_err(\"MSR %s:\\n\", name);\n\tfor (i = 0, e = m->val; i < m->nr; ++i, ++e)\n\t\tpr_err(\"  %2d: msr=0x%08x value=0x%016llx\\n\", i, e->index, e->value);\n}\n\nvoid dump_vmcs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmentry_ctl, vmexit_ctl;\n\tu32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;\n\tunsigned long cr4;\n\tint efer_slot;\n\n\tif (!dump_invalid_vmcs) {\n\t\tpr_warn_ratelimited(\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tvmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tvmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tcpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tpin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tcr4 = vmcs_readl(GUEST_CR4);\n\tsecondary_exec_control = 0;\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"VMCS %p, last attempted VM-entry on CPU %d\\n\",\n\t       vmx->loaded_vmcs->vmcs, vcpu->arch.last_vmentry_cpu);\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif (cpu_has_vmx_ept()) {\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tefer_slot = vmx_find_loadstore_msr_slot(&vmx->msr_autoload.guest, MSR_EFER);\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_EFER)\n\t\tpr_err(\"EFER= 0x%016llx\\n\", vmcs_read64(GUEST_IA32_EFER));\n\telse if (efer_slot >= 0)\n\t\tpr_err(\"EFER= 0x%016llx (autoload)\\n\",\n\t\t       vmx->msr_autoload.guest.val[efer_slot].value);\n\telse if (vmentry_ctl & VM_ENTRY_IA32E_MODE)\n\t\tpr_err(\"EFER= 0x%016llx (effective)\\n\",\n\t\t       vcpu->arch.efer | (EFER_LMA | EFER_LME));\n\telse\n\t\tpr_err(\"EFER= 0x%016llx (effective)\\n\",\n\t\t       vcpu->arch.efer & ~(EFER_LMA | EFER_LME));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tpr_err(\"PAT = 0x%016llx\\n\", vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\tif (vmcs_read32(VM_ENTRY_MSR_LOAD_COUNT) > 0)\n\t\tvmx_dump_msrs(\"guest autoload\", &vmx->msr_autoload.guest);\n\tif (vmcs_read32(VM_EXIT_MSR_STORE_COUNT) > 0)\n\t\tvmx_dump_msrs(\"guest autostore\", &vmx->msr_autostore.guest);\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_EFER)\n\t\tpr_err(\"EFER= 0x%016llx\\n\", vmcs_read64(HOST_IA32_EFER));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_PAT)\n\t\tpr_err(\"PAT = 0x%016llx\\n\", vmcs_read64(HOST_IA32_PAT));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmcs_read32(VM_EXIT_MSR_LOAD_COUNT) > 0)\n\t\tvmx_dump_msrs(\"host autoload\", &vmx->msr_autoload.host);\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW) {\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tu16 status = vmcs_read16(GUEST_INTR_STATUS);\n\t\t\tpr_err(\"SVI|RVI = %02x|%02x \", status >> 8, status & 0xff);\n\t\t}\n\t\tpr_cont(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tpr_err(\"APIC-access addr = 0x%016llx \", vmcs_read64(APIC_ACCESS_ADDR));\n\t\tpr_cont(\"virt-APIC addr = 0x%016llx\\n\", vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));\n\t}\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}\n\n/*\n * The guest has exited.  See if we can fix it or if we need userspace\n * assistance.\n */\nstatic int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunion vmx_exit_reason exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\tu16 exit_handler_index;\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.  Note, PML is never enabled in hardware while\n\t * running L2.\n\t */\n\tif (enable_pml && !is_guest_mode(vcpu))\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/*\n\t * KVM should never reach this point with a pending nested VM-Enter.\n\t * More specifically, short-circuiting VM-Entry to emulate L2 due to\n\t * invalid guest state should never happen as that means KVM knowingly\n\t * allowed a nested VM-Enter with an invalid vmcs12.  More below.\n\t */\n\tif (KVM_BUG_ON(vmx->nested.nested_run_pending, vcpu->kvm))\n\t\treturn -EIO;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * PML is never enabled when running L2, bail immediately if a\n\t\t * PML full exit occurs as something is horribly wrong.\n\t\t */\n\t\tif (exit_reason.basic == EXIT_REASON_PML_FULL)\n\t\t\tgoto unexpected_vmexit;\n\n\t\t/*\n\t\t * The host physical addresses of some pages of guest memory\n\t\t * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC\n\t\t * Page). The CPU may write to these pages via their host\n\t\t * physical address while L2 is running, bypassing any\n\t\t * address-translation-based dirty tracking (e.g. EPT write\n\t\t * protection).\n\t\t *\n\t\t * Mark them dirty on every exit from L2 to prevent them from\n\t\t * getting out of sync with dirty tracking.\n\t\t */\n\t\tnested_mark_vmcs12_pages_dirty(vcpu);\n\n\t\t/*\n\t\t * Synthesize a triple fault if L2 state is invalid.  In normal\n\t\t * operation, nested VM-Enter rejects any attempt to enter L2\n\t\t * with invalid state.  However, those checks are skipped if\n\t\t * state is being stuffed via RSM or KVM_SET_NESTED_STATE.  If\n\t\t * L2 state is invalid, it means either L1 modified SMRAM state\n\t\t * or userspace provided bad state.  Synthesize TRIPLE_FAULT as\n\t\t * doing so is architecturally allowed in the RSM case, and is\n\t\t * the least awful solution for the userspace case without\n\t\t * risking false positives.\n\t\t */\n\t\tif (vmx->emulation_required) {\n\t\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_TRIPLE_FAULT, 0, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (nested_vmx_reflect_vmexit(vcpu))\n\t\t\treturn 1;\n\t}\n\n\t/* If guest state is invalid, start emulating.  L2 is handled above. */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (exit_reason.failed_vmentry) {\n\t\tdump_vmcs(vcpu);\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason.full;\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tdump_vmcs(vcpu);\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t    (exit_reason.basic != EXIT_REASON_EXCEPTION_NMI &&\n\t     exit_reason.basic != EXIT_REASON_EPT_VIOLATION &&\n\t     exit_reason.basic != EXIT_REASON_PML_FULL &&\n\t     exit_reason.basic != EXIT_REASON_APIC_ACCESS &&\n\t     exit_reason.basic != EXIT_REASON_TASK_SWITCH)) {\n\t\tint ndata = 3;\n\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason.full;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.data[ndata++] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\tvcpu->run->internal.data[ndata++] = vcpu->arch.last_vmentry_cpu;\n\t\tvcpu->run->internal.ndata = ndata;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked)) {\n\t\tif (!vmx_interrupt_blocked(vcpu)) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_fastpath != EXIT_FASTPATH_NONE)\n\t\treturn 1;\n\n\tif (exit_reason.basic >= kvm_vmx_max_exit_handlers)\n\t\tgoto unexpected_vmexit;\n#ifdef CONFIG_RETPOLINE\n\tif (exit_reason.basic == EXIT_REASON_MSR_WRITE)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_PREEMPTION_TIMER)\n\t\treturn handle_preemption_timer(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_INTERRUPT_WINDOW)\n\t\treturn handle_interrupt_window(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\treturn handle_external_interrupt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG)\n\t\treturn handle_ept_misconfig(vcpu);\n#endif\n\n\texit_handler_index = array_index_nospec((u16)exit_reason.basic,\n\t\t\t\t\t\tkvm_vmx_max_exit_handlers);\n\tif (!kvm_vmx_exit_handlers[exit_handler_index])\n\t\tgoto unexpected_vmexit;\n\n\treturn kvm_vmx_exit_handlers[exit_handler_index](vcpu);\n\nunexpected_vmexit:\n\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\",\n\t\t    exit_reason.full);\n\tdump_vmcs(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 2;\n\tvcpu->run->internal.data[0] = exit_reason.full;\n\tvcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;\n\treturn 0;\n}\n\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tint ret = __vmx_handle_exit(vcpu, exit_fastpath);\n\n\t/*\n\t * Exit to user space when bus lock detected to inform that there is\n\t * a bus lock in guest.\n\t */\n\tif (to_vmx(vcpu)->exit_reason.bus_lock_detected) {\n\t\tif (ret > 0)\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_X86_BUS_LOCK;\n\n\t\tvcpu->run->flags |= KVM_RUN_X86_BUS_LOCK;\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n/*\n * Software based L1D cache flush which is used when microcode providing\n * the cache control MSR is not loaded.\n *\n * The L1D cache is 32 KiB on Nehalem and later microarchitectures, but to\n * flush it is required to read in 64 KiB because the replacement algorithm\n * is not exactly LRU. This could be sized at runtime via topology\n * information but as all relevant affected CPUs have 32KiB L1D cache size\n * there is no point in doing so.\n */\nstatic noinstr void vmx_l1d_flush(struct kvm_vcpu *vcpu)\n{\n\tint size = PAGE_SIZE << L1D_CACHE_ORDER;\n\n\t/*\n\t * This code is only executed when the the flush mode is 'cond' or\n\t * 'always'\n\t */\n\tif (static_branch_likely(&vmx_l1d_flush_cond)) {\n\t\tbool flush_l1d;\n\n\t\t/*\n\t\t * Clear the per-vcpu flush bit, it gets set again\n\t\t * either from vcpu_run() or from one of the unsafe\n\t\t * VMEXIT handlers.\n\t\t */\n\t\tflush_l1d = vcpu->arch.l1tf_flush_l1d;\n\t\tvcpu->arch.l1tf_flush_l1d = false;\n\n\t\t/*\n\t\t * Clear the per-cpu flush bit, it gets set again from\n\t\t * the interrupt handlers.\n\t\t */\n\t\tflush_l1d |= kvm_get_cpu_l1tf_flush_l1d();\n\t\tkvm_clear_cpu_l1tf_flush_l1d();\n\n\t\tif (!flush_l1d)\n\t\t\treturn;\n\t}\n\n\tvcpu->stat.l1d_flush++;\n\n\tif (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\tnative_wrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);\n\t\treturn;\n\t}\n\n\tasm volatile(\n\t\t/* First ensure the pages are in the TLB */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lpopulate_tlb:\\n\\t\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$4096, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lpopulate_tlb\\n\\t\"\n\t\t\"xorl\t%%eax, %%eax\\n\\t\"\n\t\t\"cpuid\\n\\t\"\n\t\t/* Now fill the cache */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lfill_cache:\\n\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$64, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lfill_cache\\n\\t\"\n\t\t\"lfence\\n\"\n\t\t:: [flush_pages] \"r\" (vmx_l1d_flush_pages),\n\t\t    [size] \"r\" (size)\n\t\t: \"eax\", \"ebx\", \"ecx\", \"edx\");\n}\n\nstatic void vmx_update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tint tpr_threshold;\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\ttpr_threshold = (irr == -1 || tpr < irr) ? 0 : irr;\n\tif (is_guest_mode(vcpu))\n\t\tto_vmx(vcpu)->nested.l1_tpr_threshold = tpr_threshold;\n\telse\n\t\tvmcs_write32(TPR_THRESHOLD, tpr_threshold);\n}\n\nvoid vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 sec_exec_control;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!flexpriority_enabled &&\n\t    !cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = true;\n\t\treturn;\n\t}\n\n\tsec_exec_control = secondary_exec_controls_get(vmx);\n\tsec_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n\n\tswitch (kvm_get_apic_mode(vcpu)) {\n\tcase LAPIC_MODE_INVALID:\n\t\tWARN_ONCE(true, \"Invalid local APIC state\");\n\t\tbreak;\n\tcase LAPIC_MODE_DISABLED:\n\t\tbreak;\n\tcase LAPIC_MODE_XAPIC:\n\t\tif (flexpriority_enabled) {\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\t\t\t/*\n\t\t\t * Flush the TLB, reloading the APIC access page will\n\t\t\t * only do so if its physical address has changed, but\n\t\t\t * the guest may have inserted a non-APIC mapping into\n\t\t\t * the TLB while the APIC access page was disabled.\n\t\t\t */\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\t\t}\n\t\tbreak;\n\tcase LAPIC_MODE_X2APIC:\n\t\tif (cpu_has_vmx_virtualize_x2apic_mode())\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tbreak;\n\t}\n\tsecondary_exec_controls_set(vmx, sec_exec_control);\n\n\tvmx_update_msr_bitmap_x2apic(vcpu);\n}\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\n\t/* Defer reload until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.reload_vmcs01_apic_access_page = true;\n\t\treturn;\n\t}\n\n\tif (!(secondary_exec_controls_get(to_vmx(vcpu)) &\n\t    SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn;\n\n\tvmcs_write64(APIC_ACCESS_ADDR, page_to_phys(page));\n\tvmx_flush_tlb_current(vcpu);\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}\n\nstatic void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (max_isr == -1)\n\t\tmax_isr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (max_isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= max_isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\t/*\n\t * When running L2, updating RVI is only relevant when\n\t * vmcs12 virtual-interrupt-delivery enabled.\n\t * However, it can be enabled only when L1 also\n\t * intercepts external-interrupts and in that case\n\t * we should not update vmcs02 RVI but instead intercept\n\t * interrupt. Therefore, do nothing when running L2.\n\t */\n\tif (!is_guest_mode(vcpu))\n\t\tvmx_set_rvi(max_irr);\n}\n\nstatic int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tbool got_posted_interrupt;\n\n\tif (KVM_BUG_ON(!enable_apicv, vcpu->kvm))\n\t\treturn -EIO;\n\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\t/*\n\t\t * IOMMU can write to PID.ON, so the barrier matters even on UP.\n\t\t * But on x86 this is just a compiler barrier anyway.\n\t\t */\n\t\tsmp_mb__after_atomic();\n\t\tgot_posted_interrupt =\n\t\t\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t\tgot_posted_interrupt = false;\n\t}\n\n\t/*\n\t * Newly recognized interrupts are injected via either virtual interrupt\n\t * delivery (RVI) or KVM_REQ_EVENT.  Virtual interrupt delivery is\n\t * disabled in two cases:\n\t *\n\t * 1) If L2 is running and the vCPU has a new pending interrupt.  If L1\n\t * wants to exit on interrupts, KVM_REQ_EVENT is needed to synthesize a\n\t * VM-Exit to L1.  If L1 doesn't want to exit, the interrupt is injected\n\t * into L2, but KVM doesn't use virtual interrupt delivery to inject\n\t * interrupts into L2, and so KVM_REQ_EVENT is again needed.\n\t *\n\t * 2) If APICv is disabled for this vCPU, assigned devices may still\n\t * attempt to post interrupts.  The posted interrupt vector will cause\n\t * a VM-Exit and the subsequent entry will call sync_pir_to_irr.\n\t */\n\tif (!is_guest_mode(vcpu) && kvm_vcpu_apicv_active(vcpu))\n\t\tvmx_set_rvi(max_irr);\n\telse if (got_posted_interrupt)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn max_irr;\n}\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}\n\nstatic void vmx_apicv_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tpi_clear_on(&vmx->pi_desc);\n\tmemset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));\n}\n\nvoid vmx_do_interrupt_nmi_irqoff(unsigned long entry);\n\nstatic void handle_interrupt_nmi_irqoff(struct kvm_vcpu *vcpu,\n\t\t\t\t\tunsigned long entry)\n{\n\tbool is_nmi = entry == (unsigned long)asm_exc_nmi_noist;\n\n\tkvm_before_interrupt(vcpu, is_nmi ? KVM_HANDLING_NMI : KVM_HANDLING_IRQ);\n\tvmx_do_interrupt_nmi_irqoff(entry);\n\tkvm_after_interrupt(vcpu);\n}\n\nstatic void handle_nm_fault_irqoff(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Save xfd_err to guest_fpu before interrupt is enabled, so the\n\t * MSR value is not clobbered by the host activity before the guest\n\t * has chance to consume it.\n\t *\n\t * Do not blindly read xfd_err here, since this exception might\n\t * be caused by L1 interception on a platform which doesn't\n\t * support xfd at all.\n\t *\n\t * Do it conditionally upon guest_fpu::xfd. xfd_err matters\n\t * only when xfd contains a non-zero value.\n\t *\n\t * Queuing exception is done in vmx_handle_exit. See comment there.\n\t */\n\tif (vcpu->arch.guest_fpu.fpstate->xfd)\n\t\trdmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);\n}\n\nstatic void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)\n{\n\tconst unsigned long nmi_entry = (unsigned long)asm_exc_nmi_noist;\n\tu32 intr_info = vmx_get_intr_info(&vmx->vcpu);\n\n\t/* if exit due to PF check for async PF */\n\tif (is_page_fault(intr_info))\n\t\tvmx->vcpu.arch.apf.host_apf_flags = kvm_read_and_reset_apf_flags();\n\t/* if exit due to NM, handle before interrupts are enabled */\n\telse if (is_nm_fault(intr_info))\n\t\thandle_nm_fault_irqoff(&vmx->vcpu);\n\t/* Handle machine checks before interrupts are enabled */\n\telse if (is_machine_check(intr_info))\n\t\tkvm_machine_check();\n\t/* We need to handle NMIs before interrupts are enabled */\n\telse if (is_nmi(intr_info))\n\t\thandle_interrupt_nmi_irqoff(&vmx->vcpu, nmi_entry);\n}\n\nstatic void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmx_get_intr_info(vcpu);\n\tunsigned int vector = intr_info & INTR_INFO_VECTOR_MASK;\n\tgate_desc *desc = (gate_desc *)host_idt_base + vector;\n\n\tif (KVM_BUG(!is_external_intr(intr_info), vcpu->kvm,\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\thandle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));\n}\n\nstatic void vmx_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\thandle_external_interrupt_irqoff(vcpu);\n\telse if (vmx->exit_reason.basic == EXIT_REASON_EXCEPTION_NMI)\n\t\thandle_exception_nmi_irqoff(vmx);\n}\n\n/*\n * The kvm parameter can be NULL (module initialization, or invocation before\n * VM creation). Be sure to check the kvm parameter before using it.\n */\nstatic bool vmx_has_emulated_msr(struct kvm *kvm, u32 index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_SMBASE:\n\t\t/*\n\t\t * We cannot do SMM unless we can run the guest in big\n\t\t * real mode.\n\t\t */\n\t\treturn enable_unrestricted_guest || emulate_invalid_guest_state;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn nested;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\tcase MSR_AMD64_TSC_RATIO:\n\t\t/* This is AMD only.  */\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\t\treturn;\n\n\t\texit_intr_info = vmx_get_intr_info(&vmx->vcpu);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time));\n}\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\tfallthrough;\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\tfallthrough;\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\t/* Note, nr_msrs may be garbage if perf_guest_get_msrs() returns NULL. */\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host, false);\n}\n\nstatic void vmx_update_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->req_immediate_exit) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (vmx->hv_deadline_tsc != -1) {\n\t\ttscl = rdtsc();\n\t\tif (vmx->hv_deadline_tsc > tscl)\n\t\t\t/* set_hv_timer ensures the delta fits in 32-bits */\n\t\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi);\n\t\telse\n\t\t\tdelta_tsc = 0;\n\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = true;\n\t}\n}\n\nvoid noinstr vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp)\n{\n\tif (unlikely(host_rsp != vmx->loaded_vmcs->host_state.rsp)) {\n\t\tvmx->loaded_vmcs->host_state.rsp = host_rsp;\n\t\tvmcs_writel(HOST_RSP, host_rsp);\n\t}\n}\n\nstatic fastpath_t vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)\n{\n\tswitch (to_vmx(vcpu)->exit_reason.basic) {\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn handle_fastpath_set_msr_irqoff(vcpu);\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn handle_fastpath_preemption_timer(vcpu);\n\tdefault:\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n}\n\nstatic noinstr void vmx_vcpu_enter_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct vcpu_vmx *vmx)\n{\n\tguest_state_enter_irqoff();\n\n\t/* L1D Flush includes CPU buffer clear to mitigate MDS */\n\tif (static_branch_unlikely(&vmx_l1d_should_flush))\n\t\tvmx_l1d_flush(vcpu);\n\telse if (static_branch_unlikely(&mds_user_clear))\n\t\tmds_clear_cpu_buffers();\n\n\tif (vcpu->arch.cr2 != native_read_cr2())\n\t\tnative_write_cr2(vcpu->arch.cr2);\n\n\tvmx->fail = __vmx_vcpu_run(vmx, (unsigned long *)&vcpu->arch.regs,\n\t\t\t\t   vmx->loaded_vmcs->launched);\n\n\tvcpu->arch.cr2 = native_read_cr2();\n\n\tguest_state_exit_irqoff();\n}\n\nstatic fastpath_t vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long cr3, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->entry_time = ktime_get();\n\n\t/*\n\t * Don't enter VMX if guest state is invalid, let the exit handler\n\t * start emulation until we arrive back to a valid state.  Synthesize a\n\t * consistency check VM-Exit due to invalid guest state and bail.\n\t */\n\tif (unlikely(vmx->emulation_required)) {\n\t\tvmx->fail = 0;\n\n\t\tvmx->exit_reason.full = EXIT_REASON_INVALID_STATE;\n\t\tvmx->exit_reason.failed_vmentry = 1;\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_1);\n\t\tvmx->exit_qualification = ENTRY_FAIL_DEFAULT;\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_2);\n\t\tvmx->exit_intr_info = 0;\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\ttrace_kvm_entry(vcpu);\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\t/*\n\t * We did this in prepare_switch_to_guest, because it needs to\n\t * be within srcu_read_lock.\n\t */\n\tWARN_ON_ONCE(vmx->nested.need_vmcs12_to_shadow_sync);\n\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RSP))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RIP))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\tvcpu->arch.regs_dirty = 0;\n\n\t/*\n\t * Refresh vmcs.HOST_CR3 if necessary.  This must be done immediately\n\t * prior to VM-Enter, as the kernel may load a new ASID (PCID) any time\n\t * it switches back to the current->mm, which can occur in KVM context\n\t * when switching to a temporary mm to patch kernel code, e.g. if KVM\n\t * toggles a static key while handling a VM-Exit.\n\t */\n\tcr3 = __get_current_cr3_fast();\n\tif (unlikely(cr3 != vmx->loaded_vmcs->host_state.cr3)) {\n\t\tvmcs_writel(HOST_CR3, cr3);\n\t\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\t}\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->loaded_vmcs->host_state.cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\t}\n\n\t/* When KVM_DEBUGREG_WONT_EXIT, dr6 is accessible in guest. */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT))\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tpt_guest_enter(vmx);\n\n\tatomic_switch_perf_msrs(vmx);\n\tif (intel_pmu_lbr_is_enabled(vcpu))\n\t\tvmx_passthrough_lbr_msrs(vcpu);\n\n\tif (enable_preemption_timer)\n\t\tvmx_update_hv_timer(vcpu);\n\n\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tx86_spec_ctrl_set_guest(vmx->spec_ctrl, 0);\n\n\t/* The actual VMENTER/EXIT is in the .noinstr.text section. */\n\tvmx_vcpu_enter_exit(vcpu, vmx);\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vmx, MSR_IA32_SPEC_CTRL)))\n\t\tvmx->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tx86_spec_ctrl_restore_host(vmx->spec_ctrl, 0);\n\n\t/* All fields are clean at this point */\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tcurrent_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\n\t\tcurrent_evmcs->hv_vp_id = kvm_hv_get_vpindex(vcpu);\n\t}\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (vmx->host_debugctlmsr)\n\t\tupdate_debugctlmsr(vmx->host_debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_prepare_switch_to_host() since that\n\t * function may be executed in interrupt context, which saves and\n\t * restore segments around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail &= ~VMX_REGS_LAZY_LOAD_SET;\n\n\tpt_guest_exit(vmx);\n\n\tkvm_load_host_xsave_state(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * Track VMLAUNCH/VMRESUME that have made past guest state\n\t\t * checking.\n\t\t */\n\t\tif (vmx->nested.nested_run_pending &&\n\t\t    !vmx->exit_reason.failed_vmentry)\n\t\t\t++vcpu->stat.nested_run;\n\n\t\tvmx->nested.nested_run_pending = 0;\n\t}\n\n\tvmx->idt_vectoring_info = 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tvmx->exit_reason.full = 0xdead;\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\tvmx->exit_reason.full = vmcs_read32(VM_EXIT_REASON);\n\tif (unlikely((u16)vmx->exit_reason.basic == EXIT_REASON_MCE_DURING_VMENTRY))\n\t\tkvm_machine_check();\n\n\tif (likely(!vmx->exit_reason.failed_vmentry))\n\t\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\ttrace_kvm_exit(vcpu, KVM_ISA_VMX);\n\n\tif (unlikely(vmx->exit_reason.failed_vmentry))\n\t\treturn EXIT_FASTPATH_NONE;\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn EXIT_FASTPATH_NONE;\n\n\treturn vmx_exit_handlers_fastpath(vcpu);\n}\n\nstatic void vmx_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (enable_pml)\n\t\tvmx_destroy_pml_buffer(vmx);\n\tfree_vpid(vmx->vpid);\n\tnested_vmx_free_vcpu(vcpu);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n}\n\nstatic int vmx_vcpu_create(struct kvm_vcpu *vcpu)\n{\n\tstruct vmx_uret_msr *tsx_ctrl;\n\tstruct vcpu_vmx *vmx;\n\tint i, err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_vmx, vcpu) != 0);\n\tvmx = to_vmx(vcpu);\n\n\tINIT_LIST_HEAD(&vmx->pi_wakeup_list);\n\n\terr = -ENOMEM;\n\n\tvmx->vpid = allocate_vpid();\n\n\t/*\n\t * If PML is turned on, failure on enabling PML just results in failure\n\t * of creating the vcpu, therefore we can simplify PML logic (by\n\t * avoiding dealing with cases, such as enabling PML partially on vcpus\n\t * for the guest), etc.\n\t */\n\tif (enable_pml) {\n\t\tvmx->pml_pg = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\t\tif (!vmx->pml_pg)\n\t\t\tgoto free_vpid;\n\t}\n\n\tfor (i = 0; i < kvm_nr_uret_msrs; ++i)\n\t\tvmx->guest_uret_msrs[i].mask = -1ull;\n\tif (boot_cpu_has(X86_FEATURE_RTM)) {\n\t\t/*\n\t\t * TSX_CTRL_CPUID_CLEAR is handled in the CPUID interception.\n\t\t * Keep the host value unchanged to avoid changing CPUID bits\n\t\t * under the host kernel's feet.\n\t\t */\n\t\ttsx_ctrl = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);\n\t\tif (tsx_ctrl)\n\t\t\ttsx_ctrl->mask = ~(u64)TSX_CTRL_CPUID_CLEAR;\n\t}\n\n\terr = alloc_loaded_vmcs(&vmx->vmcs01);\n\tif (err < 0)\n\t\tgoto free_pml;\n\n\t/*\n\t * Use Hyper-V 'Enlightened MSR Bitmap' feature when KVM runs as a\n\t * nested (L1) hypervisor and Hyper-V in L0 supports it. Enable the\n\t * feature only for vmcs01, KVM currently isn't equipped to realize any\n\t * performance benefits from enabling it for vmcs02.\n\t */\n\tif (IS_ENABLED(CONFIG_HYPERV) && static_branch_unlikely(&enable_evmcs) &&\n\t    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {\n\t\tstruct hv_enlightened_vmcs *evmcs = (void *)vmx->vmcs01.vmcs;\n\n\t\tevmcs->hv_enlightenments_control.msr_bitmap = 1;\n\t}\n\n\t/* The MSR bitmap starts with all ones */\n\tbitmap_fill(vmx->shadow_msr_intercept.read, MAX_POSSIBLE_PASSTHROUGH_MSRS);\n\tbitmap_fill(vmx->shadow_msr_intercept.write, MAX_POSSIBLE_PASSTHROUGH_MSRS);\n\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_TSC, MSR_TYPE_R);\n#ifdef CONFIG_X86_64\n\tvmx_disable_intercept_for_msr(vcpu, MSR_FS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_GS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_KERNEL_GS_BASE, MSR_TYPE_RW);\n#endif\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_CS, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_ESP, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_EIP, MSR_TYPE_RW);\n\tif (kvm_cstate_in_guest(vcpu->kvm)) {\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C1_RES, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C3_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C6_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C7_RESIDENCY, MSR_TYPE_R);\n\t}\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\n\tif (cpu_need_virtualize_apic_accesses(vcpu)) {\n\t\terr = alloc_apic_access_page(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept && !enable_unrestricted_guest) {\n\t\terr = init_rmode_identity_map(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\treturn 0;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_pml:\n\tvmx_destroy_pml_buffer(vmx);\nfree_vpid:\n\tfree_vpid(vmx->vpid);\n\treturn err;\n}\n\n#define L1TF_MSG_SMT \"L1TF CPU bug present and SMT on, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"\n#define L1TF_MSG_L1D \"L1TF CPU bug present and virtualization mitigation disabled, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"\n\nstatic int vmx_vm_init(struct kvm *kvm)\n{\n\tif (!ple_gap)\n\t\tkvm->arch.pause_in_guest = true;\n\n\tif (boot_cpu_has(X86_BUG_L1TF) && enable_ept) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\t\t/* 'I explicitly don't care' is set */\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\tcase L1TF_MITIGATION_FULL:\n\t\t\t/*\n\t\t\t * Warn upon starting the first VM in a potentially\n\t\t\t * insecure environment.\n\t\t\t */\n\t\t\tif (sched_smt_active())\n\t\t\t\tpr_warn_once(L1TF_MSG_SMT);\n\t\t\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER)\n\t\t\t\tpr_warn_once(L1TF_MSG_L1D);\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\t/* Flush is enforced */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __init vmx_check_processor_compat(void)\n{\n\tstruct vmcs_config vmcs_conf;\n\tstruct vmx_capability vmx_cap;\n\n\tif (!this_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t    !this_cpu_has(X86_FEATURE_VMX)) {\n\t\tpr_err(\"kvm: VMX is disabled on CPU %d\\n\", smp_processor_id());\n\t\treturn -EIO;\n\t}\n\n\tif (setup_vmcs_config(&vmcs_conf, &vmx_cap) < 0)\n\t\treturn -EIO;\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_conf.nested, vmx_cap.ept);\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\n\t/* We wanted to honor guest CD/MTRR/PAT, but doing so could result in\n\t * memory aliases with conflicting memory types and sometimes MCEs.\n\t * We have to be careful as to what are honored and when.\n\t *\n\t * For MMIO, guest CD/MTRR are ignored.  The EPT memory type is set to\n\t * UC.  The effective memory type is UC or WC depending on guest PAT.\n\t * This was historically the source of MCEs and we want to be\n\t * conservative.\n\t *\n\t * When there is no need to deal with noncoherent DMA (e.g., no VT-d\n\t * or VT-d has snoop control), guest CD/MTRR/PAT are all ignored.  The\n\t * EPT memory type is set to WB.  The effective memory type is forced\n\t * WB.\n\t *\n\t * Otherwise, we trust guest.  Guest CD/MTRR/PAT are all honored.  The\n\t * EPT memory type is used to emulate guest CD/MTRR.\n\t */\n\n\tif (is_mmio)\n\t\treturn MTRR_TYPE_UNCACHABLE << VMX_EPT_MT_EPTE_SHIFT;\n\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\treturn (MTRR_TYPE_WRBACK << VMX_EPT_MT_EPTE_SHIFT) | VMX_EPT_IPAT_BIT;\n\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\n\t\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | VMX_EPT_IPAT_BIT;\n\t}\n\n\treturn kvm_mtrr_get_guest_memory_type(vcpu, gfn) << VMX_EPT_MT_EPTE_SHIFT;\n}\n\nstatic void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx, u32 new_ctl)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_DESC;\n\n\tu32 cur_ctl = secondary_exec_controls_get(vmx);\n\n\tsecondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));\n}\n\n/*\n * Generate MSR_IA32_VMX_CR{0,4}_FIXED1 according to CPUID. Only set bits\n * (indicating \"allowed-1\") if they are supported in the guest's CPUID.\n */\nstatic void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));\n\tcr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));\n\n#undef cr4_fixed1_update\n}\n\nstatic void nested_vmx_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (kvm_mpx_supported()) {\n\t\tbool mpx_enabled = guest_cpuid_has(vcpu, X86_FEATURE_MPX);\n\n\t\tif (mpx_enabled) {\n\t\t\tvmx->nested.msrs.entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\t\t} else {\n\t\t\tvmx->nested.msrs.entry_ctls_high &= ~VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high &= ~VM_EXIT_CLEAR_BNDCFGS;\n\t\t}\n\t}\n}\n\nstatic void update_intel_pt_cfg(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\tint i;\n\n\tfor (i = 0; i < PT_CPUID_LEAVES; i++) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x14, i);\n\t\tif (!best)\n\t\t\treturn;\n\t\tvmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;\n\t\tvmx->pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best->ebx;\n\t\tvmx->pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best->ecx;\n\t\tvmx->pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best->edx;\n\t}\n\n\t/* Get the number of configurable Address Ranges for filtering */\n\tvmx->pt_desc.num_address_ranges = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_num_address_ranges);\n\n\t/* Initialize and clear the no dependency bits */\n\tvmx->pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |\n\t\t\tRTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC |\n\t\t\tRTIT_CTL_BRANCH_EN);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise\n\t * will inject an #GP\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_cr3_filtering))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and\n\t * PSBFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |\n\t\t\t\tRTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn and MTCFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |\n\t\t\t\t\t      RTIT_CTL_MTC_RANGE);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |\n\t\t\t\t\t\t\tRTIT_CTL_PTW_EN);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabricEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;\n\n\t/* unmask address range configure area */\n\tfor (i = 0; i < vmx->pt_desc.num_address_ranges; i++)\n\t\tvmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));\n}\n\nstatic void vmx_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/* xsaves_enabled is recomputed in vmx_compute_secondary_exec_control(). */\n\tvcpu->arch.xsaves_enabled = false;\n\n\tvmx_setup_uret_msrs(vmx);\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tvmcs_set_secondary_exec_control(vmx,\n\t\t\t\t\t\tvmx_secondary_exec_control(vmx));\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tvmx->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\tFEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;\n\telse\n\t\tvmx->msr_ia32_feature_control_valid_bits &=\n\t\t\t~(FEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\t  FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX);\n\n\tif (nested_vmx_allowed(vcpu)) {\n\t\tnested_vmx_cr_fixed1_bits_update(vcpu);\n\t\tnested_vmx_entry_exit_ctls_update(vcpu);\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_INTEL_PT) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INTEL_PT))\n\t\tupdate_intel_pt_cfg(vcpu);\n\n\tif (boot_cpu_has(X86_FEATURE_RTM)) {\n\t\tstruct vmx_uret_msr *msr;\n\t\tmsr = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);\n\t\tif (msr) {\n\t\t\tbool enabled = guest_cpuid_has(vcpu, X86_FEATURE_RTM);\n\t\t\tvmx_set_guest_uret_msr(vmx, msr, enabled ? 0 : TSX_CTRL_RTM_DISABLE);\n\t\t}\n\t}\n\n\tif (kvm_cpu_cap_has(X86_FEATURE_XFD))\n\t\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_XFD_ERR, MSR_TYPE_R,\n\t\t\t\t\t  !guest_cpuid_has(vcpu, X86_FEATURE_XFD));\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tvmx_write_encls_bitmap(vcpu, NULL);\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX))\n\t\tvmx->msr_ia32_feature_control_valid_bits |= FEAT_CTL_SGX_ENABLED;\n\telse\n\t\tvmx->msr_ia32_feature_control_valid_bits &= ~FEAT_CTL_SGX_ENABLED;\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))\n\t\tvmx->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_SGX_LC_ENABLED;\n\telse\n\t\tvmx->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEAT_CTL_SGX_LC_ENABLED;\n\n\t/* Refresh #PF interception to account for MAXPHYADDR changes. */\n\tvmx_update_exception_bitmap(vcpu);\n}\n\nstatic __init void vmx_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\t/* CPUID 0x1 */\n\tif (nested)\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMX);\n\n\t/* CPUID 0x7 */\n\tif (kvm_mpx_supported())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_MPX);\n\tif (!cpu_has_vmx_invpcid())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_INVPCID);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);\n\n\tif (!enable_sgx) {\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX_LC);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX1);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX2);\n\t}\n\n\tif (vmx_umip_emulated())\n\t\tkvm_cpu_cap_set(X86_FEATURE_UMIP);\n\n\t/* CPUID 0xD.1 */\n\tsupported_xss = 0;\n\tif (!cpu_has_vmx_xsaves())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_XSAVES);\n\n\t/* CPUID 0x80000001 and 0x7 (RDPID) */\n\tif (!cpu_has_vmx_rdtscp()) {\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDTSCP);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDPID);\n\t}\n\n\tif (cpu_has_vmx_waitpkg())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_WAITPKG);\n}\n\nstatic void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->req_immediate_exit = true;\n}\n\nstatic int vmx_check_intercept_io(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_instruction_info *info)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tunsigned short port;\n\tbool intercept;\n\tint size;\n\n\tif (info->intercept == x86_intercept_in ||\n\t    info->intercept == x86_intercept_ins) {\n\t\tport = info->src_val;\n\t\tsize = info->dst_bytes;\n\t} else {\n\t\tport = info->dst_val;\n\t\tsize = info->src_bytes;\n\t}\n\n\t/*\n\t * If the 'use IO bitmaps' VM-execution control is 0, IO instruction\n\t * VM-exits depend on the 'unconditional IO exiting' VM-execution\n\t * control.\n\t *\n\t * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.\n\t */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\tintercept = nested_cpu_has(vmcs12,\n\t\t\t\t\t   CPU_BASED_UNCOND_IO_EXITING);\n\telse\n\t\tintercept = nested_vmx_check_io_bitmaps(vcpu, port, size);\n\n\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\treturn intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;\n}\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tswitch (info->intercept) {\n\t/*\n\t * RDPID causes #UD if disabled through secondary execution controls.\n\t * Because it is marked as EmulateOnUD, we need to intercept it here.\n\t * Note, RDPID is hidden behind ENABLE_RDTSCP.\n\t */\n\tcase x86_intercept_rdpid:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_RDTSCP)) {\n\t\t\texception->vector = UD_VECTOR;\n\t\t\texception->error_code_valid = false;\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\t}\n\t\tbreak;\n\n\tcase x86_intercept_in:\n\tcase x86_intercept_ins:\n\tcase x86_intercept_out:\n\tcase x86_intercept_outs:\n\t\treturn vmx_check_intercept_io(vcpu, info);\n\n\tcase x86_intercept_lgdt:\n\tcase x86_intercept_lidt:\n\tcase x86_intercept_lldt:\n\tcase x86_intercept_ltr:\n\tcase x86_intercept_sgdt:\n\tcase x86_intercept_sidt:\n\tcase x86_intercept_sldt:\n\tcase x86_intercept_str:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC))\n\t\t\treturn X86EMUL_CONTINUE;\n\n\t\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\t\tbreak;\n\n\t/* TODO: check more intercepts... */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn X86EMUL_UNHANDLEABLE;\n}\n\n#ifdef CONFIG_X86_64\n/* (a << shift) / divisor, return 1 if overflow otherwise 0 */\nstatic inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}\n\nstatic int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,\n\t\t\t    bool *expired)\n{\n\tstruct vcpu_vmx *vmx;\n\tu64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;\n\tstruct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;\n\n\tvmx = to_vmx(vcpu);\n\ttscl = rdtsc();\n\tguest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tdelta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\tlapic_timer_advance_cycles = nsec_to_cycles(vcpu,\n\t\t\t\t\t\t    ktimer->timer_advance_ns);\n\n\tif (delta_tsc > lapic_timer_advance_cycles)\n\t\tdelta_tsc -= lapic_timer_advance_cycles;\n\telse\n\t\tdelta_tsc = 0;\n\n\t/* Convert to host delta tsc if tsc scaling is enabled */\n\tif (vcpu->arch.l1_tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t    delta_tsc && u64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.l1_tsc_scaling_ratio, &delta_tsc))\n\t\treturn -ERANGE;\n\n\t/*\n\t * If the delta tsc can't fit in the 32 bit after the multi shift,\n\t * we can't use the preemption timer.\n\t * It's possible that it fits on later vmentries, but checking\n\t * on every vmentry is costly so we just use an hrtimer.\n\t */\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\t*expired = !delta_tsc;\n\treturn 0;\n}\n\nstatic void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->hv_deadline_tsc = -1;\n}\n#endif\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tshrink_ple_window(vcpu);\n}\n\nvoid vmx_update_cpu_dirty_logging(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.update_vmcs01_cpu_dirty_logging = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Note, cpu_dirty_logging_count can be changed concurrent with this\n\t * code, but in that case another update request will be made and so\n\t * the guest will never run with a stale PML value.\n\t */\n\tif (vcpu->kvm->arch.cpu_dirty_logging_count)\n\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_ENABLE_PML);\n\telse\n\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_ENABLE_PML);\n}\n\nstatic void vmx_setup_mce(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mcg_cap & MCG_LMCE_P)\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_LMCE_ENABLED;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEAT_CTL_LMCE_ENABLED;\n}\n\nstatic int vmx_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\t/* we need a nested vmexit to enter SMM, postpone if run is pending */\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\treturn !is_smm(vcpu);\n}\n\nstatic int vmx_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx->nested.smm.guest_mode = is_guest_mode(vcpu);\n\tif (vmx->nested.smm.guest_mode)\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\n\tvmx->nested.smm.vmxon = vmx->nested.vmxon;\n\tvmx->nested.vmxon = false;\n\tvmx_clear_hlt(vcpu);\n\treturn 0;\n}\n\nstatic int vmx_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint ret;\n\n\tif (vmx->nested.smm.vmxon) {\n\t\tvmx->nested.vmxon = true;\n\t\tvmx->nested.smm.vmxon = false;\n\t}\n\n\tif (vmx->nested.smm.guest_mode) {\n\t\tret = nested_vmx_enter_non_root_mode(vcpu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvmx->nested.nested_run_pending = 1;\n\t\tvmx->nested.smm.guest_mode = false;\n\t}\n\treturn 0;\n}\n\nstatic void vmx_enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\t/* RSM will cause a vmexit anyway.  */\n}\n\nstatic bool vmx_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.vmxon && !is_guest_mode(vcpu);\n}\n\nstatic void vmx_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct hrtimer *timer = &to_vmx(vcpu)->nested.preemption_timer;\n\n\t\tif (hrtimer_try_to_cancel(timer) == 1)\n\t\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n}\n\nstatic void vmx_hardware_unsetup(void)\n{\n\tkvm_set_posted_intr_wakeup_handler(NULL);\n\n\tif (nested)\n\t\tnested_vmx_hardware_unsetup();\n\n\tfree_kvm_area();\n}\n\nstatic bool vmx_check_apicv_inhibit_reasons(enum kvm_apicv_inhibit reason)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_ABSENT) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_BLOCKIRQ);\n\n\treturn supported & BIT(reason);\n}\n\nstatic struct kvm_x86_ops vmx_x86_ops __initdata = {\n\t.name = \"kvm_intel\",\n\n\t.hardware_unsetup = vmx_hardware_unsetup,\n\n\t.hardware_enable = vmx_hardware_enable,\n\t.hardware_disable = vmx_hardware_disable,\n\t.has_emulated_msr = vmx_has_emulated_msr,\n\n\t.vm_size = sizeof(struct kvm_vmx),\n\t.vm_init = vmx_vm_init,\n\n\t.vcpu_create = vmx_vcpu_create,\n\t.vcpu_free = vmx_vcpu_free,\n\t.vcpu_reset = vmx_vcpu_reset,\n\n\t.prepare_switch_to_guest = vmx_prepare_switch_to_guest,\n\t.vcpu_load = vmx_vcpu_load,\n\t.vcpu_put = vmx_vcpu_put,\n\n\t.update_exception_bitmap = vmx_update_exception_bitmap,\n\t.get_msr_feature = vmx_get_msr_feature,\n\t.get_msr = vmx_get_msr,\n\t.set_msr = vmx_set_msr,\n\t.get_segment_base = vmx_get_segment_base,\n\t.get_segment = vmx_get_segment,\n\t.set_segment = vmx_set_segment,\n\t.get_cpl = vmx_get_cpl,\n\t.get_cs_db_l_bits = vmx_get_cs_db_l_bits,\n\t.set_cr0 = vmx_set_cr0,\n\t.is_valid_cr4 = vmx_is_valid_cr4,\n\t.set_cr4 = vmx_set_cr4,\n\t.set_efer = vmx_set_efer,\n\t.get_idt = vmx_get_idt,\n\t.set_idt = vmx_set_idt,\n\t.get_gdt = vmx_get_gdt,\n\t.set_gdt = vmx_set_gdt,\n\t.set_dr7 = vmx_set_dr7,\n\t.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,\n\t.cache_reg = vmx_cache_reg,\n\t.get_rflags = vmx_get_rflags,\n\t.set_rflags = vmx_set_rflags,\n\t.get_if_flag = vmx_get_if_flag,\n\n\t.flush_tlb_all = vmx_flush_tlb_all,\n\t.flush_tlb_current = vmx_flush_tlb_current,\n\t.flush_tlb_gva = vmx_flush_tlb_gva,\n\t.flush_tlb_guest = vmx_flush_tlb_guest,\n\n\t.vcpu_pre_run = vmx_vcpu_pre_run,\n\t.vcpu_run = vmx_vcpu_run,\n\t.handle_exit = vmx_handle_exit,\n\t.skip_emulated_instruction = vmx_skip_emulated_instruction,\n\t.update_emulated_instruction = vmx_update_emulated_instruction,\n\t.set_interrupt_shadow = vmx_set_interrupt_shadow,\n\t.get_interrupt_shadow = vmx_get_interrupt_shadow,\n\t.patch_hypercall = vmx_patch_hypercall,\n\t.inject_irq = vmx_inject_irq,\n\t.inject_nmi = vmx_inject_nmi,\n\t.queue_exception = vmx_queue_exception,\n\t.cancel_injection = vmx_cancel_injection,\n\t.interrupt_allowed = vmx_interrupt_allowed,\n\t.nmi_allowed = vmx_nmi_allowed,\n\t.get_nmi_mask = vmx_get_nmi_mask,\n\t.set_nmi_mask = vmx_set_nmi_mask,\n\t.enable_nmi_window = vmx_enable_nmi_window,\n\t.enable_irq_window = vmx_enable_irq_window,\n\t.update_cr8_intercept = vmx_update_cr8_intercept,\n\t.set_virtual_apic_mode = vmx_set_virtual_apic_mode,\n\t.set_apic_access_page_addr = vmx_set_apic_access_page_addr,\n\t.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,\n\t.load_eoi_exitmap = vmx_load_eoi_exitmap,\n\t.apicv_post_state_restore = vmx_apicv_post_state_restore,\n\t.check_apicv_inhibit_reasons = vmx_check_apicv_inhibit_reasons,\n\t.hwapic_irr_update = vmx_hwapic_irr_update,\n\t.hwapic_isr_update = vmx_hwapic_isr_update,\n\t.guest_apic_has_interrupt = vmx_guest_apic_has_interrupt,\n\t.sync_pir_to_irr = vmx_sync_pir_to_irr,\n\t.deliver_interrupt = vmx_deliver_interrupt,\n\t.dy_apicv_has_pending_interrupt = pi_has_pending_interrupt,\n\n\t.set_tss_addr = vmx_set_tss_addr,\n\t.set_identity_map_addr = vmx_set_identity_map_addr,\n\t.get_mt_mask = vmx_get_mt_mask,\n\n\t.get_exit_info = vmx_get_exit_info,\n\n\t.vcpu_after_set_cpuid = vmx_vcpu_after_set_cpuid,\n\n\t.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,\n\n\t.get_l2_tsc_offset = vmx_get_l2_tsc_offset,\n\t.get_l2_tsc_multiplier = vmx_get_l2_tsc_multiplier,\n\t.write_tsc_offset = vmx_write_tsc_offset,\n\t.write_tsc_multiplier = vmx_write_tsc_multiplier,\n\n\t.load_mmu_pgd = vmx_load_mmu_pgd,\n\n\t.check_intercept = vmx_check_intercept,\n\t.handle_exit_irqoff = vmx_handle_exit_irqoff,\n\n\t.request_immediate_exit = vmx_request_immediate_exit,\n\n\t.sched_in = vmx_sched_in,\n\n\t.cpu_dirty_log_size = PML_ENTITY_NUM,\n\t.update_cpu_dirty_logging = vmx_update_cpu_dirty_logging,\n\n\t.nested_ops = &vmx_nested_ops,\n\n\t.pi_update_irte = vmx_pi_update_irte,\n\t.pi_start_assignment = vmx_pi_start_assignment,\n\n#ifdef CONFIG_X86_64\n\t.set_hv_timer = vmx_set_hv_timer,\n\t.cancel_hv_timer = vmx_cancel_hv_timer,\n#endif\n\n\t.setup_mce = vmx_setup_mce,\n\n\t.smi_allowed = vmx_smi_allowed,\n\t.enter_smm = vmx_enter_smm,\n\t.leave_smm = vmx_leave_smm,\n\t.enable_smi_window = vmx_enable_smi_window,\n\n\t.can_emulate_instruction = vmx_can_emulate_instruction,\n\t.apic_init_signal_blocked = vmx_apic_init_signal_blocked,\n\t.migrate_timers = vmx_migrate_timers,\n\n\t.msr_filter_changed = vmx_msr_filter_changed,\n\t.complete_emulated_msr = kvm_complete_insn_gp,\n\n\t.vcpu_deliver_sipi_vector = kvm_vcpu_deliver_sipi_vector,\n};\n\nstatic unsigned int vmx_handle_intel_pt_intr(void)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\n\t/* '0' on failure so that the !PT case can use a RET0 static call. */\n\tif (!vcpu || !kvm_handling_nmi_from_guest(vcpu))\n\t\treturn 0;\n\n\tkvm_make_request(KVM_REQ_PMI, vcpu);\n\t__set_bit(MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT,\n\t\t  (unsigned long *)&vcpu->arch.pmu.global_status);\n\treturn 1;\n}\n\nstatic __init void vmx_setup_user_return_msrs(void)\n{\n\n\t/*\n\t * Though SYSCALL is only supported in 64-bit mode on Intel CPUs, kvm\n\t * will emulate SYSCALL in legacy mode if the vendor string in guest\n\t * CPUID.0:{EBX,ECX,EDX} is \"AuthenticAMD\" or \"AMDisbetter!\" To\n\t * support this emulation, MSR_STAR is included in the list for i386,\n\t * but is never loaded into hardware.  MSR_CSTAR is also never loaded\n\t * into hardware and is here purely for emulation purposes.\n\t */\n\tconst u32 vmx_uret_msrs_list[] = {\n\t#ifdef CONFIG_X86_64\n\t\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n\t#endif\n\t\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n\t\tMSR_IA32_TSX_CTRL,\n\t};\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_uret_msrs_list) != MAX_NR_USER_RETURN_MSRS);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_uret_msrs_list); ++i)\n\t\tkvm_add_user_return_msr(vmx_uret_msrs_list[i]);\n}\n\nstatic void __init vmx_setup_me_spte_mask(void)\n{\n\tu64 me_mask = 0;\n\n\t/*\n\t * kvm_get_shadow_phys_bits() returns shadow_phys_bits.  Use\n\t * the former to avoid exposing shadow_phys_bits.\n\t *\n\t * On pre-MKTME system, boot_cpu_data.x86_phys_bits equals to\n\t * shadow_phys_bits.  On MKTME and/or TDX capable systems,\n\t * boot_cpu_data.x86_phys_bits holds the actual physical address\n\t * w/o the KeyID bits, and shadow_phys_bits equals to MAXPHYADDR\n\t * reported by CPUID.  Those bits between are KeyID bits.\n\t */\n\tif (boot_cpu_data.x86_phys_bits != kvm_get_shadow_phys_bits())\n\t\tme_mask = rsvd_bits(boot_cpu_data.x86_phys_bits,\n\t\t\tkvm_get_shadow_phys_bits() - 1);\n\t/*\n\t * Unlike SME, host kernel doesn't support setting up any\n\t * MKTME KeyID on Intel platforms.  No memory encryption\n\t * bits should be included into the SPTE.\n\t */\n\tkvm_mmu_set_me_spte_mask(0, me_mask);\n}\n\nstatic struct kvm_x86_init_ops vmx_init_ops __initdata;\n\nstatic __init int hardware_setup(void)\n{\n\tunsigned long host_bndcfgs;\n\tstruct desc_ptr dt;\n\tint r;\n\n\tstore_idt(&dt);\n\thost_idt_base = dt.address;\n\n\tvmx_setup_user_return_msrs();\n\n\tif (setup_vmcs_config(&vmcs_config, &vmx_capability) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_MPX)) {\n\t\trdmsrl(MSR_IA32_BNDCFGS, host_bndcfgs);\n\t\tWARN_ONCE(host_bndcfgs, \"KVM: BNDCFGS in host will be lost\");\n\t}\n\n\tif (!cpu_has_vmx_mpx())\n\t\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS |\n\t\t\t\t    XFEATURE_MASK_BNDCSR);\n\n\tif (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||\n\t    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))\n\t\tenable_vpid = 0;\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels() ||\n\t    !cpu_has_vmx_ept_mt_wb() ||\n\t    !cpu_has_vmx_invept_global())\n\t\tenable_ept = 0;\n\n\t/* NX support is required for shadow paging. */\n\tif (!enable_ept && !boot_cpu_has(X86_FEATURE_NX)) {\n\t\tpr_err_ratelimited(\"kvm: NX (Execute Disable) not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits() || !enable_ept)\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest() || !enable_ept)\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\tif (!cpu_has_virtual_nmis())\n\t\tenable_vnmi = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tvmx_x86_ops.set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tvmx_x86_ops.update_cr8_intercept = NULL;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (ms_hyperv.nested_features & HV_X64_NESTED_GUEST_MAPPING_FLUSH\n\t    && enable_ept) {\n\t\tvmx_x86_ops.tlb_remote_flush = hv_remote_flush_tlb;\n\t\tvmx_x86_ops.tlb_remote_flush_with_range =\n\t\t\t\thv_remote_flush_tlb_with_range;\n\t}\n#endif\n\n\tif (!cpu_has_vmx_ple()) {\n\t\tple_gap = 0;\n\t\tple_window = 0;\n\t\tple_window_grow = 0;\n\t\tple_window_max = 0;\n\t\tple_window_shrink = 0;\n\t}\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\tif (!enable_apicv)\n\t\tvmx_x86_ops.sync_pir_to_irr = NULL;\n\n\tif (cpu_has_vmx_tsc_scaling())\n\t\tkvm_has_tsc_control = true;\n\n\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\tkvm_has_bus_lock_exit = cpu_has_vmx_bus_lock_detection();\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tif (enable_ept)\n\t\tkvm_mmu_set_ept_masks(enable_ept_ad_bits,\n\t\t\t\t      cpu_has_vmx_ept_execute_only());\n\n\t/*\n\t * Setup shadow_me_value/shadow_me_mask to include MKTME KeyID\n\t * bits to shadow_zero_check.\n\t */\n\tvmx_setup_me_spte_mask();\n\n\tkvm_configure_mmu(enable_ept, 0, vmx_get_max_tdp_level(),\n\t\t\t  ept_caps_to_lpage_level(vmx_capability.ept));\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml)\n\t\tvmx_x86_ops.cpu_dirty_log_size = 0;\n\n\tif (!cpu_has_vmx_preemption_timer())\n\t\tenable_preemption_timer = false;\n\n\tif (enable_preemption_timer) {\n\t\tu64 use_timer_freq = 5000ULL * 1000 * 1000;\n\t\tu64 vmx_msr;\n\n\t\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t\tcpu_preemption_timer_multi =\n\t\t\tvmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;\n\n\t\tif (tsc_khz)\n\t\t\tuse_timer_freq = (u64)tsc_khz * 1000;\n\t\tuse_timer_freq >>= cpu_preemption_timer_multi;\n\n\t\t/*\n\t\t * KVM \"disables\" the preemption timer by setting it to its max\n\t\t * value.  Don't use the timer if it might cause spurious exits\n\t\t * at a rate faster than 0.1 Hz (of uninterrupted guest time).\n\t\t */\n\t\tif (use_timer_freq > 0xffffffffu / 10)\n\t\t\tenable_preemption_timer = false;\n\t}\n\n\tif (!enable_preemption_timer) {\n\t\tvmx_x86_ops.set_hv_timer = NULL;\n\t\tvmx_x86_ops.cancel_hv_timer = NULL;\n\t\tvmx_x86_ops.request_immediate_exit = __kvm_request_immediate_exit;\n\t}\n\n\tkvm_mce_cap_supported |= MCG_LMCE_P;\n\n\tif (pt_mode != PT_MODE_SYSTEM && pt_mode != PT_MODE_HOST_GUEST)\n\t\treturn -EINVAL;\n\tif (!enable_ept || !cpu_has_vmx_intel_pt())\n\t\tpt_mode = PT_MODE_SYSTEM;\n\tif (pt_mode == PT_MODE_HOST_GUEST)\n\t\tvmx_init_ops.handle_intel_pt_intr = vmx_handle_intel_pt_intr;\n\telse\n\t\tvmx_init_ops.handle_intel_pt_intr = NULL;\n\n\tsetup_default_sgx_lepubkeyhash();\n\n\tif (nested) {\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_config.nested,\n\t\t\t\t\t   vmx_capability.ept);\n\n\t\tr = nested_vmx_hardware_setup(kvm_vmx_exit_handlers);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tvmx_set_cpu_caps();\n\n\tr = alloc_kvm_area();\n\tif (r && nested)\n\t\tnested_vmx_hardware_unsetup();\n\n\tkvm_set_posted_intr_wakeup_handler(pi_wakeup_handler);\n\n\treturn r;\n}\n\nstatic struct kvm_x86_init_ops vmx_init_ops __initdata = {\n\t.cpu_has_kvm_support = cpu_has_kvm_support,\n\t.disabled_by_bios = vmx_disabled_by_bios,\n\t.check_processor_compatibility = vmx_check_processor_compat,\n\t.hardware_setup = hardware_setup,\n\t.handle_intel_pt_intr = NULL,\n\n\t.runtime_ops = &vmx_x86_ops,\n\t.pmu_ops = &intel_pmu_ops,\n};\n\nstatic void vmx_cleanup_l1d_flush(void)\n{\n\tif (vmx_l1d_flush_pages) {\n\t\tfree_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);\n\t\tvmx_l1d_flush_pages = NULL;\n\t}\n\t/* Restore state so sysfs ignores VMX */\n\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;\n}\n\nstatic void vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tint cpu;\n\t\tstruct hv_vp_assist_page *vp_ap;\n\t\t/*\n\t\t * Reset everything to support using non-enlightened VMCS\n\t\t * access later (e.g. when we reload the module with\n\t\t * enlightened_vmcs=0)\n\t\t */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tvp_ap =\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 0;\n\t\t\tvp_ap->current_nested_vmcs = 0;\n\t\t\tvp_ap->enlighten_vmentry = 0;\n\t\t}\n\n\t\tstatic_branch_disable(&enable_evmcs);\n\t}\n#endif\n\tvmx_cleanup_l1d_flush();\n\n\tallow_smaller_maxphyaddr = false;\n}\nmodule_exit(vmx_exit);\n\nstatic int __init vmx_init(void)\n{\n\tint r, cpu;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\t/*\n\t * Enlightened VMCS usage should be recommended and the host needs\n\t * to support eVMCS v1 or above. We can also disable eVMCS support\n\t * with module parameter.\n\t */\n\tif (enlightened_vmcs &&\n\t    ms_hyperv.hints & HV_X64_ENLIGHTENED_VMCS_RECOMMENDED &&\n\t    (ms_hyperv.nested_features & HV_X64_ENLIGHTENED_VMCS_VERSION) >=\n\t    KVM_EVMCS_VERSION) {\n\n\t\t/* Check that we have assist pages on all online CPUs */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tif (!hv_get_vp_assist_page(cpu)) {\n\t\t\t\tenlightened_vmcs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (enlightened_vmcs) {\n\t\t\tpr_info(\"KVM: vmx: using Hyper-V Enlightened VMCS\\n\");\n\t\t\tstatic_branch_enable(&enable_evmcs);\n\t\t}\n\n\t\tif (ms_hyperv.nested_features & HV_X64_NESTED_DIRECT_FLUSH)\n\t\t\tvmx_x86_ops.enable_direct_tlbflush\n\t\t\t\t= hv_enable_direct_tlbflush;\n\n\t} else {\n\t\tenlightened_vmcs = false;\n\t}\n#endif\n\n\tr = kvm_init(&vmx_init_ops, sizeof(struct vcpu_vmx),\n\t\t     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Must be called after kvm_init() so enable_ept is properly set\n\t * up. Hand the parameter mitigation value in which was stored in\n\t * the pre module init parser. If no parameter was given, it will\n\t * contain 'auto' which will be turned into the default 'cond'\n\t * mitigation mode.\n\t */\n\tr = vmx_setup_l1d_flush(vmentry_l1d_flush_param);\n\tif (r) {\n\t\tvmx_exit();\n\t\treturn r;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\n\t\tpi_init_cpu(cpu);\n\t}\n\n#ifdef CONFIG_KEXEC_CORE\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\tvmx_check_vmcs12_offsets();\n\n\t/*\n\t * Shadow paging doesn't have a (further) performance penalty\n\t * from GUEST_MAXPHYADDR < HOST_MAXPHYADDR so enable it\n\t * by default\n\t */\n\tif (!enable_ept)\n\t\tallow_smaller_maxphyaddr = true;\n\n\treturn 0;\n}\nmodule_init(vmx_init);\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * derived from drivers/kvm/kvm_main.c\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2008 Qumranet, Inc.\n * Copyright IBM Corporation, 2008\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Amit Shah    <amit.shah@qumranet.com>\n *   Ben-Ami Yassour <benami@il.ibm.com>\n */\n\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include \"mmu.h\"\n#include \"i8254.h\"\n#include \"tss.h\"\n#include \"kvm_cache_regs.h\"\n#include \"kvm_emulate.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n#include \"pmu.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"xen.h\"\n\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/kvm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/mman.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/intel-iommu.h>\n#include <linux/cpufreq.h>\n#include <linux/user-return-notifier.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/uaccess.h>\n#include <linux/hash.h>\n#include <linux/pci.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/irqbypass.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/isolation.h>\n#include <linux/mem_encrypt.h>\n#include <linux/entry-kvm.h>\n#include <linux/suspend.h>\n\n#include <trace/events/kvm.h>\n\n#include <asm/debugreg.h>\n#include <asm/msr.h>\n#include <asm/desc.h>\n#include <asm/mce.h>\n#include <asm/pkru.h>\n#include <linux/kernel_stat.h>\n#include <asm/fpu/api.h>\n#include <asm/fpu/xcr.h>\n#include <asm/fpu/xstate.h>\n#include <asm/pvclock.h>\n#include <asm/div64.h>\n#include <asm/irq_remapping.h>\n#include <asm/mshyperv.h>\n#include <asm/hypervisor.h>\n#include <asm/tlbflush.h>\n#include <asm/intel_pt.h>\n#include <asm/emulate_prefix.h>\n#include <asm/sgx.h>\n#include <clocksource/hyperv_timer.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#define MAX_IO_MSRS 256\n#define KVM_MAX_MCE_BANKS 32\nu64 __read_mostly kvm_mce_cap_supported = MCG_CTL_P | MCG_SER_P;\nEXPORT_SYMBOL_GPL(kvm_mce_cap_supported);\n\n#define  ERR_PTR_USR(e)  ((void __user *)ERR_PTR(e))\n\n#define emul_to_vcpu(ctxt) \\\n\t((struct kvm_vcpu *)(ctxt)->vcpu)\n\n/* EFER defaults:\n * - enable syscall per default because its emulated by KVM\n * - enable LME and LMA per default on 64 bit KVM\n */\n#ifdef CONFIG_X86_64\nstatic\nu64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));\n#else\nstatic u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);\n#endif\n\nstatic u64 __read_mostly cr4_reserved_bits = CR4_RESERVED_BITS;\n\n#define KVM_EXIT_HYPERCALL_VALID_MASK (1 << KVM_HC_MAP_GPA_RANGE)\n\n#define KVM_CAP_PMU_VALID_MASK KVM_PMU_CAP_DISABLE\n\n#define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS | \\\n                                    KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void process_smi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu);\n\nstatic int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);\nstatic void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);\n\nstruct kvm_x86_ops kvm_x86_ops __read_mostly;\n\n#define KVM_X86_OP(func)\t\t\t\t\t     \\\n\tDEFINE_STATIC_CALL_NULL(kvm_x86_##func,\t\t\t     \\\n\t\t\t\t*(((struct kvm_x86_ops *)0)->func));\n#define KVM_X86_OP_OPTIONAL KVM_X86_OP\n#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP\n#include <asm/kvm-x86-ops.h>\nEXPORT_STATIC_CALL_GPL(kvm_x86_get_cs_db_l_bits);\nEXPORT_STATIC_CALL_GPL(kvm_x86_cache_reg);\n\nstatic bool __read_mostly ignore_msrs = 0;\nmodule_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);\n\nbool __read_mostly report_ignored_msrs = true;\nmodule_param(report_ignored_msrs, bool, S_IRUGO | S_IWUSR);\nEXPORT_SYMBOL_GPL(report_ignored_msrs);\n\nunsigned int min_timer_period_us = 200;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nstatic bool __read_mostly kvmclock_periodic_sync = true;\nmodule_param(kvmclock_periodic_sync, bool, S_IRUGO);\n\nbool __read_mostly kvm_has_tsc_control;\nEXPORT_SYMBOL_GPL(kvm_has_tsc_control);\nu32  __read_mostly kvm_max_guest_tsc_khz;\nEXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);\nu8   __read_mostly kvm_tsc_scaling_ratio_frac_bits;\nEXPORT_SYMBOL_GPL(kvm_tsc_scaling_ratio_frac_bits);\nu64  __read_mostly kvm_max_tsc_scaling_ratio;\nEXPORT_SYMBOL_GPL(kvm_max_tsc_scaling_ratio);\nu64 __read_mostly kvm_default_tsc_scaling_ratio;\nEXPORT_SYMBOL_GPL(kvm_default_tsc_scaling_ratio);\nbool __read_mostly kvm_has_bus_lock_exit;\nEXPORT_SYMBOL_GPL(kvm_has_bus_lock_exit);\n\n/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */\nstatic u32 __read_mostly tsc_tolerance_ppm = 250;\nmodule_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);\n\n/*\n * lapic timer advance (tscdeadline mode only) in nanoseconds.  '-1' enables\n * adaptive tuning starting from default advancement of 1000ns.  '0' disables\n * advancement entirely.  Any other value is used as-is and disables adaptive\n * tuning, i.e. allows privileged userspace to set an exact advancement time.\n */\nstatic int __read_mostly lapic_timer_advance_ns = -1;\nmodule_param(lapic_timer_advance_ns, int, S_IRUGO | S_IWUSR);\n\nstatic bool __read_mostly vector_hashing = true;\nmodule_param(vector_hashing, bool, S_IRUGO);\n\nbool __read_mostly enable_vmware_backdoor = false;\nmodule_param(enable_vmware_backdoor, bool, S_IRUGO);\nEXPORT_SYMBOL_GPL(enable_vmware_backdoor);\n\nstatic bool __read_mostly force_emulation_prefix = false;\nmodule_param(force_emulation_prefix, bool, S_IRUGO);\n\nint __read_mostly pi_inject_timer = -1;\nmodule_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);\n\n/* Enable/disable PMU virtualization */\nbool __read_mostly enable_pmu = true;\nEXPORT_SYMBOL_GPL(enable_pmu);\nmodule_param(enable_pmu, bool, 0444);\n\nbool __read_mostly eager_page_split = true;\nmodule_param(eager_page_split, bool, 0644);\n\n/*\n * Restoring the host value for MSRs that are only consumed when running in\n * usermode, e.g. SYSCALL MSRs and TSC_AUX, can be deferred until the CPU\n * returns to userspace, i.e. the kernel can run with the guest's value.\n */\n#define KVM_MAX_NR_USER_RETURN_MSRS 16\n\nstruct kvm_user_return_msrs {\n\tstruct user_return_notifier urn;\n\tbool registered;\n\tstruct kvm_user_return_msr_values {\n\t\tu64 host;\n\t\tu64 curr;\n\t} values[KVM_MAX_NR_USER_RETURN_MSRS];\n};\n\nu32 __read_mostly kvm_nr_uret_msrs;\nEXPORT_SYMBOL_GPL(kvm_nr_uret_msrs);\nstatic u32 __read_mostly kvm_uret_msrs_list[KVM_MAX_NR_USER_RETURN_MSRS];\nstatic struct kvm_user_return_msrs __percpu *user_return_msrs;\n\n#define KVM_SUPPORTED_XCR0     (XFEATURE_MASK_FP | XFEATURE_MASK_SSE \\\n\t\t\t\t| XFEATURE_MASK_YMM | XFEATURE_MASK_BNDREGS \\\n\t\t\t\t| XFEATURE_MASK_BNDCSR | XFEATURE_MASK_AVX512 \\\n\t\t\t\t| XFEATURE_MASK_PKRU | XFEATURE_MASK_XTILE)\n\nu64 __read_mostly host_efer;\nEXPORT_SYMBOL_GPL(host_efer);\n\nbool __read_mostly allow_smaller_maxphyaddr = 0;\nEXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);\n\nbool __read_mostly enable_apicv = true;\nEXPORT_SYMBOL_GPL(enable_apicv);\n\nu64 __read_mostly host_xss;\nEXPORT_SYMBOL_GPL(host_xss);\nu64 __read_mostly supported_xss;\nEXPORT_SYMBOL_GPL(supported_xss);\n\nconst struct _kvm_stats_desc kvm_vm_stats_desc[] = {\n\tKVM_GENERIC_VM_STATS(),\n\tSTATS_DESC_COUNTER(VM, mmu_shadow_zapped),\n\tSTATS_DESC_COUNTER(VM, mmu_pte_write),\n\tSTATS_DESC_COUNTER(VM, mmu_pde_zapped),\n\tSTATS_DESC_COUNTER(VM, mmu_flooded),\n\tSTATS_DESC_COUNTER(VM, mmu_recycled),\n\tSTATS_DESC_COUNTER(VM, mmu_cache_miss),\n\tSTATS_DESC_ICOUNTER(VM, mmu_unsync),\n\tSTATS_DESC_ICOUNTER(VM, pages_4k),\n\tSTATS_DESC_ICOUNTER(VM, pages_2m),\n\tSTATS_DESC_ICOUNTER(VM, pages_1g),\n\tSTATS_DESC_ICOUNTER(VM, nx_lpage_splits),\n\tSTATS_DESC_PCOUNTER(VM, max_mmu_rmap_size),\n\tSTATS_DESC_PCOUNTER(VM, max_mmu_page_hash_collisions)\n};\n\nconst struct kvm_stats_header kvm_vm_stats_header = {\n\t.name_size = KVM_STATS_NAME_SIZE,\n\t.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),\n\t.id_offset = sizeof(struct kvm_stats_header),\n\t.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,\n\t.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +\n\t\t       sizeof(kvm_vm_stats_desc),\n};\n\nconst struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {\n\tKVM_GENERIC_VCPU_STATS(),\n\tSTATS_DESC_COUNTER(VCPU, pf_taken),\n\tSTATS_DESC_COUNTER(VCPU, pf_fixed),\n\tSTATS_DESC_COUNTER(VCPU, pf_emulate),\n\tSTATS_DESC_COUNTER(VCPU, pf_spurious),\n\tSTATS_DESC_COUNTER(VCPU, pf_fast),\n\tSTATS_DESC_COUNTER(VCPU, pf_mmio_spte_created),\n\tSTATS_DESC_COUNTER(VCPU, pf_guest),\n\tSTATS_DESC_COUNTER(VCPU, tlb_flush),\n\tSTATS_DESC_COUNTER(VCPU, invlpg),\n\tSTATS_DESC_COUNTER(VCPU, exits),\n\tSTATS_DESC_COUNTER(VCPU, io_exits),\n\tSTATS_DESC_COUNTER(VCPU, mmio_exits),\n\tSTATS_DESC_COUNTER(VCPU, signal_exits),\n\tSTATS_DESC_COUNTER(VCPU, irq_window_exits),\n\tSTATS_DESC_COUNTER(VCPU, nmi_window_exits),\n\tSTATS_DESC_COUNTER(VCPU, l1d_flush),\n\tSTATS_DESC_COUNTER(VCPU, halt_exits),\n\tSTATS_DESC_COUNTER(VCPU, request_irq_exits),\n\tSTATS_DESC_COUNTER(VCPU, irq_exits),\n\tSTATS_DESC_COUNTER(VCPU, host_state_reload),\n\tSTATS_DESC_COUNTER(VCPU, fpu_reload),\n\tSTATS_DESC_COUNTER(VCPU, insn_emulation),\n\tSTATS_DESC_COUNTER(VCPU, insn_emulation_fail),\n\tSTATS_DESC_COUNTER(VCPU, hypercalls),\n\tSTATS_DESC_COUNTER(VCPU, irq_injections),\n\tSTATS_DESC_COUNTER(VCPU, nmi_injections),\n\tSTATS_DESC_COUNTER(VCPU, req_event),\n\tSTATS_DESC_COUNTER(VCPU, nested_run),\n\tSTATS_DESC_COUNTER(VCPU, directed_yield_attempted),\n\tSTATS_DESC_COUNTER(VCPU, directed_yield_successful),\n\tSTATS_DESC_ICOUNTER(VCPU, guest_mode)\n};\n\nconst struct kvm_stats_header kvm_vcpu_stats_header = {\n\t.name_size = KVM_STATS_NAME_SIZE,\n\t.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),\n\t.id_offset = sizeof(struct kvm_stats_header),\n\t.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,\n\t.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +\n\t\t       sizeof(kvm_vcpu_stats_desc),\n};\n\nu64 __read_mostly host_xcr0;\nu64 __read_mostly supported_xcr0;\nEXPORT_SYMBOL_GPL(supported_xcr0);\n\nstatic struct kmem_cache *x86_emulator_cache;\n\n/*\n * When called, it means the previous get/set msr reached an invalid msr.\n * Return true if we want to ignore/silent this failed msr access.\n */\nstatic bool kvm_msr_ignored_check(u32 msr, u64 data, bool write)\n{\n\tconst char *op = write ? \"wrmsr\" : \"rdmsr\";\n\n\tif (ignore_msrs) {\n\t\tif (report_ignored_msrs)\n\t\t\tkvm_pr_unimpl(\"ignored %s: 0x%x data 0x%llx\\n\",\n\t\t\t\t      op, msr, data);\n\t\t/* Mask the error */\n\t\treturn true;\n\t} else {\n\t\tkvm_debug_ratelimited(\"unhandled %s: 0x%x data 0x%llx\\n\",\n\t\t\t\t      op, msr, data);\n\t\treturn false;\n\t}\n}\n\nstatic struct kmem_cache *kvm_alloc_emulator_cache(void)\n{\n\tunsigned int useroffset = offsetof(struct x86_emulate_ctxt, src);\n\tunsigned int size = sizeof(struct x86_emulate_ctxt);\n\n\treturn kmem_cache_create_usercopy(\"x86_emulator\", size,\n\t\t\t\t\t  __alignof__(struct x86_emulate_ctxt),\n\t\t\t\t\t  SLAB_ACCOUNT, useroffset,\n\t\t\t\t\t  size - useroffset, NULL);\n}\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < ASYNC_PF_PER_VCPU; i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_user_return_msrs *msrs\n\t\t= container_of(urn, struct kvm_user_return_msrs, urn);\n\tstruct kvm_user_return_msr_values *values;\n\tunsigned long flags;\n\n\t/*\n\t * Disabling irqs at this point since the following code could be\n\t * interrupted and executed through kvm_arch_hardware_disable()\n\t */\n\tlocal_irq_save(flags);\n\tif (msrs->registered) {\n\t\tmsrs->registered = false;\n\t\tuser_return_notifier_unregister(urn);\n\t}\n\tlocal_irq_restore(flags);\n\tfor (slot = 0; slot < kvm_nr_uret_msrs; ++slot) {\n\t\tvalues = &msrs->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(kvm_uret_msrs_list[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n}\n\nstatic int kvm_probe_user_return_msr(u32 msr)\n{\n\tu64 val;\n\tint ret;\n\n\tpreempt_disable();\n\tret = rdmsrl_safe(msr, &val);\n\tif (ret)\n\t\tgoto out;\n\tret = wrmsrl_safe(msr, val);\nout:\n\tpreempt_enable();\n\treturn ret;\n}\n\nint kvm_add_user_return_msr(u32 msr)\n{\n\tBUG_ON(kvm_nr_uret_msrs >= KVM_MAX_NR_USER_RETURN_MSRS);\n\n\tif (kvm_probe_user_return_msr(msr))\n\t\treturn -1;\n\n\tkvm_uret_msrs_list[kvm_nr_uret_msrs] = msr;\n\treturn kvm_nr_uret_msrs++;\n}\nEXPORT_SYMBOL_GPL(kvm_add_user_return_msr);\n\nint kvm_find_user_return_msr(u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < kvm_nr_uret_msrs; ++i) {\n\t\tif (kvm_uret_msrs_list[i] == msr)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(kvm_find_user_return_msr);\n\nstatic void kvm_user_return_msr_cpu_online(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);\n\tu64 value;\n\tint i;\n\n\tfor (i = 0; i < kvm_nr_uret_msrs; ++i) {\n\t\trdmsrl_safe(kvm_uret_msrs_list[i], &value);\n\t\tmsrs->values[i].host = value;\n\t\tmsrs->values[i].curr = value;\n\t}\n}\n\nint kvm_set_user_return_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);\n\tint err;\n\n\tvalue = (value & mask) | (msrs->values[slot].host & ~mask);\n\tif (value == msrs->values[slot].curr)\n\t\treturn 0;\n\terr = wrmsrl_safe(kvm_uret_msrs_list[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tmsrs->values[slot].curr = value;\n\tif (!msrs->registered) {\n\t\tmsrs->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&msrs->urn);\n\t\tmsrs->registered = true;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_user_return_msr);\n\nstatic void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);\n\n\tif (msrs->registered)\n\t\tkvm_on_user_return(&msrs->urn);\n}\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_base);\n\nenum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_mode(kvm_get_apic_base(vcpu));\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_mode);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tenum lapic_mode old_mode = kvm_get_apic_mode(vcpu);\n\tenum lapic_mode new_mode = kvm_apic_mode(msr_info->data);\n\tu64 reserved_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu) | 0x2ff |\n\t\t(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);\n\n\tif ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)\n\t\treturn 1;\n\tif (!msr_info->host_initiated) {\n\t\tif (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)\n\t\t\treturn 1;\n\t\tif (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)\n\t\t\treturn 1;\n\t}\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\tkvm_recalculate_apic_map(vcpu->kvm);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_apic_base);\n\n/*\n * Handle a fault on a hardware virtualization (VMX or SVM) instruction.\n *\n * Hardware virtualization extension instructions may fault if a reboot turns\n * off virtualization while processes are running.  Usually after catching the\n * fault we just panic; during reboot instead the instruction is ignored.\n */\nnoinstr void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG_ON(!kvm_rebooting);\n}\nEXPORT_SYMBOL_GPL(kvm_spurious_fault);\n\n#define EXCPT_BENIGN\t\t0\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_PF\t\t2\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}\n\n#define EXCPT_FAULT\t\t0\n#define EXCPT_TRAP\t\t1\n#define EXCPT_ABORT\t\t2\n#define EXCPT_INTERRUPT\t\t3\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}\n\nvoid kvm_deliver_exception_payload(struct kvm_vcpu *vcpu)\n{\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_payload = vcpu->arch.exception.has_payload;\n\tunsigned long payload = vcpu->arch.exception.payload;\n\n\tif (!has_payload)\n\t\treturn;\n\n\tswitch (nr) {\n\tcase DB_VECTOR:\n\t\t/*\n\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t * remaining contents of the DR6 register are never\n\t\t * cleared by the processor\".\n\t\t */\n\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t/*\n\t\t * In order to reflect the #DB exception payload in guest\n\t\t * dr6, three components need to be considered: active low\n\t\t * bit, FIXED_1 bits and active high bits (e.g. DR6_BD,\n\t\t * DR6_BS and DR6_BT)\n\t\t * DR6_ACTIVE_LOW contains the FIXED_1 and active low bits.\n\t\t * In the target guest dr6:\n\t\t * FIXED_1 bits should always be set.\n\t\t * Active low bits should be cleared if 1-setting in payload.\n\t\t * Active high bits should be set if 1-setting in payload.\n\t\t *\n\t\t * Note, the payload is compatible with the pending debug\n\t\t * exceptions/exit qualification under VMX, that active_low bits\n\t\t * are active high in payload.\n\t\t * So they need to be flipped for DR6.\n\t\t */\n\t\tvcpu->arch.dr6 |= DR6_ACTIVE_LOW;\n\t\tvcpu->arch.dr6 |= payload;\n\t\tvcpu->arch.dr6 ^= payload & DR6_ACTIVE_LOW;\n\n\t\t/*\n\t\t * The #DB payload is defined as compatible with the 'pending\n\t\t * debug exceptions' field under VMX, not DR6. While bit 12 is\n\t\t * defined in the 'pending debug exceptions' field (enabled\n\t\t * breakpoint), it is reserved and must be zero in DR6.\n\t\t */\n\t\tvcpu->arch.dr6 &= ~BIT(12);\n\t\tbreak;\n\tcase PF_VECTOR:\n\t\tvcpu->arch.cr2 = payload;\n\t\tbreak;\n\t}\n\n\tvcpu->arch.exception.has_payload = false;\n\tvcpu->arch.exception.payload = 0;\n}\nEXPORT_SYMBOL_GPL(kvm_deliver_exception_payload);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t        bool has_payload, unsigned long payload, bool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending && !vcpu->arch.exception.injected) {\n\tqueue:\n\t\tif (reinject) {\n\t\t\t/*\n\t\t\t * On vmentry, vcpu->arch.exception.pending is only\n\t\t\t * true if an event injection was blocked by\n\t\t\t * nested_run_pending.  In that case, however,\n\t\t\t * vcpu_enter_guest requests an immediate exit,\n\t\t\t * and the guest shouldn't proceed far enough to\n\t\t\t * need reinjection.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(vcpu->arch.exception.pending);\n\t\t\tvcpu->arch.exception.injected = true;\n\t\t\tif (WARN_ON_ONCE(has_payload)) {\n\t\t\t\t/*\n\t\t\t\t * A reinjected event has already\n\t\t\t\t * delivered its payload.\n\t\t\t\t */\n\t\t\t\thas_payload = false;\n\t\t\t\tpayload = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tvcpu->arch.exception.pending = true;\n\t\t\tvcpu->arch.exception.injected = false;\n\t\t}\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.has_payload = has_payload;\n\t\tvcpu->arch.exception.payload = payload;\n\t\tif (!is_guest_mode(vcpu))\n\t\t\tkvm_deliver_exception_payload(vcpu);\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/*\n\t\t * Generate double fault per SDM Table 5-5.  Set\n\t\t * exception.pending = true so that the double fault\n\t\t * can trigger a nested vmexit.\n\t\t */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.injected = false;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t\tvcpu->arch.exception.has_payload = false;\n\t\tvcpu->arch.exception.payload = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception);\n\nvoid kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t   unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_p);\n\nstatic void kvm_queue_exception_e_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\t    u32 error_code, unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code,\n\t\t\t       true, payload, false);\n}\n\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(kvm_complete_insn_gp);\n\nstatic int complete_emulated_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE | EMULTYPE_SKIP |\n\t\t\t\t       EMULTYPE_COMPLETE_USER_EXIT);\n}\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.exception.nested_apf =\n\t\tis_guest_mode(vcpu) && fault->async_page_fault;\n\tif (vcpu->arch.exception.nested_apf) {\n\t\tvcpu->arch.apf.nested_apf_token = fault->address;\n\t\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n\t} else {\n\t\tkvm_queue_exception_e_p(vcpu, PF_VECTOR, fault->error_code,\n\t\t\t\t\tfault->address);\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_inject_page_fault);\n\n/* Returns true if the page fault was immediately morphed into a VM-Exit. */\nbool kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct x86_exception *fault)\n{\n\tstruct kvm_mmu *fault_mmu;\n\tWARN_ON_ONCE(fault->vector != PF_VECTOR);\n\n\tfault_mmu = fault->nested_page_fault ? vcpu->arch.mmu :\n\t\t\t\t\t       vcpu->arch.walk_mmu;\n\n\t/*\n\t * Invalidate the TLB entry for the faulting address, if it exists,\n\t * else the access will fault indefinitely (and to emulate hardware).\n\t */\n\tif ((fault->error_code & PFERR_PRESENT_MASK) &&\n\t    !(fault->error_code & PFERR_RSVD_MASK))\n\t\tkvm_mmu_invalidate_gva(vcpu, fault_mmu, fault->address,\n\t\t\t\t       fault_mmu->root.hpa);\n\n\t/*\n\t * A workaround for KVM's bad exception handling.  If KVM injected an\n\t * exception into L2, and L2 encountered a #PF while vectoring the\n\t * injected exception, manually check to see if L1 wants to intercept\n\t * #PF, otherwise queuing the #PF will lead to #DF or a lost exception.\n\t * In all other cases, defer the check to nested_ops->check_events(),\n\t * which will correctly handle priority (this does not).  Note, other\n\t * exceptions, e.g. #GP, are theoretically affected, #PF is simply the\n\t * most problematic, e.g. when L0 and L1 are both intercepting #PF for\n\t * shadow paging.\n\t *\n\t * TODO: Rewrite exception handling to track injected and pending\n\t *       (VM-Exit) exceptions separately.\n\t */\n\tif (unlikely(vcpu->arch.exception.injected && is_guest_mode(vcpu)) &&\n\t    kvm_x86_ops.nested_ops->handle_page_fault_workaround(vcpu, fault))\n\t\treturn true;\n\n\tfault_mmu->inject_page_fault(vcpu, fault);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_nmi);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception_e);\n\n/*\n * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n * a #GP and return false.\n */\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (static_call(kvm_x86_get_cpl)(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_cpl);\n\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_dr);\n\nstatic inline u64 pdptr_rsvd_bits(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.reserved_gpa_bits | rsvd_bits(5, 8) | rsvd_bits(1, 2);\n}\n\n/*\n * Load the pae pdptrs.  Return 1 if they are all valid, 0 otherwise.\n */\nint load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tgpa_t real_gpa;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\t/*\n\t * If the MMU is nested, CR3 holds an L2 GPA and needs to be translated\n\t * to an L1 GPA.\n\t */\n\treal_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(pdpt_gfn),\n\t\t\t\t     PFERR_USER_MASK | PFERR_WRITE_MASK, NULL);\n\tif (real_gpa == UNMAPPED_GVA)\n\t\treturn 0;\n\n\t/* Note the offset, PDPTRs are 32 byte aligned when using PAE paging. */\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(real_gpa), pdpte,\n\t\t\t\t       cr3 & GENMASK(11, 5), sizeof(pdpte));\n\tif (ret < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif ((pdpte[i] & PT_PRESENT_MASK) &&\n\t\t    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Marking VCPU_EXREG_PDPTR dirty doesn't work for !tdp_enabled.\n\t * Shadow page roots need to be reconstructed instead.\n\t */\n\tif (!tdp_enabled && memcmp(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs)))\n\t\tkvm_mmu_free_roots(vcpu->kvm, mmu, KVM_MMU_ROOT_CURRENT);\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n\tkvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);\n\tvcpu->arch.pdptrs_from_userspace = false;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(load_pdptrs);\n\nvoid kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0)\n{\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\n\t\t/*\n\t\t * Clearing CR0.PG is defined to flush the TLB from the guest's\n\t\t * perspective.\n\t\t */\n\t\tif (!(cr0 & X86_CR0_PG))\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & KVM_MMU_CR0_ROLE_BITS)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n}\nEXPORT_SYMBOL_GPL(kvm_post_set_cr0);\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n#ifdef CONFIG_X86_64\n\tif ((vcpu->arch.efer & EFER_LME) && !is_paging(vcpu) &&\n\t    (cr0 & X86_CR0_PG)) {\n\t\tint cs_db, cs_l;\n\n\t\tif (!is_pae(vcpu))\n\t\t\treturn 1;\n\t\tstatic_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);\n\t\tif (cs_l)\n\t\t\treturn 1;\n\t}\n#endif\n\tif (!(vcpu->arch.efer & EFER_LME) && (cr0 & X86_CR0_PG) &&\n\t    is_pae(vcpu) && ((cr0 ^ old_cr0) & X86_CR0_PDPTR_BITS) &&\n\t    !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif (!(cr0 & X86_CR0_PG) &&\n\t    (is_64_bit_mode(vcpu) || kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)))\n\t\treturn 1;\n\n\tstatic_call(kvm_x86_set_cr0)(vcpu, cr0);\n\n\tkvm_post_set_cr0(vcpu, old_cr0, cr0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr0);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}\nEXPORT_SYMBOL_GPL(kvm_lmsw);\n\nvoid kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);\n\t}\n\n#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    vcpu->arch.pkru != vcpu->arch.host_pkru &&\n\t    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||\n\t     kvm_read_cr4_bits(vcpu, X86_CR4_PKE)))\n\t\twrite_pkru(vcpu->arch.pkru);\n#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */\n}\nEXPORT_SYMBOL_GPL(kvm_load_guest_xsave_state);\n\nvoid kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||\n\t     kvm_read_cr4_bits(vcpu, X86_CR4_PKE))) {\n\t\tvcpu->arch.pkru = rdpkru();\n\t\tif (vcpu->arch.pkru != vcpu->arch.host_pkru)\n\t\t\twrite_pkru(vcpu->arch.host_pkru);\n\t}\n#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */\n\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, host_xss);\n\t}\n\n}\nEXPORT_SYMBOL_GPL(kvm_load_host_xsave_state);\n\nstatic inline u64 kvm_guest_supported_xcr0(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.guest_fpu.fpstate->user_xfeatures;\n}\n\n#ifdef CONFIG_X86_64\nstatic inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;\n}\n#endif\n\nstatic int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see kvm_vcpu_reset()).\n\t */\n\tvalid_bits = kvm_guest_supported_xcr0(vcpu) | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\n\tif ((xcr0 & XFEATURE_MASK_XTILE) &&\n\t    ((xcr0 & XFEATURE_MASK_XTILE) != XFEATURE_MASK_XTILE))\n\t\treturn 1;\n\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid_runtime(vcpu);\n\treturn 0;\n}\n\nint kvm_emulate_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tif (static_call(kvm_x86_get_cpl)(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, kvm_rcx_read(vcpu), kvm_read_edx_eax(vcpu))) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_xsetbv);\n\nbool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tif (cr4 & cr4_reserved_bits)\n\t\treturn false;\n\n\tif (cr4 & vcpu->arch.cr4_guest_rsvd_bits)\n\t\treturn false;\n\n\treturn static_call(kvm_x86_is_valid_cr4)(vcpu, cr4);\n}\nEXPORT_SYMBOL_GPL(kvm_is_valid_cr4);\n\nvoid kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4)\n{\n\tif ((cr4 ^ old_cr4) & KVM_MMU_CR4_ROLE_BITS)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\t/*\n\t * If CR4.PCIDE is changed 0 -> 1, there is no need to flush the TLB\n\t * according to the SDM; however, stale prev_roots could be reused\n\t * incorrectly in the future after a MOV to CR3 with NOFLUSH=1, so we\n\t * free them all.  This is *not* a superset of KVM_REQ_TLB_FLUSH_GUEST\n\t * or KVM_REQ_TLB_FLUSH_CURRENT, because the hardware TLB is not flushed,\n\t * so fall through.\n\t */\n\tif (!tdp_enabled &&\n\t    (cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE))\n\t\tkvm_mmu_unload(vcpu);\n\n\t/*\n\t * The TLB has to be flushed for all PCIDs if any of the following\n\t * (architecturally required) changes happen:\n\t * - CR4.PCIDE is changed from 1 to 0\n\t * - CR4.PGE is toggled\n\t *\n\t * This is a superset of KVM_REQ_TLB_FLUSH_CURRENT.\n\t */\n\tif (((cr4 ^ old_cr4) & X86_CR4_PGE) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\n\t/*\n\t * The TLB has to be flushed for the current PCID if any of the\n\t * following (architecturally required) changes happen:\n\t * - CR4.SMEP is changed from 0 to 1\n\t * - CR4.PAE is toggled\n\t */\n\telse if (((cr4 ^ old_cr4) & X86_CR4_PAE) ||\n\t\t ((cr4 & X86_CR4_SMEP) && !(old_cr4 & X86_CR4_SMEP)))\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\n}\nEXPORT_SYMBOL_GPL(kvm_post_set_cr4);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\n\tif (!kvm_is_valid_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t\tif ((cr4 ^ old_cr4) & X86_CR4_LA57)\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & X86_CR4_PDPTR_BITS)\n\t\t   && !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tstatic_call(kvm_x86_set_cr4)(vcpu, cr4);\n\n\tkvm_post_set_cr4(vcpu, old_cr4, cr4);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr4);\n\nstatic void kvm_invalidate_pcid(struct kvm_vcpu *vcpu, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tunsigned long roots_to_free = 0;\n\tint i;\n\n\t/*\n\t * MOV CR3 and INVPCID are usually not intercepted when using TDP, but\n\t * this is reachable when running EPT=1 and unrestricted_guest=0,  and\n\t * also via the emulator.  KVM's TDP page tables are not in the scope of\n\t * the invalidation, but the guest's TLB entries need to be flushed as\n\t * the CPU may have cached entries in its TLB for the target PCID.\n\t */\n\tif (unlikely(tdp_enabled)) {\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * If neither the current CR3 nor any of the prev_roots use the given\n\t * PCID, then nothing needs to be done here because a resync will\n\t * happen anyway before switching to any other CR3.\n\t */\n\tif (kvm_get_active_pcid(vcpu) == pcid) {\n\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\t}\n\n\t/*\n\t * If PCID is disabled, there is no need to free prev_roots even if the\n\t * PCIDs for them are also 0, because MOV to CR3 always flushes the TLB\n\t * with PCIDE=0.\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn;\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd) == pcid)\n\t\t\troots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);\n\n\tkvm_mmu_free_roots(vcpu->kvm, mmu, roots_to_free);\n}\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tbool skip_tlb_flush = false;\n\tunsigned long pcid = 0;\n#ifdef CONFIG_X86_64\n\tbool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tif (pcid_enabled) {\n\t\tskip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;\n\t\tcr3 &= ~X86_CR3_PCID_NOFLUSH;\n\t\tpcid = cr3 & X86_CR3_PCID_MASK;\n\t}\n#endif\n\n\t/* PDPTRs are always reloaded for PAE paging. */\n\tif (cr3 == kvm_read_cr3(vcpu) && !is_pae_paging(vcpu))\n\t\tgoto handle_tlb_flush;\n\n\t/*\n\t * Do not condition the GPA check on long mode, this helper is used to\n\t * stuff CR3, e.g. for RSM emulation, and there is no guarantee that\n\t * the current vCPU mode is accurate.\n\t */\n\tif (kvm_vcpu_is_illegal_gpa(vcpu, cr3))\n\t\treturn 1;\n\n\tif (is_pae_paging(vcpu) && !load_pdptrs(vcpu, cr3))\n\t\treturn 1;\n\n\tif (cr3 != kvm_read_cr3(vcpu))\n\t\tkvm_mmu_new_pgd(vcpu, cr3);\n\n\tvcpu->arch.cr3 = cr3;\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\t/* Do not call post_set_cr3, we do not get here for confidential guests.  */\n\nhandle_tlb_flush:\n\t/*\n\t * A load of CR3 that flushes the TLB flushes only the current PCID,\n\t * even if PCID is disabled, in which case PCID=0 is flushed.  It's a\n\t * moot point in the end because _disabling_ PCID will flush all PCIDs,\n\t * and it's impossible to use a non-zero PCID when PCID is disabled,\n\t * i.e. only PCID=0 can be relevant.\n\t */\n\tif (!skip_tlb_flush)\n\t\tkvm_invalidate_pcid(vcpu, pcid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr3);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr8);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cr8);\n\nstatic void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n}\n\nvoid kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tstatic_call(kvm_x86_set_dr7)(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}\nEXPORT_SYMBOL_GPL(kvm_update_dr7);\n\nstatic u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_RTM))\n\t\tfixed |= DR6_RTM;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))\n\t\tfixed |= DR6_BUS_LOCK;\n\treturn fixed;\n}\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[array_index_nospec(dr, size)] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\tcase 6:\n\t\tif (!kvm_dr6_valid(val))\n\t\t\treturn 1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tbreak;\n\tcase 5:\n\tdefault: /* 7 */\n\t\tif (!kvm_dr7_valid(val))\n\t\t\treturn 1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_dr);\n\nvoid kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[array_index_nospec(dr, size)];\n\t\tbreak;\n\tcase 4:\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_get_dr);\n\nint kvm_emulate_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\n\tif (kvm_pmu_rdpmc(vcpu, ecx, &data)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tkvm_rax_write(vcpu, (u32)data);\n\tkvm_rdx_write(vcpu, data >> 32);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_rdpmc);\n\n/*\n * List of msr numbers which we expose to userspace through KVM_GET_MSRS\n * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.\n *\n * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)\n * extract the supported MSRs from the related const lists.\n * msrs_to_save is selected from the msrs_to_save_all to reflect the\n * capabilities of the host cpu. This capabilities test skips MSRs that are\n * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs\n * may depend on host virtualization features rather than host cpu features.\n */\n\nstatic const u32 msrs_to_save_all[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEAT_CTL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n\tMSR_IA32_SPEC_CTRL,\n\tMSR_IA32_RTIT_CTL, MSR_IA32_RTIT_STATUS, MSR_IA32_RTIT_CR3_MATCH,\n\tMSR_IA32_RTIT_OUTPUT_BASE, MSR_IA32_RTIT_OUTPUT_MASK,\n\tMSR_IA32_RTIT_ADDR0_A, MSR_IA32_RTIT_ADDR0_B,\n\tMSR_IA32_RTIT_ADDR1_A, MSR_IA32_RTIT_ADDR1_B,\n\tMSR_IA32_RTIT_ADDR2_A, MSR_IA32_RTIT_ADDR2_B,\n\tMSR_IA32_RTIT_ADDR3_A, MSR_IA32_RTIT_ADDR3_B,\n\tMSR_IA32_UMWAIT_CONTROL,\n\n\tMSR_ARCH_PERFMON_FIXED_CTR0, MSR_ARCH_PERFMON_FIXED_CTR1,\n\tMSR_ARCH_PERFMON_FIXED_CTR0 + 2,\n\tMSR_CORE_PERF_FIXED_CTR_CTRL, MSR_CORE_PERF_GLOBAL_STATUS,\n\tMSR_CORE_PERF_GLOBAL_CTRL, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\tMSR_ARCH_PERFMON_PERFCTR0, MSR_ARCH_PERFMON_PERFCTR1,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 2, MSR_ARCH_PERFMON_PERFCTR0 + 3,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 4, MSR_ARCH_PERFMON_PERFCTR0 + 5,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 6, MSR_ARCH_PERFMON_PERFCTR0 + 7,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 8, MSR_ARCH_PERFMON_PERFCTR0 + 9,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 10, MSR_ARCH_PERFMON_PERFCTR0 + 11,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 12, MSR_ARCH_PERFMON_PERFCTR0 + 13,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 14, MSR_ARCH_PERFMON_PERFCTR0 + 15,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 16, MSR_ARCH_PERFMON_PERFCTR0 + 17,\n\tMSR_ARCH_PERFMON_EVENTSEL0, MSR_ARCH_PERFMON_EVENTSEL1,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 2, MSR_ARCH_PERFMON_EVENTSEL0 + 3,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 4, MSR_ARCH_PERFMON_EVENTSEL0 + 5,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 6, MSR_ARCH_PERFMON_EVENTSEL0 + 7,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 8, MSR_ARCH_PERFMON_EVENTSEL0 + 9,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 10, MSR_ARCH_PERFMON_EVENTSEL0 + 11,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 12, MSR_ARCH_PERFMON_EVENTSEL0 + 13,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 14, MSR_ARCH_PERFMON_EVENTSEL0 + 15,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 16, MSR_ARCH_PERFMON_EVENTSEL0 + 17,\n\n\tMSR_K7_EVNTSEL0, MSR_K7_EVNTSEL1, MSR_K7_EVNTSEL2, MSR_K7_EVNTSEL3,\n\tMSR_K7_PERFCTR0, MSR_K7_PERFCTR1, MSR_K7_PERFCTR2, MSR_K7_PERFCTR3,\n\tMSR_F15H_PERF_CTL0, MSR_F15H_PERF_CTL1, MSR_F15H_PERF_CTL2,\n\tMSR_F15H_PERF_CTL3, MSR_F15H_PERF_CTL4, MSR_F15H_PERF_CTL5,\n\tMSR_F15H_PERF_CTR0, MSR_F15H_PERF_CTR1, MSR_F15H_PERF_CTR2,\n\tMSR_F15H_PERF_CTR3, MSR_F15H_PERF_CTR4, MSR_F15H_PERF_CTR5,\n\tMSR_IA32_XFD, MSR_IA32_XFD_ERR,\n};\n\nstatic u32 msrs_to_save[ARRAY_SIZE(msrs_to_save_all)];\nstatic unsigned num_msrs_to_save;\n\nstatic const u32 emulated_msrs_all[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_TSC_FREQUENCY, HV_X64_MSR_APIC_FREQUENCY,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_VP_ASSIST_PAGE,\n\tHV_X64_MSR_REENLIGHTENMENT_CONTROL, HV_X64_MSR_TSC_EMULATION_CONTROL,\n\tHV_X64_MSR_TSC_EMULATION_STATUS,\n\tHV_X64_MSR_SYNDBG_OPTIONS,\n\tHV_X64_MSR_SYNDBG_CONTROL, HV_X64_MSR_SYNDBG_STATUS,\n\tHV_X64_MSR_SYNDBG_SEND_BUFFER, HV_X64_MSR_SYNDBG_RECV_BUFFER,\n\tHV_X64_MSR_SYNDBG_PENDING_BUFFER,\n\n\tMSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN, MSR_KVM_ASYNC_PF_INT, MSR_KVM_ASYNC_PF_ACK,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSC_DEADLINE,\n\tMSR_IA32_ARCH_CAPABILITIES,\n\tMSR_IA32_PERF_CAPABILITIES,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_MCG_EXT_CTL,\n\tMSR_IA32_SMBASE,\n\tMSR_SMI_COUNT,\n\tMSR_PLATFORM_INFO,\n\tMSR_MISC_FEATURES_ENABLES,\n\tMSR_AMD64_VIRT_SPEC_CTRL,\n\tMSR_AMD64_TSC_RATIO,\n\tMSR_IA32_POWER_CTL,\n\tMSR_IA32_UCODE_REV,\n\n\t/*\n\t * The following list leaves out MSRs whose values are determined\n\t * by arch/x86/kvm/vmx/nested.c based on CPUID or other MSRs.\n\t * We always support the \"true\" VMX control MSRs, even if the host\n\t * processor does not, so I am putting these registers here rather\n\t * than in msrs_to_save_all.\n\t */\n\tMSR_IA32_VMX_BASIC,\n\tMSR_IA32_VMX_TRUE_PINBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_PROCBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_EXIT_CTLS,\n\tMSR_IA32_VMX_TRUE_ENTRY_CTLS,\n\tMSR_IA32_VMX_MISC,\n\tMSR_IA32_VMX_CR0_FIXED0,\n\tMSR_IA32_VMX_CR4_FIXED0,\n\tMSR_IA32_VMX_VMCS_ENUM,\n\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\tMSR_IA32_VMX_EPT_VPID_CAP,\n\tMSR_IA32_VMX_VMFUNC,\n\n\tMSR_K7_HWCR,\n\tMSR_KVM_POLL_CONTROL,\n};\n\nstatic u32 emulated_msrs[ARRAY_SIZE(emulated_msrs_all)];\nstatic unsigned num_emulated_msrs;\n\n/*\n * List of msr numbers which are used to expose MSR-based features that\n * can be used by a hypervisor to validate requested CPU features.\n */\nstatic const u32 msr_based_features_all[] = {\n\tMSR_IA32_VMX_BASIC,\n\tMSR_IA32_VMX_TRUE_PINBASED_CTLS,\n\tMSR_IA32_VMX_PINBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_PROCBASED_CTLS,\n\tMSR_IA32_VMX_PROCBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_EXIT_CTLS,\n\tMSR_IA32_VMX_EXIT_CTLS,\n\tMSR_IA32_VMX_TRUE_ENTRY_CTLS,\n\tMSR_IA32_VMX_ENTRY_CTLS,\n\tMSR_IA32_VMX_MISC,\n\tMSR_IA32_VMX_CR0_FIXED0,\n\tMSR_IA32_VMX_CR0_FIXED1,\n\tMSR_IA32_VMX_CR4_FIXED0,\n\tMSR_IA32_VMX_CR4_FIXED1,\n\tMSR_IA32_VMX_VMCS_ENUM,\n\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\tMSR_IA32_VMX_EPT_VPID_CAP,\n\tMSR_IA32_VMX_VMFUNC,\n\n\tMSR_F10H_DECFG,\n\tMSR_IA32_UCODE_REV,\n\tMSR_IA32_ARCH_CAPABILITIES,\n\tMSR_IA32_PERF_CAPABILITIES,\n};\n\nstatic u32 msr_based_features[ARRAY_SIZE(msr_based_features_all)];\nstatic unsigned int num_msr_based_features;\n\nstatic u64 kvm_get_arch_capabilities(void)\n{\n\tu64 data = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES))\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, data);\n\n\t/*\n\t * If nx_huge_pages is enabled, KVM's shadow paging will ensure that\n\t * the nested hypervisor runs with NX huge pages.  If it is not,\n\t * L1 is anyway vulnerable to ITLB_MULTIHIT exploits from other\n\t * L1 guests, so it need not worry about its own (L2) guests.\n\t */\n\tdata |= ARCH_CAP_PSCHANGE_MC_NO;\n\n\t/*\n\t * If we're doing cache flushes (either \"always\" or \"cond\")\n\t * we will do one whenever the guest does a vmlaunch/vmresume.\n\t * If an outer hypervisor is doing the cache flush for us\n\t * (VMENTER_L1D_FLUSH_NESTED_VM), we can safely pass that\n\t * capability to the guest too, and if EPT is disabled we're not\n\t * vulnerable.  Overall, only VMENTER_L1D_FLUSH_NEVER will\n\t * require a nested hypervisor to do a flush of its own.\n\t */\n\tif (l1tf_vmx_mitigation != VMENTER_L1D_FLUSH_NEVER)\n\t\tdata |= ARCH_CAP_SKIP_VMENTRY_L1DFLUSH;\n\n\tif (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))\n\t\tdata |= ARCH_CAP_RDCL_NO;\n\tif (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))\n\t\tdata |= ARCH_CAP_SSB_NO;\n\tif (!boot_cpu_has_bug(X86_BUG_MDS))\n\t\tdata |= ARCH_CAP_MDS_NO;\n\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\t/*\n\t\t * If RTM=0 because the kernel has disabled TSX, the host might\n\t\t * have TAA_NO or TSX_CTRL.  Clear TAA_NO (the guest sees RTM=0\n\t\t * and therefore knows that there cannot be TAA) but keep\n\t\t * TSX_CTRL: some buggy userspaces leave it set on tsx=on hosts,\n\t\t * and we want to allow migrating those guests to tsx=off hosts.\n\t\t */\n\t\tdata &= ~ARCH_CAP_TAA_NO;\n\t} else if (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\tdata |= ARCH_CAP_TAA_NO;\n\t} else {\n\t\t/*\n\t\t * Nothing to do here; we emulate TSX_CTRL if present on the\n\t\t * host so the guest can choose between disabling TSX or\n\t\t * using VERW to clear CPU buffers.\n\t\t */\n\t}\n\n\treturn data;\n}\n\nstatic int kvm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tmsr->data = kvm_get_arch_capabilities();\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\trdmsrl_safe(msr->index, &msr->data);\n\t\tbreak;\n\tdefault:\n\t\treturn static_call(kvm_x86_get_msr_feature)(msr);\n\t}\n\treturn 0;\n}\n\nstatic int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct kvm_msr_entry msr;\n\tint r;\n\n\tmsr.index = index;\n\tr = kvm_get_msr_feature(&msr);\n\n\tif (r == KVM_MSR_RET_INVALID) {\n\t\t/* Unconditionally clear the output for simplicity */\n\t\t*data = 0;\n\t\tif (kvm_msr_ignored_check(index, 0, false))\n\t\t\tr = 0;\n\t}\n\n\tif (r)\n\t\treturn r;\n\n\t*data = msr.data;\n\n\treturn 0;\n}\n\nstatic bool __kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & EFER_FFXSR && !guest_cpuid_has(vcpu, X86_FEATURE_FXSR_OPT))\n\t\treturn false;\n\n\tif (efer & EFER_SVME && !guest_cpuid_has(vcpu, X86_FEATURE_SVM))\n\t\treturn false;\n\n\tif (efer & (EFER_LME | EFER_LMA) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\treturn false;\n\n\tif (efer & EFER_NX && !guest_cpuid_has(vcpu, X86_FEATURE_NX))\n\t\treturn false;\n\n\treturn true;\n\n}\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\treturn __kvm_valid_efer(vcpu, efer);\n}\nEXPORT_SYMBOL_GPL(kvm_valid_efer);\n\nstatic int set_efer(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\tu64 efer = msr_info->data;\n\tint r;\n\n\tif (efer & efer_reserved_bits)\n\t\treturn 1;\n\n\tif (!msr_info->host_initiated) {\n\t\tif (!__kvm_valid_efer(vcpu, efer))\n\t\t\treturn 1;\n\n\t\tif (is_paging(vcpu) &&\n\t\t    (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\t\treturn 1;\n\t}\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tr = static_call(kvm_x86_set_efer)(vcpu, efer);\n\tif (r) {\n\t\tWARN_ON(r > 0);\n\t\treturn r;\n\t}\n\n\tif ((efer ^ old_efer) & KVM_MMU_EFER_ROLE_BITS)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}\nEXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n\nbool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)\n{\n\tstruct kvm_x86_msr_filter *msr_filter;\n\tstruct msr_bitmap_range *ranges;\n\tstruct kvm *kvm = vcpu->kvm;\n\tbool allowed;\n\tint idx;\n\tu32 i;\n\n\t/* x2APIC MSRs do not support filtering. */\n\tif (index >= 0x800 && index <= 0x8ff)\n\t\treturn true;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tmsr_filter = srcu_dereference(kvm->arch.msr_filter, &kvm->srcu);\n\tif (!msr_filter) {\n\t\tallowed = true;\n\t\tgoto out;\n\t}\n\n\tallowed = msr_filter->default_allow;\n\tranges = msr_filter->ranges;\n\n\tfor (i = 0; i < msr_filter->count; i++) {\n\t\tu32 start = ranges[i].base;\n\t\tu32 end = start + ranges[i].nmsrs;\n\t\tu32 flags = ranges[i].flags;\n\t\tunsigned long *bitmap = ranges[i].bitmap;\n\n\t\tif ((index >= start) && (index < end) && (flags & type)) {\n\t\t\tallowed = !!test_bit(index - start, bitmap);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn allowed;\n}\nEXPORT_SYMBOL_GPL(kvm_msr_allowed);\n\n/*\n * Write @data into the MSR specified by @index.  Select MSR specific fault\n * checks are bypassed if @host_initiated is %true.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int __kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data,\n\t\t\t bool host_initiated)\n{\n\tstruct msr_data msr;\n\n\tswitch (index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(data, vcpu))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t/*\n\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n\t\t * non-canonical address is written on Intel but not on\n\t\t * AMD (which ignores the top 32-bits, because it does\n\t\t * not implement 64-bit SYSENTER).\n\t\t *\n\t\t * 64-bit code should hence be able to write a non-canonical\n\t\t * value on AMD.  Making the address canonical ensures that\n\t\t * vmentry does not fail on Intel after writing a non-canonical\n\t\t * value, and that something deterministic happens if the guest\n\t\t * invokes 64-bit SYSENTER.\n\t\t */\n\t\tdata = __canonical_address(data, vcpu_virt_addr_bits(vcpu));\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))\n\t\t\treturn 1;\n\n\t\tif (!host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * Per Intel's SDM, bits 63:32 are reserved, but AMD's APM has\n\t\t * incomplete and conflicting architectural behavior.  Current\n\t\t * AMD CPUs completely ignore bits 63:32, i.e. they aren't\n\t\t * reserved and always read as zeros.  Enforce Intel's reserved\n\t\t * bits check if and only if the guest CPU is Intel, and clear\n\t\t * the bits in all other cases.  This ensures cross-vendor\n\t\t * migration will provide consistent behavior for the guest.\n\t\t */\n\t\tif (guest_cpuid_is_intel(vcpu) && (data >> 32) != 0)\n\t\t\treturn 1;\n\n\t\tdata = (u32)data;\n\t\tbreak;\n\t}\n\n\tmsr.data = data;\n\tmsr.index = index;\n\tmsr.host_initiated = host_initiated;\n\n\treturn static_call(kvm_x86_set_msr)(vcpu, &msr);\n}\n\nstatic int kvm_set_msr_ignored_check(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data, bool host_initiated)\n{\n\tint ret = __kvm_set_msr(vcpu, index, data, host_initiated);\n\n\tif (ret == KVM_MSR_RET_INVALID)\n\t\tif (kvm_msr_ignored_check(index, data, true))\n\t\t\tret = 0;\n\n\treturn ret;\n}\n\n/*\n * Read the MSR specified by @index into @data.  Select MSR specific fault\n * checks are bypassed if @host_initiated is %true.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data,\n\t\t  bool host_initiated)\n{\n\tstruct msr_data msr;\n\tint ret;\n\n\tswitch (index) {\n\tcase MSR_TSC_AUX:\n\t\tif (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))\n\t\t\treturn 1;\n\n\t\tif (!host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\n\tmsr.index = index;\n\tmsr.host_initiated = host_initiated;\n\n\tret = static_call(kvm_x86_get_msr)(vcpu, &msr);\n\tif (!ret)\n\t\t*data = msr.data;\n\treturn ret;\n}\n\nstatic int kvm_get_msr_ignored_check(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *data, bool host_initiated)\n{\n\tint ret = __kvm_get_msr(vcpu, index, data, host_initiated);\n\n\tif (ret == KVM_MSR_RET_INVALID) {\n\t\t/* Unconditionally clear *data for simplicity */\n\t\t*data = 0;\n\t\tif (kvm_msr_ignored_check(index, 0, false))\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int kvm_get_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 *data)\n{\n\tif (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_READ))\n\t\treturn KVM_MSR_RET_FILTERED;\n\treturn kvm_get_msr_ignored_check(vcpu, index, data, false);\n}\n\nstatic int kvm_set_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 data)\n{\n\tif (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_WRITE))\n\t\treturn KVM_MSR_RET_FILTERED;\n\treturn kvm_set_msr_ignored_check(vcpu, index, data, false);\n}\n\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data)\n{\n\treturn kvm_get_msr_ignored_check(vcpu, index, data, false);\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr);\n\nint kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data)\n{\n\treturn kvm_set_msr_ignored_check(vcpu, index, data, false);\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr);\n\nstatic void complete_userspace_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->run->msr.error) {\n\t\tkvm_rax_write(vcpu, (u32)vcpu->run->msr.data);\n\t\tkvm_rdx_write(vcpu, vcpu->run->msr.data >> 32);\n\t}\n}\n\nstatic int complete_emulated_msr_access(struct kvm_vcpu *vcpu)\n{\n\treturn complete_emulated_insn_gp(vcpu, vcpu->run->msr.error);\n}\n\nstatic int complete_emulated_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tcomplete_userspace_rdmsr(vcpu);\n\treturn complete_emulated_msr_access(vcpu);\n}\n\nstatic int complete_fast_msr_access(struct kvm_vcpu *vcpu)\n{\n\treturn static_call(kvm_x86_complete_emulated_msr)(vcpu, vcpu->run->msr.error);\n}\n\nstatic int complete_fast_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tcomplete_userspace_rdmsr(vcpu);\n\treturn complete_fast_msr_access(vcpu);\n}\n\nstatic u64 kvm_msr_reason(int r)\n{\n\tswitch (r) {\n\tcase KVM_MSR_RET_INVALID:\n\t\treturn KVM_MSR_EXIT_REASON_UNKNOWN;\n\tcase KVM_MSR_RET_FILTERED:\n\t\treturn KVM_MSR_EXIT_REASON_FILTER;\n\tdefault:\n\t\treturn KVM_MSR_EXIT_REASON_INVAL;\n\t}\n}\n\nstatic int kvm_msr_user_space(struct kvm_vcpu *vcpu, u32 index,\n\t\t\t      u32 exit_reason, u64 data,\n\t\t\t      int (*completion)(struct kvm_vcpu *vcpu),\n\t\t\t      int r)\n{\n\tu64 msr_reason = kvm_msr_reason(r);\n\n\t/* Check if the user wanted to know about this MSR fault */\n\tif (!(vcpu->kvm->arch.user_space_msr_mask & msr_reason))\n\t\treturn 0;\n\n\tvcpu->run->exit_reason = exit_reason;\n\tvcpu->run->msr.error = 0;\n\tmemset(vcpu->run->msr.pad, 0, sizeof(vcpu->run->msr.pad));\n\tvcpu->run->msr.reason = msr_reason;\n\tvcpu->run->msr.index = index;\n\tvcpu->run->msr.data = data;\n\tvcpu->arch.complete_userspace_io = completion;\n\n\treturn 1;\n}\n\nint kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint r;\n\n\tr = kvm_get_msr_with_filter(vcpu, ecx, &data);\n\n\tif (!r) {\n\t\ttrace_kvm_msr_read(ecx, data);\n\n\t\tkvm_rax_write(vcpu, data & -1u);\n\t\tkvm_rdx_write(vcpu, (data >> 32) & -1u);\n\t} else {\n\t\t/* MSR read failed? See if we should ask user space */\n\t\tif (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_RDMSR, 0,\n\t\t\t\t       complete_fast_rdmsr, r))\n\t\t\treturn 0;\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t}\n\n\treturn static_call(kvm_x86_complete_emulated_msr)(vcpu, r);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_rdmsr);\n\nint kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data = kvm_read_edx_eax(vcpu);\n\tint r;\n\n\tr = kvm_set_msr_with_filter(vcpu, ecx, data);\n\n\tif (!r) {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t} else {\n\t\t/* MSR write failed? See if we should ask user space */\n\t\tif (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_WRMSR, data,\n\t\t\t\t       complete_fast_msr_access, r))\n\t\t\treturn 0;\n\t\t/* Signal all other negative errors to userspace */\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t}\n\n\treturn static_call(kvm_x86_complete_emulated_msr)(vcpu, r);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wrmsr);\n\nint kvm_emulate_as_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_as_nop);\n\nint kvm_emulate_invd(struct kvm_vcpu *vcpu)\n{\n\t/* Treat an INVD instruction as a NOP and just skip it. */\n\treturn kvm_emulate_as_nop(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_invd);\n\nint kvm_emulate_mwait(struct kvm_vcpu *vcpu)\n{\n\tpr_warn_once(\"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn kvm_emulate_as_nop(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_mwait);\n\nint kvm_handle_invalid_op(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(kvm_handle_invalid_op);\n\nint kvm_emulate_monitor(struct kvm_vcpu *vcpu)\n{\n\tpr_warn_once(\"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn kvm_emulate_as_nop(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_monitor);\n\nstatic inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)\n{\n\txfer_to_guest_mode_prepare();\n\treturn vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu) ||\n\t\txfer_to_guest_mode_work_pending();\n}\n\n/*\n * The fast path for frequent and performance sensitive wrmsr emulation,\n * i.e. the sending of IPI, sending IPI early in the VM-Exit flow reduces\n * the latency of virtual IPI by avoiding the expensive bits of transitioning\n * from guest to host, e.g. reacquiring KVM's SRCU lock. In contrast to the\n * other cases which must be called after interrupts are enabled on the host.\n */\nstatic int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)\n{\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))\n\t\treturn 1;\n\n\tif (((data & APIC_SHORT_MASK) == APIC_DEST_NOSHORT) &&\n\t    ((data & APIC_DEST_MASK) == APIC_DEST_PHYSICAL) &&\n\t    ((data & APIC_MODE_MASK) == APIC_DM_FIXED) &&\n\t    ((u32)(data >> 32) != X2APIC_BROADCAST))\n\t\treturn kvm_x2apic_icr_write(vcpu->arch.apic, data);\n\n\treturn 1;\n}\n\nstatic int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)\n{\n\tif (!kvm_can_use_hv_timer(vcpu))\n\t\treturn 1;\n\n\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\treturn 0;\n}\n\nfastpath_t handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 msr = kvm_rcx_read(vcpu);\n\tu64 data;\n\tfastpath_t ret = EXIT_FASTPATH_NONE;\n\n\tswitch (msr) {\n\tcase APIC_BASE_MSR + (APIC_ICR >> 4):\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tif (!handle_fastpath_set_x2apic_icr_irqoff(vcpu, data)) {\n\t\t\tkvm_skip_emulated_instruction(vcpu);\n\t\t\tret = EXIT_FASTPATH_EXIT_HANDLED;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_TSC_DEADLINE:\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tif (!handle_fastpath_set_tscdeadline(vcpu, data)) {\n\t\t\tkvm_skip_emulated_instruction(vcpu);\n\t\t\tret = EXIT_FASTPATH_REENTER_GUEST;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret != EXIT_FASTPATH_NONE)\n\t\ttrace_kvm_msr_write(msr, data);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(handle_fastpath_set_msr_irqoff);\n\n/*\n * Adapt set_msr() to msr_io()'s calling convention\n */\nstatic int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\treturn kvm_get_msr_ignored_check(vcpu, index, data, true);\n}\n\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\treturn kvm_set_msr_ignored_check(vcpu, index, *data, true);\n}\n\n#ifdef CONFIG_X86_64\nstruct pvclock_clock {\n\tint vclock_mode;\n\tu64 cycle_last;\n\tu64 mask;\n\tu32 mult;\n\tu32 shift;\n\tu64 base_cycles;\n\tu64 offset;\n};\n\nstruct pvclock_gtod_data {\n\tseqcount_t\tseq;\n\n\tstruct pvclock_clock clock; /* extract of a clocksource struct */\n\tstruct pvclock_clock raw_clock; /* extract of a clocksource struct */\n\n\tktime_t\t\toffs_boot;\n\tu64\t\twall_time_sec;\n};\n\nstatic struct pvclock_gtod_data pvclock_gtod_data;\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr_mono.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr_mono.mask;\n\tvdata->clock.mult\t\t= tk->tkr_mono.mult;\n\tvdata->clock.shift\t\t= tk->tkr_mono.shift;\n\tvdata->clock.base_cycles\t= tk->tkr_mono.xtime_nsec;\n\tvdata->clock.offset\t\t= tk->tkr_mono.base;\n\n\tvdata->raw_clock.vclock_mode\t= tk->tkr_raw.clock->vdso_clock_mode;\n\tvdata->raw_clock.cycle_last\t= tk->tkr_raw.cycle_last;\n\tvdata->raw_clock.mask\t\t= tk->tkr_raw.mask;\n\tvdata->raw_clock.mult\t\t= tk->tkr_raw.mult;\n\tvdata->raw_clock.shift\t\t= tk->tkr_raw.shift;\n\tvdata->raw_clock.base_cycles\t= tk->tkr_raw.xtime_nsec;\n\tvdata->raw_clock.offset\t\t= tk->tkr_raw.base;\n\n\tvdata->wall_time_sec            = tk->xtime_sec;\n\n\tvdata->offs_boot\t\t= tk->offs_boot;\n\n\twrite_seqcount_end(&vdata->seq);\n}\n\nstatic s64 get_kvmclock_base_ns(void)\n{\n\t/* Count up from boot time, but with the frequency of the raw clock.  */\n\treturn ktime_to_ns(ktime_add(ktime_get_raw(), pvclock_gtod_data.offs_boot));\n}\n#else\nstatic s64 get_kvmclock_base_ns(void)\n{\n\t/* Master clock not used, so we can just use CLOCK_BOOTTIME.  */\n\treturn ktime_get_boottime_ns();\n}\n#endif\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tu32 wc_sec_hi;\n\tu64 wall_nsec;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tif (kvm_write_guest(kvm, wall_clock, &version, sizeof(version)))\n\t\treturn;\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  We do the reverse here.\n\t */\n\twall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);\n\n\twc.nsec = do_div(wall_nsec, 1000000000);\n\twc.sec = (u32)wall_nsec; /* overflow in 2106 guest time */\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tif (sec_hi_ofs) {\n\t\twc_sec_hi = wall_nsec >> 32;\n\t\tkvm_write_guest(kvm, wall_clock + sec_hi_ofs,\n\t\t\t\t&wc_sec_hi, sizeof(wc_sec_hi));\n\t}\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n\nstatic void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time,\n\t\t\t\t  bool old_msr, bool host_initiated)\n{\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\tif (vcpu->vcpu_id == 0 && !host_initiated) {\n\t\tif (ka->boot_vcpu_runs_old_kvmclock != old_msr)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\t\tka->boot_vcpu_runs_old_kvmclock = old_msr;\n\t}\n\n\tvcpu->arch.time = system_time;\n\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t/* we verify if the enable bit is set... */\n\tif (system_time & 1) {\n\t\tkvm_gfn_to_pfn_cache_init(vcpu->kvm, &vcpu->arch.pv_time, vcpu,\n\t\t\t\t\t  KVM_HOST_USES_PFN, system_time & ~1ULL,\n\t\t\t\t\t  sizeof(struct pvclock_vcpu_time_info));\n\t} else {\n\t\tkvm_gfn_to_pfn_cache_destroy(vcpu->kvm, &vcpu->arch.pv_time);\n\t}\n\n\treturn;\n}\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tdo_shl32_div32(dividend, divisor);\n\treturn dividend;\n}\n\nstatic void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n}\n\n#ifdef CONFIG_X86_64\nstatic atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);\n#endif\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\nstatic unsigned long max_tsc_khz;\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}\n\nstatic void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier);\n\nstatic int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tu64 ratio;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tkvm_vcpu_write_tsc_multiplier(vcpu, kvm_default_tsc_scaling_ratio);\n\t\treturn 0;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!kvm_has_tsc_control) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpr_warn_ratelimited(\"user requested TSC rate below hardware speed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = mul_u64_u32_div(1ULL << kvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tuser_tsc_khz, tsc_khz);\n\n\tif (ratio == 0 || ratio >= kvm_max_tsc_scaling_ratio) {\n\t\tpr_warn_ratelimited(\"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t            user_tsc_khz);\n\t\treturn -1;\n\t}\n\n\tkvm_vcpu_write_tsc_multiplier(vcpu, ratio);\n\treturn 0;\n}\n\nstatic int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tkvm_vcpu_write_tsc_multiplier(vcpu, kvm_default_tsc_scaling_ratio);\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}\n\n#ifdef CONFIG_X86_64\nstatic inline int gtod_is_based_on_tsc(int mode)\n{\n\treturn mode == VDSO_CLOCKMODE_TSC || mode == VDSO_CLOCKMODE_HVCLOCK;\n}\n#endif\n\nstatic void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\t/*\n\t * Once the masterclock is enabled, always perform request in\n\t * order to update it.\n\t *\n\t * In order to enable masterclock, the host clocksource must be TSC\n\t * and the vcpus need to have matched TSCs.  When that happens,\n\t * perform request to enable masterclock.\n\t */\n\tif (ka->use_master_clock ||\n\t    (gtod_is_based_on_tsc(gtod->clock.vclock_mode) && vcpus_matched))\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}\n\n/*\n * Multiply tsc by a fixed point number represented by ratio.\n *\n * The most significant 64-N bits (mult) of ratio represent the\n * integral part of the fixed point number; the remaining N bits\n * (frac) represent the fractional part, ie. ratio represents a fixed\n * point number (mult + frac * 2^(-N)).\n *\n * N equals to kvm_tsc_scaling_ratio_frac_bits.\n */\nstatic inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}\n\nu64 kvm_scale_tsc(u64 tsc, u64 ratio)\n{\n\tu64 _tsc = tsc;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}\nEXPORT_SYMBOL_GPL(kvm_scale_tsc);\n\nstatic u64 kvm_compute_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio);\n\n\treturn target_tsc - tsc;\n}\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn vcpu->arch.l1_tsc_offset +\n\t\tkvm_scale_tsc(host_tsc, vcpu->arch.l1_tsc_scaling_ratio);\n}\nEXPORT_SYMBOL_GPL(kvm_read_l1_tsc);\n\nu64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier)\n{\n\tu64 nested_offset;\n\n\tif (l2_multiplier == kvm_default_tsc_scaling_ratio)\n\t\tnested_offset = l1_offset;\n\telse\n\t\tnested_offset = mul_s64_u64_shr((s64) l1_offset, l2_multiplier,\n\t\t\t\t\t\tkvm_tsc_scaling_ratio_frac_bits);\n\n\tnested_offset += l2_offset;\n\treturn nested_offset;\n}\nEXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_offset);\n\nu64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier)\n{\n\tif (l2_multiplier != kvm_default_tsc_scaling_ratio)\n\t\treturn mul_u64_u64_shr(l1_multiplier, l2_multiplier,\n\t\t\t\t       kvm_tsc_scaling_ratio_frac_bits);\n\n\treturn l1_multiplier;\n}\nEXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_multiplier);\n\nstatic void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)\n{\n\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t   vcpu->arch.l1_tsc_offset,\n\t\t\t\t   l1_offset);\n\n\tvcpu->arch.l1_tsc_offset = l1_offset;\n\n\t/*\n\t * If we are here because L1 chose not to trap WRMSR to TSC then\n\t * according to the spec this should set L1's TSC (as opposed to\n\t * setting L1's offset for L2).\n\t */\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(\n\t\t\tl1_offset,\n\t\t\tstatic_call(kvm_x86_get_l2_tsc_offset)(vcpu),\n\t\t\tstatic_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));\n\telse\n\t\tvcpu->arch.tsc_offset = l1_offset;\n\n\tstatic_call(kvm_x86_write_tsc_offset)(vcpu, vcpu->arch.tsc_offset);\n}\n\nstatic void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier)\n{\n\tvcpu->arch.l1_tsc_scaling_ratio = l1_multiplier;\n\n\t/* Userspace is changing the multiplier while L2 is active */\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_calc_nested_tsc_multiplier(\n\t\t\tl1_multiplier,\n\t\t\tstatic_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));\n\telse\n\t\tvcpu->arch.tsc_scaling_ratio = l1_multiplier;\n\n\tif (kvm_has_tsc_control)\n\t\tstatic_call(kvm_x86_write_tsc_multiplier)(\n\t\t\tvcpu, vcpu->arch.tsc_scaling_ratio);\n}\n\nstatic inline bool kvm_check_tsc_unstable(void)\n{\n#ifdef CONFIG_X86_64\n\t/*\n\t * TSC is marked unstable when we're running on Hyper-V,\n\t * 'TSC page' clocksource is good.\n\t */\n\tif (pvclock_gtod_data.clock.vclock_mode == VDSO_CLOCKMODE_HVCLOCK)\n\t\treturn false;\n#endif\n\treturn check_tsc_unstable();\n}\n\n/*\n * Infers attempts to synchronize the guest's tsc from host writes. Sets the\n * offset for the vcpu and tracks the TSC matching generation that the vcpu\n * participates in.\n */\nstatic void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,\n\t\t\t\t  u64 ns, bool matched)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tlockdep_assert_held(&kvm->arch.tsc_write_lock);\n\n\t/*\n\t * We also track th most recent recorded KHZ, write and time to\n\t * allow the matching interval to be extended at each write.\n\t */\n\tkvm->arch.last_tsc_nsec = ns;\n\tkvm->arch.last_tsc_write = tsc;\n\tkvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\tkvm->arch.last_tsc_offset = offset;\n\n\tvcpu->arch.last_guest_tsc = tsc;\n\n\tkvm_vcpu_write_tsc_offset(vcpu, offset);\n\n\tif (!matched) {\n\t\t/*\n\t\t * We split periods of matched TSC writes into generations.\n\t\t * For each generation, we track the original measured\n\t\t * nanosecond time, offset, and write, so if TSCs are in\n\t\t * sync, we can match exact offset, and if not, we can match\n\t\t * exact software computation in compute_guest_tsc()\n\t\t *\n\t\t * These values are tracked in kvm->arch.cur_xxx variables.\n\t\t */\n\t\tkvm->arch.cur_tsc_generation++;\n\t\tkvm->arch.cur_tsc_nsec = ns;\n\t\tkvm->arch.cur_tsc_write = tsc;\n\t\tkvm->arch.cur_tsc_offset = offset;\n\t\tkvm->arch.nr_vcpus_matched_tsc = 0;\n\t} else if (vcpu->arch.this_tsc_generation != kvm->arch.cur_tsc_generation) {\n\t\tkvm->arch.nr_vcpus_matched_tsc++;\n\t}\n\n\t/* Keep track of which generation this VCPU has synchronized to */\n\tvcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;\n\tvcpu->arch.this_tsc_nsec = kvm->arch.cur_tsc_nsec;\n\tvcpu->arch.this_tsc_write = kvm->arch.cur_tsc_write;\n\n\tkvm_track_tsc_matching(vcpu);\n}\n\nstatic void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tu64 offset, ns, elapsed;\n\tunsigned long flags;\n\tbool matched = false;\n\tbool synchronizing = false;\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\toffset = kvm_compute_l1_tsc_offset(vcpu, data);\n\tns = get_kvmclock_base_ns();\n\telapsed = ns - kvm->arch.last_tsc_nsec;\n\n\tif (vcpu->arch.virtual_tsc_khz) {\n\t\tif (data == 0) {\n\t\t\t/*\n\t\t\t * detection of vcpu initialization -- need to sync\n\t\t\t * with other vCPUs. This particularly helps to keep\n\t\t\t * kvm_clock stable after CPU hotplug\n\t\t\t */\n\t\t\tsynchronizing = true;\n\t\t} else {\n\t\t\tu64 tsc_exp = kvm->arch.last_tsc_write +\n\t\t\t\t\t\tnsec_to_cycles(vcpu, elapsed);\n\t\t\tu64 tsc_hz = vcpu->arch.virtual_tsc_khz * 1000LL;\n\t\t\t/*\n\t\t\t * Special case: TSC write with a small delta (1 second)\n\t\t\t * of virtual cycle time against real time is\n\t\t\t * interpreted as an attempt to synchronize the CPU.\n\t\t\t */\n\t\t\tsynchronizing = data < tsc_exp + tsc_hz &&\n\t\t\t\t\tdata + tsc_hz > tsc_exp;\n\t\t}\n\t}\n\n\t/*\n\t * For a reliable TSC, we can match TSC offsets, and for an unstable\n\t * TSC, we add elapsed time in this computation.  We could let the\n\t * compensation code attempt to catch up if we fall behind, but\n\t * it's better to try to match offsets from the beginning.\n         */\n\tif (synchronizing &&\n\t    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {\n\t\tif (!kvm_check_tsc_unstable()) {\n\t\t\toffset = kvm->arch.cur_tsc_offset;\n\t\t} else {\n\t\t\tu64 delta = nsec_to_cycles(vcpu, elapsed);\n\t\t\tdata += delta;\n\t\t\toffset = kvm_compute_l1_tsc_offset(vcpu, data);\n\t\t}\n\t\tmatched = true;\n\t}\n\n\t__kvm_synchronize_tsc(vcpu, offset, data, ns, matched);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n}\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tu64 tsc_offset = vcpu->arch.l1_tsc_offset;\n\tkvm_vcpu_write_tsc_offset(vcpu, tsc_offset + adjustment);\n}\n\nstatic inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tif (vcpu->arch.l1_tsc_scaling_ratio != kvm_default_tsc_scaling_ratio)\n\t\tWARN_ON(adjustment < 0);\n\tadjustment = kvm_scale_tsc((u64) adjustment,\n\t\t\t\t   vcpu->arch.l1_tsc_scaling_ratio);\n\tadjust_tsc_offset_guest(vcpu, adjustment);\n}\n\n#ifdef CONFIG_X86_64\n\nstatic u64 read_tsc(void)\n{\n\tu64 ret = (u64)rdtsc_ordered();\n\tu64 last = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a function of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}\n\nstatic inline u64 vgettsc(struct pvclock_clock *clock, u64 *tsc_timestamp,\n\t\t\t  int *mode)\n{\n\tlong v;\n\tu64 tsc_pg_val;\n\n\tswitch (clock->vclock_mode) {\n\tcase VDSO_CLOCKMODE_HVCLOCK:\n\t\ttsc_pg_val = hv_read_tsc_page_tsc(hv_get_tsc_page(),\n\t\t\t\t\t\t  tsc_timestamp);\n\t\tif (tsc_pg_val != U64_MAX) {\n\t\t\t/* TSC page valid */\n\t\t\t*mode = VDSO_CLOCKMODE_HVCLOCK;\n\t\t\tv = (tsc_pg_val - clock->cycle_last) &\n\t\t\t\tclock->mask;\n\t\t} else {\n\t\t\t/* TSC page invalid */\n\t\t\t*mode = VDSO_CLOCKMODE_NONE;\n\t\t}\n\t\tbreak;\n\tcase VDSO_CLOCKMODE_TSC:\n\t\t*mode = VDSO_CLOCKMODE_TSC;\n\t\t*tsc_timestamp = read_tsc();\n\t\tv = (*tsc_timestamp - clock->cycle_last) &\n\t\t\tclock->mask;\n\t\tbreak;\n\tdefault:\n\t\t*mode = VDSO_CLOCKMODE_NONE;\n\t}\n\n\tif (*mode == VDSO_CLOCKMODE_NONE)\n\t\t*tsc_timestamp = v = 0;\n\n\treturn v * clock->mult;\n}\n\nstatic int do_monotonic_raw(s64 *t, u64 *tsc_timestamp)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tns = gtod->raw_clock.base_cycles;\n\t\tns += vgettsc(&gtod->raw_clock, tsc_timestamp, &mode);\n\t\tns >>= gtod->raw_clock.shift;\n\t\tns += ktime_to_ns(ktime_add(gtod->raw_clock.offset, gtod->offs_boot));\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}\n\nstatic int do_realtime(struct timespec64 *ts, u64 *tsc_timestamp)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tts->tv_sec = gtod->wall_time_sec;\n\t\tns = gtod->clock.base_cycles;\n\t\tns += vgettsc(&gtod->clock, tsc_timestamp, &mode);\n\t\tns >>= gtod->clock.shift;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\n\tts->tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &ns);\n\tts->tv_nsec = ns;\n\n\treturn mode;\n}\n\n/* returns true if host is using TSC based clocksource */\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, u64 *tsc_timestamp)\n{\n\t/* checked again under seqlock below */\n\tif (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))\n\t\treturn false;\n\n\treturn gtod_is_based_on_tsc(do_monotonic_raw(kernel_ns,\n\t\t\t\t\t\t      tsc_timestamp));\n}\n\n/* returns true if host is using TSC based clocksource */\nstatic bool kvm_get_walltime_and_clockread(struct timespec64 *ts,\n\t\t\t\t\t   u64 *tsc_timestamp)\n{\n\t/* checked again under seqlock below */\n\tif (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))\n\t\treturn false;\n\n\treturn gtod_is_based_on_tsc(do_realtime(ts, tsc_timestamp));\n}\n#endif\n\n/*\n *\n * Assuming a stable TSC across physical CPUS, and a stable TSC\n * across virtual CPUs, the following condition is possible.\n * Each numbered line represents an event visible to both\n * CPUs at the next numbered event.\n *\n * \"timespecX\" represents host monotonic time. \"tscX\" represents\n * RDTSC value.\n *\n * \t\tVCPU0 on CPU0\t\t|\tVCPU1 on CPU1\n *\n * 1.  read timespec0,tsc0\n * 2.\t\t\t\t\t| timespec1 = timespec0 + N\n * \t\t\t\t\t| tsc1 = tsc0 + M\n * 3. transition to guest\t\t| transition to guest\n * 4. ret0 = timespec0 + (rdtsc - tsc0) |\n * 5.\t\t\t\t        | ret1 = timespec1 + (rdtsc - tsc1)\n * \t\t\t\t        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))\n *\n * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:\n *\n * \t- ret0 < ret1\n *\t- timespec0 + (rdtsc - tsc0) < timespec0 + N + (rdtsc - (tsc0 + M))\n *\t\t...\n *\t- 0 < N - M => M < N\n *\n * That is, when timespec0 != timespec1, M < N. Unfortunately that is not\n * always the case (the difference between two distinct xtime instances\n * might be smaller then the difference between corresponding TSC reads,\n * when updating guest vcpus pvclock areas).\n *\n * To avoid that problem, do not allow visibility of distinct\n * system_timestamp/tsc_timestamp values simultaneously: use a master\n * copy of host monotonic time values. Update that master copy\n * in lockstep.\n *\n * Rely on synchronization of host TSCs and guest TSCs for monotonicity.\n *\n */\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tlockdep_assert_held(&kvm->arch.tsc_write_lock);\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !ka->backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}\n\nstatic void kvm_make_mclock_inprogress_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);\n}\n\nstatic void __kvm_start_pvclock_update(struct kvm *kvm)\n{\n\traw_spin_lock_irq(&kvm->arch.tsc_write_lock);\n\twrite_seqcount_begin(&kvm->arch.pvclock_sc);\n}\n\nstatic void kvm_start_pvclock_update(struct kvm *kvm)\n{\n\tkvm_make_mclock_inprogress_request(kvm);\n\n\t/* no guest entries from this point */\n\t__kvm_start_pvclock_update(kvm);\n}\n\nstatic void kvm_end_pvclock_update(struct kvm *kvm)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\twrite_seqcount_end(&ka->pvclock_sc);\n\traw_spin_unlock_irq(&ka->tsc_write_lock);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);\n}\n\nstatic void kvm_update_masterclock(struct kvm *kvm)\n{\n\tkvm_hv_request_tsc_page_update(kvm);\n\tkvm_start_pvclock_update(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tkvm_end_pvclock_update(kvm);\n}\n\n/* Called within read_seqcount_begin/retry for kvm->pvclock_sc.  */\nstatic void __get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\n\t/* both __this_cpu_read() and rdtsc() should be on the same cpu */\n\tget_cpu();\n\n\tdata->flags = 0;\n\tif (ka->use_master_clock && __this_cpu_read(cpu_tsc_khz)) {\n#ifdef CONFIG_X86_64\n\t\tstruct timespec64 ts;\n\n\t\tif (kvm_get_walltime_and_clockread(&ts, &data->host_tsc)) {\n\t\t\tdata->realtime = ts.tv_nsec + NSEC_PER_SEC * ts.tv_sec;\n\t\t\tdata->flags |= KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC;\n\t\t} else\n#endif\n\t\tdata->host_tsc = rdtsc();\n\n\t\tdata->flags |= KVM_CLOCK_TSC_STABLE;\n\t\thv_clock.tsc_timestamp = ka->master_cycle_now;\n\t\thv_clock.system_time = ka->master_kernel_ns + ka->kvmclock_offset;\n\t\tkvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,\n\t\t\t\t   &hv_clock.tsc_shift,\n\t\t\t\t   &hv_clock.tsc_to_system_mul);\n\t\tdata->clock = __pvclock_read_cycles(&hv_clock, data->host_tsc);\n\t} else {\n\t\tdata->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;\n\t}\n\n\tput_cpu();\n}\n\nstatic void get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&ka->pvclock_sc);\n\t\t__get_kvmclock(kvm, data);\n\t} while (read_seqcount_retry(&ka->pvclock_sc, seq));\n}\n\nu64 get_kvmclock_ns(struct kvm *kvm)\n{\n\tstruct kvm_clock_data data;\n\n\tget_kvmclock(kvm, &data);\n\treturn data.clock;\n}\n\nstatic void kvm_setup_guest_pvclock(struct kvm_vcpu *v,\n\t\t\t\t    struct gfn_to_pfn_cache *gpc,\n\t\t\t\t    unsigned int offset)\n{\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct pvclock_vcpu_time_info *guest_hv_clock;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&gpc->lock, flags);\n\twhile (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,\n\t\t\t\t\t   offset + sizeof(*guest_hv_clock))) {\n\t\tread_unlock_irqrestore(&gpc->lock, flags);\n\n\t\tif (kvm_gfn_to_pfn_cache_refresh(v->kvm, gpc, gpc->gpa,\n\t\t\t\t\t\t offset + sizeof(*guest_hv_clock)))\n\t\t\treturn;\n\n\t\tread_lock_irqsave(&gpc->lock, flags);\n\t}\n\n\tguest_hv_clock = (void *)(gpc->khva + offset);\n\n\t/*\n\t * This VCPU is paused, but it's legal for a guest to read another\n\t * VCPU's kvmclock, so we really have to follow the specification where\n\t * it says that version is odd if data is being modified, and even after\n\t * it is consistent.\n\t */\n\n\tguest_hv_clock->version = vcpu->hv_clock.version = (guest_hv_clock->version + 1) | 1;\n\tsmp_wmb();\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tvcpu->hv_clock.flags |= (guest_hv_clock->flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tvcpu->hv_clock.flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\tmemcpy(guest_hv_clock, &vcpu->hv_clock, sizeof(*guest_hv_clock));\n\tsmp_wmb();\n\n\tguest_hv_clock->version = ++vcpu->hv_clock.version;\n\n\tmark_page_dirty_in_slot(v->kvm, gpc->memslot, gpc->gpa >> PAGE_SHIFT);\n\tread_unlock_irqrestore(&gpc->lock, flags);\n\n\ttrace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);\n}\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, tgt_tsc_khz;\n\tunsigned seq;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ka->pvclock_sc);\n\t\tuse_master_clock = ka->use_master_clock;\n\t\tif (use_master_clock) {\n\t\t\thost_tsc = ka->master_cycle_now;\n\t\t\tkernel_ns = ka->master_kernel_ns;\n\t\t}\n\t} while (read_seqcount_retry(&ka->pvclock_sc, seq));\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\ttgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(tgt_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = rdtsc();\n\t\tkernel_ns = get_kvmclock_base_ns();\n\t}\n\n\ttsc_timestamp = kvm_read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\t/* With all the info we got, fill in the values */\n\n\tif (kvm_has_tsc_control)\n\t\ttgt_tsc_khz = kvm_scale_tsc(tgt_tsc_khz,\n\t\t\t\t\t    v->arch.l1_tsc_scaling_ratio);\n\n\tif (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = tgt_tsc_khz;\n\t}\n\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tpvclock_flags = 0;\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\tif (vcpu->pv_time.active)\n\t\tkvm_setup_guest_pvclock(v, &vcpu->pv_time, 0);\n\tif (vcpu->xen.vcpu_info_cache.active)\n\t\tkvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_info_cache,\n\t\t\t\t\toffsetof(struct compat_vcpu_info, time));\n\tif (vcpu->xen.vcpu_time_info_cache.active)\n\t\tkvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_time_info_cache, 0);\n\tkvm_hv_setup_tsc_page(v->kvm, &vcpu->hv_clock);\n\treturn 0;\n}\n\n/*\n * kvmclock updates which are isolated to a given vcpu, such as\n * vcpu->cpu migration, should not allow system_timestamp from\n * the rest of the vcpus to remain static. Otherwise ntp frequency\n * correction applies to one vcpu's system_timestamp but not\n * the others.\n *\n * So in those cases, request a kvmclock update for all vcpus.\n * We need to rate-limit these requests though, as they can\n * considerably slow guests that have a large number of vcpus.\n * The time for a remote vcpu to update its kvmclock is bound\n * by the delay we use to rate-limit the updates.\n */\n\n#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)\n\nstatic void kvmclock_update_fn(struct work_struct *work)\n{\n\tunsigned long i;\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_update_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}\n\n#define KVMCLOCK_SYNC_PERIOD (300 * HZ)\n\nstatic void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\n\tif (!kvmclock_periodic_sync)\n\t\treturn;\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}\n\n/*\n * On AMD, HWCR[McStatusWrEn] controls whether setting MCi_STATUS results in #GP.\n */\nstatic bool can_set_mci_status(struct kvm_vcpu *vcpu)\n{\n\t/* McStatusWrEn enabled? */\n\tif (guest_cpuid_is_amd_or_hygon(vcpu))\n\t\treturn !!(vcpu->arch.msr_hwcr & BIT_ULL(18));\n\n\treturn false;\n}\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P) &&\n\t\t    (data || !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = array_index_nospec(\n\t\t\t\tmsr - MSR_IA32_MC0_CTL,\n\t\t\t\tMSR_IA32_MCx_CTL(bank_num) - MSR_IA32_MC0_CTL);\n\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\n\t\t\t/* MCi_STATUS */\n\t\t\tif (!msr_info->host_initiated &&\n\t\t\t    (offset & 0x3) == 1 && data != 0) {\n\t\t\t\tif (!can_set_mci_status(vcpu))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline bool kvm_pv_async_pf_enabled(struct kvm_vcpu *vcpu)\n{\n\tu64 mask = KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_DELIVERY_AS_INT;\n\n\treturn (vcpu->arch.apf.msr_en_val & mask) == mask;\n}\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 4:5 are reserved, Should be zero */\n\tif (data & 0x30)\n\t\treturn 1;\n\n\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_VMEXIT) &&\n\t    (data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT))\n\t\treturn 1;\n\n\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT) &&\n\t    (data & KVM_ASYNC_PF_DELIVERY_AS_INT))\n\t\treturn 1;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn data ? 1 : 0;\n\n\tvcpu->arch.apf.msr_en_val = data;\n\n\tif (!kvm_pv_async_pf_enabled(vcpu)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u64)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tvcpu->arch.apf.delivery_as_pf_vmexit = data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT;\n\n\tkvm_async_pf_wakeup_all(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_pv_enable_async_pf_int(struct kvm_vcpu *vcpu, u64 data)\n{\n\t/* Bits 8-63 are reserved */\n\tif (data >> 8)\n\t\treturn 1;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_int_val = data;\n\n\tvcpu->arch.apf.vec = data & KVM_ASYNC_PF_VEC_MASK;\n\n\treturn 0;\n}\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tkvm_gfn_to_pfn_cache_destroy(vcpu->kvm, &vcpu->arch.pv_time);\n\tvcpu->arch.time = 0;\n}\n\nstatic void kvm_vcpu_flush_tlb_all(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tstatic_call(kvm_x86_flush_tlb_all)(vcpu);\n}\n\nstatic void kvm_vcpu_flush_tlb_guest(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\n\tif (!tdp_enabled) {\n\t\t/*\n\t\t * A TLB flush on behalf of the guest is equivalent to\n\t\t * INVPCID(all), toggling CR4.PGE, etc., which requires\n\t\t * a forced sync of the shadow page tables.  Ensure all the\n\t\t * roots are synced and the guest TLB in hardware is clean.\n\t\t */\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_sync_prev_roots(vcpu);\n\t}\n\n\tstatic_call(kvm_x86_flush_tlb_guest)(vcpu);\n}\n\n\nstatic inline void kvm_vcpu_flush_tlb_current(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tstatic_call(kvm_x86_flush_tlb_current)(vcpu);\n}\n\n/*\n * Service \"local\" TLB flush requests, which are specific to the current MMU\n * context.  In addition to the generic event handling in vcpu_enter_guest(),\n * TLB flushes that are targeted at an MMU context also need to be serviced\n * prior before nested VM-Enter/VM-Exit.\n */\nvoid kvm_service_local_tlb_flush_requests(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))\n\t\tkvm_vcpu_flush_tlb_current(vcpu);\n\n\tif (kvm_check_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu))\n\t\tkvm_vcpu_flush_tlb_guest(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_service_local_tlb_flush_requests);\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tu64 steal;\n\tu32 version;\n\n\tif (kvm_xen_msr_enabled(vcpu->kvm)) {\n\t\tkvm_xen_runstate_set_running(vcpu);\n\t\treturn;\n\t}\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\n\tslots = kvm_memslots(vcpu->kvm);\n\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot)) {\n\t\tgfn_t gfn = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;\n\n\t\t/* We rely on the fact that it fits in a single page. */\n\t\tBUILD_BUG_ON((sizeof(*st) - 1) & KVM_STEAL_VALID_BITS);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, gfn, sizeof(*st)) ||\n\t\t    kvm_is_error_hva(ghc->hva) || !ghc->memslot)\n\t\t\treturn;\n\t}\n\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\t/*\n\t * Doing a TLB flush here, on the guest's behalf, can avoid\n\t * expensive IPIs.\n\t */\n\tif (guest_pv_has(vcpu, KVM_FEATURE_PV_TLB_FLUSH)) {\n\t\tu8 st_preempted = 0;\n\t\tint err = -EFAULT;\n\n\t\tif (!user_access_begin(st, sizeof(*st)))\n\t\t\treturn;\n\n\t\tasm volatile(\"1: xchgb %0, %2\\n\"\n\t\t\t     \"xor %1, %1\\n\"\n\t\t\t     \"2:\\n\"\n\t\t\t     _ASM_EXTABLE_UA(1b, 2b)\n\t\t\t     : \"+q\" (st_preempted),\n\t\t\t       \"+&r\" (err),\n\t\t\t       \"+m\" (st->preempted));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tuser_access_end();\n\n\t\tvcpu->arch.st.preempted = 0;\n\n\t\ttrace_kvm_pv_tlb_flush(vcpu->vcpu_id,\n\t\t\t\t       st_preempted & KVM_VCPU_FLUSH_TLB);\n\t\tif (st_preempted & KVM_VCPU_FLUSH_TLB)\n\t\t\tkvm_vcpu_flush_tlb_guest(vcpu);\n\n\t\tif (!user_access_begin(st, sizeof(*st)))\n\t\t\tgoto dirty;\n\t} else {\n\t\tif (!user_access_begin(st, sizeof(*st)))\n\t\t\treturn;\n\n\t\tunsafe_put_user(0, &st->preempted, out);\n\t\tvcpu->arch.st.preempted = 0;\n\t}\n\n\tunsafe_get_user(version, &st->version, out);\n\tif (version & 1)\n\t\tversion += 1;  /* first time write, random junk */\n\n\tversion += 1;\n\tunsafe_put_user(version, &st->version, out);\n\n\tsmp_wmb();\n\n\tunsafe_get_user(steal, &st->steal, out);\n\tsteal += current->sched_info.run_delay -\n\t\tvcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tunsafe_put_user(steal, &st->steal, out);\n\n\tversion += 1;\n\tunsafe_put_user(version, &st->version, out);\n\n out:\n\tuser_access_end();\n dirty:\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tif (msr && msr == vcpu->kvm->arch.xen_hvm_config.msr)\n\t\treturn kvm_xen_write_hypercall_page(vcpu, data);\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tbreak;\n\n\tcase MSR_IA32_UCODE_REV:\n\t\tif (msr_info->host_initiated)\n\t\t\tvcpu->arch.microcode_version = data;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.arch_capabilities = data;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES: {\n\t\tstruct kvm_msr_entry msr_ent = {.index = msr, .data = 0};\n\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tif (kvm_get_msr_feature(&msr_ent))\n\t\t\treturn 1;\n\t\tif (data & ~msr_ent.data)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.perf_capabilities = data;\n\n\t\treturn 0;\n\t\t}\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, msr_info);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\n\t\t/* Handle McStatusWrEn */\n\t\tif (data == BIT_ULL(18)) {\n\t\t\tvcpu->arch.msr_hwcr = data;\n\t\t} else if (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSC_DEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t\t/* Before back to guest, tsc_timestamp must be adjusted\n\t\t\t\t * as well, otherwise guest's percpu pvclock time could jump.\n\t\t\t\t */\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&\n\t\t    ((vcpu->arch.ia32_misc_enable_msr ^ data) & MSR_IA32_MISC_ENABLE_MWAIT)) {\n\t\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))\n\t\t\t\treturn 1;\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t\tkvm_update_cpuid_runtime(vcpu);\n\t\t} else {\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tvcpu->arch.msr_ia32_power_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tif (msr_info->host_initiated) {\n\t\t\tkvm_synchronize_tsc(vcpu, data);\n\t\t} else {\n\t\t\tu64 adj = kvm_compute_l1_tsc_offset(vcpu, data) - vcpu->arch.l1_tsc_offset;\n\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr += adj;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\t/*\n\t\t * KVM supports exposing PT to the guest, but does not support\n\t\t * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than\n\t\t * XSAVES/XRSTORS to save/restore PT MSRs.\n\t\t */\n\t\tif (data & ~supported_xss)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smi_count = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data, 0);\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data, 0);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tkvm_write_system_time(vcpu, data, false, msr_info->host_initiated);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tkvm_write_system_time(vcpu, data, true,  msr_info->host_initiated);\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))\n\t\t\treturn 1;\n\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_INT:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\n\t\tif (kvm_pv_enable_async_pf_int(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_ACK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\t\tif (data & 0x1) {\n\t\t\tvcpu->arch.apf.pageready_pending = false;\n\t\t\tkvm_check_async_pf_completion(vcpu);\n\t\t}\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))\n\t\t\treturn 1;\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))\n\t\t\treturn 1;\n\n\t\tif (kvm_lapic_set_pv_eoi(vcpu, data, sizeof(u8)))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))\n\t\t\treturn 1;\n\n\t\t/* only enable bit supported */\n\t\tif (data & (-1ULL << 1))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.msr_kvm_poll_control = data;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr_info);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true;\n\t\tfallthrough;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tif (report_ignored_msrs)\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\tmsr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated ||\n\t\t    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&\n\t\t     cpuid_fault_enabled(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_platform_info = data;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tif (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||\n\t\t    (data & MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &&\n\t\t     !supports_cpuid_fault(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_misc_features_enables = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_IA32_XFD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_guest_supported_xfd(vcpu))\n\t\t\treturn 1;\n\n\t\tfpu_update_guest_xfd(&vcpu->arch.guest_fpu, data);\n\t\tbreak;\n\tcase MSR_IA32_XFD_ERR:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_guest_supported_xfd(vcpu))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.guest_fpu.xfd_err = data;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr_common);\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P) && !host)\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = array_index_nospec(\n\t\t\t\tmsr - MSR_IA32_MC0_CTL,\n\t\t\t\tMSR_IA32_MCx_CTL(bank_num) - MSR_IA32_MC0_CTL);\n\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_AMD64_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_IA32_PERF_CTL:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t/*\n\t * Intel Sandy Bridge CPUs must support the RAPL (running average power\n\t * limit) MSRs. Just return 0, as we do not want to expose the host\n\t * data here. Do not conditionalize this on CPUID, as KVM does not do\n\t * so for existing CPU-specific MSRs.\n\t */\n\tcase MSR_RAPL_POWER_UNIT:\n\tcase MSR_PP0_ENERGY_STATUS:\t/* Power plane 0 (core) */\n\tcase MSR_PP1_ENERGY_STATUS:\t/* Power plane 1 (graphics uncore) */\n\tcase MSR_PKG_ENERGY_STATUS:\t/* Total package */\n\tcase MSR_DRAM_ENERGY_STATUS:\t/* DRAM controller */\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info);\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = vcpu->arch.microcode_version;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.arch_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_PDCM))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.perf_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tmsr_info->data = vcpu->arch.msr_ia32_power_ctl;\n\t\tbreak;\n\tcase MSR_IA32_TSC: {\n\t\t/*\n\t\t * Intel SDM states that MSR_IA32_TSC read adds the TSC offset\n\t\t * even when not intercepted. AMD manual doesn't explicitly\n\t\t * state this but appears to behave the same.\n\t\t *\n\t\t * On userspace reads and writes, however, we unconditionally\n\t\t * return L1's TSC value to ensure backwards-compatible\n\t\t * behavior for migration.\n\t\t */\n\t\tu64 offset, ratio;\n\n\t\tif (msr_info->host_initiated) {\n\t\t\toffset = vcpu->arch.l1_tsc_offset;\n\t\t\tratio = vcpu->arch.l1_tsc_scaling_ratio;\n\t\t} else {\n\t\t\toffset = vcpu->arch.tsc_offset;\n\t\t\tratio = vcpu->arch.tsc_scaling_ratio;\n\t\t}\n\n\t\tmsr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;\n\t\tbreak;\n\t}\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_TSC_DEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tmsr_info->data = vcpu->arch.smi_count;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.apf.msr_en_val;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_INT:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.apf.msr_int_val;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_ACK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.msr_kvm_poll_control;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data,\n\t\t\t\t   msr_info->host_initiated);\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !vcpu->kvm->arch.guest_can_read_msr_platform_info)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.msr_platform_info;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tmsr_info->data = vcpu->arch.msr_misc_features_enables;\n\t\tbreak;\n\tcase MSR_K7_HWCR:\n\t\tmsr_info->data = vcpu->arch.msr_hwcr;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_IA32_XFD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.guest_fpu.fpstate->xfd;\n\t\tbreak;\n\tcase MSR_IA32_XFD_ERR:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.guest_fpu.xfd_err;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info);\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr_common);\n\n/*\n * Read or write a bunch of msrs. All parameters are kernel addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i;\n\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\n\treturn i;\n}\n\n/*\n * Read or write a bunch of msrs. Parameters are user addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof(msrs)))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}\n\nstatic inline bool kvm_can_mwait_in_guest(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_MWAIT) &&\n\t\t!boot_cpu_has_bug(X86_BUG_MONITOR) &&\n\t\tboot_cpu_has(X86_FEATURE_ARAT);\n}\n\nstatic int kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_cpuid2 __user *cpuid_arg)\n{\n\tstruct kvm_cpuid2 cpuid;\n\tint r;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\treturn r;\n\n\tr = kvm_get_hv_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\tif (r)\n\t\treturn r;\n\n\tr = -EFAULT;\n\tif (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))\n\t\treturn r;\n\n\treturn 0;\n}\n\nint kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r = 0;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_IOEVENTFD_NO_LENGTH:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_HYPERV_SYNIC:\n\tcase KVM_CAP_HYPERV_SYNIC2:\n\tcase KVM_CAP_HYPERV_VP_INDEX:\n\tcase KVM_CAP_HYPERV_EVENTFD:\n\tcase KVM_CAP_HYPERV_TLBFLUSH:\n\tcase KVM_CAP_HYPERV_SEND_IPI:\n\tcase KVM_CAP_HYPERV_CPUID:\n\tcase KVM_CAP_HYPERV_ENFORCE_CPUID:\n\tcase KVM_CAP_SYS_HYPERV_CPUID:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_ASYNC_PF_INT:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n\tcase KVM_CAP_HYPERV_TIME:\n\tcase KVM_CAP_IOAPIC_POLARITY_IGNORED:\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\tcase KVM_CAP_SET_BOOT_CPU_ID:\n \tcase KVM_CAP_SPLIT_IRQCHIP:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\tcase KVM_CAP_PMU_EVENT_FILTER:\n\tcase KVM_CAP_GET_MSR_FEATURES:\n\tcase KVM_CAP_MSR_PLATFORM_INFO:\n\tcase KVM_CAP_EXCEPTION_PAYLOAD:\n\tcase KVM_CAP_SET_GUEST_DEBUG:\n\tcase KVM_CAP_LAST_CPU:\n\tcase KVM_CAP_X86_USER_SPACE_MSR:\n\tcase KVM_CAP_X86_MSR_FILTER:\n\tcase KVM_CAP_ENFORCE_PV_FEATURE_CPUID:\n#ifdef CONFIG_X86_SGX_KVM\n\tcase KVM_CAP_SGX_ATTRIBUTE:\n#endif\n\tcase KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:\n\tcase KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:\n\tcase KVM_CAP_SREGS2:\n\tcase KVM_CAP_EXIT_ON_EMULATION_FAILURE:\n\tcase KVM_CAP_VCPU_ATTRIBUTES:\n\tcase KVM_CAP_SYS_ATTRIBUTES:\n\tcase KVM_CAP_VAPIC:\n\tcase KVM_CAP_ENABLE_CAP:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_EXIT_HYPERCALL:\n\t\tr = KVM_EXIT_HYPERCALL_VALID_MASK;\n\t\tbreak;\n\tcase KVM_CAP_SET_GUEST_DEBUG2:\n\t\treturn KVM_GUESTDBG_VALID_MASK;\n#ifdef CONFIG_KVM_XEN\n\tcase KVM_CAP_XEN_HVM:\n\t\tr = KVM_XEN_HVM_CONFIG_HYPERCALL_MSR |\n\t\t    KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |\n\t\t    KVM_XEN_HVM_CONFIG_SHARED_INFO |\n\t\t    KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL |\n\t\t    KVM_XEN_HVM_CONFIG_EVTCHN_SEND;\n\t\tif (sched_info_on())\n\t\t\tr |= KVM_XEN_HVM_CONFIG_RUNSTATE;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_REGS:\n\t\tr = KVM_SYNC_X86_VALID_FIELDS;\n\t\tbreak;\n\tcase KVM_CAP_ADJUST_CLOCK:\n\t\tr = KVM_CLOCK_VALID_FLAGS;\n\t\tbreak;\n\tcase KVM_CAP_X86_DISABLE_EXITS:\n\t\tr |=  KVM_X86_DISABLE_EXITS_HLT | KVM_X86_DISABLE_EXITS_PAUSE |\n\t\t      KVM_X86_DISABLE_EXITS_CSTATE;\n\t\tif(kvm_can_mwait_in_guest())\n\t\t\tr |= KVM_X86_DISABLE_EXITS_MWAIT;\n\t\tbreak;\n\tcase KVM_CAP_X86_SMM:\n\t\t/* SMBASE is usually relocated above 1M on modern chipsets,\n\t\t * and SMM handlers might indeed rely on 4G segment limits,\n\t\t * so do not report SMM to be available if real mode is\n\t\t * emulated via vm86 mode.  Still, do not go to great lengths\n\t\t * to avoid userspace's usage of the feature, because it is a\n\t\t * fringe case that is not enabled except via specific settings\n\t\t * of the module parameters.\n\t\t */\n\t\tr = static_call(kvm_x86_has_emulated_msr)(kvm, MSR_IA32_SMBASE);\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = min_t(unsigned int, num_online_cpus(), KVM_MAX_VCPUS);\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPU_ID:\n\t\tr = KVM_MAX_VCPU_IDS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = boot_cpu_has(X86_FEATURE_XSAVE);\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\tcase KVM_CAP_VM_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tcase KVM_CAP_X2APIC_API:\n\t\tr = KVM_X2APIC_API_VALID_FLAGS;\n\t\tbreak;\n\tcase KVM_CAP_NESTED_STATE:\n\t\tr = kvm_x86_ops.nested_ops->get_state ?\n\t\t\tkvm_x86_ops.nested_ops->get_state(NULL, NULL, 0) : 0;\n\t\tbreak;\n\tcase KVM_CAP_HYPERV_DIRECT_TLBFLUSH:\n\t\tr = kvm_x86_ops.enable_direct_tlbflush != NULL;\n\t\tbreak;\n\tcase KVM_CAP_HYPERV_ENLIGHTENED_VMCS:\n\t\tr = kvm_x86_ops.nested_ops->enable_evmcs != NULL;\n\t\tbreak;\n\tcase KVM_CAP_SMALLER_MAXPHYADDR:\n\t\tr = (int) allow_smaller_maxphyaddr;\n\t\tbreak;\n\tcase KVM_CAP_STEAL_TIME:\n\t\tr = sched_info_on();\n\t\tbreak;\n\tcase KVM_CAP_X86_BUS_LOCK_EXIT:\n\t\tif (kvm_has_bus_lock_exit)\n\t\t\tr = KVM_BUS_LOCK_DETECTION_OFF |\n\t\t\t    KVM_BUS_LOCK_DETECTION_EXIT;\n\t\telse\n\t\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_XSAVE2: {\n\t\tu64 guest_perm = xstate_get_guest_group_perm();\n\n\t\tr = xstate_required_size(supported_xcr0 & guest_perm, false);\n\t\tif (r < sizeof(struct kvm_xsave))\n\t\t\tr = sizeof(struct kvm_xsave);\n\t\tbreak;\n\tcase KVM_CAP_PMU_CAPABILITY:\n\t\tr = enable_pmu ? KVM_CAP_PMU_VALID_MASK : 0;\n\t\tbreak;\n\t}\n\tcase KVM_CAP_DISABLE_QUIRKS2:\n\t\tr = KVM_X86_VALID_QUIRKS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic inline void __user *kvm_get_attr_addr(struct kvm_device_attr *attr)\n{\n\tvoid __user *uaddr = (void __user*)(unsigned long)attr->addr;\n\n\tif ((u64)(unsigned long)uaddr != attr->addr)\n\t\treturn ERR_PTR_USR(-EFAULT);\n\treturn uaddr;\n}\n\nstatic int kvm_x86_dev_get_attr(struct kvm_device_attr *attr)\n{\n\tu64 __user *uaddr = kvm_get_attr_addr(attr);\n\n\tif (attr->group)\n\t\treturn -ENXIO;\n\n\tif (IS_ERR(uaddr))\n\t\treturn PTR_ERR(uaddr);\n\n\tswitch (attr->attr) {\n\tcase KVM_X86_XCOMP_GUEST_SUPP:\n\t\tif (put_user(supported_xcr0, uaddr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENXIO;\n\t\tbreak;\n\t}\n}\n\nstatic int kvm_x86_dev_has_attr(struct kvm_device_attr *attr)\n{\n\tif (attr->group)\n\t\treturn -ENXIO;\n\n\tswitch (attr->attr) {\n\tcase KVM_X86_XCOMP_GUEST_SUPP:\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t num_emulated_msrs * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED:\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &kvm_mce_cap_supported,\n\t\t\t\t sizeof(kvm_mce_cap_supported)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_GET_MSR_FEATURE_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned int n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msr_based_features;\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msr_based_features,\n\t\t\t\t num_msr_based_features * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(NULL, argp, do_get_msr_feature, 1);\n\t\tbreak;\n\tcase KVM_GET_SUPPORTED_HV_CPUID:\n\t\tr = kvm_ioctl_get_supported_hv_cpuid(NULL, argp);\n\t\tbreak;\n\tcase KVM_GET_DEVICE_ATTR: {\n\t\tstruct kvm_device_attr attr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))\n\t\t\tbreak;\n\t\tr = kvm_x86_dev_get_attr(&attr);\n\t\tbreak;\n\t}\n\tcase KVM_HAS_DEVICE_ATTR: {\n\t\tstruct kvm_device_attr attr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))\n\t\t\tbreak;\n\t\tr = kvm_x86_dev_has_attr(&attr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn r;\n}\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (static_call(kvm_x86_has_wbinvd_exit)())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tstatic_call(kvm_x86_vcpu_load)(vcpu, cpu);\n\n\t/* Save host pkru register if supported */\n\tvcpu->arch.host_pkru = read_pkru();\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || kvm_check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\trdtsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\n\t\tif (kvm_check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_compute_l1_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_vcpu_write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\n\t\tif (kvm_lapic_hv_timer_in_use(vcpu))\n\t\t\tkvm_lapic_restart_hv_timer(vcpu);\n\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_make_request(KVM_REQ_MIGRATE_TIMER, vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}\n\nstatic void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tstatic const u8 preempted = KVM_VCPU_PREEMPTED;\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (vcpu->arch.st.preempted)\n\t\treturn;\n\n\t/* This happens on process exit */\n\tif (unlikely(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\n\tslots = kvm_memslots(vcpu->kvm);\n\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot))\n\t\treturn;\n\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\tBUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted));\n\n\tif (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))\n\t\tvcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;\n\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tif (vcpu->preempted) {\n\t\tif (!vcpu->arch.guest_state_protected)\n\t\t\tvcpu->arch.preempted_in_kernel = !static_call(kvm_x86_get_cpl)(vcpu);\n\n\t\t/*\n\t\t * Take the srcu lock as memslots will be accessed to check the gfn\n\t\t * cache generation against the memslots generation.\n\t\t */\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tif (kvm_xen_msr_enabled(vcpu->kvm))\n\t\t\tkvm_xen_runstate_set_preempted(vcpu);\n\t\telse\n\t\t\tkvm_steal_time_set_preempted(vcpu);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t}\n\n\tstatic_call(kvm_x86_vcpu_put)(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\n\treturn kvm_apic_get_state(vcpu, s);\n}\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tint r;\n\n\tr = kvm_apic_set_state(vcpu, s);\n\tif (r)\n\t\treturn r;\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * We can accept userspace's request for interrupt injection\n\t * as long as we have a place to store the interrupt number.\n\t * The actual injection will happen when the CPU is able to\n\t * deliver the interrupt.\n\t */\n\tif (kvm_cpu_has_extint(vcpu))\n\t\treturn false;\n\n\t/* Acknowledging ExtINT does not happen if LINT0 is masked.  */\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}\n\nstatic int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Do not cause an interrupt window exit if an exception\n\t * is pending or an event needs reinjection; userspace\n\t * might want to inject the interrupt manually using KVM_SET_REGS\n\t * or KVM_SET_SREGS.  For that to work, we must be at an\n\t * instruction boundary and with no events half-injected.\n\t */\n\treturn (kvm_arch_interrupt_allowed(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\t!vcpu->arch.exception.pending);\n}\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * With in-kernel LAPIC, we only use this to inject EXTINT, so\n\t * fail for in-kernel 8259.\n\t */\n\tif (pic_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tif (vcpu->arch.pending_external_vector != -1)\n\t\treturn -EEXIST;\n\n\tvcpu->arch.pending_external_vector = irq->irq;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\n\treturn 0;\n}\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num > KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(kvm_mce_cap_supported | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\n\n\tstatic_call(kvm_x86_setup_mce)(vcpu);\nout:\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\n\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\tprocess_smi(vcpu);\n\n\t/*\n\t * In guest mode, payload delivery should be deferred,\n\t * so that the L1 hypervisor can intercept #PF before\n\t * CR2 is modified (or intercept #DB before DR6 is\n\t * modified under nVMX). Unless the per-VM capability,\n\t * KVM_CAP_EXCEPTION_PAYLOAD, is set, we may not defer the delivery of\n\t * an exception payload and handle after a KVM_GET_VCPU_EVENTS. Since we\n\t * opportunistically defer the exception payload, deliver it if the\n\t * capability hasn't been requested before processing a\n\t * KVM_GET_VCPU_EVENTS.\n\t */\n\tif (!vcpu->kvm->arch.exception_payload_enabled &&\n\t    vcpu->arch.exception.pending && vcpu->arch.exception.has_payload)\n\t\tkvm_deliver_exception_payload(vcpu);\n\n\t/*\n\t * The API doesn't provide the instruction length for software\n\t * exceptions, so don't report them. As long as the guest RIP\n\t * isn't advanced, we should expect to encounter the exception\n\t * again.\n\t */\n\tif (kvm_exception_is_soft(vcpu->arch.exception.nr)) {\n\t\tevents->exception.injected = 0;\n\t\tevents->exception.pending = 0;\n\t} else {\n\t\tevents->exception.injected = vcpu->arch.exception.injected;\n\t\tevents->exception.pending = vcpu->arch.exception.pending;\n\t\t/*\n\t\t * For ABI compatibility, deliberately conflate\n\t\t * pending and injected exceptions when\n\t\t * KVM_CAP_EXCEPTION_PAYLOAD isn't enabled.\n\t\t */\n\t\tif (!vcpu->kvm->arch.exception_payload_enabled)\n\t\t\tevents->exception.injected |=\n\t\t\t\tvcpu->arch.exception.pending;\n\t}\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\tevents->exception_has_payload = vcpu->arch.exception.has_payload;\n\tevents->exception_payload = vcpu->arch.exception.payload;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = static_call(kvm_x86_get_nmi_mask)(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->smi.smm = is_smm(vcpu);\n\tevents->smi.pending = vcpu->arch.smi_pending;\n\tevents->smi.smm_inside_nmi =\n\t\t!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);\n\tevents->smi.latched_init = kvm_lapic_latched_init(vcpu);\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t | KVM_VCPUEVENT_VALID_SMM);\n\tif (vcpu->kvm->arch.exception_payload_enabled)\n\t\tevents->flags |= KVM_VCPUEVENT_VALID_PAYLOAD;\n\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm);\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM\n\t\t\t      | KVM_VCPUEVENT_VALID_PAYLOAD))\n\t\treturn -EINVAL;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_PAYLOAD) {\n\t\tif (!vcpu->kvm->arch.exception_payload_enabled)\n\t\t\treturn -EINVAL;\n\t\tif (events->exception.pending)\n\t\t\tevents->exception.injected = 0;\n\t\telse\n\t\t\tevents->exception_has_payload = 0;\n\t} else {\n\t\tevents->exception.pending = 0;\n\t\tevents->exception_has_payload = 0;\n\t}\n\n\tif ((events->exception.injected || events->exception.pending) &&\n\t    (events->exception.nr > 31 || events->exception.nr == NMI_VECTOR))\n\t\treturn -EINVAL;\n\n\t/* INITs are latched while in SMM */\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM &&\n\t    (events->smi.smm || events->smi.pending) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED)\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.injected = events->exception.injected;\n\tvcpu->arch.exception.pending = events->exception.pending;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\tvcpu->arch.exception.has_payload = events->exception_has_payload;\n\tvcpu->arch.exception.payload = events->exception_payload;\n\n\tvcpu->arch.interrupt.injected = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tstatic_call(kvm_x86_set_interrupt_shadow)(vcpu,\n\t\t\t\t\t\tevents->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tstatic_call(kvm_x86_set_nmi_mask)(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    lapic_in_kernel(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (!!(vcpu->arch.hflags & HF_SMM_MASK) != events->smi.smm) {\n\t\t\tkvm_x86_ops.nested_ops->leave_nested(vcpu);\n\t\t\tkvm_smm_changed(vcpu, events->smi.smm);\n\t\t}\n\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\n\t\tif (events->smi.smm) {\n\t\t\tif (events->smi.smm_inside_nmi)\n\t\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\t\telse\n\t\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\t}\n\n\t\tif (lapic_in_kernel(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tif (!kvm_dr6_valid(dbgregs->dr6))\n\t\treturn -EINVAL;\n\tif (!kvm_dr7_valid(dbgregs->dr7))\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn;\n\n\tfpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,\n\t\t\t\t       guest_xsave->region,\n\t\t\t\t       sizeof(guest_xsave->region),\n\t\t\t\t       vcpu->arch.pkru);\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave2(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  u8 *state, unsigned int size)\n{\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn;\n\n\tfpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,\n\t\t\t\t       state, size, vcpu->arch.pkru);\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn 0;\n\n\treturn fpu_copy_uabi_to_guest_fpstate(&vcpu->arch.guest_fpu,\n\t\t\t\t\t      guest_xsave->region,\n\t\t\t\t\t      supported_xcr0, &vcpu->arch.pkru);\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE)) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}\n\n/*\n * kvm_set_guest_paused() indicates to the guest kernel that it has been\n * stopped by the hypervisor.  This function will be called from the host only.\n * EINVAL is returned when the host attempts to set the flag for a guest that\n * does not support pv clocks.\n */\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time.active)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}\n\nstatic int kvm_arch_tsc_has_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_device_attr *attr)\n{\n\tint r;\n\n\tswitch (attr->attr) {\n\tcase KVM_VCPU_TSC_OFFSET:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = -ENXIO;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_arch_tsc_get_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_device_attr *attr)\n{\n\tu64 __user *uaddr = kvm_get_attr_addr(attr);\n\tint r;\n\n\tif (IS_ERR(uaddr))\n\t\treturn PTR_ERR(uaddr);\n\n\tswitch (attr->attr) {\n\tcase KVM_VCPU_TSC_OFFSET:\n\t\tr = -EFAULT;\n\t\tif (put_user(vcpu->arch.l1_tsc_offset, uaddr))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = -ENXIO;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_arch_tsc_set_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_device_attr *attr)\n{\n\tu64 __user *uaddr = kvm_get_attr_addr(attr);\n\tstruct kvm *kvm = vcpu->kvm;\n\tint r;\n\n\tif (IS_ERR(uaddr))\n\t\treturn PTR_ERR(uaddr);\n\n\tswitch (attr->attr) {\n\tcase KVM_VCPU_TSC_OFFSET: {\n\t\tu64 offset, tsc, ns;\n\t\tunsigned long flags;\n\t\tbool matched;\n\n\t\tr = -EFAULT;\n\t\tif (get_user(offset, uaddr))\n\t\t\tbreak;\n\n\t\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\n\t\tmatched = (vcpu->arch.virtual_tsc_khz &&\n\t\t\t   kvm->arch.last_tsc_khz == vcpu->arch.virtual_tsc_khz &&\n\t\t\t   kvm->arch.last_tsc_offset == offset);\n\n\t\ttsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio) + offset;\n\t\tns = get_kvmclock_base_ns();\n\n\t\t__kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);\n\t\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -ENXIO;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_device_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t      unsigned int ioctl,\n\t\t\t\t      void __user *argp)\n{\n\tstruct kvm_device_attr attr;\n\tint r;\n\n\tif (copy_from_user(&attr, argp, sizeof(attr)))\n\t\treturn -EFAULT;\n\n\tif (attr.group != KVM_VCPU_TSC_CTRL)\n\t\treturn -ENXIO;\n\n\tswitch (ioctl) {\n\tcase KVM_HAS_DEVICE_ATTR:\n\t\tr = kvm_arch_tsc_has_attr(vcpu, &attr);\n\t\tbreak;\n\tcase KVM_GET_DEVICE_ATTR:\n\t\tr = kvm_arch_tsc_get_attr(vcpu, &attr);\n\t\tbreak;\n\tcase KVM_SET_DEVICE_ATTR:\n\t\tr = kvm_arch_tsc_set_attr(vcpu, &attr);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_enable_cap *cap)\n{\n\tint r;\n\tuint16_t vmcs_version;\n\tvoid __user *user_ptr;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_HYPERV_SYNIC2:\n\t\tif (cap->args[0])\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\n\tcase KVM_CAP_HYPERV_SYNIC:\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\treturn -EINVAL;\n\t\treturn kvm_hv_activate_synic(vcpu, cap->cap ==\n\t\t\t\t\t     KVM_CAP_HYPERV_SYNIC2);\n\tcase KVM_CAP_HYPERV_ENLIGHTENED_VMCS:\n\t\tif (!kvm_x86_ops.nested_ops->enable_evmcs)\n\t\t\treturn -ENOTTY;\n\t\tr = kvm_x86_ops.nested_ops->enable_evmcs(vcpu, &vmcs_version);\n\t\tif (!r) {\n\t\t\tuser_ptr = (void __user *)(uintptr_t)cap->args[0];\n\t\t\tif (copy_to_user(user_ptr, &vmcs_version,\n\t\t\t\t\t sizeof(vmcs_version)))\n\t\t\t\tr = -EFAULT;\n\t\t}\n\t\treturn r;\n\tcase KVM_CAP_HYPERV_DIRECT_TLBFLUSH:\n\t\tif (!kvm_x86_ops.enable_direct_tlbflush)\n\t\t\treturn -ENOTTY;\n\n\t\treturn static_call(kvm_x86_enable_direct_tlbflush)(vcpu);\n\n\tcase KVM_CAP_HYPERV_ENFORCE_CPUID:\n\t\treturn kvm_hv_set_enforce_cpuid(vcpu, cap->args[0]);\n\n\tcase KVM_CAP_ENFORCE_PV_FEATURE_CPUID:\n\t\tvcpu->arch.pv_cpuid.enforce = cap->args[0];\n\t\tif (vcpu->arch.pv_cpuid.enforce)\n\t\t\tkvm_update_pv_runtime(vcpu);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_sregs2 *sregs2;\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tvcpu_load(vcpu);\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic)) {\n\t\t\tr = PTR_ERR(u.lapic);\n\t\t\tgoto out_nofree;\n\t\t}\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof(irq)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SMI: {\n\t\tr = kvm_vcpu_ioctl_smi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS: {\n\t\tint idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = msr_io(vcpu, argp, do_get_msr, 1);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_SET_MSRS: {\n\t\tint idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof(tac)))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof(tac)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\t\tint idx;\n\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof(va)))\n\t\t\tgoto out;\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof(mcg_cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof(mce)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tr = -EINVAL;\n\t\tif (vcpu->arch.guest_fpu.uabi_size > sizeof(struct kvm_xsave))\n\t\t\tbreak;\n\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tint size = vcpu->arch.guest_fpu.uabi_size;\n\n\t\tu.xsave = memdup_user(argp, size);\n\t\tif (IS_ERR(u.xsave)) {\n\t\t\tr = PTR_ERR(u.xsave);\n\t\t\tgoto out_nofree;\n\t\t}\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\n\tcase KVM_GET_XSAVE2: {\n\t\tint size = vcpu->arch.guest_fpu.uabi_size;\n\n\t\tu.xsave = kzalloc(size, GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave2(vcpu, u.buffer, size);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, size))\n\t\t\tbreak;\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs)) {\n\t\t\tr = PTR_ERR(u.xcrs);\n\t\t\tgoto out_nofree;\n\t\t}\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (kvm_has_tsc_control &&\n\t\t    user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tif (!kvm_set_tsc_khz(vcpu, user_tsc_khz))\n\t\t\tr = 0;\n\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);\n\t\tbreak;\n\t}\n\tcase KVM_GET_NESTED_STATE: {\n\t\tstruct kvm_nested_state __user *user_kvm_nested_state = argp;\n\t\tu32 user_data_size;\n\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.nested_ops->get_state)\n\t\t\tbreak;\n\n\t\tBUILD_BUG_ON(sizeof(user_data_size) != sizeof(user_kvm_nested_state->size));\n\t\tr = -EFAULT;\n\t\tif (get_user(user_data_size, &user_kvm_nested_state->size))\n\t\t\tbreak;\n\n\t\tr = kvm_x86_ops.nested_ops->get_state(vcpu, user_kvm_nested_state,\n\t\t\t\t\t\t     user_data_size);\n\t\tif (r < 0)\n\t\t\tbreak;\n\n\t\tif (r > user_data_size) {\n\t\t\tif (put_user(r, &user_kvm_nested_state->size))\n\t\t\t\tr = -EFAULT;\n\t\t\telse\n\t\t\t\tr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_NESTED_STATE: {\n\t\tstruct kvm_nested_state __user *user_kvm_nested_state = argp;\n\t\tstruct kvm_nested_state kvm_state;\n\t\tint idx;\n\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.nested_ops->set_state)\n\t\t\tbreak;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm_state, user_kvm_nested_state, sizeof(kvm_state)))\n\t\t\tbreak;\n\n\t\tr = -EINVAL;\n\t\tif (kvm_state.size < sizeof(kvm_state))\n\t\t\tbreak;\n\n\t\tif (kvm_state.flags &\n\t\t    ~(KVM_STATE_NESTED_RUN_PENDING | KVM_STATE_NESTED_GUEST_MODE\n\t\t      | KVM_STATE_NESTED_EVMCS | KVM_STATE_NESTED_MTF_PENDING\n\t\t      | KVM_STATE_NESTED_GIF_SET))\n\t\t\tbreak;\n\n\t\t/* nested_run_pending implies guest_mode.  */\n\t\tif ((kvm_state.flags & KVM_STATE_NESTED_RUN_PENDING)\n\t\t    && !(kvm_state.flags & KVM_STATE_NESTED_GUEST_MODE))\n\t\t\tbreak;\n\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = kvm_x86_ops.nested_ops->set_state(vcpu, user_kvm_nested_state, &kvm_state);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_HV_CPUID:\n\t\tr = kvm_ioctl_get_supported_hv_cpuid(vcpu, argp);\n\t\tbreak;\n#ifdef CONFIG_KVM_XEN\n\tcase KVM_XEN_VCPU_GET_ATTR: {\n\t\tstruct kvm_xen_vcpu_attr xva;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xva, argp, sizeof(xva)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_vcpu_get_attr(vcpu, &xva);\n\t\tif (!r && copy_to_user(argp, &xva, sizeof(xva)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_VCPU_SET_ATTR: {\n\t\tstruct kvm_xen_vcpu_attr xva;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xva, argp, sizeof(xva)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_vcpu_set_attr(vcpu, &xva);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_GET_SREGS2: {\n\t\tu.sregs2 = kzalloc(sizeof(struct kvm_sregs2), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.sregs2)\n\t\t\tgoto out;\n\t\t__get_sregs2(vcpu, u.sregs2);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.sregs2, sizeof(struct kvm_sregs2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_SREGS2: {\n\t\tu.sregs2 = memdup_user(argp, sizeof(struct kvm_sregs2));\n\t\tif (IS_ERR(u.sregs2)) {\n\t\t\tr = PTR_ERR(u.sregs2);\n\t\t\tu.sregs2 = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = __set_sregs2(vcpu, u.sregs2);\n\t\tbreak;\n\t}\n\tcase KVM_HAS_DEVICE_ATTR:\n\tcase KVM_GET_DEVICE_ATTR:\n\tcase KVM_SET_DEVICE_ATTR:\n\t\tr = kvm_vcpu_ioctl_device_attr(vcpu, ioctl, argp);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\nout_nofree:\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\nvm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = static_call(kvm_x86_set_tss_addr)(kvm, addr);\n\treturn ret;\n}\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\treturn static_call(kvm_x86_set_identity_map_addr)(kvm, ident_addr);\n}\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t unsigned long kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}\n\nstatic unsigned long kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tstruct kvm_pic *pic = kvm->arch.vpic;\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic, &pic->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic, &pic->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tkvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tstruct kvm_pic *pic = kvm->arch.vpic;\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic->lock);\n\t\tmemcpy(&pic->pics[0], &chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic->lock);\n\t\tmemcpy(&pic->pics[1], &chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tkvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tstruct kvm_kpit_state *kps = &kvm->arch.vpit->pit_state;\n\n\tBUILD_BUG_ON(sizeof(*ps) != sizeof(kps->channels));\n\n\tmutex_lock(&kps->lock);\n\tmemcpy(ps, &kps->channels, sizeof(*ps));\n\tmutex_unlock(&kps->lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint i;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tmemcpy(&pit->pit_state.channels, ps, sizeof(*ps));\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, ps->channels[i].count, 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tprev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&pit->pit_state.channels, &ps->channels,\n\t       sizeof(pit->pit_state.channels));\n\tpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,\n\t\t\t\t   start && i == 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\t/* pit->pit_state.lock was overloaded to prevent userspace from getting\n\t * an inconsistent state after running multiple KVM_REINJECT_CONTROL\n\t * ioctls in parallel.  Use a separate lock if that ioctl isn't rare.\n\t */\n\tmutex_lock(&pit->pit_state.lock);\n\tkvm_pit_set_reinject(pit, control->pit_reinject);\n\tmutex_unlock(&pit->pit_state.lock);\n\n\treturn 0;\n}\n\nvoid kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)\n{\n\n\t/*\n\t * Flush all CPUs' dirty log buffers to the  dirty_bitmap.  Called\n\t * before reporting dirty_bitmap to userspace.  KVM flushes the buffers\n\t * on all VM-Exits, thus we only need to kick running vCPUs to force a\n\t * VM-Exit.\n\t */\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}\n\nint kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t    struct kvm_enable_cap *cap)\n{\n\tint r;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_DISABLE_QUIRKS2:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_X86_VALID_QUIRKS)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\t\tkvm->arch.disabled_quirks = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_SPLIT_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto split_irqchip_unlock;\n\t\tif (kvm->created_vcpus)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = kvm_setup_empty_irq_routing(kvm);\n\t\tif (r)\n\t\t\tgoto split_irqchip_unlock;\n\t\t/* Pairs with irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_mode = KVM_IRQCHIP_SPLIT;\n\t\tkvm->arch.nr_reserved_ioapic_pins = cap->args[0];\n\t\tkvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);\n\t\tr = 0;\nsplit_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CAP_X2APIC_API:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)\n\t\t\tbreak;\n\n\t\tif (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)\n\t\t\tkvm->arch.x2apic_format = true;\n\t\tif (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)\n\t\t\tkvm->arch.x2apic_broadcast_quirk_disabled = true;\n\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_X86_DISABLE_EXITS:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_X86_DISABLE_VALID_EXITS)\n\t\t\tbreak;\n\n\t\tif ((cap->args[0] & KVM_X86_DISABLE_EXITS_MWAIT) &&\n\t\t\tkvm_can_mwait_in_guest())\n\t\t\tkvm->arch.mwait_in_guest = true;\n\t\tif (cap->args[0] & KVM_X86_DISABLE_EXITS_HLT)\n\t\t\tkvm->arch.hlt_in_guest = true;\n\t\tif (cap->args[0] & KVM_X86_DISABLE_EXITS_PAUSE)\n\t\t\tkvm->arch.pause_in_guest = true;\n\t\tif (cap->args[0] & KVM_X86_DISABLE_EXITS_CSTATE)\n\t\t\tkvm->arch.cstate_in_guest = true;\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_MSR_PLATFORM_INFO:\n\t\tkvm->arch.guest_can_read_msr_platform_info = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_EXCEPTION_PAYLOAD:\n\t\tkvm->arch.exception_payload_enabled = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_X86_USER_SPACE_MSR:\n\t\tkvm->arch.user_space_msr_mask = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_X86_BUS_LOCK_EXIT:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_BUS_LOCK_DETECTION_VALID_MODE)\n\t\t\tbreak;\n\n\t\tif ((cap->args[0] & KVM_BUS_LOCK_DETECTION_OFF) &&\n\t\t    (cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT))\n\t\t\tbreak;\n\n\t\tif (kvm_has_bus_lock_exit &&\n\t\t    cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT)\n\t\t\tkvm->arch.bus_lock_detection_enabled = true;\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_SGX_KVM\n\tcase KVM_CAP_SGX_ATTRIBUTE: {\n\t\tunsigned long allowed_attributes = 0;\n\n\t\tr = sgx_set_attribute(&allowed_attributes, cap->args[0]);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\t/* KVM only supports the PROVISIONKEY privileged attribute. */\n\t\tif ((allowed_attributes & SGX_ATTR_PROVISIONKEY) &&\n\t\t    !(allowed_attributes & ~SGX_ATTR_PROVISIONKEY))\n\t\t\tkvm->arch.sgx_provisioning_allowed = true;\n\t\telse\n\t\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.vm_copy_enc_context_from)\n\t\t\tbreak;\n\n\t\tr = static_call(kvm_x86_vm_copy_enc_context_from)(kvm, cap->args[0]);\n\t\tbreak;\n\tcase KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.vm_move_enc_context_from)\n\t\t\tbreak;\n\n\t\tr = static_call(kvm_x86_vm_move_enc_context_from)(kvm, cap->args[0]);\n\t\tbreak;\n\tcase KVM_CAP_EXIT_HYPERCALL:\n\t\tif (cap->args[0] & ~KVM_EXIT_HYPERCALL_VALID_MASK) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tkvm->arch.hypercall_exit_enabled = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_EXIT_ON_EMULATION_FAILURE:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~1)\n\t\t\tbreak;\n\t\tkvm->arch.exit_on_emulation_error = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PMU_CAPABILITY:\n\t\tr = -EINVAL;\n\t\tif (!enable_pmu || (cap->args[0] & ~KVM_CAP_PMU_VALID_MASK))\n\t\t\tbreak;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tif (!kvm->created_vcpus) {\n\t\t\tkvm->arch.enable_pmu = !(cap->args[0] & KVM_PMU_CAP_DISABLE);\n\t\t\tr = 0;\n\t\t}\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic struct kvm_x86_msr_filter *kvm_alloc_msr_filter(bool default_allow)\n{\n\tstruct kvm_x86_msr_filter *msr_filter;\n\n\tmsr_filter = kzalloc(sizeof(*msr_filter), GFP_KERNEL_ACCOUNT);\n\tif (!msr_filter)\n\t\treturn NULL;\n\n\tmsr_filter->default_allow = default_allow;\n\treturn msr_filter;\n}\n\nstatic void kvm_free_msr_filter(struct kvm_x86_msr_filter *msr_filter)\n{\n\tu32 i;\n\n\tif (!msr_filter)\n\t\treturn;\n\n\tfor (i = 0; i < msr_filter->count; i++)\n\t\tkfree(msr_filter->ranges[i].bitmap);\n\n\tkfree(msr_filter);\n}\n\nstatic int kvm_add_msr_filter(struct kvm_x86_msr_filter *msr_filter,\n\t\t\t      struct kvm_msr_filter_range *user_range)\n{\n\tunsigned long *bitmap = NULL;\n\tsize_t bitmap_size;\n\n\tif (!user_range->nmsrs)\n\t\treturn 0;\n\n\tif (user_range->flags & ~(KVM_MSR_FILTER_READ | KVM_MSR_FILTER_WRITE))\n\t\treturn -EINVAL;\n\n\tif (!user_range->flags)\n\t\treturn -EINVAL;\n\n\tbitmap_size = BITS_TO_LONGS(user_range->nmsrs) * sizeof(long);\n\tif (!bitmap_size || bitmap_size > KVM_MSR_FILTER_MAX_BITMAP_SIZE)\n\t\treturn -EINVAL;\n\n\tbitmap = memdup_user((__user u8*)user_range->bitmap, bitmap_size);\n\tif (IS_ERR(bitmap))\n\t\treturn PTR_ERR(bitmap);\n\n\tmsr_filter->ranges[msr_filter->count] = (struct msr_bitmap_range) {\n\t\t.flags = user_range->flags,\n\t\t.base = user_range->base,\n\t\t.nmsrs = user_range->nmsrs,\n\t\t.bitmap = bitmap,\n\t};\n\n\tmsr_filter->count++;\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_msr_filter(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_msr_filter __user *user_msr_filter = argp;\n\tstruct kvm_x86_msr_filter *new_filter, *old_filter;\n\tstruct kvm_msr_filter filter;\n\tbool default_allow;\n\tbool empty = true;\n\tint r = 0;\n\tu32 i;\n\n\tif (copy_from_user(&filter, user_msr_filter, sizeof(filter)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(filter.ranges); i++)\n\t\tempty &= !filter.ranges[i].nmsrs;\n\n\tdefault_allow = !(filter.flags & KVM_MSR_FILTER_DEFAULT_DENY);\n\tif (empty && !default_allow)\n\t\treturn -EINVAL;\n\n\tnew_filter = kvm_alloc_msr_filter(default_allow);\n\tif (!new_filter)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(filter.ranges); i++) {\n\t\tr = kvm_add_msr_filter(new_filter, &filter.ranges[i]);\n\t\tif (r) {\n\t\t\tkvm_free_msr_filter(new_filter);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tmutex_lock(&kvm->lock);\n\n\t/* The per-VM filter is protected by kvm->lock... */\n\told_filter = srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1);\n\n\trcu_assign_pointer(kvm->arch.msr_filter, new_filter);\n\tsynchronize_srcu(&kvm->srcu);\n\n\tkvm_free_msr_filter(old_filter);\n\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MSR_FILTER_CHANGED);\n\tmutex_unlock(&kvm->lock);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER\nstatic int kvm_arch_suspend_notifier(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\tint ret = 0;\n\n\tmutex_lock(&kvm->lock);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!vcpu->arch.pv_time.active)\n\t\t\tcontinue;\n\n\t\tret = kvm_set_guest_paused(vcpu);\n\t\tif (ret) {\n\t\t\tkvm_err(\"Failed to pause guest VCPU%d: %d\\n\",\n\t\t\t\tvcpu->vcpu_id, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&kvm->lock);\n\n\treturn ret ? NOTIFY_BAD : NOTIFY_DONE;\n}\n\nint kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state)\n{\n\tswitch (state) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\treturn kvm_arch_suspend_notifier(kvm);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */\n\nstatic int kvm_vm_ioctl_get_clock(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_clock_data data = { 0 };\n\n\tget_kvmclock(kvm, &data);\n\tif (copy_to_user(argp, &data, sizeof(data)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_clock(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct kvm_clock_data data;\n\tu64 now_raw_ns;\n\n\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Only KVM_CLOCK_REALTIME is used, but allow passing the\n\t * result of KVM_GET_CLOCK back to KVM_SET_CLOCK.\n\t */\n\tif (data.flags & ~KVM_CLOCK_VALID_FLAGS)\n\t\treturn -EINVAL;\n\n\tkvm_hv_request_tsc_page_update(kvm);\n\tkvm_start_pvclock_update(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\t/*\n\t * This pairs with kvm_guest_time_update(): when masterclock is\n\t * in use, we use master_kernel_ns + kvmclock_offset to set\n\t * unsigned 'system_time' so if we use get_kvmclock_ns() (which\n\t * is slightly ahead) here we risk going negative on unsigned\n\t * 'system_time' when 'data.clock' is very small.\n\t */\n\tif (data.flags & KVM_CLOCK_REALTIME) {\n\t\tu64 now_real_ns = ktime_get_real_ns();\n\n\t\t/*\n\t\t * Avoid stepping the kvmclock backwards.\n\t\t */\n\t\tif (now_real_ns > data.realtime)\n\t\t\tdata.clock += now_real_ns - data.realtime;\n\t}\n\n\tif (ka->use_master_clock)\n\t\tnow_raw_ns = ka->master_kernel_ns;\n\telse\n\t\tnow_raw_ns = get_kvmclock_base_ns();\n\tka->kvmclock_offset = data.clock - now_raw_ns;\n\tkvm_end_pvclock_update(kvm);\n\treturn 0;\n}\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (kvm->created_vcpus)\n\t\t\tgoto set_identity_unlock;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof(ident_addr)))\n\t\t\tgoto set_identity_unlock;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\nset_identity_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto create_irqchip_unlock;\n\n\t\tr = -EINVAL;\n\t\tif (kvm->created_vcpus)\n\t\t\tgoto create_irqchip_unlock;\n\n\t\tr = kvm_pic_init(kvm);\n\t\tif (r)\n\t\t\tgoto create_irqchip_unlock;\n\n\t\tr = kvm_ioapic_init(kvm);\n\t\tif (r) {\n\t\t\tkvm_pic_destroy(kvm);\n\t\t\tgoto create_irqchip_unlock;\n\t\t}\n\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_pic_destroy(kvm);\n\t\t\tgoto create_irqchip_unlock;\n\t\t}\n\t\t/* Write kvm->irq_routing before enabling irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;\n\t\tkvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof(*chip)))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(u.ps)))\n\t\t\tgoto out;\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto set_pit_out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\nset_pit_out:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto set_pit2_out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\nset_pit2_out:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_SET_BOOT_CPU_ID:\n\t\tr = 0;\n\t\tmutex_lock(&kvm->lock);\n\t\tif (kvm->created_vcpus)\n\t\t\tr = -EBUSY;\n\t\telse\n\t\t\tkvm->arch.bsp_vcpu_id = arg;\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n#ifdef CONFIG_KVM_XEN\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tstruct kvm_xen_hvm_config xhc;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xhc, argp, sizeof(xhc)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_config(kvm, &xhc);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_GET_ATTR: {\n\t\tstruct kvm_xen_hvm_attr xha;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xha, argp, sizeof(xha)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_get_attr(kvm, &xha);\n\t\tif (!r && copy_to_user(argp, &xha, sizeof(xha)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_SET_ATTR: {\n\t\tstruct kvm_xen_hvm_attr xha;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xha, argp, sizeof(xha)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_set_attr(kvm, &xha);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_EVTCHN_SEND: {\n\t\tstruct kvm_irq_routing_xen_evtchn uxe;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&uxe, argp, sizeof(uxe)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_evtchn_send(kvm, &uxe);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_SET_CLOCK:\n\t\tr = kvm_vm_ioctl_set_clock(kvm, argp);\n\t\tbreak;\n\tcase KVM_GET_CLOCK:\n\t\tr = kvm_vm_ioctl_get_clock(kvm, argp);\n\t\tbreak;\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (kvm_has_tsc_control &&\n\t\t    user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tWRITE_ONCE(kvm->arch.default_tsc_khz, user_tsc_khz);\n\t\tr = 0;\n\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = READ_ONCE(kvm->arch.default_tsc_khz);\n\t\tgoto out;\n\t}\n\tcase KVM_MEMORY_ENCRYPT_OP: {\n\t\tr = -ENOTTY;\n\t\tif (!kvm_x86_ops.mem_enc_ioctl)\n\t\t\tgoto out;\n\n\t\tr = static_call(kvm_x86_mem_enc_ioctl)(kvm, argp);\n\t\tbreak;\n\t}\n\tcase KVM_MEMORY_ENCRYPT_REG_REGION: {\n\t\tstruct kvm_enc_region region;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&region, argp, sizeof(region)))\n\t\t\tgoto out;\n\n\t\tr = -ENOTTY;\n\t\tif (!kvm_x86_ops.mem_enc_register_region)\n\t\t\tgoto out;\n\n\t\tr = static_call(kvm_x86_mem_enc_register_region)(kvm, &region);\n\t\tbreak;\n\t}\n\tcase KVM_MEMORY_ENCRYPT_UNREG_REGION: {\n\t\tstruct kvm_enc_region region;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&region, argp, sizeof(region)))\n\t\t\tgoto out;\n\n\t\tr = -ENOTTY;\n\t\tif (!kvm_x86_ops.mem_enc_unregister_region)\n\t\t\tgoto out;\n\n\t\tr = static_call(kvm_x86_mem_enc_unregister_region)(kvm, &region);\n\t\tbreak;\n\t}\n\tcase KVM_HYPERV_EVENTFD: {\n\t\tstruct kvm_hyperv_eventfd hvevfd;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&hvevfd, argp, sizeof(hvevfd)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_hv_eventfd(kvm, &hvevfd);\n\t\tbreak;\n\t}\n\tcase KVM_SET_PMU_EVENT_FILTER:\n\t\tr = kvm_vm_ioctl_set_pmu_event_filter(kvm, argp);\n\t\tbreak;\n\tcase KVM_X86_SET_MSR_FILTER:\n\t\tr = kvm_vm_ioctl_set_msr_filter(kvm, argp);\n\t\tbreak;\n\tdefault:\n\t\tr = -ENOTTY;\n\t}\nout:\n\treturn r;\n}\n\nstatic void kvm_init_msr_list(void)\n{\n\tstruct x86_pmu_capability x86_pmu;\n\tu32 dummy[2];\n\tunsigned i;\n\n\tBUILD_BUG_ON_MSG(KVM_PMC_MAX_FIXED != 3,\n\t\t\t \"Please update the fixed PMCs in msrs_to_saved_all[]\");\n\n\tperf_get_x86_pmu_capability(&x86_pmu);\n\n\tnum_msrs_to_save = 0;\n\tnum_emulated_msrs = 0;\n\tnum_msr_based_features = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(msrs_to_save_all); i++) {\n\t\tif (rdmsr_safe(msrs_to_save_all[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.\n\t\t */\n\t\tswitch (msrs_to_save_all[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_TSC_AUX:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_RDTSCP) &&\n\t\t\t    !kvm_cpu_cap_has(X86_FEATURE_RDPID))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_WAITPKG))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_CTL:\n\t\tcase MSR_IA32_RTIT_STATUS:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||\n\t\t\t    !intel_pt_validate_hw_cap(PT_CAP_cr3_filtering))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||\n\t\t\t\t(!intel_pt_validate_hw_cap(PT_CAP_topa_output) &&\n\t\t\t\t !intel_pt_validate_hw_cap(PT_CAP_single_range_output)))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||\n\t\t\t\tmsrs_to_save_all[i] - MSR_IA32_RTIT_ADDR0_A >=\n\t\t\t\tintel_pt_validate_hw_cap(PT_CAP_num_address_ranges) * 2)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_ARCH_PERFMON_PERFCTR0 ... MSR_ARCH_PERFMON_PERFCTR0 + 17:\n\t\t\tif (msrs_to_save_all[i] - MSR_ARCH_PERFMON_PERFCTR0 >=\n\t\t\t    min(INTEL_PMC_MAX_GENERIC, x86_pmu.num_counters_gp))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_ARCH_PERFMON_EVENTSEL0 ... MSR_ARCH_PERFMON_EVENTSEL0 + 17:\n\t\t\tif (msrs_to_save_all[i] - MSR_ARCH_PERFMON_EVENTSEL0 >=\n\t\t\t    min(INTEL_PMC_MAX_GENERIC, x86_pmu.num_counters_gp))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_XFD:\n\t\tcase MSR_IA32_XFD_ERR:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_XFD))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmsrs_to_save[num_msrs_to_save++] = msrs_to_save_all[i];\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(emulated_msrs_all); i++) {\n\t\tif (!static_call(kvm_x86_has_emulated_msr)(NULL, emulated_msrs_all[i]))\n\t\t\tcontinue;\n\n\t\temulated_msrs[num_emulated_msrs++] = emulated_msrs_all[i];\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(msr_based_features_all); i++) {\n\t\tstruct kvm_msr_entry msr;\n\n\t\tmsr.index = msr_based_features_all[i];\n\t\tif (kvm_get_msr_feature(&msr))\n\t\t\tcontinue;\n\n\t\tmsr_based_features[num_msr_based_features++] = msr_based_features_all[i];\n\t}\n}\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tstatic_call(kvm_x86_set_segment)(vcpu, var, seg);\n}\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tstatic_call(kvm_x86_get_segment)(vcpu, var, seg);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u64 access,\n\t\t\t   struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tgpa_t t_gpa;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = mmu->gva_to_gpa(vcpu, mmu, gpa, access, exception);\n\n\treturn t_gpa;\n}\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n}\nEXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_read);\n\n gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n}\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n}\nEXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_write);\n\n/* uses this to access any guest's mapped memory without checking CPL */\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, 0, exception);\n}\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u64 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}\n\n/* used for instruction fetching */\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\tunsigned offset;\n\tint ret;\n\n\t/* Inline kvm_read_guest_virt_helper for speed.  */\n\tgpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access|PFERR_FETCH_MASK,\n\t\t\t\t    exception);\n\tif (unlikely(gpa == UNMAPPED_GVA))\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\toffset = addr & (PAGE_SIZE-1);\n\tif (WARN_ON(offset + bytes > PAGE_SIZE))\n\t\tbytes = (unsigned)PAGE_SIZE - offset;\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,\n\t\t\t\t       offset, bytes);\n\tif (unlikely(ret < 0))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nint kvm_read_guest_virt(struct kvm_vcpu *vcpu,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\t/*\n\t * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED\n\t * is returned, but our callers are not ready for that and they blindly\n\t * call kvm_inject_page_fault.  Ensure that they at least do not leak\n\t * uninitialized kernel stack memory into cr2 and error code.\n\t */\n\tmemset(exception, 0, sizeof(*exception));\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n\nstatic int emulator_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t     gva_t addr, void *val, unsigned int bytes,\n\t\t\t     struct x86_exception *exception, bool system)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu64 access = 0;\n\n\tif (system)\n\t\taccess |= PFERR_IMPLICIT_ACCESS;\n\telse if (static_call(kvm_x86_get_cpl)(vcpu) == 3)\n\t\taccess |= PFERR_USER_MASK;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);\n}\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}\n\nstatic int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u64 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\n\nstatic int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,\n\t\t\t      unsigned int bytes, struct x86_exception *exception,\n\t\t\t      bool system)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu64 access = PFERR_WRITE_MASK;\n\n\tif (system)\n\t\taccess |= PFERR_IMPLICIT_ACCESS;\n\telse if (static_call(kvm_x86_get_cpl)(vcpu) == 3)\n\t\taccess |= PFERR_USER_MASK;\n\n\treturn kvm_write_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t   access, exception);\n}\n\nint kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,\n\t\t\t\tunsigned int bytes, struct x86_exception *exception)\n{\n\t/* kvm_write_guest_virt_system can pull in tons of pages. */\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\treturn kvm_write_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t   PFERR_WRITE_MASK, exception);\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);\n\nstatic int kvm_can_emulate_insn(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\tvoid *insn, int insn_len)\n{\n\treturn static_call(kvm_x86_can_emulate_instruction)(vcpu, emul_type,\n\t\t\t\t\t\t\t    insn, insn_len);\n}\n\nint handle_ud(struct kvm_vcpu *vcpu)\n{\n\tstatic const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };\n\tint emul_type = EMULTYPE_TRAP_UD;\n\tchar sig[5]; /* ud2; .ascii \"kvm\" */\n\tstruct x86_exception e;\n\n\tif (unlikely(!kvm_can_emulate_insn(vcpu, emul_type, NULL, 0)))\n\t\treturn 1;\n\n\tif (force_emulation_prefix &&\n\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n\t    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {\n\t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n\t\temul_type = EMULTYPE_TRAP_UD_FORCED;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, emul_type);\n}\nEXPORT_SYMBOL_GPL(handle_ud);\n\nstatic int vcpu_is_mmio_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t    gpa_t gpa, bool write)\n{\n\t/* For APIC access vmexit */\n\tif ((gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tu64 access = ((static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\t/*\n\t * currently PKRU is only applied to ept enabled guest so\n\t * there is no pkey in EPT page table for L1 guest or EPT\n\t * shadow page table for L2 guest.\n\t */\n\tif (vcpu_match_mmio_gva(vcpu, gva) && (!is_paging(vcpu) ||\n\t    !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t      vcpu->arch.mmio_access, 0, access))) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\treturn vcpu_is_mmio_gpa(vcpu, gva, *gpa, write);\n}\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_page_track_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n\nstruct read_write_emulator_ops {\n\tint (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,\n\t\t\t\t  int bytes);\n\tint (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t  void *val, int bytes);\n\tint (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       int bytes, void *val);\n\tint (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t    void *val, int bytes);\n\tbool write;\n};\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);\n}\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);\n\treturn X86EMUL_IO_NEEDED;\n}\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic const struct read_write_emulator_ops read_emultor = {\n\t.read_write_prepare = read_prepare,\n\t.read_write_emulate = read_emulate,\n\t.read_write_mmio = vcpu_mmio_read,\n\t.read_write_exit_mmio = read_exit_mmio,\n};\n\nstatic const struct read_write_emulator_ops write_emultor = {\n\t.read_write_emulate = write_emulate,\n\t.read_write_mmio = write_mmio,\n\t.read_write_exit_mmio = write_exit_mmio,\n\t.write = true,\n};\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\t/*\n\t * If the exit was due to a NPF we may already have a GPA.\n\t * If the GPA is present, use it to avoid the GVA to GPA table walk.\n\t * Note, this cannot be used on string operations since string\n\t * operation using rep will only have the initial GPA from the NPF\n\t * occurred.\n\t */\n\tif (ctxt->gpa_available && emulator_can_use_gpa(ctxt) &&\n\t    (addr & ~PAGE_MASK) == (ctxt->gpa_val & ~PAGE_MASK)) {\n\t\tgpa = ctxt->gpa_val;\n\t\tret = vcpu_is_mmio_gpa(vcpu, addr, gpa, write);\n\t} else {\n\t\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\t\tif (ret < 0)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t}\n\n\tif (!ret && ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}\n\nstatic int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}\n\n#define emulator_try_cmpxchg_user(t, ptr, old, new) \\\n\t(__try_cmpxchg_user((t __user *)(ptr), (t *)(old), *(t *)(new), efault ## t))\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu64 page_line_mask;\n\tunsigned long hva;\n\tgpa_t gpa;\n\tint r;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\t/*\n\t * Emulate the atomic as a straight write to avoid #AC if SLD is\n\t * enabled in the host and the access splits a cache line.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))\n\t\tpage_line_mask = ~(cache_line_size() - 1);\n\telse\n\t\tpage_line_mask = PAGE_MASK;\n\n\tif (((gpa + bytes - 1) & page_line_mask) != (gpa & page_line_mask))\n\t\tgoto emul_write;\n\n\thva = kvm_vcpu_gfn_to_hva(vcpu, gpa_to_gfn(gpa));\n\tif (kvm_is_error_hva(hva))\n\t\tgoto emul_write;\n\n\thva += offset_in_page(gpa);\n\n\tswitch (bytes) {\n\tcase 1:\n\t\tr = emulator_try_cmpxchg_user(u8, hva, old, new);\n\t\tbreak;\n\tcase 2:\n\t\tr = emulator_try_cmpxchg_user(u16, hva, old, new);\n\t\tbreak;\n\tcase 4:\n\t\tr = emulator_try_cmpxchg_user(u32, hva, old, new);\n\t\tbreak;\n\tcase 8:\n\t\tr = emulator_try_cmpxchg_user(u64, hva, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (r < 0)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tif (r)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tkvm_page_track_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\tint r = 0, i;\n\n\tfor (i = 0; i < vcpu->arch.pio.count; i++) {\n\t\tif (vcpu->arch.pio.in)\n\t\t\tr = kvm_io_bus_read(vcpu, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t\t    vcpu->arch.pio.size, pd);\n\t\telse\n\t\t\tr = kvm_io_bus_write(vcpu, KVM_PIO_BUS,\n\t\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t\t     pd);\n\t\tif (r)\n\t\t\tbreak;\n\t\tpd += vcpu->arch.pio.size;\n\t}\n\treturn r;\n}\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data))\n\t\treturn 1;\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}\n\nstatic int __emulator_pio_in(struct kvm_vcpu *vcpu, int size,\n\t\t\t     unsigned short port, unsigned int count)\n{\n\tWARN_ON(vcpu->arch.pio.count);\n\tmemset(vcpu->arch.pio_data, 0, size * count);\n\treturn emulator_pio_in_out(vcpu, size, port, count, true);\n}\n\nstatic void complete_emulator_pio_in(struct kvm_vcpu *vcpu, void *val)\n{\n\tint size = vcpu->arch.pio.size;\n\tunsigned count = vcpu->arch.pio.count;\n\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\ttrace_kvm_pio(KVM_PIO_IN, vcpu->arch.pio.port, size, count, vcpu->arch.pio_data);\n\tvcpu->arch.pio.count = 0;\n}\n\nstatic int emulator_pio_in(struct kvm_vcpu *vcpu, int size,\n\t\t\t   unsigned short port, void *val, unsigned int count)\n{\n\tif (vcpu->arch.pio.count) {\n\t\t/*\n\t\t * Complete a previous iteration that required userspace I/O.\n\t\t * Note, @count isn't guaranteed to match pio.count as userspace\n\t\t * can modify ECX before rerunning the vCPU.  Ignore any such\n\t\t * shenanigans as KVM doesn't support modifying the rep count,\n\t\t * and the emulator ensures @count doesn't overflow the buffer.\n\t\t */\n\t} else {\n\t\tint r = __emulator_pio_in(vcpu, size, port, count);\n\t\tif (!r)\n\t\t\treturn r;\n\n\t\t/* Results already available, fall through.  */\n\t}\n\n\tcomplete_emulator_pio_in(vcpu, val);\n\treturn 1;\n}\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\treturn emulator_pio_in(emul_to_vcpu(ctxt), size, port, val, count);\n\n}\n\nstatic int emulator_pio_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t    unsigned short port, const void *val,\n\t\t\t    unsigned int count)\n{\n\tint ret;\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\tret = emulator_pio_in_out(vcpu, size, port, count, false);\n\tif (ret)\n                vcpu->arch.pio.count = 0;\n\n        return ret;\n}\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\treturn emulator_pio_out(emul_to_vcpu(ctxt), size, port, val, count);\n}\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn static_call(kvm_x86_get_segment_base)(vcpu, seg);\n}\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}\n\nstatic int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (static_call(kvm_x86_has_wbinvd_exit)()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\ton_each_cpu_mask(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_wbinvd_noskip(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);\n\n\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t    unsigned long *dest)\n{\n\tkvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}\n\nstatic int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t   unsigned long value)\n{\n\n\treturn kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn static_call(kvm_x86_get_cpl)(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_get_gdt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_get_idt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_set_gdt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_set_idt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\tif (base3)\n\t\t\t*base3 = 0;\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n\nstatic int emulator_get_msr_with_filter(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\tu32 msr_index, u64 *pdata)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r;\n\n\tr = kvm_get_msr_with_filter(vcpu, msr_index, pdata);\n\n\tif (r && kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_RDMSR, 0,\n\t\t\t\t    complete_emulated_rdmsr, r)) {\n\t\t/* Bounce to user space */\n\t\treturn X86EMUL_IO_NEEDED;\n\t}\n\n\treturn r;\n}\n\nstatic int emulator_set_msr_with_filter(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\tu32 msr_index, u64 data)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r;\n\n\tr = kvm_set_msr_with_filter(vcpu, msr_index, data);\n\n\tif (r && kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_WRMSR, data,\n\t\t\t\t    complete_emulated_msr_access, r)) {\n\t\t/* Bounce to user space */\n\t\treturn X86EMUL_IO_NEEDED;\n\t}\n\n\treturn r;\n}\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), msr_index, data);\n}\n\nstatic u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\treturn vcpu->arch.smbase;\n}\n\nstatic void emulator_set_smbase(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tvcpu->arch.smbase = smbase;\n}\n\nstatic int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 pmc)\n{\n\tif (kvm_pmu_is_valid_rdpmc_ecx(emul_to_vcpu(ctxt), pmc))\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);\n}\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn static_call(kvm_x86_check_intercept)(emul_to_vcpu(ctxt), info, stage,\n\t\t\t\t\t    &ctxt->exception);\n}\n\nstatic bool emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 *eax, u32 *ebx, u32 *ecx, u32 *edx,\n\t\t\t      bool exact_only)\n{\n\treturn kvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx, exact_only);\n}\n\nstatic bool emulator_guest_has_long_mode(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_LM);\n}\n\nstatic bool emulator_guest_has_movbe(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_MOVBE);\n}\n\nstatic bool emulator_guest_has_fxsr(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_FXSR);\n}\n\nstatic bool emulator_guest_has_rdpid(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_RDPID);\n}\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read_raw(emul_to_vcpu(ctxt), reg);\n}\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write_raw(emul_to_vcpu(ctxt), reg, val);\n}\n\nstatic void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)\n{\n\tstatic_call(kvm_x86_set_nmi_mask)(emul_to_vcpu(ctxt), masked);\n}\n\nstatic unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emul_to_vcpu(ctxt)->arch.hflags;\n}\n\nstatic void emulator_exiting_smm(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tkvm_smm_changed(vcpu, false);\n}\n\nstatic int emulator_leave_smm(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  const char *smstate)\n{\n\treturn static_call(kvm_x86_leave_smm)(emul_to_vcpu(ctxt), smstate);\n}\n\nstatic void emulator_triple_fault(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, emul_to_vcpu(ctxt));\n}\n\nstatic int emulator_set_xcr(struct x86_emulate_ctxt *ctxt, u32 index, u64 xcr)\n{\n\treturn __kvm_set_xcr(emul_to_vcpu(ctxt), index, xcr);\n}\n\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = emulator_read_std,\n\t.write_std           = emulator_write_std,\n\t.read_phys           = kvm_read_guest_phys_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.get_smbase          = emulator_get_smbase,\n\t.set_smbase          = emulator_set_smbase,\n\t.set_msr_with_filter = emulator_set_msr_with_filter,\n\t.get_msr_with_filter = emulator_get_msr_with_filter,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.check_pmc\t     = emulator_check_pmc,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n\t.guest_has_long_mode = emulator_guest_has_long_mode,\n\t.guest_has_movbe     = emulator_guest_has_movbe,\n\t.guest_has_fxsr      = emulator_guest_has_fxsr,\n\t.guest_has_rdpid     = emulator_guest_has_rdpid,\n\t.set_nmi_mask        = emulator_set_nmi_mask,\n\t.get_hflags          = emulator_get_hflags,\n\t.exiting_smm         = emulator_exiting_smm,\n\t.leave_smm           = emulator_leave_smm,\n\t.triple_fault        = emulator_triple_fault,\n\t.set_xcr             = emulator_set_xcr,\n};\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tstatic_call(kvm_x86_set_interrupt_shadow)(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}\n\nstatic bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_inject_emulated_page_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}\n\nstatic struct x86_emulate_ctxt *alloc_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt;\n\n\tctxt = kmem_cache_zalloc(x86_emulator_cache, GFP_KERNEL_ACCOUNT);\n\tif (!ctxt) {\n\t\tpr_err(\"kvm: failed to allocate vcpu's emulator\\n\");\n\t\treturn NULL;\n\t}\n\n\tctxt->vcpu = vcpu;\n\tctxt->ops = &emulate_ops;\n\tvcpu->arch.emulate_ctxt = ctxt;\n\n\treturn ctxt;\n}\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tstatic_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);\n\n\tctxt->gpa_available = false;\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;\n\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\n\tctxt->interruptibility = 0;\n\tctxt->have_exception = false;\n\tctxt->exception.vector = -1;\n\tctxt->perm_ok = false;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}\n\nvoid kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);\n\nstatic void prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,\n\t\t\t\t\t   u8 ndata, u8 *insn_bytes, u8 insn_size)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tu64 info[5];\n\tu8 info_start;\n\n\t/*\n\t * Zero the whole array used to retrieve the exit info, as casting to\n\t * u32 for select entries will leave some chunks uninitialized.\n\t */\n\tmemset(&info, 0, sizeof(info));\n\n\tstatic_call(kvm_x86_get_exit_info)(vcpu, (u32 *)&info[0], &info[1],\n\t\t\t\t\t   &info[2], (u32 *)&info[3],\n\t\t\t\t\t   (u32 *)&info[4]);\n\n\trun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\trun->emulation_failure.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\n\t/*\n\t * There's currently space for 13 entries, but 5 are used for the exit\n\t * reason and info.  Restrict to 4 to reduce the maintenance burden\n\t * when expanding kvm_run.emulation_failure in the future.\n\t */\n\tif (WARN_ON_ONCE(ndata > 4))\n\t\tndata = 4;\n\n\t/* Always include the flags as a 'data' entry. */\n\tinfo_start = 1;\n\trun->emulation_failure.flags = 0;\n\n\tif (insn_size) {\n\t\tBUILD_BUG_ON((sizeof(run->emulation_failure.insn_size) +\n\t\t\t      sizeof(run->emulation_failure.insn_bytes) != 16));\n\t\tinfo_start += 2;\n\t\trun->emulation_failure.flags |=\n\t\t\tKVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES;\n\t\trun->emulation_failure.insn_size = insn_size;\n\t\tmemset(run->emulation_failure.insn_bytes, 0x90,\n\t\t       sizeof(run->emulation_failure.insn_bytes));\n\t\tmemcpy(run->emulation_failure.insn_bytes, insn_bytes, insn_size);\n\t}\n\n\tmemcpy(&run->internal.data[info_start], info, sizeof(info));\n\tmemcpy(&run->internal.data[info_start + ARRAY_SIZE(info)], data,\n\t       ndata * sizeof(data[0]));\n\n\trun->emulation_failure.ndata = info_start + ARRAY_SIZE(info) + ndata;\n}\n\nstatic void prepare_emulation_ctxt_failure_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tprepare_emulation_failure_exit(vcpu, NULL, 0, ctxt->fetch.data,\n\t\t\t\t       ctxt->fetch.end - ctxt->fetch.data);\n}\n\nvoid __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,\n\t\t\t\t\t  u8 ndata)\n{\n\tprepare_emulation_failure_exit(vcpu, data, ndata, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(__kvm_prepare_emulation_failure_exit);\n\nvoid kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu)\n{\n\t__kvm_prepare_emulation_failure_exit(vcpu, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_prepare_emulation_failure_exit);\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\n\tif (emulation_type & EMULTYPE_VMWARE_GP) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\tif (kvm->arch.exit_on_emulation_error ||\n\t    (emulation_type & EMULTYPE_SKIP)) {\n\t\tprepare_emulation_ctxt_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\tif (!is_guest_mode(vcpu) && static_call(kvm_x86_get_cpl)(vcpu) == 0) {\n\t\tprepare_emulation_ctxt_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2_or_gpa;\n\tkvm_pfn_t pfn;\n\n\tif (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))\n\t\treturn false;\n\n\tif (WARN_ON_ONCE(is_guest_mode(vcpu)) ||\n\t    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu->root_role.direct) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu->root_role.direct) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\twrite_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\twrite_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      gpa_t cr2_or_gpa,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2_or_gpa;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))\n\t\treturn false;\n\n\tif (WARN_ON_ONCE(is_guest_mode(vcpu)) ||\n\t    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2_or_gpa)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2_or_gpa;\n\n\tif (!vcpu->arch.mmu->root_role.direct)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm)\n{\n\ttrace_kvm_smm_transition(vcpu->vcpu_id, vcpu->arch.smbase, entering_smm);\n\n\tif (entering_smm) {\n\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t} else {\n\t\tvcpu->arch.hflags &= ~(HF_SMM_MASK | HF_SMM_INSIDE_NMI_MASK);\n\n\t\t/* Process a latched INIT or SMI, if any.  */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t\t/*\n\t\t * Even if KVM_SET_SREGS2 loaded PDPTRs out of band,\n\t\t * on SMM exit we still need to reload them from\n\t\t * guest memory\n\t\t */\n\t\tvcpu->arch.pdptrs_from_userspace = false;\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n\nstatic int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_ACTIVE_LOW;\n\t\tkvm_run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\treturn 0;\n\t}\n\tkvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BS);\n\treturn 1;\n}\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\tint r;\n\n\tr = static_call(kvm_x86_skip_emulated_instruction)(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);\n\nstatic bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool is_vmware_backdoor_opcode(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->opcode_len) {\n\tcase 1:\n\t\tswitch (ctxt->b) {\n\t\tcase 0xe4:\t/* IN */\n\t\tcase 0xe5:\n\t\tcase 0xec:\n\t\tcase 0xed:\n\t\tcase 0xe6:\t/* OUT */\n\t\tcase 0xe7:\n\t\tcase 0xee:\n\t\tcase 0xef:\n\t\tcase 0x6c:\t/* INS */\n\t\tcase 0x6d:\n\t\tcase 0x6e:\t/* OUTS */\n\t\tcase 0x6f:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (ctxt->b) {\n\t\tcase 0x33:\t/* RDPMC */\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n/*\n * Decode an instruction for emulation.  The caller is responsible for handling\n * code breakpoints.  Note, manually detecting code breakpoints is unnecessary\n * (and wrong) when emulating on an intercepted fault-like exception[*], as\n * code breakpoints have higher priority and thus have already been done by\n * hardware.\n *\n * [*] Except #MC, which is higher priority, but KVM should never emulate in\n *     response to a machine check.\n */\nint x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(x86_decode_emulated_instruction);\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    int emulation_type, void *insn, int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt;\n\n\tif (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))\n\t\treturn 1;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\twrite_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tkvm_clear_exception_queue(vcpu);\n\n\t\t/*\n\t\t * Return immediately if RIP hits a code breakpoint, such #DBs\n\t\t * are fault-like and are higher priority than any faults on\n\t\t * the code fetch itself.\n\t\t */\n\t\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t\t    kvm_vcpu_check_code_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tr = x86_decode_emulated_instruction(vcpu, emulation_type,\n\t\t\t\t\t\t    insn, insn_len);\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif ((emulation_type & EMULTYPE_TRAP_UD) ||\n\t\t\t    (emulation_type & EMULTYPE_TRAP_UD_FORCED)) {\n\t\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (reexecute_instruction(vcpu, cr2_or_gpa,\n\t\t\t\t\t\t  write_fault_to_spt,\n\t\t\t\t\t\t  emulation_type))\n\t\t\t\treturn 1;\n\t\t\tif (ctxt->have_exception) {\n\t\t\t\t/*\n\t\t\t\t * #UD should result in just EMULATION_FAILED, and trap-like\n\t\t\t\t * exception should not be encountered during decode.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||\n\t\t\t\t\t     exception_type(ctxt->exception.vector) == EXCPT_TRAP);\n\t\t\t\tinject_emulated_exception(vcpu);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t\t}\n\t}\n\n\tif ((emulation_type & EMULTYPE_VMWARE_GP) &&\n\t    !is_vmware_backdoor_opcode(ctxt)) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for\n\t * use *only* by vendor callbacks for kvm_skip_emulated_instruction().\n\t * The caller is responsible for updating interruptibility state and\n\t * injecting single-step #DBs.\n\t */\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tctxt->eip = (u32)ctxt->_eip;\n\t\telse\n\t\t\tctxt->eip = ctxt->_eip;\n\n\t\tif (emulation_type & EMULTYPE_COMPLETE_USER_EXIT) {\n\t\t\tr = 1;\n\t\t\tgoto writeback;\n\t\t}\n\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn 1;\n\t}\n\n\tif (retry_instruction(ctxt, cr2_or_gpa, emulation_type))\n\t\treturn 1;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tif (emulation_type & EMULTYPE_PF) {\n\t\t/* Save the faulting GPA (cr2) in the address field */\n\t\tctxt->exception.address = cr2_or_gpa;\n\n\t\t/* With shadow page tables, cr2 contains a GVA or nGPA. */\n\t\tif (vcpu->arch.mmu->root_role.direct) {\n\t\t\tctxt->gpa_available = true;\n\t\t\tctxt->gpa_val = cr2_or_gpa;\n\t\t}\n\t} else {\n\t\t/* Sanitize the address out of an abundance of paranoia. */\n\t\tctxt->exception.address = 0;\n\t}\n\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn 1;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn 1;\n\n\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = 1;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = 0;\n\t} else if (vcpu->mmio_needed) {\n\t\t++vcpu->stat.mmio_exits;\n\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = 0;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (vcpu->arch.complete_userspace_io) {\n\t\twriteback = false;\n\t\tr = 0;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = 1;\n\nwriteback:\n\tif (writeback) {\n\t\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {\n\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\t\t\tif (ctxt->is_branch)\n\t\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\t\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\t\tif (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))\n\t\t\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\t\t\tstatic_call_cond(kvm_x86_update_emulated_instruction)(vcpu);\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\t\t}\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_instruction);\n\nint kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\treturn x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_instruction_from_buffer);\n\nstatic int complete_fast_pio_out_port_0x7e(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pio.count = 0;\n\treturn 1;\n}\n\nstatic int complete_fast_pio_out(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pio.count = 0;\n\n\tif (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip)))\n\t\treturn 1;\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t    unsigned short port)\n{\n\tunsigned long val = kvm_rax_read(vcpu);\n\tint ret = emulator_pio_out(vcpu, size, port, &val, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Workaround userspace that relies on old KVM behavior of %rip being\n\t * incremented prior to exiting to userspace to handle \"OUT 0x7e\".\n\t */\n\tif (port == 0x7e &&\n\t    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_OUT_7E_INC_RIP)) {\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\tcomplete_fast_pio_out_port_0x7e;\n\t\tkvm_skip_emulated_instruction(vcpu);\n\t} else {\n\t\tvcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);\n\t\tvcpu->arch.complete_userspace_io = complete_fast_pio_out;\n\t}\n\treturn 0;\n}\n\nstatic int complete_fast_pio_in(struct kvm_vcpu *vcpu)\n{\n\tunsigned long val;\n\n\t/* We should only ever be called with arch.pio.count equal to 1 */\n\tBUG_ON(vcpu->arch.pio.count != 1);\n\n\tif (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip))) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\t/* For size less than 4 we merge, else we zero extend */\n\tval = (vcpu->arch.pio.size < 4) ? kvm_rax_read(vcpu) : 0;\n\n\t/*\n\t * Since vcpu->arch.pio.count == 1 let emulator_pio_in perform\n\t * the copy and tracing\n\t */\n\temulator_pio_in(vcpu, vcpu->arch.pio.size, vcpu->arch.pio.port, &val, 1);\n\tkvm_rax_write(vcpu, val);\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int kvm_fast_pio_in(struct kvm_vcpu *vcpu, int size,\n\t\t\t   unsigned short port)\n{\n\tunsigned long val;\n\tint ret;\n\n\t/* For size less than 4 we merge, else we zero extend */\n\tval = (size < 4) ? kvm_rax_read(vcpu) : 0;\n\n\tret = emulator_pio_in(vcpu, size, port, &val, 1);\n\tif (ret) {\n\t\tkvm_rax_write(vcpu, val);\n\t\treturn ret;\n\t}\n\n\tvcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);\n\tvcpu->arch.complete_userspace_io = complete_fast_pio_in;\n\n\treturn 0;\n}\n\nint kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)\n{\n\tint ret;\n\n\tif (in)\n\t\tret = kvm_fast_pio_in(vcpu, size, port);\n\telse\n\t\tret = kvm_fast_pio_out(vcpu, size, port);\n\treturn ret && kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_fast_pio);\n\nstatic int kvmclock_cpu_down_prep(unsigned int cpu)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n\treturn 0;\n}\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}\n\n#ifdef CONFIG_X86_64\nstatic void kvm_hyperv_tsc_notifier(void)\n{\n\tstruct kvm *kvm;\n\tint cpu;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_make_mclock_inprogress_request(kvm);\n\n\t/* no guest entries from this point */\n\thyperv_stop_tsc_emulation();\n\n\t/* TSC frequency always matches when on Hyper-V */\n\tfor_each_present_cpu(cpu)\n\t\tper_cpu(cpu_tsc_khz, cpu) = tsc_khz;\n\tkvm_max_guest_tsc_khz = tsc_khz;\n\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t__kvm_start_pvclock_update(kvm);\n\t\tpvclock_update_vm_gtod_copy(kvm);\n\t\tkvm_end_pvclock_update(kvm);\n\t}\n\n\tmutex_unlock(&kvm_lock);\n}\n#endif\n\nstatic void __kvmclock_cpufreq_notifier(struct cpufreq_freqs *freq, int cpu)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint send_ipi = 0;\n\tunsigned long i;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tsmp_call_function_single(cpu, tsc_khz_changed, freq, 1);\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != raw_smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tmutex_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, freq, 1);\n\t}\n}\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tint cpu;\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, freq->policy->cpus)\n\t\t__kvmclock_cpufreq_notifier(freq, cpu);\n\n\treturn 0;\n}\n\nstatic struct notifier_block kvmclock_cpufreq_notifier_block = {\n\t.notifier_call  = kvmclock_cpufreq_notifier\n};\n\nstatic int kvmclock_cpu_online(unsigned int cpu)\n{\n\ttsc_khz_changed(NULL);\n\treturn 0;\n}\n\nstatic void kvm_timer_init(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n\t\tmax_tsc_khz = tsc_khz;\n\n\t\tif (IS_ENABLED(CONFIG_CPU_FREQ)) {\n\t\t\tstruct cpufreq_policy *policy;\n\t\t\tint cpu;\n\n\t\t\tcpu = get_cpu();\n\t\t\tpolicy = cpufreq_cpu_get(cpu);\n\t\t\tif (policy) {\n\t\t\t\tif (policy->cpuinfo.max_freq)\n\t\t\t\t\tmax_tsc_khz = policy->cpuinfo.max_freq;\n\t\t\t\tcpufreq_cpu_put(policy);\n\t\t\t}\n\t\t\tput_cpu();\n\t\t}\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\n\tcpuhp_setup_state(CPUHP_AP_X86_KVM_CLK_ONLINE, \"x86/kvm/clk:online\",\n\t\t\t  kvmclock_cpu_online, kvmclock_cpu_down_prep);\n}\n\n#ifdef CONFIG_X86_64\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tmutex_unlock(&kvm_lock);\n}\n\nstatic DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);\n\n/*\n * Indirection to move queue_work() out of the tk_core.seq write held\n * region to prevent possible deadlocks against time accessors which\n * are invoked with work related locks held.\n */\nstatic void pvclock_irq_work_fn(struct irq_work *w)\n{\n\tqueue_work(system_long_wq, &pvclock_gtod_work);\n}\n\nstatic DEFINE_IRQ_WORK(pvclock_irq_work, pvclock_irq_work_fn);\n\n/*\n * Notification about pvclock gtod data update.\n */\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/*\n\t * Disable master clock if host does not trust, or does not use,\n\t * TSC based clocksource. Delegate queue_work() to irq_work as\n\t * this is invoked with tk_core.seq write held.\n\t */\n\tif (!gtod_is_based_on_tsc(gtod->clock.vclock_mode) &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tirq_work_queue(&pvclock_irq_work);\n\treturn 0;\n}\n\nstatic struct notifier_block pvclock_gtod_notifier = {\n\t.notifier_call = pvclock_gtod_notify,\n};\n#endif\n\nint kvm_arch_init(void *opaque)\n{\n\tstruct kvm_x86_init_ops *ops = opaque;\n\tint r;\n\n\tif (kvm_x86_ops.hardware_enable) {\n\t\tpr_err(\"kvm: already loaded vendor module '%s'\\n\", kvm_x86_ops.name);\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tpr_err_ratelimited(\"kvm: no hardware support for '%s'\\n\",\n\t\t\t\t   ops->runtime_ops->name);\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tpr_err_ratelimited(\"kvm: support for '%s' disabled by bios\\n\",\n\t\t\t\t   ops->runtime_ops->name);\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * KVM explicitly assumes that the guest has an FPU and\n\t * FXSAVE/FXRSTOR. For example, the KVM_GET_FPU explicitly casts the\n\t * vCPU's FPU state as a fxregs_state struct.\n\t */\n\tif (!boot_cpu_has(X86_FEATURE_FPU) || !boot_cpu_has(X86_FEATURE_FXSR)) {\n\t\tprintk(KERN_ERR \"kvm: inadequate fpu\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n\t\tpr_err(\"RT requires X86_FEATURE_CONSTANT_TSC\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\n\tx86_emulator_cache = kvm_alloc_emulator_cache();\n\tif (!x86_emulator_cache) {\n\t\tpr_err(\"kvm: failed to allocate cache for x86 emulator\\n\");\n\t\tgoto out;\n\t}\n\n\tuser_return_msrs = alloc_percpu(struct kvm_user_return_msrs);\n\tif (!user_return_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_user_return_msrs\\n\");\n\t\tgoto out_free_x86_emulator_cache;\n\t}\n\tkvm_nr_uret_msrs = 0;\n\n\tr = kvm_mmu_vendor_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_timer_init();\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVE)) {\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\t\tsupported_xcr0 = host_xcr0 & KVM_SUPPORTED_XCR0;\n\t}\n\n\tif (pi_inject_timer == -1)\n\t\tpi_inject_timer = housekeeping_enabled(HK_TYPE_TIMER);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n\n\tif (hypervisor_is_type(X86_HYPER_MS_HYPERV))\n\t\tset_hv_tscchange_cb(kvm_hyperv_tsc_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(user_return_msrs);\nout_free_x86_emulator_cache:\n\tkmem_cache_destroy(x86_emulator_cache);\nout:\n\treturn r;\n}\n\nvoid kvm_arch_exit(void)\n{\n#ifdef CONFIG_X86_64\n\tif (hypervisor_is_type(X86_HYPER_MS_HYPERV))\n\t\tclear_hv_tscchange_cb();\n#endif\n\tkvm_lapic_exit();\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_X86_KVM_CLK_ONLINE);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n\tirq_work_sync(&pvclock_irq_work);\n\tcancel_work_sync(&pvclock_gtod_work);\n#endif\n\tkvm_x86_ops.hardware_enable = NULL;\n\tkvm_mmu_vendor_module_exit();\n\tfree_percpu(user_return_msrs);\n\tkmem_cache_destroy(x86_emulator_cache);\n#ifdef CONFIG_KVM_XEN\n\tstatic_key_deferred_flush(&kvm_xen_enabled);\n\tWARN_ON(static_branch_unlikely(&kvm_xen_enabled.key));\n#endif\n}\n\nstatic int __kvm_emulate_halt(struct kvm_vcpu *vcpu, int state, int reason)\n{\n\t/*\n\t * The vCPU has halted, e.g. executed HLT.  Update the run state if the\n\t * local APIC is in-kernel, the run loop will detect the non-runnable\n\t * state and halt the vCPU.  Exit to userspace if the local APIC is\n\t * managed by userspace, in which case userspace is responsible for\n\t * handling wake events.\n\t */\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = state;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = reason;\n\t\treturn 0;\n\t}\n}\n\nint kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu)\n{\n\treturn __kvm_emulate_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt_noskip);\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\t/*\n\t * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_emulate_halt_noskip(vcpu) && ret;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt);\n\nint kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\n\treturn __kvm_emulate_halt(vcpu, KVM_MP_STATE_AP_RESET_HOLD,\n\t\t\t\t\tKVM_EXIT_AP_RESET_HOLD) && ret;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_ap_reset_hold);\n\n#ifdef CONFIG_X86_64\nstatic int kvm_pv_clock_pairing(struct kvm_vcpu *vcpu, gpa_t paddr,\n\t\t\t        unsigned long clock_type)\n{\n\tstruct kvm_clock_pairing clock_pairing;\n\tstruct timespec64 ts;\n\tu64 cycle;\n\tint ret;\n\n\tif (clock_type != KVM_CLOCK_PAIRING_WALLCLOCK)\n\t\treturn -KVM_EOPNOTSUPP;\n\n\t/*\n\t * When tsc is in permanent catchup mode guests won't be able to use\n\t * pvclock_read_retry loop to get consistent view of pvclock\n\t */\n\tif (vcpu->arch.tsc_always_catchup)\n\t\treturn -KVM_EOPNOTSUPP;\n\n\tif (!kvm_get_walltime_and_clockread(&ts, &cycle))\n\t\treturn -KVM_EOPNOTSUPP;\n\n\tclock_pairing.sec = ts.tv_sec;\n\tclock_pairing.nsec = ts.tv_nsec;\n\tclock_pairing.tsc = kvm_read_l1_tsc(vcpu, cycle);\n\tclock_pairing.flags = 0;\n\tmemset(&clock_pairing.pad, 0, sizeof(clock_pairing.pad));\n\n\tret = 0;\n\tif (kvm_write_guest(vcpu->kvm, paddr, &clock_pairing,\n\t\t\t    sizeof(struct kvm_clock_pairing)))\n\t\tret = -KVM_EFAULT;\n\n\treturn ret;\n}\n#endif\n\n/*\n * kvm_pv_kick_cpu_op:  Kick a vcpu.\n *\n * @apicid - apicid of vcpu to be kicked.\n */\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = APIC_DEST_NOSHORT;\n\tlapic_irq.dest_mode = APIC_DEST_PHYSICAL;\n\tlapic_irq.level = 0;\n\tlapic_irq.dest_id = apicid;\n\tlapic_irq.msi_redir_hint = false;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);\n}\n\nbool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}\nEXPORT_SYMBOL_GPL(kvm_apicv_activated);\n\nbool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)\n{\n\tulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);\n\tulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);\n\n\treturn (vm_reasons | vcpu_reasons) == 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_apicv_activated);\n\nstatic void set_or_clear_apicv_inhibit(unsigned long *inhibits,\n\t\t\t\t       enum kvm_apicv_inhibit reason, bool set)\n{\n\tif (set)\n\t\t__set_bit(reason, inhibits);\n\telse\n\t\t__clear_bit(reason, inhibits);\n\n\ttrace_kvm_apicv_inhibit_changed(reason, set, *inhibits);\n}\n\nstatic void kvm_apicv_init(struct kvm *kvm)\n{\n\tunsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;\n\n\tinit_rwsem(&kvm->arch.apicv_update_lock);\n\n\tset_or_clear_apicv_inhibit(inhibits, APICV_INHIBIT_REASON_ABSENT, true);\n\n\tif (!enable_apicv)\n\t\tset_or_clear_apicv_inhibit(inhibits,\n\t\t\t\t\t   APICV_INHIBIT_REASON_DISABLE, true);\n}\n\nstatic void kvm_sched_yield(struct kvm_vcpu *vcpu, unsigned long dest_id)\n{\n\tstruct kvm_vcpu *target = NULL;\n\tstruct kvm_apic_map *map;\n\n\tvcpu->stat.directed_yield_attempted++;\n\n\tif (single_task_running())\n\t\tgoto no_yield;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(vcpu->kvm->arch.apic_map);\n\n\tif (likely(map) && dest_id <= map->max_apic_id && map->phys_map[dest_id])\n\t\ttarget = map->phys_map[dest_id]->vcpu;\n\n\trcu_read_unlock();\n\n\tif (!target || !READ_ONCE(target->ready))\n\t\tgoto no_yield;\n\n\t/* Ignore requests to yield to self */\n\tif (vcpu == target)\n\t\tgoto no_yield;\n\n\tif (kvm_vcpu_yield_to(target) <= 0)\n\t\tgoto no_yield;\n\n\tvcpu->stat.directed_yield_successful++;\n\nno_yield:\n\treturn;\n}\n\nstatic int complete_hypercall_exit(struct kvm_vcpu *vcpu)\n{\n\tu64 ret = vcpu->run->hypercall.ret;\n\n\tif (!is_64_bit_mode(vcpu))\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit;\n\n\tif (kvm_xen_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_xen_hypercall(vcpu);\n\n\tif (kvm_hv_hypercall_enabled(vcpu))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_rax_read(vcpu);\n\ta0 = kvm_rbx_read(vcpu);\n\ta1 = kvm_rcx_read(vcpu);\n\ta2 = kvm_rdx_read(vcpu);\n\ta3 = kvm_rsi_read(vcpu);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_hypercall(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (static_call(kvm_x86_get_cpl)(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tret = -KVM_ENOSYS;\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_UNHALT))\n\t\t\tbreak;\n\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a1);\n\t\tkvm_sched_yield(vcpu, a1);\n\t\tret = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase KVM_HC_CLOCK_PAIRING:\n\t\tret = kvm_pv_clock_pairing(vcpu, a0, a1);\n\t\tbreak;\n#endif\n\tcase KVM_HC_SEND_IPI:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_SEND_IPI))\n\t\t\tbreak;\n\n\t\tret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);\n\t\tbreak;\n\tcase KVM_HC_SCHED_YIELD:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_SCHED_YIELD))\n\t\t\tbreak;\n\n\t\tkvm_sched_yield(vcpu, a0);\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_MAP_GPA_RANGE: {\n\t\tu64 gpa = a0, npages = a1, attrs = a2;\n\n\t\tret = -KVM_ENOSYS;\n\t\tif (!(vcpu->kvm->arch.hypercall_exit_enabled & (1 << KVM_HC_MAP_GPA_RANGE)))\n\t\t\tbreak;\n\n\t\tif (!PAGE_ALIGNED(gpa) || !npages ||\n\t\t    gpa_to_gfn(gpa) + npages <= gpa_to_gfn(gpa)) {\n\t\t\tret = -KVM_EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvcpu->run->exit_reason        = KVM_EXIT_HYPERCALL;\n\t\tvcpu->run->hypercall.nr       = KVM_HC_MAP_GPA_RANGE;\n\t\tvcpu->run->hypercall.args[0]  = gpa;\n\t\tvcpu->run->hypercall.args[1]  = npages;\n\t\tvcpu->run->hypercall.args[2]  = attrs;\n\t\tvcpu->run->hypercall.longmode = op_64_bit;\n\t\tvcpu->arch.complete_userspace_io = complete_hypercall_exit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_hypercall);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\t/*\n\t * If the quirk is disabled, synthesize a #UD and let the guest pick up\n\t * the pieces.\n\t */\n\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_FIX_HYPERCALL_INSN)) {\n\t\tctxt->exception.error_code_valid = false;\n\t\tctxt->exception.vector = UD_VECTOR;\n\t\tctxt->have_exception = true;\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t}\n\n\tstatic_call(kvm_x86_patch_hypercall)(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3,\n\t\t&ctxt->exception);\n}\n\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}\n\n/* Called within kvm->srcu read side.  */\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = static_call(kvm_x86_get_if_flag)(vcpu);\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\n\tkvm_run->ready_for_interrupt_injection =\n\t\tpic_in_kernel(vcpu->kvm) ||\n\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu);\n\n\tif (is_smm(vcpu))\n\t\tkvm_run->flags |= KVM_RUN_X86_SMM;\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops.update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tstatic_call(kvm_x86_update_cr8_intercept)(vcpu, tpr, max_irr);\n}\n\n\nint kvm_check_nested_events(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\tkvm_x86_ops.nested_ops->triple_fault(vcpu);\n\t\treturn 1;\n\t}\n\n\treturn kvm_x86_ops.nested_ops->check_events(vcpu);\n}\n\nstatic void kvm_inject_exception(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.exception.error_code && !is_protmode(vcpu))\n\t\tvcpu->arch.exception.error_code = false;\n\tstatic_call(kvm_x86_queue_exception)(vcpu);\n}\n\nstatic int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)\n{\n\tint r;\n\tbool can_inject = true;\n\n\t/* try to reinject previous events if any */\n\n\tif (vcpu->arch.exception.injected) {\n\t\tkvm_inject_exception(vcpu);\n\t\tcan_inject = false;\n\t}\n\t/*\n\t * Do not inject an NMI or interrupt if there is a pending\n\t * exception.  Exceptions and interrupts are recognized at\n\t * instruction boundaries, i.e. the start of an instruction.\n\t * Trap-like exceptions, e.g. #DB, have higher priority than\n\t * NMIs and interrupts, i.e. traps are recognized before an\n\t * NMI/interrupt that's pending on the same instruction.\n\t * Fault-like exceptions, e.g. #GP and #PF, are the lowest\n\t * priority, but are only generated (pended) during instruction\n\t * execution, i.e. a pending fault-like exception means the\n\t * fault occurred on the *previous* instruction and must be\n\t * serviced prior to recognizing any new events in order to\n\t * fully complete the previous instruction.\n\t */\n\telse if (!vcpu->arch.exception.pending) {\n\t\tif (vcpu->arch.nmi_injected) {\n\t\t\tstatic_call(kvm_x86_inject_nmi)(vcpu);\n\t\t\tcan_inject = false;\n\t\t} else if (vcpu->arch.interrupt.injected) {\n\t\t\tstatic_call(kvm_x86_inject_irq)(vcpu);\n\t\t\tcan_inject = false;\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(vcpu->arch.exception.injected &&\n\t\t     vcpu->arch.exception.pending);\n\n\t/*\n\t * Call check_nested_events() even if we reinjected a previous event\n\t * in order for caller to determine if it should require immediate-exit\n\t * from L2 to L1 due to pending L1 events which require exit\n\t * from L2 to L1.\n\t */\n\tif (is_guest_mode(vcpu)) {\n\t\tr = kvm_check_nested_events(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tvcpu->arch.exception.pending = false;\n\t\tvcpu->arch.exception.injected = true;\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tif (vcpu->arch.exception.nr == DB_VECTOR) {\n\t\t\tkvm_deliver_exception_payload(vcpu);\n\t\t\tif (vcpu->arch.dr7 & DR7_GD) {\n\t\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\t\tkvm_update_dr7(vcpu);\n\t\t\t}\n\t\t}\n\n\t\tkvm_inject_exception(vcpu);\n\t\tcan_inject = false;\n\t}\n\n\t/* Don't inject interrupts if the user asked to avoid doing so */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ)\n\t\treturn 0;\n\n\t/*\n\t * Finally, inject interrupt events.  If an event cannot be injected\n\t * due to architectural conditions (e.g. IF=0) a window-open exit\n\t * will re-request KVM_REQ_EVENT.  Sometimes however an event is pending\n\t * and can architecturally be injected, but we cannot do it right now:\n\t * an interrupt could have arrived just now and we have to inject it\n\t * as a vmexit, or there could already an event in the queue, which is\n\t * indicated by can_inject.  In that case we request an immediate exit\n\t * in order to make progress and get back here for another iteration.\n\t * The kvm_x86_ops hooks communicate this by returning -EBUSY.\n\t */\n\tif (vcpu->arch.smi_pending) {\n\t\tr = can_inject ? static_call(kvm_x86_smi_allowed)(vcpu, true) : -EBUSY;\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (r) {\n\t\t\tvcpu->arch.smi_pending = false;\n\t\t\t++vcpu->arch.smi_count;\n\t\t\tenter_smm(vcpu);\n\t\t\tcan_inject = false;\n\t\t} else\n\t\t\tstatic_call(kvm_x86_enable_smi_window)(vcpu);\n\t}\n\n\tif (vcpu->arch.nmi_pending) {\n\t\tr = can_inject ? static_call(kvm_x86_nmi_allowed)(vcpu, true) : -EBUSY;\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (r) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tstatic_call(kvm_x86_inject_nmi)(vcpu);\n\t\t\tcan_inject = false;\n\t\t\tWARN_ON(static_call(kvm_x86_nmi_allowed)(vcpu, true) < 0);\n\t\t}\n\t\tif (vcpu->arch.nmi_pending)\n\t\t\tstatic_call(kvm_x86_enable_nmi_window)(vcpu);\n\t}\n\n\tif (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\tr = can_inject ? static_call(kvm_x86_interrupt_allowed)(vcpu, true) : -EBUSY;\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (r) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu), false);\n\t\t\tstatic_call(kvm_x86_inject_irq)(vcpu);\n\t\t\tWARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);\n\t\t}\n\t\tif (kvm_cpu_has_injectable_intr(vcpu))\n\t\t\tstatic_call(kvm_x86_enable_irq_window)(vcpu);\n\t}\n\n\tif (is_guest_mode(vcpu) &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending(vcpu))\n\t\t*req_immediate_exit = true;\n\n\tWARN_ON(vcpu->arch.exception.pending);\n\treturn 0;\n\nout:\n\tif (r == -EBUSY) {\n\t\t*req_immediate_exit = true;\n\t\tr = 0;\n\t}\n\treturn r;\n}\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (static_call(kvm_x86_get_nmi_mask)(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nstatic u32 enter_smm_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}\n\nstatic void enter_smm_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\tput_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tput_smstate(u32, buf, offset + 8, seg.base);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u32, buf, offset, enter_smm_get_segment_flags(&seg));\n}\n\n#ifdef CONFIG_X86_64\nstatic void enter_smm_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\tu16 flags;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\toffset = 0x7e00 + n * 16;\n\n\tflags = enter_smm_get_segment_flags(&seg) >> 8;\n\tput_smstate(u16, buf, offset, seg.selector);\n\tput_smstate(u16, buf, offset + 2, flags);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u64, buf, offset + 8, seg.base);\n}\n#endif\n\nstatic void enter_smm_save_state_32(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tput_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));\n\tput_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));\n\tput_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));\n\tput_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read_raw(vcpu, i));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u32, buf, 0x7fcc, (u32)val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u32, buf, 0x7fc8, (u32)val);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u32, buf, 0x7fc4, seg.selector);\n\tput_smstate(u32, buf, 0x7f64, seg.base);\n\tput_smstate(u32, buf, 0x7f60, seg.limit);\n\tput_smstate(u32, buf, 0x7f5c, enter_smm_get_segment_flags(&seg));\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u32, buf, 0x7fc0, seg.selector);\n\tput_smstate(u32, buf, 0x7f80, seg.base);\n\tput_smstate(u32, buf, 0x7f7c, seg.limit);\n\tput_smstate(u32, buf, 0x7f78, enter_smm_get_segment_flags(&seg));\n\n\tstatic_call(kvm_x86_get_gdt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f74, dt.address);\n\tput_smstate(u32, buf, 0x7f70, dt.size);\n\n\tstatic_call(kvm_x86_get_idt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f58, dt.address);\n\tput_smstate(u32, buf, 0x7f54, dt.size);\n\n\tfor (i = 0; i < 6; i++)\n\t\tenter_smm_save_seg_32(vcpu, buf, i);\n\n\tput_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020000);\n\tput_smstate(u32, buf, 0x7ef8, vcpu->arch.smbase);\n}\n\n#ifdef CONFIG_X86_64\nstatic void enter_smm_save_state_64(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tput_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read_raw(vcpu, i));\n\n\tput_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));\n\tput_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u64, buf, 0x7f68, val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u64, buf, 0x7f60, val);\n\n\tput_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));\n\tput_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));\n\tput_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));\n\n\tput_smstate(u32, buf, 0x7f00, vcpu->arch.smbase);\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020064);\n\n\tput_smstate(u64, buf, 0x7ed0, vcpu->arch.efer);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u16, buf, 0x7e90, seg.selector);\n\tput_smstate(u16, buf, 0x7e92, enter_smm_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e94, seg.limit);\n\tput_smstate(u64, buf, 0x7e98, seg.base);\n\n\tstatic_call(kvm_x86_get_idt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e84, dt.size);\n\tput_smstate(u64, buf, 0x7e88, dt.address);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u16, buf, 0x7e70, seg.selector);\n\tput_smstate(u16, buf, 0x7e72, enter_smm_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e74, seg.limit);\n\tput_smstate(u64, buf, 0x7e78, seg.base);\n\n\tstatic_call(kvm_x86_get_gdt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e64, dt.size);\n\tput_smstate(u64, buf, 0x7e68, dt.address);\n\n\tfor (i = 0; i < 6; i++)\n\t\tenter_smm_save_seg_64(vcpu, buf, i);\n}\n#endif\n\nstatic void enter_smm(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ds;\n\tstruct desc_ptr dt;\n\tunsigned long cr0;\n\tchar buf[512];\n\n\tmemset(buf, 0, 512);\n#ifdef CONFIG_X86_64\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\tenter_smm_save_state_64(vcpu, buf);\n\telse\n#endif\n\t\tenter_smm_save_state_32(vcpu, buf);\n\n\t/*\n\t * Give enter_smm() a chance to make ISA-specific changes to the vCPU\n\t * state (e.g. leave guest mode) after we've saved the state into the\n\t * SMM state-save area.\n\t */\n\tstatic_call(kvm_x86_enter_smm)(vcpu, buf);\n\n\tkvm_smm_changed(vcpu, true);\n\tkvm_vcpu_write_guest(vcpu, vcpu->arch.smbase + 0xfe00, buf, sizeof(buf));\n\n\tif (static_call(kvm_x86_get_nmi_mask)(vcpu))\n\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\telse\n\t\tstatic_call(kvm_x86_set_nmi_mask)(vcpu, true);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0x8000);\n\n\tcr0 = vcpu->arch.cr0 & ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);\n\tstatic_call(kvm_x86_set_cr0)(vcpu, cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\tstatic_call(kvm_x86_set_cr4)(vcpu, 0);\n\n\t/* Undocumented: IDT limit is set to zero on entry to SMM.  */\n\tdt.address = dt.size = 0;\n\tstatic_call(kvm_x86_set_idt)(vcpu, &dt);\n\n\tkvm_set_dr(vcpu, 7, DR7_FIXED_1);\n\n\tcs.selector = (vcpu->arch.smbase >> 4) & 0xffff;\n\tcs.base = vcpu->arch.smbase;\n\n\tds.selector = 0;\n\tds.base = 0;\n\n\tcs.limit    = ds.limit = 0xffffffff;\n\tcs.type     = ds.type = 0x3;\n\tcs.dpl      = ds.dpl = 0;\n\tcs.db       = ds.db = 0;\n\tcs.s        = ds.s = 1;\n\tcs.l        = ds.l = 0;\n\tcs.g        = ds.g = 1;\n\tcs.avl      = ds.avl = 0;\n\tcs.present  = ds.present = 1;\n\tcs.unusable = ds.unusable = 0;\n\tcs.padding  = ds.padding = 0;\n\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_SS);\n\n#ifdef CONFIG_X86_64\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\tstatic_call(kvm_x86_set_efer)(vcpu, 0);\n#endif\n\n\tkvm_update_cpuid_runtime(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic void process_smi(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.smi_pending = true;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nvoid kvm_make_scan_ioapic_request_mask(struct kvm *kvm,\n\t\t\t\t       unsigned long *vcpu_bitmap)\n{\n\tkvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC, vcpu_bitmap);\n}\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}\n\nvoid kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tbool activate;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tdown_read(&vcpu->kvm->arch.apicv_update_lock);\n\n\tactivate = kvm_vcpu_apicv_activated(vcpu);\n\n\tif (vcpu->arch.apicv_active == activate)\n\t\tgoto out;\n\n\tvcpu->arch.apicv_active = activate;\n\tkvm_apic_update_apicv(vcpu);\n\tstatic_call(kvm_x86_refresh_apicv_exec_ctrl)(vcpu);\n\n\t/*\n\t * When APICv gets disabled, we may still have injected interrupts\n\t * pending. At the same time, KVM_REQ_EVENT may not be set as APICv was\n\t * still active when the interrupt got accepted. Make sure\n\t * inject_pending_event() is called to check for that.\n\t */\n\tif (!vcpu->arch.apicv_active)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\nout:\n\tup_read(&vcpu->kvm->arch.apicv_update_lock);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);\n\nvoid __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t      enum kvm_apicv_inhibit reason, bool set)\n{\n\tunsigned long old, new;\n\n\tlockdep_assert_held_write(&kvm->arch.apicv_update_lock);\n\n\tif (!static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))\n\t\treturn;\n\n\told = new = kvm->arch.apicv_inhibit_reasons;\n\n\tset_or_clear_apicv_inhibit(&new, reason, set);\n\n\tif (!!old != !!new) {\n\t\t/*\n\t\t * Kick all vCPUs before setting apicv_inhibit_reasons to avoid\n\t\t * false positives in the sanity check WARN in svm_vcpu_run().\n\t\t * This task will wait for all vCPUs to ack the kick IRQ before\n\t\t * updating apicv_inhibit_reasons, and all other vCPUs will\n\t\t * block on acquiring apicv_update_lock so that vCPUs can't\n\t\t * redo svm_vcpu_run() without seeing the new inhibit state.\n\t\t *\n\t\t * Note, holding apicv_update_lock and taking it in the read\n\t\t * side (handling the request) also prevents other vCPUs from\n\t\t * servicing the request with a stale apicv_inhibit_reasons.\n\t\t */\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n\t\tkvm->arch.apicv_inhibit_reasons = new;\n\t\tif (new) {\n\t\t\tunsigned long gfn = gpa_to_gfn(APIC_DEFAULT_PHYS_BASE);\n\t\t\tkvm_zap_gfn_range(kvm, gfn, gfn+1);\n\t\t}\n\t} else {\n\t\tkvm->arch.apicv_inhibit_reasons = new;\n\t}\n}\n\nvoid kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t    enum kvm_apicv_inhibit reason, bool set)\n{\n\tif (!enable_apicv)\n\t\treturn;\n\n\tdown_write(&kvm->arch.apicv_update_lock);\n\t__kvm_set_or_clear_apicv_inhibit(kvm, reason, set);\n\tup_write(&kvm->arch.apicv_update_lock);\n}\nEXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_present(vcpu))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\t\tif (ioapic_in_kernel(vcpu->kvm))\n\t\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}\n\nstatic void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tif (to_hv_vcpu(vcpu)) {\n\t\tbitmap_or((ulong *)eoi_exit_bitmap,\n\t\t\t  vcpu->arch.ioapic_handled_vectors,\n\t\t\t  to_hv_synic(vcpu)->vec_bitmap, 256);\n\t\tstatic_call_cond(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);\n\t\treturn;\n\t}\n\n\tstatic_call_cond(kvm_x86_load_eoi_exitmap)(\n\t\tvcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);\n}\n\nvoid kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,\n\t\t\t\t\t    unsigned long start, unsigned long end)\n{\n\tunsigned long apic_address;\n\n\t/*\n\t * The physical address of apic access page is stored in the VMCS.\n\t * Update it when it becomes invalid.\n\t */\n\tapic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (start <= apic_address && apic_address < end)\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}\n\nvoid kvm_arch_guest_memory_reclaimed(struct kvm *kvm)\n{\n\tstatic_call_cond(kvm_x86_guest_memory_reclaimed)(kvm);\n}\n\nstatic void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tstatic_call_cond(kvm_x86_set_apic_access_page_addr)(vcpu);\n}\n\nvoid __kvm_request_immediate_exit(struct kvm_vcpu *vcpu)\n{\n\tsmp_send_reschedule(vcpu->cpu);\n}\nEXPORT_SYMBOL_GPL(__kvm_request_immediate_exit);\n\n/*\n * Called within kvm->srcu read side.\n * Returns 1 to let vcpu_run() continue the guest execution loop without\n * exiting to the userspace.  Otherwise, the value will be returned to the\n * userspace.\n */\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win =\n\t\tdm_request_for_irq_injection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n\tfastpath_t exit_fastpath;\n\n\tbool req_immediate_exit = false;\n\n\t/* Forbid vmenter if vcpu dirty ring is soft-full */\n\tif (unlikely(vcpu->kvm->dirty_ring_size &&\n\t\t     kvm_dirty_ring_soft_full(&vcpu->dirty_ring))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_DIRTY_RING_FULL;\n\t\ttrace_kvm_dirty_ring_exit(vcpu);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\tif (kvm_request_pending(vcpu)) {\n\t\tif (kvm_check_request(KVM_REQ_VM_DEAD, vcpu)) {\n\t\t\tr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu)) {\n\t\t\tif (unlikely(!kvm_x86_ops.nested_ops->get_nested_state_pages(vcpu))) {\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_FREE_OBSOLETE_ROOTS, vcpu))\n\t\t\tkvm_mmu_free_obsolete_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))\n\t\t\tkvm_mmu_load_pgd(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu)) {\n\t\t\tkvm_vcpu_flush_tlb_all(vcpu);\n\n\t\t\t/* Flushing all ASIDs flushes the current ASID... */\n\t\t\tkvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\t\t}\n\t\tkvm_service_local_tlb_flush_requests(vcpu);\n\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tif (is_guest_mode(vcpu)) {\n\t\t\t\tkvm_x86_ops.nested_ops->triple_fault(vcpu);\n\t\t\t} else {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\t\tvcpu->mmio_needed = 0;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\t\tprocess_smi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_pmu_handle_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_pmu_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {\n\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);\n\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,\n\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;\n\t\t\t\tvcpu->run->eoi.vector =\n\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))\n\t\t\tvcpu_load_eoi_exitmap(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;\n\t\t\tvcpu->run->system_event.ndata = 0;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;\n\t\t\tvcpu->run->system_event.ndata = 0;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {\n\t\t\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\t\tvcpu->run->hyperv = hv_vcpu->exit;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * KVM_REQ_HV_STIMER has to be processed after\n\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers\n\t\t * depend on the guest clock being up-to-date\n\t\t */\n\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))\n\t\t\tkvm_hv_process_stimers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))\n\t\t\tkvm_vcpu_update_apicv(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APF_READY, vcpu))\n\t\t\tkvm_check_async_pf_completion(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MSR_FILTER_CHANGED, vcpu))\n\t\t\tstatic_call(kvm_x86_msr_filter_changed)(vcpu);\n\n\t\tif (kvm_check_request(KVM_REQ_UPDATE_CPU_DIRTY_LOGGING, vcpu))\n\t\t\tstatic_call(kvm_x86_update_cpu_dirty_logging)(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win ||\n\t    kvm_xen_has_interrupt(vcpu)) {\n\t\t++vcpu->stat.req_event;\n\t\tr = kvm_apic_accept_events(vcpu);\n\t\tif (r < 0) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = inject_pending_event(vcpu, &req_immediate_exit);\n\t\tif (r < 0) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (req_int_win)\n\t\t\tstatic_call(kvm_x86_enable_irq_window)(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tstatic_call(kvm_x86_prepare_switch_to_guest)(vcpu);\n\n\t/*\n\t * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt\n\t * IPI are then delayed after guest entry, which ensures that they\n\t * result in virtual interrupt delivery.\n\t */\n\tlocal_irq_disable();\n\n\t/* Store vcpu->apicv_active before vcpu->mode.  */\n\tsmp_store_release(&vcpu->mode, IN_GUEST_MODE);\n\n\tkvm_vcpu_srcu_read_unlock(vcpu);\n\n\t/*\n\t * 1) We should set ->mode before checking ->requests.  Please see\n\t * the comment in kvm_vcpu_exiting_guest_mode().\n\t *\n\t * 2) For APICv, we should set ->mode before checking PID.ON. This\n\t * pairs with the memory barrier implicit in pi_test_and_set_on\n\t * (see vmx_deliver_posted_interrupt).\n\t *\n\t * 3) This also orders the write to mode from any reads to the page\n\t * tables done while the VCPU is running.  Please see the comment\n\t * in kvm_flush_remote_tlbs.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\t/*\n\t * Process pending posted interrupts to handle the case where the\n\t * notification IRQ arrived in the host, or was never sent (because the\n\t * target vCPU wasn't running).  Do this regardless of the vCPU's APICv\n\t * status, KVM doesn't update assigned devices when APICv is inhibited,\n\t * i.e. they can post interrupts even if APICv is temporarily disabled.\n\t */\n\tif (kvm_lapic_enabled(vcpu))\n\t\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\n\tif (kvm_vcpu_exit_request(vcpu)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit) {\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tstatic_call(kvm_x86_request_immediate_exit)(vcpu);\n\t}\n\n\tfpregs_assert_state_consistent();\n\tif (test_thread_flag(TIF_NEED_FPU_LOAD))\n\t\tswitch_fpu_return();\n\n\tif (vcpu->arch.guest_fpu.xfd_err)\n\t\twrmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t} else if (unlikely(hw_breakpoint_active())) {\n\t\tset_debugreg(0, 7);\n\t}\n\n\tguest_timing_enter_irqoff();\n\n\tfor (;;) {\n\t\t/*\n\t\t * Assert that vCPU vs. VM APICv state is consistent.  An APICv\n\t\t * update must kick and wait for all vCPUs before toggling the\n\t\t * per-VM state, and responsing vCPUs must wait for the update\n\t\t * to complete before servicing KVM_REQ_APICV_UPDATE.\n\t\t */\n\t\tWARN_ON_ONCE(kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu));\n\n\t\texit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);\n\t\tif (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))\n\t\t\tbreak;\n\n\t\tif (kvm_lapic_enabled(vcpu))\n\t\t\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\n\t\tif (unlikely(kvm_vcpu_exit_request(vcpu))) {\n\t\t\texit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tstatic_call(kvm_x86_sync_dirty_debug_regs)(vcpu);\n\t\tkvm_update_dr0123(vcpu);\n\t\tkvm_update_dr7(vcpu);\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_vmentry_cpu = vcpu->cpu;\n\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/*\n\t * Sync xfd before calling handle_exit_irqoff() which may\n\t * rely on the fact that guest_fpu::xfd is up-to-date (e.g.\n\t * in #NM irqoff handler).\n\t */\n\tif (vcpu->arch.xfd_no_write_intercept)\n\t\tfpu_sync_guest_vmexit_xfd_state();\n\n\tstatic_call(kvm_x86_handle_exit_irqoff)(vcpu);\n\n\tif (vcpu->arch.guest_fpu.xfd_err)\n\t\twrmsrl(MSR_IA32_XFD_ERR, 0);\n\n\t/*\n\t * Consume any pending interrupts, including the possible source of\n\t * VM-Exit on SVM and any ticks that occur between VM-Exit and now.\n\t * An instruction is required after local_irq_enable() to fully unblock\n\t * interrupts on processors that implement an interrupt shadow, the\n\t * stat.exits increment will do nicely.\n\t */\n\tkvm_before_interrupt(vcpu, KVM_HANDLING_IRQ);\n\tlocal_irq_enable();\n\t++vcpu->stat.exits;\n\tlocal_irq_disable();\n\tkvm_after_interrupt(vcpu);\n\n\t/*\n\t * Wait until after servicing IRQs to account guest time so that any\n\t * ticks that occurred while running the guest are properly accounted\n\t * to the guest.  Waiting until IRQs are enabled degrades the accuracy\n\t * of accounting via context tracking, but the loss of accuracy is\n\t * acceptable for all known use cases.\n\t */\n\tguest_timing_exit_irqoff();\n\n\tlocal_irq_enable();\n\tpreempt_enable();\n\n\tkvm_vcpu_srcu_read_lock(vcpu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);\n\treturn r;\n\ncancel_injection:\n\tif (req_immediate_exit)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tstatic_call(kvm_x86_cancel_injection)(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n\n/* Called within kvm->srcu read side.  */\nstatic inline int vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tbool hv_timer;\n\n\tif (!kvm_arch_vcpu_runnable(vcpu)) {\n\t\t/*\n\t\t * Switch to the software timer before halt-polling/blocking as\n\t\t * the guest's timer may be a break event for the vCPU, and the\n\t\t * hypervisor timer runs only when the CPU is in guest mode.\n\t\t * Switch before halt-polling so that KVM recognizes an expired\n\t\t * timer before blocking.\n\t\t */\n\t\thv_timer = kvm_lapic_hv_timer_in_use(vcpu);\n\t\tif (hv_timer)\n\t\t\tkvm_lapic_switch_to_sw_timer(vcpu);\n\n\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\n\t\t\tkvm_vcpu_halt(vcpu);\n\t\telse\n\t\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\n\t\tif (hv_timer)\n\t\t\tkvm_lapic_switch_to_hv_timer(vcpu);\n\n\t\tif (!kvm_check_request(KVM_REQ_UNHALT, vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_apic_accept_events(vcpu) < 0)\n\t\treturn 0;\n\tswitch(vcpu->arch.mp_state) {\n\tcase KVM_MP_STATE_HALTED:\n\tcase KVM_MP_STATE_AP_RESET_HOLD:\n\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\tvcpu->arch.mp_state =\n\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\tfallthrough;\n\tcase KVM_MP_STATE_RUNNABLE:\n\t\tvcpu->arch.apf.halted = false;\n\t\tbreak;\n\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINTR;\n\t}\n\treturn 1;\n}\n\nstatic inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\tkvm_check_nested_events(vcpu);\n\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}\n\n/* Called within kvm->srcu read side.  */\nstatic int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\tfor (;;) {\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(vcpu);\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tkvm_clear_request(KVM_REQ_UNBLOCK, vcpu);\n\t\tif (kvm_xen_has_pending_events(vcpu))\n\t\t\tkvm_xen_inject_pending_events(vcpu);\n\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__xfer_to_guest_mode_work_pending()) {\n\t\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\t\tr = xfer_to_guest_mode_handle_work(vcpu);\n\t\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn r;\n}\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n}\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}\n\n/*\n * Implements the following, as a state machine:\n *\n * read:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       exit\n *       copy data\n *   execute insn\n *\n * write:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       copy data\n *       exit\n */\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n\n/* Swap (qemu) user FPU context for the guest FPU context. */\nstatic void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\t/* Exclude PKRU, it's restored separately immediately after VM-Exit. */\n\tfpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, true);\n\ttrace_kvm_fpu(1);\n}\n\n/* When vcpu_run ends, restore user space FPU context. */\nstatic void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tfpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, false);\n\t++vcpu->stat.fpu_reload;\n\ttrace_kvm_fpu(0);\n}\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tint r;\n\n\tvcpu_load(vcpu);\n\tkvm_sigset_activate(vcpu);\n\tkvm_run->flags = 0;\n\tkvm_load_guest_fpu(vcpu);\n\n\tkvm_vcpu_srcu_read_lock(vcpu);\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tif (kvm_run->immediate_exit) {\n\t\t\tr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * It should be impossible for the hypervisor timer to be in\n\t\t * use before KVM has ever run the vCPU.\n\t\t */\n\t\tWARN_ON_ONCE(kvm_lapic_hv_timer_in_use(vcpu));\n\n\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\n\t\tif (kvm_apic_accept_events(vcpu) < 0) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkvm_clear_request(KVM_REQ_UNHALT, vcpu);\n\t\tr = -EAGAIN;\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif ((kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) ||\n\t    (kvm_run->kvm_dirty_regs & ~KVM_SYNC_X86_VALID_FIELDS)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kvm_run->kvm_dirty_regs) {\n\t\tr = sync_regs(vcpu);\n\t\tif (r != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!lapic_in_kernel(vcpu)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tif (kvm_run->immediate_exit) {\n\t\tr = -EINTR;\n\t\tgoto out;\n\t}\n\n\tr = static_call(kvm_x86_vcpu_pre_run)(vcpu);\n\tif (r <= 0)\n\t\tgoto out;\n\n\tr = vcpu_run(vcpu);\n\nout:\n\tkvm_put_guest_fpu(vcpu);\n\tif (kvm_run->kvm_valid_regs)\n\t\tstore_regs(vcpu);\n\tpost_kvm_run_save(vcpu);\n\tkvm_vcpu_srcu_read_unlock(vcpu);\n\n\tkvm_sigset_deactivate(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\nstatic void __get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_rax_read(vcpu);\n\tregs->rbx = kvm_rbx_read(vcpu);\n\tregs->rcx = kvm_rcx_read(vcpu);\n\tregs->rdx = kvm_rdx_read(vcpu);\n\tregs->rsi = kvm_rsi_read(vcpu);\n\tregs->rdi = kvm_rdi_read(vcpu);\n\tregs->rsp = kvm_rsp_read(vcpu);\n\tregs->rbp = kvm_rbp_read(vcpu);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_r8_read(vcpu);\n\tregs->r9 = kvm_r9_read(vcpu);\n\tregs->r10 = kvm_r10_read(vcpu);\n\tregs->r11 = kvm_r11_read(vcpu);\n\tregs->r12 = kvm_r12_read(vcpu);\n\tregs->r13 = kvm_r13_read(vcpu);\n\tregs->r14 = kvm_r14_read(vcpu);\n\tregs->r15 = kvm_r15_read(vcpu);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n}\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu_load(vcpu);\n\t__get_regs(vcpu, regs);\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nstatic void __set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_rax_write(vcpu, regs->rax);\n\tkvm_rbx_write(vcpu, regs->rbx);\n\tkvm_rcx_write(vcpu, regs->rcx);\n\tkvm_rdx_write(vcpu, regs->rdx);\n\tkvm_rsi_write(vcpu, regs->rsi);\n\tkvm_rdi_write(vcpu, regs->rdi);\n\tkvm_rsp_write(vcpu, regs->rsp);\n\tkvm_rbp_write(vcpu, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_r8_write(vcpu, regs->r8);\n\tkvm_r9_write(vcpu, regs->r9);\n\tkvm_r10_write(vcpu, regs->r10);\n\tkvm_r11_write(vcpu, regs->r11);\n\tkvm_r12_write(vcpu, regs->r12);\n\tkvm_r13_write(vcpu, regs->r13);\n\tkvm_r14_write(vcpu, regs->r14);\n\tkvm_r15_write(vcpu, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu_load(vcpu);\n\t__set_regs(vcpu, regs);\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nstatic void __get_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tif (vcpu->arch.guest_state_protected)\n\t\tgoto skip_protected_regs;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tstatic_call(kvm_x86_get_idt)(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tstatic_call(kvm_x86_get_gdt)(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\nskip_protected_regs:\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n}\n\nstatic void __get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\t__get_sregs_common(vcpu, sregs);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tif (vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n}\n\nstatic void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)\n{\n\tint i;\n\n\t__get_sregs_common(vcpu, (struct kvm_sregs *)sregs2);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tfor (i = 0 ; i < 4 ; i++)\n\t\t\tsregs2->pdptrs[i] = kvm_pdptr_read(vcpu, i);\n\t\tsregs2->flags |= KVM_SREGS2_FLAGS_PDPTRS_VALID;\n\t}\n}\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tvcpu_load(vcpu);\n\t__get_sregs(vcpu, sregs);\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tint r;\n\n\tvcpu_load(vcpu);\n\tif (kvm_mpx_supported())\n\t\tkvm_load_guest_fpu(vcpu);\n\n\tr = kvm_apic_accept_events(vcpu);\n\tif (r < 0)\n\t\tgoto out;\n\tr = 0;\n\n\tif ((vcpu->arch.mp_state == KVM_MP_STATE_HALTED ||\n\t     vcpu->arch.mp_state == KVM_MP_STATE_AP_RESET_HOLD) &&\n\t    vcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\nout:\n\tif (kvm_mpx_supported())\n\t\tkvm_put_guest_fpu(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tint ret = -EINVAL;\n\n\tvcpu_load(vcpu);\n\n\tif (!lapic_in_kernel(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\tgoto out;\n\n\t/*\n\t * KVM_MP_STATE_INIT_RECEIVED means the processor is in\n\t * INIT state; latched init should be reported using\n\t * KVM_SET_VCPU_EVENTS, so reject it here.\n\t */\n\tif ((kvm_vcpu_latch_init(vcpu) || vcpu->arch.smi_pending) &&\n\t    (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED ||\n\t     mp_state->mp_state == KVM_MP_STATE_INIT_RECEIVED))\n\t\tgoto out;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tret = 0;\nout:\n\tvcpu_put(vcpu);\n\treturn ret;\n}\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\tif (ret) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(kvm_task_switch);\n\nstatic bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tif ((sregs->efer & EFER_LME) && (sregs->cr0 & X86_CR0_PG)) {\n\t\t/*\n\t\t * When EFER.LME and CR0.PG are set, the processor is in\n\t\t * 64-bit mode (though maybe in a 32-bit code segment).\n\t\t * CR4.PAE and EFER.LMA must be set.\n\t\t */\n\t\tif (!(sregs->cr4 & X86_CR4_PAE) || !(sregs->efer & EFER_LMA))\n\t\t\treturn false;\n\t\tif (kvm_vcpu_is_illegal_gpa(vcpu, sregs->cr3))\n\t\t\treturn false;\n\t} else {\n\t\t/*\n\t\t * Not in 64-bit mode: EFER.LMA is clear and the code\n\t\t * segment cannot be 64-bit.\n\t\t */\n\t\tif (sregs->efer & EFER_LMA || sregs->cs.l)\n\t\t\treturn false;\n\t}\n\n\treturn kvm_is_valid_cr4(vcpu, sregs->cr4);\n}\n\nstatic int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,\n\t\tint *mmu_reset_needed, bool update_pdptrs)\n{\n\tstruct msr_data apic_base_msr;\n\tint idx;\n\tstruct desc_ptr dt;\n\n\tif (!kvm_is_valid_sregs(vcpu, sregs))\n\t\treturn -EINVAL;\n\n\tapic_base_msr.data = sregs->apic_base;\n\tapic_base_msr.host_initiated = true;\n\tif (kvm_set_apic_base(vcpu, &apic_base_msr))\n\t\treturn -EINVAL;\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn 0;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tstatic_call(kvm_x86_set_idt)(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tstatic_call(kvm_x86_set_gdt)(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\t*mmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\tstatic_call_cond(kvm_x86_post_set_cr3)(vcpu, sregs->cr3);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\t*mmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tstatic_call(kvm_x86_set_efer)(vcpu, sregs->efer);\n\n\t*mmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tstatic_call(kvm_x86_set_cr0)(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\t*mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tstatic_call(kvm_x86_set_cr4)(vcpu, sregs->cr4);\n\n\tif (update_pdptrs) {\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tif (is_pae_paging(vcpu)) {\n\t\t\tload_pdptrs(vcpu, kvm_read_cr3(vcpu));\n\t\t\t*mmu_reset_needed = 1;\n\t\t}\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\treturn 0;\n}\n\nstatic int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tint pending_vec, max_bits;\n\tint mmu_reset_needed = 0;\n\tint ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\treturn 0;\n}\n\nstatic int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)\n{\n\tint mmu_reset_needed = 0;\n\tbool valid_pdptrs = sregs2->flags & KVM_SREGS2_FLAGS_PDPTRS_VALID;\n\tbool pae = (sregs2->cr0 & X86_CR0_PG) && (sregs2->cr4 & X86_CR4_PAE) &&\n\t\t!(sregs2->efer & EFER_LMA);\n\tint i, ret;\n\n\tif (sregs2->flags & ~KVM_SREGS2_FLAGS_PDPTRS_VALID)\n\t\treturn -EINVAL;\n\n\tif (valid_pdptrs && (!pae || vcpu->arch.guest_state_protected))\n\t\treturn -EINVAL;\n\n\tret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,\n\t\t\t\t &mmu_reset_needed, !valid_pdptrs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (valid_pdptrs) {\n\t\tfor (i = 0; i < 4 ; i++)\n\t\t\tkvm_pdptr_write(vcpu, i, sregs2->pdptrs[i]);\n\n\t\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n\t\tmmu_reset_needed = 1;\n\t\tvcpu->arch.pdptrs_from_userspace = true;\n\t}\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint ret;\n\n\tvcpu_load(vcpu);\n\tret = __set_sregs(vcpu, sregs);\n\tvcpu_put(vcpu);\n\treturn ret;\n}\n\nstatic void kvm_arch_vcpu_guestdbg_update_apicv_inhibit(struct kvm *kvm)\n{\n\tbool set = false;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tif (!enable_apicv)\n\t\treturn;\n\n\tdown_write(&kvm->arch.apicv_update_lock);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ) {\n\t\t\tset = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__kvm_set_or_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_BLOCKIRQ, set);\n\tup_write(&kvm->arch.apicv_update_lock);\n}\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn -EINVAL;\n\n\tvcpu_load(vcpu);\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_get_linear_rip(vcpu);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tstatic_call(kvm_x86_update_exception_bitmap)(vcpu);\n\n\tkvm_arch_vcpu_guestdbg_update_apicv_inhibit(vcpu->kvm);\n\n\tr = 0;\n\nout:\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\n/*\n * Translate a guest virtual address to a guest physical address.\n */\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tvcpu_load(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave;\n\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn 0;\n\n\tvcpu_load(vcpu);\n\n\tfxsave = &vcpu->arch.guest_fpu.fpstate->regs.fxsave;\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof(fxsave->xmm_space));\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave;\n\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn 0;\n\n\tvcpu_load(vcpu);\n\n\tfxsave = &vcpu->arch.guest_fpu.fpstate->regs.fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof(fxsave->xmm_space));\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nstatic void store_regs(struct kvm_vcpu *vcpu)\n{\n\tBUILD_BUG_ON(sizeof(struct kvm_sync_regs) > SYNC_REGS_SIZE_BYTES);\n\n\tif (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_REGS)\n\t\t__get_regs(vcpu, &vcpu->run->s.regs.regs);\n\n\tif (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_SREGS)\n\t\t__get_sregs(vcpu, &vcpu->run->s.regs.sregs);\n\n\tif (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_EVENTS)\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(\n\t\t\t\tvcpu, &vcpu->run->s.regs.events);\n}\n\nstatic int sync_regs(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {\n\t\t__set_regs(vcpu, &vcpu->run->s.regs.regs);\n\t\tvcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_REGS;\n\t}\n\tif (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_SREGS) {\n\t\tif (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))\n\t\t\treturn -EINVAL;\n\t\tvcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_SREGS;\n\t}\n\tif (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_EVENTS) {\n\t\tif (kvm_vcpu_ioctl_x86_set_vcpu_events(\n\t\t\t\tvcpu, &vcpu->run->s.regs.events))\n\t\t\treturn -EINVAL;\n\t\tvcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_EVENTS;\n\t}\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)\n{\n\tif (kvm_check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tpr_warn_once(\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\t     \"guest TSC will not be reliable\\n\");\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tint r;\n\n\tvcpu->arch.last_vmentry_cpu = -1;\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (irqchip_in_kernel(vcpu->kvm)) {\n\t\tr = kvm_create_lapic(vcpu, lapic_timer_advance_ns);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\n\t\t/*\n\t\t * Defer evaluating inhibits until the vCPU is first run, as\n\t\t * this vCPU will not get notified of any changes until this\n\t\t * vCPU is visible to other vCPUs (marked online and added to\n\t\t * the set of vCPUs).  Opportunistically mark APICv active as\n\t\t * VMX in particularly is highly unlikely to have inhibits.\n\t\t * Ignore the current per-VM APICv state so that vCPU creation\n\t\t * is guaranteed to run with a deterministic value, the request\n\t\t * will ensure the vCPU gets the correct state before VM-Entry.\n\t\t */\n\t\tif (enable_apicv) {\n\t\t\tvcpu->arch.apicv_active = true;\n\t\t\tkvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);\n\t\t}\n\t} else\n\t\tstatic_branch_inc(&kvm_has_noapic_vcpu);\n\n\tr = -ENOMEM;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!page)\n\t\tgoto fail_free_lapic;\n\tvcpu->arch.pio_data = page_address(page);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!vcpu->arch.mce_banks)\n\t\tgoto fail_free_pio_data;\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\tGFP_KERNEL_ACCOUNT))\n\t\tgoto fail_free_mce_banks;\n\n\tif (!alloc_emulate_ctxt(vcpu))\n\t\tgoto free_wbinvd_dirty_mask;\n\n\tif (!fpu_alloc_guest_fpstate(&vcpu->arch.guest_fpu)) {\n\t\tpr_err(\"kvm: failed to allocate vcpu's fpu\\n\");\n\t\tgoto free_emulate_ctxt;\n\t}\n\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\tvcpu->arch.reserved_gpa_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu);\n\n\tvcpu->arch.pat = MSR_IA32_CR_PAT_DEFAULT;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\tvcpu->arch.pending_external_vector = -1;\n\tvcpu->arch.preempted_in_kernel = false;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tvcpu->arch.hv_root_tdp = INVALID_PAGE;\n#endif\n\n\tr = static_call(kvm_x86_vcpu_create)(vcpu);\n\tif (r)\n\t\tgoto free_guest_fpu;\n\n\tvcpu->arch.arch_capabilities = kvm_get_arch_capabilities();\n\tvcpu->arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;\n\tkvm_xen_init_vcpu(vcpu);\n\tkvm_vcpu_mtrr_init(vcpu);\n\tvcpu_load(vcpu);\n\tkvm_set_tsc_khz(vcpu, vcpu->kvm->arch.default_tsc_khz);\n\tkvm_vcpu_reset(vcpu, false);\n\tkvm_init_mmu(vcpu);\n\tvcpu_put(vcpu);\n\treturn 0;\n\nfree_guest_fpu:\n\tfpu_free_guest_fpstate(&vcpu->arch.guest_fpu);\nfree_emulate_ctxt:\n\tkmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);\nfree_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tif (mutex_lock_killable(&vcpu->mutex))\n\t\treturn;\n\tvcpu_load(vcpu);\n\tkvm_synchronize_tsc(vcpu, 0);\n\tvcpu_put(vcpu);\n\n\t/* poll control enabled by default */\n\tvcpu->arch.msr_kvm_poll_control = 1;\n\n\tmutex_unlock(&vcpu->mutex);\n\n\tif (kvmclock_periodic_sync && vcpu->vcpu_idx == 0)\n\t\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvmclock_reset(vcpu);\n\n\tstatic_call(kvm_x86_vcpu_free)(vcpu);\n\n\tkmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfpu_free_guest_fpstate(&vcpu->arch.guest_fpu);\n\n\tkvm_xen_destroy_vcpu(vcpu);\n\tkvm_hv_vcpu_uninit(vcpu);\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tkvfree(vcpu->arch.cpuid_entries);\n\tif (!lapic_in_kernel(vcpu))\n\t\tstatic_branch_dec(&kvm_has_noapic_vcpu);\n}\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_0x1;\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long new_cr0;\n\n\t/*\n\t * Several of the \"set\" flows, e.g. ->set_cr0(), read other registers\n\t * to handle side effects.  RESET emulation hits those flows and relies\n\t * on emulated/virtualized registers, including those that are loaded\n\t * into hardware, to be zeroed at vCPU creation.  Use CRs as a sentinel\n\t * to detect improper or missing initialization.\n\t */\n\tWARN_ON_ONCE(!init_event &&\n\t\t     (old_cr0 || kvm_read_cr3(vcpu) || kvm_read_cr4(vcpu)));\n\n\tkvm_lapic_reset(vcpu, init_event);\n\n\tvcpu->arch.hflags = 0;\n\n\tvcpu->arch.smi_pending = 0;\n\tvcpu->arch.smi_count = 0;\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_ACTIVE_LOW;\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_en_val = 0;\n\tvcpu->arch.apf.msr_int_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (vcpu->arch.guest_fpu.fpstate && kvm_mpx_supported()) {\n\t\tstruct fpstate *fpstate = vcpu->arch.guest_fpu.fpstate;\n\n\t\t/*\n\t\t * To avoid have the INIT path from kvm_apic_has_events() that be\n\t\t * called with loaded FPU and does not let userspace fix the state.\n\t\t */\n\t\tif (init_event)\n\t\t\tkvm_put_guest_fpu(vcpu);\n\n\t\tfpstate_clear_xstate_component(fpstate, XFEATURE_BNDREGS);\n\t\tfpstate_clear_xstate_component(fpstate, XFEATURE_BNDCSR);\n\n\t\tif (init_event)\n\t\t\tkvm_load_guest_fpu(vcpu);\n\t}\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\n\t\tvcpu->arch.msr_misc_features_enables = 0;\n\n\t\t__kvm_set_xcr(vcpu, 0, XFEATURE_MASK_FP);\n\t\t__kvm_set_msr(vcpu, MSR_IA32_XSS, 0, true);\n\t}\n\n\t/* All GPRs except RDX (handled below) are zeroed on RESET/INIT. */\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tkvm_register_mark_dirty(vcpu, VCPU_REGS_RSP);\n\n\t/*\n\t * Fall back to KVM's default Family/Model/Stepping of 0x600 (P6/Athlon)\n\t * if no CPUID match is found.  Note, it's impossible to get a match at\n\t * RESET since KVM emulates RESET before exposing the vCPU to userspace,\n\t * i.e. it's impossible for kvm_find_cpuid_entry() to find a valid entry\n\t * on RESET.  But, go through the motions in case that's ever remedied.\n\t */\n\tcpuid_0x1 = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tkvm_rdx_write(vcpu, cpuid_0x1 ? cpuid_0x1->eax : 0x600);\n\n\tstatic_call(kvm_x86_vcpu_reset)(vcpu, init_event);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvcpu->arch.cr3 = 0;\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\n\t/*\n\t * CR0.CD/NW are set on RESET, preserved on INIT.  Note, some versions\n\t * of Intel's SDM list CD/NW as being set on INIT, but they contradict\n\t * (or qualify) that with a footnote stating that CD/NW are preserved.\n\t */\n\tnew_cr0 = X86_CR0_ET;\n\tif (init_event)\n\t\tnew_cr0 |= (old_cr0 & (X86_CR0_NW | X86_CR0_CD));\n\telse\n\t\tnew_cr0 |= X86_CR0_NW | X86_CR0_CD;\n\n\tstatic_call(kvm_x86_set_cr0)(vcpu, new_cr0);\n\tstatic_call(kvm_x86_set_cr4)(vcpu, 0);\n\tstatic_call(kvm_x86_set_efer)(vcpu, 0);\n\tstatic_call(kvm_x86_update_exception_bitmap)(vcpu);\n\n\t/*\n\t * On the standard CR0/CR4/EFER modification paths, there are several\n\t * complex conditions determining whether the MMU has to be reset and/or\n\t * which PCIDs have to be flushed.  However, CR0.WP and the paging-related\n\t * bits in CR4 and EFER are irrelevant if CR0.PG was '0'; and a reset+flush\n\t * is needed anyway if CR0.PG was '1' (which can only happen for INIT, as\n\t * CR0 will be '0' prior to RESET).  So we only need to check CR0.PG here.\n\t */\n\tif (old_cr0 & X86_CR0_PG) {\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t\tkvm_mmu_reset_context(vcpu);\n\t}\n\n\t/*\n\t * Intel's SDM states that all TLB entries are flushed on INIT.  AMD's\n\t * APM states the TLBs are untouched by INIT, but it also states that\n\t * the TLBs are flushed on \"External initialization of the processor.\"\n\t * Flush the guest TLB regardless of vendor, there is no meaningful\n\t * benefit in relying on the guest to flush the TLB immediately after\n\t * INIT.  A spurious TLB flush is benign and likely negligible from a\n\t * performance perspective.\n\t */\n\tif (init_event)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_reset);\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_deliver_sipi_vector);\n\nint kvm_arch_hardware_enable(void)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_user_return_msr_cpu_online();\n\tret = static_call(kvm_x86_hardware_enable)();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = rdtsc();\n\tstable = !kvm_check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, ktime_get_boottime_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm->arch.backwards_tsc_observed = true;\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_disable(void)\n{\n\tstatic_call(kvm_x86_hardware_disable)();\n\tdrop_user_return_notifiers();\n}\n\nstatic inline void kvm_ops_update(struct kvm_x86_init_ops *ops)\n{\n\tmemcpy(&kvm_x86_ops, ops->runtime_ops, sizeof(kvm_x86_ops));\n\n#define __KVM_X86_OP(func) \\\n\tstatic_call_update(kvm_x86_##func, kvm_x86_ops.func);\n#define KVM_X86_OP(func) \\\n\tWARN_ON(!kvm_x86_ops.func); __KVM_X86_OP(func)\n#define KVM_X86_OP_OPTIONAL __KVM_X86_OP\n#define KVM_X86_OP_OPTIONAL_RET0(func) \\\n\tstatic_call_update(kvm_x86_##func, (void *)kvm_x86_ops.func ? : \\\n\t\t\t\t\t   (void *)__static_call_return0);\n#include <asm/kvm-x86-ops.h>\n#undef __KVM_X86_OP\n\n\tkvm_pmu_ops_update(ops->pmu_ops);\n}\n\nint kvm_arch_hardware_setup(void *opaque)\n{\n\tstruct kvm_x86_init_ops *ops = opaque;\n\tint r;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\trdmsrl(MSR_IA32_XSS, host_xss);\n\n\tr = ops->hardware_setup();\n\tif (r != 0)\n\t\treturn r;\n\n\tkvm_ops_update(ops);\n\n\tkvm_register_perf_callbacks(ops->handle_intel_pt_intr);\n\n\tif (!kvm_cpu_cap_has(X86_FEATURE_XSAVES))\n\t\tsupported_xss = 0;\n\n#define __kvm_cpu_cap_has(UNUSED_, f) kvm_cpu_cap_has(f)\n\tcr4_reserved_bits = __cr4_reserved_bits(__kvm_cpu_cap_has, UNUSED_);\n#undef __kvm_cpu_cap_has\n\n\tif (kvm_has_tsc_control) {\n\t\t/*\n\t\t * Make sure the user can only configure tsc_khz values that\n\t\t * fit into a signed integer.\n\t\t * A min value is not calculated because it will always\n\t\t * be 1 on all machines.\n\t\t */\n\t\tu64 max = min(0x7fffffffULL,\n\t\t\t      __scale_tsc(kvm_max_tsc_scaling_ratio, tsc_khz));\n\t\tkvm_max_guest_tsc_khz = max;\n\t}\n\tkvm_default_tsc_scaling_ratio = 1ULL << kvm_tsc_scaling_ratio_frac_bits;\n\tkvm_init_msr_list();\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_unregister_perf_callbacks();\n\n\tstatic_call(kvm_x86_hardware_unsetup)();\n}\n\nint kvm_arch_check_processor_compat(void *opaque)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(smp_processor_id());\n\tstruct kvm_x86_init_ops *ops = opaque;\n\n\tWARN_ON(!irqs_disabled());\n\n\tif (__cr4_reserved_bits(cpu_has, c) !=\n\t    __cr4_reserved_bits(cpu_has, &boot_cpu_data))\n\t\treturn -EIO;\n\n\treturn ops->check_processor_compatibility();\n}\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_is_reset_bsp);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}\n\n__read_mostly DEFINE_STATIC_KEY_FALSE(kvm_has_noapic_vcpu);\nEXPORT_SYMBOL_GPL(kvm_has_noapic_vcpu);\n\nvoid kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tif (pmu->version && unlikely(pmu->event_count)) {\n\t\tpmu->need_cleanup = true;\n\t\tkvm_make_request(KVM_REQ_PMU, vcpu);\n\t}\n\tstatic_call(kvm_x86_sched_in)(vcpu, cpu);\n}\n\nvoid kvm_arch_free_vm(struct kvm *kvm)\n{\n\tkfree(to_kvm_hv(kvm)->hv_pa_pg);\n\t__kvm_arch_free_vm(kvm);\n}\n\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tif (type)\n\t\treturn -EINVAL;\n\n\tret = kvm_page_track_init(kvm);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kvm_mmu_init_vm(kvm);\n\tif (ret)\n\t\tgoto out_page_track;\n\n\tINIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tseqcount_raw_spinlock_init(&kvm->arch.pvclock_sc, &kvm->arch.tsc_write_lock);\n\tkvm->arch.kvmclock_offset = -get_kvmclock_base_ns();\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\tpvclock_update_vm_gtod_copy(kvm);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\tkvm->arch.default_tsc_khz = max_tsc_khz ? : tsc_khz;\n\tkvm->arch.guest_can_read_msr_platform_info = true;\n\tkvm->arch.enable_pmu = enable_pmu;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tspin_lock_init(&kvm->arch.hv_root_tdp_lock);\n\tkvm->arch.hv_root_tdp = INVALID_PAGE;\n#endif\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\tkvm_apicv_init(kvm);\n\tkvm_hv_init_vm(kvm);\n\tkvm_xen_init_vm(kvm);\n\n\treturn static_call(kvm_x86_vm_init)(kvm);\n\nout_page_track:\n\tkvm_page_track_cleanup(kvm);\nout:\n\treturn ret;\n}\n\nint kvm_arch_post_init_vm(struct kvm *kvm)\n{\n\treturn kvm_mmu_post_init_vm(kvm);\n}\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tvcpu_load(vcpu);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}\n\nstatic void kvm_unload_vcpu_mmus(struct kvm *kvm)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n}\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_update_work);\n\tkvm_free_pit(kvm);\n}\n\n/**\n * __x86_set_memory_region: Setup KVM internal memory slot\n *\n * @kvm: the kvm pointer to the VM.\n * @id: the slot ID to setup.\n * @gpa: the GPA to install the slot (unused when @size == 0).\n * @size: the size of the slot. Set to zero to uninstall a slot.\n *\n * This function helps to setup a KVM internal memory slot.  Specify\n * @size > 0 to install a new slot, while @size == 0 to uninstall a\n * slot.  The return code can be one of the following:\n *\n *   HVA:           on success (uninstall will return a bogus HVA)\n *   -errno:        on error\n *\n * The caller should always use IS_ERR() to check the return value\n * before use.  Note, the KVM internal memory slots are guaranteed to\n * remain valid and unchanged until the VM is destroyed, i.e., the\n * GPA->HVA translation will not change.  However, the HVA is a user\n * address, i.e. its accessibility is not guaranteed, and must be\n * accessed via __copy_{to,from}_user().\n */\nvoid __user * __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,\n\t\t\t\t      u32 size)\n{\n\tint i, r;\n\tunsigned long hva, old_npages;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn ERR_PTR_USR(-EINVAL);\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn ERR_PTR_USR(-EEXIST);\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn (void __user *)hva;\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn NULL;\n\n\t\told_npages = slot->npages;\n\t\thva = slot->userspace_addr;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn ERR_PTR_USR(r);\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn (void __user *)hva;\n}\nEXPORT_SYMBOL_GPL(__x86_set_memory_region);\n\nvoid kvm_arch_pre_destroy_vm(struct kvm *kvm)\n{\n\tkvm_mmu_pre_destroy_vm(kvm);\n}\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tmutex_lock(&kvm->slots_lock);\n\t\t__x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t\t0, 0);\n\t\t__x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t\t0, 0);\n\t\t__x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);\n\t\tmutex_unlock(&kvm->slots_lock);\n\t}\n\tkvm_unload_vcpu_mmus(kvm);\n\tstatic_call_cond(kvm_x86_vm_destroy)(kvm);\n\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tkvm_pic_destroy(kvm);\n\tkvm_ioapic_destroy(kvm);\n\tkvm_destroy_vcpus(kvm);\n\tkvfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tkvm_mmu_uninit_vm(kvm);\n\tkvm_page_track_cleanup(kvm);\n\tkvm_xen_destroy_vm(kvm);\n\tkvm_hv_destroy_vm(kvm);\n}\n\nstatic void memslot_rmap_free(struct kvm_memory_slot *slot)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t}\n}\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tint i;\n\n\tmemslot_rmap_free(slot);\n\n\tfor (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\n\tkvm_page_track_free_memslot(slot);\n}\n\nint memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages)\n{\n\tconst int sz = sizeof(*slot->arch.rmap[0]);\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tint level = i + 1;\n\t\tint lpages = __kvm_mmu_slot_lpages(slot, npages, level);\n\n\t\tif (slot->arch.rmap[i])\n\t\t\tcontinue;\n\n\t\tslot->arch.rmap[i] = __vcalloc(lpages, sz, GFP_KERNEL_ACCOUNT);\n\t\tif (!slot->arch.rmap[i]) {\n\t\t\tmemslot_rmap_free(slot);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_alloc_memslot_metadata(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *slot)\n{\n\tunsigned long npages = slot->npages;\n\tint i, r;\n\n\t/*\n\t * Clear out the previous array pointers for the KVM_MR_MOVE case.  The\n\t * old arrays will be freed by __kvm_set_memory_region() if installing\n\t * the new memslot is successful.\n\t */\n\tmemset(&slot->arch, 0, sizeof(slot->arch));\n\n\tif (kvm_memslots_have_rmaps(kvm)) {\n\t\tr = memslot_rmap_alloc(slot, npages);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tstruct kvm_lpage_info *linfo;\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = __kvm_mmu_slot_lpages(slot, npages, level);\n\n\t\tlinfo = __vcalloc(lpages, sizeof(*linfo), GFP_KERNEL_ACCOUNT);\n\t\tif (!linfo)\n\t\t\tgoto out_free;\n\n\t\tslot->arch.lpage_info[i - 1] = linfo;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[0].disallow_lpage = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[lpages - 1].disallow_lpage = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, disable large page support for this slot.\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1)) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tlinfo[j].disallow_lpage = 1;\n\t\t}\n\t}\n\n\tif (kvm_page_track_create_memslot(kvm, slot, npages))\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tmemslot_rmap_free(slot);\n\n\tfor (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm, u64 gen)\n{\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm, gen);\n\n\t/* Force re-initialization of steal_time cache */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *old,\n\t\t\t\t   struct kvm_memory_slot *new,\n\t\t\t\t   enum kvm_mr_change change)\n{\n\tif (change == KVM_MR_CREATE || change == KVM_MR_MOVE) {\n\t\tif ((new->base_gfn + new->npages - 1) > kvm_mmu_max_gfn())\n\t\t\treturn -EINVAL;\n\n\t\treturn kvm_alloc_memslot_metadata(kvm, new);\n\t}\n\n\tif (change == KVM_MR_FLAGS_ONLY)\n\t\tmemcpy(&new->arch, &old->arch, sizeof(old->arch));\n\telse if (WARN_ON_ONCE(change != KVM_MR_DELETE))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\nstatic void kvm_mmu_update_cpu_dirty_logging(struct kvm *kvm, bool enable)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tif (!kvm_x86_ops.cpu_dirty_log_size)\n\t\treturn;\n\n\tif ((enable && ++ka->cpu_dirty_logging_count == 1) ||\n\t    (!enable && --ka->cpu_dirty_logging_count == 0))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_UPDATE_CPU_DIRTY_LOGGING);\n\n\tWARN_ON_ONCE(ka->cpu_dirty_logging_count < 0);\n}\n\nstatic void kvm_mmu_slot_apply_flags(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     const struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n{\n\tu32 old_flags = old ? old->flags : 0;\n\tu32 new_flags = new ? new->flags : 0;\n\tbool log_dirty_pages = new_flags & KVM_MEM_LOG_DIRTY_PAGES;\n\n\t/*\n\t * Update CPU dirty logging if dirty logging is being toggled.  This\n\t * applies to all operations.\n\t */\n\tif ((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)\n\t\tkvm_mmu_update_cpu_dirty_logging(kvm, log_dirty_pages);\n\n\t/*\n\t * Nothing more to do for RO slots (which can't be dirtied and can't be\n\t * made writable) or CREATE/MOVE/DELETE of a slot.\n\t *\n\t * For a memslot with dirty logging disabled:\n\t * CREATE:      No dirty mappings will already exist.\n\t * MOVE/DELETE: The old mappings will already have been cleaned up by\n\t *\t\tkvm_arch_flush_shadow_memslot()\n\t *\n\t * For a memslot with dirty logging enabled:\n\t * CREATE:      No shadow pages exist, thus nothing to write-protect\n\t *\t\tand no dirty bits to clear.\n\t * MOVE/DELETE: The old mappings will already have been cleaned up by\n\t *\t\tkvm_arch_flush_shadow_memslot().\n\t */\n\tif ((change != KVM_MR_FLAGS_ONLY) || (new_flags & KVM_MEM_READONLY))\n\t\treturn;\n\n\t/*\n\t * READONLY and non-flags changes were filtered out above, and the only\n\t * other flag is LOG_DIRTY_PAGES, i.e. something is wrong if dirty\n\t * logging isn't being toggled on or off.\n\t */\n\tif (WARN_ON_ONCE(!((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)))\n\t\treturn;\n\n\tif (!log_dirty_pages) {\n\t\t/*\n\t\t * Dirty logging tracks sptes in 4k granularity, meaning that\n\t\t * large sptes have to be split.  If live migration succeeds,\n\t\t * the guest in the source machine will be destroyed and large\n\t\t * sptes will be created in the destination.  However, if the\n\t\t * guest continues to run in the source machine (for example if\n\t\t * live migration fails), small sptes will remain around and\n\t\t * cause bad performance.\n\t\t *\n\t\t * Scan sptes if dirty logging has been stopped, dropping those\n\t\t * which can be collapsed into a single large-page spte.  Later\n\t\t * page faults will create the large-page sptes.\n\t\t */\n\t\tkvm_mmu_zap_collapsible_sptes(kvm, new);\n\t} else {\n\t\t/*\n\t\t * Initially-all-set does not require write protecting any page,\n\t\t * because they're all assumed to be dirty.\n\t\t */\n\t\tif (kvm_dirty_log_manual_protect_and_init_set(kvm))\n\t\t\treturn;\n\n\t\tif (READ_ONCE(eager_page_split))\n\t\t\tkvm_mmu_slot_try_split_huge_pages(kvm, new, PG_LEVEL_4K);\n\n\t\tif (kvm_x86_ops.cpu_dirty_log_size) {\n\t\t\tkvm_mmu_slot_leaf_clear_dirty(kvm, new);\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_2M);\n\t\t} else {\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_4K);\n\t\t}\n\t}\n}\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *old,\n\t\t\t\tconst struct kvm_memory_slot *new,\n\t\t\t\tenum kvm_mr_change change)\n{\n\tif (!kvm->arch.n_requested_mmu_pages &&\n\t    (change == KVM_MR_CREATE || change == KVM_MR_DELETE)) {\n\t\tunsigned long nr_mmu_pages;\n\n\t\tnr_mmu_pages = kvm->nr_memslot_pages / KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO;\n\t\tnr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\t}\n\n\tkvm_mmu_slot_apply_flags(kvm, old, new, change);\n\n\t/* Free the arrays associated with the old memslot. */\n\tif (change == KVM_MR_MOVE)\n\t\tkvm_arch_free_memslot(kvm, old);\n}\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_zap_all(kvm);\n}\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_page_track_flush_slot(kvm, slot);\n}\n\nstatic inline bool kvm_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn (is_guest_mode(vcpu) &&\n\t\tstatic_call(kvm_x86_guest_apic_has_interrupt)(vcpu));\n}\n\nstatic inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)\n{\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n\n\tif (kvm_apic_has_events(vcpu))\n\t\treturn true;\n\n\tif (vcpu->arch.pv.pv_unhalted)\n\t\treturn true;\n\n\tif (vcpu->arch.exception.pending)\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_NMI, vcpu) ||\n\t    (vcpu->arch.nmi_pending &&\n\t     static_call(kvm_x86_nmi_allowed)(vcpu, false)))\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_SMI, vcpu) ||\n\t    (vcpu->arch.smi_pending &&\n\t     static_call(kvm_x86_smi_allowed)(vcpu, false)))\n\t\treturn true;\n\n\tif (kvm_arch_interrupt_allowed(vcpu) &&\n\t    (kvm_cpu_has_interrupt(vcpu) ||\n\t    kvm_guest_apic_has_interrupt(vcpu)))\n\t\treturn true;\n\n\tif (kvm_hv_has_stimer_pending(vcpu))\n\t\treturn true;\n\n\tif (is_guest_mode(vcpu) &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending(vcpu))\n\t\treturn true;\n\n\tif (kvm_xen_has_pending_events(vcpu))\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu))\n\t\treturn true;\n\n\treturn false;\n}\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}\n\nbool kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.apicv_active && static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (READ_ONCE(vcpu->arch.pv.pv_unhalted))\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_NMI, vcpu) ||\n\t\tkvm_test_request(KVM_REQ_SMI, vcpu) ||\n\t\t kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\treturn true;\n\n\treturn kvm_arch_dy_has_pending_interrupt(vcpu);\n}\n\nbool kvm_arch_vcpu_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn true;\n\n\treturn vcpu->arch.preempted_in_kernel;\n}\n\nunsigned long kvm_arch_vcpu_get_ip(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_rip_read(vcpu);\n}\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn static_call(kvm_x86_interrupt_allowed)(vcpu, false);\n}\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\t/* Can't read the RIP when guest state is protected, just return 0 */\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn 0;\n\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}\nEXPORT_SYMBOL_GPL(kvm_get_linear_rip);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}\nEXPORT_SYMBOL_GPL(kvm_is_linear_rip);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = static_call(kvm_x86_get_rflags)(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}\nEXPORT_SYMBOL_GPL(kvm_get_rflags);\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tstatic_call(kvm_x86_set_rflags)(vcpu, rflags);\n}\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_set_rflags);\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\tBUILD_BUG_ON(!is_power_of_2(ASYNC_PF_PER_VCPU));\n\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (ASYNC_PF_PER_VCPU - 1);\n}\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < ASYNC_PF_PER_VCPU &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\n\tif (WARN_ON_ONCE(vcpu->arch.apf.gfns[i] != gfn))\n\t\treturn;\n\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}\n\nstatic inline int apf_put_user_notpresent(struct kvm_vcpu *vcpu)\n{\n\tu32 reason = KVM_PV_REASON_PAGE_NOT_PRESENT;\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason,\n\t\t\t\t      sizeof(reason));\n}\n\nstatic inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)\n{\n\tunsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);\n\n\treturn kvm_write_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,\n\t\t\t\t\t     &token, offset, sizeof(token));\n}\n\nstatic inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)\n{\n\tunsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);\n\tu32 val;\n\n\tif (kvm_read_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,\n\t\t\t\t\t &val, offset, sizeof(val)))\n\t\treturn false;\n\n\treturn !val;\n}\n\nstatic bool kvm_can_deliver_async_pf(struct kvm_vcpu *vcpu)\n{\n\n\tif (!kvm_pv_async_pf_enabled(vcpu))\n\t\treturn false;\n\n\tif (vcpu->arch.apf.send_user_only &&\n\t    static_call(kvm_x86_get_cpl)(vcpu) == 0)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * L1 needs to opt into the special #PF vmexits that are\n\t\t * used to deliver async page faults.\n\t\t */\n\t\treturn vcpu->arch.apf.delivery_as_pf_vmexit;\n\t} else {\n\t\t/*\n\t\t * Play it safe in case the guest temporarily disables paging.\n\t\t * The real mode IDT in particular is unlikely to have a #PF\n\t\t * exception setup.\n\t\t */\n\t\treturn is_paging(vcpu);\n\t}\n}\n\nbool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu) ||\n\t\t     vcpu->arch.exception.pending))\n\t\treturn false;\n\n\tif (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))\n\t\treturn false;\n\n\t/*\n\t * If interrupts are off we cannot even use an artificial\n\t * halt state.\n\t */\n\treturn kvm_arch_interrupt_allowed(vcpu);\n}\n\nbool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->cr2_or_gpa);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (kvm_can_deliver_async_pf(vcpu) &&\n\t    !apf_put_user_notpresent(vcpu)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tfault.async_page_fault = true;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * It is not possible to deliver a paravirtualized asynchronous\n\t\t * page fault, but putting the guest in an artificial halt state\n\t\t * can be beneficial nevertheless: if an interrupt arrives, we\n\t\t * can deliver it timely and perhaps the guest will schedule\n\t\t * another process.  When the instruction that triggered a page\n\t\t * fault is retried, hopefully the page will be ready in the host.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\treturn false;\n\t}\n}\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vcpu->arch.apf.vec\n\t};\n\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\ttrace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);\n\n\tif ((work->wakeup_all || work->notpresent_injected) &&\n\t    kvm_pv_async_pf_enabled(vcpu) &&\n\t    !apf_put_user_ready(vcpu, work->arch.token)) {\n\t\tvcpu->arch.apf.pageready_pending = true;\n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\nvoid kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_APF_READY, vcpu);\n\tif (!vcpu->arch.apf.pageready_pending)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nbool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_pv_async_pf_enabled(vcpu))\n\t\treturn true;\n\telse\n\t\treturn kvm_lapic_enabled(vcpu) && apf_pageready_slot_free(vcpu);\n}\n\nvoid kvm_arch_start_assignment(struct kvm *kvm)\n{\n\tif (atomic_inc_return(&kvm->arch.assigned_device_count) == 1)\n\t\tstatic_call_cond(kvm_x86_pi_start_assignment)(kvm);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_start_assignment);\n\nvoid kvm_arch_end_assignment(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.assigned_device_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_end_assignment);\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_assigned_device);\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);\n\nbool kvm_arch_has_irq_bypass(void)\n{\n\treturn true;\n}\n\nint kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\tint ret;\n\n\tirqfd->producer = prod;\n\tkvm_arch_start_assignment(irqfd->kvm);\n\tret = static_call(kvm_x86_pi_update_irte)(irqfd->kvm,\n\t\t\t\t\t prod->irq, irqfd->gsi, 1);\n\n\tif (ret)\n\t\tkvm_arch_end_assignment(irqfd->kvm);\n\n\treturn ret;\n}\n\nvoid kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tint ret;\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\n\tWARN_ON(irqfd->producer != prod);\n\tirqfd->producer = NULL;\n\n\t/*\n\t * When producer of consumer is unregistered, we change back to\n\t * remapped mode, so we can re-use the current implementation\n\t * when the irq is masked/disabled or the consumer side (KVM\n\t * int this case doesn't want to receive the interrupts.\n\t*/\n\tret = static_call(kvm_x86_pi_update_irte)(irqfd->kvm, prod->irq, irqfd->gsi, 0);\n\tif (ret)\n\t\tprintk(KERN_INFO \"irq bypass consumer (token %p) unregistration\"\n\t\t       \" fails: %d\\n\", irqfd->consumer.token, ret);\n\n\tkvm_arch_end_assignment(irqfd->kvm);\n}\n\nint kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,\n\t\t\t\t   uint32_t guest_irq, bool set)\n{\n\treturn static_call(kvm_x86_pi_update_irte)(kvm, host_irq, guest_irq, set);\n}\n\nbool kvm_arch_irqfd_route_changed(struct kvm_kernel_irq_routing_entry *old,\n\t\t\t\t  struct kvm_kernel_irq_routing_entry *new)\n{\n\tif (new->type != KVM_IRQ_ROUTING_MSI)\n\t\treturn true;\n\n\treturn !!memcmp(&old->msi, &new->msi, sizeof(new->msi));\n}\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}\n\nbool kvm_arch_no_poll(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.msr_kvm_poll_control & 1) == 0;\n}\nEXPORT_SYMBOL_GPL(kvm_arch_no_poll);\n\n\nint kvm_spec_ctrl_test_value(u64 value)\n{\n\t/*\n\t * test that setting IA32_SPEC_CTRL to given value\n\t * is allowed by the host processor\n\t */\n\n\tu64 saved_value;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tlocal_irq_save(flags);\n\n\tif (rdmsrl_safe(MSR_IA32_SPEC_CTRL, &saved_value))\n\t\tret = 1;\n\telse if (wrmsrl_safe(MSR_IA32_SPEC_CTRL, value))\n\t\tret = 1;\n\telse\n\t\twrmsrl(MSR_IA32_SPEC_CTRL, saved_value);\n\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_spec_ctrl_test_value);\n\nvoid kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tstruct x86_exception fault;\n\tu64 access = error_code &\n\t\t(PFERR_WRITE_MASK | PFERR_FETCH_MASK | PFERR_USER_MASK);\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t    mmu->gva_to_gpa(vcpu, mmu, gva, access, &fault) != UNMAPPED_GVA) {\n\t\t/*\n\t\t * If vcpu->arch.walk_mmu->gva_to_gpa succeeded, the page\n\t\t * tables probably do not match the TLB.  Just proceed\n\t\t * with the error code that the processor gave.\n\t\t */\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = error_code;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = gva;\n\t}\n\tvcpu->arch.walk_mmu->inject_page_fault(vcpu, &fault);\n}\nEXPORT_SYMBOL_GPL(kvm_fixup_and_inject_pf_error);\n\n/*\n * Handles kvm_read/write_guest_virt*() result and either injects #PF or returns\n * KVM_EXIT_INTERNAL_ERROR for cases not currently handled by KVM. Return value\n * indicates whether exit to userspace is needed.\n */\nint kvm_handle_memory_failure(struct kvm_vcpu *vcpu, int r,\n\t\t\t      struct x86_exception *e)\n{\n\tif (r == X86EMUL_PROPAGATE_FAULT) {\n\t\tkvm_inject_emulated_page_fault(vcpu, e);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * In case kvm_read/write_guest_virt*() failed with X86EMUL_IO_NEEDED\n\t * while handling a VMX instruction KVM could've handled the request\n\t * correctly by exiting to userspace and performing I/O but there\n\t * doesn't seem to be a real use-case behind such requests, just return\n\t * KVM_EXIT_INTERNAL_ERROR for now.\n\t */\n\tkvm_prepare_emulation_failure_exit(vcpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_handle_memory_failure);\n\nint kvm_handle_invpcid(struct kvm_vcpu *vcpu, unsigned long type, gva_t gva)\n{\n\tbool pcid_enabled;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 pcid;\n\t\tu64 gla;\n\t} operand;\n\tint r;\n\n\tr = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn kvm_handle_memory_failure(vcpu, r, &e);\n\n\tif (operand.pcid >> 12 != 0) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tpcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tswitch (type) {\n\tcase INVPCID_TYPE_INDIV_ADDR:\n\t\tif ((!pcid_enabled && (operand.pcid != 0)) ||\n\t\t    is_noncanonical_address(operand.gla, vcpu)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_SINGLE_CTXT:\n\t\tif (!pcid_enabled && (operand.pcid != 0)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tkvm_invalidate_pcid(vcpu, operand.pcid);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_ALL_NON_GLOBAL:\n\t\t/*\n\t\t * Currently, KVM doesn't mark global entries in the shadow\n\t\t * page tables, so a non-global flush just degenerates to a\n\t\t * global flush. If needed, we could optimize this later by\n\t\t * keeping track of global entries in shadow page tables.\n\t\t */\n\n\t\tfallthrough;\n\tcase INVPCID_TYPE_ALL_INCL_GLOBAL:\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tdefault:\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_handle_invpcid);\n\nstatic int complete_sev_es_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned int len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t// VMG change, at this point, we're always done\n\t\t// RIP has already been advanced\n\t\treturn 1;\n\t}\n\n\t// More MMIO is needed\n\trun->mmio.phys_addr = frag->gpa;\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tif (run->mmio.is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->exit_reason = KVM_EXIT_MMIO;\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_mmio;\n\n\treturn 0;\n}\n\nint kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,\n\t\t\t  void *data)\n{\n\tint handled;\n\tstruct kvm_mmio_fragment *frag;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\thandled = write_emultor.read_write_mmio(vcpu, gpa, bytes, data);\n\tif (handled == bytes)\n\t\treturn 1;\n\n\tbytes -= handled;\n\tgpa += handled;\n\tdata += handled;\n\n\t/*TODO: Check if need to increment number of frags */\n\tfrag = vcpu->mmio_fragments;\n\tvcpu->mmio_nr_fragments = 1;\n\tfrag->len = bytes;\n\tfrag->gpa = gpa;\n\tfrag->data = data;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.phys_addr = gpa;\n\tvcpu->run->mmio.len = min(8u, frag->len);\n\tvcpu->run->mmio.is_write = 1;\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_mmio;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_sev_es_mmio_write);\n\nint kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,\n\t\t\t void *data)\n{\n\tint handled;\n\tstruct kvm_mmio_fragment *frag;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\thandled = read_emultor.read_write_mmio(vcpu, gpa, bytes, data);\n\tif (handled == bytes)\n\t\treturn 1;\n\n\tbytes -= handled;\n\tgpa += handled;\n\tdata += handled;\n\n\t/*TODO: Check if need to increment number of frags */\n\tfrag = vcpu->mmio_fragments;\n\tvcpu->mmio_nr_fragments = 1;\n\tfrag->len = bytes;\n\tfrag->gpa = gpa;\n\tfrag->data = data;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.phys_addr = gpa;\n\tvcpu->run->mmio.len = min(8u, frag->len);\n\tvcpu->run->mmio.is_write = 0;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_mmio;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_sev_es_mmio_read);\n\nstatic int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t   unsigned int port);\n\nstatic int complete_sev_es_emulated_outs(struct kvm_vcpu *vcpu)\n{\n\tint size = vcpu->arch.pio.size;\n\tint port = vcpu->arch.pio.port;\n\n\tvcpu->arch.pio.count = 0;\n\tif (vcpu->arch.sev_pio_count)\n\t\treturn kvm_sev_es_outs(vcpu, size, port);\n\treturn 1;\n}\n\nstatic int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t   unsigned int port)\n{\n\tfor (;;) {\n\t\tunsigned int count =\n\t\t\tmin_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);\n\t\tint ret = emulator_pio_out(vcpu, size, port, vcpu->arch.sev_pio_data, count);\n\n\t\t/* memcpy done already by emulator_pio_out.  */\n\t\tvcpu->arch.sev_pio_count -= count;\n\t\tvcpu->arch.sev_pio_data += count * vcpu->arch.pio.size;\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\t/* Emulation done by the kernel.  */\n\t\tif (!vcpu->arch.sev_pio_count)\n\t\t\treturn 1;\n\t}\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_outs;\n\treturn 0;\n}\n\nstatic int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t  unsigned int port);\n\nstatic void advance_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n{\n\tunsigned count = vcpu->arch.pio.count;\n\tcomplete_emulator_pio_in(vcpu, vcpu->arch.sev_pio_data);\n\tvcpu->arch.sev_pio_count -= count;\n\tvcpu->arch.sev_pio_data += count * vcpu->arch.pio.size;\n}\n\nstatic int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n{\n\tint size = vcpu->arch.pio.size;\n\tint port = vcpu->arch.pio.port;\n\n\tadvance_sev_es_emulated_ins(vcpu);\n\tif (vcpu->arch.sev_pio_count)\n\t\treturn kvm_sev_es_ins(vcpu, size, port);\n\treturn 1;\n}\n\nstatic int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t  unsigned int port)\n{\n\tfor (;;) {\n\t\tunsigned int count =\n\t\t\tmin_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);\n\t\tif (!__emulator_pio_in(vcpu, size, port, count))\n\t\t\tbreak;\n\n\t\t/* Emulation done by the kernel.  */\n\t\tadvance_sev_es_emulated_ins(vcpu);\n\t\tif (!vcpu->arch.sev_pio_count)\n\t\t\treturn 1;\n\t}\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_ins;\n\treturn 0;\n}\n\nint kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t unsigned int port, void *data,  unsigned int count,\n\t\t\t int in)\n{\n\tvcpu->arch.sev_pio_data = data;\n\tvcpu->arch.sev_pio_count = count;\n\treturn in ? kvm_sev_es_ins(vcpu, size, port)\n\t\t  : kvm_sev_es_outs(vcpu, size, port);\n}\nEXPORT_SYMBOL_GPL(kvm_sev_es_string_io);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_entry);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter_failed);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window_update);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pml_full);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pi_irte_update);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_unaccelerated_access);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_incomplete_ipi);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_ga_log);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_kick_vcpu_slowpath);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_apicv_accept_irq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_enter);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_enter);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_exit);\n\nstatic int __init kvm_x86_init(void)\n{\n\tkvm_mmu_x86_module_init();\n\treturn 0;\n}\nmodule_init(kvm_x86_init);\n\nstatic void __exit kvm_x86_exit(void)\n{\n\t/*\n\t * If module_init() is implemented, module_exit() must also be\n\t * implemented to allow module unload.\n\t */\n}\nmodule_exit(kvm_x86_exit);\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0-only */\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This header defines architecture specific interfaces, x86 version\n */\n\n#ifndef _ASM_X86_KVM_HOST_H\n#define _ASM_X86_KVM_HOST_H\n\n#include <linux/types.h>\n#include <linux/mm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/tracepoint.h>\n#include <linux/cpumask.h>\n#include <linux/irq_work.h>\n#include <linux/irq.h>\n#include <linux/workqueue.h>\n\n#include <linux/kvm.h>\n#include <linux/kvm_para.h>\n#include <linux/kvm_types.h>\n#include <linux/perf_event.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/clocksource.h>\n#include <linux/irqbypass.h>\n#include <linux/hyperv.h>\n\n#include <asm/apic.h>\n#include <asm/pvclock-abi.h>\n#include <asm/desc.h>\n#include <asm/mtrr.h>\n#include <asm/msr-index.h>\n#include <asm/asm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_vcpu_regs.h>\n#include <asm/hyperv-tlfs.h>\n\n#define __KVM_HAVE_ARCH_VCPU_DEBUGFS\n\n#define KVM_MAX_VCPUS 1024\n\n/*\n * In x86, the VCPU ID corresponds to the APIC ID, and APIC IDs\n * might be larger than the actual number of VCPUs because the\n * APIC ID encodes CPU topology information.\n *\n * In the worst case, we'll need less than one extra bit for the\n * Core ID, and less than one extra bit for the Package (Die) ID,\n * so ratio of 4 should be enough.\n */\n#define KVM_VCPU_ID_RATIO 4\n#define KVM_MAX_VCPU_IDS (KVM_MAX_VCPUS * KVM_VCPU_ID_RATIO)\n\n/* memory slots that are not exposed to userspace */\n#define KVM_PRIVATE_MEM_SLOTS 3\n\n#define KVM_HALT_POLL_NS_DEFAULT 200000\n\n#define KVM_IRQCHIP_NUM_PINS  KVM_IOAPIC_NUM_PINS\n\n#define KVM_DIRTY_LOG_MANUAL_CAPS   (KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE | \\\n\t\t\t\t\tKVM_DIRTY_LOG_INITIALLY_SET)\n\n#define KVM_BUS_LOCK_DETECTION_VALID_MODE\t(KVM_BUS_LOCK_DETECTION_OFF | \\\n\t\t\t\t\t\t KVM_BUS_LOCK_DETECTION_EXIT)\n\n/* x86-specific vcpu->requests bit members */\n#define KVM_REQ_MIGRATE_TIMER\t\tKVM_ARCH_REQ(0)\n#define KVM_REQ_REPORT_TPR_ACCESS\tKVM_ARCH_REQ(1)\n#define KVM_REQ_TRIPLE_FAULT\t\tKVM_ARCH_REQ(2)\n#define KVM_REQ_MMU_SYNC\t\tKVM_ARCH_REQ(3)\n#define KVM_REQ_CLOCK_UPDATE\t\tKVM_ARCH_REQ(4)\n#define KVM_REQ_LOAD_MMU_PGD\t\tKVM_ARCH_REQ(5)\n#define KVM_REQ_EVENT\t\t\tKVM_ARCH_REQ(6)\n#define KVM_REQ_APF_HALT\t\tKVM_ARCH_REQ(7)\n#define KVM_REQ_STEAL_UPDATE\t\tKVM_ARCH_REQ(8)\n#define KVM_REQ_NMI\t\t\tKVM_ARCH_REQ(9)\n#define KVM_REQ_PMU\t\t\tKVM_ARCH_REQ(10)\n#define KVM_REQ_PMI\t\t\tKVM_ARCH_REQ(11)\n#define KVM_REQ_SMI\t\t\tKVM_ARCH_REQ(12)\n#define KVM_REQ_MASTERCLOCK_UPDATE\tKVM_ARCH_REQ(13)\n#define KVM_REQ_MCLOCK_INPROGRESS \\\n\tKVM_ARCH_REQ_FLAGS(14, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_SCAN_IOAPIC \\\n\tKVM_ARCH_REQ_FLAGS(15, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_GLOBAL_CLOCK_UPDATE\tKVM_ARCH_REQ(16)\n#define KVM_REQ_APIC_PAGE_RELOAD \\\n\tKVM_ARCH_REQ_FLAGS(17, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_HV_CRASH\t\tKVM_ARCH_REQ(18)\n#define KVM_REQ_IOAPIC_EOI_EXIT\t\tKVM_ARCH_REQ(19)\n#define KVM_REQ_HV_RESET\t\tKVM_ARCH_REQ(20)\n#define KVM_REQ_HV_EXIT\t\t\tKVM_ARCH_REQ(21)\n#define KVM_REQ_HV_STIMER\t\tKVM_ARCH_REQ(22)\n#define KVM_REQ_LOAD_EOI_EXITMAP\tKVM_ARCH_REQ(23)\n#define KVM_REQ_GET_NESTED_STATE_PAGES\tKVM_ARCH_REQ(24)\n#define KVM_REQ_APICV_UPDATE \\\n\tKVM_ARCH_REQ_FLAGS(25, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_TLB_FLUSH_CURRENT\tKVM_ARCH_REQ(26)\n#define KVM_REQ_TLB_FLUSH_GUEST \\\n\tKVM_ARCH_REQ_FLAGS(27, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_APF_READY\t\tKVM_ARCH_REQ(28)\n#define KVM_REQ_MSR_FILTER_CHANGED\tKVM_ARCH_REQ(29)\n#define KVM_REQ_UPDATE_CPU_DIRTY_LOGGING \\\n\tKVM_ARCH_REQ_FLAGS(30, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n#define KVM_REQ_MMU_FREE_OBSOLETE_ROOTS \\\n\tKVM_ARCH_REQ_FLAGS(31, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)\n\n#define CR0_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR0_PE | X86_CR0_MP | X86_CR0_EM | X86_CR0_TS \\\n\t\t\t  | X86_CR0_ET | X86_CR0_NE | X86_CR0_WP | X86_CR0_AM \\\n\t\t\t  | X86_CR0_NW | X86_CR0_CD | X86_CR0_PG))\n\n#define CR4_RESERVED_BITS                                               \\\n\t(~(unsigned long)(X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE\\\n\t\t\t  | X86_CR4_PSE | X86_CR4_PAE | X86_CR4_MCE     \\\n\t\t\t  | X86_CR4_PGE | X86_CR4_PCE | X86_CR4_OSFXSR | X86_CR4_PCIDE \\\n\t\t\t  | X86_CR4_OSXSAVE | X86_CR4_SMEP | X86_CR4_FSGSBASE \\\n\t\t\t  | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_VMXE \\\n\t\t\t  | X86_CR4_SMAP | X86_CR4_PKE | X86_CR4_UMIP))\n\n#define CR8_RESERVED_BITS (~(unsigned long)X86_CR8_TPR)\n\n\n\n#define INVALID_PAGE (~(hpa_t)0)\n#define VALID_PAGE(x) ((x) != INVALID_PAGE)\n\n#define UNMAPPED_GVA (~(gpa_t)0)\n#define INVALID_GPA (~(gpa_t)0)\n\n/* KVM Hugepage definitions for x86 */\n#define KVM_MAX_HUGEPAGE_LEVEL\tPG_LEVEL_1G\n#define KVM_NR_PAGE_SIZES\t(KVM_MAX_HUGEPAGE_LEVEL - PG_LEVEL_4K + 1)\n#define KVM_HPAGE_GFN_SHIFT(x)\t(((x) - 1) * 9)\n#define KVM_HPAGE_SHIFT(x)\t(PAGE_SHIFT + KVM_HPAGE_GFN_SHIFT(x))\n#define KVM_HPAGE_SIZE(x)\t(1UL << KVM_HPAGE_SHIFT(x))\n#define KVM_HPAGE_MASK(x)\t(~(KVM_HPAGE_SIZE(x) - 1))\n#define KVM_PAGES_PER_HPAGE(x)\t(KVM_HPAGE_SIZE(x) / PAGE_SIZE)\n\n#define KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO 50\n#define KVM_MIN_ALLOC_MMU_PAGES 64UL\n#define KVM_MMU_HASH_SHIFT 12\n#define KVM_NUM_MMU_PAGES (1 << KVM_MMU_HASH_SHIFT)\n#define KVM_MIN_FREE_MMU_PAGES 5\n#define KVM_REFILL_PAGES 25\n#define KVM_MAX_CPUID_ENTRIES 256\n#define KVM_NR_FIXED_MTRR_REGION 88\n#define KVM_NR_VAR_MTRR 8\n\n#define ASYNC_PF_PER_VCPU 64\n\nenum kvm_reg {\n\tVCPU_REGS_RAX = __VCPU_REGS_RAX,\n\tVCPU_REGS_RCX = __VCPU_REGS_RCX,\n\tVCPU_REGS_RDX = __VCPU_REGS_RDX,\n\tVCPU_REGS_RBX = __VCPU_REGS_RBX,\n\tVCPU_REGS_RSP = __VCPU_REGS_RSP,\n\tVCPU_REGS_RBP = __VCPU_REGS_RBP,\n\tVCPU_REGS_RSI = __VCPU_REGS_RSI,\n\tVCPU_REGS_RDI = __VCPU_REGS_RDI,\n#ifdef CONFIG_X86_64\n\tVCPU_REGS_R8  = __VCPU_REGS_R8,\n\tVCPU_REGS_R9  = __VCPU_REGS_R9,\n\tVCPU_REGS_R10 = __VCPU_REGS_R10,\n\tVCPU_REGS_R11 = __VCPU_REGS_R11,\n\tVCPU_REGS_R12 = __VCPU_REGS_R12,\n\tVCPU_REGS_R13 = __VCPU_REGS_R13,\n\tVCPU_REGS_R14 = __VCPU_REGS_R14,\n\tVCPU_REGS_R15 = __VCPU_REGS_R15,\n#endif\n\tVCPU_REGS_RIP,\n\tNR_VCPU_REGS,\n\n\tVCPU_EXREG_PDPTR = NR_VCPU_REGS,\n\tVCPU_EXREG_CR0,\n\tVCPU_EXREG_CR3,\n\tVCPU_EXREG_CR4,\n\tVCPU_EXREG_RFLAGS,\n\tVCPU_EXREG_SEGMENTS,\n\tVCPU_EXREG_EXIT_INFO_1,\n\tVCPU_EXREG_EXIT_INFO_2,\n};\n\nenum {\n\tVCPU_SREG_ES,\n\tVCPU_SREG_CS,\n\tVCPU_SREG_SS,\n\tVCPU_SREG_DS,\n\tVCPU_SREG_FS,\n\tVCPU_SREG_GS,\n\tVCPU_SREG_TR,\n\tVCPU_SREG_LDTR,\n};\n\nenum exit_fastpath_completion {\n\tEXIT_FASTPATH_NONE,\n\tEXIT_FASTPATH_REENTER_GUEST,\n\tEXIT_FASTPATH_EXIT_HANDLED,\n};\ntypedef enum exit_fastpath_completion fastpath_t;\n\nstruct x86_emulate_ctxt;\nstruct x86_exception;\nenum x86_intercept;\nenum x86_intercept_stage;\n\n#define KVM_NR_DB_REGS\t4\n\n#define DR6_BUS_LOCK   (1 << 11)\n#define DR6_BD\t\t(1 << 13)\n#define DR6_BS\t\t(1 << 14)\n#define DR6_BT\t\t(1 << 15)\n#define DR6_RTM\t\t(1 << 16)\n/*\n * DR6_ACTIVE_LOW combines fixed-1 and active-low bits.\n * We can regard all the bits in DR6_FIXED_1 as active_low bits;\n * they will never be 0 for now, but when they are defined\n * in the future it will require no code change.\n *\n * DR6_ACTIVE_LOW is also used as the init/reset value for DR6.\n */\n#define DR6_ACTIVE_LOW\t0xffff0ff0\n#define DR6_VOLATILE\t0x0001e80f\n#define DR6_FIXED_1\t(DR6_ACTIVE_LOW & ~DR6_VOLATILE)\n\n#define DR7_BP_EN_MASK\t0x000000ff\n#define DR7_GE\t\t(1 << 9)\n#define DR7_GD\t\t(1 << 13)\n#define DR7_FIXED_1\t0x00000400\n#define DR7_VOLATILE\t0xffff2bff\n\n#define KVM_GUESTDBG_VALID_MASK \\\n\t(KVM_GUESTDBG_ENABLE | \\\n\tKVM_GUESTDBG_SINGLESTEP | \\\n\tKVM_GUESTDBG_USE_HW_BP | \\\n\tKVM_GUESTDBG_USE_SW_BP | \\\n\tKVM_GUESTDBG_INJECT_BP | \\\n\tKVM_GUESTDBG_INJECT_DB | \\\n\tKVM_GUESTDBG_BLOCKIRQ)\n\n\n#define PFERR_PRESENT_BIT 0\n#define PFERR_WRITE_BIT 1\n#define PFERR_USER_BIT 2\n#define PFERR_RSVD_BIT 3\n#define PFERR_FETCH_BIT 4\n#define PFERR_PK_BIT 5\n#define PFERR_SGX_BIT 15\n#define PFERR_GUEST_FINAL_BIT 32\n#define PFERR_GUEST_PAGE_BIT 33\n#define PFERR_IMPLICIT_ACCESS_BIT 48\n\n#define PFERR_PRESENT_MASK (1U << PFERR_PRESENT_BIT)\n#define PFERR_WRITE_MASK (1U << PFERR_WRITE_BIT)\n#define PFERR_USER_MASK (1U << PFERR_USER_BIT)\n#define PFERR_RSVD_MASK (1U << PFERR_RSVD_BIT)\n#define PFERR_FETCH_MASK (1U << PFERR_FETCH_BIT)\n#define PFERR_PK_MASK (1U << PFERR_PK_BIT)\n#define PFERR_SGX_MASK (1U << PFERR_SGX_BIT)\n#define PFERR_GUEST_FINAL_MASK (1ULL << PFERR_GUEST_FINAL_BIT)\n#define PFERR_GUEST_PAGE_MASK (1ULL << PFERR_GUEST_PAGE_BIT)\n#define PFERR_IMPLICIT_ACCESS (1ULL << PFERR_IMPLICIT_ACCESS_BIT)\n\n#define PFERR_NESTED_GUEST_PAGE (PFERR_GUEST_PAGE_MASK |\t\\\n\t\t\t\t PFERR_WRITE_MASK |\t\t\\\n\t\t\t\t PFERR_PRESENT_MASK)\n\n/* apic attention bits */\n#define KVM_APIC_CHECK_VAPIC\t0\n/*\n * The following bit is set with PV-EOI, unset on EOI.\n * We detect PV-EOI changes by guest by comparing\n * this bit with PV-EOI in guest memory.\n * See the implementation in apic_update_pv_eoi.\n */\n#define KVM_APIC_PV_EOI_PENDING\t1\n\nstruct kvm_kernel_irq_routing_entry;\n\n/*\n * kvm_mmu_page_role tracks the properties of a shadow page (where shadow page\n * also includes TDP pages) to determine whether or not a page can be used in\n * the given MMU context.  This is a subset of the overall kvm_cpu_role to\n * minimize the size of kvm_memory_slot.arch.gfn_track, i.e. allows allocating\n * 2 bytes per gfn instead of 4 bytes per gfn.\n *\n * Upper-level shadow pages having gptes are tracked for write-protection via\n * gfn_track.  As above, gfn_track is a 16 bit counter, so KVM must not create\n * more than 2^16-1 upper-level shadow pages at a single gfn, otherwise\n * gfn_track will overflow and explosions will ensure.\n *\n * A unique shadow page (SP) for a gfn is created if and only if an existing SP\n * cannot be reused.  The ability to reuse a SP is tracked by its role, which\n * incorporates various mode bits and properties of the SP.  Roughly speaking,\n * the number of unique SPs that can theoretically be created is 2^n, where n\n * is the number of bits that are used to compute the role.\n *\n * But, even though there are 19 bits in the mask below, not all combinations\n * of modes and flags are possible:\n *\n *   - invalid shadow pages are not accounted, so the bits are effectively 18\n *\n *   - quadrant will only be used if has_4_byte_gpte=1 (non-PAE paging);\n *     execonly and ad_disabled are only used for nested EPT which has\n *     has_4_byte_gpte=0.  Therefore, 2 bits are always unused.\n *\n *   - the 4 bits of level are effectively limited to the values 2/3/4/5,\n *     as 4k SPs are not tracked (allowed to go unsync).  In addition non-PAE\n *     paging has exactly one upper level, making level completely redundant\n *     when has_4_byte_gpte=1.\n *\n *   - on top of this, smep_andnot_wp and smap_andnot_wp are only set if\n *     cr0_wp=0, therefore these three bits only give rise to 5 possibilities.\n *\n * Therefore, the maximum number of possible upper-level shadow pages for a\n * single gfn is a bit less than 2^13.\n */\nunion kvm_mmu_page_role {\n\tu32 word;\n\tstruct {\n\t\tunsigned level:4;\n\t\tunsigned has_4_byte_gpte:1;\n\t\tunsigned quadrant:2;\n\t\tunsigned direct:1;\n\t\tunsigned access:3;\n\t\tunsigned invalid:1;\n\t\tunsigned efer_nx:1;\n\t\tunsigned cr0_wp:1;\n\t\tunsigned smep_andnot_wp:1;\n\t\tunsigned smap_andnot_wp:1;\n\t\tunsigned ad_disabled:1;\n\t\tunsigned guest_mode:1;\n\t\tunsigned passthrough:1;\n\t\tunsigned :5;\n\n\t\t/*\n\t\t * This is left at the top of the word so that\n\t\t * kvm_memslots_for_spte_role can extract it with a\n\t\t * simple shift.  While there is room, give it a whole\n\t\t * byte so it is also faster to load it from memory.\n\t\t */\n\t\tunsigned smm:8;\n\t};\n};\n\n/*\n * kvm_mmu_extended_role complements kvm_mmu_page_role, tracking properties\n * relevant to the current MMU configuration.   When loading CR0, CR4, or EFER,\n * including on nested transitions, if nothing in the full role changes then\n * MMU re-configuration can be skipped. @valid bit is set on first usage so we\n * don't treat all-zero structure as valid data.\n *\n * The properties that are tracked in the extended role but not the page role\n * are for things that either (a) do not affect the validity of the shadow page\n * or (b) are indirectly reflected in the shadow page's role.  For example,\n * CR4.PKE only affects permission checks for software walks of the guest page\n * tables (because KVM doesn't support Protection Keys with shadow paging), and\n * CR0.PG, CR4.PAE, and CR4.PSE are indirectly reflected in role.level.\n *\n * Note, SMEP and SMAP are not redundant with sm*p_andnot_wp in the page role.\n * If CR0.WP=1, KVM can reuse shadow pages for the guest regardless of SMEP and\n * SMAP, but the MMU's permission checks for software walks need to be SMEP and\n * SMAP aware regardless of CR0.WP.\n */\nunion kvm_mmu_extended_role {\n\tu32 word;\n\tstruct {\n\t\tunsigned int valid:1;\n\t\tunsigned int execonly:1;\n\t\tunsigned int cr4_pse:1;\n\t\tunsigned int cr4_pke:1;\n\t\tunsigned int cr4_smap:1;\n\t\tunsigned int cr4_smep:1;\n\t\tunsigned int cr4_la57:1;\n\t\tunsigned int efer_lma:1;\n\t};\n};\n\nunion kvm_cpu_role {\n\tu64 as_u64;\n\tstruct {\n\t\tunion kvm_mmu_page_role base;\n\t\tunion kvm_mmu_extended_role ext;\n\t};\n};\n\nstruct kvm_rmap_head {\n\tunsigned long val;\n};\n\nstruct kvm_pio_request {\n\tunsigned long linear_rip;\n\tunsigned long count;\n\tint in;\n\tint port;\n\tint size;\n};\n\n#define PT64_ROOT_MAX_LEVEL 5\n\nstruct rsvd_bits_validate {\n\tu64 rsvd_bits_mask[2][PT64_ROOT_MAX_LEVEL];\n\tu64 bad_mt_xwr;\n};\n\nstruct kvm_mmu_root_info {\n\tgpa_t pgd;\n\thpa_t hpa;\n};\n\n#define KVM_MMU_ROOT_INFO_INVALID \\\n\t((struct kvm_mmu_root_info) { .pgd = INVALID_PAGE, .hpa = INVALID_PAGE })\n\n#define KVM_MMU_NUM_PREV_ROOTS 3\n\n#define KVM_HAVE_MMU_RWLOCK\n\nstruct kvm_mmu_page;\nstruct kvm_page_fault;\n\n/*\n * x86 supports 4 paging modes (5-level 64-bit, 4-level 64-bit, 3-level 32-bit,\n * and 2-level 32-bit).  The kvm_mmu structure abstracts the details of the\n * current mmu mode.\n */\nstruct kvm_mmu {\n\tunsigned long (*get_guest_pgd)(struct kvm_vcpu *vcpu);\n\tu64 (*get_pdptr)(struct kvm_vcpu *vcpu, int index);\n\tint (*page_fault)(struct kvm_vcpu *vcpu, struct kvm_page_fault *fault);\n\tvoid (*inject_page_fault)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_exception *fault);\n\tgpa_t (*gva_to_gpa)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gpa_t gva_or_gpa, u64 access,\n\t\t\t    struct x86_exception *exception);\n\tint (*sync_page)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_mmu_page *sp);\n\tvoid (*invlpg)(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root_hpa);\n\tstruct kvm_mmu_root_info root;\n\tunion kvm_cpu_role cpu_role;\n\tunion kvm_mmu_page_role root_role;\n\n\t/*\n\t* The pkru_mask indicates if protection key checks are needed.  It\n\t* consists of 16 domains indexed by page fault error code bits [4:1],\n\t* with PFEC.RSVD replaced by ACC_USER_MASK from the page tables.\n\t* Each domain has 2 bits which are ANDed with AD and WD from PKRU.\n\t*/\n\tu32 pkru_mask;\n\n\tstruct kvm_mmu_root_info prev_roots[KVM_MMU_NUM_PREV_ROOTS];\n\n\t/*\n\t * Bitmap; bit set = permission fault\n\t * Byte index: page fault error code [4:1]\n\t * Bit index: pte permissions in ACC_* format\n\t */\n\tu8 permissions[16];\n\n\tu64 *pae_root;\n\tu64 *pml4_root;\n\tu64 *pml5_root;\n\n\t/*\n\t * check zero bits on shadow page table entries, these\n\t * bits include not only hardware reserved bits but also\n\t * the bits spte never used.\n\t */\n\tstruct rsvd_bits_validate shadow_zero_check;\n\n\tstruct rsvd_bits_validate guest_rsvd_check;\n\n\tu64 pdptrs[4]; /* pae */\n};\n\nstruct kvm_tlb_range {\n\tu64 start_gfn;\n\tu64 pages;\n};\n\nenum pmc_type {\n\tKVM_PMC_GP = 0,\n\tKVM_PMC_FIXED,\n};\n\nstruct kvm_pmc {\n\tenum pmc_type type;\n\tu8 idx;\n\tu64 counter;\n\tu64 eventsel;\n\tstruct perf_event *perf_event;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * eventsel value for general purpose counters,\n\t * ctrl value for fixed counters.\n\t */\n\tu64 current_config;\n\tbool is_paused;\n\tbool intr;\n};\n\n#define KVM_PMC_MAX_FIXED\t3\nstruct kvm_pmu {\n\tunsigned nr_arch_gp_counters;\n\tunsigned nr_arch_fixed_counters;\n\tunsigned available_event_types;\n\tu64 fixed_ctr_ctrl;\n\tu64 global_ctrl;\n\tu64 global_status;\n\tu64 counter_bitmask[2];\n\tu64 global_ctrl_mask;\n\tu64 global_ovf_ctrl_mask;\n\tu64 reserved_bits;\n\tu64 raw_event_mask;\n\tu8 version;\n\tstruct kvm_pmc gp_counters[INTEL_PMC_MAX_GENERIC];\n\tstruct kvm_pmc fixed_counters[KVM_PMC_MAX_FIXED];\n\tstruct irq_work irq_work;\n\tDECLARE_BITMAP(reprogram_pmi, X86_PMC_IDX_MAX);\n\tDECLARE_BITMAP(all_valid_pmc_idx, X86_PMC_IDX_MAX);\n\tDECLARE_BITMAP(pmc_in_use, X86_PMC_IDX_MAX);\n\n\t/*\n\t * The gate to release perf_events not marked in\n\t * pmc_in_use only once in a vcpu time slice.\n\t */\n\tbool need_cleanup;\n\n\t/*\n\t * The total number of programmed perf_events and it helps to avoid\n\t * redundant check before cleanup if guest don't use vPMU at all.\n\t */\n\tu8 event_count;\n};\n\nstruct kvm_pmu_ops;\n\nenum {\n\tKVM_DEBUGREG_BP_ENABLED = 1,\n\tKVM_DEBUGREG_WONT_EXIT = 2,\n};\n\nstruct kvm_mtrr_range {\n\tu64 base;\n\tu64 mask;\n\tstruct list_head node;\n};\n\nstruct kvm_mtrr {\n\tstruct kvm_mtrr_range var_ranges[KVM_NR_VAR_MTRR];\n\tmtrr_type fixed_ranges[KVM_NR_FIXED_MTRR_REGION];\n\tu64 deftype;\n\n\tstruct list_head head;\n};\n\n/* Hyper-V SynIC timer */\nstruct kvm_vcpu_hv_stimer {\n\tstruct hrtimer timer;\n\tint index;\n\tunion hv_stimer_config config;\n\tu64 count;\n\tu64 exp_time;\n\tstruct hv_message msg;\n\tbool msg_pending;\n};\n\n/* Hyper-V synthetic interrupt controller (SynIC)*/\nstruct kvm_vcpu_hv_synic {\n\tu64 version;\n\tu64 control;\n\tu64 msg_page;\n\tu64 evt_page;\n\tatomic64_t sint[HV_SYNIC_SINT_COUNT];\n\tatomic_t sint_to_gsi[HV_SYNIC_SINT_COUNT];\n\tDECLARE_BITMAP(auto_eoi_bitmap, 256);\n\tDECLARE_BITMAP(vec_bitmap, 256);\n\tbool active;\n\tbool dont_zero_synic_pages;\n};\n\n/* Hyper-V per vcpu emulation context */\nstruct kvm_vcpu_hv {\n\tstruct kvm_vcpu *vcpu;\n\tu32 vp_index;\n\tu64 hv_vapic;\n\ts64 runtime_offset;\n\tstruct kvm_vcpu_hv_synic synic;\n\tstruct kvm_hyperv_exit exit;\n\tstruct kvm_vcpu_hv_stimer stimer[HV_SYNIC_STIMER_COUNT];\n\tDECLARE_BITMAP(stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tbool enforce_cpuid;\n\tstruct {\n\t\tu32 features_eax; /* HYPERV_CPUID_FEATURES.EAX */\n\t\tu32 features_ebx; /* HYPERV_CPUID_FEATURES.EBX */\n\t\tu32 features_edx; /* HYPERV_CPUID_FEATURES.EDX */\n\t\tu32 enlightenments_eax; /* HYPERV_CPUID_ENLIGHTMENT_INFO.EAX */\n\t\tu32 enlightenments_ebx; /* HYPERV_CPUID_ENLIGHTMENT_INFO.EBX */\n\t\tu32 syndbg_cap_eax; /* HYPERV_CPUID_SYNDBG_PLATFORM_CAPABILITIES.EAX */\n\t} cpuid_cache;\n};\n\n/* Xen HVM per vcpu emulation context */\nstruct kvm_vcpu_xen {\n\tu64 hypercall_rip;\n\tu32 current_runstate;\n\tu8 upcall_vector;\n\tstruct gfn_to_pfn_cache vcpu_info_cache;\n\tstruct gfn_to_pfn_cache vcpu_time_info_cache;\n\tstruct gfn_to_pfn_cache runstate_cache;\n\tu64 last_steal;\n\tu64 runstate_entry_time;\n\tu64 runstate_times[4];\n\tunsigned long evtchn_pending_sel;\n\tu32 vcpu_id; /* The Xen / ACPI vCPU ID */\n\tu32 timer_virq;\n\tu64 timer_expires; /* In guest epoch */\n\tatomic_t timer_pending;\n\tstruct hrtimer timer;\n\tint poll_evtchn;\n\tstruct timer_list poll_timer;\n};\n\nstruct kvm_vcpu_arch {\n\t/*\n\t * rip and regs accesses must go through\n\t * kvm_{register,rip}_{read,write} functions.\n\t */\n\tunsigned long regs[NR_VCPU_REGS];\n\tu32 regs_avail;\n\tu32 regs_dirty;\n\n\tunsigned long cr0;\n\tunsigned long cr0_guest_owned_bits;\n\tunsigned long cr2;\n\tunsigned long cr3;\n\tunsigned long cr4;\n\tunsigned long cr4_guest_owned_bits;\n\tunsigned long cr4_guest_rsvd_bits;\n\tunsigned long cr8;\n\tu32 host_pkru;\n\tu32 pkru;\n\tu32 hflags;\n\tu64 efer;\n\tu64 apic_base;\n\tstruct kvm_lapic *apic;    /* kernel irqchip context */\n\tbool apicv_active;\n\tbool load_eoi_exitmap_pending;\n\tDECLARE_BITMAP(ioapic_handled_vectors, 256);\n\tunsigned long apic_attention;\n\tint32_t apic_arb_prio;\n\tint mp_state;\n\tu64 ia32_misc_enable_msr;\n\tu64 smbase;\n\tu64 smi_count;\n\tbool at_instruction_boundary;\n\tbool tpr_access_reporting;\n\tbool xsaves_enabled;\n\tbool xfd_no_write_intercept;\n\tu64 ia32_xss;\n\tu64 microcode_version;\n\tu64 arch_capabilities;\n\tu64 perf_capabilities;\n\n\t/*\n\t * Paging state of the vcpu\n\t *\n\t * If the vcpu runs in guest mode with two level paging this still saves\n\t * the paging mode of the l1 guest. This context is always used to\n\t * handle faults.\n\t */\n\tstruct kvm_mmu *mmu;\n\n\t/* Non-nested MMU for L1 */\n\tstruct kvm_mmu root_mmu;\n\n\t/* L1 MMU when running nested */\n\tstruct kvm_mmu guest_mmu;\n\n\t/*\n\t * Paging state of an L2 guest (used for nested npt)\n\t *\n\t * This context will save all necessary information to walk page tables\n\t * of an L2 guest. This context is only initialized for page table\n\t * walking and not for faulting since we never handle l2 page faults on\n\t * the host.\n\t */\n\tstruct kvm_mmu nested_mmu;\n\n\t/*\n\t * Pointer to the mmu context currently used for\n\t * gva_to_gpa translations.\n\t */\n\tstruct kvm_mmu *walk_mmu;\n\n\tstruct kvm_mmu_memory_cache mmu_pte_list_desc_cache;\n\tstruct kvm_mmu_memory_cache mmu_shadow_page_cache;\n\tstruct kvm_mmu_memory_cache mmu_gfn_array_cache;\n\tstruct kvm_mmu_memory_cache mmu_page_header_cache;\n\n\t/*\n\t * QEMU userspace and the guest each have their own FPU state.\n\t * In vcpu_run, we switch between the user and guest FPU contexts.\n\t * While running a VCPU, the VCPU thread will have the guest FPU\n\t * context.\n\t *\n\t * Note that while the PKRU state lives inside the fpu registers,\n\t * it is switched out separately at VMENTER and VMEXIT time. The\n\t * \"guest_fpstate\" state here contains the guest FPU context, with the\n\t * host PRKU bits.\n\t */\n\tstruct fpu_guest guest_fpu;\n\n\tu64 xcr0;\n\n\tstruct kvm_pio_request pio;\n\tvoid *pio_data;\n\tvoid *sev_pio_data;\n\tunsigned sev_pio_count;\n\n\tu8 event_exit_inst_len;\n\n\tstruct kvm_queued_exception {\n\t\tbool pending;\n\t\tbool injected;\n\t\tbool has_error_code;\n\t\tu8 nr;\n\t\tu32 error_code;\n\t\tunsigned long payload;\n\t\tbool has_payload;\n\t\tu8 nested_apf;\n\t} exception;\n\n\tstruct kvm_queued_interrupt {\n\t\tbool injected;\n\t\tbool soft;\n\t\tu8 nr;\n\t} interrupt;\n\n\tint halt_request; /* real mode on Intel only */\n\n\tint cpuid_nent;\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tu32 kvm_cpuid_base;\n\n\tu64 reserved_gpa_bits;\n\tint maxphyaddr;\n\n\t/* emulate context */\n\n\tstruct x86_emulate_ctxt *emulate_ctxt;\n\tbool emulate_regs_need_sync_to_vcpu;\n\tbool emulate_regs_need_sync_from_vcpu;\n\tint (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\n\tgpa_t time;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tunsigned int hw_tsc_khz;\n\tstruct gfn_to_pfn_cache pv_time;\n\t/* set guest stopped flag in pvclock flags field */\n\tbool pvclock_set_guest_stopped_request;\n\n\tstruct {\n\t\tu8 preempted;\n\t\tu64 msr_val;\n\t\tu64 last_steal;\n\t\tstruct gfn_to_hva_cache cache;\n\t} st;\n\n\tu64 l1_tsc_offset;\n\tu64 tsc_offset; /* current tsc offset */\n\tu64 last_guest_tsc;\n\tu64 last_host_tsc;\n\tu64 tsc_offset_adjustment;\n\tu64 this_tsc_nsec;\n\tu64 this_tsc_write;\n\tu64 this_tsc_generation;\n\tbool tsc_catchup;\n\tbool tsc_always_catchup;\n\ts8 virtual_tsc_shift;\n\tu32 virtual_tsc_mult;\n\tu32 virtual_tsc_khz;\n\ts64 ia32_tsc_adjust_msr;\n\tu64 msr_ia32_power_ctl;\n\tu64 l1_tsc_scaling_ratio;\n\tu64 tsc_scaling_ratio; /* current scaling ratio */\n\n\tatomic_t nmi_queued;  /* unprocessed asynchronous NMIs */\n\tunsigned nmi_pending; /* NMI queued after currently running handler */\n\tbool nmi_injected;    /* Trying to inject an NMI this entry */\n\tbool smi_pending;    /* SMI queued after currently running handler */\n\tu8 handling_intr_from_guest;\n\n\tstruct kvm_mtrr mtrr_state;\n\tu64 pat;\n\n\tunsigned switch_db_regs;\n\tunsigned long db[KVM_NR_DB_REGS];\n\tunsigned long dr6;\n\tunsigned long dr7;\n\tunsigned long eff_db[KVM_NR_DB_REGS];\n\tunsigned long guest_debug_dr7;\n\tu64 msr_platform_info;\n\tu64 msr_misc_features_enables;\n\n\tu64 mcg_cap;\n\tu64 mcg_status;\n\tu64 mcg_ctl;\n\tu64 mcg_ext_ctl;\n\tu64 *mce_banks;\n\n\t/* Cache MMIO info */\n\tu64 mmio_gva;\n\tunsigned mmio_access;\n\tgfn_t mmio_gfn;\n\tu64 mmio_gen;\n\n\tstruct kvm_pmu pmu;\n\n\t/* used for guest single stepping over the given code position */\n\tunsigned long singlestep_rip;\n\n\tbool hyperv_enabled;\n\tstruct kvm_vcpu_hv *hyperv;\n\tstruct kvm_vcpu_xen xen;\n\n\tcpumask_var_t wbinvd_dirty_mask;\n\n\tunsigned long last_retry_eip;\n\tunsigned long last_retry_addr;\n\n\tstruct {\n\t\tbool halted;\n\t\tgfn_t gfns[ASYNC_PF_PER_VCPU];\n\t\tstruct gfn_to_hva_cache data;\n\t\tu64 msr_en_val; /* MSR_KVM_ASYNC_PF_EN */\n\t\tu64 msr_int_val; /* MSR_KVM_ASYNC_PF_INT */\n\t\tu16 vec;\n\t\tu32 id;\n\t\tbool send_user_only;\n\t\tu32 host_apf_flags;\n\t\tunsigned long nested_apf_token;\n\t\tbool delivery_as_pf_vmexit;\n\t\tbool pageready_pending;\n\t} apf;\n\n\t/* OSVW MSRs (AMD only) */\n\tstruct {\n\t\tu64 length;\n\t\tu64 status;\n\t} osvw;\n\n\tstruct {\n\t\tu64 msr_val;\n\t\tstruct gfn_to_hva_cache data;\n\t} pv_eoi;\n\n\tu64 msr_kvm_poll_control;\n\n\t/*\n\t * Indicates the guest is trying to write a gfn that contains one or\n\t * more of the PTEs used to translate the write itself, i.e. the access\n\t * is changing its own translation in the guest page tables.  KVM exits\n\t * to userspace if emulation of the faulting instruction fails and this\n\t * flag is set, as KVM cannot make forward progress.\n\t *\n\t * If emulation fails for a write to guest page tables, KVM unprotects\n\t * (zaps) the shadow page for the target gfn and resumes the guest to\n\t * retry the non-emulatable instruction (on hardware).  Unprotecting the\n\t * gfn doesn't allow forward progress for a self-changing access because\n\t * doing so also zaps the translation for the gfn, i.e. retrying the\n\t * instruction will hit a !PRESENT fault, which results in a new shadow\n\t * page and sends KVM back to square one.\n\t */\n\tbool write_fault_to_shadow_pgtable;\n\n\t/* set at EPT violation at this point */\n\tunsigned long exit_qualification;\n\n\t/* pv related host specific info */\n\tstruct {\n\t\tbool pv_unhalted;\n\t} pv;\n\n\tint pending_ioapic_eoi;\n\tint pending_external_vector;\n\n\t/* be preempted when it's in kernel-mode(cpl=0) */\n\tbool preempted_in_kernel;\n\n\t/* Flush the L1 Data cache for L1TF mitigation on VMENTER */\n\tbool l1tf_flush_l1d;\n\n\t/* Host CPU on which VM-entry was most recently attempted */\n\tint last_vmentry_cpu;\n\n\t/* AMD MSRC001_0015 Hardware Configuration */\n\tu64 msr_hwcr;\n\n\t/* pv related cpuid info */\n\tstruct {\n\t\t/*\n\t\t * value of the eax register in the KVM_CPUID_FEATURES CPUID\n\t\t * leaf.\n\t\t */\n\t\tu32 features;\n\n\t\t/*\n\t\t * indicates whether pv emulation should be disabled if features\n\t\t * are not present in the guest's cpuid\n\t\t */\n\t\tbool enforce;\n\t} pv_cpuid;\n\n\t/* Protected Guests */\n\tbool guest_state_protected;\n\n\t/*\n\t * Set when PDPTS were loaded directly by the userspace without\n\t * reading the guest memory\n\t */\n\tbool pdptrs_from_userspace;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\thpa_t hv_root_tdp;\n#endif\n};\n\nstruct kvm_lpage_info {\n\tint disallow_lpage;\n};\n\nstruct kvm_arch_memory_slot {\n\tstruct kvm_rmap_head *rmap[KVM_NR_PAGE_SIZES];\n\tstruct kvm_lpage_info *lpage_info[KVM_NR_PAGE_SIZES - 1];\n\tunsigned short *gfn_track[KVM_PAGE_TRACK_MAX];\n};\n\n/*\n * We use as the mode the number of bits allocated in the LDR for the\n * logical processor ID.  It happens that these are all powers of two.\n * This makes it is very easy to detect cases where the APICs are\n * configured for multiple modes; in that case, we cannot use the map and\n * hence cannot use kvm_irq_delivery_to_apic_fast either.\n */\n#define KVM_APIC_MODE_XAPIC_CLUSTER          4\n#define KVM_APIC_MODE_XAPIC_FLAT             8\n#define KVM_APIC_MODE_X2APIC                16\n\nstruct kvm_apic_map {\n\tstruct rcu_head rcu;\n\tu8 mode;\n\tu32 max_apic_id;\n\tunion {\n\t\tstruct kvm_lapic *xapic_flat_map[8];\n\t\tstruct kvm_lapic *xapic_cluster_map[16][4];\n\t};\n\tstruct kvm_lapic *phys_map[];\n};\n\n/* Hyper-V synthetic debugger (SynDbg)*/\nstruct kvm_hv_syndbg {\n\tstruct {\n\t\tu64 control;\n\t\tu64 status;\n\t\tu64 send_page;\n\t\tu64 recv_page;\n\t\tu64 pending_page;\n\t} control;\n\tu64 options;\n};\n\n/* Current state of Hyper-V TSC page clocksource */\nenum hv_tsc_page_status {\n\t/* TSC page was not set up or disabled */\n\tHV_TSC_PAGE_UNSET = 0,\n\t/* TSC page MSR was written by the guest, update pending */\n\tHV_TSC_PAGE_GUEST_CHANGED,\n\t/* TSC page update was triggered from the host side */\n\tHV_TSC_PAGE_HOST_CHANGED,\n\t/* TSC page was properly set up and is currently active  */\n\tHV_TSC_PAGE_SET,\n\t/* TSC page was set up with an inaccessible GPA */\n\tHV_TSC_PAGE_BROKEN,\n};\n\n/* Hyper-V emulation context */\nstruct kvm_hv {\n\tstruct mutex hv_lock;\n\tu64 hv_guest_os_id;\n\tu64 hv_hypercall;\n\tu64 hv_tsc_page;\n\tenum hv_tsc_page_status hv_tsc_page_status;\n\n\t/* Hyper-v based guest crash (NT kernel bugcheck) parameters */\n\tu64 hv_crash_param[HV_X64_MSR_CRASH_PARAMS];\n\tu64 hv_crash_ctl;\n\n\tstruct ms_hyperv_tsc_page tsc_ref;\n\n\tstruct idr conn_to_evt;\n\n\tu64 hv_reenlightenment_control;\n\tu64 hv_tsc_emulation_control;\n\tu64 hv_tsc_emulation_status;\n\n\t/* How many vCPUs have VP index != vCPU index */\n\tatomic_t num_mismatched_vp_indexes;\n\n\t/*\n\t * How many SynICs use 'AutoEOI' feature\n\t * (protected by arch.apicv_update_lock)\n\t */\n\tunsigned int synic_auto_eoi_used;\n\n\tstruct hv_partition_assist_pg *hv_pa_pg;\n\tstruct kvm_hv_syndbg hv_syndbg;\n};\n\nstruct msr_bitmap_range {\n\tu32 flags;\n\tu32 nmsrs;\n\tu32 base;\n\tunsigned long *bitmap;\n};\n\n/* Xen emulation context */\nstruct kvm_xen {\n\tu32 xen_version;\n\tbool long_mode;\n\tu8 upcall_vector;\n\tstruct gfn_to_pfn_cache shinfo_cache;\n\tstruct idr evtchn_ports;\n\tunsigned long poll_mask[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n};\n\nenum kvm_irqchip_mode {\n\tKVM_IRQCHIP_NONE,\n\tKVM_IRQCHIP_KERNEL,       /* created with KVM_CREATE_IRQCHIP */\n\tKVM_IRQCHIP_SPLIT,        /* created with KVM_CAP_SPLIT_IRQCHIP */\n};\n\nstruct kvm_x86_msr_filter {\n\tu8 count;\n\tbool default_allow:1;\n\tstruct msr_bitmap_range ranges[16];\n};\n\nenum kvm_apicv_inhibit {\n\tAPICV_INHIBIT_REASON_DISABLE,\n\tAPICV_INHIBIT_REASON_HYPERV,\n\tAPICV_INHIBIT_REASON_NESTED,\n\tAPICV_INHIBIT_REASON_IRQWIN,\n\tAPICV_INHIBIT_REASON_PIT_REINJ,\n\tAPICV_INHIBIT_REASON_X2APIC,\n\tAPICV_INHIBIT_REASON_BLOCKIRQ,\n\tAPICV_INHIBIT_REASON_ABSENT,\n\tAPICV_INHIBIT_REASON_SEV,\n};\n\nstruct kvm_arch {\n\tunsigned long n_used_mmu_pages;\n\tunsigned long n_requested_mmu_pages;\n\tunsigned long n_max_mmu_pages;\n\tunsigned int indirect_shadow_pages;\n\tu8 mmu_valid_gen;\n\tstruct hlist_head mmu_page_hash[KVM_NUM_MMU_PAGES];\n\tstruct list_head active_mmu_pages;\n\tstruct list_head zapped_obsolete_pages;\n\tstruct list_head lpage_disallowed_mmu_pages;\n\tstruct kvm_page_track_notifier_node mmu_sp_tracker;\n\tstruct kvm_page_track_notifier_head track_notifier_head;\n\t/*\n\t * Protects marking pages unsync during page faults, as TDP MMU page\n\t * faults only take mmu_lock for read.  For simplicity, the unsync\n\t * pages lock is always taken when marking pages unsync regardless of\n\t * whether mmu_lock is held for read or write.\n\t */\n\tspinlock_t mmu_unsync_pages_lock;\n\n\tstruct list_head assigned_dev_head;\n\tstruct iommu_domain *iommu_domain;\n\tbool iommu_noncoherent;\n#define __KVM_HAVE_ARCH_NONCOHERENT_DMA\n\tatomic_t noncoherent_dma_count;\n#define __KVM_HAVE_ARCH_ASSIGNED_DEVICE\n\tatomic_t assigned_device_count;\n\tstruct kvm_pic *vpic;\n\tstruct kvm_ioapic *vioapic;\n\tstruct kvm_pit *vpit;\n\tatomic_t vapics_in_nmi_mode;\n\tstruct mutex apic_map_lock;\n\tstruct kvm_apic_map __rcu *apic_map;\n\tatomic_t apic_map_dirty;\n\n\t/* Protects apic_access_memslot_enabled and apicv_inhibit_reasons */\n\tstruct rw_semaphore apicv_update_lock;\n\n\tbool apic_access_memslot_enabled;\n\tunsigned long apicv_inhibit_reasons;\n\n\tgpa_t wall_clock;\n\n\tbool mwait_in_guest;\n\tbool hlt_in_guest;\n\tbool pause_in_guest;\n\tbool cstate_in_guest;\n\n\tunsigned long irq_sources_bitmap;\n\ts64 kvmclock_offset;\n\n\t/*\n\t * This also protects nr_vcpus_matched_tsc which is read from a\n\t * preemption-disabled region, so it must be a raw spinlock.\n\t */\n\traw_spinlock_t tsc_write_lock;\n\tu64 last_tsc_nsec;\n\tu64 last_tsc_write;\n\tu32 last_tsc_khz;\n\tu64 last_tsc_offset;\n\tu64 cur_tsc_nsec;\n\tu64 cur_tsc_write;\n\tu64 cur_tsc_offset;\n\tu64 cur_tsc_generation;\n\tint nr_vcpus_matched_tsc;\n\n\tu32 default_tsc_khz;\n\n\tseqcount_raw_spinlock_t pvclock_sc;\n\tbool use_master_clock;\n\tu64 master_kernel_ns;\n\tu64 master_cycle_now;\n\tstruct delayed_work kvmclock_update_work;\n\tstruct delayed_work kvmclock_sync_work;\n\n\tstruct kvm_xen_hvm_config xen_hvm_config;\n\n\t/* reads protected by irq_srcu, writes by irq_lock */\n\tstruct hlist_head mask_notifier_list;\n\n\tstruct kvm_hv hyperv;\n\tstruct kvm_xen xen;\n\n\tbool backwards_tsc_observed;\n\tbool boot_vcpu_runs_old_kvmclock;\n\tu32 bsp_vcpu_id;\n\n\tu64 disabled_quirks;\n\tint cpu_dirty_logging_count;\n\n\tenum kvm_irqchip_mode irqchip_mode;\n\tu8 nr_reserved_ioapic_pins;\n\n\tbool disabled_lapic_found;\n\n\tbool x2apic_format;\n\tbool x2apic_broadcast_quirk_disabled;\n\n\tbool guest_can_read_msr_platform_info;\n\tbool exception_payload_enabled;\n\n\tbool bus_lock_detection_enabled;\n\tbool enable_pmu;\n\t/*\n\t * If exit_on_emulation_error is set, and the in-kernel instruction\n\t * emulator fails to emulate an instruction, allow userspace\n\t * the opportunity to look at it.\n\t */\n\tbool exit_on_emulation_error;\n\n\t/* Deflect RDMSR and WRMSR to user space when they trigger a #GP */\n\tu32 user_space_msr_mask;\n\tstruct kvm_x86_msr_filter __rcu *msr_filter;\n\n\tu32 hypercall_exit_enabled;\n\n\t/* Guest can access the SGX PROVISIONKEY. */\n\tbool sgx_provisioning_allowed;\n\n\tstruct kvm_pmu_event_filter __rcu *pmu_event_filter;\n\tstruct task_struct *nx_lpage_recovery_thread;\n\n#ifdef CONFIG_X86_64\n\t/*\n\t * Whether the TDP MMU is enabled for this VM. This contains a\n\t * snapshot of the TDP MMU module parameter from when the VM was\n\t * created and remains unchanged for the life of the VM. If this is\n\t * true, TDP MMU handler functions will run for various MMU\n\t * operations.\n\t */\n\tbool tdp_mmu_enabled;\n\n\t/*\n\t * List of struct kvm_mmu_pages being used as roots.\n\t * All struct kvm_mmu_pages in the list should have\n\t * tdp_mmu_page set.\n\t *\n\t * For reads, this list is protected by:\n\t *\tthe MMU lock in read mode + RCU or\n\t *\tthe MMU lock in write mode\n\t *\n\t * For writes, this list is protected by:\n\t *\tthe MMU lock in read mode + the tdp_mmu_pages_lock or\n\t *\tthe MMU lock in write mode\n\t *\n\t * Roots will remain in the list until their tdp_mmu_root_count\n\t * drops to zero, at which point the thread that decremented the\n\t * count to zero should removed the root from the list and clean\n\t * it up, freeing the root after an RCU grace period.\n\t */\n\tstruct list_head tdp_mmu_roots;\n\n\t/*\n\t * List of struct kvmp_mmu_pages not being used as roots.\n\t * All struct kvm_mmu_pages in the list should have\n\t * tdp_mmu_page set and a tdp_mmu_root_count of 0.\n\t */\n\tstruct list_head tdp_mmu_pages;\n\n\t/*\n\t * Protects accesses to the following fields when the MMU lock\n\t * is held in read mode:\n\t *  - tdp_mmu_roots (above)\n\t *  - tdp_mmu_pages (above)\n\t *  - the link field of struct kvm_mmu_pages used by the TDP MMU\n\t *  - lpage_disallowed_mmu_pages\n\t *  - the lpage_disallowed_link field of struct kvm_mmu_pages used\n\t *    by the TDP MMU\n\t * It is acceptable, but not necessary, to acquire this lock when\n\t * the thread holds the MMU lock in write mode.\n\t */\n\tspinlock_t tdp_mmu_pages_lock;\n\tstruct workqueue_struct *tdp_mmu_zap_wq;\n#endif /* CONFIG_X86_64 */\n\n\t/*\n\t * If set, at least one shadow root has been allocated. This flag\n\t * is used as one input when determining whether certain memslot\n\t * related allocations are necessary.\n\t */\n\tbool shadow_root_allocated;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\thpa_t\thv_root_tdp;\n\tspinlock_t hv_root_tdp_lock;\n#endif\n};\n\nstruct kvm_vm_stat {\n\tstruct kvm_vm_stat_generic generic;\n\tu64 mmu_shadow_zapped;\n\tu64 mmu_pte_write;\n\tu64 mmu_pde_zapped;\n\tu64 mmu_flooded;\n\tu64 mmu_recycled;\n\tu64 mmu_cache_miss;\n\tu64 mmu_unsync;\n\tunion {\n\t\tstruct {\n\t\t\tatomic64_t pages_4k;\n\t\t\tatomic64_t pages_2m;\n\t\t\tatomic64_t pages_1g;\n\t\t};\n\t\tatomic64_t pages[KVM_NR_PAGE_SIZES];\n\t};\n\tu64 nx_lpage_splits;\n\tu64 max_mmu_page_hash_collisions;\n\tu64 max_mmu_rmap_size;\n};\n\nstruct kvm_vcpu_stat {\n\tstruct kvm_vcpu_stat_generic generic;\n\tu64 pf_taken;\n\tu64 pf_fixed;\n\tu64 pf_emulate;\n\tu64 pf_spurious;\n\tu64 pf_fast;\n\tu64 pf_mmio_spte_created;\n\tu64 pf_guest;\n\tu64 tlb_flush;\n\tu64 invlpg;\n\n\tu64 exits;\n\tu64 io_exits;\n\tu64 mmio_exits;\n\tu64 signal_exits;\n\tu64 irq_window_exits;\n\tu64 nmi_window_exits;\n\tu64 l1d_flush;\n\tu64 halt_exits;\n\tu64 request_irq_exits;\n\tu64 irq_exits;\n\tu64 host_state_reload;\n\tu64 fpu_reload;\n\tu64 insn_emulation;\n\tu64 insn_emulation_fail;\n\tu64 hypercalls;\n\tu64 irq_injections;\n\tu64 nmi_injections;\n\tu64 req_event;\n\tu64 nested_run;\n\tu64 directed_yield_attempted;\n\tu64 directed_yield_successful;\n\tu64 preemption_reported;\n\tu64 preemption_other;\n\tu64 guest_mode;\n};\n\nstruct x86_instruction_info;\n\nstruct msr_data {\n\tbool host_initiated;\n\tu32 index;\n\tu64 data;\n};\n\nstruct kvm_lapic_irq {\n\tu32 vector;\n\tu16 delivery_mode;\n\tu16 dest_mode;\n\tbool level;\n\tu16 trig_mode;\n\tu32 shorthand;\n\tu32 dest_id;\n\tbool msi_redir_hint;\n};\n\nstatic inline u16 kvm_lapic_irq_dest_mode(bool dest_mode_logical)\n{\n\treturn dest_mode_logical ? APIC_DEST_LOGICAL : APIC_DEST_PHYSICAL;\n}\n\nstruct kvm_x86_ops {\n\tconst char *name;\n\n\tint (*hardware_enable)(void);\n\tvoid (*hardware_disable)(void);\n\tvoid (*hardware_unsetup)(void);\n\tbool (*has_emulated_msr)(struct kvm *kvm, u32 index);\n\tvoid (*vcpu_after_set_cpuid)(struct kvm_vcpu *vcpu);\n\n\tunsigned int vm_size;\n\tint (*vm_init)(struct kvm *kvm);\n\tvoid (*vm_destroy)(struct kvm *kvm);\n\n\t/* Create, but do not attach this VCPU */\n\tint (*vcpu_create)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_free)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_reset)(struct kvm_vcpu *vcpu, bool init_event);\n\n\tvoid (*prepare_switch_to_guest)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_load)(struct kvm_vcpu *vcpu, int cpu);\n\tvoid (*vcpu_put)(struct kvm_vcpu *vcpu);\n\n\tvoid (*update_exception_bitmap)(struct kvm_vcpu *vcpu);\n\tint (*get_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\tint (*set_msr)(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\tu64 (*get_segment_base)(struct kvm_vcpu *vcpu, int seg);\n\tvoid (*get_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tint (*get_cpl)(struct kvm_vcpu *vcpu);\n\tvoid (*set_segment)(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg);\n\tvoid (*get_cs_db_l_bits)(struct kvm_vcpu *vcpu, int *db, int *l);\n\tvoid (*set_cr0)(struct kvm_vcpu *vcpu, unsigned long cr0);\n\tvoid (*post_set_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);\n\tbool (*is_valid_cr4)(struct kvm_vcpu *vcpu, unsigned long cr0);\n\tvoid (*set_cr4)(struct kvm_vcpu *vcpu, unsigned long cr4);\n\tint (*set_efer)(struct kvm_vcpu *vcpu, u64 efer);\n\tvoid (*get_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_idt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*get_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*set_gdt)(struct kvm_vcpu *vcpu, struct desc_ptr *dt);\n\tvoid (*sync_dirty_debug_regs)(struct kvm_vcpu *vcpu);\n\tvoid (*set_dr7)(struct kvm_vcpu *vcpu, unsigned long value);\n\tvoid (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);\n\tunsigned long (*get_rflags)(struct kvm_vcpu *vcpu);\n\tvoid (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);\n\tbool (*get_if_flag)(struct kvm_vcpu *vcpu);\n\n\tvoid (*flush_tlb_all)(struct kvm_vcpu *vcpu);\n\tvoid (*flush_tlb_current)(struct kvm_vcpu *vcpu);\n\tint  (*tlb_remote_flush)(struct kvm *kvm);\n\tint  (*tlb_remote_flush_with_range)(struct kvm *kvm,\n\t\t\tstruct kvm_tlb_range *range);\n\n\t/*\n\t * Flush any TLB entries associated with the given GVA.\n\t * Does not need to flush GPA->HPA mappings.\n\t * Can potentially get non-canonical addresses through INVLPGs, which\n\t * the implementation may choose to ignore if appropriate.\n\t */\n\tvoid (*flush_tlb_gva)(struct kvm_vcpu *vcpu, gva_t addr);\n\n\t/*\n\t * Flush any TLB entries created by the guest.  Like tlb_flush_gva(),\n\t * does not need to flush GPA->HPA mappings.\n\t */\n\tvoid (*flush_tlb_guest)(struct kvm_vcpu *vcpu);\n\n\tint (*vcpu_pre_run)(struct kvm_vcpu *vcpu);\n\tenum exit_fastpath_completion (*vcpu_run)(struct kvm_vcpu *vcpu);\n\tint (*handle_exit)(struct kvm_vcpu *vcpu,\n\t\tenum exit_fastpath_completion exit_fastpath);\n\tint (*skip_emulated_instruction)(struct kvm_vcpu *vcpu);\n\tvoid (*update_emulated_instruction)(struct kvm_vcpu *vcpu);\n\tvoid (*set_interrupt_shadow)(struct kvm_vcpu *vcpu, int mask);\n\tu32 (*get_interrupt_shadow)(struct kvm_vcpu *vcpu);\n\tvoid (*patch_hypercall)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned char *hypercall_addr);\n\tvoid (*inject_irq)(struct kvm_vcpu *vcpu);\n\tvoid (*inject_nmi)(struct kvm_vcpu *vcpu);\n\tvoid (*queue_exception)(struct kvm_vcpu *vcpu);\n\tvoid (*cancel_injection)(struct kvm_vcpu *vcpu);\n\tint (*interrupt_allowed)(struct kvm_vcpu *vcpu, bool for_injection);\n\tint (*nmi_allowed)(struct kvm_vcpu *vcpu, bool for_injection);\n\tbool (*get_nmi_mask)(struct kvm_vcpu *vcpu);\n\tvoid (*set_nmi_mask)(struct kvm_vcpu *vcpu, bool masked);\n\tvoid (*enable_nmi_window)(struct kvm_vcpu *vcpu);\n\tvoid (*enable_irq_window)(struct kvm_vcpu *vcpu);\n\tvoid (*update_cr8_intercept)(struct kvm_vcpu *vcpu, int tpr, int irr);\n\tbool (*check_apicv_inhibit_reasons)(enum kvm_apicv_inhibit reason);\n\tvoid (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *vcpu);\n\tvoid (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);\n\tvoid (*hwapic_isr_update)(struct kvm_vcpu *vcpu, int isr);\n\tbool (*guest_apic_has_interrupt)(struct kvm_vcpu *vcpu);\n\tvoid (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);\n\tvoid (*set_virtual_apic_mode)(struct kvm_vcpu *vcpu);\n\tvoid (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu);\n\tvoid (*deliver_interrupt)(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t\t  int trig_mode, int vector);\n\tint (*sync_pir_to_irr)(struct kvm_vcpu *vcpu);\n\tint (*set_tss_addr)(struct kvm *kvm, unsigned int addr);\n\tint (*set_identity_map_addr)(struct kvm *kvm, u64 ident_addr);\n\tu64 (*get_mt_mask)(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio);\n\n\tvoid (*load_mmu_pgd)(struct kvm_vcpu *vcpu, hpa_t root_hpa,\n\t\t\t     int root_level);\n\n\tbool (*has_wbinvd_exit)(void);\n\n\tu64 (*get_l2_tsc_offset)(struct kvm_vcpu *vcpu);\n\tu64 (*get_l2_tsc_multiplier)(struct kvm_vcpu *vcpu);\n\tvoid (*write_tsc_offset)(struct kvm_vcpu *vcpu, u64 offset);\n\tvoid (*write_tsc_multiplier)(struct kvm_vcpu *vcpu, u64 multiplier);\n\n\t/*\n\t * Retrieve somewhat arbitrary exit information.  Intended to\n\t * be used only from within tracepoints or error paths.\n\t */\n\tvoid (*get_exit_info)(struct kvm_vcpu *vcpu, u32 *reason,\n\t\t\t      u64 *info1, u64 *info2,\n\t\t\t      u32 *exit_int_info, u32 *exit_int_info_err_code);\n\n\tint (*check_intercept)(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception);\n\tvoid (*handle_exit_irqoff)(struct kvm_vcpu *vcpu);\n\n\tvoid (*request_immediate_exit)(struct kvm_vcpu *vcpu);\n\n\tvoid (*sched_in)(struct kvm_vcpu *kvm, int cpu);\n\n\t/*\n\t * Size of the CPU's dirty log buffer, i.e. VMX's PML buffer.  A zero\n\t * value indicates CPU dirty logging is unsupported or disabled.\n\t */\n\tint cpu_dirty_log_size;\n\tvoid (*update_cpu_dirty_logging)(struct kvm_vcpu *vcpu);\n\n\tconst struct kvm_x86_nested_ops *nested_ops;\n\n\tvoid (*vcpu_blocking)(struct kvm_vcpu *vcpu);\n\tvoid (*vcpu_unblocking)(struct kvm_vcpu *vcpu);\n\n\tint (*pi_update_irte)(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set);\n\tvoid (*pi_start_assignment)(struct kvm *kvm);\n\tvoid (*apicv_post_state_restore)(struct kvm_vcpu *vcpu);\n\tbool (*dy_apicv_has_pending_interrupt)(struct kvm_vcpu *vcpu);\n\n\tint (*set_hv_timer)(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,\n\t\t\t    bool *expired);\n\tvoid (*cancel_hv_timer)(struct kvm_vcpu *vcpu);\n\n\tvoid (*setup_mce)(struct kvm_vcpu *vcpu);\n\n\tint (*smi_allowed)(struct kvm_vcpu *vcpu, bool for_injection);\n\tint (*enter_smm)(struct kvm_vcpu *vcpu, char *smstate);\n\tint (*leave_smm)(struct kvm_vcpu *vcpu, const char *smstate);\n\tvoid (*enable_smi_window)(struct kvm_vcpu *vcpu);\n\n\tint (*mem_enc_ioctl)(struct kvm *kvm, void __user *argp);\n\tint (*mem_enc_register_region)(struct kvm *kvm, struct kvm_enc_region *argp);\n\tint (*mem_enc_unregister_region)(struct kvm *kvm, struct kvm_enc_region *argp);\n\tint (*vm_copy_enc_context_from)(struct kvm *kvm, unsigned int source_fd);\n\tint (*vm_move_enc_context_from)(struct kvm *kvm, unsigned int source_fd);\n\tvoid (*guest_memory_reclaimed)(struct kvm *kvm);\n\n\tint (*get_msr_feature)(struct kvm_msr_entry *entry);\n\n\tbool (*can_emulate_instruction)(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\t\tvoid *insn, int insn_len);\n\n\tbool (*apic_init_signal_blocked)(struct kvm_vcpu *vcpu);\n\tint (*enable_direct_tlbflush)(struct kvm_vcpu *vcpu);\n\n\tvoid (*migrate_timers)(struct kvm_vcpu *vcpu);\n\tvoid (*msr_filter_changed)(struct kvm_vcpu *vcpu);\n\tint (*complete_emulated_msr)(struct kvm_vcpu *vcpu, int err);\n\n\tvoid (*vcpu_deliver_sipi_vector)(struct kvm_vcpu *vcpu, u8 vector);\n\n\t/*\n\t * Returns vCPU specific APICv inhibit reasons\n\t */\n\tunsigned long (*vcpu_get_apicv_inhibit_reasons)(struct kvm_vcpu *vcpu);\n};\n\nstruct kvm_x86_nested_ops {\n\tvoid (*leave_nested)(struct kvm_vcpu *vcpu);\n\tint (*check_events)(struct kvm_vcpu *vcpu);\n\tbool (*handle_page_fault_workaround)(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct x86_exception *fault);\n\tbool (*hv_timer_pending)(struct kvm_vcpu *vcpu);\n\tvoid (*triple_fault)(struct kvm_vcpu *vcpu);\n\tint (*get_state)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_nested_state __user *user_kvm_nested_state,\n\t\t\t unsigned user_data_size);\n\tint (*set_state)(struct kvm_vcpu *vcpu,\n\t\t\t struct kvm_nested_state __user *user_kvm_nested_state,\n\t\t\t struct kvm_nested_state *kvm_state);\n\tbool (*get_nested_state_pages)(struct kvm_vcpu *vcpu);\n\tint (*write_log_dirty)(struct kvm_vcpu *vcpu, gpa_t l2_gpa);\n\n\tint (*enable_evmcs)(struct kvm_vcpu *vcpu,\n\t\t\t    uint16_t *vmcs_version);\n\tuint16_t (*get_evmcs_version)(struct kvm_vcpu *vcpu);\n};\n\nstruct kvm_x86_init_ops {\n\tint (*cpu_has_kvm_support)(void);\n\tint (*disabled_by_bios)(void);\n\tint (*check_processor_compatibility)(void);\n\tint (*hardware_setup)(void);\n\tunsigned int (*handle_intel_pt_intr)(void);\n\n\tstruct kvm_x86_ops *runtime_ops;\n\tstruct kvm_pmu_ops *pmu_ops;\n};\n\nstruct kvm_arch_async_pf {\n\tu32 token;\n\tgfn_t gfn;\n\tunsigned long cr3;\n\tbool direct_map;\n};\n\nextern u32 __read_mostly kvm_nr_uret_msrs;\nextern u64 __read_mostly host_efer;\nextern bool __read_mostly allow_smaller_maxphyaddr;\nextern bool __read_mostly enable_apicv;\nextern struct kvm_x86_ops kvm_x86_ops;\n\n#define KVM_X86_OP(func) \\\n\tDECLARE_STATIC_CALL(kvm_x86_##func, *(((struct kvm_x86_ops *)0)->func));\n#define KVM_X86_OP_OPTIONAL KVM_X86_OP\n#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP\n#include <asm/kvm-x86-ops.h>\n\n#define __KVM_HAVE_ARCH_VM_ALLOC\nstatic inline struct kvm *kvm_arch_alloc_vm(void)\n{\n\treturn __vmalloc(kvm_x86_ops.vm_size, GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n}\n\n#define __KVM_HAVE_ARCH_VM_FREE\nvoid kvm_arch_free_vm(struct kvm *kvm);\n\n#define __KVM_HAVE_ARCH_FLUSH_REMOTE_TLB\nstatic inline int kvm_arch_flush_remote_tlb(struct kvm *kvm)\n{\n\tif (kvm_x86_ops.tlb_remote_flush &&\n\t    !static_call(kvm_x86_tlb_remote_flush)(kvm))\n\t\treturn 0;\n\telse\n\t\treturn -ENOTSUPP;\n}\n\n#define kvm_arch_pmi_in_guest(vcpu) \\\n\t((vcpu) && (vcpu)->arch.handling_intr_from_guest)\n\nvoid kvm_mmu_x86_module_init(void);\nint kvm_mmu_vendor_module_init(void);\nvoid kvm_mmu_vendor_module_exit(void);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu);\nint kvm_mmu_create(struct kvm_vcpu *vcpu);\nint kvm_mmu_init_vm(struct kvm *kvm);\nvoid kvm_mmu_uninit_vm(struct kvm *kvm);\n\nvoid kvm_mmu_after_set_cpuid(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu);\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      const struct kvm_memory_slot *memslot,\n\t\t\t\t      int start_level);\nvoid kvm_mmu_slot_try_split_huge_pages(struct kvm *kvm,\n\t\t\t\t       const struct kvm_memory_slot *memslot,\n\t\t\t\t       int target_level);\nvoid kvm_mmu_try_split_huge_pages(struct kvm *kvm,\n\t\t\t\t  const struct kvm_memory_slot *memslot,\n\t\t\t\t  u64 start, u64 end,\n\t\t\t\t  int target_level);\nvoid kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot);\nvoid kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot);\nvoid kvm_mmu_zap_all(struct kvm *kvm);\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, u64 gen);\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned long kvm_nr_mmu_pages);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3);\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes);\n\nstruct kvm_irq_mask_notifier {\n\tvoid (*func)(struct kvm_irq_mask_notifier *kimn, bool masked);\n\tint irq;\n\tstruct hlist_node link;\n};\n\nvoid kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn);\nvoid kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn);\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask);\n\nextern bool tdp_enabled;\n\nu64 vcpu_tsc_khz(struct kvm_vcpu *vcpu);\n\n/* control of guest tsc rate supported? */\nextern bool kvm_has_tsc_control;\n/* maximum supported tsc_khz for guests */\nextern u32  kvm_max_guest_tsc_khz;\n/* number of bits of the fractional part of the TSC scaling ratio */\nextern u8   kvm_tsc_scaling_ratio_frac_bits;\n/* maximum allowed value of TSC scaling ratio */\nextern u64  kvm_max_tsc_scaling_ratio;\n/* 1ull << kvm_tsc_scaling_ratio_frac_bits */\nextern u64  kvm_default_tsc_scaling_ratio;\n/* bus lock detection supported? */\nextern bool kvm_has_bus_lock_exit;\n\nextern u64 kvm_mce_cap_supported;\n\n/*\n * EMULTYPE_NO_DECODE - Set when re-emulating an instruction (after completing\n *\t\t\tuserspace I/O) to indicate that the emulation context\n *\t\t\tshould be reused as is, i.e. skip initialization of\n *\t\t\temulation context, instruction fetch and decode.\n *\n * EMULTYPE_TRAP_UD - Set when emulating an intercepted #UD from hardware.\n *\t\t      Indicates that only select instructions (tagged with\n *\t\t      EmulateOnUD) should be emulated (to minimize the emulator\n *\t\t      attack surface).  See also EMULTYPE_TRAP_UD_FORCED.\n *\n * EMULTYPE_SKIP - Set when emulating solely to skip an instruction, i.e. to\n *\t\t   decode the instruction length.  For use *only* by\n *\t\t   kvm_x86_ops.skip_emulated_instruction() implementations if\n *\t\t   EMULTYPE_COMPLETE_USER_EXIT is not set.\n *\n * EMULTYPE_ALLOW_RETRY_PF - Set when the emulator should resume the guest to\n *\t\t\t     retry native execution under certain conditions,\n *\t\t\t     Can only be set in conjunction with EMULTYPE_PF.\n *\n * EMULTYPE_TRAP_UD_FORCED - Set when emulating an intercepted #UD that was\n *\t\t\t     triggered by KVM's magic \"force emulation\" prefix,\n *\t\t\t     which is opt in via module param (off by default).\n *\t\t\t     Bypasses EmulateOnUD restriction despite emulating\n *\t\t\t     due to an intercepted #UD (see EMULTYPE_TRAP_UD).\n *\t\t\t     Used to test the full emulator from userspace.\n *\n * EMULTYPE_VMWARE_GP - Set when emulating an intercepted #GP for VMware\n *\t\t\tbackdoor emulation, which is opt in via module param.\n *\t\t\tVMware backdoor emulation handles select instructions\n *\t\t\tand reinjects the #GP for all other cases.\n *\n * EMULTYPE_PF - Set when emulating MMIO by way of an intercepted #PF, in which\n *\t\t case the CR2/GPA value pass on the stack is valid.\n *\n * EMULTYPE_COMPLETE_USER_EXIT - Set when the emulator should update interruptibility\n *\t\t\t\t state and inject single-step #DBs after skipping\n *\t\t\t\t an instruction (after completing userspace I/O).\n */\n#define EMULTYPE_NO_DECODE\t    (1 << 0)\n#define EMULTYPE_TRAP_UD\t    (1 << 1)\n#define EMULTYPE_SKIP\t\t    (1 << 2)\n#define EMULTYPE_ALLOW_RETRY_PF\t    (1 << 3)\n#define EMULTYPE_TRAP_UD_FORCED\t    (1 << 4)\n#define EMULTYPE_VMWARE_GP\t    (1 << 5)\n#define EMULTYPE_PF\t\t    (1 << 6)\n#define EMULTYPE_COMPLETE_USER_EXIT (1 << 7)\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type);\nint kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,\n\t\t\t\t\tvoid *insn, int insn_len);\nvoid __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  u64 *data, u8 ndata);\nvoid kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu);\n\nvoid kvm_enable_efer_bits(u64);\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer);\nint __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data, bool host_initiated);\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data);\nint kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data);\nint kvm_emulate_rdmsr(struct kvm_vcpu *vcpu);\nint kvm_emulate_wrmsr(struct kvm_vcpu *vcpu);\nint kvm_emulate_as_nop(struct kvm_vcpu *vcpu);\nint kvm_emulate_invd(struct kvm_vcpu *vcpu);\nint kvm_emulate_mwait(struct kvm_vcpu *vcpu);\nint kvm_handle_invalid_op(struct kvm_vcpu *vcpu);\nint kvm_emulate_monitor(struct kvm_vcpu *vcpu);\n\nint kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in);\nint kvm_emulate_cpuid(struct kvm_vcpu *vcpu);\nint kvm_emulate_halt(struct kvm_vcpu *vcpu);\nint kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu);\nint kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu);\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu);\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg);\nint kvm_load_segment_descriptor(struct kvm_vcpu *vcpu, u16 selector, int seg);\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code);\n\nvoid kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0);\nvoid kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4);\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0);\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3);\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4);\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8);\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val);\nvoid kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val);\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu);\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw);\nint kvm_emulate_xsetbv(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu);\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nint kvm_emulate_rdpmc(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr, unsigned long payload);\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr);\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault);\nbool kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct x86_exception *fault);\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl);\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr);\n\nstatic inline int __kvm_irq_line_state(unsigned long *irq_state,\n\t\t\t\t       int irq_source_id, int level)\n{\n\t/* Logical OR for level trig interrupt */\n\tif (level)\n\t\t__set_bit(irq_source_id, irq_state);\n\telse\n\t\t__clear_bit(irq_source_id, irq_state);\n\n\treturn !!(*irq_state);\n}\n\n#define KVM_MMU_ROOT_CURRENT\t\tBIT(0)\n#define KVM_MMU_ROOT_PREVIOUS(i)\tBIT(1+i)\n#define KVM_MMU_ROOTS_ALL\t\t(~0UL)\n\nint kvm_pic_set_irq(struct kvm_pic *pic, int irq, int irq_source_id, int level);\nvoid kvm_pic_clear_all(struct kvm_pic *pic, int irq_source_id);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_update_dr7(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn);\nvoid kvm_mmu_free_roots(struct kvm *kvm, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free);\nvoid kvm_mmu_free_guest_mode_roots(struct kvm *kvm, struct kvm_mmu *mmu);\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception);\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception);\n\nbool kvm_apicv_activated(struct kvm *kvm);\nbool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu);\nvoid kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu);\nvoid __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t      enum kvm_apicv_inhibit reason, bool set);\nvoid kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t    enum kvm_apicv_inhibit reason, bool set);\n\nstatic inline void kvm_set_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t\t enum kvm_apicv_inhibit reason)\n{\n\tkvm_set_or_clear_apicv_inhibit(kvm, reason, true);\n}\n\nstatic inline void kvm_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t\t   enum kvm_apicv_inhibit reason)\n{\n\tkvm_set_or_clear_apicv_inhibit(kvm, reason, false);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len);\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva);\nvoid kvm_mmu_invalidate_gva(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t    gva_t gva, hpa_t root_hpa);\nvoid kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid);\nvoid kvm_mmu_new_pgd(struct kvm_vcpu *vcpu, gpa_t new_pgd);\n\nvoid kvm_configure_mmu(bool enable_tdp, int tdp_forced_root_level,\n\t\t       int tdp_max_root_level, int tdp_huge_page_level);\n\nstatic inline u16 kvm_read_ldt(void)\n{\n\tu16 ldt;\n\tasm(\"sldt %0\" : \"=g\"(ldt));\n\treturn ldt;\n}\n\nstatic inline void kvm_load_ldt(u16 sel)\n{\n\tasm(\"lldt %0\" : : \"rm\"(sel));\n}\n\n#ifdef CONFIG_X86_64\nstatic inline unsigned long read_msr(unsigned long msr)\n{\n\tu64 value;\n\n\trdmsrl(msr, value);\n\treturn value;\n}\n#endif\n\nstatic inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n{\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n}\n\n#define TSS_IOPB_BASE_OFFSET 0x66\n#define TSS_BASE_SIZE 0x68\n#define TSS_IOPB_SIZE (65536 / 8)\n#define TSS_REDIRECTION_SIZE (256 / 8)\n#define RMODE_TSS_SIZE\t\t\t\t\t\t\t\\\n\t(TSS_BASE_SIZE + TSS_REDIRECTION_SIZE + TSS_IOPB_SIZE + 1)\n\nenum {\n\tTASK_SWITCH_CALL = 0,\n\tTASK_SWITCH_IRET = 1,\n\tTASK_SWITCH_JMP = 2,\n\tTASK_SWITCH_GATE = 3,\n};\n\n#define HF_GIF_MASK\t\t(1 << 0)\n#define HF_NMI_MASK\t\t(1 << 3)\n#define HF_IRET_MASK\t\t(1 << 4)\n#define HF_GUEST_MASK\t\t(1 << 5) /* VCPU is in guest-mode */\n#define HF_SMM_MASK\t\t(1 << 6)\n#define HF_SMM_INSIDE_NMI_MASK\t(1 << 7)\n\n#define __KVM_VCPU_MULTIPLE_ADDRESS_SPACE\n#define KVM_ADDRESS_SPACE_NUM 2\n\n#define kvm_arch_vcpu_memslots_id(vcpu) ((vcpu)->arch.hflags & HF_SMM_MASK ? 1 : 0)\n#define kvm_memslots_for_spte_role(kvm, role) __kvm_memslots(kvm, (role).smm)\n\n#define KVM_ARCH_WANT_MMU_NOTIFIER\n\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v);\nint kvm_cpu_has_interrupt(struct kvm_vcpu *vcpu);\nint kvm_cpu_has_extint(struct kvm_vcpu *v);\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu);\nint kvm_cpu_get_interrupt(struct kvm_vcpu *v);\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event);\n\nint kvm_pv_send_ipi(struct kvm *kvm, unsigned long ipi_bitmap_low,\n\t\t    unsigned long ipi_bitmap_high, u32 min,\n\t\t    unsigned long icr, int op_64_bit);\n\nint kvm_add_user_return_msr(u32 msr);\nint kvm_find_user_return_msr(u32 msr);\nint kvm_set_user_return_msr(unsigned index, u64 val, u64 mask);\n\nstatic inline bool kvm_is_supported_user_return_msr(u32 msr)\n{\n\treturn kvm_find_user_return_msr(msr) >= 0;\n}\n\nu64 kvm_scale_tsc(u64 tsc, u64 ratio);\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc);\nu64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier);\nu64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier);\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu);\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip);\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm);\nvoid kvm_make_scan_ioapic_request_mask(struct kvm *kvm,\n\t\t\t\t       unsigned long *vcpu_bitmap);\n\nbool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work);\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work);\nvoid kvm_arch_async_page_ready(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_async_pf *work);\nvoid kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu);\nbool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu);\nextern bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu);\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err);\nvoid __kvm_request_immediate_exit(struct kvm_vcpu *vcpu);\n\nvoid __user *__x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,\n\t\t\t\t     u32 size);\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu);\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu);\n\nbool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t     struct kvm_vcpu **dest_vcpu);\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq);\n\nstatic inline bool kvm_irq_is_postable(struct kvm_lapic_irq *irq)\n{\n\t/* We can only post Fixed and LowPrio IRQs */\n\treturn (irq->delivery_mode == APIC_DM_FIXED ||\n\t\tirq->delivery_mode == APIC_DM_LOWEST);\n}\n\nstatic inline void kvm_arch_vcpu_blocking(struct kvm_vcpu *vcpu)\n{\n\tstatic_call_cond(kvm_x86_vcpu_blocking)(vcpu);\n}\n\nstatic inline void kvm_arch_vcpu_unblocking(struct kvm_vcpu *vcpu)\n{\n\tstatic_call_cond(kvm_x86_vcpu_unblocking)(vcpu);\n}\n\nstatic inline int kvm_cpu_get_apicid(int mps_cpu)\n{\n#ifdef CONFIG_X86_LOCAL_APIC\n\treturn default_cpu_present_to_apicid(mps_cpu);\n#else\n\tWARN_ON_ONCE(1);\n\treturn BAD_APICID;\n#endif\n}\n\n#define put_smstate(type, buf, offset, val)                      \\\n\t*(type *)((buf) + (offset) - 0x7e00) = val\n\n#define GET_SMSTATE(type, buf, offset)\t\t\\\n\t(*(type *)((buf) + (offset) - 0x7e00))\n\nint kvm_cpu_dirty_log_size(void);\n\nint memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages);\n\n#define KVM_CLOCK_VALID_FLAGS\t\t\t\t\t\t\\\n\t(KVM_CLOCK_TSC_STABLE | KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC)\n\n#define KVM_X86_VALID_QUIRKS\t\t\t\\\n\t(KVM_X86_QUIRK_LINT0_REENABLED |\t\\\n\t KVM_X86_QUIRK_CD_NW_CLEARED |\t\t\\\n\t KVM_X86_QUIRK_LAPIC_MMIO_HOLE |\t\\\n\t KVM_X86_QUIRK_OUT_7E_INC_RIP |\t\t\\\n\t KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT |\t\\\n\t KVM_X86_QUIRK_FIX_HYPERCALL_INSN)\n\n#endif /* _ASM_X86_KVM_HOST_H */\n", "#define pr_fmt(fmt) \"SVM: \" fmt\n\n#include <linux/kvm_host.h>\n\n#include \"irq.h\"\n#include \"mmu.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n#include \"pmu.h\"\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/kernel.h>\n#include <linux/vmalloc.h>\n#include <linux/highmem.h>\n#include <linux/amd-iommu.h>\n#include <linux/sched.h>\n#include <linux/trace_events.h>\n#include <linux/slab.h>\n#include <linux/hashtable.h>\n#include <linux/objtool.h>\n#include <linux/psp-sev.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/rwsem.h>\n#include <linux/cc_platform.h>\n\n#include <asm/apic.h>\n#include <asm/perf_event.h>\n#include <asm/tlbflush.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/kvm_para.h>\n#include <asm/irq_remapping.h>\n#include <asm/spec-ctrl.h>\n#include <asm/cpu_device_id.h>\n#include <asm/traps.h>\n#include <asm/fpu/api.h>\n\n#include <asm/virtext.h>\n#include \"trace.h\"\n\n#include \"svm.h\"\n#include \"svm_ops.h\"\n\n#include \"kvm_onhyperv.h\"\n#include \"svm_onhyperv.h\"\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef MODULE\nstatic const struct x86_cpu_id svm_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_SVM, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, svm_cpu_id);\n#endif\n\n#define SEG_TYPE_LDT 2\n#define SEG_TYPE_BUSY_TSS16 3\n\nstatic bool erratum_383_found __read_mostly;\n\nu32 msrpm_offsets[MSRPM_OFFSETS] __read_mostly;\n\n/*\n * Set osvw_len to higher value when updated Revision Guides\n * are published and we know what the new status bits are\n */\nstatic uint64_t osvw_len = 4, osvw_status;\n\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is initially cleared */\n} direct_access_msrs[MAX_DIRECT_ACCESS_MSRS] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_EIP,\t\t.always = false },\n\t{ .index = MSR_IA32_SYSENTER_ESP,\t\t.always = false },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_EFER,\t\t\t\t.always = false },\n\t{ .index = MSR_IA32_CR_PAT,\t\t\t.always = false },\n\t{ .index = MSR_AMD64_SEV_ES_GHCB,\t\t.always = true  },\n\t{ .index = MSR_TSC_AUX,\t\t\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * pause_filter_count: On processors that support Pause filtering(indicated\n *\tby CPUID Fn8000_000A_EDX), the VMCB provides a 16 bit pause filter\n *\tcount value. On VMRUN this value is loaded into an internal counter.\n *\tEach time a pause instruction is executed, this counter is decremented\n *\tuntil it reaches zero at which time a #VMEXIT is generated if pause\n *\tintercept is enabled. Refer to  AMD APM Vol 2 Section 15.14.4 Pause\n *\tIntercept Filtering for more details.\n *\tThis also indicate if ple logic enabled.\n *\n * pause_filter_thresh: In addition, some processor families support advanced\n *\tpause filtering (indicated by CPUID Fn8000_000A_EDX) upper bound on\n *\tthe amount of time a guest is allowed to execute in a pause loop.\n *\tIn this mode, a 16-bit pause filter threshold field is added in the\n *\tVMCB. The threshold value is a cycle count that is used to reset the\n *\tpause counter. As with simple pause filtering, VMRUN loads the pause\n *\tcount value from VMCB into an internal counter. Then, on each pause\n *\tinstruction the hardware checks the elapsed number of cycles since\n *\tthe most recent pause instruction against the pause filter threshold.\n *\tIf the elapsed cycle count is greater than the pause filter threshold,\n *\tthen the internal pause count is reloaded from the VMCB and execution\n *\tcontinues. If the elapsed cycle count is less than the pause filter\n *\tthreshold, then the internal pause count is decremented. If the count\n *\tvalue is less than zero and PAUSE intercept is enabled, a #VMEXIT is\n *\ttriggered. If advanced pause filtering is supported and pause filter\n *\tthreshold field is set to zero, the filter will operate in the simpler,\n *\tcount only mode.\n */\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nmodule_param(pause_filter_thresh, ushort, 0444);\n\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nmodule_param(pause_filter_count, ushort, 0444);\n\n/* Default doubles per-vcpu window every exit. */\nstatic unsigned short pause_filter_count_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(pause_filter_count_grow, ushort, 0444);\n\n/* Default resets per-vcpu window every exit to pause_filter_count. */\nstatic unsigned short pause_filter_count_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(pause_filter_count_shrink, ushort, 0444);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic unsigned short pause_filter_count_max = KVM_SVM_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(pause_filter_count_max, ushort, 0444);\n\n/*\n * Use nested page tables by default.  Note, NPT may get forced off by\n * svm_hardware_setup() if it's unsupported by hardware or the host kernel.\n */\nbool npt_enabled = true;\nmodule_param_named(npt, npt_enabled, bool, 0444);\n\n/* allow nested virtualization in KVM/SVM */\nstatic int nested = true;\nmodule_param(nested, int, S_IRUGO);\n\n/* enable/disable Next RIP Save */\nstatic int nrips = true;\nmodule_param(nrips, int, 0444);\n\n/* enable/disable Virtual VMLOAD VMSAVE */\nstatic int vls = true;\nmodule_param(vls, int, 0444);\n\n/* enable/disable Virtual GIF */\nint vgif = true;\nmodule_param(vgif, int, 0444);\n\n/* enable/disable LBR virtualization */\nstatic int lbrv = true;\nmodule_param(lbrv, int, 0444);\n\nstatic int tsc_scaling = true;\nmodule_param(tsc_scaling, int, 0444);\n\n/*\n * enable / disable AVIC.  Because the defaults differ for APICv\n * support between VMX and SVM we cannot use module_param_named.\n */\nstatic bool avic;\nmodule_param(avic, bool, 0444);\n\nstatic bool force_avic;\nmodule_param_unsafe(force_avic, bool, 0444);\n\nbool __read_mostly dump_invalid_vmcb;\nmodule_param(dump_invalid_vmcb, bool, 0644);\n\n\nbool intercept_smi = true;\nmodule_param(intercept_smi, bool, 0444);\n\n\nstatic bool svm_gp_erratum_intercept = true;\n\nstatic u8 rsm_ins_bytes[] = \"\\x0f\\xaa\";\n\nstatic unsigned long iopm_base;\n\nstruct kvm_ldttss_desc {\n\tu16 limit0;\n\tu16 base0;\n\tunsigned base1:8, type:5, dpl:2, p:1;\n\tunsigned limit1:4, zero0:3, g:1, base2:8;\n\tu32 base3;\n\tu32 zero1;\n} __attribute__((packed));\n\nDEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\n/*\n * Only MSR_TSC_AUX is switched via the user return hook.  EFER is switched via\n * the VMCB, and the SYSCALL/SYSENTER MSRs are handled by VMLOAD/VMSAVE.\n *\n * RDTSCP and RDPID are not used in the kernel, specifically to allow KVM to\n * defer the restoration of TSC_AUX until the CPU returns to userspace.\n */\nstatic int tsc_aux_uret_slot __read_mostly = -1;\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n#define MSRS_RANGE_SIZE 2048\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n\nu32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}\n\nstatic void svm_flush_tlb_current(struct kvm_vcpu *vcpu);\n\nstatic int get_npt_level(void)\n{\n#ifdef CONFIG_X86_64\n\treturn pgtable_l5_enabled() ? PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}\n\nint svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 old_efer = vcpu->arch.efer;\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tif ((old_efer & EFER_SVME) != (efer & EFER_SVME)) {\n\t\tif (!(efer & EFER_SVME)) {\n\t\t\tsvm_leave_nested(vcpu);\n\t\t\tsvm_set_gif(svm, true);\n\t\t\t/* #GP intercept is still needed for vmware backdoor */\n\t\t\tif (!enable_vmware_backdoor)\n\t\t\t\tclr_exception_intercept(svm, GP_VECTOR);\n\n\t\t\t/*\n\t\t\t * Free the nested guest state, unless we are in SMM.\n\t\t\t * In this case we will return to the nested guest\n\t\t\t * as soon as we leave SMM.\n\t\t\t */\n\t\t\tif (!is_smm(vcpu))\n\t\t\t\tsvm_free_nested(svm);\n\n\t\t} else {\n\t\t\tint ret = svm_allocate_nested(svm);\n\n\t\t\tif (ret) {\n\t\t\t\tvcpu->arch.efer = old_efer;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Never intercept #GP for SEV guests, KVM can't\n\t\t\t * decrypt guest memory to workaround the erratum.\n\t\t\t */\n\t\t\tif (svm_gp_erratum_intercept && !sev_guest(vcpu->kvm))\n\t\t\t\tset_exception_intercept(svm, GP_VECTOR);\n\t\t}\n\t}\n\n\tsvm->vmcb->save.efer = efer | EFER_SVME;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n\treturn 0;\n}\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}\n\nstatic u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}\n\nstatic int svm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * SEV-ES does not expose the next RIP. The RIP update is controlled by\n\t * the type of exit and the #VC handler in the guest.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\tgoto done;\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\ndone:\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}\n\nstatic void svm_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\n\tkvm_deliver_exception_payload(vcpu);\n\n\tif (nr == BP_VECTOR && !nrips) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\t(void)svm_skip_emulated_instruction(vcpu);\n\t\trip = kvm_rip_read(vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\tif (cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT)) {\n\t\tpr_info(\"KVM is unsupported when running as an SEV guest\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nvoid __svm_write_tsc_multiplier(u64 multiplier)\n{\n\tpreempt_disable();\n\n\tif (multiplier == __this_cpu_read(current_tsc_ratio))\n\t\tgoto out;\n\n\twrmsrl(MSR_AMD64_TSC_RATIO, multiplier);\n\t__this_cpu_write(current_tsc_ratio, multiplier);\nout:\n\tpreempt_enable();\n}\n\nstatic void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (tsc_scaling)\n\t\t__svm_write_tsc_multiplier(SVM_TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}\n\nstatic int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\tsd->min_asid = max_sev_asid + 1;\n\n\tgdt = get_current_gdt_rw();\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, __sme_page_pa(sd->save_area));\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\t/*\n\t\t * Set the default value, even if we don't use TSC scaling\n\t\t * to avoid having stale value in the msr\n\t\t */\n\t\t__svm_write_tsc_multiplier(SVM_TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}\n\nstatic void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, cpu) = NULL;\n\tkfree(sd->sev_vmcbs);\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\tint ret = -ENOMEM;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn ret;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tret = sev_cpu_init(sd);\n\tif (ret)\n\t\tgoto free_save_area;\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn ret;\n\n}\n\nstatic int direct_access_msr_slot(u32 msr)\n{\n\tu32 i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == msr)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic void set_shadow_msr_intercept(struct kvm_vcpu *vcpu, u32 msr, int read,\n\t\t\t\t     int write)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint slot = direct_access_msr_slot(msr);\n\n\tif (slot == -ENOENT)\n\t\treturn;\n\n\t/* Set the shadow bitmaps to the desired intercept states */\n\tif (read)\n\t\tset_bit(slot, svm->shadow_msr_intercept.read);\n\telse\n\t\tclear_bit(slot, svm->shadow_msr_intercept.read);\n\n\tif (write)\n\t\tset_bit(slot, svm->shadow_msr_intercept.write);\n\telse\n\t\tclear_bit(slot, svm->shadow_msr_intercept.write);\n}\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\treturn direct_access_msr_slot(index) != -ENOENT;\n}\n\nstatic bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tu8 bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\tu32 *msrpm;\n\n\tmsrpm = is_guest_mode(vcpu) ? to_svm(vcpu)->nested.msrpm:\n\t\t\t\t      to_svm(vcpu)->msrpm;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\treturn !!test_bit(bit_write,  &tmp);\n}\n\nstatic void set_msr_interception_bitmap(struct kvm_vcpu *vcpu, u32 *msrpm,\n\t\t\t\t\tu32 msr, int read, int write)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\t/* Enforce non allowed MSRs to trap */\n\tif (read && !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_READ))\n\t\tread = 0;\n\n\tif (write && !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_WRITE))\n\t\twrite = 0;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n\n\tsvm_hv_vmcb_dirty_nested_enlightenments(vcpu);\n\tsvm->nested.force_msr_bitmap_recalc = true;\n}\n\nvoid set_msr_interception(struct kvm_vcpu *vcpu, u32 *msrpm, u32 msr,\n\t\t\t  int read, int write)\n{\n\tset_shadow_msr_intercept(vcpu, msr, read, write);\n\tset_msr_interception_bitmap(vcpu, msrpm, msr, read, write);\n}\n\nu32 *svm_vcpu_alloc_msrpm(void)\n{\n\tunsigned int order = get_order(MSRPM_SIZE);\n\tstruct page *pages = alloc_pages(GFP_KERNEL_ACCOUNT, order);\n\tu32 *msrpm;\n\n\tif (!pages)\n\t\treturn NULL;\n\n\tmsrpm = page_address(pages);\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << order));\n\n\treturn msrpm;\n}\n\nvoid svm_vcpu_init_msrpm(struct kvm_vcpu *vcpu, u32 *msrpm)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\t\tset_msr_interception(vcpu, msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}\n\n\nvoid svm_vcpu_free_msrpm(u32 *msrpm)\n{\n\t__free_pages(virt_to_page(msrpm), get_order(MSRPM_SIZE));\n}\n\nstatic void svm_msr_filter_changed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 i;\n\n\t/*\n\t * Set intercept permissions for all direct access MSRs again. They\n\t * will automatically get filtered through the MSR filter, so we are\n\t * back in sync after this.\n\t */\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 msr = direct_access_msrs[i].index;\n\t\tu32 read = test_bit(i, svm->shadow_msr_intercept.read);\n\t\tu32 write = test_bit(i, svm->shadow_msr_intercept.write);\n\n\t\tset_msr_interception_bitmap(vcpu, svm->msrpm, msr, read, write);\n\t}\n}\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}\n\nvoid svm_copy_lbrs(struct vmcb *to_vmcb, struct vmcb *from_vmcb)\n{\n\tto_vmcb->save.dbgctl\t\t= from_vmcb->save.dbgctl;\n\tto_vmcb->save.br_from\t\t= from_vmcb->save.br_from;\n\tto_vmcb->save.br_to\t\t= from_vmcb->save.br_to;\n\tto_vmcb->save.last_excp_from\t= from_vmcb->save.last_excp_from;\n\tto_vmcb->save.last_excp_to\t= from_vmcb->save.last_excp_to;\n\n\tvmcb_mark_dirty(to_vmcb, VMCB_LBR);\n}\n\nstatic void svm_enable_lbrv(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n\n\t/* Move the LBR msrs to the vmcb02 so that the guest can see them. */\n\tif (is_guest_mode(vcpu))\n\t\tsvm_copy_lbrs(svm->vmcb, svm->vmcb01.ptr);\n}\n\nstatic void svm_disable_lbrv(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.virt_ext &= ~LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n\n\t/*\n\t * Move the LBR msrs back to the vmcb01 to avoid copying them\n\t * on nested guest entries.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\tsvm_copy_lbrs(svm->vmcb01.ptr, svm->vmcb);\n}\n\nstatic int svm_get_lbr_msr(struct vcpu_svm *svm, u32 index)\n{\n\t/*\n\t * If the LBR virtualization is disabled, the LBR msrs are always\n\t * kept in the vmcb01 to avoid copying them on nested guest entries.\n\t *\n\t * If nested, and the LBR virtualization is enabled/disabled, the msrs\n\t * are moved between the vmcb01 and vmcb02 as needed.\n\t */\n\tstruct vmcb *vmcb =\n\t\t(svm->vmcb->control.virt_ext & LBR_CTL_ENABLE_MASK) ?\n\t\t\tsvm->vmcb : svm->vmcb01.ptr;\n\n\tswitch (index) {\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\treturn vmcb->save.dbgctl;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\treturn vmcb->save.br_from;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\treturn vmcb->save.br_to;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\treturn vmcb->save.last_excp_from;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\treturn vmcb->save.last_excp_to;\n\tdefault:\n\t\tKVM_BUG(false, svm->vcpu.kvm,\n\t\t\t\"%s: Unknown MSR 0x%x\", __func__, index);\n\t\treturn 0;\n\t}\n}\n\nvoid svm_update_lbrv(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tbool enable_lbrv = svm_get_lbr_msr(svm, MSR_IA32_DEBUGCTLMSR) &\n\t\t\t\t\t   DEBUGCTLMSR_LBR;\n\n\tbool current_enable_lbrv = !!(svm->vmcb->control.virt_ext &\n\t\t\t\t      LBR_CTL_ENABLE_MASK);\n\n\tif (unlikely(is_guest_mode(vcpu) && svm->lbrv_enabled))\n\t\tif (unlikely(svm->nested.ctl.virt_ext & LBR_CTL_ENABLE_MASK))\n\t\t\tenable_lbrv = true;\n\n\tif (enable_lbrv == current_enable_lbrv)\n\t\treturn;\n\n\tif (enable_lbrv)\n\t\tsvm_enable_lbrv(vcpu);\n\telse\n\t\tsvm_disable_lbrv(vcpu);\n}\n\nvoid disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tif (kvm_pause_in_guest(vcpu->kvm) || !old)\n\t\treturn;\n\n\tcontrol->pause_filter_count = __grow_ple_window(old,\n\t\t\t\t\t\t\tpause_filter_count,\n\t\t\t\t\t\t\tpause_filter_count_grow,\n\t\t\t\t\t\t\tpause_filter_count_max);\n\n\tif (control->pause_filter_count != old) {\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tif (kvm_pause_in_guest(vcpu->kvm) || !old)\n\t\treturn;\n\n\tcontrol->pause_filter_count =\n\t\t\t\t__shrink_ple_window(old,\n\t\t\t\t\t\t    pause_filter_count,\n\t\t\t\t\t\t    pause_filter_count_shrink,\n\t\t\t\t\t\t    pause_filter_count);\n\tif (control->pause_filter_count != old) {\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}\n\nstatic void svm_hardware_unsetup(void)\n{\n\tint cpu;\n\n\tsev_hardware_unsetup();\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT),\n\tget_order(IOPM_SIZE));\n\tiopm_base = 0;\n}\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}\n\nstatic u64 svm_get_l2_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->nested.ctl.tsc_offset;\n}\n\nstatic u64 svm_get_l2_tsc_multiplier(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn svm->tsc_ratio_msr;\n}\n\nstatic void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb01.ptr->control.tsc_offset = vcpu->arch.l1_tsc_offset;\n\tsvm->vmcb->control.tsc_offset = offset;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}\n\nstatic void svm_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 multiplier)\n{\n\t__svm_write_tsc_multiplier(multiplier);\n}\n\n\n/* Evaluate instruction intercepts that depend on guest CPUID features. */\nstatic void svm_recalc_instruction_intercepts(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct vcpu_svm *svm)\n{\n\t/*\n\t * Intercept INVPCID if shadow paging is enabled to sync/free shadow\n\t * roots, or if INVPCID is disabled in the guest to inject #UD.\n\t */\n\tif (kvm_cpu_cap_has(X86_FEATURE_INVPCID)) {\n\t\tif (!npt_enabled ||\n\t\t    !guest_cpuid_has(&svm->vcpu, X86_FEATURE_INVPCID))\n\t\t\tsvm_set_intercept(svm, INTERCEPT_INVPCID);\n\t\telse\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_INVPCID);\n\t}\n\n\tif (kvm_cpu_cap_has(X86_FEATURE_RDTSCP)) {\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_RDTSCP);\n\t\telse\n\t\t\tsvm_set_intercept(svm, INTERCEPT_RDTSCP);\n\t}\n}\n\nstatic inline void init_vmcb_after_set_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (guest_cpuid_is_intel(vcpu)) {\n\t\t/*\n\t\t * We must intercept SYSENTER_EIP and SYSENTER_ESP\n\t\t * accesses because the processor only stores 32 bits.\n\t\t * For the same reason we cannot use virtual VMLOAD/VMSAVE.\n\t\t */\n\t\tsvm_set_intercept(svm, INTERCEPT_VMLOAD);\n\t\tsvm_set_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext &= ~VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_EIP, 0, 0);\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_ESP, 0, 0);\n\n\t\tsvm->v_vmload_vmsave_enabled = false;\n\t} else {\n\t\t/*\n\t\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t\t */\n\t\tif (vls) {\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_VMLOAD);\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_VMSAVE);\n\t\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t\t}\n\t\t/* No need to intercept these MSRs */\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_EIP, 1, 1);\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SYSENTER_ESP, 1, 1);\n\t}\n}\n\nstatic void init_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb01.ptr;\n\tstruct vmcb_control_area *control = &vmcb->control;\n\tstruct vmcb_save_area *save = &vmcb->save;\n\n\tsvm_set_intercept(svm, INTERCEPT_CR0_READ);\n\tsvm_set_intercept(svm, INTERCEPT_CR3_READ);\n\tsvm_set_intercept(svm, INTERCEPT_CR4_READ);\n\tsvm_set_intercept(svm, INTERCEPT_CR0_WRITE);\n\tsvm_set_intercept(svm, INTERCEPT_CR3_WRITE);\n\tsvm_set_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\tsvm_set_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.  Don't intercept #GP for SEV guests as KVM can't\n\t * decrypt guest memory to decode the faulting instruction.\n\t */\n\tif (enable_vmware_backdoor && !sev_guest(vcpu->kvm))\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tsvm_set_intercept(svm, INTERCEPT_INTR);\n\tsvm_set_intercept(svm, INTERCEPT_NMI);\n\n\tif (intercept_smi)\n\t\tsvm_set_intercept(svm, INTERCEPT_SMI);\n\n\tsvm_set_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tsvm_set_intercept(svm, INTERCEPT_RDPMC);\n\tsvm_set_intercept(svm, INTERCEPT_CPUID);\n\tsvm_set_intercept(svm, INTERCEPT_INVD);\n\tsvm_set_intercept(svm, INTERCEPT_INVLPG);\n\tsvm_set_intercept(svm, INTERCEPT_INVLPGA);\n\tsvm_set_intercept(svm, INTERCEPT_IOIO_PROT);\n\tsvm_set_intercept(svm, INTERCEPT_MSR_PROT);\n\tsvm_set_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tsvm_set_intercept(svm, INTERCEPT_SHUTDOWN);\n\tsvm_set_intercept(svm, INTERCEPT_VMRUN);\n\tsvm_set_intercept(svm, INTERCEPT_VMMCALL);\n\tsvm_set_intercept(svm, INTERCEPT_VMLOAD);\n\tsvm_set_intercept(svm, INTERCEPT_VMSAVE);\n\tsvm_set_intercept(svm, INTERCEPT_STGI);\n\tsvm_set_intercept(svm, INTERCEPT_CLGI);\n\tsvm_set_intercept(svm, INTERCEPT_SKINIT);\n\tsvm_set_intercept(svm, INTERCEPT_WBINVD);\n\tsvm_set_intercept(svm, INTERCEPT_XSETBV);\n\tsvm_set_intercept(svm, INTERCEPT_RDPRU);\n\tsvm_set_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(vcpu->kvm)) {\n\t\tsvm_set_intercept(svm, INTERCEPT_MONITOR);\n\t\tsvm_set_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(vcpu->kvm))\n\t\tsvm_set_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.base = 0;\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.base = 0;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tsvm_clr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = vcpu->arch.pat;\n\t\tsave->cr3 = 0;\n\t}\n\tsvm->current_vmcb->asid_generation = 0;\n\tsvm->asid = 0;\n\n\tsvm->nested.vmcb12_gpa = INVALID_GPA;\n\tsvm->nested.last_vmcb12_gpa = INVALID_GPA;\n\n\tif (!kvm_pause_in_guest(vcpu->kvm)) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tsvm_set_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tsvm_clr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tsvm_recalc_instruction_intercepts(vcpu, svm);\n\n\t/*\n\t * If the host supports V_SPEC_CTRL then disable the interception\n\t * of MSR_IA32_SPEC_CTRL.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);\n\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\tavic_init_vmcb(svm, vmcb);\n\n\tif (vgif) {\n\t\tsvm_clr_intercept(svm, INTERCEPT_STGI);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(vcpu->kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\n\t\tif (sev_es_guest(vcpu->kvm)) {\n\t\t\t/* Perform SEV-ES specific VMCB updates */\n\t\t\tsev_es_init_vmcb(svm);\n\t\t}\n\t}\n\n\tsvm_hv_init_vmcb(vmcb);\n\tinit_vmcb_after_set_cpuid(vcpu);\n\n\tvmcb_mark_all_dirty(vmcb);\n\n\tenable_gif(svm);\n}\n\nstatic void __svm_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm_vcpu_init_msrpm(vcpu, svm->msrpm);\n\n\tsvm_init_osvw(vcpu);\n\tvcpu->arch.microcode_version = 0x01000065;\n\tsvm->tsc_ratio_msr = kvm_default_tsc_scaling_ratio;\n\n\tif (sev_es_guest(vcpu->kvm))\n\t\tsev_es_vcpu_reset(svm);\n}\n\nstatic void svm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->spec_ctrl = 0;\n\tsvm->virt_spec_ctrl = 0;\n\n\tinit_vmcb(vcpu);\n\n\tif (!init_event)\n\t\t__svm_vcpu_reset(vcpu);\n}\n\nvoid svm_switch_vmcb(struct vcpu_svm *svm, struct kvm_vmcb_info *target_vmcb)\n{\n\tsvm->current_vmcb = target_vmcb;\n\tsvm->vmcb = target_vmcb->ptr;\n}\n\nstatic int svm_vcpu_create(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *vmcb01_page;\n\tstruct page *vmsa_page = NULL;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_svm, vcpu) != 0);\n\tsvm = to_svm(vcpu);\n\n\terr = -ENOMEM;\n\tvmcb01_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!vmcb01_page)\n\t\tgoto out;\n\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\t/*\n\t\t * SEV-ES guests require a separate VMSA page used to contain\n\t\t * the encrypted register state of the guest.\n\t\t */\n\t\tvmsa_page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\t\tif (!vmsa_page)\n\t\t\tgoto error_free_vmcb_page;\n\n\t\t/*\n\t\t * SEV-ES guests maintain an encrypted version of their FPU\n\t\t * state which is restored and saved on VMRUN and VMEXIT.\n\t\t * Mark vcpu->arch.guest_fpu->fpstate as scratch so it won't\n\t\t * do xsave/xrstor on it.\n\t\t */\n\t\tfpstate_set_confidential(&vcpu->arch.guest_fpu);\n\t}\n\n\terr = avic_init_vcpu(svm);\n\tif (err)\n\t\tgoto error_free_vmsa_page;\n\n\tsvm->msrpm = svm_vcpu_alloc_msrpm();\n\tif (!svm->msrpm) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free_vmsa_page;\n\t}\n\n\tsvm->vmcb01.ptr = page_address(vmcb01_page);\n\tsvm->vmcb01.pa = __sme_set(page_to_pfn(vmcb01_page) << PAGE_SHIFT);\n\tsvm_switch_vmcb(svm, &svm->vmcb01);\n\n\tif (vmsa_page)\n\t\tsvm->sev_es.vmsa = page_address(vmsa_page);\n\n\tsvm->guest_state_loaded = false;\n\n\treturn 0;\n\nerror_free_vmsa_page:\n\tif (vmsa_page)\n\t\t__free_page(vmsa_page);\nerror_free_vmcb_page:\n\t__free_page(vmcb01_page);\nout:\n\treturn err;\n}\n\nstatic void svm_clear_current_vmcb(struct vmcb *vmcb)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcmpxchg(&per_cpu(svm_data, i)->current_vmcb, vmcb, NULL);\n}\n\nstatic void svm_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * The vmcb page can be recycled, causing a false negative in\n\t * svm_vcpu_load(). So, ensure that no logical CPU has this\n\t * vmcb page recorded as its current vmcb.\n\t */\n\tsvm_clear_current_vmcb(svm->vmcb);\n\n\tsvm_free_nested(svm);\n\n\tsev_free_vcpu(vcpu);\n\n\t__free_page(pfn_to_page(__sme_clr(svm->vmcb01.pa) >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), get_order(MSRPM_SIZE));\n}\n\nstatic void svm_prepare_switch_to_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\n\tif (sev_es_guest(vcpu->kvm))\n\t\tsev_es_unmap_ghcb(svm);\n\n\tif (svm->guest_state_loaded)\n\t\treturn;\n\n\t/*\n\t * Save additional host state that will be restored on VMEXIT (sev-es)\n\t * or subsequent vmload of host save area.\n\t */\n\tvmsave(__sme_page_pa(sd->save_area));\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\tstruct vmcb_save_area *hostsa;\n\t\thostsa = (struct vmcb_save_area *)(page_address(sd->save_area) + 0x400);\n\n\t\tsev_es_prepare_switch_to_guest(hostsa);\n\t}\n\n\tif (tsc_scaling)\n\t\t__svm_write_tsc_multiplier(vcpu->arch.tsc_scaling_ratio);\n\n\tif (likely(tsc_aux_uret_slot >= 0))\n\t\tkvm_set_user_return_msr(tsc_aux_uret_slot, svm->tsc_aux, -1ull);\n\n\tsvm->guest_state_loaded = true;\n}\n\nstatic void svm_prepare_host_switch(struct kvm_vcpu *vcpu)\n{\n\tto_svm(vcpu)->guest_state_loaded = false;\n}\n\nstatic void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (sd->current_vmcb != svm->vmcb) {\n\t\tsd->current_vmcb = svm->vmcb;\n\t\tindirect_branch_prediction_barrier();\n\t}\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t__avic_vcpu_load(vcpu, cpu);\n}\n\nstatic void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t__avic_vcpu_put(vcpu);\n\n\tsvm_prepare_host_switch(vcpu);\n\n\t++vcpu->stat.host_state_reload;\n}\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long rflags = svm->vmcb->save.rflags;\n\n\tif (svm->nmi_singlestep) {\n\t\t/* Hide our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\trflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\trflags &= ~X86_EFLAGS_RF;\n\t}\n\treturn rflags;\n}\n\nstatic void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (to_svm(vcpu)->nmi_singlestep)\n\t\trflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\n       /*\n        * Any change of EFLAGS.VM is accompanied by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}\n\nstatic bool svm_get_if_flag(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb *vmcb = to_svm(vcpu)->vmcb;\n\n\treturn sev_es_guest(vcpu->kvm)\n\t\t? vmcb->control.int_state & SVM_GUEST_INTERRUPT_MASK\n\t\t: kvm_get_rflags(vcpu) & X86_EFLAGS_IF;\n}\n\nstatic void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\t/*\n\t\t * When !npt_enabled, mmu->pdptrs[] is already available since\n\t\t * it is always updated per SDM when moving to CRs.\n\t\t */\n\t\tif (npt_enabled)\n\t\t\tload_pdptrs(vcpu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tKVM_BUG_ON(1, vcpu->kvm);\n\t}\n}\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control;\n\n\t/*\n\t * The following fields are ignored when AVIC is enabled\n\t */\n\tWARN_ON(kvm_vcpu_apicv_activated(&svm->vcpu));\n\n\tsvm_set_intercept(svm, INTERCEPT_VINTR);\n\n\t/*\n\t * This is just a dummy VINTR to actually cause a vmexit to happen.\n\t * Actual injection of virtual interrupts happens through EVENTINJ.\n\t */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = 0x0;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTR);\n}\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tsvm_clr_intercept(svm, INTERCEPT_VINTR);\n\n\t/* Drop int_ctl fields related to VINTR injection.  */\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_INJECTION_BITS_MASK;\n\tif (is_guest_mode(&svm->vcpu)) {\n\t\tsvm->vmcb01.ptr->control.int_ctl &= ~V_IRQ_INJECTION_BITS_MASK;\n\n\t\tWARN_ON((svm->vmcb->control.int_ctl & V_TPR_MASK) !=\n\t\t\t(svm->nested.ctl.int_ctl & V_TPR_MASK));\n\n\t\tsvm->vmcb->control.int_ctl |= svm->nested.ctl.int_ctl &\n\t\t\tV_IRQ_INJECTION_BITS_MASK;\n\n\t\tsvm->vmcb->control.int_vector = svm->nested.ctl.int_vector;\n\t}\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTR);\n}\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\tstruct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save01->fs;\n\tcase VCPU_SREG_GS: return &save01->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save01->tr;\n\tcase VCPU_SREG_LDTR: return &save01->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}\n\nstatic u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}\n\nstatic void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\t/* This is symmetric with svm_set_segment() */\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}\n\nstatic void svm_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tstruct kvm_segment cs;\n\n\tsvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\t*db = cs.db;\n\t*l = cs.l;\n}\n\nstatic void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}\n\nstatic void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}\n\nstatic void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_DT);\n}\n\nstatic void sev_post_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * For guests that don't set guest_state_protected, the cr3 update is\n\t * handled via kvm_mmu_load() while entering the guest. For guests\n\t * that do (SEV-ES/SEV-SNP), the cr3 update needs to be written to\n\t * VMCB save area now, since the save area will become the initial\n\t * contents of the VMSA, and future VMCB save area updates won't be\n\t * seen.\n\t */\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\tsvm->vmcb->save.cr3 = cr3;\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n\t}\n}\n\nvoid svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 hcr0 = cr0;\n\tbool old_paging = is_paging(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME && !vcpu->arch.guest_state_protected) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled) {\n\t\thcr0 |= X86_CR0_PG | X86_CR0_WP;\n\t\tif (old_paging != is_paging(vcpu))\n\t\t\tsvm_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\thcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\n\tsvm->vmcb->save.cr0 = hcr0;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n\n\t/*\n\t * SEV-ES guests must always keep the CR intercepts cleared. CR\n\t * tracking is done using the CR write traps.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn;\n\n\tif (hcr0 == cr0) {\n\t\t/* Selective CR0 write remains on.  */\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tsvm_clr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tsvm_set_intercept(svm, INTERCEPT_CR0_READ);\n\t\tsvm_set_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}\n\nstatic bool svm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\treturn true;\n}\n\nvoid svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = vcpu->arch.cr4;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb_current(vcpu);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled) {\n\t\tcr4 |= X86_CR4_PAE;\n\n\t\tif (!is_paging(vcpu))\n\t\t\tcr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tvmcb_mark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid_runtime(vcpu);\n}\n\nstatic void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\ts->attrib |= ((var->present & 1) && !var->unusable) << SVM_SELECTOR_P_SHIFT;\n\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\t/* This is symmetric with svm_get_segment() */\n\t\tsvm->vmcb->save.cpl = (var->dpl & 3);\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_SEG);\n}\n\nstatic void svm_update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t}\n}\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = sd->min_asid;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_ASID);\n\t}\n\n\tsvm->current_vmcb->asid_generation = sd->asid_generation;\n\tsvm->asid = sd->next_asid++;\n}\n\nstatic void svm_set_dr6(struct vcpu_svm *svm, unsigned long value)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (svm->vcpu.arch.guest_state_protected)\n\t\treturn;\n\n\tif (unlikely(value != vmcb->save.dr6)) {\n\t\tvmcb->save.dr6 = value;\n\t\tvmcb_mark_dirty(vmcb, VMCB_DR);\n\t}\n}\n\nstatic void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\t/*\n\t * We cannot reset svm->vmcb->save.dr6 to DR6_ACTIVE_LOW here,\n\t * because db_interception might need it.  We can do it before vmentry.\n\t */\n\tvcpu->arch.dr6 = svm->vmcb->save.dr6;\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}\n\nstatic void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tsvm->vmcb->save.dr7 = value;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_DR);\n}\n\nstatic int pf_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\treturn kvm_handle_page_fault(vcpu, error_code, fault_address,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}\n\nstatic int npf_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu64 fault_address = svm->vmcb->control.exit_info_2;\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\ttrace_kvm_page_fault(fault_address, error_code);\n\treturn kvm_mmu_page_fault(vcpu, fault_address, error_code,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}\n\nstatic int db_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!(vcpu->guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tu32 payload = svm->vmcb->save.dr6 ^ DR6_ACTIVE_LOW;\n\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, payload);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tdisable_nmi_singlestep(svm);\n\t\t/* Make sure we check for pending NMIs upon entry */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\n\tif (vcpu->guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.dr6 = svm->vmcb->save.dr6;\n\t\tkvm_run->debug.arch.dr7 = svm->vmcb->save.dr7;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int bp_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}\n\nstatic int ud_interception(struct kvm_vcpu *vcpu)\n{\n\treturn handle_ud(vcpu);\n}\n\nstatic int ac_interception(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception_e(vcpu, AC_VECTOR, 0);\n\treturn 1;\n}\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}\n\nstatic void svm_handle_mce(struct kvm_vcpu *vcpu)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tkvm_machine_check();\n}\n\nstatic int mc_interception(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int shutdown_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * The VM save area has already been encrypted so it\n\t * cannot be reinitialized - just terminate.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn -EINVAL;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept.  INIT the vCPU to put\n\t * the VMCB in a known good state.  Unfortuately, KVM doesn't have\n\t * KVM_MP_STATE_SHUTDOWN and can't add it without potentially breaking\n\t * userspace.  At a platform view, INIT is acceptable behavior as\n\t * there exist bare metal platforms that automatically INIT the CPU\n\t * in response to shutdown.\n\t */\n\tclear_page(svm->vmcb);\n\tkvm_vcpu_reset(vcpu, true);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n\nstatic int io_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++vcpu->stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\n\tif (string) {\n\t\tif (sev_es_guest(vcpu->kvm))\n\t\t\treturn sev_es_string_io(svm, size, port, in);\n\t\telse\n\t\t\treturn kvm_emulate_instruction(vcpu, 0);\n\t}\n\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}\n\nstatic int nmi_interception(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int smi_interception(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int intr_interception(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int vmload_vmsave_interception(struct kvm_vcpu *vcpu, bool vmload)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb12;\n\tstruct kvm_host_map map;\n\tint ret;\n\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\tret = kvm_vcpu_map(vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tvmcb12 = map.hva;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\n\tif (vmload) {\n\t\tsvm_copy_vmloadsave_state(svm->vmcb, vmcb12);\n\t\tsvm->sysenter_eip_hi = 0;\n\t\tsvm->sysenter_esp_hi = 0;\n\t} else {\n\t\tsvm_copy_vmloadsave_state(vmcb12, svm->vmcb);\n\t}\n\n\tkvm_vcpu_unmap(vcpu, &map, true);\n\n\treturn ret;\n}\n\nstatic int vmload_interception(struct kvm_vcpu *vcpu)\n{\n\treturn vmload_vmsave_interception(vcpu, true);\n}\n\nstatic int vmsave_interception(struct kvm_vcpu *vcpu)\n{\n\treturn vmload_vmsave_interception(vcpu, false);\n}\n\nstatic int vmrun_interception(struct kvm_vcpu *vcpu)\n{\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\treturn nested_svm_vmrun(vcpu);\n}\n\nenum {\n\tNONE_SVM_INSTR,\n\tSVM_INSTR_VMRUN,\n\tSVM_INSTR_VMLOAD,\n\tSVM_INSTR_VMSAVE,\n};\n\n/* Return NONE_SVM_INSTR if not SVM instrs, otherwise return decode result */\nstatic int svm_instr_opcode(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tif (ctxt->b != 0x1 || ctxt->opcode_len != 2)\n\t\treturn NONE_SVM_INSTR;\n\n\tswitch (ctxt->modrm) {\n\tcase 0xd8: /* VMRUN */\n\t\treturn SVM_INSTR_VMRUN;\n\tcase 0xda: /* VMLOAD */\n\t\treturn SVM_INSTR_VMLOAD;\n\tcase 0xdb: /* VMSAVE */\n\t\treturn SVM_INSTR_VMSAVE;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NONE_SVM_INSTR;\n}\n\nstatic int emulate_svm_instr(struct kvm_vcpu *vcpu, int opcode)\n{\n\tconst int guest_mode_exit_codes[] = {\n\t\t[SVM_INSTR_VMRUN] = SVM_EXIT_VMRUN,\n\t\t[SVM_INSTR_VMLOAD] = SVM_EXIT_VMLOAD,\n\t\t[SVM_INSTR_VMSAVE] = SVM_EXIT_VMSAVE,\n\t};\n\tint (*const svm_instr_handlers[])(struct kvm_vcpu *vcpu) = {\n\t\t[SVM_INSTR_VMRUN] = vmrun_interception,\n\t\t[SVM_INSTR_VMLOAD] = vmload_interception,\n\t\t[SVM_INSTR_VMSAVE] = vmsave_interception,\n\t};\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint ret;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* Returns '1' or -errno on failure, '0' on success. */\n\t\tret = nested_svm_simple_vmexit(svm, guest_mode_exit_codes[opcode]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn 1;\n\t}\n\treturn svm_instr_handlers[opcode](vcpu);\n}\n\n/*\n * #GP handling code. Note that #GP can be triggered under the following two\n * cases:\n *   1) SVM VM-related instructions (VMRUN/VMSAVE/VMLOAD) that trigger #GP on\n *      some AMD CPUs when EAX of these instructions are in the reserved memory\n *      regions (e.g. SMM memory on host).\n *   2) VMware backdoor\n */\nstatic int gp_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 error_code = svm->vmcb->control.exit_info_1;\n\tint opcode;\n\n\t/* Both #GP cases have zero error_code */\n\tif (error_code)\n\t\tgoto reinject;\n\n\t/* Decode the instruction for usage later */\n\tif (x86_decode_emulated_instruction(vcpu, 0, NULL, 0) != EMULATION_OK)\n\t\tgoto reinject;\n\n\topcode = svm_instr_opcode(vcpu);\n\n\tif (opcode == NONE_SVM_INSTR) {\n\t\tif (!enable_vmware_backdoor)\n\t\t\tgoto reinject;\n\n\t\t/*\n\t\t * VMware backdoor emulation on #GP interception only handles\n\t\t * IN{S}, OUT{S}, and RDPMC.\n\t\t */\n\t\tif (!is_guest_mode(vcpu))\n\t\t\treturn kvm_emulate_instruction(vcpu,\n\t\t\t\tEMULTYPE_VMWARE_GP | EMULTYPE_NO_DECODE);\n\t} else {\n\t\t/* All SVM instructions expect page aligned RAX */\n\t\tif (svm->vmcb->save.rax & ~PAGE_MASK)\n\t\t\tgoto reinject;\n\n\t\treturn emulate_svm_instr(vcpu, opcode);\n\t}\n\nreinject:\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\treturn 1;\n}\n\nvoid svm_set_gif(struct vcpu_svm *svm, bool value)\n{\n\tif (value) {\n\t\t/*\n\t\t * If VGIF is enabled, the STGI intercept is only added to\n\t\t * detect the opening of the SMI/NMI window; remove it now.\n\t\t * Likewise, clear the VINTR intercept, we will set it\n\t\t * again while processing KVM_REQ_EVENT if needed.\n\t\t */\n\t\tif (vgif)\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_STGI);\n\t\tif (svm_is_intercept(svm, INTERCEPT_VINTR))\n\t\t\tsvm_clear_vintr(svm);\n\n\t\tenable_gif(svm);\n\t\tif (svm->vcpu.arch.smi_pending ||\n\t\t    svm->vcpu.arch.nmi_pending ||\n\t\t    kvm_cpu_has_injectable_intr(&svm->vcpu))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t} else {\n\t\tdisable_gif(svm);\n\n\t\t/*\n\t\t * After a CLGI no interrupts should come.  But if vGIF is\n\t\t * in use, we still rely on the VINTR intercept (rather than\n\t\t * STGI) to detect an open interrupt window.\n\t\t*/\n\t\tif (!vgif)\n\t\t\tsvm_clear_vintr(svm);\n\t}\n}\n\nstatic int stgi_interception(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\tsvm_set_gif(to_svm(vcpu), true);\n\treturn ret;\n}\n\nstatic int clgi_interception(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(vcpu))\n\t\treturn 1;\n\n\tret = kvm_skip_emulated_instruction(vcpu);\n\tsvm_set_gif(to_svm(vcpu), false);\n\treturn ret;\n}\n\nstatic int invlpga_interception(struct kvm_vcpu *vcpu)\n{\n\tgva_t gva = kvm_rax_read(vcpu);\n\tu32 asid = kvm_rcx_read(vcpu);\n\n\t/* FIXME: Handle an address size prefix. */\n\tif (!is_long_mode(vcpu))\n\t\tgva = (u32)gva;\n\n\ttrace_kvm_invlpga(to_svm(vcpu)->vmcb->save.rip, asid, gva);\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, gva);\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int skinit_interception(struct kvm_vcpu *vcpu)\n{\n\ttrace_kvm_skinit(to_svm(vcpu)->vmcb->save.rip, kvm_rax_read(vcpu));\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\n\nstatic int task_switch_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR))) {\n\t\tif (!svm_skip_emulated_instruction(vcpu))\n\t\t\treturn 0;\n\t}\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\treturn kvm_task_switch(vcpu, tss_selector, int_vec, reason,\n\t\t\t       has_error_code, error_code);\n}\n\nstatic int iret_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t++vcpu->stat.nmi_window_exits;\n\tvcpu->arch.hflags |= HF_IRET_MASK;\n\tif (!sev_es_guest(vcpu->kvm)) {\n\t\tsvm_clr_intercept(svm, INTERCEPT_IRET);\n\t\tsvm->nmi_iret_rip = kvm_rip_read(vcpu);\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 1;\n}\n\nstatic int invlpg_interception(struct kvm_vcpu *vcpu)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tkvm_mmu_invlpg(vcpu, to_svm(vcpu)->vmcb->control.exit_info_1);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int emulate_on_interception(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction(vcpu, 0);\n}\n\nstatic int rsm_interception(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction_from_buffer(vcpu, rsm_ins_bytes, 2);\n}\n\nstatic bool check_selective_cr0_intercepted(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned long val)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long cr0 = vcpu->arch.cr0;\n\tbool ret = false;\n\n\tif (!is_guest_mode(vcpu) ||\n\t    (!(vmcb12_is_intercept(&svm->nested.ctl, INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}\n\n#define CR_VALID (1ULL << 63)\n\nstatic int cr_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(vcpu);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(vcpu);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(vcpu, val))\n\t\t\t\terr = kvm_set_cr0(vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = vcpu->arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(vcpu, reg, val);\n\t\ttrace_kvm_cr_read(cr, val);\n\t}\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic int cr_trap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long old_value, new_value;\n\tunsigned int cr;\n\tint ret = 0;\n\n\tnew_value = (unsigned long)svm->vmcb->control.exit_info_1;\n\n\tcr = svm->vmcb->control.exit_code - SVM_EXIT_CR0_WRITE_TRAP;\n\tswitch (cr) {\n\tcase 0:\n\t\told_value = kvm_read_cr0(vcpu);\n\t\tsvm_set_cr0(vcpu, new_value);\n\n\t\tkvm_post_set_cr0(vcpu, old_value, new_value);\n\t\tbreak;\n\tcase 4:\n\t\told_value = kvm_read_cr4(vcpu);\n\t\tsvm_set_cr4(vcpu, new_value);\n\n\t\tkvm_post_set_cr4(vcpu, old_value, new_value);\n\t\tbreak;\n\tcase 8:\n\t\tret = kvm_set_cr8(vcpu, new_value);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unhandled CR%d write trap\", cr);\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\treturn kvm_complete_insn_gp(vcpu, ret);\n}\n\nstatic int dr_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint reg, dr;\n\tunsigned long val;\n\tint err = 0;\n\n\tif (vcpu->guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(vcpu);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\tif (dr >= 16) { /* mov to DRn  */\n\t\tdr -= 16;\n\t\tval = kvm_register_read(vcpu, reg);\n\t\terr = kvm_set_dr(vcpu, dr, val);\n\t} else {\n\t\tkvm_get_dr(vcpu, dr, &val);\n\t\tkvm_register_write(vcpu, reg, val);\n\t}\n\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic int cr8_write_interception(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(vcpu);\n\tif (lapic_in_kernel(vcpu))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(vcpu))\n\t\treturn r;\n\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}\n\nstatic int efer_trap(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr_info;\n\tint ret;\n\n\t/*\n\t * Clear the EFER_SVME bit from EFER. The SVM code always sets this\n\t * bit in svm_set_efer(), but __kvm_valid_efer() checks it against\n\t * whether the guest has X86_FEATURE_SVM - this avoids a failure if\n\t * the guest doesn't have X86_FEATURE_SVM.\n\t */\n\tmsr_info.host_initiated = false;\n\tmsr_info.index = MSR_EFER;\n\tmsr_info.data = to_svm(vcpu)->vmcb->control.exit_info_1 & ~EFER_SVME;\n\tret = kvm_set_msr_common(vcpu, &msr_info);\n\n\treturn kvm_complete_insn_gp(vcpu, ret);\n}\n\nstatic int svm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tmsr->data = 0;\n\n\tswitch (msr->index) {\n\tcase MSR_F10H_DECFG:\n\t\tif (boot_cpu_has(X86_FEATURE_LFENCE_RDTSC))\n\t\t\tmsr->data |= MSR_F10H_DECFG_LFENCE_SERIALIZE;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\treturn 0;\n\tdefault:\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n\n\treturn 0;\n}\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_AMD64_TSC_RATIO:\n\t\tif (!msr_info->host_initiated && !svm->tsc_scaling_enabled)\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_ratio_msr;\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = (u32)svm->vmcb01.ptr->save.sysenter_eip;\n\t\tif (guest_cpuid_is_intel(vcpu))\n\t\t\tmsr_info->data |= (u64)svm->sysenter_eip_hi << 32;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->vmcb01.ptr->save.sysenter_esp;\n\t\tif (guest_cpuid_is_intel(vcpu))\n\t\t\tmsr_info->data |= (u64)svm->sysenter_esp_hi << 32;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm_get_lbr_msr(svm, msr_info->index);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\t\tmsr_info->data = svm->vmcb->save.spec_ctrl;\n\t\telse\n\t\t\tmsr_info->data = svm->spec_ctrl;\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = svm->virt_spec_ctrl;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tcase MSR_F10H_DECFG:\n\t\tmsr_info->data = svm->msr_decfg;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}\n\nstatic int svm_complete_emulated_msr(struct kvm_vcpu *vcpu, int err)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (!err || !sev_es_guest(vcpu->kvm) || WARN_ON_ONCE(!svm->sev_es.ghcb))\n\t\treturn kvm_complete_insn_gp(vcpu, err);\n\n\tghcb_set_sw_exit_info_1(svm->sev_es.ghcb, 1);\n\tghcb_set_sw_exit_info_2(svm->sev_es.ghcb,\n\t\t\t\tX86_TRAP_GP |\n\t\t\t\tSVM_EVTINJ_TYPE_EXEPT |\n\t\t\t\tSVM_EVTINJ_VALID);\n\treturn 1;\n}\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint r;\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_AMD64_TSC_RATIO:\n\n\t\tif (!svm->tsc_scaling_enabled) {\n\n\t\t\tif (!msr->host_initiated)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * In case TSC scaling is not enabled, always\n\t\t\t * leave this MSR at the default value.\n\t\t\t *\n\t\t\t * Due to bug in qemu 6.2.0, it would try to set\n\t\t\t * this msr to 0 if tsc scaling is not enabled.\n\t\t\t * Ignore this value as well.\n\t\t\t */\n\t\t\tif (data != 0 && data != svm->tsc_ratio_msr)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data & SVM_TSC_RATIO_RSVD)\n\t\t\treturn 1;\n\n\t\tsvm->tsc_ratio_msr = data;\n\n\t\tif (svm->tsc_scaling_enabled && is_guest_mode(vcpu))\n\t\t\tnested_svm_update_tsc_ratio_msr(vcpu);\n\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\treturn 1;\n\t\tvcpu->arch.pat = data;\n\t\tsvm->vmcb01.ptr->save.g_pat = data;\n\t\tif (is_guest_mode(vcpu))\n\t\t\tnested_vmcb02_compute_g_pat(svm);\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_NPT);\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (kvm_spec_ctrl_test_value(data))\n\t\t\treturn 1;\n\n\t\tif (boot_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\t\tsvm->vmcb->save.spec_ctrl = data;\n\t\telse\n\t\t\tsvm->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_svm_vmrun_msrpm.\n\t\t * We update the L1 MSR bit as well since it will end up\n\t\t * touching the MSR anyway now.\n\t\t */\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);\n\t\tbreak;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_has_pred_cmd_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_IBPB))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\t\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_PRED_CMD, 0, 1);\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tif (data & ~SPEC_CTRL_SSBD)\n\t\t\treturn 1;\n\n\t\tsvm->virt_spec_ctrl = data;\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb01.ptr->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb01.ptr->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb01.ptr->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb01.ptr->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb01.ptr->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb01.ptr->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->vmcb01.ptr->save.sysenter_eip = (u32)data;\n\t\t/*\n\t\t * We only intercept the MSR_IA32_SYSENTER_{EIP|ESP} msrs\n\t\t * when we spoof an Intel vendor ID (for cross vendor migration).\n\t\t * In this case we use this intercept to track the high\n\t\t * 32 bit part of these msrs to support Intel's\n\t\t * implementation of SYSENTER/SYSEXIT.\n\t\t */\n\t\tsvm->sysenter_eip_hi = guest_cpuid_is_intel(vcpu) ? (data >> 32) : 0;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->vmcb01.ptr->save.sysenter_esp = (u32)data;\n\t\tsvm->sysenter_esp_hi = guest_cpuid_is_intel(vcpu) ? (data >> 32) : 0;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\t/*\n\t\t * TSC_AUX is usually changed only during boot and never read\n\t\t * directly.  Intercept TSC_AUX instead of exposing it to the\n\t\t * guest via direct_access_msrs, and switch it via user return.\n\t\t */\n\t\tpreempt_disable();\n\t\tr = kvm_set_user_return_msr(tsc_aux_uret_slot, data, -1ull);\n\t\tpreempt_enable();\n\t\tif (r)\n\t\t\treturn 1;\n\n\t\tsvm->tsc_aux = data;\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!lbrv) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tif (svm->vmcb->control.virt_ext & LBR_CTL_ENABLE_MASK)\n\t\t\tsvm->vmcb->save.dbgctl = data;\n\t\telse\n\t\t\tsvm->vmcb01.ptr->save.dbgctl = data;\n\n\t\tsvm_update_lbrv(vcpu);\n\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\t/*\n\t\t * Old kernels did not validate the value written to\n\t\t * MSR_VM_HSAVE_PA.  Allow KVM_SET_MSR to set an invalid\n\t\t * value to allow live migrating buggy or malicious guests\n\t\t * originating from those kernels.\n\t\t */\n\t\tif (!msr->host_initiated && !page_address_valid(vcpu, data))\n\t\t\treturn 1;\n\n\t\tsvm->nested.hsave_msr = data & PAGE_MASK;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tcase MSR_F10H_DECFG: {\n\t\tstruct kvm_msr_entry msr_entry;\n\n\t\tmsr_entry.index = msr->index;\n\t\tif (svm_get_msr_feature(&msr_entry))\n\t\t\treturn 1;\n\n\t\t/* Check the supported bits */\n\t\tif (data & ~msr_entry.data)\n\t\t\treturn 1;\n\n\t\t/* Don't allow the guest to change a bit, #GP */\n\t\tif (!msr->host_initiated && (data ^ msr_entry.data))\n\t\t\treturn 1;\n\n\t\tsvm->msr_decfg = data;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}\n\nstatic int msr_interception(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_info_1)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse\n\t\treturn kvm_emulate_rdmsr(vcpu);\n}\n\nstatic int interrupt_window_interception(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tsvm_clear_vintr(to_svm(vcpu));\n\n\t/*\n\t * If not running nested, for AVIC, the only reason to end up here is ExtINTs.\n\t * In this case AVIC was temporarily disabled for\n\t * requesting the IRQ window and we have to re-enable it.\n\t *\n\t * If running nested, still remove the VM wide AVIC inhibit to\n\t * support case in which the interrupt window was requested when the\n\t * vCPU was not running nested.\n\n\t * All vCPUs which run still run nested, will remain to have their\n\t * AVIC still inhibited due to per-cpu AVIC inhibition.\n\t */\n\tkvm_clear_apicv_inhibit(vcpu->kvm, APICV_INHIBIT_REASON_IRQWIN);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}\n\nstatic int pause_interception(struct kvm_vcpu *vcpu)\n{\n\tbool in_kernel;\n\t/*\n\t * CPL is not made available for an SEV-ES guest, therefore\n\t * vcpu->arch.preempted_in_kernel can never be true.  Just\n\t * set in_kernel to false as well.\n\t */\n\tin_kernel = !sev_es_guest(vcpu->kvm) && svm_get_cpl(vcpu) == 0;\n\n\tgrow_ple_window(vcpu);\n\n\tkvm_vcpu_on_spin(vcpu, in_kernel);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int invpcid_interception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long type;\n\tgva_t gva;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * For an INVPCID intercept:\n\t * EXITINFO1 provides the linear address of the memory operand.\n\t * EXITINFO2 provides the contents of the register operand.\n\t */\n\ttype = svm->vmcb->control.exit_info_2;\n\tgva = svm->vmcb->control.exit_info_1;\n\n\treturn kvm_handle_invpcid(vcpu, type, gva);\n}\n\nstatic int (*const svm_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_EXCP_BASE + GP_VECTOR]\t= gp_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= smi_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= kvm_emulate_rdpmc,\n\t[SVM_EXIT_CPUID]\t\t\t= kvm_emulate_cpuid,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = kvm_emulate_invd,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= kvm_emulate_halt,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= kvm_emulate_hypercall,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_RDTSCP]\t\t\t= kvm_handle_invalid_op,\n\t[SVM_EXIT_WBINVD]                       = kvm_emulate_wbinvd,\n\t[SVM_EXIT_MONITOR]\t\t\t= kvm_emulate_monitor,\n\t[SVM_EXIT_MWAIT]\t\t\t= kvm_emulate_mwait,\n\t[SVM_EXIT_XSETBV]\t\t\t= kvm_emulate_xsetbv,\n\t[SVM_EXIT_RDPRU]\t\t\t= kvm_handle_invalid_op,\n\t[SVM_EXIT_EFER_WRITE_TRAP]\t\t= efer_trap,\n\t[SVM_EXIT_CR0_WRITE_TRAP]\t\t= cr_trap,\n\t[SVM_EXIT_CR4_WRITE_TRAP]\t\t= cr_trap,\n\t[SVM_EXIT_CR8_WRITE_TRAP]\t\t= cr_trap,\n\t[SVM_EXIT_INVPCID]                      = invpcid_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= npf_interception,\n\t[SVM_EXIT_RSM]                          = rsm_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n\t[SVM_EXIT_VMGEXIT]\t\t\t= sev_handle_vmgexit,\n};\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\tstruct vmcb_save_area *save01 = &svm->vmcb01.ptr->save;\n\n\tif (!dump_invalid_vmcb) {\n\t\tpr_warn_ratelimited(\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tpr_err(\"VMCB %p, last attempted VMRUN on CPU %d\\n\",\n\t       svm->current_vmcb->ptr, vcpu->arch.last_vmentry_cpu);\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercepts[INTERCEPT_CR] & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercepts[INTERCEPT_CR] >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercepts[INTERCEPT_DR] & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercepts[INTERCEPT_DR] >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercepts[INTERCEPT_EXCEPTION]);\n\tpr_err(\"%-20s%08x %08x\\n\", \"intercepts:\",\n              control->intercepts[INTERCEPT_WORD3],\n\t       control->intercepts[INTERCEPT_WORD4]);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%d\\n\", \"pause filter threshold:\",\n\t       control->pause_filter_thresh);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%016llx\\n\", \"ghcb:\", control->ghcb_gpa);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"virt_ext:\", control->virt_ext);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"vmsa_pa:\", control->vmsa_pa);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save01->fs.selector, save01->fs.attrib,\n\t       save01->fs.limit, save01->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save01->gs.selector, save01->gs.attrib,\n\t       save01->gs.limit, save01->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save01->ldtr.selector, save01->ldtr.attrib,\n\t       save01->ldtr.limit, save01->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save01->tr.selector, save01->tr.attrib,\n\t       save01->tr.limit, save01->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save01->star, \"lstar:\", save01->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save01->cstar, \"sfmask:\", save01->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save01->kernel_gs_base,\n\t       \"sysenter_cs:\", save01->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save01->sysenter_esp,\n\t       \"sysenter_eip:\", save01->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}\n\nstatic bool svm_check_exit_valid(u64 exit_code)\n{\n\treturn (exit_code < ARRAY_SIZE(svm_exit_handlers) &&\n\t\tsvm_exit_handlers[exit_code]);\n}\n\nstatic int svm_handle_invalid_exit(struct kvm_vcpu *vcpu, u64 exit_code)\n{\n\tvcpu_unimpl(vcpu, \"svm: unexpected exit reason 0x%llx\\n\", exit_code);\n\tdump_vmcb(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 2;\n\tvcpu->run->internal.data[0] = exit_code;\n\tvcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;\n\treturn 0;\n}\n\nint svm_invoke_exit_handler(struct kvm_vcpu *vcpu, u64 exit_code)\n{\n\tif (!svm_check_exit_valid(exit_code))\n\t\treturn svm_handle_invalid_exit(vcpu, exit_code);\n\n#ifdef CONFIG_RETPOLINE\n\tif (exit_code == SVM_EXIT_MSR)\n\t\treturn msr_interception(vcpu);\n\telse if (exit_code == SVM_EXIT_VINTR)\n\t\treturn interrupt_window_interception(vcpu);\n\telse if (exit_code == SVM_EXIT_INTR)\n\t\treturn intr_interception(vcpu);\n\telse if (exit_code == SVM_EXIT_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_code == SVM_EXIT_NPF)\n\t\treturn npf_interception(vcpu);\n#endif\n\treturn svm_exit_handlers[exit_code](vcpu);\n}\n\nstatic void svm_get_exit_info(struct kvm_vcpu *vcpu, u32 *reason,\n\t\t\t      u64 *info1, u64 *info2,\n\t\t\t      u32 *intr_info, u32 *error_code)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*reason = control->exit_code;\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n\t*intr_info = control->exit_int_info;\n\tif ((*intr_info & SVM_EXITINTINFO_VALID) &&\n\t    (*intr_info & SVM_EXITINTINFO_VALID_ERR))\n\t\t*error_code = control->exit_int_info_err;\n\telse\n\t\t*error_code = 0;\n}\n\nstatic int svm_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(vcpu, KVM_ISA_SVM);\n\n\t/* SEV-ES guests must use the CR write traps to track CR registers. */\n\tif (!sev_es_guest(vcpu->kvm)) {\n\t\tif (!svm_is_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\t\tif (npt_enabled)\n\t\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(vcpu, KVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tkvm_run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_fastpath != EXIT_FASTPATH_NONE)\n\t\treturn 1;\n\n\treturn svm_invoke_exit_handler(vcpu, exit_code);\n}\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}\n\nstatic void pre_svm_run(struct kvm_vcpu *vcpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * If the previous vmrun of the vmcb occurred on a different physical\n\t * cpu, then mark the vmcb dirty and assign a new asid.  Hardware's\n\t * vmcb clean bits are per logical CPU, as are KVM's asid assignments.\n\t */\n\tif (unlikely(svm->current_vmcb->cpu != vcpu->cpu)) {\n\t\tsvm->current_vmcb->asid_generation = 0;\n\t\tvmcb_mark_all_dirty(svm->vmcb);\n\t\tsvm->current_vmcb->cpu = vcpu->cpu;\n        }\n\n\tif (sev_guest(vcpu->kvm))\n\t\treturn pre_sev_run(svm, vcpu->cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->current_vmcb->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}\n\nstatic void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tif (!sev_es_guest(vcpu->kvm))\n\t\tsvm_set_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}\n\nstatic void svm_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}\n\nvoid svm_complete_interrupt_delivery(struct kvm_vcpu *vcpu, int delivery_mode,\n\t\t\t\t     int trig_mode, int vector)\n{\n\t/*\n\t * vcpu->arch.apicv_active must be read after vcpu->mode.\n\t * Pairs with smp_store_release in vcpu_enter_guest.\n\t */\n\tbool in_guest_mode = (smp_load_acquire(&vcpu->mode) == IN_GUEST_MODE);\n\n\tif (!READ_ONCE(vcpu->arch.apicv_active)) {\n\t\t/* Process the interrupt via inject_pending_event */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\treturn;\n\t}\n\n\ttrace_kvm_apicv_accept_irq(vcpu->vcpu_id, delivery_mode, trig_mode, vector);\n\tif (in_guest_mode) {\n\t\t/*\n\t\t * Signal the doorbell to tell hardware to inject the IRQ.  If\n\t\t * the vCPU exits the guest before the doorbell chimes, hardware\n\t\t * will automatically process AVIC interrupts at the next VMRUN.\n\t\t */\n\t\tavic_ring_doorbell(vcpu);\n\t} else {\n\t\t/*\n\t\t * Wake the vCPU if it was blocking.  KVM will then detect the\n\t\t * pending IRQ when checking if the vCPU has a wake event.\n\t\t */\n\t\tkvm_vcpu_wake_up(vcpu);\n\t}\n}\n\nstatic void svm_deliver_interrupt(struct kvm_lapic *apic,  int delivery_mode,\n\t\t\t\t  int trig_mode, int vector)\n{\n\tkvm_lapic_set_irr(vector, apic);\n\n\t/*\n\t * Pairs with the smp_mb_*() after setting vcpu->guest_mode in\n\t * vcpu_enter_guest() to ensure the write to the vIRR is ordered before\n\t * the read of guest_mode.  This guarantees that either VMRUN will see\n\t * and process the new vIRR entry, or that svm_complete_interrupt_delivery\n\t * will signal the doorbell if the CPU has already entered the guest.\n\t */\n\tsmp_mb__after_atomic();\n\tsvm_complete_interrupt_delivery(apic->vcpu, delivery_mode, trig_mode, vector);\n}\n\nstatic void svm_update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * SEV-ES guests must always keep the CR intercepts cleared. CR\n\t * tracking is done using the CR write traps.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn;\n\n\tif (nested_svm_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tsvm_set_intercept(svm, INTERCEPT_CR8_WRITE);\n}\n\nbool svm_nmi_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tbool ret;\n\n\tif (!gif_set(svm))\n\t\treturn true;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_nmi(svm))\n\t\treturn false;\n\n\tret = (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) ||\n\t      (vcpu->arch.hflags & HF_NMI_MASK);\n\n\treturn ret;\n}\n\nstatic int svm_nmi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\tif (svm_nmi_blocked(vcpu))\n\t\treturn 0;\n\n\t/* An NMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_nmi(svm))\n\t\treturn -EBUSY;\n\treturn 1;\n}\n\nstatic bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\treturn !!(vcpu->arch.hflags & HF_NMI_MASK);\n}\n\nstatic void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tvcpu->arch.hflags |= HF_NMI_MASK;\n\t\tif (!sev_es_guest(vcpu->kvm))\n\t\t\tsvm_set_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tvcpu->arch.hflags &= ~HF_NMI_MASK;\n\t\tif (!sev_es_guest(vcpu->kvm))\n\t\t\tsvm_clr_intercept(svm, INTERCEPT_IRET);\n\t}\n}\n\nbool svm_interrupt_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (!gif_set(svm))\n\t\treturn true;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* As long as interrupts are being delivered...  */\n\t\tif ((svm->nested.ctl.int_ctl & V_INTR_MASKING_MASK)\n\t\t    ? !(svm->vmcb01.ptr->save.rflags & X86_EFLAGS_IF)\n\t\t    : !(kvm_get_rflags(vcpu) & X86_EFLAGS_IF))\n\t\t\treturn true;\n\n\t\t/* ... vmexits aren't blocked by the interrupt shadow  */\n\t\tif (nested_exit_on_intr(svm))\n\t\t\treturn false;\n\t} else {\n\t\tif (!svm_get_if_flag(vcpu))\n\t\t\treturn true;\n\t}\n\n\treturn (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK);\n}\n\nstatic int svm_interrupt_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\tif (svm_interrupt_blocked(vcpu))\n\t\treturn 0;\n\n\t/*\n\t * An IRQ must not be injected into L2 if it's supposed to VM-Exit,\n\t * e.g. if the IRQ arrived asynchronously after checking nested events.\n\t */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_intr(svm))\n\t\treturn -EBUSY;\n\n\treturn 1;\n}\n\nstatic void svm_enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept. However, if the vGIF feature is\n\t * enabled, the STGI interception will not occur. Enable the irq\n\t * window under the assumption that the hardware will set the GIF.\n\t */\n\tif (vgif || gif_set(svm)) {\n\t\t/*\n\t\t * IRQ window is not needed when AVIC is enabled,\n\t\t * unless we have pending ExtINT since it cannot be injected\n\t\t * via AVIC. In such case, KVM needs to temporarily disable AVIC,\n\t\t * and fallback to injecting IRQ via V_IRQ.\n\t\t *\n\t\t * If running nested, AVIC is already locally inhibited\n\t\t * on this vCPU, therefore there is no need to request\n\t\t * the VM wide AVIC inhibition.\n\t\t */\n\t\tif (!is_guest_mode(vcpu))\n\t\t\tkvm_set_apicv_inhibit(vcpu->kvm, APICV_INHIBIT_REASON_IRQWIN);\n\n\t\tsvm_set_vintr(svm);\n\t}\n}\n\nstatic void svm_enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((vcpu->arch.hflags & (HF_NMI_MASK | HF_IRET_MASK)) == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif)\n\t\t\tsvm_set_intercept(svm, INTERCEPT_STGI);\n\t\treturn; /* STGI will cause a vm exit */\n\t}\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep_guest_rflags = svm_get_rflags(vcpu);\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n}\n\nstatic void svm_flush_tlb_current(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * Flush only the current ASID even if the TLB flush was invoked via\n\t * kvm_flush_remote_tlbs().  Although flushing remote TLBs requires all\n\t * ASIDs to be flushed, KVM uses a single ASID for L1 and L2, and\n\t * unconditionally does a TLB flush on both nested VM-Enter and nested\n\t * VM-Exit (via kvm_mmu_reset_context()).\n\t */\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->current_vmcb->asid_generation--;\n}\n\nstatic void svm_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tinvlpga(gva, svm->vmcb->control.asid);\n}\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nested_svm_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!svm_is_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (nested_svm_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}\n\nstatic void svm_complete_interrupts(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((vcpu->arch.hflags & HF_IRET_MASK) &&\n\t    (sev_es_guest(vcpu->kvm) ||\n\t     kvm_rip_read(vcpu) != svm->nmi_iret_rip)) {\n\t\tvcpu->arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tvcpu->arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * Never re-inject a #VC exception.\n\t\t */\n\t\tif (vector == X86_TRAP_VC)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(vcpu,\n\t\t\t\t\t      kvm_rip_read(vcpu) - int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(vcpu);\n}\n\nstatic int svm_vcpu_pre_run(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic fastpath_t svm_exit_handlers_fastpath(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_MSR &&\n\t    to_svm(vcpu)->vmcb->control.exit_info_1)\n\t\treturn handle_fastpath_set_msr_irqoff(vcpu);\n\n\treturn EXIT_FASTPATH_NONE;\n}\n\nstatic noinstr void svm_vcpu_enter_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long vmcb_pa = svm->current_vmcb->pa;\n\n\tguest_state_enter_irqoff();\n\n\tif (sev_es_guest(vcpu->kvm)) {\n\t\t__svm_sev_es_vcpu_run(vmcb_pa);\n\t} else {\n\t\tstruct svm_cpu_data *sd = per_cpu(svm_data, vcpu->cpu);\n\n\t\t/*\n\t\t * Use a single vmcb (vmcb01 because it's always valid) for\n\t\t * context switching guest state via VMLOAD/VMSAVE, that way\n\t\t * the state doesn't need to be copied between vmcb01 and\n\t\t * vmcb02 when switching vmcbs for nested virtualization.\n\t\t */\n\t\tvmload(svm->vmcb01.pa);\n\t\t__svm_vcpu_run(vmcb_pa, (unsigned long *)&vcpu->arch.regs);\n\t\tvmsave(svm->vmcb01.pa);\n\n\t\tvmload(__sme_page_pa(sd->save_area));\n\t}\n\n\tguest_state_exit_irqoff();\n}\n\nstatic __no_kcsan fastpath_t svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\ttrace_kvm_entry(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * Disable singlestep if we're injecting an interrupt/exception.\n\t * We don't want our modified rflags to be pushed on the stack where\n\t * we might not be able to easily reset them if we disabled NMI\n\t * singlestep later.\n\t */\n\tif (svm->nmi_singlestep && svm->vmcb->control.event_inj) {\n\t\t/*\n\t\t * Event injection happens before external interrupts cause a\n\t\t * vmexit and interrupts are disabled here, so smp_send_reschedule\n\t\t * is enough to force an immediate vmexit.\n\t\t */\n\t\tdisable_nmi_singlestep(svm);\n\t\tsmp_send_reschedule(vcpu->cpu);\n\t}\n\n\tpre_svm_run(vcpu);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tif (unlikely(svm->asid != svm->vmcb->control.asid)) {\n\t\tsvm->vmcb->control.asid = svm->asid;\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_ASID);\n\t}\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tsvm_hv_update_vp_id(svm->vmcb, vcpu);\n\n\t/*\n\t * Run with all-zero DR6 unless needed, so that we can get the exact cause\n\t * of a #DB.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT))\n\t\tsvm_set_dr6(svm, vcpu->arch.dr6);\n\telse\n\t\tsvm_set_dr6(svm, DR6_ACTIVE_LOW);\n\n\tclgi();\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\tx86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tsvm_vcpu_enter_exit(vcpu);\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL) &&\n\t    unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tsvm->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tif (!sev_es_guest(vcpu->kvm))\n\t\treload_tss(vcpu);\n\n\tif (!static_cpu_has(X86_FEATURE_V_SPEC_CTRL))\n\t\tx86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tif (!sev_es_guest(vcpu->kvm)) {\n\t\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\t\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\t}\n\tvcpu->arch.regs_dirty = 0;\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_interrupt(vcpu, KVM_HANDLING_NMI);\n\n\tkvm_load_host_xsave_state(vcpu);\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_interrupt(vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\tif (is_guest_mode(vcpu)) {\n\t\tnested_sync_control_from_vmcb02(svm);\n\n\t\t/* Track VMRUNs that have made past consistency checking */\n\t\tif (svm->nested.nested_run_pending &&\n\t\t    svm->vmcb->control.exit_code != SVM_EXIT_ERR)\n                        ++vcpu->stat.nested_run;\n\n\t\tsvm->nested.nested_run_pending = 0;\n\t}\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\tvmcb_mark_all_clean(svm->vmcb);\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tvcpu->arch.apf.host_apf_flags =\n\t\t\tkvm_read_and_reset_apf_flags();\n\n\tvcpu->arch.regs_avail &= ~SVM_REGS_LAZY_LOAD_SET;\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(vcpu);\n\n\tsvm_complete_interrupts(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn EXIT_FASTPATH_NONE;\n\n\treturn svm_exit_handlers_fastpath(vcpu);\n}\n\nstatic void svm_load_mmu_pgd(struct kvm_vcpu *vcpu, hpa_t root_hpa,\n\t\t\t     int root_level)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long cr3;\n\n\tif (npt_enabled) {\n\t\tsvm->vmcb->control.nested_cr3 = __sme_set(root_hpa);\n\t\tvmcb_mark_dirty(svm->vmcb, VMCB_NPT);\n\n\t\thv_track_root_tdp(vcpu, root_hpa);\n\n\t\tcr3 = vcpu->arch.cr3;\n\t} else if (vcpu->arch.mmu->root_role.level >= PT64_ROOT_4LEVEL) {\n\t\tcr3 = __sme_set(root_hpa) | kvm_get_active_pcid(vcpu);\n\t} else {\n\t\t/* PCID in the guest should be impossible with a 32-bit MMU. */\n\t\tWARN_ON_ONCE(kvm_get_active_pcid(vcpu));\n\t\tcr3 = root_hpa;\n\t}\n\n\tsvm->vmcb->save.cr3 = cr3;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_CR);\n}\n\nstatic int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}\n\nstatic int __init svm_check_processor_compat(void)\n{\n\treturn 0;\n}\n\n/*\n * The kvm parameter can be NULL (module initialization, or invocation before\n * VM creation). Be sure to check the kvm parameter before using it.\n */\nstatic bool svm_has_emulated_msr(struct kvm *kvm, u32 index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_MCG_EXT_CTL:\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn false;\n\tcase MSR_IA32_SMBASE:\n\t\t/* SEV-ES guests do not support SMM, so report false */\n\t\tif (kvm && sev_es_guest(kvm))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}\n\nstatic void svm_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tvcpu->arch.xsaves_enabled = guest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVES);\n\n\t/* Update nrips enabled cache */\n\tsvm->nrips_enabled = kvm_cpu_cap_has(X86_FEATURE_NRIPS) &&\n\t\t\t     guest_cpuid_has(vcpu, X86_FEATURE_NRIPS);\n\n\tsvm->tsc_scaling_enabled = tsc_scaling && guest_cpuid_has(vcpu, X86_FEATURE_TSCRATEMSR);\n\tsvm->lbrv_enabled = lbrv && guest_cpuid_has(vcpu, X86_FEATURE_LBRV);\n\n\tsvm->v_vmload_vmsave_enabled = vls && guest_cpuid_has(vcpu, X86_FEATURE_V_VMSAVE_VMLOAD);\n\n\tsvm->pause_filter_enabled = kvm_cpu_cap_has(X86_FEATURE_PAUSEFILTER) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PAUSEFILTER);\n\n\tsvm->pause_threshold_enabled = kvm_cpu_cap_has(X86_FEATURE_PFTHRESHOLD) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PFTHRESHOLD);\n\n\tsvm->vgif_enabled = vgif && guest_cpuid_has(vcpu, X86_FEATURE_VGIF);\n\n\tsvm_recalc_instruction_intercepts(vcpu, svm);\n\n\t/* For sev guests, the memory encryption bit is not reserved in CR3.  */\n\tif (sev_guest(vcpu->kvm)) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x8000001F, 0);\n\t\tif (best)\n\t\t\tvcpu->arch.reserved_gpa_bits &= ~(1UL << (best->ebx & 0x3f));\n\t}\n\n\tif (kvm_vcpu_apicv_active(vcpu)) {\n\t\t/*\n\t\t * AVIC does not work with an x2APIC mode guest. If the X2APIC feature\n\t\t * is exposed to the guest, disable AVIC.\n\t\t */\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))\n\t\t\tkvm_set_apicv_inhibit(kvm, APICV_INHIBIT_REASON_X2APIC);\n\t}\n\tinit_vmcb_after_set_cpuid(vcpu);\n}\n\nstatic bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}\n\n#define PRE_EX(exit)  { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_PRE_EXCEPT, }\n#define POST_EX(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_EXCEPT, }\n#define POST_MEM(exit) { .exit_code = (exit), \\\n\t\t\t.stage = X86_ICPT_POST_MEMACCESS, }\n\nstatic const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_xsetbv]\t\t= PRE_EX(SVM_EXIT_XSETBV),\n};\n\n#undef PRE_EX\n#undef POST_EX\n#undef POST_MEM\n\nstatic int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tif (!(vmcb12_is_intercept(&svm->nested.ctl,\n\t\t\t\t\tINTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* TODO: Advertise NRIPS to guest hypervisor unconditionally */\n\tif (static_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}\n\nstatic void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_INTR)\n\t\tvcpu->arch.at_instruction_boundary = true;\n}\n\nstatic void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tshrink_ple_window(vcpu);\n}\n\nstatic void svm_setup_mce(struct kvm_vcpu *vcpu)\n{\n\t/* [63:9] are reserved. */\n\tvcpu->arch.mcg_cap &= 0x1ff;\n}\n\nbool svm_smi_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/* Per APM Vol.2 15.22.2 \"Response to SMI\" */\n\tif (!gif_set(svm))\n\t\treturn true;\n\n\treturn is_smm(vcpu);\n}\n\nstatic int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\tif (svm_smi_blocked(vcpu))\n\t\treturn 0;\n\n\t/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))\n\t\treturn -EBUSY;\n\n\treturn 1;\n}\n\nstatic int svm_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_host_map map_save;\n\tint ret;\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn 0;\n\n\t/* FED8h - SVM Guest */\n\tput_smstate(u64, smstate, 0x7ed8, 1);\n\t/* FEE0h - SVM Guest VMCB Physical Address */\n\tput_smstate(u64, smstate, 0x7ee0, svm->nested.vmcb12_gpa);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\tret = nested_svm_simple_vmexit(svm, SVM_EXIT_SW);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * KVM uses VMCB01 to store L1 host state while L2 runs but\n\t * VMCB01 is going to be used during SMM and thus the state will\n\t * be lost. Temporary save non-VMLOAD/VMSAVE state to the host save\n\t * area pointed to by MSR_VM_HSAVE_PA. APM guarantees that the\n\t * format of the area is identical to guest save area offsetted\n\t * by 0x400 (matches the offset of 'struct vmcb_save_area'\n\t * within 'struct vmcb'). Note: HSAVE area may also be used by\n\t * L1 hypervisor to save additional host context (e.g. KVM does\n\t * that, see svm_prepare_switch_to_guest()) which must be\n\t * preserved.\n\t */\n\tif (kvm_vcpu_map(vcpu, gpa_to_gfn(svm->nested.hsave_msr),\n\t\t\t &map_save) == -EINVAL)\n\t\treturn 1;\n\n\tBUILD_BUG_ON(offsetof(struct vmcb, save) != 0x400);\n\n\tsvm_copy_vmrun_state(map_save.hva + 0x400,\n\t\t\t     &svm->vmcb01.ptr->save);\n\n\tkvm_vcpu_unmap(vcpu, &map_save, true);\n\treturn 0;\n}\n\nstatic int svm_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_host_map map, map_save;\n\tu64 saved_efer, vmcb12_gpa;\n\tstruct vmcb *vmcb12;\n\tint ret;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\treturn 0;\n\n\t/* Non-zero if SMI arrived while vCPU was in guest mode. */\n\tif (!GET_SMSTATE(u64, smstate, 0x7ed8))\n\t\treturn 0;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SVM))\n\t\treturn 1;\n\n\tsaved_efer = GET_SMSTATE(u64, smstate, 0x7ed0);\n\tif (!(saved_efer & EFER_SVME))\n\t\treturn 1;\n\n\tvmcb12_gpa = GET_SMSTATE(u64, smstate, 0x7ee0);\n\tif (kvm_vcpu_map(vcpu, gpa_to_gfn(vmcb12_gpa), &map) == -EINVAL)\n\t\treturn 1;\n\n\tret = 1;\n\tif (kvm_vcpu_map(vcpu, gpa_to_gfn(svm->nested.hsave_msr), &map_save) == -EINVAL)\n\t\tgoto unmap_map;\n\n\tif (svm_allocate_nested(svm))\n\t\tgoto unmap_save;\n\n\t/*\n\t * Restore L1 host state from L1 HSAVE area as VMCB01 was\n\t * used during SMM (see svm_enter_smm())\n\t */\n\n\tsvm_copy_vmrun_state(&svm->vmcb01.ptr->save, map_save.hva + 0x400);\n\n\t/*\n\t * Enter the nested guest now\n\t */\n\n\tvmcb_mark_all_dirty(svm->vmcb01.ptr);\n\n\tvmcb12 = map.hva;\n\tnested_copy_vmcb_control_to_cache(svm, &vmcb12->control);\n\tnested_copy_vmcb_save_to_cache(svm, &vmcb12->save);\n\tret = enter_svm_guest_mode(vcpu, vmcb12_gpa, vmcb12, false);\n\n\tif (ret)\n\t\tgoto unmap_save;\n\n\tsvm->nested.nested_run_pending = 1;\n\nunmap_save:\n\tkvm_vcpu_unmap(vcpu, &map_save, true);\nunmap_map:\n\tkvm_vcpu_unmap(vcpu, &map, true);\n\treturn ret;\n}\n\nstatic void svm_enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif)\n\t\t\tsvm_set_intercept(svm, INTERCEPT_STGI);\n\t\t/* STGI will cause a vm exit */\n\t} else {\n\t\t/* We must be in SMM; RSM will cause a vmexit anyway.  */\n\t}\n}\n\nstatic bool svm_can_emulate_instruction(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\tbool smep, smap, is_user;\n\tunsigned long cr4;\n\tu64 error_code;\n\n\t/* Emulation is always possible when KVM has access to all guest state. */\n\tif (!sev_guest(vcpu->kvm))\n\t\treturn true;\n\n\t/* #UD and #GP should never be intercepted for SEV guests. */\n\tWARN_ON_ONCE(emul_type & (EMULTYPE_TRAP_UD |\n\t\t\t\t  EMULTYPE_TRAP_UD_FORCED |\n\t\t\t\t  EMULTYPE_VMWARE_GP));\n\n\t/*\n\t * Emulation is impossible for SEV-ES guests as KVM doesn't have access\n\t * to guest register state.\n\t */\n\tif (sev_es_guest(vcpu->kvm))\n\t\treturn false;\n\n\t/*\n\t * Emulation is possible if the instruction is already decoded, e.g.\n\t * when completing I/O after returning from userspace.\n\t */\n\tif (emul_type & EMULTYPE_NO_DECODE)\n\t\treturn true;\n\n\t/*\n\t * Emulation is possible for SEV guests if and only if a prefilled\n\t * buffer containing the bytes of the intercepted instruction is\n\t * available. SEV guest memory is encrypted with a guest specific key\n\t * and cannot be decrypted by KVM, i.e. KVM would read cyphertext and\n\t * decode garbage.\n\t *\n\t * Inject #UD if KVM reached this point without an instruction buffer.\n\t * In practice, this path should never be hit by a well-behaved guest,\n\t * e.g. KVM doesn't intercept #UD or #GP for SEV guests, but this path\n\t * is still theoretically reachable, e.g. via unaccelerated fault-like\n\t * AVIC access, and needs to be handled by KVM to avoid putting the\n\t * guest into an infinite loop.   Injecting #UD is somewhat arbitrary,\n\t * but its the least awful option given lack of insight into the guest.\n\t */\n\tif (unlikely(!insn)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Emulate for SEV guests if the insn buffer is not empty.  The buffer\n\t * will be empty if the DecodeAssist microcode cannot fetch bytes for\n\t * the faulting instruction because the code fetch itself faulted, e.g.\n\t * the guest attempted to fetch from emulated MMIO or a guest page\n\t * table used to translate CS:RIP resides in emulated MMIO.\n\t */\n\tif (likely(insn_len))\n\t\treturn true;\n\n\t/*\n\t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.\n\t *\n\t * Errata:\n\t * When CPU raises #NPF on guest data access and vCPU CR4.SMAP=1, it is\n\t * possible that CPU microcode implementing DecodeAssist will fail to\n\t * read guest memory at CS:RIP and vmcb.GuestIntrBytes will incorrectly\n\t * be '0'.  This happens because microcode reads CS:RIP using a _data_\n\t * loap uop with CPL=0 privileges.  If the load hits a SMAP #PF, ucode\n\t * gives up and does not fill the instruction bytes buffer.\n\t *\n\t * As above, KVM reaches this point iff the VM is an SEV guest, the CPU\n\t * supports DecodeAssist, a #NPF was raised, KVM's page fault handler\n\t * triggered emulation (e.g. for MMIO), and the CPU returned 0 in the\n\t * GuestIntrBytes field of the VMCB.\n\t *\n\t * This does _not_ mean that the erratum has been encountered, as the\n\t * DecodeAssist will also fail if the load for CS:RIP hits a legitimate\n\t * #PF, e.g. if the guest attempt to execute from emulated MMIO and\n\t * encountered a reserved/not-present #PF.\n\t *\n\t * To hit the erratum, the following conditions must be true:\n\t *    1. CR4.SMAP=1 (obviously).\n\t *    2. CR4.SMEP=0 || CPL=3.  If SMEP=1 and CPL<3, the erratum cannot\n\t *       have been hit as the guest would have encountered a SMEP\n\t *       violation #PF, not a #NPF.\n\t *    3. The #NPF is not due to a code fetch, in which case failure to\n\t *       retrieve the instruction bytes is legitimate (see abvoe).\n\t *\n\t * In addition, don't apply the erratum workaround if the #NPF occurred\n\t * while translating guest page tables (see below).\n\t */\n\terror_code = to_svm(vcpu)->vmcb->control.exit_info_1;\n\tif (error_code & (PFERR_GUEST_PAGE_MASK | PFERR_FETCH_MASK))\n\t\tgoto resume_guest;\n\n\tcr4 = kvm_read_cr4(vcpu);\n\tsmep = cr4 & X86_CR4_SMEP;\n\tsmap = cr4 & X86_CR4_SMAP;\n\tis_user = svm_get_cpl(vcpu) == 3;\n\tif (smap && (!smep || is_user)) {\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\n\t\t/*\n\t\t * If the fault occurred in userspace, arbitrarily inject #GP\n\t\t * to avoid killing the guest and to hopefully avoid confusing\n\t\t * the guest kernel too much, e.g. injecting #PF would not be\n\t\t * coherent with respect to the guest's page tables.  Request\n\t\t * triple fault if the fault occurred in the kernel as there's\n\t\t * no fault that KVM can inject without confusing the guest.\n\t\t * In practice, the triple fault is moot as no sane SEV kernel\n\t\t * will execute from user memory while also running with SMAP=1.\n\t\t */\n\t\tif (is_user)\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\telse\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\nresume_guest:\n\t/*\n\t * If the erratum was not hit, simply resume the guest and let it fault\n\t * again.  While awful, e.g. the vCPU may get stuck in an infinite loop\n\t * if the fault is at CPL=0, it's the lesser of all evils.  Exiting to\n\t * userspace will kill the guest, and letting the emulator read garbage\n\t * will yield random behavior and potentially corrupt the guest.\n\t *\n\t * Simply resuming the guest is technically not a violation of the SEV\n\t * architecture.  AMD's APM states that all code fetches and page table\n\t * accesses for SEV guest are encrypted, regardless of the C-Bit.  The\n\t * APM also states that encrypted accesses to MMIO are \"ignored\", but\n\t * doesn't explicitly define \"ignored\", i.e. doing nothing and letting\n\t * the guest spin is technically \"ignoring\" the access.\n\t */\n\treturn false;\n}\n\nstatic bool svm_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * TODO: Last condition latch INIT signals on vCPU when\n\t * vCPU is in guest-mode and vmcb12 defines intercept on INIT.\n\t * To properly emulate the INIT intercept,\n\t * svm_check_nested_events() should call nested_svm_vmexit()\n\t * if an INIT signal is pending.\n\t */\n\treturn !gif_set(svm) ||\n\t\t   (vmcb_is_intercept(&svm->vmcb->control, INTERCEPT_INIT));\n}\n\nstatic void svm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tif (!sev_es_guest(vcpu->kvm))\n\t\treturn kvm_vcpu_deliver_sipi_vector(vcpu, vector);\n\n\tsev_vcpu_deliver_sipi_vector(vcpu, vector);\n}\n\nstatic void svm_vm_destroy(struct kvm *kvm)\n{\n\tavic_vm_destroy(kvm);\n\tsev_vm_destroy(kvm);\n}\n\nstatic int svm_vm_init(struct kvm *kvm)\n{\n\tif (!pause_filter_count || !pause_filter_thresh)\n\t\tkvm->arch.pause_in_guest = true;\n\n\tif (enable_apicv) {\n\t\tint ret = avic_vm_init(kvm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct kvm_x86_ops svm_x86_ops __initdata = {\n\t.name = \"kvm_amd\",\n\n\t.hardware_unsetup = svm_hardware_unsetup,\n\t.hardware_enable = svm_hardware_enable,\n\t.hardware_disable = svm_hardware_disable,\n\t.has_emulated_msr = svm_has_emulated_msr,\n\n\t.vcpu_create = svm_vcpu_create,\n\t.vcpu_free = svm_vcpu_free,\n\t.vcpu_reset = svm_vcpu_reset,\n\n\t.vm_size = sizeof(struct kvm_svm),\n\t.vm_init = svm_vm_init,\n\t.vm_destroy = svm_vm_destroy,\n\n\t.prepare_switch_to_guest = svm_prepare_switch_to_guest,\n\t.vcpu_load = svm_vcpu_load,\n\t.vcpu_put = svm_vcpu_put,\n\t.vcpu_blocking = avic_vcpu_blocking,\n\t.vcpu_unblocking = avic_vcpu_unblocking,\n\n\t.update_exception_bitmap = svm_update_exception_bitmap,\n\t.get_msr_feature = svm_get_msr_feature,\n\t.get_msr = svm_get_msr,\n\t.set_msr = svm_set_msr,\n\t.get_segment_base = svm_get_segment_base,\n\t.get_segment = svm_get_segment,\n\t.set_segment = svm_set_segment,\n\t.get_cpl = svm_get_cpl,\n\t.get_cs_db_l_bits = svm_get_cs_db_l_bits,\n\t.set_cr0 = svm_set_cr0,\n\t.post_set_cr3 = sev_post_set_cr3,\n\t.is_valid_cr4 = svm_is_valid_cr4,\n\t.set_cr4 = svm_set_cr4,\n\t.set_efer = svm_set_efer,\n\t.get_idt = svm_get_idt,\n\t.set_idt = svm_set_idt,\n\t.get_gdt = svm_get_gdt,\n\t.set_gdt = svm_set_gdt,\n\t.set_dr7 = svm_set_dr7,\n\t.sync_dirty_debug_regs = svm_sync_dirty_debug_regs,\n\t.cache_reg = svm_cache_reg,\n\t.get_rflags = svm_get_rflags,\n\t.set_rflags = svm_set_rflags,\n\t.get_if_flag = svm_get_if_flag,\n\n\t.flush_tlb_all = svm_flush_tlb_current,\n\t.flush_tlb_current = svm_flush_tlb_current,\n\t.flush_tlb_gva = svm_flush_tlb_gva,\n\t.flush_tlb_guest = svm_flush_tlb_current,\n\n\t.vcpu_pre_run = svm_vcpu_pre_run,\n\t.vcpu_run = svm_vcpu_run,\n\t.handle_exit = svm_handle_exit,\n\t.skip_emulated_instruction = svm_skip_emulated_instruction,\n\t.update_emulated_instruction = NULL,\n\t.set_interrupt_shadow = svm_set_interrupt_shadow,\n\t.get_interrupt_shadow = svm_get_interrupt_shadow,\n\t.patch_hypercall = svm_patch_hypercall,\n\t.inject_irq = svm_inject_irq,\n\t.inject_nmi = svm_inject_nmi,\n\t.queue_exception = svm_queue_exception,\n\t.cancel_injection = svm_cancel_injection,\n\t.interrupt_allowed = svm_interrupt_allowed,\n\t.nmi_allowed = svm_nmi_allowed,\n\t.get_nmi_mask = svm_get_nmi_mask,\n\t.set_nmi_mask = svm_set_nmi_mask,\n\t.enable_nmi_window = svm_enable_nmi_window,\n\t.enable_irq_window = svm_enable_irq_window,\n\t.update_cr8_intercept = svm_update_cr8_intercept,\n\t.refresh_apicv_exec_ctrl = avic_refresh_apicv_exec_ctrl,\n\t.check_apicv_inhibit_reasons = avic_check_apicv_inhibit_reasons,\n\t.apicv_post_state_restore = avic_apicv_post_state_restore,\n\n\t.get_mt_mask = svm_get_mt_mask,\n\t.get_exit_info = svm_get_exit_info,\n\n\t.vcpu_after_set_cpuid = svm_vcpu_after_set_cpuid,\n\n\t.has_wbinvd_exit = svm_has_wbinvd_exit,\n\n\t.get_l2_tsc_offset = svm_get_l2_tsc_offset,\n\t.get_l2_tsc_multiplier = svm_get_l2_tsc_multiplier,\n\t.write_tsc_offset = svm_write_tsc_offset,\n\t.write_tsc_multiplier = svm_write_tsc_multiplier,\n\n\t.load_mmu_pgd = svm_load_mmu_pgd,\n\n\t.check_intercept = svm_check_intercept,\n\t.handle_exit_irqoff = svm_handle_exit_irqoff,\n\n\t.request_immediate_exit = __kvm_request_immediate_exit,\n\n\t.sched_in = svm_sched_in,\n\n\t.nested_ops = &svm_nested_ops,\n\n\t.deliver_interrupt = svm_deliver_interrupt,\n\t.pi_update_irte = avic_pi_update_irte,\n\t.setup_mce = svm_setup_mce,\n\n\t.smi_allowed = svm_smi_allowed,\n\t.enter_smm = svm_enter_smm,\n\t.leave_smm = svm_leave_smm,\n\t.enable_smi_window = svm_enable_smi_window,\n\n\t.mem_enc_ioctl = sev_mem_enc_ioctl,\n\t.mem_enc_register_region = sev_mem_enc_register_region,\n\t.mem_enc_unregister_region = sev_mem_enc_unregister_region,\n\t.guest_memory_reclaimed = sev_guest_memory_reclaimed,\n\n\t.vm_copy_enc_context_from = sev_vm_copy_enc_context_from,\n\t.vm_move_enc_context_from = sev_vm_move_enc_context_from,\n\n\t.can_emulate_instruction = svm_can_emulate_instruction,\n\n\t.apic_init_signal_blocked = svm_apic_init_signal_blocked,\n\n\t.msr_filter_changed = svm_msr_filter_changed,\n\t.complete_emulated_msr = svm_complete_emulated_msr,\n\n\t.vcpu_deliver_sipi_vector = svm_vcpu_deliver_sipi_vector,\n\t.vcpu_get_apicv_inhibit_reasons = avic_vcpu_get_apicv_inhibit_reasons,\n};\n\n/*\n * The default MMIO mask is a single bit (excluding the present bit),\n * which could conflict with the memory encryption bit. Check for\n * memory encryption support and override the default MMIO mask if\n * memory encryption is enabled.\n */\nstatic __init void svm_adjust_mmio_mask(void)\n{\n\tunsigned int enc_bit, mask_bit;\n\tu64 msr, mask;\n\n\t/* If there is no memory encryption support, use existing mask */\n\tif (cpuid_eax(0x80000000) < 0x8000001f)\n\t\treturn;\n\n\t/* If memory encryption is not enabled, use existing mask */\n\trdmsrl(MSR_AMD64_SYSCFG, msr);\n\tif (!(msr & MSR_AMD64_SYSCFG_MEM_ENCRYPT))\n\t\treturn;\n\n\tenc_bit = cpuid_ebx(0x8000001f) & 0x3f;\n\tmask_bit = boot_cpu_data.x86_phys_bits;\n\n\t/* Increment the mask bit if it is the same as the encryption bit */\n\tif (enc_bit == mask_bit)\n\t\tmask_bit++;\n\n\t/*\n\t * If the mask bit location is below 52, then some bits above the\n\t * physical addressing limit will always be reserved, so use the\n\t * rsvd_bits() function to generate the mask. This mask, along with\n\t * the present bit, will be used to generate a page fault with\n\t * PFER.RSV = 1.\n\t *\n\t * If the mask bit location is 52 (or above), then clear the mask.\n\t */\n\tmask = (mask_bit < 52) ? rsvd_bits(mask_bit, 51) | PT_PRESENT_MASK : 0;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, PT_WRITABLE_MASK | PT_USER_MASK);\n}\n\nstatic __init void svm_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\tsupported_xss = 0;\n\n\t/* CPUID 0x80000001 and 0x8000000A (SVM features) */\n\tif (nested) {\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVM);\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMCBCLEAN);\n\n\t\tif (nrips)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NRIPS);\n\n\t\tif (npt_enabled)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NPT);\n\n\t\tif (tsc_scaling)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_TSCRATEMSR);\n\n\t\tif (vls)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_V_VMSAVE_VMLOAD);\n\t\tif (lbrv)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_LBRV);\n\n\t\tif (boot_cpu_has(X86_FEATURE_PAUSEFILTER))\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_PAUSEFILTER);\n\n\t\tif (boot_cpu_has(X86_FEATURE_PFTHRESHOLD))\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_PFTHRESHOLD);\n\n\t\tif (vgif)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_VGIF);\n\n\t\t/* Nested VM can receive #VMEXIT instead of triggering #GP */\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVME_ADDR_CHK);\n\t}\n\n\t/* CPUID 0x80000008 */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||\n\t    boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n\n\t/* AMD PMU PERFCTR_CORE CPUID */\n\tif (enable_pmu && boot_cpu_has(X86_FEATURE_PERFCTR_CORE))\n\t\tkvm_cpu_cap_set(X86_FEATURE_PERFCTR_CORE);\n\n\t/* CPUID 0x8000001F (SME/SEV features) */\n\tsev_set_cpu_caps();\n}\n\nstatic __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\tunsigned int order = get_order(IOPM_SIZE);\n\n\t/*\n\t * NX is required for shadow paging and for NPT if the NX huge pages\n\t * mitigation is enabled.\n\t */\n\tif (!boot_cpu_has(X86_FEATURE_NX)) {\n\t\tpr_err_ratelimited(\"NX (Execute Disable) not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tkvm_enable_efer_bits(EFER_NX);\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, order);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << order));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (tsc_scaling) {\n\t\tif (!boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\t\ttsc_scaling = false;\n\t\t} else {\n\t\t\tpr_info(\"TSC scaling supported\\n\");\n\t\t\tkvm_has_tsc_control = true;\n\t\t}\n\t}\n\tkvm_max_tsc_scaling_ratio = SVM_TSC_RATIO_MAX;\n\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\n\ttsc_aux_uret_slot = kvm_add_user_return_msr(MSR_TSC_AUX);\n\n\t/* Check for pause filtering support */\n\tif (!boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tpause_filter_count = 0;\n\t\tpause_filter_thresh = 0;\n\t} else if (!boot_cpu_has(X86_FEATURE_PFTHRESHOLD)) {\n\t\tpause_filter_thresh = 0;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\t/*\n\t * KVM's MMU doesn't support using 2-level paging for itself, and thus\n\t * NPT isn't supported if the host is using 2-level paging since host\n\t * CR4 is unchanged on VMRUN.\n\t */\n\tif (!IS_ENABLED(CONFIG_X86_64) && !IS_ENABLED(CONFIG_X86_PAE))\n\t\tnpt_enabled = false;\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\t/* Force VM NPT level equal to the host's paging level */\n\tkvm_configure_mmu(npt_enabled, get_npt_level(),\n\t\t\t  get_npt_level(), PG_LEVEL_1G);\n\tpr_info(\"kvm: Nested Paging %sabled\\n\", npt_enabled ? \"en\" : \"dis\");\n\n\t/* Setup shadow_me_value and shadow_me_mask */\n\tkvm_mmu_set_me_spte_mask(sme_me_mask, sme_me_mask);\n\n\t/* Note, SEV setup consumes npt_enabled. */\n\tsev_hardware_setup();\n\n\tsvm_hv_hardware_setup();\n\n\tsvm_adjust_mmio_mask();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (nrips) {\n\t\tif (!boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tnrips = false;\n\t}\n\n\tenable_apicv = avic = avic && npt_enabled && (boot_cpu_has(X86_FEATURE_AVIC) || force_avic);\n\n\tif (enable_apicv) {\n\t\tif (!boot_cpu_has(X86_FEATURE_AVIC)) {\n\t\t\tpr_warn(\"AVIC is not supported in CPUID but force enabled\");\n\t\t\tpr_warn(\"Your system might crash and burn\");\n\t\t} else\n\t\t\tpr_info(\"AVIC enabled\\n\");\n\n\t\tamd_iommu_register_ga_log_notifier(&avic_ga_log_notifier);\n\t} else {\n\t\tsvm_x86_ops.vcpu_blocking = NULL;\n\t\tsvm_x86_ops.vcpu_unblocking = NULL;\n\t\tsvm_x86_ops.vcpu_get_apicv_inhibit_reasons = NULL;\n\t}\n\n\tif (vls) {\n\t\tif (!npt_enabled ||\n\t\t    !boot_cpu_has(X86_FEATURE_V_VMSAVE_VMLOAD) ||\n\t\t    !IS_ENABLED(CONFIG_X86_64)) {\n\t\t\tvls = false;\n\t\t} else {\n\t\t\tpr_info(\"Virtual VMLOAD VMSAVE supported\\n\");\n\t\t}\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_SVME_ADDR_CHK))\n\t\tsvm_gp_erratum_intercept = false;\n\n\tif (vgif) {\n\t\tif (!boot_cpu_has(X86_FEATURE_VGIF))\n\t\t\tvgif = false;\n\t\telse\n\t\t\tpr_info(\"Virtual GIF supported\\n\");\n\t}\n\n\tif (lbrv) {\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV))\n\t\t\tlbrv = false;\n\t\telse\n\t\t\tpr_info(\"LBR virtualization supported\\n\");\n\t}\n\n\tif (!enable_pmu)\n\t\tpr_info(\"PMU virtualization is disabled\\n\");\n\n\tsvm_set_cpu_caps();\n\n\t/*\n\t * It seems that on AMD processors PTE's accessed bit is\n\t * being set by the CPU hardware before the NPF vmexit.\n\t * This is not expected behaviour and our tests fail because\n\t * of it.\n\t * A workaround here is to disable support for\n\t * GUEST_MAXPHYADDR < HOST_MAXPHYADDR if NPT is enabled.\n\t * In this case userspace can know if there is support using\n\t * KVM_CAP_SMALLER_MAXPHYADDR extension and decide how to handle\n\t * it\n\t * If future AMD CPU models change the behaviour described above,\n\t * this variable can be changed accordingly\n\t */\n\tallow_smaller_maxphyaddr = !npt_enabled;\n\n\treturn 0;\n\nerr:\n\tsvm_hardware_unsetup();\n\treturn r;\n}\n\n\nstatic struct kvm_x86_init_ops svm_init_ops __initdata = {\n\t.cpu_has_kvm_support = has_svm,\n\t.disabled_by_bios = is_disabled,\n\t.hardware_setup = svm_hardware_setup,\n\t.check_processor_compatibility = svm_check_processor_compat,\n\n\t.runtime_ops = &svm_x86_ops,\n\t.pmu_ops = &amd_pmu_ops,\n};\n\nstatic int __init svm_init(void)\n{\n\t__unused_size_checks();\n\n\treturn kvm_init(&svm_init_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}\n\nstatic void __exit svm_exit(void)\n{\n\tkvm_exit();\n}\n\nmodule_init(svm_init)\nmodule_exit(svm_exit)\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * This module enables machines with Intel VT-x extensions to run virtual\n * machines without emulation or binary translation.\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n */\n\n#include <linux/highmem.h>\n#include <linux/hrtimer.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mm.h>\n#include <linux/objtool.h>\n#include <linux/sched.h>\n#include <linux/sched/smt.h>\n#include <linux/slab.h>\n#include <linux/tboot.h>\n#include <linux/trace_events.h>\n#include <linux/entry-kvm.h>\n\n#include <asm/apic.h>\n#include <asm/asm.h>\n#include <asm/cpu.h>\n#include <asm/cpu_device_id.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/fpu/api.h>\n#include <asm/fpu/xstate.h>\n#include <asm/idtentry.h>\n#include <asm/io.h>\n#include <asm/irq_remapping.h>\n#include <asm/kexec.h>\n#include <asm/perf_event.h>\n#include <asm/mmu_context.h>\n#include <asm/mshyperv.h>\n#include <asm/mwait.h>\n#include <asm/spec-ctrl.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n\n#include \"capabilities.h\"\n#include \"cpuid.h\"\n#include \"evmcs.h\"\n#include \"hyperv.h\"\n#include \"kvm_onhyperv.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include \"lapic.h\"\n#include \"mmu.h\"\n#include \"nested.h\"\n#include \"pmu.h\"\n#include \"sgx.h\"\n#include \"trace.h\"\n#include \"vmcs.h\"\n#include \"vmcs12.h\"\n#include \"vmx.h\"\n#include \"x86.h\"\n\nMODULE_AUTHOR(\"Qumranet\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef MODULE\nstatic const struct x86_cpu_id vmx_cpu_id[] = {\n\tX86_MATCH_FEATURE(X86_FEATURE_VMX, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, vmx_cpu_id);\n#endif\n\nbool __read_mostly enable_vpid = 1;\nmodule_param_named(vpid, enable_vpid, bool, 0444);\n\nstatic bool __read_mostly enable_vnmi = 1;\nmodule_param_named(vnmi, enable_vnmi, bool, S_IRUGO);\n\nbool __read_mostly flexpriority_enabled = 1;\nmodule_param_named(flexpriority, flexpriority_enabled, bool, S_IRUGO);\n\nbool __read_mostly enable_ept = 1;\nmodule_param_named(ept, enable_ept, bool, S_IRUGO);\n\nbool __read_mostly enable_unrestricted_guest = 1;\nmodule_param_named(unrestricted_guest,\n\t\t\tenable_unrestricted_guest, bool, S_IRUGO);\n\nbool __read_mostly enable_ept_ad_bits = 1;\nmodule_param_named(eptad, enable_ept_ad_bits, bool, S_IRUGO);\n\nstatic bool __read_mostly emulate_invalid_guest_state = true;\nmodule_param(emulate_invalid_guest_state, bool, S_IRUGO);\n\nstatic bool __read_mostly fasteoi = 1;\nmodule_param(fasteoi, bool, S_IRUGO);\n\nmodule_param(enable_apicv, bool, S_IRUGO);\n\n/*\n * If nested=1, nested virtualization is supported, i.e., guests may use\n * VMX and be a hypervisor for its own guests. If nested=0, guests may not\n * use VMX instructions.\n */\nstatic bool __read_mostly nested = 1;\nmodule_param(nested, bool, S_IRUGO);\n\nbool __read_mostly enable_pml = 1;\nmodule_param_named(pml, enable_pml, bool, S_IRUGO);\n\nstatic bool __read_mostly dump_invalid_vmcs = 0;\nmodule_param(dump_invalid_vmcs, bool, 0644);\n\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n\n#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL\n\n/* Guest_tsc -> host_tsc conversion requires 64-bit division.  */\nstatic int __read_mostly cpu_preemption_timer_multi;\nstatic bool __read_mostly enable_preemption_timer = 1;\n#ifdef CONFIG_X86_64\nmodule_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);\n#endif\n\nextern bool __read_mostly allow_smaller_maxphyaddr;\nmodule_param(allow_smaller_maxphyaddr, bool, S_IRUGO);\n\n#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | X86_CR0_PG | X86_CR0_PE)\n\n#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\n#define MSR_IA32_RTIT_STATUS_MASK (~(RTIT_STATUS_FILTEREN | \\\n\tRTIT_STATUS_CONTEXTEN | RTIT_STATUS_TRIGGEREN | \\\n\tRTIT_STATUS_ERROR | RTIT_STATUS_STOPPED | \\\n\tRTIT_STATUS_BYTECNT))\n\n/*\n * List of MSRs that can be directly passed to the guest.\n * In addition to these x2apic and PT MSRs are handled specially.\n */\nstatic u32 vmx_possible_passthrough_msrs[MAX_POSSIBLE_PASSTHROUGH_MSRS] = {\n\tMSR_IA32_SPEC_CTRL,\n\tMSR_IA32_PRED_CMD,\n\tMSR_IA32_TSC,\n#ifdef CONFIG_X86_64\n\tMSR_FS_BASE,\n\tMSR_GS_BASE,\n\tMSR_KERNEL_GS_BASE,\n\tMSR_IA32_XFD,\n\tMSR_IA32_XFD_ERR,\n#endif\n\tMSR_IA32_SYSENTER_CS,\n\tMSR_IA32_SYSENTER_ESP,\n\tMSR_IA32_SYSENTER_EIP,\n\tMSR_CORE_C1_RES,\n\tMSR_CORE_C3_RESIDENCY,\n\tMSR_CORE_C6_RESIDENCY,\n\tMSR_CORE_C7_RESIDENCY,\n};\n\n/*\n * These 2 parameters are used to config the controls for Pause-Loop Exiting:\n * ple_gap:    upper bound on the amount of time between two successive\n *             executions of PAUSE in a loop. Also indicate if ple enabled.\n *             According to test, this time is usually smaller than 128 cycles.\n * ple_window: upper bound on the amount of time a guest is allowed to execute\n *             in a PAUSE loop. Tests indicate that most spinlocks are held for\n *             less than 2^12 cycles\n * Time is measured based on a counter that runs at the same rate as the TSC,\n * refer SDM volume 3b section 21.6.13 & 22.1.3.\n */\nstatic unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;\nmodule_param(ple_gap, uint, 0444);\n\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nmodule_param(ple_window, uint, 0444);\n\n/* Default doubles per-vcpu window every exit. */\nstatic unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nmodule_param(ple_window_grow, uint, 0444);\n\n/* Default resets per-vcpu window every exit to ple_window. */\nstatic unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nmodule_param(ple_window_shrink, uint, 0444);\n\n/* Default is to compute the maximum so we can never overflow. */\nstatic unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nmodule_param(ple_window_max, uint, 0444);\n\n/* Default is SYSTEM mode, 1 for host-guest mode */\nint __read_mostly pt_mode = PT_MODE_SYSTEM;\nmodule_param(pt_mode, int, S_IRUGO);\n\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic DEFINE_MUTEX(vmx_l1d_flush_mutex);\n\n/* Storage for pre module init parameter parsing */\nstatic enum vmx_l1d_flush_state __read_mostly vmentry_l1d_flush_param = VMENTER_L1D_FLUSH_AUTO;\n\nstatic const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};\n\n#define L1D_CACHE_ORDER 4\nstatic void *vmx_l1d_flush_pages;\n\nstatic int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}\n\nstatic int vmentry_l1d_flush_parse(const char *s)\n{\n\tunsigned int i;\n\n\tif (s) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {\n\t\t\tif (vmentry_l1d_param[i].for_parse &&\n\t\t\t    sysfs_streq(s, vmentry_l1d_param[i].option))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)\n{\n\tint l1tf, ret;\n\n\tl1tf = vmentry_l1d_flush_parse(s);\n\tif (l1tf < 0)\n\t\treturn l1tf;\n\n\tif (!boot_cpu_has(X86_BUG_L1TF))\n\t\treturn 0;\n\n\t/*\n\t * Has vmx_init() run already? If not then this is the pre init\n\t * parameter parsing. In that case just store the value and let\n\t * vmx_init() do the proper setup after enable_ept has been\n\t * established.\n\t */\n\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {\n\t\tvmentry_l1d_flush_param = l1tf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&vmx_l1d_flush_mutex);\n\tret = vmx_setup_l1d_flush(l1tf);\n\tmutex_unlock(&vmx_l1d_flush_mutex);\n\treturn ret;\n}\n\nstatic int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)\n{\n\tif (WARN_ON_ONCE(l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)))\n\t\treturn sprintf(s, \"???\\n\");\n\n\treturn sprintf(s, \"%s\\n\", vmentry_l1d_param[l1tf_vmx_mitigation].option);\n}\n\nstatic const struct kernel_param_ops vmentry_l1d_flush_ops = {\n\t.set = vmentry_l1d_flush_set,\n\t.get = vmentry_l1d_flush_get,\n};\nmodule_param_cb(vmentry_l1d_flush, &vmentry_l1d_flush_ops, NULL, 0644);\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\n\nvoid vmx_vmexit(void);\n\n#define vmx_insn_failed(fmt...)\t\t\\\ndo {\t\t\t\t\t\\\n\tWARN_ONCE(1, fmt);\t\t\\\n\tpr_warn_ratelimited(fmt);\t\\\n} while (0)\n\nasmlinkage void vmread_error(unsigned long field, bool fault)\n{\n\tif (fault)\n\t\tkvm_spurious_fault();\n\telse\n\t\tvmx_insn_failed(\"kvm: vmread failed: field=%lx\\n\", field);\n}\n\nnoinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tvmx_insn_failed(\"kvm: vmwrite failed: field=%lx val=%lx err=%d\\n\",\n\t\t\tfield, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n}\n\nnoinline void vmclear_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmclear failed: %p/%llx\\n\", vmcs, phys_addr);\n}\n\nnoinline void vmptrld_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmptrld failed: %p/%llx\\n\", vmcs, phys_addr);\n}\n\nnoinline void invvpid_error(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tvmx_insn_failed(\"kvm: invvpid failed: ext=0x%lx vpid=%u gva=0x%lx\\n\",\n\t\t\text, vpid, gva);\n}\n\nnoinline void invept_error(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tvmx_insn_failed(\"kvm: invept failed: ext=0x%lx eptp=%llx gpa=0x%llx\\n\",\n\t\t\text, eptp, gpa);\n}\n\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);\n/*\n * We maintain a per-CPU linked-list of VMCS loaded on that CPU. This is needed\n * when a CPU is brought down, and we need to VMCLEAR all VMCSs loaded on it.\n */\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nstruct vmcs_config vmcs_config;\nstruct vmx_capability vmx_capability;\n\n#define VMX_SEGMENT_FIELD(seg)\t\t\t\t\t\\\n\t[VCPU_SREG_##seg] = {                                   \\\n\t\t.selector = GUEST_##seg##_SELECTOR,\t\t\\\n\t\t.base = GUEST_##seg##_BASE,\t\t   \t\\\n\t\t.limit = GUEST_##seg##_LIMIT,\t\t   \t\\\n\t\t.ar_bytes = GUEST_##seg##_AR_BYTES,\t   \t\\\n\t}\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}\n\nstatic unsigned long host_idt_base;\n\n#if IS_ENABLED(CONFIG_HYPERV)\nstatic bool __read_mostly enlightened_vmcs = true;\nmodule_param(enlightened_vmcs, bool, 0444);\n\nstatic int hv_enable_direct_tlbflush(struct kvm_vcpu *vcpu)\n{\n\tstruct hv_enlightened_vmcs *evmcs;\n\tstruct hv_partition_assist_pg **p_hv_pa_pg =\n\t\t\t&to_kvm_hv(vcpu->kvm)->hv_pa_pg;\n\t/*\n\t * Synthetic VM-Exit is not enabled in current code and so All\n\t * evmcs in singe VM shares same assist page.\n\t */\n\tif (!*p_hv_pa_pg)\n\t\t*p_hv_pa_pg = kzalloc(PAGE_SIZE, GFP_KERNEL_ACCOUNT);\n\n\tif (!*p_hv_pa_pg)\n\t\treturn -ENOMEM;\n\n\tevmcs = (struct hv_enlightened_vmcs *)to_vmx(vcpu)->loaded_vmcs->vmcs;\n\n\tevmcs->partition_assist_page =\n\t\t__pa(*p_hv_pa_pg);\n\tevmcs->hv_vm_id = (unsigned long)vcpu->kvm;\n\tevmcs->hv_enlightenments_control.nested_flush_hypercall = 1;\n\n\treturn 0;\n}\n\n#endif /* IS_ENABLED(CONFIG_HYPERV) */\n\n/*\n * Comment's format: document - errata name - stepping - processor name.\n * Refer from\n * https://www.virtualbox.org/svn/vbox/trunk/src/VBox/VMM/VMMR0/HMR0.cpp\n */\nstatic u32 vmx_preemption_cpu_tfms[] = {\n/* 323344.pdf - BA86   - D0 - Xeon 7500 Series */\n0x000206E6,\n/* 323056.pdf - AAX65  - C2 - Xeon L3406 */\n/* 322814.pdf - AAT59  - C2 - i7-600, i5-500, i5-400 and i3-300 Mobile */\n/* 322911.pdf - AAU65  - C2 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020652,\n/* 322911.pdf - AAU65  - K0 - i5-600, i3-500 Desktop and Pentium G6950 */\n0x00020655,\n/* 322373.pdf - AAO95  - B1 - Xeon 3400 Series */\n/* 322166.pdf - AAN92  - B1 - i7-800 and i5-700 Desktop */\n/*\n * 320767.pdf - AAP86  - B1 -\n * i7-900 Mobile Extreme, i7-800 and i7-700 Mobile\n */\n0x000106E5,\n/* 321333.pdf - AAM126 - C0 - Xeon 3500 */\n0x000106A0,\n/* 321333.pdf - AAM126 - C1 - Xeon 3500 */\n0x000106A1,\n/* 320836.pdf - AAJ124 - C0 - i7-900 Desktop Extreme and i7-900 Desktop */\n0x000106A4,\n /* 321333.pdf - AAM126 - D0 - Xeon 3500 */\n /* 321324.pdf - AAK139 - D0 - Xeon 5500 */\n /* 320836.pdf - AAJ124 - D0 - i7-900 Extreme and i7-900 Desktop */\n0x000106A5,\n /* Xeon E3-1220 V2 */\n0x000306A8,\n};\n\nstatic inline bool cpu_has_broken_vmx_preemption_timer(void)\n{\n\tu32 eax = cpuid_eax(0x00000001), i;\n\n\t/* Clear the reserved bits */\n\teax &= ~(0x3U << 14 | 0xfU << 28);\n\tfor (i = 0; i < ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)\n\t\tif (eax == vmx_preemption_cpu_tfms[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}\n\nstatic int possible_passthrough_msr_slot(u32 msr)\n{\n\tu32 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_possible_passthrough_msrs); i++)\n\t\tif (vmx_possible_passthrough_msrs[i] == msr)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic bool is_valid_passthrough_msr(u32 msr)\n{\n\tbool r;\n\n\tswitch (msr) {\n\tcase 0x800 ... 0x8ff:\n\t\t/* x2APIC MSRs. These are handled in vmx_update_msr_bitmap_x2apic() */\n\t\treturn true;\n\tcase MSR_IA32_RTIT_STATUS:\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\t/* PT MSRs. These are handled in pt_update_intercept_for_msr() */\n\tcase MSR_LBR_SELECT:\n\tcase MSR_LBR_TOS:\n\tcase MSR_LBR_INFO_0 ... MSR_LBR_INFO_0 + 31:\n\tcase MSR_LBR_NHM_FROM ... MSR_LBR_NHM_FROM + 31:\n\tcase MSR_LBR_NHM_TO ... MSR_LBR_NHM_TO + 31:\n\tcase MSR_LBR_CORE_FROM ... MSR_LBR_CORE_FROM + 8:\n\tcase MSR_LBR_CORE_TO ... MSR_LBR_CORE_TO + 8:\n\t\t/* LBR MSRs. These are handled in vmx_update_intercept_for_lbr_msrs() */\n\t\treturn true;\n\t}\n\n\tr = possible_passthrough_msr_slot(msr) != -ENOENT;\n\n\tWARN(!r, \"Invalid MSR %x, please adapt vmx_possible_passthrough_msrs[]\", msr);\n\n\treturn r;\n}\n\nstruct vmx_uret_msr *vmx_find_uret_msr(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = kvm_find_user_return_msr(msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_uret_msrs[i];\n\treturn NULL;\n}\n\nstatic int vmx_set_guest_uret_msr(struct vcpu_vmx *vmx,\n\t\t\t\t  struct vmx_uret_msr *msr, u64 data)\n{\n\tunsigned int slot = msr - vmx->guest_uret_msrs;\n\tint ret = 0;\n\n\tif (msr->load_into_hardware) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_user_return_msr(slot, data, msr->mask);\n\t\tpreempt_enable();\n\t}\n\tif (!ret)\n\t\tmsr->data = data;\n\treturn ret;\n}\n\n#ifdef CONFIG_KEXEC_CORE\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}\n#endif /* CONFIG_KEXEC_CORE */\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * Ensure all writes to loaded_vmcs, including deleting it from its\n\t * current percpu list, complete before setting loaded_vmcs->cpu to\n\t * -1, otherwise a different cpu can see loaded_vmcs->cpu == -1 first\n\t * and add loaded_vmcs to its percpu list before it's deleted from this\n\t * cpu's list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}\n\nvoid vmx_update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (!vmx_need_pf_intercept(vcpu))\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n        else {\n\t\tint mask = 0, match = 0;\n\n\t\tif (enable_ept && (eb & (1u << PF_VECTOR))) {\n\t\t\t/*\n\t\t\t * If EPT is enabled, #PF is currently only intercepted\n\t\t\t * if MAXPHYADDR is smaller on the guest than on the\n\t\t\t * host.  In that case we only care about present,\n\t\t\t * non-reserved faults.  For vmcs02, however, PFEC_MASK\n\t\t\t * and PFEC_MATCH are set in prepare_vmcs02_rare.\n\t\t\t */\n\t\t\tmask = PFERR_PRESENT_MASK | PFERR_RSVD_MASK;\n\t\t\tmatch = PFERR_PRESENT_MASK;\n\t\t}\n\t\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, mask);\n\t\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, match);\n\t}\n\n\t/*\n\t * Disabling xfd interception indicates that dynamic xfeatures\n\t * might be used in the guest. Always trap #NM in this case\n\t * to save guest xfd_err timely.\n\t */\n\tif (vcpu->arch.xfd_no_write_intercept)\n\t\teb |= (1u << NM_VECTOR);\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}\n\n/*\n * Check if MSR is intercepted for currently loaded MSR bitmap.\n */\nstatic bool msr_write_intercepted(struct vcpu_vmx *vmx, u32 msr)\n{\n\tif (!(exec_controls_get(vmx) & CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn true;\n\n\treturn vmx_test_msr_bitmap_write(vmx->loaded_vmcs->msr_bitmap,\n\t\t\t\t\t MSR_IA32_SPEC_CTRL);\n}\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}\n\nint vmx_find_loadstore_msr_slot(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_loadstore_msr_slot(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_loadstore_msr_slot(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tif (host_val_vmcs != HOST_IA32_EFER)\n\t\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_loadstore_msr_slot(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_loadstore_msr_slot(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == MAX_NR_LOADSTORE_MSRS) ||\n\t    (j < 0 &&  m->host.nr == MAX_NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\tint i;\n\n\t/* Shadow paging assumes NX to be available.  */\n\tif (!enable_ept)\n\t\tguest_efer |= EFER_NX;\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer() ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer, false);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t\treturn false;\n\t}\n\n\ti = kvm_find_user_return_msr(MSR_EFER);\n\tif (i < 0)\n\t\treturn false;\n\n\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\tguest_efer &= ~ignore_bits;\n\tguest_efer |= host_efer & ignore_bits;\n\n\tvmx->guest_uret_msrs[i].data = guest_efer;\n\tvmx->guest_uret_msrs[i].mask = ~ignore_bits;\n\n\treturn true;\n}\n\n#ifdef CONFIG_X86_32\n/*\n * On 32-bit kernels, VM exits still load the FS and GS bases from the\n * VMCS rather than the segment table.  KVM uses this helper to figure\n * out the current bases to poke them into the VMCS before entry.\n */\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}\n#endif\n\nstatic inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}\n\nstatic inline bool pt_output_base_valid(struct kvm_vcpu *vcpu, u64 base)\n{\n\t/* The base must be 128-byte aligned and a legal physical address. */\n\treturn kvm_vcpu_is_legal_aligned_gpa(vcpu, base, 128);\n}\n\nstatic inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}\n\nstatic inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}\n\nstatic void pt_guest_enter(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\t/*\n\t * GUEST_IA32_RTIT_CTL is already set in the VMCS.\n\t * Save host state before VM entry.\n\t */\n\trdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\twrmsrl(MSR_IA32_RTIT_CTL, 0);\n\t\tpt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.num_address_ranges);\n\t\tpt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.num_address_ranges);\n\t}\n}\n\nstatic void pt_guest_exit(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\tpt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.num_address_ranges);\n\t\tpt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.num_address_ranges);\n\t}\n\n\t/*\n\t * KVM requires VM_EXIT_CLEAR_IA32_RTIT_CTL to expose PT to the guest,\n\t * i.e. RTIT_CTL is always cleared on VM-Exit.  Restore it if necessary.\n\t */\n\tif (vmx->pt_desc.host.ctl)\n\t\twrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n}\n\nvoid vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base)\n{\n\tif (unlikely(fs_sel != host->fs_sel)) {\n\t\tif (!(fs_sel & 7))\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, fs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\thost->fs_sel = fs_sel;\n\t}\n\tif (unlikely(gs_sel != host->gs_sel)) {\n\t\tif (!(gs_sel & 7))\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, gs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\thost->gs_sel = gs_sel;\n\t}\n\tif (unlikely(fs_base != host->fs_base)) {\n\t\tvmcs_writel(HOST_FS_BASE, fs_base);\n\t\thost->fs_base = fs_base;\n\t}\n\tif (unlikely(gs_base != host->gs_base)) {\n\t\tvmcs_writel(HOST_GS_BASE, gs_base);\n\t\thost->gs_base = gs_base;\n\t}\n}\n\nvoid vmx_prepare_switch_to_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs_host_state *host_state;\n#ifdef CONFIG_X86_64\n\tint cpu = raw_smp_processor_id();\n#endif\n\tunsigned long fs_base, gs_base;\n\tu16 fs_sel, gs_sel;\n\tint i;\n\n\tvmx->req_immediate_exit = false;\n\n\t/*\n\t * Note that guest MSRs to be saved/restored can also be changed\n\t * when guest state is loaded. This happens when guest transitions\n\t * to/from long-mode by setting MSR_EFER.LMA.\n\t */\n\tif (!vmx->guest_uret_msrs_loaded) {\n\t\tvmx->guest_uret_msrs_loaded = true;\n\t\tfor (i = 0; i < kvm_nr_uret_msrs; ++i) {\n\t\t\tif (!vmx->guest_uret_msrs[i].load_into_hardware)\n\t\t\t\tcontinue;\n\n\t\t\tkvm_set_user_return_msr(i,\n\t\t\t\t\t\tvmx->guest_uret_msrs[i].data,\n\t\t\t\t\t\tvmx->guest_uret_msrs[i].mask);\n\t\t}\n\t}\n\n    \tif (vmx->nested.need_vmcs12_to_shadow_sync)\n\t\tnested_sync_vmcs12_to_shadow(vcpu);\n\n\tif (vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\thost_state->ldt_sel = kvm_read_ldt();\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, host_state->ds_sel);\n\tsavesegment(es, host_state->es_sel);\n\n\tgs_base = cpu_kernelmode_gs_base(cpu);\n\tif (likely(is_64bit_mm(current->mm))) {\n\t\tcurrent_save_fsgs();\n\t\tfs_sel = current->thread.fsindex;\n\t\tgs_sel = current->thread.gsindex;\n\t\tfs_base = current->thread.fsbase;\n\t\tvmx->msr_host_kernel_gs_base = current->thread.gsbase;\n\t} else {\n\t\tsavesegment(fs, fs_sel);\n\t\tsavesegment(gs, gs_sel);\n\t\tfs_base = read_msr(MSR_FS_BASE);\n\t\tvmx->msr_host_kernel_gs_base = read_msr(MSR_KERNEL_GS_BASE);\n\t}\n\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#else\n\tsavesegment(fs, fs_sel);\n\tsavesegment(gs, gs_sel);\n\tfs_base = segment_base(fs_sel);\n\tgs_base = segment_base(gs_sel);\n#endif\n\n\tvmx_set_host_fs_gs(host_state, fs_sel, gs_sel, fs_base, gs_base);\n\tvmx->guest_state_loaded = true;\n}\n\nstatic void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs_host_state *host_state;\n\n\tif (!vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (host_state->ldt_sel || (host_state->gs_sel & 7)) {\n\t\tkvm_load_ldt(host_state->ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(host_state->gs_sel);\n#else\n\t\tloadsegment(gs, host_state->gs_sel);\n#endif\n\t}\n\tif (host_state->fs_sel & 7)\n\t\tloadsegment(fs, host_state->fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(host_state->ds_sel | host_state->es_sel)) {\n\t\tloadsegment(ds, host_state->ds_sel);\n\t\tloadsegment(es, host_state->es_sel);\n\t}\n#endif\n\tinvalidate_tss_limit();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tload_fixmap_gdt(raw_smp_processor_id());\n\tvmx->guest_state_loaded = false;\n\tvmx->guest_uret_msrs_loaded = false;\n}\n\n#ifdef CONFIG_X86_64\nstatic u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\tpreempt_enable();\n\treturn vmx->msr_guest_kernel_gs_base;\n}\n\nstatic void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}\n#endif\n\nvoid vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu,\n\t\t\tstruct loaded_vmcs *buddy)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\tstruct vmcs *prev;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tprev = per_cpu(current_vmcs, cpu);\n\tif (prev != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\n\t\t/*\n\t\t * No indirect branch prediction barrier needed when switching\n\t\t * the active VMCS within a guest, e.g. on nested VM-Enter.\n\t\t * The L1 VMM can protect itself with retpolines, IBPB or IBRS.\n\t\t */\n\t\tif (!buddy || WARN_ON_ONCE(buddy->vmcs != prev))\n\t\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\n\t\t/*\n\t\t * Flush all EPTP/VPID contexts, the new pCPU may have stale\n\t\t * TLB entries from its previous association with the vCPU.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\tif (IS_ENABLED(CONFIG_IA32_EMULATION) || IS_ENABLED(CONFIG_X86_32)) {\n\t\t\t/* 22.2.3 */\n\t\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP,\n\t\t\t\t    (unsigned long)(cpu_entry_stack(cpu) + 1));\n\t\t}\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n}\n\n/*\n * Switches to specified vcpu, until a matching vcpu_put(), but assumes\n * vcpu mutex is already taken.\n */\nstatic void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_vcpu_load_vmcs(vcpu, cpu, NULL);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\n\tvmx->host_debugctlmsr = get_debugctlmsr();\n}\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\tvmx_prepare_switch_to_host(to_vmx(vcpu));\n}\n\nbool vmx_emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !vmx_guest_state_valid(vcpu);\n}\n\nunsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}\n\nvoid vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long old_rflags;\n\n\tif (is_unrestricted_guest(vcpu)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\tvmx->rflags = rflags;\n\t\tvmcs_writel(GUEST_RFLAGS, rflags);\n\t\treturn;\n\t}\n\n\told_rflags = vmx_get_rflags(vcpu);\n\tvmx->rflags = rflags;\n\tif (vmx->rmode.vm86_active) {\n\t\tvmx->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n\n\tif ((old_rflags ^ vmx->rflags) & X86_EFLAGS_VM)\n\t\tvmx->emulation_required = vmx_emulation_required(vcpu);\n}\n\nstatic bool vmx_get_if_flag(struct kvm_vcpu *vcpu)\n{\n\treturn vmx_get_rflags(vcpu) & X86_EFLAGS_IF;\n}\n\nu32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}\n\nvoid vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}\n\nstatic int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long value;\n\n\t/*\n\t * Any MSR write that attempts to change bits marked reserved will\n\t * case a #GP fault.\n\t */\n\tif (data & vmx->pt_desc.ctl_bitmask)\n\t\treturn 1;\n\n\t/*\n\t * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will\n\t * result in a #GP unless the same write also clears TraceEn.\n\t */\n\tif ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&\n\t\t((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))\n\t\treturn 1;\n\n\t/*\n\t * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit\n\t * and FabricEn would cause #GP, if\n\t * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0\n\t */\n\tif ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&\n\t\t!(data & RTIT_CTL_FABRIC_EN) &&\n\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output))\n\t\treturn 1;\n\n\t/*\n\t * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that\n\t * utilize encodings marked reserved will cause a #GP fault.\n\t */\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc) &&\n\t\t\t!test_bit((data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cycle_thresholds);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET, &value))\n\t\treturn 1;\n\n\t/*\n\t * If ADDRx_CFG is reserved or the encodings is >2 will\n\t * cause a #GP fault.\n\t */\n\tvalue = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 1)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 2)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 3)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;\n\tif ((value && (vmx->pt_desc.num_address_ranges < 4)) || (value > 2))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic bool vmx_can_emulate_instruction(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\t/*\n\t * Emulation of instructions in SGX enclaves is impossible as RIP does\n\t * not point at the failing instruction, and even if it did, the code\n\t * stream is inaccessible.  Inject #UD instead of exiting to userspace\n\t * so that guest userspace can't DoS the guest simply by triggering\n\t * emulation (enclaves are CPL3 only).\n\t */\n\tif (to_vmx(vcpu)->exit_reason.enclave_mode) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunion vmx_exit_reason exit_reason = to_vmx(vcpu)->exit_reason;\n\tunsigned long rip, orig_rip;\n\tu32 instr_len;\n\n\t/*\n\t * Using VMCS.VM_EXIT_INSTRUCTION_LEN on EPT misconfig depends on\n\t * undefined behavior: Intel's SDM doesn't mandate the VMCS field be\n\t * set when EPT misconfig occurs.  In practice, real hardware updates\n\t * VM_EXIT_INSTRUCTION_LEN on EPT misconfig, but other hypervisors\n\t * (namely Hyper-V) don't set it due to it being undefined behavior,\n\t * i.e. we end up advancing IP with some random value.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||\n\t    exit_reason.basic != EXIT_REASON_EPT_MISCONFIG) {\n\t\tinstr_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\n\t\t/*\n\t\t * Emulating an enclave's instructions isn't supported as KVM\n\t\t * cannot access the enclave's memory or its true RIP, e.g. the\n\t\t * vmcs.GUEST_RIP points at the exit point of the enclave, not\n\t\t * the RIP that actually triggered the VM-Exit.  But, because\n\t\t * most instructions that cause VM-Exit will #UD in an enclave,\n\t\t * most instruction-based VM-Exits simply do not occur.\n\t\t *\n\t\t * There are a few exceptions, notably the debug instructions\n\t\t * INT1ICEBRK and INT3, as they are allowed in debug enclaves\n\t\t * and generate #DB/#BP as expected, which KVM might intercept.\n\t\t * But again, the CPU does the dirty work and saves an instr\n\t\t * length of zero so VMMs don't shoot themselves in the foot.\n\t\t * WARN if KVM tries to skip a non-zero length instruction on\n\t\t * a VM-Exit from an enclave.\n\t\t */\n\t\tif (!instr_len)\n\t\t\tgoto rip_updated;\n\n\t\tWARN(exit_reason.enclave_mode,\n\t\t     \"KVM: skipping instruction after SGX enclave VM-Exit\");\n\n\t\torig_rip = kvm_rip_read(vcpu);\n\t\trip = orig_rip + instr_len;\n#ifdef CONFIG_X86_64\n\t\t/*\n\t\t * We need to mask out the high 32 bits of RIP if not in 64-bit\n\t\t * mode, but just finding out that we are in 64-bit mode is\n\t\t * quite expensive.  Only do it if there was a carry.\n\t\t */\n\t\tif (unlikely(((rip ^ orig_rip) >> 31) == 3) && !is_64_bit_mode(vcpu))\n\t\t\trip = (u32)rip;\n#endif\n\t\tkvm_rip_write(vcpu, rip);\n\t} else {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t}\n\nrip_updated:\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}\n\n/*\n * Recognizes a pending MTF VM-exit and records the nested state for later\n * delivery.\n */\nstatic void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn;\n\n\t/*\n\t * Per the SDM, MTF takes priority over debug-trap exceptions besides\n\t * T-bit traps. As instruction emulation is completed (i.e. at the\n\t * instruction boundary), any #DB exception pending delivery must be a\n\t * debug-trap. Record the pending MTF state to be delivered in\n\t * vmx_check_nested_events().\n\t */\n\tif (nested_cpu_has_mtf(vmcs12) &&\n\t    (!vcpu->arch.exception.pending ||\n\t     vcpu->arch.exception.nr == DB_VECTOR))\n\t\tvmx->nested.mtf_pending = true;\n\telse\n\t\tvmx->nested.mtf_pending = false;\n}\n\nstatic int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tkvm_deliver_exception_payload(vcpu);\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, nr, inc_eip);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(vmx->emulation_required);\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n\n\tvmx_clear_hlt(vcpu);\n}\n\nstatic void vmx_setup_uret_msr(struct vcpu_vmx *vmx, unsigned int msr,\n\t\t\t       bool load_into_hardware)\n{\n\tstruct vmx_uret_msr *uret_msr;\n\n\turet_msr = vmx_find_uret_msr(vmx, msr);\n\tif (!uret_msr)\n\t\treturn;\n\n\turet_msr->load_into_hardware = load_into_hardware;\n}\n\n/*\n * Configuring user return MSRs to automatically save, load, and restore MSRs\n * that need to be shoved into hardware when running the guest.  Note, omitting\n * an MSR here does _NOT_ mean it's not emulated, only that it will not be\n * loaded into hardware when running the guest.\n */\nstatic void vmx_setup_uret_msrs(struct vcpu_vmx *vmx)\n{\n#ifdef CONFIG_X86_64\n\tbool load_syscall_msrs;\n\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tload_syscall_msrs = is_long_mode(&vmx->vcpu) &&\n\t\t\t    (vmx->vcpu.arch.efer & EFER_SCE);\n\n\tvmx_setup_uret_msr(vmx, MSR_STAR, load_syscall_msrs);\n\tvmx_setup_uret_msr(vmx, MSR_LSTAR, load_syscall_msrs);\n\tvmx_setup_uret_msr(vmx, MSR_SYSCALL_MASK, load_syscall_msrs);\n#endif\n\tvmx_setup_uret_msr(vmx, MSR_EFER, update_transition_efer(vmx));\n\n\tvmx_setup_uret_msr(vmx, MSR_TSC_AUX,\n\t\t\t   guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP) ||\n\t\t\t   guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDPID));\n\n\t/*\n\t * hle=0, rtm=0, tsx_ctrl=1 can be found with some combinations of new\n\t * kernel and old userspace.  If those guests run on a tsx=off host, do\n\t * allow guests to use TSX_CTRL, but don't change the value in hardware\n\t * so that TSX remains always disabled.\n\t */\n\tvmx_setup_uret_msr(vmx, MSR_IA32_TSX_CTRL, boot_cpu_has(X86_FEATURE_RTM));\n\n\t/*\n\t * The set of MSRs to load may have changed, reload MSRs before the\n\t * next VM-Enter.\n\t */\n\tvmx->guest_uret_msrs_loaded = false;\n}\n\nu64 vmx_get_l2_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vmcs12->tsc_offset;\n\n\treturn 0;\n}\n\nu64 vmx_get_l2_tsc_multiplier(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_USE_TSC_OFFSETTING) &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_TSC_SCALING))\n\t\treturn vmcs12->tsc_multiplier;\n\n\treturn kvm_default_tsc_scaling_ratio;\n}\n\nstatic void vmx_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tvmcs_write64(TSC_OFFSET, offset);\n}\n\nstatic void vmx_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 multiplier)\n{\n\tvmcs_write64(TSC_MULTIPLIER, multiplier);\n}\n\n/*\n * nested_vmx_allowed() checks whether a guest should be allowed to use VMX\n * instructions and MSRs (i.e., nested VMX). Nested VMX is disabled for\n * all guests if the \"nested\" module option is off, and can also be disabled\n * for a single guest by disabling its VMX cpuid bit.\n */\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}\n\nstatic inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}\n\nstatic int vmx_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested)\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(&vmcs_config.nested, msr->index, &msr->data);\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\tmsr->data = vmx_get_perf_capabilities();\n\t\treturn 0;\n\tdefault:\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n}\n\n/*\n * Reads an msr value (of 'msr_info->index') into 'msr_info->data'.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmx_uret_msr *msr;\n\tu32 index;\n\n\tswitch (msr_info->index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = vmx_read_guest_kernel_gs_base(vmx);\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tgoto find_uret_msr;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vmx->msr_ia32_umwait_control;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = to_vmx(vcpu)->spec_ctrl;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vmx->msr_ia32_feature_control &\n\t\t      FEAT_CTL_LMCE_ENABLED))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.mcg_ext_ctl;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tmsr_info->data = vmx->msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_SGXLEPUBKEYHASH0 ... MSR_IA32_SGXLEPUBKEYHASH3:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))\n\t\t\treturn 1;\n\t\tmsr_info->data = to_vmx(vcpu)->msr_ia32_sgxlepubkeyhash\n\t\t\t[msr_info->index - MSR_IA32_SGXLEPUBKEYHASH0];\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\tif (vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,\n\t\t\t\t    &msr_info->data))\n\t\t\treturn 1;\n\t\t/*\n\t\t * Enlightened VMCS v1 doesn't have certain VMCS fields but\n\t\t * instead of just ignoring the features, different Hyper-V\n\t\t * versions are either trying to use them and fail or do some\n\t\t * sanity checking and refuse to boot. Filter all unsupported\n\t\t * features out.\n\t\t */\n\t\tif (!msr_info->host_initiated &&\n\t\t    vmx->nested.enlightened_vmcs_enabled)\n\t\t\tnested_evmcs_filter_control_msr(msr_info->index,\n\t\t\t\t\t\t\t&msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.ctl;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.status;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.cr3_match;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_base;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_mask;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t    (index >= 2 * vmx->pt_desc.num_address_ranges))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_b[index / 2];\n\t\telse\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_a[index / 2];\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\t\tbreak;\n\tdefault:\n\tfind_uret_msr:\n\t\tmsr = vmx_find_uret_msr(vmx, msr_info->index);\n\t\tif (msr) {\n\t\t\tmsr_info->data = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}\n\nstatic u64 nested_vmx_truncate_sysenter_addr(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t    u64 data)\n{\n#ifdef CONFIG_X86_64\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\treturn (u32)data;\n#endif\n\treturn (unsigned long)data;\n}\n\nstatic u64 vcpu_supported_debugctl(struct kvm_vcpu *vcpu)\n{\n\tu64 debugctl = vmx_supported_debugctl();\n\n\tif (!intel_pmu_lbr_is_enabled(vcpu))\n\t\tdebugctl &= ~DEBUGCTLMSR_LBR_MASK;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))\n\t\tdebugctl &= ~DEBUGCTLMSR_BUS_LOCK_DETECT;\n\n\treturn debugctl;\n}\n\n/*\n * Writes msr value into the appropriate \"register\".\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmx_uret_msr *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\tu32 index;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_write_guest_kernel_gs_base(vmx, data);\n\t\tbreak;\n\tcase MSR_IA32_XFD:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\t/*\n\t\t * Always intercepting WRMSR could incur non-negligible\n\t\t * overhead given xfd might be changed frequently in\n\t\t * guest context switch. Disable write interception\n\t\t * upon the first write with a non-zero value (indicating\n\t\t * potential usage on dynamic xfeatures). Also update\n\t\t * exception bitmap to trap #NM for proper virtualization\n\t\t * of guest xfd_err.\n\t\t */\n\t\tif (!ret && data) {\n\t\t\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_XFD,\n\t\t\t\t\t\t      MSR_TYPE_RW);\n\t\t\tvcpu->arch.xfd_no_write_intercept = true;\n\t\t\tvmx_update_exception_bitmap(vcpu);\n\t\t}\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_cs = data;\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tdata = nested_vmx_truncate_sysenter_addr(vcpu, data);\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_eip = data;\n\t\t}\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tif (is_guest_mode(vcpu)) {\n\t\t\tdata = nested_vmx_truncate_sysenter_addr(vcpu, data);\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_esp = data;\n\t\t}\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR: {\n\t\tu64 invalid = data & ~vcpu_supported_debugctl(vcpu);\n\t\tif (invalid & (DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR)) {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu, \"%s: BTF|LBR in IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t\t\t    __func__, data);\n\t\t\tdata &= ~(DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR);\n\t\t\tinvalid &= ~(DEBUGCTLMSR_BTF|DEBUGCTLMSR_LBR);\n\t\t}\n\n\t\tif (invalid)\n\t\t\treturn 1;\n\n\t\tif (is_guest_mode(vcpu) && get_vmcs12(vcpu)->vm_exit_controls &\n\t\t\t\t\t\tVM_EXIT_SAVE_DEBUG_CONTROLS)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_debugctl = data;\n\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, data);\n\t\tif (intel_pmu_lbr_is_enabled(vcpu) && !to_vmx(vcpu)->lbr_desc.event &&\n\t\t    (data & DEBUGCTLMSR_LBR))\n\t\t\tintel_pmu_create_guest_lbr_event(vcpu);\n\t\treturn 0;\n\t}\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data & PAGE_MASK, vcpu) ||\n\t\t    (data & MSR_IA32_BNDCFGS_RSVD))\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\t/* The reserved bit 1 and non-32 bit [63:32] should be zero */\n\t\tif (data & (BIT_ULL(1) | GENMASK_ULL(63, 32)))\n\t\t\treturn 1;\n\n\t\tvmx->msr_ia32_umwait_control = data;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_spec_ctrl_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (kvm_spec_ctrl_test_value(data))\n\t\t\treturn 1;\n\n\t\tvmx->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging. We update the vmcs01 here for L1 as well\n\t\t * since it will end up touching the MSR anyway now.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vcpu,\n\t\t\t\t\t      MSR_IA32_SPEC_CTRL,\n\t\t\t\t\t      MSR_TYPE_RW);\n\t\tbreak;\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tif (data & ~(TSX_CTRL_RTM_DISABLE | TSX_CTRL_CPUID_CLEAR))\n\t\t\treturn 1;\n\t\tgoto find_uret_msr;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_has_pred_cmd_msr(vcpu))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_IBPB))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_PRED_CMD, MSR_TYPE_W);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_pat_valid(data))\n\t\t\treturn 1;\n\n\t\tif (is_guest_mode(vcpu) &&\n\t\t    get_vmcs12(vcpu)->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_pat = data;\n\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif ((!msr_info->host_initiated &&\n\t\t     !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t       FEAT_CTL_LMCE_ENABLED)) ||\n\t\t    (data & ~MCG_EXT_CTL_LMCE_EN))\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ext_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tif (!vmx_feature_control_msr_valid(vcpu, data) ||\n\t\t    (to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t     FEAT_CTL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\n\t\t/* SGX may be enabled/disabled by guest's firmware */\n\t\tvmx_write_encls_bitmap(vcpu, NULL);\n\t\tbreak;\n\tcase MSR_IA32_SGXLEPUBKEYHASH0 ... MSR_IA32_SGXLEPUBKEYHASH3:\n\t\t/*\n\t\t * On real hardware, the LE hash MSRs are writable before\n\t\t * the firmware sets bit 0 in MSR 0x7a (\"activating\" SGX),\n\t\t * at which point SGX related bits in IA32_FEATURE_CONTROL\n\t\t * become writable.\n\t\t *\n\t\t * KVM does not emulate SGX activation for simplicity, so\n\t\t * allow writes to the LE hash MSRs if IA32_FEATURE_CONTROL\n\t\t * is unlocked.  This is technically not architectural\n\t\t * behavior, but it's close enough.\n\t\t */\n\t\tif (!msr_info->host_initiated &&\n\t\t    (!guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC) ||\n\t\t    ((vmx->msr_ia32_feature_control & FEAT_CTL_LOCKED) &&\n\t\t    !(vmx->msr_ia32_feature_control & FEAT_CTL_SGX_LC_ENABLED))))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_sgxlepubkeyhash\n\t\t\t[msr_index - MSR_IA32_SGXLEPUBKEYHASH0] = data;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1; /* they are read-only */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_set_vmx_msr(vcpu, msr_index, data);\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\tvmx_rtit_ctl_check(vcpu, data) ||\n\t\t\tvmx->nested.vmxon)\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, data);\n\t\tvmx->pt_desc.guest.ctl = data;\n\t\tpt_update_intercept_for_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (data & MSR_IA32_RTIT_STATUS_MASK)\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.status = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.cr3_match = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tif (!pt_output_base_valid(vcpu, data))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_base = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_mask = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (index >= 2 * vmx->pt_desc.num_address_ranges)\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data, vcpu))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tvmx->pt_desc.guest.addr_b[index / 2] = data;\n\t\telse\n\t\t\tvmx->pt_desc.guest.addr_a[index / 2] = data;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\tif (data && !vcpu_to_pmu(vcpu)->version)\n\t\t\treturn 1;\n\t\tif (data & PMU_CAP_LBR_FMT) {\n\t\t\tif ((data & PMU_CAP_LBR_FMT) !=\n\t\t\t    (vmx_get_perf_capabilities() & PMU_CAP_LBR_FMT))\n\t\t\t\treturn 1;\n\t\t\tif (!intel_pmu_lbr_is_compatible(vcpu))\n\t\t\t\treturn 1;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\n\tdefault:\n\tfind_uret_msr:\n\t\tmsr = vmx_find_uret_msr(vmx, msr_index);\n\t\tif (msr)\n\t\t\tret = vmx_set_guest_uret_msr(vmx, msr, data);\n\t\telse\n\t\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tunsigned long guest_owned_bits;\n\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tcase VCPU_EXREG_CR0:\n\t\tguest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\t\tvcpu->arch.cr0 &= ~guest_owned_bits;\n\t\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & guest_owned_bits;\n\t\tbreak;\n\tcase VCPU_EXREG_CR3:\n\t\t/*\n\t\t * When intercepting CR3 loads, e.g. for shadowing paging, KVM's\n\t\t * CR3 is loaded into hardware, not the guest's CR3.\n\t\t */\n\t\tif (!(exec_controls_get(to_vmx(vcpu)) & CPU_BASED_CR3_LOAD_EXITING))\n\t\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t\tbreak;\n\tcase VCPU_EXREG_CR4:\n\t\tguest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\t\tvcpu->arch.cr4 &= ~guest_owned_bits;\n\t\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & guest_owned_bits;\n\t\tbreak;\n\tdefault:\n\t\tKVM_BUG_ON(1, vcpu->kvm);\n\t\tbreak;\n\t}\n}\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\treturn !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t       !boot_cpu_has(X86_FEATURE_VMX);\n}\n\nstatic int kvm_cpu_vmxon(u64 vmxon_pointer)\n{\n\tu64 msr;\n\n\tcr4_set_bits(X86_CR4_VMXE);\n\n\tasm_volatile_goto(\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : : fault);\n\treturn 0;\n\nfault:\n\tWARN_ONCE(1, \"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\",\n\t\t  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);\n\tcr4_clear_bits(X86_CR4_VMXE);\n\n\treturn -EFAULT;\n}\n\nstatic int vmx_hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tint r;\n\n\tif (cr4_read_shadow() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\t/*\n\t * This can happen if we hot-added a CPU but failed to allocate\n\t * VP assist page for it.\n\t */\n\tif (static_branch_unlikely(&enable_evmcs) &&\n\t    !hv_get_vp_assist_page(cpu))\n\t\treturn -EFAULT;\n\n\tintel_pt_handle_vmx(1);\n\n\tr = kvm_cpu_vmxon(phys_addr);\n\tif (r) {\n\t\tintel_pt_handle_vmx(0);\n\t\treturn r;\n\t}\n\n\tif (enable_ept)\n\t\tept_sync_global();\n\n\treturn 0;\n}\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}\n\nstatic void vmx_hardware_disable(void)\n{\n\tvmclear_local_loaded_vmcss();\n\n\tif (cpu_vmxoff())\n\t\tkvm_spurious_fault();\n\n\tintel_pt_handle_vmx(0);\n}\n\n/*\n * There is no X86_FEATURE for SGX yet, but anyway we need to query CPUID\n * directly instead of going through cpu_has(), to ensure KVM is trapping\n * ENCLS whenever it's supported in hardware.  It does not matter whether\n * the host OS supports or has enabled SGX.\n */\nstatic bool cpu_has_sgx(void)\n{\n\treturn cpuid_eax(0) >= 0x12 && (cpuid_eax(0x12) & BIT(0));\n}\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}\n\nstatic __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,\n\t\t\t\t    struct vmx_capability *vmx_cap)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 min, opt, min2, opt2;\n\tu32 _pin_based_exec_control = 0;\n\tu32 _cpu_based_exec_control = 0;\n\tu32 _cpu_based_2nd_exec_control = 0;\n\tu32 _vmexit_control = 0;\n\tu32 _vmentry_control = 0;\n\n\tmemset(vmcs_conf, 0, sizeof(*vmcs_conf));\n\tmin = CPU_BASED_HLT_EXITING |\n#ifdef CONFIG_X86_64\n\t      CPU_BASED_CR8_LOAD_EXITING |\n\t      CPU_BASED_CR8_STORE_EXITING |\n#endif\n\t      CPU_BASED_CR3_LOAD_EXITING |\n\t      CPU_BASED_CR3_STORE_EXITING |\n\t      CPU_BASED_UNCOND_IO_EXITING |\n\t      CPU_BASED_MOV_DR_EXITING |\n\t      CPU_BASED_USE_TSC_OFFSETTING |\n\t      CPU_BASED_MWAIT_EXITING |\n\t      CPU_BASED_MONITOR_EXITING |\n\t      CPU_BASED_INVLPG_EXITING |\n\t      CPU_BASED_RDPMC_EXITING;\n\n\topt = CPU_BASED_TPR_SHADOW |\n\t      CPU_BASED_USE_MSR_BITMAPS |\n\t      CPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PROCBASED_CTLS,\n\t\t\t\t&_cpu_based_exec_control) < 0)\n\t\treturn -EIO;\n#ifdef CONFIG_X86_64\n\tif (_cpu_based_exec_control & CPU_BASED_TPR_SHADOW)\n\t\t_cpu_based_exec_control &= ~CPU_BASED_CR8_LOAD_EXITING &\n\t\t\t\t\t   ~CPU_BASED_CR8_STORE_EXITING;\n#endif\n\tif (_cpu_based_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS) {\n\t\tmin2 = 0;\n\t\topt2 = SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\tSECONDARY_EXEC_WBINVD_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_VPID |\n\t\t\tSECONDARY_EXEC_ENABLE_EPT |\n\t\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST |\n\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING |\n\t\t\tSECONDARY_EXEC_DESC |\n\t\t\tSECONDARY_EXEC_ENABLE_RDTSCP |\n\t\t\tSECONDARY_EXEC_ENABLE_INVPCID |\n\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY |\n\t\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\t\tSECONDARY_EXEC_XSAVES |\n\t\t\tSECONDARY_EXEC_RDSEED_EXITING |\n\t\t\tSECONDARY_EXEC_RDRAND_EXITING |\n\t\t\tSECONDARY_EXEC_ENABLE_PML |\n\t\t\tSECONDARY_EXEC_TSC_SCALING |\n\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE |\n\t\t\tSECONDARY_EXEC_PT_USE_GPA |\n\t\t\tSECONDARY_EXEC_PT_CONCEAL_VMX |\n\t\t\tSECONDARY_EXEC_ENABLE_VMFUNC |\n\t\t\tSECONDARY_EXEC_BUS_LOCK_DETECTION;\n\t\tif (cpu_has_sgx())\n\t\t\topt2 |= SECONDARY_EXEC_ENCLS_EXITING;\n\t\tif (adjust_vmx_controls(min2, opt2,\n\t\t\t\t\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\t\t\t\t\t&_cpu_based_2nd_exec_control) < 0)\n\t\t\treturn -EIO;\n\t}\n#ifndef CONFIG_X86_64\n\tif (!(_cpu_based_2nd_exec_control &\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\t_cpu_based_exec_control &= ~CPU_BASED_TPR_SHADOW;\n#endif\n\n\tif (!(_cpu_based_exec_control & CPU_BASED_TPR_SHADOW))\n\t\t_cpu_based_2nd_exec_control &= ~(\n\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\n\trdmsr_safe(MSR_IA32_VMX_EPT_VPID_CAP,\n\t\t&vmx_cap->ept, &vmx_cap->vpid);\n\n\tif (_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_EPT) {\n\t\t/* CR3 accesses and invlpg don't need to cause VM Exits when EPT\n\t\t   enabled */\n\t\t_cpu_based_exec_control &= ~(CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t     CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\t\t     CPU_BASED_INVLPG_EXITING);\n\t} else if (vmx_cap->ept) {\n\t\tvmx_cap->ept = 0;\n\t\tpr_warn_once(\"EPT CAP should not exist if not support \"\n\t\t\t\t\"1-setting enable EPT VM-execution control\\n\");\n\t}\n\tif (!(_cpu_based_2nd_exec_control & SECONDARY_EXEC_ENABLE_VPID) &&\n\t\tvmx_cap->vpid) {\n\t\tvmx_cap->vpid = 0;\n\t\tpr_warn_once(\"VPID CAP should not exist if not support \"\n\t\t\t\t\"1-setting enable VPID VM-execution control\\n\");\n\t}\n\n\tmin = VM_EXIT_SAVE_DEBUG_CONTROLS | VM_EXIT_ACK_INTR_ON_EXIT;\n#ifdef CONFIG_X86_64\n\tmin |= VM_EXIT_HOST_ADDR_SPACE_SIZE;\n#endif\n\topt = VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL |\n\t      VM_EXIT_LOAD_IA32_PAT |\n\t      VM_EXIT_LOAD_IA32_EFER |\n\t      VM_EXIT_CLEAR_BNDCFGS |\n\t      VM_EXIT_PT_CONCEAL_PIP |\n\t      VM_EXIT_CLEAR_IA32_RTIT_CTL;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_EXIT_CTLS,\n\t\t\t\t&_vmexit_control) < 0)\n\t\treturn -EIO;\n\n\tmin = PIN_BASED_EXT_INTR_MASK | PIN_BASED_NMI_EXITING;\n\topt = PIN_BASED_VIRTUAL_NMIS | PIN_BASED_POSTED_INTR |\n\t\t PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_PINBASED_CTLS,\n\t\t\t\t&_pin_based_exec_control) < 0)\n\t\treturn -EIO;\n\n\tif (cpu_has_broken_vmx_preemption_timer())\n\t\t_pin_based_exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\tif (!(_cpu_based_2nd_exec_control &\n\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY))\n\t\t_pin_based_exec_control &= ~PIN_BASED_POSTED_INTR;\n\n\tmin = VM_ENTRY_LOAD_DEBUG_CONTROLS;\n\topt = VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL |\n\t      VM_ENTRY_LOAD_IA32_PAT |\n\t      VM_ENTRY_LOAD_IA32_EFER |\n\t      VM_ENTRY_LOAD_BNDCFGS |\n\t      VM_ENTRY_PT_CONCEAL_PIP |\n\t      VM_ENTRY_LOAD_IA32_RTIT_CTL;\n\tif (adjust_vmx_controls(min, opt, MSR_IA32_VMX_ENTRY_CTLS,\n\t\t\t\t&_vmentry_control) < 0)\n\t\treturn -EIO;\n\n\t/*\n\t * Some cpus support VM_{ENTRY,EXIT}_IA32_PERF_GLOBAL_CTRL but they\n\t * can't be used due to an errata where VM Exit may incorrectly clear\n\t * IA32_PERF_GLOBAL_CTRL[34:32].  Workaround the errata by using the\n\t * MSR load mechanism to switch IA32_PERF_GLOBAL_CTRL.\n\t */\n\tif (boot_cpu_data.x86 == 0x6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase 26: /* AAK155 */\n\t\tcase 30: /* AAP115 */\n\t\tcase 37: /* AAT100 */\n\t\tcase 44: /* BC86,AAY89,BD102 */\n\t\tcase 46: /* BA97 */\n\t\t\t_vmentry_control &= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\t\t_vmexit_control &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\t\tpr_warn_once(\"kvm: VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL \"\n\t\t\t\t\t\"does not work properly. Using workaround\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\trdmsr(MSR_IA32_VMX_BASIC, vmx_msr_low, vmx_msr_high);\n\n\t/* IA-32 SDM Vol 3B: VMCS size is never greater than 4kB. */\n\tif ((vmx_msr_high & 0x1fff) > PAGE_SIZE)\n\t\treturn -EIO;\n\n#ifdef CONFIG_X86_64\n\t/* IA-32 SDM Vol 3B: 64-bit CPUs always have VMX_BASIC_MSR[48]==0. */\n\tif (vmx_msr_high & (1u<<16))\n\t\treturn -EIO;\n#endif\n\n\t/* Require Write-Back (WB) memory type for VMCS accesses. */\n\tif (((vmx_msr_high >> 18) & 15) != 6)\n\t\treturn -EIO;\n\n\tvmcs_conf->size = vmx_msr_high & 0x1fff;\n\tvmcs_conf->basic_cap = vmx_msr_high & ~0x1fff;\n\n\tvmcs_conf->revision_id = vmx_msr_low;\n\n\tvmcs_conf->pin_based_exec_ctrl = _pin_based_exec_control;\n\tvmcs_conf->cpu_based_exec_ctrl = _cpu_based_exec_control;\n\tvmcs_conf->cpu_based_2nd_exec_ctrl = _cpu_based_2nd_exec_control;\n\tvmcs_conf->vmexit_ctrl         = _vmexit_control;\n\tvmcs_conf->vmentry_ctrl        = _vmentry_control;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (enlightened_vmcs)\n\t\tevmcs_sanitize_exec_ctrls(vmcs_conf);\n#endif\n\n\treturn 0;\n}\n\nstruct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, flags, 0);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\n\t/* KVM supports Enlightened VMCS v1 only */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tvmcs->hdr.revision_id = KVM_EVMCS_VERSION;\n\telse\n\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\tif (shadow)\n\t\tvmcs->hdr.shadow_vmcs = 1;\n\treturn vmcs;\n}\n\nvoid free_vmcs(struct vmcs *vmcs)\n{\n\tfree_page((unsigned long)vmcs);\n}\n\n/*\n * Free a VMCS, but before that VMCLEAR it on the CPU where it was last loaded\n */\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}\n\nint alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tloaded_vmcs->vmcs = alloc_vmcs(false);\n\tif (!loaded_vmcs->vmcs)\n\t\treturn -ENOMEM;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\n\tloaded_vmcs->shadow_vmcs = NULL;\n\tloaded_vmcs->hv_timer_soft_disabled = false;\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tloaded_vmcs->msr_bitmap = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!loaded_vmcs->msr_bitmap)\n\t\t\tgoto out_vmcs;\n\t\tmemset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);\n\t}\n\n\tmemset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));\n\tmemset(&loaded_vmcs->controls_shadow, 0,\n\t\tsizeof(struct vmcs_controls_shadow));\n\n\treturn 0;\n\nout_vmcs:\n\tfree_loaded_vmcs(loaded_vmcs);\n\treturn -ENOMEM;\n}\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * When eVMCS is enabled, alloc_vmcs_cpu() sets\n\t\t * vmcs->revision_id to KVM_EVMCS_VERSION instead of\n\t\t * revision_id reported by MSR_IA32_VMX_BASIC.\n\t\t *\n\t\t * However, even though not explicitly documented by\n\t\t * TLFS, VMXArea passed as VMXON argument should\n\t\t * still be marked with revision_id reported by\n\t\t * physical CPU.\n\t\t */\n\t\tif (static_branch_unlikely(&enable_evmcs))\n\t\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\t__vmx_set_segment(vcpu, save, seg);\n}\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if segment\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\t__vmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tvmx_update_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!kvm_vmx->tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tvmx_update_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n}\n\nint vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/* Nothing to do if hardware doesn't support EFER. */\n\tif (!vmx_find_uret_msr(vmx, MSR_EFER))\n\t\treturn 0;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA)\n\t\tvm_entry_controls_setbit(vmx, VM_ENTRY_IA32E_MODE);\n\telse\n\t\tvm_entry_controls_clearbit(vmx, VM_ENTRY_IA32E_MODE);\n\n\tvmx_setup_uret_msrs(vmx);\n\treturn 0;\n}\n\n#ifdef CONFIG_X86_64\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}\n\n#endif\n\nstatic void vmx_flush_tlb_all(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * INVEPT must be issued when EPT is enabled, irrespective of VPID, as\n\t * the CPU is not required to invalidate guest-physical mappings on\n\t * VM-Entry, even if VPID is disabled.  Guest-physical mappings are\n\t * associated with the root EPT structure and not any particular VPID\n\t * (INVVPID also isn't required to invalidate guest-physical mappings).\n\t */\n\tif (enable_ept) {\n\t\tept_sync_global();\n\t} else if (enable_vpid) {\n\t\tif (cpu_has_vmx_invvpid_global()) {\n\t\t\tvpid_sync_vcpu_global();\n\t\t} else {\n\t\t\tvpid_sync_vcpu_single(vmx->vpid);\n\t\t\tvpid_sync_vcpu_single(vmx->nested.vpid02);\n\t\t}\n\t}\n}\n\nstatic inline int vmx_get_current_vpid(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\treturn nested_get_vpid02(vcpu);\n\treturn to_vmx(vcpu)->vpid;\n}\n\nstatic void vmx_flush_tlb_current(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tu64 root_hpa = mmu->root.hpa;\n\n\t/* No flush required if the current context is invalid. */\n\tif (!VALID_PAGE(root_hpa))\n\t\treturn;\n\n\tif (enable_ept)\n\t\tept_sync_context(construct_eptp(vcpu, root_hpa,\n\t\t\t\t\t\tmmu->root_role.level));\n\telse\n\t\tvpid_sync_context(vmx_get_current_vpid(vcpu));\n}\n\nstatic void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\t/*\n\t * vpid_sync_vcpu_addr() is a nop if vpid==0, see the comment in\n\t * vmx_flush_tlb_guest() for an explanation of why this is ok.\n\t */\n\tvpid_sync_vcpu_addr(vmx_get_current_vpid(vcpu), addr);\n}\n\nstatic void vmx_flush_tlb_guest(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * vpid_sync_context() is a nop if vpid==0, e.g. if enable_vpid==0 or a\n\t * vpid couldn't be allocated for this vCPU.  VM-Enter and VM-Exit are\n\t * required to flush GVA->{G,H}PA mappings from the TLB if vpid is\n\t * disabled (VM-Enter with vpid enabled and vpid==0 is disallowed),\n\t * i.e. no explicit INVVPID is necessary.\n\t */\n\tvpid_sync_context(vmx_get_current_vpid(vcpu));\n}\n\nvoid vmx_ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}\n\nvoid ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (WARN_ON_ONCE(!is_pae_paging(vcpu)))\n\t\treturn;\n\n\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_PDPTR);\n}\n\n#define CR3_EXITING_BITS (CPU_BASED_CR3_LOAD_EXITING | \\\n\t\t\t  CPU_BASED_CR3_STORE_EXITING)\n\nvoid vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0, old_cr0_pg;\n\tu32 tmp;\n\n\told_cr0_pg = kvm_read_cr0_bits(vcpu, X86_CR0_PG);\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (is_unrestricted_guest(vcpu))\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\t\tif (!enable_ept)\n\t\t\thw_cr0 |= X86_CR0_WP;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR0);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!old_cr0_pg && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\telse if (old_cr0_pg && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !is_unrestricted_guest(vcpu)) {\n\t\t/*\n\t\t * Ensure KVM has an up-to-date snapshot of the guest's CR3.  If\n\t\t * the below code _enables_ CR3 exiting, vmx_cache_reg() will\n\t\t * (correctly) stop reading vmcs.GUEST_CR3 because it thinks\n\t\t * KVM's CR3 is installed.\n\t\t */\n\t\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\t\tvmx_cache_reg(vcpu, VCPU_EXREG_CR3);\n\n\t\t/*\n\t\t * When running with EPT but not unrestricted guest, KVM must\n\t\t * intercept CR3 accesses when paging is _disabled_.  This is\n\t\t * necessary because restricted guests can't actually run with\n\t\t * paging disabled, and so KVM stuffs its own CR3 in order to\n\t\t * run the guest when identity mapped page tables.\n\t\t *\n\t\t * Do _NOT_ check the old CR0.PG, e.g. to optimize away the\n\t\t * update, it may be stale with respect to CR3 interception,\n\t\t * e.g. after nested VM-Enter.\n\t\t *\n\t\t * Lastly, honor L1's desires, i.e. intercept CR3 loads and/or\n\t\t * stores to forward them to L1, even if KVM does not need to\n\t\t * intercept them to preserve its identity mapped page tables.\n\t\t */\n\t\tif (!(cr0 & X86_CR0_PG)) {\n\t\t\texec_controls_setbit(vmx, CR3_EXITING_BITS);\n\t\t} else if (!is_guest_mode(vcpu)) {\n\t\t\texec_controls_clearbit(vmx, CR3_EXITING_BITS);\n\t\t} else {\n\t\t\ttmp = exec_controls_get(vmx);\n\t\t\ttmp &= ~CR3_EXITING_BITS;\n\t\t\ttmp |= get_vmcs12(vcpu)->cpu_based_vm_exec_control & CR3_EXITING_BITS;\n\t\t\texec_controls_set(vmx, tmp);\n\t\t}\n\n\t\t/* Note, vmx_set_cr4() consumes the new vcpu->arch.cr0. */\n\t\tif ((old_cr0_pg ^ cr0) & X86_CR0_PG)\n\t\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\n\t\t/*\n\t\t * When !CR0_PG -> CR0_PG, vcpu->arch.cr3 becomes active, but\n\t\t * GUEST_CR3 is still vmx->ept_identity_map_addr if EPT + !URG.\n\t\t */\n\t\tif (!(old_cr0_pg & X86_CR0_PG) && (cr0 & X86_CR0_PG))\n\t\t\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\t}\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = vmx_emulation_required(vcpu);\n}\n\nstatic int vmx_get_max_tdp_level(void)\n{\n\tif (cpu_has_vmx_ept_5levels())\n\t\treturn 5;\n\treturn 4;\n}\n\nu64 construct_eptp(struct kvm_vcpu *vcpu, hpa_t root_hpa, int root_level)\n{\n\tu64 eptp = VMX_EPTP_MT_WB;\n\n\teptp |= (root_level == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;\n\n\tif (enable_ept_ad_bits &&\n\t    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))\n\t\teptp |= VMX_EPTP_AD_ENABLE_BIT;\n\teptp |= root_hpa;\n\n\treturn eptp;\n}\n\nstatic void vmx_load_mmu_pgd(struct kvm_vcpu *vcpu, hpa_t root_hpa,\n\t\t\t     int root_level)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tbool update_guest_cr3 = true;\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tif (enable_ept) {\n\t\teptp = construct_eptp(vcpu, root_hpa, root_level);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\n\t\thv_track_root_tdp(vcpu, root_hpa);\n\n\t\tif (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t\tguest_cr3 = to_kvm_vmx(kvm)->ept_identity_map_addr;\n\t\telse if (kvm_register_is_dirty(vcpu, VCPU_EXREG_CR3))\n\t\t\tguest_cr3 = vcpu->arch.cr3;\n\t\telse /* vmcs.GUEST_CR3 is already up-to-date. */\n\t\t\tupdate_guest_cr3 = false;\n\t\tvmx_ept_load_pdptrs(vcpu);\n\t} else {\n\t\tguest_cr3 = root_hpa | kvm_get_active_pcid(vcpu);\n\t}\n\n\tif (update_guest_cr3)\n\t\tvmcs_writel(GUEST_CR3, guest_cr3);\n}\n\n\nstatic bool vmx_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\t/*\n\t * We operate under the default treatment of SMM, so VMX cannot be\n\t * enabled under SMM.  Note, whether or not VMXE is allowed at all is\n\t * handled by kvm_is_valid_cr4().\n\t */\n\tif ((cr4 & X86_CR4_VMXE) && is_smm(vcpu))\n\t\treturn false;\n\n\tif (to_vmx(vcpu)->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = vcpu->arch.cr4;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (is_unrestricted_guest(vcpu))\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tvcpu->arch.cr4 = cr4;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR4);\n\n\tif (!is_unrestricted_guest(vcpu)) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid_runtime(vcpu);\n}\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}\n\nint vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn VMX_AR_DPL(ar);\n\t}\n}\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}\n\nvoid __vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\treturn;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (is_unrestricted_guest(vcpu) && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n}\n\nstatic void vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\t__vmx_set_segment(vcpu, var, seg);\n\n\tto_vmx(vcpu)->emulation_required = vmx_emulation_required(vcpu);\n}\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}\n\n/*\n * Check if guest state is valid. Returns true if valid, false if\n * not.\n * We assume that registers are always usable\n */\nbool __vmx_guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}\n\nstatic int init_rmode_tss(struct kvm *kvm, void __user *ua)\n{\n\tconst void *zero_page = (const void *) __va(page_to_phys(ZERO_PAGE(0)));\n\tu16 data;\n\tint i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (__copy_to_user(ua + PAGE_SIZE * i, zero_page, PAGE_SIZE))\n\t\t\treturn -EFAULT;\n\t}\n\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tif (__copy_to_user(ua + TSS_IOPB_BASE_OFFSET, &data, sizeof(u16)))\n\t\treturn -EFAULT;\n\n\tdata = ~0;\n\tif (__copy_to_user(ua + RMODE_TSS_SIZE - 1, &data, sizeof(u8)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);\n\tint i, r = 0;\n\tvoid __user *uaddr;\n\tu32 tmp;\n\n\t/* Protect kvm_vmx->ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm_vmx->ept_identity_pagetable_done))\n\t\tgoto out;\n\n\tif (!kvm_vmx->ept_identity_map_addr)\n\t\tkvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\n\tuaddr = __x86_set_memory_region(kvm,\n\t\t\t\t\tIDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t\tkvm_vmx->ept_identity_map_addr,\n\t\t\t\t\tPAGE_SIZE);\n\tif (IS_ERR(uaddr)) {\n\t\tr = PTR_ERR(uaddr);\n\t\tgoto out;\n\t}\n\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tif (__copy_to_user(uaddr + i * sizeof(tmp), &tmp, sizeof(tmp))) {\n\t\t\tr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkvm_vmx->ept_identity_pagetable_done = true;\n\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tvoid __user *hva;\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_memslot_enabled)\n\t\tgoto out;\n\thva = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (IS_ERR(hva)) {\n\t\tret = PTR_ERR(hva);\n\t\tgoto out;\n\t}\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_memslot_enabled = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}\n\nint allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}\n\nvoid free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}\n\nstatic void vmx_msr_bitmap_l01_changed(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * When KVM is a nested hypervisor on top of Hyper-V and uses\n\t * 'Enlightened MSR Bitmap' feature L0 needs to know that MSR\n\t * bitmap has changed.\n\t */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\tvmx->nested.force_msr_bitmap_recalc = true;\n}\n\nvoid vmx_disable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tvmx_msr_bitmap_l01_changed(vmx);\n\n\t/*\n\t * Mark the desired intercept state in shadow bitmap, this is needed\n\t * for resync when the MSR filters change.\n\t*/\n\tif (is_valid_passthrough_msr(msr)) {\n\t\tint idx = possible_passthrough_msr_slot(msr);\n\n\t\tif (idx != -ENOENT) {\n\t\t\tif (type & MSR_TYPE_R)\n\t\t\t\tclear_bit(idx, vmx->shadow_msr_intercept.read);\n\t\t\tif (type & MSR_TYPE_W)\n\t\t\t\tclear_bit(idx, vmx->shadow_msr_intercept.write);\n\t\t}\n\t}\n\n\tif ((type & MSR_TYPE_R) &&\n\t    !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_READ)) {\n\t\tvmx_set_msr_bitmap_read(msr_bitmap, msr);\n\t\ttype &= ~MSR_TYPE_R;\n\t}\n\n\tif ((type & MSR_TYPE_W) &&\n\t    !kvm_msr_allowed(vcpu, msr, KVM_MSR_FILTER_WRITE)) {\n\t\tvmx_set_msr_bitmap_write(msr_bitmap, msr);\n\t\ttype &= ~MSR_TYPE_W;\n\t}\n\n\tif (type & MSR_TYPE_R)\n\t\tvmx_clear_msr_bitmap_read(msr_bitmap, msr);\n\n\tif (type & MSR_TYPE_W)\n\t\tvmx_clear_msr_bitmap_write(msr_bitmap, msr);\n}\n\nvoid vmx_enable_intercept_for_msr(struct kvm_vcpu *vcpu, u32 msr, int type)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tvmx_msr_bitmap_l01_changed(vmx);\n\n\t/*\n\t * Mark the desired intercept state in shadow bitmap, this is needed\n\t * for resync when the MSR filter changes.\n\t*/\n\tif (is_valid_passthrough_msr(msr)) {\n\t\tint idx = possible_passthrough_msr_slot(msr);\n\n\t\tif (idx != -ENOENT) {\n\t\t\tif (type & MSR_TYPE_R)\n\t\t\t\tset_bit(idx, vmx->shadow_msr_intercept.read);\n\t\t\tif (type & MSR_TYPE_W)\n\t\t\t\tset_bit(idx, vmx->shadow_msr_intercept.write);\n\t\t}\n\t}\n\n\tif (type & MSR_TYPE_R)\n\t\tvmx_set_msr_bitmap_read(msr_bitmap, msr);\n\n\tif (type & MSR_TYPE_W)\n\t\tvmx_set_msr_bitmap_write(msr_bitmap, msr);\n}\n\nstatic void vmx_reset_x2apic_msrs(struct kvm_vcpu *vcpu, u8 mode)\n{\n\tunsigned long *msr_bitmap = to_vmx(vcpu)->vmcs01.msr_bitmap;\n\tunsigned long read_intercept;\n\tint msr;\n\n\tread_intercept = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\tunsigned int read_idx = msr / BITS_PER_LONG;\n\t\tunsigned int write_idx = read_idx + (0x800 / sizeof(long));\n\n\t\tmsr_bitmap[read_idx] = read_intercept;\n\t\tmsr_bitmap[write_idx] = ~0ul;\n\t}\n}\n\nstatic void vmx_update_msr_bitmap_x2apic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu8 mode;\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (cpu_has_secondary_exec_ctrls() &&\n\t    (secondary_exec_controls_get(vmx) &\n\t     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tmode = MSR_BITMAP_MODE_X2APIC;\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu))\n\t\t\tmode |= MSR_BITMAP_MODE_X2APIC_APICV;\n\t} else {\n\t\tmode = 0;\n\t}\n\n\tif (mode == vmx->x2apic_msr_bitmap_mode)\n\t\treturn;\n\n\tvmx->x2apic_msr_bitmap_mode = mode;\n\n\tvmx_reset_x2apic_msrs(vcpu, mode);\n\n\t/*\n\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t * delivery is not in use.\n\t */\n\tvmx_set_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW,\n\t\t\t\t  !(mode & MSR_BITMAP_MODE_X2APIC));\n\n\tif (mode & MSR_BITMAP_MODE_X2APIC_APICV) {\n\t\tvmx_enable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_RW);\n\t\tvmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);\n\t\tvmx_disable_intercept_for_msr(vcpu, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);\n\t}\n}\n\nvoid pt_update_intercept_for_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n\tu32 i;\n\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_STATUS, MSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_OUTPUT_BASE, MSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_OUTPUT_MASK, MSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_CR3_MATCH, MSR_TYPE_RW, flag);\n\tfor (i = 0; i < vmx->pt_desc.num_address_ranges; i++) {\n\t\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);\n\t\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);\n\t}\n}\n\nstatic bool vmx_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvoid *vapic_page;\n\tu32 vppr;\n\tint rvi;\n\n\tif (WARN_ON_ONCE(!is_guest_mode(vcpu)) ||\n\t\t!nested_cpu_has_vid(get_vmcs12(vcpu)) ||\n\t\tWARN_ON_ONCE(!vmx->nested.virtual_apic_map.gfn))\n\t\treturn false;\n\n\trvi = vmx_get_rvi();\n\n\tvapic_page = vmx->nested.virtual_apic_map.hva;\n\tvppr = *((u32 *)(vapic_page + APIC_PROCPRI));\n\n\treturn ((rvi & 0xf0) > (vppr & 0xf0));\n}\n\nstatic void vmx_msr_filter_changed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 i;\n\n\t/*\n\t * Set intercept permissions for all potentially passed through MSRs\n\t * again. They will automatically get filtered through the MSR filter,\n\t * so we are back in sync after this.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(vmx_possible_passthrough_msrs); i++) {\n\t\tu32 msr = vmx_possible_passthrough_msrs[i];\n\t\tbool read = test_bit(i, vmx->shadow_msr_intercept.read);\n\t\tbool write = test_bit(i, vmx->shadow_msr_intercept.write);\n\n\t\tvmx_set_intercept_for_msr(vcpu, msr, MSR_TYPE_R, read);\n\t\tvmx_set_intercept_for_msr(vcpu, msr, MSR_TYPE_W, write);\n\t}\n\n\tpt_update_intercept_for_msr(vcpu);\n}\n\nstatic inline void kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     int pi_vec)\n{\n#ifdef CONFIG_SMP\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of the virtual has already been set in the PIR.\n\t\t * Send a notification event to deliver the virtual interrupt\n\t\t * unless the vCPU is the currently running vCPU, i.e. the\n\t\t * event is being sent from a fastpath VM-Exit handler, in\n\t\t * which case the PIR will be synced to the vIRR before\n\t\t * re-entering the guest.\n\t\t *\n\t\t * When the target is not the running vCPU, the following\n\t\t * possibilities emerge:\n\t\t *\n\t\t * Case 1: vCPU stays in non-root mode. Sending a notification\n\t\t * event posts the interrupt to the vCPU.\n\t\t *\n\t\t * Case 2: vCPU exits to root mode and is still runnable. The\n\t\t * PIR will be synced to the vIRR before re-entering the guest.\n\t\t * Sending a notification event is ok as the host IRQ handler\n\t\t * will ignore the spurious event.\n\t\t *\n\t\t * Case 3: vCPU exits to root mode and is blocked. vcpu_block()\n\t\t * has already synced PIR to vIRR and never blocks the vCPU if\n\t\t * the vIRR is not empty. Therefore, a blocked vCPU here does\n\t\t * not wait for any requested interrupts in PIR, and sending a\n\t\t * notification event also results in a benign, spurious event.\n\t\t */\n\n\t\tif (vcpu != kvm_get_running_vcpu())\n\t\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn;\n\t}\n#endif\n\t/*\n\t * The vCPU isn't in the guest; wake the vCPU in case it is blocking,\n\t * otherwise do nothing as KVM will grab the highest priority pending\n\t * IRQ via ->sync_pir_to_irr() in vcpu_enter_guest().\n\t */\n\tkvm_vcpu_wake_up(vcpu);\n}\n\nstatic int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t\t/*\n\t\t * This pairs with the smp_mb_*() after setting vcpu->mode in\n\t\t * vcpu_enter_guest() to guarantee the vCPU sees the event\n\t\t * request if triggering a posted interrupt \"fails\" because\n\t\t * vcpu->mode != IN_GUEST_MODE.  The extra barrier is needed as\n\t\t * the smb_wmb() in kvm_make_request() only ensures everything\n\t\t * done before making the request is visible when the request\n\t\t * is visible, it doesn't ensure ordering between the store to\n\t\t * vcpu->requests and the load from vcpu->mode.\n\t\t */\n\t\tsmp_mb__after_atomic();\n\n\t\t/* the PIR and ON have been set by L1. */\n\t\tkvm_vcpu_trigger_posted_interrupt(vcpu, POSTED_INTR_NESTED_VECTOR);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n/*\n * Send interrupt to vcpu via posted interrupt way.\n * 1. If target vcpu is running(non-root mode), send posted interrupt\n * notification to vcpu and hardware will sync PIR to vIRR atomically.\n * 2. If target vcpu isn't running(root mode), kick it to pick up the\n * interrupt from PIR in next vmentry.\n */\nstatic int vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tr = vmx_deliver_nested_posted_interrupt(vcpu, vector);\n\tif (!r)\n\t\treturn 0;\n\n\tif (!vcpu->arch.apicv_active)\n\t\treturn -1;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn 0;\n\n\t/* If a previous notification has sent the IPI, nothing to do.  */\n\tif (pi_test_and_set_on(&vmx->pi_desc))\n\t\treturn 0;\n\n\t/*\n\t * The implied barrier in pi_test_and_set_on() pairs with the smp_mb_*()\n\t * after setting vcpu->mode in vcpu_enter_guest(), thus the vCPU is\n\t * guaranteed to see PID.ON=1 and sync the PIR to IRR if triggering a\n\t * posted interrupt \"fails\" because vcpu->mode != IN_GUEST_MODE.\n\t */\n\tkvm_vcpu_trigger_posted_interrupt(vcpu, POSTED_INTR_VECTOR);\n\treturn 0;\n}\n\nstatic void vmx_deliver_interrupt(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t\t  int trig_mode, int vector)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\tif (vmx_deliver_posted_interrupt(vcpu, vector)) {\n\t\tkvm_lapic_set_irr(vector, apic);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t} else {\n\t\ttrace_kvm_apicv_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t\t   trig_mode, vector);\n\t}\n}\n\n/*\n * Set up the vmcs's constant host-state fields, i.e., host-state fields that\n * will not change in the lifetime of the guest.\n * Note that host-state that does change is set elsewhere. E.g., host-state\n * that is set differently for each CPU is set in vmx_vcpu_load(), not here.\n */\nvoid vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tunsigned long cr0, cr3, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\n\t/*\n\t * Save the most likely value for this task's CR3 in the VMCS.\n\t * We can't use __get_current_cr3_fast() because we're not atomic.\n\t */\n\tcr3 = __read_cr3();\n\tvmcs_writel(HOST_CR3, cr3);\t\t/* 22.2.3  FIXME: shadow tables */\n\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * vmx_prepare_switch_to_host(), in case userspace uses\n\t * the null selectors too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tvmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */\n\n\tvmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\n\t/*\n\t * SYSENTER is used for 32-bit system calls on either 32-bit or\n\t * 64-bit kernels.  It is always zero If neither is allowed, otherwise\n\t * vmx_vcpu_load_vmcs loads it with the per-CPU entry stack (and may\n\t * have already done so!).\n\t */\n\tif (!IS_ENABLED(CONFIG_IA32_EMULATION) && !IS_ENABLED(CONFIG_X86_32))\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, 0);\n\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n\n\tif (cpu_has_load_ia32_efer())\n\t\tvmcs_write64(HOST_IA32_EFER, host_efer);\n}\n\nvoid set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tvcpu->arch.cr4_guest_owned_bits = KVM_POSSIBLE_CR4_GUEST_BITS &\n\t\t\t\t\t  ~vcpu->arch.cr4_guest_rsvd_bits;\n\tif (!enable_ept) {\n\t\tvcpu->arch.cr4_guest_owned_bits &= ~X86_CR4_TLBFLUSH_BITS;\n\t\tvcpu->arch.cr4_guest_owned_bits &= ~X86_CR4_PDPTR_BITS;\n\t}\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvcpu->arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vcpu->arch.cr4_guest_owned_bits);\n}\n\nstatic u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}\n\nstatic u32 vmx_vmentry_ctrl(void)\n{\n\tu32 vmentry_ctrl = vmcs_config.vmentry_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\tvmentry_ctrl &= ~(VM_ENTRY_PT_CONCEAL_PIP |\n\t\t\t\t  VM_ENTRY_LOAD_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmentry_ctrl &\n\t\t~(VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL | VM_ENTRY_LOAD_IA32_EFER);\n}\n\nstatic u32 vmx_vmexit_ctrl(void)\n{\n\tu32 vmexit_ctrl = vmcs_config.vmexit_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\tvmexit_ctrl &= ~(VM_EXIT_PT_CONCEAL_PIP |\n\t\t\t\t VM_EXIT_CLEAR_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmexit_ctrl &\n\t\t~(VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL | VM_EXIT_LOAD_IA32_EFER);\n}\n\nstatic void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.update_vmcs01_apicv_status = true;\n\t\treturn;\n\t}\n\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tsecondary_exec_controls_setbit(vmx,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tsecondary_exec_controls_clearbit(vmx,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tvmx_update_msr_bitmap_x2apic(vcpu);\n}\n\nstatic u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tif (kvm_mwait_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~(CPU_BASED_MWAIT_EXITING |\n\t\t\t\tCPU_BASED_MONITOR_EXITING);\n\tif (kvm_hlt_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~CPU_BASED_HLT_EXITING;\n\treturn exec_control;\n}\n\n/*\n * Adjust a single secondary execution control bit to intercept/allow an\n * instruction in the guest.  This is usually done based on whether or not a\n * feature has been exposed to the guest in order to correctly emulate faults.\n */\nstatic inline void\nvmx_adjust_secondary_exec_control(struct vcpu_vmx *vmx, u32 *exec_control,\n\t\t\t\t  u32 control, bool enabled, bool exiting)\n{\n\t/*\n\t * If the control is for an opt-in feature, clear the control if the\n\t * feature is not exposed to the guest, i.e. not enabled.  If the\n\t * control is opt-out, i.e. an exiting control, clear the control if\n\t * the feature _is_ exposed to the guest, i.e. exiting/interception is\n\t * disabled for the associated instruction.  Note, the caller is\n\t * responsible presetting exec_control to set all supported bits.\n\t */\n\tif (enabled == exiting)\n\t\t*exec_control &= ~control;\n\n\t/*\n\t * Update the nested MSR settings so that a nested VMM can/can't set\n\t * controls for features that are/aren't exposed to the guest.\n\t */\n\tif (nested) {\n\t\tif (enabled)\n\t\t\tvmx->nested.msrs.secondary_ctls_high |= control;\n\t\telse\n\t\t\tvmx->nested.msrs.secondary_ctls_high &= ~control;\n\t}\n}\n\n/*\n * Wrapper macro for the common case of adjusting a secondary execution control\n * based on a single guest CPUID bit, with a dedicated feature bit.  This also\n * verifies that the control is actually supported by KVM and hardware.\n */\n#define vmx_adjust_sec_exec_control(vmx, exec_control, name, feat_name, ctrl_name, exiting) \\\n({\t\t\t\t\t\t\t\t\t \\\n\tbool __enabled;\t\t\t\t\t\t\t \\\n\t\t\t\t\t\t\t\t\t \\\n\tif (cpu_has_vmx_##name()) {\t\t\t\t\t \\\n\t\t__enabled = guest_cpuid_has(&(vmx)->vcpu,\t\t \\\n\t\t\t\t\t    X86_FEATURE_##feat_name);\t \\\n\t\tvmx_adjust_secondary_exec_control(vmx, exec_control,\t \\\n\t\t\tSECONDARY_EXEC_##ctrl_name, __enabled, exiting); \\\n\t}\t\t\t\t\t\t\t\t \\\n})\n\n/* More macro magic for ENABLE_/opt-in versus _EXITING/opt-out controls. */\n#define vmx_adjust_sec_exec_feature(vmx, exec_control, lname, uname) \\\n\tvmx_adjust_sec_exec_control(vmx, exec_control, lname, uname, ENABLE_##uname, false)\n\n#define vmx_adjust_sec_exec_exiting(vmx, exec_control, lname, uname) \\\n\tvmx_adjust_sec_exec_control(vmx, exec_control, lname, uname, uname##_EXITING, true)\n\nstatic u32 vmx_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\t/*\n\t * PML is enabled/disabled when dirty logging of memsmlots changes, but\n\t * it needs to be set here when dirty logging is already active, e.g.\n\t * if this vCPU was created after dirty logging was enabled.\n\t */\n\tif (!vcpu->kvm->arch.cpu_dirty_logging_count)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (cpu_has_vmx_xsaves()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tvmx_adjust_secondary_exec_control(vmx, &exec_control,\n\t\t\t\t\t\t  SECONDARY_EXEC_XSAVES,\n\t\t\t\t\t\t  xsaves_enabled, false);\n\t}\n\n\t/*\n\t * RDPID is also gated by ENABLE_RDTSCP, turn on the control if either\n\t * feature is exposed to the guest.  This creates a virtualization hole\n\t * if both are supported in hardware but only one is exposed to the\n\t * guest, but letting the guest execute RDTSCP or RDPID when either one\n\t * is advertised is preferable to emulating the advertised instruction\n\t * in KVM on #UD, and obviously better than incorrectly injecting #UD.\n\t */\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdpid_or_rdtscp_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) ||\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_RDPID);\n\n\t\tvmx_adjust_secondary_exec_control(vmx, &exec_control,\n\t\t\t\t\t\t  SECONDARY_EXEC_ENABLE_RDTSCP,\n\t\t\t\t\t\t  rdpid_or_rdtscp_enabled, false);\n\t}\n\tvmx_adjust_sec_exec_feature(vmx, &exec_control, invpcid, INVPCID);\n\n\tvmx_adjust_sec_exec_exiting(vmx, &exec_control, rdrand, RDRAND);\n\tvmx_adjust_sec_exec_exiting(vmx, &exec_control, rdseed, RDSEED);\n\n\tvmx_adjust_sec_exec_control(vmx, &exec_control, waitpkg, WAITPKG,\n\t\t\t\t    ENABLE_USR_WAIT_PAUSE, false);\n\n\tif (!vcpu->kvm->arch.bus_lock_detection_enabled)\n\t\texec_control &= ~SECONDARY_EXEC_BUS_LOCK_DETECTION;\n\n\treturn exec_control;\n}\n\n#define VMX_XSS_EXIT_BITMAP 0\n\nstatic void init_vmcs(struct vcpu_vmx *vmx)\n{\n\tif (nested)\n\t\tnested_vmx_set_vmcs_shadowing_bitmap();\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));\n\n\tvmcs_write64(VMCS_LINK_POINTER, INVALID_GPA); /* 22.3.1.5 */\n\n\t/* Control */\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\n\texec_controls_set(vmx, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_controls_set(vmx, vmx_secondary_exec_control(vmx));\n\n\tif (enable_apicv && lapic_in_kernel(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (!kvm_pause_in_guest(vmx->vcpu.kvm)) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n\n\tif (cpu_has_vmx_vmfunc())\n\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tvm_exit_controls_set(vmx, vmx_vmexit_ctrl());\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_set(vmx, vmx_vmentry_ctrl());\n\n\tvmx->vcpu.arch.cr0_guest_owned_bits = KVM_POSSIBLE_CR0_GUEST_BITS;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr0_guest_owned_bits);\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tif (cpu_has_vmx_xsaves())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tvmx_write_encls_bitmap(&vmx->vcpu, NULL);\n\n\tif (vmx_pt_mode_is_host_guest()) {\n\t\tmemset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));\n\t\t/* Bit[6~0] are forced to 1, writes are ignored. */\n\t\tvmx->pt_desc.guest.output_mask = 0x7F;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, 0);\n\t}\n\n\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\n\tif (cpu_has_vmx_tpr_shadow()) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (cpu_need_tpr_shadow(&vmx->vcpu))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vmx->vcpu.arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tvmx_setup_uret_msrs(vmx);\n}\n\nstatic void __vmx_vcpu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tinit_vmcs(vmx);\n\n\tif (nested)\n\t\tmemcpy(&vmx->nested.msrs, &vmcs_config.nested, sizeof(vmx->nested.msrs));\n\n\tvcpu_setup_sgx_lepubkeyhash(vcpu);\n\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.vmxon_ptr = INVALID_GPA;\n\tvmx->nested.current_vmptr = INVALID_GPA;\n\tvmx->nested.hv_evmcs_vmptr = EVMPTR_INVALID;\n\n\tvcpu->arch.microcode_version = 0x100000000ULL;\n\tvmx->msr_ia32_feature_control_valid_bits = FEAT_CTL_LOCKED;\n\n\t/*\n\t * Enforce invariant: pi_desc.nv is always either POSTED_INTR_VECTOR\n\t * or POSTED_INTR_WAKEUP_VECTOR.\n\t */\n\tvmx->pi_desc.nv = POSTED_INTR_VECTOR;\n\tvmx->pi_desc.sn = 1;\n}\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!init_event)\n\t\t__vmx_vcpu_reset(vcpu);\n\n\tvmx->rmode.vm86_active = 0;\n\tvmx->spec_ctrl = 0;\n\n\tvmx->msr_ia32_umwait_control = 0;\n\n\tvmx->hv_deadline_tsc = -1;\n\tkvm_set_cr8(vcpu, 0);\n\n\tvmx_segment_cache_clear(vmx);\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_SEGMENTS);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_writel(GUEST_CS_BASE, 0xffff0000ul);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\tif (kvm_mpx_supported())\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tvpid_sync_context(vmx->vpid);\n}\n\nstatic void vmx_enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n}\n\nstatic void vmx_enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (!enable_vnmi ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tvmx_enable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n}\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, irq, inc_eip);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n\n\tvmx_clear_hlt(vcpu);\n}\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 1;\n\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->loaded_vmcs->nmi_known_unmasked = false;\n\n\tif (vmx->rmode.vm86_active) {\n\t\tkvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n\n\tvmx_clear_hlt(vcpu);\n}\n\nbool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool masked;\n\n\tif (!enable_vnmi)\n\t\treturn vmx->loaded_vmcs->soft_vnmi_blocked;\n\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\treturn false;\n\tmasked = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_NMI;\n\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\treturn masked;\n}\n\nvoid vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}\n\nbool vmx_nmi_blocked(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_exit_on_nmi(vcpu))\n\t\treturn false;\n\n\tif (!enable_vnmi && to_vmx(vcpu)->loaded_vmcs->soft_vnmi_blocked)\n\t\treturn true;\n\n\treturn (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t(GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI |\n\t\t GUEST_INTR_STATE_NMI));\n}\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\t/* An NMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_nmi(vcpu))\n\t\treturn -EBUSY;\n\n\treturn !vmx_nmi_blocked(vcpu);\n}\n\nbool vmx_interrupt_blocked(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn false;\n\n\treturn !(vmx_get_rflags(vcpu) & X86_EFLAGS_IF) ||\n\t       (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n       /*\n        * An IRQ must not be injected into L2 if it's supposed to VM-Exit,\n        * e.g. if the IRQ arrived asynchronously after checking nested events.\n        */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn -EBUSY;\n\n\treturn !vmx_interrupt_blocked(vcpu);\n}\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tvoid __user *ret;\n\n\tif (enable_unrestricted_guest)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tret = __x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t      PAGE_SIZE * 3);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tif (IS_ERR(ret))\n\t\treturn PTR_ERR(ret);\n\n\tto_kvm_vmx(kvm)->tss_addr = addr;\n\n\treturn init_rmode_tss(kvm, ret);\n}\n\nstatic int vmx_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)\n{\n\tto_kvm_vmx(kvm)->ept_identity_map_addr = ident_addr;\n\treturn 0;\n}\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DB_VECTOR:\n\t\treturn !(vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP));\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (kvm_emulate_instruction(vcpu, 0)) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_emulate_halt_noskip(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* handled by vmx_vcpu_run() */\n\treturn 1;\n}\n\n/*\n * If the host has split lock detection disabled, then #AC is\n * unconditionally injected into the guest, which is the pre split lock\n * detection behaviour.\n *\n * If the host has split lock detection enabled then #AC is\n * only injected into the guest when:\n *  - Guest CPL == 3 (user mode)\n *  - Guest has #AC detection enabled in CR0\n *  - Guest EFLAGS has AC bit set\n */\nbool vmx_guest_inject_ac(struct kvm_vcpu *vcpu)\n{\n\tif (!boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))\n\t\treturn true;\n\n\treturn vmx_get_cpl(vcpu) == 3 && kvm_read_cr0_bits(vcpu, X86_CR0_AM) &&\n\t       (kvm_get_rflags(vcpu) & X86_EFLAGS_AC);\n}\n\nstatic int handle_exception_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, dr6;\n\tu32 vect_info;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx_get_intr_info(vcpu);\n\n\tif (is_machine_check(intr_info) || is_nmi(intr_info))\n\t\treturn 1; /* handled by handle_exception_nmi_irqoff() */\n\n\t/*\n\t * Queue the exception here instead of in handle_nm_fault_irqoff().\n\t * This ensures the nested_vmx check is not skipped so vmexit can\n\t * be reflected to L1 (when it intercepts #NM) before reaching this\n\t * point.\n\t */\n\tif (is_nm_fault(intr_info)) {\n\t\tkvm_queue_exception(vcpu, NM_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (is_invalid_opcode(intr_info))\n\t\treturn handle_ud(vcpu);\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\tif (!vmx->rmode.vm86_active && is_gp_fault(intr_info)) {\n\t\tWARN_ON_ONCE(!enable_vmware_backdoor);\n\n\t\t/*\n\t\t * VMware backdoor emulation on #GP interception only handles\n\t\t * IN{S}, OUT{S}, and RDPMC, none of which generate a non-zero\n\t\t * error code on #GP.\n\t\t */\n\t\tif (error_code) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\t\t\treturn 1;\n\t\t}\n\t\treturn kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);\n\t}\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 4;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\tvcpu->run->internal.data[3] = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\tcr2 = vmx_get_exit_qual(vcpu);\n\t\tif (enable_ept && !vcpu->arch.apf.host_apf_flags) {\n\t\t\t/*\n\t\t\t * EPT will cause page fault only if we need to\n\t\t\t * detect illegal GPAs.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(!allow_smaller_maxphyaddr);\n\t\t\tkvm_fixup_and_inject_pf_error(vcpu, cr2, error_code);\n\t\t\treturn 1;\n\t\t} else\n\t\t\treturn kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase DB_VECTOR:\n\t\tdr6 = vmx_get_exit_qual(vcpu);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\t/*\n\t\t\t * If the #DB was due to ICEBP, a.k.a. INT1, skip the\n\t\t\t * instruction.  ICEBP generates a trap-like #DB, but\n\t\t\t * despite its interception control being tied to #DB,\n\t\t\t * is an instruction intercept, i.e. the VM-Exit occurs\n\t\t\t * on the ICEBP itself.  Note, skipping ICEBP also\n\t\t\t * clears STI and MOVSS blocking.\n\t\t\t *\n\t\t\t * For all other #DBs, set vmcs.PENDING_DBG_EXCEPTIONS.BS\n\t\t\t * if single-step is enabled in RFLAGS and STI or MOVSS\n\t\t\t * blocking is active, as the CPU doesn't set the bit\n\t\t\t * on VM-Exit due to #DB interception.  VM-Entry has a\n\t\t\t * consistency check that a single-step #DB is pending\n\t\t\t * in this scenario as the previous instruction cannot\n\t\t\t * have toggled RFLAGS.TF 0=>1 (because STI and POP/MOV\n\t\t\t * don't modify RFLAGS), therefore the one instruction\n\t\t\t * delay when activating single-step breakpoints must\n\t\t\t * have already expired.  Note, the CPU sets/clears BS\n\t\t\t * as appropriate for all other VM-Exits types.\n\t\t\t */\n\t\t\tif (is_icebp(intr_info))\n\t\t\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\t\t\telse if ((vmx_get_rflags(vcpu) & X86_EFLAGS_TF) &&\n\t\t\t\t (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t\t  (GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS)))\n\t\t\t\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS,\n\t\t\t\t\t    vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS) | DR6_BS);\n\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\tfallthrough;\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tcase AC_VECTOR:\n\t\tif (vmx_guest_inject_ac(vcpu)) {\n\t\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/*\n\t\t * Handle split lock. Depending on detection mode this will\n\t\t * either warn and disable split lock detection for this\n\t\t * task or force SIGBUS on it.\n\t\t */\n\t\tif (handle_guest_split_lock(kvm_rip_read(vcpu)))\n\t\t\treturn 1;\n\t\tfallthrough;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic __always_inline int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\tvcpu->mmio_needed = 0;\n\treturn 0;\n}\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tstring = (exit_qualification & 16) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tin = (exit_qualification & 8) != 0;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}\n\n/* called to set cr0 as appropriate for a mov-to-cr0 exit. */\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}\n\nstatic int handle_desc(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(!(vcpu->arch.cr4 & X86_CR4_UMIP));\n\treturn kvm_emulate_instruction(vcpu, 0);\n}\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\tint ret;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_read(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tret = kvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn ret;\n\t\t\t\t/*\n\t\t\t\t * TODO: we might be squashing a\n\t\t\t\t * KVM_GUESTDBG_SINGLESTEP-triggered\n\t\t\t\t * KVM_EXIT_DEBUG here.\n\t\t\t\t */\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tKVM_BUG(1, vcpu->kvm, \"Guest always owns CR0.TS\");\n\t\treturn -EIO;\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, dr7, reg;\n\tint err = 1;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\n\t/* First, if DR does not exist, trigger UD */\n\tif (!kvm_require_dr(vcpu, dr))\n\t\treturn 1;\n\n\tif (vmx_get_cpl(vcpu) > 0)\n\t\tgoto out;\n\n\tdr7 = vmcs_readl(GUEST_DR7);\n\tif (dr7 & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = DR6_BD | DR6_ACTIVE_LOW;\n\t\t\tvcpu->run->debug.arch.dr7 = dr7;\n\t\t\tvcpu->run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BD);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tkvm_get_dr(vcpu, dr, &val);\n\t\tkvm_register_write(vcpu, reg, val);\n\t\terr = 0;\n\t} else {\n\t\terr = kvm_set_dr(vcpu, dr, kvm_register_read(vcpu, reg));\n\t}\n\nout:\n\treturn kvm_complete_insn_gp(vcpu, err);\n}\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n\n\t/*\n\t * exc_debug expects dr6 to be cleared after it runs, avoid that it sees\n\t * a stale dr6 from the guest.\n\t */\n\tset_debugreg(DR6_RESERVED, 6);\n}\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_apic_update_ppr(vcpu);\n\treturn 1;\n}\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t}\n\treturn kvm_emulate_instruction(vcpu, 0);\n}\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmx_get_exit_qual(vcpu);\n\n\t/*\n\t * APIC-write VM-Exit is trap-like, KVM doesn't need to advance RIP and\n\t * hardware has done any necessary aliasing, offset adjustments, etc...\n\t * for the access.  I.e. the correct value has already been  written to\n\t * the vAPIC page for the correct 16-byte chunk.  KVM needs only to\n\t * retrieve the register value and emulate the access.\n\t */\n\tu32 offset = exit_qualification & 0xff0;\n\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\treturn kvm_task_switch(vcpu, tss_selector,\n\t\t\t       type == INTR_TYPE_SOFT_INTR ? idt_index : -1,\n\t\t\t       reason, has_error_code, error_code);\n}\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu64 error_code;\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* Is it a read fault? */\n\terror_code = (exit_qualification & EPT_VIOLATION_ACC_READ)\n\t\t     ? PFERR_USER_MASK : 0;\n\t/* Is it a write fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_WRITE)\n\t\t      ? PFERR_WRITE_MASK : 0;\n\t/* Is it a fetch fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_INSTR)\n\t\t      ? PFERR_FETCH_MASK : 0;\n\t/* ept page table entry is present? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_RWX_MASK)\n\t\t      ? PFERR_PRESENT_MASK : 0;\n\n\terror_code |= (exit_qualification & EPT_VIOLATION_GVA_TRANSLATED) != 0 ?\n\t       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\n\t/*\n\t * Check that the GPA doesn't exceed physical memory limits, as that is\n\t * a guest page fault.  We have to emulate the instruction here, because\n\t * if the illegal address is that of a paging structure, then\n\t * EPT_VIOLATION_ACC_WRITE bit is set.  Alternatively, if supported we\n\t * would also use advanced VM-exit information for EPT violations to\n\t * reconstruct the page fault error code.\n\t */\n\tif (unlikely(allow_smaller_maxphyaddr && kvm_vcpu_is_illegal_gpa(vcpu, gpa)))\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tgpa_t gpa;\n\n\tif (!vmx_can_emulate_instruction(vcpu, EMULTYPE_PF, NULL, 0))\n\t\treturn 1;\n\n\t/*\n\t * A nested guest cannot optimize MMIO vmexits, because we have an\n\t * nGPA here instead of the required GPA.\n\t */\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!is_guest_mode(vcpu) &&\n\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);\n}\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (KVM_BUG_ON(!enable_vnmi, vcpu->kvm))\n\t\treturn -EIO;\n\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}\n\nstatic bool vmx_emulation_required_with_pending_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\treturn vmx->emulation_required && !vmx->rmode.vm86_active &&\n\t       (vcpu->arch.exception.pending || vcpu->arch.exception.injected);\n}\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\tintr_window_requested = exec_controls_get(vmx) &\n\t\t\t\tCPU_BASED_INTR_WINDOW_EXITING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && !vmx_interrupt_blocked(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\tif (!kvm_emulate_instruction(vcpu, 0))\n\t\t\treturn 0;\n\n\t\tif (vmx_emulation_required_with_pending_exception(vcpu)) {\n\t\t\tkvm_prepare_emulation_failure_exit(vcpu);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\treturn kvm_emulate_halt_noskip(vcpu);\n\t\t}\n\n\t\t/*\n\t\t * Note, return 1 and not 0, vcpu_run() will invoke\n\t\t * xfer_to_guest_mode() which will create a proper return\n\t\t * code.\n\t\t */\n\t\tif (__xfer_to_guest_mode_work_pending())\n\t\t\treturn 1;\n\t}\n\n\treturn 1;\n}\n\nstatic int vmx_vcpu_pre_run(struct kvm_vcpu *vcpu)\n{\n\tif (vmx_emulation_required_with_pending_exception(vcpu)) {\n\t\tkvm_prepare_emulation_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old, ple_window,\n\t\t\t\t\t    ple_window_grow,\n\t\t\t\t\t    ple_window_max);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}\n\n/*\n * Indicate a busy-waiting vcpu in spinlock. We do not enable the PAUSE\n * exiting, so only get here on cpu with PAUSE-Loop-Exiting.\n */\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tgrow_ple_window(vcpu);\n\n\t/*\n\t * Intel sdm vol3 ch-25.1.3 says: The \"PAUSE-loop exiting\"\n\t * VM-execution control is ignored if CPL > 0. OTOH, KVM\n\t * never set PAUSE_EXITING and just set PLE if supported,\n\t * so the vcpu must be CPL=0 if it gets a PAUSE exit.\n\t */\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}\n\nstatic int handle_invpcid(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct {\n\t\tu64 pcid;\n\t\tu64 gla;\n\t} operand;\n\tint gpr_index;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgpr_index = vmx_get_instr_info_reg2(vmx_instruction_info);\n\ttype = kvm_register_read(vcpu, gpr_index);\n\n\t/* According to the Intel instruction reference, the memory operand\n\t * is read even if it isn't needed (e.g., for type==all)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmx_get_exit_qual(vcpu),\n\t\t\t\tvmx_instruction_info, false,\n\t\t\t\tsizeof(operand), &gva))\n\t\treturn 1;\n\n\treturn kvm_handle_invpcid(vcpu, type, gva);\n}\n\nstatic int handle_pml_full(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\n\ttrace_kvm_pml_full(vcpu->vcpu_id);\n\n\texit_qualification = vmx_get_exit_qual(vcpu);\n\n\t/*\n\t * PML buffer FULL happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\tGUEST_INTR_STATE_NMI);\n\n\t/*\n\t * PML buffer already flushed at beginning of VMEXIT. Nothing to do\n\t * here.., and there's no userspace involvement needed for PML.\n\t */\n\treturn 1;\n}\n\nstatic fastpath_t handle_fastpath_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->req_immediate_exit &&\n\t    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled)) {\n\t\tkvm_lapic_expired_hv_timer(vcpu);\n\t\treturn EXIT_FASTPATH_REENTER_GUEST;\n\t}\n\n\treturn EXIT_FASTPATH_NONE;\n}\n\nstatic int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\thandle_fastpath_preemption_timer(vcpu);\n\treturn 1;\n}\n\n/*\n * When nested=0, all VMX instruction VM Exits filter here.  The handlers\n * are overwritten by nested_vmx_setup() when nested=1.\n */\nstatic int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\n\n#ifndef CONFIG_X86_SGX_KVM\nstatic int handle_encls(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * SGX virtualization is disabled.  There is no software enable bit for\n\t * SGX, so KVM intercepts all ENCLS leafs and injects a #UD to prevent\n\t * the guest from executing ENCLS (when SGX is supported by hardware).\n\t */\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\n#endif /* CONFIG_X86_SGX_KVM */\n\nstatic int handle_bus_lock_vmexit(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Hardware may or may not set the BUS_LOCK_DETECTED flag on BUS_LOCK\n\t * VM-Exits. Unconditionally set the flag here and leave the handling to\n\t * vmx_handle_exit().\n\t */\n\tto_vmx(vcpu)->exit_reason.bus_lock_detected = true;\n\treturn 1;\n}\n\n/*\n * The exit handlers return 1 if the exit was handled fully and guest execution\n * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n * to be done to userspace and return 0.\n */\nstatic int (*kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\t[EXIT_REASON_EXCEPTION_NMI]           = handle_exception_nmi,\n\t[EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,\n\t[EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,\n\t[EXIT_REASON_NMI_WINDOW]\t      = handle_nmi_window,\n\t[EXIT_REASON_IO_INSTRUCTION]          = handle_io,\n\t[EXIT_REASON_CR_ACCESS]               = handle_cr,\n\t[EXIT_REASON_DR_ACCESS]               = handle_dr,\n\t[EXIT_REASON_CPUID]                   = kvm_emulate_cpuid,\n\t[EXIT_REASON_MSR_READ]                = kvm_emulate_rdmsr,\n\t[EXIT_REASON_MSR_WRITE]               = kvm_emulate_wrmsr,\n\t[EXIT_REASON_INTERRUPT_WINDOW]        = handle_interrupt_window,\n\t[EXIT_REASON_HLT]                     = kvm_emulate_halt,\n\t[EXIT_REASON_INVD]\t\t      = kvm_emulate_invd,\n\t[EXIT_REASON_INVLPG]\t\t      = handle_invlpg,\n\t[EXIT_REASON_RDPMC]                   = kvm_emulate_rdpmc,\n\t[EXIT_REASON_VMCALL]                  = kvm_emulate_hypercall,\n\t[EXIT_REASON_VMCLEAR]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMLAUNCH]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMPTRLD]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMPTRST]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMREAD]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMRESUME]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMWRITE]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMOFF]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_VMON]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,\n\t[EXIT_REASON_APIC_ACCESS]             = handle_apic_access,\n\t[EXIT_REASON_APIC_WRITE]              = handle_apic_write,\n\t[EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,\n\t[EXIT_REASON_WBINVD]                  = kvm_emulate_wbinvd,\n\t[EXIT_REASON_XSETBV]                  = kvm_emulate_xsetbv,\n\t[EXIT_REASON_TASK_SWITCH]             = handle_task_switch,\n\t[EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,\n\t[EXIT_REASON_GDTR_IDTR]\t\t      = handle_desc,\n\t[EXIT_REASON_LDTR_TR]\t\t      = handle_desc,\n\t[EXIT_REASON_EPT_VIOLATION]\t      = handle_ept_violation,\n\t[EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,\n\t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n\t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = kvm_emulate_mwait,\n\t[EXIT_REASON_MONITOR_TRAP_FLAG]       = handle_monitor_trap,\n\t[EXIT_REASON_MONITOR_INSTRUCTION]     = kvm_emulate_monitor,\n\t[EXIT_REASON_INVEPT]                  = handle_vmx_instruction,\n\t[EXIT_REASON_INVVPID]                 = handle_vmx_instruction,\n\t[EXIT_REASON_RDRAND]                  = kvm_handle_invalid_op,\n\t[EXIT_REASON_RDSEED]                  = kvm_handle_invalid_op,\n\t[EXIT_REASON_PML_FULL]\t\t      = handle_pml_full,\n\t[EXIT_REASON_INVPCID]                 = handle_invpcid,\n\t[EXIT_REASON_VMFUNC]\t\t      = handle_vmx_instruction,\n\t[EXIT_REASON_PREEMPTION_TIMER]\t      = handle_preemption_timer,\n\t[EXIT_REASON_ENCLS]\t\t      = handle_encls,\n\t[EXIT_REASON_BUS_LOCK]                = handle_bus_lock_vmexit,\n};\n\nstatic const int kvm_vmx_max_exit_handlers =\n\tARRAY_SIZE(kvm_vmx_exit_handlers);\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u32 *reason,\n\t\t\t      u64 *info1, u64 *info2,\n\t\t\t      u32 *intr_info, u32 *error_code)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t*reason = vmx->exit_reason.full;\n\t*info1 = vmx_get_exit_qual(vcpu);\n\tif (!(vmx->exit_reason.failed_vmentry)) {\n\t\t*info2 = vmx->idt_vectoring_info;\n\t\t*intr_info = vmx_get_intr_info(vcpu);\n\t\tif (is_exception_with_error_code(*intr_info))\n\t\t\t*error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\t\telse\n\t\t\t*error_code = 0;\n\t} else {\n\t\t*info2 = 0;\n\t\t*intr_info = 0;\n\t\t*error_code = 0;\n\t}\n}\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}\n\nstatic void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}\n\nstatic void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read16(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}\n\nstatic void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}\n\nstatic void vmx_dump_msrs(char *name, struct vmx_msrs *m)\n{\n\tunsigned int i;\n\tstruct vmx_msr_entry *e;\n\n\tpr_err(\"MSR %s:\\n\", name);\n\tfor (i = 0, e = m->val; i < m->nr; ++i, ++e)\n\t\tpr_err(\"  %2d: msr=0x%08x value=0x%016llx\\n\", i, e->index, e->value);\n}\n\nvoid dump_vmcs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmentry_ctl, vmexit_ctl;\n\tu32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;\n\tunsigned long cr4;\n\tint efer_slot;\n\n\tif (!dump_invalid_vmcs) {\n\t\tpr_warn_ratelimited(\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tvmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tvmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tcpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tpin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tcr4 = vmcs_readl(GUEST_CR4);\n\tsecondary_exec_control = 0;\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"VMCS %p, last attempted VM-entry on CPU %d\\n\",\n\t       vmx->loaded_vmcs->vmcs, vcpu->arch.last_vmentry_cpu);\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif (cpu_has_vmx_ept()) {\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tefer_slot = vmx_find_loadstore_msr_slot(&vmx->msr_autoload.guest, MSR_EFER);\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_EFER)\n\t\tpr_err(\"EFER= 0x%016llx\\n\", vmcs_read64(GUEST_IA32_EFER));\n\telse if (efer_slot >= 0)\n\t\tpr_err(\"EFER= 0x%016llx (autoload)\\n\",\n\t\t       vmx->msr_autoload.guest.val[efer_slot].value);\n\telse if (vmentry_ctl & VM_ENTRY_IA32E_MODE)\n\t\tpr_err(\"EFER= 0x%016llx (effective)\\n\",\n\t\t       vcpu->arch.efer | (EFER_LMA | EFER_LME));\n\telse\n\t\tpr_err(\"EFER= 0x%016llx (effective)\\n\",\n\t\t       vcpu->arch.efer & ~(EFER_LMA | EFER_LME));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tpr_err(\"PAT = 0x%016llx\\n\", vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\tif (vmcs_read32(VM_ENTRY_MSR_LOAD_COUNT) > 0)\n\t\tvmx_dump_msrs(\"guest autoload\", &vmx->msr_autoload.guest);\n\tif (vmcs_read32(VM_EXIT_MSR_STORE_COUNT) > 0)\n\t\tvmx_dump_msrs(\"guest autostore\", &vmx->msr_autostore.guest);\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_EFER)\n\t\tpr_err(\"EFER= 0x%016llx\\n\", vmcs_read64(HOST_IA32_EFER));\n\tif (vmexit_ctl & VM_EXIT_LOAD_IA32_PAT)\n\t\tpr_err(\"PAT = 0x%016llx\\n\", vmcs_read64(HOST_IA32_PAT));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmcs_read32(VM_EXIT_MSR_LOAD_COUNT) > 0)\n\t\tvmx_dump_msrs(\"host autoload\", &vmx->msr_autoload.host);\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW) {\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tu16 status = vmcs_read16(GUEST_INTR_STATUS);\n\t\t\tpr_err(\"SVI|RVI = %02x|%02x \", status >> 8, status & 0xff);\n\t\t}\n\t\tpr_cont(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tpr_err(\"APIC-access addr = 0x%016llx \", vmcs_read64(APIC_ACCESS_ADDR));\n\t\tpr_cont(\"virt-APIC addr = 0x%016llx\\n\", vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));\n\t}\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}\n\n/*\n * The guest has exited.  See if we can fix it or if we need userspace\n * assistance.\n */\nstatic int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunion vmx_exit_reason exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\tu16 exit_handler_index;\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.  Note, PML is never enabled in hardware while\n\t * running L2.\n\t */\n\tif (enable_pml && !is_guest_mode(vcpu))\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/*\n\t * KVM should never reach this point with a pending nested VM-Enter.\n\t * More specifically, short-circuiting VM-Entry to emulate L2 due to\n\t * invalid guest state should never happen as that means KVM knowingly\n\t * allowed a nested VM-Enter with an invalid vmcs12.  More below.\n\t */\n\tif (KVM_BUG_ON(vmx->nested.nested_run_pending, vcpu->kvm))\n\t\treturn -EIO;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * PML is never enabled when running L2, bail immediately if a\n\t\t * PML full exit occurs as something is horribly wrong.\n\t\t */\n\t\tif (exit_reason.basic == EXIT_REASON_PML_FULL)\n\t\t\tgoto unexpected_vmexit;\n\n\t\t/*\n\t\t * The host physical addresses of some pages of guest memory\n\t\t * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC\n\t\t * Page). The CPU may write to these pages via their host\n\t\t * physical address while L2 is running, bypassing any\n\t\t * address-translation-based dirty tracking (e.g. EPT write\n\t\t * protection).\n\t\t *\n\t\t * Mark them dirty on every exit from L2 to prevent them from\n\t\t * getting out of sync with dirty tracking.\n\t\t */\n\t\tnested_mark_vmcs12_pages_dirty(vcpu);\n\n\t\t/*\n\t\t * Synthesize a triple fault if L2 state is invalid.  In normal\n\t\t * operation, nested VM-Enter rejects any attempt to enter L2\n\t\t * with invalid state.  However, those checks are skipped if\n\t\t * state is being stuffed via RSM or KVM_SET_NESTED_STATE.  If\n\t\t * L2 state is invalid, it means either L1 modified SMRAM state\n\t\t * or userspace provided bad state.  Synthesize TRIPLE_FAULT as\n\t\t * doing so is architecturally allowed in the RSM case, and is\n\t\t * the least awful solution for the userspace case without\n\t\t * risking false positives.\n\t\t */\n\t\tif (vmx->emulation_required) {\n\t\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_TRIPLE_FAULT, 0, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (nested_vmx_reflect_vmexit(vcpu))\n\t\t\treturn 1;\n\t}\n\n\t/* If guest state is invalid, start emulating.  L2 is handled above. */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (exit_reason.failed_vmentry) {\n\t\tdump_vmcs(vcpu);\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason.full;\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tdump_vmcs(vcpu);\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t    (exit_reason.basic != EXIT_REASON_EXCEPTION_NMI &&\n\t     exit_reason.basic != EXIT_REASON_EPT_VIOLATION &&\n\t     exit_reason.basic != EXIT_REASON_PML_FULL &&\n\t     exit_reason.basic != EXIT_REASON_APIC_ACCESS &&\n\t     exit_reason.basic != EXIT_REASON_TASK_SWITCH)) {\n\t\tint ndata = 3;\n\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason.full;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.data[ndata++] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\tvcpu->run->internal.data[ndata++] = vcpu->arch.last_vmentry_cpu;\n\t\tvcpu->run->internal.ndata = ndata;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked)) {\n\t\tif (!vmx_interrupt_blocked(vcpu)) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_fastpath != EXIT_FASTPATH_NONE)\n\t\treturn 1;\n\n\tif (exit_reason.basic >= kvm_vmx_max_exit_handlers)\n\t\tgoto unexpected_vmexit;\n#ifdef CONFIG_RETPOLINE\n\tif (exit_reason.basic == EXIT_REASON_MSR_WRITE)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_PREEMPTION_TIMER)\n\t\treturn handle_preemption_timer(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_INTERRUPT_WINDOW)\n\t\treturn handle_interrupt_window(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\treturn handle_external_interrupt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG)\n\t\treturn handle_ept_misconfig(vcpu);\n#endif\n\n\texit_handler_index = array_index_nospec((u16)exit_reason.basic,\n\t\t\t\t\t\tkvm_vmx_max_exit_handlers);\n\tif (!kvm_vmx_exit_handlers[exit_handler_index])\n\t\tgoto unexpected_vmexit;\n\n\treturn kvm_vmx_exit_handlers[exit_handler_index](vcpu);\n\nunexpected_vmexit:\n\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\",\n\t\t    exit_reason.full);\n\tdump_vmcs(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 2;\n\tvcpu->run->internal.data[0] = exit_reason.full;\n\tvcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;\n\treturn 0;\n}\n\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tint ret = __vmx_handle_exit(vcpu, exit_fastpath);\n\n\t/*\n\t * Exit to user space when bus lock detected to inform that there is\n\t * a bus lock in guest.\n\t */\n\tif (to_vmx(vcpu)->exit_reason.bus_lock_detected) {\n\t\tif (ret > 0)\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_X86_BUS_LOCK;\n\n\t\tvcpu->run->flags |= KVM_RUN_X86_BUS_LOCK;\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\n/*\n * Software based L1D cache flush which is used when microcode providing\n * the cache control MSR is not loaded.\n *\n * The L1D cache is 32 KiB on Nehalem and later microarchitectures, but to\n * flush it is required to read in 64 KiB because the replacement algorithm\n * is not exactly LRU. This could be sized at runtime via topology\n * information but as all relevant affected CPUs have 32KiB L1D cache size\n * there is no point in doing so.\n */\nstatic noinstr void vmx_l1d_flush(struct kvm_vcpu *vcpu)\n{\n\tint size = PAGE_SIZE << L1D_CACHE_ORDER;\n\n\t/*\n\t * This code is only executed when the the flush mode is 'cond' or\n\t * 'always'\n\t */\n\tif (static_branch_likely(&vmx_l1d_flush_cond)) {\n\t\tbool flush_l1d;\n\n\t\t/*\n\t\t * Clear the per-vcpu flush bit, it gets set again\n\t\t * either from vcpu_run() or from one of the unsafe\n\t\t * VMEXIT handlers.\n\t\t */\n\t\tflush_l1d = vcpu->arch.l1tf_flush_l1d;\n\t\tvcpu->arch.l1tf_flush_l1d = false;\n\n\t\t/*\n\t\t * Clear the per-cpu flush bit, it gets set again from\n\t\t * the interrupt handlers.\n\t\t */\n\t\tflush_l1d |= kvm_get_cpu_l1tf_flush_l1d();\n\t\tkvm_clear_cpu_l1tf_flush_l1d();\n\n\t\tif (!flush_l1d)\n\t\t\treturn;\n\t}\n\n\tvcpu->stat.l1d_flush++;\n\n\tif (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\tnative_wrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);\n\t\treturn;\n\t}\n\n\tasm volatile(\n\t\t/* First ensure the pages are in the TLB */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lpopulate_tlb:\\n\\t\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$4096, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lpopulate_tlb\\n\\t\"\n\t\t\"xorl\t%%eax, %%eax\\n\\t\"\n\t\t\"cpuid\\n\\t\"\n\t\t/* Now fill the cache */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lfill_cache:\\n\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$64, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lfill_cache\\n\\t\"\n\t\t\"lfence\\n\"\n\t\t:: [flush_pages] \"r\" (vmx_l1d_flush_pages),\n\t\t    [size] \"r\" (size)\n\t\t: \"eax\", \"ebx\", \"ecx\", \"edx\");\n}\n\nstatic void vmx_update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tint tpr_threshold;\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\ttpr_threshold = (irr == -1 || tpr < irr) ? 0 : irr;\n\tif (is_guest_mode(vcpu))\n\t\tto_vmx(vcpu)->nested.l1_tpr_threshold = tpr_threshold;\n\telse\n\t\tvmcs_write32(TPR_THRESHOLD, tpr_threshold);\n}\n\nvoid vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 sec_exec_control;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!flexpriority_enabled &&\n\t    !cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = true;\n\t\treturn;\n\t}\n\n\tsec_exec_control = secondary_exec_controls_get(vmx);\n\tsec_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n\n\tswitch (kvm_get_apic_mode(vcpu)) {\n\tcase LAPIC_MODE_INVALID:\n\t\tWARN_ONCE(true, \"Invalid local APIC state\");\n\t\tbreak;\n\tcase LAPIC_MODE_DISABLED:\n\t\tbreak;\n\tcase LAPIC_MODE_XAPIC:\n\t\tif (flexpriority_enabled) {\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\t\t\t/*\n\t\t\t * Flush the TLB, reloading the APIC access page will\n\t\t\t * only do so if its physical address has changed, but\n\t\t\t * the guest may have inserted a non-APIC mapping into\n\t\t\t * the TLB while the APIC access page was disabled.\n\t\t\t */\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\t\t}\n\t\tbreak;\n\tcase LAPIC_MODE_X2APIC:\n\t\tif (cpu_has_vmx_virtualize_x2apic_mode())\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tbreak;\n\t}\n\tsecondary_exec_controls_set(vmx, sec_exec_control);\n\n\tvmx_update_msr_bitmap_x2apic(vcpu);\n}\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\n\t/* Defer reload until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.reload_vmcs01_apic_access_page = true;\n\t\treturn;\n\t}\n\n\tif (!(secondary_exec_controls_get(to_vmx(vcpu)) &\n\t    SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))\n\t\treturn;\n\n\tpage = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn;\n\n\tvmcs_write64(APIC_ACCESS_ADDR, page_to_phys(page));\n\tvmx_flush_tlb_current(vcpu);\n\n\t/*\n\t * Do not pin apic access page in memory, the MMU notifier\n\t * will call us again if it is migrated or swapped out.\n\t */\n\tput_page(page);\n}\n\nstatic void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (max_isr == -1)\n\t\tmax_isr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (max_isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= max_isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\t/*\n\t * When running L2, updating RVI is only relevant when\n\t * vmcs12 virtual-interrupt-delivery enabled.\n\t * However, it can be enabled only when L1 also\n\t * intercepts external-interrupts and in that case\n\t * we should not update vmcs02 RVI but instead intercept\n\t * interrupt. Therefore, do nothing when running L2.\n\t */\n\tif (!is_guest_mode(vcpu))\n\t\tvmx_set_rvi(max_irr);\n}\n\nstatic int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tbool got_posted_interrupt;\n\n\tif (KVM_BUG_ON(!enable_apicv, vcpu->kvm))\n\t\treturn -EIO;\n\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\t/*\n\t\t * IOMMU can write to PID.ON, so the barrier matters even on UP.\n\t\t * But on x86 this is just a compiler barrier anyway.\n\t\t */\n\t\tsmp_mb__after_atomic();\n\t\tgot_posted_interrupt =\n\t\t\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t\tgot_posted_interrupt = false;\n\t}\n\n\t/*\n\t * Newly recognized interrupts are injected via either virtual interrupt\n\t * delivery (RVI) or KVM_REQ_EVENT.  Virtual interrupt delivery is\n\t * disabled in two cases:\n\t *\n\t * 1) If L2 is running and the vCPU has a new pending interrupt.  If L1\n\t * wants to exit on interrupts, KVM_REQ_EVENT is needed to synthesize a\n\t * VM-Exit to L1.  If L1 doesn't want to exit, the interrupt is injected\n\t * into L2, but KVM doesn't use virtual interrupt delivery to inject\n\t * interrupts into L2, and so KVM_REQ_EVENT is again needed.\n\t *\n\t * 2) If APICv is disabled for this vCPU, assigned devices may still\n\t * attempt to post interrupts.  The posted interrupt vector will cause\n\t * a VM-Exit and the subsequent entry will call sync_pir_to_irr.\n\t */\n\tif (!is_guest_mode(vcpu) && kvm_vcpu_apicv_active(vcpu))\n\t\tvmx_set_rvi(max_irr);\n\telse if (got_posted_interrupt)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn max_irr;\n}\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}\n\nstatic void vmx_apicv_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tpi_clear_on(&vmx->pi_desc);\n\tmemset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));\n}\n\nvoid vmx_do_interrupt_nmi_irqoff(unsigned long entry);\n\nstatic void handle_interrupt_nmi_irqoff(struct kvm_vcpu *vcpu,\n\t\t\t\t\tunsigned long entry)\n{\n\tbool is_nmi = entry == (unsigned long)asm_exc_nmi_noist;\n\n\tkvm_before_interrupt(vcpu, is_nmi ? KVM_HANDLING_NMI : KVM_HANDLING_IRQ);\n\tvmx_do_interrupt_nmi_irqoff(entry);\n\tkvm_after_interrupt(vcpu);\n}\n\nstatic void handle_nm_fault_irqoff(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Save xfd_err to guest_fpu before interrupt is enabled, so the\n\t * MSR value is not clobbered by the host activity before the guest\n\t * has chance to consume it.\n\t *\n\t * Do not blindly read xfd_err here, since this exception might\n\t * be caused by L1 interception on a platform which doesn't\n\t * support xfd at all.\n\t *\n\t * Do it conditionally upon guest_fpu::xfd. xfd_err matters\n\t * only when xfd contains a non-zero value.\n\t *\n\t * Queuing exception is done in vmx_handle_exit. See comment there.\n\t */\n\tif (vcpu->arch.guest_fpu.fpstate->xfd)\n\t\trdmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);\n}\n\nstatic void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)\n{\n\tconst unsigned long nmi_entry = (unsigned long)asm_exc_nmi_noist;\n\tu32 intr_info = vmx_get_intr_info(&vmx->vcpu);\n\n\t/* if exit due to PF check for async PF */\n\tif (is_page_fault(intr_info))\n\t\tvmx->vcpu.arch.apf.host_apf_flags = kvm_read_and_reset_apf_flags();\n\t/* if exit due to NM, handle before interrupts are enabled */\n\telse if (is_nm_fault(intr_info))\n\t\thandle_nm_fault_irqoff(&vmx->vcpu);\n\t/* Handle machine checks before interrupts are enabled */\n\telse if (is_machine_check(intr_info))\n\t\tkvm_machine_check();\n\t/* We need to handle NMIs before interrupts are enabled */\n\telse if (is_nmi(intr_info))\n\t\thandle_interrupt_nmi_irqoff(&vmx->vcpu, nmi_entry);\n}\n\nstatic void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmx_get_intr_info(vcpu);\n\tunsigned int vector = intr_info & INTR_INFO_VECTOR_MASK;\n\tgate_desc *desc = (gate_desc *)host_idt_base + vector;\n\n\tif (KVM_BUG(!is_external_intr(intr_info), vcpu->kvm,\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\thandle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));\n\tvcpu->arch.at_instruction_boundary = true;\n}\n\nstatic void vmx_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\thandle_external_interrupt_irqoff(vcpu);\n\telse if (vmx->exit_reason.basic == EXIT_REASON_EXCEPTION_NMI)\n\t\thandle_exception_nmi_irqoff(vmx);\n}\n\n/*\n * The kvm parameter can be NULL (module initialization, or invocation before\n * VM creation). Be sure to check the kvm parameter before using it.\n */\nstatic bool vmx_has_emulated_msr(struct kvm *kvm, u32 index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_SMBASE:\n\t\t/*\n\t\t * We cannot do SMM unless we can run the guest in big\n\t\t * real mode.\n\t\t */\n\t\treturn enable_unrestricted_guest || emulate_invalid_guest_state;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn nested;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\tcase MSR_AMD64_TSC_RATIO:\n\t\t/* This is AMD only.  */\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\t\treturn;\n\n\t\texit_intr_info = vmx_get_intr_info(&vmx->vcpu);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time));\n}\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\tfallthrough;\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\tfallthrough;\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\t/* Note, nr_msrs may be garbage if perf_guest_get_msrs() returns NULL. */\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host, false);\n}\n\nstatic void vmx_update_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->req_immediate_exit) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (vmx->hv_deadline_tsc != -1) {\n\t\ttscl = rdtsc();\n\t\tif (vmx->hv_deadline_tsc > tscl)\n\t\t\t/* set_hv_timer ensures the delta fits in 32-bits */\n\t\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi);\n\t\telse\n\t\t\tdelta_tsc = 0;\n\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = true;\n\t}\n}\n\nvoid noinstr vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp)\n{\n\tif (unlikely(host_rsp != vmx->loaded_vmcs->host_state.rsp)) {\n\t\tvmx->loaded_vmcs->host_state.rsp = host_rsp;\n\t\tvmcs_writel(HOST_RSP, host_rsp);\n\t}\n}\n\nstatic fastpath_t vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)\n{\n\tswitch (to_vmx(vcpu)->exit_reason.basic) {\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn handle_fastpath_set_msr_irqoff(vcpu);\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn handle_fastpath_preemption_timer(vcpu);\n\tdefault:\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n}\n\nstatic noinstr void vmx_vcpu_enter_exit(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct vcpu_vmx *vmx)\n{\n\tguest_state_enter_irqoff();\n\n\t/* L1D Flush includes CPU buffer clear to mitigate MDS */\n\tif (static_branch_unlikely(&vmx_l1d_should_flush))\n\t\tvmx_l1d_flush(vcpu);\n\telse if (static_branch_unlikely(&mds_user_clear))\n\t\tmds_clear_cpu_buffers();\n\n\tif (vcpu->arch.cr2 != native_read_cr2())\n\t\tnative_write_cr2(vcpu->arch.cr2);\n\n\tvmx->fail = __vmx_vcpu_run(vmx, (unsigned long *)&vcpu->arch.regs,\n\t\t\t\t   vmx->loaded_vmcs->launched);\n\n\tvcpu->arch.cr2 = native_read_cr2();\n\n\tguest_state_exit_irqoff();\n}\n\nstatic fastpath_t vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long cr3, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->entry_time = ktime_get();\n\n\t/*\n\t * Don't enter VMX if guest state is invalid, let the exit handler\n\t * start emulation until we arrive back to a valid state.  Synthesize a\n\t * consistency check VM-Exit due to invalid guest state and bail.\n\t */\n\tif (unlikely(vmx->emulation_required)) {\n\t\tvmx->fail = 0;\n\n\t\tvmx->exit_reason.full = EXIT_REASON_INVALID_STATE;\n\t\tvmx->exit_reason.failed_vmentry = 1;\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_1);\n\t\tvmx->exit_qualification = ENTRY_FAIL_DEFAULT;\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_EXIT_INFO_2);\n\t\tvmx->exit_intr_info = 0;\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\ttrace_kvm_entry(vcpu);\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\t/*\n\t * We did this in prepare_switch_to_guest, because it needs to\n\t * be within srcu_read_lock.\n\t */\n\tWARN_ON_ONCE(vmx->nested.need_vmcs12_to_shadow_sync);\n\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RSP))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RIP))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\tvcpu->arch.regs_dirty = 0;\n\n\t/*\n\t * Refresh vmcs.HOST_CR3 if necessary.  This must be done immediately\n\t * prior to VM-Enter, as the kernel may load a new ASID (PCID) any time\n\t * it switches back to the current->mm, which can occur in KVM context\n\t * when switching to a temporary mm to patch kernel code, e.g. if KVM\n\t * toggles a static key while handling a VM-Exit.\n\t */\n\tcr3 = __get_current_cr3_fast();\n\tif (unlikely(cr3 != vmx->loaded_vmcs->host_state.cr3)) {\n\t\tvmcs_writel(HOST_CR3, cr3);\n\t\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\t}\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->loaded_vmcs->host_state.cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\t}\n\n\t/* When KVM_DEBUGREG_WONT_EXIT, dr6 is accessible in guest. */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT))\n\t\tset_debugreg(vcpu->arch.dr6, 6);\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tpt_guest_enter(vmx);\n\n\tatomic_switch_perf_msrs(vmx);\n\tif (intel_pmu_lbr_is_enabled(vcpu))\n\t\tvmx_passthrough_lbr_msrs(vcpu);\n\n\tif (enable_preemption_timer)\n\t\tvmx_update_hv_timer(vcpu);\n\n\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tx86_spec_ctrl_set_guest(vmx->spec_ctrl, 0);\n\n\t/* The actual VMENTER/EXIT is in the .noinstr.text section. */\n\tvmx_vcpu_enter_exit(vcpu, vmx);\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vmx, MSR_IA32_SPEC_CTRL)))\n\t\tvmx->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tx86_spec_ctrl_restore_host(vmx->spec_ctrl, 0);\n\n\t/* All fields are clean at this point */\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tcurrent_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\n\t\tcurrent_evmcs->hv_vp_id = kvm_hv_get_vpindex(vcpu);\n\t}\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (vmx->host_debugctlmsr)\n\t\tupdate_debugctlmsr(vmx->host_debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_prepare_switch_to_host() since that\n\t * function may be executed in interrupt context, which saves and\n\t * restore segments around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail &= ~VMX_REGS_LAZY_LOAD_SET;\n\n\tpt_guest_exit(vmx);\n\n\tkvm_load_host_xsave_state(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * Track VMLAUNCH/VMRESUME that have made past guest state\n\t\t * checking.\n\t\t */\n\t\tif (vmx->nested.nested_run_pending &&\n\t\t    !vmx->exit_reason.failed_vmentry)\n\t\t\t++vcpu->stat.nested_run;\n\n\t\tvmx->nested.nested_run_pending = 0;\n\t}\n\n\tvmx->idt_vectoring_info = 0;\n\n\tif (unlikely(vmx->fail)) {\n\t\tvmx->exit_reason.full = 0xdead;\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\tvmx->exit_reason.full = vmcs_read32(VM_EXIT_REASON);\n\tif (unlikely((u16)vmx->exit_reason.basic == EXIT_REASON_MCE_DURING_VMENTRY))\n\t\tkvm_machine_check();\n\n\tif (likely(!vmx->exit_reason.failed_vmentry))\n\t\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\ttrace_kvm_exit(vcpu, KVM_ISA_VMX);\n\n\tif (unlikely(vmx->exit_reason.failed_vmentry))\n\t\treturn EXIT_FASTPATH_NONE;\n\n\tvmx->loaded_vmcs->launched = 1;\n\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn EXIT_FASTPATH_NONE;\n\n\treturn vmx_exit_handlers_fastpath(vcpu);\n}\n\nstatic void vmx_vcpu_free(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (enable_pml)\n\t\tvmx_destroy_pml_buffer(vmx);\n\tfree_vpid(vmx->vpid);\n\tnested_vmx_free_vcpu(vcpu);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n}\n\nstatic int vmx_vcpu_create(struct kvm_vcpu *vcpu)\n{\n\tstruct vmx_uret_msr *tsx_ctrl;\n\tstruct vcpu_vmx *vmx;\n\tint i, err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_vmx, vcpu) != 0);\n\tvmx = to_vmx(vcpu);\n\n\tINIT_LIST_HEAD(&vmx->pi_wakeup_list);\n\n\terr = -ENOMEM;\n\n\tvmx->vpid = allocate_vpid();\n\n\t/*\n\t * If PML is turned on, failure on enabling PML just results in failure\n\t * of creating the vcpu, therefore we can simplify PML logic (by\n\t * avoiding dealing with cases, such as enabling PML partially on vcpus\n\t * for the guest), etc.\n\t */\n\tif (enable_pml) {\n\t\tvmx->pml_pg = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\t\tif (!vmx->pml_pg)\n\t\t\tgoto free_vpid;\n\t}\n\n\tfor (i = 0; i < kvm_nr_uret_msrs; ++i)\n\t\tvmx->guest_uret_msrs[i].mask = -1ull;\n\tif (boot_cpu_has(X86_FEATURE_RTM)) {\n\t\t/*\n\t\t * TSX_CTRL_CPUID_CLEAR is handled in the CPUID interception.\n\t\t * Keep the host value unchanged to avoid changing CPUID bits\n\t\t * under the host kernel's feet.\n\t\t */\n\t\ttsx_ctrl = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);\n\t\tif (tsx_ctrl)\n\t\t\ttsx_ctrl->mask = ~(u64)TSX_CTRL_CPUID_CLEAR;\n\t}\n\n\terr = alloc_loaded_vmcs(&vmx->vmcs01);\n\tif (err < 0)\n\t\tgoto free_pml;\n\n\t/*\n\t * Use Hyper-V 'Enlightened MSR Bitmap' feature when KVM runs as a\n\t * nested (L1) hypervisor and Hyper-V in L0 supports it. Enable the\n\t * feature only for vmcs01, KVM currently isn't equipped to realize any\n\t * performance benefits from enabling it for vmcs02.\n\t */\n\tif (IS_ENABLED(CONFIG_HYPERV) && static_branch_unlikely(&enable_evmcs) &&\n\t    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {\n\t\tstruct hv_enlightened_vmcs *evmcs = (void *)vmx->vmcs01.vmcs;\n\n\t\tevmcs->hv_enlightenments_control.msr_bitmap = 1;\n\t}\n\n\t/* The MSR bitmap starts with all ones */\n\tbitmap_fill(vmx->shadow_msr_intercept.read, MAX_POSSIBLE_PASSTHROUGH_MSRS);\n\tbitmap_fill(vmx->shadow_msr_intercept.write, MAX_POSSIBLE_PASSTHROUGH_MSRS);\n\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_TSC, MSR_TYPE_R);\n#ifdef CONFIG_X86_64\n\tvmx_disable_intercept_for_msr(vcpu, MSR_FS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_GS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_KERNEL_GS_BASE, MSR_TYPE_RW);\n#endif\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_CS, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_ESP, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(vcpu, MSR_IA32_SYSENTER_EIP, MSR_TYPE_RW);\n\tif (kvm_cstate_in_guest(vcpu->kvm)) {\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C1_RES, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C3_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C6_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(vcpu, MSR_CORE_C7_RESIDENCY, MSR_TYPE_R);\n\t}\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\n\tif (cpu_need_virtualize_apic_accesses(vcpu)) {\n\t\terr = alloc_apic_access_page(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept && !enable_unrestricted_guest) {\n\t\terr = init_rmode_identity_map(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\treturn 0;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_pml:\n\tvmx_destroy_pml_buffer(vmx);\nfree_vpid:\n\tfree_vpid(vmx->vpid);\n\treturn err;\n}\n\n#define L1TF_MSG_SMT \"L1TF CPU bug present and SMT on, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"\n#define L1TF_MSG_L1D \"L1TF CPU bug present and virtualization mitigation disabled, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"\n\nstatic int vmx_vm_init(struct kvm *kvm)\n{\n\tif (!ple_gap)\n\t\tkvm->arch.pause_in_guest = true;\n\n\tif (boot_cpu_has(X86_BUG_L1TF) && enable_ept) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\t\t/* 'I explicitly don't care' is set */\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\tcase L1TF_MITIGATION_FULL:\n\t\t\t/*\n\t\t\t * Warn upon starting the first VM in a potentially\n\t\t\t * insecure environment.\n\t\t\t */\n\t\t\tif (sched_smt_active())\n\t\t\t\tpr_warn_once(L1TF_MSG_SMT);\n\t\t\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER)\n\t\t\t\tpr_warn_once(L1TF_MSG_L1D);\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\t/* Flush is enforced */\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int __init vmx_check_processor_compat(void)\n{\n\tstruct vmcs_config vmcs_conf;\n\tstruct vmx_capability vmx_cap;\n\n\tif (!this_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t    !this_cpu_has(X86_FEATURE_VMX)) {\n\t\tpr_err(\"kvm: VMX is disabled on CPU %d\\n\", smp_processor_id());\n\t\treturn -EIO;\n\t}\n\n\tif (setup_vmcs_config(&vmcs_conf, &vmx_cap) < 0)\n\t\treturn -EIO;\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_conf.nested, vmx_cap.ept);\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\n\t/* We wanted to honor guest CD/MTRR/PAT, but doing so could result in\n\t * memory aliases with conflicting memory types and sometimes MCEs.\n\t * We have to be careful as to what are honored and when.\n\t *\n\t * For MMIO, guest CD/MTRR are ignored.  The EPT memory type is set to\n\t * UC.  The effective memory type is UC or WC depending on guest PAT.\n\t * This was historically the source of MCEs and we want to be\n\t * conservative.\n\t *\n\t * When there is no need to deal with noncoherent DMA (e.g., no VT-d\n\t * or VT-d has snoop control), guest CD/MTRR/PAT are all ignored.  The\n\t * EPT memory type is set to WB.  The effective memory type is forced\n\t * WB.\n\t *\n\t * Otherwise, we trust guest.  Guest CD/MTRR/PAT are all honored.  The\n\t * EPT memory type is used to emulate guest CD/MTRR.\n\t */\n\n\tif (is_mmio)\n\t\treturn MTRR_TYPE_UNCACHABLE << VMX_EPT_MT_EPTE_SHIFT;\n\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm))\n\t\treturn (MTRR_TYPE_WRBACK << VMX_EPT_MT_EPTE_SHIFT) | VMX_EPT_IPAT_BIT;\n\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\n\t\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | VMX_EPT_IPAT_BIT;\n\t}\n\n\treturn kvm_mtrr_get_guest_memory_type(vcpu, gfn) << VMX_EPT_MT_EPTE_SHIFT;\n}\n\nstatic void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx, u32 new_ctl)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_DESC;\n\n\tu32 cur_ctl = secondary_exec_controls_get(vmx);\n\n\tsecondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));\n}\n\n/*\n * Generate MSR_IA32_VMX_CR{0,4}_FIXED1 according to CPUID. Only set bits\n * (indicating \"allowed-1\") if they are supported in the guest's CPUID.\n */\nstatic void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));\n\tcr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));\n\n#undef cr4_fixed1_update\n}\n\nstatic void nested_vmx_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (kvm_mpx_supported()) {\n\t\tbool mpx_enabled = guest_cpuid_has(vcpu, X86_FEATURE_MPX);\n\n\t\tif (mpx_enabled) {\n\t\t\tvmx->nested.msrs.entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\t\t} else {\n\t\t\tvmx->nested.msrs.entry_ctls_high &= ~VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high &= ~VM_EXIT_CLEAR_BNDCFGS;\n\t\t}\n\t}\n}\n\nstatic void update_intel_pt_cfg(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\tint i;\n\n\tfor (i = 0; i < PT_CPUID_LEAVES; i++) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x14, i);\n\t\tif (!best)\n\t\t\treturn;\n\t\tvmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;\n\t\tvmx->pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best->ebx;\n\t\tvmx->pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best->ecx;\n\t\tvmx->pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best->edx;\n\t}\n\n\t/* Get the number of configurable Address Ranges for filtering */\n\tvmx->pt_desc.num_address_ranges = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_num_address_ranges);\n\n\t/* Initialize and clear the no dependency bits */\n\tvmx->pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |\n\t\t\tRTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC |\n\t\t\tRTIT_CTL_BRANCH_EN);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise\n\t * will inject an #GP\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_cr3_filtering))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and\n\t * PSBFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |\n\t\t\t\tRTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn and MTCFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |\n\t\t\t\t\t      RTIT_CTL_MTC_RANGE);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |\n\t\t\t\t\t\t\tRTIT_CTL_PTW_EN);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabricEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;\n\n\t/* unmask address range configure area */\n\tfor (i = 0; i < vmx->pt_desc.num_address_ranges; i++)\n\t\tvmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));\n}\n\nstatic void vmx_vcpu_after_set_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/* xsaves_enabled is recomputed in vmx_compute_secondary_exec_control(). */\n\tvcpu->arch.xsaves_enabled = false;\n\n\tvmx_setup_uret_msrs(vmx);\n\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tvmcs_set_secondary_exec_control(vmx,\n\t\t\t\t\t\tvmx_secondary_exec_control(vmx));\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tvmx->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\tFEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;\n\telse\n\t\tvmx->msr_ia32_feature_control_valid_bits &=\n\t\t\t~(FEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\t  FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX);\n\n\tif (nested_vmx_allowed(vcpu)) {\n\t\tnested_vmx_cr_fixed1_bits_update(vcpu);\n\t\tnested_vmx_entry_exit_ctls_update(vcpu);\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_INTEL_PT) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INTEL_PT))\n\t\tupdate_intel_pt_cfg(vcpu);\n\n\tif (boot_cpu_has(X86_FEATURE_RTM)) {\n\t\tstruct vmx_uret_msr *msr;\n\t\tmsr = vmx_find_uret_msr(vmx, MSR_IA32_TSX_CTRL);\n\t\tif (msr) {\n\t\t\tbool enabled = guest_cpuid_has(vcpu, X86_FEATURE_RTM);\n\t\t\tvmx_set_guest_uret_msr(vmx, msr, enabled ? 0 : TSX_CTRL_RTM_DISABLE);\n\t\t}\n\t}\n\n\tif (kvm_cpu_cap_has(X86_FEATURE_XFD))\n\t\tvmx_set_intercept_for_msr(vcpu, MSR_IA32_XFD_ERR, MSR_TYPE_R,\n\t\t\t\t\t  !guest_cpuid_has(vcpu, X86_FEATURE_XFD));\n\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tvmx_write_encls_bitmap(vcpu, NULL);\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX))\n\t\tvmx->msr_ia32_feature_control_valid_bits |= FEAT_CTL_SGX_ENABLED;\n\telse\n\t\tvmx->msr_ia32_feature_control_valid_bits &= ~FEAT_CTL_SGX_ENABLED;\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_SGX_LC))\n\t\tvmx->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_SGX_LC_ENABLED;\n\telse\n\t\tvmx->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEAT_CTL_SGX_LC_ENABLED;\n\n\t/* Refresh #PF interception to account for MAXPHYADDR changes. */\n\tvmx_update_exception_bitmap(vcpu);\n}\n\nstatic __init void vmx_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\t/* CPUID 0x1 */\n\tif (nested)\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMX);\n\n\t/* CPUID 0x7 */\n\tif (kvm_mpx_supported())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_MPX);\n\tif (!cpu_has_vmx_invpcid())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_INVPCID);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);\n\n\tif (!enable_sgx) {\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX_LC);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX1);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_SGX2);\n\t}\n\n\tif (vmx_umip_emulated())\n\t\tkvm_cpu_cap_set(X86_FEATURE_UMIP);\n\n\t/* CPUID 0xD.1 */\n\tsupported_xss = 0;\n\tif (!cpu_has_vmx_xsaves())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_XSAVES);\n\n\t/* CPUID 0x80000001 and 0x7 (RDPID) */\n\tif (!cpu_has_vmx_rdtscp()) {\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDTSCP);\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDPID);\n\t}\n\n\tif (cpu_has_vmx_waitpkg())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_WAITPKG);\n}\n\nstatic void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->req_immediate_exit = true;\n}\n\nstatic int vmx_check_intercept_io(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_instruction_info *info)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tunsigned short port;\n\tbool intercept;\n\tint size;\n\n\tif (info->intercept == x86_intercept_in ||\n\t    info->intercept == x86_intercept_ins) {\n\t\tport = info->src_val;\n\t\tsize = info->dst_bytes;\n\t} else {\n\t\tport = info->dst_val;\n\t\tsize = info->src_bytes;\n\t}\n\n\t/*\n\t * If the 'use IO bitmaps' VM-execution control is 0, IO instruction\n\t * VM-exits depend on the 'unconditional IO exiting' VM-execution\n\t * control.\n\t *\n\t * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.\n\t */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\tintercept = nested_cpu_has(vmcs12,\n\t\t\t\t\t   CPU_BASED_UNCOND_IO_EXITING);\n\telse\n\t\tintercept = nested_vmx_check_io_bitmaps(vcpu, port, size);\n\n\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\treturn intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;\n}\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tswitch (info->intercept) {\n\t/*\n\t * RDPID causes #UD if disabled through secondary execution controls.\n\t * Because it is marked as EmulateOnUD, we need to intercept it here.\n\t * Note, RDPID is hidden behind ENABLE_RDTSCP.\n\t */\n\tcase x86_intercept_rdpid:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_RDTSCP)) {\n\t\t\texception->vector = UD_VECTOR;\n\t\t\texception->error_code_valid = false;\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\t}\n\t\tbreak;\n\n\tcase x86_intercept_in:\n\tcase x86_intercept_ins:\n\tcase x86_intercept_out:\n\tcase x86_intercept_outs:\n\t\treturn vmx_check_intercept_io(vcpu, info);\n\n\tcase x86_intercept_lgdt:\n\tcase x86_intercept_lidt:\n\tcase x86_intercept_lldt:\n\tcase x86_intercept_ltr:\n\tcase x86_intercept_sgdt:\n\tcase x86_intercept_sidt:\n\tcase x86_intercept_sldt:\n\tcase x86_intercept_str:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC))\n\t\t\treturn X86EMUL_CONTINUE;\n\n\t\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\t\tbreak;\n\n\t/* TODO: check more intercepts... */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn X86EMUL_UNHANDLEABLE;\n}\n\n#ifdef CONFIG_X86_64\n/* (a << shift) / divisor, return 1 if overflow otherwise 0 */\nstatic inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}\n\nstatic int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,\n\t\t\t    bool *expired)\n{\n\tstruct vcpu_vmx *vmx;\n\tu64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;\n\tstruct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;\n\n\tvmx = to_vmx(vcpu);\n\ttscl = rdtsc();\n\tguest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tdelta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\tlapic_timer_advance_cycles = nsec_to_cycles(vcpu,\n\t\t\t\t\t\t    ktimer->timer_advance_ns);\n\n\tif (delta_tsc > lapic_timer_advance_cycles)\n\t\tdelta_tsc -= lapic_timer_advance_cycles;\n\telse\n\t\tdelta_tsc = 0;\n\n\t/* Convert to host delta tsc if tsc scaling is enabled */\n\tif (vcpu->arch.l1_tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t    delta_tsc && u64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.l1_tsc_scaling_ratio, &delta_tsc))\n\t\treturn -ERANGE;\n\n\t/*\n\t * If the delta tsc can't fit in the 32 bit after the multi shift,\n\t * we can't use the preemption timer.\n\t * It's possible that it fits on later vmentries, but checking\n\t * on every vmentry is costly so we just use an hrtimer.\n\t */\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\t*expired = !delta_tsc;\n\treturn 0;\n}\n\nstatic void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->hv_deadline_tsc = -1;\n}\n#endif\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tshrink_ple_window(vcpu);\n}\n\nvoid vmx_update_cpu_dirty_logging(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.update_vmcs01_cpu_dirty_logging = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Note, cpu_dirty_logging_count can be changed concurrent with this\n\t * code, but in that case another update request will be made and so\n\t * the guest will never run with a stale PML value.\n\t */\n\tif (vcpu->kvm->arch.cpu_dirty_logging_count)\n\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_ENABLE_PML);\n\telse\n\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_ENABLE_PML);\n}\n\nstatic void vmx_setup_mce(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mcg_cap & MCG_LMCE_P)\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_LMCE_ENABLED;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEAT_CTL_LMCE_ENABLED;\n}\n\nstatic int vmx_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\t/* we need a nested vmexit to enter SMM, postpone if run is pending */\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\treturn !is_smm(vcpu);\n}\n\nstatic int vmx_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx->nested.smm.guest_mode = is_guest_mode(vcpu);\n\tif (vmx->nested.smm.guest_mode)\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\n\tvmx->nested.smm.vmxon = vmx->nested.vmxon;\n\tvmx->nested.vmxon = false;\n\tvmx_clear_hlt(vcpu);\n\treturn 0;\n}\n\nstatic int vmx_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint ret;\n\n\tif (vmx->nested.smm.vmxon) {\n\t\tvmx->nested.vmxon = true;\n\t\tvmx->nested.smm.vmxon = false;\n\t}\n\n\tif (vmx->nested.smm.guest_mode) {\n\t\tret = nested_vmx_enter_non_root_mode(vcpu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvmx->nested.nested_run_pending = 1;\n\t\tvmx->nested.smm.guest_mode = false;\n\t}\n\treturn 0;\n}\n\nstatic void vmx_enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\t/* RSM will cause a vmexit anyway.  */\n}\n\nstatic bool vmx_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.vmxon && !is_guest_mode(vcpu);\n}\n\nstatic void vmx_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct hrtimer *timer = &to_vmx(vcpu)->nested.preemption_timer;\n\n\t\tif (hrtimer_try_to_cancel(timer) == 1)\n\t\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n}\n\nstatic void vmx_hardware_unsetup(void)\n{\n\tkvm_set_posted_intr_wakeup_handler(NULL);\n\n\tif (nested)\n\t\tnested_vmx_hardware_unsetup();\n\n\tfree_kvm_area();\n}\n\nstatic bool vmx_check_apicv_inhibit_reasons(enum kvm_apicv_inhibit reason)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_ABSENT) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_BLOCKIRQ);\n\n\treturn supported & BIT(reason);\n}\n\nstatic struct kvm_x86_ops vmx_x86_ops __initdata = {\n\t.name = \"kvm_intel\",\n\n\t.hardware_unsetup = vmx_hardware_unsetup,\n\n\t.hardware_enable = vmx_hardware_enable,\n\t.hardware_disable = vmx_hardware_disable,\n\t.has_emulated_msr = vmx_has_emulated_msr,\n\n\t.vm_size = sizeof(struct kvm_vmx),\n\t.vm_init = vmx_vm_init,\n\n\t.vcpu_create = vmx_vcpu_create,\n\t.vcpu_free = vmx_vcpu_free,\n\t.vcpu_reset = vmx_vcpu_reset,\n\n\t.prepare_switch_to_guest = vmx_prepare_switch_to_guest,\n\t.vcpu_load = vmx_vcpu_load,\n\t.vcpu_put = vmx_vcpu_put,\n\n\t.update_exception_bitmap = vmx_update_exception_bitmap,\n\t.get_msr_feature = vmx_get_msr_feature,\n\t.get_msr = vmx_get_msr,\n\t.set_msr = vmx_set_msr,\n\t.get_segment_base = vmx_get_segment_base,\n\t.get_segment = vmx_get_segment,\n\t.set_segment = vmx_set_segment,\n\t.get_cpl = vmx_get_cpl,\n\t.get_cs_db_l_bits = vmx_get_cs_db_l_bits,\n\t.set_cr0 = vmx_set_cr0,\n\t.is_valid_cr4 = vmx_is_valid_cr4,\n\t.set_cr4 = vmx_set_cr4,\n\t.set_efer = vmx_set_efer,\n\t.get_idt = vmx_get_idt,\n\t.set_idt = vmx_set_idt,\n\t.get_gdt = vmx_get_gdt,\n\t.set_gdt = vmx_set_gdt,\n\t.set_dr7 = vmx_set_dr7,\n\t.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,\n\t.cache_reg = vmx_cache_reg,\n\t.get_rflags = vmx_get_rflags,\n\t.set_rflags = vmx_set_rflags,\n\t.get_if_flag = vmx_get_if_flag,\n\n\t.flush_tlb_all = vmx_flush_tlb_all,\n\t.flush_tlb_current = vmx_flush_tlb_current,\n\t.flush_tlb_gva = vmx_flush_tlb_gva,\n\t.flush_tlb_guest = vmx_flush_tlb_guest,\n\n\t.vcpu_pre_run = vmx_vcpu_pre_run,\n\t.vcpu_run = vmx_vcpu_run,\n\t.handle_exit = vmx_handle_exit,\n\t.skip_emulated_instruction = vmx_skip_emulated_instruction,\n\t.update_emulated_instruction = vmx_update_emulated_instruction,\n\t.set_interrupt_shadow = vmx_set_interrupt_shadow,\n\t.get_interrupt_shadow = vmx_get_interrupt_shadow,\n\t.patch_hypercall = vmx_patch_hypercall,\n\t.inject_irq = vmx_inject_irq,\n\t.inject_nmi = vmx_inject_nmi,\n\t.queue_exception = vmx_queue_exception,\n\t.cancel_injection = vmx_cancel_injection,\n\t.interrupt_allowed = vmx_interrupt_allowed,\n\t.nmi_allowed = vmx_nmi_allowed,\n\t.get_nmi_mask = vmx_get_nmi_mask,\n\t.set_nmi_mask = vmx_set_nmi_mask,\n\t.enable_nmi_window = vmx_enable_nmi_window,\n\t.enable_irq_window = vmx_enable_irq_window,\n\t.update_cr8_intercept = vmx_update_cr8_intercept,\n\t.set_virtual_apic_mode = vmx_set_virtual_apic_mode,\n\t.set_apic_access_page_addr = vmx_set_apic_access_page_addr,\n\t.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,\n\t.load_eoi_exitmap = vmx_load_eoi_exitmap,\n\t.apicv_post_state_restore = vmx_apicv_post_state_restore,\n\t.check_apicv_inhibit_reasons = vmx_check_apicv_inhibit_reasons,\n\t.hwapic_irr_update = vmx_hwapic_irr_update,\n\t.hwapic_isr_update = vmx_hwapic_isr_update,\n\t.guest_apic_has_interrupt = vmx_guest_apic_has_interrupt,\n\t.sync_pir_to_irr = vmx_sync_pir_to_irr,\n\t.deliver_interrupt = vmx_deliver_interrupt,\n\t.dy_apicv_has_pending_interrupt = pi_has_pending_interrupt,\n\n\t.set_tss_addr = vmx_set_tss_addr,\n\t.set_identity_map_addr = vmx_set_identity_map_addr,\n\t.get_mt_mask = vmx_get_mt_mask,\n\n\t.get_exit_info = vmx_get_exit_info,\n\n\t.vcpu_after_set_cpuid = vmx_vcpu_after_set_cpuid,\n\n\t.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,\n\n\t.get_l2_tsc_offset = vmx_get_l2_tsc_offset,\n\t.get_l2_tsc_multiplier = vmx_get_l2_tsc_multiplier,\n\t.write_tsc_offset = vmx_write_tsc_offset,\n\t.write_tsc_multiplier = vmx_write_tsc_multiplier,\n\n\t.load_mmu_pgd = vmx_load_mmu_pgd,\n\n\t.check_intercept = vmx_check_intercept,\n\t.handle_exit_irqoff = vmx_handle_exit_irqoff,\n\n\t.request_immediate_exit = vmx_request_immediate_exit,\n\n\t.sched_in = vmx_sched_in,\n\n\t.cpu_dirty_log_size = PML_ENTITY_NUM,\n\t.update_cpu_dirty_logging = vmx_update_cpu_dirty_logging,\n\n\t.nested_ops = &vmx_nested_ops,\n\n\t.pi_update_irte = vmx_pi_update_irte,\n\t.pi_start_assignment = vmx_pi_start_assignment,\n\n#ifdef CONFIG_X86_64\n\t.set_hv_timer = vmx_set_hv_timer,\n\t.cancel_hv_timer = vmx_cancel_hv_timer,\n#endif\n\n\t.setup_mce = vmx_setup_mce,\n\n\t.smi_allowed = vmx_smi_allowed,\n\t.enter_smm = vmx_enter_smm,\n\t.leave_smm = vmx_leave_smm,\n\t.enable_smi_window = vmx_enable_smi_window,\n\n\t.can_emulate_instruction = vmx_can_emulate_instruction,\n\t.apic_init_signal_blocked = vmx_apic_init_signal_blocked,\n\t.migrate_timers = vmx_migrate_timers,\n\n\t.msr_filter_changed = vmx_msr_filter_changed,\n\t.complete_emulated_msr = kvm_complete_insn_gp,\n\n\t.vcpu_deliver_sipi_vector = kvm_vcpu_deliver_sipi_vector,\n};\n\nstatic unsigned int vmx_handle_intel_pt_intr(void)\n{\n\tstruct kvm_vcpu *vcpu = kvm_get_running_vcpu();\n\n\t/* '0' on failure so that the !PT case can use a RET0 static call. */\n\tif (!vcpu || !kvm_handling_nmi_from_guest(vcpu))\n\t\treturn 0;\n\n\tkvm_make_request(KVM_REQ_PMI, vcpu);\n\t__set_bit(MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI_BIT,\n\t\t  (unsigned long *)&vcpu->arch.pmu.global_status);\n\treturn 1;\n}\n\nstatic __init void vmx_setup_user_return_msrs(void)\n{\n\n\t/*\n\t * Though SYSCALL is only supported in 64-bit mode on Intel CPUs, kvm\n\t * will emulate SYSCALL in legacy mode if the vendor string in guest\n\t * CPUID.0:{EBX,ECX,EDX} is \"AuthenticAMD\" or \"AMDisbetter!\" To\n\t * support this emulation, MSR_STAR is included in the list for i386,\n\t * but is never loaded into hardware.  MSR_CSTAR is also never loaded\n\t * into hardware and is here purely for emulation purposes.\n\t */\n\tconst u32 vmx_uret_msrs_list[] = {\n\t#ifdef CONFIG_X86_64\n\t\tMSR_SYSCALL_MASK, MSR_LSTAR, MSR_CSTAR,\n\t#endif\n\t\tMSR_EFER, MSR_TSC_AUX, MSR_STAR,\n\t\tMSR_IA32_TSX_CTRL,\n\t};\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_uret_msrs_list) != MAX_NR_USER_RETURN_MSRS);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_uret_msrs_list); ++i)\n\t\tkvm_add_user_return_msr(vmx_uret_msrs_list[i]);\n}\n\nstatic void __init vmx_setup_me_spte_mask(void)\n{\n\tu64 me_mask = 0;\n\n\t/*\n\t * kvm_get_shadow_phys_bits() returns shadow_phys_bits.  Use\n\t * the former to avoid exposing shadow_phys_bits.\n\t *\n\t * On pre-MKTME system, boot_cpu_data.x86_phys_bits equals to\n\t * shadow_phys_bits.  On MKTME and/or TDX capable systems,\n\t * boot_cpu_data.x86_phys_bits holds the actual physical address\n\t * w/o the KeyID bits, and shadow_phys_bits equals to MAXPHYADDR\n\t * reported by CPUID.  Those bits between are KeyID bits.\n\t */\n\tif (boot_cpu_data.x86_phys_bits != kvm_get_shadow_phys_bits())\n\t\tme_mask = rsvd_bits(boot_cpu_data.x86_phys_bits,\n\t\t\tkvm_get_shadow_phys_bits() - 1);\n\t/*\n\t * Unlike SME, host kernel doesn't support setting up any\n\t * MKTME KeyID on Intel platforms.  No memory encryption\n\t * bits should be included into the SPTE.\n\t */\n\tkvm_mmu_set_me_spte_mask(0, me_mask);\n}\n\nstatic struct kvm_x86_init_ops vmx_init_ops __initdata;\n\nstatic __init int hardware_setup(void)\n{\n\tunsigned long host_bndcfgs;\n\tstruct desc_ptr dt;\n\tint r;\n\n\tstore_idt(&dt);\n\thost_idt_base = dt.address;\n\n\tvmx_setup_user_return_msrs();\n\n\tif (setup_vmcs_config(&vmcs_config, &vmx_capability) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_MPX)) {\n\t\trdmsrl(MSR_IA32_BNDCFGS, host_bndcfgs);\n\t\tWARN_ONCE(host_bndcfgs, \"KVM: BNDCFGS in host will be lost\");\n\t}\n\n\tif (!cpu_has_vmx_mpx())\n\t\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS |\n\t\t\t\t    XFEATURE_MASK_BNDCSR);\n\n\tif (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||\n\t    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))\n\t\tenable_vpid = 0;\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels() ||\n\t    !cpu_has_vmx_ept_mt_wb() ||\n\t    !cpu_has_vmx_invept_global())\n\t\tenable_ept = 0;\n\n\t/* NX support is required for shadow paging. */\n\tif (!enable_ept && !boot_cpu_has(X86_FEATURE_NX)) {\n\t\tpr_err_ratelimited(\"kvm: NX (Execute Disable) not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!cpu_has_vmx_ept_ad_bits() || !enable_ept)\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest() || !enable_ept)\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\tif (!cpu_has_virtual_nmis())\n\t\tenable_vnmi = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tvmx_x86_ops.set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tvmx_x86_ops.update_cr8_intercept = NULL;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (ms_hyperv.nested_features & HV_X64_NESTED_GUEST_MAPPING_FLUSH\n\t    && enable_ept) {\n\t\tvmx_x86_ops.tlb_remote_flush = hv_remote_flush_tlb;\n\t\tvmx_x86_ops.tlb_remote_flush_with_range =\n\t\t\t\thv_remote_flush_tlb_with_range;\n\t}\n#endif\n\n\tif (!cpu_has_vmx_ple()) {\n\t\tple_gap = 0;\n\t\tple_window = 0;\n\t\tple_window_grow = 0;\n\t\tple_window_max = 0;\n\t\tple_window_shrink = 0;\n\t}\n\n\tif (!cpu_has_vmx_apicv())\n\t\tenable_apicv = 0;\n\tif (!enable_apicv)\n\t\tvmx_x86_ops.sync_pir_to_irr = NULL;\n\n\tif (cpu_has_vmx_tsc_scaling())\n\t\tkvm_has_tsc_control = true;\n\n\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\tkvm_has_bus_lock_exit = cpu_has_vmx_bus_lock_detection();\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tif (enable_ept)\n\t\tkvm_mmu_set_ept_masks(enable_ept_ad_bits,\n\t\t\t\t      cpu_has_vmx_ept_execute_only());\n\n\t/*\n\t * Setup shadow_me_value/shadow_me_mask to include MKTME KeyID\n\t * bits to shadow_zero_check.\n\t */\n\tvmx_setup_me_spte_mask();\n\n\tkvm_configure_mmu(enable_ept, 0, vmx_get_max_tdp_level(),\n\t\t\t  ept_caps_to_lpage_level(vmx_capability.ept));\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml)\n\t\tvmx_x86_ops.cpu_dirty_log_size = 0;\n\n\tif (!cpu_has_vmx_preemption_timer())\n\t\tenable_preemption_timer = false;\n\n\tif (enable_preemption_timer) {\n\t\tu64 use_timer_freq = 5000ULL * 1000 * 1000;\n\t\tu64 vmx_msr;\n\n\t\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t\tcpu_preemption_timer_multi =\n\t\t\tvmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;\n\n\t\tif (tsc_khz)\n\t\t\tuse_timer_freq = (u64)tsc_khz * 1000;\n\t\tuse_timer_freq >>= cpu_preemption_timer_multi;\n\n\t\t/*\n\t\t * KVM \"disables\" the preemption timer by setting it to its max\n\t\t * value.  Don't use the timer if it might cause spurious exits\n\t\t * at a rate faster than 0.1 Hz (of uninterrupted guest time).\n\t\t */\n\t\tif (use_timer_freq > 0xffffffffu / 10)\n\t\t\tenable_preemption_timer = false;\n\t}\n\n\tif (!enable_preemption_timer) {\n\t\tvmx_x86_ops.set_hv_timer = NULL;\n\t\tvmx_x86_ops.cancel_hv_timer = NULL;\n\t\tvmx_x86_ops.request_immediate_exit = __kvm_request_immediate_exit;\n\t}\n\n\tkvm_mce_cap_supported |= MCG_LMCE_P;\n\n\tif (pt_mode != PT_MODE_SYSTEM && pt_mode != PT_MODE_HOST_GUEST)\n\t\treturn -EINVAL;\n\tif (!enable_ept || !cpu_has_vmx_intel_pt())\n\t\tpt_mode = PT_MODE_SYSTEM;\n\tif (pt_mode == PT_MODE_HOST_GUEST)\n\t\tvmx_init_ops.handle_intel_pt_intr = vmx_handle_intel_pt_intr;\n\telse\n\t\tvmx_init_ops.handle_intel_pt_intr = NULL;\n\n\tsetup_default_sgx_lepubkeyhash();\n\n\tif (nested) {\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_config.nested,\n\t\t\t\t\t   vmx_capability.ept);\n\n\t\tr = nested_vmx_hardware_setup(kvm_vmx_exit_handlers);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tvmx_set_cpu_caps();\n\n\tr = alloc_kvm_area();\n\tif (r && nested)\n\t\tnested_vmx_hardware_unsetup();\n\n\tkvm_set_posted_intr_wakeup_handler(pi_wakeup_handler);\n\n\treturn r;\n}\n\nstatic struct kvm_x86_init_ops vmx_init_ops __initdata = {\n\t.cpu_has_kvm_support = cpu_has_kvm_support,\n\t.disabled_by_bios = vmx_disabled_by_bios,\n\t.check_processor_compatibility = vmx_check_processor_compat,\n\t.hardware_setup = hardware_setup,\n\t.handle_intel_pt_intr = NULL,\n\n\t.runtime_ops = &vmx_x86_ops,\n\t.pmu_ops = &intel_pmu_ops,\n};\n\nstatic void vmx_cleanup_l1d_flush(void)\n{\n\tif (vmx_l1d_flush_pages) {\n\t\tfree_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);\n\t\tvmx_l1d_flush_pages = NULL;\n\t}\n\t/* Restore state so sysfs ignores VMX */\n\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;\n}\n\nstatic void vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tint cpu;\n\t\tstruct hv_vp_assist_page *vp_ap;\n\t\t/*\n\t\t * Reset everything to support using non-enlightened VMCS\n\t\t * access later (e.g. when we reload the module with\n\t\t * enlightened_vmcs=0)\n\t\t */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tvp_ap =\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 0;\n\t\t\tvp_ap->current_nested_vmcs = 0;\n\t\t\tvp_ap->enlighten_vmentry = 0;\n\t\t}\n\n\t\tstatic_branch_disable(&enable_evmcs);\n\t}\n#endif\n\tvmx_cleanup_l1d_flush();\n\n\tallow_smaller_maxphyaddr = false;\n}\nmodule_exit(vmx_exit);\n\nstatic int __init vmx_init(void)\n{\n\tint r, cpu;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\t/*\n\t * Enlightened VMCS usage should be recommended and the host needs\n\t * to support eVMCS v1 or above. We can also disable eVMCS support\n\t * with module parameter.\n\t */\n\tif (enlightened_vmcs &&\n\t    ms_hyperv.hints & HV_X64_ENLIGHTENED_VMCS_RECOMMENDED &&\n\t    (ms_hyperv.nested_features & HV_X64_ENLIGHTENED_VMCS_VERSION) >=\n\t    KVM_EVMCS_VERSION) {\n\n\t\t/* Check that we have assist pages on all online CPUs */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tif (!hv_get_vp_assist_page(cpu)) {\n\t\t\t\tenlightened_vmcs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (enlightened_vmcs) {\n\t\t\tpr_info(\"KVM: vmx: using Hyper-V Enlightened VMCS\\n\");\n\t\t\tstatic_branch_enable(&enable_evmcs);\n\t\t}\n\n\t\tif (ms_hyperv.nested_features & HV_X64_NESTED_DIRECT_FLUSH)\n\t\t\tvmx_x86_ops.enable_direct_tlbflush\n\t\t\t\t= hv_enable_direct_tlbflush;\n\n\t} else {\n\t\tenlightened_vmcs = false;\n\t}\n#endif\n\n\tr = kvm_init(&vmx_init_ops, sizeof(struct vcpu_vmx),\n\t\t     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Must be called after kvm_init() so enable_ept is properly set\n\t * up. Hand the parameter mitigation value in which was stored in\n\t * the pre module init parser. If no parameter was given, it will\n\t * contain 'auto' which will be turned into the default 'cond'\n\t * mitigation mode.\n\t */\n\tr = vmx_setup_l1d_flush(vmentry_l1d_flush_param);\n\tif (r) {\n\t\tvmx_exit();\n\t\treturn r;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\n\t\tpi_init_cpu(cpu);\n\t}\n\n#ifdef CONFIG_KEXEC_CORE\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\tvmx_check_vmcs12_offsets();\n\n\t/*\n\t * Shadow paging doesn't have a (further) performance penalty\n\t * from GUEST_MAXPHYADDR < HOST_MAXPHYADDR so enable it\n\t * by default\n\t */\n\tif (!enable_ept)\n\t\tallow_smaller_maxphyaddr = true;\n\n\treturn 0;\n}\nmodule_init(vmx_init);\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Kernel-based Virtual Machine driver for Linux\n *\n * derived from drivers/kvm/kvm_main.c\n *\n * Copyright (C) 2006 Qumranet, Inc.\n * Copyright (C) 2008 Qumranet, Inc.\n * Copyright IBM Corporation, 2008\n * Copyright 2010 Red Hat, Inc. and/or its affiliates.\n *\n * Authors:\n *   Avi Kivity   <avi@qumranet.com>\n *   Yaniv Kamay  <yaniv@qumranet.com>\n *   Amit Shah    <amit.shah@qumranet.com>\n *   Ben-Ami Yassour <benami@il.ibm.com>\n */\n\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include \"mmu.h\"\n#include \"i8254.h\"\n#include \"tss.h\"\n#include \"kvm_cache_regs.h\"\n#include \"kvm_emulate.h\"\n#include \"x86.h\"\n#include \"cpuid.h\"\n#include \"pmu.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"xen.h\"\n\n#include <linux/clocksource.h>\n#include <linux/interrupt.h>\n#include <linux/kvm.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/mman.h>\n#include <linux/highmem.h>\n#include <linux/iommu.h>\n#include <linux/intel-iommu.h>\n#include <linux/cpufreq.h>\n#include <linux/user-return-notifier.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/perf_event.h>\n#include <linux/uaccess.h>\n#include <linux/hash.h>\n#include <linux/pci.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/irqbypass.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/isolation.h>\n#include <linux/mem_encrypt.h>\n#include <linux/entry-kvm.h>\n#include <linux/suspend.h>\n\n#include <trace/events/kvm.h>\n\n#include <asm/debugreg.h>\n#include <asm/msr.h>\n#include <asm/desc.h>\n#include <asm/mce.h>\n#include <asm/pkru.h>\n#include <linux/kernel_stat.h>\n#include <asm/fpu/api.h>\n#include <asm/fpu/xcr.h>\n#include <asm/fpu/xstate.h>\n#include <asm/pvclock.h>\n#include <asm/div64.h>\n#include <asm/irq_remapping.h>\n#include <asm/mshyperv.h>\n#include <asm/hypervisor.h>\n#include <asm/tlbflush.h>\n#include <asm/intel_pt.h>\n#include <asm/emulate_prefix.h>\n#include <asm/sgx.h>\n#include <clocksource/hyperv_timer.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\n#define MAX_IO_MSRS 256\n#define KVM_MAX_MCE_BANKS 32\nu64 __read_mostly kvm_mce_cap_supported = MCG_CTL_P | MCG_SER_P;\nEXPORT_SYMBOL_GPL(kvm_mce_cap_supported);\n\n#define  ERR_PTR_USR(e)  ((void __user *)ERR_PTR(e))\n\n#define emul_to_vcpu(ctxt) \\\n\t((struct kvm_vcpu *)(ctxt)->vcpu)\n\n/* EFER defaults:\n * - enable syscall per default because its emulated by KVM\n * - enable LME and LMA per default on 64 bit KVM\n */\n#ifdef CONFIG_X86_64\nstatic\nu64 __read_mostly efer_reserved_bits = ~((u64)(EFER_SCE | EFER_LME | EFER_LMA));\n#else\nstatic u64 __read_mostly efer_reserved_bits = ~((u64)EFER_SCE);\n#endif\n\nstatic u64 __read_mostly cr4_reserved_bits = CR4_RESERVED_BITS;\n\n#define KVM_EXIT_HYPERCALL_VALID_MASK (1 << KVM_HC_MAP_GPA_RANGE)\n\n#define KVM_CAP_PMU_VALID_MASK KVM_PMU_CAP_DISABLE\n\n#define KVM_X2APIC_API_VALID_FLAGS (KVM_X2APIC_API_USE_32BIT_IDS | \\\n                                    KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void process_smi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu);\n\nstatic int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);\nstatic void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2);\n\nstruct kvm_x86_ops kvm_x86_ops __read_mostly;\n\n#define KVM_X86_OP(func)\t\t\t\t\t     \\\n\tDEFINE_STATIC_CALL_NULL(kvm_x86_##func,\t\t\t     \\\n\t\t\t\t*(((struct kvm_x86_ops *)0)->func));\n#define KVM_X86_OP_OPTIONAL KVM_X86_OP\n#define KVM_X86_OP_OPTIONAL_RET0 KVM_X86_OP\n#include <asm/kvm-x86-ops.h>\nEXPORT_STATIC_CALL_GPL(kvm_x86_get_cs_db_l_bits);\nEXPORT_STATIC_CALL_GPL(kvm_x86_cache_reg);\n\nstatic bool __read_mostly ignore_msrs = 0;\nmodule_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);\n\nbool __read_mostly report_ignored_msrs = true;\nmodule_param(report_ignored_msrs, bool, S_IRUGO | S_IWUSR);\nEXPORT_SYMBOL_GPL(report_ignored_msrs);\n\nunsigned int min_timer_period_us = 200;\nmodule_param(min_timer_period_us, uint, S_IRUGO | S_IWUSR);\n\nstatic bool __read_mostly kvmclock_periodic_sync = true;\nmodule_param(kvmclock_periodic_sync, bool, S_IRUGO);\n\nbool __read_mostly kvm_has_tsc_control;\nEXPORT_SYMBOL_GPL(kvm_has_tsc_control);\nu32  __read_mostly kvm_max_guest_tsc_khz;\nEXPORT_SYMBOL_GPL(kvm_max_guest_tsc_khz);\nu8   __read_mostly kvm_tsc_scaling_ratio_frac_bits;\nEXPORT_SYMBOL_GPL(kvm_tsc_scaling_ratio_frac_bits);\nu64  __read_mostly kvm_max_tsc_scaling_ratio;\nEXPORT_SYMBOL_GPL(kvm_max_tsc_scaling_ratio);\nu64 __read_mostly kvm_default_tsc_scaling_ratio;\nEXPORT_SYMBOL_GPL(kvm_default_tsc_scaling_ratio);\nbool __read_mostly kvm_has_bus_lock_exit;\nEXPORT_SYMBOL_GPL(kvm_has_bus_lock_exit);\n\n/* tsc tolerance in parts per million - default to 1/2 of the NTP threshold */\nstatic u32 __read_mostly tsc_tolerance_ppm = 250;\nmodule_param(tsc_tolerance_ppm, uint, S_IRUGO | S_IWUSR);\n\n/*\n * lapic timer advance (tscdeadline mode only) in nanoseconds.  '-1' enables\n * adaptive tuning starting from default advancement of 1000ns.  '0' disables\n * advancement entirely.  Any other value is used as-is and disables adaptive\n * tuning, i.e. allows privileged userspace to set an exact advancement time.\n */\nstatic int __read_mostly lapic_timer_advance_ns = -1;\nmodule_param(lapic_timer_advance_ns, int, S_IRUGO | S_IWUSR);\n\nstatic bool __read_mostly vector_hashing = true;\nmodule_param(vector_hashing, bool, S_IRUGO);\n\nbool __read_mostly enable_vmware_backdoor = false;\nmodule_param(enable_vmware_backdoor, bool, S_IRUGO);\nEXPORT_SYMBOL_GPL(enable_vmware_backdoor);\n\nstatic bool __read_mostly force_emulation_prefix = false;\nmodule_param(force_emulation_prefix, bool, S_IRUGO);\n\nint __read_mostly pi_inject_timer = -1;\nmodule_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);\n\n/* Enable/disable PMU virtualization */\nbool __read_mostly enable_pmu = true;\nEXPORT_SYMBOL_GPL(enable_pmu);\nmodule_param(enable_pmu, bool, 0444);\n\nbool __read_mostly eager_page_split = true;\nmodule_param(eager_page_split, bool, 0644);\n\n/*\n * Restoring the host value for MSRs that are only consumed when running in\n * usermode, e.g. SYSCALL MSRs and TSC_AUX, can be deferred until the CPU\n * returns to userspace, i.e. the kernel can run with the guest's value.\n */\n#define KVM_MAX_NR_USER_RETURN_MSRS 16\n\nstruct kvm_user_return_msrs {\n\tstruct user_return_notifier urn;\n\tbool registered;\n\tstruct kvm_user_return_msr_values {\n\t\tu64 host;\n\t\tu64 curr;\n\t} values[KVM_MAX_NR_USER_RETURN_MSRS];\n};\n\nu32 __read_mostly kvm_nr_uret_msrs;\nEXPORT_SYMBOL_GPL(kvm_nr_uret_msrs);\nstatic u32 __read_mostly kvm_uret_msrs_list[KVM_MAX_NR_USER_RETURN_MSRS];\nstatic struct kvm_user_return_msrs __percpu *user_return_msrs;\n\n#define KVM_SUPPORTED_XCR0     (XFEATURE_MASK_FP | XFEATURE_MASK_SSE \\\n\t\t\t\t| XFEATURE_MASK_YMM | XFEATURE_MASK_BNDREGS \\\n\t\t\t\t| XFEATURE_MASK_BNDCSR | XFEATURE_MASK_AVX512 \\\n\t\t\t\t| XFEATURE_MASK_PKRU | XFEATURE_MASK_XTILE)\n\nu64 __read_mostly host_efer;\nEXPORT_SYMBOL_GPL(host_efer);\n\nbool __read_mostly allow_smaller_maxphyaddr = 0;\nEXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);\n\nbool __read_mostly enable_apicv = true;\nEXPORT_SYMBOL_GPL(enable_apicv);\n\nu64 __read_mostly host_xss;\nEXPORT_SYMBOL_GPL(host_xss);\nu64 __read_mostly supported_xss;\nEXPORT_SYMBOL_GPL(supported_xss);\n\nconst struct _kvm_stats_desc kvm_vm_stats_desc[] = {\n\tKVM_GENERIC_VM_STATS(),\n\tSTATS_DESC_COUNTER(VM, mmu_shadow_zapped),\n\tSTATS_DESC_COUNTER(VM, mmu_pte_write),\n\tSTATS_DESC_COUNTER(VM, mmu_pde_zapped),\n\tSTATS_DESC_COUNTER(VM, mmu_flooded),\n\tSTATS_DESC_COUNTER(VM, mmu_recycled),\n\tSTATS_DESC_COUNTER(VM, mmu_cache_miss),\n\tSTATS_DESC_ICOUNTER(VM, mmu_unsync),\n\tSTATS_DESC_ICOUNTER(VM, pages_4k),\n\tSTATS_DESC_ICOUNTER(VM, pages_2m),\n\tSTATS_DESC_ICOUNTER(VM, pages_1g),\n\tSTATS_DESC_ICOUNTER(VM, nx_lpage_splits),\n\tSTATS_DESC_PCOUNTER(VM, max_mmu_rmap_size),\n\tSTATS_DESC_PCOUNTER(VM, max_mmu_page_hash_collisions)\n};\n\nconst struct kvm_stats_header kvm_vm_stats_header = {\n\t.name_size = KVM_STATS_NAME_SIZE,\n\t.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),\n\t.id_offset = sizeof(struct kvm_stats_header),\n\t.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,\n\t.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +\n\t\t       sizeof(kvm_vm_stats_desc),\n};\n\nconst struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {\n\tKVM_GENERIC_VCPU_STATS(),\n\tSTATS_DESC_COUNTER(VCPU, pf_taken),\n\tSTATS_DESC_COUNTER(VCPU, pf_fixed),\n\tSTATS_DESC_COUNTER(VCPU, pf_emulate),\n\tSTATS_DESC_COUNTER(VCPU, pf_spurious),\n\tSTATS_DESC_COUNTER(VCPU, pf_fast),\n\tSTATS_DESC_COUNTER(VCPU, pf_mmio_spte_created),\n\tSTATS_DESC_COUNTER(VCPU, pf_guest),\n\tSTATS_DESC_COUNTER(VCPU, tlb_flush),\n\tSTATS_DESC_COUNTER(VCPU, invlpg),\n\tSTATS_DESC_COUNTER(VCPU, exits),\n\tSTATS_DESC_COUNTER(VCPU, io_exits),\n\tSTATS_DESC_COUNTER(VCPU, mmio_exits),\n\tSTATS_DESC_COUNTER(VCPU, signal_exits),\n\tSTATS_DESC_COUNTER(VCPU, irq_window_exits),\n\tSTATS_DESC_COUNTER(VCPU, nmi_window_exits),\n\tSTATS_DESC_COUNTER(VCPU, l1d_flush),\n\tSTATS_DESC_COUNTER(VCPU, halt_exits),\n\tSTATS_DESC_COUNTER(VCPU, request_irq_exits),\n\tSTATS_DESC_COUNTER(VCPU, irq_exits),\n\tSTATS_DESC_COUNTER(VCPU, host_state_reload),\n\tSTATS_DESC_COUNTER(VCPU, fpu_reload),\n\tSTATS_DESC_COUNTER(VCPU, insn_emulation),\n\tSTATS_DESC_COUNTER(VCPU, insn_emulation_fail),\n\tSTATS_DESC_COUNTER(VCPU, hypercalls),\n\tSTATS_DESC_COUNTER(VCPU, irq_injections),\n\tSTATS_DESC_COUNTER(VCPU, nmi_injections),\n\tSTATS_DESC_COUNTER(VCPU, req_event),\n\tSTATS_DESC_COUNTER(VCPU, nested_run),\n\tSTATS_DESC_COUNTER(VCPU, directed_yield_attempted),\n\tSTATS_DESC_COUNTER(VCPU, directed_yield_successful),\n\tSTATS_DESC_COUNTER(VCPU, preemption_reported),\n\tSTATS_DESC_COUNTER(VCPU, preemption_other),\n\tSTATS_DESC_ICOUNTER(VCPU, guest_mode)\n};\n\nconst struct kvm_stats_header kvm_vcpu_stats_header = {\n\t.name_size = KVM_STATS_NAME_SIZE,\n\t.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),\n\t.id_offset = sizeof(struct kvm_stats_header),\n\t.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,\n\t.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +\n\t\t       sizeof(kvm_vcpu_stats_desc),\n};\n\nu64 __read_mostly host_xcr0;\nu64 __read_mostly supported_xcr0;\nEXPORT_SYMBOL_GPL(supported_xcr0);\n\nstatic struct kmem_cache *x86_emulator_cache;\n\n/*\n * When called, it means the previous get/set msr reached an invalid msr.\n * Return true if we want to ignore/silent this failed msr access.\n */\nstatic bool kvm_msr_ignored_check(u32 msr, u64 data, bool write)\n{\n\tconst char *op = write ? \"wrmsr\" : \"rdmsr\";\n\n\tif (ignore_msrs) {\n\t\tif (report_ignored_msrs)\n\t\t\tkvm_pr_unimpl(\"ignored %s: 0x%x data 0x%llx\\n\",\n\t\t\t\t      op, msr, data);\n\t\t/* Mask the error */\n\t\treturn true;\n\t} else {\n\t\tkvm_debug_ratelimited(\"unhandled %s: 0x%x data 0x%llx\\n\",\n\t\t\t\t      op, msr, data);\n\t\treturn false;\n\t}\n}\n\nstatic struct kmem_cache *kvm_alloc_emulator_cache(void)\n{\n\tunsigned int useroffset = offsetof(struct x86_emulate_ctxt, src);\n\tunsigned int size = sizeof(struct x86_emulate_ctxt);\n\n\treturn kmem_cache_create_usercopy(\"x86_emulator\", size,\n\t\t\t\t\t  __alignof__(struct x86_emulate_ctxt),\n\t\t\t\t\t  SLAB_ACCOUNT, useroffset,\n\t\t\t\t\t  size - useroffset, NULL);\n}\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nstatic inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < ASYNC_PF_PER_VCPU; i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}\n\nstatic void kvm_on_user_return(struct user_return_notifier *urn)\n{\n\tunsigned slot;\n\tstruct kvm_user_return_msrs *msrs\n\t\t= container_of(urn, struct kvm_user_return_msrs, urn);\n\tstruct kvm_user_return_msr_values *values;\n\tunsigned long flags;\n\n\t/*\n\t * Disabling irqs at this point since the following code could be\n\t * interrupted and executed through kvm_arch_hardware_disable()\n\t */\n\tlocal_irq_save(flags);\n\tif (msrs->registered) {\n\t\tmsrs->registered = false;\n\t\tuser_return_notifier_unregister(urn);\n\t}\n\tlocal_irq_restore(flags);\n\tfor (slot = 0; slot < kvm_nr_uret_msrs; ++slot) {\n\t\tvalues = &msrs->values[slot];\n\t\tif (values->host != values->curr) {\n\t\t\twrmsrl(kvm_uret_msrs_list[slot], values->host);\n\t\t\tvalues->curr = values->host;\n\t\t}\n\t}\n}\n\nstatic int kvm_probe_user_return_msr(u32 msr)\n{\n\tu64 val;\n\tint ret;\n\n\tpreempt_disable();\n\tret = rdmsrl_safe(msr, &val);\n\tif (ret)\n\t\tgoto out;\n\tret = wrmsrl_safe(msr, val);\nout:\n\tpreempt_enable();\n\treturn ret;\n}\n\nint kvm_add_user_return_msr(u32 msr)\n{\n\tBUG_ON(kvm_nr_uret_msrs >= KVM_MAX_NR_USER_RETURN_MSRS);\n\n\tif (kvm_probe_user_return_msr(msr))\n\t\treturn -1;\n\n\tkvm_uret_msrs_list[kvm_nr_uret_msrs] = msr;\n\treturn kvm_nr_uret_msrs++;\n}\nEXPORT_SYMBOL_GPL(kvm_add_user_return_msr);\n\nint kvm_find_user_return_msr(u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < kvm_nr_uret_msrs; ++i) {\n\t\tif (kvm_uret_msrs_list[i] == msr)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(kvm_find_user_return_msr);\n\nstatic void kvm_user_return_msr_cpu_online(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);\n\tu64 value;\n\tint i;\n\n\tfor (i = 0; i < kvm_nr_uret_msrs; ++i) {\n\t\trdmsrl_safe(kvm_uret_msrs_list[i], &value);\n\t\tmsrs->values[i].host = value;\n\t\tmsrs->values[i].curr = value;\n\t}\n}\n\nint kvm_set_user_return_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);\n\tint err;\n\n\tvalue = (value & mask) | (msrs->values[slot].host & ~mask);\n\tif (value == msrs->values[slot].curr)\n\t\treturn 0;\n\terr = wrmsrl_safe(kvm_uret_msrs_list[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tmsrs->values[slot].curr = value;\n\tif (!msrs->registered) {\n\t\tmsrs->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&msrs->urn);\n\t\tmsrs->registered = true;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_user_return_msr);\n\nstatic void drop_user_return_notifiers(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_user_return_msrs *msrs = per_cpu_ptr(user_return_msrs, cpu);\n\n\tif (msrs->registered)\n\t\tkvm_on_user_return(&msrs->urn);\n}\n\nu64 kvm_get_apic_base(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic_base;\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_base);\n\nenum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_mode(kvm_get_apic_base(vcpu));\n}\nEXPORT_SYMBOL_GPL(kvm_get_apic_mode);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tenum lapic_mode old_mode = kvm_get_apic_mode(vcpu);\n\tenum lapic_mode new_mode = kvm_apic_mode(msr_info->data);\n\tu64 reserved_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu) | 0x2ff |\n\t\t(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);\n\n\tif ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)\n\t\treturn 1;\n\tif (!msr_info->host_initiated) {\n\t\tif (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)\n\t\t\treturn 1;\n\t\tif (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)\n\t\t\treturn 1;\n\t}\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\tkvm_recalculate_apic_map(vcpu->kvm);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_apic_base);\n\n/*\n * Handle a fault on a hardware virtualization (VMX or SVM) instruction.\n *\n * Hardware virtualization extension instructions may fault if a reboot turns\n * off virtualization while processes are running.  Usually after catching the\n * fault we just panic; during reboot instead the instruction is ignored.\n */\nnoinstr void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG_ON(!kvm_rebooting);\n}\nEXPORT_SYMBOL_GPL(kvm_spurious_fault);\n\n#define EXCPT_BENIGN\t\t0\n#define EXCPT_CONTRIBUTORY\t1\n#define EXCPT_PF\t\t2\n\nstatic int exception_class(int vector)\n{\n\tswitch (vector) {\n\tcase PF_VECTOR:\n\t\treturn EXCPT_PF;\n\tcase DE_VECTOR:\n\tcase TS_VECTOR:\n\tcase NP_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\t\treturn EXCPT_CONTRIBUTORY;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn EXCPT_BENIGN;\n}\n\n#define EXCPT_FAULT\t\t0\n#define EXCPT_TRAP\t\t1\n#define EXCPT_ABORT\t\t2\n#define EXCPT_INTERRUPT\t\t3\n\nstatic int exception_type(int vector)\n{\n\tunsigned int mask;\n\n\tif (WARN_ON(vector > 31 || vector == NMI_VECTOR))\n\t\treturn EXCPT_INTERRUPT;\n\n\tmask = 1 << vector;\n\n\t/* #DB is trap, as instruction watchpoints are handled elsewhere */\n\tif (mask & ((1 << DB_VECTOR) | (1 << BP_VECTOR) | (1 << OF_VECTOR)))\n\t\treturn EXCPT_TRAP;\n\n\tif (mask & ((1 << DF_VECTOR) | (1 << MC_VECTOR)))\n\t\treturn EXCPT_ABORT;\n\n\t/* Reserved exceptions will result in fault */\n\treturn EXCPT_FAULT;\n}\n\nvoid kvm_deliver_exception_payload(struct kvm_vcpu *vcpu)\n{\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_payload = vcpu->arch.exception.has_payload;\n\tunsigned long payload = vcpu->arch.exception.payload;\n\n\tif (!has_payload)\n\t\treturn;\n\n\tswitch (nr) {\n\tcase DB_VECTOR:\n\t\t/*\n\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t * remaining contents of the DR6 register are never\n\t\t * cleared by the processor\".\n\t\t */\n\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t/*\n\t\t * In order to reflect the #DB exception payload in guest\n\t\t * dr6, three components need to be considered: active low\n\t\t * bit, FIXED_1 bits and active high bits (e.g. DR6_BD,\n\t\t * DR6_BS and DR6_BT)\n\t\t * DR6_ACTIVE_LOW contains the FIXED_1 and active low bits.\n\t\t * In the target guest dr6:\n\t\t * FIXED_1 bits should always be set.\n\t\t * Active low bits should be cleared if 1-setting in payload.\n\t\t * Active high bits should be set if 1-setting in payload.\n\t\t *\n\t\t * Note, the payload is compatible with the pending debug\n\t\t * exceptions/exit qualification under VMX, that active_low bits\n\t\t * are active high in payload.\n\t\t * So they need to be flipped for DR6.\n\t\t */\n\t\tvcpu->arch.dr6 |= DR6_ACTIVE_LOW;\n\t\tvcpu->arch.dr6 |= payload;\n\t\tvcpu->arch.dr6 ^= payload & DR6_ACTIVE_LOW;\n\n\t\t/*\n\t\t * The #DB payload is defined as compatible with the 'pending\n\t\t * debug exceptions' field under VMX, not DR6. While bit 12 is\n\t\t * defined in the 'pending debug exceptions' field (enabled\n\t\t * breakpoint), it is reserved and must be zero in DR6.\n\t\t */\n\t\tvcpu->arch.dr6 &= ~BIT(12);\n\t\tbreak;\n\tcase PF_VECTOR:\n\t\tvcpu->arch.cr2 = payload;\n\t\tbreak;\n\t}\n\n\tvcpu->arch.exception.has_payload = false;\n\tvcpu->arch.exception.payload = 0;\n}\nEXPORT_SYMBOL_GPL(kvm_deliver_exception_payload);\n\nstatic void kvm_multiple_exception(struct kvm_vcpu *vcpu,\n\t\tunsigned nr, bool has_error, u32 error_code,\n\t        bool has_payload, unsigned long payload, bool reinject)\n{\n\tu32 prev_nr;\n\tint class1, class2;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tif (!vcpu->arch.exception.pending && !vcpu->arch.exception.injected) {\n\tqueue:\n\t\tif (reinject) {\n\t\t\t/*\n\t\t\t * On vmentry, vcpu->arch.exception.pending is only\n\t\t\t * true if an event injection was blocked by\n\t\t\t * nested_run_pending.  In that case, however,\n\t\t\t * vcpu_enter_guest requests an immediate exit,\n\t\t\t * and the guest shouldn't proceed far enough to\n\t\t\t * need reinjection.\n\t\t\t */\n\t\t\tWARN_ON_ONCE(vcpu->arch.exception.pending);\n\t\t\tvcpu->arch.exception.injected = true;\n\t\t\tif (WARN_ON_ONCE(has_payload)) {\n\t\t\t\t/*\n\t\t\t\t * A reinjected event has already\n\t\t\t\t * delivered its payload.\n\t\t\t\t */\n\t\t\t\thas_payload = false;\n\t\t\t\tpayload = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tvcpu->arch.exception.pending = true;\n\t\t\tvcpu->arch.exception.injected = false;\n\t\t}\n\t\tvcpu->arch.exception.has_error_code = has_error;\n\t\tvcpu->arch.exception.nr = nr;\n\t\tvcpu->arch.exception.error_code = error_code;\n\t\tvcpu->arch.exception.has_payload = has_payload;\n\t\tvcpu->arch.exception.payload = payload;\n\t\tif (!is_guest_mode(vcpu))\n\t\t\tkvm_deliver_exception_payload(vcpu);\n\t\treturn;\n\t}\n\n\t/* to check exception */\n\tprev_nr = vcpu->arch.exception.nr;\n\tif (prev_nr == DF_VECTOR) {\n\t\t/* triple fault -> shutdown */\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\treturn;\n\t}\n\tclass1 = exception_class(prev_nr);\n\tclass2 = exception_class(nr);\n\tif ((class1 == EXCPT_CONTRIBUTORY && class2 == EXCPT_CONTRIBUTORY)\n\t\t|| (class1 == EXCPT_PF && class2 != EXCPT_BENIGN)) {\n\t\t/*\n\t\t * Generate double fault per SDM Table 5-5.  Set\n\t\t * exception.pending = true so that the double fault\n\t\t * can trigger a nested vmexit.\n\t\t */\n\t\tvcpu->arch.exception.pending = true;\n\t\tvcpu->arch.exception.injected = false;\n\t\tvcpu->arch.exception.has_error_code = true;\n\t\tvcpu->arch.exception.nr = DF_VECTOR;\n\t\tvcpu->arch.exception.error_code = 0;\n\t\tvcpu->arch.exception.has_payload = false;\n\t\tvcpu->arch.exception.payload = 0;\n\t} else\n\t\t/* replace previous exception with a new one in a hope\n\t\t   that instruction re-execution will regenerate lost\n\t\t   exception */\n\t\tgoto queue;\n}\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception);\n\nvoid kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t   unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_p);\n\nstatic void kvm_queue_exception_e_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\t    u32 error_code, unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code,\n\t\t\t       true, payload, false);\n}\n\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(kvm_complete_insn_gp);\n\nstatic int complete_emulated_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE | EMULTYPE_SKIP |\n\t\t\t\t       EMULTYPE_COMPLETE_USER_EXIT);\n}\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.exception.nested_apf =\n\t\tis_guest_mode(vcpu) && fault->async_page_fault;\n\tif (vcpu->arch.exception.nested_apf) {\n\t\tvcpu->arch.apf.nested_apf_token = fault->address;\n\t\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n\t} else {\n\t\tkvm_queue_exception_e_p(vcpu, PF_VECTOR, fault->error_code,\n\t\t\t\t\tfault->address);\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_inject_page_fault);\n\n/* Returns true if the page fault was immediately morphed into a VM-Exit. */\nbool kvm_inject_emulated_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct x86_exception *fault)\n{\n\tstruct kvm_mmu *fault_mmu;\n\tWARN_ON_ONCE(fault->vector != PF_VECTOR);\n\n\tfault_mmu = fault->nested_page_fault ? vcpu->arch.mmu :\n\t\t\t\t\t       vcpu->arch.walk_mmu;\n\n\t/*\n\t * Invalidate the TLB entry for the faulting address, if it exists,\n\t * else the access will fault indefinitely (and to emulate hardware).\n\t */\n\tif ((fault->error_code & PFERR_PRESENT_MASK) &&\n\t    !(fault->error_code & PFERR_RSVD_MASK))\n\t\tkvm_mmu_invalidate_gva(vcpu, fault_mmu, fault->address,\n\t\t\t\t       fault_mmu->root.hpa);\n\n\t/*\n\t * A workaround for KVM's bad exception handling.  If KVM injected an\n\t * exception into L2, and L2 encountered a #PF while vectoring the\n\t * injected exception, manually check to see if L1 wants to intercept\n\t * #PF, otherwise queuing the #PF will lead to #DF or a lost exception.\n\t * In all other cases, defer the check to nested_ops->check_events(),\n\t * which will correctly handle priority (this does not).  Note, other\n\t * exceptions, e.g. #GP, are theoretically affected, #PF is simply the\n\t * most problematic, e.g. when L0 and L1 are both intercepting #PF for\n\t * shadow paging.\n\t *\n\t * TODO: Rewrite exception handling to track injected and pending\n\t *       (VM-Exit) exceptions separately.\n\t */\n\tif (unlikely(vcpu->arch.exception.injected && is_guest_mode(vcpu)) &&\n\t    kvm_x86_ops.nested_ops->handle_page_fault_workaround(vcpu, fault))\n\t\treturn true;\n\n\tfault_mmu->inject_page_fault(vcpu, fault);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_inject_emulated_page_fault);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_inject_nmi);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}\nEXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);\n}\nEXPORT_SYMBOL_GPL(kvm_requeue_exception_e);\n\n/*\n * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n * a #GP and return false.\n */\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (static_call(kvm_x86_get_cpl)(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_cpl);\n\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(kvm_require_dr);\n\nstatic inline u64 pdptr_rsvd_bits(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.reserved_gpa_bits | rsvd_bits(5, 8) | rsvd_bits(1, 2);\n}\n\n/*\n * Load the pae pdptrs.  Return 1 if they are all valid, 0 otherwise.\n */\nint load_pdptrs(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tgpa_t real_gpa;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\t/*\n\t * If the MMU is nested, CR3 holds an L2 GPA and needs to be translated\n\t * to an L1 GPA.\n\t */\n\treal_gpa = kvm_translate_gpa(vcpu, mmu, gfn_to_gpa(pdpt_gfn),\n\t\t\t\t     PFERR_USER_MASK | PFERR_WRITE_MASK, NULL);\n\tif (real_gpa == UNMAPPED_GVA)\n\t\treturn 0;\n\n\t/* Note the offset, PDPTRs are 32 byte aligned when using PAE paging. */\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa_to_gfn(real_gpa), pdpte,\n\t\t\t\t       cr3 & GENMASK(11, 5), sizeof(pdpte));\n\tif (ret < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif ((pdpte[i] & PT_PRESENT_MASK) &&\n\t\t    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Marking VCPU_EXREG_PDPTR dirty doesn't work for !tdp_enabled.\n\t * Shadow page roots need to be reconstructed instead.\n\t */\n\tif (!tdp_enabled && memcmp(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs)))\n\t\tkvm_mmu_free_roots(vcpu->kvm, mmu, KVM_MMU_ROOT_CURRENT);\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n\tkvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);\n\tvcpu->arch.pdptrs_from_userspace = false;\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(load_pdptrs);\n\nvoid kvm_post_set_cr0(struct kvm_vcpu *vcpu, unsigned long old_cr0, unsigned long cr0)\n{\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\n\t\t/*\n\t\t * Clearing CR0.PG is defined to flush the TLB from the guest's\n\t\t * perspective.\n\t\t */\n\t\tif (!(cr0 & X86_CR0_PG))\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & KVM_MMU_CR0_ROLE_BITS)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n}\nEXPORT_SYMBOL_GPL(kvm_post_set_cr0);\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n#ifdef CONFIG_X86_64\n\tif ((vcpu->arch.efer & EFER_LME) && !is_paging(vcpu) &&\n\t    (cr0 & X86_CR0_PG)) {\n\t\tint cs_db, cs_l;\n\n\t\tif (!is_pae(vcpu))\n\t\t\treturn 1;\n\t\tstatic_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);\n\t\tif (cs_l)\n\t\t\treturn 1;\n\t}\n#endif\n\tif (!(vcpu->arch.efer & EFER_LME) && (cr0 & X86_CR0_PG) &&\n\t    is_pae(vcpu) && ((cr0 ^ old_cr0) & X86_CR0_PDPTR_BITS) &&\n\t    !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif (!(cr0 & X86_CR0_PG) &&\n\t    (is_64_bit_mode(vcpu) || kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)))\n\t\treturn 1;\n\n\tstatic_call(kvm_x86_set_cr0)(vcpu, cr0);\n\n\tkvm_post_set_cr0(vcpu, old_cr0, cr0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr0);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}\nEXPORT_SYMBOL_GPL(kvm_lmsw);\n\nvoid kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);\n\t}\n\n#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    vcpu->arch.pkru != vcpu->arch.host_pkru &&\n\t    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||\n\t     kvm_read_cr4_bits(vcpu, X86_CR4_PKE)))\n\t\twrite_pkru(vcpu->arch.pkru);\n#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */\n}\nEXPORT_SYMBOL_GPL(kvm_load_guest_xsave_state);\n\nvoid kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    ((vcpu->arch.xcr0 & XFEATURE_MASK_PKRU) ||\n\t     kvm_read_cr4_bits(vcpu, X86_CR4_PKE))) {\n\t\tvcpu->arch.pkru = rdpkru();\n\t\tif (vcpu->arch.pkru != vcpu->arch.host_pkru)\n\t\t\twrite_pkru(vcpu->arch.host_pkru);\n\t}\n#endif /* CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS */\n\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, host_xss);\n\t}\n\n}\nEXPORT_SYMBOL_GPL(kvm_load_host_xsave_state);\n\nstatic inline u64 kvm_guest_supported_xcr0(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.guest_fpu.fpstate->user_xfeatures;\n}\n\n#ifdef CONFIG_X86_64\nstatic inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;\n}\n#endif\n\nstatic int __kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tu64 xcr0 = xcr;\n\tu64 old_xcr0 = vcpu->arch.xcr0;\n\tu64 valid_bits;\n\n\t/* Only support XCR_XFEATURE_ENABLED_MASK(xcr0) now  */\n\tif (index != XCR_XFEATURE_ENABLED_MASK)\n\t\treturn 1;\n\tif (!(xcr0 & XFEATURE_MASK_FP))\n\t\treturn 1;\n\tif ((xcr0 & XFEATURE_MASK_YMM) && !(xcr0 & XFEATURE_MASK_SSE))\n\t\treturn 1;\n\n\t/*\n\t * Do not allow the guest to set bits that we do not support\n\t * saving.  However, xcr0 bit 0 is always set, even if the\n\t * emulated CPU does not support XSAVE (see kvm_vcpu_reset()).\n\t */\n\tvalid_bits = kvm_guest_supported_xcr0(vcpu) | XFEATURE_MASK_FP;\n\tif (xcr0 & ~valid_bits)\n\t\treturn 1;\n\n\tif ((!(xcr0 & XFEATURE_MASK_BNDREGS)) !=\n\t    (!(xcr0 & XFEATURE_MASK_BNDCSR)))\n\t\treturn 1;\n\n\tif (xcr0 & XFEATURE_MASK_AVX512) {\n\t\tif (!(xcr0 & XFEATURE_MASK_YMM))\n\t\t\treturn 1;\n\t\tif ((xcr0 & XFEATURE_MASK_AVX512) != XFEATURE_MASK_AVX512)\n\t\t\treturn 1;\n\t}\n\n\tif ((xcr0 & XFEATURE_MASK_XTILE) &&\n\t    ((xcr0 & XFEATURE_MASK_XTILE) != XFEATURE_MASK_XTILE))\n\t\treturn 1;\n\n\tvcpu->arch.xcr0 = xcr0;\n\n\tif ((xcr0 ^ old_xcr0) & XFEATURE_MASK_EXTEND)\n\t\tkvm_update_cpuid_runtime(vcpu);\n\treturn 0;\n}\n\nint kvm_emulate_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tif (static_call(kvm_x86_get_cpl)(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, kvm_rcx_read(vcpu), kvm_read_edx_eax(vcpu))) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_xsetbv);\n\nbool kvm_is_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tif (cr4 & cr4_reserved_bits)\n\t\treturn false;\n\n\tif (cr4 & vcpu->arch.cr4_guest_rsvd_bits)\n\t\treturn false;\n\n\treturn static_call(kvm_x86_is_valid_cr4)(vcpu, cr4);\n}\nEXPORT_SYMBOL_GPL(kvm_is_valid_cr4);\n\nvoid kvm_post_set_cr4(struct kvm_vcpu *vcpu, unsigned long old_cr4, unsigned long cr4)\n{\n\tif ((cr4 ^ old_cr4) & KVM_MMU_CR4_ROLE_BITS)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\t/*\n\t * If CR4.PCIDE is changed 0 -> 1, there is no need to flush the TLB\n\t * according to the SDM; however, stale prev_roots could be reused\n\t * incorrectly in the future after a MOV to CR3 with NOFLUSH=1, so we\n\t * free them all.  This is *not* a superset of KVM_REQ_TLB_FLUSH_GUEST\n\t * or KVM_REQ_TLB_FLUSH_CURRENT, because the hardware TLB is not flushed,\n\t * so fall through.\n\t */\n\tif (!tdp_enabled &&\n\t    (cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE))\n\t\tkvm_mmu_unload(vcpu);\n\n\t/*\n\t * The TLB has to be flushed for all PCIDs if any of the following\n\t * (architecturally required) changes happen:\n\t * - CR4.PCIDE is changed from 1 to 0\n\t * - CR4.PGE is toggled\n\t *\n\t * This is a superset of KVM_REQ_TLB_FLUSH_CURRENT.\n\t */\n\tif (((cr4 ^ old_cr4) & X86_CR4_PGE) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\n\t/*\n\t * The TLB has to be flushed for the current PCID if any of the\n\t * following (architecturally required) changes happen:\n\t * - CR4.SMEP is changed from 0 to 1\n\t * - CR4.PAE is toggled\n\t */\n\telse if (((cr4 ^ old_cr4) & X86_CR4_PAE) ||\n\t\t ((cr4 & X86_CR4_SMEP) && !(old_cr4 & X86_CR4_SMEP)))\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\n}\nEXPORT_SYMBOL_GPL(kvm_post_set_cr4);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\n\tif (!kvm_is_valid_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t\tif ((cr4 ^ old_cr4) & X86_CR4_LA57)\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & X86_CR4_PDPTR_BITS)\n\t\t   && !load_pdptrs(vcpu, kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tstatic_call(kvm_x86_set_cr4)(vcpu, cr4);\n\n\tkvm_post_set_cr4(vcpu, old_cr4, cr4);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr4);\n\nstatic void kvm_invalidate_pcid(struct kvm_vcpu *vcpu, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tunsigned long roots_to_free = 0;\n\tint i;\n\n\t/*\n\t * MOV CR3 and INVPCID are usually not intercepted when using TDP, but\n\t * this is reachable when running EPT=1 and unrestricted_guest=0,  and\n\t * also via the emulator.  KVM's TDP page tables are not in the scope of\n\t * the invalidation, but the guest's TLB entries need to be flushed as\n\t * the CPU may have cached entries in its TLB for the target PCID.\n\t */\n\tif (unlikely(tdp_enabled)) {\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * If neither the current CR3 nor any of the prev_roots use the given\n\t * PCID, then nothing needs to be done here because a resync will\n\t * happen anyway before switching to any other CR3.\n\t */\n\tif (kvm_get_active_pcid(vcpu) == pcid) {\n\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\t}\n\n\t/*\n\t * If PCID is disabled, there is no need to free prev_roots even if the\n\t * PCIDs for them are also 0, because MOV to CR3 always flushes the TLB\n\t * with PCIDE=0.\n\t */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn;\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd) == pcid)\n\t\t\troots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);\n\n\tkvm_mmu_free_roots(vcpu->kvm, mmu, roots_to_free);\n}\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tbool skip_tlb_flush = false;\n\tunsigned long pcid = 0;\n#ifdef CONFIG_X86_64\n\tbool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tif (pcid_enabled) {\n\t\tskip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;\n\t\tcr3 &= ~X86_CR3_PCID_NOFLUSH;\n\t\tpcid = cr3 & X86_CR3_PCID_MASK;\n\t}\n#endif\n\n\t/* PDPTRs are always reloaded for PAE paging. */\n\tif (cr3 == kvm_read_cr3(vcpu) && !is_pae_paging(vcpu))\n\t\tgoto handle_tlb_flush;\n\n\t/*\n\t * Do not condition the GPA check on long mode, this helper is used to\n\t * stuff CR3, e.g. for RSM emulation, and there is no guarantee that\n\t * the current vCPU mode is accurate.\n\t */\n\tif (kvm_vcpu_is_illegal_gpa(vcpu, cr3))\n\t\treturn 1;\n\n\tif (is_pae_paging(vcpu) && !load_pdptrs(vcpu, cr3))\n\t\treturn 1;\n\n\tif (cr3 != kvm_read_cr3(vcpu))\n\t\tkvm_mmu_new_pgd(vcpu, cr3);\n\n\tvcpu->arch.cr3 = cr3;\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\t/* Do not call post_set_cr3, we do not get here for confidential guests.  */\n\nhandle_tlb_flush:\n\t/*\n\t * A load of CR3 that flushes the TLB flushes only the current PCID,\n\t * even if PCID is disabled, in which case PCID=0 is flushed.  It's a\n\t * moot point in the end because _disabling_ PCID will flush all PCIDs,\n\t * and it's impossible to use a non-zero PCID when PCID is disabled,\n\t * i.e. only PCID=0 can be relevant.\n\t */\n\tif (!skip_tlb_flush)\n\t\tkvm_invalidate_pcid(vcpu, pcid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr3);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_cr8);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}\nEXPORT_SYMBOL_GPL(kvm_get_cr8);\n\nstatic void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n}\n\nvoid kvm_update_dr7(struct kvm_vcpu *vcpu)\n{\n\tunsigned long dr7;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\tdr7 = vcpu->arch.guest_debug_dr7;\n\telse\n\t\tdr7 = vcpu->arch.dr7;\n\tstatic_call(kvm_x86_set_dr7)(vcpu, dr7);\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_BP_ENABLED;\n\tif (dr7 & DR7_BP_EN_MASK)\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_BP_ENABLED;\n}\nEXPORT_SYMBOL_GPL(kvm_update_dr7);\n\nstatic u64 kvm_dr6_fixed(struct kvm_vcpu *vcpu)\n{\n\tu64 fixed = DR6_FIXED_1;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_RTM))\n\t\tfixed |= DR6_RTM;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_BUS_LOCK_DETECT))\n\t\tfixed |= DR6_BUS_LOCK;\n\treturn fixed;\n}\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\tvcpu->arch.db[array_index_nospec(dr, size)] = val;\n\t\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP))\n\t\t\tvcpu->arch.eff_db[dr] = val;\n\t\tbreak;\n\tcase 4:\n\tcase 6:\n\t\tif (!kvm_dr6_valid(val))\n\t\t\treturn 1; /* #GP */\n\t\tvcpu->arch.dr6 = (val & DR6_VOLATILE) | kvm_dr6_fixed(vcpu);\n\t\tbreak;\n\tcase 5:\n\tdefault: /* 7 */\n\t\tif (!kvm_dr7_valid(val))\n\t\t\treturn 1; /* #GP */\n\t\tvcpu->arch.dr7 = (val & DR7_VOLATILE) | DR7_FIXED_1;\n\t\tkvm_update_dr7(vcpu);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_dr);\n\nvoid kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[array_index_nospec(dr, size)];\n\t\tbreak;\n\tcase 4:\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_get_dr);\n\nint kvm_emulate_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\n\tif (kvm_pmu_rdpmc(vcpu, ecx, &data)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tkvm_rax_write(vcpu, (u32)data);\n\tkvm_rdx_write(vcpu, data >> 32);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_rdpmc);\n\n/*\n * List of msr numbers which we expose to userspace through KVM_GET_MSRS\n * and KVM_SET_MSRS, and KVM_GET_MSR_INDEX_LIST.\n *\n * The three MSR lists(msrs_to_save, emulated_msrs, msr_based_features)\n * extract the supported MSRs from the related const lists.\n * msrs_to_save is selected from the msrs_to_save_all to reflect the\n * capabilities of the host cpu. This capabilities test skips MSRs that are\n * kvm-specific. Those are put in emulated_msrs_all; filtering of emulated_msrs\n * may depend on host virtualization features rather than host cpu features.\n */\n\nstatic const u32 msrs_to_save_all[] = {\n\tMSR_IA32_SYSENTER_CS, MSR_IA32_SYSENTER_ESP, MSR_IA32_SYSENTER_EIP,\n\tMSR_STAR,\n#ifdef CONFIG_X86_64\n\tMSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,\n#endif\n\tMSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,\n\tMSR_IA32_FEAT_CTL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,\n\tMSR_IA32_SPEC_CTRL,\n\tMSR_IA32_RTIT_CTL, MSR_IA32_RTIT_STATUS, MSR_IA32_RTIT_CR3_MATCH,\n\tMSR_IA32_RTIT_OUTPUT_BASE, MSR_IA32_RTIT_OUTPUT_MASK,\n\tMSR_IA32_RTIT_ADDR0_A, MSR_IA32_RTIT_ADDR0_B,\n\tMSR_IA32_RTIT_ADDR1_A, MSR_IA32_RTIT_ADDR1_B,\n\tMSR_IA32_RTIT_ADDR2_A, MSR_IA32_RTIT_ADDR2_B,\n\tMSR_IA32_RTIT_ADDR3_A, MSR_IA32_RTIT_ADDR3_B,\n\tMSR_IA32_UMWAIT_CONTROL,\n\n\tMSR_ARCH_PERFMON_FIXED_CTR0, MSR_ARCH_PERFMON_FIXED_CTR1,\n\tMSR_ARCH_PERFMON_FIXED_CTR0 + 2,\n\tMSR_CORE_PERF_FIXED_CTR_CTRL, MSR_CORE_PERF_GLOBAL_STATUS,\n\tMSR_CORE_PERF_GLOBAL_CTRL, MSR_CORE_PERF_GLOBAL_OVF_CTRL,\n\tMSR_ARCH_PERFMON_PERFCTR0, MSR_ARCH_PERFMON_PERFCTR1,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 2, MSR_ARCH_PERFMON_PERFCTR0 + 3,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 4, MSR_ARCH_PERFMON_PERFCTR0 + 5,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 6, MSR_ARCH_PERFMON_PERFCTR0 + 7,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 8, MSR_ARCH_PERFMON_PERFCTR0 + 9,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 10, MSR_ARCH_PERFMON_PERFCTR0 + 11,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 12, MSR_ARCH_PERFMON_PERFCTR0 + 13,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 14, MSR_ARCH_PERFMON_PERFCTR0 + 15,\n\tMSR_ARCH_PERFMON_PERFCTR0 + 16, MSR_ARCH_PERFMON_PERFCTR0 + 17,\n\tMSR_ARCH_PERFMON_EVENTSEL0, MSR_ARCH_PERFMON_EVENTSEL1,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 2, MSR_ARCH_PERFMON_EVENTSEL0 + 3,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 4, MSR_ARCH_PERFMON_EVENTSEL0 + 5,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 6, MSR_ARCH_PERFMON_EVENTSEL0 + 7,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 8, MSR_ARCH_PERFMON_EVENTSEL0 + 9,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 10, MSR_ARCH_PERFMON_EVENTSEL0 + 11,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 12, MSR_ARCH_PERFMON_EVENTSEL0 + 13,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 14, MSR_ARCH_PERFMON_EVENTSEL0 + 15,\n\tMSR_ARCH_PERFMON_EVENTSEL0 + 16, MSR_ARCH_PERFMON_EVENTSEL0 + 17,\n\n\tMSR_K7_EVNTSEL0, MSR_K7_EVNTSEL1, MSR_K7_EVNTSEL2, MSR_K7_EVNTSEL3,\n\tMSR_K7_PERFCTR0, MSR_K7_PERFCTR1, MSR_K7_PERFCTR2, MSR_K7_PERFCTR3,\n\tMSR_F15H_PERF_CTL0, MSR_F15H_PERF_CTL1, MSR_F15H_PERF_CTL2,\n\tMSR_F15H_PERF_CTL3, MSR_F15H_PERF_CTL4, MSR_F15H_PERF_CTL5,\n\tMSR_F15H_PERF_CTR0, MSR_F15H_PERF_CTR1, MSR_F15H_PERF_CTR2,\n\tMSR_F15H_PERF_CTR3, MSR_F15H_PERF_CTR4, MSR_F15H_PERF_CTR5,\n\tMSR_IA32_XFD, MSR_IA32_XFD_ERR,\n};\n\nstatic u32 msrs_to_save[ARRAY_SIZE(msrs_to_save_all)];\nstatic unsigned num_msrs_to_save;\n\nstatic const u32 emulated_msrs_all[] = {\n\tMSR_KVM_SYSTEM_TIME, MSR_KVM_WALL_CLOCK,\n\tMSR_KVM_SYSTEM_TIME_NEW, MSR_KVM_WALL_CLOCK_NEW,\n\tHV_X64_MSR_GUEST_OS_ID, HV_X64_MSR_HYPERCALL,\n\tHV_X64_MSR_TIME_REF_COUNT, HV_X64_MSR_REFERENCE_TSC,\n\tHV_X64_MSR_TSC_FREQUENCY, HV_X64_MSR_APIC_FREQUENCY,\n\tHV_X64_MSR_CRASH_P0, HV_X64_MSR_CRASH_P1, HV_X64_MSR_CRASH_P2,\n\tHV_X64_MSR_CRASH_P3, HV_X64_MSR_CRASH_P4, HV_X64_MSR_CRASH_CTL,\n\tHV_X64_MSR_RESET,\n\tHV_X64_MSR_VP_INDEX,\n\tHV_X64_MSR_VP_RUNTIME,\n\tHV_X64_MSR_SCONTROL,\n\tHV_X64_MSR_STIMER0_CONFIG,\n\tHV_X64_MSR_VP_ASSIST_PAGE,\n\tHV_X64_MSR_REENLIGHTENMENT_CONTROL, HV_X64_MSR_TSC_EMULATION_CONTROL,\n\tHV_X64_MSR_TSC_EMULATION_STATUS,\n\tHV_X64_MSR_SYNDBG_OPTIONS,\n\tHV_X64_MSR_SYNDBG_CONTROL, HV_X64_MSR_SYNDBG_STATUS,\n\tHV_X64_MSR_SYNDBG_SEND_BUFFER, HV_X64_MSR_SYNDBG_RECV_BUFFER,\n\tHV_X64_MSR_SYNDBG_PENDING_BUFFER,\n\n\tMSR_KVM_ASYNC_PF_EN, MSR_KVM_STEAL_TIME,\n\tMSR_KVM_PV_EOI_EN, MSR_KVM_ASYNC_PF_INT, MSR_KVM_ASYNC_PF_ACK,\n\n\tMSR_IA32_TSC_ADJUST,\n\tMSR_IA32_TSC_DEADLINE,\n\tMSR_IA32_ARCH_CAPABILITIES,\n\tMSR_IA32_PERF_CAPABILITIES,\n\tMSR_IA32_MISC_ENABLE,\n\tMSR_IA32_MCG_STATUS,\n\tMSR_IA32_MCG_CTL,\n\tMSR_IA32_MCG_EXT_CTL,\n\tMSR_IA32_SMBASE,\n\tMSR_SMI_COUNT,\n\tMSR_PLATFORM_INFO,\n\tMSR_MISC_FEATURES_ENABLES,\n\tMSR_AMD64_VIRT_SPEC_CTRL,\n\tMSR_AMD64_TSC_RATIO,\n\tMSR_IA32_POWER_CTL,\n\tMSR_IA32_UCODE_REV,\n\n\t/*\n\t * The following list leaves out MSRs whose values are determined\n\t * by arch/x86/kvm/vmx/nested.c based on CPUID or other MSRs.\n\t * We always support the \"true\" VMX control MSRs, even if the host\n\t * processor does not, so I am putting these registers here rather\n\t * than in msrs_to_save_all.\n\t */\n\tMSR_IA32_VMX_BASIC,\n\tMSR_IA32_VMX_TRUE_PINBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_PROCBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_EXIT_CTLS,\n\tMSR_IA32_VMX_TRUE_ENTRY_CTLS,\n\tMSR_IA32_VMX_MISC,\n\tMSR_IA32_VMX_CR0_FIXED0,\n\tMSR_IA32_VMX_CR4_FIXED0,\n\tMSR_IA32_VMX_VMCS_ENUM,\n\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\tMSR_IA32_VMX_EPT_VPID_CAP,\n\tMSR_IA32_VMX_VMFUNC,\n\n\tMSR_K7_HWCR,\n\tMSR_KVM_POLL_CONTROL,\n};\n\nstatic u32 emulated_msrs[ARRAY_SIZE(emulated_msrs_all)];\nstatic unsigned num_emulated_msrs;\n\n/*\n * List of msr numbers which are used to expose MSR-based features that\n * can be used by a hypervisor to validate requested CPU features.\n */\nstatic const u32 msr_based_features_all[] = {\n\tMSR_IA32_VMX_BASIC,\n\tMSR_IA32_VMX_TRUE_PINBASED_CTLS,\n\tMSR_IA32_VMX_PINBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_PROCBASED_CTLS,\n\tMSR_IA32_VMX_PROCBASED_CTLS,\n\tMSR_IA32_VMX_TRUE_EXIT_CTLS,\n\tMSR_IA32_VMX_EXIT_CTLS,\n\tMSR_IA32_VMX_TRUE_ENTRY_CTLS,\n\tMSR_IA32_VMX_ENTRY_CTLS,\n\tMSR_IA32_VMX_MISC,\n\tMSR_IA32_VMX_CR0_FIXED0,\n\tMSR_IA32_VMX_CR0_FIXED1,\n\tMSR_IA32_VMX_CR4_FIXED0,\n\tMSR_IA32_VMX_CR4_FIXED1,\n\tMSR_IA32_VMX_VMCS_ENUM,\n\tMSR_IA32_VMX_PROCBASED_CTLS2,\n\tMSR_IA32_VMX_EPT_VPID_CAP,\n\tMSR_IA32_VMX_VMFUNC,\n\n\tMSR_F10H_DECFG,\n\tMSR_IA32_UCODE_REV,\n\tMSR_IA32_ARCH_CAPABILITIES,\n\tMSR_IA32_PERF_CAPABILITIES,\n};\n\nstatic u32 msr_based_features[ARRAY_SIZE(msr_based_features_all)];\nstatic unsigned int num_msr_based_features;\n\nstatic u64 kvm_get_arch_capabilities(void)\n{\n\tu64 data = 0;\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES))\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, data);\n\n\t/*\n\t * If nx_huge_pages is enabled, KVM's shadow paging will ensure that\n\t * the nested hypervisor runs with NX huge pages.  If it is not,\n\t * L1 is anyway vulnerable to ITLB_MULTIHIT exploits from other\n\t * L1 guests, so it need not worry about its own (L2) guests.\n\t */\n\tdata |= ARCH_CAP_PSCHANGE_MC_NO;\n\n\t/*\n\t * If we're doing cache flushes (either \"always\" or \"cond\")\n\t * we will do one whenever the guest does a vmlaunch/vmresume.\n\t * If an outer hypervisor is doing the cache flush for us\n\t * (VMENTER_L1D_FLUSH_NESTED_VM), we can safely pass that\n\t * capability to the guest too, and if EPT is disabled we're not\n\t * vulnerable.  Overall, only VMENTER_L1D_FLUSH_NEVER will\n\t * require a nested hypervisor to do a flush of its own.\n\t */\n\tif (l1tf_vmx_mitigation != VMENTER_L1D_FLUSH_NEVER)\n\t\tdata |= ARCH_CAP_SKIP_VMENTRY_L1DFLUSH;\n\n\tif (!boot_cpu_has_bug(X86_BUG_CPU_MELTDOWN))\n\t\tdata |= ARCH_CAP_RDCL_NO;\n\tif (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))\n\t\tdata |= ARCH_CAP_SSB_NO;\n\tif (!boot_cpu_has_bug(X86_BUG_MDS))\n\t\tdata |= ARCH_CAP_MDS_NO;\n\n\tif (!boot_cpu_has(X86_FEATURE_RTM)) {\n\t\t/*\n\t\t * If RTM=0 because the kernel has disabled TSX, the host might\n\t\t * have TAA_NO or TSX_CTRL.  Clear TAA_NO (the guest sees RTM=0\n\t\t * and therefore knows that there cannot be TAA) but keep\n\t\t * TSX_CTRL: some buggy userspaces leave it set on tsx=on hosts,\n\t\t * and we want to allow migrating those guests to tsx=off hosts.\n\t\t */\n\t\tdata &= ~ARCH_CAP_TAA_NO;\n\t} else if (!boot_cpu_has_bug(X86_BUG_TAA)) {\n\t\tdata |= ARCH_CAP_TAA_NO;\n\t} else {\n\t\t/*\n\t\t * Nothing to do here; we emulate TSX_CTRL if present on the\n\t\t * host so the guest can choose between disabling TSX or\n\t\t * using VERW to clear CPU buffers.\n\t\t */\n\t}\n\n\treturn data;\n}\n\nstatic int kvm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tmsr->data = kvm_get_arch_capabilities();\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\trdmsrl_safe(msr->index, &msr->data);\n\t\tbreak;\n\tdefault:\n\t\treturn static_call(kvm_x86_get_msr_feature)(msr);\n\t}\n\treturn 0;\n}\n\nstatic int do_get_msr_feature(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\tstruct kvm_msr_entry msr;\n\tint r;\n\n\tmsr.index = index;\n\tr = kvm_get_msr_feature(&msr);\n\n\tif (r == KVM_MSR_RET_INVALID) {\n\t\t/* Unconditionally clear the output for simplicity */\n\t\t*data = 0;\n\t\tif (kvm_msr_ignored_check(index, 0, false))\n\t\t\tr = 0;\n\t}\n\n\tif (r)\n\t\treturn r;\n\n\t*data = msr.data;\n\n\treturn 0;\n}\n\nstatic bool __kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & EFER_FFXSR && !guest_cpuid_has(vcpu, X86_FEATURE_FXSR_OPT))\n\t\treturn false;\n\n\tif (efer & EFER_SVME && !guest_cpuid_has(vcpu, X86_FEATURE_SVM))\n\t\treturn false;\n\n\tif (efer & (EFER_LME | EFER_LMA) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\treturn false;\n\n\tif (efer & EFER_NX && !guest_cpuid_has(vcpu, X86_FEATURE_NX))\n\t\treturn false;\n\n\treturn true;\n\n}\nbool kvm_valid_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tif (efer & efer_reserved_bits)\n\t\treturn false;\n\n\treturn __kvm_valid_efer(vcpu, efer);\n}\nEXPORT_SYMBOL_GPL(kvm_valid_efer);\n\nstatic int set_efer(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 old_efer = vcpu->arch.efer;\n\tu64 efer = msr_info->data;\n\tint r;\n\n\tif (efer & efer_reserved_bits)\n\t\treturn 1;\n\n\tif (!msr_info->host_initiated) {\n\t\tif (!__kvm_valid_efer(vcpu, efer))\n\t\t\treturn 1;\n\n\t\tif (is_paging(vcpu) &&\n\t\t    (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n\t\t\treturn 1;\n\t}\n\n\tefer &= ~EFER_LMA;\n\tefer |= vcpu->arch.efer & EFER_LMA;\n\n\tr = static_call(kvm_x86_set_efer)(vcpu, efer);\n\tif (r) {\n\t\tWARN_ON(r > 0);\n\t\treturn r;\n\t}\n\n\tif ((efer ^ old_efer) & KVM_MMU_EFER_ROLE_BITS)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\treturn 0;\n}\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}\nEXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n\nbool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)\n{\n\tstruct kvm_x86_msr_filter *msr_filter;\n\tstruct msr_bitmap_range *ranges;\n\tstruct kvm *kvm = vcpu->kvm;\n\tbool allowed;\n\tint idx;\n\tu32 i;\n\n\t/* x2APIC MSRs do not support filtering. */\n\tif (index >= 0x800 && index <= 0x8ff)\n\t\treturn true;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\n\tmsr_filter = srcu_dereference(kvm->arch.msr_filter, &kvm->srcu);\n\tif (!msr_filter) {\n\t\tallowed = true;\n\t\tgoto out;\n\t}\n\n\tallowed = msr_filter->default_allow;\n\tranges = msr_filter->ranges;\n\n\tfor (i = 0; i < msr_filter->count; i++) {\n\t\tu32 start = ranges[i].base;\n\t\tu32 end = start + ranges[i].nmsrs;\n\t\tu32 flags = ranges[i].flags;\n\t\tunsigned long *bitmap = ranges[i].bitmap;\n\n\t\tif ((index >= start) && (index < end) && (flags & type)) {\n\t\t\tallowed = !!test_bit(index - start, bitmap);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\treturn allowed;\n}\nEXPORT_SYMBOL_GPL(kvm_msr_allowed);\n\n/*\n * Write @data into the MSR specified by @index.  Select MSR specific fault\n * checks are bypassed if @host_initiated is %true.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nstatic int __kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data,\n\t\t\t bool host_initiated)\n{\n\tstruct msr_data msr;\n\n\tswitch (index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(data, vcpu))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\t/*\n\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n\t\t * non-canonical address is written on Intel but not on\n\t\t * AMD (which ignores the top 32-bits, because it does\n\t\t * not implement 64-bit SYSENTER).\n\t\t *\n\t\t * 64-bit code should hence be able to write a non-canonical\n\t\t * value on AMD.  Making the address canonical ensures that\n\t\t * vmentry does not fail on Intel after writing a non-canonical\n\t\t * value, and that something deterministic happens if the guest\n\t\t * invokes 64-bit SYSENTER.\n\t\t */\n\t\tdata = __canonical_address(data, vcpu_virt_addr_bits(vcpu));\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))\n\t\t\treturn 1;\n\n\t\tif (!host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * Per Intel's SDM, bits 63:32 are reserved, but AMD's APM has\n\t\t * incomplete and conflicting architectural behavior.  Current\n\t\t * AMD CPUs completely ignore bits 63:32, i.e. they aren't\n\t\t * reserved and always read as zeros.  Enforce Intel's reserved\n\t\t * bits check if and only if the guest CPU is Intel, and clear\n\t\t * the bits in all other cases.  This ensures cross-vendor\n\t\t * migration will provide consistent behavior for the guest.\n\t\t */\n\t\tif (guest_cpuid_is_intel(vcpu) && (data >> 32) != 0)\n\t\t\treturn 1;\n\n\t\tdata = (u32)data;\n\t\tbreak;\n\t}\n\n\tmsr.data = data;\n\tmsr.index = index;\n\tmsr.host_initiated = host_initiated;\n\n\treturn static_call(kvm_x86_set_msr)(vcpu, &msr);\n}\n\nstatic int kvm_set_msr_ignored_check(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data, bool host_initiated)\n{\n\tint ret = __kvm_set_msr(vcpu, index, data, host_initiated);\n\n\tif (ret == KVM_MSR_RET_INVALID)\n\t\tif (kvm_msr_ignored_check(index, data, true))\n\t\t\tret = 0;\n\n\treturn ret;\n}\n\n/*\n * Read the MSR specified by @index into @data.  Select MSR specific fault\n * checks are bypassed if @host_initiated is %true.\n * Returns 0 on success, non-0 otherwise.\n * Assumes vcpu_load() was already called.\n */\nint __kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data,\n\t\t  bool host_initiated)\n{\n\tstruct msr_data msr;\n\tint ret;\n\n\tswitch (index) {\n\tcase MSR_TSC_AUX:\n\t\tif (!kvm_is_supported_user_return_msr(MSR_TSC_AUX))\n\t\t\treturn 1;\n\n\t\tif (!host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDPID))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\n\tmsr.index = index;\n\tmsr.host_initiated = host_initiated;\n\n\tret = static_call(kvm_x86_get_msr)(vcpu, &msr);\n\tif (!ret)\n\t\t*data = msr.data;\n\treturn ret;\n}\n\nstatic int kvm_get_msr_ignored_check(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *data, bool host_initiated)\n{\n\tint ret = __kvm_get_msr(vcpu, index, data, host_initiated);\n\n\tif (ret == KVM_MSR_RET_INVALID) {\n\t\t/* Unconditionally clear *data for simplicity */\n\t\t*data = 0;\n\t\tif (kvm_msr_ignored_check(index, 0, false))\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int kvm_get_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 *data)\n{\n\tif (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_READ))\n\t\treturn KVM_MSR_RET_FILTERED;\n\treturn kvm_get_msr_ignored_check(vcpu, index, data, false);\n}\n\nstatic int kvm_set_msr_with_filter(struct kvm_vcpu *vcpu, u32 index, u64 data)\n{\n\tif (!kvm_msr_allowed(vcpu, index, KVM_MSR_FILTER_WRITE))\n\t\treturn KVM_MSR_RET_FILTERED;\n\treturn kvm_set_msr_ignored_check(vcpu, index, data, false);\n}\n\nint kvm_get_msr(struct kvm_vcpu *vcpu, u32 index, u64 *data)\n{\n\treturn kvm_get_msr_ignored_check(vcpu, index, data, false);\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr);\n\nint kvm_set_msr(struct kvm_vcpu *vcpu, u32 index, u64 data)\n{\n\treturn kvm_set_msr_ignored_check(vcpu, index, data, false);\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr);\n\nstatic void complete_userspace_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->run->msr.error) {\n\t\tkvm_rax_write(vcpu, (u32)vcpu->run->msr.data);\n\t\tkvm_rdx_write(vcpu, vcpu->run->msr.data >> 32);\n\t}\n}\n\nstatic int complete_emulated_msr_access(struct kvm_vcpu *vcpu)\n{\n\treturn complete_emulated_insn_gp(vcpu, vcpu->run->msr.error);\n}\n\nstatic int complete_emulated_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tcomplete_userspace_rdmsr(vcpu);\n\treturn complete_emulated_msr_access(vcpu);\n}\n\nstatic int complete_fast_msr_access(struct kvm_vcpu *vcpu)\n{\n\treturn static_call(kvm_x86_complete_emulated_msr)(vcpu, vcpu->run->msr.error);\n}\n\nstatic int complete_fast_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tcomplete_userspace_rdmsr(vcpu);\n\treturn complete_fast_msr_access(vcpu);\n}\n\nstatic u64 kvm_msr_reason(int r)\n{\n\tswitch (r) {\n\tcase KVM_MSR_RET_INVALID:\n\t\treturn KVM_MSR_EXIT_REASON_UNKNOWN;\n\tcase KVM_MSR_RET_FILTERED:\n\t\treturn KVM_MSR_EXIT_REASON_FILTER;\n\tdefault:\n\t\treturn KVM_MSR_EXIT_REASON_INVAL;\n\t}\n}\n\nstatic int kvm_msr_user_space(struct kvm_vcpu *vcpu, u32 index,\n\t\t\t      u32 exit_reason, u64 data,\n\t\t\t      int (*completion)(struct kvm_vcpu *vcpu),\n\t\t\t      int r)\n{\n\tu64 msr_reason = kvm_msr_reason(r);\n\n\t/* Check if the user wanted to know about this MSR fault */\n\tif (!(vcpu->kvm->arch.user_space_msr_mask & msr_reason))\n\t\treturn 0;\n\n\tvcpu->run->exit_reason = exit_reason;\n\tvcpu->run->msr.error = 0;\n\tmemset(vcpu->run->msr.pad, 0, sizeof(vcpu->run->msr.pad));\n\tvcpu->run->msr.reason = msr_reason;\n\tvcpu->run->msr.index = index;\n\tvcpu->run->msr.data = data;\n\tvcpu->arch.complete_userspace_io = completion;\n\n\treturn 1;\n}\n\nint kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint r;\n\n\tr = kvm_get_msr_with_filter(vcpu, ecx, &data);\n\n\tif (!r) {\n\t\ttrace_kvm_msr_read(ecx, data);\n\n\t\tkvm_rax_write(vcpu, data & -1u);\n\t\tkvm_rdx_write(vcpu, (data >> 32) & -1u);\n\t} else {\n\t\t/* MSR read failed? See if we should ask user space */\n\t\tif (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_RDMSR, 0,\n\t\t\t\t       complete_fast_rdmsr, r))\n\t\t\treturn 0;\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t}\n\n\treturn static_call(kvm_x86_complete_emulated_msr)(vcpu, r);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_rdmsr);\n\nint kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data = kvm_read_edx_eax(vcpu);\n\tint r;\n\n\tr = kvm_set_msr_with_filter(vcpu, ecx, data);\n\n\tif (!r) {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t} else {\n\t\t/* MSR write failed? See if we should ask user space */\n\t\tif (kvm_msr_user_space(vcpu, ecx, KVM_EXIT_X86_WRMSR, data,\n\t\t\t\t       complete_fast_msr_access, r))\n\t\t\treturn 0;\n\t\t/* Signal all other negative errors to userspace */\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t}\n\n\treturn static_call(kvm_x86_complete_emulated_msr)(vcpu, r);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wrmsr);\n\nint kvm_emulate_as_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_as_nop);\n\nint kvm_emulate_invd(struct kvm_vcpu *vcpu)\n{\n\t/* Treat an INVD instruction as a NOP and just skip it. */\n\treturn kvm_emulate_as_nop(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_invd);\n\nint kvm_emulate_mwait(struct kvm_vcpu *vcpu)\n{\n\tpr_warn_once(\"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn kvm_emulate_as_nop(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_mwait);\n\nint kvm_handle_invalid_op(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(kvm_handle_invalid_op);\n\nint kvm_emulate_monitor(struct kvm_vcpu *vcpu)\n{\n\tpr_warn_once(\"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn kvm_emulate_as_nop(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_monitor);\n\nstatic inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)\n{\n\txfer_to_guest_mode_prepare();\n\treturn vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu) ||\n\t\txfer_to_guest_mode_work_pending();\n}\n\n/*\n * The fast path for frequent and performance sensitive wrmsr emulation,\n * i.e. the sending of IPI, sending IPI early in the VM-Exit flow reduces\n * the latency of virtual IPI by avoiding the expensive bits of transitioning\n * from guest to host, e.g. reacquiring KVM's SRCU lock. In contrast to the\n * other cases which must be called after interrupts are enabled on the host.\n */\nstatic int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)\n{\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))\n\t\treturn 1;\n\n\tif (((data & APIC_SHORT_MASK) == APIC_DEST_NOSHORT) &&\n\t    ((data & APIC_DEST_MASK) == APIC_DEST_PHYSICAL) &&\n\t    ((data & APIC_MODE_MASK) == APIC_DM_FIXED) &&\n\t    ((u32)(data >> 32) != X2APIC_BROADCAST))\n\t\treturn kvm_x2apic_icr_write(vcpu->arch.apic, data);\n\n\treturn 1;\n}\n\nstatic int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)\n{\n\tif (!kvm_can_use_hv_timer(vcpu))\n\t\treturn 1;\n\n\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\treturn 0;\n}\n\nfastpath_t handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 msr = kvm_rcx_read(vcpu);\n\tu64 data;\n\tfastpath_t ret = EXIT_FASTPATH_NONE;\n\n\tswitch (msr) {\n\tcase APIC_BASE_MSR + (APIC_ICR >> 4):\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tif (!handle_fastpath_set_x2apic_icr_irqoff(vcpu, data)) {\n\t\t\tkvm_skip_emulated_instruction(vcpu);\n\t\t\tret = EXIT_FASTPATH_EXIT_HANDLED;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_TSC_DEADLINE:\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tif (!handle_fastpath_set_tscdeadline(vcpu, data)) {\n\t\t\tkvm_skip_emulated_instruction(vcpu);\n\t\t\tret = EXIT_FASTPATH_REENTER_GUEST;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret != EXIT_FASTPATH_NONE)\n\t\ttrace_kvm_msr_write(msr, data);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(handle_fastpath_set_msr_irqoff);\n\n/*\n * Adapt set_msr() to msr_io()'s calling convention\n */\nstatic int do_get_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\treturn kvm_get_msr_ignored_check(vcpu, index, data, true);\n}\n\nstatic int do_set_msr(struct kvm_vcpu *vcpu, unsigned index, u64 *data)\n{\n\treturn kvm_set_msr_ignored_check(vcpu, index, *data, true);\n}\n\n#ifdef CONFIG_X86_64\nstruct pvclock_clock {\n\tint vclock_mode;\n\tu64 cycle_last;\n\tu64 mask;\n\tu32 mult;\n\tu32 shift;\n\tu64 base_cycles;\n\tu64 offset;\n};\n\nstruct pvclock_gtod_data {\n\tseqcount_t\tseq;\n\n\tstruct pvclock_clock clock; /* extract of a clocksource struct */\n\tstruct pvclock_clock raw_clock; /* extract of a clocksource struct */\n\n\tktime_t\t\toffs_boot;\n\tu64\t\twall_time_sec;\n};\n\nstatic struct pvclock_gtod_data pvclock_gtod_data;\n\nstatic void update_pvclock_gtod(struct timekeeper *tk)\n{\n\tstruct pvclock_gtod_data *vdata = &pvclock_gtod_data;\n\n\twrite_seqcount_begin(&vdata->seq);\n\n\t/* copy pvclock gtod data */\n\tvdata->clock.vclock_mode\t= tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata->clock.cycle_last\t\t= tk->tkr_mono.cycle_last;\n\tvdata->clock.mask\t\t= tk->tkr_mono.mask;\n\tvdata->clock.mult\t\t= tk->tkr_mono.mult;\n\tvdata->clock.shift\t\t= tk->tkr_mono.shift;\n\tvdata->clock.base_cycles\t= tk->tkr_mono.xtime_nsec;\n\tvdata->clock.offset\t\t= tk->tkr_mono.base;\n\n\tvdata->raw_clock.vclock_mode\t= tk->tkr_raw.clock->vdso_clock_mode;\n\tvdata->raw_clock.cycle_last\t= tk->tkr_raw.cycle_last;\n\tvdata->raw_clock.mask\t\t= tk->tkr_raw.mask;\n\tvdata->raw_clock.mult\t\t= tk->tkr_raw.mult;\n\tvdata->raw_clock.shift\t\t= tk->tkr_raw.shift;\n\tvdata->raw_clock.base_cycles\t= tk->tkr_raw.xtime_nsec;\n\tvdata->raw_clock.offset\t\t= tk->tkr_raw.base;\n\n\tvdata->wall_time_sec            = tk->xtime_sec;\n\n\tvdata->offs_boot\t\t= tk->offs_boot;\n\n\twrite_seqcount_end(&vdata->seq);\n}\n\nstatic s64 get_kvmclock_base_ns(void)\n{\n\t/* Count up from boot time, but with the frequency of the raw clock.  */\n\treturn ktime_to_ns(ktime_add(ktime_get_raw(), pvclock_gtod_data.offs_boot));\n}\n#else\nstatic s64 get_kvmclock_base_ns(void)\n{\n\t/* Master clock not used, so we can just use CLOCK_BOOTTIME.  */\n\treturn ktime_get_boottime_ns();\n}\n#endif\n\nstatic void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock, int sec_hi_ofs)\n{\n\tint version;\n\tint r;\n\tstruct pvclock_wall_clock wc;\n\tu32 wc_sec_hi;\n\tu64 wall_nsec;\n\n\tif (!wall_clock)\n\t\treturn;\n\n\tr = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n\tif (r)\n\t\treturn;\n\n\tif (version & 1)\n\t\t++version;  /* first time write, random junk */\n\n\t++version;\n\n\tif (kvm_write_guest(kvm, wall_clock, &version, sizeof(version)))\n\t\treturn;\n\n\t/*\n\t * The guest calculates current wall clock time by adding\n\t * system time (updated by kvm_guest_time_update below) to the\n\t * wall clock specified here.  We do the reverse here.\n\t */\n\twall_nsec = ktime_get_real_ns() - get_kvmclock_ns(kvm);\n\n\twc.nsec = do_div(wall_nsec, 1000000000);\n\twc.sec = (u32)wall_nsec; /* overflow in 2106 guest time */\n\twc.version = version;\n\n\tkvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n\n\tif (sec_hi_ofs) {\n\t\twc_sec_hi = wall_nsec >> 32;\n\t\tkvm_write_guest(kvm, wall_clock + sec_hi_ofs,\n\t\t\t\t&wc_sec_hi, sizeof(wc_sec_hi));\n\t}\n\n\tversion++;\n\tkvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n\nstatic void kvm_write_system_time(struct kvm_vcpu *vcpu, gpa_t system_time,\n\t\t\t\t  bool old_msr, bool host_initiated)\n{\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\tif (vcpu->vcpu_id == 0 && !host_initiated) {\n\t\tif (ka->boot_vcpu_runs_old_kvmclock != old_msr)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\t\tka->boot_vcpu_runs_old_kvmclock = old_msr;\n\t}\n\n\tvcpu->arch.time = system_time;\n\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t/* we verify if the enable bit is set... */\n\tif (system_time & 1) {\n\t\tkvm_gfn_to_pfn_cache_init(vcpu->kvm, &vcpu->arch.pv_time, vcpu,\n\t\t\t\t\t  KVM_HOST_USES_PFN, system_time & ~1ULL,\n\t\t\t\t\t  sizeof(struct pvclock_vcpu_time_info));\n\t} else {\n\t\tkvm_gfn_to_pfn_cache_destroy(vcpu->kvm, &vcpu->arch.pv_time);\n\t}\n\n\treturn;\n}\n\nstatic uint32_t div_frac(uint32_t dividend, uint32_t divisor)\n{\n\tdo_shl32_div32(dividend, divisor);\n\treturn dividend;\n}\n\nstatic void kvm_get_time_scale(uint64_t scaled_hz, uint64_t base_hz,\n\t\t\t       s8 *pshift, u32 *pmultiplier)\n{\n\tuint64_t scaled64;\n\tint32_t  shift = 0;\n\tuint64_t tps64;\n\tuint32_t tps32;\n\n\ttps64 = base_hz;\n\tscaled64 = scaled_hz;\n\twhile (tps64 > scaled64*2 || tps64 & 0xffffffff00000000ULL) {\n\t\ttps64 >>= 1;\n\t\tshift--;\n\t}\n\n\ttps32 = (uint32_t)tps64;\n\twhile (tps32 <= scaled64 || scaled64 & 0xffffffff00000000ULL) {\n\t\tif (scaled64 & 0xffffffff00000000ULL || tps32 & 0x80000000)\n\t\t\tscaled64 >>= 1;\n\t\telse\n\t\t\ttps32 <<= 1;\n\t\tshift++;\n\t}\n\n\t*pshift = shift;\n\t*pmultiplier = div_frac(scaled64, tps32);\n}\n\n#ifdef CONFIG_X86_64\nstatic atomic_t kvm_guest_has_master_clock = ATOMIC_INIT(0);\n#endif\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\nstatic unsigned long max_tsc_khz;\n\nstatic u32 adjust_tsc_khz(u32 khz, s32 ppm)\n{\n\tu64 v = (u64)khz * (1000000 + ppm);\n\tdo_div(v, 1000000);\n\treturn v;\n}\n\nstatic void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier);\n\nstatic int set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz, bool scale)\n{\n\tu64 ratio;\n\n\t/* Guest TSC same frequency as host TSC? */\n\tif (!scale) {\n\t\tkvm_vcpu_write_tsc_multiplier(vcpu, kvm_default_tsc_scaling_ratio);\n\t\treturn 0;\n\t}\n\n\t/* TSC scaling supported? */\n\tif (!kvm_has_tsc_control) {\n\t\tif (user_tsc_khz > tsc_khz) {\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t\tvcpu->arch.tsc_always_catchup = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpr_warn_ratelimited(\"user requested TSC rate below hardware speed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* TSC scaling required  - calculate ratio */\n\tratio = mul_u64_u32_div(1ULL << kvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tuser_tsc_khz, tsc_khz);\n\n\tif (ratio == 0 || ratio >= kvm_max_tsc_scaling_ratio) {\n\t\tpr_warn_ratelimited(\"Invalid TSC scaling ratio - virtual-tsc-khz=%u\\n\",\n\t\t\t            user_tsc_khz);\n\t\treturn -1;\n\t}\n\n\tkvm_vcpu_write_tsc_multiplier(vcpu, ratio);\n\treturn 0;\n}\n\nstatic int kvm_set_tsc_khz(struct kvm_vcpu *vcpu, u32 user_tsc_khz)\n{\n\tu32 thresh_lo, thresh_hi;\n\tint use_scaling = 0;\n\n\t/* tsc_khz can be zero if TSC calibration fails */\n\tif (user_tsc_khz == 0) {\n\t\t/* set tsc_scaling_ratio to a safe value */\n\t\tkvm_vcpu_write_tsc_multiplier(vcpu, kvm_default_tsc_scaling_ratio);\n\t\treturn -1;\n\t}\n\n\t/* Compute a scale to convert nanoseconds in TSC cycles */\n\tkvm_get_time_scale(user_tsc_khz * 1000LL, NSEC_PER_SEC,\n\t\t\t   &vcpu->arch.virtual_tsc_shift,\n\t\t\t   &vcpu->arch.virtual_tsc_mult);\n\tvcpu->arch.virtual_tsc_khz = user_tsc_khz;\n\n\t/*\n\t * Compute the variation in TSC rate which is acceptable\n\t * within the range of tolerance and decide if the\n\t * rate being applied is within that bounds of the hardware\n\t * rate.  If so, no scaling or compensation need be done.\n\t */\n\tthresh_lo = adjust_tsc_khz(tsc_khz, -tsc_tolerance_ppm);\n\tthresh_hi = adjust_tsc_khz(tsc_khz, tsc_tolerance_ppm);\n\tif (user_tsc_khz < thresh_lo || user_tsc_khz > thresh_hi) {\n\t\tpr_debug(\"kvm: requested TSC rate %u falls outside tolerance [%u,%u]\\n\", user_tsc_khz, thresh_lo, thresh_hi);\n\t\tuse_scaling = 1;\n\t}\n\treturn set_tsc_khz(vcpu, user_tsc_khz, use_scaling);\n}\n\nstatic u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.this_tsc_nsec,\n\t\t\t\t      vcpu->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.this_tsc_write;\n\treturn tsc;\n}\n\n#ifdef CONFIG_X86_64\nstatic inline int gtod_is_based_on_tsc(int mode)\n{\n\treturn mode == VDSO_CLOCKMODE_TSC || mode == VDSO_CLOCKMODE_HVCLOCK;\n}\n#endif\n\nstatic void kvm_track_tsc_matching(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\tbool vcpus_matched;\n\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\t atomic_read(&vcpu->kvm->online_vcpus));\n\n\t/*\n\t * Once the masterclock is enabled, always perform request in\n\t * order to update it.\n\t *\n\t * In order to enable masterclock, the host clocksource must be TSC\n\t * and the vcpus need to have matched TSCs.  When that happens,\n\t * perform request to enable masterclock.\n\t */\n\tif (ka->use_master_clock ||\n\t    (gtod_is_based_on_tsc(gtod->clock.vclock_mode) && vcpus_matched))\n\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\ttrace_kvm_track_tsc(vcpu->vcpu_id, ka->nr_vcpus_matched_tsc,\n\t\t\t    atomic_read(&vcpu->kvm->online_vcpus),\n\t\t            ka->use_master_clock, gtod->clock.vclock_mode);\n#endif\n}\n\n/*\n * Multiply tsc by a fixed point number represented by ratio.\n *\n * The most significant 64-N bits (mult) of ratio represent the\n * integral part of the fixed point number; the remaining N bits\n * (frac) represent the fractional part, ie. ratio represents a fixed\n * point number (mult + frac * 2^(-N)).\n *\n * N equals to kvm_tsc_scaling_ratio_frac_bits.\n */\nstatic inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}\n\nu64 kvm_scale_tsc(u64 tsc, u64 ratio)\n{\n\tu64 _tsc = tsc;\n\n\tif (ratio != kvm_default_tsc_scaling_ratio)\n\t\t_tsc = __scale_tsc(ratio, tsc);\n\n\treturn _tsc;\n}\nEXPORT_SYMBOL_GPL(kvm_scale_tsc);\n\nstatic u64 kvm_compute_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 target_tsc)\n{\n\tu64 tsc;\n\n\ttsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio);\n\n\treturn target_tsc - tsc;\n}\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn vcpu->arch.l1_tsc_offset +\n\t\tkvm_scale_tsc(host_tsc, vcpu->arch.l1_tsc_scaling_ratio);\n}\nEXPORT_SYMBOL_GPL(kvm_read_l1_tsc);\n\nu64 kvm_calc_nested_tsc_offset(u64 l1_offset, u64 l2_offset, u64 l2_multiplier)\n{\n\tu64 nested_offset;\n\n\tif (l2_multiplier == kvm_default_tsc_scaling_ratio)\n\t\tnested_offset = l1_offset;\n\telse\n\t\tnested_offset = mul_s64_u64_shr((s64) l1_offset, l2_multiplier,\n\t\t\t\t\t\tkvm_tsc_scaling_ratio_frac_bits);\n\n\tnested_offset += l2_offset;\n\treturn nested_offset;\n}\nEXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_offset);\n\nu64 kvm_calc_nested_tsc_multiplier(u64 l1_multiplier, u64 l2_multiplier)\n{\n\tif (l2_multiplier != kvm_default_tsc_scaling_ratio)\n\t\treturn mul_u64_u64_shr(l1_multiplier, l2_multiplier,\n\t\t\t\t       kvm_tsc_scaling_ratio_frac_bits);\n\n\treturn l1_multiplier;\n}\nEXPORT_SYMBOL_GPL(kvm_calc_nested_tsc_multiplier);\n\nstatic void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 l1_offset)\n{\n\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t   vcpu->arch.l1_tsc_offset,\n\t\t\t\t   l1_offset);\n\n\tvcpu->arch.l1_tsc_offset = l1_offset;\n\n\t/*\n\t * If we are here because L1 chose not to trap WRMSR to TSC then\n\t * according to the spec this should set L1's TSC (as opposed to\n\t * setting L1's offset for L2).\n\t */\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.tsc_offset = kvm_calc_nested_tsc_offset(\n\t\t\tl1_offset,\n\t\t\tstatic_call(kvm_x86_get_l2_tsc_offset)(vcpu),\n\t\t\tstatic_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));\n\telse\n\t\tvcpu->arch.tsc_offset = l1_offset;\n\n\tstatic_call(kvm_x86_write_tsc_offset)(vcpu, vcpu->arch.tsc_offset);\n}\n\nstatic void kvm_vcpu_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 l1_multiplier)\n{\n\tvcpu->arch.l1_tsc_scaling_ratio = l1_multiplier;\n\n\t/* Userspace is changing the multiplier while L2 is active */\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.tsc_scaling_ratio = kvm_calc_nested_tsc_multiplier(\n\t\t\tl1_multiplier,\n\t\t\tstatic_call(kvm_x86_get_l2_tsc_multiplier)(vcpu));\n\telse\n\t\tvcpu->arch.tsc_scaling_ratio = l1_multiplier;\n\n\tif (kvm_has_tsc_control)\n\t\tstatic_call(kvm_x86_write_tsc_multiplier)(\n\t\t\tvcpu, vcpu->arch.tsc_scaling_ratio);\n}\n\nstatic inline bool kvm_check_tsc_unstable(void)\n{\n#ifdef CONFIG_X86_64\n\t/*\n\t * TSC is marked unstable when we're running on Hyper-V,\n\t * 'TSC page' clocksource is good.\n\t */\n\tif (pvclock_gtod_data.clock.vclock_mode == VDSO_CLOCKMODE_HVCLOCK)\n\t\treturn false;\n#endif\n\treturn check_tsc_unstable();\n}\n\n/*\n * Infers attempts to synchronize the guest's tsc from host writes. Sets the\n * offset for the vcpu and tracks the TSC matching generation that the vcpu\n * participates in.\n */\nstatic void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,\n\t\t\t\t  u64 ns, bool matched)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tlockdep_assert_held(&kvm->arch.tsc_write_lock);\n\n\t/*\n\t * We also track th most recent recorded KHZ, write and time to\n\t * allow the matching interval to be extended at each write.\n\t */\n\tkvm->arch.last_tsc_nsec = ns;\n\tkvm->arch.last_tsc_write = tsc;\n\tkvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\tkvm->arch.last_tsc_offset = offset;\n\n\tvcpu->arch.last_guest_tsc = tsc;\n\n\tkvm_vcpu_write_tsc_offset(vcpu, offset);\n\n\tif (!matched) {\n\t\t/*\n\t\t * We split periods of matched TSC writes into generations.\n\t\t * For each generation, we track the original measured\n\t\t * nanosecond time, offset, and write, so if TSCs are in\n\t\t * sync, we can match exact offset, and if not, we can match\n\t\t * exact software computation in compute_guest_tsc()\n\t\t *\n\t\t * These values are tracked in kvm->arch.cur_xxx variables.\n\t\t */\n\t\tkvm->arch.cur_tsc_generation++;\n\t\tkvm->arch.cur_tsc_nsec = ns;\n\t\tkvm->arch.cur_tsc_write = tsc;\n\t\tkvm->arch.cur_tsc_offset = offset;\n\t\tkvm->arch.nr_vcpus_matched_tsc = 0;\n\t} else if (vcpu->arch.this_tsc_generation != kvm->arch.cur_tsc_generation) {\n\t\tkvm->arch.nr_vcpus_matched_tsc++;\n\t}\n\n\t/* Keep track of which generation this VCPU has synchronized to */\n\tvcpu->arch.this_tsc_generation = kvm->arch.cur_tsc_generation;\n\tvcpu->arch.this_tsc_nsec = kvm->arch.cur_tsc_nsec;\n\tvcpu->arch.this_tsc_write = kvm->arch.cur_tsc_write;\n\n\tkvm_track_tsc_matching(vcpu);\n}\n\nstatic void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tu64 offset, ns, elapsed;\n\tunsigned long flags;\n\tbool matched = false;\n\tbool synchronizing = false;\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\toffset = kvm_compute_l1_tsc_offset(vcpu, data);\n\tns = get_kvmclock_base_ns();\n\telapsed = ns - kvm->arch.last_tsc_nsec;\n\n\tif (vcpu->arch.virtual_tsc_khz) {\n\t\tif (data == 0) {\n\t\t\t/*\n\t\t\t * detection of vcpu initialization -- need to sync\n\t\t\t * with other vCPUs. This particularly helps to keep\n\t\t\t * kvm_clock stable after CPU hotplug\n\t\t\t */\n\t\t\tsynchronizing = true;\n\t\t} else {\n\t\t\tu64 tsc_exp = kvm->arch.last_tsc_write +\n\t\t\t\t\t\tnsec_to_cycles(vcpu, elapsed);\n\t\t\tu64 tsc_hz = vcpu->arch.virtual_tsc_khz * 1000LL;\n\t\t\t/*\n\t\t\t * Special case: TSC write with a small delta (1 second)\n\t\t\t * of virtual cycle time against real time is\n\t\t\t * interpreted as an attempt to synchronize the CPU.\n\t\t\t */\n\t\t\tsynchronizing = data < tsc_exp + tsc_hz &&\n\t\t\t\t\tdata + tsc_hz > tsc_exp;\n\t\t}\n\t}\n\n\t/*\n\t * For a reliable TSC, we can match TSC offsets, and for an unstable\n\t * TSC, we add elapsed time in this computation.  We could let the\n\t * compensation code attempt to catch up if we fall behind, but\n\t * it's better to try to match offsets from the beginning.\n         */\n\tif (synchronizing &&\n\t    vcpu->arch.virtual_tsc_khz == kvm->arch.last_tsc_khz) {\n\t\tif (!kvm_check_tsc_unstable()) {\n\t\t\toffset = kvm->arch.cur_tsc_offset;\n\t\t} else {\n\t\t\tu64 delta = nsec_to_cycles(vcpu, elapsed);\n\t\t\tdata += delta;\n\t\t\toffset = kvm_compute_l1_tsc_offset(vcpu, data);\n\t\t}\n\t\tmatched = true;\n\t}\n\n\t__kvm_synchronize_tsc(vcpu, offset, data, ns, matched);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n}\n\nstatic inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   s64 adjustment)\n{\n\tu64 tsc_offset = vcpu->arch.l1_tsc_offset;\n\tkvm_vcpu_write_tsc_offset(vcpu, tsc_offset + adjustment);\n}\n\nstatic inline void adjust_tsc_offset_host(struct kvm_vcpu *vcpu, s64 adjustment)\n{\n\tif (vcpu->arch.l1_tsc_scaling_ratio != kvm_default_tsc_scaling_ratio)\n\t\tWARN_ON(adjustment < 0);\n\tadjustment = kvm_scale_tsc((u64) adjustment,\n\t\t\t\t   vcpu->arch.l1_tsc_scaling_ratio);\n\tadjust_tsc_offset_guest(vcpu, adjustment);\n}\n\n#ifdef CONFIG_X86_64\n\nstatic u64 read_tsc(void)\n{\n\tu64 ret = (u64)rdtsc_ordered();\n\tu64 last = pvclock_gtod_data.clock.cycle_last;\n\n\tif (likely(ret >= last))\n\t\treturn ret;\n\n\t/*\n\t * GCC likes to generate cmov here, but this branch is extremely\n\t * predictable (it's just a function of time and the likely is\n\t * very likely) and there's a data dependence, so force GCC\n\t * to generate a branch instead.  I don't barrier() because\n\t * we don't actually need a barrier, and if this function\n\t * ever gets inlined it will generate worse code.\n\t */\n\tasm volatile (\"\");\n\treturn last;\n}\n\nstatic inline u64 vgettsc(struct pvclock_clock *clock, u64 *tsc_timestamp,\n\t\t\t  int *mode)\n{\n\tlong v;\n\tu64 tsc_pg_val;\n\n\tswitch (clock->vclock_mode) {\n\tcase VDSO_CLOCKMODE_HVCLOCK:\n\t\ttsc_pg_val = hv_read_tsc_page_tsc(hv_get_tsc_page(),\n\t\t\t\t\t\t  tsc_timestamp);\n\t\tif (tsc_pg_val != U64_MAX) {\n\t\t\t/* TSC page valid */\n\t\t\t*mode = VDSO_CLOCKMODE_HVCLOCK;\n\t\t\tv = (tsc_pg_val - clock->cycle_last) &\n\t\t\t\tclock->mask;\n\t\t} else {\n\t\t\t/* TSC page invalid */\n\t\t\t*mode = VDSO_CLOCKMODE_NONE;\n\t\t}\n\t\tbreak;\n\tcase VDSO_CLOCKMODE_TSC:\n\t\t*mode = VDSO_CLOCKMODE_TSC;\n\t\t*tsc_timestamp = read_tsc();\n\t\tv = (*tsc_timestamp - clock->cycle_last) &\n\t\t\tclock->mask;\n\t\tbreak;\n\tdefault:\n\t\t*mode = VDSO_CLOCKMODE_NONE;\n\t}\n\n\tif (*mode == VDSO_CLOCKMODE_NONE)\n\t\t*tsc_timestamp = v = 0;\n\n\treturn v * clock->mult;\n}\n\nstatic int do_monotonic_raw(s64 *t, u64 *tsc_timestamp)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tns = gtod->raw_clock.base_cycles;\n\t\tns += vgettsc(&gtod->raw_clock, tsc_timestamp, &mode);\n\t\tns >>= gtod->raw_clock.shift;\n\t\tns += ktime_to_ns(ktime_add(gtod->raw_clock.offset, gtod->offs_boot));\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\t*t = ns;\n\n\treturn mode;\n}\n\nstatic int do_realtime(struct timespec64 *ts, u64 *tsc_timestamp)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tunsigned long seq;\n\tint mode;\n\tu64 ns;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&gtod->seq);\n\t\tts->tv_sec = gtod->wall_time_sec;\n\t\tns = gtod->clock.base_cycles;\n\t\tns += vgettsc(&gtod->clock, tsc_timestamp, &mode);\n\t\tns >>= gtod->clock.shift;\n\t} while (unlikely(read_seqcount_retry(&gtod->seq, seq)));\n\n\tts->tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &ns);\n\tts->tv_nsec = ns;\n\n\treturn mode;\n}\n\n/* returns true if host is using TSC based clocksource */\nstatic bool kvm_get_time_and_clockread(s64 *kernel_ns, u64 *tsc_timestamp)\n{\n\t/* checked again under seqlock below */\n\tif (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))\n\t\treturn false;\n\n\treturn gtod_is_based_on_tsc(do_monotonic_raw(kernel_ns,\n\t\t\t\t\t\t      tsc_timestamp));\n}\n\n/* returns true if host is using TSC based clocksource */\nstatic bool kvm_get_walltime_and_clockread(struct timespec64 *ts,\n\t\t\t\t\t   u64 *tsc_timestamp)\n{\n\t/* checked again under seqlock below */\n\tif (!gtod_is_based_on_tsc(pvclock_gtod_data.clock.vclock_mode))\n\t\treturn false;\n\n\treturn gtod_is_based_on_tsc(do_realtime(ts, tsc_timestamp));\n}\n#endif\n\n/*\n *\n * Assuming a stable TSC across physical CPUS, and a stable TSC\n * across virtual CPUs, the following condition is possible.\n * Each numbered line represents an event visible to both\n * CPUs at the next numbered event.\n *\n * \"timespecX\" represents host monotonic time. \"tscX\" represents\n * RDTSC value.\n *\n * \t\tVCPU0 on CPU0\t\t|\tVCPU1 on CPU1\n *\n * 1.  read timespec0,tsc0\n * 2.\t\t\t\t\t| timespec1 = timespec0 + N\n * \t\t\t\t\t| tsc1 = tsc0 + M\n * 3. transition to guest\t\t| transition to guest\n * 4. ret0 = timespec0 + (rdtsc - tsc0) |\n * 5.\t\t\t\t        | ret1 = timespec1 + (rdtsc - tsc1)\n * \t\t\t\t        | ret1 = timespec0 + N + (rdtsc - (tsc0 + M))\n *\n * Since ret0 update is visible to VCPU1 at time 5, to obey monotonicity:\n *\n * \t- ret0 < ret1\n *\t- timespec0 + (rdtsc - tsc0) < timespec0 + N + (rdtsc - (tsc0 + M))\n *\t\t...\n *\t- 0 < N - M => M < N\n *\n * That is, when timespec0 != timespec1, M < N. Unfortunately that is not\n * always the case (the difference between two distinct xtime instances\n * might be smaller then the difference between corresponding TSC reads,\n * when updating guest vcpus pvclock areas).\n *\n * To avoid that problem, do not allow visibility of distinct\n * system_timestamp/tsc_timestamp values simultaneously: use a master\n * copy of host monotonic time values. Update that master copy\n * in lockstep.\n *\n * Rely on synchronization of host TSCs and guest TSCs for monotonicity.\n *\n */\n\nstatic void pvclock_update_vm_gtod_copy(struct kvm *kvm)\n{\n#ifdef CONFIG_X86_64\n\tstruct kvm_arch *ka = &kvm->arch;\n\tint vclock_mode;\n\tbool host_tsc_clocksource, vcpus_matched;\n\n\tlockdep_assert_held(&kvm->arch.tsc_write_lock);\n\tvcpus_matched = (ka->nr_vcpus_matched_tsc + 1 ==\n\t\t\tatomic_read(&kvm->online_vcpus));\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\thost_tsc_clocksource = kvm_get_time_and_clockread(\n\t\t\t\t\t&ka->master_kernel_ns,\n\t\t\t\t\t&ka->master_cycle_now);\n\n\tka->use_master_clock = host_tsc_clocksource && vcpus_matched\n\t\t\t\t&& !ka->backwards_tsc_observed\n\t\t\t\t&& !ka->boot_vcpu_runs_old_kvmclock;\n\n\tif (ka->use_master_clock)\n\t\tatomic_set(&kvm_guest_has_master_clock, 1);\n\n\tvclock_mode = pvclock_gtod_data.clock.vclock_mode;\n\ttrace_kvm_update_master_clock(ka->use_master_clock, vclock_mode,\n\t\t\t\t\tvcpus_matched);\n#endif\n}\n\nstatic void kvm_make_mclock_inprogress_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MCLOCK_INPROGRESS);\n}\n\nstatic void __kvm_start_pvclock_update(struct kvm *kvm)\n{\n\traw_spin_lock_irq(&kvm->arch.tsc_write_lock);\n\twrite_seqcount_begin(&kvm->arch.pvclock_sc);\n}\n\nstatic void kvm_start_pvclock_update(struct kvm *kvm)\n{\n\tkvm_make_mclock_inprogress_request(kvm);\n\n\t/* no guest entries from this point */\n\t__kvm_start_pvclock_update(kvm);\n}\n\nstatic void kvm_end_pvclock_update(struct kvm *kvm)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\twrite_seqcount_end(&ka->pvclock_sc);\n\traw_spin_unlock_irq(&ka->tsc_write_lock);\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\t/* guest entries allowed */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_clear_request(KVM_REQ_MCLOCK_INPROGRESS, vcpu);\n}\n\nstatic void kvm_update_masterclock(struct kvm *kvm)\n{\n\tkvm_hv_request_tsc_page_update(kvm);\n\tkvm_start_pvclock_update(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\tkvm_end_pvclock_update(kvm);\n}\n\n/* Called within read_seqcount_begin/retry for kvm->pvclock_sc.  */\nstatic void __get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\n\t/* both __this_cpu_read() and rdtsc() should be on the same cpu */\n\tget_cpu();\n\n\tdata->flags = 0;\n\tif (ka->use_master_clock && __this_cpu_read(cpu_tsc_khz)) {\n#ifdef CONFIG_X86_64\n\t\tstruct timespec64 ts;\n\n\t\tif (kvm_get_walltime_and_clockread(&ts, &data->host_tsc)) {\n\t\t\tdata->realtime = ts.tv_nsec + NSEC_PER_SEC * ts.tv_sec;\n\t\t\tdata->flags |= KVM_CLOCK_REALTIME | KVM_CLOCK_HOST_TSC;\n\t\t} else\n#endif\n\t\tdata->host_tsc = rdtsc();\n\n\t\tdata->flags |= KVM_CLOCK_TSC_STABLE;\n\t\thv_clock.tsc_timestamp = ka->master_cycle_now;\n\t\thv_clock.system_time = ka->master_kernel_ns + ka->kvmclock_offset;\n\t\tkvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,\n\t\t\t\t   &hv_clock.tsc_shift,\n\t\t\t\t   &hv_clock.tsc_to_system_mul);\n\t\tdata->clock = __pvclock_read_cycles(&hv_clock, data->host_tsc);\n\t} else {\n\t\tdata->clock = get_kvmclock_base_ns() + ka->kvmclock_offset;\n\t}\n\n\tput_cpu();\n}\n\nstatic void get_kvmclock(struct kvm *kvm, struct kvm_clock_data *data)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&ka->pvclock_sc);\n\t\t__get_kvmclock(kvm, data);\n\t} while (read_seqcount_retry(&ka->pvclock_sc, seq));\n}\n\nu64 get_kvmclock_ns(struct kvm *kvm)\n{\n\tstruct kvm_clock_data data;\n\n\tget_kvmclock(kvm, &data);\n\treturn data.clock;\n}\n\nstatic void kvm_setup_guest_pvclock(struct kvm_vcpu *v,\n\t\t\t\t    struct gfn_to_pfn_cache *gpc,\n\t\t\t\t    unsigned int offset)\n{\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct pvclock_vcpu_time_info *guest_hv_clock;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&gpc->lock, flags);\n\twhile (!kvm_gfn_to_pfn_cache_check(v->kvm, gpc, gpc->gpa,\n\t\t\t\t\t   offset + sizeof(*guest_hv_clock))) {\n\t\tread_unlock_irqrestore(&gpc->lock, flags);\n\n\t\tif (kvm_gfn_to_pfn_cache_refresh(v->kvm, gpc, gpc->gpa,\n\t\t\t\t\t\t offset + sizeof(*guest_hv_clock)))\n\t\t\treturn;\n\n\t\tread_lock_irqsave(&gpc->lock, flags);\n\t}\n\n\tguest_hv_clock = (void *)(gpc->khva + offset);\n\n\t/*\n\t * This VCPU is paused, but it's legal for a guest to read another\n\t * VCPU's kvmclock, so we really have to follow the specification where\n\t * it says that version is odd if data is being modified, and even after\n\t * it is consistent.\n\t */\n\n\tguest_hv_clock->version = vcpu->hv_clock.version = (guest_hv_clock->version + 1) | 1;\n\tsmp_wmb();\n\n\t/* retain PVCLOCK_GUEST_STOPPED if set in guest copy */\n\tvcpu->hv_clock.flags |= (guest_hv_clock->flags & PVCLOCK_GUEST_STOPPED);\n\n\tif (vcpu->pvclock_set_guest_stopped_request) {\n\t\tvcpu->hv_clock.flags |= PVCLOCK_GUEST_STOPPED;\n\t\tvcpu->pvclock_set_guest_stopped_request = false;\n\t}\n\n\tmemcpy(guest_hv_clock, &vcpu->hv_clock, sizeof(*guest_hv_clock));\n\tsmp_wmb();\n\n\tguest_hv_clock->version = ++vcpu->hv_clock.version;\n\n\tmark_page_dirty_in_slot(v->kvm, gpc->memslot, gpc->gpa >> PAGE_SHIFT);\n\tread_unlock_irqrestore(&gpc->lock, flags);\n\n\ttrace_kvm_pvclock_update(v->vcpu_id, &vcpu->hv_clock);\n}\n\nstatic int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n\tunsigned long flags, tgt_tsc_khz;\n\tunsigned seq;\n\tstruct kvm_vcpu_arch *vcpu = &v->arch;\n\tstruct kvm_arch *ka = &v->kvm->arch;\n\ts64 kernel_ns;\n\tu64 tsc_timestamp, host_tsc;\n\tu8 pvclock_flags;\n\tbool use_master_clock;\n\n\tkernel_ns = 0;\n\thost_tsc = 0;\n\n\t/*\n\t * If the host uses TSC clock, then passthrough TSC as stable\n\t * to the guest.\n\t */\n\tdo {\n\t\tseq = read_seqcount_begin(&ka->pvclock_sc);\n\t\tuse_master_clock = ka->use_master_clock;\n\t\tif (use_master_clock) {\n\t\t\thost_tsc = ka->master_cycle_now;\n\t\t\tkernel_ns = ka->master_kernel_ns;\n\t\t}\n\t} while (read_seqcount_retry(&ka->pvclock_sc, seq));\n\n\t/* Keep irq disabled to prevent changes to the clock */\n\tlocal_irq_save(flags);\n\ttgt_tsc_khz = __this_cpu_read(cpu_tsc_khz);\n\tif (unlikely(tgt_tsc_khz == 0)) {\n\t\tlocal_irq_restore(flags);\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\t\treturn 1;\n\t}\n\tif (!use_master_clock) {\n\t\thost_tsc = rdtsc();\n\t\tkernel_ns = get_kvmclock_base_ns();\n\t}\n\n\ttsc_timestamp = kvm_read_l1_tsc(v, host_tsc);\n\n\t/*\n\t * We may have to catch up the TSC to match elapsed wall clock\n\t * time for two reasons, even if kvmclock is used.\n\t *   1) CPU could have been running below the maximum TSC rate\n\t *   2) Broken TSC compensation resets the base at each VCPU\n\t *      entry to avoid unknown leaps of TSC even when running\n\t *      again on the same CPU.  This may cause apparent elapsed\n\t *      time to disappear, and the guest to stand still or run\n\t *\tvery slowly.\n\t */\n\tif (vcpu->tsc_catchup) {\n\t\tu64 tsc = compute_guest_tsc(v, kernel_ns);\n\t\tif (tsc > tsc_timestamp) {\n\t\t\tadjust_tsc_offset_guest(v, tsc - tsc_timestamp);\n\t\t\ttsc_timestamp = tsc;\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n\n\t/* With all the info we got, fill in the values */\n\n\tif (kvm_has_tsc_control)\n\t\ttgt_tsc_khz = kvm_scale_tsc(tgt_tsc_khz,\n\t\t\t\t\t    v->arch.l1_tsc_scaling_ratio);\n\n\tif (unlikely(vcpu->hw_tsc_khz != tgt_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, tgt_tsc_khz * 1000LL,\n\t\t\t\t   &vcpu->hv_clock.tsc_shift,\n\t\t\t\t   &vcpu->hv_clock.tsc_to_system_mul);\n\t\tvcpu->hw_tsc_khz = tgt_tsc_khz;\n\t}\n\n\tvcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n\tvcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n\tvcpu->last_guest_tsc = tsc_timestamp;\n\n\t/* If the host uses TSC clocksource, then it is stable */\n\tpvclock_flags = 0;\n\tif (use_master_clock)\n\t\tpvclock_flags |= PVCLOCK_TSC_STABLE_BIT;\n\n\tvcpu->hv_clock.flags = pvclock_flags;\n\n\tif (vcpu->pv_time.active)\n\t\tkvm_setup_guest_pvclock(v, &vcpu->pv_time, 0);\n\tif (vcpu->xen.vcpu_info_cache.active)\n\t\tkvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_info_cache,\n\t\t\t\t\toffsetof(struct compat_vcpu_info, time));\n\tif (vcpu->xen.vcpu_time_info_cache.active)\n\t\tkvm_setup_guest_pvclock(v, &vcpu->xen.vcpu_time_info_cache, 0);\n\tkvm_hv_setup_tsc_page(v->kvm, &vcpu->hv_clock);\n\treturn 0;\n}\n\n/*\n * kvmclock updates which are isolated to a given vcpu, such as\n * vcpu->cpu migration, should not allow system_timestamp from\n * the rest of the vcpus to remain static. Otherwise ntp frequency\n * correction applies to one vcpu's system_timestamp but not\n * the others.\n *\n * So in those cases, request a kvmclock update for all vcpus.\n * We need to rate-limit these requests though, as they can\n * considerably slow guests that have a large number of vcpus.\n * The time for a remote vcpu to update its kvmclock is bound\n * by the delay we use to rate-limit the updates.\n */\n\n#define KVMCLOCK_UPDATE_DELAY msecs_to_jiffies(100)\n\nstatic void kvmclock_update_fn(struct work_struct *work)\n{\n\tunsigned long i;\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_update_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t}\n}\n\nstatic void kvm_gen_kvmclock_update(struct kvm_vcpu *v)\n{\n\tstruct kvm *kvm = v->kvm;\n\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work,\n\t\t\t\t\tKVMCLOCK_UPDATE_DELAY);\n}\n\n#define KVMCLOCK_SYNC_PERIOD (300 * HZ)\n\nstatic void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\n\tif (!kvmclock_periodic_sync)\n\t\treturn;\n\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}\n\n/*\n * On AMD, HWCR[McStatusWrEn] controls whether setting MCi_STATUS results in #GP.\n */\nstatic bool can_set_mci_status(struct kvm_vcpu *vcpu)\n{\n\t/* McStatusWrEn enabled? */\n\tif (guest_cpuid_is_amd_or_hygon(vcpu))\n\t\treturn !!(vcpu->arch.msr_hwcr & BIT_ULL(18));\n\n\treturn false;\n}\n\nstatic int set_msr_mce(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P) &&\n\t\t    (data || !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = array_index_nospec(\n\t\t\t\tmsr - MSR_IA32_MC0_CTL,\n\t\t\t\tMSR_IA32_MCx_CTL(bank_num) - MSR_IA32_MC0_CTL);\n\n\t\t\t/* only 0 or all 1s can be written to IA32_MCi_CTL\n\t\t\t * some Linux kernels though clear bit 10 in bank 4 to\n\t\t\t * workaround a BIOS/GART TBL issue on AMD K8s, ignore\n\t\t\t * this to avoid an uncatched #GP in the guest\n\t\t\t */\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\n\t\t\t/* MCi_STATUS */\n\t\t\tif (!msr_info->host_initiated &&\n\t\t\t    (offset & 0x3) == 1 && data != 0) {\n\t\t\t\tif (!can_set_mci_status(vcpu))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline bool kvm_pv_async_pf_enabled(struct kvm_vcpu *vcpu)\n{\n\tu64 mask = KVM_ASYNC_PF_ENABLED | KVM_ASYNC_PF_DELIVERY_AS_INT;\n\n\treturn (vcpu->arch.apf.msr_en_val & mask) == mask;\n}\n\nstatic int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n{\n\tgpa_t gpa = data & ~0x3f;\n\n\t/* Bits 4:5 are reserved, Should be zero */\n\tif (data & 0x30)\n\t\treturn 1;\n\n\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_VMEXIT) &&\n\t    (data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT))\n\t\treturn 1;\n\n\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT) &&\n\t    (data & KVM_ASYNC_PF_DELIVERY_AS_INT))\n\t\treturn 1;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn data ? 1 : 0;\n\n\tvcpu->arch.apf.msr_en_val = data;\n\n\tif (!kvm_pv_async_pf_enabled(vcpu)) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.apf.data, gpa,\n\t\t\t\t\tsizeof(u64)))\n\t\treturn 1;\n\n\tvcpu->arch.apf.send_user_only = !(data & KVM_ASYNC_PF_SEND_ALWAYS);\n\tvcpu->arch.apf.delivery_as_pf_vmexit = data & KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT;\n\n\tkvm_async_pf_wakeup_all(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_pv_enable_async_pf_int(struct kvm_vcpu *vcpu, u64 data)\n{\n\t/* Bits 8-63 are reserved */\n\tif (data >> 8)\n\t\treturn 1;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tvcpu->arch.apf.msr_int_val = data;\n\n\tvcpu->arch.apf.vec = data & KVM_ASYNC_PF_VEC_MASK;\n\n\treturn 0;\n}\n\nstatic void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tkvm_gfn_to_pfn_cache_destroy(vcpu->kvm, &vcpu->arch.pv_time);\n\tvcpu->arch.time = 0;\n}\n\nstatic void kvm_vcpu_flush_tlb_all(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tstatic_call(kvm_x86_flush_tlb_all)(vcpu);\n}\n\nstatic void kvm_vcpu_flush_tlb_guest(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\n\tif (!tdp_enabled) {\n\t\t/*\n\t\t * A TLB flush on behalf of the guest is equivalent to\n\t\t * INVPCID(all), toggling CR4.PGE, etc., which requires\n\t\t * a forced sync of the shadow page tables.  Ensure all the\n\t\t * roots are synced and the guest TLB in hardware is clean.\n\t\t */\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_sync_prev_roots(vcpu);\n\t}\n\n\tstatic_call(kvm_x86_flush_tlb_guest)(vcpu);\n}\n\n\nstatic inline void kvm_vcpu_flush_tlb_current(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.tlb_flush;\n\tstatic_call(kvm_x86_flush_tlb_current)(vcpu);\n}\n\n/*\n * Service \"local\" TLB flush requests, which are specific to the current MMU\n * context.  In addition to the generic event handling in vcpu_enter_guest(),\n * TLB flushes that are targeted at an MMU context also need to be serviced\n * prior before nested VM-Enter/VM-Exit.\n */\nvoid kvm_service_local_tlb_flush_requests(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_check_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu))\n\t\tkvm_vcpu_flush_tlb_current(vcpu);\n\n\tif (kvm_check_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu))\n\t\tkvm_vcpu_flush_tlb_guest(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_service_local_tlb_flush_requests);\n\nstatic void record_steal_time(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tu64 steal;\n\tu32 version;\n\n\tif (kvm_xen_msr_enabled(vcpu->kvm)) {\n\t\tkvm_xen_runstate_set_running(vcpu);\n\t\treturn;\n\t}\n\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\n\tslots = kvm_memslots(vcpu->kvm);\n\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot)) {\n\t\tgfn_t gfn = vcpu->arch.st.msr_val & KVM_STEAL_VALID_BITS;\n\n\t\t/* We rely on the fact that it fits in a single page. */\n\t\tBUILD_BUG_ON((sizeof(*st) - 1) & KVM_STEAL_VALID_BITS);\n\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, gfn, sizeof(*st)) ||\n\t\t    kvm_is_error_hva(ghc->hva) || !ghc->memslot)\n\t\t\treturn;\n\t}\n\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\t/*\n\t * Doing a TLB flush here, on the guest's behalf, can avoid\n\t * expensive IPIs.\n\t */\n\tif (guest_pv_has(vcpu, KVM_FEATURE_PV_TLB_FLUSH)) {\n\t\tu8 st_preempted = 0;\n\t\tint err = -EFAULT;\n\n\t\tif (!user_access_begin(st, sizeof(*st)))\n\t\t\treturn;\n\n\t\tasm volatile(\"1: xchgb %0, %2\\n\"\n\t\t\t     \"xor %1, %1\\n\"\n\t\t\t     \"2:\\n\"\n\t\t\t     _ASM_EXTABLE_UA(1b, 2b)\n\t\t\t     : \"+q\" (st_preempted),\n\t\t\t       \"+&r\" (err),\n\t\t\t       \"+m\" (st->preempted));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tuser_access_end();\n\n\t\tvcpu->arch.st.preempted = 0;\n\n\t\ttrace_kvm_pv_tlb_flush(vcpu->vcpu_id,\n\t\t\t\t       st_preempted & KVM_VCPU_FLUSH_TLB);\n\t\tif (st_preempted & KVM_VCPU_FLUSH_TLB)\n\t\t\tkvm_vcpu_flush_tlb_guest(vcpu);\n\n\t\tif (!user_access_begin(st, sizeof(*st)))\n\t\t\tgoto dirty;\n\t} else {\n\t\tif (!user_access_begin(st, sizeof(*st)))\n\t\t\treturn;\n\n\t\tunsafe_put_user(0, &st->preempted, out);\n\t\tvcpu->arch.st.preempted = 0;\n\t}\n\n\tunsafe_get_user(version, &st->version, out);\n\tif (version & 1)\n\t\tversion += 1;  /* first time write, random junk */\n\n\tversion += 1;\n\tunsafe_put_user(version, &st->version, out);\n\n\tsmp_wmb();\n\n\tunsafe_get_user(steal, &st->steal, out);\n\tsteal += current->sched_info.run_delay -\n\t\tvcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tunsafe_put_user(steal, &st->steal, out);\n\n\tversion += 1;\n\tunsafe_put_user(version, &st->version, out);\n\n out:\n\tuser_access_end();\n dirty:\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tif (msr && msr == vcpu->kvm->arch.xen_hvm_config.msr)\n\t\treturn kvm_xen_write_hypercall_page(vcpu, data);\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tbreak;\n\n\tcase MSR_IA32_UCODE_REV:\n\t\tif (msr_info->host_initiated)\n\t\t\tvcpu->arch.microcode_version = data;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.arch_capabilities = data;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES: {\n\t\tstruct kvm_msr_entry msr_ent = {.index = msr, .data = 0};\n\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tif (kvm_get_msr_feature(&msr_ent))\n\t\t\treturn 1;\n\t\tif (data & ~msr_ent.data)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.perf_capabilities = data;\n\n\t\treturn 0;\n\t\t}\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, msr_info);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\n\t\t/* Handle McStatusWrEn */\n\t\tif (data == BIT_ULL(18)) {\n\t\t\tvcpu->arch.msr_hwcr = data;\n\t\t} else if (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSC_DEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t\t/* Before back to guest, tsc_timestamp must be adjusted\n\t\t\t\t * as well, otherwise guest's percpu pvclock time could jump.\n\t\t\t\t */\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&\n\t\t    ((vcpu->arch.ia32_misc_enable_msr ^ data) & MSR_IA32_MISC_ENABLE_MWAIT)) {\n\t\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))\n\t\t\t\treturn 1;\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t\tkvm_update_cpuid_runtime(vcpu);\n\t\t} else {\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tvcpu->arch.msr_ia32_power_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tif (msr_info->host_initiated) {\n\t\t\tkvm_synchronize_tsc(vcpu, data);\n\t\t} else {\n\t\t\tu64 adj = kvm_compute_l1_tsc_offset(vcpu, data) - vcpu->arch.l1_tsc_offset;\n\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr += adj;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\t/*\n\t\t * KVM supports exposing PT to the guest, but does not support\n\t\t * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than\n\t\t * XSAVES/XRSTORS to save/restore PT MSRs.\n\t\t */\n\t\tif (data & ~supported_xss)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tkvm_update_cpuid_runtime(vcpu);\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smi_count = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data, 0);\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data, 0);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tkvm_write_system_time(vcpu, data, false, msr_info->host_initiated);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tkvm_write_system_time(vcpu, data, true,  msr_info->host_initiated);\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))\n\t\t\treturn 1;\n\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_INT:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\n\t\tif (kvm_pv_enable_async_pf_int(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_ACK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\t\tif (data & 0x1) {\n\t\t\tvcpu->arch.apf.pageready_pending = false;\n\t\t\tkvm_check_async_pf_completion(vcpu);\n\t\t}\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))\n\t\t\treturn 1;\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))\n\t\t\treturn 1;\n\n\t\tif (kvm_lapic_set_pv_eoi(vcpu, data, sizeof(u8)))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))\n\t\t\treturn 1;\n\n\t\t/* only enable bit supported */\n\t\tif (data & (-1ULL << 1))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.msr_kvm_poll_control = data;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr_info);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true;\n\t\tfallthrough;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tif (report_ignored_msrs)\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\tmsr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated ||\n\t\t    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&\n\t\t     cpuid_fault_enabled(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_platform_info = data;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tif (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||\n\t\t    (data & MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &&\n\t\t     !supports_cpuid_fault(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_misc_features_enables = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_IA32_XFD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_guest_supported_xfd(vcpu))\n\t\t\treturn 1;\n\n\t\tfpu_update_guest_xfd(&vcpu->arch.guest_fpu, data);\n\t\tbreak;\n\tcase MSR_IA32_XFD_ERR:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_guest_supported_xfd(vcpu))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.guest_fpu.xfd_err = data;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_set_msr_common);\n\nstatic int get_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tu64 data;\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\n\tswitch (msr) {\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\t\tdata = 0;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CAP:\n\t\tdata = vcpu->arch.mcg_cap;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P) && !host)\n\t\t\treturn 1;\n\t\tdata = vcpu->arch.mcg_ctl;\n\t\tbreak;\n\tcase MSR_IA32_MCG_STATUS:\n\t\tdata = vcpu->arch.mcg_status;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MCx_CTL(bank_num)) {\n\t\t\tu32 offset = array_index_nospec(\n\t\t\t\tmsr - MSR_IA32_MC0_CTL,\n\t\t\t\tMSR_IA32_MCx_CTL(bank_num) - MSR_IA32_MC0_CTL);\n\n\t\t\tdata = vcpu->arch.mce_banks[offset];\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_AMD64_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_IA32_PERF_CTL:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t/*\n\t * Intel Sandy Bridge CPUs must support the RAPL (running average power\n\t * limit) MSRs. Just return 0, as we do not want to expose the host\n\t * data here. Do not conditionalize this on CPUID, as KVM does not do\n\t * so for existing CPU-specific MSRs.\n\t */\n\tcase MSR_RAPL_POWER_UNIT:\n\tcase MSR_PP0_ENERGY_STATUS:\t/* Power plane 0 (core) */\n\tcase MSR_PP1_ENERGY_STATUS:\t/* Power plane 1 (graphics uncore) */\n\tcase MSR_PKG_ENERGY_STATUS:\t/* Total package */\n\tcase MSR_DRAM_ENERGY_STATUS:\t/* DRAM controller */\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info);\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = vcpu->arch.microcode_version;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.arch_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_PERF_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_PDCM))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.perf_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tmsr_info->data = vcpu->arch.msr_ia32_power_ctl;\n\t\tbreak;\n\tcase MSR_IA32_TSC: {\n\t\t/*\n\t\t * Intel SDM states that MSR_IA32_TSC read adds the TSC offset\n\t\t * even when not intercepted. AMD manual doesn't explicitly\n\t\t * state this but appears to behave the same.\n\t\t *\n\t\t * On userspace reads and writes, however, we unconditionally\n\t\t * return L1's TSC value to ensure backwards-compatible\n\t\t * behavior for migration.\n\t\t */\n\t\tu64 offset, ratio;\n\n\t\tif (msr_info->host_initiated) {\n\t\t\toffset = vcpu->arch.l1_tsc_offset;\n\t\t\tratio = vcpu->arch.l1_tsc_scaling_ratio;\n\t\t} else {\n\t\t\toffset = vcpu->arch.tsc_offset;\n\t\t\tratio = vcpu->arch.tsc_scaling_ratio;\n\t\t}\n\n\t\tmsr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;\n\t\tbreak;\n\t}\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0xff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_TSC_DEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tmsr_info->data = vcpu->arch.smi_count;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_CLOCKSOURCE2))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.apf.msr_en_val;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_INT:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.apf.msr_int_val;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_ACK:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_ASYNC_PF_INT))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_STEAL_TIME))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_EOI))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_POLL_CONTROL))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.msr_kvm_poll_control;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data,\n\t\t\t\t   msr_info->host_initiated);\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_SYNDBG_CONTROL ... HV_X64_MSR_SYNDBG_PENDING_BUFFER:\n\tcase HV_X64_MSR_SYNDBG_OPTIONS:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !vcpu->kvm->arch.guest_can_read_msr_platform_info)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.msr_platform_info;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tmsr_info->data = vcpu->arch.msr_misc_features_enables;\n\t\tbreak;\n\tcase MSR_K7_HWCR:\n\t\tmsr_info->data = vcpu->arch.msr_hwcr;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_IA32_XFD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.guest_fpu.fpstate->xfd;\n\t\tbreak;\n\tcase MSR_IA32_XFD_ERR:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XFD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vcpu->arch.guest_fpu.xfd_err;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info);\n\t\treturn KVM_MSR_RET_INVALID;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_get_msr_common);\n\n/*\n * Read or write a bunch of msrs. All parameters are kernel addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i;\n\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\n\treturn i;\n}\n\n/*\n * Read or write a bunch of msrs. Parameters are user addresses.\n *\n * @return number of msrs set successfully.\n */\nstatic int msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs __user *user_msrs,\n\t\t  int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\tunsigned index, u64 *data),\n\t\t  int writeback)\n{\n\tstruct kvm_msrs msrs;\n\tstruct kvm_msr_entry *entries;\n\tint r, n;\n\tunsigned size;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&msrs, user_msrs, sizeof(msrs)))\n\t\tgoto out;\n\n\tr = -E2BIG;\n\tif (msrs.nmsrs >= MAX_IO_MSRS)\n\t\tgoto out;\n\n\tsize = sizeof(struct kvm_msr_entry) * msrs.nmsrs;\n\tentries = memdup_user(user_msrs->entries, size);\n\tif (IS_ERR(entries)) {\n\t\tr = PTR_ERR(entries);\n\t\tgoto out;\n\t}\n\n\tr = n = __msr_io(vcpu, &msrs, entries, do_msr);\n\tif (r < 0)\n\t\tgoto out_free;\n\n\tr = -EFAULT;\n\tif (writeback && copy_to_user(user_msrs->entries, entries, size))\n\t\tgoto out_free;\n\n\tr = n;\n\nout_free:\n\tkfree(entries);\nout:\n\treturn r;\n}\n\nstatic inline bool kvm_can_mwait_in_guest(void)\n{\n\treturn boot_cpu_has(X86_FEATURE_MWAIT) &&\n\t\t!boot_cpu_has_bug(X86_BUG_MONITOR) &&\n\t\tboot_cpu_has(X86_FEATURE_ARAT);\n}\n\nstatic int kvm_ioctl_get_supported_hv_cpuid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_cpuid2 __user *cpuid_arg)\n{\n\tstruct kvm_cpuid2 cpuid;\n\tint r;\n\n\tr = -EFAULT;\n\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\treturn r;\n\n\tr = kvm_get_hv_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\tif (r)\n\t\treturn r;\n\n\tr = -EFAULT;\n\tif (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))\n\t\treturn r;\n\n\treturn 0;\n}\n\nint kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n{\n\tint r = 0;\n\n\tswitch (ext) {\n\tcase KVM_CAP_IRQCHIP:\n\tcase KVM_CAP_HLT:\n\tcase KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n\tcase KVM_CAP_SET_TSS_ADDR:\n\tcase KVM_CAP_EXT_CPUID:\n\tcase KVM_CAP_EXT_EMUL_CPUID:\n\tcase KVM_CAP_CLOCKSOURCE:\n\tcase KVM_CAP_PIT:\n\tcase KVM_CAP_NOP_IO_DELAY:\n\tcase KVM_CAP_MP_STATE:\n\tcase KVM_CAP_SYNC_MMU:\n\tcase KVM_CAP_USER_NMI:\n\tcase KVM_CAP_REINJECT_CONTROL:\n\tcase KVM_CAP_IRQ_INJECT_STATUS:\n\tcase KVM_CAP_IOEVENTFD:\n\tcase KVM_CAP_IOEVENTFD_NO_LENGTH:\n\tcase KVM_CAP_PIT2:\n\tcase KVM_CAP_PIT_STATE2:\n\tcase KVM_CAP_SET_IDENTITY_MAP_ADDR:\n\tcase KVM_CAP_VCPU_EVENTS:\n\tcase KVM_CAP_HYPERV:\n\tcase KVM_CAP_HYPERV_VAPIC:\n\tcase KVM_CAP_HYPERV_SPIN:\n\tcase KVM_CAP_HYPERV_SYNIC:\n\tcase KVM_CAP_HYPERV_SYNIC2:\n\tcase KVM_CAP_HYPERV_VP_INDEX:\n\tcase KVM_CAP_HYPERV_EVENTFD:\n\tcase KVM_CAP_HYPERV_TLBFLUSH:\n\tcase KVM_CAP_HYPERV_SEND_IPI:\n\tcase KVM_CAP_HYPERV_CPUID:\n\tcase KVM_CAP_HYPERV_ENFORCE_CPUID:\n\tcase KVM_CAP_SYS_HYPERV_CPUID:\n\tcase KVM_CAP_PCI_SEGMENT:\n\tcase KVM_CAP_DEBUGREGS:\n\tcase KVM_CAP_X86_ROBUST_SINGLESTEP:\n\tcase KVM_CAP_XSAVE:\n\tcase KVM_CAP_ASYNC_PF:\n\tcase KVM_CAP_ASYNC_PF_INT:\n\tcase KVM_CAP_GET_TSC_KHZ:\n\tcase KVM_CAP_KVMCLOCK_CTRL:\n\tcase KVM_CAP_READONLY_MEM:\n\tcase KVM_CAP_HYPERV_TIME:\n\tcase KVM_CAP_IOAPIC_POLARITY_IGNORED:\n\tcase KVM_CAP_TSC_DEADLINE_TIMER:\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\tcase KVM_CAP_SET_BOOT_CPU_ID:\n \tcase KVM_CAP_SPLIT_IRQCHIP:\n\tcase KVM_CAP_IMMEDIATE_EXIT:\n\tcase KVM_CAP_PMU_EVENT_FILTER:\n\tcase KVM_CAP_GET_MSR_FEATURES:\n\tcase KVM_CAP_MSR_PLATFORM_INFO:\n\tcase KVM_CAP_EXCEPTION_PAYLOAD:\n\tcase KVM_CAP_SET_GUEST_DEBUG:\n\tcase KVM_CAP_LAST_CPU:\n\tcase KVM_CAP_X86_USER_SPACE_MSR:\n\tcase KVM_CAP_X86_MSR_FILTER:\n\tcase KVM_CAP_ENFORCE_PV_FEATURE_CPUID:\n#ifdef CONFIG_X86_SGX_KVM\n\tcase KVM_CAP_SGX_ATTRIBUTE:\n#endif\n\tcase KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:\n\tcase KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:\n\tcase KVM_CAP_SREGS2:\n\tcase KVM_CAP_EXIT_ON_EMULATION_FAILURE:\n\tcase KVM_CAP_VCPU_ATTRIBUTES:\n\tcase KVM_CAP_SYS_ATTRIBUTES:\n\tcase KVM_CAP_VAPIC:\n\tcase KVM_CAP_ENABLE_CAP:\n\t\tr = 1;\n\t\tbreak;\n\tcase KVM_CAP_EXIT_HYPERCALL:\n\t\tr = KVM_EXIT_HYPERCALL_VALID_MASK;\n\t\tbreak;\n\tcase KVM_CAP_SET_GUEST_DEBUG2:\n\t\treturn KVM_GUESTDBG_VALID_MASK;\n#ifdef CONFIG_KVM_XEN\n\tcase KVM_CAP_XEN_HVM:\n\t\tr = KVM_XEN_HVM_CONFIG_HYPERCALL_MSR |\n\t\t    KVM_XEN_HVM_CONFIG_INTERCEPT_HCALL |\n\t\t    KVM_XEN_HVM_CONFIG_SHARED_INFO |\n\t\t    KVM_XEN_HVM_CONFIG_EVTCHN_2LEVEL |\n\t\t    KVM_XEN_HVM_CONFIG_EVTCHN_SEND;\n\t\tif (sched_info_on())\n\t\t\tr |= KVM_XEN_HVM_CONFIG_RUNSTATE;\n\t\tbreak;\n#endif\n\tcase KVM_CAP_SYNC_REGS:\n\t\tr = KVM_SYNC_X86_VALID_FIELDS;\n\t\tbreak;\n\tcase KVM_CAP_ADJUST_CLOCK:\n\t\tr = KVM_CLOCK_VALID_FLAGS;\n\t\tbreak;\n\tcase KVM_CAP_X86_DISABLE_EXITS:\n\t\tr |=  KVM_X86_DISABLE_EXITS_HLT | KVM_X86_DISABLE_EXITS_PAUSE |\n\t\t      KVM_X86_DISABLE_EXITS_CSTATE;\n\t\tif(kvm_can_mwait_in_guest())\n\t\t\tr |= KVM_X86_DISABLE_EXITS_MWAIT;\n\t\tbreak;\n\tcase KVM_CAP_X86_SMM:\n\t\t/* SMBASE is usually relocated above 1M on modern chipsets,\n\t\t * and SMM handlers might indeed rely on 4G segment limits,\n\t\t * so do not report SMM to be available if real mode is\n\t\t * emulated via vm86 mode.  Still, do not go to great lengths\n\t\t * to avoid userspace's usage of the feature, because it is a\n\t\t * fringe case that is not enabled except via specific settings\n\t\t * of the module parameters.\n\t\t */\n\t\tr = static_call(kvm_x86_has_emulated_msr)(kvm, MSR_IA32_SMBASE);\n\t\tbreak;\n\tcase KVM_CAP_NR_VCPUS:\n\t\tr = min_t(unsigned int, num_online_cpus(), KVM_MAX_VCPUS);\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPUS:\n\t\tr = KVM_MAX_VCPUS;\n\t\tbreak;\n\tcase KVM_CAP_MAX_VCPU_ID:\n\t\tr = KVM_MAX_VCPU_IDS;\n\t\tbreak;\n\tcase KVM_CAP_PV_MMU:\t/* obsolete */\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_MCE:\n\t\tr = KVM_MAX_MCE_BANKS;\n\t\tbreak;\n\tcase KVM_CAP_XCRS:\n\t\tr = boot_cpu_has(X86_FEATURE_XSAVE);\n\t\tbreak;\n\tcase KVM_CAP_TSC_CONTROL:\n\tcase KVM_CAP_VM_TSC_CONTROL:\n\t\tr = kvm_has_tsc_control;\n\t\tbreak;\n\tcase KVM_CAP_X2APIC_API:\n\t\tr = KVM_X2APIC_API_VALID_FLAGS;\n\t\tbreak;\n\tcase KVM_CAP_NESTED_STATE:\n\t\tr = kvm_x86_ops.nested_ops->get_state ?\n\t\t\tkvm_x86_ops.nested_ops->get_state(NULL, NULL, 0) : 0;\n\t\tbreak;\n\tcase KVM_CAP_HYPERV_DIRECT_TLBFLUSH:\n\t\tr = kvm_x86_ops.enable_direct_tlbflush != NULL;\n\t\tbreak;\n\tcase KVM_CAP_HYPERV_ENLIGHTENED_VMCS:\n\t\tr = kvm_x86_ops.nested_ops->enable_evmcs != NULL;\n\t\tbreak;\n\tcase KVM_CAP_SMALLER_MAXPHYADDR:\n\t\tr = (int) allow_smaller_maxphyaddr;\n\t\tbreak;\n\tcase KVM_CAP_STEAL_TIME:\n\t\tr = sched_info_on();\n\t\tbreak;\n\tcase KVM_CAP_X86_BUS_LOCK_EXIT:\n\t\tif (kvm_has_bus_lock_exit)\n\t\t\tr = KVM_BUS_LOCK_DETECTION_OFF |\n\t\t\t    KVM_BUS_LOCK_DETECTION_EXIT;\n\t\telse\n\t\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_XSAVE2: {\n\t\tu64 guest_perm = xstate_get_guest_group_perm();\n\n\t\tr = xstate_required_size(supported_xcr0 & guest_perm, false);\n\t\tif (r < sizeof(struct kvm_xsave))\n\t\t\tr = sizeof(struct kvm_xsave);\n\t\tbreak;\n\tcase KVM_CAP_PMU_CAPABILITY:\n\t\tr = enable_pmu ? KVM_CAP_PMU_VALID_MASK : 0;\n\t\tbreak;\n\t}\n\tcase KVM_CAP_DISABLE_QUIRKS2:\n\t\tr = KVM_X86_VALID_QUIRKS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic inline void __user *kvm_get_attr_addr(struct kvm_device_attr *attr)\n{\n\tvoid __user *uaddr = (void __user*)(unsigned long)attr->addr;\n\n\tif ((u64)(unsigned long)uaddr != attr->addr)\n\t\treturn ERR_PTR_USR(-EFAULT);\n\treturn uaddr;\n}\n\nstatic int kvm_x86_dev_get_attr(struct kvm_device_attr *attr)\n{\n\tu64 __user *uaddr = kvm_get_attr_addr(attr);\n\n\tif (attr->group)\n\t\treturn -ENXIO;\n\n\tif (IS_ERR(uaddr))\n\t\treturn PTR_ERR(uaddr);\n\n\tswitch (attr->attr) {\n\tcase KVM_X86_XCOMP_GUEST_SUPP:\n\t\tif (put_user(supported_xcr0, uaddr))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENXIO;\n\t\tbreak;\n\t}\n}\n\nstatic int kvm_x86_dev_has_attr(struct kvm_device_attr *attr)\n{\n\tif (attr->group)\n\t\treturn -ENXIO;\n\n\tswitch (attr->attr) {\n\tcase KVM_X86_XCOMP_GUEST_SUPP:\n\t\treturn 0;\n\tdefault:\n\t\treturn -ENXIO;\n\t}\n}\n\nlong kvm_arch_dev_ioctl(struct file *filp,\n\t\t\tunsigned int ioctl, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\tlong r;\n\n\tswitch (ioctl) {\n\tcase KVM_GET_MSR_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msrs_to_save + num_emulated_msrs;\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msrs_to_save,\n\t\t\t\t num_msrs_to_save * sizeof(u32)))\n\t\t\tgoto out;\n\t\tif (copy_to_user(user_msr_list->indices + num_msrs_to_save,\n\t\t\t\t &emulated_msrs,\n\t\t\t\t num_emulated_msrs * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_CPUID:\n\tcase KVM_GET_EMULATED_CPUID: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\n\t\tr = kvm_dev_ioctl_get_cpuid(&cpuid, cpuid_arg->entries,\n\t\t\t\t\t    ioctl);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_X86_GET_MCE_CAP_SUPPORTED:\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &kvm_mce_cap_supported,\n\t\t\t\t sizeof(kvm_mce_cap_supported)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_GET_MSR_FEATURE_INDEX_LIST: {\n\t\tstruct kvm_msr_list __user *user_msr_list = argp;\n\t\tstruct kvm_msr_list msr_list;\n\t\tunsigned int n;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&msr_list, user_msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tn = msr_list.nmsrs;\n\t\tmsr_list.nmsrs = num_msr_based_features;\n\t\tif (copy_to_user(user_msr_list, &msr_list, sizeof(msr_list)))\n\t\t\tgoto out;\n\t\tr = -E2BIG;\n\t\tif (n < msr_list.nmsrs)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(user_msr_list->indices, &msr_based_features,\n\t\t\t\t num_msr_based_features * sizeof(u32)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS:\n\t\tr = msr_io(NULL, argp, do_get_msr_feature, 1);\n\t\tbreak;\n\tcase KVM_GET_SUPPORTED_HV_CPUID:\n\t\tr = kvm_ioctl_get_supported_hv_cpuid(NULL, argp);\n\t\tbreak;\n\tcase KVM_GET_DEVICE_ATTR: {\n\t\tstruct kvm_device_attr attr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))\n\t\t\tbreak;\n\t\tr = kvm_x86_dev_get_attr(&attr);\n\t\tbreak;\n\t}\n\tcase KVM_HAS_DEVICE_ATTR: {\n\t\tstruct kvm_device_attr attr;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&attr, (void __user *)arg, sizeof(attr)))\n\t\t\tbreak;\n\t\tr = kvm_x86_dev_has_attr(&attr);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\treturn r;\n}\n\nstatic void wbinvd_ipi(void *garbage)\n{\n\twbinvd();\n}\n\nstatic bool need_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_arch_has_noncoherent_dma(vcpu->kvm);\n}\n\nvoid kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\t/* Address WBINVD may be executed by guest */\n\tif (need_emulate_wbinvd(vcpu)) {\n\t\tif (static_call(kvm_x86_has_wbinvd_exit)())\n\t\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\telse if (vcpu->cpu != -1 && vcpu->cpu != cpu)\n\t\t\tsmp_call_function_single(vcpu->cpu,\n\t\t\t\t\twbinvd_ipi, NULL, 1);\n\t}\n\n\tstatic_call(kvm_x86_vcpu_load)(vcpu, cpu);\n\n\t/* Save host pkru register if supported */\n\tvcpu->arch.host_pkru = read_pkru();\n\n\t/* Apply any externally detected TSC adjustments (due to suspend) */\n\tif (unlikely(vcpu->arch.tsc_offset_adjustment)) {\n\t\tadjust_tsc_offset_host(vcpu, vcpu->arch.tsc_offset_adjustment);\n\t\tvcpu->arch.tsc_offset_adjustment = 0;\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t}\n\n\tif (unlikely(vcpu->cpu != cpu) || kvm_check_tsc_unstable()) {\n\t\ts64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :\n\t\t\t\trdtsc() - vcpu->arch.last_host_tsc;\n\t\tif (tsc_delta < 0)\n\t\t\tmark_tsc_unstable(\"KVM discovered backwards TSC\");\n\n\t\tif (kvm_check_tsc_unstable()) {\n\t\t\tu64 offset = kvm_compute_l1_tsc_offset(vcpu,\n\t\t\t\t\t\tvcpu->arch.last_guest_tsc);\n\t\t\tkvm_vcpu_write_tsc_offset(vcpu, offset);\n\t\t\tvcpu->arch.tsc_catchup = 1;\n\t\t}\n\n\t\tif (kvm_lapic_hv_timer_in_use(vcpu))\n\t\t\tkvm_lapic_restart_hv_timer(vcpu);\n\n\t\t/*\n\t\t * On a host with synchronized TSC, there is no need to update\n\t\t * kvmclock on vcpu->cpu migration\n\t\t */\n\t\tif (!vcpu->kvm->arch.use_master_clock || vcpu->cpu == -1)\n\t\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\t\tif (vcpu->cpu != cpu)\n\t\t\tkvm_make_request(KVM_REQ_MIGRATE_TIMER, vcpu);\n\t\tvcpu->cpu = cpu;\n\t}\n\n\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n}\n\nstatic void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tstatic const u8 preempted = KVM_VCPU_PREEMPTED;\n\n\t/*\n\t * The vCPU can be marked preempted if and only if the VM-Exit was on\n\t * an instruction boundary and will not trigger guest emulation of any\n\t * kind (see vcpu_run).  Vendor specific code controls (conservatively)\n\t * when this is true, for example allowing the vCPU to be marked\n\t * preempted if and only if the VM-Exit was due to a host interrupt.\n\t */\n\tif (!vcpu->arch.at_instruction_boundary) {\n\t\tvcpu->stat.preemption_other++;\n\t\treturn;\n\t}\n\n\tvcpu->stat.preemption_reported++;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\n\tif (vcpu->arch.st.preempted)\n\t\treturn;\n\n\t/* This happens on process exit */\n\tif (unlikely(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\n\tslots = kvm_memslots(vcpu->kvm);\n\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot))\n\t\treturn;\n\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\tBUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted));\n\n\tif (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))\n\t\tvcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;\n\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}\n\nvoid kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tif (vcpu->preempted) {\n\t\tif (!vcpu->arch.guest_state_protected)\n\t\t\tvcpu->arch.preempted_in_kernel = !static_call(kvm_x86_get_cpl)(vcpu);\n\n\t\t/*\n\t\t * Take the srcu lock as memslots will be accessed to check the gfn\n\t\t * cache generation against the memslots generation.\n\t\t */\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tif (kvm_xen_msr_enabled(vcpu->kvm))\n\t\t\tkvm_xen_runstate_set_preempted(vcpu);\n\t\telse\n\t\t\tkvm_steal_time_set_preempted(vcpu);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t}\n\n\tstatic_call(kvm_x86_vcpu_put)(vcpu);\n\tvcpu->arch.last_host_tsc = rdtsc();\n}\n\nstatic int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\n\treturn kvm_apic_get_state(vcpu, s);\n}\n\nstatic int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_lapic_state *s)\n{\n\tint r;\n\n\tr = kvm_apic_set_state(vcpu, s);\n\tif (r)\n\t\treturn r;\n\tupdate_cr8_intercept(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * We can accept userspace's request for interrupt injection\n\t * as long as we have a place to store the interrupt number.\n\t * The actual injection will happen when the CPU is able to\n\t * deliver the interrupt.\n\t */\n\tif (kvm_cpu_has_extint(vcpu))\n\t\treturn false;\n\n\t/* Acknowledging ExtINT does not happen if LINT0 is masked.  */\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}\n\nstatic int kvm_vcpu_ready_for_interrupt_injection(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Do not cause an interrupt window exit if an exception\n\t * is pending or an event needs reinjection; userspace\n\t * might want to inject the interrupt manually using KVM_SET_REGS\n\t * or KVM_SET_SREGS.  For that to work, we must be at an\n\t * instruction boundary and with no events half-injected.\n\t */\n\treturn (kvm_arch_interrupt_allowed(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu) &&\n\t\t!kvm_event_needs_reinjection(vcpu) &&\n\t\t!vcpu->arch.exception.pending);\n}\n\nstatic int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_interrupt *irq)\n{\n\tif (irq->irq >= KVM_NR_INTERRUPTS)\n\t\treturn -EINVAL;\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tkvm_queue_interrupt(vcpu, irq->irq, false);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * With in-kernel LAPIC, we only use this to inject EXTINT, so\n\t * fail for in-kernel 8259.\n\t */\n\tif (pic_in_kernel(vcpu->kvm))\n\t\treturn -ENXIO;\n\n\tif (vcpu->arch.pending_external_vector != -1)\n\t\treturn -EEXIST;\n\n\tvcpu->arch.pending_external_vector = irq->irq;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_inject_nmi(vcpu);\n\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\n\treturn 0;\n}\n\nstatic int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   struct kvm_tpr_access_ctl *tac)\n{\n\tif (tac->flags)\n\t\treturn -EINVAL;\n\tvcpu->arch.tpr_access_reporting = !!tac->enabled;\n\treturn 0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_setup_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t\tu64 mcg_cap)\n{\n\tint r;\n\tunsigned bank_num = mcg_cap & 0xff, bank;\n\n\tr = -EINVAL;\n\tif (!bank_num || bank_num > KVM_MAX_MCE_BANKS)\n\t\tgoto out;\n\tif (mcg_cap & ~(kvm_mce_cap_supported | 0xff | 0xff0000))\n\t\tgoto out;\n\tr = 0;\n\tvcpu->arch.mcg_cap = mcg_cap;\n\t/* Init IA32_MCG_CTL to all 1s */\n\tif (mcg_cap & MCG_CTL_P)\n\t\tvcpu->arch.mcg_ctl = ~(u64)0;\n\t/* Init IA32_MCi_CTL to all 1s */\n\tfor (bank = 0; bank < bank_num; bank++)\n\t\tvcpu->arch.mce_banks[bank*4] = ~(u64)0;\n\n\tstatic_call(kvm_x86_setup_mce)(vcpu);\nout:\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\t/*\n\t * if IA32_MCG_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\t/*\n\t * if IA32_MCi_CTL is not all 1s, the uncorrected error\n\t * reporting is disabled for the bank\n\t */\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       struct kvm_vcpu_events *events)\n{\n\tprocess_nmi(vcpu);\n\n\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\tprocess_smi(vcpu);\n\n\t/*\n\t * In guest mode, payload delivery should be deferred,\n\t * so that the L1 hypervisor can intercept #PF before\n\t * CR2 is modified (or intercept #DB before DR6 is\n\t * modified under nVMX). Unless the per-VM capability,\n\t * KVM_CAP_EXCEPTION_PAYLOAD, is set, we may not defer the delivery of\n\t * an exception payload and handle after a KVM_GET_VCPU_EVENTS. Since we\n\t * opportunistically defer the exception payload, deliver it if the\n\t * capability hasn't been requested before processing a\n\t * KVM_GET_VCPU_EVENTS.\n\t */\n\tif (!vcpu->kvm->arch.exception_payload_enabled &&\n\t    vcpu->arch.exception.pending && vcpu->arch.exception.has_payload)\n\t\tkvm_deliver_exception_payload(vcpu);\n\n\t/*\n\t * The API doesn't provide the instruction length for software\n\t * exceptions, so don't report them. As long as the guest RIP\n\t * isn't advanced, we should expect to encounter the exception\n\t * again.\n\t */\n\tif (kvm_exception_is_soft(vcpu->arch.exception.nr)) {\n\t\tevents->exception.injected = 0;\n\t\tevents->exception.pending = 0;\n\t} else {\n\t\tevents->exception.injected = vcpu->arch.exception.injected;\n\t\tevents->exception.pending = vcpu->arch.exception.pending;\n\t\t/*\n\t\t * For ABI compatibility, deliberately conflate\n\t\t * pending and injected exceptions when\n\t\t * KVM_CAP_EXCEPTION_PAYLOAD isn't enabled.\n\t\t */\n\t\tif (!vcpu->kvm->arch.exception_payload_enabled)\n\t\t\tevents->exception.injected |=\n\t\t\t\tvcpu->arch.exception.pending;\n\t}\n\tevents->exception.nr = vcpu->arch.exception.nr;\n\tevents->exception.has_error_code = vcpu->arch.exception.has_error_code;\n\tevents->exception.error_code = vcpu->arch.exception.error_code;\n\tevents->exception_has_payload = vcpu->arch.exception.has_payload;\n\tevents->exception_payload = vcpu->arch.exception.payload;\n\n\tevents->interrupt.injected =\n\t\tvcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft;\n\tevents->interrupt.nr = vcpu->arch.interrupt.nr;\n\tevents->interrupt.soft = 0;\n\tevents->interrupt.shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);\n\n\tevents->nmi.injected = vcpu->arch.nmi_injected;\n\tevents->nmi.pending = vcpu->arch.nmi_pending != 0;\n\tevents->nmi.masked = static_call(kvm_x86_get_nmi_mask)(vcpu);\n\tevents->nmi.pad = 0;\n\n\tevents->sipi_vector = 0; /* never valid when reporting to user space */\n\n\tevents->smi.smm = is_smm(vcpu);\n\tevents->smi.pending = vcpu->arch.smi_pending;\n\tevents->smi.smm_inside_nmi =\n\t\t!!(vcpu->arch.hflags & HF_SMM_INSIDE_NMI_MASK);\n\tevents->smi.latched_init = kvm_lapic_latched_init(vcpu);\n\n\tevents->flags = (KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t | KVM_VCPUEVENT_VALID_SMM);\n\tif (vcpu->kvm->arch.exception_payload_enabled)\n\t\tevents->flags |= KVM_VCPUEVENT_VALID_PAYLOAD;\n\n\tmemset(&events->reserved, 0, sizeof(events->reserved));\n}\n\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm);\n\nstatic int kvm_vcpu_ioctl_x86_set_vcpu_events(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      struct kvm_vcpu_events *events)\n{\n\tif (events->flags & ~(KVM_VCPUEVENT_VALID_NMI_PENDING\n\t\t\t      | KVM_VCPUEVENT_VALID_SIPI_VECTOR\n\t\t\t      | KVM_VCPUEVENT_VALID_SHADOW\n\t\t\t      | KVM_VCPUEVENT_VALID_SMM\n\t\t\t      | KVM_VCPUEVENT_VALID_PAYLOAD))\n\t\treturn -EINVAL;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_PAYLOAD) {\n\t\tif (!vcpu->kvm->arch.exception_payload_enabled)\n\t\t\treturn -EINVAL;\n\t\tif (events->exception.pending)\n\t\t\tevents->exception.injected = 0;\n\t\telse\n\t\t\tevents->exception_has_payload = 0;\n\t} else {\n\t\tevents->exception.pending = 0;\n\t\tevents->exception_has_payload = 0;\n\t}\n\n\tif ((events->exception.injected || events->exception.pending) &&\n\t    (events->exception.nr > 31 || events->exception.nr == NMI_VECTOR))\n\t\treturn -EINVAL;\n\n\t/* INITs are latched while in SMM */\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM &&\n\t    (events->smi.smm || events->smi.pending) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED)\n\t\treturn -EINVAL;\n\n\tprocess_nmi(vcpu);\n\tvcpu->arch.exception.injected = events->exception.injected;\n\tvcpu->arch.exception.pending = events->exception.pending;\n\tvcpu->arch.exception.nr = events->exception.nr;\n\tvcpu->arch.exception.has_error_code = events->exception.has_error_code;\n\tvcpu->arch.exception.error_code = events->exception.error_code;\n\tvcpu->arch.exception.has_payload = events->exception_has_payload;\n\tvcpu->arch.exception.payload = events->exception_payload;\n\n\tvcpu->arch.interrupt.injected = events->interrupt.injected;\n\tvcpu->arch.interrupt.nr = events->interrupt.nr;\n\tvcpu->arch.interrupt.soft = events->interrupt.soft;\n\tif (events->flags & KVM_VCPUEVENT_VALID_SHADOW)\n\t\tstatic_call(kvm_x86_set_interrupt_shadow)(vcpu,\n\t\t\t\t\t\tevents->interrupt.shadow);\n\n\tvcpu->arch.nmi_injected = events->nmi.injected;\n\tif (events->flags & KVM_VCPUEVENT_VALID_NMI_PENDING)\n\t\tvcpu->arch.nmi_pending = events->nmi.pending;\n\tstatic_call(kvm_x86_set_nmi_mask)(vcpu, events->nmi.masked);\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SIPI_VECTOR &&\n\t    lapic_in_kernel(vcpu))\n\t\tvcpu->arch.apic->sipi_vector = events->sipi_vector;\n\n\tif (events->flags & KVM_VCPUEVENT_VALID_SMM) {\n\t\tif (!!(vcpu->arch.hflags & HF_SMM_MASK) != events->smi.smm) {\n\t\t\tkvm_x86_ops.nested_ops->leave_nested(vcpu);\n\t\t\tkvm_smm_changed(vcpu, events->smi.smm);\n\t\t}\n\n\t\tvcpu->arch.smi_pending = events->smi.pending;\n\n\t\tif (events->smi.smm) {\n\t\t\tif (events->smi.smm_inside_nmi)\n\t\t\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\t\t\telse\n\t\t\t\tvcpu->arch.hflags &= ~HF_SMM_INSIDE_NMI_MASK;\n\t\t}\n\n\t\tif (lapic_in_kernel(vcpu)) {\n\t\t\tif (events->smi.latched_init)\n\t\t\t\tset_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t\telse\n\t\t\t\tclear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);\n\t\t}\n\t}\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    struct kvm_debugregs *dbgregs)\n{\n\tif (dbgregs->flags)\n\t\treturn -EINVAL;\n\n\tif (!kvm_dr6_valid(dbgregs->dr6))\n\t\treturn -EINVAL;\n\tif (!kvm_dr7_valid(dbgregs->dr7))\n\t\treturn -EINVAL;\n\n\tmemcpy(vcpu->arch.db, dbgregs->db, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = dbgregs->dr6;\n\tvcpu->arch.dr7 = dbgregs->dr7;\n\tkvm_update_dr7(vcpu);\n\n\treturn 0;\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_xsave *guest_xsave)\n{\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn;\n\n\tfpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,\n\t\t\t\t       guest_xsave->region,\n\t\t\t\t       sizeof(guest_xsave->region),\n\t\t\t\t       vcpu->arch.pkru);\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xsave2(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  u8 *state, unsigned int size)\n{\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn;\n\n\tfpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu,\n\t\t\t\t       state, size, vcpu->arch.pkru);\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xsave *guest_xsave)\n{\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn 0;\n\n\treturn fpu_copy_uabi_to_guest_fpstate(&vcpu->arch.guest_fpu,\n\t\t\t\t\t      guest_xsave->region,\n\t\t\t\t\t      supported_xcr0, &vcpu->arch.pkru);\n}\n\nstatic void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE)) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}\n\nstatic int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct kvm_xcrs *guest_xcrs)\n{\n\tint i, r = 0;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -EINVAL;\n\n\tif (guest_xcrs->nr_xcrs > KVM_MAX_XCRS || guest_xcrs->flags)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < guest_xcrs->nr_xcrs; i++)\n\t\t/* Only support XCR0 currently */\n\t\tif (guest_xcrs->xcrs[i].xcr == XCR_XFEATURE_ENABLED_MASK) {\n\t\t\tr = __kvm_set_xcr(vcpu, XCR_XFEATURE_ENABLED_MASK,\n\t\t\t\tguest_xcrs->xcrs[i].value);\n\t\t\tbreak;\n\t\t}\n\tif (r)\n\t\tr = -EINVAL;\n\treturn r;\n}\n\n/*\n * kvm_set_guest_paused() indicates to the guest kernel that it has been\n * stopped by the hypervisor.  This function will be called from the host only.\n * EINVAL is returned when the host attempts to set the flag for a guest that\n * does not support pv clocks.\n */\nstatic int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time.active)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}\n\nstatic int kvm_arch_tsc_has_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_device_attr *attr)\n{\n\tint r;\n\n\tswitch (attr->attr) {\n\tcase KVM_VCPU_TSC_OFFSET:\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = -ENXIO;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_arch_tsc_get_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_device_attr *attr)\n{\n\tu64 __user *uaddr = kvm_get_attr_addr(attr);\n\tint r;\n\n\tif (IS_ERR(uaddr))\n\t\treturn PTR_ERR(uaddr);\n\n\tswitch (attr->attr) {\n\tcase KVM_VCPU_TSC_OFFSET:\n\t\tr = -EFAULT;\n\t\tif (put_user(vcpu->arch.l1_tsc_offset, uaddr))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\tdefault:\n\t\tr = -ENXIO;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_arch_tsc_set_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_device_attr *attr)\n{\n\tu64 __user *uaddr = kvm_get_attr_addr(attr);\n\tstruct kvm *kvm = vcpu->kvm;\n\tint r;\n\n\tif (IS_ERR(uaddr))\n\t\treturn PTR_ERR(uaddr);\n\n\tswitch (attr->attr) {\n\tcase KVM_VCPU_TSC_OFFSET: {\n\t\tu64 offset, tsc, ns;\n\t\tunsigned long flags;\n\t\tbool matched;\n\n\t\tr = -EFAULT;\n\t\tif (get_user(offset, uaddr))\n\t\t\tbreak;\n\n\t\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\n\t\tmatched = (vcpu->arch.virtual_tsc_khz &&\n\t\t\t   kvm->arch.last_tsc_khz == vcpu->arch.virtual_tsc_khz &&\n\t\t\t   kvm->arch.last_tsc_offset == offset);\n\n\t\ttsc = kvm_scale_tsc(rdtsc(), vcpu->arch.l1_tsc_scaling_ratio) + offset;\n\t\tns = get_kvmclock_base_ns();\n\n\t\t__kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);\n\t\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tr = -ENXIO;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_device_attr(struct kvm_vcpu *vcpu,\n\t\t\t\t      unsigned int ioctl,\n\t\t\t\t      void __user *argp)\n{\n\tstruct kvm_device_attr attr;\n\tint r;\n\n\tif (copy_from_user(&attr, argp, sizeof(attr)))\n\t\treturn -EFAULT;\n\n\tif (attr.group != KVM_VCPU_TSC_CTRL)\n\t\treturn -ENXIO;\n\n\tswitch (ioctl) {\n\tcase KVM_HAS_DEVICE_ATTR:\n\t\tr = kvm_arch_tsc_has_attr(vcpu, &attr);\n\t\tbreak;\n\tcase KVM_GET_DEVICE_ATTR:\n\t\tr = kvm_arch_tsc_get_attr(vcpu, &attr);\n\t\tbreak;\n\tcase KVM_SET_DEVICE_ATTR:\n\t\tr = kvm_arch_tsc_set_attr(vcpu, &attr);\n\t\tbreak;\n\t}\n\n\treturn r;\n}\n\nstatic int kvm_vcpu_ioctl_enable_cap(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_enable_cap *cap)\n{\n\tint r;\n\tuint16_t vmcs_version;\n\tvoid __user *user_ptr;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_HYPERV_SYNIC2:\n\t\tif (cap->args[0])\n\t\t\treturn -EINVAL;\n\t\tfallthrough;\n\n\tcase KVM_CAP_HYPERV_SYNIC:\n\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\treturn -EINVAL;\n\t\treturn kvm_hv_activate_synic(vcpu, cap->cap ==\n\t\t\t\t\t     KVM_CAP_HYPERV_SYNIC2);\n\tcase KVM_CAP_HYPERV_ENLIGHTENED_VMCS:\n\t\tif (!kvm_x86_ops.nested_ops->enable_evmcs)\n\t\t\treturn -ENOTTY;\n\t\tr = kvm_x86_ops.nested_ops->enable_evmcs(vcpu, &vmcs_version);\n\t\tif (!r) {\n\t\t\tuser_ptr = (void __user *)(uintptr_t)cap->args[0];\n\t\t\tif (copy_to_user(user_ptr, &vmcs_version,\n\t\t\t\t\t sizeof(vmcs_version)))\n\t\t\t\tr = -EFAULT;\n\t\t}\n\t\treturn r;\n\tcase KVM_CAP_HYPERV_DIRECT_TLBFLUSH:\n\t\tif (!kvm_x86_ops.enable_direct_tlbflush)\n\t\t\treturn -ENOTTY;\n\n\t\treturn static_call(kvm_x86_enable_direct_tlbflush)(vcpu);\n\n\tcase KVM_CAP_HYPERV_ENFORCE_CPUID:\n\t\treturn kvm_hv_set_enforce_cpuid(vcpu, cap->args[0]);\n\n\tcase KVM_CAP_ENFORCE_PV_FEATURE_CPUID:\n\t\tvcpu->arch.pv_cpuid.enforce = cap->args[0];\n\t\tif (vcpu->arch.pv_cpuid.enforce)\n\t\t\tkvm_update_pv_runtime(vcpu);\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nlong kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r;\n\tunion {\n\t\tstruct kvm_sregs2 *sregs2;\n\t\tstruct kvm_lapic_state *lapic;\n\t\tstruct kvm_xsave *xsave;\n\t\tstruct kvm_xcrs *xcrs;\n\t\tvoid *buffer;\n\t} u;\n\n\tvcpu_load(vcpu);\n\n\tu.buffer = NULL;\n\tswitch (ioctl) {\n\tcase KVM_GET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = kzalloc(sizeof(struct kvm_lapic_state),\n\t\t\t\tGFP_KERNEL_ACCOUNT);\n\n\t\tr = -ENOMEM;\n\t\tif (!u.lapic)\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_lapic(vcpu, u.lapic);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.lapic, sizeof(struct kvm_lapic_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_LAPIC: {\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tu.lapic = memdup_user(argp, sizeof(*u.lapic));\n\t\tif (IS_ERR(u.lapic)) {\n\t\t\tr = PTR_ERR(u.lapic);\n\t\t\tgoto out_nofree;\n\t\t}\n\n\t\tr = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);\n\t\tbreak;\n\t}\n\tcase KVM_INTERRUPT: {\n\t\tstruct kvm_interrupt irq;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&irq, argp, sizeof(irq)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_interrupt(vcpu, &irq);\n\t\tbreak;\n\t}\n\tcase KVM_NMI: {\n\t\tr = kvm_vcpu_ioctl_nmi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SMI: {\n\t\tr = kvm_vcpu_ioctl_smi(vcpu);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID: {\n\t\tstruct kvm_cpuid __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid(vcpu, &cpuid, cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_SET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_set_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tbreak;\n\t}\n\tcase KVM_GET_CPUID2: {\n\t\tstruct kvm_cpuid2 __user *cpuid_arg = argp;\n\t\tstruct kvm_cpuid2 cpuid;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cpuid, cpuid_arg, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_get_cpuid2(vcpu, &cpuid,\n\t\t\t\t\t      cpuid_arg->entries);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(cpuid_arg, &cpuid, sizeof(cpuid)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_GET_MSRS: {\n\t\tint idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = msr_io(vcpu, argp, do_get_msr, 1);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_SET_MSRS: {\n\t\tint idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = msr_io(vcpu, argp, do_set_msr, 0);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_TPR_ACCESS_REPORTING: {\n\t\tstruct kvm_tpr_access_ctl tac;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&tac, argp, sizeof(tac)))\n\t\t\tgoto out;\n\t\tr = vcpu_ioctl_tpr_access_reporting(vcpu, &tac);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &tac, sizeof(tac)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t};\n\tcase KVM_SET_VAPIC_ADDR: {\n\t\tstruct kvm_vapic_addr va;\n\t\tint idx;\n\n\t\tr = -EINVAL;\n\t\tif (!lapic_in_kernel(vcpu))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof(va)))\n\t\t\tgoto out;\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof(mcg_cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof(mce)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tr = -EINVAL;\n\t\tif (vcpu->arch.guest_fpu.uabi_size > sizeof(struct kvm_xsave))\n\t\t\tbreak;\n\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tint size = vcpu->arch.guest_fpu.uabi_size;\n\n\t\tu.xsave = memdup_user(argp, size);\n\t\tif (IS_ERR(u.xsave)) {\n\t\t\tr = PTR_ERR(u.xsave);\n\t\t\tgoto out_nofree;\n\t\t}\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\n\tcase KVM_GET_XSAVE2: {\n\t\tint size = vcpu->arch.guest_fpu.uabi_size;\n\n\t\tu.xsave = kzalloc(size, GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xsave2(vcpu, u.buffer, size);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, size))\n\t\t\tbreak;\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL_ACCOUNT);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs)) {\n\t\t\tr = PTR_ERR(u.xcrs);\n\t\t\tgoto out_nofree;\n\t\t}\n\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (kvm_has_tsc_control &&\n\t\t    user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tif (!kvm_set_tsc_khz(vcpu, user_tsc_khz))\n\t\t\tr = 0;\n\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = vcpu->arch.virtual_tsc_khz;\n\t\tgoto out;\n\t}\n\tcase KVM_KVMCLOCK_CTRL: {\n\t\tr = kvm_set_guest_paused(vcpu);\n\t\tgoto out;\n\t}\n\tcase KVM_ENABLE_CAP: {\n\t\tstruct kvm_enable_cap cap;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&cap, argp, sizeof(cap)))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);\n\t\tbreak;\n\t}\n\tcase KVM_GET_NESTED_STATE: {\n\t\tstruct kvm_nested_state __user *user_kvm_nested_state = argp;\n\t\tu32 user_data_size;\n\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.nested_ops->get_state)\n\t\t\tbreak;\n\n\t\tBUILD_BUG_ON(sizeof(user_data_size) != sizeof(user_kvm_nested_state->size));\n\t\tr = -EFAULT;\n\t\tif (get_user(user_data_size, &user_kvm_nested_state->size))\n\t\t\tbreak;\n\n\t\tr = kvm_x86_ops.nested_ops->get_state(vcpu, user_kvm_nested_state,\n\t\t\t\t\t\t     user_data_size);\n\t\tif (r < 0)\n\t\t\tbreak;\n\n\t\tif (r > user_data_size) {\n\t\t\tif (put_user(r, &user_kvm_nested_state->size))\n\t\t\t\tr = -EFAULT;\n\t\t\telse\n\t\t\t\tr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_NESTED_STATE: {\n\t\tstruct kvm_nested_state __user *user_kvm_nested_state = argp;\n\t\tstruct kvm_nested_state kvm_state;\n\t\tint idx;\n\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.nested_ops->set_state)\n\t\t\tbreak;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&kvm_state, user_kvm_nested_state, sizeof(kvm_state)))\n\t\t\tbreak;\n\n\t\tr = -EINVAL;\n\t\tif (kvm_state.size < sizeof(kvm_state))\n\t\t\tbreak;\n\n\t\tif (kvm_state.flags &\n\t\t    ~(KVM_STATE_NESTED_RUN_PENDING | KVM_STATE_NESTED_GUEST_MODE\n\t\t      | KVM_STATE_NESTED_EVMCS | KVM_STATE_NESTED_MTF_PENDING\n\t\t      | KVM_STATE_NESTED_GIF_SET))\n\t\t\tbreak;\n\n\t\t/* nested_run_pending implies guest_mode.  */\n\t\tif ((kvm_state.flags & KVM_STATE_NESTED_RUN_PENDING)\n\t\t    && !(kvm_state.flags & KVM_STATE_NESTED_GUEST_MODE))\n\t\t\tbreak;\n\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = kvm_x86_ops.nested_ops->set_state(vcpu, user_kvm_nested_state, &kvm_state);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t\tbreak;\n\t}\n\tcase KVM_GET_SUPPORTED_HV_CPUID:\n\t\tr = kvm_ioctl_get_supported_hv_cpuid(vcpu, argp);\n\t\tbreak;\n#ifdef CONFIG_KVM_XEN\n\tcase KVM_XEN_VCPU_GET_ATTR: {\n\t\tstruct kvm_xen_vcpu_attr xva;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xva, argp, sizeof(xva)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_vcpu_get_attr(vcpu, &xva);\n\t\tif (!r && copy_to_user(argp, &xva, sizeof(xva)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_VCPU_SET_ATTR: {\n\t\tstruct kvm_xen_vcpu_attr xva;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xva, argp, sizeof(xva)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_vcpu_set_attr(vcpu, &xva);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_GET_SREGS2: {\n\t\tu.sregs2 = kzalloc(sizeof(struct kvm_sregs2), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.sregs2)\n\t\t\tgoto out;\n\t\t__get_sregs2(vcpu, u.sregs2);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.sregs2, sizeof(struct kvm_sregs2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_SREGS2: {\n\t\tu.sregs2 = memdup_user(argp, sizeof(struct kvm_sregs2));\n\t\tif (IS_ERR(u.sregs2)) {\n\t\t\tr = PTR_ERR(u.sregs2);\n\t\t\tu.sregs2 = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tr = __set_sregs2(vcpu, u.sregs2);\n\t\tbreak;\n\t}\n\tcase KVM_HAS_DEVICE_ATTR:\n\tcase KVM_GET_DEVICE_ATTR:\n\tcase KVM_SET_DEVICE_ATTR:\n\t\tr = kvm_vcpu_ioctl_device_attr(vcpu, ioctl, argp);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t}\nout:\n\tkfree(u.buffer);\nout_nofree:\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\nvm_fault_t kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}\n\nstatic int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = static_call(kvm_x86_set_tss_addr)(kvm, addr);\n\treturn ret;\n}\n\nstatic int kvm_vm_ioctl_set_identity_map_addr(struct kvm *kvm,\n\t\t\t\t\t      u64 ident_addr)\n{\n\treturn static_call(kvm_x86_set_identity_map_addr)(kvm, ident_addr);\n}\n\nstatic int kvm_vm_ioctl_set_nr_mmu_pages(struct kvm *kvm,\n\t\t\t\t\t unsigned long kvm_nr_mmu_pages)\n{\n\tif (kvm_nr_mmu_pages < KVM_MIN_ALLOC_MMU_PAGES)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&kvm->slots_lock);\n\n\tkvm_mmu_change_mmu_pages(kvm, kvm_nr_mmu_pages);\n\tkvm->arch.n_requested_mmu_pages = kvm_nr_mmu_pages;\n\n\tmutex_unlock(&kvm->slots_lock);\n\treturn 0;\n}\n\nstatic unsigned long kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}\n\nstatic int kvm_vm_ioctl_get_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tstruct kvm_pic *pic = kvm->arch.vpic;\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tmemcpy(&chip->chip.pic, &pic->pics[0],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tmemcpy(&chip->chip.pic, &pic->pics[1],\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tkvm_get_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_set_irqchip(struct kvm *kvm, struct kvm_irqchip *chip)\n{\n\tstruct kvm_pic *pic = kvm->arch.vpic;\n\tint r;\n\n\tr = 0;\n\tswitch (chip->chip_id) {\n\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\tspin_lock(&pic->lock);\n\t\tmemcpy(&pic->pics[0], &chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\tspin_lock(&pic->lock);\n\t\tmemcpy(&pic->pics[1], &chip->chip.pic,\n\t\t\tsizeof(struct kvm_pic_state));\n\t\tspin_unlock(&pic->lock);\n\t\tbreak;\n\tcase KVM_IRQCHIP_IOAPIC:\n\t\tkvm_set_ioapic(kvm, &chip->chip.ioapic);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\tkvm_pic_update_irq(pic);\n\treturn r;\n}\n\nstatic int kvm_vm_ioctl_get_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tstruct kvm_kpit_state *kps = &kvm->arch.vpit->pit_state;\n\n\tBUILD_BUG_ON(sizeof(*ps) != sizeof(kps->channels));\n\n\tmutex_lock(&kps->lock);\n\tmemcpy(ps, &kps->channels, sizeof(*ps));\n\tmutex_unlock(&kps->lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint i;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tmemcpy(&pit->pit_state.channels, ps, sizeof(*ps));\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, ps->channels[i].count, 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_get_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(ps->channels, &kvm->arch.vpit->pit_state.channels,\n\t\tsizeof(ps->channels));\n\tps->flags = kvm->arch.vpit->pit_state.flags;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\tmemset(&ps->reserved, 0, sizeof(ps->reserved));\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tmutex_lock(&pit->pit_state.lock);\n\tprev_legacy = pit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&pit->pit_state.channels, &ps->channels,\n\t       sizeof(pit->pit_state.channels));\n\tpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(pit, i, pit->pit_state.channels[i].count,\n\t\t\t\t   start && i == 0);\n\tmutex_unlock(&pit->pit_state.lock);\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\t/* pit->pit_state.lock was overloaded to prevent userspace from getting\n\t * an inconsistent state after running multiple KVM_REINJECT_CONTROL\n\t * ioctls in parallel.  Use a separate lock if that ioctl isn't rare.\n\t */\n\tmutex_lock(&pit->pit_state.lock);\n\tkvm_pit_set_reinject(pit, control->pit_reinject);\n\tmutex_unlock(&pit->pit_state.lock);\n\n\treturn 0;\n}\n\nvoid kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)\n{\n\n\t/*\n\t * Flush all CPUs' dirty log buffers to the  dirty_bitmap.  Called\n\t * before reporting dirty_bitmap to userspace.  KVM flushes the buffers\n\t * on all VM-Exits, thus we only need to kick running vCPUs to force a\n\t * VM-Exit.\n\t */\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nint kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,\n\t\t\tbool line_status)\n{\n\tif (!irqchip_in_kernel(kvm))\n\t\treturn -ENXIO;\n\n\tirq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,\n\t\t\t\t\tirq_event->irq, irq_event->level,\n\t\t\t\t\tline_status);\n\treturn 0;\n}\n\nint kvm_vm_ioctl_enable_cap(struct kvm *kvm,\n\t\t\t    struct kvm_enable_cap *cap)\n{\n\tint r;\n\n\tif (cap->flags)\n\t\treturn -EINVAL;\n\n\tswitch (cap->cap) {\n\tcase KVM_CAP_DISABLE_QUIRKS2:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_X86_VALID_QUIRKS)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase KVM_CAP_DISABLE_QUIRKS:\n\t\tkvm->arch.disabled_quirks = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_SPLIT_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] > MAX_NR_RESERVED_IOAPIC_PINS)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto split_irqchip_unlock;\n\t\tif (kvm->created_vcpus)\n\t\t\tgoto split_irqchip_unlock;\n\t\tr = kvm_setup_empty_irq_routing(kvm);\n\t\tif (r)\n\t\t\tgoto split_irqchip_unlock;\n\t\t/* Pairs with irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_mode = KVM_IRQCHIP_SPLIT;\n\t\tkvm->arch.nr_reserved_ioapic_pins = cap->args[0];\n\t\tkvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);\n\t\tr = 0;\nsplit_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CAP_X2APIC_API:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)\n\t\t\tbreak;\n\n\t\tif (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)\n\t\t\tkvm->arch.x2apic_format = true;\n\t\tif (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)\n\t\t\tkvm->arch.x2apic_broadcast_quirk_disabled = true;\n\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_X86_DISABLE_EXITS:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_X86_DISABLE_VALID_EXITS)\n\t\t\tbreak;\n\n\t\tif ((cap->args[0] & KVM_X86_DISABLE_EXITS_MWAIT) &&\n\t\t\tkvm_can_mwait_in_guest())\n\t\t\tkvm->arch.mwait_in_guest = true;\n\t\tif (cap->args[0] & KVM_X86_DISABLE_EXITS_HLT)\n\t\t\tkvm->arch.hlt_in_guest = true;\n\t\tif (cap->args[0] & KVM_X86_DISABLE_EXITS_PAUSE)\n\t\t\tkvm->arch.pause_in_guest = true;\n\t\tif (cap->args[0] & KVM_X86_DISABLE_EXITS_CSTATE)\n\t\t\tkvm->arch.cstate_in_guest = true;\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_MSR_PLATFORM_INFO:\n\t\tkvm->arch.guest_can_read_msr_platform_info = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_EXCEPTION_PAYLOAD:\n\t\tkvm->arch.exception_payload_enabled = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_X86_USER_SPACE_MSR:\n\t\tkvm->arch.user_space_msr_mask = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_X86_BUS_LOCK_EXIT:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~KVM_BUS_LOCK_DETECTION_VALID_MODE)\n\t\t\tbreak;\n\n\t\tif ((cap->args[0] & KVM_BUS_LOCK_DETECTION_OFF) &&\n\t\t    (cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT))\n\t\t\tbreak;\n\n\t\tif (kvm_has_bus_lock_exit &&\n\t\t    cap->args[0] & KVM_BUS_LOCK_DETECTION_EXIT)\n\t\t\tkvm->arch.bus_lock_detection_enabled = true;\n\t\tr = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_SGX_KVM\n\tcase KVM_CAP_SGX_ATTRIBUTE: {\n\t\tunsigned long allowed_attributes = 0;\n\n\t\tr = sgx_set_attribute(&allowed_attributes, cap->args[0]);\n\t\tif (r)\n\t\t\tbreak;\n\n\t\t/* KVM only supports the PROVISIONKEY privileged attribute. */\n\t\tif ((allowed_attributes & SGX_ATTR_PROVISIONKEY) &&\n\t\t    !(allowed_attributes & ~SGX_ATTR_PROVISIONKEY))\n\t\t\tkvm->arch.sgx_provisioning_allowed = true;\n\t\telse\n\t\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_CAP_VM_COPY_ENC_CONTEXT_FROM:\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.vm_copy_enc_context_from)\n\t\t\tbreak;\n\n\t\tr = static_call(kvm_x86_vm_copy_enc_context_from)(kvm, cap->args[0]);\n\t\tbreak;\n\tcase KVM_CAP_VM_MOVE_ENC_CONTEXT_FROM:\n\t\tr = -EINVAL;\n\t\tif (!kvm_x86_ops.vm_move_enc_context_from)\n\t\t\tbreak;\n\n\t\tr = static_call(kvm_x86_vm_move_enc_context_from)(kvm, cap->args[0]);\n\t\tbreak;\n\tcase KVM_CAP_EXIT_HYPERCALL:\n\t\tif (cap->args[0] & ~KVM_EXIT_HYPERCALL_VALID_MASK) {\n\t\t\tr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tkvm->arch.hypercall_exit_enabled = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_EXIT_ON_EMULATION_FAILURE:\n\t\tr = -EINVAL;\n\t\tif (cap->args[0] & ~1)\n\t\t\tbreak;\n\t\tkvm->arch.exit_on_emulation_error = cap->args[0];\n\t\tr = 0;\n\t\tbreak;\n\tcase KVM_CAP_PMU_CAPABILITY:\n\t\tr = -EINVAL;\n\t\tif (!enable_pmu || (cap->args[0] & ~KVM_CAP_PMU_VALID_MASK))\n\t\t\tbreak;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tif (!kvm->created_vcpus) {\n\t\t\tkvm->arch.enable_pmu = !(cap->args[0] & KVM_PMU_CAP_DISABLE);\n\t\t\tr = 0;\n\t\t}\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn r;\n}\n\nstatic struct kvm_x86_msr_filter *kvm_alloc_msr_filter(bool default_allow)\n{\n\tstruct kvm_x86_msr_filter *msr_filter;\n\n\tmsr_filter = kzalloc(sizeof(*msr_filter), GFP_KERNEL_ACCOUNT);\n\tif (!msr_filter)\n\t\treturn NULL;\n\n\tmsr_filter->default_allow = default_allow;\n\treturn msr_filter;\n}\n\nstatic void kvm_free_msr_filter(struct kvm_x86_msr_filter *msr_filter)\n{\n\tu32 i;\n\n\tif (!msr_filter)\n\t\treturn;\n\n\tfor (i = 0; i < msr_filter->count; i++)\n\t\tkfree(msr_filter->ranges[i].bitmap);\n\n\tkfree(msr_filter);\n}\n\nstatic int kvm_add_msr_filter(struct kvm_x86_msr_filter *msr_filter,\n\t\t\t      struct kvm_msr_filter_range *user_range)\n{\n\tunsigned long *bitmap = NULL;\n\tsize_t bitmap_size;\n\n\tif (!user_range->nmsrs)\n\t\treturn 0;\n\n\tif (user_range->flags & ~(KVM_MSR_FILTER_READ | KVM_MSR_FILTER_WRITE))\n\t\treturn -EINVAL;\n\n\tif (!user_range->flags)\n\t\treturn -EINVAL;\n\n\tbitmap_size = BITS_TO_LONGS(user_range->nmsrs) * sizeof(long);\n\tif (!bitmap_size || bitmap_size > KVM_MSR_FILTER_MAX_BITMAP_SIZE)\n\t\treturn -EINVAL;\n\n\tbitmap = memdup_user((__user u8*)user_range->bitmap, bitmap_size);\n\tif (IS_ERR(bitmap))\n\t\treturn PTR_ERR(bitmap);\n\n\tmsr_filter->ranges[msr_filter->count] = (struct msr_bitmap_range) {\n\t\t.flags = user_range->flags,\n\t\t.base = user_range->base,\n\t\t.nmsrs = user_range->nmsrs,\n\t\t.bitmap = bitmap,\n\t};\n\n\tmsr_filter->count++;\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_msr_filter(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_msr_filter __user *user_msr_filter = argp;\n\tstruct kvm_x86_msr_filter *new_filter, *old_filter;\n\tstruct kvm_msr_filter filter;\n\tbool default_allow;\n\tbool empty = true;\n\tint r = 0;\n\tu32 i;\n\n\tif (copy_from_user(&filter, user_msr_filter, sizeof(filter)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(filter.ranges); i++)\n\t\tempty &= !filter.ranges[i].nmsrs;\n\n\tdefault_allow = !(filter.flags & KVM_MSR_FILTER_DEFAULT_DENY);\n\tif (empty && !default_allow)\n\t\treturn -EINVAL;\n\n\tnew_filter = kvm_alloc_msr_filter(default_allow);\n\tif (!new_filter)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(filter.ranges); i++) {\n\t\tr = kvm_add_msr_filter(new_filter, &filter.ranges[i]);\n\t\tif (r) {\n\t\t\tkvm_free_msr_filter(new_filter);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tmutex_lock(&kvm->lock);\n\n\t/* The per-VM filter is protected by kvm->lock... */\n\told_filter = srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1);\n\n\trcu_assign_pointer(kvm->arch.msr_filter, new_filter);\n\tsynchronize_srcu(&kvm->srcu);\n\n\tkvm_free_msr_filter(old_filter);\n\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_MSR_FILTER_CHANGED);\n\tmutex_unlock(&kvm->lock);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_HAVE_KVM_PM_NOTIFIER\nstatic int kvm_arch_suspend_notifier(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\tint ret = 0;\n\n\tmutex_lock(&kvm->lock);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!vcpu->arch.pv_time.active)\n\t\t\tcontinue;\n\n\t\tret = kvm_set_guest_paused(vcpu);\n\t\tif (ret) {\n\t\t\tkvm_err(\"Failed to pause guest VCPU%d: %d\\n\",\n\t\t\t\tvcpu->vcpu_id, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&kvm->lock);\n\n\treturn ret ? NOTIFY_BAD : NOTIFY_DONE;\n}\n\nint kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state)\n{\n\tswitch (state) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\t\treturn kvm_arch_suspend_notifier(kvm);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n#endif /* CONFIG_HAVE_KVM_PM_NOTIFIER */\n\nstatic int kvm_vm_ioctl_get_clock(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_clock_data data = { 0 };\n\n\tget_kvmclock(kvm, &data);\n\tif (copy_to_user(argp, &data, sizeof(data)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int kvm_vm_ioctl_set_clock(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct kvm_clock_data data;\n\tu64 now_raw_ns;\n\n\tif (copy_from_user(&data, argp, sizeof(data)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Only KVM_CLOCK_REALTIME is used, but allow passing the\n\t * result of KVM_GET_CLOCK back to KVM_SET_CLOCK.\n\t */\n\tif (data.flags & ~KVM_CLOCK_VALID_FLAGS)\n\t\treturn -EINVAL;\n\n\tkvm_hv_request_tsc_page_update(kvm);\n\tkvm_start_pvclock_update(kvm);\n\tpvclock_update_vm_gtod_copy(kvm);\n\n\t/*\n\t * This pairs with kvm_guest_time_update(): when masterclock is\n\t * in use, we use master_kernel_ns + kvmclock_offset to set\n\t * unsigned 'system_time' so if we use get_kvmclock_ns() (which\n\t * is slightly ahead) here we risk going negative on unsigned\n\t * 'system_time' when 'data.clock' is very small.\n\t */\n\tif (data.flags & KVM_CLOCK_REALTIME) {\n\t\tu64 now_real_ns = ktime_get_real_ns();\n\n\t\t/*\n\t\t * Avoid stepping the kvmclock backwards.\n\t\t */\n\t\tif (now_real_ns > data.realtime)\n\t\t\tdata.clock += now_real_ns - data.realtime;\n\t}\n\n\tif (ka->use_master_clock)\n\t\tnow_raw_ns = ka->master_kernel_ns;\n\telse\n\t\tnow_raw_ns = get_kvmclock_base_ns();\n\tka->kvmclock_offset = data.clock - now_raw_ns;\n\tkvm_end_pvclock_update(kvm);\n\treturn 0;\n}\n\nlong kvm_arch_vm_ioctl(struct file *filp,\n\t\t       unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tint r = -ENOTTY;\n\t/*\n\t * This union makes it completely explicit to gcc-3.x\n\t * that these two variables' stack usage should be\n\t * combined, not added together.\n\t */\n\tunion {\n\t\tstruct kvm_pit_state ps;\n\t\tstruct kvm_pit_state2 ps2;\n\t\tstruct kvm_pit_config pit_config;\n\t} u;\n\n\tswitch (ioctl) {\n\tcase KVM_SET_TSS_ADDR:\n\t\tr = kvm_vm_ioctl_set_tss_addr(kvm, arg);\n\t\tbreak;\n\tcase KVM_SET_IDENTITY_MAP_ADDR: {\n\t\tu64 ident_addr;\n\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EINVAL;\n\t\tif (kvm->created_vcpus)\n\t\t\tgoto set_identity_unlock;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&ident_addr, argp, sizeof(ident_addr)))\n\t\t\tgoto set_identity_unlock;\n\t\tr = kvm_vm_ioctl_set_identity_map_addr(kvm, ident_addr);\nset_identity_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_SET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_set_nr_mmu_pages(kvm, arg);\n\t\tbreak;\n\tcase KVM_GET_NR_MMU_PAGES:\n\t\tr = kvm_vm_ioctl_get_nr_mmu_pages(kvm);\n\t\tbreak;\n\tcase KVM_CREATE_IRQCHIP: {\n\t\tmutex_lock(&kvm->lock);\n\n\t\tr = -EEXIST;\n\t\tif (irqchip_in_kernel(kvm))\n\t\t\tgoto create_irqchip_unlock;\n\n\t\tr = -EINVAL;\n\t\tif (kvm->created_vcpus)\n\t\t\tgoto create_irqchip_unlock;\n\n\t\tr = kvm_pic_init(kvm);\n\t\tif (r)\n\t\t\tgoto create_irqchip_unlock;\n\n\t\tr = kvm_ioapic_init(kvm);\n\t\tif (r) {\n\t\t\tkvm_pic_destroy(kvm);\n\t\t\tgoto create_irqchip_unlock;\n\t\t}\n\n\t\tr = kvm_setup_default_irq_routing(kvm);\n\t\tif (r) {\n\t\t\tkvm_ioapic_destroy(kvm);\n\t\t\tkvm_pic_destroy(kvm);\n\t\t\tgoto create_irqchip_unlock;\n\t\t}\n\t\t/* Write kvm->irq_routing before enabling irqchip_in_kernel. */\n\t\tsmp_wmb();\n\t\tkvm->arch.irqchip_mode = KVM_IRQCHIP_KERNEL;\n\t\tkvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);\n\tcreate_irqchip_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_CREATE_PIT:\n\t\tu.pit_config.flags = KVM_PIT_SPEAKER_DUMMY;\n\t\tgoto create_pit;\n\tcase KVM_CREATE_PIT2:\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.pit_config, argp,\n\t\t\t\t   sizeof(struct kvm_pit_config)))\n\t\t\tgoto out;\n\tcreate_pit:\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -EEXIST;\n\t\tif (kvm->arch.vpit)\n\t\t\tgoto create_pit_unlock;\n\t\tr = -ENOMEM;\n\t\tkvm->arch.vpit = kvm_create_pit(kvm, u.pit_config.flags);\n\t\tif (kvm->arch.vpit)\n\t\t\tr = 0;\n\tcreate_pit_unlock:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\tcase KVM_GET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_kernel(kvm))\n\t\t\tgoto get_irqchip_out;\n\t\tr = kvm_vm_ioctl_get_irqchip(kvm, chip);\n\t\tif (r)\n\t\t\tgoto get_irqchip_out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, chip, sizeof(*chip)))\n\t\t\tgoto get_irqchip_out;\n\t\tr = 0;\n\tget_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_SET_IRQCHIP: {\n\t\t/* 0: PIC master, 1: PIC slave, 2: IOAPIC */\n\t\tstruct kvm_irqchip *chip;\n\n\t\tchip = memdup_user(argp, sizeof(*chip));\n\t\tif (IS_ERR(chip)) {\n\t\t\tr = PTR_ERR(chip);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = -ENXIO;\n\t\tif (!irqchip_kernel(kvm))\n\t\t\tgoto set_irqchip_out;\n\t\tr = kvm_vm_ioctl_set_irqchip(kvm, chip);\n\tset_irqchip_out:\n\t\tkfree(chip);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit(kvm, &u.ps);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps, sizeof(struct kvm_pit_state)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps, argp, sizeof(u.ps)))\n\t\t\tgoto out;\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto set_pit_out;\n\t\tr = kvm_vm_ioctl_set_pit(kvm, &u.ps);\nset_pit_out:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_GET_PIT2: {\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_get_pit2(kvm, &u.ps2);\n\t\tif (r)\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &u.ps2, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_PIT2: {\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&u.ps2, argp, sizeof(u.ps2)))\n\t\t\tgoto out;\n\t\tmutex_lock(&kvm->lock);\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto set_pit2_out;\n\t\tr = kvm_vm_ioctl_set_pit2(kvm, &u.ps2);\nset_pit2_out:\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n\t}\n\tcase KVM_REINJECT_CONTROL: {\n\t\tstruct kvm_reinject_control control;\n\t\tr =  -EFAULT;\n\t\tif (copy_from_user(&control, argp, sizeof(control)))\n\t\t\tgoto out;\n\t\tr = -ENXIO;\n\t\tif (!kvm->arch.vpit)\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_reinject(kvm, &control);\n\t\tbreak;\n\t}\n\tcase KVM_SET_BOOT_CPU_ID:\n\t\tr = 0;\n\t\tmutex_lock(&kvm->lock);\n\t\tif (kvm->created_vcpus)\n\t\t\tr = -EBUSY;\n\t\telse\n\t\t\tkvm->arch.bsp_vcpu_id = arg;\n\t\tmutex_unlock(&kvm->lock);\n\t\tbreak;\n#ifdef CONFIG_KVM_XEN\n\tcase KVM_XEN_HVM_CONFIG: {\n\t\tstruct kvm_xen_hvm_config xhc;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xhc, argp, sizeof(xhc)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_config(kvm, &xhc);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_GET_ATTR: {\n\t\tstruct kvm_xen_hvm_attr xha;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xha, argp, sizeof(xha)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_get_attr(kvm, &xha);\n\t\tif (!r && copy_to_user(argp, &xha, sizeof(xha)))\n\t\t\tr = -EFAULT;\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_SET_ATTR: {\n\t\tstruct kvm_xen_hvm_attr xha;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&xha, argp, sizeof(xha)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_set_attr(kvm, &xha);\n\t\tbreak;\n\t}\n\tcase KVM_XEN_HVM_EVTCHN_SEND: {\n\t\tstruct kvm_irq_routing_xen_evtchn uxe;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&uxe, argp, sizeof(uxe)))\n\t\t\tgoto out;\n\t\tr = kvm_xen_hvm_evtchn_send(kvm, &uxe);\n\t\tbreak;\n\t}\n#endif\n\tcase KVM_SET_CLOCK:\n\t\tr = kvm_vm_ioctl_set_clock(kvm, argp);\n\t\tbreak;\n\tcase KVM_GET_CLOCK:\n\t\tr = kvm_vm_ioctl_get_clock(kvm, argp);\n\t\tbreak;\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;\n\n\t\tif (kvm_has_tsc_control &&\n\t\t    user_tsc_khz >= kvm_max_guest_tsc_khz)\n\t\t\tgoto out;\n\n\t\tif (user_tsc_khz == 0)\n\t\t\tuser_tsc_khz = tsc_khz;\n\n\t\tWRITE_ONCE(kvm->arch.default_tsc_khz, user_tsc_khz);\n\t\tr = 0;\n\n\t\tgoto out;\n\t}\n\tcase KVM_GET_TSC_KHZ: {\n\t\tr = READ_ONCE(kvm->arch.default_tsc_khz);\n\t\tgoto out;\n\t}\n\tcase KVM_MEMORY_ENCRYPT_OP: {\n\t\tr = -ENOTTY;\n\t\tif (!kvm_x86_ops.mem_enc_ioctl)\n\t\t\tgoto out;\n\n\t\tr = static_call(kvm_x86_mem_enc_ioctl)(kvm, argp);\n\t\tbreak;\n\t}\n\tcase KVM_MEMORY_ENCRYPT_REG_REGION: {\n\t\tstruct kvm_enc_region region;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&region, argp, sizeof(region)))\n\t\t\tgoto out;\n\n\t\tr = -ENOTTY;\n\t\tif (!kvm_x86_ops.mem_enc_register_region)\n\t\t\tgoto out;\n\n\t\tr = static_call(kvm_x86_mem_enc_register_region)(kvm, &region);\n\t\tbreak;\n\t}\n\tcase KVM_MEMORY_ENCRYPT_UNREG_REGION: {\n\t\tstruct kvm_enc_region region;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&region, argp, sizeof(region)))\n\t\t\tgoto out;\n\n\t\tr = -ENOTTY;\n\t\tif (!kvm_x86_ops.mem_enc_unregister_region)\n\t\t\tgoto out;\n\n\t\tr = static_call(kvm_x86_mem_enc_unregister_region)(kvm, &region);\n\t\tbreak;\n\t}\n\tcase KVM_HYPERV_EVENTFD: {\n\t\tstruct kvm_hyperv_eventfd hvevfd;\n\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&hvevfd, argp, sizeof(hvevfd)))\n\t\t\tgoto out;\n\t\tr = kvm_vm_ioctl_hv_eventfd(kvm, &hvevfd);\n\t\tbreak;\n\t}\n\tcase KVM_SET_PMU_EVENT_FILTER:\n\t\tr = kvm_vm_ioctl_set_pmu_event_filter(kvm, argp);\n\t\tbreak;\n\tcase KVM_X86_SET_MSR_FILTER:\n\t\tr = kvm_vm_ioctl_set_msr_filter(kvm, argp);\n\t\tbreak;\n\tdefault:\n\t\tr = -ENOTTY;\n\t}\nout:\n\treturn r;\n}\n\nstatic void kvm_init_msr_list(void)\n{\n\tstruct x86_pmu_capability x86_pmu;\n\tu32 dummy[2];\n\tunsigned i;\n\n\tBUILD_BUG_ON_MSG(KVM_PMC_MAX_FIXED != 3,\n\t\t\t \"Please update the fixed PMCs in msrs_to_saved_all[]\");\n\n\tperf_get_x86_pmu_capability(&x86_pmu);\n\n\tnum_msrs_to_save = 0;\n\tnum_emulated_msrs = 0;\n\tnum_msr_based_features = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(msrs_to_save_all); i++) {\n\t\tif (rdmsr_safe(msrs_to_save_all[i], &dummy[0], &dummy[1]) < 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Even MSRs that are valid in the host may not be exposed\n\t\t * to the guests in some cases.\n\t\t */\n\t\tswitch (msrs_to_save_all[i]) {\n\t\tcase MSR_IA32_BNDCFGS:\n\t\t\tif (!kvm_mpx_supported())\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_TSC_AUX:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_RDTSCP) &&\n\t\t\t    !kvm_cpu_cap_has(X86_FEATURE_RDPID))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_WAITPKG))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_CTL:\n\t\tcase MSR_IA32_RTIT_STATUS:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||\n\t\t\t    !intel_pt_validate_hw_cap(PT_CAP_cr3_filtering))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||\n\t\t\t\t(!intel_pt_validate_hw_cap(PT_CAP_topa_output) &&\n\t\t\t\t !intel_pt_validate_hw_cap(PT_CAP_single_range_output)))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT) ||\n\t\t\t\tmsrs_to_save_all[i] - MSR_IA32_RTIT_ADDR0_A >=\n\t\t\t\tintel_pt_validate_hw_cap(PT_CAP_num_address_ranges) * 2)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_ARCH_PERFMON_PERFCTR0 ... MSR_ARCH_PERFMON_PERFCTR0 + 17:\n\t\t\tif (msrs_to_save_all[i] - MSR_ARCH_PERFMON_PERFCTR0 >=\n\t\t\t    min(INTEL_PMC_MAX_GENERIC, x86_pmu.num_counters_gp))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_ARCH_PERFMON_EVENTSEL0 ... MSR_ARCH_PERFMON_EVENTSEL0 + 17:\n\t\t\tif (msrs_to_save_all[i] - MSR_ARCH_PERFMON_EVENTSEL0 >=\n\t\t\t    min(INTEL_PMC_MAX_GENERIC, x86_pmu.num_counters_gp))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MSR_IA32_XFD:\n\t\tcase MSR_IA32_XFD_ERR:\n\t\t\tif (!kvm_cpu_cap_has(X86_FEATURE_XFD))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmsrs_to_save[num_msrs_to_save++] = msrs_to_save_all[i];\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(emulated_msrs_all); i++) {\n\t\tif (!static_call(kvm_x86_has_emulated_msr)(NULL, emulated_msrs_all[i]))\n\t\t\tcontinue;\n\n\t\temulated_msrs[num_emulated_msrs++] = emulated_msrs_all[i];\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(msr_based_features_all); i++) {\n\t\tstruct kvm_msr_entry msr;\n\n\t\tmsr.index = msr_based_features_all[i];\n\t\tif (kvm_get_msr_feature(&msr))\n\t\t\tcontinue;\n\n\t\tmsr_based_features[num_msr_based_features++] = msr_based_features_all[i];\n\t}\n}\n\nstatic int vcpu_mmio_write(struct kvm_vcpu *vcpu, gpa_t addr, int len,\n\t\t\t   const void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_write(vcpu, &vcpu->arch.apic->dev, addr, n, v))\n\t\t    && kvm_io_bus_write(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tint handled = 0;\n\tint n;\n\n\tdo {\n\t\tn = min(len, 8);\n\t\tif (!(lapic_in_kernel(vcpu) &&\n\t\t      !kvm_iodevice_read(vcpu, &vcpu->arch.apic->dev,\n\t\t\t\t\t addr, n, v))\n\t\t    && kvm_io_bus_read(vcpu, KVM_MMIO_BUS, addr, n, v))\n\t\t\tbreak;\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, n, addr, v);\n\t\thandled += n;\n\t\taddr += n;\n\t\tlen -= n;\n\t\tv += n;\n\t} while (len);\n\n\treturn handled;\n}\n\nstatic void kvm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_segment *var, int seg)\n{\n\tstatic_call(kvm_x86_set_segment)(vcpu, var, seg);\n}\n\nvoid kvm_get_segment(struct kvm_vcpu *vcpu,\n\t\t     struct kvm_segment *var, int seg)\n{\n\tstatic_call(kvm_x86_get_segment)(vcpu, var, seg);\n}\n\ngpa_t translate_nested_gpa(struct kvm_vcpu *vcpu, gpa_t gpa, u64 access,\n\t\t\t   struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tgpa_t t_gpa;\n\n\tBUG_ON(!mmu_is_nested(vcpu));\n\n\t/* NPT walks are always user-walks */\n\taccess |= PFERR_USER_MASK;\n\tt_gpa  = mmu->gva_to_gpa(vcpu, mmu, gpa, access, exception);\n\n\treturn t_gpa;\n}\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n}\nEXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_read);\n\n gpa_t kvm_mmu_gva_to_gpa_fetch(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_FETCH_MASK;\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n}\n\ngpa_t kvm_mmu_gva_to_gpa_write(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\taccess |= PFERR_WRITE_MASK;\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n}\nEXPORT_SYMBOL_GPL(kvm_mmu_gva_to_gpa_write);\n\n/* uses this to access any guest's mapped memory without checking CPL */\ngpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\treturn mmu->gva_to_gpa(vcpu, mmu, gva, 0, exception);\n}\n\nstatic int kvm_read_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u64 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned toread = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, data,\n\t\t\t\t\t       offset, toread);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= toread;\n\t\tdata += toread;\n\t\taddr += toread;\n\t}\nout:\n\treturn r;\n}\n\n/* used for instruction fetching */\nstatic int kvm_fetch_guest_virt(struct x86_emulate_ctxt *ctxt,\n\t\t\t\tgva_t addr, void *val, unsigned int bytes,\n\t\t\t\tstruct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\tunsigned offset;\n\tint ret;\n\n\t/* Inline kvm_read_guest_virt_helper for speed.  */\n\tgpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access|PFERR_FETCH_MASK,\n\t\t\t\t    exception);\n\tif (unlikely(gpa == UNMAPPED_GVA))\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\n\toffset = addr & (PAGE_SIZE-1);\n\tif (WARN_ON(offset + bytes > PAGE_SIZE))\n\t\tbytes = (unsigned)PAGE_SIZE - offset;\n\tret = kvm_vcpu_read_guest_page(vcpu, gpa >> PAGE_SHIFT, val,\n\t\t\t\t       offset, bytes);\n\tif (unlikely(ret < 0))\n\t\treturn X86EMUL_IO_NEEDED;\n\n\treturn X86EMUL_CONTINUE;\n}\n\nint kvm_read_guest_virt(struct kvm_vcpu *vcpu,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tu64 access = (static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\t/*\n\t * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED\n\t * is returned, but our callers are not ready for that and they blindly\n\t * call kvm_inject_page_fault.  Ensure that they at least do not leak\n\t * uninitialized kernel stack memory into cr2 and error code.\n\t */\n\tmemset(exception, 0, sizeof(*exception));\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}\nEXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n\nstatic int emulator_read_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t     gva_t addr, void *val, unsigned int bytes,\n\t\t\t     struct x86_exception *exception, bool system)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu64 access = 0;\n\n\tif (system)\n\t\taccess |= PFERR_IMPLICIT_ACCESS;\n\telse if (static_call(kvm_x86_get_cpl)(vcpu) == 3)\n\t\taccess |= PFERR_USER_MASK;\n\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);\n}\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}\n\nstatic int kvm_write_guest_virt_helper(gva_t addr, void *val, unsigned int bytes,\n\t\t\t\t      struct kvm_vcpu *vcpu, u64 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tvoid *data = val;\n\tint r = X86EMUL_CONTINUE;\n\n\twhile (bytes) {\n\t\tgpa_t gpa = mmu->gva_to_gpa(vcpu, mmu, addr, access, exception);\n\t\tunsigned offset = addr & (PAGE_SIZE-1);\n\t\tunsigned towrite = min(bytes, (unsigned)PAGE_SIZE - offset);\n\t\tint ret;\n\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\tret = kvm_vcpu_write_guest(vcpu, gpa, data, towrite);\n\t\tif (ret < 0) {\n\t\t\tr = X86EMUL_IO_NEEDED;\n\t\t\tgoto out;\n\t\t}\n\n\t\tbytes -= towrite;\n\t\tdata += towrite;\n\t\taddr += towrite;\n\t}\nout:\n\treturn r;\n}\n\nstatic int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,\n\t\t\t      unsigned int bytes, struct x86_exception *exception,\n\t\t\t      bool system)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu64 access = PFERR_WRITE_MASK;\n\n\tif (system)\n\t\taccess |= PFERR_IMPLICIT_ACCESS;\n\telse if (static_call(kvm_x86_get_cpl)(vcpu) == 3)\n\t\taccess |= PFERR_USER_MASK;\n\n\treturn kvm_write_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t   access, exception);\n}\n\nint kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,\n\t\t\t\tunsigned int bytes, struct x86_exception *exception)\n{\n\t/* kvm_write_guest_virt_system can pull in tons of pages. */\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\treturn kvm_write_guest_virt_helper(addr, val, bytes, vcpu,\n\t\t\t\t\t   PFERR_WRITE_MASK, exception);\n}\nEXPORT_SYMBOL_GPL(kvm_write_guest_virt_system);\n\nstatic int kvm_can_emulate_insn(struct kvm_vcpu *vcpu, int emul_type,\n\t\t\t\tvoid *insn, int insn_len)\n{\n\treturn static_call(kvm_x86_can_emulate_instruction)(vcpu, emul_type,\n\t\t\t\t\t\t\t    insn, insn_len);\n}\n\nint handle_ud(struct kvm_vcpu *vcpu)\n{\n\tstatic const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };\n\tint emul_type = EMULTYPE_TRAP_UD;\n\tchar sig[5]; /* ud2; .ascii \"kvm\" */\n\tstruct x86_exception e;\n\n\tif (unlikely(!kvm_can_emulate_insn(vcpu, emul_type, NULL, 0)))\n\t\treturn 1;\n\n\tif (force_emulation_prefix &&\n\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n\t    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {\n\t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n\t\temul_type = EMULTYPE_TRAP_UD_FORCED;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, emul_type);\n}\nEXPORT_SYMBOL_GPL(handle_ud);\n\nstatic int vcpu_is_mmio_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t    gpa_t gpa, bool write)\n{\n\t/* For APIC access vmexit */\n\tif ((gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\treturn 1;\n\n\tif (vcpu_match_mmio_gpa(vcpu, gpa)) {\n\t\ttrace_vcpu_match_mmio(gva, gpa, write, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int vcpu_mmio_gva_to_gpa(struct kvm_vcpu *vcpu, unsigned long gva,\n\t\t\t\tgpa_t *gpa, struct x86_exception *exception,\n\t\t\t\tbool write)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tu64 access = ((static_call(kvm_x86_get_cpl)(vcpu) == 3) ? PFERR_USER_MASK : 0)\n\t\t| (write ? PFERR_WRITE_MASK : 0);\n\n\t/*\n\t * currently PKRU is only applied to ept enabled guest so\n\t * there is no pkey in EPT page table for L1 guest or EPT\n\t * shadow page table for L2 guest.\n\t */\n\tif (vcpu_match_mmio_gva(vcpu, gva) && (!is_paging(vcpu) ||\n\t    !permission_fault(vcpu, vcpu->arch.walk_mmu,\n\t\t\t      vcpu->arch.mmio_access, 0, access))) {\n\t\t*gpa = vcpu->arch.mmio_gfn << PAGE_SHIFT |\n\t\t\t\t\t(gva & (PAGE_SIZE - 1));\n\t\ttrace_vcpu_match_mmio(gva, *gpa, write, false);\n\t\treturn 1;\n\t}\n\n\t*gpa = mmu->gva_to_gpa(vcpu, mmu, gva, access, exception);\n\n\tif (*gpa == UNMAPPED_GVA)\n\t\treturn -1;\n\n\treturn vcpu_is_mmio_gpa(vcpu, gva, *gpa, write);\n}\n\nint emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tconst void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_vcpu_write_guest(vcpu, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_page_track_write(vcpu, gpa, val, bytes);\n\treturn 1;\n}\n\nstruct read_write_emulator_ops {\n\tint (*read_write_prepare)(struct kvm_vcpu *vcpu, void *val,\n\t\t\t\t  int bytes);\n\tint (*read_write_emulate)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t  void *val, int bytes);\n\tint (*read_write_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t       int bytes, void *val);\n\tint (*read_write_exit_mmio)(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\t    void *val, int bytes);\n\tbool write;\n};\n\nstatic int read_prepare(struct kvm_vcpu *vcpu, void *val, int bytes)\n{\n\tif (vcpu->mmio_read_completed) {\n\t\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ, bytes,\n\t\t\t       vcpu->mmio_fragments[0].gpa, val);\n\t\tvcpu->mmio_read_completed = 0;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_vcpu_read_guest(vcpu, gpa, val, bytes);\n}\n\nstatic int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}\n\nstatic int write_mmio(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes, void *val)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_WRITE, bytes, gpa, val);\n\treturn vcpu_mmio_write(vcpu, gpa, bytes, val);\n}\n\nstatic int read_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  void *val, int bytes)\n{\n\ttrace_kvm_mmio(KVM_TRACE_MMIO_READ_UNSATISFIED, bytes, gpa, NULL);\n\treturn X86EMUL_IO_NEEDED;\n}\n\nstatic int write_exit_mmio(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t   void *val, int bytes)\n{\n\tstruct kvm_mmio_fragment *frag = &vcpu->mmio_fragments[0];\n\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic const struct read_write_emulator_ops read_emultor = {\n\t.read_write_prepare = read_prepare,\n\t.read_write_emulate = read_emulate,\n\t.read_write_mmio = vcpu_mmio_read,\n\t.read_write_exit_mmio = read_exit_mmio,\n};\n\nstatic const struct read_write_emulator_ops write_emultor = {\n\t.read_write_emulate = write_emulate,\n\t.read_write_mmio = write_mmio,\n\t.read_write_exit_mmio = write_exit_mmio,\n\t.write = true,\n};\n\nstatic int emulator_read_write_onepage(unsigned long addr, void *val,\n\t\t\t\t       unsigned int bytes,\n\t\t\t\t       struct x86_exception *exception,\n\t\t\t\t       struct kvm_vcpu *vcpu,\n\t\t\t\t       const struct read_write_emulator_ops *ops)\n{\n\tgpa_t gpa;\n\tint handled, ret;\n\tbool write = ops->write;\n\tstruct kvm_mmio_fragment *frag;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\t/*\n\t * If the exit was due to a NPF we may already have a GPA.\n\t * If the GPA is present, use it to avoid the GVA to GPA table walk.\n\t * Note, this cannot be used on string operations since string\n\t * operation using rep will only have the initial GPA from the NPF\n\t * occurred.\n\t */\n\tif (ctxt->gpa_available && emulator_can_use_gpa(ctxt) &&\n\t    (addr & ~PAGE_MASK) == (ctxt->gpa_val & ~PAGE_MASK)) {\n\t\tgpa = ctxt->gpa_val;\n\t\tret = vcpu_is_mmio_gpa(vcpu, addr, gpa, write);\n\t} else {\n\t\tret = vcpu_mmio_gva_to_gpa(vcpu, addr, &gpa, exception, write);\n\t\tif (ret < 0)\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t}\n\n\tif (!ret && ops->read_write_emulate(vcpu, gpa, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\t/*\n\t * Is this MMIO handled locally?\n\t */\n\thandled = ops->read_write_mmio(vcpu, gpa, bytes, val);\n\tif (handled == bytes)\n\t\treturn X86EMUL_CONTINUE;\n\n\tgpa += handled;\n\tbytes -= handled;\n\tval += handled;\n\n\tWARN_ON(vcpu->mmio_nr_fragments >= KVM_MAX_MMIO_FRAGMENTS);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_nr_fragments++];\n\tfrag->gpa = gpa;\n\tfrag->data = val;\n\tfrag->len = bytes;\n\treturn X86EMUL_CONTINUE;\n}\n\nstatic int emulator_read_write(struct x86_emulate_ctxt *ctxt,\n\t\t\tunsigned long addr,\n\t\t\tvoid *val, unsigned int bytes,\n\t\t\tstruct x86_exception *exception,\n\t\t\tconst struct read_write_emulator_ops *ops)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tgpa_t gpa;\n\tint rc;\n\n\tif (ops->read_write_prepare &&\n\t\t  ops->read_write_prepare(vcpu, val, bytes))\n\t\treturn X86EMUL_CONTINUE;\n\n\tvcpu->mmio_nr_fragments = 0;\n\n\t/* Crossing a page boundary? */\n\tif (((addr + bytes - 1) ^ addr) & PAGE_MASK) {\n\t\tint now;\n\n\t\tnow = -addr & ~PAGE_MASK;\n\t\trc = emulator_read_write_onepage(addr, val, now, exception,\n\t\t\t\t\t\t vcpu, ops);\n\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\taddr += now;\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\taddr = (u32)addr;\n\t\tval += now;\n\t\tbytes -= now;\n\t}\n\n\trc = emulator_read_write_onepage(addr, val, bytes, exception,\n\t\t\t\t\t vcpu, ops);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (!vcpu->mmio_nr_fragments)\n\t\treturn rc;\n\n\tgpa = vcpu->mmio_fragments[0].gpa;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.len = min(8u, vcpu->mmio_fragments[0].len);\n\tvcpu->run->mmio.is_write = vcpu->mmio_is_write = ops->write;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\tvcpu->run->mmio.phys_addr = gpa;\n\n\treturn ops->read_write_exit_mmio(vcpu, gpa, val, bytes);\n}\n\nstatic int emulator_read_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  unsigned long addr,\n\t\t\t\t  void *val,\n\t\t\t\t  unsigned int bytes,\n\t\t\t\t  struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, val, bytes,\n\t\t\t\t   exception, &read_emultor);\n}\n\nstatic int emulator_write_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t    unsigned long addr,\n\t\t\t    const void *val,\n\t\t\t    unsigned int bytes,\n\t\t\t    struct x86_exception *exception)\n{\n\treturn emulator_read_write(ctxt, addr, (void *)val, bytes,\n\t\t\t\t   exception, &write_emultor);\n}\n\n#define emulator_try_cmpxchg_user(t, ptr, old, new) \\\n\t(__try_cmpxchg_user((t __user *)(ptr), (t *)(old), *(t *)(new), efault ## t))\n\nstatic int emulator_cmpxchg_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     unsigned long addr,\n\t\t\t\t     const void *old,\n\t\t\t\t     const void *new,\n\t\t\t\t     unsigned int bytes,\n\t\t\t\t     struct x86_exception *exception)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tu64 page_line_mask;\n\tunsigned long hva;\n\tgpa_t gpa;\n\tint r;\n\n\t/* guests cmpxchg8b have to be emulated atomically */\n\tif (bytes > 8 || (bytes & (bytes - 1)))\n\t\tgoto emul_write;\n\n\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, addr, NULL);\n\n\tif (gpa == UNMAPPED_GVA ||\n\t    (gpa & PAGE_MASK) == APIC_DEFAULT_PHYS_BASE)\n\t\tgoto emul_write;\n\n\t/*\n\t * Emulate the atomic as a straight write to avoid #AC if SLD is\n\t * enabled in the host and the access splits a cache line.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_SPLIT_LOCK_DETECT))\n\t\tpage_line_mask = ~(cache_line_size() - 1);\n\telse\n\t\tpage_line_mask = PAGE_MASK;\n\n\tif (((gpa + bytes - 1) & page_line_mask) != (gpa & page_line_mask))\n\t\tgoto emul_write;\n\n\thva = kvm_vcpu_gfn_to_hva(vcpu, gpa_to_gfn(gpa));\n\tif (kvm_is_error_hva(hva))\n\t\tgoto emul_write;\n\n\thva += offset_in_page(gpa);\n\n\tswitch (bytes) {\n\tcase 1:\n\t\tr = emulator_try_cmpxchg_user(u8, hva, old, new);\n\t\tbreak;\n\tcase 2:\n\t\tr = emulator_try_cmpxchg_user(u16, hva, old, new);\n\t\tbreak;\n\tcase 4:\n\t\tr = emulator_try_cmpxchg_user(u32, hva, old, new);\n\t\tbreak;\n\tcase 8:\n\t\tr = emulator_try_cmpxchg_user(u64, hva, old, new);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (r < 0)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tif (r)\n\t\treturn X86EMUL_CMPXCHG_FAILED;\n\n\tkvm_page_track_write(vcpu, gpa, new, bytes);\n\n\treturn X86EMUL_CONTINUE;\n\nemul_write:\n\tprintk_once(KERN_WARNING \"kvm: emulating exchange as write\\n\");\n\n\treturn emulator_write_emulated(ctxt, addr, new, bytes, exception);\n}\n\nstatic int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\tint r = 0, i;\n\n\tfor (i = 0; i < vcpu->arch.pio.count; i++) {\n\t\tif (vcpu->arch.pio.in)\n\t\t\tr = kvm_io_bus_read(vcpu, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t\t    vcpu->arch.pio.size, pd);\n\t\telse\n\t\t\tr = kvm_io_bus_write(vcpu, KVM_PIO_BUS,\n\t\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t\t     pd);\n\t\tif (r)\n\t\t\tbreak;\n\t\tpd += vcpu->arch.pio.size;\n\t}\n\treturn r;\n}\n\nstatic int emulator_pio_in_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t       unsigned short port,\n\t\t\t       unsigned int count, bool in)\n{\n\tvcpu->arch.pio.port = port;\n\tvcpu->arch.pio.in = in;\n\tvcpu->arch.pio.count  = count;\n\tvcpu->arch.pio.size = size;\n\n\tif (!kernel_pio(vcpu, vcpu->arch.pio_data))\n\t\treturn 1;\n\n\tvcpu->run->exit_reason = KVM_EXIT_IO;\n\tvcpu->run->io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;\n\tvcpu->run->io.size = size;\n\tvcpu->run->io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;\n\tvcpu->run->io.count = count;\n\tvcpu->run->io.port = port;\n\n\treturn 0;\n}\n\nstatic int __emulator_pio_in(struct kvm_vcpu *vcpu, int size,\n\t\t\t     unsigned short port, unsigned int count)\n{\n\tWARN_ON(vcpu->arch.pio.count);\n\tmemset(vcpu->arch.pio_data, 0, size * count);\n\treturn emulator_pio_in_out(vcpu, size, port, count, true);\n}\n\nstatic void complete_emulator_pio_in(struct kvm_vcpu *vcpu, void *val)\n{\n\tint size = vcpu->arch.pio.size;\n\tunsigned count = vcpu->arch.pio.count;\n\tmemcpy(val, vcpu->arch.pio_data, size * count);\n\ttrace_kvm_pio(KVM_PIO_IN, vcpu->arch.pio.port, size, count, vcpu->arch.pio_data);\n\tvcpu->arch.pio.count = 0;\n}\n\nstatic int emulator_pio_in(struct kvm_vcpu *vcpu, int size,\n\t\t\t   unsigned short port, void *val, unsigned int count)\n{\n\tif (vcpu->arch.pio.count) {\n\t\t/*\n\t\t * Complete a previous iteration that required userspace I/O.\n\t\t * Note, @count isn't guaranteed to match pio.count as userspace\n\t\t * can modify ECX before rerunning the vCPU.  Ignore any such\n\t\t * shenanigans as KVM doesn't support modifying the rep count,\n\t\t * and the emulator ensures @count doesn't overflow the buffer.\n\t\t */\n\t} else {\n\t\tint r = __emulator_pio_in(vcpu, size, port, count);\n\t\tif (!r)\n\t\t\treturn r;\n\n\t\t/* Results already available, fall through.  */\n\t}\n\n\tcomplete_emulator_pio_in(vcpu, val);\n\treturn 1;\n}\n\nstatic int emulator_pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t    int size, unsigned short port, void *val,\n\t\t\t\t    unsigned int count)\n{\n\treturn emulator_pio_in(emul_to_vcpu(ctxt), size, port, val, count);\n\n}\n\nstatic int emulator_pio_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t    unsigned short port, const void *val,\n\t\t\t    unsigned int count)\n{\n\tint ret;\n\n\tmemcpy(vcpu->arch.pio_data, val, size * count);\n\ttrace_kvm_pio(KVM_PIO_OUT, port, size, count, vcpu->arch.pio_data);\n\tret = emulator_pio_in_out(vcpu, size, port, count, false);\n\tif (ret)\n                vcpu->arch.pio.count = 0;\n\n        return ret;\n}\n\nstatic int emulator_pio_out_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t     int size, unsigned short port,\n\t\t\t\t     const void *val, unsigned int count)\n{\n\treturn emulator_pio_out(emul_to_vcpu(ctxt), size, port, val, count);\n}\n\nstatic unsigned long get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\treturn static_call(kvm_x86_get_segment_base)(vcpu, seg);\n}\n\nstatic void emulator_invlpg(struct x86_emulate_ctxt *ctxt, ulong address)\n{\n\tkvm_mmu_invlpg(emul_to_vcpu(ctxt), address);\n}\n\nstatic int kvm_emulate_wbinvd_noskip(struct kvm_vcpu *vcpu)\n{\n\tif (!need_emulate_wbinvd(vcpu))\n\t\treturn X86EMUL_CONTINUE;\n\n\tif (static_call(kvm_x86_has_wbinvd_exit)()) {\n\t\tint cpu = get_cpu();\n\n\t\tcpumask_set_cpu(cpu, vcpu->arch.wbinvd_dirty_mask);\n\t\ton_each_cpu_mask(vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\twbinvd_ipi, NULL, 1);\n\t\tput_cpu();\n\t\tcpumask_clear(vcpu->arch.wbinvd_dirty_mask);\n\t} else\n\t\twbinvd();\n\treturn X86EMUL_CONTINUE;\n}\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_wbinvd_noskip(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_wbinvd);\n\n\n\nstatic void emulator_wbinvd(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_emulate_wbinvd_noskip(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t    unsigned long *dest)\n{\n\tkvm_get_dr(emul_to_vcpu(ctxt), dr, dest);\n}\n\nstatic int emulator_set_dr(struct x86_emulate_ctxt *ctxt, int dr,\n\t\t\t   unsigned long value)\n{\n\n\treturn kvm_set_dr(emul_to_vcpu(ctxt), dr, value);\n}\n\nstatic u64 mk_cr_64(u64 curr_cr, u32 new_val)\n{\n\treturn (curr_cr & ~((1ULL << 32) - 1)) | new_val;\n}\n\nstatic unsigned long emulator_get_cr(struct x86_emulate_ctxt *ctxt, int cr)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long value;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tvalue = kvm_read_cr0(vcpu);\n\t\tbreak;\n\tcase 2:\n\t\tvalue = vcpu->arch.cr2;\n\t\tbreak;\n\tcase 3:\n\t\tvalue = kvm_read_cr3(vcpu);\n\t\tbreak;\n\tcase 4:\n\t\tvalue = kvm_read_cr4(vcpu);\n\t\tbreak;\n\tcase 8:\n\t\tvalue = kvm_get_cr8(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\treturn 0;\n\t}\n\n\treturn value;\n}\n\nstatic int emulator_set_cr(struct x86_emulate_ctxt *ctxt, int cr, ulong val)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint res = 0;\n\n\tswitch (cr) {\n\tcase 0:\n\t\tres = kvm_set_cr0(vcpu, mk_cr_64(kvm_read_cr0(vcpu), val));\n\t\tbreak;\n\tcase 2:\n\t\tvcpu->arch.cr2 = val;\n\t\tbreak;\n\tcase 3:\n\t\tres = kvm_set_cr3(vcpu, val);\n\t\tbreak;\n\tcase 4:\n\t\tres = kvm_set_cr4(vcpu, mk_cr_64(kvm_read_cr4(vcpu), val));\n\t\tbreak;\n\tcase 8:\n\t\tres = kvm_set_cr8(vcpu, val);\n\t\tbreak;\n\tdefault:\n\t\tkvm_err(\"%s: unexpected cr %u\\n\", __func__, cr);\n\t\tres = -1;\n\t}\n\n\treturn res;\n}\n\nstatic int emulator_get_cpl(struct x86_emulate_ctxt *ctxt)\n{\n\treturn static_call(kvm_x86_get_cpl)(emul_to_vcpu(ctxt));\n}\n\nstatic void emulator_get_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_get_gdt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_get_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_get_idt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_gdt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_set_gdt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic void emulator_set_idt(struct x86_emulate_ctxt *ctxt, struct desc_ptr *dt)\n{\n\tstatic_call(kvm_x86_set_idt)(emul_to_vcpu(ctxt), dt);\n}\n\nstatic unsigned long emulator_get_cached_segment_base(\n\tstruct x86_emulate_ctxt *ctxt, int seg)\n{\n\treturn get_segment_base(emul_to_vcpu(ctxt), seg);\n}\n\nstatic bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\tif (base3)\n\t\t\t*base3 = 0;\n\t\treturn false;\n\t}\n\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\n\treturn true;\n}\n\nstatic void emulator_set_segment(struct x86_emulate_ctxt *ctxt, u16 selector,\n\t\t\t\t struct desc_struct *desc, u32 base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tstruct kvm_segment var;\n\n\tvar.selector = selector;\n\tvar.base = get_desc_base(desc);\n#ifdef CONFIG_X86_64\n\tvar.base |= ((u64)base3) << 32;\n#endif\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}\n\nstatic int emulator_get_msr_with_filter(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\tu32 msr_index, u64 *pdata)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r;\n\n\tr = kvm_get_msr_with_filter(vcpu, msr_index, pdata);\n\n\tif (r && kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_RDMSR, 0,\n\t\t\t\t    complete_emulated_rdmsr, r)) {\n\t\t/* Bounce to user space */\n\t\treturn X86EMUL_IO_NEEDED;\n\t}\n\n\treturn r;\n}\n\nstatic int emulator_set_msr_with_filter(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\tu32 msr_index, u64 data)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r;\n\n\tr = kvm_set_msr_with_filter(vcpu, msr_index, data);\n\n\tif (r && kvm_msr_user_space(vcpu, msr_index, KVM_EXIT_X86_WRMSR, data,\n\t\t\t\t    complete_emulated_msr_access, r)) {\n\t\t/* Bounce to user space */\n\t\treturn X86EMUL_IO_NEEDED;\n\t}\n\n\treturn r;\n}\n\nstatic int emulator_get_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 *pdata)\n{\n\treturn kvm_get_msr(emul_to_vcpu(ctxt), msr_index, pdata);\n}\n\nstatic int emulator_set_msr(struct x86_emulate_ctxt *ctxt,\n\t\t\t    u32 msr_index, u64 data)\n{\n\treturn kvm_set_msr(emul_to_vcpu(ctxt), msr_index, data);\n}\n\nstatic u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\treturn vcpu->arch.smbase;\n}\n\nstatic void emulator_set_smbase(struct x86_emulate_ctxt *ctxt, u64 smbase)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tvcpu->arch.smbase = smbase;\n}\n\nstatic int emulator_check_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 pmc)\n{\n\tif (kvm_pmu_is_valid_rdpmc_ecx(emul_to_vcpu(ctxt), pmc))\n\t\treturn 0;\n\treturn -EINVAL;\n}\n\nstatic int emulator_read_pmc(struct x86_emulate_ctxt *ctxt,\n\t\t\t     u32 pmc, u64 *pdata)\n{\n\treturn kvm_pmu_rdpmc(emul_to_vcpu(ctxt), pmc, pdata);\n}\n\nstatic void emulator_halt(struct x86_emulate_ctxt *ctxt)\n{\n\temul_to_vcpu(ctxt)->arch.halt_request = 1;\n}\n\nstatic int emulator_intercept(struct x86_emulate_ctxt *ctxt,\n\t\t\t      struct x86_instruction_info *info,\n\t\t\t      enum x86_intercept_stage stage)\n{\n\treturn static_call(kvm_x86_check_intercept)(emul_to_vcpu(ctxt), info, stage,\n\t\t\t\t\t    &ctxt->exception);\n}\n\nstatic bool emulator_get_cpuid(struct x86_emulate_ctxt *ctxt,\n\t\t\t      u32 *eax, u32 *ebx, u32 *ecx, u32 *edx,\n\t\t\t      bool exact_only)\n{\n\treturn kvm_cpuid(emul_to_vcpu(ctxt), eax, ebx, ecx, edx, exact_only);\n}\n\nstatic bool emulator_guest_has_long_mode(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_LM);\n}\n\nstatic bool emulator_guest_has_movbe(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_MOVBE);\n}\n\nstatic bool emulator_guest_has_fxsr(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_FXSR);\n}\n\nstatic bool emulator_guest_has_rdpid(struct x86_emulate_ctxt *ctxt)\n{\n\treturn guest_cpuid_has(emul_to_vcpu(ctxt), X86_FEATURE_RDPID);\n}\n\nstatic ulong emulator_read_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg)\n{\n\treturn kvm_register_read_raw(emul_to_vcpu(ctxt), reg);\n}\n\nstatic void emulator_write_gpr(struct x86_emulate_ctxt *ctxt, unsigned reg, ulong val)\n{\n\tkvm_register_write_raw(emul_to_vcpu(ctxt), reg, val);\n}\n\nstatic void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)\n{\n\tstatic_call(kvm_x86_set_nmi_mask)(emul_to_vcpu(ctxt), masked);\n}\n\nstatic unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)\n{\n\treturn emul_to_vcpu(ctxt)->arch.hflags;\n}\n\nstatic void emulator_exiting_smm(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\n\tkvm_smm_changed(vcpu, false);\n}\n\nstatic int emulator_leave_smm(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  const char *smstate)\n{\n\treturn static_call(kvm_x86_leave_smm)(emul_to_vcpu(ctxt), smstate);\n}\n\nstatic void emulator_triple_fault(struct x86_emulate_ctxt *ctxt)\n{\n\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, emul_to_vcpu(ctxt));\n}\n\nstatic int emulator_set_xcr(struct x86_emulate_ctxt *ctxt, u32 index, u64 xcr)\n{\n\treturn __kvm_set_xcr(emul_to_vcpu(ctxt), index, xcr);\n}\n\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = emulator_read_std,\n\t.write_std           = emulator_write_std,\n\t.read_phys           = kvm_read_guest_phys_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.get_smbase          = emulator_get_smbase,\n\t.set_smbase          = emulator_set_smbase,\n\t.set_msr_with_filter = emulator_set_msr_with_filter,\n\t.get_msr_with_filter = emulator_get_msr_with_filter,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.check_pmc\t     = emulator_check_pmc,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n\t.guest_has_long_mode = emulator_guest_has_long_mode,\n\t.guest_has_movbe     = emulator_guest_has_movbe,\n\t.guest_has_fxsr      = emulator_guest_has_fxsr,\n\t.guest_has_rdpid     = emulator_guest_has_rdpid,\n\t.set_nmi_mask        = emulator_set_nmi_mask,\n\t.get_hflags          = emulator_get_hflags,\n\t.exiting_smm         = emulator_exiting_smm,\n\t.leave_smm           = emulator_leave_smm,\n\t.triple_fault        = emulator_triple_fault,\n\t.set_xcr             = emulator_set_xcr,\n};\n\nstatic void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)\n{\n\tu32 int_shadow = static_call(kvm_x86_get_interrupt_shadow)(vcpu);\n\t/*\n\t * an sti; sti; sequence only disable interrupts for the first\n\t * instruction. So, if the last instruction, be it emulated or\n\t * not, left the system with the INT_STI flag enabled, it\n\t * means that the last instruction is an sti. We should not\n\t * leave the flag on in this case. The same goes for mov ss\n\t */\n\tif (int_shadow & mask)\n\t\tmask = 0;\n\tif (unlikely(int_shadow || mask)) {\n\t\tstatic_call(kvm_x86_set_interrupt_shadow)(vcpu, mask);\n\t\tif (!mask)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n}\n\nstatic bool inject_emulated_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tif (ctxt->exception.vector == PF_VECTOR)\n\t\treturn kvm_inject_emulated_page_fault(vcpu, &ctxt->exception);\n\n\tif (ctxt->exception.error_code_valid)\n\t\tkvm_queue_exception_e(vcpu, ctxt->exception.vector,\n\t\t\t\t      ctxt->exception.error_code);\n\telse\n\t\tkvm_queue_exception(vcpu, ctxt->exception.vector);\n\treturn false;\n}\n\nstatic struct x86_emulate_ctxt *alloc_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt;\n\n\tctxt = kmem_cache_zalloc(x86_emulator_cache, GFP_KERNEL_ACCOUNT);\n\tif (!ctxt) {\n\t\tpr_err(\"kvm: failed to allocate vcpu's emulator\\n\");\n\t\treturn NULL;\n\t}\n\n\tctxt->vcpu = vcpu;\n\tctxt->ops = &emulate_ops;\n\tvcpu->arch.emulate_ctxt = ctxt;\n\n\treturn ctxt;\n}\n\nstatic void init_emulate_ctxt(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint cs_db, cs_l;\n\n\tstatic_call(kvm_x86_get_cs_db_l_bits)(vcpu, &cs_db, &cs_l);\n\n\tctxt->gpa_available = false;\n\tctxt->eflags = kvm_get_rflags(vcpu);\n\tctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;\n\n\tctxt->eip = kvm_rip_read(vcpu);\n\tctxt->mode = (!is_protmode(vcpu))\t\t? X86EMUL_MODE_REAL :\n\t\t     (ctxt->eflags & X86_EFLAGS_VM)\t? X86EMUL_MODE_VM86 :\n\t\t     (cs_l && is_long_mode(vcpu))\t? X86EMUL_MODE_PROT64 :\n\t\t     cs_db\t\t\t\t? X86EMUL_MODE_PROT32 :\n\t\t\t\t\t\t\t  X86EMUL_MODE_PROT16;\n\tBUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);\n\tBUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);\n\tBUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);\n\n\tctxt->interruptibility = 0;\n\tctxt->have_exception = false;\n\tctxt->exception.vector = -1;\n\tctxt->perm_ok = false;\n\n\tinit_decode_cache(ctxt);\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n}\n\nvoid kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_inject_realmode_interrupt);\n\nstatic void prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,\n\t\t\t\t\t   u8 ndata, u8 *insn_bytes, u8 insn_size)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tu64 info[5];\n\tu8 info_start;\n\n\t/*\n\t * Zero the whole array used to retrieve the exit info, as casting to\n\t * u32 for select entries will leave some chunks uninitialized.\n\t */\n\tmemset(&info, 0, sizeof(info));\n\n\tstatic_call(kvm_x86_get_exit_info)(vcpu, (u32 *)&info[0], &info[1],\n\t\t\t\t\t   &info[2], (u32 *)&info[3],\n\t\t\t\t\t   (u32 *)&info[4]);\n\n\trun->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\trun->emulation_failure.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\n\t/*\n\t * There's currently space for 13 entries, but 5 are used for the exit\n\t * reason and info.  Restrict to 4 to reduce the maintenance burden\n\t * when expanding kvm_run.emulation_failure in the future.\n\t */\n\tif (WARN_ON_ONCE(ndata > 4))\n\t\tndata = 4;\n\n\t/* Always include the flags as a 'data' entry. */\n\tinfo_start = 1;\n\trun->emulation_failure.flags = 0;\n\n\tif (insn_size) {\n\t\tBUILD_BUG_ON((sizeof(run->emulation_failure.insn_size) +\n\t\t\t      sizeof(run->emulation_failure.insn_bytes) != 16));\n\t\tinfo_start += 2;\n\t\trun->emulation_failure.flags |=\n\t\t\tKVM_INTERNAL_ERROR_EMULATION_FLAG_INSTRUCTION_BYTES;\n\t\trun->emulation_failure.insn_size = insn_size;\n\t\tmemset(run->emulation_failure.insn_bytes, 0x90,\n\t\t       sizeof(run->emulation_failure.insn_bytes));\n\t\tmemcpy(run->emulation_failure.insn_bytes, insn_bytes, insn_size);\n\t}\n\n\tmemcpy(&run->internal.data[info_start], info, sizeof(info));\n\tmemcpy(&run->internal.data[info_start + ARRAY_SIZE(info)], data,\n\t       ndata * sizeof(data[0]));\n\n\trun->emulation_failure.ndata = info_start + ARRAY_SIZE(info) + ndata;\n}\n\nstatic void prepare_emulation_ctxt_failure_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tprepare_emulation_failure_exit(vcpu, NULL, 0, ctxt->fetch.data,\n\t\t\t\t       ctxt->fetch.end - ctxt->fetch.data);\n}\n\nvoid __kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu, u64 *data,\n\t\t\t\t\t  u8 ndata)\n{\n\tprepare_emulation_failure_exit(vcpu, data, ndata, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(__kvm_prepare_emulation_failure_exit);\n\nvoid kvm_prepare_emulation_failure_exit(struct kvm_vcpu *vcpu)\n{\n\t__kvm_prepare_emulation_failure_exit(vcpu, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_prepare_emulation_failure_exit);\n\nstatic int handle_emulation_failure(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\n\tif (emulation_type & EMULTYPE_VMWARE_GP) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\tif (kvm->arch.exit_on_emulation_error ||\n\t    (emulation_type & EMULTYPE_SKIP)) {\n\t\tprepare_emulation_ctxt_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\tif (!is_guest_mode(vcpu) && static_call(kvm_x86_get_cpl)(vcpu) == 0) {\n\t\tprepare_emulation_ctxt_failure_exit(vcpu);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic bool reexecute_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t  bool write_fault_to_shadow_pgtable,\n\t\t\t\t  int emulation_type)\n{\n\tgpa_t gpa = cr2_or_gpa;\n\tkvm_pfn_t pfn;\n\n\tif (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))\n\t\treturn false;\n\n\tif (WARN_ON_ONCE(is_guest_mode(vcpu)) ||\n\t    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))\n\t\treturn false;\n\n\tif (!vcpu->arch.mmu->root_role.direct) {\n\t\t/*\n\t\t * Write permission should be allowed since only\n\t\t * write access need to be emulated.\n\t\t */\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);\n\n\t\t/*\n\t\t * If the mapping is invalid in guest, let cpu retry\n\t\t * it to generate fault.\n\t\t */\n\t\tif (gpa == UNMAPPED_GVA)\n\t\t\treturn true;\n\t}\n\n\t/*\n\t * Do not retry the unhandleable instruction if it faults on the\n\t * readonly host memory, otherwise it will goto a infinite loop:\n\t * retry instruction -> write #PF -> emulation fail -> retry\n\t * instruction -> ...\n\t */\n\tpfn = gfn_to_pfn(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the instruction failed on the error pfn, it can not be fixed,\n\t * report the error to userspace.\n\t */\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn false;\n\n\tkvm_release_pfn_clean(pfn);\n\n\t/* The instructions are well-emulated on direct mmu. */\n\tif (vcpu->arch.mmu->root_role.direct) {\n\t\tunsigned int indirect_shadow_pages;\n\n\t\twrite_lock(&vcpu->kvm->mmu_lock);\n\t\tindirect_shadow_pages = vcpu->kvm->arch.indirect_shadow_pages;\n\t\twrite_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tif (indirect_shadow_pages)\n\t\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t\treturn true;\n\t}\n\n\t/*\n\t * if emulation was due to access to shadowed page table\n\t * and it failed try to unshadow page and re-enter the\n\t * guest to let CPU execute the instruction.\n\t */\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\t/*\n\t * If the access faults on its page table, it can not\n\t * be fixed by unprotecting shadow page and it should\n\t * be reported to userspace.\n\t */\n\treturn !write_fault_to_shadow_pgtable;\n}\n\nstatic bool retry_instruction(struct x86_emulate_ctxt *ctxt,\n\t\t\t      gpa_t cr2_or_gpa,  int emulation_type)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tunsigned long last_retry_eip, last_retry_addr, gpa = cr2_or_gpa;\n\n\tlast_retry_eip = vcpu->arch.last_retry_eip;\n\tlast_retry_addr = vcpu->arch.last_retry_addr;\n\n\t/*\n\t * If the emulation is caused by #PF and it is non-page_table\n\t * writing instruction, it means the VM-EXIT is caused by shadow\n\t * page protected, we can zap the shadow page and retry this\n\t * instruction directly.\n\t *\n\t * Note: if the guest uses a non-page-table modifying instruction\n\t * on the PDE that points to the instruction, then we will unmap\n\t * the instruction and go to an infinite loop. So, we cache the\n\t * last retried eip and the last fault address, if we meet the eip\n\t * and the address again, we can break out of the potential infinite\n\t * loop.\n\t */\n\tvcpu->arch.last_retry_eip = vcpu->arch.last_retry_addr = 0;\n\n\tif (!(emulation_type & EMULTYPE_ALLOW_RETRY_PF))\n\t\treturn false;\n\n\tif (WARN_ON_ONCE(is_guest_mode(vcpu)) ||\n\t    WARN_ON_ONCE(!(emulation_type & EMULTYPE_PF)))\n\t\treturn false;\n\n\tif (x86_page_table_writing_insn(ctxt))\n\t\treturn false;\n\n\tif (ctxt->eip == last_retry_eip && last_retry_addr == cr2_or_gpa)\n\t\treturn false;\n\n\tvcpu->arch.last_retry_eip = ctxt->eip;\n\tvcpu->arch.last_retry_addr = cr2_or_gpa;\n\n\tif (!vcpu->arch.mmu->root_role.direct)\n\t\tgpa = kvm_mmu_gva_to_gpa_write(vcpu, cr2_or_gpa, NULL);\n\n\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(gpa));\n\n\treturn true;\n}\n\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu, bool entering_smm)\n{\n\ttrace_kvm_smm_transition(vcpu->vcpu_id, vcpu->arch.smbase, entering_smm);\n\n\tif (entering_smm) {\n\t\tvcpu->arch.hflags |= HF_SMM_MASK;\n\t} else {\n\t\tvcpu->arch.hflags &= ~(HF_SMM_MASK | HF_SMM_INSIDE_NMI_MASK);\n\n\t\t/* Process a latched INIT or SMI, if any.  */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t\t/*\n\t\t * Even if KVM_SET_SREGS2 loaded PDPTRs out of band,\n\t\t * on SMM exit we still need to reload them from\n\t\t * guest memory\n\t\t */\n\t\tvcpu->arch.pdptrs_from_userspace = false;\n\t}\n\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,\n\t\t\t\tunsigned long *db)\n{\n\tu32 dr6 = 0;\n\tint i;\n\tu32 enable, rwlen;\n\n\tenable = dr7;\n\trwlen = dr7 >> 16;\n\tfor (i = 0; i < 4; i++, enable >>= 2, rwlen >>= 4)\n\t\tif ((enable & 3) && (rwlen & 15) == type && db[i] == addr)\n\t\t\tdr6 |= (1 << i);\n\treturn dr6;\n}\n\nstatic int kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP) {\n\t\tkvm_run->debug.arch.dr6 = DR6_BS | DR6_ACTIVE_LOW;\n\t\tkvm_run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\treturn 0;\n\t}\n\tkvm_queue_exception_p(vcpu, DB_VECTOR, DR6_BS);\n\treturn 1;\n}\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\tint r;\n\n\tr = static_call(kvm_x86_skip_emulated_instruction)(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);\n\nstatic bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool is_vmware_backdoor_opcode(struct x86_emulate_ctxt *ctxt)\n{\n\tswitch (ctxt->opcode_len) {\n\tcase 1:\n\t\tswitch (ctxt->b) {\n\t\tcase 0xe4:\t/* IN */\n\t\tcase 0xe5:\n\t\tcase 0xec:\n\t\tcase 0xed:\n\t\tcase 0xe6:\t/* OUT */\n\t\tcase 0xe7:\n\t\tcase 0xee:\n\t\tcase 0xef:\n\t\tcase 0x6c:\t/* INS */\n\t\tcase 0x6d:\n\t\tcase 0x6e:\t/* OUTS */\n\t\tcase 0x6f:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (ctxt->b) {\n\t\tcase 0x33:\t/* RDPMC */\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n/*\n * Decode an instruction for emulation.  The caller is responsible for handling\n * code breakpoints.  Note, manually detecting code breakpoints is unnecessary\n * (and wrong) when emulating on an intercepted fault-like exception[*], as\n * code breakpoints have higher priority and thus have already been done by\n * hardware.\n *\n * [*] Except #MC, which is higher priority, but KVM should never emulate in\n *     response to a machine check.\n */\nint x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}\nEXPORT_SYMBOL_GPL(x86_decode_emulated_instruction);\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    int emulation_type, void *insn, int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt;\n\n\tif (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len)))\n\t\treturn 1;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\twrite_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tkvm_clear_exception_queue(vcpu);\n\n\t\t/*\n\t\t * Return immediately if RIP hits a code breakpoint, such #DBs\n\t\t * are fault-like and are higher priority than any faults on\n\t\t * the code fetch itself.\n\t\t */\n\t\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t\t    kvm_vcpu_check_code_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tr = x86_decode_emulated_instruction(vcpu, emulation_type,\n\t\t\t\t\t\t    insn, insn_len);\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif ((emulation_type & EMULTYPE_TRAP_UD) ||\n\t\t\t    (emulation_type & EMULTYPE_TRAP_UD_FORCED)) {\n\t\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (reexecute_instruction(vcpu, cr2_or_gpa,\n\t\t\t\t\t\t  write_fault_to_spt,\n\t\t\t\t\t\t  emulation_type))\n\t\t\t\treturn 1;\n\t\t\tif (ctxt->have_exception) {\n\t\t\t\t/*\n\t\t\t\t * #UD should result in just EMULATION_FAILED, and trap-like\n\t\t\t\t * exception should not be encountered during decode.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||\n\t\t\t\t\t     exception_type(ctxt->exception.vector) == EXCPT_TRAP);\n\t\t\t\tinject_emulated_exception(vcpu);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t\t}\n\t}\n\n\tif ((emulation_type & EMULTYPE_VMWARE_GP) &&\n\t    !is_vmware_backdoor_opcode(ctxt)) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * EMULTYPE_SKIP without EMULTYPE_COMPLETE_USER_EXIT is intended for\n\t * use *only* by vendor callbacks for kvm_skip_emulated_instruction().\n\t * The caller is responsible for updating interruptibility state and\n\t * injecting single-step #DBs.\n\t */\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tif (ctxt->mode != X86EMUL_MODE_PROT64)\n\t\t\tctxt->eip = (u32)ctxt->_eip;\n\t\telse\n\t\t\tctxt->eip = ctxt->_eip;\n\n\t\tif (emulation_type & EMULTYPE_COMPLETE_USER_EXIT) {\n\t\t\tr = 1;\n\t\t\tgoto writeback;\n\t\t}\n\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn 1;\n\t}\n\n\tif (retry_instruction(ctxt, cr2_or_gpa, emulation_type))\n\t\treturn 1;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tif (emulation_type & EMULTYPE_PF) {\n\t\t/* Save the faulting GPA (cr2) in the address field */\n\t\tctxt->exception.address = cr2_or_gpa;\n\n\t\t/* With shadow page tables, cr2 contains a GVA or nGPA. */\n\t\tif (vcpu->arch.mmu->root_role.direct) {\n\t\t\tctxt->gpa_available = true;\n\t\t\tctxt->gpa_val = cr2_or_gpa;\n\t\t}\n\t} else {\n\t\t/* Sanitize the address out of an abundance of paranoia. */\n\t\tctxt->exception.address = 0;\n\t}\n\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn 1;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn 1;\n\n\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = 1;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = 0;\n\t} else if (vcpu->mmio_needed) {\n\t\t++vcpu->stat.mmio_exits;\n\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = 0;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (vcpu->arch.complete_userspace_io) {\n\t\twriteback = false;\n\t\tr = 0;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = 1;\n\nwriteback:\n\tif (writeback) {\n\t\tunsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {\n\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS);\n\t\t\tif (ctxt->is_branch)\n\t\t\t\tkvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS);\n\t\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\t\tif (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))\n\t\t\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\t\t\tstatic_call_cond(kvm_x86_update_emulated_instruction)(vcpu);\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\t\t}\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_instruction);\n\nint kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\treturn x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_instruction_from_buffer);\n\nstatic int complete_fast_pio_out_port_0x7e(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pio.count = 0;\n\treturn 1;\n}\n\nstatic int complete_fast_pio_out(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pio.count = 0;\n\n\tif (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip)))\n\t\treturn 1;\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int kvm_fast_pio_out(struct kvm_vcpu *vcpu, int size,\n\t\t\t    unsigned short port)\n{\n\tunsigned long val = kvm_rax_read(vcpu);\n\tint ret = emulator_pio_out(vcpu, size, port, &val, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Workaround userspace that relies on old KVM behavior of %rip being\n\t * incremented prior to exiting to userspace to handle \"OUT 0x7e\".\n\t */\n\tif (port == 0x7e &&\n\t    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_OUT_7E_INC_RIP)) {\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\tcomplete_fast_pio_out_port_0x7e;\n\t\tkvm_skip_emulated_instruction(vcpu);\n\t} else {\n\t\tvcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);\n\t\tvcpu->arch.complete_userspace_io = complete_fast_pio_out;\n\t}\n\treturn 0;\n}\n\nstatic int complete_fast_pio_in(struct kvm_vcpu *vcpu)\n{\n\tunsigned long val;\n\n\t/* We should only ever be called with arch.pio.count equal to 1 */\n\tBUG_ON(vcpu->arch.pio.count != 1);\n\n\tif (unlikely(!kvm_is_linear_rip(vcpu, vcpu->arch.pio.linear_rip))) {\n\t\tvcpu->arch.pio.count = 0;\n\t\treturn 1;\n\t}\n\n\t/* For size less than 4 we merge, else we zero extend */\n\tval = (vcpu->arch.pio.size < 4) ? kvm_rax_read(vcpu) : 0;\n\n\t/*\n\t * Since vcpu->arch.pio.count == 1 let emulator_pio_in perform\n\t * the copy and tracing\n\t */\n\temulator_pio_in(vcpu, vcpu->arch.pio.size, vcpu->arch.pio.port, &val, 1);\n\tkvm_rax_write(vcpu, val);\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nstatic int kvm_fast_pio_in(struct kvm_vcpu *vcpu, int size,\n\t\t\t   unsigned short port)\n{\n\tunsigned long val;\n\tint ret;\n\n\t/* For size less than 4 we merge, else we zero extend */\n\tval = (size < 4) ? kvm_rax_read(vcpu) : 0;\n\n\tret = emulator_pio_in(vcpu, size, port, &val, 1);\n\tif (ret) {\n\t\tkvm_rax_write(vcpu, val);\n\t\treturn ret;\n\t}\n\n\tvcpu->arch.pio.linear_rip = kvm_get_linear_rip(vcpu);\n\tvcpu->arch.complete_userspace_io = complete_fast_pio_in;\n\n\treturn 0;\n}\n\nint kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)\n{\n\tint ret;\n\n\tif (in)\n\t\tret = kvm_fast_pio_in(vcpu, size, port);\n\telse\n\t\tret = kvm_fast_pio_out(vcpu, size, port);\n\treturn ret && kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_fast_pio);\n\nstatic int kvmclock_cpu_down_prep(unsigned int cpu)\n{\n\t__this_cpu_write(cpu_tsc_khz, 0);\n\treturn 0;\n}\n\nstatic void tsc_khz_changed(void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tunsigned long khz = 0;\n\n\tif (data)\n\t\tkhz = freq->new;\n\telse if (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tkhz = cpufreq_quick_get(raw_smp_processor_id());\n\tif (!khz)\n\t\tkhz = tsc_khz;\n\t__this_cpu_write(cpu_tsc_khz, khz);\n}\n\n#ifdef CONFIG_X86_64\nstatic void kvm_hyperv_tsc_notifier(void)\n{\n\tstruct kvm *kvm;\n\tint cpu;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_make_mclock_inprogress_request(kvm);\n\n\t/* no guest entries from this point */\n\thyperv_stop_tsc_emulation();\n\n\t/* TSC frequency always matches when on Hyper-V */\n\tfor_each_present_cpu(cpu)\n\t\tper_cpu(cpu_tsc_khz, cpu) = tsc_khz;\n\tkvm_max_guest_tsc_khz = tsc_khz;\n\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t__kvm_start_pvclock_update(kvm);\n\t\tpvclock_update_vm_gtod_copy(kvm);\n\t\tkvm_end_pvclock_update(kvm);\n\t}\n\n\tmutex_unlock(&kvm_lock);\n}\n#endif\n\nstatic void __kvmclock_cpufreq_notifier(struct cpufreq_freqs *freq, int cpu)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint send_ipi = 0;\n\tunsigned long i;\n\n\t/*\n\t * We allow guests to temporarily run on slowing clocks,\n\t * provided we notify them after, or to run on accelerating\n\t * clocks, provided we notify them before.  Thus time never\n\t * goes backwards.\n\t *\n\t * However, we have a problem.  We can't atomically update\n\t * the frequency of a given CPU from this function; it is\n\t * merely a notifier, which can be called from any CPU.\n\t * Changing the TSC frequency at arbitrary points in time\n\t * requires a recomputation of local variables related to\n\t * the TSC for each VCPU.  We must flag these local variables\n\t * to be updated and be sure the update takes place with the\n\t * new frequency before any guests proceed.\n\t *\n\t * Unfortunately, the combination of hotplug CPU and frequency\n\t * change creates an intractable locking scenario; the order\n\t * of when these callouts happen is undefined with respect to\n\t * CPU hotplug, and they can race with each other.  As such,\n\t * merely setting per_cpu(cpu_tsc_khz) = X during a hotadd is\n\t * undefined; you can actually have a CPU frequency change take\n\t * place in between the computation of X and the setting of the\n\t * variable.  To protect against this problem, all updates of\n\t * the per_cpu tsc_khz variable are done in an interrupt\n\t * protected IPI, and all callers wishing to update the value\n\t * must wait for a synchronous IPI to complete (which is trivial\n\t * if the caller is on the CPU already).  This establishes the\n\t * necessary total order on variable updates.\n\t *\n\t * Note that because a guest time update may take place\n\t * anytime after the setting of the VCPU's request bit, the\n\t * correct TSC value must be set before the request.  However,\n\t * to ensure the update actually makes it to any guest which\n\t * starts running in hardware virtualization between the set\n\t * and the acquisition of the spinlock, we must also ping the\n\t * CPU after setting the request bit.\n\t *\n\t */\n\n\tsmp_call_function_single(cpu, tsc_khz_changed, freq, 1);\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (vcpu->cpu != cpu)\n\t\t\t\tcontinue;\n\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (vcpu->cpu != raw_smp_processor_id())\n\t\t\t\tsend_ipi = 1;\n\t\t}\n\t}\n\tmutex_unlock(&kvm_lock);\n\n\tif (freq->old < freq->new && send_ipi) {\n\t\t/*\n\t\t * We upscale the frequency.  Must make the guest\n\t\t * doesn't see old kvmclock values while running with\n\t\t * the new frequency, otherwise we risk the guest sees\n\t\t * time go backwards.\n\t\t *\n\t\t * In case we update the frequency for another cpu\n\t\t * (which might be in guest context) send an interrupt\n\t\t * to kick the cpu out of guest context.  Next time\n\t\t * guest context is entered kvmclock will be updated,\n\t\t * so the guest will not see stale values.\n\t\t */\n\t\tsmp_call_function_single(cpu, tsc_khz_changed, freq, 1);\n\t}\n}\n\nstatic int kvmclock_cpufreq_notifier(struct notifier_block *nb, unsigned long val,\n\t\t\t\t     void *data)\n{\n\tstruct cpufreq_freqs *freq = data;\n\tint cpu;\n\n\tif (val == CPUFREQ_PRECHANGE && freq->old > freq->new)\n\t\treturn 0;\n\tif (val == CPUFREQ_POSTCHANGE && freq->old < freq->new)\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, freq->policy->cpus)\n\t\t__kvmclock_cpufreq_notifier(freq, cpu);\n\n\treturn 0;\n}\n\nstatic struct notifier_block kvmclock_cpufreq_notifier_block = {\n\t.notifier_call  = kvmclock_cpufreq_notifier\n};\n\nstatic int kvmclock_cpu_online(unsigned int cpu)\n{\n\ttsc_khz_changed(NULL);\n\treturn 0;\n}\n\nstatic void kvm_timer_init(void)\n{\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n\t\tmax_tsc_khz = tsc_khz;\n\n\t\tif (IS_ENABLED(CONFIG_CPU_FREQ)) {\n\t\t\tstruct cpufreq_policy *policy;\n\t\t\tint cpu;\n\n\t\t\tcpu = get_cpu();\n\t\t\tpolicy = cpufreq_cpu_get(cpu);\n\t\t\tif (policy) {\n\t\t\t\tif (policy->cpuinfo.max_freq)\n\t\t\t\t\tmax_tsc_khz = policy->cpuinfo.max_freq;\n\t\t\t\tcpufreq_cpu_put(policy);\n\t\t\t}\n\t\t\tput_cpu();\n\t\t}\n\t\tcpufreq_register_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t  CPUFREQ_TRANSITION_NOTIFIER);\n\t}\n\n\tcpuhp_setup_state(CPUHP_AP_X86_KVM_CLK_ONLINE, \"x86/kvm/clk:online\",\n\t\t\t  kvmclock_cpu_online, kvmclock_cpu_down_prep);\n}\n\n#ifdef CONFIG_X86_64\nstatic void pvclock_gtod_update_fn(struct work_struct *work)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tmutex_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\tatomic_set(&kvm_guest_has_master_clock, 0);\n\tmutex_unlock(&kvm_lock);\n}\n\nstatic DECLARE_WORK(pvclock_gtod_work, pvclock_gtod_update_fn);\n\n/*\n * Indirection to move queue_work() out of the tk_core.seq write held\n * region to prevent possible deadlocks against time accessors which\n * are invoked with work related locks held.\n */\nstatic void pvclock_irq_work_fn(struct irq_work *w)\n{\n\tqueue_work(system_long_wq, &pvclock_gtod_work);\n}\n\nstatic DEFINE_IRQ_WORK(pvclock_irq_work, pvclock_irq_work_fn);\n\n/*\n * Notification about pvclock gtod data update.\n */\nstatic int pvclock_gtod_notify(struct notifier_block *nb, unsigned long unused,\n\t\t\t       void *priv)\n{\n\tstruct pvclock_gtod_data *gtod = &pvclock_gtod_data;\n\tstruct timekeeper *tk = priv;\n\n\tupdate_pvclock_gtod(tk);\n\n\t/*\n\t * Disable master clock if host does not trust, or does not use,\n\t * TSC based clocksource. Delegate queue_work() to irq_work as\n\t * this is invoked with tk_core.seq write held.\n\t */\n\tif (!gtod_is_based_on_tsc(gtod->clock.vclock_mode) &&\n\t    atomic_read(&kvm_guest_has_master_clock) != 0)\n\t\tirq_work_queue(&pvclock_irq_work);\n\treturn 0;\n}\n\nstatic struct notifier_block pvclock_gtod_notifier = {\n\t.notifier_call = pvclock_gtod_notify,\n};\n#endif\n\nint kvm_arch_init(void *opaque)\n{\n\tstruct kvm_x86_init_ops *ops = opaque;\n\tint r;\n\n\tif (kvm_x86_ops.hardware_enable) {\n\t\tpr_err(\"kvm: already loaded vendor module '%s'\\n\", kvm_x86_ops.name);\n\t\tr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (!ops->cpu_has_kvm_support()) {\n\t\tpr_err_ratelimited(\"kvm: no hardware support for '%s'\\n\",\n\t\t\t\t   ops->runtime_ops->name);\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ops->disabled_by_bios()) {\n\t\tpr_err_ratelimited(\"kvm: support for '%s' disabled by bios\\n\",\n\t\t\t\t   ops->runtime_ops->name);\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * KVM explicitly assumes that the guest has an FPU and\n\t * FXSAVE/FXRSTOR. For example, the KVM_GET_FPU explicitly casts the\n\t * vCPU's FPU state as a fxregs_state struct.\n\t */\n\tif (!boot_cpu_has(X86_FEATURE_FPU) || !boot_cpu_has(X86_FEATURE_FXSR)) {\n\t\tprintk(KERN_ERR \"kvm: inadequate fpu\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !boot_cpu_has(X86_FEATURE_CONSTANT_TSC)) {\n\t\tpr_err(\"RT requires X86_FEATURE_CONSTANT_TSC\\n\");\n\t\tr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tr = -ENOMEM;\n\n\tx86_emulator_cache = kvm_alloc_emulator_cache();\n\tif (!x86_emulator_cache) {\n\t\tpr_err(\"kvm: failed to allocate cache for x86 emulator\\n\");\n\t\tgoto out;\n\t}\n\n\tuser_return_msrs = alloc_percpu(struct kvm_user_return_msrs);\n\tif (!user_return_msrs) {\n\t\tprintk(KERN_ERR \"kvm: failed to allocate percpu kvm_user_return_msrs\\n\");\n\t\tgoto out_free_x86_emulator_cache;\n\t}\n\tkvm_nr_uret_msrs = 0;\n\n\tr = kvm_mmu_vendor_module_init();\n\tif (r)\n\t\tgoto out_free_percpu;\n\n\tkvm_timer_init();\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVE)) {\n\t\thost_xcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\n\t\tsupported_xcr0 = host_xcr0 & KVM_SUPPORTED_XCR0;\n\t}\n\n\tif (pi_inject_timer == -1)\n\t\tpi_inject_timer = housekeeping_enabled(HK_TYPE_TIMER);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_register_notifier(&pvclock_gtod_notifier);\n\n\tif (hypervisor_is_type(X86_HYPER_MS_HYPERV))\n\t\tset_hv_tscchange_cb(kvm_hyperv_tsc_notifier);\n#endif\n\n\treturn 0;\n\nout_free_percpu:\n\tfree_percpu(user_return_msrs);\nout_free_x86_emulator_cache:\n\tkmem_cache_destroy(x86_emulator_cache);\nout:\n\treturn r;\n}\n\nvoid kvm_arch_exit(void)\n{\n#ifdef CONFIG_X86_64\n\tif (hypervisor_is_type(X86_HYPER_MS_HYPERV))\n\t\tclear_hv_tscchange_cb();\n#endif\n\tkvm_lapic_exit();\n\n\tif (!boot_cpu_has(X86_FEATURE_CONSTANT_TSC))\n\t\tcpufreq_unregister_notifier(&kvmclock_cpufreq_notifier_block,\n\t\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n\tcpuhp_remove_state_nocalls(CPUHP_AP_X86_KVM_CLK_ONLINE);\n#ifdef CONFIG_X86_64\n\tpvclock_gtod_unregister_notifier(&pvclock_gtod_notifier);\n\tirq_work_sync(&pvclock_irq_work);\n\tcancel_work_sync(&pvclock_gtod_work);\n#endif\n\tkvm_x86_ops.hardware_enable = NULL;\n\tkvm_mmu_vendor_module_exit();\n\tfree_percpu(user_return_msrs);\n\tkmem_cache_destroy(x86_emulator_cache);\n#ifdef CONFIG_KVM_XEN\n\tstatic_key_deferred_flush(&kvm_xen_enabled);\n\tWARN_ON(static_branch_unlikely(&kvm_xen_enabled.key));\n#endif\n}\n\nstatic int __kvm_emulate_halt(struct kvm_vcpu *vcpu, int state, int reason)\n{\n\t/*\n\t * The vCPU has halted, e.g. executed HLT.  Update the run state if the\n\t * local APIC is in-kernel, the run loop will detect the non-runnable\n\t * state and halt the vCPU.  Exit to userspace if the local APIC is\n\t * managed by userspace, in which case userspace is responsible for\n\t * handling wake events.\n\t */\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = state;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = reason;\n\t\treturn 0;\n\t}\n}\n\nint kvm_emulate_halt_noskip(struct kvm_vcpu *vcpu)\n{\n\treturn __kvm_emulate_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt_noskip);\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\t/*\n\t * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_emulate_halt_noskip(vcpu) && ret;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_halt);\n\nint kvm_emulate_ap_reset_hold(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\n\treturn __kvm_emulate_halt(vcpu, KVM_MP_STATE_AP_RESET_HOLD,\n\t\t\t\t\tKVM_EXIT_AP_RESET_HOLD) && ret;\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_ap_reset_hold);\n\n#ifdef CONFIG_X86_64\nstatic int kvm_pv_clock_pairing(struct kvm_vcpu *vcpu, gpa_t paddr,\n\t\t\t        unsigned long clock_type)\n{\n\tstruct kvm_clock_pairing clock_pairing;\n\tstruct timespec64 ts;\n\tu64 cycle;\n\tint ret;\n\n\tif (clock_type != KVM_CLOCK_PAIRING_WALLCLOCK)\n\t\treturn -KVM_EOPNOTSUPP;\n\n\t/*\n\t * When tsc is in permanent catchup mode guests won't be able to use\n\t * pvclock_read_retry loop to get consistent view of pvclock\n\t */\n\tif (vcpu->arch.tsc_always_catchup)\n\t\treturn -KVM_EOPNOTSUPP;\n\n\tif (!kvm_get_walltime_and_clockread(&ts, &cycle))\n\t\treturn -KVM_EOPNOTSUPP;\n\n\tclock_pairing.sec = ts.tv_sec;\n\tclock_pairing.nsec = ts.tv_nsec;\n\tclock_pairing.tsc = kvm_read_l1_tsc(vcpu, cycle);\n\tclock_pairing.flags = 0;\n\tmemset(&clock_pairing.pad, 0, sizeof(clock_pairing.pad));\n\n\tret = 0;\n\tif (kvm_write_guest(vcpu->kvm, paddr, &clock_pairing,\n\t\t\t    sizeof(struct kvm_clock_pairing)))\n\t\tret = -KVM_EFAULT;\n\n\treturn ret;\n}\n#endif\n\n/*\n * kvm_pv_kick_cpu_op:  Kick a vcpu.\n *\n * @apicid - apicid of vcpu to be kicked.\n */\nstatic void kvm_pv_kick_cpu_op(struct kvm *kvm, int apicid)\n{\n\tstruct kvm_lapic_irq lapic_irq;\n\n\tlapic_irq.shorthand = APIC_DEST_NOSHORT;\n\tlapic_irq.dest_mode = APIC_DEST_PHYSICAL;\n\tlapic_irq.level = 0;\n\tlapic_irq.dest_id = apicid;\n\tlapic_irq.msi_redir_hint = false;\n\n\tlapic_irq.delivery_mode = APIC_DM_REMRD;\n\tkvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);\n}\n\nbool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}\nEXPORT_SYMBOL_GPL(kvm_apicv_activated);\n\nbool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)\n{\n\tulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);\n\tulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);\n\n\treturn (vm_reasons | vcpu_reasons) == 0;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_apicv_activated);\n\nstatic void set_or_clear_apicv_inhibit(unsigned long *inhibits,\n\t\t\t\t       enum kvm_apicv_inhibit reason, bool set)\n{\n\tif (set)\n\t\t__set_bit(reason, inhibits);\n\telse\n\t\t__clear_bit(reason, inhibits);\n\n\ttrace_kvm_apicv_inhibit_changed(reason, set, *inhibits);\n}\n\nstatic void kvm_apicv_init(struct kvm *kvm)\n{\n\tunsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;\n\n\tinit_rwsem(&kvm->arch.apicv_update_lock);\n\n\tset_or_clear_apicv_inhibit(inhibits, APICV_INHIBIT_REASON_ABSENT, true);\n\n\tif (!enable_apicv)\n\t\tset_or_clear_apicv_inhibit(inhibits,\n\t\t\t\t\t   APICV_INHIBIT_REASON_DISABLE, true);\n}\n\nstatic void kvm_sched_yield(struct kvm_vcpu *vcpu, unsigned long dest_id)\n{\n\tstruct kvm_vcpu *target = NULL;\n\tstruct kvm_apic_map *map;\n\n\tvcpu->stat.directed_yield_attempted++;\n\n\tif (single_task_running())\n\t\tgoto no_yield;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(vcpu->kvm->arch.apic_map);\n\n\tif (likely(map) && dest_id <= map->max_apic_id && map->phys_map[dest_id])\n\t\ttarget = map->phys_map[dest_id]->vcpu;\n\n\trcu_read_unlock();\n\n\tif (!target || !READ_ONCE(target->ready))\n\t\tgoto no_yield;\n\n\t/* Ignore requests to yield to self */\n\tif (vcpu == target)\n\t\tgoto no_yield;\n\n\tif (kvm_vcpu_yield_to(target) <= 0)\n\t\tgoto no_yield;\n\n\tvcpu->stat.directed_yield_successful++;\n\nno_yield:\n\treturn;\n}\n\nstatic int complete_hypercall_exit(struct kvm_vcpu *vcpu)\n{\n\tu64 ret = vcpu->run->hypercall.ret;\n\n\tif (!is_64_bit_mode(vcpu))\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit;\n\n\tif (kvm_xen_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_xen_hypercall(vcpu);\n\n\tif (kvm_hv_hypercall_enabled(vcpu))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_rax_read(vcpu);\n\ta0 = kvm_rbx_read(vcpu);\n\ta1 = kvm_rcx_read(vcpu);\n\ta2 = kvm_rdx_read(vcpu);\n\ta3 = kvm_rsi_read(vcpu);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_hypercall(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (static_call(kvm_x86_get_cpl)(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tret = -KVM_ENOSYS;\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_UNHALT))\n\t\t\tbreak;\n\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a1);\n\t\tkvm_sched_yield(vcpu, a1);\n\t\tret = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase KVM_HC_CLOCK_PAIRING:\n\t\tret = kvm_pv_clock_pairing(vcpu, a0, a1);\n\t\tbreak;\n#endif\n\tcase KVM_HC_SEND_IPI:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_SEND_IPI))\n\t\t\tbreak;\n\n\t\tret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);\n\t\tbreak;\n\tcase KVM_HC_SCHED_YIELD:\n\t\tif (!guest_pv_has(vcpu, KVM_FEATURE_PV_SCHED_YIELD))\n\t\t\tbreak;\n\n\t\tkvm_sched_yield(vcpu, a0);\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_MAP_GPA_RANGE: {\n\t\tu64 gpa = a0, npages = a1, attrs = a2;\n\n\t\tret = -KVM_ENOSYS;\n\t\tif (!(vcpu->kvm->arch.hypercall_exit_enabled & (1 << KVM_HC_MAP_GPA_RANGE)))\n\t\t\tbreak;\n\n\t\tif (!PAGE_ALIGNED(gpa) || !npages ||\n\t\t    gpa_to_gfn(gpa) + npages <= gpa_to_gfn(gpa)) {\n\t\t\tret = -KVM_EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tvcpu->run->exit_reason        = KVM_EXIT_HYPERCALL;\n\t\tvcpu->run->hypercall.nr       = KVM_HC_MAP_GPA_RANGE;\n\t\tvcpu->run->hypercall.args[0]  = gpa;\n\t\tvcpu->run->hypercall.args[1]  = npages;\n\t\tvcpu->run->hypercall.args[2]  = attrs;\n\t\tvcpu->run->hypercall.longmode = op_64_bit;\n\t\tvcpu->arch.complete_userspace_io = complete_hypercall_exit;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_emulate_hypercall);\n\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tchar instruction[3];\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\t/*\n\t * If the quirk is disabled, synthesize a #UD and let the guest pick up\n\t * the pieces.\n\t */\n\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_FIX_HYPERCALL_INSN)) {\n\t\tctxt->exception.error_code_valid = false;\n\t\tctxt->exception.vector = UD_VECTOR;\n\t\tctxt->have_exception = true;\n\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t}\n\n\tstatic_call(kvm_x86_patch_hypercall)(vcpu, instruction);\n\n\treturn emulator_write_emulated(ctxt, rip, instruction, 3,\n\t\t&ctxt->exception);\n}\n\nstatic int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->run->request_interrupt_window &&\n\t\tlikely(!pic_in_kernel(vcpu->kvm));\n}\n\n/* Called within kvm->srcu read side.  */\nstatic void post_kvm_run_save(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\n\tkvm_run->if_flag = static_call(kvm_x86_get_if_flag)(vcpu);\n\tkvm_run->cr8 = kvm_get_cr8(vcpu);\n\tkvm_run->apic_base = kvm_get_apic_base(vcpu);\n\n\tkvm_run->ready_for_interrupt_injection =\n\t\tpic_in_kernel(vcpu->kvm) ||\n\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu);\n\n\tif (is_smm(vcpu))\n\t\tkvm_run->flags |= KVM_RUN_X86_SMM;\n}\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\n\tif (!kvm_x86_ops.update_cr8_intercept)\n\t\treturn;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (vcpu->arch.apicv_active)\n\t\treturn;\n\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\n\tstatic_call(kvm_x86_update_cr8_intercept)(vcpu, tpr, max_irr);\n}\n\n\nint kvm_check_nested_events(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\tkvm_x86_ops.nested_ops->triple_fault(vcpu);\n\t\treturn 1;\n\t}\n\n\treturn kvm_x86_ops.nested_ops->check_events(vcpu);\n}\n\nstatic void kvm_inject_exception(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.exception.error_code && !is_protmode(vcpu))\n\t\tvcpu->arch.exception.error_code = false;\n\tstatic_call(kvm_x86_queue_exception)(vcpu);\n}\n\nstatic int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)\n{\n\tint r;\n\tbool can_inject = true;\n\n\t/* try to reinject previous events if any */\n\n\tif (vcpu->arch.exception.injected) {\n\t\tkvm_inject_exception(vcpu);\n\t\tcan_inject = false;\n\t}\n\t/*\n\t * Do not inject an NMI or interrupt if there is a pending\n\t * exception.  Exceptions and interrupts are recognized at\n\t * instruction boundaries, i.e. the start of an instruction.\n\t * Trap-like exceptions, e.g. #DB, have higher priority than\n\t * NMIs and interrupts, i.e. traps are recognized before an\n\t * NMI/interrupt that's pending on the same instruction.\n\t * Fault-like exceptions, e.g. #GP and #PF, are the lowest\n\t * priority, but are only generated (pended) during instruction\n\t * execution, i.e. a pending fault-like exception means the\n\t * fault occurred on the *previous* instruction and must be\n\t * serviced prior to recognizing any new events in order to\n\t * fully complete the previous instruction.\n\t */\n\telse if (!vcpu->arch.exception.pending) {\n\t\tif (vcpu->arch.nmi_injected) {\n\t\t\tstatic_call(kvm_x86_inject_nmi)(vcpu);\n\t\t\tcan_inject = false;\n\t\t} else if (vcpu->arch.interrupt.injected) {\n\t\t\tstatic_call(kvm_x86_inject_irq)(vcpu);\n\t\t\tcan_inject = false;\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(vcpu->arch.exception.injected &&\n\t\t     vcpu->arch.exception.pending);\n\n\t/*\n\t * Call check_nested_events() even if we reinjected a previous event\n\t * in order for caller to determine if it should require immediate-exit\n\t * from L2 to L1 due to pending L1 events which require exit\n\t * from L2 to L1.\n\t */\n\tif (is_guest_mode(vcpu)) {\n\t\tr = kvm_check_nested_events(vcpu);\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* try to inject new event if pending */\n\tif (vcpu->arch.exception.pending) {\n\t\ttrace_kvm_inj_exception(vcpu->arch.exception.nr,\n\t\t\t\t\tvcpu->arch.exception.has_error_code,\n\t\t\t\t\tvcpu->arch.exception.error_code);\n\n\t\tvcpu->arch.exception.pending = false;\n\t\tvcpu->arch.exception.injected = true;\n\n\t\tif (exception_type(vcpu->arch.exception.nr) == EXCPT_FAULT)\n\t\t\t__kvm_set_rflags(vcpu, kvm_get_rflags(vcpu) |\n\t\t\t\t\t     X86_EFLAGS_RF);\n\n\t\tif (vcpu->arch.exception.nr == DB_VECTOR) {\n\t\t\tkvm_deliver_exception_payload(vcpu);\n\t\t\tif (vcpu->arch.dr7 & DR7_GD) {\n\t\t\t\tvcpu->arch.dr7 &= ~DR7_GD;\n\t\t\t\tkvm_update_dr7(vcpu);\n\t\t\t}\n\t\t}\n\n\t\tkvm_inject_exception(vcpu);\n\t\tcan_inject = false;\n\t}\n\n\t/* Don't inject interrupts if the user asked to avoid doing so */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ)\n\t\treturn 0;\n\n\t/*\n\t * Finally, inject interrupt events.  If an event cannot be injected\n\t * due to architectural conditions (e.g. IF=0) a window-open exit\n\t * will re-request KVM_REQ_EVENT.  Sometimes however an event is pending\n\t * and can architecturally be injected, but we cannot do it right now:\n\t * an interrupt could have arrived just now and we have to inject it\n\t * as a vmexit, or there could already an event in the queue, which is\n\t * indicated by can_inject.  In that case we request an immediate exit\n\t * in order to make progress and get back here for another iteration.\n\t * The kvm_x86_ops hooks communicate this by returning -EBUSY.\n\t */\n\tif (vcpu->arch.smi_pending) {\n\t\tr = can_inject ? static_call(kvm_x86_smi_allowed)(vcpu, true) : -EBUSY;\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (r) {\n\t\t\tvcpu->arch.smi_pending = false;\n\t\t\t++vcpu->arch.smi_count;\n\t\t\tenter_smm(vcpu);\n\t\t\tcan_inject = false;\n\t\t} else\n\t\t\tstatic_call(kvm_x86_enable_smi_window)(vcpu);\n\t}\n\n\tif (vcpu->arch.nmi_pending) {\n\t\tr = can_inject ? static_call(kvm_x86_nmi_allowed)(vcpu, true) : -EBUSY;\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (r) {\n\t\t\t--vcpu->arch.nmi_pending;\n\t\t\tvcpu->arch.nmi_injected = true;\n\t\t\tstatic_call(kvm_x86_inject_nmi)(vcpu);\n\t\t\tcan_inject = false;\n\t\t\tWARN_ON(static_call(kvm_x86_nmi_allowed)(vcpu, true) < 0);\n\t\t}\n\t\tif (vcpu->arch.nmi_pending)\n\t\t\tstatic_call(kvm_x86_enable_nmi_window)(vcpu);\n\t}\n\n\tif (kvm_cpu_has_injectable_intr(vcpu)) {\n\t\tr = can_inject ? static_call(kvm_x86_interrupt_allowed)(vcpu, true) : -EBUSY;\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tif (r) {\n\t\t\tkvm_queue_interrupt(vcpu, kvm_cpu_get_interrupt(vcpu), false);\n\t\t\tstatic_call(kvm_x86_inject_irq)(vcpu);\n\t\t\tWARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);\n\t\t}\n\t\tif (kvm_cpu_has_injectable_intr(vcpu))\n\t\t\tstatic_call(kvm_x86_enable_irq_window)(vcpu);\n\t}\n\n\tif (is_guest_mode(vcpu) &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending(vcpu))\n\t\t*req_immediate_exit = true;\n\n\tWARN_ON(vcpu->arch.exception.pending);\n\treturn 0;\n\nout:\n\tif (r == -EBUSY) {\n\t\t*req_immediate_exit = true;\n\t\tr = 0;\n\t}\n\treturn r;\n}\n\nstatic void process_nmi(struct kvm_vcpu *vcpu)\n{\n\tunsigned limit = 2;\n\n\t/*\n\t * x86 is limited to one NMI running, and one NMI pending after it.\n\t * If an NMI is already in progress, limit further NMIs to just one.\n\t * Otherwise, allow two (and we'll inject the first one immediately).\n\t */\n\tif (static_call(kvm_x86_get_nmi_mask)(vcpu) || vcpu->arch.nmi_injected)\n\t\tlimit = 1;\n\n\tvcpu->arch.nmi_pending += atomic_xchg(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = min(vcpu->arch.nmi_pending, limit);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nstatic u32 enter_smm_get_segment_flags(struct kvm_segment *seg)\n{\n\tu32 flags = 0;\n\tflags |= seg->g       << 23;\n\tflags |= seg->db      << 22;\n\tflags |= seg->l       << 21;\n\tflags |= seg->avl     << 20;\n\tflags |= seg->present << 15;\n\tflags |= seg->dpl     << 13;\n\tflags |= seg->s       << 12;\n\tflags |= seg->type    << 8;\n\treturn flags;\n}\n\nstatic void enter_smm_save_seg_32(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\tput_smstate(u32, buf, 0x7fa8 + n * 4, seg.selector);\n\n\tif (n < 3)\n\t\toffset = 0x7f84 + n * 12;\n\telse\n\t\toffset = 0x7f2c + (n - 3) * 12;\n\n\tput_smstate(u32, buf, offset + 8, seg.base);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u32, buf, offset, enter_smm_get_segment_flags(&seg));\n}\n\n#ifdef CONFIG_X86_64\nstatic void enter_smm_save_seg_64(struct kvm_vcpu *vcpu, char *buf, int n)\n{\n\tstruct kvm_segment seg;\n\tint offset;\n\tu16 flags;\n\n\tkvm_get_segment(vcpu, &seg, n);\n\toffset = 0x7e00 + n * 16;\n\n\tflags = enter_smm_get_segment_flags(&seg) >> 8;\n\tput_smstate(u16, buf, offset, seg.selector);\n\tput_smstate(u16, buf, offset + 2, flags);\n\tput_smstate(u32, buf, offset + 4, seg.limit);\n\tput_smstate(u64, buf, offset + 8, seg.base);\n}\n#endif\n\nstatic void enter_smm_save_state_32(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tput_smstate(u32, buf, 0x7ffc, kvm_read_cr0(vcpu));\n\tput_smstate(u32, buf, 0x7ff8, kvm_read_cr3(vcpu));\n\tput_smstate(u32, buf, 0x7ff4, kvm_get_rflags(vcpu));\n\tput_smstate(u32, buf, 0x7ff0, kvm_rip_read(vcpu));\n\n\tfor (i = 0; i < 8; i++)\n\t\tput_smstate(u32, buf, 0x7fd0 + i * 4, kvm_register_read_raw(vcpu, i));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u32, buf, 0x7fcc, (u32)val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u32, buf, 0x7fc8, (u32)val);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u32, buf, 0x7fc4, seg.selector);\n\tput_smstate(u32, buf, 0x7f64, seg.base);\n\tput_smstate(u32, buf, 0x7f60, seg.limit);\n\tput_smstate(u32, buf, 0x7f5c, enter_smm_get_segment_flags(&seg));\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u32, buf, 0x7fc0, seg.selector);\n\tput_smstate(u32, buf, 0x7f80, seg.base);\n\tput_smstate(u32, buf, 0x7f7c, seg.limit);\n\tput_smstate(u32, buf, 0x7f78, enter_smm_get_segment_flags(&seg));\n\n\tstatic_call(kvm_x86_get_gdt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f74, dt.address);\n\tput_smstate(u32, buf, 0x7f70, dt.size);\n\n\tstatic_call(kvm_x86_get_idt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7f58, dt.address);\n\tput_smstate(u32, buf, 0x7f54, dt.size);\n\n\tfor (i = 0; i < 6; i++)\n\t\tenter_smm_save_seg_32(vcpu, buf, i);\n\n\tput_smstate(u32, buf, 0x7f14, kvm_read_cr4(vcpu));\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020000);\n\tput_smstate(u32, buf, 0x7ef8, vcpu->arch.smbase);\n}\n\n#ifdef CONFIG_X86_64\nstatic void enter_smm_save_state_64(struct kvm_vcpu *vcpu, char *buf)\n{\n\tstruct desc_ptr dt;\n\tstruct kvm_segment seg;\n\tunsigned long val;\n\tint i;\n\n\tfor (i = 0; i < 16; i++)\n\t\tput_smstate(u64, buf, 0x7ff8 - i * 8, kvm_register_read_raw(vcpu, i));\n\n\tput_smstate(u64, buf, 0x7f78, kvm_rip_read(vcpu));\n\tput_smstate(u32, buf, 0x7f70, kvm_get_rflags(vcpu));\n\n\tkvm_get_dr(vcpu, 6, &val);\n\tput_smstate(u64, buf, 0x7f68, val);\n\tkvm_get_dr(vcpu, 7, &val);\n\tput_smstate(u64, buf, 0x7f60, val);\n\n\tput_smstate(u64, buf, 0x7f58, kvm_read_cr0(vcpu));\n\tput_smstate(u64, buf, 0x7f50, kvm_read_cr3(vcpu));\n\tput_smstate(u64, buf, 0x7f48, kvm_read_cr4(vcpu));\n\n\tput_smstate(u32, buf, 0x7f00, vcpu->arch.smbase);\n\n\t/* revision id */\n\tput_smstate(u32, buf, 0x7efc, 0x00020064);\n\n\tput_smstate(u64, buf, 0x7ed0, vcpu->arch.efer);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_TR);\n\tput_smstate(u16, buf, 0x7e90, seg.selector);\n\tput_smstate(u16, buf, 0x7e92, enter_smm_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e94, seg.limit);\n\tput_smstate(u64, buf, 0x7e98, seg.base);\n\n\tstatic_call(kvm_x86_get_idt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e84, dt.size);\n\tput_smstate(u64, buf, 0x7e88, dt.address);\n\n\tkvm_get_segment(vcpu, &seg, VCPU_SREG_LDTR);\n\tput_smstate(u16, buf, 0x7e70, seg.selector);\n\tput_smstate(u16, buf, 0x7e72, enter_smm_get_segment_flags(&seg) >> 8);\n\tput_smstate(u32, buf, 0x7e74, seg.limit);\n\tput_smstate(u64, buf, 0x7e78, seg.base);\n\n\tstatic_call(kvm_x86_get_gdt)(vcpu, &dt);\n\tput_smstate(u32, buf, 0x7e64, dt.size);\n\tput_smstate(u64, buf, 0x7e68, dt.address);\n\n\tfor (i = 0; i < 6; i++)\n\t\tenter_smm_save_seg_64(vcpu, buf, i);\n}\n#endif\n\nstatic void enter_smm(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ds;\n\tstruct desc_ptr dt;\n\tunsigned long cr0;\n\tchar buf[512];\n\n\tmemset(buf, 0, 512);\n#ifdef CONFIG_X86_64\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\tenter_smm_save_state_64(vcpu, buf);\n\telse\n#endif\n\t\tenter_smm_save_state_32(vcpu, buf);\n\n\t/*\n\t * Give enter_smm() a chance to make ISA-specific changes to the vCPU\n\t * state (e.g. leave guest mode) after we've saved the state into the\n\t * SMM state-save area.\n\t */\n\tstatic_call(kvm_x86_enter_smm)(vcpu, buf);\n\n\tkvm_smm_changed(vcpu, true);\n\tkvm_vcpu_write_guest(vcpu, vcpu->arch.smbase + 0xfe00, buf, sizeof(buf));\n\n\tif (static_call(kvm_x86_get_nmi_mask)(vcpu))\n\t\tvcpu->arch.hflags |= HF_SMM_INSIDE_NMI_MASK;\n\telse\n\t\tstatic_call(kvm_x86_set_nmi_mask)(vcpu, true);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0x8000);\n\n\tcr0 = vcpu->arch.cr0 & ~(X86_CR0_PE | X86_CR0_EM | X86_CR0_TS | X86_CR0_PG);\n\tstatic_call(kvm_x86_set_cr0)(vcpu, cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\tstatic_call(kvm_x86_set_cr4)(vcpu, 0);\n\n\t/* Undocumented: IDT limit is set to zero on entry to SMM.  */\n\tdt.address = dt.size = 0;\n\tstatic_call(kvm_x86_set_idt)(vcpu, &dt);\n\n\tkvm_set_dr(vcpu, 7, DR7_FIXED_1);\n\n\tcs.selector = (vcpu->arch.smbase >> 4) & 0xffff;\n\tcs.base = vcpu->arch.smbase;\n\n\tds.selector = 0;\n\tds.base = 0;\n\n\tcs.limit    = ds.limit = 0xffffffff;\n\tcs.type     = ds.type = 0x3;\n\tcs.dpl      = ds.dpl = 0;\n\tcs.db       = ds.db = 0;\n\tcs.s        = ds.s = 1;\n\tcs.l        = ds.l = 0;\n\tcs.g        = ds.g = 1;\n\tcs.avl      = ds.avl = 0;\n\tcs.present  = ds.present = 1;\n\tcs.unusable = ds.unusable = 0;\n\tcs.padding  = ds.padding = 0;\n\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &ds, VCPU_SREG_SS);\n\n#ifdef CONFIG_X86_64\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_LM))\n\t\tstatic_call(kvm_x86_set_efer)(vcpu, 0);\n#endif\n\n\tkvm_update_cpuid_runtime(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n}\n\nstatic void process_smi(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.smi_pending = true;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nvoid kvm_make_scan_ioapic_request_mask(struct kvm *kvm,\n\t\t\t\t       unsigned long *vcpu_bitmap)\n{\n\tkvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC, vcpu_bitmap);\n}\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}\n\nvoid kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tbool activate;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tdown_read(&vcpu->kvm->arch.apicv_update_lock);\n\n\tactivate = kvm_vcpu_apicv_activated(vcpu);\n\n\tif (vcpu->arch.apicv_active == activate)\n\t\tgoto out;\n\n\tvcpu->arch.apicv_active = activate;\n\tkvm_apic_update_apicv(vcpu);\n\tstatic_call(kvm_x86_refresh_apicv_exec_ctrl)(vcpu);\n\n\t/*\n\t * When APICv gets disabled, we may still have injected interrupts\n\t * pending. At the same time, KVM_REQ_EVENT may not be set as APICv was\n\t * still active when the interrupt got accepted. Make sure\n\t * inject_pending_event() is called to check for that.\n\t */\n\tif (!vcpu->arch.apicv_active)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\nout:\n\tup_read(&vcpu->kvm->arch.apicv_update_lock);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);\n\nvoid __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t      enum kvm_apicv_inhibit reason, bool set)\n{\n\tunsigned long old, new;\n\n\tlockdep_assert_held_write(&kvm->arch.apicv_update_lock);\n\n\tif (!static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))\n\t\treturn;\n\n\told = new = kvm->arch.apicv_inhibit_reasons;\n\n\tset_or_clear_apicv_inhibit(&new, reason, set);\n\n\tif (!!old != !!new) {\n\t\t/*\n\t\t * Kick all vCPUs before setting apicv_inhibit_reasons to avoid\n\t\t * false positives in the sanity check WARN in svm_vcpu_run().\n\t\t * This task will wait for all vCPUs to ack the kick IRQ before\n\t\t * updating apicv_inhibit_reasons, and all other vCPUs will\n\t\t * block on acquiring apicv_update_lock so that vCPUs can't\n\t\t * redo svm_vcpu_run() without seeing the new inhibit state.\n\t\t *\n\t\t * Note, holding apicv_update_lock and taking it in the read\n\t\t * side (handling the request) also prevents other vCPUs from\n\t\t * servicing the request with a stale apicv_inhibit_reasons.\n\t\t */\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n\t\tkvm->arch.apicv_inhibit_reasons = new;\n\t\tif (new) {\n\t\t\tunsigned long gfn = gpa_to_gfn(APIC_DEFAULT_PHYS_BASE);\n\t\t\tkvm_zap_gfn_range(kvm, gfn, gfn+1);\n\t\t}\n\t} else {\n\t\tkvm->arch.apicv_inhibit_reasons = new;\n\t}\n}\n\nvoid kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,\n\t\t\t\t    enum kvm_apicv_inhibit reason, bool set)\n{\n\tif (!enable_apicv)\n\t\treturn;\n\n\tdown_write(&kvm->arch.apicv_update_lock);\n\t__kvm_set_or_clear_apicv_inhibit(kvm, reason, set);\n\tup_write(&kvm->arch.apicv_update_lock);\n}\nEXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);\n\nstatic void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_present(vcpu))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\t\tif (ioapic_in_kernel(vcpu->kvm))\n\t\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}\n\nstatic void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)\n{\n\tu64 eoi_exit_bitmap[4];\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tif (to_hv_vcpu(vcpu)) {\n\t\tbitmap_or((ulong *)eoi_exit_bitmap,\n\t\t\t  vcpu->arch.ioapic_handled_vectors,\n\t\t\t  to_hv_synic(vcpu)->vec_bitmap, 256);\n\t\tstatic_call_cond(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);\n\t\treturn;\n\t}\n\n\tstatic_call_cond(kvm_x86_load_eoi_exitmap)(\n\t\tvcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);\n}\n\nvoid kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,\n\t\t\t\t\t    unsigned long start, unsigned long end)\n{\n\tunsigned long apic_address;\n\n\t/*\n\t * The physical address of apic access page is stored in the VMCS.\n\t * Update it when it becomes invalid.\n\t */\n\tapic_address = gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (start <= apic_address && apic_address < end)\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}\n\nvoid kvm_arch_guest_memory_reclaimed(struct kvm *kvm)\n{\n\tstatic_call_cond(kvm_x86_guest_memory_reclaimed)(kvm);\n}\n\nstatic void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tstatic_call_cond(kvm_x86_set_apic_access_page_addr)(vcpu);\n}\n\nvoid __kvm_request_immediate_exit(struct kvm_vcpu *vcpu)\n{\n\tsmp_send_reschedule(vcpu->cpu);\n}\nEXPORT_SYMBOL_GPL(__kvm_request_immediate_exit);\n\n/*\n * Called within kvm->srcu read side.\n * Returns 1 to let vcpu_run() continue the guest execution loop without\n * exiting to the userspace.  Otherwise, the value will be returned to the\n * userspace.\n */\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tbool req_int_win =\n\t\tdm_request_for_irq_injection(vcpu) &&\n\t\tkvm_cpu_accept_dm_intr(vcpu);\n\tfastpath_t exit_fastpath;\n\n\tbool req_immediate_exit = false;\n\n\t/* Forbid vmenter if vcpu dirty ring is soft-full */\n\tif (unlikely(vcpu->kvm->dirty_ring_size &&\n\t\t     kvm_dirty_ring_soft_full(&vcpu->dirty_ring))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_DIRTY_RING_FULL;\n\t\ttrace_kvm_dirty_ring_exit(vcpu);\n\t\tr = 0;\n\t\tgoto out;\n\t}\n\n\tif (kvm_request_pending(vcpu)) {\n\t\tif (kvm_check_request(KVM_REQ_VM_DEAD, vcpu)) {\n\t\t\tr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_GET_NESTED_STATE_PAGES, vcpu)) {\n\t\t\tif (unlikely(!kvm_x86_ops.nested_ops->get_nested_state_pages(vcpu))) {\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_FREE_OBSOLETE_ROOTS, vcpu))\n\t\t\tkvm_mmu_free_obsolete_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MIGRATE_TIMER, vcpu))\n\t\t\t__kvm_migrate_timers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu))\n\t\t\tkvm_update_masterclock(vcpu->kvm);\n\t\tif (kvm_check_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu))\n\t\t\tkvm_gen_kvmclock_update(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_CLOCK_UPDATE, vcpu)) {\n\t\t\tr = kvm_guest_time_update(vcpu);\n\t\t\tif (unlikely(r))\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_MMU_SYNC, vcpu))\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_LOAD_MMU_PGD, vcpu))\n\t\t\tkvm_mmu_load_pgd(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_TLB_FLUSH, vcpu)) {\n\t\t\tkvm_vcpu_flush_tlb_all(vcpu);\n\n\t\t\t/* Flushing all ASIDs flushes the current ASID... */\n\t\t\tkvm_clear_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);\n\t\t}\n\t\tkvm_service_local_tlb_flush_requests(vcpu);\n\n\t\tif (kvm_check_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_TPR_ACCESS;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_TRIPLE_FAULT, vcpu)) {\n\t\t\tif (is_guest_mode(vcpu)) {\n\t\t\t\tkvm_x86_ops.nested_ops->triple_fault(vcpu);\n\t\t\t} else {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\t\t\t\tvcpu->mmio_needed = 0;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_APF_HALT, vcpu)) {\n\t\t\t/* Page is swapped out. Do synthetic halt */\n\t\t\tvcpu->arch.apf.halted = true;\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_STEAL_UPDATE, vcpu))\n\t\t\trecord_steal_time(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_SMI, vcpu))\n\t\t\tprocess_smi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_NMI, vcpu))\n\t\t\tprocess_nmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMU, vcpu))\n\t\t\tkvm_pmu_handle_event(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_PMI, vcpu))\n\t\t\tkvm_pmu_deliver_pmi(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {\n\t\t\tBUG_ON(vcpu->arch.pending_ioapic_eoi > 255);\n\t\t\tif (test_bit(vcpu->arch.pending_ioapic_eoi,\n\t\t\t\t     vcpu->arch.ioapic_handled_vectors)) {\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;\n\t\t\t\tvcpu->run->eoi.vector =\n\t\t\t\t\t\tvcpu->arch.pending_ioapic_eoi;\n\t\t\t\tr = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))\n\t\t\tvcpu_scan_ioapic(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))\n\t\t\tvcpu_load_eoi_exitmap(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))\n\t\t\tkvm_vcpu_reload_apic_access_page(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_HV_CRASH, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_CRASH;\n\t\t\tvcpu->run->system_event.ndata = 0;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_RESET, vcpu)) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\n\t\t\tvcpu->run->system_event.type = KVM_SYSTEM_EVENT_RESET;\n\t\t\tvcpu->run->system_event.ndata = 0;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (kvm_check_request(KVM_REQ_HV_EXIT, vcpu)) {\n\t\t\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\t\tvcpu->run->hyperv = hv_vcpu->exit;\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * KVM_REQ_HV_STIMER has to be processed after\n\t\t * KVM_REQ_CLOCK_UPDATE, because Hyper-V SynIC timers\n\t\t * depend on the guest clock being up-to-date\n\t\t */\n\t\tif (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))\n\t\t\tkvm_hv_process_stimers(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))\n\t\t\tkvm_vcpu_update_apicv(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_APF_READY, vcpu))\n\t\t\tkvm_check_async_pf_completion(vcpu);\n\t\tif (kvm_check_request(KVM_REQ_MSR_FILTER_CHANGED, vcpu))\n\t\t\tstatic_call(kvm_x86_msr_filter_changed)(vcpu);\n\n\t\tif (kvm_check_request(KVM_REQ_UPDATE_CPU_DIRTY_LOGGING, vcpu))\n\t\t\tstatic_call(kvm_x86_update_cpu_dirty_logging)(vcpu);\n\t}\n\n\tif (kvm_check_request(KVM_REQ_EVENT, vcpu) || req_int_win ||\n\t    kvm_xen_has_interrupt(vcpu)) {\n\t\t++vcpu->stat.req_event;\n\t\tr = kvm_apic_accept_events(vcpu);\n\t\tif (r < 0) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t\tr = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tr = inject_pending_event(vcpu, &req_immediate_exit);\n\t\tif (r < 0) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tif (req_int_win)\n\t\t\tstatic_call(kvm_x86_enable_irq_window)(vcpu);\n\n\t\tif (kvm_lapic_enabled(vcpu)) {\n\t\t\tupdate_cr8_intercept(vcpu);\n\t\t\tkvm_lapic_sync_to_vapic(vcpu);\n\t\t}\n\t}\n\n\tr = kvm_mmu_reload(vcpu);\n\tif (unlikely(r)) {\n\t\tgoto cancel_injection;\n\t}\n\n\tpreempt_disable();\n\n\tstatic_call(kvm_x86_prepare_switch_to_guest)(vcpu);\n\n\t/*\n\t * Disable IRQs before setting IN_GUEST_MODE.  Posted interrupt\n\t * IPI are then delayed after guest entry, which ensures that they\n\t * result in virtual interrupt delivery.\n\t */\n\tlocal_irq_disable();\n\n\t/* Store vcpu->apicv_active before vcpu->mode.  */\n\tsmp_store_release(&vcpu->mode, IN_GUEST_MODE);\n\n\tkvm_vcpu_srcu_read_unlock(vcpu);\n\n\t/*\n\t * 1) We should set ->mode before checking ->requests.  Please see\n\t * the comment in kvm_vcpu_exiting_guest_mode().\n\t *\n\t * 2) For APICv, we should set ->mode before checking PID.ON. This\n\t * pairs with the memory barrier implicit in pi_test_and_set_on\n\t * (see vmx_deliver_posted_interrupt).\n\t *\n\t * 3) This also orders the write to mode from any reads to the page\n\t * tables done while the VCPU is running.  Please see the comment\n\t * in kvm_flush_remote_tlbs.\n\t */\n\tsmp_mb__after_srcu_read_unlock();\n\n\t/*\n\t * Process pending posted interrupts to handle the case where the\n\t * notification IRQ arrived in the host, or was never sent (because the\n\t * target vCPU wasn't running).  Do this regardless of the vCPU's APICv\n\t * status, KVM doesn't update assigned devices when APICv is inhibited,\n\t * i.e. they can post interrupts even if APICv is temporarily disabled.\n\t */\n\tif (kvm_lapic_enabled(vcpu))\n\t\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\n\tif (kvm_vcpu_exit_request(vcpu)) {\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tsmp_wmb();\n\t\tlocal_irq_enable();\n\t\tpreempt_enable();\n\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\tr = 1;\n\t\tgoto cancel_injection;\n\t}\n\n\tif (req_immediate_exit) {\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tstatic_call(kvm_x86_request_immediate_exit)(vcpu);\n\t}\n\n\tfpregs_assert_state_consistent();\n\tif (test_thread_flag(TIF_NEED_FPU_LOAD))\n\t\tswitch_fpu_return();\n\n\tif (vcpu->arch.guest_fpu.xfd_err)\n\t\twrmsrl(MSR_IA32_XFD_ERR, vcpu->arch.guest_fpu.xfd_err);\n\n\tif (unlikely(vcpu->arch.switch_db_regs)) {\n\t\tset_debugreg(0, 7);\n\t\tset_debugreg(vcpu->arch.eff_db[0], 0);\n\t\tset_debugreg(vcpu->arch.eff_db[1], 1);\n\t\tset_debugreg(vcpu->arch.eff_db[2], 2);\n\t\tset_debugreg(vcpu->arch.eff_db[3], 3);\n\t} else if (unlikely(hw_breakpoint_active())) {\n\t\tset_debugreg(0, 7);\n\t}\n\n\tguest_timing_enter_irqoff();\n\n\tfor (;;) {\n\t\t/*\n\t\t * Assert that vCPU vs. VM APICv state is consistent.  An APICv\n\t\t * update must kick and wait for all vCPUs before toggling the\n\t\t * per-VM state, and responsing vCPUs must wait for the update\n\t\t * to complete before servicing KVM_REQ_APICV_UPDATE.\n\t\t */\n\t\tWARN_ON_ONCE(kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu));\n\n\t\texit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);\n\t\tif (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))\n\t\t\tbreak;\n\n\t\tif (kvm_lapic_enabled(vcpu))\n\t\t\tstatic_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);\n\n\t\tif (unlikely(kvm_vcpu_exit_request(vcpu))) {\n\t\t\texit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Do this here before restoring debug registers on the host.  And\n\t * since we do this before handling the vmexit, a DR access vmexit\n\t * can (a) read the correct value of the debug registers, (b) set\n\t * KVM_DEBUGREG_WONT_EXIT again.\n\t */\n\tif (unlikely(vcpu->arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)) {\n\t\tWARN_ON(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP);\n\t\tstatic_call(kvm_x86_sync_dirty_debug_regs)(vcpu);\n\t\tkvm_update_dr0123(vcpu);\n\t\tkvm_update_dr7(vcpu);\n\t}\n\n\t/*\n\t * If the guest has used debug registers, at least dr7\n\t * will be disabled while returning to the host.\n\t * If we don't have active breakpoints in the host, we don't\n\t * care about the messed up debug address registers. But if\n\t * we have some of them active, restore the old state.\n\t */\n\tif (hw_breakpoint_active())\n\t\thw_breakpoint_restore();\n\n\tvcpu->arch.last_vmentry_cpu = vcpu->cpu;\n\tvcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\tsmp_wmb();\n\n\t/*\n\t * Sync xfd before calling handle_exit_irqoff() which may\n\t * rely on the fact that guest_fpu::xfd is up-to-date (e.g.\n\t * in #NM irqoff handler).\n\t */\n\tif (vcpu->arch.xfd_no_write_intercept)\n\t\tfpu_sync_guest_vmexit_xfd_state();\n\n\tstatic_call(kvm_x86_handle_exit_irqoff)(vcpu);\n\n\tif (vcpu->arch.guest_fpu.xfd_err)\n\t\twrmsrl(MSR_IA32_XFD_ERR, 0);\n\n\t/*\n\t * Consume any pending interrupts, including the possible source of\n\t * VM-Exit on SVM and any ticks that occur between VM-Exit and now.\n\t * An instruction is required after local_irq_enable() to fully unblock\n\t * interrupts on processors that implement an interrupt shadow, the\n\t * stat.exits increment will do nicely.\n\t */\n\tkvm_before_interrupt(vcpu, KVM_HANDLING_IRQ);\n\tlocal_irq_enable();\n\t++vcpu->stat.exits;\n\tlocal_irq_disable();\n\tkvm_after_interrupt(vcpu);\n\n\t/*\n\t * Wait until after servicing IRQs to account guest time so that any\n\t * ticks that occurred while running the guest are properly accounted\n\t * to the guest.  Waiting until IRQs are enabled degrades the accuracy\n\t * of accounting via context tracking, but the loss of accuracy is\n\t * acceptable for all known use cases.\n\t */\n\tguest_timing_exit_irqoff();\n\n\tlocal_irq_enable();\n\tpreempt_enable();\n\n\tkvm_vcpu_srcu_read_lock(vcpu);\n\n\t/*\n\t * Profile KVM exit RIPs:\n\t */\n\tif (unlikely(prof_on == KVM_PROFILING)) {\n\t\tunsigned long rip = kvm_rip_read(vcpu);\n\t\tprofile_hit(KVM_PROFILING, (void *)rip);\n\t}\n\n\tif (unlikely(vcpu->arch.tsc_always_catchup))\n\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\n\tif (vcpu->arch.apic_attention)\n\t\tkvm_lapic_sync_from_vapic(vcpu);\n\n\tr = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);\n\treturn r;\n\ncancel_injection:\n\tif (req_immediate_exit)\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tstatic_call(kvm_x86_cancel_injection)(vcpu);\n\tif (unlikely(vcpu->arch.apic_attention))\n\t\tkvm_lapic_sync_from_vapic(vcpu);\nout:\n\treturn r;\n}\n\n/* Called within kvm->srcu read side.  */\nstatic inline int vcpu_block(struct kvm_vcpu *vcpu)\n{\n\tbool hv_timer;\n\n\tif (!kvm_arch_vcpu_runnable(vcpu)) {\n\t\t/*\n\t\t * Switch to the software timer before halt-polling/blocking as\n\t\t * the guest's timer may be a break event for the vCPU, and the\n\t\t * hypervisor timer runs only when the CPU is in guest mode.\n\t\t * Switch before halt-polling so that KVM recognizes an expired\n\t\t * timer before blocking.\n\t\t */\n\t\thv_timer = kvm_lapic_hv_timer_in_use(vcpu);\n\t\tif (hv_timer)\n\t\t\tkvm_lapic_switch_to_sw_timer(vcpu);\n\n\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)\n\t\t\tkvm_vcpu_halt(vcpu);\n\t\telse\n\t\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\n\t\tif (hv_timer)\n\t\t\tkvm_lapic_switch_to_hv_timer(vcpu);\n\n\t\tif (!kvm_check_request(KVM_REQ_UNHALT, vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_apic_accept_events(vcpu) < 0)\n\t\treturn 0;\n\tswitch(vcpu->arch.mp_state) {\n\tcase KVM_MP_STATE_HALTED:\n\tcase KVM_MP_STATE_AP_RESET_HOLD:\n\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\tvcpu->arch.mp_state =\n\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\tfallthrough;\n\tcase KVM_MP_STATE_RUNNABLE:\n\t\tvcpu->arch.apf.halted = false;\n\t\tbreak;\n\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINTR;\n\t}\n\treturn 1;\n}\n\nstatic inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu))\n\t\tkvm_check_nested_events(vcpu);\n\n\treturn (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t!vcpu->arch.apf.halted);\n}\n\n/* Called within kvm->srcu read side.  */\nstatic int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\tfor (;;) {\n\t\t/*\n\t\t * If another guest vCPU requests a PV TLB flush in the middle\n\t\t * of instruction emulation, the rest of the emulation could\n\t\t * use a stale page translation. Assume that any code after\n\t\t * this point can start executing an instruction.\n\t\t */\n\t\tvcpu->arch.at_instruction_boundary = false;\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(vcpu);\n\t\t}\n\n\t\tif (r <= 0)\n\t\t\tbreak;\n\n\t\tkvm_clear_request(KVM_REQ_UNBLOCK, vcpu);\n\t\tif (kvm_xen_has_pending_events(vcpu))\n\t\t\tkvm_xen_inject_pending_events(vcpu);\n\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__xfer_to_guest_mode_work_pending()) {\n\t\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\t\tr = xfer_to_guest_mode_handle_work(vcpu);\n\t\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn r;\n}\n\nstatic inline int complete_emulated_io(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction(vcpu, EMULTYPE_NO_DECODE);\n}\n\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu)\n{\n\tBUG_ON(!vcpu->arch.pio.count);\n\n\treturn complete_emulated_io(vcpu);\n}\n\n/*\n * Implements the following, as a state machine:\n *\n * read:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       exit\n *       copy data\n *   execute insn\n *\n * write:\n *   for each fragment\n *     for each mmio piece in the fragment\n *       write gpa, len\n *       copy data\n *       exit\n */\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}\n\n/* Swap (qemu) user FPU context for the guest FPU context. */\nstatic void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\t/* Exclude PKRU, it's restored separately immediately after VM-Exit. */\n\tfpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, true);\n\ttrace_kvm_fpu(1);\n}\n\n/* When vcpu_run ends, restore user space FPU context. */\nstatic void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)\n{\n\tfpu_swap_kvm_fpstate(&vcpu->arch.guest_fpu, false);\n\t++vcpu->stat.fpu_reload;\n\ttrace_kvm_fpu(0);\n}\n\nint kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tint r;\n\n\tvcpu_load(vcpu);\n\tkvm_sigset_activate(vcpu);\n\tkvm_run->flags = 0;\n\tkvm_load_guest_fpu(vcpu);\n\n\tkvm_vcpu_srcu_read_lock(vcpu);\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tif (kvm_run->immediate_exit) {\n\t\t\tr = -EINTR;\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * It should be impossible for the hypervisor timer to be in\n\t\t * use before KVM has ever run the vCPU.\n\t\t */\n\t\tWARN_ON_ONCE(kvm_lapic_hv_timer_in_use(vcpu));\n\n\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\tkvm_vcpu_block(vcpu);\n\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\n\t\tif (kvm_apic_accept_events(vcpu) < 0) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tkvm_clear_request(KVM_REQ_UNHALT, vcpu);\n\t\tr = -EAGAIN;\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tif ((kvm_run->kvm_valid_regs & ~KVM_SYNC_X86_VALID_FIELDS) ||\n\t    (kvm_run->kvm_dirty_regs & ~KVM_SYNC_X86_VALID_FIELDS)) {\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kvm_run->kvm_dirty_regs) {\n\t\tr = sync_regs(vcpu);\n\t\tif (r != 0)\n\t\t\tgoto out;\n\t}\n\n\t/* re-sync apic's tpr */\n\tif (!lapic_in_kernel(vcpu)) {\n\t\tif (kvm_set_cr8(vcpu, kvm_run->cr8) != 0) {\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (unlikely(vcpu->arch.complete_userspace_io)) {\n\t\tint (*cui)(struct kvm_vcpu *) = vcpu->arch.complete_userspace_io;\n\t\tvcpu->arch.complete_userspace_io = NULL;\n\t\tr = cui(vcpu);\n\t\tif (r <= 0)\n\t\t\tgoto out;\n\t} else\n\t\tWARN_ON(vcpu->arch.pio.count || vcpu->mmio_needed);\n\n\tif (kvm_run->immediate_exit) {\n\t\tr = -EINTR;\n\t\tgoto out;\n\t}\n\n\tr = static_call(kvm_x86_vcpu_pre_run)(vcpu);\n\tif (r <= 0)\n\t\tgoto out;\n\n\tr = vcpu_run(vcpu);\n\nout:\n\tkvm_put_guest_fpu(vcpu);\n\tif (kvm_run->kvm_valid_regs)\n\t\tstore_regs(vcpu);\n\tpost_kvm_run_save(vcpu);\n\tkvm_vcpu_srcu_read_unlock(vcpu);\n\n\tkvm_sigset_deactivate(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\nstatic void __get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tif (vcpu->arch.emulate_regs_need_sync_to_vcpu) {\n\t\t/*\n\t\t * We are here if userspace calls get_regs() in the middle of\n\t\t * instruction emulation. Registers state needs to be copied\n\t\t * back from emulation context to vcpu. Userspace shouldn't do\n\t\t * that usually, but some bad designed PV devices (vmware\n\t\t * backdoor interface) need this to work\n\t\t */\n\t\temulator_writeback_register_cache(vcpu->arch.emulate_ctxt);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t}\n\tregs->rax = kvm_rax_read(vcpu);\n\tregs->rbx = kvm_rbx_read(vcpu);\n\tregs->rcx = kvm_rcx_read(vcpu);\n\tregs->rdx = kvm_rdx_read(vcpu);\n\tregs->rsi = kvm_rsi_read(vcpu);\n\tregs->rdi = kvm_rdi_read(vcpu);\n\tregs->rsp = kvm_rsp_read(vcpu);\n\tregs->rbp = kvm_rbp_read(vcpu);\n#ifdef CONFIG_X86_64\n\tregs->r8 = kvm_r8_read(vcpu);\n\tregs->r9 = kvm_r9_read(vcpu);\n\tregs->r10 = kvm_r10_read(vcpu);\n\tregs->r11 = kvm_r11_read(vcpu);\n\tregs->r12 = kvm_r12_read(vcpu);\n\tregs->r13 = kvm_r13_read(vcpu);\n\tregs->r14 = kvm_r14_read(vcpu);\n\tregs->r15 = kvm_r15_read(vcpu);\n#endif\n\n\tregs->rip = kvm_rip_read(vcpu);\n\tregs->rflags = kvm_get_rflags(vcpu);\n}\n\nint kvm_arch_vcpu_ioctl_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu_load(vcpu);\n\t__get_regs(vcpu, regs);\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nstatic void __set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu->arch.emulate_regs_need_sync_from_vcpu = true;\n\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\n\tkvm_rax_write(vcpu, regs->rax);\n\tkvm_rbx_write(vcpu, regs->rbx);\n\tkvm_rcx_write(vcpu, regs->rcx);\n\tkvm_rdx_write(vcpu, regs->rdx);\n\tkvm_rsi_write(vcpu, regs->rsi);\n\tkvm_rdi_write(vcpu, regs->rdi);\n\tkvm_rsp_write(vcpu, regs->rsp);\n\tkvm_rbp_write(vcpu, regs->rbp);\n#ifdef CONFIG_X86_64\n\tkvm_r8_write(vcpu, regs->r8);\n\tkvm_r9_write(vcpu, regs->r9);\n\tkvm_r10_write(vcpu, regs->r10);\n\tkvm_r11_write(vcpu, regs->r11);\n\tkvm_r12_write(vcpu, regs->r12);\n\tkvm_r13_write(vcpu, regs->r13);\n\tkvm_r14_write(vcpu, regs->r14);\n\tkvm_r15_write(vcpu, regs->r15);\n#endif\n\n\tkvm_rip_write(vcpu, regs->rip);\n\tkvm_set_rflags(vcpu, regs->rflags | X86_EFLAGS_FIXED);\n\n\tvcpu->arch.exception.pending = false;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\n\nint kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)\n{\n\tvcpu_load(vcpu);\n\t__set_regs(vcpu, regs);\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nstatic void __get_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tif (vcpu->arch.guest_state_protected)\n\t\tgoto skip_protected_regs;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tstatic_call(kvm_x86_get_idt)(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tstatic_call(kvm_x86_get_gdt)(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\nskip_protected_regs:\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n}\n\nstatic void __get_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\t__get_sregs_common(vcpu, sregs);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tif (vcpu->arch.interrupt.injected && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n}\n\nstatic void __get_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)\n{\n\tint i;\n\n\t__get_sregs_common(vcpu, (struct kvm_sregs *)sregs2);\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tfor (i = 0 ; i < 4 ; i++)\n\t\t\tsregs2->pdptrs[i] = kvm_pdptr_read(vcpu, i);\n\t\tsregs2->flags |= KVM_SREGS2_FLAGS_PDPTRS_VALID;\n\t}\n}\n\nint kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tvcpu_load(vcpu);\n\t__get_sregs(vcpu, sregs);\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tint r;\n\n\tvcpu_load(vcpu);\n\tif (kvm_mpx_supported())\n\t\tkvm_load_guest_fpu(vcpu);\n\n\tr = kvm_apic_accept_events(vcpu);\n\tif (r < 0)\n\t\tgoto out;\n\tr = 0;\n\n\tif ((vcpu->arch.mp_state == KVM_MP_STATE_HALTED ||\n\t     vcpu->arch.mp_state == KVM_MP_STATE_AP_RESET_HOLD) &&\n\t    vcpu->arch.pv.pv_unhalted)\n\t\tmp_state->mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tmp_state->mp_state = vcpu->arch.mp_state;\n\nout:\n\tif (kvm_mpx_supported())\n\t\tkvm_put_guest_fpu(vcpu);\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\nint kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mp_state *mp_state)\n{\n\tint ret = -EINVAL;\n\n\tvcpu_load(vcpu);\n\n\tif (!lapic_in_kernel(vcpu) &&\n\t    mp_state->mp_state != KVM_MP_STATE_RUNNABLE)\n\t\tgoto out;\n\n\t/*\n\t * KVM_MP_STATE_INIT_RECEIVED means the processor is in\n\t * INIT state; latched init should be reported using\n\t * KVM_SET_VCPU_EVENTS, so reject it here.\n\t */\n\tif ((kvm_vcpu_latch_init(vcpu) || vcpu->arch.smi_pending) &&\n\t    (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED ||\n\t     mp_state->mp_state == KVM_MP_STATE_INIT_RECEIVED))\n\t\tgoto out;\n\n\tif (mp_state->mp_state == KVM_MP_STATE_SIPI_RECEIVED) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t\tset_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);\n\t} else\n\t\tvcpu->arch.mp_state = mp_state->mp_state;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tret = 0;\nout:\n\tvcpu_put(vcpu);\n\treturn ret;\n}\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\tif (ret) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(kvm_task_switch);\n\nstatic bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tif ((sregs->efer & EFER_LME) && (sregs->cr0 & X86_CR0_PG)) {\n\t\t/*\n\t\t * When EFER.LME and CR0.PG are set, the processor is in\n\t\t * 64-bit mode (though maybe in a 32-bit code segment).\n\t\t * CR4.PAE and EFER.LMA must be set.\n\t\t */\n\t\tif (!(sregs->cr4 & X86_CR4_PAE) || !(sregs->efer & EFER_LMA))\n\t\t\treturn false;\n\t\tif (kvm_vcpu_is_illegal_gpa(vcpu, sregs->cr3))\n\t\t\treturn false;\n\t} else {\n\t\t/*\n\t\t * Not in 64-bit mode: EFER.LMA is clear and the code\n\t\t * segment cannot be 64-bit.\n\t\t */\n\t\tif (sregs->efer & EFER_LMA || sregs->cs.l)\n\t\t\treturn false;\n\t}\n\n\treturn kvm_is_valid_cr4(vcpu, sregs->cr4);\n}\n\nstatic int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,\n\t\tint *mmu_reset_needed, bool update_pdptrs)\n{\n\tstruct msr_data apic_base_msr;\n\tint idx;\n\tstruct desc_ptr dt;\n\n\tif (!kvm_is_valid_sregs(vcpu, sregs))\n\t\treturn -EINVAL;\n\n\tapic_base_msr.data = sregs->apic_base;\n\tapic_base_msr.host_initiated = true;\n\tif (kvm_set_apic_base(vcpu, &apic_base_msr))\n\t\treturn -EINVAL;\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn 0;\n\n\tdt.size = sregs->idt.limit;\n\tdt.address = sregs->idt.base;\n\tstatic_call(kvm_x86_set_idt)(vcpu, &dt);\n\tdt.size = sregs->gdt.limit;\n\tdt.address = sregs->gdt.base;\n\tstatic_call(kvm_x86_set_gdt)(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\t*mmu_reset_needed |= kvm_read_cr3(vcpu) != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\tstatic_call_cond(kvm_x86_post_set_cr3)(vcpu, sregs->cr3);\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\t*mmu_reset_needed |= vcpu->arch.efer != sregs->efer;\n\tstatic_call(kvm_x86_set_efer)(vcpu, sregs->efer);\n\n\t*mmu_reset_needed |= kvm_read_cr0(vcpu) != sregs->cr0;\n\tstatic_call(kvm_x86_set_cr0)(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\t*mmu_reset_needed |= kvm_read_cr4(vcpu) != sregs->cr4;\n\tstatic_call(kvm_x86_set_cr4)(vcpu, sregs->cr4);\n\n\tif (update_pdptrs) {\n\t\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tif (is_pae_paging(vcpu)) {\n\t\t\tload_pdptrs(vcpu, kvm_read_cr3(vcpu));\n\t\t\t*mmu_reset_needed = 1;\n\t\t}\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tupdate_cr8_intercept(vcpu);\n\n\t/* Older userspace won't unhalt the vcpu on reset. */\n\tif (kvm_vcpu_is_bsp(vcpu) && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !is_protmode(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\treturn 0;\n}\n\nstatic int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)\n{\n\tint pending_vec, max_bits;\n\tint mmu_reset_needed = 0;\n\tint ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tmax_bits = KVM_NR_INTERRUPTS;\n\tpending_vec = find_first_bit(\n\t\t(const unsigned long *)sregs->interrupt_bitmap, max_bits);\n\n\tif (pending_vec < max_bits) {\n\t\tkvm_queue_interrupt(vcpu, pending_vec, false);\n\t\tpr_debug(\"Set back pending irq %d\\n\", pending_vec);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\treturn 0;\n}\n\nstatic int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)\n{\n\tint mmu_reset_needed = 0;\n\tbool valid_pdptrs = sregs2->flags & KVM_SREGS2_FLAGS_PDPTRS_VALID;\n\tbool pae = (sregs2->cr0 & X86_CR0_PG) && (sregs2->cr4 & X86_CR4_PAE) &&\n\t\t!(sregs2->efer & EFER_LMA);\n\tint i, ret;\n\n\tif (sregs2->flags & ~KVM_SREGS2_FLAGS_PDPTRS_VALID)\n\t\treturn -EINVAL;\n\n\tif (valid_pdptrs && (!pae || vcpu->arch.guest_state_protected))\n\t\treturn -EINVAL;\n\n\tret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,\n\t\t\t\t &mmu_reset_needed, !valid_pdptrs);\n\tif (ret)\n\t\treturn ret;\n\n\tif (valid_pdptrs) {\n\t\tfor (i = 0; i < 4 ; i++)\n\t\t\tkvm_pdptr_write(vcpu, i, sregs2->pdptrs[i]);\n\n\t\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n\t\tmmu_reset_needed = 1;\n\t\tvcpu->arch.pdptrs_from_userspace = true;\n\t}\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint ret;\n\n\tvcpu_load(vcpu);\n\tret = __set_sregs(vcpu, sregs);\n\tvcpu_put(vcpu);\n\treturn ret;\n}\n\nstatic void kvm_arch_vcpu_guestdbg_update_apicv_inhibit(struct kvm *kvm)\n{\n\tbool set = false;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\tif (!enable_apicv)\n\t\treturn;\n\n\tdown_write(&kvm->arch.apicv_update_lock);\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_BLOCKIRQ) {\n\t\t\tset = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__kvm_set_or_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_BLOCKIRQ, set);\n\tup_write(&kvm->arch.apicv_update_lock);\n}\n\nint kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_guest_debug *dbg)\n{\n\tunsigned long rflags;\n\tint i, r;\n\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn -EINVAL;\n\n\tvcpu_load(vcpu);\n\n\tif (dbg->control & (KVM_GUESTDBG_INJECT_DB | KVM_GUESTDBG_INJECT_BP)) {\n\t\tr = -EBUSY;\n\t\tif (vcpu->arch.exception.pending)\n\t\t\tgoto out;\n\t\tif (dbg->control & KVM_GUESTDBG_INJECT_DB)\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\telse\n\t\t\tkvm_queue_exception(vcpu, BP_VECTOR);\n\t}\n\n\t/*\n\t * Read rflags as long as potentially injected trace flags are still\n\t * filtered out.\n\t */\n\trflags = kvm_get_rflags(vcpu);\n\n\tvcpu->guest_debug = dbg->control;\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_ENABLE))\n\t\tvcpu->guest_debug = 0;\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; ++i)\n\t\t\tvcpu->arch.eff_db[i] = dbg->arch.debugreg[i];\n\t\tvcpu->arch.guest_debug_dr7 = dbg->arch.debugreg[7];\n\t} else {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t}\n\tkvm_update_dr7(vcpu);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvcpu->arch.singlestep_rip = kvm_get_linear_rip(vcpu);\n\n\t/*\n\t * Trigger an rflags update that will inject or remove the trace\n\t * flags.\n\t */\n\tkvm_set_rflags(vcpu, rflags);\n\n\tstatic_call(kvm_x86_update_exception_bitmap)(vcpu);\n\n\tkvm_arch_vcpu_guestdbg_update_apicv_inhibit(vcpu->kvm);\n\n\tr = 0;\n\nout:\n\tvcpu_put(vcpu);\n\treturn r;\n}\n\n/*\n * Translate a guest virtual address to a guest physical address.\n */\nint kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\n\tvcpu_load(vcpu);\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_get_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave;\n\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn 0;\n\n\tvcpu_load(vcpu);\n\n\tfxsave = &vcpu->arch.guest_fpu.fpstate->regs.fxsave;\n\tmemcpy(fpu->fpr, fxsave->st_space, 128);\n\tfpu->fcw = fxsave->cwd;\n\tfpu->fsw = fxsave->swd;\n\tfpu->ftwx = fxsave->twd;\n\tfpu->last_opcode = fxsave->fop;\n\tfpu->last_ip = fxsave->rip;\n\tfpu->last_dp = fxsave->rdp;\n\tmemcpy(fpu->xmm, fxsave->xmm_space, sizeof(fxsave->xmm_space));\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nint kvm_arch_vcpu_ioctl_set_fpu(struct kvm_vcpu *vcpu, struct kvm_fpu *fpu)\n{\n\tstruct fxregs_state *fxsave;\n\n\tif (fpstate_is_confidential(&vcpu->arch.guest_fpu))\n\t\treturn 0;\n\n\tvcpu_load(vcpu);\n\n\tfxsave = &vcpu->arch.guest_fpu.fpstate->regs.fxsave;\n\n\tmemcpy(fxsave->st_space, fpu->fpr, 128);\n\tfxsave->cwd = fpu->fcw;\n\tfxsave->swd = fpu->fsw;\n\tfxsave->twd = fpu->ftwx;\n\tfxsave->fop = fpu->last_opcode;\n\tfxsave->rip = fpu->last_ip;\n\tfxsave->rdp = fpu->last_dp;\n\tmemcpy(fxsave->xmm_space, fpu->xmm, sizeof(fxsave->xmm_space));\n\n\tvcpu_put(vcpu);\n\treturn 0;\n}\n\nstatic void store_regs(struct kvm_vcpu *vcpu)\n{\n\tBUILD_BUG_ON(sizeof(struct kvm_sync_regs) > SYNC_REGS_SIZE_BYTES);\n\n\tif (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_REGS)\n\t\t__get_regs(vcpu, &vcpu->run->s.regs.regs);\n\n\tif (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_SREGS)\n\t\t__get_sregs(vcpu, &vcpu->run->s.regs.sregs);\n\n\tif (vcpu->run->kvm_valid_regs & KVM_SYNC_X86_EVENTS)\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(\n\t\t\t\tvcpu, &vcpu->run->s.regs.events);\n}\n\nstatic int sync_regs(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {\n\t\t__set_regs(vcpu, &vcpu->run->s.regs.regs);\n\t\tvcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_REGS;\n\t}\n\tif (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_SREGS) {\n\t\tif (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))\n\t\t\treturn -EINVAL;\n\t\tvcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_SREGS;\n\t}\n\tif (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_EVENTS) {\n\t\tif (kvm_vcpu_ioctl_x86_set_vcpu_events(\n\t\t\t\tvcpu, &vcpu->run->s.regs.events))\n\t\t\treturn -EINVAL;\n\t\tvcpu->run->kvm_dirty_regs &= ~KVM_SYNC_X86_EVENTS;\n\t}\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)\n{\n\tif (kvm_check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)\n\t\tpr_warn_once(\"kvm: SMP vm created on host with unstable TSC; \"\n\t\t\t     \"guest TSC will not be reliable\\n\");\n\n\treturn 0;\n}\n\nint kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tint r;\n\n\tvcpu->arch.last_vmentry_cpu = -1;\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tif (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\telse\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;\n\n\tr = kvm_mmu_create(vcpu);\n\tif (r < 0)\n\t\treturn r;\n\n\tif (irqchip_in_kernel(vcpu->kvm)) {\n\t\tr = kvm_create_lapic(vcpu, lapic_timer_advance_ns);\n\t\tif (r < 0)\n\t\t\tgoto fail_mmu_destroy;\n\n\t\t/*\n\t\t * Defer evaluating inhibits until the vCPU is first run, as\n\t\t * this vCPU will not get notified of any changes until this\n\t\t * vCPU is visible to other vCPUs (marked online and added to\n\t\t * the set of vCPUs).  Opportunistically mark APICv active as\n\t\t * VMX in particularly is highly unlikely to have inhibits.\n\t\t * Ignore the current per-VM APICv state so that vCPU creation\n\t\t * is guaranteed to run with a deterministic value, the request\n\t\t * will ensure the vCPU gets the correct state before VM-Entry.\n\t\t */\n\t\tif (enable_apicv) {\n\t\t\tvcpu->arch.apicv_active = true;\n\t\t\tkvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);\n\t\t}\n\t} else\n\t\tstatic_branch_inc(&kvm_has_noapic_vcpu);\n\n\tr = -ENOMEM;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\tif (!page)\n\t\tgoto fail_free_lapic;\n\tvcpu->arch.pio_data = page_address(page);\n\n\tvcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,\n\t\t\t\t       GFP_KERNEL_ACCOUNT);\n\tif (!vcpu->arch.mce_banks)\n\t\tgoto fail_free_pio_data;\n\tvcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;\n\n\tif (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask,\n\t\t\t\tGFP_KERNEL_ACCOUNT))\n\t\tgoto fail_free_mce_banks;\n\n\tif (!alloc_emulate_ctxt(vcpu))\n\t\tgoto free_wbinvd_dirty_mask;\n\n\tif (!fpu_alloc_guest_fpstate(&vcpu->arch.guest_fpu)) {\n\t\tpr_err(\"kvm: failed to allocate vcpu's fpu\\n\");\n\t\tgoto free_emulate_ctxt;\n\t}\n\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\tvcpu->arch.reserved_gpa_bits = kvm_vcpu_reserved_gpa_bits_raw(vcpu);\n\n\tvcpu->arch.pat = MSR_IA32_CR_PAT_DEFAULT;\n\n\tkvm_async_pf_hash_reset(vcpu);\n\tkvm_pmu_init(vcpu);\n\n\tvcpu->arch.pending_external_vector = -1;\n\tvcpu->arch.preempted_in_kernel = false;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tvcpu->arch.hv_root_tdp = INVALID_PAGE;\n#endif\n\n\tr = static_call(kvm_x86_vcpu_create)(vcpu);\n\tif (r)\n\t\tgoto free_guest_fpu;\n\n\tvcpu->arch.arch_capabilities = kvm_get_arch_capabilities();\n\tvcpu->arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;\n\tkvm_xen_init_vcpu(vcpu);\n\tkvm_vcpu_mtrr_init(vcpu);\n\tvcpu_load(vcpu);\n\tkvm_set_tsc_khz(vcpu, vcpu->kvm->arch.default_tsc_khz);\n\tkvm_vcpu_reset(vcpu, false);\n\tkvm_init_mmu(vcpu);\n\tvcpu_put(vcpu);\n\treturn 0;\n\nfree_guest_fpu:\n\tfpu_free_guest_fpstate(&vcpu->arch.guest_fpu);\nfree_emulate_ctxt:\n\tkmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);\nfree_wbinvd_dirty_mask:\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\nfail_free_mce_banks:\n\tkfree(vcpu->arch.mce_banks);\nfail_free_pio_data:\n\tfree_page((unsigned long)vcpu->arch.pio_data);\nfail_free_lapic:\n\tkvm_free_lapic(vcpu);\nfail_mmu_destroy:\n\tkvm_mmu_destroy(vcpu);\n\treturn r;\n}\n\nvoid kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\n\tif (mutex_lock_killable(&vcpu->mutex))\n\t\treturn;\n\tvcpu_load(vcpu);\n\tkvm_synchronize_tsc(vcpu, 0);\n\tvcpu_put(vcpu);\n\n\t/* poll control enabled by default */\n\tvcpu->arch.msr_kvm_poll_control = 1;\n\n\tmutex_unlock(&vcpu->mutex);\n\n\tif (kvmclock_periodic_sync && vcpu->vcpu_idx == 0)\n\t\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}\n\nvoid kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tint idx;\n\n\tkvmclock_reset(vcpu);\n\n\tstatic_call(kvm_x86_vcpu_free)(vcpu);\n\n\tkmem_cache_free(x86_emulator_cache, vcpu->arch.emulate_ctxt);\n\tfree_cpumask_var(vcpu->arch.wbinvd_dirty_mask);\n\tfpu_free_guest_fpstate(&vcpu->arch.guest_fpu);\n\n\tkvm_xen_destroy_vcpu(vcpu);\n\tkvm_hv_vcpu_uninit(vcpu);\n\tkvm_pmu_destroy(vcpu);\n\tkfree(vcpu->arch.mce_banks);\n\tkvm_free_lapic(vcpu);\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_mmu_destroy(vcpu);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\tfree_page((unsigned long)vcpu->arch.pio_data);\n\tkvfree(vcpu->arch.cpuid_entries);\n\tif (!lapic_in_kernel(vcpu))\n\t\tstatic_branch_dec(&kvm_has_noapic_vcpu);\n}\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_0x1;\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long new_cr0;\n\n\t/*\n\t * Several of the \"set\" flows, e.g. ->set_cr0(), read other registers\n\t * to handle side effects.  RESET emulation hits those flows and relies\n\t * on emulated/virtualized registers, including those that are loaded\n\t * into hardware, to be zeroed at vCPU creation.  Use CRs as a sentinel\n\t * to detect improper or missing initialization.\n\t */\n\tWARN_ON_ONCE(!init_event &&\n\t\t     (old_cr0 || kvm_read_cr3(vcpu) || kvm_read_cr4(vcpu)));\n\n\tkvm_lapic_reset(vcpu, init_event);\n\n\tvcpu->arch.hflags = 0;\n\n\tvcpu->arch.smi_pending = 0;\n\tvcpu->arch.smi_count = 0;\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_ACTIVE_LOW;\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_en_val = 0;\n\tvcpu->arch.apf.msr_int_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (vcpu->arch.guest_fpu.fpstate && kvm_mpx_supported()) {\n\t\tstruct fpstate *fpstate = vcpu->arch.guest_fpu.fpstate;\n\n\t\t/*\n\t\t * To avoid have the INIT path from kvm_apic_has_events() that be\n\t\t * called with loaded FPU and does not let userspace fix the state.\n\t\t */\n\t\tif (init_event)\n\t\t\tkvm_put_guest_fpu(vcpu);\n\n\t\tfpstate_clear_xstate_component(fpstate, XFEATURE_BNDREGS);\n\t\tfpstate_clear_xstate_component(fpstate, XFEATURE_BNDCSR);\n\n\t\tif (init_event)\n\t\t\tkvm_load_guest_fpu(vcpu);\n\t}\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\n\t\tvcpu->arch.msr_misc_features_enables = 0;\n\n\t\t__kvm_set_xcr(vcpu, 0, XFEATURE_MASK_FP);\n\t\t__kvm_set_msr(vcpu, MSR_IA32_XSS, 0, true);\n\t}\n\n\t/* All GPRs except RDX (handled below) are zeroed on RESET/INIT. */\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tkvm_register_mark_dirty(vcpu, VCPU_REGS_RSP);\n\n\t/*\n\t * Fall back to KVM's default Family/Model/Stepping of 0x600 (P6/Athlon)\n\t * if no CPUID match is found.  Note, it's impossible to get a match at\n\t * RESET since KVM emulates RESET before exposing the vCPU to userspace,\n\t * i.e. it's impossible for kvm_find_cpuid_entry() to find a valid entry\n\t * on RESET.  But, go through the motions in case that's ever remedied.\n\t */\n\tcpuid_0x1 = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tkvm_rdx_write(vcpu, cpuid_0x1 ? cpuid_0x1->eax : 0x600);\n\n\tstatic_call(kvm_x86_vcpu_reset)(vcpu, init_event);\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvcpu->arch.cr3 = 0;\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_CR3);\n\n\t/*\n\t * CR0.CD/NW are set on RESET, preserved on INIT.  Note, some versions\n\t * of Intel's SDM list CD/NW as being set on INIT, but they contradict\n\t * (or qualify) that with a footnote stating that CD/NW are preserved.\n\t */\n\tnew_cr0 = X86_CR0_ET;\n\tif (init_event)\n\t\tnew_cr0 |= (old_cr0 & (X86_CR0_NW | X86_CR0_CD));\n\telse\n\t\tnew_cr0 |= X86_CR0_NW | X86_CR0_CD;\n\n\tstatic_call(kvm_x86_set_cr0)(vcpu, new_cr0);\n\tstatic_call(kvm_x86_set_cr4)(vcpu, 0);\n\tstatic_call(kvm_x86_set_efer)(vcpu, 0);\n\tstatic_call(kvm_x86_update_exception_bitmap)(vcpu);\n\n\t/*\n\t * On the standard CR0/CR4/EFER modification paths, there are several\n\t * complex conditions determining whether the MMU has to be reset and/or\n\t * which PCIDs have to be flushed.  However, CR0.WP and the paging-related\n\t * bits in CR4 and EFER are irrelevant if CR0.PG was '0'; and a reset+flush\n\t * is needed anyway if CR0.PG was '1' (which can only happen for INIT, as\n\t * CR0 will be '0' prior to RESET).  So we only need to check CR0.PG here.\n\t */\n\tif (old_cr0 & X86_CR0_PG) {\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t\tkvm_mmu_reset_context(vcpu);\n\t}\n\n\t/*\n\t * Intel's SDM states that all TLB entries are flushed on INIT.  AMD's\n\t * APM states the TLBs are untouched by INIT, but it also states that\n\t * the TLBs are flushed on \"External initialization of the processor.\"\n\t * Flush the guest TLB regardless of vendor, there is no meaningful\n\t * benefit in relying on the guest to flush the TLB immediately after\n\t * INIT.  A spurious TLB flush is benign and likely negligible from a\n\t * performance perspective.\n\t */\n\tif (init_event)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_reset);\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_deliver_sipi_vector);\n\nint kvm_arch_hardware_enable(void)\n{\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\tint ret;\n\tu64 local_tsc;\n\tu64 max_tsc = 0;\n\tbool stable, backwards_tsc = false;\n\n\tkvm_user_return_msr_cpu_online();\n\tret = static_call(kvm_x86_hardware_enable)();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tlocal_tsc = rdtsc();\n\tstable = !kvm_check_tsc_unstable();\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!stable && vcpu->cpu == smp_processor_id())\n\t\t\t\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\t\t\tif (stable && vcpu->arch.last_host_tsc > local_tsc) {\n\t\t\t\tbackwards_tsc = true;\n\t\t\t\tif (vcpu->arch.last_host_tsc > max_tsc)\n\t\t\t\t\tmax_tsc = vcpu->arch.last_host_tsc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Sometimes, even reliable TSCs go backwards.  This happens on\n\t * platforms that reset TSC during suspend or hibernate actions, but\n\t * maintain synchronization.  We must compensate.  Fortunately, we can\n\t * detect that condition here, which happens early in CPU bringup,\n\t * before any KVM threads can be running.  Unfortunately, we can't\n\t * bring the TSCs fully up to date with real time, as we aren't yet far\n\t * enough into CPU bringup that we know how much real time has actually\n\t * elapsed; our helper function, ktime_get_boottime_ns() will be using boot\n\t * variables that haven't been updated yet.\n\t *\n\t * So we simply find the maximum observed TSC above, then record the\n\t * adjustment to TSC in each VCPU.  When the VCPU later gets loaded,\n\t * the adjustment will be applied.  Note that we accumulate\n\t * adjustments, in case multiple suspend cycles happen before some VCPU\n\t * gets a chance to run again.  In the event that no KVM threads get a\n\t * chance to run, we will miss the entire elapsed period, as we'll have\n\t * reset last_host_tsc, so VCPUs will not have the TSC adjusted and may\n\t * loose cycle time.  This isn't too big a deal, since the loss will be\n\t * uniform across all VCPUs (not to mention the scenario is extremely\n\t * unlikely). It is possible that a second hibernate recovery happens\n\t * much faster than a first, causing the observed TSC here to be\n\t * smaller; this would require additional padding adjustment, which is\n\t * why we set last_host_tsc to the local tsc observed here.\n\t *\n\t * N.B. - this code below runs only on platforms with reliable TSC,\n\t * as that is the only way backwards_tsc is set above.  Also note\n\t * that this runs for ALL vcpus, which is not a bug; all VCPUs should\n\t * have the same delta_cyc adjustment applied if backwards_tsc\n\t * is detected.  Note further, this adjustment is only done once,\n\t * as we reset last_host_tsc on all VCPUs to stop this from being\n\t * called multiple times (one for each physical CPU bringup).\n\t *\n\t * Platforms with unreliable TSCs don't have to deal with this, they\n\t * will be compensated by the logic in vcpu_load, which sets the TSC to\n\t * catchup mode.  This will catchup all VCPUs to real time, but cannot\n\t * guarantee that they stay in perfect synchronization.\n\t */\n\tif (backwards_tsc) {\n\t\tu64 delta_cyc = max_tsc - local_tsc;\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tkvm->arch.backwards_tsc_observed = true;\n\t\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t\tvcpu->arch.tsc_offset_adjustment += delta_cyc;\n\t\t\t\tvcpu->arch.last_host_tsc = local_tsc;\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We have to disable TSC offset matching.. if you were\n\t\t\t * booting a VM while issuing an S4 host suspend....\n\t\t\t * you may have some problem.  Solving this issue is\n\t\t\t * left as an exercise to the reader.\n\t\t\t */\n\t\t\tkvm->arch.last_tsc_nsec = 0;\n\t\t\tkvm->arch.last_tsc_write = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_disable(void)\n{\n\tstatic_call(kvm_x86_hardware_disable)();\n\tdrop_user_return_notifiers();\n}\n\nstatic inline void kvm_ops_update(struct kvm_x86_init_ops *ops)\n{\n\tmemcpy(&kvm_x86_ops, ops->runtime_ops, sizeof(kvm_x86_ops));\n\n#define __KVM_X86_OP(func) \\\n\tstatic_call_update(kvm_x86_##func, kvm_x86_ops.func);\n#define KVM_X86_OP(func) \\\n\tWARN_ON(!kvm_x86_ops.func); __KVM_X86_OP(func)\n#define KVM_X86_OP_OPTIONAL __KVM_X86_OP\n#define KVM_X86_OP_OPTIONAL_RET0(func) \\\n\tstatic_call_update(kvm_x86_##func, (void *)kvm_x86_ops.func ? : \\\n\t\t\t\t\t   (void *)__static_call_return0);\n#include <asm/kvm-x86-ops.h>\n#undef __KVM_X86_OP\n\n\tkvm_pmu_ops_update(ops->pmu_ops);\n}\n\nint kvm_arch_hardware_setup(void *opaque)\n{\n\tstruct kvm_x86_init_ops *ops = opaque;\n\tint r;\n\n\trdmsrl_safe(MSR_EFER, &host_efer);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\trdmsrl(MSR_IA32_XSS, host_xss);\n\n\tr = ops->hardware_setup();\n\tif (r != 0)\n\t\treturn r;\n\n\tkvm_ops_update(ops);\n\n\tkvm_register_perf_callbacks(ops->handle_intel_pt_intr);\n\n\tif (!kvm_cpu_cap_has(X86_FEATURE_XSAVES))\n\t\tsupported_xss = 0;\n\n#define __kvm_cpu_cap_has(UNUSED_, f) kvm_cpu_cap_has(f)\n\tcr4_reserved_bits = __cr4_reserved_bits(__kvm_cpu_cap_has, UNUSED_);\n#undef __kvm_cpu_cap_has\n\n\tif (kvm_has_tsc_control) {\n\t\t/*\n\t\t * Make sure the user can only configure tsc_khz values that\n\t\t * fit into a signed integer.\n\t\t * A min value is not calculated because it will always\n\t\t * be 1 on all machines.\n\t\t */\n\t\tu64 max = min(0x7fffffffULL,\n\t\t\t      __scale_tsc(kvm_max_tsc_scaling_ratio, tsc_khz));\n\t\tkvm_max_guest_tsc_khz = max;\n\t}\n\tkvm_default_tsc_scaling_ratio = 1ULL << kvm_tsc_scaling_ratio_frac_bits;\n\tkvm_init_msr_list();\n\treturn 0;\n}\n\nvoid kvm_arch_hardware_unsetup(void)\n{\n\tkvm_unregister_perf_callbacks();\n\n\tstatic_call(kvm_x86_hardware_unsetup)();\n}\n\nint kvm_arch_check_processor_compat(void *opaque)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(smp_processor_id());\n\tstruct kvm_x86_init_ops *ops = opaque;\n\n\tWARN_ON(!irqs_disabled());\n\n\tif (__cr4_reserved_bits(cpu_has, c) !=\n\t    __cr4_reserved_bits(cpu_has, &boot_cpu_data))\n\t\treturn -EIO;\n\n\treturn ops->check_processor_compatibility();\n}\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}\nEXPORT_SYMBOL_GPL(kvm_vcpu_is_reset_bsp);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}\n\n__read_mostly DEFINE_STATIC_KEY_FALSE(kvm_has_noapic_vcpu);\nEXPORT_SYMBOL_GPL(kvm_has_noapic_vcpu);\n\nvoid kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tif (pmu->version && unlikely(pmu->event_count)) {\n\t\tpmu->need_cleanup = true;\n\t\tkvm_make_request(KVM_REQ_PMU, vcpu);\n\t}\n\tstatic_call(kvm_x86_sched_in)(vcpu, cpu);\n}\n\nvoid kvm_arch_free_vm(struct kvm *kvm)\n{\n\tkfree(to_kvm_hv(kvm)->hv_pa_pg);\n\t__kvm_arch_free_vm(kvm);\n}\n\n\nint kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tif (type)\n\t\treturn -EINVAL;\n\n\tret = kvm_page_track_init(kvm);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kvm_mmu_init_vm(kvm);\n\tif (ret)\n\t\tgoto out_page_track;\n\n\tINIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tatomic_set(&kvm->arch.noncoherent_dma_count, 0);\n\n\t/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\t/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tseqcount_raw_spinlock_init(&kvm->arch.pvclock_sc, &kvm->arch.tsc_write_lock);\n\tkvm->arch.kvmclock_offset = -get_kvmclock_base_ns();\n\n\traw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);\n\tpvclock_update_vm_gtod_copy(kvm);\n\traw_spin_unlock_irqrestore(&kvm->arch.tsc_write_lock, flags);\n\n\tkvm->arch.default_tsc_khz = max_tsc_khz ? : tsc_khz;\n\tkvm->arch.guest_can_read_msr_platform_info = true;\n\tkvm->arch.enable_pmu = enable_pmu;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tspin_lock_init(&kvm->arch.hv_root_tdp_lock);\n\tkvm->arch.hv_root_tdp = INVALID_PAGE;\n#endif\n\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_update_work, kvmclock_update_fn);\n\tINIT_DELAYED_WORK(&kvm->arch.kvmclock_sync_work, kvmclock_sync_fn);\n\n\tkvm_apicv_init(kvm);\n\tkvm_hv_init_vm(kvm);\n\tkvm_xen_init_vm(kvm);\n\n\treturn static_call(kvm_x86_vm_init)(kvm);\n\nout_page_track:\n\tkvm_page_track_cleanup(kvm);\nout:\n\treturn ret;\n}\n\nint kvm_arch_post_init_vm(struct kvm *kvm)\n{\n\treturn kvm_mmu_post_init_vm(kvm);\n}\n\nstatic void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tvcpu_load(vcpu);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}\n\nstatic void kvm_unload_vcpu_mmus(struct kvm *kvm)\n{\n\tunsigned long i;\n\tstruct kvm_vcpu *vcpu;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_unload_vcpu_mmu(vcpu);\n\t}\n}\n\nvoid kvm_arch_sync_events(struct kvm *kvm)\n{\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_sync_work);\n\tcancel_delayed_work_sync(&kvm->arch.kvmclock_update_work);\n\tkvm_free_pit(kvm);\n}\n\n/**\n * __x86_set_memory_region: Setup KVM internal memory slot\n *\n * @kvm: the kvm pointer to the VM.\n * @id: the slot ID to setup.\n * @gpa: the GPA to install the slot (unused when @size == 0).\n * @size: the size of the slot. Set to zero to uninstall a slot.\n *\n * This function helps to setup a KVM internal memory slot.  Specify\n * @size > 0 to install a new slot, while @size == 0 to uninstall a\n * slot.  The return code can be one of the following:\n *\n *   HVA:           on success (uninstall will return a bogus HVA)\n *   -errno:        on error\n *\n * The caller should always use IS_ERR() to check the return value\n * before use.  Note, the KVM internal memory slots are guaranteed to\n * remain valid and unchanged until the VM is destroyed, i.e., the\n * GPA->HVA translation will not change.  However, the HVA is a user\n * address, i.e. its accessibility is not guaranteed, and must be\n * accessed via __copy_{to,from}_user().\n */\nvoid __user * __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa,\n\t\t\t\t      u32 size)\n{\n\tint i, r;\n\tunsigned long hva, old_npages;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn ERR_PTR_USR(-EINVAL);\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn ERR_PTR_USR(-EEXIST);\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn (void __user *)hva;\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn NULL;\n\n\t\told_npages = slot->npages;\n\t\thva = slot->userspace_addr;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn ERR_PTR_USR(r);\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn (void __user *)hva;\n}\nEXPORT_SYMBOL_GPL(__x86_set_memory_region);\n\nvoid kvm_arch_pre_destroy_vm(struct kvm *kvm)\n{\n\tkvm_mmu_pre_destroy_vm(kvm);\n}\n\nvoid kvm_arch_destroy_vm(struct kvm *kvm)\n{\n\tif (current->mm == kvm->mm) {\n\t\t/*\n\t\t * Free memory regions allocated on behalf of userspace,\n\t\t * unless the the memory map has changed due to process exit\n\t\t * or fd copying.\n\t\t */\n\t\tmutex_lock(&kvm->slots_lock);\n\t\t__x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t\t0, 0);\n\t\t__x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t\t0, 0);\n\t\t__x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, 0, 0);\n\t\tmutex_unlock(&kvm->slots_lock);\n\t}\n\tkvm_unload_vcpu_mmus(kvm);\n\tstatic_call_cond(kvm_x86_vm_destroy)(kvm);\n\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tkvm_pic_destroy(kvm);\n\tkvm_ioapic_destroy(kvm);\n\tkvm_destroy_vcpus(kvm);\n\tkvfree(rcu_dereference_check(kvm->arch.apic_map, 1));\n\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tkvm_mmu_uninit_vm(kvm);\n\tkvm_page_track_cleanup(kvm);\n\tkvm_xen_destroy_vm(kvm);\n\tkvm_hv_destroy_vm(kvm);\n}\n\nstatic void memslot_rmap_free(struct kvm_memory_slot *slot)\n{\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.rmap[i]);\n\t\tslot->arch.rmap[i] = NULL;\n\t}\n}\n\nvoid kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tint i;\n\n\tmemslot_rmap_free(slot);\n\n\tfor (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\n\tkvm_page_track_free_memslot(slot);\n}\n\nint memslot_rmap_alloc(struct kvm_memory_slot *slot, unsigned long npages)\n{\n\tconst int sz = sizeof(*slot->arch.rmap[0]);\n\tint i;\n\n\tfor (i = 0; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tint level = i + 1;\n\t\tint lpages = __kvm_mmu_slot_lpages(slot, npages, level);\n\n\t\tif (slot->arch.rmap[i])\n\t\t\tcontinue;\n\n\t\tslot->arch.rmap[i] = __vcalloc(lpages, sz, GFP_KERNEL_ACCOUNT);\n\t\tif (!slot->arch.rmap[i]) {\n\t\t\tmemslot_rmap_free(slot);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int kvm_alloc_memslot_metadata(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *slot)\n{\n\tunsigned long npages = slot->npages;\n\tint i, r;\n\n\t/*\n\t * Clear out the previous array pointers for the KVM_MR_MOVE case.  The\n\t * old arrays will be freed by __kvm_set_memory_region() if installing\n\t * the new memslot is successful.\n\t */\n\tmemset(&slot->arch, 0, sizeof(slot->arch));\n\n\tif (kvm_memslots_have_rmaps(kvm)) {\n\t\tr = memslot_rmap_alloc(slot, npages);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tfor (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tstruct kvm_lpage_info *linfo;\n\t\tunsigned long ugfn;\n\t\tint lpages;\n\t\tint level = i + 1;\n\n\t\tlpages = __kvm_mmu_slot_lpages(slot, npages, level);\n\n\t\tlinfo = __vcalloc(lpages, sizeof(*linfo), GFP_KERNEL_ACCOUNT);\n\t\tif (!linfo)\n\t\t\tgoto out_free;\n\n\t\tslot->arch.lpage_info[i - 1] = linfo;\n\n\t\tif (slot->base_gfn & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[0].disallow_lpage = 1;\n\t\tif ((slot->base_gfn + npages) & (KVM_PAGES_PER_HPAGE(level) - 1))\n\t\t\tlinfo[lpages - 1].disallow_lpage = 1;\n\t\tugfn = slot->userspace_addr >> PAGE_SHIFT;\n\t\t/*\n\t\t * If the gfn and userspace address are not aligned wrt each\n\t\t * other, disable large page support for this slot.\n\t\t */\n\t\tif ((slot->base_gfn ^ ugfn) & (KVM_PAGES_PER_HPAGE(level) - 1)) {\n\t\t\tunsigned long j;\n\n\t\t\tfor (j = 0; j < lpages; ++j)\n\t\t\t\tlinfo[j].disallow_lpage = 1;\n\t\t}\n\t}\n\n\tif (kvm_page_track_create_memslot(kvm, slot, npages))\n\t\tgoto out_free;\n\n\treturn 0;\n\nout_free:\n\tmemslot_rmap_free(slot);\n\n\tfor (i = 1; i < KVM_NR_PAGE_SIZES; ++i) {\n\t\tkvfree(slot->arch.lpage_info[i - 1]);\n\t\tslot->arch.lpage_info[i - 1] = NULL;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid kvm_arch_memslots_updated(struct kvm *kvm, u64 gen)\n{\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long i;\n\n\t/*\n\t * memslots->generation has been incremented.\n\t * mmio generation may have reached its maximum value.\n\t */\n\tkvm_mmu_invalidate_mmio_sptes(kvm, gen);\n\n\t/* Force re-initialization of steal_time cache */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nint kvm_arch_prepare_memory_region(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *old,\n\t\t\t\t   struct kvm_memory_slot *new,\n\t\t\t\t   enum kvm_mr_change change)\n{\n\tif (change == KVM_MR_CREATE || change == KVM_MR_MOVE) {\n\t\tif ((new->base_gfn + new->npages - 1) > kvm_mmu_max_gfn())\n\t\t\treturn -EINVAL;\n\n\t\treturn kvm_alloc_memslot_metadata(kvm, new);\n\t}\n\n\tif (change == KVM_MR_FLAGS_ONLY)\n\t\tmemcpy(&new->arch, &old->arch, sizeof(old->arch));\n\telse if (WARN_ON_ONCE(change != KVM_MR_DELETE))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n\nstatic void kvm_mmu_update_cpu_dirty_logging(struct kvm *kvm, bool enable)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\n\tif (!kvm_x86_ops.cpu_dirty_log_size)\n\t\treturn;\n\n\tif ((enable && ++ka->cpu_dirty_logging_count == 1) ||\n\t    (!enable && --ka->cpu_dirty_logging_count == 0))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_UPDATE_CPU_DIRTY_LOGGING);\n\n\tWARN_ON_ONCE(ka->cpu_dirty_logging_count < 0);\n}\n\nstatic void kvm_mmu_slot_apply_flags(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *old,\n\t\t\t\t     const struct kvm_memory_slot *new,\n\t\t\t\t     enum kvm_mr_change change)\n{\n\tu32 old_flags = old ? old->flags : 0;\n\tu32 new_flags = new ? new->flags : 0;\n\tbool log_dirty_pages = new_flags & KVM_MEM_LOG_DIRTY_PAGES;\n\n\t/*\n\t * Update CPU dirty logging if dirty logging is being toggled.  This\n\t * applies to all operations.\n\t */\n\tif ((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)\n\t\tkvm_mmu_update_cpu_dirty_logging(kvm, log_dirty_pages);\n\n\t/*\n\t * Nothing more to do for RO slots (which can't be dirtied and can't be\n\t * made writable) or CREATE/MOVE/DELETE of a slot.\n\t *\n\t * For a memslot with dirty logging disabled:\n\t * CREATE:      No dirty mappings will already exist.\n\t * MOVE/DELETE: The old mappings will already have been cleaned up by\n\t *\t\tkvm_arch_flush_shadow_memslot()\n\t *\n\t * For a memslot with dirty logging enabled:\n\t * CREATE:      No shadow pages exist, thus nothing to write-protect\n\t *\t\tand no dirty bits to clear.\n\t * MOVE/DELETE: The old mappings will already have been cleaned up by\n\t *\t\tkvm_arch_flush_shadow_memslot().\n\t */\n\tif ((change != KVM_MR_FLAGS_ONLY) || (new_flags & KVM_MEM_READONLY))\n\t\treturn;\n\n\t/*\n\t * READONLY and non-flags changes were filtered out above, and the only\n\t * other flag is LOG_DIRTY_PAGES, i.e. something is wrong if dirty\n\t * logging isn't being toggled on or off.\n\t */\n\tif (WARN_ON_ONCE(!((old_flags ^ new_flags) & KVM_MEM_LOG_DIRTY_PAGES)))\n\t\treturn;\n\n\tif (!log_dirty_pages) {\n\t\t/*\n\t\t * Dirty logging tracks sptes in 4k granularity, meaning that\n\t\t * large sptes have to be split.  If live migration succeeds,\n\t\t * the guest in the source machine will be destroyed and large\n\t\t * sptes will be created in the destination.  However, if the\n\t\t * guest continues to run in the source machine (for example if\n\t\t * live migration fails), small sptes will remain around and\n\t\t * cause bad performance.\n\t\t *\n\t\t * Scan sptes if dirty logging has been stopped, dropping those\n\t\t * which can be collapsed into a single large-page spte.  Later\n\t\t * page faults will create the large-page sptes.\n\t\t */\n\t\tkvm_mmu_zap_collapsible_sptes(kvm, new);\n\t} else {\n\t\t/*\n\t\t * Initially-all-set does not require write protecting any page,\n\t\t * because they're all assumed to be dirty.\n\t\t */\n\t\tif (kvm_dirty_log_manual_protect_and_init_set(kvm))\n\t\t\treturn;\n\n\t\tif (READ_ONCE(eager_page_split))\n\t\t\tkvm_mmu_slot_try_split_huge_pages(kvm, new, PG_LEVEL_4K);\n\n\t\tif (kvm_x86_ops.cpu_dirty_log_size) {\n\t\t\tkvm_mmu_slot_leaf_clear_dirty(kvm, new);\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_2M);\n\t\t} else {\n\t\t\tkvm_mmu_slot_remove_write_access(kvm, new, PG_LEVEL_4K);\n\t\t}\n\t}\n}\n\nvoid kvm_arch_commit_memory_region(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *old,\n\t\t\t\tconst struct kvm_memory_slot *new,\n\t\t\t\tenum kvm_mr_change change)\n{\n\tif (!kvm->arch.n_requested_mmu_pages &&\n\t    (change == KVM_MR_CREATE || change == KVM_MR_DELETE)) {\n\t\tunsigned long nr_mmu_pages;\n\n\t\tnr_mmu_pages = kvm->nr_memslot_pages / KVM_MEMSLOT_PAGES_TO_MMU_PAGES_RATIO;\n\t\tnr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);\n\t\tkvm_mmu_change_mmu_pages(kvm, nr_mmu_pages);\n\t}\n\n\tkvm_mmu_slot_apply_flags(kvm, old, new, change);\n\n\t/* Free the arrays associated with the old memslot. */\n\tif (change == KVM_MR_MOVE)\n\t\tkvm_arch_free_memslot(kvm, old);\n}\n\nvoid kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_zap_all(kvm);\n}\n\nvoid kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_page_track_flush_slot(kvm, slot);\n}\n\nstatic inline bool kvm_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn (is_guest_mode(vcpu) &&\n\t\tstatic_call(kvm_x86_guest_apic_has_interrupt)(vcpu));\n}\n\nstatic inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)\n{\n\tif (!list_empty_careful(&vcpu->async_pf.done))\n\t\treturn true;\n\n\tif (kvm_apic_has_events(vcpu))\n\t\treturn true;\n\n\tif (vcpu->arch.pv.pv_unhalted)\n\t\treturn true;\n\n\tif (vcpu->arch.exception.pending)\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_NMI, vcpu) ||\n\t    (vcpu->arch.nmi_pending &&\n\t     static_call(kvm_x86_nmi_allowed)(vcpu, false)))\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_SMI, vcpu) ||\n\t    (vcpu->arch.smi_pending &&\n\t     static_call(kvm_x86_smi_allowed)(vcpu, false)))\n\t\treturn true;\n\n\tif (kvm_arch_interrupt_allowed(vcpu) &&\n\t    (kvm_cpu_has_interrupt(vcpu) ||\n\t    kvm_guest_apic_has_interrupt(vcpu)))\n\t\treturn true;\n\n\tif (kvm_hv_has_stimer_pending(vcpu))\n\t\treturn true;\n\n\tif (is_guest_mode(vcpu) &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending &&\n\t    kvm_x86_ops.nested_ops->hv_timer_pending(vcpu))\n\t\treturn true;\n\n\tif (kvm_xen_has_pending_events(vcpu))\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_TRIPLE_FAULT, vcpu))\n\t\treturn true;\n\n\treturn false;\n}\n\nint kvm_arch_vcpu_runnable(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);\n}\n\nbool kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.apicv_active && static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool kvm_arch_dy_runnable(struct kvm_vcpu *vcpu)\n{\n\tif (READ_ONCE(vcpu->arch.pv.pv_unhalted))\n\t\treturn true;\n\n\tif (kvm_test_request(KVM_REQ_NMI, vcpu) ||\n\t\tkvm_test_request(KVM_REQ_SMI, vcpu) ||\n\t\t kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\treturn true;\n\n\treturn kvm_arch_dy_has_pending_interrupt(vcpu);\n}\n\nbool kvm_arch_vcpu_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn true;\n\n\treturn vcpu->arch.preempted_in_kernel;\n}\n\nunsigned long kvm_arch_vcpu_get_ip(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_rip_read(vcpu);\n}\n\nint kvm_arch_vcpu_should_kick(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_exiting_guest_mode(vcpu) == IN_GUEST_MODE;\n}\n\nint kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn static_call(kvm_x86_interrupt_allowed)(vcpu, false);\n}\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\t/* Can't read the RIP when guest state is protected, just return 0 */\n\tif (vcpu->arch.guest_state_protected)\n\t\treturn 0;\n\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}\nEXPORT_SYMBOL_GPL(kvm_get_linear_rip);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}\nEXPORT_SYMBOL_GPL(kvm_is_linear_rip);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = static_call(kvm_x86_get_rflags)(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}\nEXPORT_SYMBOL_GPL(kvm_get_rflags);\n\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tstatic_call(kvm_x86_set_rflags)(vcpu, rflags);\n}\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}\nEXPORT_SYMBOL_GPL(kvm_set_rflags);\n\nstatic inline u32 kvm_async_pf_hash_fn(gfn_t gfn)\n{\n\tBUILD_BUG_ON(!is_power_of_2(ASYNC_PF_PER_VCPU));\n\n\treturn hash_32(gfn & 0xffffffff, order_base_2(ASYNC_PF_PER_VCPU));\n}\n\nstatic inline u32 kvm_async_pf_next_probe(u32 key)\n{\n\treturn (key + 1) & (ASYNC_PF_PER_VCPU - 1);\n}\n\nstatic void kvm_add_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\twhile (vcpu->arch.apf.gfns[key] != ~0)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\tvcpu->arch.apf.gfns[key] = gfn;\n}\n\nstatic u32 kvm_async_pf_gfn_slot(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tint i;\n\tu32 key = kvm_async_pf_hash_fn(gfn);\n\n\tfor (i = 0; i < ASYNC_PF_PER_VCPU &&\n\t\t     (vcpu->arch.apf.gfns[key] != gfn &&\n\t\t      vcpu->arch.apf.gfns[key] != ~0); i++)\n\t\tkey = kvm_async_pf_next_probe(key);\n\n\treturn key;\n}\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\n\tif (WARN_ON_ONCE(vcpu->arch.apf.gfns[i] != gfn))\n\t\treturn;\n\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}\n\nstatic inline int apf_put_user_notpresent(struct kvm_vcpu *vcpu)\n{\n\tu32 reason = KVM_PV_REASON_PAGE_NOT_PRESENT;\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apf.data, &reason,\n\t\t\t\t      sizeof(reason));\n}\n\nstatic inline int apf_put_user_ready(struct kvm_vcpu *vcpu, u32 token)\n{\n\tunsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);\n\n\treturn kvm_write_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,\n\t\t\t\t\t     &token, offset, sizeof(token));\n}\n\nstatic inline bool apf_pageready_slot_free(struct kvm_vcpu *vcpu)\n{\n\tunsigned int offset = offsetof(struct kvm_vcpu_pv_apf_data, token);\n\tu32 val;\n\n\tif (kvm_read_guest_offset_cached(vcpu->kvm, &vcpu->arch.apf.data,\n\t\t\t\t\t &val, offset, sizeof(val)))\n\t\treturn false;\n\n\treturn !val;\n}\n\nstatic bool kvm_can_deliver_async_pf(struct kvm_vcpu *vcpu)\n{\n\n\tif (!kvm_pv_async_pf_enabled(vcpu))\n\t\treturn false;\n\n\tif (vcpu->arch.apf.send_user_only &&\n\t    static_call(kvm_x86_get_cpl)(vcpu) == 0)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * L1 needs to opt into the special #PF vmexits that are\n\t\t * used to deliver async page faults.\n\t\t */\n\t\treturn vcpu->arch.apf.delivery_as_pf_vmexit;\n\t} else {\n\t\t/*\n\t\t * Play it safe in case the guest temporarily disables paging.\n\t\t * The real mode IDT in particular is unlikely to have a #PF\n\t\t * exception setup.\n\t\t */\n\t\treturn is_paging(vcpu);\n\t}\n}\n\nbool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu) ||\n\t\t     vcpu->arch.exception.pending))\n\t\treturn false;\n\n\tif (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))\n\t\treturn false;\n\n\t/*\n\t * If interrupts are off we cannot even use an artificial\n\t * halt state.\n\t */\n\treturn kvm_arch_interrupt_allowed(vcpu);\n}\n\nbool kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,\n\t\t\t\t     struct kvm_async_pf *work)\n{\n\tstruct x86_exception fault;\n\n\ttrace_kvm_async_pf_not_present(work->arch.token, work->cr2_or_gpa);\n\tkvm_add_async_pf_gfn(vcpu, work->arch.gfn);\n\n\tif (kvm_can_deliver_async_pf(vcpu) &&\n\t    !apf_put_user_notpresent(vcpu)) {\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = 0;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = work->arch.token;\n\t\tfault.async_page_fault = true;\n\t\tkvm_inject_page_fault(vcpu, &fault);\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * It is not possible to deliver a paravirtualized asynchronous\n\t\t * page fault, but putting the guest in an artificial halt state\n\t\t * can be beneficial nevertheless: if an interrupt arrives, we\n\t\t * can deliver it timely and perhaps the guest will schedule\n\t\t * another process.  When the instruction that triggered a page\n\t\t * fault is retried, hopefully the page will be ready in the host.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\treturn false;\n\t}\n}\n\nvoid kvm_arch_async_page_present(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_async_pf *work)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vcpu->arch.apf.vec\n\t};\n\n\tif (work->wakeup_all)\n\t\twork->arch.token = ~0; /* broadcast wakeup */\n\telse\n\t\tkvm_del_async_pf_gfn(vcpu, work->arch.gfn);\n\ttrace_kvm_async_pf_ready(work->arch.token, work->cr2_or_gpa);\n\n\tif ((work->wakeup_all || work->notpresent_injected) &&\n\t    kvm_pv_async_pf_enabled(vcpu) &&\n\t    !apf_put_user_ready(vcpu, work->arch.token)) {\n\t\tvcpu->arch.apf.pageready_pending = true;\n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n\n\tvcpu->arch.apf.halted = false;\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n}\n\nvoid kvm_arch_async_page_present_queued(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_APF_READY, vcpu);\n\tif (!vcpu->arch.apf.pageready_pending)\n\t\tkvm_vcpu_kick(vcpu);\n}\n\nbool kvm_arch_can_dequeue_async_page_present(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_pv_async_pf_enabled(vcpu))\n\t\treturn true;\n\telse\n\t\treturn kvm_lapic_enabled(vcpu) && apf_pageready_slot_free(vcpu);\n}\n\nvoid kvm_arch_start_assignment(struct kvm *kvm)\n{\n\tif (atomic_inc_return(&kvm->arch.assigned_device_count) == 1)\n\t\tstatic_call_cond(kvm_x86_pi_start_assignment)(kvm);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_start_assignment);\n\nvoid kvm_arch_end_assignment(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.assigned_device_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_end_assignment);\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_assigned_device);\n\nvoid kvm_arch_register_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_inc(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_register_noncoherent_dma);\n\nvoid kvm_arch_unregister_noncoherent_dma(struct kvm *kvm)\n{\n\tatomic_dec(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_unregister_noncoherent_dma);\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}\nEXPORT_SYMBOL_GPL(kvm_arch_has_noncoherent_dma);\n\nbool kvm_arch_has_irq_bypass(void)\n{\n\treturn true;\n}\n\nint kvm_arch_irq_bypass_add_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\tint ret;\n\n\tirqfd->producer = prod;\n\tkvm_arch_start_assignment(irqfd->kvm);\n\tret = static_call(kvm_x86_pi_update_irte)(irqfd->kvm,\n\t\t\t\t\t prod->irq, irqfd->gsi, 1);\n\n\tif (ret)\n\t\tkvm_arch_end_assignment(irqfd->kvm);\n\n\treturn ret;\n}\n\nvoid kvm_arch_irq_bypass_del_producer(struct irq_bypass_consumer *cons,\n\t\t\t\t      struct irq_bypass_producer *prod)\n{\n\tint ret;\n\tstruct kvm_kernel_irqfd *irqfd =\n\t\tcontainer_of(cons, struct kvm_kernel_irqfd, consumer);\n\n\tWARN_ON(irqfd->producer != prod);\n\tirqfd->producer = NULL;\n\n\t/*\n\t * When producer of consumer is unregistered, we change back to\n\t * remapped mode, so we can re-use the current implementation\n\t * when the irq is masked/disabled or the consumer side (KVM\n\t * int this case doesn't want to receive the interrupts.\n\t*/\n\tret = static_call(kvm_x86_pi_update_irte)(irqfd->kvm, prod->irq, irqfd->gsi, 0);\n\tif (ret)\n\t\tprintk(KERN_INFO \"irq bypass consumer (token %p) unregistration\"\n\t\t       \" fails: %d\\n\", irqfd->consumer.token, ret);\n\n\tkvm_arch_end_assignment(irqfd->kvm);\n}\n\nint kvm_arch_update_irqfd_routing(struct kvm *kvm, unsigned int host_irq,\n\t\t\t\t   uint32_t guest_irq, bool set)\n{\n\treturn static_call(kvm_x86_pi_update_irte)(kvm, host_irq, guest_irq, set);\n}\n\nbool kvm_arch_irqfd_route_changed(struct kvm_kernel_irq_routing_entry *old,\n\t\t\t\t  struct kvm_kernel_irq_routing_entry *new)\n{\n\tif (new->type != KVM_IRQ_ROUTING_MSI)\n\t\treturn true;\n\n\treturn !!memcmp(&old->msi, &new->msi, sizeof(new->msi));\n}\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}\n\nbool kvm_arch_no_poll(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.msr_kvm_poll_control & 1) == 0;\n}\nEXPORT_SYMBOL_GPL(kvm_arch_no_poll);\n\n\nint kvm_spec_ctrl_test_value(u64 value)\n{\n\t/*\n\t * test that setting IA32_SPEC_CTRL to given value\n\t * is allowed by the host processor\n\t */\n\n\tu64 saved_value;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tlocal_irq_save(flags);\n\n\tif (rdmsrl_safe(MSR_IA32_SPEC_CTRL, &saved_value))\n\t\tret = 1;\n\telse if (wrmsrl_safe(MSR_IA32_SPEC_CTRL, value))\n\t\tret = 1;\n\telse\n\t\twrmsrl(MSR_IA32_SPEC_CTRL, saved_value);\n\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(kvm_spec_ctrl_test_value);\n\nvoid kvm_fixup_and_inject_pf_error(struct kvm_vcpu *vcpu, gva_t gva, u16 error_code)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\tstruct x86_exception fault;\n\tu64 access = error_code &\n\t\t(PFERR_WRITE_MASK | PFERR_FETCH_MASK | PFERR_USER_MASK);\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t    mmu->gva_to_gpa(vcpu, mmu, gva, access, &fault) != UNMAPPED_GVA) {\n\t\t/*\n\t\t * If vcpu->arch.walk_mmu->gva_to_gpa succeeded, the page\n\t\t * tables probably do not match the TLB.  Just proceed\n\t\t * with the error code that the processor gave.\n\t\t */\n\t\tfault.vector = PF_VECTOR;\n\t\tfault.error_code_valid = true;\n\t\tfault.error_code = error_code;\n\t\tfault.nested_page_fault = false;\n\t\tfault.address = gva;\n\t}\n\tvcpu->arch.walk_mmu->inject_page_fault(vcpu, &fault);\n}\nEXPORT_SYMBOL_GPL(kvm_fixup_and_inject_pf_error);\n\n/*\n * Handles kvm_read/write_guest_virt*() result and either injects #PF or returns\n * KVM_EXIT_INTERNAL_ERROR for cases not currently handled by KVM. Return value\n * indicates whether exit to userspace is needed.\n */\nint kvm_handle_memory_failure(struct kvm_vcpu *vcpu, int r,\n\t\t\t      struct x86_exception *e)\n{\n\tif (r == X86EMUL_PROPAGATE_FAULT) {\n\t\tkvm_inject_emulated_page_fault(vcpu, e);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * In case kvm_read/write_guest_virt*() failed with X86EMUL_IO_NEEDED\n\t * while handling a VMX instruction KVM could've handled the request\n\t * correctly by exiting to userspace and performing I/O but there\n\t * doesn't seem to be a real use-case behind such requests, just return\n\t * KVM_EXIT_INTERNAL_ERROR for now.\n\t */\n\tkvm_prepare_emulation_failure_exit(vcpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_handle_memory_failure);\n\nint kvm_handle_invpcid(struct kvm_vcpu *vcpu, unsigned long type, gva_t gva)\n{\n\tbool pcid_enabled;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 pcid;\n\t\tu64 gla;\n\t} operand;\n\tint r;\n\n\tr = kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e);\n\tif (r != X86EMUL_CONTINUE)\n\t\treturn kvm_handle_memory_failure(vcpu, r, &e);\n\n\tif (operand.pcid >> 12 != 0) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tpcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tswitch (type) {\n\tcase INVPCID_TYPE_INDIV_ADDR:\n\t\tif ((!pcid_enabled && (operand.pcid != 0)) ||\n\t\t    is_noncanonical_address(operand.gla, vcpu)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_SINGLE_CTXT:\n\t\tif (!pcid_enabled && (operand.pcid != 0)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tkvm_invalidate_pcid(vcpu, operand.pcid);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_ALL_NON_GLOBAL:\n\t\t/*\n\t\t * Currently, KVM doesn't mark global entries in the shadow\n\t\t * page tables, so a non-global flush just degenerates to a\n\t\t * global flush. If needed, we could optimize this later by\n\t\t * keeping track of global entries in shadow page tables.\n\t\t */\n\n\t\tfallthrough;\n\tcase INVPCID_TYPE_ALL_INCL_GLOBAL:\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH_GUEST, vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tdefault:\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n}\nEXPORT_SYMBOL_GPL(kvm_handle_invpcid);\n\nstatic int complete_sev_es_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned int len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t/* Complete previous fragment */\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t/* Switch to the next fragment. */\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t/* Go forward to the next mmio piece. */\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment >= vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t// VMG change, at this point, we're always done\n\t\t// RIP has already been advanced\n\t\treturn 1;\n\t}\n\n\t// More MMIO is needed\n\trun->mmio.phys_addr = frag->gpa;\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tif (run->mmio.is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->exit_reason = KVM_EXIT_MMIO;\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_mmio;\n\n\treturn 0;\n}\n\nint kvm_sev_es_mmio_write(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,\n\t\t\t  void *data)\n{\n\tint handled;\n\tstruct kvm_mmio_fragment *frag;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\thandled = write_emultor.read_write_mmio(vcpu, gpa, bytes, data);\n\tif (handled == bytes)\n\t\treturn 1;\n\n\tbytes -= handled;\n\tgpa += handled;\n\tdata += handled;\n\n\t/*TODO: Check if need to increment number of frags */\n\tfrag = vcpu->mmio_fragments;\n\tvcpu->mmio_nr_fragments = 1;\n\tfrag->len = bytes;\n\tfrag->gpa = gpa;\n\tfrag->data = data;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.phys_addr = gpa;\n\tvcpu->run->mmio.len = min(8u, frag->len);\n\tvcpu->run->mmio.is_write = 1;\n\tmemcpy(vcpu->run->mmio.data, frag->data, min(8u, frag->len));\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_mmio;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_sev_es_mmio_write);\n\nint kvm_sev_es_mmio_read(struct kvm_vcpu *vcpu, gpa_t gpa, unsigned int bytes,\n\t\t\t void *data)\n{\n\tint handled;\n\tstruct kvm_mmio_fragment *frag;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\thandled = read_emultor.read_write_mmio(vcpu, gpa, bytes, data);\n\tif (handled == bytes)\n\t\treturn 1;\n\n\tbytes -= handled;\n\tgpa += handled;\n\tdata += handled;\n\n\t/*TODO: Check if need to increment number of frags */\n\tfrag = vcpu->mmio_fragments;\n\tvcpu->mmio_nr_fragments = 1;\n\tfrag->len = bytes;\n\tfrag->gpa = gpa;\n\tfrag->data = data;\n\n\tvcpu->mmio_needed = 1;\n\tvcpu->mmio_cur_fragment = 0;\n\n\tvcpu->run->mmio.phys_addr = gpa;\n\tvcpu->run->mmio.len = min(8u, frag->len);\n\tvcpu->run->mmio.is_write = 0;\n\tvcpu->run->exit_reason = KVM_EXIT_MMIO;\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_mmio;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(kvm_sev_es_mmio_read);\n\nstatic int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t   unsigned int port);\n\nstatic int complete_sev_es_emulated_outs(struct kvm_vcpu *vcpu)\n{\n\tint size = vcpu->arch.pio.size;\n\tint port = vcpu->arch.pio.port;\n\n\tvcpu->arch.pio.count = 0;\n\tif (vcpu->arch.sev_pio_count)\n\t\treturn kvm_sev_es_outs(vcpu, size, port);\n\treturn 1;\n}\n\nstatic int kvm_sev_es_outs(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t   unsigned int port)\n{\n\tfor (;;) {\n\t\tunsigned int count =\n\t\t\tmin_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);\n\t\tint ret = emulator_pio_out(vcpu, size, port, vcpu->arch.sev_pio_data, count);\n\n\t\t/* memcpy done already by emulator_pio_out.  */\n\t\tvcpu->arch.sev_pio_count -= count;\n\t\tvcpu->arch.sev_pio_data += count * vcpu->arch.pio.size;\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\t/* Emulation done by the kernel.  */\n\t\tif (!vcpu->arch.sev_pio_count)\n\t\t\treturn 1;\n\t}\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_outs;\n\treturn 0;\n}\n\nstatic int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t  unsigned int port);\n\nstatic void advance_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n{\n\tunsigned count = vcpu->arch.pio.count;\n\tcomplete_emulator_pio_in(vcpu, vcpu->arch.sev_pio_data);\n\tvcpu->arch.sev_pio_count -= count;\n\tvcpu->arch.sev_pio_data += count * vcpu->arch.pio.size;\n}\n\nstatic int complete_sev_es_emulated_ins(struct kvm_vcpu *vcpu)\n{\n\tint size = vcpu->arch.pio.size;\n\tint port = vcpu->arch.pio.port;\n\n\tadvance_sev_es_emulated_ins(vcpu);\n\tif (vcpu->arch.sev_pio_count)\n\t\treturn kvm_sev_es_ins(vcpu, size, port);\n\treturn 1;\n}\n\nstatic int kvm_sev_es_ins(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t  unsigned int port)\n{\n\tfor (;;) {\n\t\tunsigned int count =\n\t\t\tmin_t(unsigned int, PAGE_SIZE / size, vcpu->arch.sev_pio_count);\n\t\tif (!__emulator_pio_in(vcpu, size, port, count))\n\t\t\tbreak;\n\n\t\t/* Emulation done by the kernel.  */\n\t\tadvance_sev_es_emulated_ins(vcpu);\n\t\tif (!vcpu->arch.sev_pio_count)\n\t\t\treturn 1;\n\t}\n\n\tvcpu->arch.complete_userspace_io = complete_sev_es_emulated_ins;\n\treturn 0;\n}\n\nint kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t unsigned int port, void *data,  unsigned int count,\n\t\t\t int in)\n{\n\tvcpu->arch.sev_pio_data = data;\n\tvcpu->arch.sev_pio_count = count;\n\treturn in ? kvm_sev_es_ins(vcpu, size, port)\n\t\t  : kvm_sev_es_outs(vcpu, size, port);\n}\nEXPORT_SYMBOL_GPL(kvm_sev_es_string_io);\n\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_entry);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_inj_virq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_page_fault);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_msr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_cr);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmrun);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmexit_inject);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intr_vmexit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_vmenter_failed);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_invlpga);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_skinit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_nested_intercepts);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_write_tsc_offset);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_ple_window_update);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pml_full);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_pi_irte_update);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_unaccelerated_access);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_incomplete_ipi);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_ga_log);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_avic_kick_vcpu_slowpath);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_apicv_accept_irq);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_enter);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_exit);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_enter);\nEXPORT_TRACEPOINT_SYMBOL_GPL(kvm_vmgexit_msr_protocol_exit);\n\nstatic int __init kvm_x86_init(void)\n{\n\tkvm_mmu_x86_module_init();\n\treturn 0;\n}\nmodule_init(kvm_x86_init);\n\nstatic void __exit kvm_x86_exit(void)\n{\n\t/*\n\t * If module_init() is implemented, module_exit() must also be\n\t * implemented to allow module unload.\n\t */\n}\nmodule_exit(kvm_x86_exit);\n"], "filenames": ["arch/x86/include/asm/kvm_host.h", "arch/x86/kvm/svm/svm.c", "arch/x86/kvm/vmx/vmx.c", "arch/x86/kvm/x86.c"], "buggy_code_start_loc": [655, 4265, 6549, 298], "buggy_code_end_loc": [1302, 4265, 6549, 10426], "fixing_code_start_loc": [656, 4266, 6550, 299], "fixing_code_end_loc": [1306, 4268, 6551, 10449], "type": "NVD-CWE-noinfo", "message": "An issue was discovered the x86 KVM subsystem in the Linux kernel before 5.18.17. Unprivileged guest users can compromise the guest kernel because TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations.", "other": {"cve": {"id": "CVE-2022-39189", "sourceIdentifier": "cve@mitre.org", "published": "2022-09-02T05:15:07.693", "lastModified": "2023-02-14T13:15:11.417", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered the x86 KVM subsystem in the Linux kernel before 5.18.17. Unprivileged guest users can compromise the guest kernel because TLB flush operations are mishandled in certain KVM_VCPU_PREEMPTED situations."}, {"lang": "es", "value": "Se ha detectado un problema en el subsistema KVM x86 en el kernel de Linux versiones anteriores a 5.18.17. Los usuarios invitados no privilegiados pueden comprometer el kernel invitado porque las operaciones de vaciado del TLB son manejadas inapropiadamente en determinadas situaciones de KVM_VCPU_PREEMPTED"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.18.17", "matchCriteriaId": "1F280165-1214-41AD-BAC3-E3D0B73AF604"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=2309", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.18.17", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6cd88243c7e03845a450795e134b488fc2afb736", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/6cd88243c7e03845a450795e134b488fc2afb736", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230214-0007/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/6cd88243c7e03845a450795e134b488fc2afb736"}}