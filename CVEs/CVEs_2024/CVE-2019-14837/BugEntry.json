{"buggy_code": ["{\n    \"realm\": \"demo\",\n    \"enabled\": true,\n    \"accessTokenLifespan\": 60,\n    \"accessCodeLifespan\": 60,\n    \"accessCodeLifespanUserAction\": 300,\n    \"ssoSessionIdleTimeout\": 600,\n    \"ssoSessionMaxLifespan\": 36000,\n    \"sslRequired\": \"external\",\n    \"registrationAllowed\": false,\n    \"privateKey\": \"MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y=\",\n    \"publicKey\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n    \"requiredCredentials\": [ \"password\" ],\n    \"users\" : [\n        {\n            \"username\" : \"bburke@redhat.com\",\n            \"enabled\": true,\n            \"email\" : \"bburke@redhat.com\",\n            \"firstName\": \"Bill\",\n            \"lastName\": \"Burke\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\", \"offline_access\"  ],\n            \"clientRoles\": {\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"stian\",\n            \"enabled\": true,\n            \"email\" : \"stian@redhat.com\",\n            \"firstName\": \"Stian\",\n            \"lastName\": \"Thorgersen\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\", \"offline_access\"  ],\n            \"clientRoles\": {\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"mposolda@redhat.com\",\n            \"enabled\": true,\n            \"email\" : \"mposolda@redhat.com\",\n            \"firstName\": \"Marek\",\n            \"lastName\": \"Posolda\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\", \"offline_access\" ],\n            \"clientRoles\": {\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"admin\",\n            \"enabled\": true,\n            \"email\" : \"admin@admin.com\",\n            \"firstName\": \"Admin\",\n            \"lastName\": \"Burke\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\",\"admin\" ],\n            \"clientRoles\": {\n                \"realm-management\": [ \"realm-admin\" ],\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"service-account-product-sa-client\",\n            \"enabled\": true,\n            \"email\" : \"service-account-product-sa-client@placeholder.org\",\n            \"serviceAccountClientId\": \"product-sa-client\",\n            \"realmRoles\": [ \"user\" ]\n        }\n    ],\n    \"roles\" : {\n        \"realm\" : [\n            {\n                \"name\": \"user\",\n                \"description\": \"User privileges\"\n            },\n            {\n                \"name\": \"admin\",\n                \"description\": \"Administrator privileges\"\n            }\n        ]\n    },\n    \"scopeMappings\": [\n        {\n            \"client\": \"third-party\",\n            \"roles\": [\"user\"]\n        },\n        {\n            \"client\": \"offline-access-portal\",\n            \"roles\": [\"user\", \"offline_access\"]\n        }\n    ],\n    \"clients\": [\n        {\n            \"clientId\": \"customer-portal\",\n            \"enabled\": true,\n            \"adminUrl\": \"/customer-portal\",\n            \"baseUrl\": \"/customer-portal\",\n            \"redirectUris\": [\n                \"/customer-portal/*\"\n            ],\n            \"secret\": \"password\"\n        },\n        {\n            \"clientId\": \"customer-portal-filter\",\n            \"enabled\": true,\n            \"adminUrl\": \"/customer-portal-filter/keycloak\",\n            \"baseUrl\": \"/customer-portal-filter\",\n            \"redirectUris\": [\n                \"/customer-portal-filter/*\"\n            ],\n            \"secret\": \"password\"\n        },\n        {\n            \"clientId\": \"customer-portal-js\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"baseUrl\": \"/customer-portal-js\",\n            \"redirectUris\": [\n                \"/customer-portal-js/*\"\n            ]\n        },\n        {\n            \"clientId\": \"angular-product\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"baseUrl\": \"/angular-product/index.html\",\n            \"redirectUris\": [\n                \"/angular-product/*\"\n            ]\n        },\n\t\t{\n            \"clientId\": \"angular2-product\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"baseUrl\": \"/angular2-product/index.html\",\n            \"redirectUris\": [\n                \"/angular2-product/*\"\n            ]\n        },\n        {\n            \"clientId\": \"customer-portal-cli\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"redirectUris\": [\n                \"urn:ietf:wg:oauth:2.0:oob\",\n                \"http://localhost\"\n            ]\n        },\n        {\n            \"clientId\": \"product-portal\",\n            \"enabled\": true,\n            \"adminUrl\": \"/product-portal\",\n            \"baseUrl\": \"/product-portal\",\n            \"redirectUris\": [\n                \"/product-portal/*\"\n            ],\n            \"clientAuthenticatorType\": \"client-jwt\",\n            \"attributes\": {\n                \"use.jwks.url\": \"true\",\n                \"jwks.url\": \"/product-portal/k_jwks\"\n            }\n        },\n        {\n            \"clientId\": \"database-service\",\n            \"enabled\": true,\n            \"adminUrl\": \"/database\",\n            \"baseUrl\": \"/database\",\n            \"bearerOnly\": true\n        },\n        {\n            \"clientId\": \"third-party\",\n            \"enabled\": true,\n            \"consentRequired\": true,\n            \"redirectUris\": [\n                \"/oauth-client/*\",\n                \"/oauth-client-cdi/*\"\n            ],\n            \"secret\": \"password\"\n        },\n        {\n            \"clientId\": \"admin-client\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"standardFlowEnabled\": false,\n            \"directAccessGrantsEnabled\": true\n        },\n        {\n            \"clientId\": \"product-sa-client\",\n            \"enabled\": true,\n            \"secret\": \"password\",\n            \"serviceAccountsEnabled\": true\n        },\n        {\n            \"clientId\": \"offline-access-portal\",\n            \"enabled\": true,\n            \"consentRequired\": true,\n            \"adminUrl\": \"/offline-access-portal\",\n            \"baseUrl\": \"/offline-access-portal\",\n            \"redirectUris\": [\n                \"/offline-access-portal/*\"\n            ],\n            \"secret\": \"password\"\n        }\n    ],\n    \"clientScopeMappings\": {\n        \"realm-management\": [\n            {\n                \"client\": \"admin-client\",\n                \"roles\": [\"realm-admin\"]\n            },\n            {\n                \"client\": \"customer-portal\",\n                \"roles\": [\"realm-admin\"]\n            },\n            {\n                \"client\": \"customer-portal-filter\",\n                \"roles\": [\"realm-admin\"]\n            }\n        ]\n    }\n\n\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.keycloak.services.managers;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonPropertyOrder;\nimport org.jboss.logging.Logger;\nimport org.keycloak.authentication.ClientAuthenticator;\nimport org.keycloak.authentication.ClientAuthenticatorFactory;\nimport org.keycloak.common.constants.ServiceAccountConstants;\nimport org.keycloak.common.util.Time;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.models.KeycloakSession;\nimport org.keycloak.models.ProtocolMapperModel;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.UserManager;\nimport org.keycloak.models.UserModel;\nimport org.keycloak.models.UserSessionProvider;\nimport org.keycloak.models.session.UserSessionPersisterProvider;\nimport org.keycloak.models.utils.RepresentationToModel;\nimport org.keycloak.protocol.LoginProtocol;\nimport org.keycloak.protocol.LoginProtocolFactory;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocol;\nimport org.keycloak.protocol.oidc.mappers.UserSessionNoteMapper;\nimport org.keycloak.representations.adapters.config.BaseRealmConfig;\nimport org.keycloak.representations.adapters.config.PolicyEnforcerConfig;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.sessions.AuthenticationSessionProvider;\n\nimport java.net.URI;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class ClientManager {\n    private static final Logger logger = Logger.getLogger(ClientManager.class);\n\n    protected RealmManager realmManager;\n\n    public ClientManager(RealmManager realmManager) {\n        this.realmManager = realmManager;\n    }\n\n    public ClientManager() {\n    }\n\n    /**\n     * Should not be called from an import.  This really expects that the client is created from the admin console.\n     *\n     * @param session\n     * @param realm\n     * @param rep\n     * @param addDefaultRoles\n     * @return\n     */\n    public static ClientModel createClient(KeycloakSession session, RealmModel realm, ClientRepresentation rep, boolean addDefaultRoles) {\n        ClientModel client = RepresentationToModel.createClient(session, realm, rep, addDefaultRoles);\n\n        if (rep.getProtocol() != null) {\n            LoginProtocolFactory providerFactory = (LoginProtocolFactory) session.getKeycloakSessionFactory().getProviderFactory(LoginProtocol.class, rep.getProtocol());\n            providerFactory.setupClientDefaults(rep, client);\n        }\n\n\n        // remove default mappers if there is a template\n        if (rep.getProtocolMappers() == null && rep.getClientTemplate() != null) {\n            Set<ProtocolMapperModel> mappers = client.getProtocolMappers();\n            for (ProtocolMapperModel mapper : mappers) client.removeProtocolMapper(mapper);\n        }\n        return client;\n\n    }\n\n\n    public boolean removeClient(RealmModel realm, ClientModel client) {\n        if (realm.removeClient(client.getId())) {\n            UserSessionProvider sessions = realmManager.getSession().sessions();\n            if (sessions != null) {\n                sessions.onClientRemoved(realm, client);\n            }\n\n            UserSessionPersisterProvider sessionsPersister = realmManager.getSession().getProvider(UserSessionPersisterProvider.class);\n            if (sessionsPersister != null) {\n                sessionsPersister.onClientRemoved(realm, client);\n            }\n\n            AuthenticationSessionProvider authSessions = realmManager.getSession().authenticationSessions();\n            if (authSessions != null) {\n                authSessions.onClientRemoved(realm, client);\n            }\n\n            UserModel serviceAccountUser = realmManager.getSession().users().getServiceAccount(client);\n            if (serviceAccountUser != null) {\n                new UserManager(realmManager.getSession()).removeUser(realm, serviceAccountUser);\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public Set<String> validateRegisteredNodes(ClientModel client) {\n        Map<String, Integer> registeredNodes = client.getRegisteredNodes();\n        if (registeredNodes == null || registeredNodes.isEmpty()) {\n            return Collections.emptySet();\n        }\n\n        int currentTime = Time.currentTime();\n\n        Set<String> validatedNodes = new TreeSet<String>();\n        if (client.getNodeReRegistrationTimeout() > 0) {\n            List<String> toRemove = new LinkedList<String>();\n            for (Map.Entry<String, Integer> entry : registeredNodes.entrySet()) {\n                Integer lastReRegistration = entry.getValue();\n                if (lastReRegistration + client.getNodeReRegistrationTimeout() < currentTime) {\n                    toRemove.add(entry.getKey());\n                } else {\n                    validatedNodes.add(entry.getKey());\n                }\n            }\n\n            // Remove time-outed nodes\n            for (String node : toRemove) {\n                client.unregisterNode(node);\n            }\n        } else {\n            // Periodic node reRegistration is disabled, so allow all nodes\n            validatedNodes.addAll(registeredNodes.keySet());\n        }\n\n        return validatedNodes;\n    }\n\n    public void enableServiceAccount(ClientModel client) {\n        client.setServiceAccountsEnabled(true);\n\n        // Add dedicated user for this service account\n        if (realmManager.getSession().users().getServiceAccount(client) == null) {\n            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + client.getClientId();\n            logger.debugf(\"Creating service account user '%s'\", username);\n\n            // Don't use federation for service account user\n            UserModel user = realmManager.getSession().userLocalStorage().addUser(client.getRealm(), username);\n            user.setEnabled(true);\n            user.setEmail(username + \"@placeholder.org\");\n            user.setServiceAccountClientLink(client.getId());\n        }\n\n        // Add protocol mappers to retrieve clientId in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ID,\n                    ServiceAccountConstants.CLIENT_ID, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        // Add protocol mappers to retrieve hostname and IP address of client in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_HOST,\n                    ServiceAccountConstants.CLIENT_HOST, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ADDRESS,\n                    ServiceAccountConstants.CLIENT_ADDRESS, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n    }\n\n    public void clientIdChanged(ClientModel client, String newClientId) {\n        logger.debugf(\"Updating clientId from '%s' to '%s'\", client.getClientId(), newClientId);\n\n        UserModel serviceAccountUser = realmManager.getSession().users().getServiceAccount(client);\n        if (serviceAccountUser != null) {\n            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + newClientId;\n            serviceAccountUser.setUsername(username);\n            serviceAccountUser.setEmail(username + \"@placeholder.org\");\n        }\n    }\n\n    @JsonPropertyOrder({\"realm\", \"realm-public-key\", \"bearer-only\", \"auth-server-url\", \"ssl-required\",\n            \"resource\", \"public-client\", \"verify-token-audience\", \"credentials\",\n            \"use-resource-role-mappings\"})\n    public static class InstallationAdapterConfig extends BaseRealmConfig {\n        @JsonProperty(\"resource\")\n        protected String resource;\n        @JsonProperty(\"use-resource-role-mappings\")\n        protected Boolean useResourceRoleMappings;\n        @JsonProperty(\"bearer-only\")\n        protected Boolean bearerOnly;\n        @JsonProperty(\"public-client\")\n        protected Boolean publicClient;\n        @JsonProperty(\"credentials\")\n        protected Map<String, Object> credentials;\n        @JsonProperty(\"verify-token-audience\")\n        protected Boolean verifyTokenAudience;\n        @JsonProperty(\"policy-enforcer\")\n        protected PolicyEnforcerConfig enforcerConfig;\n\n        public Boolean isUseResourceRoleMappings() {\n            return useResourceRoleMappings;\n        }\n\n        public void setUseResourceRoleMappings(Boolean useResourceRoleMappings) {\n            this.useResourceRoleMappings = useResourceRoleMappings;\n        }\n\n        public String getResource() {\n            return resource;\n        }\n\n        public void setResource(String resource) {\n            this.resource = resource;\n        }\n\n        public Map<String, Object> getCredentials() {\n            return credentials;\n        }\n\n        public void setCredentials(Map<String, Object> credentials) {\n            this.credentials = credentials;\n        }\n\n        public Boolean getVerifyTokenAudience() {\n            return verifyTokenAudience;\n        }\n\n        public void setVerifyTokenAudience(Boolean verifyTokenAudience) {\n            this.verifyTokenAudience = verifyTokenAudience;\n        }\n\n        public Boolean getPublicClient() {\n            return publicClient;\n        }\n\n        public void setPublicClient(Boolean publicClient) {\n            this.publicClient = publicClient;\n        }\n\n        public Boolean getBearerOnly() {\n            return bearerOnly;\n        }\n\n        public void setBearerOnly(Boolean bearerOnly) {\n            this.bearerOnly = bearerOnly;\n        }\n\n        public PolicyEnforcerConfig getEnforcerConfig() {\n            return this.enforcerConfig;\n        }\n\n        public void setEnforcerConfig(PolicyEnforcerConfig enforcerConfig) {\n            this.enforcerConfig = enforcerConfig;\n        }\n    }\n\n\n    public InstallationAdapterConfig toInstallationRepresentation(RealmModel realmModel, ClientModel clientModel, URI baseUri) {\n        InstallationAdapterConfig rep = new InstallationAdapterConfig();\n        rep.setAuthServerUrl(baseUri.toString());\n        rep.setRealm(realmModel.getName());\n        rep.setSslRequired(realmModel.getSslRequired().name().toLowerCase());\n\n        if (clientModel.isPublicClient() && !clientModel.isBearerOnly()) rep.setPublicClient(true);\n        if (clientModel.isBearerOnly()) rep.setBearerOnly(true);\n        if (clientModel.getRoles().size() > 0) rep.setUseResourceRoleMappings(true);\n\n        rep.setResource(clientModel.getClientId());\n\n        if (showClientCredentialsAdapterConfig(clientModel)) {\n            Map<String, Object> adapterConfig = getClientCredentialsAdapterConfig(clientModel);\n            rep.setCredentials(adapterConfig);\n        }\n\n        return rep;\n    }\n\n    public String toJBossSubsystemConfig(RealmModel realmModel, ClientModel clientModel, URI baseUri) {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"<secure-deployment name=\\\"WAR MODULE NAME.war\\\">\\n\");\n        buffer.append(\"    <realm>\").append(realmModel.getName()).append(\"</realm>\\n\");\n        buffer.append(\"    <auth-server-url>\").append(baseUri.toString()).append(\"</auth-server-url>\\n\");\n        if (clientModel.isBearerOnly()){\n            buffer.append(\"    <bearer-only>true</bearer-only>\\n\");\n\n        } else if (clientModel.isPublicClient()) {\n            buffer.append(\"    <public-client>true</public-client>\\n\");\n        }\n        buffer.append(\"    <ssl-required>\").append(realmModel.getSslRequired().name()).append(\"</ssl-required>\\n\");\n        buffer.append(\"    <resource>\").append(clientModel.getClientId()).append(\"</resource>\\n\");\n        String cred = clientModel.getSecret();\n        if (showClientCredentialsAdapterConfig(clientModel)) {\n            Map<String, Object> adapterConfig = getClientCredentialsAdapterConfig(clientModel);\n            for (Map.Entry<String, Object> entry : adapterConfig.entrySet()) {\n                buffer.append(\"    <credential name=\\\"\" + entry.getKey() + \"\\\">\");\n\n                Object value = entry.getValue();\n                if (value instanceof Map) {\n                    buffer.append(\"\\n\");\n                    Map<String, Object> asMap = (Map<String, Object>) value;\n                    for (Map.Entry<String, Object> credEntry : asMap.entrySet()) {\n                        buffer.append(\"        <\" + credEntry.getKey() + \">\" + credEntry.getValue().toString() + \"</\" + credEntry.getKey() + \">\\n\");\n                    }\n                    buffer.append(\"    </credential>\\n\");\n                } else {\n                    buffer.append(value.toString()).append(\"</credential>\\n\");\n                }\n            }\n        }\n        if (clientModel.getRoles().size() > 0) {\n            buffer.append(\"    <use-resource-role-mappings>true</use-resource-role-mappings>\\n\");\n        }\n        buffer.append(\"</secure-deployment>\\n\");\n        return buffer.toString();\n    }\n\n    private boolean showClientCredentialsAdapterConfig(ClientModel client) {\n        if (client.isPublicClient()) {\n            return false;\n        }\n\n        if (client.isBearerOnly() && client.getNodeReRegistrationTimeout() <= 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private Map<String, Object> getClientCredentialsAdapterConfig(ClientModel client) {\n        String clientAuthenticator = client.getClientAuthenticatorType();\n        ClientAuthenticatorFactory authenticator = (ClientAuthenticatorFactory) realmManager.getSession().getKeycloakSessionFactory().getProviderFactory(ClientAuthenticator.class, clientAuthenticator);\n        return authenticator.getAdapterConfiguration(client);\n    }\n\n}\n", "{\n  \"realm\": \"photoz\",\n  \"enabled\": true,\n  \"userManagedAccessAllowed\": true,\n  \"sslRequired\": \"external\",\n  \"privateKey\": \"MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y=\",\n  \"publicKey\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n  \"accessTokenLifespan\": 100000,\n  \"requiredCredentials\": [\n    \"password\"\n  ],\n  \"users\": [\n    {\n      \"username\": \"alice\",\n      \"enabled\": true,\n      \"email\": \"alice@keycloak.org\",\n      \"firstName\": \"Alice\",\n      \"lastName\": \"In Chains\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"alice\"\n        }\n      ],\n      \"realmRoles\": [\n        \"user\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"jdoe\",\n      \"enabled\": true,\n      \"email\": \"jdoe@keycloak.org\",\n      \"firstName\": \"John\",\n      \"lastName\": \"Doe\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"jdoe\"\n        }\n      ],\n      \"realmRoles\": [\n        \"user\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"pedroigor\",\n      \"enabled\": true,\n      \"email\": \"pedroigor@keycloak.org\",\n      \"firstName\": \"Pedro Igor\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"pedroigor\"\n        }\n      ],\n      \"realmRoles\": [\n        \"user\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"admin\",\n      \"enabled\": true,\n      \"email\": \"admin@admin.com\",\n      \"firstName\": \"Admin\",\n      \"lastName\": \"Istrator\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"admin\"\n        }\n      ],\n      \"realmRoles\": [\n        \"admin\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"realm-management\": [\n          \"realm-admin\"\n        ],\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"service-account-photoz-restful-api\",\n      \"enabled\": true,\n      \"email\": \"service-account-photoz-restful-api@placeholder.org\",\n      \"serviceAccountClientId\": \"photoz-restful-api\",\n      \"clientRoles\": {\n        \"photoz-restful-api\" : [\"uma_protection\"]\n      }\n    }\n  ],\n  \"roles\": {\n    \"realm\": [\n      {\n        \"name\": \"user\",\n        \"description\": \"User privileges\"\n      },\n      {\n        \"name\": \"admin\",\n        \"description\": \"Administrator privileges\"\n      }\n    ]\n  },\n  \"clients\": [\n    {\n      \"clientId\": \"photoz-html5-client\",\n      \"enabled\": true,\n      \"adminUrl\": \"/photoz-html5-client\",\n      \"baseUrl\": \"/photoz-html5-client\",\n      \"publicClient\": true,\n      \"consentRequired\" : true,\n      \"fullScopeAllowed\" : true,\n      \"redirectUris\": [\n        \"*\"\n      ],\n      \"webOrigins\": [\"*\"]\n    },\n    {\n      \"clientId\": \"photoz-restful-api\",\n      \"enabled\": true,\n      \"baseUrl\": \"/photoz-restful-api\",\n      \"authorizationServicesEnabled\" : true,\n      \"redirectUris\": [\n        \"*\"\n      ],\n      \"webOrigins\" : [\"*\"],\n      \"clientAuthenticatorType\": \"client-jwt\",\n      \"attributes\" : {\n        \"jwt.credential.certificate\" : \"MIICqTCCAZECBgFT0Ngs/DANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1zZWN1cmUtcG9ydGFsMB4XDTE2MDQwMTA4MDA0MVoXDTI2MDQwMTA4MDIyMVowGDEWMBQGA1UEAwwNc2VjdXJlLXBvcnRhbDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJa4GixpmzP511AmI0eLPLORyJwXS8908MUvdG3hmh8jMOIhe28XjIFeZSY09vFxh22F2SUMjxU/B2Hw4PDJUkebuNR7rXhOIYCJAo6eEZzjSBY/wngFtfm74zJ/eLCobBtDvIld7jobdHTfE1Oz9+GzvtG0k7cm7ubrLT0J4I1UsFZj3b//3wa+O0vNaTwHC1Jz/m59VbtXqyO4xEzIdl416cnGCmEmk5qd5h1de2UoLi/CTad8HftIJhzN1qhlySzW/9Ha70aYlDH2hiibDsXDTrNaMdaaLik7I8Rv/nIbggysG863PKZo8wknDe62QctH5VYSSktiy4gjSJkGh7ECAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAZnnx+AHQ8txugGcFK8gWjildDgk+v31fBHBDvmLQaSzsUaIOJaK4wnlwUI+VfR46HmBXhjlDCobFLUptd+kz0G7xapcIn3b5jLrySUUD7L+LAp1vNOQU4mKhTGS3IEvNB73D3GH9rQ+M3KEcoN3f99fNKqKsUdxbmZqGf4VOQ57PUfLBw4PJJGlROPosBc7ivPRyeYnKekhoCTynq30BAD1FA1BA8ppcY4ZVGADPTAgMJxpglpFY9LiqCwdLAGW1ttnsyIJ7DpT+kybhhk7c+MU7gyQdv8xPnMR0bSCB9hndowgBn5oZ393aMscwMNCzwJ0aWBs1sUyn3X0RIsu9Jg==\"\n      }\n    }\n  ]\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.testsuite.admin;\n\nimport org.junit.Test;\nimport org.keycloak.OAuth2Constants;\nimport org.keycloak.admin.client.resource.ClientResource;\nimport org.keycloak.admin.client.resource.ProtocolMappersResource;\nimport org.keycloak.admin.client.resource.RoleMappingResource;\nimport org.keycloak.common.util.Time;\nimport org.keycloak.events.admin.OperationType;\nimport org.keycloak.events.admin.ResourceType;\nimport org.keycloak.models.AccountRoles;\nimport org.keycloak.models.Constants;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocol;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocolFactory;\nimport org.keycloak.representations.adapters.action.GlobalRequestResult;\nimport org.keycloak.representations.adapters.action.PushNotBeforeAction;\nimport org.keycloak.representations.adapters.action.TestAvailabilityAction;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.representations.idm.OAuth2ErrorRepresentation;\nimport org.keycloak.representations.idm.ProtocolMapperRepresentation;\nimport org.keycloak.representations.idm.RoleRepresentation;\nimport org.keycloak.representations.idm.UserRepresentation;\nimport org.keycloak.representations.idm.UserSessionRepresentation;\nimport org.keycloak.testsuite.Assert;\nimport org.keycloak.testsuite.util.AdminEventPaths;\nimport org.keycloak.testsuite.util.ClientBuilder;\nimport org.keycloak.testsuite.util.CredentialBuilder;\nimport org.keycloak.testsuite.util.OAuthClient;\nimport org.keycloak.testsuite.util.OAuthClient.AccessTokenResponse;\nimport org.keycloak.testsuite.util.RoleBuilder;\nimport org.keycloak.testsuite.util.UserBuilder;\n\nimport javax.ws.rs.BadRequestException;\nimport javax.ws.rs.NotFoundException;\nimport javax.ws.rs.core.Response;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.junit.Assert.*;\n\n/**\n * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n */\npublic class ClientTest extends AbstractAdminTest {\n\n    @Test\n    public void getClients() {\n        Assert.assertNames(realm.clients().findAll(), \"account\", \"realm-management\", \"security-admin-console\", \"broker\", Constants.ADMIN_CLI_CLIENT_ID);\n    }\n\n    private ClientRepresentation createClient() {\n        ClientRepresentation rep = new ClientRepresentation();\n        rep.setClientId(\"my-app\");\n        rep.setDescription(\"my-app description\");\n        rep.setEnabled(true);\n        Response response = realm.clients().create(rep);\n        response.close();\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        ClientRepresentation found = ApiUtil.findClientResourceByClientId(realm, \"my-app\").toRepresentation();\n\n        assertEquals(\"my-app\", found.getClientId());\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientResourcePath(id), rep, ResourceType.CLIENT);\n\n        rep.setId(id);\n\n        return rep;\n    }\n\n    @Test\n    public void createClientVerify() {\n        String id = createClient().getId();\n\n        assertNotNull(realm.clients().get(id));\n        Assert.assertNames(realm.clients().findAll(), \"account\", \"realm-management\", \"security-admin-console\", \"broker\", \"my-app\", Constants.ADMIN_CLI_CLIENT_ID);\n    }\n\n    @Test\n    public void removeClient() {\n        String id = createClient().getId();\n\n        assertNotNull(ApiUtil.findClientByClientId(realm, \"my-app\"));\n        realm.clients().get(id).remove();\n        assertNull(ApiUtil.findClientResourceByClientId(realm, \"my-app\"));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientResourcePath(id), ResourceType.CLIENT);\n    }\n\n    @Test\n    public void getClientRepresentation() {\n        String id = createClient().getId();\n\n        ClientRepresentation rep = realm.clients().get(id).toRepresentation();\n        assertEquals(id, rep.getId());\n        assertEquals(\"my-app\", rep.getClientId());\n        assertTrue(rep.isEnabled());\n    }\n\n    /**\n     * See <a href=\"https://issues.jboss.org/browse/KEYCLOAK-1918\">KEYCLOAK-1918</a>\n     */\n    @Test\n    public void getClientDescription() {\n        String id = createClient().getId();\n\n        ClientRepresentation rep = realm.clients().get(id).toRepresentation();\n        assertEquals(id, rep.getId());\n        assertEquals(\"my-app description\", rep.getDescription());\n    }\n\n    @Test\n    public void getClientSessions() throws Exception {\n        OAuthClient.AccessTokenResponse response = oauth.doGrantAccessTokenRequest(\"password\", \"test-user@localhost\", \"password\");\n        assertEquals(200, response.getStatusCode());\n\n        OAuthClient.AuthorizationEndpointResponse codeResponse = oauth.doLogin(\"test-user@localhost\", \"password\");\n\n        OAuthClient.AccessTokenResponse response2 = oauth.doAccessTokenRequest(codeResponse.getCode(), \"password\");\n        assertEquals(200, response2.getStatusCode());\n\n        ClientResource app = ApiUtil.findClientByClientId(adminClient.realm(\"test\"), \"test-app\");\n\n        assertEquals(2, (long) app.getApplicationSessionCount().get(\"count\"));\n\n        List<UserSessionRepresentation> userSessions = app.getUserSessions(0, 100);\n        assertEquals(2, userSessions.size());\n        assertEquals(1, userSessions.get(0).getClients().size());\n    }\n\n    @Test\n    public void getAllClients() {\n        List<ClientRepresentation> allClients = realm.clients().findAll();\n        assertNotNull(allClients);\n        assertFalse(allClients.isEmpty());\n    }\n\n    @Test\n    public void getClientById() {\n        createClient();\n        ClientRepresentation rep = ApiUtil.findClientResourceByClientId(realm, \"my-app\").toRepresentation();\n        ClientRepresentation gotById = realm.clients().get(rep.getId()).toRepresentation();\n        assertClient(rep, gotById);\n    }\n\n    @Test\n    // KEYCLOAK-1110\n    public void deleteDefaultRole() {\n        ClientRepresentation rep = createClient();\n        String id = rep.getId();\n\n        RoleRepresentation role = new RoleRepresentation(\"test\", \"test\", false);\n        realm.clients().get(id).roles().create(role);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientRoleResourcePath(id, \"test\"), role, ResourceType.CLIENT_ROLE);\n\n        ClientRepresentation foundClientRep = realm.clients().get(id).toRepresentation();\n        foundClientRep.setDefaultRoles(new String[]{\"test\"});\n        realm.clients().get(id).update(foundClientRep);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(id), rep, ResourceType.CLIENT);\n\n        assertArrayEquals(new String[]{\"test\"}, realm.clients().get(id).toRepresentation().getDefaultRoles());\n\n        realm.clients().get(id).roles().deleteRole(\"test\");\n\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientRoleResourcePath(id, \"test\"), ResourceType.CLIENT_ROLE);\n\n        assertNull(realm.clients().get(id).toRepresentation().getDefaultRoles());\n    }\n\n    @Test\n    public void testProtocolMappers() {\n        String clientDbId = createClient().getId();\n        ProtocolMappersResource mappersResource = ApiUtil.findClientByClientId(realm, \"my-app\").getProtocolMappers();\n\n        protocolMappersTest(clientDbId, mappersResource);\n    }\n\n    @Test\n    public void updateClient() {\n        ClientRepresentation client = createClient();\n\n        ClientRepresentation newClient = new ClientRepresentation();\n        newClient.setId(client.getId());\n        newClient.setClientId(client.getClientId());\n        newClient.setBaseUrl(\"http://baseurl\");\n\n        realm.clients().get(client.getId()).update(newClient);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(client.getId()), newClient, ResourceType.CLIENT);\n\n        ClientRepresentation storedClient = realm.clients().get(client.getId()).toRepresentation();\n\n        assertClient(client, storedClient);\n\n        newClient.setSecret(\"new-secret\");\n\n        realm.clients().get(client.getId()).update(newClient);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(client.getId()), newClient, ResourceType.CLIENT);\n\n        storedClient = realm.clients().get(client.getId()).toRepresentation();\n        assertClient(client, storedClient);\n    }\n\n    @Test\n    public void serviceAccount() {\n        Response response = realm.clients().create(ClientBuilder.create().clientId(\"serviceClient\").serviceAccount().build());\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n        UserRepresentation userRep = realm.clients().get(id).getServiceAccountUser();\n        assertEquals(\"service-account-serviceclient\", userRep.getUsername());\n    }\n\n    // KEYCLOAK-3421\n    @Test\n    public void createClientWithFragments() {\n        ClientRepresentation client = ClientBuilder.create()\n                .clientId(\"client-with-fragment\")\n                .rootUrl(\"http://localhost/base#someFragment\")\n                .redirectUris(\"http://localhost/auth\", \"http://localhost/auth#fragment\", \"http://localhost/auth*\", \"/relative\")\n                .build();\n\n        Response response = realm.clients().create(client);\n        assertUriFragmentError(response);\n    }\n\n    // KEYCLOAK-3421\n    @Test\n    public void updateClientWithFragments() {\n        ClientRepresentation client = ClientBuilder.create()\n                .clientId(\"client-with-fragment\")\n                .redirectUris(\"http://localhost/auth\", \"http://localhost/auth*\")\n                .build();\n        Response response = realm.clients().create(client);\n        String clientUuid = ApiUtil.getCreatedId(response);\n        ClientResource clientResource = realm.clients().get(clientUuid);\n        getCleanup().addClientUuid(clientUuid);\n        response.close();\n\n        client = clientResource.toRepresentation();\n        client.setRootUrl(\"http://localhost/base#someFragment\");\n        List<String> redirectUris = client.getRedirectUris();\n        redirectUris.add(\"http://localhost/auth#fragment\");\n        redirectUris.add(\"/relative\");\n        client.setRedirectUris(redirectUris);\n\n        try {\n            clientResource.update(client);\n            fail(\"Should fail\");\n        }\n        catch (BadRequestException e) {\n            assertUriFragmentError(e.getResponse());\n        }\n    }\n\n    private void assertUriFragmentError(Response response) {\n        assertEquals(response.getStatus(), 400);\n        String error = response.readEntity(OAuth2ErrorRepresentation.class).getError();\n        assertTrue(\"Error response doesn't mention Redirect URIs fragments\", error.contains(\"Redirect URIs must not contain an URI fragment\"));\n        assertTrue(\"Error response doesn't mention Root URL fragments\", error.contains(\"Root URL must not contain an URL fragment\"));\n    }\n\n    @Test\n    public void pushRevocation() {\n        testingClient.testApp().clearAdminActions();\n\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        realm.clients().get(id).pushRevocation();\n\n        PushNotBeforeAction pushNotBefore = testingClient.testApp().getAdminPushNotBefore();\n        assertEquals(client.getNotBefore().intValue(), pushNotBefore.getNotBefore());\n\n        assertAdminEvents.assertEvent(realmId, OperationType.ACTION, AdminEventPaths.clientPushRevocationPath(id), ResourceType.CLIENT);\n    }\n\n    private ClientRepresentation createAppClient() {\n        String redirectUri = oauth.getRedirectUri().replace(\"/master/\", \"/\" + REALM_NAME + \"/\");\n\n        ClientRepresentation client = new ClientRepresentation();\n        client.setClientId(\"test-app\");\n        client.setAdminUrl(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth/realms/master/app/admin\");\n        client.setRedirectUris(Collections.singletonList(redirectUri));\n        client.setSecret(\"secret\");\n        client.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n\n        int notBefore = Time.currentTime() - 60;\n        client.setNotBefore(notBefore);\n\n        Response response = realm.clients().create(client);\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientResourcePath(id), client, ResourceType.CLIENT);\n\n        client.setId(id);\n        return client;\n    }\n\n    @Test\n    public void nodes() {\n        testingClient.testApp().clearAdminActions();\n\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        String myhost = suiteContext.getAuthServerInfo().getContextRoot().getHost();\n        realm.clients().get(id).registerNode(Collections.singletonMap(\"node\", myhost));\n        realm.clients().get(id).registerNode(Collections.singletonMap(\"node\", \"invalid\"));\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientNodePath(id, myhost), ResourceType.CLUSTER_NODE);\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientNodePath(id, \"invalid\"), ResourceType.CLUSTER_NODE);\n\n        GlobalRequestResult result = realm.clients().get(id).testNodesAvailable();\n        assertEquals(1, result.getSuccessRequests().size());\n        assertEquals(1, result.getFailedRequests().size());\n\n        assertAdminEvents.assertEvent(realmId, OperationType.ACTION, AdminEventPaths.clientTestNodesAvailablePath(id), result, ResourceType.CLUSTER_NODE);\n\n        TestAvailabilityAction testAvailable = testingClient.testApp().getTestAvailable();\n        assertEquals(\"test-app\", testAvailable.getResource());\n\n        assertEquals(2, realm.clients().get(id).toRepresentation().getRegisteredNodes().size());\n\n        realm.clients().get(id).unregisterNode(\"invalid\");\n\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientNodePath(id, \"invalid\"), ResourceType.CLUSTER_NODE);\n\n        assertEquals(1, realm.clients().get(id).toRepresentation().getRegisteredNodes().size());\n    }\n\n    @Test\n    public void offlineUserSessions() throws IOException {\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        Response response = realm.users().create(UserBuilder.create().username(\"testuser\").build());\n        String userId = ApiUtil.getCreatedId(response);\n        response.close();\n\n        realm.users().get(userId).resetPassword(CredentialBuilder.create().password(\"password\").build());\n\n        Map<String, Long> offlineSessionCount = realm.clients().get(id).getOfflineSessionCount();\n        assertEquals(new Long(0), offlineSessionCount.get(\"count\"));\n\n        List<UserSessionRepresentation> userSessions = realm.users().get(userId).getOfflineSessions(id);\n        assertEquals(\"There should be no offline sessions\", 0, userSessions.size());\n\n        oauth.realm(REALM_NAME);\n        oauth.redirectUri(client.getRedirectUris().get(0));\n        oauth.scope(OAuth2Constants.OFFLINE_ACCESS);\n        oauth.doLogin(\"testuser\", \"password\");\n        AccessTokenResponse accessTokenResponse = oauth.doAccessTokenRequest(oauth.getCurrentQuery().get(\"code\"), \"secret\");\n        assertEquals(200, accessTokenResponse.getStatusCode());\n\n        offlineSessionCount = realm.clients().get(id).getOfflineSessionCount();\n        assertEquals(new Long(1), offlineSessionCount.get(\"count\"));\n\n        List<UserSessionRepresentation> offlineUserSessions = realm.clients().get(id).getOfflineUserSessions(0, 100);\n        assertEquals(1, offlineUserSessions.size());\n        assertEquals(\"testuser\", offlineUserSessions.get(0).getUsername());\n\n        userSessions = realm.users().get(userId).getOfflineSessions(id);\n        assertEquals(\"There should be one offline session\", 1, userSessions.size());\n        assertOfflineSession(offlineUserSessions.get(0), userSessions.get(0));\n    }\n\n    private void assertOfflineSession(UserSessionRepresentation expected, UserSessionRepresentation actual) {\n        assertEquals(\"id\", expected.getId(), actual.getId());\n        assertEquals(\"userId\", expected.getUserId(), actual.getUserId());\n        assertEquals(\"userName\", expected.getUsername(), actual.getUsername());\n        assertEquals(\"clients\", expected.getClients(), actual.getClients());\n    }\n\n    @Test\n    public void scopes() {\n        Response response = realm.clients().create(ClientBuilder.create().clientId(\"client\").fullScopeEnabled(false).build());\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n\n        assertAdminEvents.poll();\n\n        RoleMappingResource scopesResource = realm.clients().get(id).getScopeMappings();\n\n        RoleRepresentation roleRep1 = RoleBuilder.create().name(\"role1\").build();\n        RoleRepresentation roleRep2 = RoleBuilder.create().name(\"role2\").build();\n        realm.roles().create(roleRep1);\n        realm.roles().create(roleRep2);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourcePath(\"role1\"), roleRep1, ResourceType.REALM_ROLE);\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourcePath(\"role2\"), roleRep2, ResourceType.REALM_ROLE);\n\n        roleRep1 = realm.roles().get(\"role1\").toRepresentation();\n        roleRep2 = realm.roles().get(\"role2\").toRepresentation();\n\n        realm.roles().get(\"role1\").addComposites(Collections.singletonList(roleRep2));\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourceCompositesPath(\"role1\"), Collections.singletonList(roleRep2), ResourceType.REALM_ROLE);\n\n        String accountMgmtId = realm.clients().findByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID).get(0).getId();\n        RoleRepresentation viewAccountRoleRep = realm.clients().get(accountMgmtId).roles().get(AccountRoles.VIEW_PROFILE).toRepresentation();\n\n        scopesResource.realmLevel().add(Collections.singletonList(roleRep1));\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientScopeMappingsRealmLevelPath(id), Collections.singletonList(roleRep1), ResourceType.REALM_SCOPE_MAPPING);\n\n        scopesResource.clientLevel(accountMgmtId).add(Collections.singletonList(viewAccountRoleRep));\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientScopeMappingsClientLevelPath(id, accountMgmtId), Collections.singletonList(viewAccountRoleRep), ResourceType.CLIENT_SCOPE_MAPPING);\n\n        Assert.assertNames(scopesResource.realmLevel().listAll(), \"role1\");\n        Assert.assertNames(scopesResource.realmLevel().listEffective(), \"role1\", \"role2\");\n        Assert.assertNames(scopesResource.realmLevel().listAvailable(), \"offline_access\", Constants.AUTHZ_UMA_AUTHORIZATION);\n\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAll(), AccountRoles.VIEW_PROFILE);\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listEffective(), AccountRoles.VIEW_PROFILE);\n\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAvailable(), AccountRoles.MANAGE_ACCOUNT, AccountRoles.MANAGE_ACCOUNT_LINKS);\n\n        Assert.assertNames(scopesResource.getAll().getRealmMappings(), \"role1\");\n        Assert.assertNames(scopesResource.getAll().getClientMappings().get(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID).getMappings(), AccountRoles.VIEW_PROFILE);\n\n        scopesResource.realmLevel().remove(Collections.singletonList(roleRep1));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientScopeMappingsRealmLevelPath(id), Collections.singletonList(roleRep1), ResourceType.REALM_SCOPE_MAPPING);\n\n        scopesResource.clientLevel(accountMgmtId).remove(Collections.singletonList(viewAccountRoleRep));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientScopeMappingsClientLevelPath(id, accountMgmtId), Collections.singletonList(viewAccountRoleRep), ResourceType.CLIENT_SCOPE_MAPPING);\n\n        Assert.assertNames(scopesResource.realmLevel().listAll());\n        Assert.assertNames(scopesResource.realmLevel().listEffective());\n        Assert.assertNames(scopesResource.realmLevel().listAvailable(), \"offline_access\", Constants.AUTHZ_UMA_AUTHORIZATION, \"role1\", \"role2\");\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAll());\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAvailable(), AccountRoles.VIEW_PROFILE, AccountRoles.MANAGE_ACCOUNT, AccountRoles.MANAGE_ACCOUNT_LINKS);\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listEffective());\n    }\n\n    public void protocolMappersTest(String clientDbId, ProtocolMappersResource mappersResource) {\n        // assert default mappers found\n        List<ProtocolMapperRepresentation> protocolMappers = mappersResource.getMappers();\n\n        String emailMapperId = null;\n        String usernameMapperId = null;\n        String fooMapperId = null;\n        for (ProtocolMapperRepresentation mapper : protocolMappers) {\n            if (mapper.getName().equals(OIDCLoginProtocolFactory.EMAIL)) {\n                emailMapperId = mapper.getId();\n            } else if (mapper.getName().equals(OIDCLoginProtocolFactory.USERNAME)) {\n                usernameMapperId = mapper.getId();\n            } else if (mapper.getName().equals(\"foo\")) {\n                fooMapperId = mapper.getId();\n            }\n        }\n\n        // Builtin mappers are not here\n        assertNull(emailMapperId);\n        assertNull(usernameMapperId);\n\n        assertNull(fooMapperId);\n\n        // Create foo mapper\n        ProtocolMapperRepresentation fooMapper = new ProtocolMapperRepresentation();\n        fooMapper.setName(\"foo\");\n        fooMapper.setProtocol(\"openid-connect\");\n        fooMapper.setProtocolMapper(\"oidc-hardcoded-claim-mapper\");\n        Response response = mappersResource.createMapper(fooMapper);\n        String location = response.getLocation().toString();\n        fooMapperId = location.substring(location.lastIndexOf(\"/\") + 1);\n        response.close();\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), fooMapper, ResourceType.PROTOCOL_MAPPER);\n\n        fooMapper = mappersResource.getMapperById(fooMapperId);\n        assertEquals(fooMapper.getName(), \"foo\");\n\n        // Update foo mapper\n        mappersResource.update(fooMapperId, fooMapper);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), fooMapper, ResourceType.PROTOCOL_MAPPER);\n\n        fooMapper = mappersResource.getMapperById(fooMapperId);\n\n        // Remove foo mapper\n        mappersResource.delete(fooMapperId);\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), ResourceType.PROTOCOL_MAPPER);\n        try {\n            mappersResource.getMapperById(fooMapperId);\n            fail(\"Not expected to find deleted mapper\");\n        } catch (NotFoundException nfe) {\n        }\n    }\n\n    public static void assertClient(ClientRepresentation client, ClientRepresentation storedClient) {\n        if (client.getClientId() != null) Assert.assertEquals(client.getClientId(), storedClient.getClientId());\n        if (client.getName() != null) Assert.assertEquals(client.getName(), storedClient.getName());\n        if (client.isEnabled() != null) Assert.assertEquals(client.isEnabled(), storedClient.isEnabled());\n        if (client.isBearerOnly() != null) Assert.assertEquals(client.isBearerOnly(), storedClient.isBearerOnly());\n        if (client.isPublicClient() != null) Assert.assertEquals(client.isPublicClient(), storedClient.isPublicClient());\n        if (client.isFullScopeAllowed() != null) Assert.assertEquals(client.isFullScopeAllowed(), storedClient.isFullScopeAllowed());\n        if (client.getRootUrl() != null) Assert.assertEquals(client.getRootUrl(), storedClient.getRootUrl());\n        if (client.getAdminUrl() != null) Assert.assertEquals(client.getAdminUrl(), storedClient.getAdminUrl());\n        if (client.getBaseUrl() != null) Assert.assertEquals(client.getBaseUrl(), storedClient.getBaseUrl());\n        if (client.isSurrogateAuthRequired() != null) Assert.assertEquals(client.isSurrogateAuthRequired(), storedClient.isSurrogateAuthRequired());\n        if (client.getClientAuthenticatorType() != null) Assert.assertEquals(client.getClientAuthenticatorType(), storedClient.getClientAuthenticatorType());\n\n        if (client.getNotBefore() != null) {\n            Assert.assertEquals(client.getNotBefore(), storedClient.getNotBefore());\n        }\n        if (client.getDefaultRoles() != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getDefaultRoles()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getDefaultRoles()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n\n        List<String> redirectUris = client.getRedirectUris();\n        if (redirectUris != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getRedirectUris()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getRedirectUris()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n\n        List<String> webOrigins = client.getWebOrigins();\n        if (webOrigins != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getWebOrigins()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getWebOrigins()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n    }\n\n}\n"], "fixing_code": ["{\n    \"realm\": \"demo\",\n    \"enabled\": true,\n    \"accessTokenLifespan\": 60,\n    \"accessCodeLifespan\": 60,\n    \"accessCodeLifespanUserAction\": 300,\n    \"ssoSessionIdleTimeout\": 600,\n    \"ssoSessionMaxLifespan\": 36000,\n    \"sslRequired\": \"external\",\n    \"registrationAllowed\": false,\n    \"privateKey\": \"MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y=\",\n    \"publicKey\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n    \"requiredCredentials\": [ \"password\" ],\n    \"users\" : [\n        {\n            \"username\" : \"bburke@redhat.com\",\n            \"enabled\": true,\n            \"email\" : \"bburke@redhat.com\",\n            \"firstName\": \"Bill\",\n            \"lastName\": \"Burke\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\", \"offline_access\"  ],\n            \"clientRoles\": {\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"stian\",\n            \"enabled\": true,\n            \"email\" : \"stian@redhat.com\",\n            \"firstName\": \"Stian\",\n            \"lastName\": \"Thorgersen\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\", \"offline_access\"  ],\n            \"clientRoles\": {\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"mposolda@redhat.com\",\n            \"enabled\": true,\n            \"email\" : \"mposolda@redhat.com\",\n            \"firstName\": \"Marek\",\n            \"lastName\": \"Posolda\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\", \"offline_access\" ],\n            \"clientRoles\": {\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"admin\",\n            \"enabled\": true,\n            \"email\" : \"admin@admin.com\",\n            \"firstName\": \"Admin\",\n            \"lastName\": \"Burke\",\n            \"credentials\" : [\n                { \"type\" : \"password\",\n                    \"value\" : \"password\" }\n            ],\n            \"realmRoles\": [ \"user\",\"admin\" ],\n            \"clientRoles\": {\n                \"realm-management\": [ \"realm-admin\" ],\n                \"account\": [ \"manage-account\" ]\n            }\n        },\n        {\n            \"username\" : \"service-account-product-sa-client\",\n            \"enabled\": true,\n            \"serviceAccountClientId\": \"product-sa-client\",\n            \"realmRoles\": [ \"user\" ]\n        }\n    ],\n    \"roles\" : {\n        \"realm\" : [\n            {\n                \"name\": \"user\",\n                \"description\": \"User privileges\"\n            },\n            {\n                \"name\": \"admin\",\n                \"description\": \"Administrator privileges\"\n            }\n        ]\n    },\n    \"scopeMappings\": [\n        {\n            \"client\": \"third-party\",\n            \"roles\": [\"user\"]\n        },\n        {\n            \"client\": \"offline-access-portal\",\n            \"roles\": [\"user\", \"offline_access\"]\n        }\n    ],\n    \"clients\": [\n        {\n            \"clientId\": \"customer-portal\",\n            \"enabled\": true,\n            \"adminUrl\": \"/customer-portal\",\n            \"baseUrl\": \"/customer-portal\",\n            \"redirectUris\": [\n                \"/customer-portal/*\"\n            ],\n            \"secret\": \"password\"\n        },\n        {\n            \"clientId\": \"customer-portal-filter\",\n            \"enabled\": true,\n            \"adminUrl\": \"/customer-portal-filter/keycloak\",\n            \"baseUrl\": \"/customer-portal-filter\",\n            \"redirectUris\": [\n                \"/customer-portal-filter/*\"\n            ],\n            \"secret\": \"password\"\n        },\n        {\n            \"clientId\": \"customer-portal-js\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"baseUrl\": \"/customer-portal-js\",\n            \"redirectUris\": [\n                \"/customer-portal-js/*\"\n            ]\n        },\n        {\n            \"clientId\": \"angular-product\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"baseUrl\": \"/angular-product/index.html\",\n            \"redirectUris\": [\n                \"/angular-product/*\"\n            ]\n        },\n\t\t{\n            \"clientId\": \"angular2-product\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"baseUrl\": \"/angular2-product/index.html\",\n            \"redirectUris\": [\n                \"/angular2-product/*\"\n            ]\n        },\n        {\n            \"clientId\": \"customer-portal-cli\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"redirectUris\": [\n                \"urn:ietf:wg:oauth:2.0:oob\",\n                \"http://localhost\"\n            ]\n        },\n        {\n            \"clientId\": \"product-portal\",\n            \"enabled\": true,\n            \"adminUrl\": \"/product-portal\",\n            \"baseUrl\": \"/product-portal\",\n            \"redirectUris\": [\n                \"/product-portal/*\"\n            ],\n            \"clientAuthenticatorType\": \"client-jwt\",\n            \"attributes\": {\n                \"use.jwks.url\": \"true\",\n                \"jwks.url\": \"/product-portal/k_jwks\"\n            }\n        },\n        {\n            \"clientId\": \"database-service\",\n            \"enabled\": true,\n            \"adminUrl\": \"/database\",\n            \"baseUrl\": \"/database\",\n            \"bearerOnly\": true\n        },\n        {\n            \"clientId\": \"third-party\",\n            \"enabled\": true,\n            \"consentRequired\": true,\n            \"redirectUris\": [\n                \"/oauth-client/*\",\n                \"/oauth-client-cdi/*\"\n            ],\n            \"secret\": \"password\"\n        },\n        {\n            \"clientId\": \"admin-client\",\n            \"enabled\": true,\n            \"publicClient\": true,\n            \"standardFlowEnabled\": false,\n            \"directAccessGrantsEnabled\": true\n        },\n        {\n            \"clientId\": \"product-sa-client\",\n            \"enabled\": true,\n            \"secret\": \"password\",\n            \"serviceAccountsEnabled\": true\n        },\n        {\n            \"clientId\": \"offline-access-portal\",\n            \"enabled\": true,\n            \"consentRequired\": true,\n            \"adminUrl\": \"/offline-access-portal\",\n            \"baseUrl\": \"/offline-access-portal\",\n            \"redirectUris\": [\n                \"/offline-access-portal/*\"\n            ],\n            \"secret\": \"password\"\n        }\n    ],\n    \"clientScopeMappings\": {\n        \"realm-management\": [\n            {\n                \"client\": \"admin-client\",\n                \"roles\": [\"realm-admin\"]\n            },\n            {\n                \"client\": \"customer-portal\",\n                \"roles\": [\"realm-admin\"]\n            },\n            {\n                \"client\": \"customer-portal-filter\",\n                \"roles\": [\"realm-admin\"]\n            }\n        ]\n    }\n\n\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.keycloak.services.managers;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonPropertyOrder;\nimport org.jboss.logging.Logger;\nimport org.keycloak.authentication.ClientAuthenticator;\nimport org.keycloak.authentication.ClientAuthenticatorFactory;\nimport org.keycloak.common.constants.ServiceAccountConstants;\nimport org.keycloak.common.util.Time;\nimport org.keycloak.models.ClientModel;\nimport org.keycloak.models.KeycloakSession;\nimport org.keycloak.models.ProtocolMapperModel;\nimport org.keycloak.models.RealmModel;\nimport org.keycloak.models.UserManager;\nimport org.keycloak.models.UserModel;\nimport org.keycloak.models.UserSessionProvider;\nimport org.keycloak.models.session.UserSessionPersisterProvider;\nimport org.keycloak.models.utils.RepresentationToModel;\nimport org.keycloak.protocol.LoginProtocol;\nimport org.keycloak.protocol.LoginProtocolFactory;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocol;\nimport org.keycloak.protocol.oidc.mappers.UserSessionNoteMapper;\nimport org.keycloak.representations.adapters.config.BaseRealmConfig;\nimport org.keycloak.representations.adapters.config.PolicyEnforcerConfig;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.sessions.AuthenticationSessionProvider;\n\nimport java.net.URI;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n * @version $Revision: 1 $\n */\npublic class ClientManager {\n    private static final Logger logger = Logger.getLogger(ClientManager.class);\n\n    protected RealmManager realmManager;\n\n    public ClientManager(RealmManager realmManager) {\n        this.realmManager = realmManager;\n    }\n\n    public ClientManager() {\n    }\n\n    /**\n     * Should not be called from an import.  This really expects that the client is created from the admin console.\n     *\n     * @param session\n     * @param realm\n     * @param rep\n     * @param addDefaultRoles\n     * @return\n     */\n    public static ClientModel createClient(KeycloakSession session, RealmModel realm, ClientRepresentation rep, boolean addDefaultRoles) {\n        ClientModel client = RepresentationToModel.createClient(session, realm, rep, addDefaultRoles);\n\n        if (rep.getProtocol() != null) {\n            LoginProtocolFactory providerFactory = (LoginProtocolFactory) session.getKeycloakSessionFactory().getProviderFactory(LoginProtocol.class, rep.getProtocol());\n            providerFactory.setupClientDefaults(rep, client);\n        }\n\n\n        // remove default mappers if there is a template\n        if (rep.getProtocolMappers() == null && rep.getClientTemplate() != null) {\n            Set<ProtocolMapperModel> mappers = client.getProtocolMappers();\n            for (ProtocolMapperModel mapper : mappers) client.removeProtocolMapper(mapper);\n        }\n        return client;\n\n    }\n\n\n    public boolean removeClient(RealmModel realm, ClientModel client) {\n        if (realm.removeClient(client.getId())) {\n            UserSessionProvider sessions = realmManager.getSession().sessions();\n            if (sessions != null) {\n                sessions.onClientRemoved(realm, client);\n            }\n\n            UserSessionPersisterProvider sessionsPersister = realmManager.getSession().getProvider(UserSessionPersisterProvider.class);\n            if (sessionsPersister != null) {\n                sessionsPersister.onClientRemoved(realm, client);\n            }\n\n            AuthenticationSessionProvider authSessions = realmManager.getSession().authenticationSessions();\n            if (authSessions != null) {\n                authSessions.onClientRemoved(realm, client);\n            }\n\n            UserModel serviceAccountUser = realmManager.getSession().users().getServiceAccount(client);\n            if (serviceAccountUser != null) {\n                new UserManager(realmManager.getSession()).removeUser(realm, serviceAccountUser);\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public Set<String> validateRegisteredNodes(ClientModel client) {\n        Map<String, Integer> registeredNodes = client.getRegisteredNodes();\n        if (registeredNodes == null || registeredNodes.isEmpty()) {\n            return Collections.emptySet();\n        }\n\n        int currentTime = Time.currentTime();\n\n        Set<String> validatedNodes = new TreeSet<String>();\n        if (client.getNodeReRegistrationTimeout() > 0) {\n            List<String> toRemove = new LinkedList<String>();\n            for (Map.Entry<String, Integer> entry : registeredNodes.entrySet()) {\n                Integer lastReRegistration = entry.getValue();\n                if (lastReRegistration + client.getNodeReRegistrationTimeout() < currentTime) {\n                    toRemove.add(entry.getKey());\n                } else {\n                    validatedNodes.add(entry.getKey());\n                }\n            }\n\n            // Remove time-outed nodes\n            for (String node : toRemove) {\n                client.unregisterNode(node);\n            }\n        } else {\n            // Periodic node reRegistration is disabled, so allow all nodes\n            validatedNodes.addAll(registeredNodes.keySet());\n        }\n\n        return validatedNodes;\n    }\n\n    public void enableServiceAccount(ClientModel client) {\n        client.setServiceAccountsEnabled(true);\n\n        // Add dedicated user for this service account\n        if (realmManager.getSession().users().getServiceAccount(client) == null) {\n            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + client.getClientId();\n            logger.debugf(\"Creating service account user '%s'\", username);\n\n            // Don't use federation for service account user\n            UserModel user = realmManager.getSession().userLocalStorage().addUser(client.getRealm(), username);\n            user.setEnabled(true);\n            user.setServiceAccountClientLink(client.getId());\n        }\n\n        // Add protocol mappers to retrieve clientId in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ID_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ID,\n                    ServiceAccountConstants.CLIENT_ID, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        // Add protocol mappers to retrieve hostname and IP address of client in access token\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_HOST_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_HOST,\n                    ServiceAccountConstants.CLIENT_HOST, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n\n        if (client.getProtocolMapperByName(OIDCLoginProtocol.LOGIN_PROTOCOL, ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER) == null) {\n            logger.debugf(\"Creating service account protocol mapper '%s' for client '%s'\", ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER, client.getClientId());\n            ProtocolMapperModel protocolMapper = UserSessionNoteMapper.createClaimMapper(ServiceAccountConstants.CLIENT_ADDRESS_PROTOCOL_MAPPER,\n                    ServiceAccountConstants.CLIENT_ADDRESS,\n                    ServiceAccountConstants.CLIENT_ADDRESS, \"String\",\n                    true, true);\n            client.addProtocolMapper(protocolMapper);\n        }\n    }\n\n    public void clientIdChanged(ClientModel client, String newClientId) {\n        logger.debugf(\"Updating clientId from '%s' to '%s'\", client.getClientId(), newClientId);\n\n        UserModel serviceAccountUser = realmManager.getSession().users().getServiceAccount(client);\n        if (serviceAccountUser != null) {\n            String username = ServiceAccountConstants.SERVICE_ACCOUNT_USER_PREFIX + newClientId;\n            serviceAccountUser.setUsername(username);\n        }\n    }\n\n    @JsonPropertyOrder({\"realm\", \"realm-public-key\", \"bearer-only\", \"auth-server-url\", \"ssl-required\",\n            \"resource\", \"public-client\", \"verify-token-audience\", \"credentials\",\n            \"use-resource-role-mappings\"})\n    public static class InstallationAdapterConfig extends BaseRealmConfig {\n        @JsonProperty(\"resource\")\n        protected String resource;\n        @JsonProperty(\"use-resource-role-mappings\")\n        protected Boolean useResourceRoleMappings;\n        @JsonProperty(\"bearer-only\")\n        protected Boolean bearerOnly;\n        @JsonProperty(\"public-client\")\n        protected Boolean publicClient;\n        @JsonProperty(\"credentials\")\n        protected Map<String, Object> credentials;\n        @JsonProperty(\"verify-token-audience\")\n        protected Boolean verifyTokenAudience;\n        @JsonProperty(\"policy-enforcer\")\n        protected PolicyEnforcerConfig enforcerConfig;\n\n        public Boolean isUseResourceRoleMappings() {\n            return useResourceRoleMappings;\n        }\n\n        public void setUseResourceRoleMappings(Boolean useResourceRoleMappings) {\n            this.useResourceRoleMappings = useResourceRoleMappings;\n        }\n\n        public String getResource() {\n            return resource;\n        }\n\n        public void setResource(String resource) {\n            this.resource = resource;\n        }\n\n        public Map<String, Object> getCredentials() {\n            return credentials;\n        }\n\n        public void setCredentials(Map<String, Object> credentials) {\n            this.credentials = credentials;\n        }\n\n        public Boolean getVerifyTokenAudience() {\n            return verifyTokenAudience;\n        }\n\n        public void setVerifyTokenAudience(Boolean verifyTokenAudience) {\n            this.verifyTokenAudience = verifyTokenAudience;\n        }\n\n        public Boolean getPublicClient() {\n            return publicClient;\n        }\n\n        public void setPublicClient(Boolean publicClient) {\n            this.publicClient = publicClient;\n        }\n\n        public Boolean getBearerOnly() {\n            return bearerOnly;\n        }\n\n        public void setBearerOnly(Boolean bearerOnly) {\n            this.bearerOnly = bearerOnly;\n        }\n\n        public PolicyEnforcerConfig getEnforcerConfig() {\n            return this.enforcerConfig;\n        }\n\n        public void setEnforcerConfig(PolicyEnforcerConfig enforcerConfig) {\n            this.enforcerConfig = enforcerConfig;\n        }\n    }\n\n\n    public InstallationAdapterConfig toInstallationRepresentation(RealmModel realmModel, ClientModel clientModel, URI baseUri) {\n        InstallationAdapterConfig rep = new InstallationAdapterConfig();\n        rep.setAuthServerUrl(baseUri.toString());\n        rep.setRealm(realmModel.getName());\n        rep.setSslRequired(realmModel.getSslRequired().name().toLowerCase());\n\n        if (clientModel.isPublicClient() && !clientModel.isBearerOnly()) rep.setPublicClient(true);\n        if (clientModel.isBearerOnly()) rep.setBearerOnly(true);\n        if (clientModel.getRoles().size() > 0) rep.setUseResourceRoleMappings(true);\n\n        rep.setResource(clientModel.getClientId());\n\n        if (showClientCredentialsAdapterConfig(clientModel)) {\n            Map<String, Object> adapterConfig = getClientCredentialsAdapterConfig(clientModel);\n            rep.setCredentials(adapterConfig);\n        }\n\n        return rep;\n    }\n\n    public String toJBossSubsystemConfig(RealmModel realmModel, ClientModel clientModel, URI baseUri) {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"<secure-deployment name=\\\"WAR MODULE NAME.war\\\">\\n\");\n        buffer.append(\"    <realm>\").append(realmModel.getName()).append(\"</realm>\\n\");\n        buffer.append(\"    <auth-server-url>\").append(baseUri.toString()).append(\"</auth-server-url>\\n\");\n        if (clientModel.isBearerOnly()){\n            buffer.append(\"    <bearer-only>true</bearer-only>\\n\");\n\n        } else if (clientModel.isPublicClient()) {\n            buffer.append(\"    <public-client>true</public-client>\\n\");\n        }\n        buffer.append(\"    <ssl-required>\").append(realmModel.getSslRequired().name()).append(\"</ssl-required>\\n\");\n        buffer.append(\"    <resource>\").append(clientModel.getClientId()).append(\"</resource>\\n\");\n        String cred = clientModel.getSecret();\n        if (showClientCredentialsAdapterConfig(clientModel)) {\n            Map<String, Object> adapterConfig = getClientCredentialsAdapterConfig(clientModel);\n            for (Map.Entry<String, Object> entry : adapterConfig.entrySet()) {\n                buffer.append(\"    <credential name=\\\"\" + entry.getKey() + \"\\\">\");\n\n                Object value = entry.getValue();\n                if (value instanceof Map) {\n                    buffer.append(\"\\n\");\n                    Map<String, Object> asMap = (Map<String, Object>) value;\n                    for (Map.Entry<String, Object> credEntry : asMap.entrySet()) {\n                        buffer.append(\"        <\" + credEntry.getKey() + \">\" + credEntry.getValue().toString() + \"</\" + credEntry.getKey() + \">\\n\");\n                    }\n                    buffer.append(\"    </credential>\\n\");\n                } else {\n                    buffer.append(value.toString()).append(\"</credential>\\n\");\n                }\n            }\n        }\n        if (clientModel.getRoles().size() > 0) {\n            buffer.append(\"    <use-resource-role-mappings>true</use-resource-role-mappings>\\n\");\n        }\n        buffer.append(\"</secure-deployment>\\n\");\n        return buffer.toString();\n    }\n\n    private boolean showClientCredentialsAdapterConfig(ClientModel client) {\n        if (client.isPublicClient()) {\n            return false;\n        }\n\n        if (client.isBearerOnly() && client.getNodeReRegistrationTimeout() <= 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private Map<String, Object> getClientCredentialsAdapterConfig(ClientModel client) {\n        String clientAuthenticator = client.getClientAuthenticatorType();\n        ClientAuthenticatorFactory authenticator = (ClientAuthenticatorFactory) realmManager.getSession().getKeycloakSessionFactory().getProviderFactory(ClientAuthenticator.class, clientAuthenticator);\n        return authenticator.getAdapterConfiguration(client);\n    }\n\n}\n", "{\n  \"realm\": \"photoz\",\n  \"enabled\": true,\n  \"userManagedAccessAllowed\": true,\n  \"sslRequired\": \"external\",\n  \"privateKey\": \"MIICXAIBAAKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQABAoGAfmO8gVhyBxdqlxmIuglbz8bcjQbhXJLR2EoS8ngTXmN1bo2L90M0mUKSdc7qF10LgETBzqL8jYlQIbt+e6TH8fcEpKCjUlyq0Mf/vVbfZSNaVycY13nTzo27iPyWQHK5NLuJzn1xvxxrUeXI6A2WFpGEBLbHjwpx5WQG9A+2scECQQDvdn9NE75HPTVPxBqsEd2z10TKkl9CZxu10Qby3iQQmWLEJ9LNmy3acvKrE3gMiYNWb6xHPKiIqOR1as7L24aTAkEAtyvQOlCvr5kAjVqrEKXalj0Tzewjweuxc0pskvArTI2Oo070h65GpoIKLc9jf+UA69cRtquwP93aZKtW06U8dQJAF2Y44ks/mK5+eyDqik3koCI08qaC8HYq2wVl7G2QkJ6sbAaILtcvD92ToOvyGyeE0flvmDZxMYlvaZnaQ0lcSQJBAKZU6umJi3/xeEbkJqMfeLclD27XGEFoPeNrmdx0q10Azp4NfJAY+Z8KRyQCR2BEG+oNitBOZ+YXF9KCpH3cdmECQHEigJhYg+ykOvr1aiZUMFT72HU0jnmQe2FVekuG+LJUt2Tm7GtMjTFoGpf0JwrVuZN39fOYAlo+nTixgeW7X8Y=\",\n  \"publicKey\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n  \"accessTokenLifespan\": 100000,\n  \"requiredCredentials\": [\n    \"password\"\n  ],\n  \"users\": [\n    {\n      \"username\": \"alice\",\n      \"enabled\": true,\n      \"email\": \"alice@keycloak.org\",\n      \"firstName\": \"Alice\",\n      \"lastName\": \"In Chains\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"alice\"\n        }\n      ],\n      \"realmRoles\": [\n        \"user\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"jdoe\",\n      \"enabled\": true,\n      \"email\": \"jdoe@keycloak.org\",\n      \"firstName\": \"John\",\n      \"lastName\": \"Doe\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"jdoe\"\n        }\n      ],\n      \"realmRoles\": [\n        \"user\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"pedroigor\",\n      \"enabled\": true,\n      \"email\": \"pedroigor@keycloak.org\",\n      \"firstName\": \"Pedro Igor\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"pedroigor\"\n        }\n      ],\n      \"realmRoles\": [\n        \"user\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"admin\",\n      \"enabled\": true,\n      \"email\": \"admin@admin.com\",\n      \"firstName\": \"Admin\",\n      \"lastName\": \"Istrator\",\n      \"credentials\": [\n        {\n          \"type\": \"password\",\n          \"value\": \"admin\"\n        }\n      ],\n      \"realmRoles\": [\n        \"admin\", \"uma_authorization\"\n      ],\n      \"clientRoles\": {\n        \"realm-management\": [\n          \"realm-admin\"\n        ],\n        \"photoz-restful-api\": [\n          \"manage-albums\"\n        ],\n        \"account\": [\n          \"manage-account\"\n        ]\n      }\n    },\n    {\n      \"username\": \"service-account-photoz-restful-api\",\n      \"enabled\": true,\n      \"serviceAccountClientId\": \"photoz-restful-api\",\n      \"clientRoles\": {\n        \"photoz-restful-api\" : [\"uma_protection\"]\n      }\n    }\n  ],\n  \"roles\": {\n    \"realm\": [\n      {\n        \"name\": \"user\",\n        \"description\": \"User privileges\"\n      },\n      {\n        \"name\": \"admin\",\n        \"description\": \"Administrator privileges\"\n      }\n    ]\n  },\n  \"clients\": [\n    {\n      \"clientId\": \"photoz-html5-client\",\n      \"enabled\": true,\n      \"adminUrl\": \"/photoz-html5-client\",\n      \"baseUrl\": \"/photoz-html5-client\",\n      \"publicClient\": true,\n      \"consentRequired\" : true,\n      \"fullScopeAllowed\" : true,\n      \"redirectUris\": [\n        \"*\"\n      ],\n      \"webOrigins\": [\"*\"]\n    },\n    {\n      \"clientId\": \"photoz-restful-api\",\n      \"enabled\": true,\n      \"baseUrl\": \"/photoz-restful-api\",\n      \"authorizationServicesEnabled\" : true,\n      \"redirectUris\": [\n        \"*\"\n      ],\n      \"webOrigins\" : [\"*\"],\n      \"clientAuthenticatorType\": \"client-jwt\",\n      \"attributes\" : {\n        \"jwt.credential.certificate\" : \"MIICqTCCAZECBgFT0Ngs/DANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1zZWN1cmUtcG9ydGFsMB4XDTE2MDQwMTA4MDA0MVoXDTI2MDQwMTA4MDIyMVowGDEWMBQGA1UEAwwNc2VjdXJlLXBvcnRhbDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJa4GixpmzP511AmI0eLPLORyJwXS8908MUvdG3hmh8jMOIhe28XjIFeZSY09vFxh22F2SUMjxU/B2Hw4PDJUkebuNR7rXhOIYCJAo6eEZzjSBY/wngFtfm74zJ/eLCobBtDvIld7jobdHTfE1Oz9+GzvtG0k7cm7ubrLT0J4I1UsFZj3b//3wa+O0vNaTwHC1Jz/m59VbtXqyO4xEzIdl416cnGCmEmk5qd5h1de2UoLi/CTad8HftIJhzN1qhlySzW/9Ha70aYlDH2hiibDsXDTrNaMdaaLik7I8Rv/nIbggysG863PKZo8wknDe62QctH5VYSSktiy4gjSJkGh7ECAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAZnnx+AHQ8txugGcFK8gWjildDgk+v31fBHBDvmLQaSzsUaIOJaK4wnlwUI+VfR46HmBXhjlDCobFLUptd+kz0G7xapcIn3b5jLrySUUD7L+LAp1vNOQU4mKhTGS3IEvNB73D3GH9rQ+M3KEcoN3f99fNKqKsUdxbmZqGf4VOQ57PUfLBw4PJJGlROPosBc7ivPRyeYnKekhoCTynq30BAD1FA1BA8ppcY4ZVGADPTAgMJxpglpFY9LiqCwdLAGW1ttnsyIJ7DpT+kybhhk7c+MU7gyQdv8xPnMR0bSCB9hndowgBn5oZ393aMscwMNCzwJ0aWBs1sUyn3X0RIsu9Jg==\"\n      }\n    }\n  ]\n}\n", "/*\n * Copyright 2016 Red Hat, Inc. and/or its affiliates\n * and other contributors as indicated by the @author tags.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.keycloak.testsuite.admin;\n\nimport org.junit.Test;\nimport org.keycloak.OAuth2Constants;\nimport org.keycloak.admin.client.resource.ClientResource;\nimport org.keycloak.admin.client.resource.ProtocolMappersResource;\nimport org.keycloak.admin.client.resource.RoleMappingResource;\nimport org.keycloak.common.util.Time;\nimport org.keycloak.events.admin.OperationType;\nimport org.keycloak.events.admin.ResourceType;\nimport org.keycloak.models.AccountRoles;\nimport org.keycloak.models.Constants;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocol;\nimport org.keycloak.protocol.oidc.OIDCLoginProtocolFactory;\nimport org.keycloak.representations.adapters.action.GlobalRequestResult;\nimport org.keycloak.representations.adapters.action.PushNotBeforeAction;\nimport org.keycloak.representations.adapters.action.TestAvailabilityAction;\nimport org.keycloak.representations.idm.ClientRepresentation;\nimport org.keycloak.representations.idm.OAuth2ErrorRepresentation;\nimport org.keycloak.representations.idm.ProtocolMapperRepresentation;\nimport org.keycloak.representations.idm.RoleRepresentation;\nimport org.keycloak.representations.idm.UserRepresentation;\nimport org.keycloak.representations.idm.UserSessionRepresentation;\nimport org.keycloak.testsuite.Assert;\nimport org.keycloak.testsuite.util.AdminEventPaths;\nimport org.keycloak.testsuite.util.ClientBuilder;\nimport org.keycloak.testsuite.util.CredentialBuilder;\nimport org.keycloak.testsuite.util.OAuthClient;\nimport org.keycloak.testsuite.util.OAuthClient.AccessTokenResponse;\nimport org.keycloak.testsuite.util.RoleBuilder;\nimport org.keycloak.testsuite.util.UserBuilder;\n\nimport javax.ws.rs.BadRequestException;\nimport javax.ws.rs.NotFoundException;\nimport javax.ws.rs.core.Response;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.junit.Assert.*;\n\n/**\n * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n */\npublic class ClientTest extends AbstractAdminTest {\n\n    @Test\n    public void getClients() {\n        Assert.assertNames(realm.clients().findAll(), \"account\", \"realm-management\", \"security-admin-console\", \"broker\", Constants.ADMIN_CLI_CLIENT_ID);\n    }\n\n    private ClientRepresentation createClient() {\n        ClientRepresentation rep = new ClientRepresentation();\n        rep.setClientId(\"my-app\");\n        rep.setDescription(\"my-app description\");\n        rep.setEnabled(true);\n        Response response = realm.clients().create(rep);\n        response.close();\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        ClientRepresentation found = ApiUtil.findClientResourceByClientId(realm, \"my-app\").toRepresentation();\n\n        assertEquals(\"my-app\", found.getClientId());\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientResourcePath(id), rep, ResourceType.CLIENT);\n\n        rep.setId(id);\n\n        return rep;\n    }\n\n    @Test\n    public void createClientVerify() {\n        String id = createClient().getId();\n\n        assertNotNull(realm.clients().get(id));\n        Assert.assertNames(realm.clients().findAll(), \"account\", \"realm-management\", \"security-admin-console\", \"broker\", \"my-app\", Constants.ADMIN_CLI_CLIENT_ID);\n    }\n\n    @Test\n    public void removeClient() {\n        String id = createClient().getId();\n\n        assertNotNull(ApiUtil.findClientByClientId(realm, \"my-app\"));\n        realm.clients().get(id).remove();\n        assertNull(ApiUtil.findClientResourceByClientId(realm, \"my-app\"));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientResourcePath(id), ResourceType.CLIENT);\n    }\n\n    @Test\n    public void getClientRepresentation() {\n        String id = createClient().getId();\n\n        ClientRepresentation rep = realm.clients().get(id).toRepresentation();\n        assertEquals(id, rep.getId());\n        assertEquals(\"my-app\", rep.getClientId());\n        assertTrue(rep.isEnabled());\n    }\n\n    /**\n     * See <a href=\"https://issues.jboss.org/browse/KEYCLOAK-1918\">KEYCLOAK-1918</a>\n     */\n    @Test\n    public void getClientDescription() {\n        String id = createClient().getId();\n\n        ClientRepresentation rep = realm.clients().get(id).toRepresentation();\n        assertEquals(id, rep.getId());\n        assertEquals(\"my-app description\", rep.getDescription());\n    }\n\n    @Test\n    public void getClientSessions() throws Exception {\n        OAuthClient.AccessTokenResponse response = oauth.doGrantAccessTokenRequest(\"password\", \"test-user@localhost\", \"password\");\n        assertEquals(200, response.getStatusCode());\n\n        OAuthClient.AuthorizationEndpointResponse codeResponse = oauth.doLogin(\"test-user@localhost\", \"password\");\n\n        OAuthClient.AccessTokenResponse response2 = oauth.doAccessTokenRequest(codeResponse.getCode(), \"password\");\n        assertEquals(200, response2.getStatusCode());\n\n        ClientResource app = ApiUtil.findClientByClientId(adminClient.realm(\"test\"), \"test-app\");\n\n        assertEquals(2, (long) app.getApplicationSessionCount().get(\"count\"));\n\n        List<UserSessionRepresentation> userSessions = app.getUserSessions(0, 100);\n        assertEquals(2, userSessions.size());\n        assertEquals(1, userSessions.get(0).getClients().size());\n    }\n\n    @Test\n    public void getAllClients() {\n        List<ClientRepresentation> allClients = realm.clients().findAll();\n        assertNotNull(allClients);\n        assertFalse(allClients.isEmpty());\n    }\n\n    @Test\n    public void getClientById() {\n        createClient();\n        ClientRepresentation rep = ApiUtil.findClientResourceByClientId(realm, \"my-app\").toRepresentation();\n        ClientRepresentation gotById = realm.clients().get(rep.getId()).toRepresentation();\n        assertClient(rep, gotById);\n    }\n\n    @Test\n    // KEYCLOAK-1110\n    public void deleteDefaultRole() {\n        ClientRepresentation rep = createClient();\n        String id = rep.getId();\n\n        RoleRepresentation role = new RoleRepresentation(\"test\", \"test\", false);\n        realm.clients().get(id).roles().create(role);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientRoleResourcePath(id, \"test\"), role, ResourceType.CLIENT_ROLE);\n\n        ClientRepresentation foundClientRep = realm.clients().get(id).toRepresentation();\n        foundClientRep.setDefaultRoles(new String[]{\"test\"});\n        realm.clients().get(id).update(foundClientRep);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(id), rep, ResourceType.CLIENT);\n\n        assertArrayEquals(new String[]{\"test\"}, realm.clients().get(id).toRepresentation().getDefaultRoles());\n\n        realm.clients().get(id).roles().deleteRole(\"test\");\n\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientRoleResourcePath(id, \"test\"), ResourceType.CLIENT_ROLE);\n\n        assertNull(realm.clients().get(id).toRepresentation().getDefaultRoles());\n    }\n\n    @Test\n    public void testProtocolMappers() {\n        String clientDbId = createClient().getId();\n        ProtocolMappersResource mappersResource = ApiUtil.findClientByClientId(realm, \"my-app\").getProtocolMappers();\n\n        protocolMappersTest(clientDbId, mappersResource);\n    }\n\n    @Test\n    public void updateClient() {\n        ClientRepresentation client = createClient();\n\n        ClientRepresentation newClient = new ClientRepresentation();\n        newClient.setId(client.getId());\n        newClient.setClientId(client.getClientId());\n        newClient.setBaseUrl(\"http://baseurl\");\n\n        realm.clients().get(client.getId()).update(newClient);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(client.getId()), newClient, ResourceType.CLIENT);\n\n        ClientRepresentation storedClient = realm.clients().get(client.getId()).toRepresentation();\n\n        assertClient(client, storedClient);\n\n        newClient.setSecret(\"new-secret\");\n\n        realm.clients().get(client.getId()).update(newClient);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientResourcePath(client.getId()), newClient, ResourceType.CLIENT);\n\n        storedClient = realm.clients().get(client.getId()).toRepresentation();\n        assertClient(client, storedClient);\n    }\n\n    @Test\n    public void serviceAccount() {\n        Response response = realm.clients().create(ClientBuilder.create().clientId(\"serviceClient\").serviceAccount().build());\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n        UserRepresentation userRep = realm.clients().get(id).getServiceAccountUser();\n        assertEquals(\"service-account-serviceclient\", userRep.getUsername());\n        // KEYCLOAK-11197 service accounts are no longer created with a placeholder e-mail.\n        assertNull(userRep.getEmail());\n    }\n\n    // KEYCLOAK-3421\n    @Test\n    public void createClientWithFragments() {\n        ClientRepresentation client = ClientBuilder.create()\n                .clientId(\"client-with-fragment\")\n                .rootUrl(\"http://localhost/base#someFragment\")\n                .redirectUris(\"http://localhost/auth\", \"http://localhost/auth#fragment\", \"http://localhost/auth*\", \"/relative\")\n                .build();\n\n        Response response = realm.clients().create(client);\n        assertUriFragmentError(response);\n    }\n\n    // KEYCLOAK-3421\n    @Test\n    public void updateClientWithFragments() {\n        ClientRepresentation client = ClientBuilder.create()\n                .clientId(\"client-with-fragment\")\n                .redirectUris(\"http://localhost/auth\", \"http://localhost/auth*\")\n                .build();\n        Response response = realm.clients().create(client);\n        String clientUuid = ApiUtil.getCreatedId(response);\n        ClientResource clientResource = realm.clients().get(clientUuid);\n        getCleanup().addClientUuid(clientUuid);\n        response.close();\n\n        client = clientResource.toRepresentation();\n        client.setRootUrl(\"http://localhost/base#someFragment\");\n        List<String> redirectUris = client.getRedirectUris();\n        redirectUris.add(\"http://localhost/auth#fragment\");\n        redirectUris.add(\"/relative\");\n        client.setRedirectUris(redirectUris);\n\n        try {\n            clientResource.update(client);\n            fail(\"Should fail\");\n        }\n        catch (BadRequestException e) {\n            assertUriFragmentError(e.getResponse());\n        }\n    }\n\n    private void assertUriFragmentError(Response response) {\n        assertEquals(response.getStatus(), 400);\n        String error = response.readEntity(OAuth2ErrorRepresentation.class).getError();\n        assertTrue(\"Error response doesn't mention Redirect URIs fragments\", error.contains(\"Redirect URIs must not contain an URI fragment\"));\n        assertTrue(\"Error response doesn't mention Root URL fragments\", error.contains(\"Root URL must not contain an URL fragment\"));\n    }\n\n    @Test\n    public void pushRevocation() {\n        testingClient.testApp().clearAdminActions();\n\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        realm.clients().get(id).pushRevocation();\n\n        PushNotBeforeAction pushNotBefore = testingClient.testApp().getAdminPushNotBefore();\n        assertEquals(client.getNotBefore().intValue(), pushNotBefore.getNotBefore());\n\n        assertAdminEvents.assertEvent(realmId, OperationType.ACTION, AdminEventPaths.clientPushRevocationPath(id), ResourceType.CLIENT);\n    }\n\n    private ClientRepresentation createAppClient() {\n        String redirectUri = oauth.getRedirectUri().replace(\"/master/\", \"/\" + REALM_NAME + \"/\");\n\n        ClientRepresentation client = new ClientRepresentation();\n        client.setClientId(\"test-app\");\n        client.setAdminUrl(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth/realms/master/app/admin\");\n        client.setRedirectUris(Collections.singletonList(redirectUri));\n        client.setSecret(\"secret\");\n        client.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n\n        int notBefore = Time.currentTime() - 60;\n        client.setNotBefore(notBefore);\n\n        Response response = realm.clients().create(client);\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientResourcePath(id), client, ResourceType.CLIENT);\n\n        client.setId(id);\n        return client;\n    }\n\n    @Test\n    public void nodes() {\n        testingClient.testApp().clearAdminActions();\n\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        String myhost = suiteContext.getAuthServerInfo().getContextRoot().getHost();\n        realm.clients().get(id).registerNode(Collections.singletonMap(\"node\", myhost));\n        realm.clients().get(id).registerNode(Collections.singletonMap(\"node\", \"invalid\"));\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientNodePath(id, myhost), ResourceType.CLUSTER_NODE);\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientNodePath(id, \"invalid\"), ResourceType.CLUSTER_NODE);\n\n        GlobalRequestResult result = realm.clients().get(id).testNodesAvailable();\n        assertEquals(1, result.getSuccessRequests().size());\n        assertEquals(1, result.getFailedRequests().size());\n\n        assertAdminEvents.assertEvent(realmId, OperationType.ACTION, AdminEventPaths.clientTestNodesAvailablePath(id), result, ResourceType.CLUSTER_NODE);\n\n        TestAvailabilityAction testAvailable = testingClient.testApp().getTestAvailable();\n        assertEquals(\"test-app\", testAvailable.getResource());\n\n        assertEquals(2, realm.clients().get(id).toRepresentation().getRegisteredNodes().size());\n\n        realm.clients().get(id).unregisterNode(\"invalid\");\n\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientNodePath(id, \"invalid\"), ResourceType.CLUSTER_NODE);\n\n        assertEquals(1, realm.clients().get(id).toRepresentation().getRegisteredNodes().size());\n    }\n\n    @Test\n    public void offlineUserSessions() throws IOException {\n        ClientRepresentation client = createAppClient();\n        String id = client.getId();\n\n        Response response = realm.users().create(UserBuilder.create().username(\"testuser\").build());\n        String userId = ApiUtil.getCreatedId(response);\n        response.close();\n\n        realm.users().get(userId).resetPassword(CredentialBuilder.create().password(\"password\").build());\n\n        Map<String, Long> offlineSessionCount = realm.clients().get(id).getOfflineSessionCount();\n        assertEquals(new Long(0), offlineSessionCount.get(\"count\"));\n\n        List<UserSessionRepresentation> userSessions = realm.users().get(userId).getOfflineSessions(id);\n        assertEquals(\"There should be no offline sessions\", 0, userSessions.size());\n\n        oauth.realm(REALM_NAME);\n        oauth.redirectUri(client.getRedirectUris().get(0));\n        oauth.scope(OAuth2Constants.OFFLINE_ACCESS);\n        oauth.doLogin(\"testuser\", \"password\");\n        AccessTokenResponse accessTokenResponse = oauth.doAccessTokenRequest(oauth.getCurrentQuery().get(\"code\"), \"secret\");\n        assertEquals(200, accessTokenResponse.getStatusCode());\n\n        offlineSessionCount = realm.clients().get(id).getOfflineSessionCount();\n        assertEquals(new Long(1), offlineSessionCount.get(\"count\"));\n\n        List<UserSessionRepresentation> offlineUserSessions = realm.clients().get(id).getOfflineUserSessions(0, 100);\n        assertEquals(1, offlineUserSessions.size());\n        assertEquals(\"testuser\", offlineUserSessions.get(0).getUsername());\n\n        userSessions = realm.users().get(userId).getOfflineSessions(id);\n        assertEquals(\"There should be one offline session\", 1, userSessions.size());\n        assertOfflineSession(offlineUserSessions.get(0), userSessions.get(0));\n    }\n\n    private void assertOfflineSession(UserSessionRepresentation expected, UserSessionRepresentation actual) {\n        assertEquals(\"id\", expected.getId(), actual.getId());\n        assertEquals(\"userId\", expected.getUserId(), actual.getUserId());\n        assertEquals(\"userName\", expected.getUsername(), actual.getUsername());\n        assertEquals(\"clients\", expected.getClients(), actual.getClients());\n    }\n\n    @Test\n    public void scopes() {\n        Response response = realm.clients().create(ClientBuilder.create().clientId(\"client\").fullScopeEnabled(false).build());\n        String id = ApiUtil.getCreatedId(response);\n        getCleanup().addClientUuid(id);\n        response.close();\n\n        assertAdminEvents.poll();\n\n        RoleMappingResource scopesResource = realm.clients().get(id).getScopeMappings();\n\n        RoleRepresentation roleRep1 = RoleBuilder.create().name(\"role1\").build();\n        RoleRepresentation roleRep2 = RoleBuilder.create().name(\"role2\").build();\n        realm.roles().create(roleRep1);\n        realm.roles().create(roleRep2);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourcePath(\"role1\"), roleRep1, ResourceType.REALM_ROLE);\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourcePath(\"role2\"), roleRep2, ResourceType.REALM_ROLE);\n\n        roleRep1 = realm.roles().get(\"role1\").toRepresentation();\n        roleRep2 = realm.roles().get(\"role2\").toRepresentation();\n\n        realm.roles().get(\"role1\").addComposites(Collections.singletonList(roleRep2));\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.roleResourceCompositesPath(\"role1\"), Collections.singletonList(roleRep2), ResourceType.REALM_ROLE);\n\n        String accountMgmtId = realm.clients().findByClientId(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID).get(0).getId();\n        RoleRepresentation viewAccountRoleRep = realm.clients().get(accountMgmtId).roles().get(AccountRoles.VIEW_PROFILE).toRepresentation();\n\n        scopesResource.realmLevel().add(Collections.singletonList(roleRep1));\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientScopeMappingsRealmLevelPath(id), Collections.singletonList(roleRep1), ResourceType.REALM_SCOPE_MAPPING);\n\n        scopesResource.clientLevel(accountMgmtId).add(Collections.singletonList(viewAccountRoleRep));\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientScopeMappingsClientLevelPath(id, accountMgmtId), Collections.singletonList(viewAccountRoleRep), ResourceType.CLIENT_SCOPE_MAPPING);\n\n        Assert.assertNames(scopesResource.realmLevel().listAll(), \"role1\");\n        Assert.assertNames(scopesResource.realmLevel().listEffective(), \"role1\", \"role2\");\n        Assert.assertNames(scopesResource.realmLevel().listAvailable(), \"offline_access\", Constants.AUTHZ_UMA_AUTHORIZATION);\n\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAll(), AccountRoles.VIEW_PROFILE);\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listEffective(), AccountRoles.VIEW_PROFILE);\n\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAvailable(), AccountRoles.MANAGE_ACCOUNT, AccountRoles.MANAGE_ACCOUNT_LINKS);\n\n        Assert.assertNames(scopesResource.getAll().getRealmMappings(), \"role1\");\n        Assert.assertNames(scopesResource.getAll().getClientMappings().get(Constants.ACCOUNT_MANAGEMENT_CLIENT_ID).getMappings(), AccountRoles.VIEW_PROFILE);\n\n        scopesResource.realmLevel().remove(Collections.singletonList(roleRep1));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientScopeMappingsRealmLevelPath(id), Collections.singletonList(roleRep1), ResourceType.REALM_SCOPE_MAPPING);\n\n        scopesResource.clientLevel(accountMgmtId).remove(Collections.singletonList(viewAccountRoleRep));\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientScopeMappingsClientLevelPath(id, accountMgmtId), Collections.singletonList(viewAccountRoleRep), ResourceType.CLIENT_SCOPE_MAPPING);\n\n        Assert.assertNames(scopesResource.realmLevel().listAll());\n        Assert.assertNames(scopesResource.realmLevel().listEffective());\n        Assert.assertNames(scopesResource.realmLevel().listAvailable(), \"offline_access\", Constants.AUTHZ_UMA_AUTHORIZATION, \"role1\", \"role2\");\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAll());\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listAvailable(), AccountRoles.VIEW_PROFILE, AccountRoles.MANAGE_ACCOUNT, AccountRoles.MANAGE_ACCOUNT_LINKS);\n        Assert.assertNames(scopesResource.clientLevel(accountMgmtId).listEffective());\n    }\n\n    public void protocolMappersTest(String clientDbId, ProtocolMappersResource mappersResource) {\n        // assert default mappers found\n        List<ProtocolMapperRepresentation> protocolMappers = mappersResource.getMappers();\n\n        String emailMapperId = null;\n        String usernameMapperId = null;\n        String fooMapperId = null;\n        for (ProtocolMapperRepresentation mapper : protocolMappers) {\n            if (mapper.getName().equals(OIDCLoginProtocolFactory.EMAIL)) {\n                emailMapperId = mapper.getId();\n            } else if (mapper.getName().equals(OIDCLoginProtocolFactory.USERNAME)) {\n                usernameMapperId = mapper.getId();\n            } else if (mapper.getName().equals(\"foo\")) {\n                fooMapperId = mapper.getId();\n            }\n        }\n\n        // Builtin mappers are not here\n        assertNull(emailMapperId);\n        assertNull(usernameMapperId);\n\n        assertNull(fooMapperId);\n\n        // Create foo mapper\n        ProtocolMapperRepresentation fooMapper = new ProtocolMapperRepresentation();\n        fooMapper.setName(\"foo\");\n        fooMapper.setProtocol(\"openid-connect\");\n        fooMapper.setProtocolMapper(\"oidc-hardcoded-claim-mapper\");\n        Response response = mappersResource.createMapper(fooMapper);\n        String location = response.getLocation().toString();\n        fooMapperId = location.substring(location.lastIndexOf(\"/\") + 1);\n        response.close();\n\n        assertAdminEvents.assertEvent(realmId, OperationType.CREATE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), fooMapper, ResourceType.PROTOCOL_MAPPER);\n\n        fooMapper = mappersResource.getMapperById(fooMapperId);\n        assertEquals(fooMapper.getName(), \"foo\");\n\n        // Update foo mapper\n        mappersResource.update(fooMapperId, fooMapper);\n\n        assertAdminEvents.assertEvent(realmId, OperationType.UPDATE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), fooMapper, ResourceType.PROTOCOL_MAPPER);\n\n        fooMapper = mappersResource.getMapperById(fooMapperId);\n\n        // Remove foo mapper\n        mappersResource.delete(fooMapperId);\n        assertAdminEvents.assertEvent(realmId, OperationType.DELETE, AdminEventPaths.clientProtocolMapperPath(clientDbId, fooMapperId), ResourceType.PROTOCOL_MAPPER);\n        try {\n            mappersResource.getMapperById(fooMapperId);\n            fail(\"Not expected to find deleted mapper\");\n        } catch (NotFoundException nfe) {\n        }\n    }\n\n    public static void assertClient(ClientRepresentation client, ClientRepresentation storedClient) {\n        if (client.getClientId() != null) Assert.assertEquals(client.getClientId(), storedClient.getClientId());\n        if (client.getName() != null) Assert.assertEquals(client.getName(), storedClient.getName());\n        if (client.isEnabled() != null) Assert.assertEquals(client.isEnabled(), storedClient.isEnabled());\n        if (client.isBearerOnly() != null) Assert.assertEquals(client.isBearerOnly(), storedClient.isBearerOnly());\n        if (client.isPublicClient() != null) Assert.assertEquals(client.isPublicClient(), storedClient.isPublicClient());\n        if (client.isFullScopeAllowed() != null) Assert.assertEquals(client.isFullScopeAllowed(), storedClient.isFullScopeAllowed());\n        if (client.getRootUrl() != null) Assert.assertEquals(client.getRootUrl(), storedClient.getRootUrl());\n        if (client.getAdminUrl() != null) Assert.assertEquals(client.getAdminUrl(), storedClient.getAdminUrl());\n        if (client.getBaseUrl() != null) Assert.assertEquals(client.getBaseUrl(), storedClient.getBaseUrl());\n        if (client.isSurrogateAuthRequired() != null) Assert.assertEquals(client.isSurrogateAuthRequired(), storedClient.isSurrogateAuthRequired());\n        if (client.getClientAuthenticatorType() != null) Assert.assertEquals(client.getClientAuthenticatorType(), storedClient.getClientAuthenticatorType());\n\n        if (client.getNotBefore() != null) {\n            Assert.assertEquals(client.getNotBefore(), storedClient.getNotBefore());\n        }\n        if (client.getDefaultRoles() != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getDefaultRoles()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getDefaultRoles()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n\n        List<String> redirectUris = client.getRedirectUris();\n        if (redirectUris != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getRedirectUris()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getRedirectUris()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n\n        List<String> webOrigins = client.getWebOrigins();\n        if (webOrigins != null) {\n            Set<String> set = new HashSet<String>();\n            for (String val : client.getWebOrigins()) {\n                set.add(val);\n            }\n            Set<String> storedSet = new HashSet<String>();\n            for (String val : storedClient.getWebOrigins()) {\n                storedSet.add(val);\n            }\n\n            Assert.assertEquals(set, storedSet);\n        }\n    }\n\n}\n"], "filenames": ["examples/demo-template/testrealm.json", "services/src/main/java/org/keycloak/services/managers/ClientManager.java", "testsuite/integration-arquillian/test-apps/photoz/photoz-realm.json", "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/ClientTest.java"], "buggy_code_start_loc": [79, 167, 114, 233], "buggy_code_end_loc": [80, 209, 115, 233], "fixing_code_start_loc": [78, 166, 113, 234], "fixing_code_end_loc": [78, 206, 113, 236], "type": "CWE-798", "message": "A flaw was found in keycloack before version 8.0.0. The owner of 'placeholder.org' domain can setup mail server on this domain and knowing only name of a client can reset password and then log in. For example, for client name 'test' the email address will be 'service-account-test@placeholder.org'.", "other": {"cve": {"id": "CVE-2019-14837", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-07T17:15:11.033", "lastModified": "2020-01-15T15:43:22.813", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in keycloack before version 8.0.0. The owner of 'placeholder.org' domain can setup mail server on this domain and knowing only name of a client can reset password and then log in. For example, for client name 'test' the email address will be 'service-account-test@placeholder.org'."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo en keycloack versiones anteriores a la versi\u00f3n  8.0.0. El propietario del dominio \"placeholder.org\" puede configurar el servidor de correo sobre este dominio y conociendo solo el nombre de un cliente puede restablecer la contrase\u00f1a y luego iniciar sesi\u00f3n. Por ejemplo, para el nombre del cliente \"prueba\", la direcci\u00f3n de correo electr\u00f3nico ser\u00e1 \"service-account-test@placeholder.org\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-798"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-547"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:keycloak:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.0.0", "matchCriteriaId": "637DA24E-DD9D-4895-8335-7C6A2AB6472F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:single_sign-on:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "E939A0E0-3437-459E-9FAB-FE42811B1D32"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-14837", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/keycloak/keycloak/commit/9a7c1a91a59ab85e7f8889a505be04a71580777f", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://issues.jboss.org/browse/KEYCLOAK-10780", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Permissions Required", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/keycloak/keycloak/commit/9a7c1a91a59ab85e7f8889a505be04a71580777f"}}