{"buggy_code": ["#include \"jsi.h\"\n#include \"jslex.h\"\n#include \"jsparse.h\"\n#include \"jscompile.h\"\n#include \"jsvalue.h\" /* for jsV_numbertostring */\n\n#define cexp jsC_cexp /* collision with math.h */\n\n#define JF js_State *J, js_Function *F\n\nJS_NORETURN void jsC_error(js_State *J, js_Ast *node, const char *fmt, ...) JS_PRINTFLIKE(3,4);\n\nstatic void cfunbody(JF, js_Ast *name, js_Ast *params, js_Ast *body);\nstatic void cexp(JF, js_Ast *exp);\nstatic void cstmlist(JF, js_Ast *list);\nstatic void cstm(JF, js_Ast *stm);\n\nvoid jsC_error(js_State *J, js_Ast *node, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tchar msgbuf[256];\n\n\tva_start(ap, fmt);\n\tvsnprintf(msgbuf, 256, fmt, ap);\n\tva_end(ap);\n\n\tsnprintf(buf, 256, \"%s:%d: \", J->filename, node->line);\n\tstrcat(buf, msgbuf);\n\n\tjs_newsyntaxerror(J, buf);\n\tjs_throw(J);\n}\n\nstatic const char *futurewords[] = {\n\t\"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\",\n};\n\nstatic const char *strictfuturewords[] = {\n\t\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\",\n\t\"public\", \"static\", \"yield\",\n};\n\nstatic void checkfutureword(JF, js_Ast *exp)\n{\n\tif (jsY_findword(exp->string, futurewords, nelem(futurewords)) >= 0)\n\t\tjsC_error(J, exp, \"'%s' is a future reserved word\", exp->string);\n\tif (F->strict) {\n\t\tif (jsY_findword(exp->string, strictfuturewords, nelem(strictfuturewords)) >= 0)\n\t\t\tjsC_error(J, exp, \"'%s' is a strict mode future reserved word\", exp->string);\n\t}\n}\n\nstatic js_Function *newfun(js_State *J, int line, js_Ast *name, js_Ast *params, js_Ast *body, int script, int default_strict)\n{\n\tjs_Function *F = js_malloc(J, sizeof *F);\n\tmemset(F, 0, sizeof *F);\n\tF->gcmark = 0;\n\tF->gcnext = J->gcfun;\n\tJ->gcfun = F;\n\t++J->gccounter;\n\n\tF->filename = js_intern(J, J->filename);\n\tF->line = line;\n\tF->script = script;\n\tF->strict = default_strict;\n\tF->name = name ? name->string : \"\";\n\n\tcfunbody(J, F, name, params, body);\n\n\treturn F;\n}\n\n/* Emit opcodes, constants and jumps */\n\nstatic void emitraw(JF, int value)\n{\n\tif (value != (js_Instruction)value)\n\t\tjs_syntaxerror(J, \"integer overflow in instruction coding\");\n\tif (F->codelen >= F->codecap) {\n\t\tF->codecap = F->codecap ? F->codecap * 2 : 64;\n\t\tF->code = js_realloc(J, F->code, F->codecap * sizeof *F->code);\n\t}\n\tF->code[F->codelen++] = value;\n}\n\nstatic void emit(JF, int value)\n{\n\temitraw(J, F, F->lastline);\n\temitraw(J, F, value);\n}\n\nstatic void emitarg(JF, int value)\n{\n\temitraw(J, F, value);\n}\n\nstatic void emitline(JF, js_Ast *node)\n{\n\tF->lastline = node->line;\n}\n\nstatic int addfunction(JF, js_Function *value)\n{\n\tif (F->funlen >= F->funcap) {\n\t\tF->funcap = F->funcap ? F->funcap * 2 : 16;\n\t\tF->funtab = js_realloc(J, F->funtab, F->funcap * sizeof *F->funtab);\n\t}\n\tF->funtab[F->funlen] = value;\n\treturn F->funlen++;\n}\n\nstatic int addnumber(JF, double value)\n{\n\tint i;\n\tfor (i = 0; i < F->numlen; ++i)\n\t\tif (F->numtab[i] == value)\n\t\t\treturn i;\n\tif (F->numlen >= F->numcap) {\n\t\tF->numcap = F->numcap ? F->numcap * 2 : 16;\n\t\tF->numtab = js_realloc(J, F->numtab, F->numcap * sizeof *F->numtab);\n\t}\n\tF->numtab[F->numlen] = value;\n\treturn F->numlen++;\n}\n\nstatic int addstring(JF, const char *value)\n{\n\tint i;\n\tfor (i = 0; i < F->strlen; ++i)\n\t\tif (!strcmp(F->strtab[i], value))\n\t\t\treturn i;\n\tif (F->strlen >= F->strcap) {\n\t\tF->strcap = F->strcap ? F->strcap * 2 : 16;\n\t\tF->strtab = js_realloc(J, F->strtab, F->strcap * sizeof *F->strtab);\n\t}\n\tF->strtab[F->strlen] = value;\n\treturn F->strlen++;\n}\n\nstatic int addlocal(JF, js_Ast *ident, int reuse)\n{\n\tconst char *name = ident->string;\n\tif (F->strict) {\n\t\tif (!strcmp(name, \"arguments\"))\n\t\t\tjsC_error(J, ident, \"redefining 'arguments' is not allowed in strict mode\");\n\t\tif (!strcmp(name, \"eval\"))\n\t\t\tjsC_error(J, ident, \"redefining 'eval' is not allowed in strict mode\");\n\t} else {\n\t\tif (!strcmp(name, \"eval\"))\n\t\t\tjs_evalerror(J, \"%s:%d: invalid use of 'eval'\", J->filename, ident->line);\n\t}\n\tif (reuse || F->strict) {\n\t\tint i;\n\t\tfor (i = 0; i < F->varlen; ++i) {\n\t\t\tif (!strcmp(F->vartab[i], name)) {\n\t\t\t\tif (reuse)\n\t\t\t\t\treturn i+1;\n\t\t\t\tif (F->strict)\n\t\t\t\t\tjsC_error(J, ident, \"duplicate formal parameter '%s'\", name);\n\t\t\t}\n\t\t}\n\t}\n\tif (F->varlen >= F->varcap) {\n\t\tF->varcap = F->varcap ? F->varcap * 2 : 16;\n\t\tF->vartab = js_realloc(J, F->vartab, F->varcap * sizeof *F->vartab);\n\t}\n\tF->vartab[F->varlen] = name;\n\treturn ++F->varlen;\n}\n\nstatic int findlocal(JF, const char *name)\n{\n\tint i;\n\tfor (i = F->varlen; i > 0; --i)\n\t\tif (!strcmp(F->vartab[i-1], name))\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic void emitfunction(JF, js_Function *fun)\n{\n\tF->lightweight = 0;\n\temit(J, F, OP_CLOSURE);\n\temitarg(J, F, addfunction(J, F, fun));\n}\n\nstatic void emitnumber(JF, double num)\n{\n\tif (num == 0) {\n\t\temit(J, F, OP_INTEGER);\n\t\temitarg(J, F, 32768);\n\t\tif (signbit(num))\n\t\t\temit(J, F, OP_NEG);\n\t} else {\n\t\tdouble nv = num + 32768;\n\t\tjs_Instruction iv = nv;\n\t\tif (nv == iv) {\n\t\t\temit(J, F, OP_INTEGER);\n\t\t\temitarg(J, F, iv);\n\t\t} else {\n\t\t\temit(J, F, OP_NUMBER);\n\t\t\temitarg(J, F, addnumber(J, F, num));\n\t\t}\n\t}\n}\n\nstatic void emitstring(JF, int opcode, const char *str)\n{\n\temit(J, F, opcode);\n\temitarg(J, F, addstring(J, F, str));\n}\n\nstatic void emitlocal(JF, int oploc, int opvar, js_Ast *ident)\n{\n\tint is_arguments = !strcmp(ident->string, \"arguments\");\n\tint is_eval = !strcmp(ident->string, \"eval\");\n\tint i;\n\n\tif (is_arguments) {\n\t\tF->lightweight = 0;\n\t\tF->arguments = 1;\n\t}\n\n\tcheckfutureword(J, F, ident);\n\tif (F->strict && oploc == OP_SETLOCAL) {\n\t\tif (is_arguments)\n\t\t\tjsC_error(J, ident, \"'arguments' is read-only in strict mode\");\n\t\tif (is_eval)\n\t\t\tjsC_error(J, ident, \"'eval' is read-only in strict mode\");\n\t}\n\tif (is_eval)\n\t\tjs_evalerror(J, \"%s:%d: invalid use of 'eval'\", J->filename, ident->line);\n\n\ti = findlocal(J, F, ident->string);\n\tif (i < 0) {\n\t\temitstring(J, F, opvar, ident->string);\n\t} else {\n\t\temit(J, F, oploc);\n\t\temitarg(J, F, i);\n\t}\n}\n\nstatic int here(JF)\n{\n\treturn F->codelen;\n}\n\nstatic int emitjump(JF, int opcode)\n{\n\tint inst;\n\temit(J, F, opcode);\n\tinst = F->codelen;\n\temitarg(J, F, 0);\n\treturn inst;\n}\n\nstatic void emitjumpto(JF, int opcode, int dest)\n{\n\temit(J, F, opcode);\n\tif (dest != (js_Instruction)dest)\n\t\tjs_syntaxerror(J, \"jump address integer overflow\");\n\temitarg(J, F, dest);\n}\n\nstatic void labelto(JF, int inst, int addr)\n{\n\tif (addr != (js_Instruction)addr)\n\t\tjs_syntaxerror(J, \"jump address integer overflow\");\n\tF->code[inst] = addr;\n}\n\nstatic void label(JF, int inst)\n{\n\tlabelto(J, F, inst, F->codelen);\n}\n\n/* Expressions */\n\nstatic void ctypeof(JF, js_Ast *exp)\n{\n\tif (exp->a->type == EXP_IDENTIFIER) {\n\t\temitline(J, F, exp->a);\n\t\temitlocal(J, F, OP_GETLOCAL, OP_HASVAR, exp->a);\n\t} else {\n\t\tcexp(J, F, exp->a);\n\t}\n\temitline(J, F, exp);\n\temit(J, F, OP_TYPEOF);\n}\n\nstatic void cunary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n}\n\nstatic void cbinary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\tcexp(J, F, exp->b);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n}\n\nstatic void carray(JF, js_Ast *list)\n{\n\tint i = 0;\n\twhile (list) {\n\t\tif (list->a->type != EXP_UNDEF) {\n\t\t\temitline(J, F, list->a);\n\t\t\temitnumber(J, F, i++);\n\t\t\tcexp(J, F, list->a);\n\t\t\temitline(J, F, list->a);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void checkdup(JF, js_Ast *list, js_Ast *end)\n{\n\tchar nbuf[32], sbuf[32];\n\tconst char *needle, *straw;\n\n\tif (end->a->type == EXP_NUMBER)\n\t\tneedle = jsV_numbertostring(J, nbuf, end->a->number);\n\telse\n\t\tneedle = end->a->string;\n\n\twhile (list->a != end) {\n\t\tif (list->a->type == end->type) {\n\t\t\tjs_Ast *prop = list->a->a;\n\t\t\tif (prop->type == EXP_NUMBER)\n\t\t\t\tstraw = jsV_numbertostring(J, sbuf, prop->number);\n\t\t\telse\n\t\t\t\tstraw =  prop->string;\n\t\t\tif (!strcmp(needle, straw))\n\t\t\t\tjsC_error(J, list, \"duplicate property '%s' in object literal\", needle);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cobject(JF, js_Ast *list)\n{\n\tjs_Ast *head = list;\n\n\twhile (list) {\n\t\tjs_Ast *kv = list->a;\n\t\tjs_Ast *prop = kv->a;\n\n\t\tif (prop->type == AST_IDENTIFIER || prop->type == EXP_STRING) {\n\t\t\temitline(J, F, prop);\n\t\t\temitstring(J, F, OP_STRING, prop->string);\n\t\t} else if (prop->type == EXP_NUMBER) {\n\t\t\temitline(J, F, prop);\n\t\t\temitnumber(J, F, prop->number);\n\t\t} else {\n\t\t\tjsC_error(J, prop, \"invalid property name in object initializer\");\n\t\t}\n\n\t\tif (F->strict)\n\t\t\tcheckdup(J, F, head, kv);\n\n\t\tswitch (kv->type) {\n\t\tdefault: /* impossible */ break;\n\t\tcase EXP_PROP_VAL:\n\t\t\tcexp(J, F, kv->b);\n\t\t\temitline(J, F, kv);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t\tbreak;\n\t\tcase EXP_PROP_GET:\n\t\t\temitfunction(J, F, newfun(J, prop->line, NULL, NULL, kv->c, 0, F->strict));\n\t\t\temitline(J, F, kv);\n\t\t\temit(J, F, OP_INITGETTER);\n\t\t\tbreak;\n\t\tcase EXP_PROP_SET:\n\t\t\temitfunction(J, F, newfun(J, prop->line, NULL, kv->b, kv->c, 0, F->strict));\n\t\t\temitline(J, F, kv);\n\t\t\temit(J, F, OP_INITSETTER);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist = list->b;\n\t}\n}\n\nstatic int cargs(JF, js_Ast *list)\n{\n\tint n = 0;\n\twhile (list) {\n\t\tcexp(J, F, list->a);\n\t\tlist = list->b;\n\t\t++n;\n\t}\n\treturn n;\n}\n\nstatic void cassign(JF, js_Ast *exp)\n{\n\tjs_Ast *lhs = exp->a;\n\tjs_Ast *rhs = exp->b;\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\tcexp(J, F, rhs);\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\tcexp(J, F, rhs);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_SETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, rhs);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n\nstatic void cassignforin(JF, js_Ast *stm)\n{\n\tjs_Ast *lhs = stm->a;\n\n\tif (stm->type == STM_FOR_IN_VAR) {\n\t\tif (lhs->b)\n\t\t\tjsC_error(J, lhs->b, \"more than one loop variable in for-in statement\");\n\t\temitline(J, F, lhs->a);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs->a->a); /* list(var-init(ident)) */\n\t\temit(J, F, OP_POP);\n\t\treturn;\n\t}\n\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, lhs);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_ROT3);\n\t\temit(J, F, OP_SETPROP);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_ROT2);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in for-in loop assignment\");\n\t}\n}\n\nstatic void cassignop1(JF, js_Ast *lhs)\n{\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, lhs);\n\t\temitlocal(J, F, OP_GETLOCAL, OP_GETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_DUP2);\n\t\temit(J, F, OP_GETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_DUP);\n\t\temitstring(J, F, OP_GETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n\nstatic void cassignop2(JF, js_Ast *lhs, int postfix)\n{\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, lhs);\n\t\tif (postfix) emit(J, F, OP_ROT2);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\temitline(J, F, lhs);\n\t\tif (postfix) emit(J, F, OP_ROT4);\n\t\temit(J, F, OP_SETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\temitline(J, F, lhs);\n\t\tif (postfix) emit(J, F, OP_ROT3);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n\nstatic void cassignop(JF, js_Ast *exp, int opcode)\n{\n\tjs_Ast *lhs = exp->a;\n\tjs_Ast *rhs = exp->b;\n\tcassignop1(J, F, lhs);\n\tcexp(J, F, rhs);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n\tcassignop2(J, F, lhs, 0);\n}\n\nstatic void cdelete(JF, js_Ast *exp)\n{\n\tjs_Ast *arg = exp->a;\n\tswitch (arg->type) {\n\tcase EXP_IDENTIFIER:\n\t\tif (F->strict)\n\t\t\tjsC_error(J, exp, \"delete on an unqualified name is not allowed in strict mode\");\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_DELLOCAL, OP_DELVAR, arg);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, arg->a);\n\t\tcexp(J, F, arg->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DELPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, arg->a);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_DELPROP_S, arg->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, exp, \"invalid l-value in delete expression\");\n\t}\n}\n\nstatic void ceval(JF, js_Ast *fun, js_Ast *args)\n{\n\tint n = cargs(J, F, args);\n\tF->lightweight = 0;\n\tif (n == 0)\n\t\temit(J, F, OP_UNDEF);\n\telse while (n-- > 1)\n\t\temit(J, F, OP_POP);\n\temit(J, F, OP_EVAL);\n}\n\nstatic void ccall(JF, js_Ast *fun, js_Ast *args)\n{\n\tint n;\n\tswitch (fun->type) {\n\tcase EXP_INDEX:\n\t\tcexp(J, F, fun->a);\n\t\temit(J, F, OP_DUP);\n\t\tcexp(J, F, fun->b);\n\t\temit(J, F, OP_GETPROP);\n\t\temit(J, F, OP_ROT2);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, fun->a);\n\t\temit(J, F, OP_DUP);\n\t\temitstring(J, F, OP_GETPROP_S, fun->b->string);\n\t\temit(J, F, OP_ROT2);\n\t\tbreak;\n\tcase EXP_IDENTIFIER:\n\t\tif (!strcmp(fun->string, \"eval\")) {\n\t\t\tceval(J, F, fun, args);\n\t\t\treturn;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tcexp(J, F, fun);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\t}\n\tn = cargs(J, F, args);\n\temit(J, F, OP_CALL);\n\temitarg(J, F, n);\n}\n\nstatic void cexp(JF, js_Ast *exp)\n{\n\tint then, end;\n\tint n;\n\n\tswitch (exp->type) {\n\tcase EXP_STRING:\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_STRING, exp->string);\n\t\tbreak;\n\tcase EXP_NUMBER:\n\t\temitline(J, F, exp);\n\t\temitnumber(J, F, exp->number);\n\t\tbreak;\n\tcase EXP_UNDEF:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\tcase EXP_NULL:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NULL);\n\t\tbreak;\n\tcase EXP_TRUE:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_TRUE);\n\t\tbreak;\n\tcase EXP_FALSE:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_FALSE);\n\t\tbreak;\n\tcase EXP_THIS:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_THIS);\n\t\tbreak;\n\n\tcase EXP_REGEXP:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEWREGEXP);\n\t\temitarg(J, F, addstring(J, F, exp->string));\n\t\temitarg(J, F, exp->number);\n\t\tbreak;\n\n\tcase EXP_OBJECT:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEWOBJECT);\n\t\tcobject(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_ARRAY:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEWARRAY);\n\t\tcarray(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_FUN:\n\t\temitline(J, F, exp);\n\t\temitfunction(J, F, newfun(J, exp->line, exp->a, exp->b, exp->c, 0, F->strict));\n\t\tbreak;\n\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_GETLOCAL, OP_GETVAR, exp);\n\t\tbreak;\n\n\tcase EXP_INDEX:\n\t\tcexp(J, F, exp->a);\n\t\tcexp(J, F, exp->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_GETPROP);\n\t\tbreak;\n\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_GETPROP_S, exp->b->string);\n\t\tbreak;\n\n\tcase EXP_CALL:\n\t\tccall(J, F, exp->a, exp->b);\n\t\tbreak;\n\n\tcase EXP_NEW:\n\t\tcexp(J, F, exp->a);\n\t\tn = cargs(J, F, exp->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEW);\n\t\temitarg(J, F, n);\n\t\tbreak;\n\n\tcase EXP_DELETE:\n\t\tcdelete(J, F, exp);\n\t\tbreak;\n\n\tcase EXP_PREINC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_INC);\n\t\tcassignop2(J, F, exp->a, 0);\n\t\tbreak;\n\n\tcase EXP_PREDEC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DEC);\n\t\tcassignop2(J, F, exp->a, 0);\n\t\tbreak;\n\n\tcase EXP_POSTINC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POSTINC);\n\t\tcassignop2(J, F, exp->a, 1);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\n\tcase EXP_POSTDEC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POSTDEC);\n\t\tcassignop2(J, F, exp->a, 1);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\n\tcase EXP_VOID:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POP);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\n\tcase EXP_TYPEOF: ctypeof(J, F, exp); break;\n\tcase EXP_POS: cunary(J, F, exp, OP_POS); break;\n\tcase EXP_NEG: cunary(J, F, exp, OP_NEG); break;\n\tcase EXP_BITNOT: cunary(J, F, exp, OP_BITNOT); break;\n\tcase EXP_LOGNOT: cunary(J, F, exp, OP_LOGNOT); break;\n\n\tcase EXP_BITOR: cbinary(J, F, exp, OP_BITOR); break;\n\tcase EXP_BITXOR: cbinary(J, F, exp, OP_BITXOR); break;\n\tcase EXP_BITAND: cbinary(J, F, exp, OP_BITAND); break;\n\tcase EXP_EQ: cbinary(J, F, exp, OP_EQ); break;\n\tcase EXP_NE: cbinary(J, F, exp, OP_NE); break;\n\tcase EXP_STRICTEQ: cbinary(J, F, exp, OP_STRICTEQ); break;\n\tcase EXP_STRICTNE: cbinary(J, F, exp, OP_STRICTNE); break;\n\tcase EXP_LT: cbinary(J, F, exp, OP_LT); break;\n\tcase EXP_GT: cbinary(J, F, exp, OP_GT); break;\n\tcase EXP_LE: cbinary(J, F, exp, OP_LE); break;\n\tcase EXP_GE: cbinary(J, F, exp, OP_GE); break;\n\tcase EXP_INSTANCEOF: cbinary(J, F, exp, OP_INSTANCEOF); break;\n\tcase EXP_IN: cbinary(J, F, exp, OP_IN); break;\n\tcase EXP_SHL: cbinary(J, F, exp, OP_SHL); break;\n\tcase EXP_SHR: cbinary(J, F, exp, OP_SHR); break;\n\tcase EXP_USHR: cbinary(J, F, exp, OP_USHR); break;\n\tcase EXP_ADD: cbinary(J, F, exp, OP_ADD); break;\n\tcase EXP_SUB: cbinary(J, F, exp, OP_SUB); break;\n\tcase EXP_MUL: cbinary(J, F, exp, OP_MUL); break;\n\tcase EXP_DIV: cbinary(J, F, exp, OP_DIV); break;\n\tcase EXP_MOD: cbinary(J, F, exp, OP_MOD); break;\n\n\tcase EXP_ASS: cassign(J, F, exp); break;\n\tcase EXP_ASS_MUL: cassignop(J, F, exp, OP_MUL); break;\n\tcase EXP_ASS_DIV: cassignop(J, F, exp, OP_DIV); break;\n\tcase EXP_ASS_MOD: cassignop(J, F, exp, OP_MOD); break;\n\tcase EXP_ASS_ADD: cassignop(J, F, exp, OP_ADD); break;\n\tcase EXP_ASS_SUB: cassignop(J, F, exp, OP_SUB); break;\n\tcase EXP_ASS_SHL: cassignop(J, F, exp, OP_SHL); break;\n\tcase EXP_ASS_SHR: cassignop(J, F, exp, OP_SHR); break;\n\tcase EXP_ASS_USHR: cassignop(J, F, exp, OP_USHR); break;\n\tcase EXP_ASS_BITAND: cassignop(J, F, exp, OP_BITAND); break;\n\tcase EXP_ASS_BITXOR: cassignop(J, F, exp, OP_BITXOR); break;\n\tcase EXP_ASS_BITOR: cassignop(J, F, exp, OP_BITOR); break;\n\n\tcase EXP_COMMA:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tbreak;\n\n\tcase EXP_LOGOR:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DUP);\n\t\tend = emitjump(J, F, OP_JTRUE);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tcase EXP_LOGAND:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DUP);\n\t\tend = emitjump(J, F, OP_JFALSE);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tcase EXP_COND:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\tthen = emitjump(J, F, OP_JTRUE);\n\t\tcexp(J, F, exp->c);\n\t\tend = emitjump(J, F, OP_JUMP);\n\t\tlabel(J, F, then);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tdefault:\n\t\tjsC_error(J, exp, \"unknown expression: (%s)\", jsP_aststring(exp->type));\n\t}\n}\n\n/* Patch break and continue statements */\n\nstatic void addjump(JF, enum js_AstType type, js_Ast *target, int inst)\n{\n\tjs_JumpList *jump = js_malloc(J, sizeof *jump);\n\tjump->type = type;\n\tjump->inst = inst;\n\tjump->next = target->jumps;\n\ttarget->jumps = jump;\n}\n\nstatic void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}\n\nstatic int isloop(enum js_AstType T)\n{\n\treturn T == STM_DO || T == STM_WHILE ||\n\t\tT == STM_FOR || T == STM_FOR_VAR ||\n\t\tT == STM_FOR_IN || T == STM_FOR_IN_VAR;\n}\n\nstatic int isfun(enum js_AstType T)\n{\n\treturn T == AST_FUNDEC || T == EXP_FUN || T == EXP_PROP_GET || T == EXP_PROP_SET;\n}\n\nstatic int matchlabel(js_Ast *node, const char *label)\n{\n\twhile (node && node->type == STM_LABEL) {\n\t\tif (!strcmp(node->a->string, label))\n\t\t\treturn 1;\n\t\tnode = node->parent;\n\t}\n\treturn 0;\n}\n\nstatic js_Ast *breaktarget(JF, js_Ast *node, const char *label)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\tbreak;\n\t\tif (!label) {\n\t\t\tif (isloop(node->type) || node->type == STM_SWITCH)\n\t\t\t\treturn node;\n\t\t} else {\n\t\t\tif (matchlabel(node->parent, label))\n\t\t\t\treturn node;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n\nstatic js_Ast *continuetarget(JF, js_Ast *node, const char *label)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\tbreak;\n\t\tif (isloop(node->type)) {\n\t\t\tif (!label)\n\t\t\t\treturn node;\n\t\t\telse if (matchlabel(node->parent, label))\n\t\t\t\treturn node;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n\nstatic js_Ast *returntarget(JF, js_Ast *node)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\treturn node;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n\n/* Emit code to rebalance stack and scopes during an abrupt exit */\n\nstatic void cexit(JF, enum js_AstType T, js_Ast *node, js_Ast *target)\n{\n\tjs_Ast *prev;\n\tdo {\n\t\tprev = node, node = node->parent;\n\t\tswitch (node->type) {\n\t\tdefault:\n\t\t\t/* impossible */\n\t\t\tbreak;\n\t\tcase STM_WITH:\n\t\t\temitline(J, F, node);\n\t\t\temit(J, F, OP_ENDWITH);\n\t\t\tbreak;\n\t\tcase STM_FOR_IN:\n\t\tcase STM_FOR_IN_VAR:\n\t\t\temitline(J, F, node);\n\t\t\t/* pop the iterator if leaving the loop */\n\t\t\tif (F->script) {\n\t\t\t\tif (T == STM_RETURN || T == STM_BREAK || (T == STM_CONTINUE && target != node)) {\n\t\t\t\t\t/* pop the iterator, save the return or exp value */\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_CONTINUE)\n\t\t\t\t\temit(J, F, OP_ROT2); /* put the iterator back on top */\n\t\t\t} else {\n\t\t\t\tif (T == STM_RETURN) {\n\t\t\t\t\t/* pop the iterator, save the return value */\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_BREAK || (T == STM_CONTINUE && target != node))\n\t\t\t\t\temit(J, F, OP_POP); /* pop the iterator */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STM_TRY:\n\t\t\temitline(J, F, node);\n\t\t\t/* came from try block */\n\t\t\tif (prev == node->a) {\n\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\tif (node->d) cstm(J, F, node->d); /* finally */\n\t\t\t}\n\t\t\t/* came from catch block */\n\t\t\tif (prev == node->c) {\n\t\t\t\t/* ... with finally */\n\t\t\t\tif (node->d) {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\t\tcstm(J, F, node->d); /* finally */\n\t\t\t\t} else {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (node != target);\n}\n\n/* Try/catch/finally */\n\nstatic void ctryfinally(JF, js_Ast *trystm, js_Ast *finallystm)\n{\n\tint L1;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tcstm(J, F, finallystm); /* inline finally block */\n\t\temit(J, F, OP_THROW); /* rethrow exception */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tcstm(J, F, finallystm);\n}\n\nstatic void ctrycatch(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm)\n{\n\tint L1, L2;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tcheckfutureword(J, F, catchvar);\n\t\tif (F->strict) {\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\tL2 = emitjump(J, F, OP_JUMP); /* skip past the try block */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L2);\n}\n\nstatic void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\t/* if we get here, we have caught an exception in the catch block */\n\t\t\tcstm(J, F, finallystm); /* inline finally block */\n\t\t\temit(J, F, OP_THROW); /* rethrow exception */\n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\tL3 = emitjump(J, F, OP_JUMP); /* skip past the try block to the finally block */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}\n\n/* Switch */\n\nstatic void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\n\tcexp(J, F, ref);\n\n\t/* emit an if-else chain of tests for the case clause expressions */\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\temitline(J, F, clause);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\temitline(J, F, def);\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\n\t/* emit the case clause bodies */\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\n\tif (end)\n\t\tlabel(J, F, end);\n}\n\n/* Statements */\n\nstatic void cvarinit(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *var = list->a;\n\t\tif (var->b) {\n\t\t\tcexp(J, F, var->b);\n\t\t\temitline(J, F, var);\n\t\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, var->a);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cstm(JF, js_Ast *stm)\n{\n\tjs_Ast *target;\n\tint loop, cont, then, end;\n\n\temitline(J, F, stm);\n\n\tswitch (stm->type) {\n\tcase AST_FUNDEC:\n\t\tbreak;\n\n\tcase STM_BLOCK:\n\t\tcstmlist(J, F, stm->a);\n\t\tbreak;\n\n\tcase STM_EMPTY:\n\t\tif (F->script) {\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t\temit(J, F, OP_UNDEF);\n\t\t}\n\t\tbreak;\n\n\tcase STM_VAR:\n\t\tcvarinit(J, F, stm->a);\n\t\tbreak;\n\n\tcase STM_IF:\n\t\tif (stm->c) {\n\t\t\tcexp(J, F, stm->a);\n\t\t\temitline(J, F, stm);\n\t\t\tthen = emitjump(J, F, OP_JTRUE);\n\t\t\tcstm(J, F, stm->c);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JUMP);\n\t\t\tlabel(J, F, then);\n\t\t\tcstm(J, F, stm->b);\n\t\t\tlabel(J, F, end);\n\t\t} else {\n\t\t\tcexp(J, F, stm->a);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t\tcstm(J, F, stm->b);\n\t\t\tlabel(J, F, end);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DO:\n\t\tloop = here(J, F);\n\t\tcstm(J, F, stm->a);\n\t\tcont = here(J, F);\n\t\tcexp(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JTRUE, loop);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), cont);\n\t\tbreak;\n\n\tcase STM_WHILE:\n\t\tloop = here(J, F);\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\tend = emitjump(J, F, OP_JFALSE);\n\t\tcstm(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n\t\tbreak;\n\n\tcase STM_FOR:\n\tcase STM_FOR_VAR:\n\t\tif (stm->type == STM_FOR_VAR) {\n\t\t\tcvarinit(J, F, stm->a);\n\t\t} else {\n\t\t\tif (stm->a) {\n\t\t\t\tcexp(J, F, stm->a);\n\t\t\t\temit(J, F, OP_POP);\n\t\t\t}\n\t\t}\n\t\tloop = here(J, F);\n\t\tif (stm->b) {\n\t\t\tcexp(J, F, stm->b);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t} else {\n\t\t\tend = 0;\n\t\t}\n\t\tcstm(J, F, stm->d);\n\t\tcont = here(J, F);\n\t\tif (stm->c) {\n\t\t\tcexp(J, F, stm->c);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\tif (end)\n\t\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), cont);\n\t\tbreak;\n\n\tcase STM_FOR_IN:\n\tcase STM_FOR_IN_VAR:\n\t\tcexp(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_ITERATOR);\n\t\tloop = here(J, F);\n\t\t{\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_NEXTITER);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t\tcassignforin(J, F, stm);\n\t\t\tif (F->script) {\n\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\tcstm(J, F, stm->c);\n\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t} else {\n\t\t\t\tcstm(J, F, stm->c);\n\t\t\t}\n\t\t\temitline(J, F, stm);\n\t\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\t}\n\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n\t\tbreak;\n\n\tcase STM_SWITCH:\n\t\tcswitch(J, F, stm->a, stm->b);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n\t\tbreak;\n\n\tcase STM_LABEL:\n\t\tcstm(J, F, stm->b);\n\t\t/* skip consecutive labels */\n\t\twhile (stm->type == STM_LABEL)\n\t\t\tstm = stm->b;\n\t\t/* loops and switches have already been labelled */\n\t\tif (!isloop(stm->type) && stm->type != STM_SWITCH)\n\t\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n\t\tbreak;\n\n\tcase STM_BREAK:\n\t\tif (stm->a) {\n\t\t\tcheckfutureword(J, F, stm->a);\n\t\t\ttarget = breaktarget(J, F, stm->parent, stm->a->string);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"break label '%s' not found\", stm->a->string);\n\t\t} else {\n\t\t\ttarget = breaktarget(J, F, stm->parent, NULL);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"unlabelled break must be inside loop or switch\");\n\t\t}\n\t\tcexit(J, F, STM_BREAK, stm, target);\n\t\temitline(J, F, stm);\n\t\taddjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));\n\t\tbreak;\n\n\tcase STM_CONTINUE:\n\t\tif (stm->a) {\n\t\t\tcheckfutureword(J, F, stm->a);\n\t\t\ttarget = continuetarget(J, F, stm->parent, stm->a->string);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"continue label '%s' not found\", stm->a->string);\n\t\t} else {\n\t\t\ttarget = continuetarget(J, F, stm->parent, NULL);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"continue must be inside loop\");\n\t\t}\n\t\tcexit(J, F, STM_CONTINUE, stm, target);\n\t\temitline(J, F, stm);\n\t\taddjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));\n\t\tbreak;\n\n\tcase STM_RETURN:\n\t\tif (stm->a)\n\t\t\tcexp(J, F, stm->a);\n\t\telse\n\t\t\temit(J, F, OP_UNDEF);\n\t\ttarget = returntarget(J, F, stm->parent);\n\t\tif (!target)\n\t\t\tjsC_error(J, stm, \"return not in function\");\n\t\tcexit(J, F, STM_RETURN, stm, target);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_RETURN);\n\t\tbreak;\n\n\tcase STM_THROW:\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_THROW);\n\t\tbreak;\n\n\tcase STM_WITH:\n\t\tF->lightweight = 0;\n\t\tif (F->strict)\n\t\t\tjsC_error(J, stm->a, \"'with' statements are not allowed in strict mode\");\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_WITH);\n\t\tcstm(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_ENDWITH);\n\t\tbreak;\n\n\tcase STM_TRY:\n\t\temitline(J, F, stm);\n\t\tif (stm->b && stm->c) {\n\t\t\tF->lightweight = 0;\n\t\t\tif (stm->d)\n\t\t\t\tctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);\n\t\t\telse\n\t\t\t\tctrycatch(J, F, stm->a, stm->b, stm->c);\n\t\t} else {\n\t\t\tctryfinally(J, F, stm->a, stm->d);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DEBUGGER:\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_DEBUGGER);\n\t\tbreak;\n\n\tdefault:\n\t\tif (F->script) {\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t\tcexp(J, F, stm);\n\t\t} else {\n\t\t\tcexp(J, F, stm);\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void cstmlist(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tcstm(J, F, list->a);\n\t\tlist = list->b;\n\t}\n}\n\n/* Declarations and programs */\n\nstatic int listlength(js_Ast *list)\n{\n\tint n = 0;\n\twhile (list) ++n, list = list->b;\n\treturn n;\n}\n\nstatic void cparams(JF, js_Ast *list, js_Ast *fname)\n{\n\tF->numparams = listlength(list);\n\twhile (list) {\n\t\tcheckfutureword(J, F, list->a);\n\t\taddlocal(J, F, list->a, 0);\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cvardecs(JF, js_Ast *node)\n{\n\tif (node->type == AST_LIST) {\n\t\twhile (node) {\n\t\t\tcvardecs(J, F, node->a);\n\t\t\tnode = node->b;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (isfun(node->type))\n\t\treturn; /* stop at inner functions */\n\n\tif (node->type == EXP_VAR) {\n\t\tcheckfutureword(J, F, node->a);\n\t\taddlocal(J, F, node->a, 1);\n\t}\n\n\tif (node->a) cvardecs(J, F, node->a);\n\tif (node->b) cvardecs(J, F, node->b);\n\tif (node->c) cvardecs(J, F, node->c);\n\tif (node->d) cvardecs(J, F, node->d);\n}\n\nstatic void cfundecs(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *stm = list->a;\n\t\tif (stm->type == AST_FUNDEC) {\n\t\t\temitline(J, F, stm);\n\t\t\temitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_SETLOCAL);\n\t\t\temitarg(J, F, addlocal(J, F, stm->a, 0));\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cfunbody(JF, js_Ast *name, js_Ast *params, js_Ast *body)\n{\n\tF->lightweight = 1;\n\tF->arguments = 0;\n\n\tif (F->script)\n\t\tF->lightweight = 0;\n\n\t/* Check if first statement is 'use strict': */\n\tif (body && body->type == AST_LIST && body->a && body->a->type == EXP_STRING)\n\t\tif (!strcmp(body->a->string, \"use strict\"))\n\t\t\tF->strict = 1;\n\n\tF->lastline = F->line;\n\n\tcparams(J, F, params, name);\n\n\tif (body) {\n\t\tcvardecs(J, F, body);\n\t\tcfundecs(J, F, body);\n\t}\n\n\tif (name) {\n\t\tcheckfutureword(J, F, name);\n\t\tif (findlocal(J, F, name->string) < 0) {\n\t\t\temit(J, F, OP_CURRENT);\n\t\t\temit(J, F, OP_SETLOCAL);\n\t\t\temitarg(J, F, addlocal(J, F, name, 0));\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t}\n\n\tif (F->script) {\n\t\temit(J, F, OP_UNDEF);\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_RETURN);\n\t} else {\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_UNDEF);\n\t\temit(J, F, OP_RETURN);\n\t}\n}\n\njs_Function *jsC_compilefunction(js_State *J, js_Ast *prog)\n{\n\treturn newfun(J, prog->line, prog->a, prog->b, prog->c, 0, J->default_strict);\n}\n\njs_Function *jsC_compilescript(js_State *J, js_Ast *prog, int default_strict)\n{\n\treturn newfun(J, prog ? prog->line : 0, NULL, NULL, prog, 1, default_strict);\n}\n"], "fixing_code": ["#include \"jsi.h\"\n#include \"jslex.h\"\n#include \"jsparse.h\"\n#include \"jscompile.h\"\n#include \"jsvalue.h\" /* for jsV_numbertostring */\n\n#define cexp jsC_cexp /* collision with math.h */\n\n#define JF js_State *J, js_Function *F\n\nJS_NORETURN void jsC_error(js_State *J, js_Ast *node, const char *fmt, ...) JS_PRINTFLIKE(3,4);\n\nstatic void cfunbody(JF, js_Ast *name, js_Ast *params, js_Ast *body);\nstatic void cexp(JF, js_Ast *exp);\nstatic void cstmlist(JF, js_Ast *list);\nstatic void cstm(JF, js_Ast *stm);\n\nvoid jsC_error(js_State *J, js_Ast *node, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tchar msgbuf[256];\n\n\tva_start(ap, fmt);\n\tvsnprintf(msgbuf, 256, fmt, ap);\n\tva_end(ap);\n\n\tsnprintf(buf, 256, \"%s:%d: \", J->filename, node->line);\n\tstrcat(buf, msgbuf);\n\n\tjs_newsyntaxerror(J, buf);\n\tjs_throw(J);\n}\n\nstatic const char *futurewords[] = {\n\t\"class\", \"const\", \"enum\", \"export\", \"extends\", \"import\", \"super\",\n};\n\nstatic const char *strictfuturewords[] = {\n\t\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\",\n\t\"public\", \"static\", \"yield\",\n};\n\nstatic void checkfutureword(JF, js_Ast *exp)\n{\n\tif (jsY_findword(exp->string, futurewords, nelem(futurewords)) >= 0)\n\t\tjsC_error(J, exp, \"'%s' is a future reserved word\", exp->string);\n\tif (F->strict) {\n\t\tif (jsY_findword(exp->string, strictfuturewords, nelem(strictfuturewords)) >= 0)\n\t\t\tjsC_error(J, exp, \"'%s' is a strict mode future reserved word\", exp->string);\n\t}\n}\n\nstatic js_Function *newfun(js_State *J, int line, js_Ast *name, js_Ast *params, js_Ast *body, int script, int default_strict)\n{\n\tjs_Function *F = js_malloc(J, sizeof *F);\n\tmemset(F, 0, sizeof *F);\n\tF->gcmark = 0;\n\tF->gcnext = J->gcfun;\n\tJ->gcfun = F;\n\t++J->gccounter;\n\n\tF->filename = js_intern(J, J->filename);\n\tF->line = line;\n\tF->script = script;\n\tF->strict = default_strict;\n\tF->name = name ? name->string : \"\";\n\n\tcfunbody(J, F, name, params, body);\n\n\treturn F;\n}\n\n/* Emit opcodes, constants and jumps */\n\nstatic void emitraw(JF, int value)\n{\n\tif (value != (js_Instruction)value)\n\t\tjs_syntaxerror(J, \"integer overflow in instruction coding\");\n\tif (F->codelen >= F->codecap) {\n\t\tF->codecap = F->codecap ? F->codecap * 2 : 64;\n\t\tF->code = js_realloc(J, F->code, F->codecap * sizeof *F->code);\n\t}\n\tF->code[F->codelen++] = value;\n}\n\nstatic void emit(JF, int value)\n{\n\temitraw(J, F, F->lastline);\n\temitraw(J, F, value);\n}\n\nstatic void emitarg(JF, int value)\n{\n\temitraw(J, F, value);\n}\n\nstatic void emitline(JF, js_Ast *node)\n{\n\tF->lastline = node->line;\n}\n\nstatic int addfunction(JF, js_Function *value)\n{\n\tif (F->funlen >= F->funcap) {\n\t\tF->funcap = F->funcap ? F->funcap * 2 : 16;\n\t\tF->funtab = js_realloc(J, F->funtab, F->funcap * sizeof *F->funtab);\n\t}\n\tF->funtab[F->funlen] = value;\n\treturn F->funlen++;\n}\n\nstatic int addnumber(JF, double value)\n{\n\tint i;\n\tfor (i = 0; i < F->numlen; ++i)\n\t\tif (F->numtab[i] == value)\n\t\t\treturn i;\n\tif (F->numlen >= F->numcap) {\n\t\tF->numcap = F->numcap ? F->numcap * 2 : 16;\n\t\tF->numtab = js_realloc(J, F->numtab, F->numcap * sizeof *F->numtab);\n\t}\n\tF->numtab[F->numlen] = value;\n\treturn F->numlen++;\n}\n\nstatic int addstring(JF, const char *value)\n{\n\tint i;\n\tfor (i = 0; i < F->strlen; ++i)\n\t\tif (!strcmp(F->strtab[i], value))\n\t\t\treturn i;\n\tif (F->strlen >= F->strcap) {\n\t\tF->strcap = F->strcap ? F->strcap * 2 : 16;\n\t\tF->strtab = js_realloc(J, F->strtab, F->strcap * sizeof *F->strtab);\n\t}\n\tF->strtab[F->strlen] = value;\n\treturn F->strlen++;\n}\n\nstatic int addlocal(JF, js_Ast *ident, int reuse)\n{\n\tconst char *name = ident->string;\n\tif (F->strict) {\n\t\tif (!strcmp(name, \"arguments\"))\n\t\t\tjsC_error(J, ident, \"redefining 'arguments' is not allowed in strict mode\");\n\t\tif (!strcmp(name, \"eval\"))\n\t\t\tjsC_error(J, ident, \"redefining 'eval' is not allowed in strict mode\");\n\t} else {\n\t\tif (!strcmp(name, \"eval\"))\n\t\t\tjs_evalerror(J, \"%s:%d: invalid use of 'eval'\", J->filename, ident->line);\n\t}\n\tif (reuse || F->strict) {\n\t\tint i;\n\t\tfor (i = 0; i < F->varlen; ++i) {\n\t\t\tif (!strcmp(F->vartab[i], name)) {\n\t\t\t\tif (reuse)\n\t\t\t\t\treturn i+1;\n\t\t\t\tif (F->strict)\n\t\t\t\t\tjsC_error(J, ident, \"duplicate formal parameter '%s'\", name);\n\t\t\t}\n\t\t}\n\t}\n\tif (F->varlen >= F->varcap) {\n\t\tF->varcap = F->varcap ? F->varcap * 2 : 16;\n\t\tF->vartab = js_realloc(J, F->vartab, F->varcap * sizeof *F->vartab);\n\t}\n\tF->vartab[F->varlen] = name;\n\treturn ++F->varlen;\n}\n\nstatic int findlocal(JF, const char *name)\n{\n\tint i;\n\tfor (i = F->varlen; i > 0; --i)\n\t\tif (!strcmp(F->vartab[i-1], name))\n\t\t\treturn i;\n\treturn -1;\n}\n\nstatic void emitfunction(JF, js_Function *fun)\n{\n\tF->lightweight = 0;\n\temit(J, F, OP_CLOSURE);\n\temitarg(J, F, addfunction(J, F, fun));\n}\n\nstatic void emitnumber(JF, double num)\n{\n\tif (num == 0) {\n\t\temit(J, F, OP_INTEGER);\n\t\temitarg(J, F, 32768);\n\t\tif (signbit(num))\n\t\t\temit(J, F, OP_NEG);\n\t} else {\n\t\tdouble nv = num + 32768;\n\t\tjs_Instruction iv = nv;\n\t\tif (nv == iv) {\n\t\t\temit(J, F, OP_INTEGER);\n\t\t\temitarg(J, F, iv);\n\t\t} else {\n\t\t\temit(J, F, OP_NUMBER);\n\t\t\temitarg(J, F, addnumber(J, F, num));\n\t\t}\n\t}\n}\n\nstatic void emitstring(JF, int opcode, const char *str)\n{\n\temit(J, F, opcode);\n\temitarg(J, F, addstring(J, F, str));\n}\n\nstatic void emitlocal(JF, int oploc, int opvar, js_Ast *ident)\n{\n\tint is_arguments = !strcmp(ident->string, \"arguments\");\n\tint is_eval = !strcmp(ident->string, \"eval\");\n\tint i;\n\n\tif (is_arguments) {\n\t\tF->lightweight = 0;\n\t\tF->arguments = 1;\n\t}\n\n\tcheckfutureword(J, F, ident);\n\tif (F->strict && oploc == OP_SETLOCAL) {\n\t\tif (is_arguments)\n\t\t\tjsC_error(J, ident, \"'arguments' is read-only in strict mode\");\n\t\tif (is_eval)\n\t\t\tjsC_error(J, ident, \"'eval' is read-only in strict mode\");\n\t}\n\tif (is_eval)\n\t\tjs_evalerror(J, \"%s:%d: invalid use of 'eval'\", J->filename, ident->line);\n\n\ti = findlocal(J, F, ident->string);\n\tif (i < 0) {\n\t\temitstring(J, F, opvar, ident->string);\n\t} else {\n\t\temit(J, F, oploc);\n\t\temitarg(J, F, i);\n\t}\n}\n\nstatic int here(JF)\n{\n\treturn F->codelen;\n}\n\nstatic int emitjump(JF, int opcode)\n{\n\tint inst;\n\temit(J, F, opcode);\n\tinst = F->codelen;\n\temitarg(J, F, 0);\n\treturn inst;\n}\n\nstatic void emitjumpto(JF, int opcode, int dest)\n{\n\temit(J, F, opcode);\n\tif (dest != (js_Instruction)dest)\n\t\tjs_syntaxerror(J, \"jump address integer overflow\");\n\temitarg(J, F, dest);\n}\n\nstatic void labelto(JF, int inst, int addr)\n{\n\tif (addr != (js_Instruction)addr)\n\t\tjs_syntaxerror(J, \"jump address integer overflow\");\n\tF->code[inst] = addr;\n}\n\nstatic void label(JF, int inst)\n{\n\tlabelto(J, F, inst, F->codelen);\n}\n\n/* Expressions */\n\nstatic void ctypeof(JF, js_Ast *exp)\n{\n\tif (exp->a->type == EXP_IDENTIFIER) {\n\t\temitline(J, F, exp->a);\n\t\temitlocal(J, F, OP_GETLOCAL, OP_HASVAR, exp->a);\n\t} else {\n\t\tcexp(J, F, exp->a);\n\t}\n\temitline(J, F, exp);\n\temit(J, F, OP_TYPEOF);\n}\n\nstatic void cunary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n}\n\nstatic void cbinary(JF, js_Ast *exp, int opcode)\n{\n\tcexp(J, F, exp->a);\n\tcexp(J, F, exp->b);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n}\n\nstatic void carray(JF, js_Ast *list)\n{\n\tint i = 0;\n\twhile (list) {\n\t\tif (list->a->type != EXP_UNDEF) {\n\t\t\temitline(J, F, list->a);\n\t\t\temitnumber(J, F, i++);\n\t\t\tcexp(J, F, list->a);\n\t\t\temitline(J, F, list->a);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t} else {\n\t\t\t++i;\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void checkdup(JF, js_Ast *list, js_Ast *end)\n{\n\tchar nbuf[32], sbuf[32];\n\tconst char *needle, *straw;\n\n\tif (end->a->type == EXP_NUMBER)\n\t\tneedle = jsV_numbertostring(J, nbuf, end->a->number);\n\telse\n\t\tneedle = end->a->string;\n\n\twhile (list->a != end) {\n\t\tif (list->a->type == end->type) {\n\t\t\tjs_Ast *prop = list->a->a;\n\t\t\tif (prop->type == EXP_NUMBER)\n\t\t\t\tstraw = jsV_numbertostring(J, sbuf, prop->number);\n\t\t\telse\n\t\t\t\tstraw =  prop->string;\n\t\t\tif (!strcmp(needle, straw))\n\t\t\t\tjsC_error(J, list, \"duplicate property '%s' in object literal\", needle);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cobject(JF, js_Ast *list)\n{\n\tjs_Ast *head = list;\n\n\twhile (list) {\n\t\tjs_Ast *kv = list->a;\n\t\tjs_Ast *prop = kv->a;\n\n\t\tif (prop->type == AST_IDENTIFIER || prop->type == EXP_STRING) {\n\t\t\temitline(J, F, prop);\n\t\t\temitstring(J, F, OP_STRING, prop->string);\n\t\t} else if (prop->type == EXP_NUMBER) {\n\t\t\temitline(J, F, prop);\n\t\t\temitnumber(J, F, prop->number);\n\t\t} else {\n\t\t\tjsC_error(J, prop, \"invalid property name in object initializer\");\n\t\t}\n\n\t\tif (F->strict)\n\t\t\tcheckdup(J, F, head, kv);\n\n\t\tswitch (kv->type) {\n\t\tdefault: /* impossible */ break;\n\t\tcase EXP_PROP_VAL:\n\t\t\tcexp(J, F, kv->b);\n\t\t\temitline(J, F, kv);\n\t\t\temit(J, F, OP_INITPROP);\n\t\t\tbreak;\n\t\tcase EXP_PROP_GET:\n\t\t\temitfunction(J, F, newfun(J, prop->line, NULL, NULL, kv->c, 0, F->strict));\n\t\t\temitline(J, F, kv);\n\t\t\temit(J, F, OP_INITGETTER);\n\t\t\tbreak;\n\t\tcase EXP_PROP_SET:\n\t\t\temitfunction(J, F, newfun(J, prop->line, NULL, kv->b, kv->c, 0, F->strict));\n\t\t\temitline(J, F, kv);\n\t\t\temit(J, F, OP_INITSETTER);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist = list->b;\n\t}\n}\n\nstatic int cargs(JF, js_Ast *list)\n{\n\tint n = 0;\n\twhile (list) {\n\t\tcexp(J, F, list->a);\n\t\tlist = list->b;\n\t\t++n;\n\t}\n\treturn n;\n}\n\nstatic void cassign(JF, js_Ast *exp)\n{\n\tjs_Ast *lhs = exp->a;\n\tjs_Ast *rhs = exp->b;\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\tcexp(J, F, rhs);\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\tcexp(J, F, rhs);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_SETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, rhs);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n\nstatic void cassignforin(JF, js_Ast *stm)\n{\n\tjs_Ast *lhs = stm->a;\n\n\tif (stm->type == STM_FOR_IN_VAR) {\n\t\tif (lhs->b)\n\t\t\tjsC_error(J, lhs->b, \"more than one loop variable in for-in statement\");\n\t\temitline(J, F, lhs->a);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs->a->a); /* list(var-init(ident)) */\n\t\temit(J, F, OP_POP);\n\t\treturn;\n\t}\n\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, lhs);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_ROT3);\n\t\temit(J, F, OP_SETPROP);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_ROT2);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in for-in loop assignment\");\n\t}\n}\n\nstatic void cassignop1(JF, js_Ast *lhs)\n{\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, lhs);\n\t\temitlocal(J, F, OP_GETLOCAL, OP_GETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_DUP2);\n\t\temit(J, F, OP_GETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temitline(J, F, lhs);\n\t\temit(J, F, OP_DUP);\n\t\temitstring(J, F, OP_GETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n\nstatic void cassignop2(JF, js_Ast *lhs, int postfix)\n{\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, lhs);\n\t\tif (postfix) emit(J, F, OP_ROT2);\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\temitline(J, F, lhs);\n\t\tif (postfix) emit(J, F, OP_ROT4);\n\t\temit(J, F, OP_SETPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\temitline(J, F, lhs);\n\t\tif (postfix) emit(J, F, OP_ROT3);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in assignment\");\n\t}\n}\n\nstatic void cassignop(JF, js_Ast *exp, int opcode)\n{\n\tjs_Ast *lhs = exp->a;\n\tjs_Ast *rhs = exp->b;\n\tcassignop1(J, F, lhs);\n\tcexp(J, F, rhs);\n\temitline(J, F, exp);\n\temit(J, F, opcode);\n\tcassignop2(J, F, lhs, 0);\n}\n\nstatic void cdelete(JF, js_Ast *exp)\n{\n\tjs_Ast *arg = exp->a;\n\tswitch (arg->type) {\n\tcase EXP_IDENTIFIER:\n\t\tif (F->strict)\n\t\t\tjsC_error(J, exp, \"delete on an unqualified name is not allowed in strict mode\");\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_DELLOCAL, OP_DELVAR, arg);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, arg->a);\n\t\tcexp(J, F, arg->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DELPROP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, arg->a);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_DELPROP_S, arg->b->string);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, exp, \"invalid l-value in delete expression\");\n\t}\n}\n\nstatic void ceval(JF, js_Ast *fun, js_Ast *args)\n{\n\tint n = cargs(J, F, args);\n\tF->lightweight = 0;\n\tif (n == 0)\n\t\temit(J, F, OP_UNDEF);\n\telse while (n-- > 1)\n\t\temit(J, F, OP_POP);\n\temit(J, F, OP_EVAL);\n}\n\nstatic void ccall(JF, js_Ast *fun, js_Ast *args)\n{\n\tint n;\n\tswitch (fun->type) {\n\tcase EXP_INDEX:\n\t\tcexp(J, F, fun->a);\n\t\temit(J, F, OP_DUP);\n\t\tcexp(J, F, fun->b);\n\t\temit(J, F, OP_GETPROP);\n\t\temit(J, F, OP_ROT2);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, fun->a);\n\t\temit(J, F, OP_DUP);\n\t\temitstring(J, F, OP_GETPROP_S, fun->b->string);\n\t\temit(J, F, OP_ROT2);\n\t\tbreak;\n\tcase EXP_IDENTIFIER:\n\t\tif (!strcmp(fun->string, \"eval\")) {\n\t\t\tceval(J, F, fun, args);\n\t\t\treturn;\n\t\t}\n\t\t/* fallthrough */\n\tdefault:\n\t\tcexp(J, F, fun);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\t}\n\tn = cargs(J, F, args);\n\temit(J, F, OP_CALL);\n\temitarg(J, F, n);\n}\n\nstatic void cexp(JF, js_Ast *exp)\n{\n\tint then, end;\n\tint n;\n\n\tswitch (exp->type) {\n\tcase EXP_STRING:\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_STRING, exp->string);\n\t\tbreak;\n\tcase EXP_NUMBER:\n\t\temitline(J, F, exp);\n\t\temitnumber(J, F, exp->number);\n\t\tbreak;\n\tcase EXP_UNDEF:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\tcase EXP_NULL:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NULL);\n\t\tbreak;\n\tcase EXP_TRUE:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_TRUE);\n\t\tbreak;\n\tcase EXP_FALSE:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_FALSE);\n\t\tbreak;\n\tcase EXP_THIS:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_THIS);\n\t\tbreak;\n\n\tcase EXP_REGEXP:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEWREGEXP);\n\t\temitarg(J, F, addstring(J, F, exp->string));\n\t\temitarg(J, F, exp->number);\n\t\tbreak;\n\n\tcase EXP_OBJECT:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEWOBJECT);\n\t\tcobject(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_ARRAY:\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEWARRAY);\n\t\tcarray(J, F, exp->a);\n\t\tbreak;\n\n\tcase EXP_FUN:\n\t\temitline(J, F, exp);\n\t\temitfunction(J, F, newfun(J, exp->line, exp->a, exp->b, exp->c, 0, F->strict));\n\t\tbreak;\n\n\tcase EXP_IDENTIFIER:\n\t\temitline(J, F, exp);\n\t\temitlocal(J, F, OP_GETLOCAL, OP_GETVAR, exp);\n\t\tbreak;\n\n\tcase EXP_INDEX:\n\t\tcexp(J, F, exp->a);\n\t\tcexp(J, F, exp->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_GETPROP);\n\t\tbreak;\n\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temitstring(J, F, OP_GETPROP_S, exp->b->string);\n\t\tbreak;\n\n\tcase EXP_CALL:\n\t\tccall(J, F, exp->a, exp->b);\n\t\tbreak;\n\n\tcase EXP_NEW:\n\t\tcexp(J, F, exp->a);\n\t\tn = cargs(J, F, exp->b);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_NEW);\n\t\temitarg(J, F, n);\n\t\tbreak;\n\n\tcase EXP_DELETE:\n\t\tcdelete(J, F, exp);\n\t\tbreak;\n\n\tcase EXP_PREINC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_INC);\n\t\tcassignop2(J, F, exp->a, 0);\n\t\tbreak;\n\n\tcase EXP_PREDEC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DEC);\n\t\tcassignop2(J, F, exp->a, 0);\n\t\tbreak;\n\n\tcase EXP_POSTINC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POSTINC);\n\t\tcassignop2(J, F, exp->a, 1);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\n\tcase EXP_POSTDEC:\n\t\tcassignop1(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POSTDEC);\n\t\tcassignop2(J, F, exp->a, 1);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\n\tcase EXP_VOID:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POP);\n\t\temit(J, F, OP_UNDEF);\n\t\tbreak;\n\n\tcase EXP_TYPEOF: ctypeof(J, F, exp); break;\n\tcase EXP_POS: cunary(J, F, exp, OP_POS); break;\n\tcase EXP_NEG: cunary(J, F, exp, OP_NEG); break;\n\tcase EXP_BITNOT: cunary(J, F, exp, OP_BITNOT); break;\n\tcase EXP_LOGNOT: cunary(J, F, exp, OP_LOGNOT); break;\n\n\tcase EXP_BITOR: cbinary(J, F, exp, OP_BITOR); break;\n\tcase EXP_BITXOR: cbinary(J, F, exp, OP_BITXOR); break;\n\tcase EXP_BITAND: cbinary(J, F, exp, OP_BITAND); break;\n\tcase EXP_EQ: cbinary(J, F, exp, OP_EQ); break;\n\tcase EXP_NE: cbinary(J, F, exp, OP_NE); break;\n\tcase EXP_STRICTEQ: cbinary(J, F, exp, OP_STRICTEQ); break;\n\tcase EXP_STRICTNE: cbinary(J, F, exp, OP_STRICTNE); break;\n\tcase EXP_LT: cbinary(J, F, exp, OP_LT); break;\n\tcase EXP_GT: cbinary(J, F, exp, OP_GT); break;\n\tcase EXP_LE: cbinary(J, F, exp, OP_LE); break;\n\tcase EXP_GE: cbinary(J, F, exp, OP_GE); break;\n\tcase EXP_INSTANCEOF: cbinary(J, F, exp, OP_INSTANCEOF); break;\n\tcase EXP_IN: cbinary(J, F, exp, OP_IN); break;\n\tcase EXP_SHL: cbinary(J, F, exp, OP_SHL); break;\n\tcase EXP_SHR: cbinary(J, F, exp, OP_SHR); break;\n\tcase EXP_USHR: cbinary(J, F, exp, OP_USHR); break;\n\tcase EXP_ADD: cbinary(J, F, exp, OP_ADD); break;\n\tcase EXP_SUB: cbinary(J, F, exp, OP_SUB); break;\n\tcase EXP_MUL: cbinary(J, F, exp, OP_MUL); break;\n\tcase EXP_DIV: cbinary(J, F, exp, OP_DIV); break;\n\tcase EXP_MOD: cbinary(J, F, exp, OP_MOD); break;\n\n\tcase EXP_ASS: cassign(J, F, exp); break;\n\tcase EXP_ASS_MUL: cassignop(J, F, exp, OP_MUL); break;\n\tcase EXP_ASS_DIV: cassignop(J, F, exp, OP_DIV); break;\n\tcase EXP_ASS_MOD: cassignop(J, F, exp, OP_MOD); break;\n\tcase EXP_ASS_ADD: cassignop(J, F, exp, OP_ADD); break;\n\tcase EXP_ASS_SUB: cassignop(J, F, exp, OP_SUB); break;\n\tcase EXP_ASS_SHL: cassignop(J, F, exp, OP_SHL); break;\n\tcase EXP_ASS_SHR: cassignop(J, F, exp, OP_SHR); break;\n\tcase EXP_ASS_USHR: cassignop(J, F, exp, OP_USHR); break;\n\tcase EXP_ASS_BITAND: cassignop(J, F, exp, OP_BITAND); break;\n\tcase EXP_ASS_BITXOR: cassignop(J, F, exp, OP_BITXOR); break;\n\tcase EXP_ASS_BITOR: cassignop(J, F, exp, OP_BITOR); break;\n\n\tcase EXP_COMMA:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tbreak;\n\n\tcase EXP_LOGOR:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DUP);\n\t\tend = emitjump(J, F, OP_JTRUE);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tcase EXP_LOGAND:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\temit(J, F, OP_DUP);\n\t\tend = emitjump(J, F, OP_JFALSE);\n\t\temit(J, F, OP_POP);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tcase EXP_COND:\n\t\tcexp(J, F, exp->a);\n\t\temitline(J, F, exp);\n\t\tthen = emitjump(J, F, OP_JTRUE);\n\t\tcexp(J, F, exp->c);\n\t\tend = emitjump(J, F, OP_JUMP);\n\t\tlabel(J, F, then);\n\t\tcexp(J, F, exp->b);\n\t\tlabel(J, F, end);\n\t\tbreak;\n\n\tdefault:\n\t\tjsC_error(J, exp, \"unknown expression: (%s)\", jsP_aststring(exp->type));\n\t}\n}\n\n/* Patch break and continue statements */\n\nstatic void addjump(JF, enum js_AstType type, js_Ast *target, int inst)\n{\n\tjs_JumpList *jump = js_malloc(J, sizeof *jump);\n\tjump->type = type;\n\tjump->inst = inst;\n\tjump->next = target->jumps;\n\ttarget->jumps = jump;\n}\n\nstatic void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}\n\nstatic int isloop(enum js_AstType T)\n{\n\treturn T == STM_DO || T == STM_WHILE ||\n\t\tT == STM_FOR || T == STM_FOR_VAR ||\n\t\tT == STM_FOR_IN || T == STM_FOR_IN_VAR;\n}\n\nstatic int isfun(enum js_AstType T)\n{\n\treturn T == AST_FUNDEC || T == EXP_FUN || T == EXP_PROP_GET || T == EXP_PROP_SET;\n}\n\nstatic int matchlabel(js_Ast *node, const char *label)\n{\n\twhile (node && node->type == STM_LABEL) {\n\t\tif (!strcmp(node->a->string, label))\n\t\t\treturn 1;\n\t\tnode = node->parent;\n\t}\n\treturn 0;\n}\n\nstatic js_Ast *breaktarget(JF, js_Ast *node, const char *label)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\tbreak;\n\t\tif (!label) {\n\t\t\tif (isloop(node->type) || node->type == STM_SWITCH)\n\t\t\t\treturn node;\n\t\t} else {\n\t\t\tif (matchlabel(node->parent, label))\n\t\t\t\treturn node;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n\nstatic js_Ast *continuetarget(JF, js_Ast *node, const char *label)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\tbreak;\n\t\tif (isloop(node->type)) {\n\t\t\tif (!label)\n\t\t\t\treturn node;\n\t\t\telse if (matchlabel(node->parent, label))\n\t\t\t\treturn node;\n\t\t}\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n\nstatic js_Ast *returntarget(JF, js_Ast *node)\n{\n\twhile (node) {\n\t\tif (isfun(node->type))\n\t\t\treturn node;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}\n\n/* Emit code to rebalance stack and scopes during an abrupt exit */\n\nstatic void cexit(JF, enum js_AstType T, js_Ast *node, js_Ast *target)\n{\n\tjs_Ast *prev;\n\tdo {\n\t\tprev = node, node = node->parent;\n\t\tswitch (node->type) {\n\t\tdefault:\n\t\t\t/* impossible */\n\t\t\tbreak;\n\t\tcase STM_WITH:\n\t\t\temitline(J, F, node);\n\t\t\temit(J, F, OP_ENDWITH);\n\t\t\tbreak;\n\t\tcase STM_FOR_IN:\n\t\tcase STM_FOR_IN_VAR:\n\t\t\temitline(J, F, node);\n\t\t\t/* pop the iterator if leaving the loop */\n\t\t\tif (F->script) {\n\t\t\t\tif (T == STM_RETURN || T == STM_BREAK || (T == STM_CONTINUE && target != node)) {\n\t\t\t\t\t/* pop the iterator, save the return or exp value */\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_CONTINUE)\n\t\t\t\t\temit(J, F, OP_ROT2); /* put the iterator back on top */\n\t\t\t} else {\n\t\t\t\tif (T == STM_RETURN) {\n\t\t\t\t\t/* pop the iterator, save the return value */\n\t\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\t\temit(J, F, OP_POP);\n\t\t\t\t}\n\t\t\t\tif (T == STM_BREAK || (T == STM_CONTINUE && target != node))\n\t\t\t\t\temit(J, F, OP_POP); /* pop the iterator */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STM_TRY:\n\t\t\temitline(J, F, node);\n\t\t\t/* came from try block */\n\t\t\tif (prev == node->a) {\n\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\tif (node->d) cstm(J, F, node->d); /* finally */\n\t\t\t}\n\t\t\t/* came from catch block */\n\t\t\tif (prev == node->c) {\n\t\t\t\t/* ... with finally */\n\t\t\t\tif (node->d) {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t\temit(J, F, OP_ENDTRY);\n\t\t\t\t\tcstm(J, F, node->d); /* finally */\n\t\t\t\t} else {\n\t\t\t\t\temit(J, F, OP_ENDCATCH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (node != target);\n}\n\n/* Try/catch/finally */\n\nstatic void ctryfinally(JF, js_Ast *trystm, js_Ast *finallystm)\n{\n\tint L1;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tcstm(J, F, finallystm); /* inline finally block */\n\t\temit(J, F, OP_THROW); /* rethrow exception */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tcstm(J, F, finallystm);\n}\n\nstatic void ctrycatch(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm)\n{\n\tint L1, L2;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tcheckfutureword(J, F, catchvar);\n\t\tif (F->strict) {\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\tL2 = emitjump(J, F, OP_JUMP); /* skip past the try block */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L2);\n}\n\nstatic void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\t/* if we get here, we have caught an exception in the try block */\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\t/* if we get here, we have caught an exception in the catch block */\n\t\t\tcstm(J, F, finallystm); /* inline finally block */\n\t\t\temit(J, F, OP_THROW); /* rethrow exception */\n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\temit(J, F, OP_ENDTRY);\n\t\tL3 = emitjump(J, F, OP_JUMP); /* skip past the try block to the finally block */\n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}\n\n/* Switch */\n\nstatic void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\n\tcexp(J, F, ref);\n\n\t/* emit an if-else chain of tests for the case clause expressions */\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\temitline(J, F, clause);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\temitline(J, F, def);\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\n\t/* emit the case clause bodies */\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\n\tif (end)\n\t\tlabel(J, F, end);\n}\n\n/* Statements */\n\nstatic void cvarinit(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *var = list->a;\n\t\tif (var->b) {\n\t\t\tcexp(J, F, var->b);\n\t\t\temitline(J, F, var);\n\t\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, var->a);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cstm(JF, js_Ast *stm)\n{\n\tjs_Ast *target;\n\tint loop, cont, then, end;\n\n\temitline(J, F, stm);\n\n\tswitch (stm->type) {\n\tcase AST_FUNDEC:\n\t\tbreak;\n\n\tcase STM_BLOCK:\n\t\tcstmlist(J, F, stm->a);\n\t\tbreak;\n\n\tcase STM_EMPTY:\n\t\tif (F->script) {\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t\temit(J, F, OP_UNDEF);\n\t\t}\n\t\tbreak;\n\n\tcase STM_VAR:\n\t\tcvarinit(J, F, stm->a);\n\t\tbreak;\n\n\tcase STM_IF:\n\t\tif (stm->c) {\n\t\t\tcexp(J, F, stm->a);\n\t\t\temitline(J, F, stm);\n\t\t\tthen = emitjump(J, F, OP_JTRUE);\n\t\t\tcstm(J, F, stm->c);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JUMP);\n\t\t\tlabel(J, F, then);\n\t\t\tcstm(J, F, stm->b);\n\t\t\tlabel(J, F, end);\n\t\t} else {\n\t\t\tcexp(J, F, stm->a);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t\tcstm(J, F, stm->b);\n\t\t\tlabel(J, F, end);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DO:\n\t\tloop = here(J, F);\n\t\tcstm(J, F, stm->a);\n\t\tcont = here(J, F);\n\t\tcexp(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JTRUE, loop);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), cont);\n\t\tbreak;\n\n\tcase STM_WHILE:\n\t\tloop = here(J, F);\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\tend = emitjump(J, F, OP_JFALSE);\n\t\tcstm(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n\t\tbreak;\n\n\tcase STM_FOR:\n\tcase STM_FOR_VAR:\n\t\tif (stm->type == STM_FOR_VAR) {\n\t\t\tcvarinit(J, F, stm->a);\n\t\t} else {\n\t\t\tif (stm->a) {\n\t\t\t\tcexp(J, F, stm->a);\n\t\t\t\temit(J, F, OP_POP);\n\t\t\t}\n\t\t}\n\t\tloop = here(J, F);\n\t\tif (stm->b) {\n\t\t\tcexp(J, F, stm->b);\n\t\t\temitline(J, F, stm);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t} else {\n\t\t\tend = 0;\n\t\t}\n\t\tcstm(J, F, stm->d);\n\t\tcont = here(J, F);\n\t\tif (stm->c) {\n\t\t\tcexp(J, F, stm->c);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\temitline(J, F, stm);\n\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\tif (end)\n\t\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), cont);\n\t\tbreak;\n\n\tcase STM_FOR_IN:\n\tcase STM_FOR_IN_VAR:\n\t\tcexp(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_ITERATOR);\n\t\tloop = here(J, F);\n\t\t{\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_NEXTITER);\n\t\t\tend = emitjump(J, F, OP_JFALSE);\n\t\t\tcassignforin(J, F, stm);\n\t\t\tif (F->script) {\n\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t\tcstm(J, F, stm->c);\n\t\t\t\temit(J, F, OP_ROT2);\n\t\t\t} else {\n\t\t\t\tcstm(J, F, stm->c);\n\t\t\t}\n\t\t\temitline(J, F, stm);\n\t\t\temitjumpto(J, F, OP_JUMP, loop);\n\t\t}\n\t\tlabel(J, F, end);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), loop);\n\t\tbreak;\n\n\tcase STM_SWITCH:\n\t\tcswitch(J, F, stm->a, stm->b);\n\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n\t\tbreak;\n\n\tcase STM_LABEL:\n\t\tcstm(J, F, stm->b);\n\t\t/* skip consecutive labels */\n\t\twhile (stm->type == STM_LABEL)\n\t\t\tstm = stm->b;\n\t\t/* loops and switches have already been labelled */\n\t\tif (!isloop(stm->type) && stm->type != STM_SWITCH)\n\t\t\tlabeljumps(J, F, stm->jumps, here(J,F), 0);\n\t\tbreak;\n\n\tcase STM_BREAK:\n\t\tif (stm->a) {\n\t\t\tcheckfutureword(J, F, stm->a);\n\t\t\ttarget = breaktarget(J, F, stm->parent, stm->a->string);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"break label '%s' not found\", stm->a->string);\n\t\t} else {\n\t\t\ttarget = breaktarget(J, F, stm->parent, NULL);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"unlabelled break must be inside loop or switch\");\n\t\t}\n\t\tcexit(J, F, STM_BREAK, stm, target);\n\t\temitline(J, F, stm);\n\t\taddjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP));\n\t\tbreak;\n\n\tcase STM_CONTINUE:\n\t\tif (stm->a) {\n\t\t\tcheckfutureword(J, F, stm->a);\n\t\t\ttarget = continuetarget(J, F, stm->parent, stm->a->string);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"continue label '%s' not found\", stm->a->string);\n\t\t} else {\n\t\t\ttarget = continuetarget(J, F, stm->parent, NULL);\n\t\t\tif (!target)\n\t\t\t\tjsC_error(J, stm, \"continue must be inside loop\");\n\t\t}\n\t\tcexit(J, F, STM_CONTINUE, stm, target);\n\t\temitline(J, F, stm);\n\t\taddjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP));\n\t\tbreak;\n\n\tcase STM_RETURN:\n\t\tif (stm->a)\n\t\t\tcexp(J, F, stm->a);\n\t\telse\n\t\t\temit(J, F, OP_UNDEF);\n\t\ttarget = returntarget(J, F, stm->parent);\n\t\tif (!target)\n\t\t\tjsC_error(J, stm, \"return not in function\");\n\t\tcexit(J, F, STM_RETURN, stm, target);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_RETURN);\n\t\tbreak;\n\n\tcase STM_THROW:\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_THROW);\n\t\tbreak;\n\n\tcase STM_WITH:\n\t\tF->lightweight = 0;\n\t\tif (F->strict)\n\t\t\tjsC_error(J, stm->a, \"'with' statements are not allowed in strict mode\");\n\t\tcexp(J, F, stm->a);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_WITH);\n\t\tcstm(J, F, stm->b);\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_ENDWITH);\n\t\tbreak;\n\n\tcase STM_TRY:\n\t\temitline(J, F, stm);\n\t\tif (stm->b && stm->c) {\n\t\t\tF->lightweight = 0;\n\t\t\tif (stm->d)\n\t\t\t\tctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d);\n\t\t\telse\n\t\t\t\tctrycatch(J, F, stm->a, stm->b, stm->c);\n\t\t} else {\n\t\t\tctryfinally(J, F, stm->a, stm->d);\n\t\t}\n\t\tbreak;\n\n\tcase STM_DEBUGGER:\n\t\temitline(J, F, stm);\n\t\temit(J, F, OP_DEBUGGER);\n\t\tbreak;\n\n\tdefault:\n\t\tif (F->script) {\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t\tcexp(J, F, stm);\n\t\t} else {\n\t\t\tcexp(J, F, stm);\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void cstmlist(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tcstm(J, F, list->a);\n\t\tlist = list->b;\n\t}\n}\n\n/* Declarations and programs */\n\nstatic int listlength(js_Ast *list)\n{\n\tint n = 0;\n\twhile (list) ++n, list = list->b;\n\treturn n;\n}\n\nstatic void cparams(JF, js_Ast *list, js_Ast *fname)\n{\n\tF->numparams = listlength(list);\n\twhile (list) {\n\t\tcheckfutureword(J, F, list->a);\n\t\taddlocal(J, F, list->a, 0);\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cvardecs(JF, js_Ast *node)\n{\n\tif (node->type == AST_LIST) {\n\t\twhile (node) {\n\t\t\tcvardecs(J, F, node->a);\n\t\t\tnode = node->b;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (isfun(node->type))\n\t\treturn; /* stop at inner functions */\n\n\tif (node->type == EXP_VAR) {\n\t\tcheckfutureword(J, F, node->a);\n\t\taddlocal(J, F, node->a, 1);\n\t}\n\n\tif (node->a) cvardecs(J, F, node->a);\n\tif (node->b) cvardecs(J, F, node->b);\n\tif (node->c) cvardecs(J, F, node->c);\n\tif (node->d) cvardecs(J, F, node->d);\n}\n\nstatic void cfundecs(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *stm = list->a;\n\t\tif (stm->type == AST_FUNDEC) {\n\t\t\temitline(J, F, stm);\n\t\t\temitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_SETLOCAL);\n\t\t\temitarg(J, F, addlocal(J, F, stm->a, 0));\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n\nstatic void cfunbody(JF, js_Ast *name, js_Ast *params, js_Ast *body)\n{\n\tF->lightweight = 1;\n\tF->arguments = 0;\n\n\tif (F->script)\n\t\tF->lightweight = 0;\n\n\t/* Check if first statement is 'use strict': */\n\tif (body && body->type == AST_LIST && body->a && body->a->type == EXP_STRING)\n\t\tif (!strcmp(body->a->string, \"use strict\"))\n\t\t\tF->strict = 1;\n\n\tF->lastline = F->line;\n\n\tcparams(J, F, params, name);\n\n\tif (body) {\n\t\tcvardecs(J, F, body);\n\t\tcfundecs(J, F, body);\n\t}\n\n\tif (name) {\n\t\tcheckfutureword(J, F, name);\n\t\tif (findlocal(J, F, name->string) < 0) {\n\t\t\temit(J, F, OP_CURRENT);\n\t\t\temit(J, F, OP_SETLOCAL);\n\t\t\temitarg(J, F, addlocal(J, F, name, 0));\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t}\n\n\tif (F->script) {\n\t\temit(J, F, OP_UNDEF);\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_RETURN);\n\t} else {\n\t\tcstmlist(J, F, body);\n\t\temit(J, F, OP_UNDEF);\n\t\temit(J, F, OP_RETURN);\n\t}\n}\n\njs_Function *jsC_compilefunction(js_State *J, js_Ast *prog)\n{\n\treturn newfun(J, prog->line, prog->a, prog->b, prog->c, 0, J->default_strict);\n}\n\njs_Function *jsC_compilescript(js_State *J, js_Ast *prog, int default_strict)\n{\n\treturn newfun(J, prog ? prog->line : 0, NULL, NULL, prog, 1, default_strict);\n}\n"], "filenames": ["jscompile.c"], "buggy_code_start_loc": [1025], "buggy_code_end_loc": [1025], "fixing_code_start_loc": [1026], "fixing_code_end_loc": [1027], "type": "CWE-670", "message": "An issue was discovered in Artifex MuJS 1.0.5. jscompile.c can cause a denial of service (invalid stack-frame jump) because it lacks an ENDTRY opcode call.", "other": {"cve": {"id": "CVE-2019-11412", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-22T11:29:05.050", "lastModified": "2022-05-03T14:50:10.687", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Artifex MuJS 1.0.5. jscompile.c can cause a denial of service (invalid stack-frame jump) because it lacks an ENDTRY opcode call."}, {"lang": "es", "value": "Se ha descubierto un problema en Artifex MuJS versi\u00f3n 1.0.5. jscompile.c puede causar una denegaci\u00f3n de servicio (invalid stack-frame jump) porque carece de una llamada ENDTRY opcode."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:mujs:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "3FA24B50-E74E-4790-928D-DAD8CC042C09"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "http://www.ghostscript.com/cgi-bin/findgit.cgi?1e5479084bc9852854feb1ba9bf68b52cd127e02", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/108093", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://bugs.ghostscript.com/show_bug.cgi?id=700947", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Vendor Advisory"]}, {"url": "https://github.com/ccxvii/mujs/commit/1e5479084bc9852854feb1ba9bf68b52cd127e02", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3RQXMWEOWCGLOLFBQSXBM3MBN33T4I5H/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/67PMOZV4DLVL2KGU2SV724QL7Y4PKWKU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MFCRO74ORRIVWNVAX2MAMRY3THCTWLQI/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-52", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ccxvii/mujs/commit/1e5479084bc9852854feb1ba9bf68b52cd127e02"}}