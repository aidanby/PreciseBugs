{"buggy_code": ["/* radare - LGPL - Copyright 2009-2020 - pancake, maijin, thestr4ng3r */\n\n#include \"r_util.h\"\n#include \"r_anal.h\"\n\n#define VTABLE_BUFF_SIZE 10\n\n#define VTABLE_READ_ADDR_FUNC(fname, read_fname, sz) \\\n\tstatic bool fname(RAnal *anal, ut64 addr, ut64 *buf) {\\\n\t\tut8 tmp[sz];\\\n\t\tif (!anal->iob.read_at (anal->iob.io, addr, tmp, sz)) {\\\n\t\t\treturn false;\\\n\t\t}\\\n\t\t*buf = read_fname (tmp);\\\n\t\treturn true;\\\n\t}\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le8, r_read_le8, 1)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le16, r_read_le16, 2)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le32, r_read_le32, 4)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le64, r_read_le64, 8)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be8, r_read_be8, 1)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be16, r_read_be16, 2)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be32, r_read_be32, 4)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be64, r_read_be64, 8)\n\nR_API void r_anal_vtable_info_free(RVTableInfo *vtable) {\n\tif (!vtable) {\n\t\treturn;\n\t}\n\tr_vector_clear (&vtable->methods);\n\tfree (vtable);\n}\n\nR_API ut64 r_anal_vtable_info_get_size(RVTableContext *context, RVTableInfo *vtable) {\n\treturn (ut64)vtable->methods.len * context->word_size;\n}\n\nR_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {\n\tcontext->anal = anal;\n\tcontext->abi = anal->cxxabi;\n\tcontext->word_size = (ut8) (anal->config->bits / 8);\n\tconst bool is_arm = anal->cur->arch && r_str_startswith (anal->cur->arch, \"arm\");\n\tif (is_arm && context->word_size < 4) {\n\t\tcontext->word_size = 4;\n\t}\n\tconst bool be = anal->config->big_endian;\n\tswitch (context->word_size) {\n\tcase 1:\n\t\tcontext->read_addr = be? vtable_read_addr_be8 : vtable_read_addr_le8;\n\t\tbreak;\n\tcase 2:\n\t\tcontext->read_addr = be? vtable_read_addr_be16 : vtable_read_addr_le16;\n\t\tbreak;\n\tcase 4:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\tbreak;\n\tcase 8:\n\t\tcontext->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool vtable_addr_in_text_section(RVTableContext *context, ut64 curAddress) {\n\t//section of the curAddress\n\tRBinSection *value = context->anal->binb.get_vsect_at (context->anal->binb.bin, curAddress);\n\t//If the pointed value lies in .text section\n\treturn value && strstr (value->name, \"text\") && (value->perm & 1) != 0;\n}\n\nstatic bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\t//value at the current address\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\t//if the value is in text section\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}\n\nstatic bool vtable_section_can_contain_vtables(RBinSection *section) {\n\tif (section->is_segment) {\n\t\treturn false;\n\t}\n\treturn !strcmp (section->name, \".rodata\") ||\n\t\t!strcmp (section->name, \".rdata\") ||\n\t\t!strcmp (section->name, \".data.rel.ro\") ||\n\t\t!strcmp (section->name, \".data.rel.ro.local\") ||\n\t\tr_str_endswith (section->name, \"__const\");\n}\n\nstatic bool section_can_contain_rtti(RBinSection *section) {\n\tif (!section) {\n\t\treturn false;\n\t}\n\tif (section->is_data) {\n\t\treturn true;\n\t}\n\treturn !strcmp (section->name, \".data.rel.ro\") ||\n\t\t!strcmp (section->name, \".data.rel.ro.local\") ||\n\t\tr_str_endswith (section->name, \"__const\");\n}\n\nstatic bool vtable_is_addr_vtable_start_itanium(RVTableContext *context, RBinSection *section, ut64 curAddress) {\n\tut64 value;\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) { // Vtable beginning referenced from the code\n\t\treturn false;\n\t}\n\tif (!context->read_addr (context->anal, curAddress - context->word_size, &value)) { // get the RTTI pointer\n\t\treturn false;\n\t}\n\tRBinSection *rtti_section = context->anal->binb.get_vsect_at (context->anal->binb.bin, value);\n\tif (value && !section_can_contain_rtti (rtti_section)) { // RTTI ptr must point somewhere in the data section\n\t\treturn false;\n\t}\n\tif (!context->read_addr (context->anal, curAddress - 2 * context->word_size, &value)) { // Offset to top\n\t\treturn false;\n\t}\n\tif ((st32)value > 0) { // Offset to top has to be negative\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {\n\tRAnalRef *xref;\n\tRListIter *xrefIter;\n\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) {\n\t\treturn false;\n\t}\n\t// total xref's to curAddress\n\tRList *xrefs = r_anal_xrefs_get (context->anal, curAddress);\n\tif (r_list_empty (xrefs)) {\n\t\tr_list_free (xrefs);\n\t\treturn false;\n\t}\n\tr_list_foreach (xrefs, xrefIter, xref) {\n\t\t// section in which currenct xref lies\n\t\tif (vtable_addr_in_text_section (context, xref->addr)) {\n\t\t\tut8 buf[VTABLE_BUFF_SIZE];\n\t\t\tcontext->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));\n\n\t\t\tRAnalOp analop = {0};\n\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);\n\n\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV\n\t\t\t\t|| analop.type == R_ANAL_OP_TYPE_LEA) {\n\t\t\t\tr_list_free (xrefs);\n\t\t\t\tr_anal_op_fini (&analop);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tr_anal_op_fini (&analop);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\treturn false;\n}\n\nstatic bool vtable_is_addr_vtable_start(RVTableContext *context, RBinSection *section, ut64 curAddress) {\n\tif (context->abi == R_ANAL_CPP_ABI_MSVC) {\n\t\treturn vtable_is_addr_vtable_start_msvc (context, curAddress);\n\t}\n\tif (context->abi == R_ANAL_CPP_ABI_ITANIUM) {\n\t\treturn vtable_is_addr_vtable_start_itanium (context, section, curAddress);\n\t}\n\tr_return_val_if_reached (false);\n\treturn false;\n}\n\nR_API RVTableInfo *r_anal_vtable_parse_at(RVTableContext *context, ut64 addr) {\n\tut64 offset_to_top;\n\tif (!context->read_addr (context->anal, addr - 2 * context->word_size, &offset_to_top)) {\n\t\treturn NULL;\n\t}\n\n\tRVTableInfo *vtable = calloc (1, sizeof (RVTableInfo));\n\tif (!vtable) {\n\t\treturn NULL;\n\t}\n\n\tvtable->saddr = addr;\n\n\tr_vector_init (&vtable->methods, sizeof (RVTableMethodInfo), NULL, NULL);\n\n\tRVTableMethodInfo meth;\n\twhile (vtable_is_value_in_text_section (context, addr, &meth.addr)) {\n\t\tmeth.vtable_offset = addr - vtable->saddr;\n\t\tif (!r_vector_push (&vtable->methods, &meth)) {\n\t\t\tbreak;\n\t\t}\n\n\t\taddr += context->word_size;\n\n\t\t// a ref means the vtable has ended\n\t\tRList *ll = r_anal_xrefs_get (context->anal, addr);\n\t\tif (!r_list_empty (ll)) {\n\t\t\tr_list_free (ll);\n\t\t\tbreak;\n\t\t}\n\t\tr_list_free (ll);\n\t}\n\treturn vtable;\n}\n\nR_API RList *r_anal_vtable_search(RVTableContext *context) {\n\tRAnal *anal = context->anal;\n\tif (!anal) {\n\t\treturn NULL;\n\t}\n\n\tRList *vtables = r_list_newf ((RListFree)r_anal_vtable_info_free);\n\tif (!vtables) {\n\t\treturn NULL;\n\t}\n\n\tRList *sections = anal->binb.get_sections (anal->binb.bin);\n\tif (!sections) {\n\t\tr_list_free (vtables);\n\t\treturn NULL;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\n\tRListIter *iter;\n\tRBinSection *section;\n\tr_list_foreach (sections, iter, section) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!vtable_section_can_contain_vtables (section)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut64 startAddress = section->vaddr;\n\t\tut64 endAddress = startAddress + (section->vsize) - context->word_size;\n\t\tut64 ss = endAddress - startAddress;\n\t\tif (ss > ST32_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\twhile (startAddress <= endAddress) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!anal->iob.is_valid_offset (anal->iob.io, startAddress, 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (vtable_is_addr_vtable_start (context, section, startAddress)) {\n\t\t\t\tRVTableInfo *vtable = r_anal_vtable_parse_at (context, startAddress);\n\t\t\t\tif (vtable) {\n\t\t\t\t\tr_list_append (vtables, vtable);\n\t\t\t\t\tut64 size = r_anal_vtable_info_get_size (context, vtable);\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tstartAddress += size;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstartAddress += context->word_size;\n\t\t}\n\t}\n\n\tr_cons_break_pop ();\n\n\tif (r_list_empty (vtables)) {\n\t\t// stripped binary?\n\t\tr_list_free (vtables);\n\t\treturn NULL;\n\t}\n\treturn vtables;\n}\n\nR_API void r_anal_list_vtables(RAnal *anal, int rad) {\n\tRVTableContext context;\n\tr_anal_vtable_begin (anal, &context);\n\n\tconst char *noMethodName = \"No Name found\";\n\tRVTableMethodInfo *curMethod;\n\tRListIter *vtableIter;\n\tRVTableInfo *table;\n\n\tRList *vtables = r_anal_vtable_search (&context);\n\n\tif (rad == 'j') {\n\t\tPJ *pj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tpj_o (pj);\n\t\t\tpj_kN (pj, \"offset\", table->saddr);\n\t\t\tpj_ka (pj, \"methods\");\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kN (pj, \"offset\", curMethod->addr);\n\t\t\t\tpj_ks (pj, \"name\", r_str_get_fail (name, noMethodName));\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else if (rad == '*') {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tr_cons_printf (\"f vtable.0x%08\"PFMT64x\" %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\t   table->saddr,\n\t\t\t\t\t\t   r_anal_vtable_info_get_size (&context, table),\n\t\t\t\t\t\t   table->saddr);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", context.word_size, table->saddr + curMethod->vtable_offset);\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tif (name) {\n\t\t\t\t\tr_cons_printf (\"f %s=0x%08\"PFMT64x\"\\n\", name, curMethod->addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f method.virtual.0x%08\"PFMT64x\"=0x%08\"PFMT64x\"\\n\", curMethod->addr, curMethod->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tut64 vtableStartAddress = table->saddr;\n\t\t\tr_cons_printf (\"\\nVtable Found at 0x%08\"PFMT64x\"\\n\", vtableStartAddress);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" : %s\\n\", vtableStartAddress, r_str_get_fail (name, noMethodName));\n\t\t\t\tvtableStartAddress += context.word_size;\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (vtables);\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2009-2020 - pancake, maijin, thestr4ng3r */\n\n#include \"r_util.h\"\n#include \"r_anal.h\"\n\n#define VTABLE_BUFF_SIZE 10\n\n#define VTABLE_READ_ADDR_FUNC(fname, read_fname, sz) \\\n\tstatic bool fname(RAnal *anal, ut64 addr, ut64 *buf) {\\\n\t\tut8 tmp[sz];\\\n\t\tif (!anal->iob.read_at (anal->iob.io, addr, tmp, sz)) {\\\n\t\t\treturn false;\\\n\t\t}\\\n\t\t*buf = read_fname (tmp);\\\n\t\treturn true;\\\n\t}\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le8, r_read_le8, 1)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le16, r_read_le16, 2)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le32, r_read_le32, 4)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_le64, r_read_le64, 8)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be8, r_read_be8, 1)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be16, r_read_be16, 2)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be32, r_read_be32, 4)\nVTABLE_READ_ADDR_FUNC (vtable_read_addr_be64, r_read_be64, 8)\n\nR_API void r_anal_vtable_info_free(RVTableInfo *vtable) {\n\tif (!vtable) {\n\t\treturn;\n\t}\n\tr_vector_clear (&vtable->methods);\n\tfree (vtable);\n}\n\nR_API ut64 r_anal_vtable_info_get_size(RVTableContext *context, RVTableInfo *vtable) {\n\treturn (ut64)vtable->methods.len * context->word_size;\n}\n\nR_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {\n\tcontext->anal = anal;\n\tcontext->abi = anal->cxxabi;\n\tcontext->word_size = (ut8) (anal->config->bits / 8);\n\tconst bool is_arm = anal->cur->arch && r_str_startswith (anal->cur->arch, \"arm\");\n\tif (is_arm && context->word_size < 4) {\n\t\tcontext->word_size = 4;\n\t}\n\tconst bool be = anal->config->big_endian;\n\tswitch (context->word_size) {\n\tcase 1:\n\t\tcontext->read_addr = be? vtable_read_addr_be8 : vtable_read_addr_le8;\n\t\tbreak;\n\tcase 2:\n\t\tcontext->read_addr = be? vtable_read_addr_be16 : vtable_read_addr_le16;\n\t\tbreak;\n\tcase 4:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\tbreak;\n\tcase 8:\n\t\tcontext->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;\n\t\tbreak;\n\tdefault:\n\t\t// cant be null. assume 32bit \"->read_addr = NULL;\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool vtable_addr_in_text_section(RVTableContext *context, ut64 curAddress) {\n\t//section of the curAddress\n\tRBinSection *value = context->anal->binb.get_vsect_at (context->anal->binb.bin, curAddress);\n\t//If the pointed value lies in .text section\n\treturn value && strstr (value->name, \"text\") && (value->perm & 1) != 0;\n}\n\nstatic bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\t//value at the current address\n\tut64 curAddressValue = UT64_MAX;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\t//if the value is in text section\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}\n\nstatic bool vtable_section_can_contain_vtables(RBinSection *section) {\n\tif (section->is_segment) {\n\t\treturn false;\n\t}\n\treturn !strcmp (section->name, \".rodata\") ||\n\t\t!strcmp (section->name, \".rdata\") ||\n\t\t!strcmp (section->name, \".data.rel.ro\") ||\n\t\t!strcmp (section->name, \".data.rel.ro.local\") ||\n\t\tr_str_endswith (section->name, \"__const\");\n}\n\nstatic bool section_can_contain_rtti(RBinSection *section) {\n\tif (!section) {\n\t\treturn false;\n\t}\n\tif (section->is_data) {\n\t\treturn true;\n\t}\n\treturn !strcmp (section->name, \".data.rel.ro\") ||\n\t\t!strcmp (section->name, \".data.rel.ro.local\") ||\n\t\tr_str_endswith (section->name, \"__const\");\n}\n\nstatic bool vtable_is_addr_vtable_start_itanium(RVTableContext *context, RBinSection *section, ut64 curAddress) {\n\tut64 value;\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) { // Vtable beginning referenced from the code\n\t\treturn false;\n\t}\n\tif (!context->read_addr (context->anal, curAddress - context->word_size, &value)) { // get the RTTI pointer\n\t\treturn false;\n\t}\n\tRBinSection *rtti_section = context->anal->binb.get_vsect_at (context->anal->binb.bin, value);\n\tif (value && !section_can_contain_rtti (rtti_section)) { // RTTI ptr must point somewhere in the data section\n\t\treturn false;\n\t}\n\tif (!context->read_addr (context->anal, curAddress - 2 * context->word_size, &value)) { // Offset to top\n\t\treturn false;\n\t}\n\tif ((st32)value > 0) { // Offset to top has to be negative\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {\n\tut8 buf[VTABLE_BUFF_SIZE];\n\tRAnalRef *xref;\n\tRListIter *xrefIter;\n\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) {\n\t\treturn false;\n\t}\n\t// total xref's to curAddress\n\tRList *xrefs = r_anal_xrefs_get (context->anal, curAddress);\n\tif (r_list_empty (xrefs)) {\n\t\tr_list_free (xrefs);\n\t\treturn false;\n\t}\n\tr_list_foreach (xrefs, xrefIter, xref) {\n\t\t// section in which currenct xref lies\n\t\tif (vtable_addr_in_text_section (context, xref->addr)) {\n\t\t\tcontext->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof (buf));\n\t\t\tRAnalOp analop = {0};\n\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof (buf), R_ANAL_OP_MASK_BASIC);\n\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV || analop.type == R_ANAL_OP_TYPE_LEA) {\n\t\t\t\tr_list_free (xrefs);\n\t\t\t\tr_anal_op_fini (&analop);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_anal_op_fini (&analop);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\treturn false;\n}\n\nstatic bool vtable_is_addr_vtable_start(RVTableContext *context, RBinSection *section, ut64 curAddress) {\n\tif (context->abi == R_ANAL_CPP_ABI_MSVC) {\n\t\treturn vtable_is_addr_vtable_start_msvc (context, curAddress);\n\t}\n\tif (context->abi == R_ANAL_CPP_ABI_ITANIUM) {\n\t\treturn vtable_is_addr_vtable_start_itanium (context, section, curAddress);\n\t}\n\tr_return_val_if_reached (false);\n\treturn false;\n}\n\nR_API RVTableInfo *r_anal_vtable_parse_at(RVTableContext *context, ut64 addr) {\n\tut64 offset_to_top;\n\tif (!context->read_addr (context->anal, addr - 2 * context->word_size, &offset_to_top)) {\n\t\treturn NULL;\n\t}\n\n\tRVTableInfo *vtable = calloc (1, sizeof (RVTableInfo));\n\tif (!vtable) {\n\t\treturn NULL;\n\t}\n\n\tvtable->saddr = addr;\n\n\tr_vector_init (&vtable->methods, sizeof (RVTableMethodInfo), NULL, NULL);\n\n\tRVTableMethodInfo meth;\n\twhile (vtable_is_value_in_text_section (context, addr, &meth.addr)) {\n\t\tmeth.vtable_offset = addr - vtable->saddr;\n\t\tif (!r_vector_push (&vtable->methods, &meth)) {\n\t\t\tbreak;\n\t\t}\n\n\t\taddr += context->word_size;\n\n\t\t// a ref means the vtable has ended\n\t\tRList *ll = r_anal_xrefs_get (context->anal, addr);\n\t\tif (!r_list_empty (ll)) {\n\t\t\tr_list_free (ll);\n\t\t\tbreak;\n\t\t}\n\t\tr_list_free (ll);\n\t}\n\treturn vtable;\n}\n\nR_API RList *r_anal_vtable_search(RVTableContext *context) {\n\tRAnal *anal = context->anal;\n\tif (!anal) {\n\t\treturn NULL;\n\t}\n\n\tRList *vtables = r_list_newf ((RListFree)r_anal_vtable_info_free);\n\tif (!vtables) {\n\t\treturn NULL;\n\t}\n\n\tRList *sections = anal->binb.get_sections (anal->binb.bin);\n\tif (!sections) {\n\t\tr_list_free (vtables);\n\t\treturn NULL;\n\t}\n\n\tr_cons_break_push (NULL, NULL);\n\n\tRListIter *iter;\n\tRBinSection *section;\n\tr_list_foreach (sections, iter, section) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!vtable_section_can_contain_vtables (section)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut64 startAddress = section->vaddr;\n\t\tut64 endAddress = startAddress + (section->vsize) - context->word_size;\n\t\tut64 ss = endAddress - startAddress;\n\t\tif (ss > ST32_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\twhile (startAddress <= endAddress) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!anal->iob.is_valid_offset (anal->iob.io, startAddress, 0)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (vtable_is_addr_vtable_start (context, section, startAddress)) {\n\t\t\t\tRVTableInfo *vtable = r_anal_vtable_parse_at (context, startAddress);\n\t\t\t\tif (vtable) {\n\t\t\t\t\tr_list_append (vtables, vtable);\n\t\t\t\t\tut64 size = r_anal_vtable_info_get_size (context, vtable);\n\t\t\t\t\tif (size > 0) {\n\t\t\t\t\t\tstartAddress += size;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstartAddress += context->word_size;\n\t\t}\n\t}\n\n\tr_cons_break_pop ();\n\n\tif (r_list_empty (vtables)) {\n\t\t// stripped binary?\n\t\tr_list_free (vtables);\n\t\treturn NULL;\n\t}\n\treturn vtables;\n}\n\nR_API void r_anal_list_vtables(RAnal *anal, int rad) {\n\tRVTableContext context = {0};\n\tr_anal_vtable_begin (anal, &context);\n\n\tconst char *noMethodName = \"No Name found\";\n\tRVTableMethodInfo *curMethod;\n\tRListIter *vtableIter;\n\tRVTableInfo *table;\n\n\tRList *vtables = r_anal_vtable_search (&context);\n\n\tif (rad == 'j') {\n\t\tPJ *pj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tpj_o (pj);\n\t\t\tpj_kN (pj, \"offset\", table->saddr);\n\t\t\tpj_ka (pj, \"methods\");\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kN (pj, \"offset\", curMethod->addr);\n\t\t\t\tpj_ks (pj, \"name\", r_str_get_fail (name, noMethodName));\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t} else if (rad == '*') {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tr_cons_printf (\"f vtable.0x%08\"PFMT64x\" %\"PFMT64d\" @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\t\t   table->saddr,\n\t\t\t\t\t\t   r_anal_vtable_info_get_size (&context, table),\n\t\t\t\t\t\t   table->saddr);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", context.word_size, table->saddr + curMethod->vtable_offset);\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tif (name) {\n\t\t\t\t\tr_cons_printf (\"f %s=0x%08\"PFMT64x\"\\n\", name, curMethod->addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"f method.virtual.0x%08\"PFMT64x\"=0x%08\"PFMT64x\"\\n\", curMethod->addr, curMethod->addr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr_list_foreach (vtables, vtableIter, table) {\n\t\t\tut64 vtableStartAddress = table->saddr;\n\t\t\tr_cons_printf (\"\\nVtable Found at 0x%08\"PFMT64x\"\\n\", vtableStartAddress);\n\t\t\tr_vector_foreach (&table->methods, curMethod) {\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (anal, curMethod->addr, 0);\n\t\t\t\tconst char *const name = fcn ? fcn->name : NULL;\n\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" : %s\\n\", vtableStartAddress, r_str_get_fail (name, noMethodName));\n\t\t\t\tvtableStartAddress += context.word_size;\n\t\t\t}\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\tr_list_free (vtables);\n}\n"], "filenames": ["libr/anal/vtable.c"], "buggy_code_start_loc": [60], "buggy_code_end_loc": [290], "fixing_code_start_loc": [61], "fixing_code_end_loc": [288], "type": "CWE-824", "message": "Access of Uninitialized Pointer in GitHub repository radareorg/radare2 prior to 5.7.0.", "other": {"cve": {"id": "CVE-2022-1809", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-21T23:16:11.963", "lastModified": "2022-06-03T14:46:29.000", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Access of Uninitialized Pointer in GitHub repository radareorg/radare2 prior to 5.7.0."}, {"lang": "es", "value": "Un Acceso de Puntero no Inicializado en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.7.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.0", "matchCriteriaId": "A79BEA4D-5D5F-4593-B2CA-0CA4C22C1C0A"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/919e3ac1a13f753c73e7a8e8d8bb4a143218732d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0730a95e-c485-4ff2-9a5d-bb3abfda0b17", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/919e3ac1a13f753c73e7a8e8d8bb4a143218732d"}}