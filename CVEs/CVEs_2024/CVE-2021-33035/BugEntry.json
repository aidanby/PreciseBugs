{"buggy_code": ["/**************************************************************\n * \n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n * \n *************************************************************/\n\n\n\n// MARKER(update_precomp.py): autogen include statement, do not remove\n#include \"precompiled_connectivity.hxx\"\n#include \"dbase/DTable.hxx\"\n#include <com/sun/star/sdbc/ColumnValue.hpp>\n#include <com/sun/star/sdbc/DataType.hpp>\n#include <com/sun/star/ucb/XContentAccess.hpp>\n#include <com/sun/star/sdbc/XRow.hpp>\n#include <svl/converter.hxx>\n#include \"dbase/DConnection.hxx\"\n#include \"dbase/DColumns.hxx\"\n#include <osl/thread.h>\n#include <tools/config.hxx>\n#include \"dbase/DIndex.hxx\"\n#include \"dbase/DIndexes.hxx\"\n//#include \"file/FDriver.hxx\"\n#include <comphelper/sequence.hxx>\n#include <svl/zforlist.hxx>\n#include <unotools/syslocale.hxx>\n#include <rtl/math.hxx>\n#include <stdio.h>\t\t//sprintf\n#include <ucbhelper/content.hxx>\n#include <comphelper/extract.hxx>\n#include <connectivity/dbexception.hxx>\n#include <connectivity/dbconversion.hxx>\n#include <com/sun/star/lang/DisposedException.hpp>\n#include <comphelper/property.hxx>\n//#include <unotools/calendarwrapper.hxx>\n#include <unotools/tempfile.hxx>\n#include <unotools/ucbhelper.hxx>\n#include <comphelper/types.hxx>\n#include <cppuhelper/exc_hlp.hxx>\n#include \"connectivity/PColumn.hxx\"\n#include \"connectivity/dbtools.hxx\"\n#include \"connectivity/FValue.hxx\"\n#include \"connectivity/dbconversion.hxx\"\n#include \"resource/dbase_res.hrc\"\n#include <rtl/logfile.hxx>\n\n#include <algorithm>\n\nusing namespace ::comphelper;\nusing namespace connectivity;\nusing namespace connectivity::sdbcx;\nusing namespace connectivity::dbase;\nusing namespace connectivity::file;\nusing namespace ::ucbhelper;\nusing namespace ::utl;\nusing namespace ::cppu;\nusing namespace ::dbtools;\nusing namespace ::com::sun::star::uno;\nusing namespace ::com::sun::star::ucb;\nusing namespace ::com::sun::star::beans;\nusing namespace ::com::sun::star::sdbcx;\nusing namespace ::com::sun::star::sdbc;\nusing namespace ::com::sun::star::container;\nusing namespace ::com::sun::star::lang;\nusing namespace ::com::sun::star::i18n;\n\n// stored as the Field Descriptor terminator\n#define FIELD_DESCRIPTOR_TERMINATOR 0x0D\n#define DBF_EOL                     0x1A\n\nnamespace \n{\nsal_Int32 lcl_getFileSize(SvStream& _rStream)\n{\n    sal_Int32 nFileSize = 0;\n    _rStream.Seek(STREAM_SEEK_TO_END);\n    _rStream.SeekRel(-1);\n    char cEOL;\n    _rStream >> cEOL;\n    nFileSize = _rStream.Tell();\n    if ( cEOL == DBF_EOL )\n        nFileSize -= 1;\n    return nFileSize;\n}\n/**\n\tcalculates the Julian date\n*/\nvoid lcl_CalcJulDate(sal_Int32& _nJulianDate,sal_Int32& _nJulianTime,const com::sun::star::util::DateTime _aDateTime)\n{\n    com::sun::star::util::DateTime aDateTime = _aDateTime;\n\t// weird: months fix \n    if (aDateTime.Month > 12)\n\t{\n\t    aDateTime.Month--;\n\t    sal_uInt16 delta = _aDateTime.Month / 12;\n\t    aDateTime.Year += delta;\n\t    aDateTime.Month -= delta * 12;\n\t    aDateTime.Month++;\n\t}\n\n\t_nJulianTime = ((aDateTime.Hours*3600000)+(aDateTime.Minutes*60000)+(aDateTime.Seconds*1000)+(aDateTime.HundredthSeconds*10));\n\t/* conversion factors */\n\tsal_uInt16 iy0;\n\tsal_uInt16 im0;\n\tif ( aDateTime.Month <= 2 )\n\t{\n\t\tiy0 = aDateTime.Year - 1;\n\t\tim0 = aDateTime.Month + 12;\n\t}\n\telse\n\t{\n\t\tiy0 = aDateTime.Year;\n\t\tim0 = aDateTime.Month;\n\t}\n\tsal_Int32 ia = iy0 / 100;\n\tsal_Int32 ib = 2 - ia + (ia >> 2);\n\t/* calculate julian date\t*/\n\tif ( aDateTime.Year <= 0 ) \n    {\n\t\t_nJulianDate = (sal_Int32) ((365.25 * iy0) - 0.75)\n\t\t\t+ (sal_Int32) (30.6001 * (im0 + 1) )\n\t\t\t+ aDateTime.Day + 1720994;\n\t} // if ( _aDateTime.Year <= 0 ) \n    else \n    {\n\t\t_nJulianDate = static_cast<sal_Int32>( ((365.25 * iy0) \n\t\t\t+ (sal_Int32) (30.6001 * (im0 + 1))\n\t\t\t+ aDateTime.Day + 1720994));\n\t}\n    double JD = _nJulianDate + 0.5;\n    _nJulianDate = (sal_Int32)( JD + 0.5);\n    const double gyr = aDateTime.Year + (0.01 * aDateTime.Month) + (0.0001 * aDateTime.Day);\n\tif ( gyr >= 1582.1015 )\t/* on or after 15 October 1582\t*/\n\t\t_nJulianDate += ib;\n}\n\n/**\n\tcalculates date time from the Julian Date\n*/\nvoid lcl_CalDate(sal_Int32 _nJulianDate,sal_Int32 _nJulianTime,com::sun::star::util::DateTime& _rDateTime)\n{\n    if ( _nJulianDate )\n    {\n        sal_Int32 ialp;\n\t    sal_Int32 ka = _nJulianDate;\n\t    if ( _nJulianDate >= 2299161 )\n\t    {\n\t\t    ialp = (sal_Int32)( ((double) _nJulianDate - 1867216.25 ) / ( 36524.25 ));\n\t\t    ka = _nJulianDate + 1 + ialp - ( ialp >> 2 );\n\t    }\n\t    sal_Int32 kb = ka + 1524;\n\t    sal_Int32 kc =  (sal_Int32) ( ((double) kb - 122.1 ) / 365.25 );\n\t    sal_Int32 kd = (sal_Int32) ((double) kc * 365.25);\n\t    sal_Int32 ke = (sal_Int32) ((double) ( kb - kd ) / 30.6001 );\n\t    _rDateTime.Day = static_cast<sal_uInt16>(kb - kd - ((sal_Int32) ( (double) ke * 30.6001 )));\n\t    if ( ke > 13 )\n\t\t    _rDateTime.Month = static_cast<sal_uInt16>(ke - 13);\n\t    else\n\t\t    _rDateTime.Month = static_cast<sal_uInt16>(ke - 1);\n\t    if ( (_rDateTime.Month == 2) && (_rDateTime.Day > 28) )\n\t\t    _rDateTime.Day = 29;\n\t    if ( (_rDateTime.Month == 2) && (_rDateTime.Day == 29) && (ke == 3) )\n\t\t    _rDateTime.Year = static_cast<sal_uInt16>(kc - 4716);\n\t    else if ( _rDateTime.Month > 2 )\n\t\t    _rDateTime.Year = static_cast<sal_uInt16>(kc - 4716);\n\t    else\n\t\t    _rDateTime.Year = static_cast<sal_uInt16>(kc - 4715);\n    } // if ( _nJulianDate )\n\n    if ( _nJulianTime )\n    {\n        double d_s = _nJulianTime / 1000;\n        double d_m = d_s / 60;\n        double d_h  = d_m / 60;\n        _rDateTime.Hours = (sal_uInt16) (d_h);\n\t    _rDateTime.Minutes = (sal_uInt16) d_m;\t\t\t// integer _aDateTime.Minutes\n\t    //// weird: time fix\n     //   int test = (_rDateTime.Hours % 3) * 100 + _rDateTime.Minutes;\n\t    //int test_tbl[] = {0, 1, 2, 11, 12, 13, 22, 23, 24, 25, 34, 35, 36,\n\t    //\t45, 46, 47, 56, 57, 58, 107, 108, 109, 110, 119, 120, 121,\n\t    //\t130, 131, 132, 141, 142, 143, 152, 153, 154, 155, 204, 205,\n\t    //\t206, 215, 216, 217, 226, 227, 228, 237, 238, 239, 240, 249,\n\t    //\t250, 251};\n     //   for (int i = 0; i < sizeof(test_tbl)/sizeof(test_tbl[0]); i++)\n\t    //{\n\t    //    if (test == test_tbl[i])\n\t    //    {\n\t    //\t// frac += 0.000012;\n\t    //\t    //d_hour = frac * 24.0;\n\t    //\t    _rDateTime.Hours = (sal_uInt16)d_hour;\n\t    //\t    d_minute = (d_hour - (double)_rDateTime.Hours) * 60.0;\n\t    //\t    _rDateTime.Minutes = (sal_uInt16)d_minute;\n\t    //\t    break;\n\t    //    }\n     //   }\n\n\t    _rDateTime.Seconds = static_cast<sal_uInt16>(( d_m - (double) _rDateTime.Minutes ) * 60.0);\n    }\n}\n\n}\n\n// -------------------------------------------------------------------------\nvoid ODbaseTable::readHeader()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::readHeader\" );\n\tOSL_ENSURE(m_pFileStream,\"No Stream available!\");\n\tif(!m_pFileStream)\n\t\treturn;\n\tm_pFileStream->RefreshBuffer(); // sicherstellen, dass die Kopfinformationen tatsaechlich neu gelesen werden\n\tm_pFileStream->Seek(STREAM_SEEK_TO_BEGIN);\n\n\tsal_uInt8 nType=0;\n\t(*m_pFileStream) >> nType;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\n\tm_pFileStream->Read((char*)(&m_aHeader.db_aedat), 3*sizeof(sal_uInt8));\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\t(*m_pFileStream) >> m_aHeader.db_anz;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\t(*m_pFileStream) >> m_aHeader.db_kopf;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\t(*m_pFileStream) >> m_aHeader.db_slng;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\tm_pFileStream->Read((char*)(&m_aHeader.db_frei), 20*sizeof(sal_uInt8));\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\n    if ( ( ( m_aHeader.db_kopf - 1 ) / 32 - 1 ) <= 0 ) // anzahl felder\n\t{\n\t\t// no dbase file\n\t\tthrowInvalidDbaseFormat();\n\t}\n\telse\n\t{\n\t\t// Konsistenzpruefung des Header:\n\t\tm_aHeader.db_typ = (DBFType)nType;\n\t\tswitch (m_aHeader.db_typ)\n\t\t{\n\t\t\tcase dBaseIII:\n\t\t\tcase dBaseIV:\n\t\t\tcase dBaseV:\n            case VisualFoxPro:\n            case VisualFoxProAuto:\n\t\t\tcase dBaseFS:\n\t\t\tcase dBaseFSMemo:\n\t\t\tcase dBaseIVMemoSQL:\n\t\t\tcase dBaseIIIMemo:\n\t\t\tcase FoxProMemo:\n\t\t\t\tm_pFileStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);\n                if ( m_aHeader.db_frei[17] != 0x00 \n                    && !m_aHeader.db_frei[18] && !m_aHeader.db_frei[19] && getConnection()->isTextEncodingDefaulted() )\n                {\n                    switch(m_aHeader.db_frei[17])\n                    {\n                        case 0x01: m_eEncoding = RTL_TEXTENCODING_IBM_437; break; \t    // DOS USA\tcode page 437\n                        case 0x02: m_eEncoding = RTL_TEXTENCODING_IBM_850; break; \t    // DOS Multilingual\tcode page 850\n                        case 0x03: m_eEncoding = RTL_TEXTENCODING_MS_1252; break; \t    // Windows ANSI\tcode page 1252\n                        case 0x04: m_eEncoding = RTL_TEXTENCODING_APPLE_ROMAN; break; \t// Standard Macintosh\n                        case 0x64: m_eEncoding = RTL_TEXTENCODING_IBM_852; break; \t    // EE MS-DOS\tcode page 852\n                        case 0x65: m_eEncoding = RTL_TEXTENCODING_IBM_865; break; \t    // Nordic MS-DOS\tcode page 865\n                        case 0x66: m_eEncoding = RTL_TEXTENCODING_IBM_866; break; \t    // Russian MS-DOS\tcode page 866\n                        case 0x67: m_eEncoding = RTL_TEXTENCODING_IBM_861; break; \t    // Icelandic MS-DOS\n                        //case 0x68: m_eEncoding = ; break; \t// Kamenicky (Czech) MS-DOS\n                        //case 0x69: m_eEncoding = ; break; \t// Mazovia (Polish) MS-DOS\n                        case 0x6A: m_eEncoding = RTL_TEXTENCODING_IBM_737; break; \t    // Greek MS-DOS (437G)\n                        case 0x6B: m_eEncoding = RTL_TEXTENCODING_IBM_857; break; \t    // Turkish MS-DOS\n                        case 0x96: m_eEncoding = RTL_TEXTENCODING_APPLE_CYRILLIC; break; \t// Russian Macintosh\n                        case 0x97: m_eEncoding = RTL_TEXTENCODING_APPLE_CENTEURO; break; \t// Eastern European Macintosh\n                        case 0x98: m_eEncoding = RTL_TEXTENCODING_APPLE_GREEK; break; \t// Greek Macintosh\n                        case 0xC8: m_eEncoding = RTL_TEXTENCODING_MS_1250; break; \t    // Windows EE\tcode page 1250\n                        case 0xC9: m_eEncoding = RTL_TEXTENCODING_MS_1251; break; \t    // Russian Windows\n                        case 0xCA: m_eEncoding = RTL_TEXTENCODING_MS_1254; break; \t    // Turkish Windows\n                        case 0xCB: m_eEncoding = RTL_TEXTENCODING_MS_1253; break; \t    // Greek Windows\n                        default:\n                            break;\n                    }\n                }\n\t\t\t\tbreak;\n            case dBaseIVMemo:\n                m_pFileStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);\n                break;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tthrowInvalidDbaseFormat();\n\t\t\t}\n\t\t}\n\t}\n}\n// -------------------------------------------------------------------------\nvoid ODbaseTable::fillColumns()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::fillColumns\" );\n\tm_pFileStream->Seek(STREAM_SEEK_TO_BEGIN);\n\tm_pFileStream->Seek(32L);\n\n\tif(!m_aColumns.isValid())\n\t\tm_aColumns = new OSQLColumns();\n\telse\n\t\tm_aColumns->get().clear();\n\n\tm_aTypes.clear();\n\tm_aPrecisions.clear();\n\tm_aScales.clear();\n\n\t// Anzahl Felder:\n\tconst sal_Int32 nFieldCount = (m_aHeader.db_kopf - 1) / 32 - 1;\n\tOSL_ENSURE(nFieldCount,\"No columns in table!\");\n\n\tm_aColumns->get().reserve(nFieldCount);\n\tm_aTypes.reserve(nFieldCount);\n\tm_aPrecisions.reserve(nFieldCount);\n\tm_aScales.reserve(nFieldCount);\n\n\tString aStrFieldName;\n\taStrFieldName.AssignAscii(\"Column\");\n\t::rtl::OUString aTypeName;\n    static const ::rtl::OUString sVARCHAR(RTL_CONSTASCII_USTRINGPARAM(\"VARCHAR\"));\n\tconst sal_Bool bCase = getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers();\n    const bool bFoxPro = m_aHeader.db_typ == VisualFoxPro || m_aHeader.db_typ == VisualFoxProAuto || m_aHeader.db_typ == FoxProMemo;\n\n    sal_Int32 i = 0;\n\tfor (; i < nFieldCount; i++)\n\t{\n\t\tDBFColumn aDBFColumn;\n\t\tm_pFileStream->Read((char*)&aDBFColumn, sizeof(aDBFColumn));\n        if ( FIELD_DESCRIPTOR_TERMINATOR == aDBFColumn.db_fnm[0] ) // 0x0D stored as the Field Descriptor terminator.\n            break;\n\n        sal_Bool bIsRowVersion = bFoxPro && ( aDBFColumn.db_frei2[0] & 0x01 ) == 0x01;\n        //if ( bFoxPro && ( aDBFColumn.db_frei2[0] & 0x01 ) == 0x01 ) // system column not visible to user\n        //    continue;\n\t\tconst String aColumnName((const char *)aDBFColumn.db_fnm,m_eEncoding);\n\n        m_aRealFieldLengths.push_back(aDBFColumn.db_flng);\n\t\tsal_Int32 nPrecision = aDBFColumn.db_flng;\n\t\tsal_Int32 eType;\n        sal_Bool bIsCurrency = sal_False;\n        \n        char cType[2];\n        cType[0] = aDBFColumn.db_typ;\n        cType[1] = 0;\n        aTypeName = ::rtl::OUString::createFromAscii(cType);\nOSL_TRACE(\"column type: %c\",aDBFColumn.db_typ);\n\n\t\tswitch (aDBFColumn.db_typ)\n\t\t{\n\t\t\tcase 'C':\n\t\t\t\teType = DataType::VARCHAR;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"VARCHAR\"));\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DECIMAL\"));\n\t\t\tcase 'N':\n                if ( aDBFColumn.db_typ == 'N' )\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"NUMERIC\"));\n\t\t\t\teType = DataType::DECIMAL;\n\n\t\t\t\t// Bei numerischen Feldern werden zwei Zeichen mehr geschrieben, als die Precision der Spaltenbeschreibung eigentlich\n\t\t\t\t// angibt, um Platz fuer das eventuelle Vorzeichen und das Komma zu haben. Das muss ich jetzt aber wieder rausrechnen.\n\t\t\t\tnPrecision = SvDbaseConverter::ConvertPrecisionToOdbc(nPrecision,aDBFColumn.db_dez);\n\t\t\t\t\t// leider gilt das eben Gesagte nicht fuer aeltere Versionen ....\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\teType = DataType::BIT;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"BOOLEAN\"));\n\t\t\t\tbreak;\n            case 'Y':\n                bIsCurrency = sal_True;\n\t\t\t\teType = DataType::DOUBLE;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DOUBLE\"));\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\teType = DataType::DATE;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DATE\"));\n\t\t\t\tbreak;\n            case 'T':\n\t\t\t\teType = DataType::TIMESTAMP;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"TIMESTAMP\"));\n\t\t\t\tbreak;\n            case 'I':\n\t\t\t\teType = DataType::INTEGER;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"INTEGER\"));\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n                if ( bFoxPro && ( aDBFColumn.db_frei2[0] & 0x04 ) == 0x04 )\n                {\n\t\t\t\t    eType = DataType::LONGVARBINARY;\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARBINARY\"));\n                }\n                else\n                {\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARCHAR\"));\n                    eType = DataType::LONGVARCHAR;\n                }\n\t\t\t\tnPrecision = 2147483647;\n\t\t\t\tbreak;\n            case 'P':\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARBINARY\"));\n\t\t\t\teType = DataType::LONGVARBINARY;\n\t\t\t\tnPrecision = 2147483647;\n\t\t\t\tbreak;\n            case '0':\n            case 'B':\n                if ( m_aHeader.db_typ == VisualFoxPro || m_aHeader.db_typ == VisualFoxProAuto )\n                {\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DOUBLE\"));\n                    eType = DataType::DOUBLE;\n                }\n                else\n                {\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARBINARY\"));\n                    eType = DataType::LONGVARBINARY;\n\t\t\t\t    nPrecision = 2147483647;\n                }\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teType = DataType::OTHER;\n\t\t}\n\n\t\tm_aTypes.push_back(eType);\n\t\tm_aPrecisions.push_back(nPrecision);\n\t\tm_aScales.push_back(aDBFColumn.db_dez);\n\n\t\tReference< XPropertySet> xCol = new sdbcx::OColumn(aColumnName,\n\t\t\t\t\t\t\t\t\t\t\t\t\taTypeName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t::rtl::OUString(),\n                                                    ::rtl::OUString(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tColumnValue::NULLABLE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnPrecision,\n\t\t\t\t\t\t\t\t\t\t\t\t\taDBFColumn.db_dez,\n\t\t\t\t\t\t\t\t\t\t\t\t\teType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsal_False,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbIsRowVersion,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbIsCurrency,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbCase);\n\t\tm_aColumns->get().push_back(xCol);\n\t} // for (; i < nFieldCount; i++)\n    OSL_ENSURE(i,\"No columns in table!\");\n}\n// -------------------------------------------------------------------------\nODbaseTable::ODbaseTable(sdbcx::OCollection* _pTables,ODbaseConnection* _pConnection)\n\t\t:ODbaseTable_BASE(_pTables,_pConnection)\n\t\t,m_pMemoStream(NULL)\n\t\t,m_bWriteableMemo(sal_False)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ODbaseTable\" );\n\t// initialize the header\n\tm_aHeader.db_typ\t= dBaseIII;\n\tm_aHeader.db_anz\t= 0;\n\tm_aHeader.db_kopf\t= 0;\n\tm_aHeader.db_slng\t= 0;\n    m_eEncoding = getConnection()->getTextEncoding();\n}\n// -------------------------------------------------------------------------\nODbaseTable::ODbaseTable(sdbcx::OCollection* _pTables,ODbaseConnection* _pConnection,\n\t\t\t\t\tconst ::rtl::OUString& _Name,\n\t\t\t\t\tconst ::rtl::OUString& _Type,\n\t\t\t\t\tconst ::rtl::OUString& _Description ,\n\t\t\t\t\tconst ::rtl::OUString& _SchemaName,\n\t\t\t\t\tconst ::rtl::OUString& _CatalogName\n\t\t\t\t) : ODbaseTable_BASE(_pTables,_pConnection,_Name,\n\t\t\t\t\t\t\t\t  _Type,\n\t\t\t\t\t\t\t\t  _Description,\n\t\t\t\t\t\t\t\t  _SchemaName,\n\t\t\t\t\t\t\t\t  _CatalogName)\n\t\t\t\t,m_pMemoStream(NULL)\n\t\t\t\t,m_bWriteableMemo(sal_False)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ODbaseTable\" );\n    m_eEncoding = getConnection()->getTextEncoding();\n}\n\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::construct()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::construct\" );\n\t// initialize the header\n\tm_aHeader.db_typ\t= dBaseIII;\n\tm_aHeader.db_anz\t= 0;\n\tm_aHeader.db_kopf\t= 0;\n\tm_aHeader.db_slng\t= 0;\n    m_aMemoHeader.db_size = 0;\n\n\tString sFileName(getEntry(m_pConnection,m_Name));\n\n\tINetURLObject aURL;\n\taURL.SetURL(sFileName);\n\n\tOSL_ENSURE( m_pConnection->matchesExtension( aURL.getExtension() ),\n\t\t\"ODbaseTable::ODbaseTable: invalid extension!\");\n\t\t// getEntry is expected to ensure the corect file name\n\n\tm_pFileStream = createStream_simpleError( sFileName, STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYWRITE);\n\tm_bWriteable = ( m_pFileStream != NULL );\n\n    if ( !m_pFileStream )\n    {\n        m_bWriteable = sal_False;\n\t\tm_pFileStream = createStream_simpleError( sFileName, STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYNONE);\n    }\n\n\tif(m_pFileStream)\n\t{\n\t\treadHeader();\n\t\tif (HasMemoFields())\n\t\t{\n\t\t\t// Memo-Dateinamen bilden (.DBT):\n\t\t\t// nyi: Unschoen fuer Unix und Mac!\n\n\t\t\tif ( m_aHeader.db_typ == FoxProMemo || VisualFoxPro == m_aHeader.db_typ || VisualFoxProAuto == m_aHeader.db_typ ) // foxpro uses another extension\n\t\t\t\taURL.SetExtension(String::CreateFromAscii(\"fpt\"));\n\t\t\telse\n\t\t\t\taURL.SetExtension(String::CreateFromAscii(\"dbt\"));\n\n\t\t\t// Wenn die Memodatei nicht gefunden wird, werden die Daten trotzdem angezeigt\n\t\t\t// allerdings koennen keine Updates durchgefuehrt werden\n\t\t\t// jedoch die Operation wird ausgefuehrt\n\t\t\tm_pMemoStream = createStream_simpleError( aURL.GetMainURL(INetURLObject::NO_DECODE), STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYWRITE);\n            if ( !m_pMemoStream )\n            {\n                m_bWriteableMemo = sal_False;\n\t\t\t\tm_pMemoStream = createStream_simpleError( aURL.GetMainURL(INetURLObject::NO_DECODE), STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYNONE);\n            }\n\t\t\tif (m_pMemoStream)\n\t\t\t\tReadMemoHeader();\n\t\t}\n\t\t//\tif(!m_pColumns && (!m_aColumns.isValid() || !m_aColumns->size()))\n\t\tfillColumns();\n\n\t\tsal_uInt32 nFileSize = lcl_getFileSize(*m_pFileStream);\n\t\tm_pFileStream->Seek(STREAM_SEEK_TO_BEGIN);\n        if ( m_aHeader.db_anz == 0 && ((nFileSize-m_aHeader.db_kopf)/m_aHeader.db_slng) > 0) // seems to be empty or someone wrote bullshit into the dbase file\n            m_aHeader.db_anz = ((nFileSize-m_aHeader.db_kopf)/m_aHeader.db_slng);\n\n\t\t// Buffersize abhaengig von der Filegroesse\n\t\tm_pFileStream->SetBufferSize(nFileSize > 1000000 ? 32768 :\n\t\t\t\t\t\t\t\t  nFileSize > 100000 ? 16384 :\n\t\t\t\t\t\t\t\t  nFileSize > 10000 ? 4096 : 1024);\n\n\t\tif (m_pMemoStream)\n\t\t{\n\t\t\t// Puffer genau auf Laenge eines Satzes stellen\n\t\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\t\tnFileSize = m_pMemoStream->Tell();\n\t\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_BEGIN);\n\n\t\t\t// Buffersize abhaengig von der Filegroesse\n\t\t\tm_pMemoStream->SetBufferSize(nFileSize > 1000000 ? 32768 :\n\t\t\t\t\t\t\t\t\t\t  nFileSize > 100000 ? 16384 :\n\t\t\t\t\t\t\t\t\t\t  nFileSize > 10000 ? 4096 :\n\t\t\t\t\t\t\t\t\t\t  m_aMemoHeader.db_size);\n\t\t}\n\n\t\tAllocBuffer();\n\t}\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::ReadMemoHeader()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ReadMemoHeader\" );\n\tm_pMemoStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);\n\tm_pMemoStream->RefreshBuffer();\t\t\t// sicherstellen das die Kopfinformationen tatsaechlich neu gelesen werden\n\tm_pMemoStream->Seek(0L);\n\n\t(*m_pMemoStream) >> m_aMemoHeader.db_next;\n\tswitch (m_aHeader.db_typ)\n\t{\n        case dBaseIIIMemo:  // dBase III: feste Blockgroesse\n\t\tcase dBaseIVMemo:\n\t\t\t// manchmal wird aber auch dBase3 dBase4 Memo zugeordnet\n\t\t\tm_pMemoStream->Seek(20L);\n\t\t\t(*m_pMemoStream) >> m_aMemoHeader.db_size;\n\t\t\tif (m_aMemoHeader.db_size > 1 && m_aMemoHeader.db_size != 512)\t// 1 steht auch fuer dBase 3\n\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIV;\n\t\t\telse if (m_aMemoHeader.db_size > 1 && m_aMemoHeader.db_size == 512)\n\t\t\t{\n                // nun gibt es noch manche Dateien, die verwenden eine Groessenangabe,\n\t\t\t\t// sind aber dennoch dBase Dateien\n\t\t\t\tchar sHeader[4];\n\t\t\t\tm_pMemoStream->Seek(m_aMemoHeader.db_size);\n\t\t\t\tm_pMemoStream->Read(sHeader,4);\n\n\t\t\t\tif ((m_pMemoStream->GetErrorCode() != ERRCODE_NONE) || ((sal_uInt8)sHeader[0]) != 0xFF || ((sal_uInt8)sHeader[1]) != 0xFF || ((sal_uInt8)sHeader[2]) != 0x08)\n\t\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIII;\n\t\t\t\telse\n\t\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIV;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIII;\n\t\t\t\tm_aMemoHeader.db_size = 512;\n\t\t\t}\n\t\t\tbreak;\n        case VisualFoxPro:\n        case VisualFoxProAuto:\n\t\tcase FoxProMemo:\n\t\t\tm_aMemoHeader.db_typ\t= MemoFoxPro;\n\t\t\tm_pMemoStream->Seek(6L);\n\t\t\tm_pMemoStream->SetNumberFormatInt(NUMBERFORMAT_INT_BIGENDIAN);\n\t\t\t(*m_pMemoStream) >> m_aMemoHeader.db_size;\n            break;\n        default:\n            OSL_ENSURE( false, \"ODbaseTable::ReadMemoHeader: unsupported memo type!\" );\n            break;\n\t}\n\treturn sal_True;\n}\n// -------------------------------------------------------------------------\nString ODbaseTable::getEntry(OConnection* _pConnection,const ::rtl::OUString& _sName )\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getEntry\" );\n\t::rtl::OUString sURL;\n\ttry\n\t{\n\t\tReference< XResultSet > xDir = _pConnection->getDir()->getStaticResultSet();\n\t\tReference< XRow> xRow(xDir,UNO_QUERY);\n\t\t::rtl::OUString sName;\n\t\t::rtl::OUString sExt;\n\t\tINetURLObject aURL;\n\t\tstatic const ::rtl::OUString s_sSeparator(RTL_CONSTASCII_USTRINGPARAM(\"/\"));\n\t\txDir->beforeFirst();\n\t\twhile(xDir->next())\n\t\t{\n\t\t\tsName = xRow->getString(1);\n\t\t\taURL.SetSmartProtocol(INET_PROT_FILE);\n\t\t\tString sUrl = _pConnection->getURL() +  s_sSeparator + sName;\n\t\t\taURL.SetSmartURL( sUrl );\n\n\t\t\t// cut the extension\n\t\t\tsExt = aURL.getExtension();\n\n\t\t\t// name and extension have to coincide\n\t\t\tif ( _pConnection->matchesExtension( sExt ) )\n\t\t\t{\n\t\t\t\tsName = sName.replaceAt(sName.getLength()-(sExt.getLength()+1),sExt.getLength()+1,::rtl::OUString());\n\t\t\t\tif ( sName == _sName )\n\t\t\t\t{\n\t\t\t\t\tReference< XContentAccess > xContentAccess( xDir, UNO_QUERY );\n\t\t\t\t\tsURL = xContentAccess->queryContentIdentifierString();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txDir->beforeFirst(); // move back to before first record\n\t}\n\tcatch(Exception&)\n\t{\n\t\tOSL_ASSERT(0);\n\t}\n\treturn sURL;\n}\n// -------------------------------------------------------------------------\nvoid ODbaseTable::refreshColumns()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::refreshColumns\" );\n\t::osl::MutexGuard aGuard( m_aMutex );\n\n\tTStringVector aVector;\n\taVector.reserve(m_aColumns->get().size());\n\n\tfor(OSQLColumns::Vector::const_iterator aIter = m_aColumns->get().begin();aIter != m_aColumns->get().end();++aIter)\n\t\taVector.push_back(Reference< XNamed>(*aIter,UNO_QUERY)->getName());\n\n\tif(m_pColumns)\n\t\tm_pColumns->reFill(aVector);\n\telse\n\t\tm_pColumns\t= new ODbaseColumns(this,m_aMutex,aVector);\n}\n// -------------------------------------------------------------------------\nvoid ODbaseTable::refreshIndexes()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::refreshIndexes\" );\n\tTStringVector aVector;\n\tif(m_pFileStream && (!m_pIndexes || m_pIndexes->getCount() == 0))\n\t{\n\t\tINetURLObject aURL;\n\t\taURL.SetURL(getEntry(m_pConnection,m_Name));\n\n\t\taURL.setExtension(String::CreateFromAscii(\"inf\"));\n\t\tConfig aInfFile(aURL.getFSysPath(INetURLObject::FSYS_DETECT));\n\t\taInfFile.SetGroup(dBASE_III_GROUP);\n\t\tsal_uInt16 nKeyCnt = aInfFile.GetKeyCount();\n\t\tByteString aKeyName;\n\t\tByteString aIndexName;\n\n\t\tfor (sal_uInt16 nKey = 0; nKey < nKeyCnt; nKey++)\n\t\t{\n\t\t\t// Verweist der Key auf ein Indexfile?...\n\t\t\taKeyName = aInfFile.GetKeyName( nKey );\n\t\t\t//...wenn ja, Indexliste der Tabelle hinzufuegen\n\t\t\tif (aKeyName.Copy(0,3) == ByteString(\"NDX\") )\n\t\t\t{\n\t\t\t\taIndexName = aInfFile.ReadKey(aKeyName);\n\t\t\t\taURL.setName(String(aIndexName,m_eEncoding));\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tContent aCnt(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\t\t\tif (aCnt.isDocument())\n\t\t\t\t\t{\n\t\t\t\t\t\taVector.push_back(aURL.getBase());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(Exception&) // a execption is thrown when no file exists\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(m_pIndexes)\n\t\tm_pIndexes->reFill(aVector);\n\telse\n\t\tm_pIndexes\t= new ODbaseIndexes(this,m_aMutex,aVector);\n}\n\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::disposing(void)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::disposing\" );\n\tOFileTable::disposing();\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tm_aColumns = NULL;\n}\n// -------------------------------------------------------------------------\nSequence< Type > SAL_CALL ODbaseTable::getTypes(  ) throw(RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getTypes\" );\n\tSequence< Type > aTypes = OTable_TYPEDEF::getTypes();\n\t::std::vector<Type> aOwnTypes;\n\taOwnTypes.reserve(aTypes.getLength());\n\n\tconst Type* pBegin = aTypes.getConstArray();\n\tconst Type* pEnd = pBegin + aTypes.getLength();\n\tfor(;pBegin != pEnd;++pBegin)\n\t{\n\t\tif(!(*pBegin == ::getCppuType((const Reference<XKeysSupplier>*)0)\t||\n\t\t\t//\t*pBegin == ::getCppuType((const Reference<XAlterTable>*)0)\t||\n\t\t\t*pBegin == ::getCppuType((const Reference<XDataDescriptorFactory>*)0)))\n\t\t{\n\t\t\taOwnTypes.push_back(*pBegin);\n\t\t}\n\t}\n\taOwnTypes.push_back(::getCppuType( (const Reference< ::com::sun::star::lang::XUnoTunnel > *)0 ));\n\tType *pTypes = aOwnTypes.empty() ? 0 : &aOwnTypes[0];\n\treturn Sequence< Type >(pTypes, aOwnTypes.size());\n}\n\n// -------------------------------------------------------------------------\nAny SAL_CALL ODbaseTable::queryInterface( const Type & rType ) throw(RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::queryInterface\" );\n\tif( rType == ::getCppuType((const Reference<XKeysSupplier>*)0)\t||\n\t\trType == ::getCppuType((const Reference<XDataDescriptorFactory>*)0))\n\t\treturn Any();\n\n\tAny aRet = OTable_TYPEDEF::queryInterface(rType);\n\treturn aRet.hasValue() ? aRet : ::cppu::queryInterface(rType,static_cast< ::com::sun::star::lang::XUnoTunnel*> (this));\n}\n\n//--------------------------------------------------------------------------\nSequence< sal_Int8 > ODbaseTable::getUnoTunnelImplementationId()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getUnoTunnelImplementationId\" );\n\tstatic ::cppu::OImplementationId * pId = 0;\n\tif (! pId)\n\t{\n\t\t::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );\n\t\tif (! pId)\n\t\t{\n\t\t\tstatic ::cppu::OImplementationId aId;\n\t\t\tpId = &aId;\n\t\t}\n\t}\n\treturn pId->getImplementationId();\n}\n\n// com::sun::star::lang::XUnoTunnel\n//------------------------------------------------------------------\nsal_Int64 ODbaseTable::getSomething( const Sequence< sal_Int8 > & rId ) throw (RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getSomething\" );\n\treturn (rId.getLength() == 16 && 0 == rtl_compareMemory(getUnoTunnelImplementationId().getConstArray(),  rId.getConstArray(), 16 ) )\n\t\t\t\t? reinterpret_cast< sal_Int64 >( this )\n\t\t\t\t: ODbaseTable_BASE::getSomething(rId);\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::fetchRow(OValueRefRow& _rRow,const OSQLColumns & _rCols, sal_Bool _bUseTableDefs,sal_Bool bRetrieveData)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::fetchRow\" );\n\t// Einlesen der Daten\n\tsal_Bool bIsCurRecordDeleted = ((char)m_pBuffer[0] == '*') ? sal_True : sal_False;\n\n\t// only read the bookmark\n\n\t// Satz als geloescht markieren\n\t//\trRow.setState(bIsCurRecordDeleted ? ROW_DELETED : ROW_CLEAN );\n\t_rRow->setDeleted(bIsCurRecordDeleted);\n\t*(_rRow->get())[0] = m_nFilePos;\n\n\tif (!bRetrieveData)\n\t\treturn sal_True;\n\n\tsal_Size nByteOffset = 1;\n\t// Felder:\n\tOSQLColumns::Vector::const_iterator aIter = _rCols.get().begin();\n    OSQLColumns::Vector::const_iterator aEnd  = _rCols.get().end();\n    const sal_Size nCount = _rRow->get().size();\n\tfor (sal_Size i = 1; aIter != aEnd && nByteOffset <= m_nBufferSize && i < nCount;++aIter, i++)\n\t{\n\t\t// Laengen je nach Datentyp:\n\t\tsal_Int32 nLen = 0;\n\t\tsal_Int32 nType = 0;\n\t\tif(_bUseTableDefs)\n\t\t{\n\t\t\tnLen\t= m_aPrecisions[i-1];\n\t\t\tnType\t= m_aTypes[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))\t>>= nLen;\n\t\t\t(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))\t\t>>= nType;\n\t\t}\n\t\tswitch(nType)\n\t\t{\n            case DataType::INTEGER:\t\t\n            case DataType::DOUBLE:\n            case DataType::TIMESTAMP:\n\t\t\tcase DataType::DATE:\t\t\n            case DataType::BIT:\t\t\t\n\t\t\tcase DataType::LONGVARCHAR:\t\n            case DataType::LONGVARBINARY:   \n                nLen = m_aRealFieldLengths[i-1]; \n                break;\n\t\t\tcase DataType::DECIMAL:\n\t\t\t\tif(_bUseTableDefs)\n\t\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,m_aScales[i-1]);\n\t\t\t\telse\n\t\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,getINT32((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))));\n\t\t\t\tbreak;\t// das Vorzeichen und das Komma\n\t\t\t\n            case DataType::BINARY:\n\t\t\tcase DataType::OTHER:\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t// Ist die Variable ueberhaupt gebunden?\n\t\tif ( !(_rRow->get())[i]->isBound() )\n\t\t{\n\t\t\t// Nein - naechstes Feld.\n\t\t\tnByteOffset += nLen;\n\t\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t\t\tcontinue;\n\t\t} // if ( !(_rRow->get())[i]->isBound() )\n        if ( ( nByteOffset + nLen) > m_nBufferSize )\n            break; // length doesn't match buffer size.\n\n\t\tchar *pData = (char *) (m_pBuffer + nByteOffset);\n\n\t\t//\t(*_rRow)[i].setType(nType);\n\n\t\tif (nType == DataType::CHAR || nType == DataType::VARCHAR)\n\t\t{\n\t\t\tchar cLast = pData[nLen];\n\t\t\tpData[nLen] = 0;\n\t\t\tString aStr(pData,(xub_StrLen)nLen,m_eEncoding);\n\t\t\taStr.EraseTrailingChars();\n\n\t\t\tif ( aStr.Len() )\n                *(_rRow->get())[i] = ::rtl::OUString(aStr);\n\t\t\telse// keine StringLaenge, dann NULL\n                (_rRow->get())[i]->setNull();\n\t\t\t\t\n\t\t\tpData[nLen] = cLast;\n\t\t} // if (nType == DataType::CHAR || nType == DataType::VARCHAR)\n        else if ( DataType::TIMESTAMP == nType )\n        {\n            sal_Int32 nDate = 0,nTime = 0;\n\t\t\tmemcpy(&nDate, pData, 4);\n            memcpy(&nTime, pData+ 4, 4);\n            if ( !nDate && !nTime )\n            {\n                (_rRow->get())[i]->setNull();\n            }\n            else\n            {\n                ::com::sun::star::util::DateTime aDateTime;\n                lcl_CalDate(nDate,nTime,aDateTime);\n                *(_rRow->get())[i] = aDateTime;\n            }\n        }\n        else if ( DataType::INTEGER == nType )\n        {\n            sal_Int32 nValue = 0;\n\t\t\tmemcpy(&nValue, pData, nLen);\n            *(_rRow->get())[i] = nValue;\n        }\n        else if ( DataType::DOUBLE == nType )\n        {\n            double d = 0.0;\n            if (getBOOL((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n            {\n                sal_Int64 nValue = 0;\n\t\t\t    memcpy(&nValue, pData, nLen);\n            \n                if ( m_aScales[i-1] )\n                    d = (double)(nValue / pow(10.0,(int)m_aScales[i-1]));\n                else\n                    d = (double)(nValue);\n            }\n            else\n            {\n                memcpy(&d, pData, nLen);\n            }\n            \n            *(_rRow->get())[i] = d;\n        }\n\t\telse\n\t\t{\n\t\t\t// Falls Nul-Zeichen im String enthalten sind, in Blanks umwandeln!\n\t\t\tfor (sal_Int32 k = 0; k < nLen; k++)\n\t\t\t{\n\t\t\t\tif (pData[k] == '\\0')\n\t\t\t\t\tpData[k] = ' ';\n\t\t\t}\n\n\t\t\tString aStr(pData, (xub_StrLen)nLen,m_eEncoding);\t\t// Spaces am Anfang und am Ende entfernen:\n\t\t\taStr.EraseLeadingChars();\n\t\t\taStr.EraseTrailingChars();\n\n\t\t\tif (!aStr.Len())\n\t\t\t{\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\t(_rRow->get())[i]->setNull();\t// keine Werte -> fertig\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (nType)\n\t\t\t{\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t{\n\t\t\t\t\tif (aStr.Len() != nLen)\n\t\t\t\t\t{\n\t\t\t\t\t\t(_rRow->get())[i]->setNull();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst sal_uInt16  nYear   = (sal_uInt16)aStr.Copy( 0, 4 ).ToInt32();\n\t\t\t\t\tconst sal_uInt16  nMonth  = (sal_uInt16)aStr.Copy( 4, 2 ).ToInt32();\n\t\t\t\t\tconst sal_uInt16  nDay    = (sal_uInt16)aStr.Copy( 6, 2 ).ToInt32();\n\n\t\t\t\t\tconst ::com::sun::star::util::Date aDate(nDay,nMonth,nYear);\n\t\t\t\t\t*(_rRow->get())[i] = aDate;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\t\t*(_rRow->get())[i] = ORowSetValue(aStr);\n\t\t\t\t\t//\tpVal->setDouble(SdbTools::ToDouble(aStr));\n\t\t\t\tbreak;\n\t\t\t\tcase DataType::BIT:\n\t\t\t\t{\n\t\t\t\t\tsal_Bool b;\n\t\t\t\t\tswitch (* ((const char *)pData))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\tcase 'J':\tb = sal_True; break;\n\t\t\t\t\t\tdefault: \tb = sal_False; break;\n\t\t\t\t\t}\n\t\t\t\t\t*(_rRow->get())[i] = b;\n\t\t\t\t\t//\tpVal->setDouble(b);\n\t\t\t\t}\n\t\t\t\tbreak;\n                case DataType::LONGVARBINARY:\n                case DataType::BINARY:\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t{\n\t\t\t\t\tconst long nBlockNo = aStr.ToInt32();\t// Blocknummer lesen\n\t\t\t\t\tif (nBlockNo > 0 && m_pMemoStream) // Daten aus Memo-Datei lesen, nur wenn\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( !ReadMemo(nBlockNo, (_rRow->get())[i]->get()) )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t(_rRow->get())[i]->setNull();\n\t\t\t\t}\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tOSL_ASSERT(\"Falscher Type\");\n\t\t\t}\n\t\t\t(_rRow->get())[i]->setTypeKind(nType);\n\t\t}\n\n\t\tnByteOffset += nLen;\n\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t}\n\treturn sal_True;\n}\n//------------------------------------------------------------------\n// -------------------------------------------------------------------------\nvoid ODbaseTable::FileClose()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::FileClose\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\t// falls noch nicht alles geschrieben wurde\n\tif (m_pMemoStream && m_pMemoStream->IsWritable())\n\t\tm_pMemoStream->Flush();\n\n\tdelete m_pMemoStream;\n\tm_pMemoStream = NULL;\n\n\tODbaseTable_BASE::FileClose();\n}\n// -------------------------------------------------------------------------\nsal_Bool ODbaseTable::CreateImpl()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::CreateImpl\" );\n\tOSL_ENSURE(!m_pFileStream, \"SequenceError\");\n\n\tif ( m_pConnection->isCheckEnabled() && ::dbtools::convertName2SQLName(m_Name,::rtl::OUString()) != m_Name )\n\t{\n        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_SQL_NAME_ERROR,\n                \"$name$\", m_Name\n             ) );\n        ::dbtools::throwGenericSQLException( sError, *this );\n\t}\n\n\tINetURLObject aURL;\n\taURL.SetSmartProtocol(INET_PROT_FILE);\n\tString aName = getEntry(m_pConnection,m_Name);\n\tif(!aName.Len())\n\t{\n\t\t::rtl::OUString aIdent = m_pConnection->getContent()->getIdentifier()->getContentIdentifier();\n\t\tif ( aIdent.lastIndexOf('/') != (aIdent.getLength()-1) )\n\t\t\taIdent += ::rtl::OUString::createFromAscii(\"/\");\n\t\taIdent += m_Name;\n\t\taName = aIdent.getStr();\n\t}\n\taURL.SetURL(aName);\n\n\tif ( !m_pConnection->matchesExtension( aURL.getExtension() ) )\n\t\taURL.setExtension(m_pConnection->getExtension());\n\n\ttry\n\t{\n\t\tContent aContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\tif (aContent.isDocument())\n\t\t{\n\t\t\t// Hack fuer Bug #30609 , nur wenn das File existiert und die Laenge > 0 gibt es einen Fehler\n\t\t\tSvStream* pFileStream = createStream_simpleError( aURL.GetMainURL(INetURLObject::NO_DECODE),STREAM_READ);\n\n\t\t\tif (pFileStream && pFileStream->Seek(STREAM_SEEK_TO_END))\n\t\t\t{\n\t\t\t\t//\taStatus.SetError(ERRCODE_IO_ALREADYEXISTS,TABLE,aFile.GetFull());\n\t\t\t\treturn sal_False;\n\t\t\t}\n\t\t\tdelete pFileStream;\n\t\t}\n\t}\n\tcatch(Exception&) // a execption is thrown when no file exists\n\t{\n\t}\n\n\tsal_Bool bMemoFile = sal_False;\n\n\tsal_Bool bOk = CreateFile(aURL, bMemoFile);\n\n\tFileClose();\n\n\tif (!bOk)\n\t{\n\t\ttry\n\t\t{\n\t\t\tContent aContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\taContent.executeCommand( rtl::OUString::createFromAscii( \"delete\" ),bool2any( sal_True ) );\n\t\t}\n\t\tcatch(Exception&) // a execption is thrown when no file exists\n\t\t{\n\t\t}\n\t\treturn sal_False;\n\t}\n\n\tif (bMemoFile)\n\t{\n\t\tString aExt = aURL.getExtension();\n\t\taURL.setExtension(String::CreateFromAscii(\"dbt\"));                      // extension for memo file\n\t\tContent aMemo1Content(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\n\t\tsal_Bool bMemoAlreadyExists = sal_False;\n\t\ttry\n\t\t{\n\t\t\tbMemoAlreadyExists = aMemo1Content.isDocument();\n\t\t}\n\t\tcatch(Exception&) // a execption is thrown when no file exists\n\t\t{\n\t\t}\n\t\tif (bMemoAlreadyExists)\n\t\t{\n\t\t\t//\taStatus.SetError(ERRCODE_IO_ALREADYEXISTS,MEMO,aFile.GetFull());\n\t\t\taURL.setExtension(aExt);      // kill dbf file\n\t\t\ttry\n\t\t\t{\n\t\t\t\tContent aMemoContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\t\taMemoContent.executeCommand( rtl::OUString::createFromAscii( \"delete\" ),bool2any( sal_True ) );\n\t\t\t}\n\t\t\tcatch(const Exception&)\n\t\t\t{\n                \n                const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                        STR_COULD_NOT_DELETE_FILE,\n                        \"$name$\", aName\n                     ) );\n                ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t}\n\t\t}\n\t\tif (!CreateMemoFile(aURL))\n\t\t{\n\t\t\taURL.setExtension(aExt);      // kill dbf file\n\t\t\tContent aMemoContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\taMemoContent.executeCommand( rtl::OUString::createFromAscii( \"delete\" ),bool2any( sal_True ) );\n\t\t\treturn sal_False;\n\t\t}\n\t\tm_aHeader.db_typ = dBaseIIIMemo;\n\t}\n\telse\n\t\tm_aHeader.db_typ = dBaseIII;\n\n\treturn sal_True;\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::throwInvalidColumnType(const sal_uInt16 _nErrorId,const ::rtl::OUString& _sColumnName)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::throwInvalidColumnType\" );\n\ttry\n\t{\n\t\t// we have to drop the file because it is corrupted now\n\t\tDropImpl();\n\t}\n\tcatch(const Exception&)\n\t{\n\t}\n\n    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n            _nErrorId,\n            \"$columnname$\", _sColumnName\n         ) );\n    ::dbtools::throwGenericSQLException( sError, *this );\n}\n//------------------------------------------------------------------\n// erzeugt grundsaetzlich dBase IV Datei Format\nsal_Bool ODbaseTable::CreateFile(const INetURLObject& aFile, sal_Bool& bCreateMemo)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::CreateFile\" );\n\tbCreateMemo = sal_False;\n\tDate aDate;                                     // aktuelles Datum\n\n\tm_pFileStream = createStream_simpleError( aFile.GetMainURL(INetURLObject::NO_DECODE),STREAM_READWRITE | STREAM_SHARE_DENYWRITE | STREAM_TRUNC );\n\n\tif (!m_pFileStream)\n\t\treturn sal_False;\n\n    sal_uInt8 nDbaseType = dBaseIII;\n    Reference<XIndexAccess> xColumns(getColumns(),UNO_QUERY);\n\tReference<XPropertySet> xCol;\n    const ::rtl::OUString sPropType = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE);\n    \n    try\n\t{\n        const sal_Int32 nCount = xColumns->getCount();\n\t\tfor(sal_Int32 i=0;i<nCount;++i)\n\t\t{\n\t\t\txColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"This should be a column!\");\n\n\t\t\tswitch (getINT32(xCol->getPropertyValue(sPropType)))\n\t\t\t{\n                case DataType::DOUBLE:\n                case DataType::INTEGER:                \n                case DataType::TIMESTAMP:\n                case DataType::LONGVARBINARY:\n                    nDbaseType = VisualFoxPro;\n                    i = nCount; // no more columns need to be checked\n                    break;\n            } // switch (getINT32(xCol->getPropertyValue(sPropType)))\n        }\n    }\n    catch ( const Exception& e )\n\t{\n        (void)e;\n\n\t\ttry\n\t\t{\n\t\t\t// we have to drop the file because it is corrupted now\n\t\t\tDropImpl();\n\t\t}\n\t\tcatch(const Exception&) { }\n\t\tthrow;\n\t}\n\n\tchar aBuffer[21];               // write buffer\n\tmemset(aBuffer,0,sizeof(aBuffer));\n\n\tm_pFileStream->Seek(0L);\n\t(*m_pFileStream) << (sal_uInt8) nDbaseType;                              // dBase format\n\t(*m_pFileStream) << (sal_uInt8) (aDate.GetYear() % 100);                 // aktuelles Datum\n\n\n\t(*m_pFileStream) << (sal_uInt8) aDate.GetMonth();\n\t(*m_pFileStream) << (sal_uInt8) aDate.GetDay();\n    (*m_pFileStream) << 0L;                                             // Anzahl der Datensaetze\n\t(*m_pFileStream) << (sal_uInt16)((m_pColumns->getCount()+1) * 32 + 1);  // Kopfinformationen,\n                                                                        // pColumns erhaelt immer eine Spalte mehr\n    (*m_pFileStream) << (sal_uInt16) 0;                                     // Satzlaenge wird spaeter bestimmt\n\tm_pFileStream->Write(aBuffer, 20);\n\n    sal_uInt16 nRecLength = 1;                                              // Laenge 1 fuer deleted flag\n\tsal_Int32  nMaxFieldLength = m_pConnection->getMetaData()->getMaxColumnNameLength();\n\t::rtl::OUString aName;\n    const ::rtl::OUString sPropName = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME);\n    const ::rtl::OUString sPropPrec = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION);\n    const ::rtl::OUString sPropScale = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE);\n    \n\ttry\n\t{\n\t\tconst sal_Int32 nCount = xColumns->getCount();\n\t\tfor(sal_Int32 i=0;i<nCount;++i)\n\t\t{\n\t\t\txColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"This should be a column!\");\n\n            char cTyp( 'C' );\n\n\t\t\txCol->getPropertyValue(sPropName) >>= aName;\n\n\t\t\t::rtl::OString aCol;\n\t\t\tif ( DBTypeConversion::convertUnicodeString( aName, aCol, m_eEncoding ) > nMaxFieldLength)\n\t\t\t{\n                throwInvalidColumnType( STR_INVALID_COLUMN_NAME_LENGTH, aName );\n\t\t\t}\n\n\t\t\t(*m_pFileStream) << aCol.getStr();\n\t\t\tm_pFileStream->Write(aBuffer, 11 - aCol.getLength());\n\n            sal_Int32 nPrecision = 0;\n\t\t\txCol->getPropertyValue(sPropPrec) >>= nPrecision;\n\t\t\tsal_Int32 nScale = 0;\n\t\t\txCol->getPropertyValue(sPropScale) >>= nScale;\n\n            bool bBinary = false;\n\n\t\t\tswitch (getINT32(xCol->getPropertyValue(sPropType)))\n\t\t\t{\n\t\t\t\tcase DataType::CHAR:\n\t\t\t\tcase DataType::VARCHAR:\n\t\t\t\t\tcTyp = 'C';\n\t\t\t\t\tbreak;\n                case DataType::DOUBLE:\n                    if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        cTyp = 'Y';\n                    else\n                        cTyp = 'B';\n\t\t\t\t\tbreak;\n                case DataType::INTEGER:\n                    cTyp = 'I';\n\t\t\t\t    break;\n\t\t\t\tcase DataType::TINYINT:\n\t\t\t\tcase DataType::SMALLINT:\n\t\t\t\tcase DataType::BIGINT:\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\tcase DataType::NUMERIC:\n\t\t\t\tcase DataType::REAL:\n\t\t\t\t\tcTyp = 'N';                             // nur dBase 3 format\n\t\t\t\t\tbreak;\n                case DataType::TIMESTAMP:\n                    cTyp = 'T';\n\t\t\t\t    break;\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t\tcTyp = 'D';\n\t\t\t\t\tbreak;\n\t\t\t\tcase DataType::BIT:\n\t\t\t\t\tcTyp = 'L';\n\t\t\t\t\tbreak;\n\t\t\t\tcase DataType::LONGVARBINARY:\n                    bBinary = true;\n                    // run through\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t\tcTyp = 'M';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tthrowInvalidColumnType(STR_INVALID_COLUMN_TYPE, aName);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t(*m_pFileStream) << cTyp;\n            if ( nDbaseType == VisualFoxPro )\n                (*m_pFileStream) << (nRecLength-1);\n            else\n\t\t\t    m_pFileStream->Write(aBuffer, 4);\t\t\t\n\n\t\t\tswitch(cTyp)\n\t\t\t{\n\t\t\t\tcase 'C':\n\t\t\t\t\tOSL_ENSURE(nPrecision < 255, \"ODbaseTable::Create: Column zu lang!\");\n\t\t\t\t\tif (nPrecision > 254)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrowInvalidColumnType(STR_INVALID_COLUMN_PRECISION, aName);\n\t\t\t\t\t}\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8) Min((sal_uIntPtr)nPrecision, 255UL);      //Feldlaenge\n                    nRecLength = nRecLength + (sal_uInt16)::std::min((sal_uInt16)nPrecision, (sal_uInt16)255UL);\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;                                                                //Nachkommastellen\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'N':\n\t\t\t\t\tOSL_ENSURE(nPrecision >=  nScale,\n\t\t\t\t\t\t\t\"ODbaseTable::Create: Feldlaenge muss groesser Nachkommastellen sein!\");\n\t\t\t\t\tif (nPrecision <  nScale)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrowInvalidColumnType(STR_INVALID_PRECISION_SCALE, aName);\n\t\t\t\t\t}\n\t\t\t\t\tif (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n\t\t\t\t\t{\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)10;          // Standard Laenge\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)4;\n\t\t\t\t\t\tnRecLength += 10;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsal_Int32 nPrec = SvDbaseConverter::ConvertPrecisionToDbase(nPrecision,nScale);\n\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)( nPrec);\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)nScale;\n                        nRecLength += (sal_uInt16)nPrec;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)1;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\t++nRecLength;\n\t\t\t\t\tbreak;\n                case 'I':\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)4;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\tnRecLength += 4;\n\t\t\t\t\tbreak;\n                case 'Y':\n                case 'B':\n                case 'T':\n\t\t\t\tcase 'D':\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)8;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\tnRecLength += 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tbCreateMemo = sal_True;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)10;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\tnRecLength += 10;\n                    if ( bBinary )\n                        aBuffer[0] = 0x06;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n                    throwInvalidColumnType(STR_INVALID_COLUMN_TYPE, aName);\n\t\t\t}\n\t\t\tm_pFileStream->Write(aBuffer, 14);\n            aBuffer[0] = 0x00;\n\t\t}\n\n\t\t(*m_pFileStream) << (sal_uInt8)FIELD_DESCRIPTOR_TERMINATOR;              // kopf ende\n        (*m_pFileStream) << (char)DBF_EOL;\n\t\tm_pFileStream->Seek(10L);\n\t\t(*m_pFileStream) << nRecLength;                                     // Satzlaenge nachtraeglich eintragen\n\n\t\tif (bCreateMemo)\n\t\t{\n\t\t\tm_pFileStream->Seek(0L);\n            if (nDbaseType == VisualFoxPro)\n                (*m_pFileStream) << (sal_uInt8) FoxProMemo;\n            else\n                (*m_pFileStream) << (sal_uInt8) dBaseIIIMemo;\n\t\t} // if (bCreateMemo)\n\t}\n\tcatch ( const Exception& e )\n\t{\n        (void)e;\n\n\t\ttry\n\t\t{\n\t\t\t// we have to drop the file because it is corrupted now\n\t\t\tDropImpl();\n\t\t}\n\t\tcatch(const Exception&) { }\n\t\tthrow;\n\t}\n\treturn sal_True;\n}\n\n//------------------------------------------------------------------\n// erzeugt grundsaetzlich dBase III Datei Format\nsal_Bool ODbaseTable::CreateMemoFile(const INetURLObject& aFile)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::CreateMemoFile\" );\n    // Makro zum Filehandling fuers Erzeugen von Tabellen\n\tm_pMemoStream = createStream_simpleError( aFile.GetMainURL(INetURLObject::NO_DECODE),STREAM_READWRITE | STREAM_SHARE_DENYWRITE);\n\n\tif (!m_pMemoStream)\n\t\treturn sal_False;\n\n\tchar aBuffer[512];              // write buffer\n\tmemset(aBuffer,0,sizeof(aBuffer));\n\n\tm_pMemoStream->SetFiller('\\0');\n\tm_pMemoStream->SetStreamSize(512);\n\n\tm_pMemoStream->Seek(0L);\n\t(*m_pMemoStream) << long(1);                  // Zeiger auf ersten freien Block\n\n\tm_pMemoStream->Flush();\n\tdelete m_pMemoStream;\n\tm_pMemoStream = NULL;\n\treturn sal_True;\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::Drop_Static(const ::rtl::OUString& _sUrl,sal_Bool _bHasMemoFields,OCollection* _pIndexes )\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::Drop_Static\" );\n\tINetURLObject aURL;\n\taURL.SetURL(_sUrl);\n\n\tsal_Bool bDropped = ::utl::UCBContentHelper::Kill(aURL.GetMainURL(INetURLObject::NO_DECODE));\n\n\tif(bDropped)\n\t{\n\t\tif (_bHasMemoFields)\n\t\t{  // delete the memo fields\n\t\t\taURL.setExtension(String::CreateFromAscii(\"dbt\"));\n\t\t\tbDropped = ::utl::UCBContentHelper::Kill(aURL.GetMainURL(INetURLObject::NO_DECODE));\n\t\t}\n\n\t\tif(bDropped)\n\t\t{\n\t\t\tif(_pIndexes)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsal_Int32 i = _pIndexes->getCount();\n\t\t\t\t\twhile (i)\n\t\t\t\t\t{\n\t\t\t\t\t\t_pIndexes->dropByIndex(--i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(SQLException)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\taFile.SetBase(m_Name);\n\t\t\taURL.setExtension(String::CreateFromAscii(\"inf\"));\n\n\t\t\t// as the inf file does not necessarily exist, we aren't allowed to use UCBContentHelper::Kill\n\t\t\t// 89711 - 16.07.2001 - frank.schoenheit@sun.com\n\t\t\ttry\n\t\t\t{\n\t\t\t\t::ucbhelper::Content aDeleteContent( aURL.GetMainURL( INetURLObject::NO_DECODE ), Reference< XCommandEnvironment > () );\n\t\t\t\taDeleteContent.executeCommand( ::rtl::OUString::createFromAscii( \"delete\" ), makeAny( sal_Bool( sal_True ) ) );\n\t\t\t}\n\t\t\tcatch(Exception&)\n\t\t\t{\n\t\t\t\t// silently ignore this ....\n\t\t\t}\n\t\t}\n\t}\n\treturn bDropped;\n}\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::DropImpl()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::DropImpl\" );\n\tFileClose();\n\n\tif(!m_pIndexes)\n\t\trefreshIndexes(); // look for indexes which must be deleted as well\n\n\tsal_Bool bDropped = Drop_Static(getEntry(m_pConnection,m_Name),HasMemoFields(),m_pIndexes);\n\tif(!bDropped)\n\t{// we couldn't drop the table so we have to reopen it\n\t\tconstruct();\n\t\tif(m_pColumns)\n\t\t\tm_pColumns->refresh();\n\t}\n\treturn bDropped;\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::InsertRow(OValueRefVector& rRow, sal_Bool bFlush,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::InsertRow\" );\n    // Buffer mit Leerzeichen fuellen\n\tAllocBuffer();\n\tmemset(m_pBuffer, 0, m_aHeader.db_slng);\n    m_pBuffer[0] = ' ';\n\n\t// Gesamte neue Row uebernehmen:\n\t// ... und am Ende als neuen Record hinzufuegen:\n\tsal_uInt32 nTempPos = m_nFilePos,\n\t\t   nFileSize = 0,\n\t\t   nMemoFileSize = 0;\n\n\tm_nFilePos = (sal_uIntPtr)m_aHeader.db_anz + 1;\n    sal_Bool bInsertRow = UpdateBuffer( rRow, NULL, _xCols );\n\tif ( bInsertRow )\n\t{\n\t\tnFileSize = lcl_getFileSize(*m_pFileStream);\t\t\n\n\t\tif (HasMemoFields() && m_pMemoStream)\n\t\t{\n\t\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\t\tnMemoFileSize = m_pMemoStream->Tell();\n\t\t}\n\n\t\tif (!WriteBuffer())\n\t\t{\n            m_pFileStream->SetStreamSize(nFileSize);                // alte Groesse restaurieren\n\n\t\t\tif (HasMemoFields() && m_pMemoStream)\n                m_pMemoStream->SetStreamSize(nMemoFileSize);    // alte Groesse restaurieren\n\t\t\tm_nFilePos = nTempPos;\t\t\t\t\t\t\t\t// Fileposition restaurieren\n\t\t}\n\t\telse\n\t\t{\n            (*m_pFileStream) << (char)DBF_EOL; // write EOL\n\t\t\t// Anzahl Datensaetze im Header erhoehen:\n\t\t\tm_pFileStream->Seek( 4L );\n\t\t\t(*m_pFileStream) << (m_aHeader.db_anz + 1);\n\n\t\t\t// beim AppendOnly kein Flush!\n\t\t\tif (bFlush)\n\t\t\t\tm_pFileStream->Flush();\n\n            // bei Erfolg # erhoehen\n\t\t\tm_aHeader.db_anz++;\n\t\t\t*rRow.get()[0] = m_nFilePos;\t\t\t\t\t\t\t    // BOOKmark setzen\n\t\t\tm_nFilePos = nTempPos;\n\t\t}\n\t}\n\telse\n\t\tm_nFilePos = nTempPos;\n\n\treturn bInsertRow;\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::UpdateRow(OValueRefVector& rRow, OValueRefRow& pOrgRow,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::UpdateRow\" );\n    // Buffer mit Leerzeichen fuellen\n\tAllocBuffer();\n\n\t// Auf gewuenschten Record positionieren:\n\tlong nPos = m_aHeader.db_kopf + (long)(m_nFilePos-1) * m_aHeader.db_slng;\n\tm_pFileStream->Seek(nPos);\n\tm_pFileStream->Read((char*)m_pBuffer, m_aHeader.db_slng);\n\n\tsal_uInt32 nMemoFileSize( 0 );\n\tif (HasMemoFields() && m_pMemoStream)\n\t{\n\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\tnMemoFileSize = m_pMemoStream->Tell();\n\t}\n\tif (!UpdateBuffer(rRow, pOrgRow,_xCols) || !WriteBuffer())\n\t{\n\t\tif (HasMemoFields() && m_pMemoStream)\n            m_pMemoStream->SetStreamSize(nMemoFileSize);    // alte Groesse restaurieren\n\t}\n\telse\n\t{\n\t\tm_pFileStream->Flush();\n\t}\n\treturn sal_True;\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::DeleteRow(const OSQLColumns& _rCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::DeleteRow\" );\n\t// Einfach das Loesch-Flag setzen (egal, ob es schon gesetzt war\n\t// oder nicht):\n\t// Auf gewuenschten Record positionieren:\n\tlong nFilePos = m_aHeader.db_kopf + (long)(m_nFilePos-1) * m_aHeader.db_slng;\n\tm_pFileStream->Seek(nFilePos);\n\n\tOValueRefRow aRow = new OValueRefVector(_rCols.get().size());\n\n\tif (!fetchRow(aRow,_rCols,sal_True,sal_True))\n\t\treturn sal_False;\n\n\tReference<XPropertySet> xCol;\n\t::rtl::OUString aColName;\n\t::comphelper::UStringMixEqual aCase(isCaseSensitive());\n\tfor (sal_uInt16 i = 0; i < m_pColumns->getCount(); i++)\n\t{\n\t\tReference<XPropertySet> xIndex = isUniqueByColumnName(i);\n\t\tif (xIndex.is())\n\t\t{\n\t\t\t::cppu::extractInterface(xCol,m_pColumns->getByIndex(i));\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::DeleteRow column is null!\");\n\t\t\tif(xCol.is())\n\t\t\t{\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\t\tReference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);\n\t\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::DeleteRow: No Index returned!\");\n\n\t\t\t\tOSQLColumns::Vector::const_iterator aIter = _rCols.get().begin();\n\t\t\t\tsal_Int32 nPos = 1;\n\t\t\t\tfor(;aIter != _rCols.get().end();++aIter,++nPos)\n\t\t\t\t{\n\t\t\t\t\tif(aCase(getString((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_REALNAME))),aColName))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (aIter == _rCols.get().end())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tpIndex->Delete(m_nFilePos,*(aRow->get())[nPos]);\n\t\t\t}\n\t\t}\n\t}\n\n\tm_pFileStream->Seek(nFilePos);\n\t(*m_pFileStream) << (sal_uInt8)'*'; // mark the row in the table as deleted\n\tm_pFileStream->Flush();\n\treturn sal_True;\n}\n// -------------------------------------------------------------------------\nReference<XPropertySet> ODbaseTable::isUniqueByColumnName(sal_Int32 _nColumnPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::isUniqueByColumnName\" );\n\tif(!m_pIndexes)\n\t\trefreshIndexes();\n\tif(m_pIndexes->hasElements())\n\t{\n\t\tReference<XPropertySet> xCol;\n\t\tm_pColumns->getByIndex(_nColumnPos) >>= xCol;\n\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::isUniqueByColumnName column is null!\");\n\t\t::rtl::OUString sColName;\n\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= sColName;\n\n\t\tReference<XPropertySet> xIndex;\n\t\tfor(sal_Int32 i=0;i<m_pIndexes->getCount();++i)\n\t\t{\n\t\t\t::cppu::extractInterface(xIndex,m_pIndexes->getByIndex(i));\n\t\t\tif(xIndex.is() && getBOOL(xIndex->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISUNIQUE))))\n\t\t\t{\n\t\t\t\tReference<XNameAccess> xCols(Reference<XColumnsSupplier>(xIndex,UNO_QUERY)->getColumns());\n\t\t\t\tif(xCols->hasByName(sColName))\n\t\t\t\t\treturn xIndex;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn Reference<XPropertySet>();\n}\n//------------------------------------------------------------------\ndouble toDouble(const ByteString& rString)\n{\n    return ::rtl::math::stringToDouble( rString, '.', ',', NULL, NULL );\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::UpdateBuffer\" );\n\tOSL_ENSURE(m_pBuffer,\"Buffer is NULL!\");\n\tif ( !m_pBuffer )\n\t\treturn sal_False;\n\tsal_Int32 nByteOffset  = 1;\n\n\t// Felder aktualisieren:\n\tReference<XPropertySet> xCol;\n\tReference<XPropertySet> xIndex;\n\tsal_uInt16 i;\n\t::rtl::OUString aColName;\n\tconst sal_Int32 nColumnCount = m_pColumns->getCount();\n\t::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);\n\n\t::comphelper::UStringMixEqual aCase(isCaseSensitive());\n\n\tReference<XIndexAccess> xColumns = m_pColumns;\n\t// first search a key that exist already in the table\n\tfor (i = 0; i < nColumnCount; ++i)\n\t{\n\t\tsal_Int32 nPos = i;\n\t\tif(_xCols != xColumns)\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\tfor(nPos = 0;nPos<_xCols->getCount();++nPos)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xFindCol;\n\t\t\t\t::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));\n\t\t\t\tOSL_ENSURE(xFindCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\tif(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nPos >= _xCols->getCount())\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t++nPos;\n\t\txIndex = isUniqueByColumnName(i);\n\t\taIndexedCols[i] = xIndex;\n\t\tif (xIndex.is())\n\t\t{\n\t\t\t// first check if the value is different to the old one and when if it conform to the index\n\t\t\tif(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos]))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t//\tODbVariantRef xVar = (pVal == NULL) ? new ODbVariant() : pVal;\n\t\t\t\tReference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);\n\t\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::UpdateBuffer: No Index returned!\");\n\n\t\t\t\tif (pIndex->Find(0,*rRow.get()[nPos]))\n\t\t\t\t{\n\t\t\t\t\t// es existiert kein eindeutiger Wert\n\t\t\t\t\tif ( !aColName.getLength() )\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\t\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\t\t\t\t\t\txCol.clear();\n\t\t\t\t\t} // if ( !aColName.getLength() )\n                    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                            STR_DUPLICATE_VALUE_IN_COLUMN\n                            ,\"$columnname$\", aColName\n                         ) );\n                    ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// when we are here there is no double key in the table\n\n\tfor (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i)\n\t{\n\t\t// Laengen je nach Datentyp:\n\t\tOSL_ENSURE(i < m_aPrecisions.size(),\"Illegal index!\");\n\t\tsal_Int32 nLen = 0;\n\t\tsal_Int32 nType = 0;\n\t\tsal_Int32 nScale = 0;\n\t\tif ( i < m_aPrecisions.size() )\n\t\t{\n\t\t\tnLen\t= m_aPrecisions[i];\n\t\t\tnType\t= m_aTypes[i];\n\t\t\tnScale\t= m_aScales[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tif ( xCol.is() )\n\t\t\t{\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))\t>>= nLen;\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))\t\t>>= nType;\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))\t\t>>= nScale;\n\t\t\t}\n\t\t}\n\n        bool bSetZero = false;\n\t\tswitch (nType)\n\t\t{\n            case DataType::INTEGER:\n            case DataType::DOUBLE:\n            case DataType::TIMESTAMP:\n                bSetZero = true;\n            case DataType::LONGVARBINARY:\n\t\t\tcase DataType::DATE:\n            case DataType::BIT:\t\t\t\n\t\t\tcase DataType::LONGVARCHAR:\n                nLen = m_aRealFieldLengths[i]; \n                break;\n\t\t\tcase DataType::DECIMAL:\n\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale);\n\t\t\t\tbreak;\t// das Vorzeichen und das Komma\n\t\t\tdefault:\t\t\t\t\t\n                break;\n\n\t\t} // switch (nType)\n\n\t\tsal_Int32 nPos = i;\n\t\tif(_xCols != xColumns)\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\t\t\tfor(nPos = 0;nPos<_xCols->getCount();++nPos)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xFindCol;\n\t\t\t\t::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));\n\t\t\t\tif(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nPos >= _xCols->getCount())\n\t\t\t{\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\n\n\t\t++nPos; // the row values start at 1\n\t\t// Ist die Variable ueberhaupt gebunden?\n\t\tif ( !rRow.get()[nPos]->isBound() )\n\t\t{\n\t\t\t// Nein - naechstes Feld.\n\t\t\tnByteOffset += nLen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (aIndexedCols[i].is())\n\t\t{\n\t\t\tReference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY);\n\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::UpdateBuffer: No Index returned!\");\n\t\t\t// Update !!\n\t\t\tif (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )//&& pVal->isModified())\n\t\t\t\tpIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]);\n\t\t\telse\n\t\t\t\tpIndex->Insert(m_nFilePos,*rRow.get()[nPos]);\n\t\t}\n\n\t\tchar* pData = (char *)(m_pBuffer + nByteOffset);\n\t\tif (rRow.get()[nPos]->getValue().isNull())\n\t\t{\n            if ( bSetZero )\n                memset(pData,0,nLen);\t// Zuruecksetzen auf NULL\n            else\n\t\t\t    memset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\t\t\tnByteOffset += nLen;\n\t\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t\t\tcontinue;\n\t\t}\n\n        sal_Bool bHadError = sal_False;\n\t\ttry\n\t\t{\n\t\t\tswitch (nType)\n\t\t\t{\n                case DataType::TIMESTAMP:\n                    {\n                        sal_Int32 nJulianDate = 0, nJulianTime = 0;\n                        lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue());\n                        // Genau 8 Byte kopieren:\n\t\t\t\t\t    memcpy(pData,&nJulianDate,4);\n                        memcpy(pData+4,&nJulianTime,4);\n                    }\n                    break;\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t{\n\t\t\t\t\t::com::sun::star::util::Date aDate;\n\t\t\t\t\tif(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE)\n\t\t\t\t\t\taDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble());\n\t\t\t\t\telse\n\t\t\t\t\t\taDate = rRow.get()[nPos]->getValue();\n\t\t\t\t\tchar s[9];\n\t\t\t\t\tsnprintf(s,\n\t\t\t\t\t\tsizeof(s),\n\t\t\t\t\t\t\"%04d%02d%02d\",\n\t\t\t\t\t\t(int)aDate.Year,\n\t\t\t\t\t\t(int)aDate.Month,\n\t\t\t\t\t\t(int)aDate.Day);\n\n\t\t\t\t\t// Genau 8 Byte kopieren:\n\t\t\t\t\tstrncpy(pData,s,sizeof s - 1);\n\t\t\t\t} break;\n                case DataType::INTEGER:\n                    {\n                        sal_Int32 nValue = rRow.get()[nPos]->getValue();\n                        memcpy(pData,&nValue,nLen);\n                    }\n                    break;\n                case DataType::DOUBLE:\n                    {\n                        const double d = rRow.get()[nPos]->getValue();\n                        m_pColumns->getByIndex(i) >>= xCol;\n                        \n                        if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        {\n                            sal_Int64 nValue = 0;\n                            if ( m_aScales[i] )\n                                nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i]));\n                            else\n                                nValue = (sal_Int64)(d);\n                            memcpy(pData,&nValue,nLen);\n                        } // if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        else\n                            memcpy(pData,&d,nLen);\n                    }\n                    break;\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\t{\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\n\t\t\t\t\tconst double n = rRow.get()[nPos]->getValue();\n\n\t\t\t\t\t// ein const_cast, da GetFormatPrecision am SvNumberFormat nicht const ist, obwohl es das eigentlich\n\t\t\t\t\t// sein koennte und muesste\n\n\t\t\t\t\tconst ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0));\n                    sal_Bool bValidLength  = aDefaultValue.Len() <= nLen;\n                    if ( bValidLength )\n                    {\n\t\t\t\t\t    strncpy(pData,aDefaultValue.GetBuffer(),nLen);\n\t\t\t\t\t    // write the resulting double back\n\t\t\t\t\t    *rRow.get()[nPos] = toDouble(aDefaultValue);\n                    }\n                    else\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\t\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n                        ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes;\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$columnname$\", aColName));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$precision$\", String::CreateFromInt32(nLen)));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$scale$\", String::CreateFromInt32(nScale)));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$value$\", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8)));\n\n                        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                                STR_INVALID_COLUMN_DECIMAL_VALUE\n                                ,aStringToSubstitutes\n                             ) );\n                        ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t\t\t}\n\t\t\t\t} break;\n\t\t\t\tcase DataType::BIT:\n\t\t\t\t\t*pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F';\n\t\t\t\t\tbreak;\n                case DataType::LONGVARBINARY:\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t{\n\t\t\t\t\tchar cNext = pData[nLen]; // merken und temporaer durch 0 ersetzen\n\t\t\t\t\tpData[nLen] = '\\0';\t\t  // das geht, da der Puffer immer ein Zeichen groesser ist ...\n\n\t\t\t\t\tsal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10);\t// Blocknummer lesen\n\n\t\t\t\t\t// Naechstes Anfangszeichen wieder restaurieren:\n\t\t\t\t\tpData[nLen] = cNext;\n\t\t\t\t\tif (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tByteString aStr;\n\t\t\t\t\tByteString aBlock(ByteString::CreateFromInt32(nBlockNo));\n\t\t\t\t\taStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' );\n\t\t\t\t\taStr += aBlock;\n\t\t\t\t\t// Zeichen kopieren:\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\t\t\t\t\tmemcpy(pData, aStr.GetBuffer(), nLen);\n\t\t\t\t}\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\n                    ::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() );\n\n                    // convert the string, using the connection's encoding\n                    ::rtl::OString sEncoded;\n                   \n                    DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding );\n                    memcpy( pData, sEncoded.getStr(), sEncoded.getLength() );\n\n\t\t\t\t}\n                break;\n\t\t\t}\n\t\t}\n\t\tcatch( SQLException&  )\n        {\n            throw;\n        }\n\t\tcatch ( Exception& ) { bHadError = sal_True; }\n\n\t\tif ( bHadError )\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE( xCol.is(), \"ODbaseTable::UpdateBuffer column is null!\" );\n            if ( xCol.is() )\n\t\t\t    xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\tconst ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                    STR_INVALID_COLUMN_VALUE,\n                    \"$columnname$\", aColName\n                 ) );\n            ::dbtools::throwGenericSQLException( sError, *this );\n\t\t}\n\t\t// Und weiter ...\n\t\tnByteOffset += nLen;\n\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t}\n\treturn sal_True;\n}\n\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::WriteMemo(ORowSetValue& aVariable, sal_uIntPtr& rBlockNr)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::WriteMemo\" );\n\t// wird die BlockNr 0 vorgegeben, wird der block ans Ende gehaengt\n    sal_uIntPtr nSize = 0;\n    ::rtl::OString aStr;\n    ::com::sun::star::uno::Sequence<sal_Int8> aValue;\n\tsal_uInt8 nHeader[4];\n    const bool bBinary = aVariable.getTypeKind() == DataType::LONGVARBINARY && m_aMemoHeader.db_typ == MemoFoxPro;\n    if ( bBinary )\n    {\n        aValue = aVariable.getSequence();\n        nSize = aValue.getLength();\n    }\n    else\n    {\n        nSize = DBTypeConversion::convertUnicodeString( aVariable.getString(), aStr, m_eEncoding );\n    }\n\n\t// Anhaengen oder ueberschreiben\n\tsal_Bool bAppend = rBlockNr == 0;\n\n\tif (!bAppend)\n\t{\n\t\tswitch (m_aMemoHeader.db_typ)\n\t\t{\n\t\t\tcase MemodBaseIII: // dBase III-Memofeld, endet mit 2 * Ctrl-Z\n\t\t\t\tbAppend = nSize > (512 - 2);\n\t\t\t\tbreak;\n\t\t\tcase MemoFoxPro:\n\t\t\tcase MemodBaseIV: // dBase IV-Memofeld mit Laengenangabe\n\t\t\t{\n\t\t\t\tchar sHeader[4];\n\t\t\t\tm_pMemoStream->Seek(rBlockNr * m_aMemoHeader.db_size);\n\t\t\t\tm_pMemoStream->SeekRel(4L);\n\t\t\t\tm_pMemoStream->Read(sHeader,4);\n\n\t\t\t\tsal_uIntPtr nOldSize;\n\t\t\t\tif (m_aMemoHeader.db_typ == MemoFoxPro)\n\t\t\t\t\tnOldSize = ((((unsigned char)sHeader[0]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[1]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[2]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[3];\n\t\t\t\telse\n\t\t\t\t\tnOldSize = ((((unsigned char)sHeader[3]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[2]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[1]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[0]  - 8;\n\n\t\t\t\t// passt die neue Laenge in die belegten Bloecke\n\t\t\t\tsal_uIntPtr nUsedBlocks = ((nSize + 8) / m_aMemoHeader.db_size) + (((nSize + 8) % m_aMemoHeader.db_size > 0) ? 1 : 0),\n\t\t\t\t\t  nOldUsedBlocks = ((nOldSize + 8) / m_aMemoHeader.db_size) + (((nOldSize + 8) % m_aMemoHeader.db_size > 0) ? 1 : 0);\n\t\t\t\tbAppend = nUsedBlocks > nOldUsedBlocks;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bAppend)\n\t{\n\t\tsal_uIntPtr nStreamSize = m_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\t// letzten block auffuellen\n\t\trBlockNr = (nStreamSize / m_aMemoHeader.db_size) + ((nStreamSize % m_aMemoHeader.db_size) > 0 ? 1 : 0);\n\n\t\tm_pMemoStream->SetStreamSize(rBlockNr * m_aMemoHeader.db_size);\n\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t}\n\telse\n\t{\n\t\tm_pMemoStream->Seek(rBlockNr * m_aMemoHeader.db_size);\n\t}\n\n\tswitch (m_aMemoHeader.db_typ)\n\t{\n\t\tcase MemodBaseIII: // dBase III-Memofeld, endet mit Ctrl-Z\n\t\t{\n\t\t\tconst char cEOF = (char) DBF_EOL;\n\t\t\tnSize++;\n\t\t\tm_pMemoStream->Write( aStr.getStr(), aStr.getLength() );\n\t\t\t(*m_pMemoStream) << cEOF << cEOF;\n\t\t} break;\n\t\tcase MemoFoxPro:\n\t\tcase MemodBaseIV: // dBase IV-Memofeld mit Laengenangabe\n\t\t{\n            if ( MemodBaseIV == m_aMemoHeader.db_typ )\n\t\t\t    (*m_pMemoStream) << (sal_uInt8)0xFF\n\t\t\t\t\t\t\t     << (sal_uInt8)0xFF\n\t\t\t\t\t\t\t     << (sal_uInt8)0x08;\n            else\n                (*m_pMemoStream) << (sal_uInt8)0x00\n\t\t\t\t\t\t\t     << (sal_uInt8)0x00\n\t\t\t\t\t\t\t     << (sal_uInt8)0x00;\n\n\t\t\tsal_uInt32 nWriteSize = nSize;\n\t\t\tif (m_aMemoHeader.db_typ == MemoFoxPro)\n\t\t\t{\n                if ( bBinary )\n                    (*m_pMemoStream) << (sal_uInt8) 0x00; // Picture\n                else\n\t\t\t\t    (*m_pMemoStream) << (sal_uInt8) 0x01; // Memo\n\t\t\t\tfor (int i = 4; i > 0; nWriteSize >>= 8)\n\t\t\t\t\tnHeader[--i] = (sal_uInt8) (nWriteSize % 256);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*m_pMemoStream) << (sal_uInt8) 0x00;\n\t\t\t\tnWriteSize += 8;\n\t\t\t\tfor (int i = 0; i < 4; nWriteSize >>= 8)\n\t\t\t\t\tnHeader[i++] = (sal_uInt8) (nWriteSize % 256);\n\t\t\t}\n\n\t\t\tm_pMemoStream->Write(nHeader,4);\n            if ( bBinary )\n                m_pMemoStream->Write( aValue.getConstArray(), aValue.getLength() );\n            else\n\t\t\t    m_pMemoStream->Write( aStr.getStr(), aStr.getLength() );\n\t\t\tm_pMemoStream->Flush();\n\t\t}\n\t}\n\n\n\t// Schreiben der neuen Blocknummer\n\tif (bAppend)\n\t{\n\t\tsal_uIntPtr nStreamSize = m_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\tm_aMemoHeader.db_next = (nStreamSize / m_aMemoHeader.db_size) + ((nStreamSize % m_aMemoHeader.db_size) > 0 ? 1 : 0);\n\n\t\t// Schreiben der neuen Blocknummer\n\t\tm_pMemoStream->Seek(0L);\n\t\t(*m_pMemoStream) << m_aMemoHeader.db_next;\n\t\tm_pMemoStream->Flush();\n\t}\n\treturn sal_True;\n}\n\n// -----------------------------------------------------------------------------\n// XAlterTable\nvoid SAL_CALL ODbaseTable::alterColumnByName( const ::rtl::OUString& colName, const Reference< XPropertySet >& descriptor ) throw(SQLException, NoSuchElementException, RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::alterColumnByName\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tcheckDisposed(OTableDescriptor_BASE::rBHelper.bDisposed);\n\n\n\tReference<XDataDescriptorFactory> xOldColumn;\n\tm_pColumns->getByName(colName) >>= xOldColumn;\n\n\talterColumn(m_pColumns->findColumn(colName)-1,descriptor,xOldColumn);\n}\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::alterColumnByIndex( sal_Int32 index, const Reference< XPropertySet >& descriptor ) throw(SQLException, ::com::sun::star::lang::IndexOutOfBoundsException, RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::alterColumnByIndex\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tcheckDisposed(OTableDescriptor_BASE::rBHelper.bDisposed);\n\n\tif(index < 0 || index >= m_pColumns->getCount())\n\t\tthrow IndexOutOfBoundsException(::rtl::OUString::valueOf(index),*this);\n\n\tReference<XDataDescriptorFactory> xOldColumn;\n\tm_pColumns->getByIndex(index) >>= xOldColumn;\n\talterColumn(index,descriptor,xOldColumn);\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::alterColumn(sal_Int32 index,\n\t\t\t\t\t\t\t  const Reference< XPropertySet >& descriptor ,\n\t\t\t\t\t\t\t  const Reference< XDataDescriptorFactory >& xOldColumn )\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::alterColumn\" );\n\tif(index < 0 || index >= m_pColumns->getCount())\n\t\tthrow IndexOutOfBoundsException(::rtl::OUString::valueOf(index),*this);\n\n\tODbaseTable* pNewTable = NULL;\n\ttry\n\t{\n\t\tOSL_ENSURE(descriptor.is(),\"ODbaseTable::alterColumn: descriptor can not be null!\");\n\t\t// creates a copy of the the original column and copy all properties from descriptor in xCopyColumn\n\t\tReference<XPropertySet> xCopyColumn;\n\t\tif(xOldColumn.is())\n\t\t\txCopyColumn = xOldColumn->createDataDescriptor();\n\t\telse\n\t\t\txCopyColumn = new OColumn(getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers());\n\n\t\t::comphelper::copyProperties(descriptor,xCopyColumn);\n\n\t\t// creates a temp file\n\n\t\tString sTempName = createTempFile();\n\n\t\tpNewTable = new ODbaseTable(m_pTables,static_cast<ODbaseConnection*>(m_pConnection));\n\t\tReference<XPropertySet> xHoldTable = pNewTable;\n\t\tpNewTable->setPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME),makeAny(::rtl::OUString(sTempName)));\n\t\tReference<XAppend> xAppend(pNewTable->getColumns(),UNO_QUERY);\n\t\tOSL_ENSURE(xAppend.is(),\"ODbaseTable::alterColumn: No XAppend interface!\");\n\n\t\t// copy the structure\n\t\tsal_Int32 i=0;\n\t\tfor(;i < index;++i)\n\t\t{\n\t\t\tReference<XPropertySet> xProp;\n\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\tReference<XPropertySet> xCpy;\n\t\t\tif(xColumn.is())\n\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\telse\n\t\t\t\txCpy = new OColumn(getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers());\n\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t}\n\t\t++i; // now insert our new column\n\t\txAppend->appendByDescriptor(xCopyColumn);\n\n\t\tfor(;i < m_pColumns->getCount();++i)\n\t\t{\n\t\t\tReference<XPropertySet> xProp;\n\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\tReference<XPropertySet> xCpy;\n\t\t\tif(xColumn.is())\n\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\telse\n\t\t\t\txCpy = new OColumn(getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers());\n\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t}\n\n\t\t// construct the new table\n\t\tif(!pNewTable->CreateImpl())\n\t\t{\n            const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                    STR_COLUMN_NOT_ALTERABLE,\n                    \"$columnname$\", ::comphelper::getString(descriptor->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)))\n                 ) );\n            ::dbtools::throwGenericSQLException( sError, *this );\n\t\t}\n\n\t\tpNewTable->construct();\n\n\t\t// copy the data\n\t\tcopyData(pNewTable,0);\n\n\t\t// now drop the old one\n\t\tif( DropImpl() ) // we don't want to delete the memo columns too\n\t\t{\n\t\t\t// rename the new one to the old one\n\t\t\tpNewTable->renameImpl(m_Name);\n\t\t\t// release the temp file\n\t\t\tpNewTable = NULL;\n\t\t\t::comphelper::disposeComponent(xHoldTable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpNewTable = NULL;\n\t\t}\n\t\tFileClose();\n\t\tconstruct();\n\t\tif(m_pColumns)\n\t\t\tm_pColumns->refresh();\n\n\t}\n\tcatch(const SQLException&)\n\t{\n\t\tthrow;\n\t}\n\tcatch(const Exception&)\n\t{\n\t\tOSL_ENSURE(0,\"ODbaseTable::alterColumn: Exception occured!\");\n\t\tthrow;\n\t}\n}\n// -----------------------------------------------------------------------------\nReference< XDatabaseMetaData> ODbaseTable::getMetaData() const\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getMetaData\" );\n\treturn getConnection()->getMetaData();\n}\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::rename( const ::rtl::OUString& newName ) throw(::com::sun::star::sdbc::SQLException, ::com::sun::star::container::ElementExistException, ::com::sun::star::uno::RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::rename\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tcheckDisposed(OTableDescriptor_BASE::rBHelper.bDisposed);\n\tif(m_pTables && m_pTables->hasByName(newName))\n\t\tthrow ElementExistException(newName,*this);\n\n\n\trenameImpl(newName);\n\n\tODbaseTable_BASE::rename(newName);\n\n\tconstruct();\n\tif(m_pColumns)\n\t\tm_pColumns->refresh();\n}\nnamespace\n{\n\tvoid renameFile(OConnection* _pConenction,const ::rtl::OUString& oldName,\n\t\t\t\t\tconst ::rtl::OUString& newName,const String& _sExtension)\n\t{\n\t\tString aName = ODbaseTable::getEntry(_pConenction,oldName);\n\t\tif(!aName.Len())\n\t\t{\n\t\t\t::rtl::OUString aIdent = _pConenction->getContent()->getIdentifier()->getContentIdentifier();\n\t\t\tif ( aIdent.lastIndexOf('/') != (aIdent.getLength()-1) )\n\t\t\t\taIdent += ::rtl::OUString::createFromAscii(\"/\");\n\t\t\taIdent += oldName;\n\t\t\taName = aIdent;\n\t\t}\n\t\tINetURLObject aURL;\n\t\taURL.SetURL(aName);\n\n\t\taURL.setExtension( _sExtension );\n\t\tString sNewName(newName);\n\t\tsNewName.AppendAscii(\".\");\n\t\tsNewName += _sExtension;\n\n\t\ttry\n\t\t{\n\t\t\tContent aContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\n\t\t\tSequence< PropertyValue > aProps( 1 );\n\t\t\taProps[0].Name\t\t= ::rtl::OUString::createFromAscii(\"Title\");\n\t\t\taProps[0].Handle\t= -1; // n/a\n\t\t\taProps[0].Value\t\t= makeAny( ::rtl::OUString(sNewName) );\n\t\t\tSequence< Any > aValues;\n\t\t\taContent.executeCommand( rtl::OUString::createFromAscii( \"setPropertyValues\" ),makeAny(aProps) ) >>= aValues;\n\t\t\tif(aValues.getLength() && aValues[0].hasValue())\n\t\t\t\tthrow Exception();\n\t\t}\n\t\tcatch(Exception&)\n\t\t{\n\t\t\tthrow ElementExistException(newName,NULL);\n\t\t}\n\t}\n}\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::renameImpl( const ::rtl::OUString& newName ) throw(::com::sun::star::sdbc::SQLException, ::com::sun::star::container::ElementExistException, ::com::sun::star::uno::RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getEntry\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\n\tFileClose();\n\n\n\trenameFile(m_pConnection,m_Name,newName,m_pConnection->getExtension());\n\tif ( HasMemoFields() )\n\t{  // delete the memo fields\n\t\tString sExt = String::CreateFromAscii(\"dbt\");\n\t\trenameFile(m_pConnection,m_Name,newName,sExt);\n\t}\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::addColumn(const Reference< XPropertySet >& _xNewColumn)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::addColumn\" );\n\tString sTempName = createTempFile();\n\n\tODbaseTable* pNewTable = new ODbaseTable(m_pTables,static_cast<ODbaseConnection*>(m_pConnection));\n\tReference< XPropertySet > xHold = pNewTable;\n\tpNewTable->setPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME),makeAny(::rtl::OUString(sTempName)));\n\t{\n\t\tReference<XAppend> xAppend(pNewTable->getColumns(),UNO_QUERY);\n\t\tsal_Bool bCase = getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers();\n\t\t// copy the structure\n\t\tfor(sal_Int32 i=0;i < m_pColumns->getCount();++i)\n\t\t{\n\t\t\tReference<XPropertySet> xProp;\n\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\tReference<XPropertySet> xCpy;\n\t\t\tif(xColumn.is())\n\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\telse\n\t\t\t{\n\t\t\t\txCpy = new OColumn(bCase);\n\t\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\t}\n\n\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t}\n\t\tReference<XPropertySet> xCpy = new OColumn(bCase);\n\t\t::comphelper::copyProperties(_xNewColumn,xCpy);\n\t\txAppend->appendByDescriptor(xCpy);\n\t}\n\n\t// construct the new table\n\tif(!pNewTable->CreateImpl())\n\t{\n        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_COLUMN_NOT_ADDABLE,\n                \"$columnname$\", ::comphelper::getString(_xNewColumn->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)))\n             ) );\n        ::dbtools::throwGenericSQLException( sError, *this );\n\t}\n\n\tsal_Bool bAlreadyDroped = sal_False;\n\ttry\n\t{\n\t\tpNewTable->construct();\n\t\t// copy the data\n\t\tcopyData(pNewTable,pNewTable->m_pColumns->getCount());\n\t\t// drop the old table\n\t\tif(DropImpl())\n\t\t{\n\t\t\tbAlreadyDroped = sal_True;\n\t\t\tpNewTable->renameImpl(m_Name);\n\t\t\t// release the temp file\n\t\t}\n\t\txHold = pNewTable = NULL;\n\n\t\tFileClose();\n\t\tconstruct();\n\t\tif(m_pColumns)\n\t\t\tm_pColumns->refresh();\n\t}\n\tcatch(const SQLException&)\n\t{\n\t\t// here we know that the old table wasn't droped before\n\t\tif(!bAlreadyDroped)\n\t\t\txHold = pNewTable = NULL;\n\n\t\tthrow;\n\t}\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::dropColumn(sal_Int32 _nPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::dropColumn\" );\n\tString sTempName = createTempFile();\n\n\tODbaseTable* pNewTable = new ODbaseTable(m_pTables,static_cast<ODbaseConnection*>(m_pConnection));\n\tReference< XPropertySet > xHold = pNewTable;\n\tpNewTable->setPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME),makeAny(::rtl::OUString(sTempName)));\n\t{\n\t\tReference<XAppend> xAppend(pNewTable->getColumns(),UNO_QUERY);\n\t\tsal_Bool bCase = getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers();\n\t\t// copy the structure\n\t\tfor(sal_Int32 i=0;i < m_pColumns->getCount();++i)\n\t\t{\n\t\t\tif(_nPos != i)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xProp;\n\t\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\t\tReference<XPropertySet> xCpy;\n\t\t\t\tif(xColumn.is())\n\t\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\txCpy = new OColumn(bCase);\n\t\t\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\t\t}\n\t\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t\t}\n\t\t}\n\t}\n\n\t// construct the new table\n\tif(!pNewTable->CreateImpl())\n\t{\n\t\txHold = pNewTable = NULL;\n        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_COLUMN_NOT_DROP,\n                \"$position$\", ::rtl::OUString::valueOf(_nPos)\n             ) );\n        ::dbtools::throwGenericSQLException( sError, *this );\n\t}\n\tpNewTable->construct();\n\t// copy the data\n\tcopyData(pNewTable,_nPos);\n\t// drop the old table\n\tif(DropImpl())\n\t\tpNewTable->renameImpl(m_Name);\n\t\t// release the temp file\n\n\txHold = pNewTable = NULL;\n\n\tFileClose();\n\tconstruct();\n}\n// -----------------------------------------------------------------------------\nString ODbaseTable::createTempFile()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::createTempFile\" );\n\t::rtl::OUString aIdent = m_pConnection->getContent()->getIdentifier()->getContentIdentifier();\n\tif ( aIdent.lastIndexOf('/') != (aIdent.getLength()-1) )\n\t\taIdent += ::rtl::OUString::createFromAscii(\"/\");\n\tString sTempName(aIdent);\n\tString sExt;\n\tsExt.AssignAscii(\".\");\n\tsExt += m_pConnection->getExtension();\n\n\tString sName(m_Name);\n\tTempFile aTempFile(sName,&sExt,&sTempName);\n\tif(!aTempFile.IsValid())\n        getConnection()->throwGenericSQLException(STR_COULD_NOT_ALTER_TABLE,*this);\n\n\tINetURLObject aURL;\n\taURL.SetSmartProtocol(INET_PROT_FILE);\n\taURL.SetURL(aTempFile.GetURL());\n\n\tString sNewName(aURL.getName());\n\tsNewName.Erase(sNewName.Len() - sExt.Len());\n\treturn sNewName;\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::copyData(ODbaseTable* _pNewTable,sal_Int32 _nPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::copyData\" );\n\tsal_Int32 nPos = _nPos + 1; // +1 because we always have the bookmark clumn as well\n\tOValueRefRow aRow = new OValueRefVector(m_pColumns->getCount());\n\tOValueRefRow aInsertRow;\n\tif(_nPos)\n\t{\n\t\taInsertRow = new OValueRefVector(_pNewTable->m_pColumns->getCount());\n\t\t::std::for_each(aInsertRow->get().begin(),aInsertRow->get().end(),TSetRefBound(sal_True));\n\t}\n\telse\n\t\taInsertRow = aRow;\n\n\t// we only have to bind the values which we need to copy into the new table\n\t::std::for_each(aRow->get().begin(),aRow->get().end(),TSetRefBound(sal_True));\n\tif(_nPos && (_nPos < (sal_Int32)aRow->get().size()))\n\t\t(aRow->get())[nPos]->setBound(sal_False);\n\n\n\tsal_Bool bOk = sal_True;\n\tsal_Int32 nCurPos;\n\tOValueRefVector::Vector::iterator aIter;\n\tfor(sal_uInt32 nRowPos = 0; nRowPos < m_aHeader.db_anz;++nRowPos)\n\t{\n        bOk = seekRow( IResultSetHelper::BOOKMARK, nRowPos+1, nCurPos );\n        if ( bOk )\n\t\t{\n            bOk = fetchRow( aRow, m_aColumns.getBody(), sal_True, sal_True);\n            if ( bOk && !aRow->isDeleted() ) // copy only not deleted rows\n\t\t\t{\n\t\t\t\t// special handling when pos == 0 then we don't have to distinguish\tbetween the two rows\n\t\t\t\tif(_nPos)\n\t\t\t\t{\n\t\t\t\t\taIter = aRow->get().begin()+1;\n\t\t\t\t\tsal_Int32 nCount = 1;\n\t\t\t\t\tfor(OValueRefVector::Vector::iterator aInsertIter = aInsertRow->get().begin()+1; aIter != aRow->get().end() && aInsertIter != aInsertRow->get().end();++aIter,++nCount)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(nPos != nCount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(*aInsertIter)->setValue( (*aIter)->getValue() );\n\t\t\t\t\t\t\t++aInsertIter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbOk = _pNewTable->InsertRow(*aInsertRow,sal_True,_pNewTable->m_pColumns);\n\t\t\t\tOSL_ENSURE(bOk,\"Row could not be inserted!\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tOSL_ENSURE(bOk,\"Row could not be fetched!\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOSL_ASSERT(0);\n\t\t}\n\t} // for(sal_uInt32 nRowPos = 0; nRowPos < m_aHeader.db_anz;++nRowPos)\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::throwInvalidDbaseFormat()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::throwInvalidDbaseFormat\" );\n\tFileClose();\n\t// no dbase file\n    \n    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_INVALID_DBASE_FILE,\n                \"$filename$\", getEntry(m_pConnection,m_Name)\n             ) );\n    ::dbtools::throwGenericSQLException( sError, *this );\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::refreshHeader()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::refreshHeader\" );\n    if ( m_aHeader.db_anz == 0 )\n\t    readHeader();\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::seekRow(IResultSetHelper::Movement eCursorPosition, sal_Int32 nOffset, sal_Int32& nCurPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::seekRow\" );\n\t// ----------------------------------------------------------\n\t// Positionierung vorbereiten:\n\tOSL_ENSURE(m_pFileStream,\"ODbaseTable::seekRow: FileStream is NULL!\");\n\n\tsal_uInt32  nNumberOfRecords = (sal_uInt32)m_aHeader.db_anz;\n\tsal_uInt32 nTempPos = m_nFilePos;\n\tm_nFilePos = nCurPos;\n\n\tswitch(eCursorPosition)\n\t{\n\t\tcase IResultSetHelper::NEXT:\n\t\t\t++m_nFilePos;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::PRIOR:\n\t\t\tif (m_nFilePos > 0)\n\t\t\t\t--m_nFilePos;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::FIRST:\n\t\t\tm_nFilePos = 1;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::LAST:\n\t\t\tm_nFilePos = nNumberOfRecords;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::RELATIVE:\n\t\t\tm_nFilePos = (((sal_Int32)m_nFilePos) + nOffset < 0) ? 0L\n\t\t\t\t\t\t\t: (sal_uInt32)(((sal_Int32)m_nFilePos) + nOffset);\n\t\t\tbreak;\n\t\tcase IResultSetHelper::ABSOLUTE:\n\t\tcase IResultSetHelper::BOOKMARK:\n\t\t\tm_nFilePos = (sal_uInt32)nOffset;\n\t\t\tbreak;\n\t}\n\n\tif (m_nFilePos > (sal_Int32)nNumberOfRecords)\n\t\tm_nFilePos = (sal_Int32)nNumberOfRecords + 1;\n\n\tif (m_nFilePos == 0 || m_nFilePos == (sal_Int32)nNumberOfRecords + 1)\n\t\tgoto Error;\n\telse\n\t{\n\t\tsal_uInt16 nEntryLen = m_aHeader.db_slng;\n\n\t\tOSL_ENSURE(m_nFilePos >= 1,\"SdbDBFCursor::FileFetchRow: ungueltige Record-Position\");\n\t\tsal_Int32 nPos = m_aHeader.db_kopf + (sal_Int32)(m_nFilePos-1) * nEntryLen;\n\n\t\tsal_uIntPtr nLen = m_pFileStream->Seek(nPos);\n\t\tif (m_pFileStream->GetError() != ERRCODE_NONE)\n\t\t\tgoto Error;\n\n\t\tnLen = m_pFileStream->Read((char*)m_pBuffer, nEntryLen);\n\t\tif (m_pFileStream->GetError() != ERRCODE_NONE)\n\t\t\tgoto Error;\n\t}\n\tgoto End;\n\nError:\n\tswitch(eCursorPosition)\n\t{\n\t\tcase IResultSetHelper::PRIOR:\n\t\tcase IResultSetHelper::FIRST:\n\t\t\tm_nFilePos = 0;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::LAST:\n\t\tcase IResultSetHelper::NEXT:\n\t\tcase IResultSetHelper::ABSOLUTE:\n\t\tcase IResultSetHelper::RELATIVE:\n\t\t\tif (nOffset > 0)\n\t\t\t\tm_nFilePos = nNumberOfRecords + 1;\n\t\t\telse if (nOffset < 0)\n\t\t\t\tm_nFilePos = 0;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::BOOKMARK:\n\t\t\tm_nFilePos = nTempPos;\t // vorherige Position\n\t}\n\t//\taStatus.Set(SDB_STAT_NO_DATA_FOUND);\n\treturn sal_False;\n\nEnd:\n\tnCurPos = m_nFilePos;\n\treturn sal_True;\n}\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::ReadMemo(sal_uIntPtr nBlockNo, ORowSetValue& aVariable)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ReadMemo\" );\n\tsal_Bool bIsText = sal_True;\n\t//\tSdbConnection* pConnection = GetConnection();\n\n\tm_pMemoStream->Seek(nBlockNo * m_aMemoHeader.db_size);\n\tswitch (m_aMemoHeader.db_typ)\n\t{\n\t\tcase MemodBaseIII: // dBase III-Memofeld, endet mit Ctrl-Z\n\t\t{\n\t\t\tconst char cEOF = (char) DBF_EOL;\n\t\t\tByteString aBStr;\n\t\t\tstatic char aBuf[514];\n\t\t\taBuf[512] = 0;\t\t\t// sonst kann der Zufall uebel mitspielen\n\t\t\tsal_Bool bReady = sal_False;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm_pMemoStream->Read(&aBuf,512);\n\n\t\t\t\tsal_uInt16 i = 0;\n\t\t\t\twhile (aBuf[i] != cEOF && ++i < 512)\n\t\t\t\t\t;\n\t\t\t\tbReady = aBuf[i] == cEOF;\n\n\t\t\t\taBuf[i] = 0;\n\t\t\t\taBStr += aBuf;\n\n\t\t\t} while (!bReady && !m_pMemoStream->IsEof() && aBStr.Len() < STRING_MAXLEN);\n\n\t\t\t::rtl::OUString aStr(aBStr.GetBuffer(), aBStr.Len(),m_eEncoding);\n\t\t\taVariable = aStr;\n\n\t\t} break;\n\t\tcase MemoFoxPro:\n\t\tcase MemodBaseIV: // dBase IV-Memofeld mit Laengenangabe\n\t\t{\n\t\t\tchar sHeader[4];\n\t\t\tm_pMemoStream->Read(sHeader,4);\n\t\t\t// Foxpro stores text and binary data\n\t\t\tif (m_aMemoHeader.db_typ == MemoFoxPro)\n\t\t\t{\n//\t\t\t\tif (((sal_uInt8)sHeader[0]) != 0 || ((sal_uInt8)sHeader[1]) != 0 || ((sal_uInt8)sHeader[2]) != 0)\n//\t\t\t\t{\n////\t\t\t\t\tString aText = String(SdbResId(STR_STAT_IResultSetHelper::INVALID));\n////\t\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%d\"),m_pMemoStream->GetFileName());\n////\t\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%t\"),aStatus.TypeToString(MEMO));\n////\t\t\t\t\taStatus.Set(SDB_STAT_ERROR,\n////\t\t\t\t\t\t\tString::CreateFromAscii(\"01000\"),\n////\t\t\t\t\t\t\taStatus.CreateErrorMessage(aText),\n////\t\t\t\t\t\t\t0, String() );\n//\t\t\t\t\treturn sal_False;\n//\t\t\t\t}\n//\n\t\t\t\tbIsText = sHeader[3] != 0;\n\t\t\t}\n\t\t\telse if (((sal_uInt8)sHeader[0]) != 0xFF || ((sal_uInt8)sHeader[1]) != 0xFF || ((sal_uInt8)sHeader[2]) != 0x08)\n\t\t\t{\n//\t\t\t\tString aText = String(SdbResId(STR_STAT_IResultSetHelper::INVALID));\n//\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%d\"),m_pMemoStream->GetFileName());\n//\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%t\"),aStatus.TypeToString(MEMO));\n//\t\t\t\taStatus.Set(SDB_STAT_ERROR,\n//\t\t\t\t\t\tString::CreateFromAscii(\"01000\"),\n//\t\t\t\t\t\taStatus.CreateErrorMessage(aText),\n//\t\t\t\t\t\t0, String() );\n\t\t\t\treturn sal_False;\n\t\t\t}\n\n\t\t\tsal_uInt32 nLength(0);\n\t\t\t(*m_pMemoStream) >> nLength;\n\n\t\t\tif (m_aMemoHeader.db_typ == MemodBaseIV)\n\t\t\t\tnLength -= 8;\n\n            if ( nLength )\n            {\n                if ( bIsText )\n                {\n\t\t\t        //\tchar cChar;\n\t\t\t\t\t::rtl::OUStringBuffer aStr;\n\t\t\t        while ( nLength > STRING_MAXLEN )\n\t\t\t        {\n\t\t\t\t        ByteString aBStr;\n\t\t\t\t        aBStr.Expand(STRING_MAXLEN);\n\t\t\t\t        m_pMemoStream->Read(aBStr.AllocBuffer(STRING_MAXLEN),STRING_MAXLEN);\n\t\t\t\t\t\taStr.append(::rtl::OUString(aBStr.GetBuffer(),aBStr.Len(), m_eEncoding));\n\t\t\t\t        nLength -= STRING_MAXLEN;\n\t\t\t        }\n\t\t\t        if ( nLength > 0 )\n\t\t\t        {\n\t\t\t\t        ByteString aBStr;\n\t\t\t\t        aBStr.Expand(static_cast<xub_StrLen>(nLength));\n\t\t\t\t        m_pMemoStream->Read(aBStr.AllocBuffer(static_cast<xub_StrLen>(nLength)),nLength);\n\t\t\t\t        //\taBStr.ReleaseBufferAccess();\n\t\t\t\t\t\taStr.append(::rtl::OUString(aBStr.GetBuffer(),aBStr.Len(), m_eEncoding));\n\t\t\t        }\n\t\t\t        if ( aStr.getLength() )\n\t\t\t\t\t\taVariable = aStr.makeStringAndClear();\n                } // if ( bIsText )\n                else\n                {\n                    ::com::sun::star::uno::Sequence< sal_Int8 > aData(nLength);\n                    m_pMemoStream->Read(aData.getArray(),nLength);\n                    aVariable = aData;\n                }\n            } // if ( nLength )\n\t\t}\n\t}\n\treturn sal_True;\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::AllocBuffer()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::AllocBuffer\" );\n\tsal_uInt16 nSize = m_aHeader.db_slng;\n\tOSL_ENSURE(nSize > 0, \"Size too small\");\n\n\tif (m_nBufferSize != nSize)\n\t{\n\t\tdelete m_pBuffer;\n\t\tm_pBuffer = NULL;\n\t}\n\n\t// Falls noch kein Puffer vorhanden: allozieren:\n\tif (m_pBuffer == NULL && nSize > 0)\n\t{\n\t\tm_nBufferSize = nSize;\n\t\tm_pBuffer\t\t= new sal_uInt8[m_nBufferSize+1];\n\t}\n}\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::WriteBuffer()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::WriteBuffer\" );\n\tOSL_ENSURE(m_nFilePos >= 1,\"SdbDBFCursor::FileFetchRow: ungueltige Record-Position\");\n\n\t// Auf gewuenschten Record positionieren:\n\tlong nPos = m_aHeader.db_kopf + (long)(m_nFilePos-1) * m_aHeader.db_slng;\n\tm_pFileStream->Seek(nPos);\n\treturn m_pFileStream->Write((char*) m_pBuffer, m_aHeader.db_slng) > 0;\n}\n// -----------------------------------------------------------------------------\nsal_Int32 ODbaseTable::getCurrentLastPos() const\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getCurrentLastPos\" );\n\treturn m_aHeader.db_anz;\n}\n"], "fixing_code": ["/**************************************************************\n * \n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n * \n *************************************************************/\n\n\n\n// MARKER(update_precomp.py): autogen include statement, do not remove\n#include \"precompiled_connectivity.hxx\"\n#include \"dbase/DTable.hxx\"\n#include <com/sun/star/sdbc/ColumnValue.hpp>\n#include <com/sun/star/sdbc/DataType.hpp>\n#include <com/sun/star/ucb/XContentAccess.hpp>\n#include <com/sun/star/sdbc/XRow.hpp>\n#include <svl/converter.hxx>\n#include \"dbase/DConnection.hxx\"\n#include \"dbase/DColumns.hxx\"\n#include <osl/thread.h>\n#include <tools/config.hxx>\n#include \"dbase/DIndex.hxx\"\n#include \"dbase/DIndexes.hxx\"\n//#include \"file/FDriver.hxx\"\n#include <comphelper/sequence.hxx>\n#include <svl/zforlist.hxx>\n#include <unotools/syslocale.hxx>\n#include <rtl/math.hxx>\n#include <stdio.h>\t\t//sprintf\n#include <ucbhelper/content.hxx>\n#include <comphelper/extract.hxx>\n#include <connectivity/dbexception.hxx>\n#include <connectivity/dbconversion.hxx>\n#include <com/sun/star/lang/DisposedException.hpp>\n#include <comphelper/property.hxx>\n//#include <unotools/calendarwrapper.hxx>\n#include <unotools/tempfile.hxx>\n#include <unotools/ucbhelper.hxx>\n#include <comphelper/types.hxx>\n#include <cppuhelper/exc_hlp.hxx>\n#include \"connectivity/PColumn.hxx\"\n#include \"connectivity/dbtools.hxx\"\n#include \"connectivity/FValue.hxx\"\n#include \"connectivity/dbconversion.hxx\"\n#include \"resource/dbase_res.hrc\"\n#include <rtl/logfile.hxx>\n\n#include <algorithm>\n\nusing namespace ::comphelper;\nusing namespace connectivity;\nusing namespace connectivity::sdbcx;\nusing namespace connectivity::dbase;\nusing namespace connectivity::file;\nusing namespace ::ucbhelper;\nusing namespace ::utl;\nusing namespace ::cppu;\nusing namespace ::dbtools;\nusing namespace ::com::sun::star::uno;\nusing namespace ::com::sun::star::ucb;\nusing namespace ::com::sun::star::beans;\nusing namespace ::com::sun::star::sdbcx;\nusing namespace ::com::sun::star::sdbc;\nusing namespace ::com::sun::star::container;\nusing namespace ::com::sun::star::lang;\nusing namespace ::com::sun::star::i18n;\n\n// stored as the Field Descriptor terminator\n#define FIELD_DESCRIPTOR_TERMINATOR 0x0D\n#define DBF_EOL                     0x1A\n\nnamespace \n{\nsal_Int32 lcl_getFileSize(SvStream& _rStream)\n{\n    sal_Int32 nFileSize = 0;\n    _rStream.Seek(STREAM_SEEK_TO_END);\n    _rStream.SeekRel(-1);\n    char cEOL;\n    _rStream >> cEOL;\n    nFileSize = _rStream.Tell();\n    if ( cEOL == DBF_EOL )\n        nFileSize -= 1;\n    return nFileSize;\n}\n/**\n\tcalculates the Julian date\n*/\nvoid lcl_CalcJulDate(sal_Int32& _nJulianDate,sal_Int32& _nJulianTime,const com::sun::star::util::DateTime _aDateTime)\n{\n    com::sun::star::util::DateTime aDateTime = _aDateTime;\n\t// weird: months fix \n    if (aDateTime.Month > 12)\n\t{\n\t    aDateTime.Month--;\n\t    sal_uInt16 delta = _aDateTime.Month / 12;\n\t    aDateTime.Year += delta;\n\t    aDateTime.Month -= delta * 12;\n\t    aDateTime.Month++;\n\t}\n\n\t_nJulianTime = ((aDateTime.Hours*3600000)+(aDateTime.Minutes*60000)+(aDateTime.Seconds*1000)+(aDateTime.HundredthSeconds*10));\n\t/* conversion factors */\n\tsal_uInt16 iy0;\n\tsal_uInt16 im0;\n\tif ( aDateTime.Month <= 2 )\n\t{\n\t\tiy0 = aDateTime.Year - 1;\n\t\tim0 = aDateTime.Month + 12;\n\t}\n\telse\n\t{\n\t\tiy0 = aDateTime.Year;\n\t\tim0 = aDateTime.Month;\n\t}\n\tsal_Int32 ia = iy0 / 100;\n\tsal_Int32 ib = 2 - ia + (ia >> 2);\n\t/* calculate julian date\t*/\n\tif ( aDateTime.Year <= 0 ) \n    {\n\t\t_nJulianDate = (sal_Int32) ((365.25 * iy0) - 0.75)\n\t\t\t+ (sal_Int32) (30.6001 * (im0 + 1) )\n\t\t\t+ aDateTime.Day + 1720994;\n\t} // if ( _aDateTime.Year <= 0 ) \n    else \n    {\n\t\t_nJulianDate = static_cast<sal_Int32>( ((365.25 * iy0) \n\t\t\t+ (sal_Int32) (30.6001 * (im0 + 1))\n\t\t\t+ aDateTime.Day + 1720994));\n\t}\n    double JD = _nJulianDate + 0.5;\n    _nJulianDate = (sal_Int32)( JD + 0.5);\n    const double gyr = aDateTime.Year + (0.01 * aDateTime.Month) + (0.0001 * aDateTime.Day);\n\tif ( gyr >= 1582.1015 )\t/* on or after 15 October 1582\t*/\n\t\t_nJulianDate += ib;\n}\n\n/**\n\tcalculates date time from the Julian Date\n*/\nvoid lcl_CalDate(sal_Int32 _nJulianDate,sal_Int32 _nJulianTime,com::sun::star::util::DateTime& _rDateTime)\n{\n    if ( _nJulianDate )\n    {\n        sal_Int32 ialp;\n\t    sal_Int32 ka = _nJulianDate;\n\t    if ( _nJulianDate >= 2299161 )\n\t    {\n\t\t    ialp = (sal_Int32)( ((double) _nJulianDate - 1867216.25 ) / ( 36524.25 ));\n\t\t    ka = _nJulianDate + 1 + ialp - ( ialp >> 2 );\n\t    }\n\t    sal_Int32 kb = ka + 1524;\n\t    sal_Int32 kc =  (sal_Int32) ( ((double) kb - 122.1 ) / 365.25 );\n\t    sal_Int32 kd = (sal_Int32) ((double) kc * 365.25);\n\t    sal_Int32 ke = (sal_Int32) ((double) ( kb - kd ) / 30.6001 );\n\t    _rDateTime.Day = static_cast<sal_uInt16>(kb - kd - ((sal_Int32) ( (double) ke * 30.6001 )));\n\t    if ( ke > 13 )\n\t\t    _rDateTime.Month = static_cast<sal_uInt16>(ke - 13);\n\t    else\n\t\t    _rDateTime.Month = static_cast<sal_uInt16>(ke - 1);\n\t    if ( (_rDateTime.Month == 2) && (_rDateTime.Day > 28) )\n\t\t    _rDateTime.Day = 29;\n\t    if ( (_rDateTime.Month == 2) && (_rDateTime.Day == 29) && (ke == 3) )\n\t\t    _rDateTime.Year = static_cast<sal_uInt16>(kc - 4716);\n\t    else if ( _rDateTime.Month > 2 )\n\t\t    _rDateTime.Year = static_cast<sal_uInt16>(kc - 4716);\n\t    else\n\t\t    _rDateTime.Year = static_cast<sal_uInt16>(kc - 4715);\n    } // if ( _nJulianDate )\n\n    if ( _nJulianTime )\n    {\n        double d_s = _nJulianTime / 1000;\n        double d_m = d_s / 60;\n        double d_h  = d_m / 60;\n        _rDateTime.Hours = (sal_uInt16) (d_h);\n\t    _rDateTime.Minutes = (sal_uInt16) d_m;\t\t\t// integer _aDateTime.Minutes\n\t    //// weird: time fix\n     //   int test = (_rDateTime.Hours % 3) * 100 + _rDateTime.Minutes;\n\t    //int test_tbl[] = {0, 1, 2, 11, 12, 13, 22, 23, 24, 25, 34, 35, 36,\n\t    //\t45, 46, 47, 56, 57, 58, 107, 108, 109, 110, 119, 120, 121,\n\t    //\t130, 131, 132, 141, 142, 143, 152, 153, 154, 155, 204, 205,\n\t    //\t206, 215, 216, 217, 226, 227, 228, 237, 238, 239, 240, 249,\n\t    //\t250, 251};\n     //   for (int i = 0; i < sizeof(test_tbl)/sizeof(test_tbl[0]); i++)\n\t    //{\n\t    //    if (test == test_tbl[i])\n\t    //    {\n\t    //\t// frac += 0.000012;\n\t    //\t    //d_hour = frac * 24.0;\n\t    //\t    _rDateTime.Hours = (sal_uInt16)d_hour;\n\t    //\t    d_minute = (d_hour - (double)_rDateTime.Hours) * 60.0;\n\t    //\t    _rDateTime.Minutes = (sal_uInt16)d_minute;\n\t    //\t    break;\n\t    //    }\n     //   }\n\n\t    _rDateTime.Seconds = static_cast<sal_uInt16>(( d_m - (double) _rDateTime.Minutes ) * 60.0);\n    }\n}\n\n}\n\n// -------------------------------------------------------------------------\nvoid ODbaseTable::readHeader()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::readHeader\" );\n\tOSL_ENSURE(m_pFileStream,\"No Stream available!\");\n\tif(!m_pFileStream)\n\t\treturn;\n\tm_pFileStream->RefreshBuffer(); // sicherstellen, dass die Kopfinformationen tatsaechlich neu gelesen werden\n\tm_pFileStream->Seek(STREAM_SEEK_TO_BEGIN);\n\n\tsal_uInt8 nType=0;\n\t(*m_pFileStream) >> nType;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\n\tm_pFileStream->Read((char*)(&m_aHeader.db_aedat), 3*sizeof(sal_uInt8));\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\t(*m_pFileStream) >> m_aHeader.db_anz;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\t(*m_pFileStream) >> m_aHeader.db_kopf;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\t(*m_pFileStream) >> m_aHeader.db_slng;\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\tm_pFileStream->Read((char*)(&m_aHeader.db_frei), 20*sizeof(sal_uInt8));\n\tif(ERRCODE_NONE != m_pFileStream->GetErrorCode())\n\t\tthrowInvalidDbaseFormat();\n\n    if ( ( ( m_aHeader.db_kopf - 1 ) / 32 - 1 ) <= 0 ) // anzahl felder\n\t{\n\t\t// no dbase file\n\t\tthrowInvalidDbaseFormat();\n\t}\n\telse\n\t{\n\t\t// Konsistenzpruefung des Header:\n\t\tm_aHeader.db_typ = (DBFType)nType;\n\t\tswitch (m_aHeader.db_typ)\n\t\t{\n\t\t\tcase dBaseIII:\n\t\t\tcase dBaseIV:\n\t\t\tcase dBaseV:\n            case VisualFoxPro:\n            case VisualFoxProAuto:\n\t\t\tcase dBaseFS:\n\t\t\tcase dBaseFSMemo:\n\t\t\tcase dBaseIVMemoSQL:\n\t\t\tcase dBaseIIIMemo:\n\t\t\tcase FoxProMemo:\n\t\t\t\tm_pFileStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);\n                if ( m_aHeader.db_frei[17] != 0x00 \n                    && !m_aHeader.db_frei[18] && !m_aHeader.db_frei[19] && getConnection()->isTextEncodingDefaulted() )\n                {\n                    switch(m_aHeader.db_frei[17])\n                    {\n                        case 0x01: m_eEncoding = RTL_TEXTENCODING_IBM_437; break; \t    // DOS USA\tcode page 437\n                        case 0x02: m_eEncoding = RTL_TEXTENCODING_IBM_850; break; \t    // DOS Multilingual\tcode page 850\n                        case 0x03: m_eEncoding = RTL_TEXTENCODING_MS_1252; break; \t    // Windows ANSI\tcode page 1252\n                        case 0x04: m_eEncoding = RTL_TEXTENCODING_APPLE_ROMAN; break; \t// Standard Macintosh\n                        case 0x64: m_eEncoding = RTL_TEXTENCODING_IBM_852; break; \t    // EE MS-DOS\tcode page 852\n                        case 0x65: m_eEncoding = RTL_TEXTENCODING_IBM_865; break; \t    // Nordic MS-DOS\tcode page 865\n                        case 0x66: m_eEncoding = RTL_TEXTENCODING_IBM_866; break; \t    // Russian MS-DOS\tcode page 866\n                        case 0x67: m_eEncoding = RTL_TEXTENCODING_IBM_861; break; \t    // Icelandic MS-DOS\n                        //case 0x68: m_eEncoding = ; break; \t// Kamenicky (Czech) MS-DOS\n                        //case 0x69: m_eEncoding = ; break; \t// Mazovia (Polish) MS-DOS\n                        case 0x6A: m_eEncoding = RTL_TEXTENCODING_IBM_737; break; \t    // Greek MS-DOS (437G)\n                        case 0x6B: m_eEncoding = RTL_TEXTENCODING_IBM_857; break; \t    // Turkish MS-DOS\n                        case 0x96: m_eEncoding = RTL_TEXTENCODING_APPLE_CYRILLIC; break; \t// Russian Macintosh\n                        case 0x97: m_eEncoding = RTL_TEXTENCODING_APPLE_CENTEURO; break; \t// Eastern European Macintosh\n                        case 0x98: m_eEncoding = RTL_TEXTENCODING_APPLE_GREEK; break; \t// Greek Macintosh\n                        case 0xC8: m_eEncoding = RTL_TEXTENCODING_MS_1250; break; \t    // Windows EE\tcode page 1250\n                        case 0xC9: m_eEncoding = RTL_TEXTENCODING_MS_1251; break; \t    // Russian Windows\n                        case 0xCA: m_eEncoding = RTL_TEXTENCODING_MS_1254; break; \t    // Turkish Windows\n                        case 0xCB: m_eEncoding = RTL_TEXTENCODING_MS_1253; break; \t    // Greek Windows\n                        default:\n                            break;\n                    }\n                }\n\t\t\t\tbreak;\n            case dBaseIVMemo:\n                m_pFileStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);\n                break;\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tthrowInvalidDbaseFormat();\n\t\t\t}\n\t\t}\n\t}\n}\n// -------------------------------------------------------------------------\nvoid ODbaseTable::fillColumns()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::fillColumns\" );\n\tm_pFileStream->Seek(STREAM_SEEK_TO_BEGIN);\n\tm_pFileStream->Seek(32L);\n\n\tif(!m_aColumns.isValid())\n\t\tm_aColumns = new OSQLColumns();\n\telse\n\t\tm_aColumns->get().clear();\n\n\tm_aTypes.clear();\n\tm_aPrecisions.clear();\n\tm_aScales.clear();\n\n\t// Anzahl Felder:\n\tconst sal_Int32 nFieldCount = (m_aHeader.db_kopf - 1) / 32 - 1;\n\tOSL_ENSURE(nFieldCount,\"No columns in table!\");\n\n\tm_aColumns->get().reserve(nFieldCount);\n\tm_aTypes.reserve(nFieldCount);\n\tm_aPrecisions.reserve(nFieldCount);\n\tm_aScales.reserve(nFieldCount);\n\n\tString aStrFieldName;\n\taStrFieldName.AssignAscii(\"Column\");\n\t::rtl::OUString aTypeName;\n    static const ::rtl::OUString sVARCHAR(RTL_CONSTASCII_USTRINGPARAM(\"VARCHAR\"));\n\tconst sal_Bool bCase = getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers();\n    const bool bFoxPro = m_aHeader.db_typ == VisualFoxPro || m_aHeader.db_typ == VisualFoxProAuto || m_aHeader.db_typ == FoxProMemo;\n\n    sal_Int32 i = 0;\n\tfor (; i < nFieldCount; i++)\n\t{\n\t\tDBFColumn aDBFColumn;\n\t\tm_pFileStream->Read((char*)&aDBFColumn, sizeof(aDBFColumn));\n        if ( FIELD_DESCRIPTOR_TERMINATOR == aDBFColumn.db_fnm[0] ) // 0x0D stored as the Field Descriptor terminator.\n            break;\n\n        sal_Bool bIsRowVersion = bFoxPro && ( aDBFColumn.db_frei2[0] & 0x01 ) == 0x01;\n        //if ( bFoxPro && ( aDBFColumn.db_frei2[0] & 0x01 ) == 0x01 ) // system column not visible to user\n        //    continue;\n\t\tconst String aColumnName((const char *)aDBFColumn.db_fnm,m_eEncoding);\n\n        m_aRealFieldLengths.push_back(aDBFColumn.db_flng);\n\t\tsal_Int32 nPrecision = aDBFColumn.db_flng;\n\t\tsal_Int32 eType;\n        sal_Bool bIsCurrency = sal_False;\n        \n        char cType[2];\n        cType[0] = aDBFColumn.db_typ;\n        cType[1] = 0;\n        aTypeName = ::rtl::OUString::createFromAscii(cType);\nOSL_TRACE(\"column type: %c\",aDBFColumn.db_typ);\n\n\t\tswitch (aDBFColumn.db_typ)\n\t\t{\n\t\t\tcase 'C':\n\t\t\t\teType = DataType::VARCHAR;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"VARCHAR\"));\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DECIMAL\"));\n\t\t\tcase 'N':\n                if ( aDBFColumn.db_typ == 'N' )\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"NUMERIC\"));\n\t\t\t\teType = DataType::DECIMAL;\n\n\t\t\t\t// Bei numerischen Feldern werden zwei Zeichen mehr geschrieben, als die Precision der Spaltenbeschreibung eigentlich\n\t\t\t\t// angibt, um Platz fuer das eventuelle Vorzeichen und das Komma zu haben. Das muss ich jetzt aber wieder rausrechnen.\n\t\t\t\tnPrecision = SvDbaseConverter::ConvertPrecisionToOdbc(nPrecision,aDBFColumn.db_dez);\n\t\t\t\t\t// leider gilt das eben Gesagte nicht fuer aeltere Versionen ....\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\teType = DataType::BIT;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"BOOLEAN\"));\n\t\t\t\tbreak;\n            case 'Y':\n                bIsCurrency = sal_True;\n\t\t\t\teType = DataType::DOUBLE;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DOUBLE\"));\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\teType = DataType::DATE;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DATE\"));\n\t\t\t\tbreak;\n            case 'T':\n\t\t\t\teType = DataType::TIMESTAMP;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"TIMESTAMP\"));\n\t\t\t\tbreak;\n            case 'I':\n\t\t\t\teType = DataType::INTEGER;\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"INTEGER\"));\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n                if ( bFoxPro && ( aDBFColumn.db_frei2[0] & 0x04 ) == 0x04 )\n                {\n\t\t\t\t    eType = DataType::LONGVARBINARY;\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARBINARY\"));\n                }\n                else\n                {\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARCHAR\"));\n                    eType = DataType::LONGVARCHAR;\n                }\n\t\t\t\tnPrecision = 2147483647;\n\t\t\t\tbreak;\n            case 'P':\n                aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARBINARY\"));\n\t\t\t\teType = DataType::LONGVARBINARY;\n\t\t\t\tnPrecision = 2147483647;\n\t\t\t\tbreak;\n            case '0':\n            case 'B':\n                if ( m_aHeader.db_typ == VisualFoxPro || m_aHeader.db_typ == VisualFoxProAuto )\n                {\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"DOUBLE\"));\n                    eType = DataType::DOUBLE;\n                }\n                else\n                {\n                    aTypeName = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(\"LONGVARBINARY\"));\n                    eType = DataType::LONGVARBINARY;\n\t\t\t\t    nPrecision = 2147483647;\n                }\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teType = DataType::OTHER;\n\t\t}\n\n\t\tm_aTypes.push_back(eType);\n\t\tm_aPrecisions.push_back(nPrecision);\n\t\tm_aScales.push_back(aDBFColumn.db_dez);\n\n\t\tReference< XPropertySet> xCol = new sdbcx::OColumn(aColumnName,\n\t\t\t\t\t\t\t\t\t\t\t\t\taTypeName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t::rtl::OUString(),\n                                                    ::rtl::OUString(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tColumnValue::NULLABLE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnPrecision,\n\t\t\t\t\t\t\t\t\t\t\t\t\taDBFColumn.db_dez,\n\t\t\t\t\t\t\t\t\t\t\t\t\teType,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsal_False,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbIsRowVersion,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbIsCurrency,\n\t\t\t\t\t\t\t\t\t\t\t\t\tbCase);\n\t\tm_aColumns->get().push_back(xCol);\n\t} // for (; i < nFieldCount; i++)\n    OSL_ENSURE(i,\"No columns in table!\");\n}\n// -------------------------------------------------------------------------\nODbaseTable::ODbaseTable(sdbcx::OCollection* _pTables,ODbaseConnection* _pConnection)\n\t\t:ODbaseTable_BASE(_pTables,_pConnection)\n\t\t,m_pMemoStream(NULL)\n\t\t,m_bWriteableMemo(sal_False)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ODbaseTable\" );\n\t// initialize the header\n\tm_aHeader.db_typ\t= dBaseIII;\n\tm_aHeader.db_anz\t= 0;\n\tm_aHeader.db_kopf\t= 0;\n\tm_aHeader.db_slng\t= 0;\n    m_eEncoding = getConnection()->getTextEncoding();\n}\n// -------------------------------------------------------------------------\nODbaseTable::ODbaseTable(sdbcx::OCollection* _pTables,ODbaseConnection* _pConnection,\n\t\t\t\t\tconst ::rtl::OUString& _Name,\n\t\t\t\t\tconst ::rtl::OUString& _Type,\n\t\t\t\t\tconst ::rtl::OUString& _Description ,\n\t\t\t\t\tconst ::rtl::OUString& _SchemaName,\n\t\t\t\t\tconst ::rtl::OUString& _CatalogName\n\t\t\t\t) : ODbaseTable_BASE(_pTables,_pConnection,_Name,\n\t\t\t\t\t\t\t\t  _Type,\n\t\t\t\t\t\t\t\t  _Description,\n\t\t\t\t\t\t\t\t  _SchemaName,\n\t\t\t\t\t\t\t\t  _CatalogName)\n\t\t\t\t,m_pMemoStream(NULL)\n\t\t\t\t,m_bWriteableMemo(sal_False)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ODbaseTable\" );\n    m_eEncoding = getConnection()->getTextEncoding();\n}\n\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::construct()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::construct\" );\n\t// initialize the header\n\tm_aHeader.db_typ\t= dBaseIII;\n\tm_aHeader.db_anz\t= 0;\n\tm_aHeader.db_kopf\t= 0;\n\tm_aHeader.db_slng\t= 0;\n    m_aMemoHeader.db_size = 0;\n\n\tString sFileName(getEntry(m_pConnection,m_Name));\n\n\tINetURLObject aURL;\n\taURL.SetURL(sFileName);\n\n\tOSL_ENSURE( m_pConnection->matchesExtension( aURL.getExtension() ),\n\t\t\"ODbaseTable::ODbaseTable: invalid extension!\");\n\t\t// getEntry is expected to ensure the corect file name\n\n\tm_pFileStream = createStream_simpleError( sFileName, STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYWRITE);\n\tm_bWriteable = ( m_pFileStream != NULL );\n\n    if ( !m_pFileStream )\n    {\n        m_bWriteable = sal_False;\n\t\tm_pFileStream = createStream_simpleError( sFileName, STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYNONE);\n    }\n\n\tif(m_pFileStream)\n\t{\n\t\treadHeader();\n\t\tif (HasMemoFields())\n\t\t{\n\t\t\t// Memo-Dateinamen bilden (.DBT):\n\t\t\t// nyi: Unschoen fuer Unix und Mac!\n\n\t\t\tif ( m_aHeader.db_typ == FoxProMemo || VisualFoxPro == m_aHeader.db_typ || VisualFoxProAuto == m_aHeader.db_typ ) // foxpro uses another extension\n\t\t\t\taURL.SetExtension(String::CreateFromAscii(\"fpt\"));\n\t\t\telse\n\t\t\t\taURL.SetExtension(String::CreateFromAscii(\"dbt\"));\n\n\t\t\t// Wenn die Memodatei nicht gefunden wird, werden die Daten trotzdem angezeigt\n\t\t\t// allerdings koennen keine Updates durchgefuehrt werden\n\t\t\t// jedoch die Operation wird ausgefuehrt\n\t\t\tm_pMemoStream = createStream_simpleError( aURL.GetMainURL(INetURLObject::NO_DECODE), STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYWRITE);\n            if ( !m_pMemoStream )\n            {\n                m_bWriteableMemo = sal_False;\n\t\t\t\tm_pMemoStream = createStream_simpleError( aURL.GetMainURL(INetURLObject::NO_DECODE), STREAM_READ | STREAM_NOCREATE | STREAM_SHARE_DENYNONE);\n            }\n\t\t\tif (m_pMemoStream)\n\t\t\t\tReadMemoHeader();\n\t\t}\n\t\t//\tif(!m_pColumns && (!m_aColumns.isValid() || !m_aColumns->size()))\n\t\tfillColumns();\n\n\t\tsal_uInt32 nFileSize = lcl_getFileSize(*m_pFileStream);\n\t\tm_pFileStream->Seek(STREAM_SEEK_TO_BEGIN);\n        if ( m_aHeader.db_anz == 0 && ((nFileSize-m_aHeader.db_kopf)/m_aHeader.db_slng) > 0) // seems to be empty or someone wrote bullshit into the dbase file\n            m_aHeader.db_anz = ((nFileSize-m_aHeader.db_kopf)/m_aHeader.db_slng);\n\n\t\t// Buffersize abhaengig von der Filegroesse\n\t\tm_pFileStream->SetBufferSize(nFileSize > 1000000 ? 32768 :\n\t\t\t\t\t\t\t\t  nFileSize > 100000 ? 16384 :\n\t\t\t\t\t\t\t\t  nFileSize > 10000 ? 4096 : 1024);\n\n\t\tif (m_pMemoStream)\n\t\t{\n\t\t\t// Puffer genau auf Laenge eines Satzes stellen\n\t\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\t\tnFileSize = m_pMemoStream->Tell();\n\t\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_BEGIN);\n\n\t\t\t// Buffersize abhaengig von der Filegroesse\n\t\t\tm_pMemoStream->SetBufferSize(nFileSize > 1000000 ? 32768 :\n\t\t\t\t\t\t\t\t\t\t  nFileSize > 100000 ? 16384 :\n\t\t\t\t\t\t\t\t\t\t  nFileSize > 10000 ? 4096 :\n\t\t\t\t\t\t\t\t\t\t  m_aMemoHeader.db_size);\n\t\t}\n\n\t\tAllocBuffer();\n\t}\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::ReadMemoHeader()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ReadMemoHeader\" );\n\tm_pMemoStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);\n\tm_pMemoStream->RefreshBuffer();\t\t\t// sicherstellen das die Kopfinformationen tatsaechlich neu gelesen werden\n\tm_pMemoStream->Seek(0L);\n\n\t(*m_pMemoStream) >> m_aMemoHeader.db_next;\n\tswitch (m_aHeader.db_typ)\n\t{\n        case dBaseIIIMemo:  // dBase III: feste Blockgroesse\n\t\tcase dBaseIVMemo:\n\t\t\t// manchmal wird aber auch dBase3 dBase4 Memo zugeordnet\n\t\t\tm_pMemoStream->Seek(20L);\n\t\t\t(*m_pMemoStream) >> m_aMemoHeader.db_size;\n\t\t\tif (m_aMemoHeader.db_size > 1 && m_aMemoHeader.db_size != 512)\t// 1 steht auch fuer dBase 3\n\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIV;\n\t\t\telse if (m_aMemoHeader.db_size > 1 && m_aMemoHeader.db_size == 512)\n\t\t\t{\n                // nun gibt es noch manche Dateien, die verwenden eine Groessenangabe,\n\t\t\t\t// sind aber dennoch dBase Dateien\n\t\t\t\tchar sHeader[4];\n\t\t\t\tm_pMemoStream->Seek(m_aMemoHeader.db_size);\n\t\t\t\tm_pMemoStream->Read(sHeader,4);\n\n\t\t\t\tif ((m_pMemoStream->GetErrorCode() != ERRCODE_NONE) || ((sal_uInt8)sHeader[0]) != 0xFF || ((sal_uInt8)sHeader[1]) != 0xFF || ((sal_uInt8)sHeader[2]) != 0x08)\n\t\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIII;\n\t\t\t\telse\n\t\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIV;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_aMemoHeader.db_typ  = MemodBaseIII;\n\t\t\t\tm_aMemoHeader.db_size = 512;\n\t\t\t}\n\t\t\tbreak;\n        case VisualFoxPro:\n        case VisualFoxProAuto:\n\t\tcase FoxProMemo:\n\t\t\tm_aMemoHeader.db_typ\t= MemoFoxPro;\n\t\t\tm_pMemoStream->Seek(6L);\n\t\t\tm_pMemoStream->SetNumberFormatInt(NUMBERFORMAT_INT_BIGENDIAN);\n\t\t\t(*m_pMemoStream) >> m_aMemoHeader.db_size;\n            break;\n        default:\n            OSL_ENSURE( false, \"ODbaseTable::ReadMemoHeader: unsupported memo type!\" );\n            break;\n\t}\n\treturn sal_True;\n}\n// -------------------------------------------------------------------------\nString ODbaseTable::getEntry(OConnection* _pConnection,const ::rtl::OUString& _sName )\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getEntry\" );\n\t::rtl::OUString sURL;\n\ttry\n\t{\n\t\tReference< XResultSet > xDir = _pConnection->getDir()->getStaticResultSet();\n\t\tReference< XRow> xRow(xDir,UNO_QUERY);\n\t\t::rtl::OUString sName;\n\t\t::rtl::OUString sExt;\n\t\tINetURLObject aURL;\n\t\tstatic const ::rtl::OUString s_sSeparator(RTL_CONSTASCII_USTRINGPARAM(\"/\"));\n\t\txDir->beforeFirst();\n\t\twhile(xDir->next())\n\t\t{\n\t\t\tsName = xRow->getString(1);\n\t\t\taURL.SetSmartProtocol(INET_PROT_FILE);\n\t\t\tString sUrl = _pConnection->getURL() +  s_sSeparator + sName;\n\t\t\taURL.SetSmartURL( sUrl );\n\n\t\t\t// cut the extension\n\t\t\tsExt = aURL.getExtension();\n\n\t\t\t// name and extension have to coincide\n\t\t\tif ( _pConnection->matchesExtension( sExt ) )\n\t\t\t{\n\t\t\t\tsName = sName.replaceAt(sName.getLength()-(sExt.getLength()+1),sExt.getLength()+1,::rtl::OUString());\n\t\t\t\tif ( sName == _sName )\n\t\t\t\t{\n\t\t\t\t\tReference< XContentAccess > xContentAccess( xDir, UNO_QUERY );\n\t\t\t\t\tsURL = xContentAccess->queryContentIdentifierString();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\txDir->beforeFirst(); // move back to before first record\n\t}\n\tcatch(Exception&)\n\t{\n\t\tOSL_ASSERT(0);\n\t}\n\treturn sURL;\n}\n// -------------------------------------------------------------------------\nvoid ODbaseTable::refreshColumns()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::refreshColumns\" );\n\t::osl::MutexGuard aGuard( m_aMutex );\n\n\tTStringVector aVector;\n\taVector.reserve(m_aColumns->get().size());\n\n\tfor(OSQLColumns::Vector::const_iterator aIter = m_aColumns->get().begin();aIter != m_aColumns->get().end();++aIter)\n\t\taVector.push_back(Reference< XNamed>(*aIter,UNO_QUERY)->getName());\n\n\tif(m_pColumns)\n\t\tm_pColumns->reFill(aVector);\n\telse\n\t\tm_pColumns\t= new ODbaseColumns(this,m_aMutex,aVector);\n}\n// -------------------------------------------------------------------------\nvoid ODbaseTable::refreshIndexes()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::refreshIndexes\" );\n\tTStringVector aVector;\n\tif(m_pFileStream && (!m_pIndexes || m_pIndexes->getCount() == 0))\n\t{\n\t\tINetURLObject aURL;\n\t\taURL.SetURL(getEntry(m_pConnection,m_Name));\n\n\t\taURL.setExtension(String::CreateFromAscii(\"inf\"));\n\t\tConfig aInfFile(aURL.getFSysPath(INetURLObject::FSYS_DETECT));\n\t\taInfFile.SetGroup(dBASE_III_GROUP);\n\t\tsal_uInt16 nKeyCnt = aInfFile.GetKeyCount();\n\t\tByteString aKeyName;\n\t\tByteString aIndexName;\n\n\t\tfor (sal_uInt16 nKey = 0; nKey < nKeyCnt; nKey++)\n\t\t{\n\t\t\t// Verweist der Key auf ein Indexfile?...\n\t\t\taKeyName = aInfFile.GetKeyName( nKey );\n\t\t\t//...wenn ja, Indexliste der Tabelle hinzufuegen\n\t\t\tif (aKeyName.Copy(0,3) == ByteString(\"NDX\") )\n\t\t\t{\n\t\t\t\taIndexName = aInfFile.ReadKey(aKeyName);\n\t\t\t\taURL.setName(String(aIndexName,m_eEncoding));\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tContent aCnt(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\t\t\tif (aCnt.isDocument())\n\t\t\t\t\t{\n\t\t\t\t\t\taVector.push_back(aURL.getBase());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(Exception&) // a execption is thrown when no file exists\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(m_pIndexes)\n\t\tm_pIndexes->reFill(aVector);\n\telse\n\t\tm_pIndexes\t= new ODbaseIndexes(this,m_aMutex,aVector);\n}\n\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::disposing(void)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::disposing\" );\n\tOFileTable::disposing();\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tm_aColumns = NULL;\n}\n// -------------------------------------------------------------------------\nSequence< Type > SAL_CALL ODbaseTable::getTypes(  ) throw(RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getTypes\" );\n\tSequence< Type > aTypes = OTable_TYPEDEF::getTypes();\n\t::std::vector<Type> aOwnTypes;\n\taOwnTypes.reserve(aTypes.getLength());\n\n\tconst Type* pBegin = aTypes.getConstArray();\n\tconst Type* pEnd = pBegin + aTypes.getLength();\n\tfor(;pBegin != pEnd;++pBegin)\n\t{\n\t\tif(!(*pBegin == ::getCppuType((const Reference<XKeysSupplier>*)0)\t||\n\t\t\t//\t*pBegin == ::getCppuType((const Reference<XAlterTable>*)0)\t||\n\t\t\t*pBegin == ::getCppuType((const Reference<XDataDescriptorFactory>*)0)))\n\t\t{\n\t\t\taOwnTypes.push_back(*pBegin);\n\t\t}\n\t}\n\taOwnTypes.push_back(::getCppuType( (const Reference< ::com::sun::star::lang::XUnoTunnel > *)0 ));\n\tType *pTypes = aOwnTypes.empty() ? 0 : &aOwnTypes[0];\n\treturn Sequence< Type >(pTypes, aOwnTypes.size());\n}\n\n// -------------------------------------------------------------------------\nAny SAL_CALL ODbaseTable::queryInterface( const Type & rType ) throw(RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::queryInterface\" );\n\tif( rType == ::getCppuType((const Reference<XKeysSupplier>*)0)\t||\n\t\trType == ::getCppuType((const Reference<XDataDescriptorFactory>*)0))\n\t\treturn Any();\n\n\tAny aRet = OTable_TYPEDEF::queryInterface(rType);\n\treturn aRet.hasValue() ? aRet : ::cppu::queryInterface(rType,static_cast< ::com::sun::star::lang::XUnoTunnel*> (this));\n}\n\n//--------------------------------------------------------------------------\nSequence< sal_Int8 > ODbaseTable::getUnoTunnelImplementationId()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getUnoTunnelImplementationId\" );\n\tstatic ::cppu::OImplementationId * pId = 0;\n\tif (! pId)\n\t{\n\t\t::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );\n\t\tif (! pId)\n\t\t{\n\t\t\tstatic ::cppu::OImplementationId aId;\n\t\t\tpId = &aId;\n\t\t}\n\t}\n\treturn pId->getImplementationId();\n}\n\n// com::sun::star::lang::XUnoTunnel\n//------------------------------------------------------------------\nsal_Int64 ODbaseTable::getSomething( const Sequence< sal_Int8 > & rId ) throw (RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getSomething\" );\n\treturn (rId.getLength() == 16 && 0 == rtl_compareMemory(getUnoTunnelImplementationId().getConstArray(),  rId.getConstArray(), 16 ) )\n\t\t\t\t? reinterpret_cast< sal_Int64 >( this )\n\t\t\t\t: ODbaseTable_BASE::getSomething(rId);\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::fetchRow(OValueRefRow& _rRow,const OSQLColumns & _rCols, sal_Bool _bUseTableDefs,sal_Bool bRetrieveData)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::fetchRow\" );\n\t// Einlesen der Daten\n\tsal_Bool bIsCurRecordDeleted = ((char)m_pBuffer[0] == '*') ? sal_True : sal_False;\n\n\t// only read the bookmark\n\n\t// Satz als geloescht markieren\n\t//\trRow.setState(bIsCurRecordDeleted ? ROW_DELETED : ROW_CLEAN );\n\t_rRow->setDeleted(bIsCurRecordDeleted);\n\t*(_rRow->get())[0] = m_nFilePos;\n\n\tif (!bRetrieveData)\n\t\treturn sal_True;\n\n\tsal_Size nByteOffset = 1;\n\t// Felder:\n\tOSQLColumns::Vector::const_iterator aIter = _rCols.get().begin();\n    OSQLColumns::Vector::const_iterator aEnd  = _rCols.get().end();\n    const sal_Size nCount = _rRow->get().size();\n\tfor (sal_Size i = 1; aIter != aEnd && nByteOffset <= m_nBufferSize && i < nCount;++aIter, i++)\n\t{\n\t\t// Laengen je nach Datentyp:\n\t\tsal_Int32 nLen = 0;\n\t\tsal_Int32 nType = 0;\n\t\tif(_bUseTableDefs)\n\t\t{\n\t\t\tnLen\t= m_aPrecisions[i-1];\n\t\t\tnType\t= m_aTypes[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))\t>>= nLen;\n\t\t\t(*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))\t\t>>= nType;\n\t\t}\n\t\tswitch(nType)\n\t\t{\n            case DataType::INTEGER:\t\t\n            case DataType::DOUBLE:\n            case DataType::TIMESTAMP:\n\t\t\tcase DataType::DATE:\t\t\n            case DataType::BIT:\t\t\t\n\t\t\tcase DataType::LONGVARCHAR:\t\n            case DataType::LONGVARBINARY:   \n                nLen = m_aRealFieldLengths[i-1]; \n                break;\n\t\t\tcase DataType::DECIMAL:\n\t\t\t\tif(_bUseTableDefs)\n\t\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,m_aScales[i-1]);\n\t\t\t\telse\n\t\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,getINT32((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))));\n\t\t\t\tbreak;\t// das Vorzeichen und das Komma\n\t\t\t\n            case DataType::BINARY:\n\t\t\tcase DataType::OTHER:\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t// Ist die Variable ueberhaupt gebunden?\n\t\tif ( !(_rRow->get())[i]->isBound() )\n\t\t{\n\t\t\t// Nein - naechstes Feld.\n\t\t\tnByteOffset += nLen;\n\t\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t\t\tcontinue;\n\t\t} // if ( !(_rRow->get())[i]->isBound() )\n        if ( ( nByteOffset + nLen) > m_nBufferSize )\n            break; // length doesn't match buffer size.\n\n\t\tchar *pData = (char *) (m_pBuffer + nByteOffset);\n\n\t\t//\t(*_rRow)[i].setType(nType);\n\n\t\tif (nType == DataType::CHAR || nType == DataType::VARCHAR)\n\t\t{\n\t\t\tchar cLast = pData[nLen];\n\t\t\tpData[nLen] = 0;\n\t\t\tString aStr(pData,(xub_StrLen)nLen,m_eEncoding);\n\t\t\taStr.EraseTrailingChars();\n\n\t\t\tif ( aStr.Len() )\n                *(_rRow->get())[i] = ::rtl::OUString(aStr);\n\t\t\telse// keine StringLaenge, dann NULL\n                (_rRow->get())[i]->setNull();\n\t\t\t\t\n\t\t\tpData[nLen] = cLast;\n\t\t} // if (nType == DataType::CHAR || nType == DataType::VARCHAR)\n        else if ( DataType::TIMESTAMP == nType )\n        {\n            sal_Int32 nDate = 0,nTime = 0;\n            OSL_ENSURE(nLen == 8, \"Invalid length for date field\");\n            if (nLen != 8) {\n                return false;\n            }\n\t\t\tmemcpy(&nDate, pData, 4);\n            memcpy(&nTime, pData+ 4, 4);\n            if ( !nDate && !nTime )\n            {\n                (_rRow->get())[i]->setNull();\n            }\n            else\n            {\n                ::com::sun::star::util::DateTime aDateTime;\n                lcl_CalDate(nDate,nTime,aDateTime);\n                *(_rRow->get())[i] = aDateTime;\n            }\n        }\n        else if ( DataType::INTEGER == nType )\n        {\n            OSL_ENSURE(nLen == 4, \"Invalid length for integer field\");\n            if (nLen != 4) {\n                return false;\n            }\n            sal_Int32 nValue = 0;\n\t\t\tmemcpy(&nValue, pData, nLen);\n            *(_rRow->get())[i] = nValue;\n        }\n        else if ( DataType::DOUBLE == nType )\n        {\n            double d = 0.0;\n            OSL_ENSURE(nLen == 8, \"Invalid length for double field\");\n            if (nLen != 8) {\n                return false;\n            }\n            if (getBOOL((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n            {\n                sal_Int64 nValue = 0;\n\t\t\t    memcpy(&nValue, pData, nLen);\n            \n                if ( m_aScales[i-1] )\n                    d = (double)(nValue / pow(10.0,(int)m_aScales[i-1]));\n                else\n                    d = (double)(nValue);\n            }\n            else\n            {\n                memcpy(&d, pData, nLen);\n            }\n            \n            *(_rRow->get())[i] = d;\n        }\n\t\telse\n\t\t{\n\t\t\t// Falls Nul-Zeichen im String enthalten sind, in Blanks umwandeln!\n\t\t\tfor (sal_Int32 k = 0; k < nLen; k++)\n\t\t\t{\n\t\t\t\tif (pData[k] == '\\0')\n\t\t\t\t\tpData[k] = ' ';\n\t\t\t}\n\n\t\t\tString aStr(pData, (xub_StrLen)nLen,m_eEncoding);\t\t// Spaces am Anfang und am Ende entfernen:\n\t\t\taStr.EraseLeadingChars();\n\t\t\taStr.EraseTrailingChars();\n\n\t\t\tif (!aStr.Len())\n\t\t\t{\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\t(_rRow->get())[i]->setNull();\t// keine Werte -> fertig\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (nType)\n\t\t\t{\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t{\n                    OSL_ENSURE(nLen == 8, \"Invalid length for date field\");\n                    if (nLen != 8) {\n                        return false;\n                    }\n\t\t\t\t\tif (aStr.Len() != nLen)\n\t\t\t\t\t{\n\t\t\t\t\t\t(_rRow->get())[i]->setNull();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst sal_uInt16  nYear   = (sal_uInt16)aStr.Copy( 0, 4 ).ToInt32();\n\t\t\t\t\tconst sal_uInt16  nMonth  = (sal_uInt16)aStr.Copy( 4, 2 ).ToInt32();\n\t\t\t\t\tconst sal_uInt16  nDay    = (sal_uInt16)aStr.Copy( 6, 2 ).ToInt32();\n\n\t\t\t\t\tconst ::com::sun::star::util::Date aDate(nDay,nMonth,nYear);\n\t\t\t\t\t*(_rRow->get())[i] = aDate;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\t\t*(_rRow->get())[i] = ORowSetValue(aStr);\n\t\t\t\t\t//\tpVal->setDouble(SdbTools::ToDouble(aStr));\n\t\t\t\tbreak;\n\t\t\t\tcase DataType::BIT:\n\t\t\t\t{\n                    OSL_ENSURE(nLen == 1, \"Invalid length for bit field\");\n                    if (nLen != 1) {\n                        return false;\n                    }\n\t\t\t\t\tsal_Bool b;\n\t\t\t\t\tswitch (* ((const char *)pData))\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\tcase 'J':\tb = sal_True; break;\n\t\t\t\t\t\tdefault: \tb = sal_False; break;\n\t\t\t\t\t}\n\t\t\t\t\t*(_rRow->get())[i] = b;\n\t\t\t\t\t//\tpVal->setDouble(b);\n\t\t\t\t}\n\t\t\t\tbreak;\n                case DataType::LONGVARBINARY:\n                case DataType::BINARY:\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t{\n\t\t\t\t\tconst long nBlockNo = aStr.ToInt32();\t// Blocknummer lesen\n\t\t\t\t\tif (nBlockNo > 0 && m_pMemoStream) // Daten aus Memo-Datei lesen, nur wenn\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( !ReadMemo(nBlockNo, (_rRow->get())[i]->get()) )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t(_rRow->get())[i]->setNull();\n\t\t\t\t}\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tOSL_ASSERT(\"Falscher Type\");\n\t\t\t}\n\t\t\t(_rRow->get())[i]->setTypeKind(nType);\n\t\t}\n\n\t\tnByteOffset += nLen;\n\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t}\n\treturn sal_True;\n}\n//------------------------------------------------------------------\n// -------------------------------------------------------------------------\nvoid ODbaseTable::FileClose()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::FileClose\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\t// falls noch nicht alles geschrieben wurde\n\tif (m_pMemoStream && m_pMemoStream->IsWritable())\n\t\tm_pMemoStream->Flush();\n\n\tdelete m_pMemoStream;\n\tm_pMemoStream = NULL;\n\n\tODbaseTable_BASE::FileClose();\n}\n// -------------------------------------------------------------------------\nsal_Bool ODbaseTable::CreateImpl()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::CreateImpl\" );\n\tOSL_ENSURE(!m_pFileStream, \"SequenceError\");\n\n\tif ( m_pConnection->isCheckEnabled() && ::dbtools::convertName2SQLName(m_Name,::rtl::OUString()) != m_Name )\n\t{\n        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_SQL_NAME_ERROR,\n                \"$name$\", m_Name\n             ) );\n        ::dbtools::throwGenericSQLException( sError, *this );\n\t}\n\n\tINetURLObject aURL;\n\taURL.SetSmartProtocol(INET_PROT_FILE);\n\tString aName = getEntry(m_pConnection,m_Name);\n\tif(!aName.Len())\n\t{\n\t\t::rtl::OUString aIdent = m_pConnection->getContent()->getIdentifier()->getContentIdentifier();\n\t\tif ( aIdent.lastIndexOf('/') != (aIdent.getLength()-1) )\n\t\t\taIdent += ::rtl::OUString::createFromAscii(\"/\");\n\t\taIdent += m_Name;\n\t\taName = aIdent.getStr();\n\t}\n\taURL.SetURL(aName);\n\n\tif ( !m_pConnection->matchesExtension( aURL.getExtension() ) )\n\t\taURL.setExtension(m_pConnection->getExtension());\n\n\ttry\n\t{\n\t\tContent aContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\tif (aContent.isDocument())\n\t\t{\n\t\t\t// Hack fuer Bug #30609 , nur wenn das File existiert und die Laenge > 0 gibt es einen Fehler\n\t\t\tSvStream* pFileStream = createStream_simpleError( aURL.GetMainURL(INetURLObject::NO_DECODE),STREAM_READ);\n\n\t\t\tif (pFileStream && pFileStream->Seek(STREAM_SEEK_TO_END))\n\t\t\t{\n\t\t\t\t//\taStatus.SetError(ERRCODE_IO_ALREADYEXISTS,TABLE,aFile.GetFull());\n\t\t\t\treturn sal_False;\n\t\t\t}\n\t\t\tdelete pFileStream;\n\t\t}\n\t}\n\tcatch(Exception&) // a execption is thrown when no file exists\n\t{\n\t}\n\n\tsal_Bool bMemoFile = sal_False;\n\n\tsal_Bool bOk = CreateFile(aURL, bMemoFile);\n\n\tFileClose();\n\n\tif (!bOk)\n\t{\n\t\ttry\n\t\t{\n\t\t\tContent aContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\taContent.executeCommand( rtl::OUString::createFromAscii( \"delete\" ),bool2any( sal_True ) );\n\t\t}\n\t\tcatch(Exception&) // a execption is thrown when no file exists\n\t\t{\n\t\t}\n\t\treturn sal_False;\n\t}\n\n\tif (bMemoFile)\n\t{\n\t\tString aExt = aURL.getExtension();\n\t\taURL.setExtension(String::CreateFromAscii(\"dbt\"));                      // extension for memo file\n\t\tContent aMemo1Content(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\n\t\tsal_Bool bMemoAlreadyExists = sal_False;\n\t\ttry\n\t\t{\n\t\t\tbMemoAlreadyExists = aMemo1Content.isDocument();\n\t\t}\n\t\tcatch(Exception&) // a execption is thrown when no file exists\n\t\t{\n\t\t}\n\t\tif (bMemoAlreadyExists)\n\t\t{\n\t\t\t//\taStatus.SetError(ERRCODE_IO_ALREADYEXISTS,MEMO,aFile.GetFull());\n\t\t\taURL.setExtension(aExt);      // kill dbf file\n\t\t\ttry\n\t\t\t{\n\t\t\t\tContent aMemoContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\t\taMemoContent.executeCommand( rtl::OUString::createFromAscii( \"delete\" ),bool2any( sal_True ) );\n\t\t\t}\n\t\t\tcatch(const Exception&)\n\t\t\t{\n                \n                const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                        STR_COULD_NOT_DELETE_FILE,\n                        \"$name$\", aName\n                     ) );\n                ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t}\n\t\t}\n\t\tif (!CreateMemoFile(aURL))\n\t\t{\n\t\t\taURL.setExtension(aExt);      // kill dbf file\n\t\t\tContent aMemoContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\t\t\taMemoContent.executeCommand( rtl::OUString::createFromAscii( \"delete\" ),bool2any( sal_True ) );\n\t\t\treturn sal_False;\n\t\t}\n\t\tm_aHeader.db_typ = dBaseIIIMemo;\n\t}\n\telse\n\t\tm_aHeader.db_typ = dBaseIII;\n\n\treturn sal_True;\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::throwInvalidColumnType(const sal_uInt16 _nErrorId,const ::rtl::OUString& _sColumnName)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::throwInvalidColumnType\" );\n\ttry\n\t{\n\t\t// we have to drop the file because it is corrupted now\n\t\tDropImpl();\n\t}\n\tcatch(const Exception&)\n\t{\n\t}\n\n    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n            _nErrorId,\n            \"$columnname$\", _sColumnName\n         ) );\n    ::dbtools::throwGenericSQLException( sError, *this );\n}\n//------------------------------------------------------------------\n// erzeugt grundsaetzlich dBase IV Datei Format\nsal_Bool ODbaseTable::CreateFile(const INetURLObject& aFile, sal_Bool& bCreateMemo)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::CreateFile\" );\n\tbCreateMemo = sal_False;\n\tDate aDate;                                     // aktuelles Datum\n\n\tm_pFileStream = createStream_simpleError( aFile.GetMainURL(INetURLObject::NO_DECODE),STREAM_READWRITE | STREAM_SHARE_DENYWRITE | STREAM_TRUNC );\n\n\tif (!m_pFileStream)\n\t\treturn sal_False;\n\n    sal_uInt8 nDbaseType = dBaseIII;\n    Reference<XIndexAccess> xColumns(getColumns(),UNO_QUERY);\n\tReference<XPropertySet> xCol;\n    const ::rtl::OUString sPropType = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE);\n    \n    try\n\t{\n        const sal_Int32 nCount = xColumns->getCount();\n\t\tfor(sal_Int32 i=0;i<nCount;++i)\n\t\t{\n\t\t\txColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"This should be a column!\");\n\n\t\t\tswitch (getINT32(xCol->getPropertyValue(sPropType)))\n\t\t\t{\n                case DataType::DOUBLE:\n                case DataType::INTEGER:                \n                case DataType::TIMESTAMP:\n                case DataType::LONGVARBINARY:\n                    nDbaseType = VisualFoxPro;\n                    i = nCount; // no more columns need to be checked\n                    break;\n            } // switch (getINT32(xCol->getPropertyValue(sPropType)))\n        }\n    }\n    catch ( const Exception& e )\n\t{\n        (void)e;\n\n\t\ttry\n\t\t{\n\t\t\t// we have to drop the file because it is corrupted now\n\t\t\tDropImpl();\n\t\t}\n\t\tcatch(const Exception&) { }\n\t\tthrow;\n\t}\n\n\tchar aBuffer[21];               // write buffer\n\tmemset(aBuffer,0,sizeof(aBuffer));\n\n\tm_pFileStream->Seek(0L);\n\t(*m_pFileStream) << (sal_uInt8) nDbaseType;                              // dBase format\n\t(*m_pFileStream) << (sal_uInt8) (aDate.GetYear() % 100);                 // aktuelles Datum\n\n\n\t(*m_pFileStream) << (sal_uInt8) aDate.GetMonth();\n\t(*m_pFileStream) << (sal_uInt8) aDate.GetDay();\n    (*m_pFileStream) << 0L;                                             // Anzahl der Datensaetze\n\t(*m_pFileStream) << (sal_uInt16)((m_pColumns->getCount()+1) * 32 + 1);  // Kopfinformationen,\n                                                                        // pColumns erhaelt immer eine Spalte mehr\n    (*m_pFileStream) << (sal_uInt16) 0;                                     // Satzlaenge wird spaeter bestimmt\n\tm_pFileStream->Write(aBuffer, 20);\n\n    sal_uInt16 nRecLength = 1;                                              // Laenge 1 fuer deleted flag\n\tsal_Int32  nMaxFieldLength = m_pConnection->getMetaData()->getMaxColumnNameLength();\n\t::rtl::OUString aName;\n    const ::rtl::OUString sPropName = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME);\n    const ::rtl::OUString sPropPrec = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION);\n    const ::rtl::OUString sPropScale = OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE);\n    \n\ttry\n\t{\n\t\tconst sal_Int32 nCount = xColumns->getCount();\n\t\tfor(sal_Int32 i=0;i<nCount;++i)\n\t\t{\n\t\t\txColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"This should be a column!\");\n\n            char cTyp( 'C' );\n\n\t\t\txCol->getPropertyValue(sPropName) >>= aName;\n\n\t\t\t::rtl::OString aCol;\n\t\t\tif ( DBTypeConversion::convertUnicodeString( aName, aCol, m_eEncoding ) > nMaxFieldLength)\n\t\t\t{\n                throwInvalidColumnType( STR_INVALID_COLUMN_NAME_LENGTH, aName );\n\t\t\t}\n\n\t\t\t(*m_pFileStream) << aCol.getStr();\n\t\t\tm_pFileStream->Write(aBuffer, 11 - aCol.getLength());\n\n            sal_Int32 nPrecision = 0;\n\t\t\txCol->getPropertyValue(sPropPrec) >>= nPrecision;\n\t\t\tsal_Int32 nScale = 0;\n\t\t\txCol->getPropertyValue(sPropScale) >>= nScale;\n\n            bool bBinary = false;\n\n\t\t\tswitch (getINT32(xCol->getPropertyValue(sPropType)))\n\t\t\t{\n\t\t\t\tcase DataType::CHAR:\n\t\t\t\tcase DataType::VARCHAR:\n\t\t\t\t\tcTyp = 'C';\n\t\t\t\t\tbreak;\n                case DataType::DOUBLE:\n                    if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        cTyp = 'Y';\n                    else\n                        cTyp = 'B';\n\t\t\t\t\tbreak;\n                case DataType::INTEGER:\n                    cTyp = 'I';\n\t\t\t\t    break;\n\t\t\t\tcase DataType::TINYINT:\n\t\t\t\tcase DataType::SMALLINT:\n\t\t\t\tcase DataType::BIGINT:\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\tcase DataType::NUMERIC:\n\t\t\t\tcase DataType::REAL:\n\t\t\t\t\tcTyp = 'N';                             // nur dBase 3 format\n\t\t\t\t\tbreak;\n                case DataType::TIMESTAMP:\n                    cTyp = 'T';\n\t\t\t\t    break;\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t\tcTyp = 'D';\n\t\t\t\t\tbreak;\n\t\t\t\tcase DataType::BIT:\n\t\t\t\t\tcTyp = 'L';\n\t\t\t\t\tbreak;\n\t\t\t\tcase DataType::LONGVARBINARY:\n                    bBinary = true;\n                    // run through\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t\tcTyp = 'M';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tthrowInvalidColumnType(STR_INVALID_COLUMN_TYPE, aName);\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t(*m_pFileStream) << cTyp;\n            if ( nDbaseType == VisualFoxPro )\n                (*m_pFileStream) << (nRecLength-1);\n            else\n\t\t\t    m_pFileStream->Write(aBuffer, 4);\t\t\t\n\n\t\t\tswitch(cTyp)\n\t\t\t{\n\t\t\t\tcase 'C':\n\t\t\t\t\tOSL_ENSURE(nPrecision < 255, \"ODbaseTable::Create: Column zu lang!\");\n\t\t\t\t\tif (nPrecision > 254)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrowInvalidColumnType(STR_INVALID_COLUMN_PRECISION, aName);\n\t\t\t\t\t}\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8) Min((sal_uIntPtr)nPrecision, 255UL);      //Feldlaenge\n                    nRecLength = nRecLength + (sal_uInt16)::std::min((sal_uInt16)nPrecision, (sal_uInt16)255UL);\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;                                                                //Nachkommastellen\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'N':\n\t\t\t\t\tOSL_ENSURE(nPrecision >=  nScale,\n\t\t\t\t\t\t\t\"ODbaseTable::Create: Feldlaenge muss groesser Nachkommastellen sein!\");\n\t\t\t\t\tif (nPrecision <  nScale)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrowInvalidColumnType(STR_INVALID_PRECISION_SCALE, aName);\n\t\t\t\t\t}\n\t\t\t\t\tif (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n\t\t\t\t\t{\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)10;          // Standard Laenge\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)4;\n\t\t\t\t\t\tnRecLength += 10;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsal_Int32 nPrec = SvDbaseConverter::ConvertPrecisionToDbase(nPrecision,nScale);\n\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)( nPrec);\n\t\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)nScale;\n                        nRecLength += (sal_uInt16)nPrec;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)1;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\t++nRecLength;\n\t\t\t\t\tbreak;\n                case 'I':\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)4;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\tnRecLength += 4;\n\t\t\t\t\tbreak;\n                case 'Y':\n                case 'B':\n                case 'T':\n\t\t\t\tcase 'D':\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)8;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\tnRecLength += 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tbCreateMemo = sal_True;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)10;\n\t\t\t\t\t(*m_pFileStream) << (sal_uInt8)0;\n\t\t\t\t\tnRecLength += 10;\n                    if ( bBinary )\n                        aBuffer[0] = 0x06;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n                    throwInvalidColumnType(STR_INVALID_COLUMN_TYPE, aName);\n\t\t\t}\n\t\t\tm_pFileStream->Write(aBuffer, 14);\n            aBuffer[0] = 0x00;\n\t\t}\n\n\t\t(*m_pFileStream) << (sal_uInt8)FIELD_DESCRIPTOR_TERMINATOR;              // kopf ende\n        (*m_pFileStream) << (char)DBF_EOL;\n\t\tm_pFileStream->Seek(10L);\n\t\t(*m_pFileStream) << nRecLength;                                     // Satzlaenge nachtraeglich eintragen\n\n\t\tif (bCreateMemo)\n\t\t{\n\t\t\tm_pFileStream->Seek(0L);\n            if (nDbaseType == VisualFoxPro)\n                (*m_pFileStream) << (sal_uInt8) FoxProMemo;\n            else\n                (*m_pFileStream) << (sal_uInt8) dBaseIIIMemo;\n\t\t} // if (bCreateMemo)\n\t}\n\tcatch ( const Exception& e )\n\t{\n        (void)e;\n\n\t\ttry\n\t\t{\n\t\t\t// we have to drop the file because it is corrupted now\n\t\t\tDropImpl();\n\t\t}\n\t\tcatch(const Exception&) { }\n\t\tthrow;\n\t}\n\treturn sal_True;\n}\n\n//------------------------------------------------------------------\n// erzeugt grundsaetzlich dBase III Datei Format\nsal_Bool ODbaseTable::CreateMemoFile(const INetURLObject& aFile)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::CreateMemoFile\" );\n    // Makro zum Filehandling fuers Erzeugen von Tabellen\n\tm_pMemoStream = createStream_simpleError( aFile.GetMainURL(INetURLObject::NO_DECODE),STREAM_READWRITE | STREAM_SHARE_DENYWRITE);\n\n\tif (!m_pMemoStream)\n\t\treturn sal_False;\n\n\tchar aBuffer[512];              // write buffer\n\tmemset(aBuffer,0,sizeof(aBuffer));\n\n\tm_pMemoStream->SetFiller('\\0');\n\tm_pMemoStream->SetStreamSize(512);\n\n\tm_pMemoStream->Seek(0L);\n\t(*m_pMemoStream) << long(1);                  // Zeiger auf ersten freien Block\n\n\tm_pMemoStream->Flush();\n\tdelete m_pMemoStream;\n\tm_pMemoStream = NULL;\n\treturn sal_True;\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::Drop_Static(const ::rtl::OUString& _sUrl,sal_Bool _bHasMemoFields,OCollection* _pIndexes )\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::Drop_Static\" );\n\tINetURLObject aURL;\n\taURL.SetURL(_sUrl);\n\n\tsal_Bool bDropped = ::utl::UCBContentHelper::Kill(aURL.GetMainURL(INetURLObject::NO_DECODE));\n\n\tif(bDropped)\n\t{\n\t\tif (_bHasMemoFields)\n\t\t{  // delete the memo fields\n\t\t\taURL.setExtension(String::CreateFromAscii(\"dbt\"));\n\t\t\tbDropped = ::utl::UCBContentHelper::Kill(aURL.GetMainURL(INetURLObject::NO_DECODE));\n\t\t}\n\n\t\tif(bDropped)\n\t\t{\n\t\t\tif(_pIndexes)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tsal_Int32 i = _pIndexes->getCount();\n\t\t\t\t\twhile (i)\n\t\t\t\t\t{\n\t\t\t\t\t\t_pIndexes->dropByIndex(--i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(SQLException)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\taFile.SetBase(m_Name);\n\t\t\taURL.setExtension(String::CreateFromAscii(\"inf\"));\n\n\t\t\t// as the inf file does not necessarily exist, we aren't allowed to use UCBContentHelper::Kill\n\t\t\t// 89711 - 16.07.2001 - frank.schoenheit@sun.com\n\t\t\ttry\n\t\t\t{\n\t\t\t\t::ucbhelper::Content aDeleteContent( aURL.GetMainURL( INetURLObject::NO_DECODE ), Reference< XCommandEnvironment > () );\n\t\t\t\taDeleteContent.executeCommand( ::rtl::OUString::createFromAscii( \"delete\" ), makeAny( sal_Bool( sal_True ) ) );\n\t\t\t}\n\t\t\tcatch(Exception&)\n\t\t\t{\n\t\t\t\t// silently ignore this ....\n\t\t\t}\n\t\t}\n\t}\n\treturn bDropped;\n}\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::DropImpl()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::DropImpl\" );\n\tFileClose();\n\n\tif(!m_pIndexes)\n\t\trefreshIndexes(); // look for indexes which must be deleted as well\n\n\tsal_Bool bDropped = Drop_Static(getEntry(m_pConnection,m_Name),HasMemoFields(),m_pIndexes);\n\tif(!bDropped)\n\t{// we couldn't drop the table so we have to reopen it\n\t\tconstruct();\n\t\tif(m_pColumns)\n\t\t\tm_pColumns->refresh();\n\t}\n\treturn bDropped;\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::InsertRow(OValueRefVector& rRow, sal_Bool bFlush,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::InsertRow\" );\n    // Buffer mit Leerzeichen fuellen\n\tAllocBuffer();\n\tmemset(m_pBuffer, 0, m_aHeader.db_slng);\n    m_pBuffer[0] = ' ';\n\n\t// Gesamte neue Row uebernehmen:\n\t// ... und am Ende als neuen Record hinzufuegen:\n\tsal_uInt32 nTempPos = m_nFilePos,\n\t\t   nFileSize = 0,\n\t\t   nMemoFileSize = 0;\n\n\tm_nFilePos = (sal_uIntPtr)m_aHeader.db_anz + 1;\n    sal_Bool bInsertRow = UpdateBuffer( rRow, NULL, _xCols );\n\tif ( bInsertRow )\n\t{\n\t\tnFileSize = lcl_getFileSize(*m_pFileStream);\t\t\n\n\t\tif (HasMemoFields() && m_pMemoStream)\n\t\t{\n\t\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\t\tnMemoFileSize = m_pMemoStream->Tell();\n\t\t}\n\n\t\tif (!WriteBuffer())\n\t\t{\n            m_pFileStream->SetStreamSize(nFileSize);                // alte Groesse restaurieren\n\n\t\t\tif (HasMemoFields() && m_pMemoStream)\n                m_pMemoStream->SetStreamSize(nMemoFileSize);    // alte Groesse restaurieren\n\t\t\tm_nFilePos = nTempPos;\t\t\t\t\t\t\t\t// Fileposition restaurieren\n\t\t}\n\t\telse\n\t\t{\n            (*m_pFileStream) << (char)DBF_EOL; // write EOL\n\t\t\t// Anzahl Datensaetze im Header erhoehen:\n\t\t\tm_pFileStream->Seek( 4L );\n\t\t\t(*m_pFileStream) << (m_aHeader.db_anz + 1);\n\n\t\t\t// beim AppendOnly kein Flush!\n\t\t\tif (bFlush)\n\t\t\t\tm_pFileStream->Flush();\n\n            // bei Erfolg # erhoehen\n\t\t\tm_aHeader.db_anz++;\n\t\t\t*rRow.get()[0] = m_nFilePos;\t\t\t\t\t\t\t    // BOOKmark setzen\n\t\t\tm_nFilePos = nTempPos;\n\t\t}\n\t}\n\telse\n\t\tm_nFilePos = nTempPos;\n\n\treturn bInsertRow;\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::UpdateRow(OValueRefVector& rRow, OValueRefRow& pOrgRow,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::UpdateRow\" );\n    // Buffer mit Leerzeichen fuellen\n\tAllocBuffer();\n\n\t// Auf gewuenschten Record positionieren:\n\tlong nPos = m_aHeader.db_kopf + (long)(m_nFilePos-1) * m_aHeader.db_slng;\n\tm_pFileStream->Seek(nPos);\n\tm_pFileStream->Read((char*)m_pBuffer, m_aHeader.db_slng);\n\n\tsal_uInt32 nMemoFileSize( 0 );\n\tif (HasMemoFields() && m_pMemoStream)\n\t{\n\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\tnMemoFileSize = m_pMemoStream->Tell();\n\t}\n\tif (!UpdateBuffer(rRow, pOrgRow,_xCols) || !WriteBuffer())\n\t{\n\t\tif (HasMemoFields() && m_pMemoStream)\n            m_pMemoStream->SetStreamSize(nMemoFileSize);    // alte Groesse restaurieren\n\t}\n\telse\n\t{\n\t\tm_pFileStream->Flush();\n\t}\n\treturn sal_True;\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::DeleteRow(const OSQLColumns& _rCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::DeleteRow\" );\n\t// Einfach das Loesch-Flag setzen (egal, ob es schon gesetzt war\n\t// oder nicht):\n\t// Auf gewuenschten Record positionieren:\n\tlong nFilePos = m_aHeader.db_kopf + (long)(m_nFilePos-1) * m_aHeader.db_slng;\n\tm_pFileStream->Seek(nFilePos);\n\n\tOValueRefRow aRow = new OValueRefVector(_rCols.get().size());\n\n\tif (!fetchRow(aRow,_rCols,sal_True,sal_True))\n\t\treturn sal_False;\n\n\tReference<XPropertySet> xCol;\n\t::rtl::OUString aColName;\n\t::comphelper::UStringMixEqual aCase(isCaseSensitive());\n\tfor (sal_uInt16 i = 0; i < m_pColumns->getCount(); i++)\n\t{\n\t\tReference<XPropertySet> xIndex = isUniqueByColumnName(i);\n\t\tif (xIndex.is())\n\t\t{\n\t\t\t::cppu::extractInterface(xCol,m_pColumns->getByIndex(i));\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::DeleteRow column is null!\");\n\t\t\tif(xCol.is())\n\t\t\t{\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\t\tReference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);\n\t\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::DeleteRow: No Index returned!\");\n\n\t\t\t\tOSQLColumns::Vector::const_iterator aIter = _rCols.get().begin();\n\t\t\t\tsal_Int32 nPos = 1;\n\t\t\t\tfor(;aIter != _rCols.get().end();++aIter,++nPos)\n\t\t\t\t{\n\t\t\t\t\tif(aCase(getString((*aIter)->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_REALNAME))),aColName))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (aIter == _rCols.get().end())\n\t\t\t\t\tcontinue;\n\n\t\t\t\tpIndex->Delete(m_nFilePos,*(aRow->get())[nPos]);\n\t\t\t}\n\t\t}\n\t}\n\n\tm_pFileStream->Seek(nFilePos);\n\t(*m_pFileStream) << (sal_uInt8)'*'; // mark the row in the table as deleted\n\tm_pFileStream->Flush();\n\treturn sal_True;\n}\n// -------------------------------------------------------------------------\nReference<XPropertySet> ODbaseTable::isUniqueByColumnName(sal_Int32 _nColumnPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::isUniqueByColumnName\" );\n\tif(!m_pIndexes)\n\t\trefreshIndexes();\n\tif(m_pIndexes->hasElements())\n\t{\n\t\tReference<XPropertySet> xCol;\n\t\tm_pColumns->getByIndex(_nColumnPos) >>= xCol;\n\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::isUniqueByColumnName column is null!\");\n\t\t::rtl::OUString sColName;\n\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= sColName;\n\n\t\tReference<XPropertySet> xIndex;\n\t\tfor(sal_Int32 i=0;i<m_pIndexes->getCount();++i)\n\t\t{\n\t\t\t::cppu::extractInterface(xIndex,m_pIndexes->getByIndex(i));\n\t\t\tif(xIndex.is() && getBOOL(xIndex->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISUNIQUE))))\n\t\t\t{\n\t\t\t\tReference<XNameAccess> xCols(Reference<XColumnsSupplier>(xIndex,UNO_QUERY)->getColumns());\n\t\t\t\tif(xCols->hasByName(sColName))\n\t\t\t\t\treturn xIndex;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn Reference<XPropertySet>();\n}\n//------------------------------------------------------------------\ndouble toDouble(const ByteString& rString)\n{\n    return ::rtl::math::stringToDouble( rString, '.', ',', NULL, NULL );\n}\n\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::UpdateBuffer\" );\n\tOSL_ENSURE(m_pBuffer,\"Buffer is NULL!\");\n\tif ( !m_pBuffer )\n\t\treturn sal_False;\n\tsal_Int32 nByteOffset  = 1;\n\n\t// Felder aktualisieren:\n\tReference<XPropertySet> xCol;\n\tReference<XPropertySet> xIndex;\n\tsal_uInt16 i;\n\t::rtl::OUString aColName;\n\tconst sal_Int32 nColumnCount = m_pColumns->getCount();\n\t::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount);\n\n\t::comphelper::UStringMixEqual aCase(isCaseSensitive());\n\n\tReference<XIndexAccess> xColumns = m_pColumns;\n\t// first search a key that exist already in the table\n\tfor (i = 0; i < nColumnCount; ++i)\n\t{\n\t\tsal_Int32 nPos = i;\n\t\tif(_xCols != xColumns)\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\tfor(nPos = 0;nPos<_xCols->getCount();++nPos)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xFindCol;\n\t\t\t\t::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));\n\t\t\t\tOSL_ENSURE(xFindCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\tif(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nPos >= _xCols->getCount())\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t++nPos;\n\t\txIndex = isUniqueByColumnName(i);\n\t\taIndexedCols[i] = xIndex;\n\t\tif (xIndex.is())\n\t\t{\n\t\t\t// first check if the value is different to the old one and when if it conform to the index\n\t\t\tif(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos]))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t//\tODbVariantRef xVar = (pVal == NULL) ? new ODbVariant() : pVal;\n\t\t\t\tReference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY);\n\t\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::UpdateBuffer: No Index returned!\");\n\n\t\t\t\tif (pIndex->Find(0,*rRow.get()[nPos]))\n\t\t\t\t{\n\t\t\t\t\t// es existiert kein eindeutiger Wert\n\t\t\t\t\tif ( !aColName.getLength() )\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\t\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\t\t\t\t\t\txCol.clear();\n\t\t\t\t\t} // if ( !aColName.getLength() )\n                    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                            STR_DUPLICATE_VALUE_IN_COLUMN\n                            ,\"$columnname$\", aColName\n                         ) );\n                    ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// when we are here there is no double key in the table\n\n\tfor (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i)\n\t{\n\t\t// Laengen je nach Datentyp:\n\t\tOSL_ENSURE(i < m_aPrecisions.size(),\"Illegal index!\");\n\t\tsal_Int32 nLen = 0;\n\t\tsal_Int32 nType = 0;\n\t\tsal_Int32 nScale = 0;\n\t\tif ( i < m_aPrecisions.size() )\n\t\t{\n\t\t\tnLen\t= m_aPrecisions[i];\n\t\t\tnType\t= m_aTypes[i];\n\t\t\tnScale\t= m_aScales[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tif ( xCol.is() )\n\t\t\t{\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))\t>>= nLen;\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))\t\t>>= nType;\n\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))\t\t>>= nScale;\n\t\t\t}\n\t\t}\n\n        bool bSetZero = false;\n\t\tswitch (nType)\n\t\t{\n            case DataType::INTEGER:\n            case DataType::DOUBLE:\n            case DataType::TIMESTAMP:\n                bSetZero = true;\n            case DataType::LONGVARBINARY:\n\t\t\tcase DataType::DATE:\n            case DataType::BIT:\t\t\t\n\t\t\tcase DataType::LONGVARCHAR:\n                nLen = m_aRealFieldLengths[i]; \n                break;\n\t\t\tcase DataType::DECIMAL:\n\t\t\t\tnLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale);\n\t\t\t\tbreak;\t// das Vorzeichen und das Komma\n\t\t\tdefault:\t\t\t\t\t\n                break;\n\n\t\t} // switch (nType)\n\n\t\tsal_Int32 nPos = i;\n\t\tif(_xCols != xColumns)\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\t\t\tfor(nPos = 0;nPos<_xCols->getCount();++nPos)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xFindCol;\n\t\t\t\t::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos));\n\t\t\t\tif(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (nPos >= _xCols->getCount())\n\t\t\t{\n\t\t\t\tnByteOffset += nLen;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\n\n\t\t++nPos; // the row values start at 1\n\t\t// Ist die Variable ueberhaupt gebunden?\n\t\tif ( !rRow.get()[nPos]->isBound() )\n\t\t{\n\t\t\t// Nein - naechstes Feld.\n\t\t\tnByteOffset += nLen;\n\t\t\tcontinue;\n\t\t}\n\t\tif (aIndexedCols[i].is())\n\t\t{\n\t\t\tReference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY);\n\t\t\tOSL_ENSURE(xTunnel.is(),\"No TunnelImplementation!\");\n\t\t\tODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) );\n\t\t\tOSL_ENSURE(pIndex,\"ODbaseTable::UpdateBuffer: No Index returned!\");\n\t\t\t// Update !!\n\t\t\tif (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )//&& pVal->isModified())\n\t\t\t\tpIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]);\n\t\t\telse\n\t\t\t\tpIndex->Insert(m_nFilePos,*rRow.get()[nPos]);\n\t\t}\n\n\t\tchar* pData = (char *)(m_pBuffer + nByteOffset);\n\t\tif (rRow.get()[nPos]->getValue().isNull())\n\t\t{\n            if ( bSetZero )\n                memset(pData,0,nLen);\t// Zuruecksetzen auf NULL\n            else\n\t\t\t    memset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\t\t\tnByteOffset += nLen;\n\t\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t\t\tcontinue;\n\t\t}\n\n        sal_Bool bHadError = sal_False;\n\t\ttry\n\t\t{\n\t\t\tswitch (nType)\n\t\t\t{\n                case DataType::TIMESTAMP:\n                    {\n                        OSL_ENSURE(nLen == 8, \"Invalid length for timestamp field\");\n                        if (nLen != 8) {\n                            bHadError = true;\n                            break;\n                        }\n                        sal_Int32 nJulianDate = 0, nJulianTime = 0;\n                        lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue());\n                        // Genau 8 Byte kopieren:\n\t\t\t\t\t    memcpy(pData,&nJulianDate,4);\n                        memcpy(pData+4,&nJulianTime,4);\n                    }\n                    break;\n\t\t\t\tcase DataType::DATE:\n\t\t\t\t{\n                    OSL_ENSURE(nLen == 8, \"Invalid length for date field\");\n                    if (nLen != 8) {\n                        bHadError = true;\n                        break;\n                    }\n\t\t\t\t\t::com::sun::star::util::Date aDate;\n\t\t\t\t\tif(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE)\n\t\t\t\t\t\taDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble());\n\t\t\t\t\telse\n\t\t\t\t\t\taDate = rRow.get()[nPos]->getValue();\n\t\t\t\t\tchar s[9];\n\t\t\t\t\tsnprintf(s,\n\t\t\t\t\t\tsizeof(s),\n\t\t\t\t\t\t\"%04d%02d%02d\",\n\t\t\t\t\t\t(int)aDate.Year,\n\t\t\t\t\t\t(int)aDate.Month,\n\t\t\t\t\t\t(int)aDate.Day);\n\n\t\t\t\t\t// Genau 8 Byte kopieren:\n\t\t\t\t\tstrncpy(pData,s,sizeof s - 1);\n\t\t\t\t} break;\n                case DataType::INTEGER:\n                    {\n                        OSL_ENSURE(nLen == 4, \"Invalid length for integer field\");\n                        if (nLen != 4) {\n                            bHadError = true;\n                            break;\n                        }\n                        sal_Int32 nValue = rRow.get()[nPos]->getValue();\n                        memcpy(pData,&nValue,nLen);\n                    }\n                    break;\n                case DataType::DOUBLE:\n                    {\n                        OSL_ENSURE(nLen == 8, \"Invalid length for double field\");\n                        if (nLen != 8) {\n                            bHadError = true;\n                            break;\n                        }\n                        const double d = rRow.get()[nPos]->getValue();\n                        m_pColumns->getByIndex(i) >>= xCol;\n                        \n                        if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        {\n                            sal_Int64 nValue = 0;\n                            if ( m_aScales[i] )\n                                nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i]));\n                            else\n                                nValue = (sal_Int64)(d);\n                            memcpy(pData,&nValue,nLen);\n                        } // if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY)))) // Currency wird gesondert behandelt\n                        else\n                            memcpy(pData,&d,nLen);\n                    }\n                    break;\n\t\t\t\tcase DataType::DECIMAL:\n\t\t\t\t{\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\n\t\t\t\t\tconst double n = rRow.get()[nPos]->getValue();\n\n\t\t\t\t\t// ein const_cast, da GetFormatPrecision am SvNumberFormat nicht const ist, obwohl es das eigentlich\n\t\t\t\t\t// sein koennte und muesste\n\n\t\t\t\t\tconst ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0));\n                    sal_Bool bValidLength  = aDefaultValue.Len() <= nLen;\n                    if ( bValidLength )\n                    {\n\t\t\t\t\t    strncpy(pData,aDefaultValue.GetBuffer(),nLen);\n\t\t\t\t\t    // write the resulting double back\n\t\t\t\t\t    *rRow.get()[nPos] = toDouble(aDefaultValue);\n                    }\n                    else\n\t\t\t\t\t{\n\t\t\t\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\t\t\t\tOSL_ENSURE(xCol.is(),\"ODbaseTable::UpdateBuffer column is null!\");\n\t\t\t\t\t\txCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n                        ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes;\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$columnname$\", aColName));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$precision$\", String::CreateFromInt32(nLen)));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$scale$\", String::CreateFromInt32(nScale)));\n                        aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(\"$value$\", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8)));\n\n                        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                                STR_INVALID_COLUMN_DECIMAL_VALUE\n                                ,aStringToSubstitutes\n                             ) );\n                        ::dbtools::throwGenericSQLException( sError, *this );\n\t\t\t\t\t}\n\t\t\t\t} break;\n\t\t\t\tcase DataType::BIT:\n                    OSL_ENSURE(nLen == 1, \"Invalid length for bit field\");\n                    if (nLen != 1) {\n                        bHadError = true;\n                        break;\n                    }\n\t\t\t\t\t*pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F';\n\t\t\t\t\tbreak;\n                case DataType::LONGVARBINARY:\n\t\t\t\tcase DataType::LONGVARCHAR:\n\t\t\t\t{\n\t\t\t\t\tchar cNext = pData[nLen]; // merken und temporaer durch 0 ersetzen\n\t\t\t\t\tpData[nLen] = '\\0';\t\t  // das geht, da der Puffer immer ein Zeichen groesser ist ...\n\n\t\t\t\t\tsal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10);\t// Blocknummer lesen\n\n\t\t\t\t\t// Naechstes Anfangszeichen wieder restaurieren:\n\t\t\t\t\tpData[nLen] = cNext;\n\t\t\t\t\tif (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tByteString aStr;\n\t\t\t\t\tByteString aBlock(ByteString::CreateFromInt32(nBlockNo));\n\t\t\t\t\taStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' );\n\t\t\t\t\taStr += aBlock;\n\t\t\t\t\t// Zeichen kopieren:\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\t\t\t\t\tmemcpy(pData, aStr.GetBuffer(), nLen);\n\t\t\t\t}\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tmemset(pData,' ',nLen);\t// Zuruecksetzen auf NULL\n\n                    ::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() );\n\n                    // convert the string, using the connection's encoding\n                    ::rtl::OString sEncoded;\n                   \n                    DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding );\n                    memcpy( pData, sEncoded.getStr(), sEncoded.getLength() );\n\n\t\t\t\t}\n                break;\n\t\t\t}\n\t\t}\n\t\tcatch( SQLException&  )\n        {\n            throw;\n        }\n\t\tcatch ( Exception& ) { bHadError = sal_True; }\n\n\t\tif ( bHadError )\n\t\t{\n\t\t\tm_pColumns->getByIndex(i) >>= xCol;\n\t\t\tOSL_ENSURE( xCol.is(), \"ODbaseTable::UpdateBuffer column is null!\" );\n            if ( xCol.is() )\n\t\t\t    xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName;\n\n\t\t\tconst ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                    STR_INVALID_COLUMN_VALUE,\n                    \"$columnname$\", aColName\n                 ) );\n            ::dbtools::throwGenericSQLException( sError, *this );\n\t\t}\n\t\t// Und weiter ...\n\t\tnByteOffset += nLen;\n\t\tOSL_ENSURE( nByteOffset <= m_nBufferSize ,\"ByteOffset > m_nBufferSize!\");\n\t}\n\treturn sal_True;\n}\n\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::WriteMemo(ORowSetValue& aVariable, sal_uIntPtr& rBlockNr)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::WriteMemo\" );\n\t// wird die BlockNr 0 vorgegeben, wird der block ans Ende gehaengt\n    sal_uIntPtr nSize = 0;\n    ::rtl::OString aStr;\n    ::com::sun::star::uno::Sequence<sal_Int8> aValue;\n\tsal_uInt8 nHeader[4];\n    const bool bBinary = aVariable.getTypeKind() == DataType::LONGVARBINARY && m_aMemoHeader.db_typ == MemoFoxPro;\n    if ( bBinary )\n    {\n        aValue = aVariable.getSequence();\n        nSize = aValue.getLength();\n    }\n    else\n    {\n        nSize = DBTypeConversion::convertUnicodeString( aVariable.getString(), aStr, m_eEncoding );\n    }\n\n\t// Anhaengen oder ueberschreiben\n\tsal_Bool bAppend = rBlockNr == 0;\n\n\tif (!bAppend)\n\t{\n\t\tswitch (m_aMemoHeader.db_typ)\n\t\t{\n\t\t\tcase MemodBaseIII: // dBase III-Memofeld, endet mit 2 * Ctrl-Z\n\t\t\t\tbAppend = nSize > (512 - 2);\n\t\t\t\tbreak;\n\t\t\tcase MemoFoxPro:\n\t\t\tcase MemodBaseIV: // dBase IV-Memofeld mit Laengenangabe\n\t\t\t{\n\t\t\t\tchar sHeader[4];\n\t\t\t\tm_pMemoStream->Seek(rBlockNr * m_aMemoHeader.db_size);\n\t\t\t\tm_pMemoStream->SeekRel(4L);\n\t\t\t\tm_pMemoStream->Read(sHeader,4);\n\n\t\t\t\tsal_uIntPtr nOldSize;\n\t\t\t\tif (m_aMemoHeader.db_typ == MemoFoxPro)\n\t\t\t\t\tnOldSize = ((((unsigned char)sHeader[0]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[1]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[2]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[3];\n\t\t\t\telse\n\t\t\t\t\tnOldSize = ((((unsigned char)sHeader[3]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[2]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[1]) * 256 +\n\t\t\t\t\t\t\t\t (unsigned char)sHeader[0]  - 8;\n\n\t\t\t\t// passt die neue Laenge in die belegten Bloecke\n\t\t\t\tsal_uIntPtr nUsedBlocks = ((nSize + 8) / m_aMemoHeader.db_size) + (((nSize + 8) % m_aMemoHeader.db_size > 0) ? 1 : 0),\n\t\t\t\t\t  nOldUsedBlocks = ((nOldSize + 8) / m_aMemoHeader.db_size) + (((nOldSize + 8) % m_aMemoHeader.db_size > 0) ? 1 : 0);\n\t\t\t\tbAppend = nUsedBlocks > nOldUsedBlocks;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bAppend)\n\t{\n\t\tsal_uIntPtr nStreamSize = m_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\t// letzten block auffuellen\n\t\trBlockNr = (nStreamSize / m_aMemoHeader.db_size) + ((nStreamSize % m_aMemoHeader.db_size) > 0 ? 1 : 0);\n\n\t\tm_pMemoStream->SetStreamSize(rBlockNr * m_aMemoHeader.db_size);\n\t\tm_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t}\n\telse\n\t{\n\t\tm_pMemoStream->Seek(rBlockNr * m_aMemoHeader.db_size);\n\t}\n\n\tswitch (m_aMemoHeader.db_typ)\n\t{\n\t\tcase MemodBaseIII: // dBase III-Memofeld, endet mit Ctrl-Z\n\t\t{\n\t\t\tconst char cEOF = (char) DBF_EOL;\n\t\t\tnSize++;\n\t\t\tm_pMemoStream->Write( aStr.getStr(), aStr.getLength() );\n\t\t\t(*m_pMemoStream) << cEOF << cEOF;\n\t\t} break;\n\t\tcase MemoFoxPro:\n\t\tcase MemodBaseIV: // dBase IV-Memofeld mit Laengenangabe\n\t\t{\n            if ( MemodBaseIV == m_aMemoHeader.db_typ )\n\t\t\t    (*m_pMemoStream) << (sal_uInt8)0xFF\n\t\t\t\t\t\t\t     << (sal_uInt8)0xFF\n\t\t\t\t\t\t\t     << (sal_uInt8)0x08;\n            else\n                (*m_pMemoStream) << (sal_uInt8)0x00\n\t\t\t\t\t\t\t     << (sal_uInt8)0x00\n\t\t\t\t\t\t\t     << (sal_uInt8)0x00;\n\n\t\t\tsal_uInt32 nWriteSize = nSize;\n\t\t\tif (m_aMemoHeader.db_typ == MemoFoxPro)\n\t\t\t{\n                if ( bBinary )\n                    (*m_pMemoStream) << (sal_uInt8) 0x00; // Picture\n                else\n\t\t\t\t    (*m_pMemoStream) << (sal_uInt8) 0x01; // Memo\n\t\t\t\tfor (int i = 4; i > 0; nWriteSize >>= 8)\n\t\t\t\t\tnHeader[--i] = (sal_uInt8) (nWriteSize % 256);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t(*m_pMemoStream) << (sal_uInt8) 0x00;\n\t\t\t\tnWriteSize += 8;\n\t\t\t\tfor (int i = 0; i < 4; nWriteSize >>= 8)\n\t\t\t\t\tnHeader[i++] = (sal_uInt8) (nWriteSize % 256);\n\t\t\t}\n\n\t\t\tm_pMemoStream->Write(nHeader,4);\n            if ( bBinary )\n                m_pMemoStream->Write( aValue.getConstArray(), aValue.getLength() );\n            else\n\t\t\t    m_pMemoStream->Write( aStr.getStr(), aStr.getLength() );\n\t\t\tm_pMemoStream->Flush();\n\t\t}\n\t}\n\n\n\t// Schreiben der neuen Blocknummer\n\tif (bAppend)\n\t{\n\t\tsal_uIntPtr nStreamSize = m_pMemoStream->Seek(STREAM_SEEK_TO_END);\n\t\tm_aMemoHeader.db_next = (nStreamSize / m_aMemoHeader.db_size) + ((nStreamSize % m_aMemoHeader.db_size) > 0 ? 1 : 0);\n\n\t\t// Schreiben der neuen Blocknummer\n\t\tm_pMemoStream->Seek(0L);\n\t\t(*m_pMemoStream) << m_aMemoHeader.db_next;\n\t\tm_pMemoStream->Flush();\n\t}\n\treturn sal_True;\n}\n\n// -----------------------------------------------------------------------------\n// XAlterTable\nvoid SAL_CALL ODbaseTable::alterColumnByName( const ::rtl::OUString& colName, const Reference< XPropertySet >& descriptor ) throw(SQLException, NoSuchElementException, RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::alterColumnByName\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tcheckDisposed(OTableDescriptor_BASE::rBHelper.bDisposed);\n\n\n\tReference<XDataDescriptorFactory> xOldColumn;\n\tm_pColumns->getByName(colName) >>= xOldColumn;\n\n\talterColumn(m_pColumns->findColumn(colName)-1,descriptor,xOldColumn);\n}\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::alterColumnByIndex( sal_Int32 index, const Reference< XPropertySet >& descriptor ) throw(SQLException, ::com::sun::star::lang::IndexOutOfBoundsException, RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::alterColumnByIndex\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tcheckDisposed(OTableDescriptor_BASE::rBHelper.bDisposed);\n\n\tif(index < 0 || index >= m_pColumns->getCount())\n\t\tthrow IndexOutOfBoundsException(::rtl::OUString::valueOf(index),*this);\n\n\tReference<XDataDescriptorFactory> xOldColumn;\n\tm_pColumns->getByIndex(index) >>= xOldColumn;\n\talterColumn(index,descriptor,xOldColumn);\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::alterColumn(sal_Int32 index,\n\t\t\t\t\t\t\t  const Reference< XPropertySet >& descriptor ,\n\t\t\t\t\t\t\t  const Reference< XDataDescriptorFactory >& xOldColumn )\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::alterColumn\" );\n\tif(index < 0 || index >= m_pColumns->getCount())\n\t\tthrow IndexOutOfBoundsException(::rtl::OUString::valueOf(index),*this);\n\n\tODbaseTable* pNewTable = NULL;\n\ttry\n\t{\n\t\tOSL_ENSURE(descriptor.is(),\"ODbaseTable::alterColumn: descriptor can not be null!\");\n\t\t// creates a copy of the the original column and copy all properties from descriptor in xCopyColumn\n\t\tReference<XPropertySet> xCopyColumn;\n\t\tif(xOldColumn.is())\n\t\t\txCopyColumn = xOldColumn->createDataDescriptor();\n\t\telse\n\t\t\txCopyColumn = new OColumn(getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers());\n\n\t\t::comphelper::copyProperties(descriptor,xCopyColumn);\n\n\t\t// creates a temp file\n\n\t\tString sTempName = createTempFile();\n\n\t\tpNewTable = new ODbaseTable(m_pTables,static_cast<ODbaseConnection*>(m_pConnection));\n\t\tReference<XPropertySet> xHoldTable = pNewTable;\n\t\tpNewTable->setPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME),makeAny(::rtl::OUString(sTempName)));\n\t\tReference<XAppend> xAppend(pNewTable->getColumns(),UNO_QUERY);\n\t\tOSL_ENSURE(xAppend.is(),\"ODbaseTable::alterColumn: No XAppend interface!\");\n\n\t\t// copy the structure\n\t\tsal_Int32 i=0;\n\t\tfor(;i < index;++i)\n\t\t{\n\t\t\tReference<XPropertySet> xProp;\n\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\tReference<XPropertySet> xCpy;\n\t\t\tif(xColumn.is())\n\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\telse\n\t\t\t\txCpy = new OColumn(getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers());\n\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t}\n\t\t++i; // now insert our new column\n\t\txAppend->appendByDescriptor(xCopyColumn);\n\n\t\tfor(;i < m_pColumns->getCount();++i)\n\t\t{\n\t\t\tReference<XPropertySet> xProp;\n\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\tReference<XPropertySet> xCpy;\n\t\t\tif(xColumn.is())\n\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\telse\n\t\t\t\txCpy = new OColumn(getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers());\n\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t}\n\n\t\t// construct the new table\n\t\tif(!pNewTable->CreateImpl())\n\t\t{\n            const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                    STR_COLUMN_NOT_ALTERABLE,\n                    \"$columnname$\", ::comphelper::getString(descriptor->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)))\n                 ) );\n            ::dbtools::throwGenericSQLException( sError, *this );\n\t\t}\n\n\t\tpNewTable->construct();\n\n\t\t// copy the data\n\t\tcopyData(pNewTable,0);\n\n\t\t// now drop the old one\n\t\tif( DropImpl() ) // we don't want to delete the memo columns too\n\t\t{\n\t\t\t// rename the new one to the old one\n\t\t\tpNewTable->renameImpl(m_Name);\n\t\t\t// release the temp file\n\t\t\tpNewTable = NULL;\n\t\t\t::comphelper::disposeComponent(xHoldTable);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpNewTable = NULL;\n\t\t}\n\t\tFileClose();\n\t\tconstruct();\n\t\tif(m_pColumns)\n\t\t\tm_pColumns->refresh();\n\n\t}\n\tcatch(const SQLException&)\n\t{\n\t\tthrow;\n\t}\n\tcatch(const Exception&)\n\t{\n\t\tOSL_ENSURE(0,\"ODbaseTable::alterColumn: Exception occured!\");\n\t\tthrow;\n\t}\n}\n// -----------------------------------------------------------------------------\nReference< XDatabaseMetaData> ODbaseTable::getMetaData() const\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getMetaData\" );\n\treturn getConnection()->getMetaData();\n}\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::rename( const ::rtl::OUString& newName ) throw(::com::sun::star::sdbc::SQLException, ::com::sun::star::container::ElementExistException, ::com::sun::star::uno::RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::rename\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\tcheckDisposed(OTableDescriptor_BASE::rBHelper.bDisposed);\n\tif(m_pTables && m_pTables->hasByName(newName))\n\t\tthrow ElementExistException(newName,*this);\n\n\n\trenameImpl(newName);\n\n\tODbaseTable_BASE::rename(newName);\n\n\tconstruct();\n\tif(m_pColumns)\n\t\tm_pColumns->refresh();\n}\nnamespace\n{\n\tvoid renameFile(OConnection* _pConenction,const ::rtl::OUString& oldName,\n\t\t\t\t\tconst ::rtl::OUString& newName,const String& _sExtension)\n\t{\n\t\tString aName = ODbaseTable::getEntry(_pConenction,oldName);\n\t\tif(!aName.Len())\n\t\t{\n\t\t\t::rtl::OUString aIdent = _pConenction->getContent()->getIdentifier()->getContentIdentifier();\n\t\t\tif ( aIdent.lastIndexOf('/') != (aIdent.getLength()-1) )\n\t\t\t\taIdent += ::rtl::OUString::createFromAscii(\"/\");\n\t\t\taIdent += oldName;\n\t\t\taName = aIdent;\n\t\t}\n\t\tINetURLObject aURL;\n\t\taURL.SetURL(aName);\n\n\t\taURL.setExtension( _sExtension );\n\t\tString sNewName(newName);\n\t\tsNewName.AppendAscii(\".\");\n\t\tsNewName += _sExtension;\n\n\t\ttry\n\t\t{\n\t\t\tContent aContent(aURL.GetMainURL(INetURLObject::NO_DECODE),Reference<XCommandEnvironment>());\n\n\t\t\tSequence< PropertyValue > aProps( 1 );\n\t\t\taProps[0].Name\t\t= ::rtl::OUString::createFromAscii(\"Title\");\n\t\t\taProps[0].Handle\t= -1; // n/a\n\t\t\taProps[0].Value\t\t= makeAny( ::rtl::OUString(sNewName) );\n\t\t\tSequence< Any > aValues;\n\t\t\taContent.executeCommand( rtl::OUString::createFromAscii( \"setPropertyValues\" ),makeAny(aProps) ) >>= aValues;\n\t\t\tif(aValues.getLength() && aValues[0].hasValue())\n\t\t\t\tthrow Exception();\n\t\t}\n\t\tcatch(Exception&)\n\t\t{\n\t\t\tthrow ElementExistException(newName,NULL);\n\t\t}\n\t}\n}\n// -------------------------------------------------------------------------\nvoid SAL_CALL ODbaseTable::renameImpl( const ::rtl::OUString& newName ) throw(::com::sun::star::sdbc::SQLException, ::com::sun::star::container::ElementExistException, ::com::sun::star::uno::RuntimeException)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getEntry\" );\n\t::osl::MutexGuard aGuard(m_aMutex);\n\n\tFileClose();\n\n\n\trenameFile(m_pConnection,m_Name,newName,m_pConnection->getExtension());\n\tif ( HasMemoFields() )\n\t{  // delete the memo fields\n\t\tString sExt = String::CreateFromAscii(\"dbt\");\n\t\trenameFile(m_pConnection,m_Name,newName,sExt);\n\t}\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::addColumn(const Reference< XPropertySet >& _xNewColumn)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::addColumn\" );\n\tString sTempName = createTempFile();\n\n\tODbaseTable* pNewTable = new ODbaseTable(m_pTables,static_cast<ODbaseConnection*>(m_pConnection));\n\tReference< XPropertySet > xHold = pNewTable;\n\tpNewTable->setPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME),makeAny(::rtl::OUString(sTempName)));\n\t{\n\t\tReference<XAppend> xAppend(pNewTable->getColumns(),UNO_QUERY);\n\t\tsal_Bool bCase = getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers();\n\t\t// copy the structure\n\t\tfor(sal_Int32 i=0;i < m_pColumns->getCount();++i)\n\t\t{\n\t\t\tReference<XPropertySet> xProp;\n\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\tReference<XPropertySet> xCpy;\n\t\t\tif(xColumn.is())\n\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\telse\n\t\t\t{\n\t\t\t\txCpy = new OColumn(bCase);\n\t\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\t}\n\n\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t}\n\t\tReference<XPropertySet> xCpy = new OColumn(bCase);\n\t\t::comphelper::copyProperties(_xNewColumn,xCpy);\n\t\txAppend->appendByDescriptor(xCpy);\n\t}\n\n\t// construct the new table\n\tif(!pNewTable->CreateImpl())\n\t{\n        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_COLUMN_NOT_ADDABLE,\n                \"$columnname$\", ::comphelper::getString(_xNewColumn->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)))\n             ) );\n        ::dbtools::throwGenericSQLException( sError, *this );\n\t}\n\n\tsal_Bool bAlreadyDroped = sal_False;\n\ttry\n\t{\n\t\tpNewTable->construct();\n\t\t// copy the data\n\t\tcopyData(pNewTable,pNewTable->m_pColumns->getCount());\n\t\t// drop the old table\n\t\tif(DropImpl())\n\t\t{\n\t\t\tbAlreadyDroped = sal_True;\n\t\t\tpNewTable->renameImpl(m_Name);\n\t\t\t// release the temp file\n\t\t}\n\t\txHold = pNewTable = NULL;\n\n\t\tFileClose();\n\t\tconstruct();\n\t\tif(m_pColumns)\n\t\t\tm_pColumns->refresh();\n\t}\n\tcatch(const SQLException&)\n\t{\n\t\t// here we know that the old table wasn't droped before\n\t\tif(!bAlreadyDroped)\n\t\t\txHold = pNewTable = NULL;\n\n\t\tthrow;\n\t}\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::dropColumn(sal_Int32 _nPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::dropColumn\" );\n\tString sTempName = createTempFile();\n\n\tODbaseTable* pNewTable = new ODbaseTable(m_pTables,static_cast<ODbaseConnection*>(m_pConnection));\n\tReference< XPropertySet > xHold = pNewTable;\n\tpNewTable->setPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME),makeAny(::rtl::OUString(sTempName)));\n\t{\n\t\tReference<XAppend> xAppend(pNewTable->getColumns(),UNO_QUERY);\n\t\tsal_Bool bCase = getConnection()->getMetaData()->supportsMixedCaseQuotedIdentifiers();\n\t\t// copy the structure\n\t\tfor(sal_Int32 i=0;i < m_pColumns->getCount();++i)\n\t\t{\n\t\t\tif(_nPos != i)\n\t\t\t{\n\t\t\t\tReference<XPropertySet> xProp;\n\t\t\t\tm_pColumns->getByIndex(i) >>= xProp;\n\t\t\t\tReference<XDataDescriptorFactory> xColumn(xProp,UNO_QUERY);\n\t\t\t\tReference<XPropertySet> xCpy;\n\t\t\t\tif(xColumn.is())\n\t\t\t\t\txCpy = xColumn->createDataDescriptor();\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\txCpy = new OColumn(bCase);\n\t\t\t\t\t::comphelper::copyProperties(xProp,xCpy);\n\t\t\t\t}\n\t\t\t\txAppend->appendByDescriptor(xCpy);\n\t\t\t}\n\t\t}\n\t}\n\n\t// construct the new table\n\tif(!pNewTable->CreateImpl())\n\t{\n\t\txHold = pNewTable = NULL;\n        const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_COLUMN_NOT_DROP,\n                \"$position$\", ::rtl::OUString::valueOf(_nPos)\n             ) );\n        ::dbtools::throwGenericSQLException( sError, *this );\n\t}\n\tpNewTable->construct();\n\t// copy the data\n\tcopyData(pNewTable,_nPos);\n\t// drop the old table\n\tif(DropImpl())\n\t\tpNewTable->renameImpl(m_Name);\n\t\t// release the temp file\n\n\txHold = pNewTable = NULL;\n\n\tFileClose();\n\tconstruct();\n}\n// -----------------------------------------------------------------------------\nString ODbaseTable::createTempFile()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::createTempFile\" );\n\t::rtl::OUString aIdent = m_pConnection->getContent()->getIdentifier()->getContentIdentifier();\n\tif ( aIdent.lastIndexOf('/') != (aIdent.getLength()-1) )\n\t\taIdent += ::rtl::OUString::createFromAscii(\"/\");\n\tString sTempName(aIdent);\n\tString sExt;\n\tsExt.AssignAscii(\".\");\n\tsExt += m_pConnection->getExtension();\n\n\tString sName(m_Name);\n\tTempFile aTempFile(sName,&sExt,&sTempName);\n\tif(!aTempFile.IsValid())\n        getConnection()->throwGenericSQLException(STR_COULD_NOT_ALTER_TABLE,*this);\n\n\tINetURLObject aURL;\n\taURL.SetSmartProtocol(INET_PROT_FILE);\n\taURL.SetURL(aTempFile.GetURL());\n\n\tString sNewName(aURL.getName());\n\tsNewName.Erase(sNewName.Len() - sExt.Len());\n\treturn sNewName;\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::copyData(ODbaseTable* _pNewTable,sal_Int32 _nPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::copyData\" );\n\tsal_Int32 nPos = _nPos + 1; // +1 because we always have the bookmark clumn as well\n\tOValueRefRow aRow = new OValueRefVector(m_pColumns->getCount());\n\tOValueRefRow aInsertRow;\n\tif(_nPos)\n\t{\n\t\taInsertRow = new OValueRefVector(_pNewTable->m_pColumns->getCount());\n\t\t::std::for_each(aInsertRow->get().begin(),aInsertRow->get().end(),TSetRefBound(sal_True));\n\t}\n\telse\n\t\taInsertRow = aRow;\n\n\t// we only have to bind the values which we need to copy into the new table\n\t::std::for_each(aRow->get().begin(),aRow->get().end(),TSetRefBound(sal_True));\n\tif(_nPos && (_nPos < (sal_Int32)aRow->get().size()))\n\t\t(aRow->get())[nPos]->setBound(sal_False);\n\n\n\tsal_Bool bOk = sal_True;\n\tsal_Int32 nCurPos;\n\tOValueRefVector::Vector::iterator aIter;\n\tfor(sal_uInt32 nRowPos = 0; nRowPos < m_aHeader.db_anz;++nRowPos)\n\t{\n        bOk = seekRow( IResultSetHelper::BOOKMARK, nRowPos+1, nCurPos );\n        if ( bOk )\n\t\t{\n            bOk = fetchRow( aRow, m_aColumns.getBody(), sal_True, sal_True);\n            if ( bOk && !aRow->isDeleted() ) // copy only not deleted rows\n\t\t\t{\n\t\t\t\t// special handling when pos == 0 then we don't have to distinguish\tbetween the two rows\n\t\t\t\tif(_nPos)\n\t\t\t\t{\n\t\t\t\t\taIter = aRow->get().begin()+1;\n\t\t\t\t\tsal_Int32 nCount = 1;\n\t\t\t\t\tfor(OValueRefVector::Vector::iterator aInsertIter = aInsertRow->get().begin()+1; aIter != aRow->get().end() && aInsertIter != aInsertRow->get().end();++aIter,++nCount)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(nPos != nCount)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t(*aInsertIter)->setValue( (*aIter)->getValue() );\n\t\t\t\t\t\t\t++aInsertIter;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbOk = _pNewTable->InsertRow(*aInsertRow,sal_True,_pNewTable->m_pColumns);\n\t\t\t\tOSL_ENSURE(bOk,\"Row could not be inserted!\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tOSL_ENSURE(bOk,\"Row could not be fetched!\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOSL_ASSERT(0);\n\t\t}\n\t} // for(sal_uInt32 nRowPos = 0; nRowPos < m_aHeader.db_anz;++nRowPos)\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::throwInvalidDbaseFormat()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::throwInvalidDbaseFormat\" );\n\tFileClose();\n\t// no dbase file\n    \n    const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution(\n                STR_INVALID_DBASE_FILE,\n                \"$filename$\", getEntry(m_pConnection,m_Name)\n             ) );\n    ::dbtools::throwGenericSQLException( sError, *this );\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::refreshHeader()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::refreshHeader\" );\n    if ( m_aHeader.db_anz == 0 )\n\t    readHeader();\n}\n//------------------------------------------------------------------\nsal_Bool ODbaseTable::seekRow(IResultSetHelper::Movement eCursorPosition, sal_Int32 nOffset, sal_Int32& nCurPos)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::seekRow\" );\n\t// ----------------------------------------------------------\n\t// Positionierung vorbereiten:\n\tOSL_ENSURE(m_pFileStream,\"ODbaseTable::seekRow: FileStream is NULL!\");\n\n\tsal_uInt32  nNumberOfRecords = (sal_uInt32)m_aHeader.db_anz;\n\tsal_uInt32 nTempPos = m_nFilePos;\n\tm_nFilePos = nCurPos;\n\n\tswitch(eCursorPosition)\n\t{\n\t\tcase IResultSetHelper::NEXT:\n\t\t\t++m_nFilePos;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::PRIOR:\n\t\t\tif (m_nFilePos > 0)\n\t\t\t\t--m_nFilePos;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::FIRST:\n\t\t\tm_nFilePos = 1;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::LAST:\n\t\t\tm_nFilePos = nNumberOfRecords;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::RELATIVE:\n\t\t\tm_nFilePos = (((sal_Int32)m_nFilePos) + nOffset < 0) ? 0L\n\t\t\t\t\t\t\t: (sal_uInt32)(((sal_Int32)m_nFilePos) + nOffset);\n\t\t\tbreak;\n\t\tcase IResultSetHelper::ABSOLUTE:\n\t\tcase IResultSetHelper::BOOKMARK:\n\t\t\tm_nFilePos = (sal_uInt32)nOffset;\n\t\t\tbreak;\n\t}\n\n\tif (m_nFilePos > (sal_Int32)nNumberOfRecords)\n\t\tm_nFilePos = (sal_Int32)nNumberOfRecords + 1;\n\n\tif (m_nFilePos == 0 || m_nFilePos == (sal_Int32)nNumberOfRecords + 1)\n\t\tgoto Error;\n\telse\n\t{\n\t\tsal_uInt16 nEntryLen = m_aHeader.db_slng;\n\n\t\tOSL_ENSURE(m_nFilePos >= 1,\"SdbDBFCursor::FileFetchRow: ungueltige Record-Position\");\n\t\tsal_Int32 nPos = m_aHeader.db_kopf + (sal_Int32)(m_nFilePos-1) * nEntryLen;\n\n\t\tsal_uIntPtr nLen = m_pFileStream->Seek(nPos);\n\t\tif (m_pFileStream->GetError() != ERRCODE_NONE)\n\t\t\tgoto Error;\n\n\t\tnLen = m_pFileStream->Read((char*)m_pBuffer, nEntryLen);\n\t\tif (m_pFileStream->GetError() != ERRCODE_NONE)\n\t\t\tgoto Error;\n\t}\n\tgoto End;\n\nError:\n\tswitch(eCursorPosition)\n\t{\n\t\tcase IResultSetHelper::PRIOR:\n\t\tcase IResultSetHelper::FIRST:\n\t\t\tm_nFilePos = 0;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::LAST:\n\t\tcase IResultSetHelper::NEXT:\n\t\tcase IResultSetHelper::ABSOLUTE:\n\t\tcase IResultSetHelper::RELATIVE:\n\t\t\tif (nOffset > 0)\n\t\t\t\tm_nFilePos = nNumberOfRecords + 1;\n\t\t\telse if (nOffset < 0)\n\t\t\t\tm_nFilePos = 0;\n\t\t\tbreak;\n\t\tcase IResultSetHelper::BOOKMARK:\n\t\t\tm_nFilePos = nTempPos;\t // vorherige Position\n\t}\n\t//\taStatus.Set(SDB_STAT_NO_DATA_FOUND);\n\treturn sal_False;\n\nEnd:\n\tnCurPos = m_nFilePos;\n\treturn sal_True;\n}\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::ReadMemo(sal_uIntPtr nBlockNo, ORowSetValue& aVariable)\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::ReadMemo\" );\n\tsal_Bool bIsText = sal_True;\n\t//\tSdbConnection* pConnection = GetConnection();\n\n\tm_pMemoStream->Seek(nBlockNo * m_aMemoHeader.db_size);\n\tswitch (m_aMemoHeader.db_typ)\n\t{\n\t\tcase MemodBaseIII: // dBase III-Memofeld, endet mit Ctrl-Z\n\t\t{\n\t\t\tconst char cEOF = (char) DBF_EOL;\n\t\t\tByteString aBStr;\n\t\t\tstatic char aBuf[514];\n\t\t\taBuf[512] = 0;\t\t\t// sonst kann der Zufall uebel mitspielen\n\t\t\tsal_Bool bReady = sal_False;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm_pMemoStream->Read(&aBuf,512);\n\n\t\t\t\tsal_uInt16 i = 0;\n\t\t\t\twhile (aBuf[i] != cEOF && ++i < 512)\n\t\t\t\t\t;\n\t\t\t\tbReady = aBuf[i] == cEOF;\n\n\t\t\t\taBuf[i] = 0;\n\t\t\t\taBStr += aBuf;\n\n\t\t\t} while (!bReady && !m_pMemoStream->IsEof() && aBStr.Len() < STRING_MAXLEN);\n\n\t\t\t::rtl::OUString aStr(aBStr.GetBuffer(), aBStr.Len(),m_eEncoding);\n\t\t\taVariable = aStr;\n\n\t\t} break;\n\t\tcase MemoFoxPro:\n\t\tcase MemodBaseIV: // dBase IV-Memofeld mit Laengenangabe\n\t\t{\n\t\t\tchar sHeader[4];\n\t\t\tm_pMemoStream->Read(sHeader,4);\n\t\t\t// Foxpro stores text and binary data\n\t\t\tif (m_aMemoHeader.db_typ == MemoFoxPro)\n\t\t\t{\n//\t\t\t\tif (((sal_uInt8)sHeader[0]) != 0 || ((sal_uInt8)sHeader[1]) != 0 || ((sal_uInt8)sHeader[2]) != 0)\n//\t\t\t\t{\n////\t\t\t\t\tString aText = String(SdbResId(STR_STAT_IResultSetHelper::INVALID));\n////\t\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%d\"),m_pMemoStream->GetFileName());\n////\t\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%t\"),aStatus.TypeToString(MEMO));\n////\t\t\t\t\taStatus.Set(SDB_STAT_ERROR,\n////\t\t\t\t\t\t\tString::CreateFromAscii(\"01000\"),\n////\t\t\t\t\t\t\taStatus.CreateErrorMessage(aText),\n////\t\t\t\t\t\t\t0, String() );\n//\t\t\t\t\treturn sal_False;\n//\t\t\t\t}\n//\n\t\t\t\tbIsText = sHeader[3] != 0;\n\t\t\t}\n\t\t\telse if (((sal_uInt8)sHeader[0]) != 0xFF || ((sal_uInt8)sHeader[1]) != 0xFF || ((sal_uInt8)sHeader[2]) != 0x08)\n\t\t\t{\n//\t\t\t\tString aText = String(SdbResId(STR_STAT_IResultSetHelper::INVALID));\n//\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%d\"),m_pMemoStream->GetFileName());\n//\t\t\t\taText.SearchAndReplace(String::CreateFromAscii(\"%%t\"),aStatus.TypeToString(MEMO));\n//\t\t\t\taStatus.Set(SDB_STAT_ERROR,\n//\t\t\t\t\t\tString::CreateFromAscii(\"01000\"),\n//\t\t\t\t\t\taStatus.CreateErrorMessage(aText),\n//\t\t\t\t\t\t0, String() );\n\t\t\t\treturn sal_False;\n\t\t\t}\n\n\t\t\tsal_uInt32 nLength(0);\n\t\t\t(*m_pMemoStream) >> nLength;\n\n\t\t\tif (m_aMemoHeader.db_typ == MemodBaseIV)\n\t\t\t\tnLength -= 8;\n\n            if ( nLength )\n            {\n                if ( bIsText )\n                {\n\t\t\t        //\tchar cChar;\n\t\t\t\t\t::rtl::OUStringBuffer aStr;\n\t\t\t        while ( nLength > STRING_MAXLEN )\n\t\t\t        {\n\t\t\t\t        ByteString aBStr;\n\t\t\t\t        aBStr.Expand(STRING_MAXLEN);\n\t\t\t\t        m_pMemoStream->Read(aBStr.AllocBuffer(STRING_MAXLEN),STRING_MAXLEN);\n\t\t\t\t\t\taStr.append(::rtl::OUString(aBStr.GetBuffer(),aBStr.Len(), m_eEncoding));\n\t\t\t\t        nLength -= STRING_MAXLEN;\n\t\t\t        }\n\t\t\t        if ( nLength > 0 )\n\t\t\t        {\n\t\t\t\t        ByteString aBStr;\n\t\t\t\t        aBStr.Expand(static_cast<xub_StrLen>(nLength));\n\t\t\t\t        m_pMemoStream->Read(aBStr.AllocBuffer(static_cast<xub_StrLen>(nLength)),nLength);\n\t\t\t\t        //\taBStr.ReleaseBufferAccess();\n\t\t\t\t\t\taStr.append(::rtl::OUString(aBStr.GetBuffer(),aBStr.Len(), m_eEncoding));\n\t\t\t        }\n\t\t\t        if ( aStr.getLength() )\n\t\t\t\t\t\taVariable = aStr.makeStringAndClear();\n                } // if ( bIsText )\n                else\n                {\n                    ::com::sun::star::uno::Sequence< sal_Int8 > aData(nLength);\n                    m_pMemoStream->Read(aData.getArray(),nLength);\n                    aVariable = aData;\n                }\n            } // if ( nLength )\n\t\t}\n\t}\n\treturn sal_True;\n}\n// -----------------------------------------------------------------------------\nvoid ODbaseTable::AllocBuffer()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::AllocBuffer\" );\n\tsal_uInt16 nSize = m_aHeader.db_slng;\n\tOSL_ENSURE(nSize > 0, \"Size too small\");\n\n\tif (m_nBufferSize != nSize)\n\t{\n\t\tdelete m_pBuffer;\n\t\tm_pBuffer = NULL;\n\t}\n\n\t// Falls noch kein Puffer vorhanden: allozieren:\n\tif (m_pBuffer == NULL && nSize > 0)\n\t{\n\t\tm_nBufferSize = nSize;\n\t\tm_pBuffer\t\t= new sal_uInt8[m_nBufferSize+1];\n\t}\n}\n// -----------------------------------------------------------------------------\nsal_Bool ODbaseTable::WriteBuffer()\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::WriteBuffer\" );\n\tOSL_ENSURE(m_nFilePos >= 1,\"SdbDBFCursor::FileFetchRow: ungueltige Record-Position\");\n\n\t// Auf gewuenschten Record positionieren:\n\tlong nPos = m_aHeader.db_kopf + (long)(m_nFilePos-1) * m_aHeader.db_slng;\n\tm_pFileStream->Seek(nPos);\n\treturn m_pFileStream->Write((char*) m_pBuffer, m_aHeader.db_slng) > 0;\n}\n// -----------------------------------------------------------------------------\nsal_Int32 ODbaseTable::getCurrentLastPos() const\n{\n    RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, \"dbase\", \"Ocke.Janssen@sun.com\", \"ODbaseTable::getCurrentLastPos\" );\n\treturn m_aHeader.db_anz;\n}\n"], "filenames": ["main/connectivity/source/drivers/dbase/DTable.cxx"], "buggy_code_start_loc": [898], "buggy_code_end_loc": [1960], "fixing_code_start_loc": [899], "fixing_code_end_loc": [2006], "type": "CWE-120", "message": "Apache OpenOffice opens dBase/DBF documents and shows the contents as spreadsheets. DBF are database files with data organized in fields. When reading DBF data the size of certain fields is not checked: the data is just copied into local variables. A carefully crafted document could overflow the allocated space, leading to the execution of arbitrary code by altering the contents of the program stack. This issue affects Apache OpenOffice up to and including version 4.1.10", "other": {"cve": {"id": "CVE-2021-33035", "sourceIdentifier": "security@apache.org", "published": "2021-09-23T08:15:06.747", "lastModified": "2021-12-01T14:15:42.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Apache OpenOffice opens dBase/DBF documents and shows the contents as spreadsheets. DBF are database files with data organized in fields. When reading DBF data the size of certain fields is not checked: the data is just copied into local variables. A carefully crafted document could overflow the allocated space, leading to the execution of arbitrary code by altering the contents of the program stack. This issue affects Apache OpenOffice up to and including version 4.1.10"}, {"lang": "es", "value": "Apache OpenOffice abre documentos dBase/DBF y muestra el contenido como hojas de c\u00e1lculo. Los DBF son archivos de bases de datos con datos organizados en campos. Cuando se leen datos DBF no se comprueba el tama\u00f1o de ciertos campos: los datos se copian simplemente en variables locales. Un documento cuidadosamente dise\u00f1ado podr\u00eda desbordar el espacio asignado, conllevando a una ejecuci\u00f3n de c\u00f3digo arbitrario al alterar el contenido de la pila del programa. Este problema afecta a Apache OpenOffice hasta la versi\u00f3n 4.1.10, incluy\u00e9ndola"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security@apache.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:openoffice:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.1.10", "matchCriteriaId": "D7F87A5A-F263-46B3-9267-8657ACC1FC9F"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2021/10/07/3", "source": "security@apache.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/apache/openoffice/commit/efddaef0151af3be16078cc4d88c6bae0f911e56#diff-ea66e734dd358922aba12ad4ba39c96bdc6cbde587d07dbc63d04daa0a30e90f", "source": "security@apache.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1ab8532e11f41bc7ca057ac7e39cab25f2e1f9d5f4929788ae21c8b9@%3Cusers.openoffice.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/r929c0c6a53cad64a1007b878342756badbb05ddd9b8f31a6d0b424cb@%3Cannounce.apache.org%3E", "source": "security@apache.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/apache/openoffice/commit/efddaef0151af3be16078cc4d88c6bae0f911e56#diff-ea66e734dd358922aba12ad4ba39c96bdc6cbde587d07dbc63d04daa0a30e90f"}}