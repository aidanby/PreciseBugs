{"buggy_code": ["/**\n * @file\n * Manage IMAP messages\n *\n * @authors\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_message Manage IMAP messages\n *\n * Manage IMAP messages\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"message.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"tags.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct BodyCache;\n\n/**\n * new_header_data - Create a new ImapHeaderData\n * @retval ptr New ImapHeaderData\n */\nstatic struct ImapHeaderData *new_header_data(void)\n{\n  struct ImapHeaderData *d = mutt_mem_calloc(1, sizeof(struct ImapHeaderData));\n  return d;\n}\n\n/**\n * update_context - Cache the headers of all the emails\n * @param idata       Server data\n * @param oldmsgcount Number of emails\n */\nstatic void update_context(struct ImapData *idata, int oldmsgcount)\n{\n  struct Header *h = NULL;\n\n  struct Context *ctx = idata->ctx;\n  if (!idata->uid_hash)\n    idata->uid_hash = mutt_hash_int_create(MAX(6 * ctx->msgcount / 5, 30), 0);\n\n  for (int msgno = oldmsgcount; msgno < ctx->msgcount; msgno++)\n  {\n    h = ctx->hdrs[msgno];\n    mutt_hash_int_insert(idata->uid_hash, HEADER_DATA(h)->uid, h);\n  }\n}\n\n/**\n * msg_cache_open - Open a message cache\n * @param idata Server data\n * @retval ptr  Success, using existing cache\n * @retval ptr  Success, opened new cache\n * @retval NULL Failure\n */\nstatic struct BodyCache *msg_cache_open(struct ImapData *idata)\n{\n  char mailbox[PATH_MAX];\n\n  if (idata->bcache)\n    return idata->bcache;\n\n  imap_cachepath(idata, idata->mailbox, mailbox, sizeof(mailbox));\n\n  return mutt_bcache_open(&idata->conn->account, mailbox);\n}\n\n/**\n * msg_cache_get - Get the message cache entry for an email\n * @param idata Server data\n * @param h     Email header\n * @retval ptr  Success, handle of cache entry\n * @retval NULL Failure\n */\nstatic FILE *msg_cache_get(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return NULL;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_get(idata->bcache, id);\n}\n\n/**\n * msg_cache_put - Put an email into the message cache\n * @param idata Server data\n * @param h     Email header\n * @retval ptr  Success, handle of cache entry\n * @retval NULL Failure\n */\nstatic FILE *msg_cache_put(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return NULL;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_put(idata->bcache, id);\n}\n\n/**\n * msg_cache_commit - Add to the message cache\n * @param idata Server data\n * @param h     Email header\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int msg_cache_commit(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return -1;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n\n  return mutt_bcache_commit(idata->bcache, id);\n}\n\n/**\n * msg_cache_clean_cb - Delete an entry from the message cache\n * @param id     ID of entry to delete\n * @param bcache BodyCache\n * @param data   Server data\n * @retval 0 Always\n */\nstatic int msg_cache_clean_cb(const char *id, struct BodyCache *bcache, void *data)\n{\n  unsigned int uv, uid;\n  struct ImapData *idata = data;\n\n  if (sscanf(id, \"%u-%u\", &uv, &uid) != 2)\n    return 0;\n\n  /* bad UID */\n  if (uv != idata->uid_validity || !mutt_hash_int_find(idata->uid_hash, uid))\n    mutt_bcache_del(bcache, id);\n\n  return 0;\n}\n\n/**\n * msg_parse_flags - read a FLAGS token into an ImapHeader\n * @param h Header to store flags\n * @param s Command string containing flags\n * @retval ptr  The end of flags string\n * @retval NULL Failure\n */\nstatic char *msg_parse_flags(struct ImapHeader *h, char *s)\n{\n  struct ImapHeaderData *hd = h->data;\n\n  /* sanity-check string */\n  if (mutt_str_strncasecmp(\"FLAGS\", s, 5) != 0)\n  {\n    mutt_debug(1, \"not a FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s += 5;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"bogus FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s++;\n\n  FREE(&hd->flags_system);\n  FREE(&hd->flags_remote);\n\n  hd->deleted = hd->flagged = hd->replied = hd->read = hd->old = false;\n\n  /* start parsing */\n  while (*s && *s != ')')\n  {\n    if (mutt_str_strncasecmp(\"\\\\deleted\", s, 8) == 0)\n    {\n      s += 8;\n      hd->deleted = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\flagged\", s, 8) == 0)\n    {\n      s += 8;\n      hd->flagged = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\answered\", s, 9) == 0)\n    {\n      s += 9;\n      hd->replied = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\seen\", s, 5) == 0)\n    {\n      s += 5;\n      hd->read = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\recent\", s, 7) == 0)\n      s += 7;\n    else if (mutt_str_strncasecmp(\"old\", s, 3) == 0)\n    {\n      s += 3;\n      hd->old = MarkOld ? true : false;\n    }\n    else\n    {\n      char ctmp;\n      char *flag_word = s;\n      bool is_system_keyword = (mutt_str_strncasecmp(\"\\\\\", s, 1) == 0);\n\n      while (*s && !ISSPACE(*s) && *s != ')')\n        s++;\n\n      ctmp = *s;\n      *s = '\\0';\n\n      /* store other system flags as well (mainly \\\\Draft) */\n      if (is_system_keyword)\n        mutt_str_append_item(&hd->flags_system, flag_word, ' ');\n      /* store custom flags as well */\n      else\n        mutt_str_append_item(&hd->flags_remote, flag_word, ' ');\n\n      *s = ctmp;\n    }\n    SKIPWS(s);\n  }\n\n  /* wrap up, or note bad flags response */\n  if (*s == ')')\n    s++;\n  else\n  {\n    mutt_debug(1, \"Unterminated FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n\n  return s;\n}\n\n/**\n * msg_parse_fetch - handle headers returned from header fetch\n * @param h IMAP Header\n * @param s Command string\n * @retval  0 Success\n * @retval -1 String is corrupted\n * @retval -2 Fetch contains a body or header lines that still need to be parsed\n */\nstatic int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      /* got something i don't understand */\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * msg_fetch_header - import IMAP FETCH response into an ImapHeader\n * @param ctx Context\n * @param h   ImapHeader\n * @param buf Server string containing FETCH response\n * @param fp  Connection to server\n * @retval  0 Success\n * @retval -1 String is not a fetch response\n * @retval -2 String is a corrupt fetch response\n *\n * Expects string beginning with * n FETCH.\n */\nstatic int msg_fetch_header(struct Context *ctx, struct ImapHeader *h, char *buf, FILE *fp)\n{\n  unsigned int bytes;\n  int rc = -1; /* default now is that string isn't FETCH response */\n  int parse_rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (buf[0] != '*')\n    return rc;\n\n  /* skip to message number */\n  buf = imap_next_word(buf);\n  if (mutt_str_atoui(buf, &h->data->msn) < 0)\n    return rc;\n\n  /* find FETCH tag */\n  buf = imap_next_word(buf);\n  if (mutt_str_strncasecmp(\"FETCH\", buf, 5) != 0)\n    return rc;\n\n  rc = -2; /* we've got a FETCH response, for better or worse */\n  buf = strchr(buf, '(');\n  if (!buf)\n    return rc;\n  buf++;\n\n  /* FIXME: current implementation - call msg_parse_fetch - if it returns -2,\n   *   read header lines and call it again. Silly. */\n  parse_rc = msg_parse_fetch(h, buf);\n  if (!parse_rc)\n    return 0;\n  if (parse_rc != -2 || !fp)\n    return rc;\n\n  if (imap_get_literal_count(buf, &bytes) == 0)\n  {\n    imap_read_literal(fp, idata, bytes, NULL);\n\n    /* we may have other fields of the FETCH _after_ the literal\n     * (eg Domino puts FLAGS here). Nothing wrong with that, either.\n     * This all has to go - we should accept literals and nonliterals\n     * interchangeably at any time. */\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n      return rc;\n\n    if (msg_parse_fetch(h, idata->buf) == -1)\n      return rc;\n  }\n\n  rc = 0; /* success */\n\n  /* subtract headers from message size - unfortunately only the subset of\n   * headers we've requested. */\n  h->content_length -= bytes;\n\n  return rc;\n}\n\n/**\n * flush_buffer - Write data to a connection\n * @param buf  Buffer containing data\n * @param len  Length of buffer\n * @param conn Network connection\n */\nstatic void flush_buffer(char *buf, size_t *len, struct Connection *conn)\n{\n  buf[*len] = '\\0';\n  mutt_socket_write_n(conn, buf, *len);\n  *len = 0;\n}\n\n/**\n * alloc_msn_index - Create lookup table of MSN to Header\n * @param idata     Server data\n * @param msn_count Number of MSNs in use\n *\n * Mapping from Message Sequence Number to Header\n */\nstatic void alloc_msn_index(struct ImapData *idata, size_t msn_count)\n{\n  size_t new_size;\n\n  if (msn_count <= idata->msn_index_size)\n    return;\n\n  /* This is a conservative check to protect against a malicious imap\n   * server.  Most likely size_t is bigger than an unsigned int, but\n   * if msn_count is this big, we have a serious problem. */\n  if (msn_count >= (UINT_MAX / sizeof(struct Header *)))\n  {\n    mutt_error(_(\"Integer overflow -- can't allocate memory.\"));\n    mutt_exit(1);\n  }\n\n  /* Add a little padding, like mx_allloc_memory() */\n  new_size = msn_count + 25;\n\n  if (!idata->msn_index)\n    idata->msn_index = mutt_mem_calloc(new_size, sizeof(struct Header *));\n  else\n  {\n    mutt_mem_realloc(&idata->msn_index, sizeof(struct Header *) * new_size);\n    memset(idata->msn_index + idata->msn_index_size, 0,\n           sizeof(struct Header *) * (new_size - idata->msn_index_size));\n  }\n\n  idata->msn_index_size = new_size;\n}\n\n/**\n * generate_seqset - Generate a sequence set\n * @param b         Buffer for the result\n * @param idata     Server data\n * @param msn_begin First Message Sequence number\n * @param msn_end   Last Message Sequence number\n *\n * Generates a more complicated sequence set after using the header cache,\n * in case there are missing MSNs in the middle.\n *\n * There is a suggested limit of 1000 bytes for an IMAP client request.\n * Ideally, we would generate multiple requests if the number of ranges\n * is too big, but for now just abort to using the whole range.\n */\nstatic void generate_seqset(struct Buffer *b, struct ImapData *idata,\n                            unsigned int msn_begin, unsigned int msn_end)\n{\n  int chunks = 0;\n  int state = 0; /* 1: single msn, 2: range of msn */\n  unsigned int msn, range_begin, range_end;\n\n  for (msn = msn_begin; msn <= msn_end + 1; msn++)\n  {\n    if (msn <= msn_end && !idata->msn_index[msn - 1])\n    {\n      switch (state)\n      {\n        case 1: /* single: convert to a range */\n          state = 2;\n        /* fallthrough */\n        case 2: /* extend range ending */\n          range_end = msn;\n          break;\n        default:\n          state = 1;\n          range_begin = msn;\n          break;\n      }\n    }\n    else if (state)\n    {\n      if (chunks++)\n        mutt_buffer_addch(b, ',');\n      if (chunks == 150)\n        break;\n\n      if (state == 1)\n        mutt_buffer_printf(b, \"%u\", range_begin);\n      else if (state == 2)\n        mutt_buffer_printf(b, \"%u:%u\", range_begin, range_end);\n      state = 0;\n    }\n  }\n\n  /* Too big.  Just query the whole range then. */\n  if (chunks == 150 || mutt_str_strlen(b->data) > 500)\n  {\n    b->dptr = b->data;\n    mutt_buffer_printf(b, \"%u:%u\", msn_begin, msn_end);\n  }\n}\n\n/**\n * set_changed_flag - Have the flags of an email changed\n * @param[in]  ctx            Context\n * @param[in]  h              Email Header\n * @param[in]  local_changes  Has the local mailbox been changed?\n * @param[out] server_changes Set to 1 if the flag has changed\n * @param[in]  flag_name      Flag to check, e.g. #MUTT_FLAG\n * @param[in]  old_hd_flag    Old header flags\n * @param[in]  new_hd_flag    New header flags\n * @param[in]  h_flag         Email's value for flag_name\n *\n * Sets server_changes to 1 if a change to a flag is made, or in the\n * case of local_changes, if a change to a flag _would_ have been\n * made.\n */\nstatic void set_changed_flag(struct Context *ctx, struct Header *h,\n                             int local_changes, int *server_changes, int flag_name,\n                             int old_hd_flag, int new_hd_flag, int h_flag)\n{\n  /* If there are local_changes, we only want to note if the server\n   * flags have changed, so we can set a reopen flag in\n   * cmd_parse_fetch().  We don't want to count a local modification\n   * to the header flag as a \"change\".\n   */\n  if ((old_hd_flag == new_hd_flag) && local_changes)\n    return;\n\n  if (new_hd_flag == h_flag)\n    return;\n\n  if (server_changes)\n    *server_changes = 1;\n\n  /* Local changes have priority */\n  if (!local_changes)\n    mutt_set_flag(ctx, h, flag_name, new_hd_flag);\n}\n\n/**\n * imap_read_headers - Read headers from the server\n * @param idata     Server data\n * @param msn_begin First Message Sequence Number\n * @param msn_end   Last Message Sequence Number\n * @retval num Last MSN\n * @retval -1  Failure\n *\n * Changed to read many headers instead of just one. It will return the msn of\n * the last message read. It will return a value other than msn_end if mail\n * comes in while downloading headers (in theory).\n */\nint imap_read_headers(struct ImapData *idata, unsigned int msn_begin, unsigned int msn_end)\n{\n  char *hdrreq = NULL;\n  FILE *fp = NULL;\n  char tempfile[PATH_MAX];\n  int msgno, idx;\n  struct ImapHeader h;\n  struct ImapStatus *status = NULL;\n  int rc, mfhrc = 0, oldmsgcount;\n  int fetch_msn_end = 0;\n  unsigned int maxuid = 0;\n  static const char *const want_headers =\n      \"DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE \"\n      \"CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL \"\n      \"X-ORIGINAL-TO\";\n  struct Progress progress;\n  int retval = -1;\n  bool evalhc = false;\n\n#ifdef USE_HCACHE\n  char buf[LONG_STRING];\n  void *uid_validity = NULL;\n  void *puidnext = NULL;\n  unsigned int uidnext = 0;\n#endif /* USE_HCACHE */\n\n  struct Context *ctx = idata->ctx;\n\n  if (mutt_bit_isset(idata->capabilities, IMAP4REV1))\n  {\n    safe_asprintf(&hdrreq, \"BODY.PEEK[HEADER.FIELDS (%s%s%s)]\", want_headers,\n                  ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));\n  }\n  else if (mutt_bit_isset(idata->capabilities, IMAP4))\n  {\n    safe_asprintf(&hdrreq, \"RFC822.HEADER.LINES (%s%s%s)\", want_headers,\n                  ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));\n  }\n  else\n  { /* Unable to fetch headers for lower versions */\n    mutt_error(_(\"Unable to fetch headers from this IMAP server version.\"));\n    goto error_out_0;\n  }\n\n  /* instead of downloading all headers and then parsing them, we parse them\n   * as they come in. */\n  mutt_mktemp(tempfile, sizeof(tempfile));\n  fp = mutt_file_fopen(tempfile, \"w+\");\n  if (!fp)\n  {\n    mutt_error(_(\"Could not create temporary file %s\"), tempfile);\n    goto error_out_0;\n  }\n  unlink(tempfile);\n\n  /* make sure context has room to hold the mailbox */\n  while (msn_end > ctx->hdrmax)\n    mx_alloc_memory(ctx);\n  alloc_msn_index(idata, msn_end);\n\n  idx = ctx->msgcount;\n  oldmsgcount = ctx->msgcount;\n  idata->reopen &= ~(IMAP_REOPEN_ALLOW | IMAP_NEWMAIL_PENDING);\n  idata->new_mail_count = 0;\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open(idata, NULL);\n\n  if (idata->hcache && (msn_begin == 1))\n  {\n    uid_validity = mutt_hcache_fetch_raw(idata->hcache, \"/UIDVALIDITY\", 12);\n    puidnext = mutt_hcache_fetch_raw(idata->hcache, \"/UIDNEXT\", 8);\n    if (puidnext)\n    {\n      uidnext = *(unsigned int *) puidnext;\n      mutt_hcache_free(idata->hcache, &puidnext);\n    }\n    if (uid_validity && uidnext && *(unsigned int *) uid_validity == idata->uid_validity)\n      evalhc = true;\n    mutt_hcache_free(idata->hcache, &uid_validity);\n  }\n  if (evalhc)\n  {\n    /* L10N:\n       Comparing the cached data with the IMAP server's data */\n    mutt_progress_init(&progress, _(\"Evaluating cache...\"), MUTT_PROGRESS_MSG,\n                       ReadInc, msn_end);\n\n    snprintf(buf, sizeof(buf), \"UID FETCH 1:%u (UID FLAGS)\", uidnext - 1);\n\n    imap_cmd_start(idata, buf);\n\n    rc = IMAP_CMD_CONTINUE;\n    for (msgno = 1; rc == IMAP_CMD_CONTINUE; msgno++)\n    {\n      mutt_progress_update(&progress, msgno, -1);\n\n      memset(&h, 0, sizeof(h));\n      h.data = new_header_data();\n      do\n      {\n        rc = imap_cmd_step(idata);\n        if (rc != IMAP_CMD_CONTINUE)\n          break;\n\n        mfhrc = msg_fetch_header(ctx, &h, idata->buf, NULL);\n        if (mfhrc < 0)\n          continue;\n\n        if (!h.data->uid)\n        {\n          mutt_debug(2,\n                     \"skipping hcache FETCH response for message number %d \"\n                     \"missing a UID\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        if (h.data->msn < 1 || h.data->msn > msn_end)\n        {\n          mutt_debug(1, \"skipping hcache FETCH response for unknown message number %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        if (idata->msn_index[h.data->msn - 1])\n        {\n          mutt_debug(2, \"skipping hcache FETCH for duplicate message %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        ctx->hdrs[idx] = imap_hcache_get(idata, h.data->uid);\n        if (ctx->hdrs[idx])\n        {\n          idata->max_msn = MAX(idata->max_msn, h.data->msn);\n          idata->msn_index[h.data->msn - 1] = ctx->hdrs[idx];\n\n          ctx->hdrs[idx]->index = idx;\n          /* messages which have not been expunged are ACTIVE (borrowed from mh\n           * folders) */\n          ctx->hdrs[idx]->active = true;\n          ctx->hdrs[idx]->read = h.data->read;\n          ctx->hdrs[idx]->old = h.data->old;\n          ctx->hdrs[idx]->deleted = h.data->deleted;\n          ctx->hdrs[idx]->flagged = h.data->flagged;\n          ctx->hdrs[idx]->replied = h.data->replied;\n          ctx->hdrs[idx]->changed = h.data->changed;\n          /*  ctx->hdrs[msgno]->received is restored from mutt_hcache_restore */\n          ctx->hdrs[idx]->data = (void *) (h.data);\n          STAILQ_INIT(&ctx->hdrs[idx]->tags);\n          driver_tags_replace(&ctx->hdrs[idx]->tags, mutt_str_strdup(h.data->flags_remote));\n\n          ctx->msgcount++;\n          ctx->size += ctx->hdrs[idx]->content->length;\n\n          h.data = NULL;\n          idx++;\n        }\n      } while (mfhrc == -1);\n\n      imap_free_header_data(&h.data);\n\n      if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))\n      {\n        imap_hcache_close(idata);\n        goto error_out_1;\n      }\n    }\n\n    /* Look for the first empty MSN and start there */\n    while (msn_begin <= msn_end)\n    {\n      if (!idata->msn_index[msn_begin - 1])\n        break;\n      msn_begin++;\n    }\n  }\n#endif /* USE_HCACHE */\n\n  mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                     MUTT_PROGRESS_MSG, ReadInc, msn_end);\n\n  while (msn_begin <= msn_end && fetch_msn_end < msn_end)\n  {\n    struct Buffer *b = mutt_buffer_new();\n    if (evalhc)\n    {\n      /* In case there are holes in the header cache. */\n      evalhc = false;\n      generate_seqset(b, idata, msn_begin, msn_end);\n    }\n    else\n      mutt_buffer_printf(b, \"%u:%u\", msn_begin, msn_end);\n\n    fetch_msn_end = msn_end;\n    char *cmd = NULL;\n    safe_asprintf(&cmd, \"FETCH %s (UID FLAGS INTERNALDATE RFC822.SIZE %s)\", b->data, hdrreq);\n    imap_cmd_start(idata, cmd);\n    FREE(&cmd);\n    mutt_buffer_free(&b);\n\n    rc = IMAP_CMD_CONTINUE;\n    for (msgno = msn_begin; rc == IMAP_CMD_CONTINUE; msgno++)\n    {\n      mutt_progress_update(&progress, msgno, -1);\n\n      rewind(fp);\n      memset(&h, 0, sizeof(h));\n      h.data = new_header_data();\n\n      /* this DO loop does two things:\n       * 1. handles untagged messages, so we can try again on the same msg\n       * 2. fetches the tagged response at the end of the last message.\n       */\n      do\n      {\n        rc = imap_cmd_step(idata);\n        if (rc != IMAP_CMD_CONTINUE)\n          break;\n\n        mfhrc = msg_fetch_header(ctx, &h, idata->buf, fp);\n        if (mfhrc < 0)\n          continue;\n\n        if (!ftello(fp))\n        {\n          mutt_debug(\n              2, \"msg_fetch_header: ignoring fetch response with no body\\n\");\n          continue;\n        }\n\n        /* make sure we don't get remnants from older larger message headers */\n        fputs(\"\\n\\n\", fp);\n\n        if (h.data->msn < 1 || h.data->msn > fetch_msn_end)\n        {\n          mutt_debug(1, \"skipping FETCH response for unknown message number %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        /* May receive FLAGS updates in a separate untagged response (#2935) */\n        if (idata->msn_index[h.data->msn - 1])\n        {\n          mutt_debug(2, \"skipping FETCH response for duplicate message %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        ctx->hdrs[idx] = mutt_header_new();\n\n        idata->max_msn = MAX(idata->max_msn, h.data->msn);\n        idata->msn_index[h.data->msn - 1] = ctx->hdrs[idx];\n\n        ctx->hdrs[idx]->index = idx;\n        /* messages which have not been expunged are ACTIVE (borrowed from mh\n         * folders) */\n        ctx->hdrs[idx]->active = true;\n        ctx->hdrs[idx]->read = h.data->read;\n        ctx->hdrs[idx]->old = h.data->old;\n        ctx->hdrs[idx]->deleted = h.data->deleted;\n        ctx->hdrs[idx]->flagged = h.data->flagged;\n        ctx->hdrs[idx]->replied = h.data->replied;\n        ctx->hdrs[idx]->changed = h.data->changed;\n        ctx->hdrs[idx]->received = h.received;\n        ctx->hdrs[idx]->data = (void *) (h.data);\n        STAILQ_INIT(&ctx->hdrs[idx]->tags);\n        driver_tags_replace(&ctx->hdrs[idx]->tags, mutt_str_strdup(h.data->flags_remote));\n\n        if (maxuid < h.data->uid)\n          maxuid = h.data->uid;\n\n        rewind(fp);\n        /* NOTE: if Date: header is missing, mutt_rfc822_read_header depends\n         *   on h.received being set */\n        ctx->hdrs[idx]->env = mutt_rfc822_read_header(fp, ctx->hdrs[idx], 0, 0);\n        /* content built as a side-effect of mutt_rfc822_read_header */\n        ctx->hdrs[idx]->content->length = h.content_length;\n        ctx->size += h.content_length;\n\n#ifdef USE_HCACHE\n        imap_hcache_put(idata, ctx->hdrs[idx]);\n#endif /* USE_HCACHE */\n\n        ctx->msgcount++;\n\n        h.data = NULL;\n        idx++;\n      } while (mfhrc == -1);\n\n      imap_free_header_data(&h.data);\n\n      if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))\n      {\n#ifdef USE_HCACHE\n        imap_hcache_close(idata);\n#endif\n        goto error_out_1;\n      }\n    }\n\n    /* In case we get new mail while fetching the headers.\n     *\n     * Note: The RFC says we shouldn't get any EXPUNGE responses in the\n     * middle of a FETCH.  But just to be cautious, use the current state\n     * of max_msn, not fetch_msn_end to set the next start range.\n     */\n    if (idata->reopen & IMAP_NEWMAIL_PENDING)\n    {\n      /* update to the last value we actually pulled down */\n      fetch_msn_end = idata->max_msn;\n      msn_begin = idata->max_msn + 1;\n      msn_end = idata->new_mail_count;\n      while (msn_end > ctx->hdrmax)\n        mx_alloc_memory(ctx);\n      alloc_msn_index(idata, msn_end);\n      idata->reopen &= ~IMAP_NEWMAIL_PENDING;\n      idata->new_mail_count = 0;\n    }\n  }\n\n  if (maxuid && (status = imap_mboxcache_get(idata, idata->mailbox, 0)) &&\n      (status->uidnext < maxuid + 1))\n  {\n    status->uidnext = maxuid + 1;\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_store_raw(idata->hcache, \"/UIDVALIDITY\", 12, &idata->uid_validity,\n                        sizeof(idata->uid_validity));\n  if (maxuid && idata->uidnext < maxuid + 1)\n  {\n    mutt_debug(2, \"Overriding UIDNEXT: %u -> %u\\n\", idata->uidnext, maxuid + 1);\n    idata->uidnext = maxuid + 1;\n  }\n  if (idata->uidnext > 1)\n  {\n    mutt_hcache_store_raw(idata->hcache, \"/UIDNEXT\", 8, &idata->uidnext,\n                          sizeof(idata->uidnext));\n  }\n\n  imap_hcache_close(idata);\n#endif /* USE_HCACHE */\n\n  if (ctx->msgcount > oldmsgcount)\n  {\n    /* TODO: it's not clear to me why we are calling mx_alloc_memory\n     *       yet again. */\n    mx_alloc_memory(ctx);\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n    update_context(idata, oldmsgcount);\n  }\n\n  idata->reopen |= IMAP_REOPEN_ALLOW;\n\n  retval = msn_end;\n\nerror_out_1:\n  mutt_file_fclose(&fp);\n\nerror_out_0:\n  FREE(&hdrreq);\n\n  return retval;\n}\n\n/**\n * imap_msg_open - Implements MxOps::msg_open()\n */\nint imap_msg_open(struct Context *ctx, struct Message *msg, int msgno)\n{\n  struct Envelope *newenv = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  char *pc = NULL;\n  unsigned int bytes;\n  struct Progress progressbar;\n  unsigned int uid;\n  int cacheno;\n  struct ImapCache *cache = NULL;\n  bool retried = false;\n  bool read;\n  int rc;\n\n  /* Sam's weird courier server returns an OK response even when FETCH\n   * fails. Thanks Sam. */\n  bool fetched = false;\n  int output_progress;\n\n  struct ImapData *idata = ctx->data;\n  struct Header *h = ctx->hdrs[msgno];\n\n  msg->fp = msg_cache_get(idata, h);\n  if (msg->fp)\n  {\n    if (HEADER_DATA(h)->parsed)\n      return 0;\n    else\n      goto parsemsg;\n  }\n\n  /* we still do some caching even if imap_cachedir is unset */\n  /* see if we already have the message in our cache */\n  cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;\n  cache = &idata->cache[cacheno];\n\n  if (cache->path)\n  {\n    /* don't treat cache errors as fatal, just fall back. */\n    if (cache->uid == HEADER_DATA(h)->uid && (msg->fp = fopen(cache->path, \"r\")))\n      return 0;\n    else\n    {\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  /* This function is called in a few places after endwin()\n   * e.g. mutt_pipe_message(). */\n  output_progress = !isendwin();\n  if (output_progress)\n    mutt_message(_(\"Fetching message...\"));\n\n  msg->fp = msg_cache_put(idata, h);\n  if (!msg->fp)\n  {\n    cache->uid = HEADER_DATA(h)->uid;\n    mutt_mktemp(path, sizeof(path));\n    cache->path = mutt_str_strdup(path);\n    msg->fp = mutt_file_fopen(path, \"w+\");\n    if (!msg->fp)\n    {\n      FREE(&cache->path);\n      return -1;\n    }\n  }\n\n  /* mark this header as currently inactive so the command handler won't\n   * also try to update it. HACK until all this code can be moved into the\n   * command handler */\n  h->active = false;\n\n  snprintf(buf, sizeof(buf), \"UID FETCH %u %s\", HEADER_DATA(h)->uid,\n           (mutt_bit_isset(idata->capabilities, IMAP4REV1) ?\n                (ImapPeek ? \"BODY.PEEK[]\" : \"BODY[]\") :\n                \"RFC822\"));\n\n  imap_cmd_start(idata, buf);\n  do\n  {\n    rc = imap_cmd_step(idata);\n    if (rc != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf;\n    pc = imap_next_word(pc);\n    pc = imap_next_word(pc);\n\n    if (mutt_str_strncasecmp(\"FETCH\", pc, 5) == 0)\n    {\n      while (*pc)\n      {\n        pc = imap_next_word(pc);\n        if (pc[0] == '(')\n          pc++;\n        if (mutt_str_strncasecmp(\"UID\", pc, 3) == 0)\n        {\n          pc = imap_next_word(pc);\n          if (mutt_str_atoui(pc, &uid) < 0)\n            goto bail;\n          if (uid != HEADER_DATA(h)->uid)\n          {\n            mutt_error(_(\n                \"The message index is incorrect. Try reopening the mailbox.\"));\n          }\n        }\n        else if ((mutt_str_strncasecmp(\"RFC822\", pc, 6) == 0) ||\n                 (mutt_str_strncasecmp(\"BODY[]\", pc, 6) == 0))\n        {\n          pc = imap_next_word(pc);\n          if (imap_get_literal_count(pc, &bytes) < 0)\n          {\n            imap_error(\"imap_msg_open()\", buf);\n            goto bail;\n          }\n          if (output_progress)\n          {\n            mutt_progress_init(&progressbar, _(\"Fetching message...\"),\n                               MUTT_PROGRESS_SIZE, NetInc, bytes);\n          }\n          if (imap_read_literal(msg->fp, idata, bytes,\n                                output_progress ? &progressbar : NULL) < 0)\n          {\n            goto bail;\n          }\n          /* pick up trailing line */\n          rc = imap_cmd_step(idata);\n          if (rc != IMAP_CMD_CONTINUE)\n            goto bail;\n          pc = idata->buf;\n\n          fetched = true;\n        }\n        /* UW-IMAP will provide a FLAGS update here if the FETCH causes a\n         * change (eg from \\Unseen to \\Seen).\n         * Uncommitted changes in neomutt take precedence. If we decide to\n         * incrementally update flags later, this won't stop us syncing */\n        else if ((mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0) && !h->changed)\n        {\n          pc = imap_set_flags(idata, h, pc, NULL);\n          if (!pc)\n            goto bail;\n        }\n      }\n    }\n  } while (rc == IMAP_CMD_CONTINUE);\n\n  /* see comment before command start. */\n  h->active = true;\n\n  fflush(msg->fp);\n  if (ferror(msg->fp))\n  {\n    mutt_perror(cache->path);\n    goto bail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto bail;\n\n  if (!fetched || !imap_code(idata->buf))\n    goto bail;\n\n  msg_cache_commit(idata, h);\n\nparsemsg:\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  rewind(msg->fp);\n  /* It may be that the Status header indicates a message is read, but the\n   * IMAP server doesn't know the message has been \\Seen. So we capture\n   * the server's notion of 'read' and if it differs from the message info\n   * picked up in mutt_rfc822_read_header, we mark the message (and context\n   * changed). Another possibility: ignore Status on IMAP? */\n  read = h->read;\n  newenv = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  mutt_env_merge(h->env, &newenv);\n\n  /* see above. We want the new status in h->read, so we unset it manually\n   * and let mutt_set_flag set it correctly, updating context. */\n  if (read != h->read)\n  {\n    h->read = read;\n    mutt_set_flag(ctx, h, MUTT_NEW, read);\n  }\n\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    h->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftell(msg->fp) - h->content->offset;\n\n  mutt_clear_error();\n  rewind(msg->fp);\n  HEADER_DATA(h)->parsed = true;\n\n  /* retry message parse if cached message is empty */\n  if (!retried && ((h->lines == 0) || (h->content->length == 0)))\n  {\n    imap_cache_del(idata, h);\n    retried = true;\n    goto parsemsg;\n  }\n\n  return 0;\n\nbail:\n  mutt_file_fclose(&msg->fp);\n  imap_cache_del(idata, h);\n  if (cache->path)\n  {\n    unlink(cache->path);\n    FREE(&cache->path);\n  }\n\n  return -1;\n}\n\n/**\n * imap_msg_close - Close an email\n *\n * @note May also return EOF Failure, see errno\n */\nint imap_msg_close(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * imap_msg_commit - Implements MxOps::msg_commit()\n *\n * @note May also return EOF Failure, see errno\n */\nint imap_msg_commit(struct Context *ctx, struct Message *msg)\n{\n  int r = mutt_file_fclose(&msg->fp);\n  if (r != 0)\n    return r;\n\n  return imap_append_message(ctx, msg);\n}\n\n/**\n * imap_append_message - Write an email back to the server\n * @param ctx Context\n * @param msg Message to save\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_append_message(struct Context *ctx, struct Message *msg)\n{\n  FILE *fp = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char mailbox[LONG_STRING];\n  char internaldate[IMAP_DATELEN];\n  char imap_flags[SHORT_STRING];\n  size_t len;\n  struct Progress progressbar;\n  size_t sent;\n  int c, last;\n  struct ImapMbox mx;\n  int rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(ctx->path, &mx))\n    return -1;\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n\n  fp = fopen(msg->path, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg->path);\n    goto fail;\n  }\n\n  /* currently we set the \\Seen flag on all messages, but probably we\n   * should scan the message Status header for flag info. Since we're\n   * already rereading the whole file for length it isn't any more\n   * expensive (it'd be nice if we had the file size passed in already\n   * by the code that writes the file, but that's a lot of changes.\n   * Ideally we'd have a Header structure with flag info here... */\n  for (last = EOF, len = 0; (c = fgetc(fp)) != EOF; last = c)\n  {\n    if (c == '\\n' && last != '\\r')\n      len++;\n\n    len++;\n  }\n  rewind(fp);\n\n  mutt_progress_init(&progressbar, _(\"Uploading message...\"),\n                     MUTT_PROGRESS_SIZE, NetInc, len);\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n  mutt_date_make_imap(internaldate, sizeof(internaldate), msg->received);\n\n  imap_flags[0] = imap_flags[1] = 0;\n  if (msg->flags.read)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Seen\");\n  if (msg->flags.replied)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Answered\");\n  if (msg->flags.flagged)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Flagged\");\n  if (msg->flags.draft)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Draft\");\n\n  snprintf(buf, sizeof(buf), \"APPEND %s (%s) \\\"%s\\\" {%lu}\", mbox,\n           imap_flags + 1, internaldate, (unsigned long) len);\n\n  imap_cmd_start(idata, buf);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"#1 command failed: %s\\n\", idata->buf);\n\n    char *pc = idata->buf + SEQLEN;\n    SKIPWS(pc);\n    pc = imap_next_word(pc);\n    mutt_error(\"%s\", pc);\n    mutt_file_fclose(&fp);\n    goto fail;\n  }\n\n  for (last = EOF, sent = len = 0; (c = fgetc(fp)) != EOF; last = c)\n  {\n    if (c == '\\n' && last != '\\r')\n      buf[len++] = '\\r';\n\n    buf[len++] = c;\n\n    if (len > sizeof(buf) - 3)\n    {\n      sent += len;\n      flush_buffer(buf, &len, idata->conn);\n      mutt_progress_update(&progressbar, sent, -1);\n    }\n  }\n\n  if (len)\n    flush_buffer(buf, &len, idata->conn);\n\n  mutt_socket_send(idata->conn, \"\\r\\n\");\n  mutt_file_fclose(&fp);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (!imap_code(idata->buf))\n  {\n    mutt_debug(1, \"#2 command failed: %s\\n\", idata->buf);\n    char *pc = idata->buf + SEQLEN;\n    SKIPWS(pc);\n    pc = imap_next_word(pc);\n    mutt_error(\"%s\", pc);\n    goto fail;\n  }\n\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}\n\n/**\n * imap_copy_messages - Server COPY messages to another folder\n * @param ctx    Context\n * @param h      Header of the email\n * @param dest   Destination folder\n * @param delete Delete the original?\n * @retval -1 Error\n * @retval  0 Success\n * @retval  1 Non-fatal error - try fetch/append\n */\nint imap_copy_messages(struct Context *ctx, struct Header *h, char *dest, int delete)\n{\n  struct Buffer cmd, sync_cmd;\n  char mbox[PATH_MAX];\n  char mmbox[PATH_MAX];\n  char prompt[PATH_MAX + 64];\n  int rc;\n  struct ImapMbox mx;\n  int err_continue = MUTT_NO;\n  int triedcreate = 0;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(dest, &mx))\n  {\n    mutt_debug(1, \"bad destination %s\\n\", dest);\n    return -1;\n  }\n\n  /* check that the save-to folder is in the same account */\n  if (mutt_account_match(&(idata->conn->account), &(mx.account)) == 0)\n  {\n    mutt_debug(3, \"%s not same server as %s\\n\", dest, ctx->path);\n    return 1;\n  }\n\n  if (h && h->attach_del)\n  {\n    mutt_debug(3, \"#1 Message contains attachments to be deleted\\n\");\n    return 1;\n  }\n\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n  if (!*mbox)\n    mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));\n  imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    mutt_buffer_init(&sync_cmd);\n    mutt_buffer_init(&cmd);\n\n    /* Null Header* means copy tagged messages */\n    if (!h)\n    {\n      /* if any messages have attachments to delete, fall through to FETCH\n       * and APPEND. TODO: Copy what we can with COPY, fall through for the\n       * remainder. */\n      for (int i = 0; i < ctx->msgcount; i++)\n      {\n        if (!message_is_tagged(ctx, i))\n          continue;\n\n        if (ctx->hdrs[i]->attach_del)\n        {\n          mutt_debug(3, \"#2 Message contains attachments to be deleted\\n\");\n          return 1;\n        }\n\n        if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed)\n        {\n          rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], &sync_cmd, &err_continue);\n          if (rc < 0)\n          {\n            mutt_debug(1, \"#1 could not sync\\n\");\n            goto out;\n          }\n        }\n      }\n\n      rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TAG, 0, 0);\n      if (!rc)\n      {\n        mutt_debug(1, \"No messages tagged\\n\");\n        rc = -1;\n        goto out;\n      }\n      else if (rc < 0)\n      {\n        mutt_debug(1, \"#1 could not queue copy\\n\");\n        goto out;\n      }\n      else\n      {\n        mutt_message(ngettext(\"Copying %d message to %s...\", \"Copying %d messages to %s...\", rc),\n                     rc, mbox);\n      }\n    }\n    else\n    {\n      mutt_message(_(\"Copying message %d to %s...\"), h->index + 1, mbox);\n      mutt_buffer_printf(&cmd, \"UID COPY %u %s\", HEADER_DATA(h)->uid, mmbox);\n\n      if (h->active && h->changed)\n      {\n        rc = imap_sync_message_for_copy(idata, h, &sync_cmd, &err_continue);\n        if (rc < 0)\n        {\n          mutt_debug(1, \"#2 could not sync\\n\");\n          goto out;\n        }\n      }\n      rc = imap_exec(idata, cmd.data, IMAP_CMD_QUEUE);\n      if (rc < 0)\n      {\n        mutt_debug(1, \"#2 could not queue copy\\n\");\n        goto out;\n      }\n    }\n\n    /* let's get it on */\n    rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);\n    if (rc == -2)\n    {\n      if (triedcreate)\n      {\n        mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)\n        break;\n      mutt_debug(3, \"server suggests TRYCREATE\\n\");\n      snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);\n      if (Confirmcreate && mutt_yesorno(prompt, 1) != MUTT_YES)\n      {\n        mutt_clear_error();\n        goto out;\n      }\n      if (imap_create_mailbox(idata, mbox) < 0)\n        break;\n      triedcreate = 1;\n    }\n  } while (rc == -2);\n\n  if (rc != 0)\n  {\n    imap_error(\"imap_copy_messages\", idata->buf);\n    goto out;\n  }\n\n  /* cleanup */\n  if (delete)\n  {\n    if (!h)\n    {\n      for (int i = 0; i < ctx->msgcount; i++)\n      {\n        if (!message_is_tagged(ctx, i))\n          continue;\n\n        mutt_set_flag(ctx, ctx->hdrs[i], MUTT_DELETE, 1);\n        mutt_set_flag(ctx, ctx->hdrs[i], MUTT_PURGE, 1);\n        if (DeleteUntag)\n          mutt_set_flag(ctx, ctx->hdrs[i], MUTT_TAG, 0);\n      }\n    }\n    else\n    {\n      mutt_set_flag(ctx, h, MUTT_DELETE, 1);\n      mutt_set_flag(ctx, h, MUTT_PURGE, 1);\n      if (DeleteUntag)\n        mutt_set_flag(ctx, h, MUTT_TAG, 0);\n    }\n  }\n\n  rc = 0;\n\nout:\n  if (cmd.data)\n    FREE(&cmd.data);\n  if (sync_cmd.data)\n    FREE(&sync_cmd.data);\n  FREE(&mx.mbox);\n\n  return (rc < 0) ? -1 : rc;\n}\n\n/**\n * imap_cache_del - Delete an email from the body cache\n * @param idata Server data\n * @param h     Email header\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_cache_del(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return -1;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_del(idata->bcache, id);\n}\n\n/**\n * imap_cache_clean - Delete all the entries in the message cache\n * @param idata Server data\n * @retval 0 Always\n */\nint imap_cache_clean(struct ImapData *idata)\n{\n  idata->bcache = msg_cache_open(idata);\n  mutt_bcache_list(idata->bcache, msg_cache_clean_cb, idata);\n\n  return 0;\n}\n\n/**\n * imap_free_header_data - free ImapHeader structure\n * @param data Header data to free\n */\nvoid imap_free_header_data(struct ImapHeaderData **data)\n{\n  if (!data || !*data)\n    return;\n\n  /* this should be safe even if the list wasn't used */\n  FREE(&((*data)->flags_system));\n  FREE(&((*data)->flags_remote));\n  FREE(data);\n}\n\n/**\n * imap_set_flags - fill the message header according to the server flags\n * @param[in]  idata          Server data\n * @param[in]  h              Email Header\n * @param[in]  s              Command string\n * @param[out] server_changes Flags have changed\n * @retval ptr  The end of flags string\n * @retval NULL Failure\n *\n * Expects a flags line of the form \"FLAGS (flag flag ...)\"\n *\n * imap_set_flags: fill out the message header according to the flags from\n * the server. Expects a flags line of the form \"FLAGS (flag flag ...)\"\n *\n * Sets server_changes to 1 if a change to a flag is made, or in the\n * case of h->changed, if a change to a flag _would_ have been\n * made.\n */\nchar *imap_set_flags(struct ImapData *idata, struct Header *h, char *s, int *server_changes)\n{\n  struct Context *ctx = idata->ctx;\n  struct ImapHeader newh = { 0 };\n  struct ImapHeaderData old_hd;\n  bool readonly;\n  int local_changes;\n\n  local_changes = h->changed;\n\n  struct ImapHeaderData *hd = h->data;\n  newh.data = hd;\n\n  memcpy(&old_hd, hd, sizeof(old_hd));\n\n  mutt_debug(2, \"parsing FLAGS\\n\");\n  s = msg_parse_flags(&newh, s);\n  if (!s)\n    return NULL;\n\n  /* Update tags system */\n  driver_tags_replace(&h->tags, mutt_str_strdup(hd->flags_remote));\n\n  /* YAUH (yet another ugly hack): temporarily set context to\n   * read-write even if it's read-only, so *server* updates of\n   * flags can be processed by mutt_set_flag. ctx->changed must\n   * be restored afterwards */\n  readonly = ctx->readonly;\n  ctx->readonly = false;\n\n  /* This is redundant with the following two checks. Removing:\n   * mutt_set_flag (ctx, h, MUTT_NEW, !(hd->read || hd->old));\n   */\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_OLD, old_hd.old,\n                   hd->old, h->old);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_READ,\n                   old_hd.read, hd->read, h->read);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_DELETE,\n                   old_hd.deleted, hd->deleted, h->deleted);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_FLAG,\n                   old_hd.flagged, hd->flagged, h->flagged);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_REPLIED,\n                   old_hd.replied, hd->replied, h->replied);\n\n  /* this message is now definitively *not* changed (mutt_set_flag\n   * marks things changed as a side-effect) */\n  if (!local_changes)\n    h->changed = false;\n  ctx->changed &= !readonly;\n  ctx->readonly = readonly;\n\n  return s;\n}\n"], "fixing_code": ["/**\n * @file\n * Manage IMAP messages\n *\n * @authors\n * Copyright (C) 1996-1999 Brandon Long <blong@fiction.net>\n * Copyright (C) 1999-2009 Brendan Cully <brendan@kublai.com>\n *\n * @copyright\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software\n * Foundation, either version 2 of the License, or (at your option) any later\n * version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * @page imap_message Manage IMAP messages\n *\n * Manage IMAP messages\n */\n\n#include \"config.h\"\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include \"imap_private.h\"\n#include \"mutt/mutt.h\"\n#include \"conn/conn.h\"\n#include \"mutt.h\"\n#include \"message.h\"\n#include \"bcache.h\"\n#include \"body.h\"\n#include \"context.h\"\n#include \"envelope.h\"\n#include \"globals.h\"\n#include \"header.h\"\n#include \"imap/imap.h\"\n#include \"mailbox.h\"\n#include \"mutt_account.h\"\n#include \"mutt_curses.h\"\n#include \"mutt_socket.h\"\n#include \"mx.h\"\n#include \"options.h\"\n#include \"progress.h\"\n#include \"protos.h\"\n#include \"tags.h\"\n#ifdef USE_HCACHE\n#include \"hcache/hcache.h\"\n#endif\n\nstruct BodyCache;\n\n/**\n * new_header_data - Create a new ImapHeaderData\n * @retval ptr New ImapHeaderData\n */\nstatic struct ImapHeaderData *new_header_data(void)\n{\n  struct ImapHeaderData *d = mutt_mem_calloc(1, sizeof(struct ImapHeaderData));\n  return d;\n}\n\n/**\n * update_context - Cache the headers of all the emails\n * @param idata       Server data\n * @param oldmsgcount Number of emails\n */\nstatic void update_context(struct ImapData *idata, int oldmsgcount)\n{\n  struct Header *h = NULL;\n\n  struct Context *ctx = idata->ctx;\n  if (!idata->uid_hash)\n    idata->uid_hash = mutt_hash_int_create(MAX(6 * ctx->msgcount / 5, 30), 0);\n\n  for (int msgno = oldmsgcount; msgno < ctx->msgcount; msgno++)\n  {\n    h = ctx->hdrs[msgno];\n    mutt_hash_int_insert(idata->uid_hash, HEADER_DATA(h)->uid, h);\n  }\n}\n\n/**\n * msg_cache_open - Open a message cache\n * @param idata Server data\n * @retval ptr  Success, using existing cache\n * @retval ptr  Success, opened new cache\n * @retval NULL Failure\n */\nstatic struct BodyCache *msg_cache_open(struct ImapData *idata)\n{\n  char mailbox[PATH_MAX];\n\n  if (idata->bcache)\n    return idata->bcache;\n\n  imap_cachepath(idata, idata->mailbox, mailbox, sizeof(mailbox));\n\n  return mutt_bcache_open(&idata->conn->account, mailbox);\n}\n\n/**\n * msg_cache_get - Get the message cache entry for an email\n * @param idata Server data\n * @param h     Email header\n * @retval ptr  Success, handle of cache entry\n * @retval NULL Failure\n */\nstatic FILE *msg_cache_get(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return NULL;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_get(idata->bcache, id);\n}\n\n/**\n * msg_cache_put - Put an email into the message cache\n * @param idata Server data\n * @param h     Email header\n * @retval ptr  Success, handle of cache entry\n * @retval NULL Failure\n */\nstatic FILE *msg_cache_put(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return NULL;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_put(idata->bcache, id);\n}\n\n/**\n * msg_cache_commit - Add to the message cache\n * @param idata Server data\n * @param h     Email header\n * @retval  0 Success\n * @retval -1 Failure\n */\nstatic int msg_cache_commit(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return -1;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n\n  return mutt_bcache_commit(idata->bcache, id);\n}\n\n/**\n * msg_cache_clean_cb - Delete an entry from the message cache\n * @param id     ID of entry to delete\n * @param bcache BodyCache\n * @param data   Server data\n * @retval 0 Always\n */\nstatic int msg_cache_clean_cb(const char *id, struct BodyCache *bcache, void *data)\n{\n  unsigned int uv, uid;\n  struct ImapData *idata = data;\n\n  if (sscanf(id, \"%u-%u\", &uv, &uid) != 2)\n    return 0;\n\n  /* bad UID */\n  if (uv != idata->uid_validity || !mutt_hash_int_find(idata->uid_hash, uid))\n    mutt_bcache_del(bcache, id);\n\n  return 0;\n}\n\n/**\n * msg_parse_flags - read a FLAGS token into an ImapHeader\n * @param h Header to store flags\n * @param s Command string containing flags\n * @retval ptr  The end of flags string\n * @retval NULL Failure\n */\nstatic char *msg_parse_flags(struct ImapHeader *h, char *s)\n{\n  struct ImapHeaderData *hd = h->data;\n\n  /* sanity-check string */\n  if (mutt_str_strncasecmp(\"FLAGS\", s, 5) != 0)\n  {\n    mutt_debug(1, \"not a FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s += 5;\n  SKIPWS(s);\n  if (*s != '(')\n  {\n    mutt_debug(1, \"bogus FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n  s++;\n\n  FREE(&hd->flags_system);\n  FREE(&hd->flags_remote);\n\n  hd->deleted = hd->flagged = hd->replied = hd->read = hd->old = false;\n\n  /* start parsing */\n  while (*s && *s != ')')\n  {\n    if (mutt_str_strncasecmp(\"\\\\deleted\", s, 8) == 0)\n    {\n      s += 8;\n      hd->deleted = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\flagged\", s, 8) == 0)\n    {\n      s += 8;\n      hd->flagged = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\answered\", s, 9) == 0)\n    {\n      s += 9;\n      hd->replied = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\seen\", s, 5) == 0)\n    {\n      s += 5;\n      hd->read = true;\n    }\n    else if (mutt_str_strncasecmp(\"\\\\recent\", s, 7) == 0)\n      s += 7;\n    else if (mutt_str_strncasecmp(\"old\", s, 3) == 0)\n    {\n      s += 3;\n      hd->old = MarkOld ? true : false;\n    }\n    else\n    {\n      char ctmp;\n      char *flag_word = s;\n      bool is_system_keyword = (mutt_str_strncasecmp(\"\\\\\", s, 1) == 0);\n\n      while (*s && !ISSPACE(*s) && *s != ')')\n        s++;\n\n      ctmp = *s;\n      *s = '\\0';\n\n      /* store other system flags as well (mainly \\\\Draft) */\n      if (is_system_keyword)\n        mutt_str_append_item(&hd->flags_system, flag_word, ' ');\n      /* store custom flags as well */\n      else\n        mutt_str_append_item(&hd->flags_remote, flag_word, ' ');\n\n      *s = ctmp;\n    }\n    SKIPWS(s);\n  }\n\n  /* wrap up, or note bad flags response */\n  if (*s == ')')\n    s++;\n  else\n  {\n    mutt_debug(1, \"Unterminated FLAGS response: %s\\n\", s);\n    return NULL;\n  }\n\n  return s;\n}\n\n/**\n * msg_parse_fetch - handle headers returned from header fetch\n * @param h IMAP Header\n * @param s Command string\n * @retval  0 Success\n * @retval -1 String is corrupted\n * @retval -2 Fetch contains a body or header lines that still need to be parsed\n */\nstatic int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS(s);\n\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && (*s != '\\\"') && (ptmp != (tmp + sizeof(tmp) - 1)))\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }\n    else if (*s == ')')\n      s++; /* end of request */\n    else if (*s)\n    {\n      /* got something i don't understand */\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * msg_fetch_header - import IMAP FETCH response into an ImapHeader\n * @param ctx Context\n * @param h   ImapHeader\n * @param buf Server string containing FETCH response\n * @param fp  Connection to server\n * @retval  0 Success\n * @retval -1 String is not a fetch response\n * @retval -2 String is a corrupt fetch response\n *\n * Expects string beginning with * n FETCH.\n */\nstatic int msg_fetch_header(struct Context *ctx, struct ImapHeader *h, char *buf, FILE *fp)\n{\n  unsigned int bytes;\n  int rc = -1; /* default now is that string isn't FETCH response */\n  int parse_rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (buf[0] != '*')\n    return rc;\n\n  /* skip to message number */\n  buf = imap_next_word(buf);\n  if (mutt_str_atoui(buf, &h->data->msn) < 0)\n    return rc;\n\n  /* find FETCH tag */\n  buf = imap_next_word(buf);\n  if (mutt_str_strncasecmp(\"FETCH\", buf, 5) != 0)\n    return rc;\n\n  rc = -2; /* we've got a FETCH response, for better or worse */\n  buf = strchr(buf, '(');\n  if (!buf)\n    return rc;\n  buf++;\n\n  /* FIXME: current implementation - call msg_parse_fetch - if it returns -2,\n   *   read header lines and call it again. Silly. */\n  parse_rc = msg_parse_fetch(h, buf);\n  if (!parse_rc)\n    return 0;\n  if (parse_rc != -2 || !fp)\n    return rc;\n\n  if (imap_get_literal_count(buf, &bytes) == 0)\n  {\n    imap_read_literal(fp, idata, bytes, NULL);\n\n    /* we may have other fields of the FETCH _after_ the literal\n     * (eg Domino puts FLAGS here). Nothing wrong with that, either.\n     * This all has to go - we should accept literals and nonliterals\n     * interchangeably at any time. */\n    if (imap_cmd_step(idata) != IMAP_CMD_CONTINUE)\n      return rc;\n\n    if (msg_parse_fetch(h, idata->buf) == -1)\n      return rc;\n  }\n\n  rc = 0; /* success */\n\n  /* subtract headers from message size - unfortunately only the subset of\n   * headers we've requested. */\n  h->content_length -= bytes;\n\n  return rc;\n}\n\n/**\n * flush_buffer - Write data to a connection\n * @param buf  Buffer containing data\n * @param len  Length of buffer\n * @param conn Network connection\n */\nstatic void flush_buffer(char *buf, size_t *len, struct Connection *conn)\n{\n  buf[*len] = '\\0';\n  mutt_socket_write_n(conn, buf, *len);\n  *len = 0;\n}\n\n/**\n * alloc_msn_index - Create lookup table of MSN to Header\n * @param idata     Server data\n * @param msn_count Number of MSNs in use\n *\n * Mapping from Message Sequence Number to Header\n */\nstatic void alloc_msn_index(struct ImapData *idata, size_t msn_count)\n{\n  size_t new_size;\n\n  if (msn_count <= idata->msn_index_size)\n    return;\n\n  /* This is a conservative check to protect against a malicious imap\n   * server.  Most likely size_t is bigger than an unsigned int, but\n   * if msn_count is this big, we have a serious problem. */\n  if (msn_count >= (UINT_MAX / sizeof(struct Header *)))\n  {\n    mutt_error(_(\"Integer overflow -- can't allocate memory.\"));\n    mutt_exit(1);\n  }\n\n  /* Add a little padding, like mx_allloc_memory() */\n  new_size = msn_count + 25;\n\n  if (!idata->msn_index)\n    idata->msn_index = mutt_mem_calloc(new_size, sizeof(struct Header *));\n  else\n  {\n    mutt_mem_realloc(&idata->msn_index, sizeof(struct Header *) * new_size);\n    memset(idata->msn_index + idata->msn_index_size, 0,\n           sizeof(struct Header *) * (new_size - idata->msn_index_size));\n  }\n\n  idata->msn_index_size = new_size;\n}\n\n/**\n * generate_seqset - Generate a sequence set\n * @param b         Buffer for the result\n * @param idata     Server data\n * @param msn_begin First Message Sequence number\n * @param msn_end   Last Message Sequence number\n *\n * Generates a more complicated sequence set after using the header cache,\n * in case there are missing MSNs in the middle.\n *\n * There is a suggested limit of 1000 bytes for an IMAP client request.\n * Ideally, we would generate multiple requests if the number of ranges\n * is too big, but for now just abort to using the whole range.\n */\nstatic void generate_seqset(struct Buffer *b, struct ImapData *idata,\n                            unsigned int msn_begin, unsigned int msn_end)\n{\n  int chunks = 0;\n  int state = 0; /* 1: single msn, 2: range of msn */\n  unsigned int msn, range_begin, range_end;\n\n  for (msn = msn_begin; msn <= msn_end + 1; msn++)\n  {\n    if (msn <= msn_end && !idata->msn_index[msn - 1])\n    {\n      switch (state)\n      {\n        case 1: /* single: convert to a range */\n          state = 2;\n        /* fallthrough */\n        case 2: /* extend range ending */\n          range_end = msn;\n          break;\n        default:\n          state = 1;\n          range_begin = msn;\n          break;\n      }\n    }\n    else if (state)\n    {\n      if (chunks++)\n        mutt_buffer_addch(b, ',');\n      if (chunks == 150)\n        break;\n\n      if (state == 1)\n        mutt_buffer_printf(b, \"%u\", range_begin);\n      else if (state == 2)\n        mutt_buffer_printf(b, \"%u:%u\", range_begin, range_end);\n      state = 0;\n    }\n  }\n\n  /* Too big.  Just query the whole range then. */\n  if (chunks == 150 || mutt_str_strlen(b->data) > 500)\n  {\n    b->dptr = b->data;\n    mutt_buffer_printf(b, \"%u:%u\", msn_begin, msn_end);\n  }\n}\n\n/**\n * set_changed_flag - Have the flags of an email changed\n * @param[in]  ctx            Context\n * @param[in]  h              Email Header\n * @param[in]  local_changes  Has the local mailbox been changed?\n * @param[out] server_changes Set to 1 if the flag has changed\n * @param[in]  flag_name      Flag to check, e.g. #MUTT_FLAG\n * @param[in]  old_hd_flag    Old header flags\n * @param[in]  new_hd_flag    New header flags\n * @param[in]  h_flag         Email's value for flag_name\n *\n * Sets server_changes to 1 if a change to a flag is made, or in the\n * case of local_changes, if a change to a flag _would_ have been\n * made.\n */\nstatic void set_changed_flag(struct Context *ctx, struct Header *h,\n                             int local_changes, int *server_changes, int flag_name,\n                             int old_hd_flag, int new_hd_flag, int h_flag)\n{\n  /* If there are local_changes, we only want to note if the server\n   * flags have changed, so we can set a reopen flag in\n   * cmd_parse_fetch().  We don't want to count a local modification\n   * to the header flag as a \"change\".\n   */\n  if ((old_hd_flag == new_hd_flag) && local_changes)\n    return;\n\n  if (new_hd_flag == h_flag)\n    return;\n\n  if (server_changes)\n    *server_changes = 1;\n\n  /* Local changes have priority */\n  if (!local_changes)\n    mutt_set_flag(ctx, h, flag_name, new_hd_flag);\n}\n\n/**\n * imap_read_headers - Read headers from the server\n * @param idata     Server data\n * @param msn_begin First Message Sequence Number\n * @param msn_end   Last Message Sequence Number\n * @retval num Last MSN\n * @retval -1  Failure\n *\n * Changed to read many headers instead of just one. It will return the msn of\n * the last message read. It will return a value other than msn_end if mail\n * comes in while downloading headers (in theory).\n */\nint imap_read_headers(struct ImapData *idata, unsigned int msn_begin, unsigned int msn_end)\n{\n  char *hdrreq = NULL;\n  FILE *fp = NULL;\n  char tempfile[PATH_MAX];\n  int msgno, idx;\n  struct ImapHeader h;\n  struct ImapStatus *status = NULL;\n  int rc, mfhrc = 0, oldmsgcount;\n  int fetch_msn_end = 0;\n  unsigned int maxuid = 0;\n  static const char *const want_headers =\n      \"DATE FROM SUBJECT TO CC MESSAGE-ID REFERENCES CONTENT-TYPE \"\n      \"CONTENT-DESCRIPTION IN-REPLY-TO REPLY-TO LINES LIST-POST X-LABEL \"\n      \"X-ORIGINAL-TO\";\n  struct Progress progress;\n  int retval = -1;\n  bool evalhc = false;\n\n#ifdef USE_HCACHE\n  char buf[LONG_STRING];\n  void *uid_validity = NULL;\n  void *puidnext = NULL;\n  unsigned int uidnext = 0;\n#endif /* USE_HCACHE */\n\n  struct Context *ctx = idata->ctx;\n\n  if (mutt_bit_isset(idata->capabilities, IMAP4REV1))\n  {\n    safe_asprintf(&hdrreq, \"BODY.PEEK[HEADER.FIELDS (%s%s%s)]\", want_headers,\n                  ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));\n  }\n  else if (mutt_bit_isset(idata->capabilities, IMAP4))\n  {\n    safe_asprintf(&hdrreq, \"RFC822.HEADER.LINES (%s%s%s)\", want_headers,\n                  ImapHeaders ? \" \" : \"\", NONULL(ImapHeaders));\n  }\n  else\n  { /* Unable to fetch headers for lower versions */\n    mutt_error(_(\"Unable to fetch headers from this IMAP server version.\"));\n    goto error_out_0;\n  }\n\n  /* instead of downloading all headers and then parsing them, we parse them\n   * as they come in. */\n  mutt_mktemp(tempfile, sizeof(tempfile));\n  fp = mutt_file_fopen(tempfile, \"w+\");\n  if (!fp)\n  {\n    mutt_error(_(\"Could not create temporary file %s\"), tempfile);\n    goto error_out_0;\n  }\n  unlink(tempfile);\n\n  /* make sure context has room to hold the mailbox */\n  while (msn_end > ctx->hdrmax)\n    mx_alloc_memory(ctx);\n  alloc_msn_index(idata, msn_end);\n\n  idx = ctx->msgcount;\n  oldmsgcount = ctx->msgcount;\n  idata->reopen &= ~(IMAP_REOPEN_ALLOW | IMAP_NEWMAIL_PENDING);\n  idata->new_mail_count = 0;\n\n#ifdef USE_HCACHE\n  idata->hcache = imap_hcache_open(idata, NULL);\n\n  if (idata->hcache && (msn_begin == 1))\n  {\n    uid_validity = mutt_hcache_fetch_raw(idata->hcache, \"/UIDVALIDITY\", 12);\n    puidnext = mutt_hcache_fetch_raw(idata->hcache, \"/UIDNEXT\", 8);\n    if (puidnext)\n    {\n      uidnext = *(unsigned int *) puidnext;\n      mutt_hcache_free(idata->hcache, &puidnext);\n    }\n    if (uid_validity && uidnext && *(unsigned int *) uid_validity == idata->uid_validity)\n      evalhc = true;\n    mutt_hcache_free(idata->hcache, &uid_validity);\n  }\n  if (evalhc)\n  {\n    /* L10N:\n       Comparing the cached data with the IMAP server's data */\n    mutt_progress_init(&progress, _(\"Evaluating cache...\"), MUTT_PROGRESS_MSG,\n                       ReadInc, msn_end);\n\n    snprintf(buf, sizeof(buf), \"UID FETCH 1:%u (UID FLAGS)\", uidnext - 1);\n\n    imap_cmd_start(idata, buf);\n\n    rc = IMAP_CMD_CONTINUE;\n    for (msgno = 1; rc == IMAP_CMD_CONTINUE; msgno++)\n    {\n      mutt_progress_update(&progress, msgno, -1);\n\n      memset(&h, 0, sizeof(h));\n      h.data = new_header_data();\n      do\n      {\n        rc = imap_cmd_step(idata);\n        if (rc != IMAP_CMD_CONTINUE)\n          break;\n\n        mfhrc = msg_fetch_header(ctx, &h, idata->buf, NULL);\n        if (mfhrc < 0)\n          continue;\n\n        if (!h.data->uid)\n        {\n          mutt_debug(2,\n                     \"skipping hcache FETCH response for message number %d \"\n                     \"missing a UID\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        if (h.data->msn < 1 || h.data->msn > msn_end)\n        {\n          mutt_debug(1, \"skipping hcache FETCH response for unknown message number %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        if (idata->msn_index[h.data->msn - 1])\n        {\n          mutt_debug(2, \"skipping hcache FETCH for duplicate message %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        ctx->hdrs[idx] = imap_hcache_get(idata, h.data->uid);\n        if (ctx->hdrs[idx])\n        {\n          idata->max_msn = MAX(idata->max_msn, h.data->msn);\n          idata->msn_index[h.data->msn - 1] = ctx->hdrs[idx];\n\n          ctx->hdrs[idx]->index = idx;\n          /* messages which have not been expunged are ACTIVE (borrowed from mh\n           * folders) */\n          ctx->hdrs[idx]->active = true;\n          ctx->hdrs[idx]->read = h.data->read;\n          ctx->hdrs[idx]->old = h.data->old;\n          ctx->hdrs[idx]->deleted = h.data->deleted;\n          ctx->hdrs[idx]->flagged = h.data->flagged;\n          ctx->hdrs[idx]->replied = h.data->replied;\n          ctx->hdrs[idx]->changed = h.data->changed;\n          /*  ctx->hdrs[msgno]->received is restored from mutt_hcache_restore */\n          ctx->hdrs[idx]->data = (void *) (h.data);\n          STAILQ_INIT(&ctx->hdrs[idx]->tags);\n          driver_tags_replace(&ctx->hdrs[idx]->tags, mutt_str_strdup(h.data->flags_remote));\n\n          ctx->msgcount++;\n          ctx->size += ctx->hdrs[idx]->content->length;\n\n          h.data = NULL;\n          idx++;\n        }\n      } while (mfhrc == -1);\n\n      imap_free_header_data(&h.data);\n\n      if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))\n      {\n        imap_hcache_close(idata);\n        goto error_out_1;\n      }\n    }\n\n    /* Look for the first empty MSN and start there */\n    while (msn_begin <= msn_end)\n    {\n      if (!idata->msn_index[msn_begin - 1])\n        break;\n      msn_begin++;\n    }\n  }\n#endif /* USE_HCACHE */\n\n  mutt_progress_init(&progress, _(\"Fetching message headers...\"),\n                     MUTT_PROGRESS_MSG, ReadInc, msn_end);\n\n  while (msn_begin <= msn_end && fetch_msn_end < msn_end)\n  {\n    struct Buffer *b = mutt_buffer_new();\n    if (evalhc)\n    {\n      /* In case there are holes in the header cache. */\n      evalhc = false;\n      generate_seqset(b, idata, msn_begin, msn_end);\n    }\n    else\n      mutt_buffer_printf(b, \"%u:%u\", msn_begin, msn_end);\n\n    fetch_msn_end = msn_end;\n    char *cmd = NULL;\n    safe_asprintf(&cmd, \"FETCH %s (UID FLAGS INTERNALDATE RFC822.SIZE %s)\", b->data, hdrreq);\n    imap_cmd_start(idata, cmd);\n    FREE(&cmd);\n    mutt_buffer_free(&b);\n\n    rc = IMAP_CMD_CONTINUE;\n    for (msgno = msn_begin; rc == IMAP_CMD_CONTINUE; msgno++)\n    {\n      mutt_progress_update(&progress, msgno, -1);\n\n      rewind(fp);\n      memset(&h, 0, sizeof(h));\n      h.data = new_header_data();\n\n      /* this DO loop does two things:\n       * 1. handles untagged messages, so we can try again on the same msg\n       * 2. fetches the tagged response at the end of the last message.\n       */\n      do\n      {\n        rc = imap_cmd_step(idata);\n        if (rc != IMAP_CMD_CONTINUE)\n          break;\n\n        mfhrc = msg_fetch_header(ctx, &h, idata->buf, fp);\n        if (mfhrc < 0)\n          continue;\n\n        if (!ftello(fp))\n        {\n          mutt_debug(\n              2, \"msg_fetch_header: ignoring fetch response with no body\\n\");\n          continue;\n        }\n\n        /* make sure we don't get remnants from older larger message headers */\n        fputs(\"\\n\\n\", fp);\n\n        if (h.data->msn < 1 || h.data->msn > fetch_msn_end)\n        {\n          mutt_debug(1, \"skipping FETCH response for unknown message number %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        /* May receive FLAGS updates in a separate untagged response (#2935) */\n        if (idata->msn_index[h.data->msn - 1])\n        {\n          mutt_debug(2, \"skipping FETCH response for duplicate message %d\\n\",\n                     h.data->msn);\n          continue;\n        }\n\n        ctx->hdrs[idx] = mutt_header_new();\n\n        idata->max_msn = MAX(idata->max_msn, h.data->msn);\n        idata->msn_index[h.data->msn - 1] = ctx->hdrs[idx];\n\n        ctx->hdrs[idx]->index = idx;\n        /* messages which have not been expunged are ACTIVE (borrowed from mh\n         * folders) */\n        ctx->hdrs[idx]->active = true;\n        ctx->hdrs[idx]->read = h.data->read;\n        ctx->hdrs[idx]->old = h.data->old;\n        ctx->hdrs[idx]->deleted = h.data->deleted;\n        ctx->hdrs[idx]->flagged = h.data->flagged;\n        ctx->hdrs[idx]->replied = h.data->replied;\n        ctx->hdrs[idx]->changed = h.data->changed;\n        ctx->hdrs[idx]->received = h.received;\n        ctx->hdrs[idx]->data = (void *) (h.data);\n        STAILQ_INIT(&ctx->hdrs[idx]->tags);\n        driver_tags_replace(&ctx->hdrs[idx]->tags, mutt_str_strdup(h.data->flags_remote));\n\n        if (maxuid < h.data->uid)\n          maxuid = h.data->uid;\n\n        rewind(fp);\n        /* NOTE: if Date: header is missing, mutt_rfc822_read_header depends\n         *   on h.received being set */\n        ctx->hdrs[idx]->env = mutt_rfc822_read_header(fp, ctx->hdrs[idx], 0, 0);\n        /* content built as a side-effect of mutt_rfc822_read_header */\n        ctx->hdrs[idx]->content->length = h.content_length;\n        ctx->size += h.content_length;\n\n#ifdef USE_HCACHE\n        imap_hcache_put(idata, ctx->hdrs[idx]);\n#endif /* USE_HCACHE */\n\n        ctx->msgcount++;\n\n        h.data = NULL;\n        idx++;\n      } while (mfhrc == -1);\n\n      imap_free_header_data(&h.data);\n\n      if ((mfhrc < -1) || ((rc != IMAP_CMD_CONTINUE) && (rc != IMAP_CMD_OK)))\n      {\n#ifdef USE_HCACHE\n        imap_hcache_close(idata);\n#endif\n        goto error_out_1;\n      }\n    }\n\n    /* In case we get new mail while fetching the headers.\n     *\n     * Note: The RFC says we shouldn't get any EXPUNGE responses in the\n     * middle of a FETCH.  But just to be cautious, use the current state\n     * of max_msn, not fetch_msn_end to set the next start range.\n     */\n    if (idata->reopen & IMAP_NEWMAIL_PENDING)\n    {\n      /* update to the last value we actually pulled down */\n      fetch_msn_end = idata->max_msn;\n      msn_begin = idata->max_msn + 1;\n      msn_end = idata->new_mail_count;\n      while (msn_end > ctx->hdrmax)\n        mx_alloc_memory(ctx);\n      alloc_msn_index(idata, msn_end);\n      idata->reopen &= ~IMAP_NEWMAIL_PENDING;\n      idata->new_mail_count = 0;\n    }\n  }\n\n  if (maxuid && (status = imap_mboxcache_get(idata, idata->mailbox, 0)) &&\n      (status->uidnext < maxuid + 1))\n  {\n    status->uidnext = maxuid + 1;\n  }\n\n#ifdef USE_HCACHE\n  mutt_hcache_store_raw(idata->hcache, \"/UIDVALIDITY\", 12, &idata->uid_validity,\n                        sizeof(idata->uid_validity));\n  if (maxuid && idata->uidnext < maxuid + 1)\n  {\n    mutt_debug(2, \"Overriding UIDNEXT: %u -> %u\\n\", idata->uidnext, maxuid + 1);\n    idata->uidnext = maxuid + 1;\n  }\n  if (idata->uidnext > 1)\n  {\n    mutt_hcache_store_raw(idata->hcache, \"/UIDNEXT\", 8, &idata->uidnext,\n                          sizeof(idata->uidnext));\n  }\n\n  imap_hcache_close(idata);\n#endif /* USE_HCACHE */\n\n  if (ctx->msgcount > oldmsgcount)\n  {\n    /* TODO: it's not clear to me why we are calling mx_alloc_memory\n     *       yet again. */\n    mx_alloc_memory(ctx);\n    mx_update_context(ctx, ctx->msgcount - oldmsgcount);\n    update_context(idata, oldmsgcount);\n  }\n\n  idata->reopen |= IMAP_REOPEN_ALLOW;\n\n  retval = msn_end;\n\nerror_out_1:\n  mutt_file_fclose(&fp);\n\nerror_out_0:\n  FREE(&hdrreq);\n\n  return retval;\n}\n\n/**\n * imap_msg_open - Implements MxOps::msg_open()\n */\nint imap_msg_open(struct Context *ctx, struct Message *msg, int msgno)\n{\n  struct Envelope *newenv = NULL;\n  char buf[LONG_STRING];\n  char path[PATH_MAX];\n  char *pc = NULL;\n  unsigned int bytes;\n  struct Progress progressbar;\n  unsigned int uid;\n  int cacheno;\n  struct ImapCache *cache = NULL;\n  bool retried = false;\n  bool read;\n  int rc;\n\n  /* Sam's weird courier server returns an OK response even when FETCH\n   * fails. Thanks Sam. */\n  bool fetched = false;\n  int output_progress;\n\n  struct ImapData *idata = ctx->data;\n  struct Header *h = ctx->hdrs[msgno];\n\n  msg->fp = msg_cache_get(idata, h);\n  if (msg->fp)\n  {\n    if (HEADER_DATA(h)->parsed)\n      return 0;\n    else\n      goto parsemsg;\n  }\n\n  /* we still do some caching even if imap_cachedir is unset */\n  /* see if we already have the message in our cache */\n  cacheno = HEADER_DATA(h)->uid % IMAP_CACHE_LEN;\n  cache = &idata->cache[cacheno];\n\n  if (cache->path)\n  {\n    /* don't treat cache errors as fatal, just fall back. */\n    if (cache->uid == HEADER_DATA(h)->uid && (msg->fp = fopen(cache->path, \"r\")))\n      return 0;\n    else\n    {\n      unlink(cache->path);\n      FREE(&cache->path);\n    }\n  }\n\n  /* This function is called in a few places after endwin()\n   * e.g. mutt_pipe_message(). */\n  output_progress = !isendwin();\n  if (output_progress)\n    mutt_message(_(\"Fetching message...\"));\n\n  msg->fp = msg_cache_put(idata, h);\n  if (!msg->fp)\n  {\n    cache->uid = HEADER_DATA(h)->uid;\n    mutt_mktemp(path, sizeof(path));\n    cache->path = mutt_str_strdup(path);\n    msg->fp = mutt_file_fopen(path, \"w+\");\n    if (!msg->fp)\n    {\n      FREE(&cache->path);\n      return -1;\n    }\n  }\n\n  /* mark this header as currently inactive so the command handler won't\n   * also try to update it. HACK until all this code can be moved into the\n   * command handler */\n  h->active = false;\n\n  snprintf(buf, sizeof(buf), \"UID FETCH %u %s\", HEADER_DATA(h)->uid,\n           (mutt_bit_isset(idata->capabilities, IMAP4REV1) ?\n                (ImapPeek ? \"BODY.PEEK[]\" : \"BODY[]\") :\n                \"RFC822\"));\n\n  imap_cmd_start(idata, buf);\n  do\n  {\n    rc = imap_cmd_step(idata);\n    if (rc != IMAP_CMD_CONTINUE)\n      break;\n\n    pc = idata->buf;\n    pc = imap_next_word(pc);\n    pc = imap_next_word(pc);\n\n    if (mutt_str_strncasecmp(\"FETCH\", pc, 5) == 0)\n    {\n      while (*pc)\n      {\n        pc = imap_next_word(pc);\n        if (pc[0] == '(')\n          pc++;\n        if (mutt_str_strncasecmp(\"UID\", pc, 3) == 0)\n        {\n          pc = imap_next_word(pc);\n          if (mutt_str_atoui(pc, &uid) < 0)\n            goto bail;\n          if (uid != HEADER_DATA(h)->uid)\n          {\n            mutt_error(_(\n                \"The message index is incorrect. Try reopening the mailbox.\"));\n          }\n        }\n        else if ((mutt_str_strncasecmp(\"RFC822\", pc, 6) == 0) ||\n                 (mutt_str_strncasecmp(\"BODY[]\", pc, 6) == 0))\n        {\n          pc = imap_next_word(pc);\n          if (imap_get_literal_count(pc, &bytes) < 0)\n          {\n            imap_error(\"imap_msg_open()\", buf);\n            goto bail;\n          }\n          if (output_progress)\n          {\n            mutt_progress_init(&progressbar, _(\"Fetching message...\"),\n                               MUTT_PROGRESS_SIZE, NetInc, bytes);\n          }\n          if (imap_read_literal(msg->fp, idata, bytes,\n                                output_progress ? &progressbar : NULL) < 0)\n          {\n            goto bail;\n          }\n          /* pick up trailing line */\n          rc = imap_cmd_step(idata);\n          if (rc != IMAP_CMD_CONTINUE)\n            goto bail;\n          pc = idata->buf;\n\n          fetched = true;\n        }\n        /* UW-IMAP will provide a FLAGS update here if the FETCH causes a\n         * change (eg from \\Unseen to \\Seen).\n         * Uncommitted changes in neomutt take precedence. If we decide to\n         * incrementally update flags later, this won't stop us syncing */\n        else if ((mutt_str_strncasecmp(\"FLAGS\", pc, 5) == 0) && !h->changed)\n        {\n          pc = imap_set_flags(idata, h, pc, NULL);\n          if (!pc)\n            goto bail;\n        }\n      }\n    }\n  } while (rc == IMAP_CMD_CONTINUE);\n\n  /* see comment before command start. */\n  h->active = true;\n\n  fflush(msg->fp);\n  if (ferror(msg->fp))\n  {\n    mutt_perror(cache->path);\n    goto bail;\n  }\n\n  if (rc != IMAP_CMD_OK)\n    goto bail;\n\n  if (!fetched || !imap_code(idata->buf))\n    goto bail;\n\n  msg_cache_commit(idata, h);\n\nparsemsg:\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  rewind(msg->fp);\n  /* It may be that the Status header indicates a message is read, but the\n   * IMAP server doesn't know the message has been \\Seen. So we capture\n   * the server's notion of 'read' and if it differs from the message info\n   * picked up in mutt_rfc822_read_header, we mark the message (and context\n   * changed). Another possibility: ignore Status on IMAP? */\n  read = h->read;\n  newenv = mutt_rfc822_read_header(msg->fp, h, 0, 0);\n  mutt_env_merge(h->env, &newenv);\n\n  /* see above. We want the new status in h->read, so we unset it manually\n   * and let mutt_set_flag set it correctly, updating context. */\n  if (read != h->read)\n  {\n    h->read = read;\n    mutt_set_flag(ctx, h, MUTT_NEW, read);\n  }\n\n  h->lines = 0;\n  fgets(buf, sizeof(buf), msg->fp);\n  while (!feof(msg->fp))\n  {\n    h->lines++;\n    fgets(buf, sizeof(buf), msg->fp);\n  }\n\n  h->content->length = ftell(msg->fp) - h->content->offset;\n\n  mutt_clear_error();\n  rewind(msg->fp);\n  HEADER_DATA(h)->parsed = true;\n\n  /* retry message parse if cached message is empty */\n  if (!retried && ((h->lines == 0) || (h->content->length == 0)))\n  {\n    imap_cache_del(idata, h);\n    retried = true;\n    goto parsemsg;\n  }\n\n  return 0;\n\nbail:\n  mutt_file_fclose(&msg->fp);\n  imap_cache_del(idata, h);\n  if (cache->path)\n  {\n    unlink(cache->path);\n    FREE(&cache->path);\n  }\n\n  return -1;\n}\n\n/**\n * imap_msg_close - Close an email\n *\n * @note May also return EOF Failure, see errno\n */\nint imap_msg_close(struct Context *ctx, struct Message *msg)\n{\n  return mutt_file_fclose(&msg->fp);\n}\n\n/**\n * imap_msg_commit - Implements MxOps::msg_commit()\n *\n * @note May also return EOF Failure, see errno\n */\nint imap_msg_commit(struct Context *ctx, struct Message *msg)\n{\n  int r = mutt_file_fclose(&msg->fp);\n  if (r != 0)\n    return r;\n\n  return imap_append_message(ctx, msg);\n}\n\n/**\n * imap_append_message - Write an email back to the server\n * @param ctx Context\n * @param msg Message to save\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_append_message(struct Context *ctx, struct Message *msg)\n{\n  FILE *fp = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char mailbox[LONG_STRING];\n  char internaldate[IMAP_DATELEN];\n  char imap_flags[SHORT_STRING];\n  size_t len;\n  struct Progress progressbar;\n  size_t sent;\n  int c, last;\n  struct ImapMbox mx;\n  int rc;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(ctx->path, &mx))\n    return -1;\n\n  imap_fix_path(idata, mx.mbox, mailbox, sizeof(mailbox));\n  if (!*mailbox)\n    mutt_str_strfcpy(mailbox, \"INBOX\", sizeof(mailbox));\n\n  fp = fopen(msg->path, \"r\");\n  if (!fp)\n  {\n    mutt_perror(msg->path);\n    goto fail;\n  }\n\n  /* currently we set the \\Seen flag on all messages, but probably we\n   * should scan the message Status header for flag info. Since we're\n   * already rereading the whole file for length it isn't any more\n   * expensive (it'd be nice if we had the file size passed in already\n   * by the code that writes the file, but that's a lot of changes.\n   * Ideally we'd have a Header structure with flag info here... */\n  for (last = EOF, len = 0; (c = fgetc(fp)) != EOF; last = c)\n  {\n    if (c == '\\n' && last != '\\r')\n      len++;\n\n    len++;\n  }\n  rewind(fp);\n\n  mutt_progress_init(&progressbar, _(\"Uploading message...\"),\n                     MUTT_PROGRESS_SIZE, NetInc, len);\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mailbox);\n  mutt_date_make_imap(internaldate, sizeof(internaldate), msg->received);\n\n  imap_flags[0] = imap_flags[1] = 0;\n  if (msg->flags.read)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Seen\");\n  if (msg->flags.replied)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Answered\");\n  if (msg->flags.flagged)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Flagged\");\n  if (msg->flags.draft)\n    mutt_str_strcat(imap_flags, sizeof(imap_flags), \" \\\\Draft\");\n\n  snprintf(buf, sizeof(buf), \"APPEND %s (%s) \\\"%s\\\" {%lu}\", mbox,\n           imap_flags + 1, internaldate, (unsigned long) len);\n\n  imap_cmd_start(idata, buf);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"#1 command failed: %s\\n\", idata->buf);\n\n    char *pc = idata->buf + SEQLEN;\n    SKIPWS(pc);\n    pc = imap_next_word(pc);\n    mutt_error(\"%s\", pc);\n    mutt_file_fclose(&fp);\n    goto fail;\n  }\n\n  for (last = EOF, sent = len = 0; (c = fgetc(fp)) != EOF; last = c)\n  {\n    if (c == '\\n' && last != '\\r')\n      buf[len++] = '\\r';\n\n    buf[len++] = c;\n\n    if (len > sizeof(buf) - 3)\n    {\n      sent += len;\n      flush_buffer(buf, &len, idata->conn);\n      mutt_progress_update(&progressbar, sent, -1);\n    }\n  }\n\n  if (len)\n    flush_buffer(buf, &len, idata->conn);\n\n  mutt_socket_send(idata->conn, \"\\r\\n\");\n  mutt_file_fclose(&fp);\n\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (!imap_code(idata->buf))\n  {\n    mutt_debug(1, \"#2 command failed: %s\\n\", idata->buf);\n    char *pc = idata->buf + SEQLEN;\n    SKIPWS(pc);\n    pc = imap_next_word(pc);\n    mutt_error(\"%s\", pc);\n    goto fail;\n  }\n\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}\n\n/**\n * imap_copy_messages - Server COPY messages to another folder\n * @param ctx    Context\n * @param h      Header of the email\n * @param dest   Destination folder\n * @param delete Delete the original?\n * @retval -1 Error\n * @retval  0 Success\n * @retval  1 Non-fatal error - try fetch/append\n */\nint imap_copy_messages(struct Context *ctx, struct Header *h, char *dest, int delete)\n{\n  struct Buffer cmd, sync_cmd;\n  char mbox[PATH_MAX];\n  char mmbox[PATH_MAX];\n  char prompt[PATH_MAX + 64];\n  int rc;\n  struct ImapMbox mx;\n  int err_continue = MUTT_NO;\n  int triedcreate = 0;\n\n  struct ImapData *idata = ctx->data;\n\n  if (imap_parse_path(dest, &mx))\n  {\n    mutt_debug(1, \"bad destination %s\\n\", dest);\n    return -1;\n  }\n\n  /* check that the save-to folder is in the same account */\n  if (mutt_account_match(&(idata->conn->account), &(mx.account)) == 0)\n  {\n    mutt_debug(3, \"%s not same server as %s\\n\", dest, ctx->path);\n    return 1;\n  }\n\n  if (h && h->attach_del)\n  {\n    mutt_debug(3, \"#1 Message contains attachments to be deleted\\n\");\n    return 1;\n  }\n\n  imap_fix_path(idata, mx.mbox, mbox, sizeof(mbox));\n  if (!*mbox)\n    mutt_str_strfcpy(mbox, \"INBOX\", sizeof(mbox));\n  imap_munge_mbox_name(idata, mmbox, sizeof(mmbox), mbox);\n\n  /* loop in case of TRYCREATE */\n  do\n  {\n    mutt_buffer_init(&sync_cmd);\n    mutt_buffer_init(&cmd);\n\n    /* Null Header* means copy tagged messages */\n    if (!h)\n    {\n      /* if any messages have attachments to delete, fall through to FETCH\n       * and APPEND. TODO: Copy what we can with COPY, fall through for the\n       * remainder. */\n      for (int i = 0; i < ctx->msgcount; i++)\n      {\n        if (!message_is_tagged(ctx, i))\n          continue;\n\n        if (ctx->hdrs[i]->attach_del)\n        {\n          mutt_debug(3, \"#2 Message contains attachments to be deleted\\n\");\n          return 1;\n        }\n\n        if (ctx->hdrs[i]->active && ctx->hdrs[i]->changed)\n        {\n          rc = imap_sync_message_for_copy(idata, ctx->hdrs[i], &sync_cmd, &err_continue);\n          if (rc < 0)\n          {\n            mutt_debug(1, \"#1 could not sync\\n\");\n            goto out;\n          }\n        }\n      }\n\n      rc = imap_exec_msgset(idata, \"UID COPY\", mmbox, MUTT_TAG, 0, 0);\n      if (!rc)\n      {\n        mutt_debug(1, \"No messages tagged\\n\");\n        rc = -1;\n        goto out;\n      }\n      else if (rc < 0)\n      {\n        mutt_debug(1, \"#1 could not queue copy\\n\");\n        goto out;\n      }\n      else\n      {\n        mutt_message(ngettext(\"Copying %d message to %s...\", \"Copying %d messages to %s...\", rc),\n                     rc, mbox);\n      }\n    }\n    else\n    {\n      mutt_message(_(\"Copying message %d to %s...\"), h->index + 1, mbox);\n      mutt_buffer_printf(&cmd, \"UID COPY %u %s\", HEADER_DATA(h)->uid, mmbox);\n\n      if (h->active && h->changed)\n      {\n        rc = imap_sync_message_for_copy(idata, h, &sync_cmd, &err_continue);\n        if (rc < 0)\n        {\n          mutt_debug(1, \"#2 could not sync\\n\");\n          goto out;\n        }\n      }\n      rc = imap_exec(idata, cmd.data, IMAP_CMD_QUEUE);\n      if (rc < 0)\n      {\n        mutt_debug(1, \"#2 could not queue copy\\n\");\n        goto out;\n      }\n    }\n\n    /* let's get it on */\n    rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK);\n    if (rc == -2)\n    {\n      if (triedcreate)\n      {\n        mutt_debug(1, \"Already tried to create mailbox %s\\n\", mbox);\n        break;\n      }\n      /* bail out if command failed for reasons other than nonexistent target */\n      if (mutt_str_strncasecmp(imap_get_qualifier(idata->buf), \"[TRYCREATE]\", 11) != 0)\n        break;\n      mutt_debug(3, \"server suggests TRYCREATE\\n\");\n      snprintf(prompt, sizeof(prompt), _(\"Create %s?\"), mbox);\n      if (Confirmcreate && mutt_yesorno(prompt, 1) != MUTT_YES)\n      {\n        mutt_clear_error();\n        goto out;\n      }\n      if (imap_create_mailbox(idata, mbox) < 0)\n        break;\n      triedcreate = 1;\n    }\n  } while (rc == -2);\n\n  if (rc != 0)\n  {\n    imap_error(\"imap_copy_messages\", idata->buf);\n    goto out;\n  }\n\n  /* cleanup */\n  if (delete)\n  {\n    if (!h)\n    {\n      for (int i = 0; i < ctx->msgcount; i++)\n      {\n        if (!message_is_tagged(ctx, i))\n          continue;\n\n        mutt_set_flag(ctx, ctx->hdrs[i], MUTT_DELETE, 1);\n        mutt_set_flag(ctx, ctx->hdrs[i], MUTT_PURGE, 1);\n        if (DeleteUntag)\n          mutt_set_flag(ctx, ctx->hdrs[i], MUTT_TAG, 0);\n      }\n    }\n    else\n    {\n      mutt_set_flag(ctx, h, MUTT_DELETE, 1);\n      mutt_set_flag(ctx, h, MUTT_PURGE, 1);\n      if (DeleteUntag)\n        mutt_set_flag(ctx, h, MUTT_TAG, 0);\n    }\n  }\n\n  rc = 0;\n\nout:\n  if (cmd.data)\n    FREE(&cmd.data);\n  if (sync_cmd.data)\n    FREE(&sync_cmd.data);\n  FREE(&mx.mbox);\n\n  return (rc < 0) ? -1 : rc;\n}\n\n/**\n * imap_cache_del - Delete an email from the body cache\n * @param idata Server data\n * @param h     Email header\n * @retval  0 Success\n * @retval -1 Failure\n */\nint imap_cache_del(struct ImapData *idata, struct Header *h)\n{\n  if (!idata || !h)\n    return -1;\n\n  idata->bcache = msg_cache_open(idata);\n  char id[64];\n  snprintf(id, sizeof(id), \"%u-%u\", idata->uid_validity, HEADER_DATA(h)->uid);\n  return mutt_bcache_del(idata->bcache, id);\n}\n\n/**\n * imap_cache_clean - Delete all the entries in the message cache\n * @param idata Server data\n * @retval 0 Always\n */\nint imap_cache_clean(struct ImapData *idata)\n{\n  idata->bcache = msg_cache_open(idata);\n  mutt_bcache_list(idata->bcache, msg_cache_clean_cb, idata);\n\n  return 0;\n}\n\n/**\n * imap_free_header_data - free ImapHeader structure\n * @param data Header data to free\n */\nvoid imap_free_header_data(struct ImapHeaderData **data)\n{\n  if (!data || !*data)\n    return;\n\n  /* this should be safe even if the list wasn't used */\n  FREE(&((*data)->flags_system));\n  FREE(&((*data)->flags_remote));\n  FREE(data);\n}\n\n/**\n * imap_set_flags - fill the message header according to the server flags\n * @param[in]  idata          Server data\n * @param[in]  h              Email Header\n * @param[in]  s              Command string\n * @param[out] server_changes Flags have changed\n * @retval ptr  The end of flags string\n * @retval NULL Failure\n *\n * Expects a flags line of the form \"FLAGS (flag flag ...)\"\n *\n * imap_set_flags: fill out the message header according to the flags from\n * the server. Expects a flags line of the form \"FLAGS (flag flag ...)\"\n *\n * Sets server_changes to 1 if a change to a flag is made, or in the\n * case of h->changed, if a change to a flag _would_ have been\n * made.\n */\nchar *imap_set_flags(struct ImapData *idata, struct Header *h, char *s, int *server_changes)\n{\n  struct Context *ctx = idata->ctx;\n  struct ImapHeader newh = { 0 };\n  struct ImapHeaderData old_hd;\n  bool readonly;\n  int local_changes;\n\n  local_changes = h->changed;\n\n  struct ImapHeaderData *hd = h->data;\n  newh.data = hd;\n\n  memcpy(&old_hd, hd, sizeof(old_hd));\n\n  mutt_debug(2, \"parsing FLAGS\\n\");\n  s = msg_parse_flags(&newh, s);\n  if (!s)\n    return NULL;\n\n  /* Update tags system */\n  driver_tags_replace(&h->tags, mutt_str_strdup(hd->flags_remote));\n\n  /* YAUH (yet another ugly hack): temporarily set context to\n   * read-write even if it's read-only, so *server* updates of\n   * flags can be processed by mutt_set_flag. ctx->changed must\n   * be restored afterwards */\n  readonly = ctx->readonly;\n  ctx->readonly = false;\n\n  /* This is redundant with the following two checks. Removing:\n   * mutt_set_flag (ctx, h, MUTT_NEW, !(hd->read || hd->old));\n   */\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_OLD, old_hd.old,\n                   hd->old, h->old);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_READ,\n                   old_hd.read, hd->read, h->read);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_DELETE,\n                   old_hd.deleted, hd->deleted, h->deleted);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_FLAG,\n                   old_hd.flagged, hd->flagged, h->flagged);\n  set_changed_flag(ctx, h, local_changes, server_changes, MUTT_REPLIED,\n                   old_hd.replied, hd->replied, h->replied);\n\n  /* this message is now definitively *not* changed (mutt_set_flag\n   * marks things changed as a side-effect) */\n  if (!local_changes)\n    h->changed = false;\n  ctx->changed &= !readonly;\n  ctx->readonly = readonly;\n\n  return s;\n}\n"], "filenames": ["imap/message.c"], "buggy_code_start_loc": [333], "buggy_code_end_loc": [347], "fixing_code_start_loc": [333], "fixing_code_end_loc": [347], "type": "CWE-787", "message": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/message.c has a stack-based buffer overflow for a FETCH response with a long RFC822.SIZE field.", "other": {"cve": {"id": "CVE-2018-14358", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-17T17:29:00.747", "lastModified": "2020-05-20T00:48:02.887", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. imap/message.c has a stack-based buffer overflow for a FETCH response with a long RFC822.SIZE field."}, {"lang": "es", "value": "Se ha descubierto un problema en Mutt en versiones anteriores a la 1.10.1 y NeoMutt en versiones anteriores al 2018-07-16. imap/message.c tiene un desbordamiento de b\u00fafer basado en pila para una respuesta FETCH con un campo RFC822.SIZE largo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mutt:mutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "2FA2C3A6-423C-4BE5-8FA7-0241384D58D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:neomutt:neomutt:*:*:*:*:*:*:*:*", "versionEndExcluding": "20180716", "matchCriteriaId": "1C15CCD1-1752-4913-9506-32035B52A513"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.mutt.org/news.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/neomutt/neomutt/commit/1b0f0d0988e6df4e32e9f4bf8780846ea95d4485", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/muttmua/mutt/commit/3287534daa3beac68e2e83ca4b4fe8a3148ff870", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/08/msg00001.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://neomutt.org/2018/07/16/release", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://security.gentoo.org/glsa/201810-07", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3719-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4277", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/neomutt/neomutt/commit/1b0f0d0988e6df4e32e9f4bf8780846ea95d4485"}}