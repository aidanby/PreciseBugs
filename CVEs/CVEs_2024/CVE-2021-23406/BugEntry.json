{"buggy_code": ["import { isRegExp } from 'util';\nimport { generate } from 'escodegen';\nimport { parseScript } from 'esprima';\nimport { visit, namedTypes as n, builders as b } from 'ast-types';\nimport { Context, RunningScriptOptions } from 'vm';\nimport { VM } from 'vm2';\n\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\n\nfunction degenerator(\n\tcode: string,\n\t_names: degenerator.DegeneratorNames\n): string {\n\tif (!Array.isArray(_names)) {\n\t\tthrow new TypeError('an array of async function \"names\" is required');\n\t}\n\n\t// Duplicate the `names` array since it's rude to augment the user args\n\tconst names = _names.slice(0);\n\n\tconst ast = parseScript(code);\n\n\t// First pass is to find the `function` nodes and turn them into async or\n\t// generator functions only if their body includes `CallExpressions` to\n\t// function in `names`. We also add the names of the functions to the `names`\n\t// array. We'll iterate several time, as every iteration might add new items\n\t// to the `names` array, until no new names were added in the iteration.\n\tlet lastNamesLength = 0;\n\tdo {\n\t\tlastNamesLength = names.length;\n\t\tvisit(ast, {\n\t\t\tvisitVariableDeclaration(path) {\n\t\t\t\tif (path.node.declarations) {\n\t\t\t\t\tfor (let i = 0; i < path.node.declarations.length; i++) {\n\t\t\t\t\t\tconst declaration = path.node.declarations[i];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tn.VariableDeclarator.check(declaration) &&\n\t\t\t\t\t\t\tn.Identifier.check(declaration.init) &&\n\t\t\t\t\t\t\tn.Identifier.check(declaration.id) &&\n\t\t\t\t\t\t\tcheckName(declaration.init.name, names) &&\n\t\t\t\t\t\t\t!checkName(declaration.id.name, names)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnames.push(declaration.id.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tvisitAssignmentExpression(path) {\n\t\t\t\tif (\n\t\t\t\t\tn.Identifier.check(path.node.left) &&\n\t\t\t\t\tn.Identifier.check(path.node.right) &&\n\t\t\t\t\tcheckName(path.node.right.name, names) &&\n\t\t\t\t\t!checkName(path.node.left.name, names)\n\t\t\t\t) {\n\t\t\t\t\tnames.push(path.node.left.name);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tvisitFunction(path) {\n\t\t\t\tif (path.node.id) {\n\t\t\t\t\tlet shouldDegenerate = false;\n\t\t\t\t\tvisit(path.node, {\n\t\t\t\t\t\tvisitCallExpression(path) {\n\t\t\t\t\t\t\tif (checkNames(path.node, names)) {\n\t\t\t\t\t\t\t\tshouldDegenerate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!shouldDegenerate) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Got a \"function\" expression/statement,\n\t\t\t\t\t// convert it into an async function\n\t\t\t\t\tpath.node.async = true;\n\n\t\t\t\t\t// Add function name to `names` array\n\t\t\t\t\tif (!checkName(path.node.id.name, names)) {\n\t\t\t\t\t\tnames.push(path.node.id.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.traverse(path);\n\t\t\t},\n\t\t});\n\t} while (lastNamesLength !== names.length);\n\n\t// Second pass is for adding `await`/`yield` statements to any function\n\t// invocations that match the given `names` array.\n\tvisit(ast, {\n\t\tvisitCallExpression(path) {\n\t\t\tif (checkNames(path.node, names)) {\n\t\t\t\t// A \"function invocation\" expression,\n\t\t\t\t// we need to inject a `AwaitExpression`/`YieldExpression`\n\t\t\t\tconst delegate = false;\n\t\t\t\tconst {\n\t\t\t\t\tname,\n\t\t\t\t\tparent: { node: pNode },\n\t\t\t\t} = path;\n\n\t\t\t\tconst expr = b.awaitExpression(path.node, delegate);\n\n\t\t\t\tif (n.CallExpression.check(pNode)) {\n\t\t\t\t\tpNode.arguments[name] = expr;\n\t\t\t\t} else {\n\t\t\t\t\tpNode[name] = expr;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.traverse(path);\n\t\t},\n\t});\n\n\treturn generate(ast);\n}\n\nnamespace degenerator {\n\texport type DegeneratorName = string | RegExp;\n\texport type DegeneratorNames = DegeneratorName[];\n\texport interface CompileOptions extends RunningScriptOptions {\n\t\tsandbox?: Context;\n\t}\n\texport function compile<R = any, A extends any[] = []>(\n\t\tcode: string,\n\t\treturnName: string,\n\t\tnames: DegeneratorNames,\n\t\toptions: CompileOptions = {}\n\t): (...args: A) => Promise<R> {\n\t\tconst compiled = degenerator(code, names);\n\t\tconst vm = new VM(options);\n\t\tconst fn = vm.run(`${compiled};${returnName}`);\n\t\tif (typeof fn !== 'function') {\n\t\t\tthrow new Error(\n\t\t\t\t`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`\n\t\t\t);\n\t\t}\n\t\tconst r = function (this: any, ...args: A): Promise<R> {\n\t\t\ttry {\n\t\t\t\tconst p = fn.apply(this, args);\n\t\t\t\tif (typeof p?.then === 'function') {\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(p);\n\t\t\t} catch (err) {\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\t\t};\n\t\tObject.defineProperty(r, 'toString', {\n\t\t\tvalue: fn.toString.bind(fn),\n\t\t\tenumerable: false,\n\t\t});\n\t\treturn r;\n\t}\n}\n\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\nfunction checkNames(\n\t{ callee }: n.CallExpression,\n\tnames: degenerator.DegeneratorNames\n): boolean {\n\tlet name: string;\n\tif (n.Identifier.check(callee)) {\n\t\tname = callee.name;\n\t} else if (n.MemberExpression.check(callee)) {\n\t\tif (\n\t\t\tn.Identifier.check(callee.object) &&\n\t\t\tn.Identifier.check(callee.property)\n\t\t) {\n\t\t\tname = `${callee.object.name}.${callee.property.name}`;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else if (n.FunctionExpression.check(callee)) {\n\t\tif (callee.id) {\n\t\t\tname = callee.id.name;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tthrow new Error(`Don't know how to get name for: ${callee.type}`);\n\t}\n\treturn checkName(name, names);\n}\n\nfunction checkName(name: string, names: degenerator.DegeneratorNames): boolean {\n\t// now that we have the `name`, check if any entries match in the `names` array\n\tfor (let i = 0; i < names.length; i++) {\n\t\tconst n = names[i];\n\t\tif (isRegExp(n)) {\n\t\t\tif (n.test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (name === n) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport = degenerator;\n", "import fs from 'fs';\nimport path from 'path';\nimport assert from 'assert';\nimport degenerator, { compile } from '../src';\n\ndescribe('degenerator()', () => {\n\tit('should support \"async\" output functions', () => {\n\t\tfunction aPlusB(a: () => string, b: () => string): string {\n\t\t\treturn a() + b();\n\t\t}\n\t\tconst compiled = degenerator('' + aPlusB, ['a']);\n\t\tassert.equal(\n\t\t\tcompiled.replace(/\\s+/g, ' '),\n\t\t\t'async function aPlusB(a, b) { return await a() + b(); }'\n\t\t);\n\t});\n\tit('should be the default \"output\" mode (without options)', () => {\n\t\tfunction foo(a: () => string): string {\n\t\t\treturn a();\n\t\t}\n\t\tconst compiled = degenerator('' + foo, ['a']);\n\t\tassert.equal(\n\t\t\tcompiled.replace(/\\s+/g, ' '),\n\t\t\t'async function foo(a) { return await a(); }'\n\t\t);\n\t});\n\n\tdescribe('\"expected\" fixture tests', () => {\n\t\tfs.readdirSync(__dirname)\n\t\t\t.sort()\n\t\t\t.forEach((n) => {\n\t\t\t\tif (n === 'test.js') return;\n\t\t\t\tif (/\\.expected\\.js$/.test(n)) return;\n\t\t\t\tif (/\\.ts$/.test(n)) return;\n\t\t\t\tif (/\\.map/.test(n)) return;\n\n\t\t\t\tconst expectedName = `${path.basename(n, '.js')}.expected.js`;\n\n\t\t\t\tit(`${n} \u2192 ${expectedName}`, function () {\n\t\t\t\t\tconst sourceName = path.resolve(__dirname, n);\n\t\t\t\t\tconst compiledName = path.resolve(__dirname, expectedName);\n\t\t\t\t\tconst js = fs.readFileSync(sourceName, 'utf8');\n\t\t\t\t\tconst expected = fs.readFileSync(compiledName, 'utf8');\n\n\t\t\t\t\t// the test case can define the `names` to use as a\n\t\t\t\t\t// comment on the first line of the file\n\t\t\t\t\tconst m = js.match(/\\/\\/\\s*(.*)/);\n\t\t\t\t\tlet names;\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\t// the comment should be a comma-separated list of function names\n\t\t\t\t\t\tnames = m[1].split(/,\\s*/);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if no function names were passed in then convert them all\n\t\t\t\t\t\tnames = [/.*/];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst compiled = degenerator(js, names);\n\t\t\t\t\tassert.equal(\n\t\t\t\t\t\tcompiled.trim().replace(/\\r/g, ''),\n\t\t\t\t\t\texpected.trim().replace(/\\r/g, '')\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\t});\n\n\tdescribe('`compile()`', () => {\n\t\tit('should compile code into an invocable async function', async () => {\n\t\t\tconst a = (v: string) => Promise.resolve(v);\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(v: string): string {\n\t\t\t\treturn a(v) + b();\n\t\t\t}\n\t\t\tconst fn = compile<string, [string]>('' + aPlusB, 'aPlusB', ['a'], {\n\t\t\t\tsandbox: { a, b },\n\t\t\t});\n\t\t\tconst val = await fn('c');\n\t\t\tassert.equal(val, 'cb');\n\t\t});\n\t\tit('should contain the compiled code in `toString()` output', () => {\n\t\t\tconst a = () => 'a';\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(): string {\n\t\t\t\treturn a() + b();\n\t\t\t}\n\t\t\tconst fn = compile<() => Promise<string>>(\n\t\t\t\t'' + aPlusB,\n\t\t\t\t'aPlusB',\n\t\t\t\t['b'],\n\t\t\t\t{\n\t\t\t\t\tsandbox: { a, b },\n\t\t\t\t}\n\t\t\t);\n\t\t\tassert(/await b\\(\\)/.test(fn + ''));\n\t\t});\n\t\tit('should be able to await non-promises', () => {\n\t\t\tconst a = () => 'a';\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(): string {\n\t\t\t\treturn a() + b();\n\t\t\t}\n\t\t\tconst fn = compile<() => Promise<string>>(\n\t\t\t\t'' + aPlusB,\n\t\t\t\t'aPlusB',\n\t\t\t\t['a'],\n\t\t\t\t{\n\t\t\t\t\tsandbox: { a, b },\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn fn().then((val) => {\n\t\t\t\tassert.equal(val, 'ab');\n\t\t\t});\n\t\t});\n\t\tit('should be able to compile functions with no async', () => {\n\t\t\tconst a = () => 'a';\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(): string {\n\t\t\t\treturn a() + b();\n\t\t\t}\n\t\t\tconst fn = compile<string>('' + aPlusB, 'aPlusB', [], {\n\t\t\t\tsandbox: { a, b },\n\t\t\t});\n\t\t\treturn fn().then((val: string) => {\n\t\t\t\tassert.equal(val, 'ab');\n\t\t\t});\n\t\t});\n\t\tit('should throw an Error if no function is returned from the `vm`', () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tcompile<() => Promise<string>>('const foo = 1', 'foo', []);\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert(err);\n\t\t\tassert.equal(\n\t\t\t\terr.message,\n\t\t\t\t'Expected a \"function\" to be returned for `foo`, but got \"number\"'\n\t\t\t);\n\t\t});\n\t\tit('should compile if branches', () => {\n\t\t\tfunction ifA(): string {\n\t\t\t\tif (a()) {\n\t\t\t\t\treturn 'foo';\n\t\t\t\t}\n\t\t\t\treturn 'bar';\n\t\t\t}\n\t\t\tfunction a() {\n\t\t\t\tif (b()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfunction b() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst fn = compile<string>(`${ifA};${a}`, 'ifA', ['b'], {\n\t\t\t\tsandbox: { b },\n\t\t\t});\n\t\t\treturn fn().then((val: string) => {\n\t\t\t\tassert.equal(val, 'foo');\n\t\t\t});\n\t\t});\n\t\tit('should prevent privilege escalation of untrusted code', async() => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tconst fn = compile<typeof process>(\n\t\t\t\t\t`const f = this.constructor.constructor('return process');`,\n\t\t\t\t\t'f',\n\t\t\t\t\t[],\n\t\t\t\t);\n\t\t\t\tawait fn();\n\t\t\t} catch(_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.equal(err.message,'process is not defined')\n\t\t});\n\t\tit('should allow to return synchronous undefined', () => {\n\t\t\tfunction u() {}\n\t\t\tconst fn = compile(`${u}`, 'u', ['']);\n\t\t\treturn fn().then(val => {\n\t\t\t\tassert.strictEqual(val, undefined);\n\t\t\t});\n\t\t});\n\t});\n});\n"], "fixing_code": ["import { isRegExp } from 'util';\nimport { generate } from 'escodegen';\nimport { parseScript } from 'esprima';\nimport { visit, namedTypes as n, builders as b } from 'ast-types';\nimport { Context, RunningScriptOptions } from 'vm';\nimport { VM, VMScript } from 'vm2';\n\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\n\nfunction degenerator(\n\tcode: string,\n\t_names: degenerator.DegeneratorNames\n): string {\n\tif (!Array.isArray(_names)) {\n\t\tthrow new TypeError('an array of async function \"names\" is required');\n\t}\n\n\t// Duplicate the `names` array since it's rude to augment the user args\n\tconst names = _names.slice(0);\n\n\tconst ast = parseScript(code);\n\n\t// First pass is to find the `function` nodes and turn them into async or\n\t// generator functions only if their body includes `CallExpressions` to\n\t// function in `names`. We also add the names of the functions to the `names`\n\t// array. We'll iterate several time, as every iteration might add new items\n\t// to the `names` array, until no new names were added in the iteration.\n\tlet lastNamesLength = 0;\n\tdo {\n\t\tlastNamesLength = names.length;\n\t\tvisit(ast, {\n\t\t\tvisitVariableDeclaration(path) {\n\t\t\t\tif (path.node.declarations) {\n\t\t\t\t\tfor (let i = 0; i < path.node.declarations.length; i++) {\n\t\t\t\t\t\tconst declaration = path.node.declarations[i];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tn.VariableDeclarator.check(declaration) &&\n\t\t\t\t\t\t\tn.Identifier.check(declaration.init) &&\n\t\t\t\t\t\t\tn.Identifier.check(declaration.id) &&\n\t\t\t\t\t\t\tcheckName(declaration.init.name, names) &&\n\t\t\t\t\t\t\t!checkName(declaration.id.name, names)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnames.push(declaration.id.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tvisitAssignmentExpression(path) {\n\t\t\t\tif (\n\t\t\t\t\tn.Identifier.check(path.node.left) &&\n\t\t\t\t\tn.Identifier.check(path.node.right) &&\n\t\t\t\t\tcheckName(path.node.right.name, names) &&\n\t\t\t\t\t!checkName(path.node.left.name, names)\n\t\t\t\t) {\n\t\t\t\t\tnames.push(path.node.left.name);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tvisitFunction(path) {\n\t\t\t\tif (path.node.id) {\n\t\t\t\t\tlet shouldDegenerate = false;\n\t\t\t\t\tvisit(path.node, {\n\t\t\t\t\t\tvisitCallExpression(path) {\n\t\t\t\t\t\t\tif (checkNames(path.node, names)) {\n\t\t\t\t\t\t\t\tshouldDegenerate = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!shouldDegenerate) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Got a \"function\" expression/statement,\n\t\t\t\t\t// convert it into an async function\n\t\t\t\t\tpath.node.async = true;\n\n\t\t\t\t\t// Add function name to `names` array\n\t\t\t\t\tif (!checkName(path.node.id.name, names)) {\n\t\t\t\t\t\tnames.push(path.node.id.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.traverse(path);\n\t\t\t},\n\t\t});\n\t} while (lastNamesLength !== names.length);\n\n\t// Second pass is for adding `await`/`yield` statements to any function\n\t// invocations that match the given `names` array.\n\tvisit(ast, {\n\t\tvisitCallExpression(path) {\n\t\t\tif (checkNames(path.node, names)) {\n\t\t\t\t// A \"function invocation\" expression,\n\t\t\t\t// we need to inject a `AwaitExpression`/`YieldExpression`\n\t\t\t\tconst delegate = false;\n\t\t\t\tconst {\n\t\t\t\t\tname,\n\t\t\t\t\tparent: { node: pNode },\n\t\t\t\t} = path;\n\n\t\t\t\tconst expr = b.awaitExpression(path.node, delegate);\n\n\t\t\t\tif (n.CallExpression.check(pNode)) {\n\t\t\t\t\tpNode.arguments[name] = expr;\n\t\t\t\t} else {\n\t\t\t\t\tpNode[name] = expr;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.traverse(path);\n\t\t},\n\t});\n\n\treturn generate(ast);\n}\n\nnamespace degenerator {\n\texport type DegeneratorName = string | RegExp;\n\texport type DegeneratorNames = DegeneratorName[];\n\texport interface CompileOptions extends RunningScriptOptions {\n\t\tsandbox?: Context;\n\t}\n\texport function compile<R = any, A extends any[] = []>(\n\t\tcode: string,\n\t\treturnName: string,\n\t\tnames: DegeneratorNames,\n\t\toptions: CompileOptions = {}\n\t): (...args: A) => Promise<R> {\n\t\tconst compiled = degenerator(code, names);\n\t\tconst vm = new VM(options);\n\t\tconst script = new VMScript(`${compiled};${returnName}`, {\n\t\t\tfilename: options.filename,\n\t\t});\n\t\tconst fn = vm.run(script);\n\t\tif (typeof fn !== 'function') {\n\t\t\tthrow new Error(\n\t\t\t\t`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`\n\t\t\t);\n\t\t}\n\t\tconst r = function (this: any, ...args: A): Promise<R> {\n\t\t\ttry {\n\t\t\t\tconst p = fn.apply(this, args);\n\t\t\t\tif (typeof p?.then === 'function') {\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\t\t\t\treturn Promise.resolve(p);\n\t\t\t} catch (err) {\n\t\t\t\treturn Promise.reject(err);\n\t\t\t}\n\t\t};\n\t\tObject.defineProperty(r, 'toString', {\n\t\t\tvalue: fn.toString.bind(fn),\n\t\t\tenumerable: false,\n\t\t});\n\t\treturn r;\n\t}\n}\n\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\nfunction checkNames(\n\t{ callee }: n.CallExpression,\n\tnames: degenerator.DegeneratorNames\n): boolean {\n\tlet name: string;\n\tif (n.Identifier.check(callee)) {\n\t\tname = callee.name;\n\t} else if (n.MemberExpression.check(callee)) {\n\t\tif (\n\t\t\tn.Identifier.check(callee.object) &&\n\t\t\tn.Identifier.check(callee.property)\n\t\t) {\n\t\t\tname = `${callee.object.name}.${callee.property.name}`;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else if (n.FunctionExpression.check(callee)) {\n\t\tif (callee.id) {\n\t\t\tname = callee.id.name;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tthrow new Error(`Don't know how to get name for: ${callee.type}`);\n\t}\n\treturn checkName(name, names);\n}\n\nfunction checkName(name: string, names: degenerator.DegeneratorNames): boolean {\n\t// now that we have the `name`, check if any entries match in the `names` array\n\tfor (let i = 0; i < names.length; i++) {\n\t\tconst n = names[i];\n\t\tif (isRegExp(n)) {\n\t\t\tif (n.test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (name === n) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nexport = degenerator;\n", "import fs from 'fs';\nimport path from 'path';\nimport assert from 'assert';\nimport degenerator, { compile } from '../src';\n\ndescribe('degenerator()', () => {\n\tit('should support \"async\" output functions', () => {\n\t\tfunction aPlusB(a: () => string, b: () => string): string {\n\t\t\treturn a() + b();\n\t\t}\n\t\tconst compiled = degenerator('' + aPlusB, ['a']);\n\t\tassert.equal(\n\t\t\tcompiled.replace(/\\s+/g, ' '),\n\t\t\t'async function aPlusB(a, b) { return await a() + b(); }'\n\t\t);\n\t});\n\tit('should be the default \"output\" mode (without options)', () => {\n\t\tfunction foo(a: () => string): string {\n\t\t\treturn a();\n\t\t}\n\t\tconst compiled = degenerator('' + foo, ['a']);\n\t\tassert.equal(\n\t\t\tcompiled.replace(/\\s+/g, ' '),\n\t\t\t'async function foo(a) { return await a(); }'\n\t\t);\n\t});\n\n\tdescribe('\"expected\" fixture tests', () => {\n\t\tfs.readdirSync(__dirname)\n\t\t\t.sort()\n\t\t\t.forEach((n) => {\n\t\t\t\tif (n === 'test.js') return;\n\t\t\t\tif (/\\.expected\\.js$/.test(n)) return;\n\t\t\t\tif (/\\.ts$/.test(n)) return;\n\t\t\t\tif (/\\.map/.test(n)) return;\n\n\t\t\t\tconst expectedName = `${path.basename(n, '.js')}.expected.js`;\n\n\t\t\t\tit(`${n} \u2192 ${expectedName}`, function () {\n\t\t\t\t\tconst sourceName = path.resolve(__dirname, n);\n\t\t\t\t\tconst compiledName = path.resolve(__dirname, expectedName);\n\t\t\t\t\tconst js = fs.readFileSync(sourceName, 'utf8');\n\t\t\t\t\tconst expected = fs.readFileSync(compiledName, 'utf8');\n\n\t\t\t\t\t// the test case can define the `names` to use as a\n\t\t\t\t\t// comment on the first line of the file\n\t\t\t\t\tconst m = js.match(/\\/\\/\\s*(.*)/);\n\t\t\t\t\tlet names;\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\t// the comment should be a comma-separated list of function names\n\t\t\t\t\t\tnames = m[1].split(/,\\s*/);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if no function names were passed in then convert them all\n\t\t\t\t\t\tnames = [/.*/];\n\t\t\t\t\t}\n\n\t\t\t\t\tconst compiled = degenerator(js, names);\n\t\t\t\t\tassert.equal(\n\t\t\t\t\t\tcompiled.trim().replace(/\\r/g, ''),\n\t\t\t\t\t\texpected.trim().replace(/\\r/g, '')\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\t});\n\n\tdescribe('`compile()`', () => {\n\t\tit('should compile code into an invocable async function', async () => {\n\t\t\tconst a = (v: string) => Promise.resolve(v);\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(v: string): string {\n\t\t\t\treturn a(v) + b();\n\t\t\t}\n\t\t\tconst fn = compile<string, [string]>('' + aPlusB, 'aPlusB', ['a'], {\n\t\t\t\tsandbox: { a, b },\n\t\t\t});\n\t\t\tconst val = await fn('c');\n\t\t\tassert.equal(val, 'cb');\n\t\t});\n\t\tit('should contain the compiled code in `toString()` output', () => {\n\t\t\tconst a = () => 'a';\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(): string {\n\t\t\t\treturn a() + b();\n\t\t\t}\n\t\t\tconst fn = compile<() => Promise<string>>(\n\t\t\t\t'' + aPlusB,\n\t\t\t\t'aPlusB',\n\t\t\t\t['b'],\n\t\t\t\t{\n\t\t\t\t\tsandbox: { a, b },\n\t\t\t\t}\n\t\t\t);\n\t\t\tassert(/await b\\(\\)/.test(fn + ''));\n\t\t});\n\t\tit('should be able to await non-promises', () => {\n\t\t\tconst a = () => 'a';\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(): string {\n\t\t\t\treturn a() + b();\n\t\t\t}\n\t\t\tconst fn = compile<() => Promise<string>>(\n\t\t\t\t'' + aPlusB,\n\t\t\t\t'aPlusB',\n\t\t\t\t['a'],\n\t\t\t\t{\n\t\t\t\t\tsandbox: { a, b },\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn fn().then((val) => {\n\t\t\t\tassert.equal(val, 'ab');\n\t\t\t});\n\t\t});\n\t\tit('should be able to compile functions with no async', () => {\n\t\t\tconst a = () => 'a';\n\t\t\tconst b = () => 'b';\n\t\t\tfunction aPlusB(): string {\n\t\t\t\treturn a() + b();\n\t\t\t}\n\t\t\tconst fn = compile<string>('' + aPlusB, 'aPlusB', [], {\n\t\t\t\tsandbox: { a, b },\n\t\t\t});\n\t\t\treturn fn().then((val: string) => {\n\t\t\t\tassert.equal(val, 'ab');\n\t\t\t});\n\t\t});\n\t\tit('should throw an Error if no function is returned from the `vm`', () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tcompile<() => Promise<string>>('const foo = 1', 'foo', []);\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert(err);\n\t\t\tassert.equal(\n\t\t\t\terr.message,\n\t\t\t\t'Expected a \"function\" to be returned for `foo`, but got \"number\"'\n\t\t\t);\n\t\t});\n\t\tit('should compile if branches', () => {\n\t\t\tfunction ifA(): string {\n\t\t\t\tif (a()) {\n\t\t\t\t\treturn 'foo';\n\t\t\t\t}\n\t\t\t\treturn 'bar';\n\t\t\t}\n\t\t\tfunction a() {\n\t\t\t\tif (b()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfunction b() {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst fn = compile<string>(`${ifA};${a}`, 'ifA', ['b'], {\n\t\t\t\tsandbox: { b },\n\t\t\t});\n\t\t\treturn fn().then((val: string) => {\n\t\t\t\tassert.equal(val, 'foo');\n\t\t\t});\n\t\t});\n\t\tit('should prevent privilege escalation of untrusted code', async () => {\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tconst fn = compile<typeof process>(\n\t\t\t\t\t`const f = this.constructor.constructor('return process');`,\n\t\t\t\t\t'f',\n\t\t\t\t\t[]\n\t\t\t\t);\n\t\t\t\tawait fn();\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.equal(err.message, 'process is not defined');\n\t\t});\n\t\tit('should allow to return synchronous undefined', () => {\n\t\t\tfunction u() {}\n\t\t\tconst fn = compile(`${u}`, 'u', ['']);\n\t\t\treturn fn().then((val) => {\n\t\t\t\tassert.strictEqual(val, undefined);\n\t\t\t});\n\t\t});\n\t\tit('should support \"filename\" option', async () => {\n\t\t\tfunction u() {\n\t\t\t\tthrow new Error('fail');\n\t\t\t}\n\t\t\tlet err;\n\t\t\tconst fn = compile(`${u}`, 'u', [''], {\n\t\t\t\tfilename: '/foo/bar/baz.js',\n\t\t\t});\n\t\t\ttry {\n\t\t\t\tawait fn();\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, 'fail');\n\t\t\tassert(err.stack.includes('at u (/foo/bar/baz.js:'));\n\t\t});\n\t});\n});\n"], "filenames": ["src/index.ts", "test/test.ts"], "buggy_code_start_loc": [6, 162], "buggy_code_end_loc": [142, 182], "fixing_code_start_loc": [6, 162], "fixing_code_end_loc": [145, 199], "type": "NVD-CWE-noinfo", "message": "This affects the package pac-resolver before 5.0.0. This can occur when used with untrusted input, due to unsafe PAC file handling. **NOTE:** The fix for this vulnerability is applied in the node-degenerator library, a dependency written by the same maintainer.", "other": {"cve": {"id": "CVE-2021-23406", "sourceIdentifier": "report@snyk.io", "published": "2021-08-24T08:15:18.180", "lastModified": "2021-08-30T19:15:28.817", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package pac-resolver before 5.0.0. This can occur when used with untrusted input, due to unsafe PAC file handling. **NOTE:** The fix for this vulnerability is applied in the node-degenerator library, a dependency written by the same maintainer."}, {"lang": "es", "value": "Esto afecta al paquete pac-resolver versiones anteriores a 5.0.0.&#xa0;Esto puede ocurrir cuando se usa con una entrada no confiable debido a un manejo no seguro de archivos PAC.&#xa0;**NOTA:** La correcci\u00f3n para esta vulnerabilidad se aplica en la biblioteca degenerador de nodos, una dependencia escrita por el mismo mantenedor"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pac-resolver_project:pac-resolver:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.0.0", "matchCriteriaId": "7F43E597-369F-4116-B2CF-25FE6286C6B5"}]}]}], "references": [{"url": "https://github.com/TooTallNate/node-degenerator/commit/9d25bb67d957bc2e5425fea7bf7a58b3fc64ff9e", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TooTallNate/node-degenerator/commit/ccc3445354135398b6eb1a04c7d27c13b833f2d5", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TooTallNate/node-pac-resolver/releases/tag/5.0.0", "source": "report@snyk.io", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1568506", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-PACRESOLVER-1564857", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/TooTallNate/node-degenerator/commit/9d25bb67d957bc2e5425fea7bf7a58b3fc64ff9e"}}