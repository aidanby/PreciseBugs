{"buggy_code": ["<?php\n/**\n * @copyright Copyright (c) 2017 Bjoern Schiessle <bjoern@schiessle.org>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nnamespace OCA\\GlobalSiteSelector\\Controller;\n\nuse OC\\Authentication\\Token\\IToken;\nuse OCA\\GlobalSiteSelector\\AppInfo\\Application;\nuse OCA\\GlobalSiteSelector\\Exceptions\\MasterUrlException;\nuse OCA\\GlobalSiteSelector\\GlobalSiteSelector;\nuse OCA\\GlobalSiteSelector\\Service\\SlaveService;\nuse OCA\\GlobalSiteSelector\\Slave;\nuse OCA\\GlobalSiteSelector\\TokenHandler;\nuse OCA\\GlobalSiteSelector\\UserBackend;\nuse OCA\\GlobalSiteSelector\\Vendor\\Firebase\\JWT\\ExpiredException;\nuse OCA\\GlobalSiteSelector\\Vendor\\Firebase\\JWT\\JWT;\nuse OCA\\GlobalSiteSelector\\Vendor\\Firebase\\JWT\\Key;\nuse OCP\\AppFramework\\Http;\nuse OCP\\AppFramework\\Http\\DataResponse;\nuse OCP\\AppFramework\\Http\\RedirectResponse;\nuse OCP\\AppFramework\\OCSController;\nuse OCP\\IConfig;\nuse OCP\\IRequest;\nuse OCP\\ISession;\nuse OCP\\IURLGenerator;\nuse OCP\\IUser;\nuse OCP\\IUserManager;\nuse OCP\\IUserSession;\nuse OCP\\Security\\ICrypto;\nuse Psr\\Log\\LoggerInterface;\n\n/**\n * Class SlaveController\n *\n * Endpoints in case the global site selector operates as a slave\n *\n * @package OCA\\GlobalSiteSelector\\Controller\n */\nclass SlaveController extends OCSController {\n\n\tpublic function __construct(\n\t\t$appName,\n\t\tIRequest $request,\n\t\tprivate GlobalSiteSelector $gss,\n\t\tprivate IUserSession $userSession,\n\t\tprivate IURLGenerator $urlGenerator,\n\t\tprivate ICrypto $crypto,\n\t\tprivate TokenHandler $tokenHandler,\n\t\tprivate IUserManager $userManager,\n\t\tprivate UserBackend $userBackend,\n\t\tprivate ISession $session,\n\t\tprivate SlaveService $slaveService,\n\t\tprivate IConfig $config,\n\t\tprivate LoggerInterface $logger,\n\t) {\n\t\tparent::__construct($appName, $request);\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @UseSession\n\t *\n\t * @param string $jwt\n\t *\n\t * @return RedirectResponse\n\t */\n\tpublic function autoLogin(string $jwt): RedirectResponse {\n\t\t$this->logger->debug('autologin incoming request with ' . $jwt);\n\n\t\ttry {\n\t\t\t$masterUrl = $this->gss->getMasterUrl();\n\t\t} catch (MasterUrlException $e) {\n\t\t\t$this->logger->warning('missing master url');\n\t\t\treturn new RedirectResponse('');\n\t\t}\n\n\t\tif ($this->gss->isMaster()) {\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t}\n\t\tif ($jwt === '') {\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t}\n\n\t\ttry {\n\t\t\tlist($uid, $password, $options) = $this->decodeJwt($jwt);\n\t\t\t$this->logger->debug('uid: ' . $uid . ', options: ' . json_encode($options));\n\n\t\t\t$target = $options['target'];\n\t\t\tif (($options['backend'] ?? '') === 'saml') {\n\t\t\t\t$this->logger->debug('saml enabled');\n\t\t\t\t$this->autoprovisionIfNeeded($uid, $options);\n\n\t\t\t\t$user = $this->userManager->get($uid);\n\t\t\t\tif (!($user instanceof IUser)) {\n\t\t\t\t\tthrow new \\InvalidArgumentException('User is not valid');\n\t\t\t\t}\n\t\t\t\t$user->updateLastLoginTimestamp();\n\n\t\t\t\t$this->session->set('globalScale.userData', $options);\n\t\t\t\t$this->session->set('globalScale.uid', $uid);\n\t\t\t\t$this->config->setUserValue(\n\t\t\t\t\t$user->getUID(),\n\t\t\t\t\tApplication::APP_ID,\n\t\t\t\t\tSlave::SAML_IDP,\n\t\t\t\t\t$options['saml']['idp'] ?? null\n\t\t\t\t);\n\n\t\t\t\t$result = true;\n\t\t\t} else {\n\t\t\t\t$this->logger->debug('testing normal login process');\n\t\t\t\t$result = $this->userSession->login($uid, $password);\n\t\t\t}\n\n\t\t\t$this->logger->notice('auth result: ' . json_encode($result));\n\t\t\tif ($result === false) {\n\t\t\t\tthrow new \\Exception('wrong username or password given for: ' . $uid);\n\t\t\t}\n\t\t} catch (ExpiredException $e) {\n\t\t\t$this->logger->info('token expired');\n\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t} catch (\\Exception $e) {\n\t\t\t$this->logger->warning('issue during login process', ['exception' => $e]);\n\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t}\n\n\t\t$this->logger->debug('all good. creating session');\n\t\t$this->userSession->createSessionToken($this->request, $uid, $uid, null, IToken::REMEMBER);\n\n\t\t$this->slaveService->updateUserById($uid);\n\t\t$this->logger->debug('userdata updated on lus');\n\n\t\t$home = $this->urlGenerator->getAbsoluteURL($target);\n\t\t$this->logger->debug('redirecting to ' . $home);\n\n\t\treturn new RedirectResponse($home);\n\t}\n\n\t/**\n\t * Create app token\n\t *\n\t * @PublicPage\n\t * @NoAdminRequired\n\t *\n\t * @return DataResponse\n\t */\n\tpublic function createAppToken($jwt) {\n\t\tif ($this->gss->getMode() === 'master' || empty($jwt)) {\n\t\t\treturn new DataResponse([], Http::STATUS_BAD_REQUEST);\n\t\t}\n\n\t\ttry {\n\t\t\tlist($uid, $password, $options) = $this->decodeJwt($jwt);\n\n\t\t\tif (is_array($options) && isset($options['backend']) && $options['backend'] === 'saml') {\n\t\t\t\t$this->autoprovisionIfNeeded($uid, $options);\n\t\t\t}\n\n\t\t\tif ($this->userManager->userExists($uid)) {\n\t\t\t\t// if we have a password, we verify it\n\t\t\t\tif (!empty($password)) {\n\t\t\t\t\t$result = $this->userSession->login($uid, $password);\n\t\t\t\t} else {\n\t\t\t\t\t$result = true;\n\t\t\t\t}\n\t\t\t\tif ($result) {\n\t\t\t\t\t$token = $this->tokenHandler->generateAppToken($uid);\n\n\t\t\t\t\treturn new DataResponse($token);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ExpiredException $e) {\n\t\t\t$this->logger->info('Create app password: JWT token expired');\n\t\t} catch (\\Exception $e) {\n\t\t\t$this->logger->info('issue while token creation', ['exception' => $e]);\n\t\t}\n\n\t\treturn new DataResponse([], Http::STATUS_BAD_REQUEST);\n\t}\n\n\t/**\n\t * decode jwt and return the uid and the password\n\t *\n\t * @param string $jwt\n\t *\n\t * @return array\n\t * @throws \\Exception\n\t */\n\tprotected function decodeJwt($jwt) {\n\t\t$key = $this->gss->getJwtKey();\n\t\t$decoded = (array)JWT::decode($jwt, new Key($key, Application::JWT_ALGORITHM));\n\n\t\tif (!isset($decoded['uid'])) {\n\t\t\tthrow new \\Exception('\"uid\" not set in JWT');\n\t\t}\n\n\t\tif (!isset($decoded['password'])) {\n\t\t\tthrow new \\Exception('\"password\" not set in JWT');\n\t\t}\n\n\t\t$uid = $decoded['uid'];\n\t\t$password = $this->crypto->decrypt($decoded['password'], $key);\n\t\t$options = $decoded['options'] ?? json_encode([]);\n\n\t\treturn [$uid, $password, json_decode($options, true)];\n\t}\n\n\n\t/**\n\t * create new user if the user doesn't exist yet on the client node\n\t *\n\t * @param string $uid\n\t * @param array $options\n\t */\n\tprotected function autoprovisionIfNeeded($uid, $options) {\n\t\t// make sure that a valid UID is given\n\t\tif (empty($uid)) {\n\t\t\t$this->logger->error('Uid \"{uid}\" is not valid.', ['app' => $this->appName, 'uid' => $uid]);\n\t\t\tthrow new \\InvalidArgumentException('No valid uid given. Given uid: ' . $uid);\n\t\t}\n\n\t\t$this->userBackend->createUserIfNotExists($uid);\n\t\t$this->userBackend->updateAttributes($uid, $options);\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * @copyright Copyright (c) 2017 Bjoern Schiessle <bjoern@schiessle.org>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nnamespace OCA\\GlobalSiteSelector\\Controller;\n\nuse OC\\Authentication\\Token\\IToken;\nuse OCA\\GlobalSiteSelector\\AppInfo\\Application;\nuse OCA\\GlobalSiteSelector\\Exceptions\\MasterUrlException;\nuse OCA\\GlobalSiteSelector\\GlobalSiteSelector;\nuse OCA\\GlobalSiteSelector\\Service\\SlaveService;\nuse OCA\\GlobalSiteSelector\\Slave;\nuse OCA\\GlobalSiteSelector\\TokenHandler;\nuse OCA\\GlobalSiteSelector\\UserBackend;\nuse OCA\\GlobalSiteSelector\\Vendor\\Firebase\\JWT\\ExpiredException;\nuse OCA\\GlobalSiteSelector\\Vendor\\Firebase\\JWT\\JWT;\nuse OCA\\GlobalSiteSelector\\Vendor\\Firebase\\JWT\\Key;\nuse OCP\\AppFramework\\Http;\nuse OCP\\AppFramework\\Http\\DataResponse;\nuse OCP\\AppFramework\\Http\\RedirectResponse;\nuse OCP\\AppFramework\\OCSController;\nuse OCP\\IConfig;\nuse OCP\\IRequest;\nuse OCP\\ISession;\nuse OCP\\IURLGenerator;\nuse OCP\\IUser;\nuse OCP\\IUserManager;\nuse OCP\\IUserSession;\nuse OCP\\Security\\ICrypto;\nuse Psr\\Log\\LoggerInterface;\n\n/**\n * Class SlaveController\n *\n * Endpoints in case the global site selector operates as a slave\n *\n * @package OCA\\GlobalSiteSelector\\Controller\n */\nclass SlaveController extends OCSController {\n\n\tpublic function __construct(\n\t\t$appName,\n\t\tIRequest $request,\n\t\tprivate GlobalSiteSelector $gss,\n\t\tprivate IUserSession $userSession,\n\t\tprivate IURLGenerator $urlGenerator,\n\t\tprivate ICrypto $crypto,\n\t\tprivate TokenHandler $tokenHandler,\n\t\tprivate IUserManager $userManager,\n\t\tprivate UserBackend $userBackend,\n\t\tprivate ISession $session,\n\t\tprivate SlaveService $slaveService,\n\t\tprivate IConfig $config,\n\t\tprivate LoggerInterface $logger,\n\t) {\n\t\tparent::__construct($appName, $request);\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @UseSession\n\t *\n\t * @param string $jwt\n\t *\n\t * @return RedirectResponse\n\t */\n\tpublic function autoLogin(string $jwt): RedirectResponse {\n\t\t$this->logger->debug('autologin incoming request with ' . $jwt);\n\n\t\ttry {\n\t\t\t$masterUrl = $this->gss->getMasterUrl();\n\t\t} catch (MasterUrlException $e) {\n\t\t\t$this->logger->warning('missing master url');\n\t\t\treturn new RedirectResponse('');\n\t\t}\n\n\t\tif ($this->gss->isMaster()) {\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t}\n\t\tif ($jwt === '') {\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t}\n\n\t\ttry {\n\t\t\tlist($uid, $password, $options) = $this->decodeJwt($jwt);\n\t\t\t$this->logger->debug('uid: ' . $uid . ', options: ' . json_encode($options));\n\n\t\t\t$target = $options['target'];\n\t\t\tif (($options['backend'] ?? '') === 'saml') {\n\t\t\t\t$this->logger->debug('saml enabled');\n\t\t\t\t$this->autoprovisionIfNeeded($uid, $options);\n\n\t\t\t\t$user = $this->userManager->get($uid);\n\t\t\t\tif (!($user instanceof IUser)) {\n\t\t\t\t\tthrow new \\InvalidArgumentException('User is not valid');\n\t\t\t\t}\n\t\t\t\t$user->updateLastLoginTimestamp();\n\n\t\t\t\t$this->session->set('globalScale.userData', $options);\n\t\t\t\t$this->session->set('globalScale.uid', $uid);\n\t\t\t\t$this->config->setUserValue(\n\t\t\t\t\t$user->getUID(),\n\t\t\t\t\tApplication::APP_ID,\n\t\t\t\t\tSlave::SAML_IDP,\n\t\t\t\t\t$options['saml']['idp'] ?? null\n\t\t\t\t);\n\n\t\t\t\t$result = true;\n\t\t\t} else {\n\t\t\t\t$this->logger->debug('testing normal login process');\n\t\t\t\t$result = $this->userSession->login($uid, $password);\n\t\t\t}\n\n\t\t\t$this->logger->notice('auth result: ' . json_encode($result));\n\t\t\tif ($result === false) {\n\t\t\t\tthrow new \\Exception('wrong username or password given for: ' . $uid);\n\t\t\t}\n\t\t} catch (ExpiredException $e) {\n\t\t\t$this->logger->info('token expired');\n\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t} catch (\\Exception $e) {\n\t\t\t$this->logger->warning('issue during login process', ['exception' => $e]);\n\n\t\t\treturn new RedirectResponse($masterUrl);\n\t\t}\n\n\t\t$this->logger->debug('all good. creating session');\n\t\t$this->userSession->createSessionToken($this->request, $uid, $uid, null, IToken::REMEMBER);\n\n\t\t$this->slaveService->updateUserById($uid);\n\t\t$this->logger->debug('userdata updated on lus');\n\n\t\t$home = $this->urlGenerator->getAbsoluteURL($target);\n\t\t$this->logger->debug('redirecting to ' . $home);\n\n\t\treturn new RedirectResponse($home);\n\t}\n\n\t/**\n\t * Create app token\n\t *\n\t * @PublicPage\n\t * @NoAdminRequired\n\t *\n\t * @return DataResponse\n\t */\n\tpublic function createAppToken($jwt) {\n\t\tif ($this->gss->getMode() === 'master' || empty($jwt)) {\n\t\t\treturn new DataResponse([], Http::STATUS_BAD_REQUEST);\n\t\t}\n\n\t\ttry {\n\t\t\tlist($uid, $password, $options) = $this->decodeJwt($jwt);\n\t\t\t$saml = (($options['backend'] ?? '') === 'saml');\n\t\t\tif ($saml) {\n\t\t\t\t$this->autoprovisionIfNeeded($uid, $options);\n\t\t\t}\n\n\t\t\tif ($this->userManager->userExists($uid)) {\n\t\t\t\t// if we have a password, we verify it; if not it means we should be using saml.\n\t\t\t\t$result = ('' === $password) ? $saml : $this->userSession->login($uid, $password);\n\t\t\t\tif ($result) {\n\t\t\t\t\t$token = $this->tokenHandler->generateAppToken($uid);\n\n\t\t\t\t\treturn new DataResponse($token);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ExpiredException $e) {\n\t\t\t$this->logger->info('Create app password: JWT token expired');\n\t\t} catch (\\Exception $e) {\n\t\t\t$this->logger->info('issue while token creation', ['exception' => $e]);\n\t\t}\n\n\t\treturn new DataResponse([], Http::STATUS_BAD_REQUEST);\n\t}\n\n\t/**\n\t * decode jwt and return the uid and the password\n\t *\n\t * @param string $jwt\n\t *\n\t * @return array\n\t * @throws \\Exception\n\t */\n\tprotected function decodeJwt($jwt) {\n\t\t$key = $this->gss->getJwtKey();\n\t\t$decoded = (array)JWT::decode($jwt, new Key($key, Application::JWT_ALGORITHM));\n\n\t\tif (!isset($decoded['uid'])) {\n\t\t\tthrow new \\Exception('\"uid\" not set in JWT');\n\t\t}\n\n\t\tif (!isset($decoded['password'])) {\n\t\t\tthrow new \\Exception('\"password\" not set in JWT');\n\t\t}\n\n\t\t$uid = $decoded['uid'];\n\t\t$password = $this->crypto->decrypt($decoded['password'], $key);\n\t\t$options = $decoded['options'] ?? json_encode([]);\n\n\t\treturn [$uid, $password, json_decode($options, true)];\n\t}\n\n\n\t/**\n\t * create new user if the user doesn't exist yet on the client node\n\t *\n\t * @param string $uid\n\t * @param array $options\n\t */\n\tprotected function autoprovisionIfNeeded($uid, $options) {\n\t\t// make sure that a valid UID is given\n\t\tif (empty($uid)) {\n\t\t\t$this->logger->error('Uid \"{uid}\" is not valid.', ['app' => $this->appName, 'uid' => $uid]);\n\t\t\tthrow new \\InvalidArgumentException('No valid uid given. Given uid: ' . $uid);\n\t\t}\n\n\t\t$this->userBackend->createUserIfNotExists($uid);\n\t\t$this->userBackend->updateAttributes($uid, $options);\n\t}\n}\n"], "filenames": ["lib/Controller/SlaveController.php"], "buggy_code_start_loc": [174], "buggy_code_end_loc": [186], "fixing_code_start_loc": [174], "fixing_code_end_loc": [182], "type": "CWE-306", "message": "Nextcloud Global Site Selector is a tool which allows you to run multiple small Nextcloud instances and redirect users to the right server. A problem in the password verification method allows an attacker to authenticate as another user. It is recommended that the Nextcloud Global Site Selector is upgraded to version 1.4.1, 2.1.2, 2.3.4 or 2.4.5. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2024-22212", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-18T19:15:10.353", "lastModified": "2024-01-26T14:58:18.877", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nextcloud Global Site Selector is a tool which allows you to run multiple small Nextcloud instances and redirect users to the right server. A problem in the password verification method allows an attacker to authenticate as another user. It is recommended that the Nextcloud Global Site Selector is upgraded to version 1.4.1, 2.1.2, 2.3.4 or 2.4.5. There are no known workarounds for this issue."}, {"lang": "es", "value": "Nextcloud Global Site Selector es una herramienta que le permite ejecutar m\u00faltiples instancias peque\u00f1as de Nextcloud y redirigir a los usuarios al servidor correcto. Un problema en el m\u00e9todo de verificaci\u00f3n de contrase\u00f1a permite que un atacante se autentique como otro usuario. Se recomienda actualizar Nextcloud Global Site Selector a la versi\u00f3n 1.4.1, 2.1.2, 2.3.4 o 2.4.5. No se conocen workarounds para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-306"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:global_site_selector:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.4.1", "matchCriteriaId": "2534CD35-8367-48DB-A2F9-25035D763F70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:global_site_selector:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.1.2", "matchCriteriaId": "E217B435-E2A5-4186-9905-898DACA4D502"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:global_site_selector:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.3.4", "matchCriteriaId": "ABAB048C-B643-445F-AECF-DFB4356ED026"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:global_site_selector:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.5", "matchCriteriaId": "214AE852-2C02-45E0-99AD-47886EEB074D"}]}]}], "references": [{"url": "https://github.com/nextcloud/globalsiteselector/commit/ab5da57190d5bbc79079ce4109b6bcccccd893ee", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nextcloud/security-advisories/security/advisories/GHSA-vj5q-f63m-wp77", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://hackerone.com/reports/2248689", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nextcloud/globalsiteselector/commit/ab5da57190d5bbc79079ce4109b6bcccccd893ee"}}