{"buggy_code": ["/*\n * threads.c: Thread support internal calls\n *\n * Author:\n *\tDick Porter (dick@ximian.com)\n *\tPaolo Molaro (lupus@ximian.com)\n *\tPatrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n */\n\n#include <config.h>\n\n#include <glib.h>\n#include <signal.h>\n#include <string.h>\n\n#if defined(__OpenBSD__)\n#include <pthread.h>\n#include <pthread_np.h>\n#endif\n\n#include <mono/metadata/object.h>\n#include <mono/metadata/domain-internals.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/threadpool.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/environment.h>\n#include <mono/metadata/monitor.h>\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/marshal.h>\n#include <mono/io-layer/io-layer.h>\n#ifndef HOST_WIN32\n#include <mono/io-layer/threads.h>\n#endif\n#include <mono/metadata/object-internals.h>\n#include <mono/metadata/mono-debug-debugger.h>\n#include <mono/utils/mono-compiler.h>\n#include <mono/utils/mono-mmap.h>\n#include <mono/utils/mono-membar.h>\n#include <mono/utils/mono-time.h>\n#include <mono/utils/hazard-pointer.h>\n\n#include <mono/metadata/gc-internal.h>\n\n#ifdef PLATFORM_ANDROID\n#include <errno.h>\n\nextern int tkill (pid_t tid, int signal);\n#endif\n\n/*#define THREAD_DEBUG(a) do { a; } while (0)*/\n#define THREAD_DEBUG(a)\n/*#define THREAD_WAIT_DEBUG(a) do { a; } while (0)*/\n#define THREAD_WAIT_DEBUG(a)\n/*#define LIBGC_DEBUG(a) do { a; } while (0)*/\n#define LIBGC_DEBUG(a)\n\n#define SPIN_TRYLOCK(i) (InterlockedCompareExchange (&(i), 1, 0) == 0)\n#define SPIN_LOCK(i) do { \\\n\t\t\t\tif (SPIN_TRYLOCK (i)) \\\n\t\t\t\t\tbreak; \\\n\t\t\t} while (1)\n\n#define SPIN_UNLOCK(i) i = 0\n\n/* Provide this for systems with glib < 2.6 */\n#ifndef G_GSIZE_FORMAT\n#   if GLIB_SIZEOF_LONG == 8\n#       define G_GSIZE_FORMAT \"lu\"\n#   else\n#       define G_GSIZE_FORMAT \"u\"\n#   endif\n#endif\n\nstruct StartInfo \n{\n\tguint32 (*func)(void *);\n\tMonoThread *obj;\n\tMonoObject *delegate;\n\tvoid *start_arg;\n};\n\ntypedef union {\n\tgint32 ival;\n\tgfloat fval;\n} IntFloatUnion;\n\ntypedef union {\n\tgint64 ival;\n\tgdouble fval;\n} LongDoubleUnion;\n \ntypedef struct _MonoThreadDomainTls MonoThreadDomainTls;\nstruct _MonoThreadDomainTls {\n\tMonoThreadDomainTls *next;\n\tguint32 offset;\n\tguint32 size;\n};\n\ntypedef struct {\n\tint idx;\n\tint offset;\n\tMonoThreadDomainTls *freelist;\n} StaticDataInfo;\n\n/* Number of cached culture objects in the MonoThread->cached_culture_info array\n * (per-type): we use the first NUM entries for CultureInfo and the last for\n * UICultureInfo. So the size of the array is really NUM_CACHED_CULTURES * 2.\n */\n#define NUM_CACHED_CULTURES 4\n#define CULTURES_START_IDX 0\n#define UICULTURES_START_IDX NUM_CACHED_CULTURES\n\n/* Controls access to the 'threads' hash table */\n#define mono_threads_lock() EnterCriticalSection (&threads_mutex)\n#define mono_threads_unlock() LeaveCriticalSection (&threads_mutex)\nstatic CRITICAL_SECTION threads_mutex;\n\n/* Controls access to context static data */\n#define mono_contexts_lock() EnterCriticalSection (&contexts_mutex)\n#define mono_contexts_unlock() LeaveCriticalSection (&contexts_mutex)\nstatic CRITICAL_SECTION contexts_mutex;\n\n/* Holds current status of static data heap */\nstatic StaticDataInfo thread_static_info;\nstatic StaticDataInfo context_static_info;\n\n/* The hash of existing threads (key is thread ID, value is\n * MonoInternalThread*) that need joining before exit\n */\nstatic MonoGHashTable *threads=NULL;\n\n/*\n * Threads which are starting up and they are not in the 'threads' hash yet.\n * When handle_store is called for a thread, it will be removed from this hash table.\n * Protected by mono_threads_lock ().\n */\nstatic MonoGHashTable *threads_starting_up = NULL;\n \n/* Maps a MonoThread to its start argument */\n/* Protected by mono_threads_lock () */\nstatic MonoGHashTable *thread_start_args = NULL;\n\n/* The TLS key that holds the MonoObject assigned to each thread */\nstatic guint32 current_object_key = -1;\n\n#ifdef MONO_HAVE_FAST_TLS\n/* we need to use both the Tls* functions and __thread because\n * the gc needs to see all the threads \n */\nMONO_FAST_TLS_DECLARE(tls_current_object);\n#define SET_CURRENT_OBJECT(x) do { \\\n\tMONO_FAST_TLS_SET (tls_current_object, x); \\\n\tTlsSetValue (current_object_key, x); \\\n} while (FALSE)\n#define GET_CURRENT_OBJECT() ((MonoInternalThread*) MONO_FAST_TLS_GET (tls_current_object))\n#else\n#define SET_CURRENT_OBJECT(x) TlsSetValue (current_object_key, x)\n#define GET_CURRENT_OBJECT() (MonoInternalThread*) TlsGetValue (current_object_key)\n#endif\n\n/* function called at thread start */\nstatic MonoThreadStartCB mono_thread_start_cb = NULL;\n\n/* function called at thread attach */\nstatic MonoThreadAttachCB mono_thread_attach_cb = NULL;\n\n/* function called at thread cleanup */\nstatic MonoThreadCleanupFunc mono_thread_cleanup_fn = NULL;\n\n/* function called to notify the runtime about a pending exception on the current thread */\nstatic MonoThreadNotifyPendingExcFunc mono_thread_notify_pending_exc_fn = NULL;\n\n/* The default stack size for each thread */\nstatic guint32 default_stacksize = 0;\n#define default_stacksize_for_thread(thread) ((thread)->stack_size? (thread)->stack_size: default_stacksize)\n\nstatic void thread_adjust_static_data (MonoInternalThread *thread);\nstatic void mono_free_static_data (gpointer* static_data, gboolean threadlocal);\nstatic void mono_init_static_data_info (StaticDataInfo *static_data);\nstatic guint32 mono_alloc_static_data_slot (StaticDataInfo *static_data, guint32 size, guint32 align);\nstatic gboolean mono_thread_resume (MonoInternalThread* thread);\nstatic void mono_thread_start (MonoThread *thread);\nstatic void signal_thread_state_change (MonoInternalThread *thread);\n\nstatic MonoException* mono_thread_execute_interruption (MonoInternalThread *thread);\nstatic void ref_stack_destroy (gpointer rs);\n\n/* Spin lock for InterlockedXXX 64 bit functions */\n#define mono_interlocked_lock() EnterCriticalSection (&interlocked_mutex)\n#define mono_interlocked_unlock() LeaveCriticalSection (&interlocked_mutex)\nstatic CRITICAL_SECTION interlocked_mutex;\n\n/* global count of thread interruptions requested */\nstatic gint32 thread_interruption_requested = 0;\n\n/* Event signaled when a thread changes its background mode */\nstatic HANDLE background_change_event;\n\nstatic gboolean shutting_down = FALSE;\n\nguint32\nmono_thread_get_tls_key (void)\n{\n\treturn current_object_key;\n}\n\ngint32\nmono_thread_get_tls_offset (void)\n{\n\tint offset;\n\tMONO_THREAD_VAR_OFFSET (tls_current_object,offset);\n\treturn offset;\n}\n\n/* handle_store() and handle_remove() manage the array of threads that\n * still need to be waited for when the main thread exits.\n *\n * If handle_store() returns FALSE the thread must not be started\n * because Mono is shutting down.\n */\nstatic gboolean handle_store(MonoThread *thread)\n{\n\tmono_threads_lock ();\n\n\tTHREAD_DEBUG (g_message (\"%s: thread %p ID %\"G_GSIZE_FORMAT, __func__, thread, (gsize)thread->internal_thread->tid));\n\n\tif (threads_starting_up)\n\t\tmono_g_hash_table_remove (threads_starting_up, thread);\n\n\tif (shutting_down) {\n\t\tmono_threads_unlock ();\n\t\treturn FALSE;\n\t}\n\n\tif(threads==NULL) {\n\t\tMONO_GC_REGISTER_ROOT_FIXED (threads);\n\t\tthreads=mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\t}\n\n\t/* We don't need to duplicate thread->handle, because it is\n\t * only closed when the thread object is finalized by the GC.\n\t */\n\tg_assert (thread->internal_thread);\n\tmono_g_hash_table_insert(threads, (gpointer)(gsize)(thread->internal_thread->tid),\n\t\t\t\t thread->internal_thread);\n\n\tmono_threads_unlock ();\n\n\treturn TRUE;\n}\n\nstatic gboolean handle_remove(MonoInternalThread *thread)\n{\n\tgboolean ret;\n\tgsize tid = thread->tid;\n\n\tTHREAD_DEBUG (g_message (\"%s: thread ID %\"G_GSIZE_FORMAT, __func__, tid));\n\n\tmono_threads_lock ();\n\n\tif (threads) {\n\t\t/* We have to check whether the thread object for the\n\t\t * tid is still the same in the table because the\n\t\t * thread might have been destroyed and the tid reused\n\t\t * in the meantime, in which case the tid would be in\n\t\t * the table, but with another thread object.\n\t\t */\n\t\tif (mono_g_hash_table_lookup (threads, (gpointer)tid) == thread) {\n\t\t\tmono_g_hash_table_remove (threads, (gpointer)tid);\n\t\t\tret = TRUE;\n\t\t} else {\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\telse\n\t\tret = FALSE;\n\t\n\tmono_threads_unlock ();\n\n\t/* Don't close the handle here, wait for the object finalizer\n\t * to do it. Otherwise, the following race condition applies:\n\t *\n\t * 1) Thread exits (and handle_remove() closes the handle)\n\t *\n\t * 2) Some other handle is reassigned the same slot\n\t *\n\t * 3) Another thread tries to join the first thread, and\n\t * blocks waiting for the reassigned handle to be signalled\n\t * (which might never happen).  This is possible, because the\n\t * thread calling Join() still has a reference to the first\n\t * thread's object.\n\t */\n\treturn ret;\n}\n\nstatic void ensure_synch_cs_set (MonoInternalThread *thread)\n{\n\tCRITICAL_SECTION *synch_cs;\n\t\n\tif (thread->synch_cs != NULL) {\n\t\treturn;\n\t}\n\t\n\tsynch_cs = g_new0 (CRITICAL_SECTION, 1);\n\tInitializeCriticalSection (synch_cs);\n\t\n\tif (InterlockedCompareExchangePointer ((gpointer *)&thread->synch_cs,\n\t\t\t\t\t       synch_cs, NULL) != NULL) {\n\t\t/* Another thread must have installed this CS */\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n}\n\n/*\n * NOTE: this function can be called also for threads different from the current one:\n * make sure no code called from it will ever assume it is run on the thread that is\n * getting cleaned up.\n */\nstatic void thread_cleanup (MonoInternalThread *thread)\n{\n\tg_assert (thread != NULL);\n\n\tif (thread->abort_state_handle) {\n\t\tmono_gchandle_free (thread->abort_state_handle);\n\t\tthread->abort_state_handle = 0;\n\t}\n\tthread->abort_exc = NULL;\n\tthread->current_appcontext = NULL;\n\n\t/*\n\t * This is necessary because otherwise we might have\n\t * cross-domain references which will not get cleaned up when\n\t * the target domain is unloaded.\n\t */\n\tif (thread->cached_culture_info) {\n\t\tint i;\n\t\tfor (i = 0; i < NUM_CACHED_CULTURES * 2; ++i)\n\t\t\tmono_array_set (thread->cached_culture_info, MonoObject*, i, NULL);\n\t}\n\n\t/* if the thread is not in the hash it has been removed already */\n\tif (!handle_remove (thread)) {\n\t\t/* This needs to be called even if handle_remove () fails */\n\t\tif (mono_thread_cleanup_fn)\n\t\t\tmono_thread_cleanup_fn (thread);\n\t\treturn;\n\t}\n\tmono_release_type_locks (thread);\n\n\tEnterCriticalSection (thread->synch_cs);\n\n\tthread->state |= ThreadState_Stopped;\n\tthread->state &= ~ThreadState_Background;\n\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\tmono_profiler_thread_end (thread->tid);\n\n\tif (thread == mono_thread_internal_current ())\n\t\tmono_thread_pop_appdomain_ref ();\n\n\tthread->cached_culture_info = NULL;\n\n\tmono_free_static_data (thread->static_data, TRUE);\n\tthread->static_data = NULL;\n\tref_stack_destroy (thread->appdomain_refs);\n\tthread->appdomain_refs = NULL;\n\n\tif (mono_thread_cleanup_fn)\n\t\tmono_thread_cleanup_fn (thread);\n\n\tmono_thread_small_id_free (thread->small_id);\n\tMONO_GC_UNREGISTER_ROOT (thread->thread_pinning_ref);\n\tthread->small_id = -2;\n}\n\nstatic gpointer\nget_thread_static_data (MonoInternalThread *thread, guint32 offset)\n{\n\tint idx;\n\tg_assert ((offset & 0x80000000) == 0);\n\toffset &= 0x7fffffff;\n\tidx = (offset >> 24) - 1;\n\treturn ((char*) thread->static_data [idx]) + (offset & 0xffffff);\n}\n\nstatic MonoThread**\nget_current_thread_ptr_for_domain (MonoDomain *domain, MonoInternalThread *thread)\n{\n\tstatic MonoClassField *current_thread_field = NULL;\n\n\tguint32 offset;\n\n\tif (!current_thread_field) {\n\t\tcurrent_thread_field = mono_class_get_field_from_name (mono_defaults.thread_class, \"current_thread\");\n\t\tg_assert (current_thread_field);\n\t}\n\n\tmono_class_vtable (domain, mono_defaults.thread_class);\n\tmono_domain_lock (domain);\n\toffset = GPOINTER_TO_UINT (g_hash_table_lookup (domain->special_static_fields, current_thread_field));\n\tmono_domain_unlock (domain);\n\tg_assert (offset);\n\n\treturn get_thread_static_data (thread, offset);\n}\n\nstatic void\nset_current_thread_for_domain (MonoDomain *domain, MonoInternalThread *thread, MonoThread *current)\n{\n\tMonoThread **current_thread_ptr = get_current_thread_ptr_for_domain (domain, thread);\n\n\tg_assert (current->obj.vtable->domain == domain);\n\n\tg_assert (!*current_thread_ptr);\n\t*current_thread_ptr = current;\n}\n\nstatic MonoInternalThread*\ncreate_internal_thread_object (void)\n{\n\tMonoVTable *vt = mono_class_vtable (mono_get_root_domain (), mono_defaults.internal_thread_class);\n\treturn (MonoInternalThread*)mono_gc_alloc_mature (vt);\n}\n\nstatic MonoThread*\ncreate_thread_object (MonoDomain *domain)\n{\n\tMonoVTable *vt = mono_class_vtable (domain, mono_defaults.thread_class);\n\treturn (MonoThread*)mono_gc_alloc_mature (vt);\n}\n\nstatic MonoThread*\nnew_thread_with_internal (MonoDomain *domain, MonoInternalThread *internal)\n{\n\tMonoThread *thread = create_thread_object (domain);\n\tMONO_OBJECT_SETREF (thread, internal_thread, internal);\n\treturn thread;\n}\n\nstatic void\ninit_root_domain_thread (MonoInternalThread *thread, MonoThread *candidate)\n{\n\tMonoDomain *domain = mono_get_root_domain ();\n\n\tif (!candidate || candidate->obj.vtable->domain != domain)\n\t\tcandidate = new_thread_with_internal (domain, thread);\n\tset_current_thread_for_domain (domain, thread, candidate);\n\tg_assert (!thread->root_domain_thread);\n\tMONO_OBJECT_SETREF (thread, root_domain_thread, candidate);\n}\n\nstatic guint32 WINAPI start_wrapper_internal(void *data)\n{\n\tstruct StartInfo *start_info=(struct StartInfo *)data;\n\tguint32 (*start_func)(void *);\n\tvoid *start_arg;\n\tgsize tid;\n\t/* \n\t * We don't create a local to hold start_info->obj, so hopefully it won't get pinned during a\n\t * GC stack walk.\n\t */\n\tMonoInternalThread *internal = start_info->obj->internal_thread;\n\tMonoObject *start_delegate = start_info->delegate;\n\tMonoDomain *domain = start_info->obj->obj.vtable->domain;\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Start wrapper\", __func__, GetCurrentThreadId ()));\n\n\t/* We can be sure start_info->obj->tid and\n\t * start_info->obj->handle have been set, because the thread\n\t * was created suspended, and these values were set before the\n\t * thread resumed\n\t */\n\n\ttid=internal->tid;\n\n\tSET_CURRENT_OBJECT (internal);\n\n\tmono_monitor_init_tls ();\n\n\t/* Every thread references the appdomain which created it */\n\tmono_thread_push_appdomain_ref (domain);\n\t\n\tif (!mono_domain_set (domain, FALSE)) {\n\t\t/* No point in raising an appdomain_unloaded exception here */\n\t\t/* FIXME: Cleanup here */\n\t\tmono_thread_pop_appdomain_ref ();\n\t\treturn 0;\n\t}\n\n\tstart_func = start_info->func;\n\tstart_arg = start_info->start_arg;\n\n\t/* We have to do this here because mono_thread_new_init()\n\t   requires that root_domain_thread is set up. */\n\tthread_adjust_static_data (internal);\n\tinit_root_domain_thread (internal, start_info->obj);\n\n\t/* This MUST be called before any managed code can be\n\t * executed, as it calls the callback function that (for the\n\t * jit) sets the lmf marker.\n\t */\n\tmono_thread_new_init (tid, &tid, start_func);\n\tinternal->stack_ptr = &tid;\n\n\tLIBGC_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\",%d) Setting thread stack to %p\", __func__, GetCurrentThreadId (), getpid (), thread->stack_ptr));\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Setting current_object_key to %p\", __func__, GetCurrentThreadId (), internal));\n\n\t/* On 2.0 profile (and higher), set explicitly since state might have been\n\t   Unknown */\n\tif (internal->apartment_state == ThreadApartmentState_Unknown)\n\t\tinternal->apartment_state = ThreadApartmentState_MTA;\n\n\tmono_thread_init_apartment_state ();\n\n\tif(internal->start_notify!=NULL) {\n\t\t/* Let the thread that called Start() know we're\n\t\t * ready\n\t\t */\n\t\tReleaseSemaphore (internal->start_notify, 1, NULL);\n\t}\n\n\tmono_threads_lock ();\n\tmono_g_hash_table_remove (thread_start_args, start_info->obj);\n\tmono_threads_unlock ();\n\n\tmono_thread_set_execution_context (start_info->obj->ec_to_set);\n\tstart_info->obj->ec_to_set = NULL;\n\n\tg_free (start_info);\n\tTHREAD_DEBUG (g_message (\"%s: start_wrapper for %\"G_GSIZE_FORMAT, __func__,\n\t\t\t\t\t\t\t internal->tid));\n\n\t/* \n\t * Call this after calling start_notify, since the profiler callback might want\n\t * to lock the thread, and the lock is held by thread_start () which waits for\n\t * start_notify.\n\t */\n\tmono_profiler_thread_start (tid);\n\n\t/* start_func is set only for unmanaged start functions */\n\tif (start_func) {\n\t\tstart_func (start_arg);\n\t} else {\n\t\tvoid *args [1];\n\t\tg_assert (start_delegate != NULL);\n\t\targs [0] = start_arg;\n\t\t/* we may want to handle the exception here. See comment below on unhandled exceptions */\n\t\tmono_runtime_delegate_invoke (start_delegate, args, NULL);\n\t}\n\n\t/* If the thread calls ExitThread at all, this remaining code\n\t * will not be executed, but the main thread will eventually\n\t * call thread_cleanup() on this thread's behalf.\n\t */\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Start wrapper terminating\", __func__, GetCurrentThreadId ()));\n\n\tthread_cleanup (internal);\n\n\t/* Do any cleanup needed for apartment state. This\n\t * cannot be done in thread_cleanup since thread_cleanup could be \n\t * called for a thread other than the current thread.\n\t * mono_thread_cleanup_apartment_state cleans up apartment\n\t * for the current thead */\n\tmono_thread_cleanup_apartment_state ();\n\n\t/* Remove the reference to the thread object in the TLS data,\n\t * so the thread object can be finalized.  This won't be\n\t * reached if the thread threw an uncaught exception, so those\n\t * thread handles will stay referenced :-( (This is due to\n\t * missing support for scanning thread-specific data in the\n\t * Boehm GC - the io-layer keeps a GC-visible hash of pointers\n\t * to TLS data.)\n\t */\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\treturn(0);\n}\n\nstatic guint32 WINAPI start_wrapper(void *data)\n{\n#ifdef HAVE_SGEN_GC\n\tvolatile int dummy;\n\n\t/* Avoid scanning the frames above this frame during a GC */\n\tmono_gc_set_stack_end ((void*)&dummy);\n#endif\n\n\treturn start_wrapper_internal (data);\n}\n\nvoid mono_thread_new_init (intptr_t tid, gpointer stack_start, gpointer func)\n{\n\tif (mono_thread_start_cb) {\n\t\tmono_thread_start_cb (tid, stack_start, func);\n\t}\n}\n\nvoid mono_threads_set_default_stacksize (guint32 stacksize)\n{\n\tdefault_stacksize = stacksize;\n}\n\nguint32 mono_threads_get_default_stacksize (void)\n{\n\treturn default_stacksize;\n}\n\n/*\n * mono_create_thread:\n *\n *   This is a wrapper around CreateThread which handles differences in the type of\n * the the 'tid' argument.\n */\ngpointer mono_create_thread (WapiSecurityAttributes *security,\n\t\t\t\t\t\t\t guint32 stacksize, WapiThreadStart start,\n\t\t\t\t\t\t\t gpointer param, guint32 create, gsize *tid)\n{\n\tgpointer res;\n\n#ifdef HOST_WIN32\n\tDWORD real_tid;\n\n\tres = CreateThread (security, stacksize, start, param, create, &real_tid);\n\tif (tid)\n\t\t*tid = real_tid;\n#else\n\tres = CreateThread (security, stacksize, start, param, create, tid);\n#endif\n\n\treturn res;\n}\n\n/* \n * The thread start argument may be an object reference, and there is\n * no ref to keep it alive when the new thread is started but not yet\n * registered with the collector. So we store it in a GC tracked hash\n * table.\n *\n * LOCKING: Assumes the threads lock is held.\n */\nstatic void\nregister_thread_start_argument (MonoThread *thread, struct StartInfo *start_info)\n{\n\tif (thread_start_args == NULL) {\n\t\tMONO_GC_REGISTER_ROOT_FIXED (thread_start_args);\n\t\tthread_start_args = mono_g_hash_table_new (NULL, NULL);\n\t}\n\tmono_g_hash_table_insert (thread_start_args, thread, start_info->start_arg);\n}\n\nMonoInternalThread* mono_thread_create_internal (MonoDomain *domain, gpointer func, gpointer arg, gboolean threadpool_thread, guint32 stack_size)\n{\n\tMonoThread *thread;\n\tMonoInternalThread *internal;\n\tHANDLE thread_handle;\n\tstruct StartInfo *start_info;\n\tgsize tid;\n\n\tthread = create_thread_object (domain);\n\tinternal = create_internal_thread_object ();\n\tMONO_OBJECT_SETREF (thread, internal_thread, internal);\n\n\tstart_info=g_new0 (struct StartInfo, 1);\n\tstart_info->func = func;\n\tstart_info->obj = thread;\n\tstart_info->start_arg = arg;\n\n\tmono_threads_lock ();\n\tif (shutting_down) {\n\t\tmono_threads_unlock ();\n\t\tg_free (start_info);\n\t\treturn NULL;\n\t}\n\tif (threads_starting_up == NULL) {\n\t\tMONO_GC_REGISTER_ROOT_FIXED (threads_starting_up);\n\t\tthreads_starting_up = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_KEY_VALUE_GC);\n\t}\n\n\tregister_thread_start_argument (thread, start_info);\n \tmono_g_hash_table_insert (threads_starting_up, thread, thread);\n\tmono_threads_unlock ();\t\n\n\tif (stack_size == 0)\n\t\tstack_size = default_stacksize_for_thread (internal);\n\n\t/* Create suspended, so we can do some housekeeping before the thread\n\t * starts\n\t */\n\tthread_handle = mono_create_thread (NULL, stack_size, (LPTHREAD_START_ROUTINE)start_wrapper, start_info,\n\t\t\t\t     CREATE_SUSPENDED, &tid);\n\tTHREAD_DEBUG (g_message (\"%s: Started thread ID %\"G_GSIZE_FORMAT\" (handle %p)\", __func__, tid, thread_handle));\n\tif (thread_handle == NULL) {\n\t\t/* The thread couldn't be created, so throw an exception */\n\t\tmono_threads_lock ();\n\t\tmono_g_hash_table_remove (threads_starting_up, thread);\n\t\tmono_threads_unlock ();\n\t\tg_free (start_info);\n\t\tmono_raise_exception (mono_get_exception_execution_engine (\"Couldn't create thread\"));\n\t\treturn NULL;\n\t}\n\n\tinternal->handle=thread_handle;\n\tinternal->tid=tid;\n\tinternal->apartment_state=ThreadApartmentState_Unknown;\n\tinternal->small_id = mono_thread_small_id_alloc ();\n\tinternal->thread_pinning_ref = internal;\n\tMONO_GC_REGISTER_ROOT (internal->thread_pinning_ref);\n\n\tinternal->synch_cs = g_new0 (CRITICAL_SECTION, 1);\n\tInitializeCriticalSection (internal->synch_cs);\n\n\tinternal->threadpool_thread = threadpool_thread;\n\tif (threadpool_thread)\n\t\tmono_thread_set_state (internal, ThreadState_Background);\n\n\tif (handle_store (thread))\n\t\tResumeThread (thread_handle);\n\n\treturn internal;\n}\n\nvoid\nmono_thread_create (MonoDomain *domain, gpointer func, gpointer arg)\n{\n\tmono_thread_create_internal (domain, func, arg, FALSE, 0);\n}\n\n/*\n * mono_thread_get_stack_bounds:\n *\n *   Return the address and size of the current threads stack. Return NULL as the \n * stack address if the stack address cannot be determined.\n */\nvoid\nmono_thread_get_stack_bounds (guint8 **staddr, size_t *stsize)\n{\n#if defined(HAVE_PTHREAD_GET_STACKSIZE_NP) && defined(HAVE_PTHREAD_GET_STACKADDR_NP)\n\t*staddr = (guint8*)pthread_get_stackaddr_np (pthread_self ());\n\t*stsize = pthread_get_stacksize_np (pthread_self ());\n\t*staddr = (guint8*)((gssize)*staddr & ~(mono_pagesize () - 1));\n\treturn;\n\t/* FIXME: simplify the mess below */\n#elif !defined(HOST_WIN32)\n\tpthread_attr_t attr;\n\tguint8 *current = (guint8*)&attr;\n\n\tpthread_attr_init (&attr);\n#  ifdef HAVE_PTHREAD_GETATTR_NP\n\tpthread_getattr_np (pthread_self(), &attr);\n#  else\n#    ifdef HAVE_PTHREAD_ATTR_GET_NP\n\tpthread_attr_get_np (pthread_self(), &attr);\n#    elif defined(sun)\n\t*staddr = NULL;\n\tpthread_attr_getstacksize (&attr, &stsize);\n#    elif defined(__OpenBSD__)\n\tstack_t ss;\n\tint rslt;\n\n\trslt = pthread_stackseg_np(pthread_self(), &ss);\n\tg_assert (rslt == 0);\n\n\t*staddr = (guint8*)((size_t)ss.ss_sp - ss.ss_size);\n\t*stsize = ss.ss_size;\n#    else\n\t*staddr = NULL;\n\t*stsize = 0;\n\treturn;\n#    endif\n#  endif\n\n#  if !defined(sun)\n#    if !defined(__OpenBSD__)\n\tpthread_attr_getstack (&attr, (void**)staddr, stsize);\n#    endif\n\tif (*staddr)\n\t\tg_assert ((current > *staddr) && (current < *staddr + *stsize));\n#  endif\n\n\tpthread_attr_destroy (&attr);\n#else\n\t*staddr = NULL;\n\t*stsize = (size_t)-1;\n#endif\n\n\t/* When running under emacs, sometimes staddr is not aligned to a page size */\n\t*staddr = (guint8*)((gssize)*staddr & ~(mono_pagesize () - 1));\n}\t\n\nMonoThread *\nmono_thread_attach (MonoDomain *domain)\n{\n\tMonoInternalThread *thread;\n\tMonoThread *current_thread;\n\tHANDLE thread_handle;\n\tgsize tid;\n\n\tif ((thread = mono_thread_internal_current ())) {\n\t\tif (domain != mono_domain_get ())\n\t\t\tmono_domain_set (domain, TRUE);\n\t\t/* Already attached */\n\t\treturn mono_thread_current ();\n\t}\n\n\tif (!mono_gc_register_thread (&domain)) {\n\t\tg_error (\"Thread %\"G_GSIZE_FORMAT\" calling into managed code is not registered with the GC. On UNIX, this can be fixed by #include-ing <gc.h> before <pthread.h> in the file containing the thread creation code.\", GetCurrentThreadId ());\n\t}\n\n\tthread = create_internal_thread_object ();\n\n\tthread_handle = GetCurrentThread ();\n\tg_assert (thread_handle);\n\n\ttid=GetCurrentThreadId ();\n\n\t/* \n\t * The handle returned by GetCurrentThread () is a pseudo handle, so it can't be used to\n\t * refer to the thread from other threads for things like aborting.\n\t */\n\tDuplicateHandle (GetCurrentProcess (), thread_handle, GetCurrentProcess (), &thread_handle, \n\t\t\t\t\t THREAD_ALL_ACCESS, TRUE, 0);\n\n\tthread->handle=thread_handle;\n\tthread->tid=tid;\n#ifdef PLATFORM_ANDROID\n\tthread->android_tid = (gpointer) gettid ();\n#endif\n\tthread->apartment_state=ThreadApartmentState_Unknown;\n\tthread->small_id = mono_thread_small_id_alloc ();\n\tthread->thread_pinning_ref = thread;\n\tMONO_GC_REGISTER_ROOT (thread->thread_pinning_ref);\n\n\tthread->stack_ptr = &tid;\n\n\tthread->synch_cs = g_new0 (CRITICAL_SECTION, 1);\n\tInitializeCriticalSection (thread->synch_cs);\n\n\tTHREAD_DEBUG (g_message (\"%s: Attached thread ID %\"G_GSIZE_FORMAT\" (handle %p)\", __func__, tid, thread_handle));\n\n\tcurrent_thread = new_thread_with_internal (domain, thread);\n\n\tif (!handle_store (current_thread)) {\n\t\t/* Mono is shutting down, so just wait for the end */\n\t\tfor (;;)\n\t\t\tSleep (10000);\n\t}\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Setting current_object_key to %p\", __func__, GetCurrentThreadId (), thread));\n\n\tSET_CURRENT_OBJECT (thread);\n\tmono_domain_set (domain, TRUE);\n\n\tmono_monitor_init_tls ();\n\n\tthread_adjust_static_data (thread);\n\n\tinit_root_domain_thread (thread, current_thread);\n\tif (domain != mono_get_root_domain ())\n\t\tset_current_thread_for_domain (domain, thread, current_thread);\n\n\n\tif (mono_thread_attach_cb) {\n\t\tguint8 *staddr;\n\t\tsize_t stsize;\n\n\t\tmono_thread_get_stack_bounds (&staddr, &stsize);\n\n\t\tif (staddr == NULL)\n\t\t\tmono_thread_attach_cb (tid, &tid);\n\t\telse\n\t\t\tmono_thread_attach_cb (tid, staddr + stsize);\n\t}\n\n\t// FIXME: Need a separate callback\n\tmono_profiler_thread_start (tid);\n\n\treturn current_thread;\n}\n\nvoid\nmono_thread_detach (MonoThread *thread)\n{\n\tg_return_if_fail (thread != NULL);\n\n\tTHREAD_DEBUG (g_message (\"%s: mono_thread_detach for %p (%\"G_GSIZE_FORMAT\")\", __func__, thread, (gsize)thread->internal_thread->tid));\n\t\n\tthread_cleanup (thread->internal_thread);\n\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\t/* Don't need to CloseHandle this thread, even though we took a\n\t * reference in mono_thread_attach (), because the GC will do it\n\t * when the Thread object is finalised.\n\t */\n}\n\nvoid\nmono_thread_exit ()\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_DEBUG (g_message (\"%s: mono_thread_exit for %p (%\"G_GSIZE_FORMAT\")\", __func__, thread, (gsize)thread->tid));\n\n\tthread_cleanup (thread);\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\t/* we could add a callback here for embedders to use. */\n\tif (mono_thread_get_main () && (thread == mono_thread_get_main ()->internal_thread))\n\t\texit (mono_environment_exitcode_get ());\n\tExitThread (-1);\n}\n\nvoid\nves_icall_System_Threading_Thread_ConstructInternalThread (MonoThread *this)\n{\n\tMonoInternalThread *internal = create_internal_thread_object ();\n\n\tinternal->state = ThreadState_Unstarted;\n\tinternal->apartment_state = ThreadApartmentState_Unknown;\n\n\tInterlockedCompareExchangePointer ((gpointer)&this->internal_thread, internal, NULL);\n}\n\nHANDLE ves_icall_System_Threading_Thread_Thread_internal(MonoThread *this,\n\t\t\t\t\t\t\t MonoObject *start)\n{\n\tguint32 (*start_func)(void *);\n\tstruct StartInfo *start_info;\n\tHANDLE thread;\n\tgsize tid;\n\tMonoInternalThread *internal;\n\n\tTHREAD_DEBUG (g_message(\"%s: Trying to start a new thread: this (%p) start (%p)\", __func__, this, start));\n\n\tif (!this->internal_thread)\n\t\tves_icall_System_Threading_Thread_ConstructInternalThread (this);\n\tinternal = this->internal_thread;\n\n\tensure_synch_cs_set (internal);\n\n\tEnterCriticalSection (internal->synch_cs);\n\n\tif ((internal->state & ThreadState_Unstarted) == 0) {\n\t\tLeaveCriticalSection (internal->synch_cs);\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has already been started.\"));\n\t\treturn NULL;\n\t}\n\n\tinternal->small_id = -1;\n\n\tif ((internal->state & ThreadState_Aborted) != 0) {\n\t\tLeaveCriticalSection (internal->synch_cs);\n\t\treturn this;\n\t}\n\tstart_func = NULL;\n\t{\n\t\t/* This is freed in start_wrapper */\n\t\tstart_info = g_new0 (struct StartInfo, 1);\n\t\tstart_info->func = start_func;\n\t\tstart_info->start_arg = this->start_obj; /* FIXME: GC object stored in unmanaged memory */\n\t\tstart_info->delegate = start;\n\t\tstart_info->obj = this;\n\t\tg_assert (this->obj.vtable->domain == mono_domain_get ());\n\n\t\tinternal->start_notify=CreateSemaphore (NULL, 0, 0x7fffffff, NULL);\n\t\tif (internal->start_notify==NULL) {\n\t\t\tLeaveCriticalSection (internal->synch_cs);\n\t\t\tg_warning (\"%s: CreateSemaphore error 0x%x\", __func__, GetLastError ());\n\t\t\tg_free (start_info);\n\t\t\treturn(NULL);\n\t\t}\n\n\t\tmono_threads_lock ();\n\t\tregister_thread_start_argument (this, start_info);\n\t\tif (threads_starting_up == NULL) {\n\t\t\tMONO_GC_REGISTER_ROOT_FIXED (threads_starting_up);\n\t\t\tthreads_starting_up = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_KEY_VALUE_GC);\n\t\t}\n\t\tmono_g_hash_table_insert (threads_starting_up, this, this);\n\t\tmono_threads_unlock ();\t\n\n\t\tthread=mono_create_thread(NULL, default_stacksize_for_thread (internal), (LPTHREAD_START_ROUTINE)start_wrapper, start_info,\n\t\t\t\t    CREATE_SUSPENDED, &tid);\n\t\tif(thread==NULL) {\n\t\t\tLeaveCriticalSection (internal->synch_cs);\n\t\t\tmono_threads_lock ();\n\t\t\tmono_g_hash_table_remove (threads_starting_up, this);\n\t\t\tmono_threads_unlock ();\n\t\t\tg_warning(\"%s: CreateThread error 0x%x\", __func__, GetLastError());\n\t\t\treturn(NULL);\n\t\t}\n\t\t\n\t\tinternal->handle=thread;\n\t\tinternal->tid=tid;\n\t\tinternal->small_id = mono_thread_small_id_alloc ();\n\t\tinternal->thread_pinning_ref = internal;\n\t\tMONO_GC_REGISTER_ROOT (internal->thread_pinning_ref);\n\t\t\n\n\t\t/* Don't call handle_store() here, delay it to Start.\n\t\t * We can't join a thread (trying to will just block\n\t\t * forever) until it actually starts running, so don't\n\t\t * store the handle till then.\n\t\t */\n\n\t\tmono_thread_start (this);\n\t\t\n\t\tinternal->state &= ~ThreadState_Unstarted;\n\n\t\tTHREAD_DEBUG (g_message (\"%s: Started thread ID %\"G_GSIZE_FORMAT\" (handle %p)\", __func__, tid, thread));\n\n\t\tLeaveCriticalSection (internal->synch_cs);\n\t\treturn(thread);\n\t}\n}\n\nvoid ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}\n\nstatic void mono_thread_start (MonoThread *thread)\n{\n\tMonoInternalThread *internal = thread->internal_thread;\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Launching thread %p (%\"G_GSIZE_FORMAT\")\", __func__, GetCurrentThreadId (), internal, (gsize)internal->tid));\n\n\t/* Only store the handle when the thread is about to be\n\t * launched, to avoid the main thread deadlocking while trying\n\t * to clean up a thread that will never be signalled.\n\t */\n\tif (!handle_store (thread))\n\t\treturn;\n\n\tResumeThread (internal->handle);\n\n\tif(internal->start_notify!=NULL) {\n\t\t/* Wait for the thread to set up its TLS data etc, so\n\t\t * theres no potential race condition if someone tries\n\t\t * to look up the data believing the thread has\n\t\t * started\n\t\t */\n\n\t\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") waiting for thread %p (%\"G_GSIZE_FORMAT\") to start\", __func__, GetCurrentThreadId (), internal, (gsize)internal->tid));\n\n\t\tWaitForSingleObjectEx (internal->start_notify, INFINITE, FALSE);\n\t\tCloseHandle (internal->start_notify);\n\t\tinternal->start_notify = NULL;\n\t}\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Done launching thread %p (%\"G_GSIZE_FORMAT\")\", __func__, GetCurrentThreadId (), internal, (gsize)internal->tid));\n}\n\nvoid ves_icall_System_Threading_Thread_Sleep_internal(gint32 ms)\n{\n\tguint32 res;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_DEBUG (g_message (\"%s: Sleeping for %d ms\", __func__, ms));\n\n\tmono_thread_current_check_pending_interrupt ();\n\t\n\twhile (TRUE) {\n\t\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\t\tres = SleepEx(ms,TRUE);\n\t\n\t\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\t\tif (res == WAIT_IO_COMPLETION) { /* we might have been interrupted */\n\t\t\tMonoException* exc = mono_thread_execute_interruption (thread);\n\t\t\tif (exc) {\n\t\t\t\tmono_raise_exception (exc);\n\t\t\t} else {\n\t\t\t\t// FIXME: !INFINITE\n\t\t\t\tif (ms != INFINITE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ves_icall_System_Threading_Thread_SpinWait_nop (void)\n{\n}\n\ngint32\nves_icall_System_Threading_Thread_GetDomainID (void) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_domain_get()->domain_id;\n}\n\ngboolean \nves_icall_System_Threading_Thread_Yield (void)\n{\n#ifdef HOST_WIN32\n\treturn SwitchToThread ();\n#else\n\treturn sched_yield () == 0;\n#endif\n}\n\n/*\n * mono_thread_get_name:\n *\n *   Return the name of the thread. NAME_LEN is set to the length of the name.\n * Return NULL if the thread has no name. The returned memory is owned by the\n * caller.\n */\ngunichar2*\nmono_thread_get_name (MonoInternalThread *this_obj, guint32 *name_len)\n{\n\tgunichar2 *res;\n\n\tensure_synch_cs_set (this_obj);\n\t\n\tEnterCriticalSection (this_obj->synch_cs);\n\t\n\tif (!this_obj->name) {\n\t\t*name_len = 0;\n\t\tres = NULL;\n\t} else {\n\t\t*name_len = this_obj->name_len;\n\t\tres = g_new (gunichar2, this_obj->name_len);\n\t\tmemcpy (res, this_obj->name, sizeof (gunichar2) * this_obj->name_len);\n\t}\n\t\n\tLeaveCriticalSection (this_obj->synch_cs);\n\n\treturn res;\n}\n\nMonoString* \nves_icall_System_Threading_Thread_GetName_internal (MonoInternalThread *this_obj)\n{\n\tMonoString* str;\n\n\tensure_synch_cs_set (this_obj);\n\t\n\tEnterCriticalSection (this_obj->synch_cs);\n\t\n\tif (!this_obj->name)\n\t\tstr = NULL;\n\telse\n\t\tstr = mono_string_new_utf16 (mono_domain_get (), this_obj->name, this_obj->name_len);\n\t\n\tLeaveCriticalSection (this_obj->synch_cs);\n\t\n\treturn str;\n}\n\nvoid \nves_icall_System_Threading_Thread_SetName_internal (MonoInternalThread *this_obj, MonoString *name)\n{\n\tensure_synch_cs_set (this_obj);\n\t\n\tEnterCriticalSection (this_obj->synch_cs);\n\t\n\tif (this_obj->name) {\n\t\tLeaveCriticalSection (this_obj->synch_cs);\n\t\t\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"Thread.Name can only be set once.\"));\n\t\treturn;\n\t}\n\tif (name) {\n\t\tthis_obj->name = g_new (gunichar2, mono_string_length (name));\n\t\tmemcpy (this_obj->name, mono_string_chars (name), mono_string_length (name) * 2);\n\t\tthis_obj->name_len = mono_string_length (name);\n\t}\n\telse\n\t\tthis_obj->name = NULL;\n\t\n\tLeaveCriticalSection (this_obj->synch_cs);\n\tif (this_obj->name) {\n\t\tchar *tname = mono_string_to_utf8 (name);\n\t\tmono_profiler_thread_name (this_obj->tid, tname);\n\t\tmono_free (tname);\n\t}\n}\n\n/* If the array is already in the requested domain, we just return it,\n   otherwise we return a copy in that domain. */\nstatic MonoArray*\nbyte_array_to_domain (MonoArray *arr, MonoDomain *domain)\n{\n\tMonoArray *copy;\n\n\tif (!arr)\n\t\treturn NULL;\n\n\tif (mono_object_domain (arr) == domain)\n\t\treturn arr;\n\n\tcopy = mono_array_new (domain, mono_defaults.byte_class, arr->max_length);\n\tmemcpy (mono_array_addr (copy, guint8, 0), mono_array_addr (arr, guint8, 0), arr->max_length);\n\treturn copy;\n}\n\nMonoArray*\nves_icall_System_Threading_Thread_ByteArrayToRootDomain (MonoArray *arr)\n{\n\treturn byte_array_to_domain (arr, mono_get_root_domain ());\n}\n\nMonoArray*\nves_icall_System_Threading_Thread_ByteArrayToCurrentDomain (MonoArray *arr)\n{\n\treturn byte_array_to_domain (arr, mono_domain_get ());\n}\n\nMonoThread *\nmono_thread_current (void)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoInternalThread *internal = mono_thread_internal_current ();\n\tMonoThread **current_thread_ptr;\n\n\tg_assert (internal);\n\tcurrent_thread_ptr = get_current_thread_ptr_for_domain (domain, internal);\n\n\tif (!*current_thread_ptr) {\n\t\tg_assert (domain != mono_get_root_domain ());\n\t\t*current_thread_ptr = new_thread_with_internal (domain, internal);\n\t}\n\treturn *current_thread_ptr;\n}\n\nMonoInternalThread*\nmono_thread_internal_current (void)\n{\n\tMonoInternalThread *res = GET_CURRENT_OBJECT ();\n\tTHREAD_DEBUG (g_message (\"%s: returning %p\", __func__, res));\n\treturn res;\n}\n\ngboolean ves_icall_System_Threading_Thread_Join_internal(MonoInternalThread *this,\n\t\t\t\t\t\t\t int ms, HANDLE thread)\n{\n\tMonoInternalThread *cur_thread = mono_thread_internal_current ();\n\tgboolean ret;\n\n\tmono_thread_current_check_pending_interrupt ();\n\n\tensure_synch_cs_set (this);\n\t\n\tEnterCriticalSection (this->synch_cs);\n\t\n\tif ((this->state & ThreadState_Unstarted) != 0) {\n\t\tLeaveCriticalSection (this->synch_cs);\n\t\t\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has not been started.\"));\n\t\treturn FALSE;\n\t}\n\n\tLeaveCriticalSection (this->synch_cs);\n\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\tTHREAD_DEBUG (g_message (\"%s: joining thread handle %p, %d ms\", __func__, thread, ms));\n\t\n\tmono_thread_set_state (cur_thread, ThreadState_WaitSleepJoin);\n\n\tret=WaitForSingleObjectEx (thread, ms, TRUE);\n\n\tmono_thread_clr_state (cur_thread, ThreadState_WaitSleepJoin);\n\t\n\tif(ret==WAIT_OBJECT_0) {\n\t\tTHREAD_DEBUG (g_message (\"%s: join successful\", __func__));\n\n\t\treturn(TRUE);\n\t}\n\t\n\tTHREAD_DEBUG (g_message (\"%s: join failed\", __func__));\n\n\treturn(FALSE);\n}\n\n/* FIXME: exitContext isnt documented */\ngboolean ves_icall_System_Threading_WaitHandle_WaitAll_internal(MonoArray *mono_handles, gint32 ms, gboolean exitContext)\n{\n\tHANDLE *handles;\n\tguint32 numhandles;\n\tguint32 ret;\n\tguint32 i;\n\tMonoObject *waitHandle;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* Do this WaitSleepJoin check before creating objects */\n\tmono_thread_current_check_pending_interrupt ();\n\n\tnumhandles = mono_array_length(mono_handles);\n\thandles = g_new0(HANDLE, numhandles);\n\n\tfor(i = 0; i < numhandles; i++) {\t\n\t\twaitHandle = mono_array_get(mono_handles, MonoObject*, i);\n\t\thandles [i] = mono_wait_handle_get_handle ((MonoWaitHandle *) waitHandle);\n\t}\n\t\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tret=WaitForMultipleObjectsEx(numhandles, handles, TRUE, ms, TRUE);\n\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\tg_free(handles);\n\n\tif(ret==WAIT_FAILED) {\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait failed\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t} else if(ret==WAIT_TIMEOUT || ret == WAIT_IO_COMPLETION) {\n\t\t/* Do we want to try again if we get\n\t\t * WAIT_IO_COMPLETION? The documentation for\n\t\t * WaitHandle doesn't give any clues.  (We'd have to\n\t\t * fiddle with the timeout if we retry.)\n\t\t */\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait timed out\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t}\n\t\n\treturn(TRUE);\n}\n\n/* FIXME: exitContext isnt documented */\ngint32 ves_icall_System_Threading_WaitHandle_WaitAny_internal(MonoArray *mono_handles, gint32 ms, gboolean exitContext)\n{\n\tHANDLE handles [MAXIMUM_WAIT_OBJECTS];\n\tguint32 numhandles;\n\tguint32 ret;\n\tguint32 i;\n\tMonoObject *waitHandle;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tguint32 start;\n\n\t/* Do this WaitSleepJoin check before creating objects */\n\tmono_thread_current_check_pending_interrupt ();\n\n\tnumhandles = mono_array_length(mono_handles);\n\tif (numhandles > MAXIMUM_WAIT_OBJECTS)\n\t\treturn WAIT_FAILED;\n\n\tfor(i = 0; i < numhandles; i++) {\t\n\t\twaitHandle = mono_array_get(mono_handles, MonoObject*, i);\n\t\thandles [i] = mono_wait_handle_get_handle ((MonoWaitHandle *) waitHandle);\n\t}\n\t\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\n\tstart = (ms == -1) ? 0 : mono_msec_ticks ();\n\tdo {\n\t\tret = WaitForMultipleObjectsEx (numhandles, handles, FALSE, ms, TRUE);\n\t\tif (ret != WAIT_IO_COMPLETION)\n\t\t\tbreak;\n\t\tif (ms != -1) {\n\t\t\tguint32 diff;\n\n\t\t\tdiff = mono_msec_ticks () - start;\n\t\t\tms -= diff;\n\t\t\tif (ms <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} while (ms == -1 || ms > 0);\n\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") returning %d\", __func__, GetCurrentThreadId (), ret));\n\n\t/*\n\t * These need to be here.  See MSDN dos on WaitForMultipleObjects.\n\t */\n\tif (ret >= WAIT_OBJECT_0 && ret <= WAIT_OBJECT_0 + numhandles - 1) {\n\t\treturn ret - WAIT_OBJECT_0;\n\t}\n\telse if (ret >= WAIT_ABANDONED_0 && ret <= WAIT_ABANDONED_0 + numhandles - 1) {\n\t\treturn ret - WAIT_ABANDONED_0;\n\t}\n\telse {\n\t\treturn ret;\n\t}\n}\n\n/* FIXME: exitContext isnt documented */\ngboolean ves_icall_System_Threading_WaitHandle_WaitOne_internal(MonoObject *this, HANDLE handle, gint32 ms, gboolean exitContext)\n{\n\tguint32 ret;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") waiting for %p, %d ms\", __func__, GetCurrentThreadId (), handle, ms));\n\t\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\t\n\tmono_thread_current_check_pending_interrupt ();\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tret=WaitForSingleObjectEx (handle, ms, TRUE);\n\t\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tif(ret==WAIT_FAILED) {\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait failed\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t} else if(ret==WAIT_TIMEOUT || ret == WAIT_IO_COMPLETION) {\n\t\t/* Do we want to try again if we get\n\t\t * WAIT_IO_COMPLETION? The documentation for\n\t\t * WaitHandle doesn't give any clues.  (We'd have to\n\t\t * fiddle with the timeout if we retry.)\n\t\t */\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait timed out\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t}\n\t\n\treturn(TRUE);\n}\n\ngboolean\nves_icall_System_Threading_WaitHandle_SignalAndWait_Internal (HANDLE toSignal, HANDLE toWait, gint32 ms, gboolean exitContext)\n{\n\tguint32 ret;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (ms == -1)\n\t\tms = INFINITE;\n\n\tmono_thread_current_check_pending_interrupt ();\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tret = SignalObjectAndWait (toSignal, toWait, ms, TRUE);\n\t\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\treturn  (!(ret == WAIT_TIMEOUT || ret == WAIT_IO_COMPLETION || ret == WAIT_FAILED));\n}\n\nHANDLE ves_icall_System_Threading_Mutex_CreateMutex_internal (MonoBoolean owned, MonoString *name, MonoBoolean *created)\n{ \n\tHANDLE mutex;\n\t\n\tMONO_ARCH_SAVE_REGS;\n   \n\t*created = TRUE;\n\t\n\tif (name == NULL) {\n\t\tmutex = CreateMutex (NULL, owned, NULL);\n\t} else {\n\t\tmutex = CreateMutex (NULL, owned, mono_string_chars (name));\n\t\t\n\t\tif (GetLastError () == ERROR_ALREADY_EXISTS) {\n\t\t\t*created = FALSE;\n\t\t}\n\t}\n\n\treturn(mutex);\n}                                                                   \n\nMonoBoolean ves_icall_System_Threading_Mutex_ReleaseMutex_internal (HANDLE handle ) { \n\tMONO_ARCH_SAVE_REGS;\n\n\treturn(ReleaseMutex (handle));\n}\n\nHANDLE ves_icall_System_Threading_Mutex_OpenMutex_internal (MonoString *name,\n\t\t\t\t\t\t\t    gint32 rights,\n\t\t\t\t\t\t\t    gint32 *error)\n{\n\tHANDLE ret;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\t\n\t*error = ERROR_SUCCESS;\n\t\n\tret = OpenMutex (rights, FALSE, mono_string_chars (name));\n\tif (ret == NULL) {\n\t\t*error = GetLastError ();\n\t}\n\t\n\treturn(ret);\n}\n\n\nHANDLE ves_icall_System_Threading_Semaphore_CreateSemaphore_internal (gint32 initialCount, gint32 maximumCount, MonoString *name, MonoBoolean *created)\n{ \n\tHANDLE sem;\n\t\n\tMONO_ARCH_SAVE_REGS;\n   \n\t*created = TRUE;\n\t\n\tif (name == NULL) {\n\t\tsem = CreateSemaphore (NULL, initialCount, maximumCount, NULL);\n\t} else {\n\t\tsem = CreateSemaphore (NULL, initialCount, maximumCount,\n\t\t\t\t       mono_string_chars (name));\n\t\t\n\t\tif (GetLastError () == ERROR_ALREADY_EXISTS) {\n\t\t\t*created = FALSE;\n\t\t}\n\t}\n\n\treturn(sem);\n}                                                                   \n\ngint32 ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal (HANDLE handle, gint32 releaseCount, MonoBoolean *fail)\n{ \n\tgint32 prevcount;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\t*fail = !ReleaseSemaphore (handle, releaseCount, &prevcount);\n\n\treturn (prevcount);\n}\n\nHANDLE ves_icall_System_Threading_Semaphore_OpenSemaphore_internal (MonoString *name, gint32 rights, gint32 *error)\n{\n\tHANDLE ret;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\t\n\t*error = ERROR_SUCCESS;\n\t\n\tret = OpenSemaphore (rights, FALSE, mono_string_chars (name));\n\tif (ret == NULL) {\n\t\t*error = GetLastError ();\n\t}\n\t\n\treturn(ret);\n}\n\nHANDLE ves_icall_System_Threading_Events_CreateEvent_internal (MonoBoolean manual, MonoBoolean initial, MonoString *name, MonoBoolean *created)\n{\n\tHANDLE event;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\t*created = TRUE;\n\n\tif (name == NULL) {\n\t\tevent = CreateEvent (NULL, manual, initial, NULL);\n\t} else {\n\t\tevent = CreateEvent (NULL, manual, initial,\n\t\t\t\t     mono_string_chars (name));\n\t\t\n\t\tif (GetLastError () == ERROR_ALREADY_EXISTS) {\n\t\t\t*created = FALSE;\n\t\t}\n\t}\n\t\n\treturn(event);\n}\n\ngboolean ves_icall_System_Threading_Events_SetEvent_internal (HANDLE handle) {\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (SetEvent(handle));\n}\n\ngboolean ves_icall_System_Threading_Events_ResetEvent_internal (HANDLE handle) {\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (ResetEvent(handle));\n}\n\nvoid\nves_icall_System_Threading_Events_CloseEvent_internal (HANDLE handle) {\n\tMONO_ARCH_SAVE_REGS;\n\n\tCloseHandle (handle);\n}\n\nHANDLE ves_icall_System_Threading_Events_OpenEvent_internal (MonoString *name,\n\t\t\t\t\t\t\t     gint32 rights,\n\t\t\t\t\t\t\t     gint32 *error)\n{\n\tHANDLE ret;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\t\n\t*error = ERROR_SUCCESS;\n\t\n\tret = OpenEvent (rights, FALSE, mono_string_chars (name));\n\tif (ret == NULL) {\n\t\t*error = GetLastError ();\n\t}\n\t\n\treturn(ret);\n}\n\ngint32 ves_icall_System_Threading_Interlocked_Increment_Int (gint32 *location)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedIncrement (location);\n}\n\ngint64 ves_icall_System_Threading_Interlocked_Increment_Long (gint64 *location)\n{\n\tgint64 ret;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_interlocked_lock ();\n\n\tret = ++ *location;\n\t\n\tmono_interlocked_unlock ();\n\n\t\n\treturn ret;\n}\n\ngint32 ves_icall_System_Threading_Interlocked_Decrement_Int (gint32 *location)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedDecrement(location);\n}\n\ngint64 ves_icall_System_Threading_Interlocked_Decrement_Long (gint64 * location)\n{\n\tgint64 ret;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_interlocked_lock ();\n\n\tret = -- *location;\n\t\n\tmono_interlocked_unlock ();\n\n\treturn ret;\n}\n\ngint32 ves_icall_System_Threading_Interlocked_Exchange_Int (gint32 *location, gint32 value)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedExchange(location, value);\n}\n\nMonoObject * ves_icall_System_Threading_Interlocked_Exchange_Object (MonoObject **location, MonoObject *value)\n{\n\tMonoObject *res;\n\tres = (MonoObject *) InterlockedExchangePointer((gpointer *) location, value);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\ngpointer ves_icall_System_Threading_Interlocked_Exchange_IntPtr (gpointer *location, gpointer value)\n{\n\treturn InterlockedExchangePointer(location, value);\n}\n\ngfloat ves_icall_System_Threading_Interlocked_Exchange_Single (gfloat *location, gfloat value)\n{\n\tIntFloatUnion val, ret;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tval.fval = value;\n\tret.ival = InterlockedExchange((gint32 *) location, val.ival);\n\n\treturn ret.fval;\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_Exchange_Long (gint64 *location, gint64 value)\n{\n#if SIZEOF_VOID_P == 8\n\treturn (gint64) InterlockedExchangePointer((gpointer *) location, (gpointer)value);\n#else\n\tgint64 res;\n\n\t/* \n\t * According to MSDN, this function is only atomic with regards to the \n\t * other Interlocked functions on 32 bit platforms.\n\t */\n\tmono_interlocked_lock ();\n\tres = *location;\n\t*location = value;\n\tmono_interlocked_unlock ();\n\n\treturn res;\n#endif\n}\n\ngdouble \nves_icall_System_Threading_Interlocked_Exchange_Double (gdouble *location, gdouble value)\n{\n#if SIZEOF_VOID_P == 8\n\tLongDoubleUnion val, ret;\n\n\tval.fval = value;\n\tret.ival = (gint64)InterlockedExchangePointer((gpointer *) location, (gpointer)val.ival);\n\n\treturn ret.fval;\n#else\n\tgdouble res;\n\n\t/* \n\t * According to MSDN, this function is only atomic with regards to the \n\t * other Interlocked functions on 32 bit platforms.\n\t */\n\tmono_interlocked_lock ();\n\tres = *location;\n\t*location = value;\n\tmono_interlocked_unlock ();\n\n\treturn res;\n#endif\n}\n\ngint32 ves_icall_System_Threading_Interlocked_CompareExchange_Int(gint32 *location, gint32 value, gint32 comparand)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedCompareExchange(location, value, comparand);\n}\n\nMonoObject * ves_icall_System_Threading_Interlocked_CompareExchange_Object (MonoObject **location, MonoObject *value, MonoObject *comparand)\n{\n\tMonoObject *res;\n\tres = (MonoObject *) InterlockedCompareExchangePointer((gpointer *) location, value, comparand);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\ngpointer ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr(gpointer *location, gpointer value, gpointer comparand)\n{\n\treturn InterlockedCompareExchangePointer(location, value, comparand);\n}\n\ngfloat ves_icall_System_Threading_Interlocked_CompareExchange_Single (gfloat *location, gfloat value, gfloat comparand)\n{\n\tIntFloatUnion val, ret, cmp;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tval.fval = value;\n\tcmp.fval = comparand;\n\tret.ival = InterlockedCompareExchange((gint32 *) location, val.ival, cmp.ival);\n\n\treturn ret.fval;\n}\n\ngdouble\nves_icall_System_Threading_Interlocked_CompareExchange_Double (gdouble *location, gdouble value, gdouble comparand)\n{\n#if SIZEOF_VOID_P == 8\n\tLongDoubleUnion val, comp, ret;\n\n\tval.fval = value;\n\tcomp.fval = comparand;\n\tret.ival = (gint64)InterlockedCompareExchangePointer((gpointer *) location, (gpointer)val.ival, (gpointer)comp.ival);\n\n\treturn ret.fval;\n#else\n\tgdouble old;\n\n\tmono_interlocked_lock ();\n\told = *location;\n\tif (old == comparand)\n\t\t*location = value;\n\tmono_interlocked_unlock ();\n\n\treturn old;\n#endif\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_CompareExchange_Long (gint64 *location, gint64 value, gint64 comparand)\n{\n#if SIZEOF_VOID_P == 8\n\treturn (gint64)InterlockedCompareExchangePointer((gpointer *) location, (gpointer)value, (gpointer)comparand);\n#else\n\tgint64 old;\n\n\tmono_interlocked_lock ();\n\told = *location;\n\tif (old == comparand)\n\t\t*location = value;\n\tmono_interlocked_unlock ();\n\t\n\treturn old;\n#endif\n}\n\nMonoObject*\nves_icall_System_Threading_Interlocked_CompareExchange_T (MonoObject **location, MonoObject *value, MonoObject *comparand)\n{\n\tMonoObject *res;\n\tres = InterlockedCompareExchangePointer ((gpointer *)location, value, comparand);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\nMonoObject*\nves_icall_System_Threading_Interlocked_Exchange_T (MonoObject **location, MonoObject *value)\n{\n\tMonoObject *res;\n\tres = InterlockedExchangePointer ((gpointer *)location, value);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\ngint32 \nves_icall_System_Threading_Interlocked_Add_Int (gint32 *location, gint32 value)\n{\n#if SIZEOF_VOID_P == 8\n\t/* Should be implemented as a JIT intrinsic */\n\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\treturn 0;\n#else\n\tgint32 orig;\n\n\tmono_interlocked_lock ();\n\torig = *location;\n\t*location = orig + value;\n\tmono_interlocked_unlock ();\n\n\treturn orig + value;\n#endif\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_Add_Long (gint64 *location, gint64 value)\n{\n#if SIZEOF_VOID_P == 8\n\t/* Should be implemented as a JIT intrinsic */\n\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\treturn 0;\n#else\n\tgint64 orig;\n\n\tmono_interlocked_lock ();\n\torig = *location;\n\t*location = orig + value;\n\tmono_interlocked_unlock ();\n\n\treturn orig + value;\n#endif\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_Read_Long (gint64 *location)\n{\n#if SIZEOF_VOID_P == 8\n\t/* 64 bit reads are already atomic */\n\treturn *location;\n#else\n\tgint64 res;\n\n\tmono_interlocked_lock ();\n\tres = *location;\n\tmono_interlocked_unlock ();\n\n\treturn res;\n#endif\n}\n\nvoid\nves_icall_System_Threading_Thread_MemoryBarrier (void)\n{\n\tmono_threads_lock ();\n\tmono_threads_unlock ();\n}\n\nvoid\nves_icall_System_Threading_Thread_ClrState (MonoInternalThread* this, guint32 state)\n{\n\tmono_thread_clr_state (this, state);\n\n\tif (state & ThreadState_Background) {\n\t\t/* If the thread changes the background mode, the main thread has to\n\t\t * be notified, since it has to rebuild the list of threads to\n\t\t * wait for.\n\t\t */\n\t\tSetEvent (background_change_event);\n\t}\n}\n\nvoid\nves_icall_System_Threading_Thread_SetState (MonoInternalThread* this, guint32 state)\n{\n\tmono_thread_set_state (this, state);\n\t\n\tif (state & ThreadState_Background) {\n\t\t/* If the thread changes the background mode, the main thread has to\n\t\t * be notified, since it has to rebuild the list of threads to\n\t\t * wait for.\n\t\t */\n\t\tSetEvent (background_change_event);\n\t}\n}\n\nguint32\nves_icall_System_Threading_Thread_GetState (MonoInternalThread* this)\n{\n\tguint32 state;\n\n\tensure_synch_cs_set (this);\n\t\n\tEnterCriticalSection (this->synch_cs);\n\t\n\tstate = this->state;\n\n\tLeaveCriticalSection (this->synch_cs);\n\t\n\treturn state;\n}\n\nvoid ves_icall_System_Threading_Thread_Interrupt_internal (MonoInternalThread *this)\n{\n\tgboolean throw = FALSE;\n\t\n\tensure_synch_cs_set (this);\n\n\tif (this == mono_thread_internal_current ())\n\t\treturn;\n\t\n\tEnterCriticalSection (this->synch_cs);\n\t\n\tthis->thread_interrupt_requested = TRUE;\n\t\n\tif (this->state & ThreadState_WaitSleepJoin) {\n\t\tthrow = TRUE;\n\t}\n\t\n\tLeaveCriticalSection (this->synch_cs);\n\t\n\tif (throw) {\n\t\tsignal_thread_state_change (this);\n\t}\n}\n\nvoid mono_thread_current_check_pending_interrupt ()\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tgboolean throw = FALSE;\n\n\tmono_debugger_check_interruption ();\n\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\t\n\tif (thread->thread_interrupt_requested) {\n\t\tthrow = TRUE;\n\t\tthread->thread_interrupt_requested = FALSE;\n\t}\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tif (throw) {\n\t\tmono_raise_exception (mono_get_exception_thread_interrupted ());\n\t}\n}\n\nint  \nmono_thread_get_abort_signal (void)\n{\n#ifdef HOST_WIN32\n\treturn -1;\n#else\n#ifndef\tSIGRTMIN\n#ifdef SIGUSR1\n\treturn SIGUSR1;\n#else\n\treturn -1;\n#endif\n#else\n\tstatic int abort_signum = -1;\n\tint i;\n\tif (abort_signum != -1)\n\t\treturn abort_signum;\n\t/* we try to avoid SIGRTMIN and any one that might have been set already, see bug #75387 */\n\tfor (i = SIGRTMIN + 1; i < SIGRTMAX; ++i) {\n\t\tstruct sigaction sinfo;\n\t\tsigaction (i, NULL, &sinfo);\n\t\tif (sinfo.sa_handler == SIG_DFL && (void*)sinfo.sa_sigaction == (void*)SIG_DFL) {\n\t\t\tabort_signum = i;\n\t\t\treturn i;\n\t\t}\n\t}\n\t/* fallback to the old way */\n\treturn SIGRTMIN;\n#endif\n#endif /* HOST_WIN32 */\n}\n\n#ifdef HOST_WIN32\nstatic void CALLBACK interruption_request_apc (ULONG_PTR param)\n{\n\tMonoException* exc = mono_thread_request_interruption (FALSE);\n\tif (exc) mono_raise_exception (exc);\n}\n#endif /* HOST_WIN32 */\n\n/*\n * signal_thread_state_change\n *\n * Tells the thread that his state has changed and it has to enter the new\n * state as soon as possible.\n */\nstatic void signal_thread_state_change (MonoInternalThread *thread)\n{\n\tif (thread == mono_thread_internal_current ()) {\n\t\t/* Do it synchronously */\n\t\tMonoException *exc = mono_thread_request_interruption (FALSE); \n\t\tif (exc)\n\t\t\tmono_raise_exception (exc);\n\t}\n\n#ifdef HOST_WIN32\n\tQueueUserAPC ((PAPCFUNC)interruption_request_apc, thread->handle, NULL);\n#else\n\t/* fixme: store the state somewhere */\n\tmono_thread_kill (thread, mono_thread_get_abort_signal ());\n\n\t/* \n\t * This will cause waits to be broken.\n\t * It will also prevent the thread from entering a wait, so if the thread returns\n\t * from the wait before it receives the abort signal, it will just spin in the wait\n\t * functions in the io-layer until the signal handler calls QueueUserAPC which will\n\t * make it return.\n\t */\n\twapi_interrupt_thread (thread->handle);\n#endif /* HOST_WIN32 */\n}\n\nvoid\nves_icall_System_Threading_Thread_Abort (MonoInternalThread *thread, MonoObject *state)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\t\n\tif ((thread->state & ThreadState_AbortRequested) != 0 || \n\t\t(thread->state & ThreadState_StopRequested) != 0 ||\n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn;\n\t}\n\n\tif ((thread->state & ThreadState_Unstarted) != 0) {\n\t\tthread->state |= ThreadState_Aborted;\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn;\n\t}\n\n\tthread->state |= ThreadState_AbortRequested;\n\tif (thread->abort_state_handle)\n\t\tmono_gchandle_free (thread->abort_state_handle);\n\tif (state) {\n\t\tthread->abort_state_handle = mono_gchandle_new (state, FALSE);\n\t\tg_assert (thread->abort_state_handle);\n\t} else {\n\t\tthread->abort_state_handle = 0;\n\t}\n\tthread->abort_exc = NULL;\n\n\t/*\n\t * abort_exc is set in mono_thread_execute_interruption(),\n\t * triggered by the call to signal_thread_state_change(),\n\t * below.  There's a point between where we have\n\t * abort_state_handle set, but abort_exc NULL, but that's not\n\t * a problem.\n\t */\n\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Abort requested for %p (%\"G_GSIZE_FORMAT\")\", __func__, GetCurrentThreadId (), thread, (gsize)thread->tid));\n\n\t/* During shutdown, we can't wait for other threads */\n\tif (!shutting_down)\n\t\t/* Make sure the thread is awake */\n\t\tmono_thread_resume (thread);\n\t\n\tsignal_thread_state_change (thread);\n}\n\nvoid\nves_icall_System_Threading_Thread_ResetAbort (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tgboolean was_aborting;\n\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\twas_aborting = thread->state & ThreadState_AbortRequested;\n\tthread->state &= ~ThreadState_AbortRequested;\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tif (!was_aborting) {\n\t\tconst char *msg = \"Unable to reset abort because no abort was requested\";\n\t\tmono_raise_exception (mono_get_exception_thread_state (msg));\n\t}\n\tthread->abort_exc = NULL;\n\tif (thread->abort_state_handle) {\n\t\tmono_gchandle_free (thread->abort_state_handle);\n\t\t/* This is actually not necessary - the handle\n\t\t   only counts if the exception is set */\n\t\tthread->abort_state_handle = 0;\n\t}\n}\n\nvoid\nmono_thread_internal_reset_abort (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\n\tEnterCriticalSection (thread->synch_cs);\n\n\tthread->state &= ~ThreadState_AbortRequested;\n\n\tif (thread->abort_exc) {\n\t\tthread->abort_exc = NULL;\n\t\tif (thread->abort_state_handle) {\n\t\t\tmono_gchandle_free (thread->abort_state_handle);\n\t\t\t/* This is actually not necessary - the handle\n\t\t\t   only counts if the exception is set */\n\t\t\tthread->abort_state_handle = 0;\n\t\t}\n\t}\n\n\tLeaveCriticalSection (thread->synch_cs);\n}\n\nMonoObject*\nves_icall_System_Threading_Thread_GetAbortExceptionState (MonoThread *this)\n{\n\tMonoInternalThread *thread = this->internal_thread;\n\tMonoObject *state, *deserialized = NULL, *exc;\n\tMonoDomain *domain;\n\n\tif (!thread->abort_state_handle)\n\t\treturn NULL;\n\n\tstate = mono_gchandle_get_target (thread->abort_state_handle);\n\tg_assert (state);\n\n\tdomain = mono_domain_get ();\n\tif (mono_object_domain (state) == domain)\n\t\treturn state;\n\n\tdeserialized = mono_object_xdomain_representation (state, domain, &exc);\n\n\tif (!deserialized) {\n\t\tMonoException *invalid_op_exc = mono_get_exception_invalid_operation (\"Thread.ExceptionState cannot access an ExceptionState from a different AppDomain\");\n\t\tif (exc)\n\t\t\tMONO_OBJECT_SETREF (invalid_op_exc, inner_ex, exc);\n\t\tmono_raise_exception (invalid_op_exc);\n\t}\n\n\treturn deserialized;\n}\n\nstatic gboolean\nmono_thread_suspend (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & ThreadState_Unstarted) != 0 || \n\t\t(thread->state & ThreadState_Aborted) != 0 || \n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn FALSE;\n\t}\n\n\tif ((thread->state & ThreadState_Suspended) != 0 || \n\t\t(thread->state & ThreadState_SuspendRequested) != 0 ||\n\t\t(thread->state & ThreadState_StopRequested) != 0) \n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn TRUE;\n\t}\n\t\n\tthread->state |= ThreadState_SuspendRequested;\n\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tsignal_thread_state_change (thread);\n\treturn TRUE;\n}\n\nvoid\nves_icall_System_Threading_Thread_Suspend (MonoInternalThread *thread)\n{\n\tif (!mono_thread_suspend (thread))\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has not been started, or is dead.\"));\n}\n\nstatic gboolean\nmono_thread_resume (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & ThreadState_SuspendRequested) != 0) {\n\t\tthread->state &= ~ThreadState_SuspendRequested;\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn TRUE;\n\t}\n\n\tif ((thread->state & ThreadState_Suspended) == 0 ||\n\t\t(thread->state & ThreadState_Unstarted) != 0 || \n\t\t(thread->state & ThreadState_Aborted) != 0 || \n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn FALSE;\n\t}\n\t\n\tthread->resume_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tif (thread->resume_event == NULL) {\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn(FALSE);\n\t}\n\t\n\t/* Awake the thread */\n\tSetEvent (thread->suspend_event);\n\n\tLeaveCriticalSection (thread->synch_cs);\n\n\t/* Wait for the thread to awake */\n\tWaitForSingleObject (thread->resume_event, INFINITE);\n\tCloseHandle (thread->resume_event);\n\tthread->resume_event = NULL;\n\n\treturn TRUE;\n}\n\nvoid\nves_icall_System_Threading_Thread_Resume (MonoThread *thread)\n{\n\tif (!thread->internal_thread || !mono_thread_resume (thread->internal_thread))\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has not been started, or is dead.\"));\n}\n\nstatic gboolean\nfind_wrapper (MonoMethod *m, gint no, gint ilo, gboolean managed, gpointer data)\n{\n\tif (managed)\n\t\treturn TRUE;\n\n\tif (m->wrapper_type == MONO_WRAPPER_RUNTIME_INVOKE ||\n\t\tm->wrapper_type == MONO_WRAPPER_XDOMAIN_INVOKE ||\n\t\tm->wrapper_type == MONO_WRAPPER_XDOMAIN_DISPATCH) \n\t{\n\t\t*((gboolean*)data) = TRUE;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean \nis_running_protected_wrapper (void)\n{\n\tgboolean found = FALSE;\n\tmono_stack_walk (find_wrapper, &found);\n\treturn found;\n}\n\nvoid mono_thread_internal_stop (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & ThreadState_StopRequested) != 0 ||\n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn;\n\t}\n\t\n\t/* Make sure the thread is awake */\n\tmono_thread_resume (thread);\n\n\tthread->state |= ThreadState_StopRequested;\n\tthread->state &= ~ThreadState_AbortRequested;\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\tsignal_thread_state_change (thread);\n}\n\nvoid mono_thread_stop (MonoThread *thread)\n{\n\tmono_thread_internal_stop (thread->internal_thread);\n}\n\ngint8\nves_icall_System_Threading_Thread_VolatileRead1 (void *ptr)\n{\n\treturn *((volatile gint8 *) (ptr));\n}\n\ngint16\nves_icall_System_Threading_Thread_VolatileRead2 (void *ptr)\n{\n\treturn *((volatile gint16 *) (ptr));\n}\n\ngint32\nves_icall_System_Threading_Thread_VolatileRead4 (void *ptr)\n{\n\treturn *((volatile gint32 *) (ptr));\n}\n\ngint64\nves_icall_System_Threading_Thread_VolatileRead8 (void *ptr)\n{\n\treturn *((volatile gint64 *) (ptr));\n}\n\nvoid *\nves_icall_System_Threading_Thread_VolatileReadIntPtr (void *ptr)\n{\n\treturn (void *)  *((volatile void **) ptr);\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite1 (void *ptr, gint8 value)\n{\n\t*((volatile gint8 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite2 (void *ptr, gint16 value)\n{\n\t*((volatile gint16 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite4 (void *ptr, gint32 value)\n{\n\t*((volatile gint32 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite8 (void *ptr, gint64 value)\n{\n\t*((volatile gint64 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWriteIntPtr (void *ptr, void *value)\n{\n\t*((volatile void **) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWriteObject (void *ptr, void *value)\n{\n\tmono_gc_wbarrier_generic_store (ptr, value);\n}\n\nvoid mono_thread_init (MonoThreadStartCB start_cb,\n\t\t       MonoThreadAttachCB attach_cb)\n{\n\tmono_thread_smr_init ();\n\n\tInitializeCriticalSection(&threads_mutex);\n\tInitializeCriticalSection(&interlocked_mutex);\n\tInitializeCriticalSection(&contexts_mutex);\n\t\n\tbackground_change_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tg_assert(background_change_event != NULL);\n\t\n\tmono_init_static_data_info (&thread_static_info);\n\tmono_init_static_data_info (&context_static_info);\n\n\tMONO_FAST_TLS_INIT (tls_current_object);\n\tcurrent_object_key=TlsAlloc();\n\tTHREAD_DEBUG (g_message (\"%s: Allocated current_object_key %d\", __func__, current_object_key));\n\n\tmono_thread_start_cb = start_cb;\n\tmono_thread_attach_cb = attach_cb;\n\n\t/* Get a pseudo handle to the current process.  This is just a\n\t * kludge so that wapi can build a process handle if needed.\n\t * As a pseudo handle is returned, we don't need to clean\n\t * anything up.\n\t */\n\tGetCurrentProcess ();\n}\n\nvoid mono_thread_cleanup (void)\n{\n#if !defined(HOST_WIN32) && !defined(RUN_IN_SUBTHREAD)\n\t/* The main thread must abandon any held mutexes (particularly\n\t * important for named mutexes as they are shared across\n\t * processes, see bug 74680.)  This will happen when the\n\t * thread exits, but if it's not running in a subthread it\n\t * won't exit in time.\n\t */\n\t/* Using non-w32 API is a nasty kludge, but I couldn't find\n\t * anything in the documentation that would let me do this\n\t * here yet still be safe to call on windows.\n\t */\n\t_wapi_thread_signal_self (mono_environment_exitcode_get ());\n#endif\n\n#if 0\n\t/* This stuff needs more testing, it seems one of these\n\t * critical sections can be locked when mono_thread_cleanup is\n\t * called.\n\t */\n\tDeleteCriticalSection (&threads_mutex);\n\tDeleteCriticalSection (&interlocked_mutex);\n\tDeleteCriticalSection (&contexts_mutex);\n\tDeleteCriticalSection (&delayed_free_table_mutex);\n\tDeleteCriticalSection (&small_id_mutex);\n\tCloseHandle (background_change_event);\n#endif\n\n\tTlsFree (current_object_key);\n}\n\nvoid\nmono_threads_install_cleanup (MonoThreadCleanupFunc func)\n{\n\tmono_thread_cleanup_fn = func;\n}\n\nvoid\nmono_thread_set_manage_callback (MonoThread *thread, MonoThreadManageCallback func)\n{\n\tthread->internal_thread->manage_callback = func;\n}\n\nvoid mono_threads_install_notify_pending_exc (MonoThreadNotifyPendingExcFunc func)\n{\n\tmono_thread_notify_pending_exc_fn = func;\n}\n\nG_GNUC_UNUSED\nstatic void print_tids (gpointer key, gpointer value, gpointer user)\n{\n\t/* GPOINTER_TO_UINT breaks horribly if sizeof(void *) >\n\t * sizeof(uint) and a cast to uint would overflow\n\t */\n\t/* Older versions of glib don't have G_GSIZE_FORMAT, so just\n\t * print this as a pointer.\n\t */\n\tg_message (\"Waiting for: %p\", key);\n}\n\nstruct wait_data \n{\n\tHANDLE handles[MAXIMUM_WAIT_OBJECTS];\n\tMonoInternalThread *threads[MAXIMUM_WAIT_OBJECTS];\n\tguint32 num;\n};\n\nstatic void wait_for_tids (struct wait_data *wait, guint32 timeout)\n{\n\tguint32 i, ret;\n\t\n\tTHREAD_DEBUG (g_message(\"%s: %d threads to wait for in this batch\", __func__, wait->num));\n\n\tret=WaitForMultipleObjectsEx(wait->num, wait->handles, TRUE, timeout, TRUE);\n\n\tif(ret==WAIT_FAILED) {\n\t\t/* See the comment in build_wait_tids() */\n\t\tTHREAD_DEBUG (g_message (\"%s: Wait failed\", __func__));\n\t\treturn;\n\t}\n\t\n\tfor(i=0; i<wait->num; i++)\n\t\tCloseHandle (wait->handles[i]);\n\n\tif (ret == WAIT_TIMEOUT)\n\t\treturn;\n\n\tfor(i=0; i<wait->num; i++) {\n\t\tgsize tid = wait->threads[i]->tid;\n\t\t\n\t\tmono_threads_lock ();\n\t\tif(mono_g_hash_table_lookup (threads, (gpointer)tid)!=NULL) {\n\t\t\t/* This thread must have been killed, because\n\t\t\t * it hasn't cleaned itself up. (It's just\n\t\t\t * possible that the thread exited before the\n\t\t\t * parent thread had a chance to store the\n\t\t\t * handle, and now there is another pointer to\n\t\t\t * the already-exited thread stored.  In this\n\t\t\t * case, we'll just get two\n\t\t\t * mono_profiler_thread_end() calls for the\n\t\t\t * same thread.)\n\t\t\t */\n\t\n\t\t\tmono_threads_unlock ();\n\t\t\tTHREAD_DEBUG (g_message (\"%s: cleaning up after thread %p (%\"G_GSIZE_FORMAT\")\", __func__, wait->threads[i], tid));\n\t\t\tthread_cleanup (wait->threads[i]);\n\t\t} else {\n\t\t\tmono_threads_unlock ();\n\t\t}\n\t}\n}\n\nstatic void wait_for_tids_or_state_change (struct wait_data *wait, guint32 timeout)\n{\n\tguint32 i, ret, count;\n\t\n\tTHREAD_DEBUG (g_message(\"%s: %d threads to wait for in this batch\", __func__, wait->num));\n\n\t/* Add the thread state change event, so it wakes up if a thread changes\n\t * to background mode.\n\t */\n\tcount = wait->num;\n\tif (count < MAXIMUM_WAIT_OBJECTS) {\n\t\twait->handles [count] = background_change_event;\n\t\tcount++;\n\t}\n\n\tret=WaitForMultipleObjectsEx (count, wait->handles, FALSE, timeout, TRUE);\n\n\tif(ret==WAIT_FAILED) {\n\t\t/* See the comment in build_wait_tids() */\n\t\tTHREAD_DEBUG (g_message (\"%s: Wait failed\", __func__));\n\t\treturn;\n\t}\n\t\n\tfor(i=0; i<wait->num; i++)\n\t\tCloseHandle (wait->handles[i]);\n\n\tif (ret == WAIT_TIMEOUT)\n\t\treturn;\n\t\n\tif (ret < wait->num) {\n\t\tgsize tid = wait->threads[ret]->tid;\n\t\tmono_threads_lock ();\n\t\tif (mono_g_hash_table_lookup (threads, (gpointer)tid)!=NULL) {\n\t\t\t/* See comment in wait_for_tids about thread cleanup */\n\t\t\tmono_threads_unlock ();\n\t\t\tTHREAD_DEBUG (g_message (\"%s: cleaning up after thread %\"G_GSIZE_FORMAT, __func__, tid));\n\t\t\tthread_cleanup (wait->threads [ret]);\n\t\t} else\n\t\t\tmono_threads_unlock ();\n\t}\n}\n\nstatic void build_wait_tids (gpointer key, gpointer value, gpointer user)\n{\n\tstruct wait_data *wait=(struct wait_data *)user;\n\n\tif(wait->num<MAXIMUM_WAIT_OBJECTS) {\n\t\tHANDLE handle;\n\t\tMonoInternalThread *thread=(MonoInternalThread *)value;\n\n\t\t/* Ignore background threads, we abort them later */\n\t\t/* Do not lock here since it is not needed and the caller holds threads_lock */\n\t\tif (thread->state & ThreadState_Background) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring background thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn; /* just leave, ignore */\n\t\t}\n\t\t\n\t\tif (mono_gc_is_finalizer_internal_thread (thread)) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring finalizer thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (thread == mono_thread_internal_current ()) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring current thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (mono_thread_get_main () && (thread == mono_thread_get_main ()->internal_thread)) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring main thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (thread->flags & MONO_THREAD_FLAG_DONT_MANAGE) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring thread %\" G_GSIZE_FORMAT \"with DONT_MANAGE flag set.\", __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring unopenable thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tTHREAD_DEBUG (g_message (\"%s: Invoking mono_thread_manage callback on thread %p\", __func__, thread));\n\t\tif ((thread->manage_callback == NULL) || (thread->manage_callback (thread->root_domain_thread) == TRUE)) {\n\t\t\twait->handles[wait->num]=handle;\n\t\t\twait->threads[wait->num]=thread;\n\t\t\twait->num++;\n\n\t\t\tTHREAD_DEBUG (g_message (\"%s: adding thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t} else {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring (because of callback) thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t}\n\t\t\n\t\t\n\t} else {\n\t\t/* Just ignore the rest, we can't do anything with\n\t\t * them yet\n\t\t */\n\t}\n}\n\nstatic gboolean\nremove_and_abort_threads (gpointer key, gpointer value, gpointer user)\n{\n\tstruct wait_data *wait=(struct wait_data *)user;\n\tgsize self = GetCurrentThreadId ();\n\tMonoInternalThread *thread = value;\n\tHANDLE handle;\n\n\tif (wait->num >= MAXIMUM_WAIT_OBJECTS)\n\t\treturn FALSE;\n\n\t/* The finalizer thread is not a background thread */\n\tif (thread->tid != self && (thread->state & ThreadState_Background) != 0 &&\n\t\t!(thread->flags & MONO_THREAD_FLAG_DONT_MANAGE)) {\n\t\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL)\n\t\t\treturn FALSE;\n\n\t\t/* printf (\"A: %d\\n\", wait->num); */\n\t\twait->handles[wait->num]=thread->handle;\n\t\twait->threads[wait->num]=thread;\n\t\twait->num++;\n\n\t\tTHREAD_DEBUG (g_print (\"%s: Aborting id: %\"G_GSIZE_FORMAT\"\\n\", __func__, (gsize)thread->tid));\n\t\tmono_thread_internal_stop (thread);\n\t\treturn TRUE;\n\t}\n\n\treturn (thread->tid != self && !mono_gc_is_finalizer_internal_thread (thread)); \n}\n\n/** \n * mono_threads_set_shutting_down:\n *\n * Is called by a thread that wants to shut down Mono. If the runtime is already\n * shutting down, the calling thread is suspended/stopped, and this function never\n * returns.\n */\nvoid\nmono_threads_set_shutting_down (void)\n{\n\tMonoInternalThread *current_thread = mono_thread_internal_current ();\n\n\tmono_threads_lock ();\n\n\tif (shutting_down) {\n\t\tmono_threads_unlock ();\n\n\t\t/* Make sure we're properly suspended/stopped */\n\n\t\tEnterCriticalSection (current_thread->synch_cs);\n\n\t\tif ((current_thread->state & ThreadState_SuspendRequested) ||\n\t\t    (current_thread->state & ThreadState_AbortRequested) ||\n\t\t    (current_thread->state & ThreadState_StopRequested)) {\n\t\t\tLeaveCriticalSection (current_thread->synch_cs);\n\t\t\tmono_thread_execute_interruption (current_thread);\n\t\t} else {\n\t\t\tcurrent_thread->state |= ThreadState_Stopped;\n\t\t\tLeaveCriticalSection (current_thread->synch_cs);\n\t\t}\n\n\t\t/*since we're killing the thread, unset the current domain.*/\n\t\tmono_domain_unset ();\n\n\t\t/* Wake up other threads potentially waiting for us */\n\t\tExitThread (0);\n\t} else {\n\t\tshutting_down = TRUE;\n\n\t\t/* Not really a background state change, but this will\n\t\t * interrupt the main thread if it is waiting for all\n\t\t * the other threads.\n\t\t */\n\t\tSetEvent (background_change_event);\n\t\t\n\t\tmono_threads_unlock ();\n\t}\n}\n\n/** \n * mono_threads_is_shutting_down:\n *\n * Returns whether a thread has commenced shutdown of Mono.  Note that\n * if the function returns FALSE the caller must not assume that\n * shutdown is not in progress, because the situation might have\n * changed since the function returned.  For that reason this function\n * is of very limited utility.\n */\ngboolean\nmono_threads_is_shutting_down (void)\n{\n\treturn shutting_down;\n}\n\nvoid mono_thread_manage (void)\n{\n\tstruct wait_data wait_data;\n\tstruct wait_data *wait = &wait_data;\n\n\tmemset (wait, 0, sizeof (struct wait_data));\n\t/* join each thread that's still running */\n\tTHREAD_DEBUG (g_message (\"%s: Joining each running thread...\", __func__));\n\t\n\tmono_threads_lock ();\n\tif(threads==NULL) {\n\t\tTHREAD_DEBUG (g_message(\"%s: No threads\", __func__));\n\t\tmono_threads_unlock ();\n\t\treturn;\n\t}\n\tmono_threads_unlock ();\n\t\n\tdo {\n\t\tmono_threads_lock ();\n\t\tif (shutting_down) {\n\t\t\t/* somebody else is shutting down */\n\t\t\tmono_threads_unlock ();\n\t\t\tbreak;\n\t\t}\n\t\tTHREAD_DEBUG (g_message (\"%s: There are %d threads to join\", __func__, mono_g_hash_table_size (threads));\n\t\t\tmono_g_hash_table_foreach (threads, print_tids, NULL));\n\t\n\t\tResetEvent (background_change_event);\n\t\twait->num=0;\n\t\t/*We must zero all InternalThread pointers to avoid making the GC unhappy.*/\n\t\tmemset (wait->threads, 0, MAXIMUM_WAIT_OBJECTS * SIZEOF_VOID_P);\n\t\tmono_g_hash_table_foreach (threads, build_wait_tids, wait);\n\t\tmono_threads_unlock ();\n\t\tif(wait->num>0) {\n\t\t\t/* Something to wait for */\n\t\t\twait_for_tids_or_state_change (wait, INFINITE);\n\t\t}\n\t\tTHREAD_DEBUG (g_message (\"%s: I have %d threads after waiting.\", __func__, wait->num));\n\t} while(wait->num>0);\n\n\tmono_threads_set_shutting_down ();\n\n\t/* No new threads will be created after this point */\n\n\tmono_runtime_set_shutting_down ();\n\n\tTHREAD_DEBUG (g_message (\"%s: threadpool cleanup\", __func__));\n\tmono_thread_pool_cleanup ();\n\n\t/* \n\t * Remove everything but the finalizer thread and self.\n\t * Also abort all the background threads\n\t * */\n\tdo {\n\t\tmono_threads_lock ();\n\n\t\twait->num = 0;\n\t\t/*We must zero all InternalThread pointers to avoid making the GC unhappy.*/\n\t\tmemset (wait->threads, 0, MAXIMUM_WAIT_OBJECTS * SIZEOF_VOID_P);\n\t\tmono_g_hash_table_foreach_remove (threads, remove_and_abort_threads, wait);\n\n\t\tmono_threads_unlock ();\n\n\t\tTHREAD_DEBUG (g_message (\"%s: wait->num is now %d\", __func__, wait->num));\n\t\tif(wait->num>0) {\n\t\t\t/* Something to wait for */\n\t\t\twait_for_tids (wait, INFINITE);\n\t\t}\n\t} while (wait->num > 0);\n\t\n\t/* \n\t * give the subthreads a chance to really quit (this is mainly needed\n\t * to get correct user and system times from getrusage/wait/time(1)).\n\t * This could be removed if we avoid pthread_detach() and use pthread_join().\n\t */\n#ifndef HOST_WIN32\n\tsched_yield ();\n#endif\n}\n\nstatic void terminate_thread (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread=(MonoInternalThread *)value;\n\t\n\tif(thread->tid != (gsize)user) {\n\t\t/*TerminateThread (thread->handle, -1);*/\n\t}\n}\n\nvoid mono_thread_abort_all_other_threads (void)\n{\n\tgsize self = GetCurrentThreadId ();\n\n\tmono_threads_lock ();\n\tTHREAD_DEBUG (g_message (\"%s: There are %d threads to abort\", __func__,\n\t\t\t\t mono_g_hash_table_size (threads));\n\t\t      mono_g_hash_table_foreach (threads, print_tids, NULL));\n\n\tmono_g_hash_table_foreach (threads, terminate_thread, (gpointer)self);\n\t\n\tmono_threads_unlock ();\n}\n\nstatic void\ncollect_threads_for_suspend (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tstruct wait_data *wait = (struct wait_data*)user_data;\n\tHANDLE handle;\n\n\t/* \n\t * We try to exclude threads early, to avoid running into the MAXIMUM_WAIT_OBJECTS\n\t * limitation.\n\t * This needs no locking.\n\t */\n\tif ((thread->state & ThreadState_Suspended) != 0 || \n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t\treturn;\n\n\tif (wait->num<MAXIMUM_WAIT_OBJECTS) {\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL)\n\t\t\treturn;\n\n\t\twait->handles [wait->num] = handle;\n\t\twait->threads [wait->num] = thread;\n\t\twait->num++;\n\t}\n}\n\n/*\n * mono_thread_suspend_all_other_threads:\n *\n *  Suspend all managed threads except the finalizer thread and this thread. It is\n * not possible to resume them later.\n */\nvoid mono_thread_suspend_all_other_threads (void)\n{\n\tstruct wait_data wait_data;\n\tstruct wait_data *wait = &wait_data;\n\tint i;\n\tgsize self = GetCurrentThreadId ();\n\tgpointer *events;\n\tguint32 eventidx = 0;\n\tgboolean starting, finished;\n\n\tmemset (wait, 0, sizeof (struct wait_data));\n\t/*\n\t * The other threads could be in an arbitrary state at this point, i.e.\n\t * they could be starting up, shutting down etc. This means that there could be\n\t * threads which are not even in the threads hash table yet.\n\t */\n\n\t/* \n\t * First we set a barrier which will be checked by all threads before they\n\t * are added to the threads hash table, and they will exit if the flag is set.\n\t * This ensures that no threads could be added to the hash later.\n\t * We will use shutting_down as the barrier for now.\n\t */\n\tg_assert (shutting_down);\n\n\t/*\n\t * We make multiple calls to WaitForMultipleObjects since:\n\t * - we can only wait for MAXIMUM_WAIT_OBJECTS threads\n\t * - some threads could exit without becoming suspended\n\t */\n\tfinished = FALSE;\n\twhile (!finished) {\n\t\t/*\n\t\t * Make a copy of the hashtable since we can't do anything with\n\t\t * threads while threads_mutex is held.\n\t\t */\n\t\twait->num = 0;\n\t\t/*We must zero all InternalThread pointers to avoid making the GC unhappy.*/\n\t\tmemset (wait->threads, 0, MAXIMUM_WAIT_OBJECTS * SIZEOF_VOID_P);\n\t\tmono_threads_lock ();\n\t\tmono_g_hash_table_foreach (threads, collect_threads_for_suspend, wait);\n\t\tmono_threads_unlock ();\n\n\t\tevents = g_new0 (gpointer, wait->num);\n\t\teventidx = 0;\n\t\t/* Get the suspended events that we'll be waiting for */\n\t\tfor (i = 0; i < wait->num; ++i) {\n\t\t\tMonoInternalThread *thread = wait->threads [i];\n\t\t\tgboolean signal_suspend = FALSE;\n\n\t\t\tif ((thread->tid == self) || mono_gc_is_finalizer_internal_thread (thread) || (thread->flags & MONO_THREAD_FLAG_DONT_MANAGE)) {\n\t\t\t\t//CloseHandle (wait->handles [i]);\n\t\t\t\twait->threads [i] = NULL; /* ignore this thread in next loop */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tensure_synch_cs_set (thread);\n\t\t\n\t\t\tEnterCriticalSection (thread->synch_cs);\n\n\t\t\tif (thread->suspended_event == NULL) {\n\t\t\t\tthread->suspended_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\t\t\t\tif (thread->suspended_event == NULL) {\n\t\t\t\t\t/* Forget this one and go on to the next */\n\t\t\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((thread->state & ThreadState_Suspended) != 0 || \n\t\t\t\t(thread->state & ThreadState_StopRequested) != 0 ||\n\t\t\t\t(thread->state & ThreadState_Stopped) != 0) {\n\t\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\t\tCloseHandle (wait->handles [i]);\n\t\t\t\twait->threads [i] = NULL; /* ignore this thread in next loop */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((thread->state & ThreadState_SuspendRequested) == 0)\n\t\t\t\tsignal_suspend = TRUE;\n\n\t\t\tevents [eventidx++] = thread->suspended_event;\n\n\t\t\t/* Convert abort requests into suspend requests */\n\t\t\tif ((thread->state & ThreadState_AbortRequested) != 0)\n\t\t\t\tthread->state &= ~ThreadState_AbortRequested;\n\t\t\t\n\t\t\tthread->state |= ThreadState_SuspendRequested;\n\n\t\t\tLeaveCriticalSection (thread->synch_cs);\n\n\t\t\t/* Signal the thread to suspend */\n\t\t\tif (signal_suspend)\n\t\t\t\tsignal_thread_state_change (thread);\n\t\t}\n\n\t\tif (eventidx > 0) {\n\t\t\tWaitForMultipleObjectsEx (eventidx, events, TRUE, 100, FALSE);\n\t\t\tfor (i = 0; i < wait->num; ++i) {\n\t\t\t\tMonoInternalThread *thread = wait->threads [i];\n\n\t\t\t\tif (thread == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tensure_synch_cs_set (thread);\n\t\t\t\n\t\t\t\tEnterCriticalSection (thread->synch_cs);\n\t\t\t\tif ((thread->state & ThreadState_Suspended) != 0) {\n\t\t\t\t\tCloseHandle (thread->suspended_event);\n\t\t\t\t\tthread->suspended_event = NULL;\n\t\t\t\t}\n\t\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\t}\n\t\t} else {\n\t\t\t/* \n\t\t\t * If there are threads which are starting up, we wait until they\n\t\t\t * are suspended when they try to register in the threads hash.\n\t\t\t * This is guaranteed to finish, since the threads which can create new\n\t\t\t * threads get suspended after a while.\n\t\t\t * FIXME: The finalizer thread can still create new threads.\n\t\t\t */\n\t\t\tmono_threads_lock ();\n\t\t\tif (threads_starting_up)\n\t\t\t\tstarting = mono_g_hash_table_size (threads_starting_up) > 0;\n\t\t\telse\n\t\t\t\tstarting = FALSE;\n\t\t\tmono_threads_unlock ();\n\t\t\tif (starting)\n\t\t\t\tSleep (100);\n\t\t\telse\n\t\t\t\tfinished = TRUE;\n\t\t}\n\n\t\tg_free (events);\n\t}\n}\n\nstatic void\ncollect_threads (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tstruct wait_data *wait = (struct wait_data*)user_data;\n\tHANDLE handle;\n\n\tif (wait->num<MAXIMUM_WAIT_OBJECTS) {\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL)\n\t\t\treturn;\n\n\t\twait->handles [wait->num] = handle;\n\t\twait->threads [wait->num] = thread;\n\t\twait->num++;\n\t}\n}\n\n/**\n * mono_threads_request_thread_dump:\n *\n *   Ask all threads except the current to print their stacktrace to stdout.\n */\nvoid\nmono_threads_request_thread_dump (void)\n{\n\tstruct wait_data wait_data;\n\tstruct wait_data *wait = &wait_data;\n\tint i;\n\n\tmemset (wait, 0, sizeof (struct wait_data));\n\n\t/* \n\t * Make a copy of the hashtable since we can't do anything with\n\t * threads while threads_mutex is held.\n\t */\n\tmono_threads_lock ();\n\tmono_g_hash_table_foreach (threads, collect_threads, wait);\n\tmono_threads_unlock ();\n\n\tfor (i = 0; i < wait->num; ++i) {\n\t\tMonoInternalThread *thread = wait->threads [i];\n\n\t\tif (!mono_gc_is_finalizer_internal_thread (thread) &&\n\t\t\t\t(thread != mono_thread_internal_current ()) &&\n\t\t\t\t!thread->thread_dump_requested) {\n\t\t\tthread->thread_dump_requested = TRUE;\n\n\t\t\tsignal_thread_state_change (thread);\n\t\t}\n\n\t\tCloseHandle (wait->handles [i]);\n\t}\n}\n\nstruct ref_stack {\n\tgpointer *refs;\n\tgint allocated; /* +1 so that refs [allocated] == NULL */\n\tgint bottom;\n};\n\ntypedef struct ref_stack RefStack;\n\nstatic RefStack *\nref_stack_new (gint initial_size)\n{\n\tRefStack *rs;\n\n\tinitial_size = MAX (initial_size, 16) + 1;\n\trs = g_new0 (RefStack, 1);\n\trs->refs = g_new0 (gpointer, initial_size);\n\trs->allocated = initial_size;\n\treturn rs;\n}\n\nstatic void\nref_stack_destroy (gpointer ptr)\n{\n\tRefStack *rs = ptr;\n\n\tif (rs != NULL) {\n\t\tg_free (rs->refs);\n\t\tg_free (rs);\n\t}\n}\n\nstatic void\nref_stack_push (RefStack *rs, gpointer ptr)\n{\n\tg_assert (rs != NULL);\n\n\tif (rs->bottom >= rs->allocated) {\n\t\trs->refs = g_realloc (rs->refs, rs->allocated * 2 * sizeof (gpointer) + 1);\n\t\trs->allocated <<= 1;\n\t\trs->refs [rs->allocated] = NULL;\n\t}\n\trs->refs [rs->bottom++] = ptr;\n}\n\nstatic void\nref_stack_pop (RefStack *rs)\n{\n\tif (rs == NULL || rs->bottom == 0)\n\t\treturn;\n\n\trs->bottom--;\n\trs->refs [rs->bottom] = NULL;\n}\n\nstatic gboolean\nref_stack_find (RefStack *rs, gpointer ptr)\n{\n\tgpointer *refs;\n\n\tif (rs == NULL)\n\t\treturn FALSE;\n\n\tfor (refs = rs->refs; refs && *refs; refs++) {\n\t\tif (*refs == ptr)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/*\n * mono_thread_push_appdomain_ref:\n *\n *   Register that the current thread may have references to objects in domain \n * @domain on its stack. Each call to this function should be paired with a \n * call to pop_appdomain_ref.\n */\nvoid \nmono_thread_push_appdomain_ref (MonoDomain *domain)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tif (thread) {\n\t\t/* printf (\"PUSH REF: %\"G_GSIZE_FORMAT\" -> %s.\\n\", (gsize)thread->tid, domain->friendly_name); */\n\t\tSPIN_LOCK (thread->lock_thread_id);\n\t\tif (thread->appdomain_refs == NULL)\n\t\t\tthread->appdomain_refs = ref_stack_new (16);\n\t\tref_stack_push (thread->appdomain_refs, domain);\n\t\tSPIN_UNLOCK (thread->lock_thread_id);\n\t}\n}\n\nvoid\nmono_thread_pop_appdomain_ref (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tif (thread) {\n\t\t/* printf (\"POP REF: %\"G_GSIZE_FORMAT\" -> %s.\\n\", (gsize)thread->tid, ((MonoDomain*)(thread->appdomain_refs->data))->friendly_name); */\n\t\tSPIN_LOCK (thread->lock_thread_id);\n\t\tref_stack_pop (thread->appdomain_refs);\n\t\tSPIN_UNLOCK (thread->lock_thread_id);\n\t}\n}\n\ngboolean\nmono_thread_internal_has_appdomain_ref (MonoInternalThread *thread, MonoDomain *domain)\n{\n\tgboolean res;\n\tSPIN_LOCK (thread->lock_thread_id);\n\tres = ref_stack_find (thread->appdomain_refs, domain);\n\tSPIN_UNLOCK (thread->lock_thread_id);\n\treturn res;\n}\n\ngboolean\nmono_thread_has_appdomain_ref (MonoThread *thread, MonoDomain *domain)\n{\n\treturn mono_thread_internal_has_appdomain_ref (thread->internal_thread, domain);\n}\n\ntypedef struct abort_appdomain_data {\n\tstruct wait_data wait;\n\tMonoDomain *domain;\n} abort_appdomain_data;\n\nstatic void\ncollect_appdomain_thread (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tabort_appdomain_data *data = (abort_appdomain_data*)user_data;\n\tMonoDomain *domain = data->domain;\n\n\tif (mono_thread_internal_has_appdomain_ref (thread, domain)) {\n\t\t/* printf (\"ABORTING THREAD %p BECAUSE IT REFERENCES DOMAIN %s.\\n\", thread->tid, domain->friendly_name); */\n\n\t\tif(data->wait.num<MAXIMUM_WAIT_OBJECTS) {\n\t\t\tHANDLE handle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\t\tif (handle == NULL)\n\t\t\t\treturn;\n\t\t\tdata->wait.handles [data->wait.num] = handle;\n\t\t\tdata->wait.threads [data->wait.num] = thread;\n\t\t\tdata->wait.num++;\n\t\t} else {\n\t\t\t/* Just ignore the rest, we can't do anything with\n\t\t\t * them yet\n\t\t\t */\n\t\t}\n\t}\n}\n\n/*\n * mono_threads_abort_appdomain_threads:\n *\n *   Abort threads which has references to the given appdomain.\n */\ngboolean\nmono_threads_abort_appdomain_threads (MonoDomain *domain, int timeout)\n{\n\tabort_appdomain_data user_data;\n\tguint32 start_time;\n\tint orig_timeout = timeout;\n\tint i;\n\n\tTHREAD_DEBUG (g_message (\"%s: starting abort\", __func__));\n\n\tstart_time = mono_msec_ticks ();\n\tdo {\n\t\tmono_threads_lock ();\n\n\t\tuser_data.domain = domain;\n\t\tuser_data.wait.num = 0;\n\t\t/* This shouldn't take any locks */\n\t\tmono_g_hash_table_foreach (threads, collect_appdomain_thread, &user_data);\n\t\tmono_threads_unlock ();\n\n\t\tif (user_data.wait.num > 0) {\n\t\t\t/* Abort the threads outside the threads lock */\n\t\t\tfor (i = 0; i < user_data.wait.num; ++i)\n\t\t\t\tves_icall_System_Threading_Thread_Abort (user_data.wait.threads [i], NULL);\n\n\t\t\t/*\n\t\t\t * We should wait for the threads either to abort, or to leave the\n\t\t\t * domain. We can't do the latter, so we wait with a timeout.\n\t\t\t */\n\t\t\twait_for_tids (&user_data.wait, 100);\n\t\t}\n\n\t\t/* Update remaining time */\n\t\ttimeout -= mono_msec_ticks () - start_time;\n\t\tstart_time = mono_msec_ticks ();\n\n\t\tif (orig_timeout != -1 && timeout < 0)\n\t\t\treturn FALSE;\n\t}\n\twhile (user_data.wait.num > 0);\n\n\tTHREAD_DEBUG (g_message (\"%s: abort done\", __func__));\n\n\treturn TRUE;\n}\n\nstatic void\nclear_cached_culture (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tMonoDomain *domain = (MonoDomain*)user_data;\n\tint i;\n\n\t/* No locking needed here */\n\t/* FIXME: why no locking? writes to the cache are protected with synch_cs above */\n\n\tif (thread->cached_culture_info) {\n\t\tfor (i = 0; i < NUM_CACHED_CULTURES * 2; ++i) {\n\t\t\tMonoObject *obj = mono_array_get (thread->cached_culture_info, MonoObject*, i);\n\t\t\tif (obj && obj->vtable->domain == domain)\n\t\t\t\tmono_array_set (thread->cached_culture_info, MonoObject*, i, NULL);\n\t\t}\n\t}\n}\n\t\n/*\n * mono_threads_clear_cached_culture:\n *\n *   Clear the cached_current_culture from all threads if it is in the\n * given appdomain.\n */\nvoid\nmono_threads_clear_cached_culture (MonoDomain *domain)\n{\n\tmono_threads_lock ();\n\tmono_g_hash_table_foreach (threads, clear_cached_culture, domain);\n\tmono_threads_unlock ();\n}\n\n/*\n * mono_thread_get_undeniable_exception:\n *\n *   Return an exception which needs to be raised when leaving a catch clause.\n * This is used for undeniable exception propagation.\n */\nMonoException*\nmono_thread_get_undeniable_exception (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tif (thread && thread->abort_exc && !is_running_protected_wrapper ()) {\n\t\t/*\n\t\t * FIXME: Clear the abort exception and return an AppDomainUnloaded \n\t\t * exception if the thread no longer references a dying appdomain.\n\t\t */\n\t\tthread->abort_exc->trace_ips = NULL;\n\t\tthread->abort_exc->stack_trace = NULL;\n\t\treturn thread->abort_exc;\n\t}\n\n\treturn NULL;\n}\n\n#if MONO_SMALL_CONFIG\n#define NUM_STATIC_DATA_IDX 4\nstatic const int static_data_size [NUM_STATIC_DATA_IDX] = {\n\t64, 256, 1024, 4096\n};\n#else\n#define NUM_STATIC_DATA_IDX 8\nstatic const int static_data_size [NUM_STATIC_DATA_IDX] = {\n\t1024, 4096, 16384, 65536, 262144, 1048576, 4194304, 16777216\n};\n#endif\n\nstatic uintptr_t* static_reference_bitmaps [NUM_STATIC_DATA_IDX];\n\n#ifdef HAVE_SGEN_GC\nstatic void\nmark_tls_slots (void *addr, MonoGCMarkFunc mark_func)\n{\n\tint i;\n\tgpointer *static_data = addr;\n\tfor (i = 0; i < NUM_STATIC_DATA_IDX; ++i) {\n\t\tint j, numwords;\n\t\tvoid **ptr;\n\t\tif (!static_data [i])\n\t\t\tcontinue;\n\t\tnumwords = 1 + static_data_size [i] / sizeof (gpointer) / (sizeof(uintptr_t) * 8);\n\t\tptr = static_data [i];\n\t\tfor (j = 0; j < numwords; ++j, ptr += sizeof (uintptr_t) * 8) {\n\t\t\tuintptr_t bmap = static_reference_bitmaps [i][j];\n\t\t\tvoid ** p = ptr;\n\t\t\twhile (bmap) {\n\t\t\t\tif ((bmap & 1) && *p) {\n\t\t\t\t\tmark_func (p);\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tbmap >>= 1;\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\n/*\n *  mono_alloc_static_data\n *\n *   Allocate memory blocks for storing threads or context static data\n */\nstatic void \nmono_alloc_static_data (gpointer **static_data_ptr, guint32 offset, gboolean threadlocal)\n{\n\tguint idx = (offset >> 24) - 1;\n\tint i;\n\n\tgpointer* static_data = *static_data_ptr;\n\tif (!static_data) {\n\t\tstatic void* tls_desc = NULL;\n#ifdef HAVE_SGEN_GC\n\t\tif (!tls_desc)\n\t\t\ttls_desc = mono_gc_make_root_descr_user (mark_tls_slots);\n#endif\n\t\tstatic_data = mono_gc_alloc_fixed (static_data_size [0], threadlocal?tls_desc:NULL);\n\t\t*static_data_ptr = static_data;\n\t\tstatic_data [0] = static_data;\n\t}\n\n\tfor (i = 1; i <= idx; ++i) {\n\t\tif (static_data [i])\n\t\t\tcontinue;\n#ifdef HAVE_SGEN_GC\n\t\tstatic_data [i] = threadlocal?g_malloc0 (static_data_size [i]):mono_gc_alloc_fixed (static_data_size [i], NULL);\n#else\n\t\tstatic_data [i] = mono_gc_alloc_fixed (static_data_size [i], NULL);\n#endif\n\t}\n}\n\nstatic void \nmono_free_static_data (gpointer* static_data, gboolean threadlocal)\n{\n\tint i;\n\tfor (i = 1; i < NUM_STATIC_DATA_IDX; ++i) {\n\t\tif (!static_data [i])\n\t\t\tcontinue;\n#ifdef HAVE_SGEN_GC\n\t\tif (threadlocal)\n\t\t\tg_free (static_data [i]);\n\t\telse\n\t\t\tmono_gc_free_fixed (static_data [i]);\n#else\n\t\tmono_gc_free_fixed (static_data [i]);\n#endif\n\t}\n\tmono_gc_free_fixed (static_data);\n}\n\n/*\n *  mono_init_static_data_info\n *\n *   Initializes static data counters\n */\nstatic void mono_init_static_data_info (StaticDataInfo *static_data)\n{\n\tstatic_data->idx = 0;\n\tstatic_data->offset = 0;\n\tstatic_data->freelist = NULL;\n}\n\n/*\n *  mono_alloc_static_data_slot\n *\n *   Generates an offset for static data. static_data contains the counters\n *  used to generate it.\n */\nstatic guint32\nmono_alloc_static_data_slot (StaticDataInfo *static_data, guint32 size, guint32 align)\n{\n\tguint32 offset;\n\n\tif (!static_data->idx && !static_data->offset) {\n\t\t/* \n\t\t * we use the first chunk of the first allocation also as\n\t\t * an array for the rest of the data \n\t\t */\n\t\tstatic_data->offset = sizeof (gpointer) * NUM_STATIC_DATA_IDX;\n\t}\n\tstatic_data->offset += align - 1;\n\tstatic_data->offset &= ~(align - 1);\n\tif (static_data->offset + size >= static_data_size [static_data->idx]) {\n\t\tstatic_data->idx ++;\n\t\tg_assert (size <= static_data_size [static_data->idx]);\n\t\tg_assert (static_data->idx < NUM_STATIC_DATA_IDX);\n\t\tstatic_data->offset = 0;\n\t}\n\toffset = static_data->offset | ((static_data->idx + 1) << 24);\n\tstatic_data->offset += size;\n\treturn offset;\n}\n\n/* \n * ensure thread static fields already allocated are valid for thread\n * This function is called when a thread is created or on thread attach.\n */\nstatic void\nthread_adjust_static_data (MonoInternalThread *thread)\n{\n\tguint32 offset;\n\n\tmono_threads_lock ();\n\tif (thread_static_info.offset || thread_static_info.idx > 0) {\n\t\t/* get the current allocated size */\n\t\toffset = thread_static_info.offset | ((thread_static_info.idx + 1) << 24);\n\t\tmono_alloc_static_data (&(thread->static_data), offset, TRUE);\n\t}\n\tmono_threads_unlock ();\n}\n\nstatic void \nalloc_thread_static_data_helper (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread = value;\n\tguint32 offset = GPOINTER_TO_UINT (user);\n\n\tmono_alloc_static_data (&(thread->static_data), offset, TRUE);\n}\n\nstatic MonoThreadDomainTls*\nsearch_tls_slot_in_freelist (StaticDataInfo *static_data, guint32 size, guint32 align)\n{\n\tMonoThreadDomainTls* prev = NULL;\n\tMonoThreadDomainTls* tmp = static_data->freelist;\n\twhile (tmp) {\n\t\tif (tmp->size == size) {\n\t\t\tif (prev)\n\t\t\t\tprev->next = tmp->next;\n\t\t\telse\n\t\t\t\tstatic_data->freelist = tmp->next;\n\t\t\treturn tmp;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\treturn NULL;\n}\n\nstatic void\nupdate_tls_reference_bitmap (guint32 offset, uintptr_t *bitmap, int max_set)\n{\n\tint i;\n\tint idx = (offset >> 24) - 1;\n\tuintptr_t *rb;\n\tif (!static_reference_bitmaps [idx])\n\t\tstatic_reference_bitmaps [idx] = g_new0 (uintptr_t, 1 + static_data_size [idx] / sizeof(gpointer) / (sizeof(uintptr_t) * 8));\n\trb = static_reference_bitmaps [idx];\n\toffset &= 0xffffff;\n\toffset /= sizeof (gpointer);\n\t/* offset is now the bitmap offset */\n\tfor (i = 0; i < max_set; ++i) {\n\t\tif (bitmap [i / sizeof (uintptr_t)] & (1L << (i & (sizeof (uintptr_t) * 8 -1))))\n\t\t\trb [(offset + i) / (sizeof (uintptr_t) * 8)] |= (1L << ((offset + i) & (sizeof (uintptr_t) * 8 -1)));\n\t}\n}\n\nstatic void\nclear_reference_bitmap (guint32 offset, guint32 size)\n{\n\tint idx = (offset >> 24) - 1;\n\tuintptr_t *rb;\n\trb = static_reference_bitmaps [idx];\n\toffset &= 0xffffff;\n\toffset /= sizeof (gpointer);\n\tsize /= sizeof (gpointer);\n\tsize += offset;\n\t/* offset is now the bitmap offset */\n\tfor (; offset < size; ++offset)\n\t\trb [offset / (sizeof (uintptr_t) * 8)] &= ~(1L << (offset & (sizeof (uintptr_t) * 8 -1)));\n}\n\n/*\n * The offset for a special static variable is composed of three parts:\n * a bit that indicates the type of static data (0:thread, 1:context),\n * an index in the array of chunks of memory for the thread (thread->static_data)\n * and an offset in that chunk of mem. This allows allocating less memory in the \n * common case.\n */\n\nguint32\nmono_alloc_special_static_data (guint32 static_type, guint32 size, guint32 align, uintptr_t *bitmap, int max_set)\n{\n\tguint32 offset;\n\tif (static_type == SPECIAL_STATIC_THREAD) {\n\t\tMonoThreadDomainTls *item;\n\t\tmono_threads_lock ();\n\t\titem = search_tls_slot_in_freelist (&thread_static_info, size, align);\n\t\t/*g_print (\"TLS alloc: %d in domain %p (total: %d), cached: %p\\n\", size, mono_domain_get (), thread_static_info.offset, item);*/\n\t\tif (item) {\n\t\t\toffset = item->offset;\n\t\t\tg_free (item);\n\t\t} else {\n\t\t\toffset = mono_alloc_static_data_slot (&thread_static_info, size, align);\n\t\t}\n\t\tupdate_tls_reference_bitmap (offset, bitmap, max_set);\n\t\t/* This can be called during startup */\n\t\tif (threads != NULL)\n\t\t\tmono_g_hash_table_foreach (threads, alloc_thread_static_data_helper, GUINT_TO_POINTER (offset));\n\t\tmono_threads_unlock ();\n\t} else {\n\t\tg_assert (static_type == SPECIAL_STATIC_CONTEXT);\n\t\tmono_contexts_lock ();\n\t\toffset = mono_alloc_static_data_slot (&context_static_info, size, align);\n\t\tmono_contexts_unlock ();\n\t\toffset |= 0x80000000;\t/* Set the high bit to indicate context static data */\n\t}\n\treturn offset;\n}\n\ngpointer\nmono_get_special_static_data_for_thread (MonoInternalThread *thread, guint32 offset)\n{\n\t/* The high bit means either thread (0) or static (1) data. */\n\n\tguint32 static_type = (offset & 0x80000000);\n\tint idx;\n\n\toffset &= 0x7fffffff;\n\tidx = (offset >> 24) - 1;\n\n\tif (static_type == 0) {\n\t\treturn get_thread_static_data (thread, offset);\n\t} else {\n\t\t/* Allocate static data block under demand, since we don't have a list\n\t\t// of contexts\n\t\t*/\n\t\tMonoAppContext *context = mono_context_get ();\n\t\tif (!context->static_data || !context->static_data [idx]) {\n\t\t\tmono_contexts_lock ();\n\t\t\tmono_alloc_static_data (&(context->static_data), offset, FALSE);\n\t\t\tmono_contexts_unlock ();\n\t\t}\n\t\treturn ((char*) context->static_data [idx]) + (offset & 0xffffff);\t\n\t}\n}\n\ngpointer\nmono_get_special_static_data (guint32 offset)\n{\n\treturn mono_get_special_static_data_for_thread (mono_thread_internal_current (), offset);\n}\n\ntypedef struct {\n\tguint32 offset;\n\tguint32 size;\n} TlsOffsetSize;\n\nstatic void \nfree_thread_static_data_helper (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread = value;\n\tTlsOffsetSize *data = user;\n\tint idx = (data->offset >> 24) - 1;\n\tchar *ptr;\n\n\tif (!thread->static_data || !thread->static_data [idx])\n\t\treturn;\n\tptr = ((char*) thread->static_data [idx]) + (data->offset & 0xffffff);\n\tmemset (ptr, 0, data->size);\n}\n\nstatic void\ndo_free_special_slot (guint32 offset, guint32 size)\n{\n\tguint32 static_type = (offset & 0x80000000);\n\t/*g_print (\"free %s , size: %d, offset: %x\\n\", field->name, size, offset);*/\n\tif (static_type == 0) {\n\t\tTlsOffsetSize data;\n\t\tMonoThreadDomainTls *item = g_new0 (MonoThreadDomainTls, 1);\n\t\tdata.offset = offset & 0x7fffffff;\n\t\tdata.size = size;\n\t\tclear_reference_bitmap (data.offset, data.size);\n\t\tif (threads != NULL)\n\t\t\tmono_g_hash_table_foreach (threads, free_thread_static_data_helper, &data);\n\t\titem->offset = offset;\n\t\titem->size = size;\n\n\t\tif (!mono_runtime_is_shutting_down ()) {\n\t\t\titem->next = thread_static_info.freelist;\n\t\t\tthread_static_info.freelist = item;\n\t\t} else {\n\t\t\t/* We could be called during shutdown after mono_thread_cleanup () is called */\n\t\t\tg_free (item);\n\t\t}\n\t} else {\n\t\t/* FIXME: free context static data as well */\n\t}\n}\n\nstatic void\ndo_free_special (gpointer key, gpointer value, gpointer data)\n{\n\tMonoClassField *field = key;\n\tguint32 offset = GPOINTER_TO_UINT (value);\n\tgint32 align;\n\tguint32 size;\n\tsize = mono_type_size (field->type, &align);\n\tdo_free_special_slot (offset, size);\n}\n\nvoid\nmono_alloc_special_static_data_free (GHashTable *special_static_fields)\n{\n\tmono_threads_lock ();\n\tg_hash_table_foreach (special_static_fields, do_free_special, NULL);\n\tmono_threads_unlock ();\n}\n\nvoid\nmono_special_static_data_free_slot (guint32 offset, guint32 size)\n{\n\tmono_threads_lock ();\n\tdo_free_special_slot (offset, size);\n\tmono_threads_unlock ();\n}\n\n/*\n * allocates room in the thread local area for storing an instance of the struct type\n * the allocation is kept track of in domain->tlsrec_list.\n */\nuint32_t\nmono_thread_alloc_tls (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoClass *klass;\n\tMonoTlsDataRecord *tlsrec;\n\tint max_set = 0;\n\tgsize *bitmap;\n\tgsize default_bitmap [4] = {0};\n\tuint32_t tls_offset;\n\tguint32 size;\n\tgint32 align;\n\n\tklass = mono_class_from_mono_type (type->type);\n\t/* TlsDatum is a struct, so we subtract the object header size offset */\n\tbitmap = mono_class_compute_bitmap (klass, default_bitmap, sizeof (default_bitmap) * 8, - (int)(sizeof (MonoObject) / sizeof (gpointer)), &max_set, FALSE);\n\tsize = mono_type_size (type->type, &align);\n\ttls_offset = mono_alloc_special_static_data (SPECIAL_STATIC_THREAD, size, align, bitmap, max_set);\n\tif (bitmap != default_bitmap)\n\t\tg_free (bitmap);\n\ttlsrec = g_new0 (MonoTlsDataRecord, 1);\n\ttlsrec->tls_offset = tls_offset;\n\ttlsrec->size = size;\n\tmono_domain_lock (domain);\n\ttlsrec->next = domain->tlsrec_list;\n\tdomain->tlsrec_list = tlsrec;\n\tmono_domain_unlock (domain);\n\treturn tls_offset;\n}\n\nvoid\nmono_thread_destroy_tls (uint32_t tls_offset)\n{\n\tMonoTlsDataRecord *prev = NULL;\n\tMonoTlsDataRecord *cur;\n\tguint32 size = 0;\n\tMonoDomain *domain = mono_domain_get ();\n\tmono_domain_lock (domain);\n\tcur = domain->tlsrec_list;\n\twhile (cur) {\n\t\tif (cur->tls_offset == tls_offset) {\n\t\t\tif (prev)\n\t\t\t\tprev->next = cur->next;\n\t\t\telse\n\t\t\t\tdomain->tlsrec_list = cur->next;\n\t\t\tsize = cur->size;\n\t\t\tg_free (cur);\n\t\t\tbreak;\n\t\t}\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\tmono_domain_unlock (domain);\n\tif (size)\n\t\tmono_special_static_data_free_slot (tls_offset, size);\n}\n\n/*\n * This is just to ensure cleanup: the finalizers should have taken care, so this is not perf-critical.\n */\nvoid\nmono_thread_destroy_domain_tls (MonoDomain *domain)\n{\n\twhile (domain->tlsrec_list)\n\t\tmono_thread_destroy_tls (domain->tlsrec_list->tls_offset);\n}\n\nstatic MonoClassField *local_slots = NULL;\n\ntypedef struct {\n\t/* local tls data to get locals_slot from a thread */\n\tguint32 offset;\n\tint idx;\n\t/* index in the locals_slot array */\n\tint slot;\n} LocalSlotID;\n\nstatic void\nclear_local_slot (gpointer key, gpointer value, gpointer user_data)\n{\n\tLocalSlotID *sid = user_data;\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tMonoArray *slots_array;\n\t/*\n\t * the static field is stored at: ((char*) thread->static_data [idx]) + (offset & 0xffffff);\n\t * it is for the right domain, so we need to check if it is allocated an initialized\n\t * for the current thread.\n\t */\n\t/*g_print (\"handling thread %p\\n\", thread);*/\n\tif (!thread->static_data || !thread->static_data [sid->idx])\n\t\treturn;\n\tslots_array = *(MonoArray **)(((char*) thread->static_data [sid->idx]) + (sid->offset & 0xffffff));\n\tif (!slots_array || sid->slot >= mono_array_length (slots_array))\n\t\treturn;\n\tmono_array_set (slots_array, MonoObject*, sid->slot, NULL);\n}\n\nvoid\nmono_thread_free_local_slot_values (int slot, MonoBoolean thread_local)\n{\n\tMonoDomain *domain;\n\tLocalSlotID sid;\n\tsid.slot = slot;\n\tif (thread_local) {\n\t\tvoid *addr = NULL;\n\t\tif (!local_slots) {\n\t\t\tlocal_slots = mono_class_get_field_from_name (mono_defaults.thread_class, \"local_slots\");\n\t\t\tif (!local_slots) {\n\t\t\t\tg_warning (\"local_slots field not found in Thread class\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdomain = mono_domain_get ();\n\t\tmono_domain_lock (domain);\n\t\tif (domain->special_static_fields)\n\t\t\taddr = g_hash_table_lookup (domain->special_static_fields, local_slots);\n\t\tmono_domain_unlock (domain);\n\t\tif (!addr)\n\t\t\treturn;\n\t\t/*g_print (\"freeing slot %d at %p\\n\", slot, addr);*/\n\t\tsid.offset = GPOINTER_TO_UINT (addr);\n\t\tsid.offset &= 0x7fffffff;\n\t\tsid.idx = (sid.offset >> 24) - 1;\n\t\tmono_threads_lock ();\n\t\tmono_g_hash_table_foreach (threads, clear_local_slot, &sid);\n\t\tmono_threads_unlock ();\n\t} else {\n\t\t/* FIXME: clear the slot for MonoAppContexts, too */\n\t}\n}\n\n#ifdef HOST_WIN32\nstatic void CALLBACK dummy_apc (ULONG_PTR param)\n{\n}\n#else\nstatic guint32 dummy_apc (gpointer param)\n{\n\treturn 0;\n}\n#endif\n\n/*\n * mono_thread_execute_interruption\n * \n * Performs the operation that the requested thread state requires (abort,\n * suspend or stop)\n */\nstatic MonoException* mono_thread_execute_interruption (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\t/* MonoThread::interruption_requested can only be changed with atomics */\n\tif (InterlockedCompareExchange (&thread->interruption_requested, FALSE, TRUE)) {\n\t\t/* this will consume pending APC calls */\n\t\tWaitForSingleObjectEx (GetCurrentThread(), 0, TRUE);\n\t\tInterlockedDecrement (&thread_interruption_requested);\n#ifndef HOST_WIN32\n\t\t/* Clear the interrupted flag of the thread so it can wait again */\n\t\twapi_clear_interruption ();\n#endif\n\t}\n\n\tif ((thread->state & ThreadState_AbortRequested) != 0) {\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\tif (thread->abort_exc == NULL) {\n\t\t\t/* \n\t\t\t * This might be racy, but it has to be called outside the lock\n\t\t\t * since it calls managed code.\n\t\t\t */\n\t\t\tMONO_OBJECT_SETREF (thread, abort_exc, mono_get_exception_thread_abort ());\n\t\t}\n\t\treturn thread->abort_exc;\n\t}\n\telse if ((thread->state & ThreadState_SuspendRequested) != 0) {\n\t\tthread->state &= ~ThreadState_SuspendRequested;\n\t\tthread->state |= ThreadState_Suspended;\n\t\tthread->suspend_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\t\tif (thread->suspend_event == NULL) {\n\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\treturn(NULL);\n\t\t}\n\t\tif (thread->suspended_event)\n\t\t\tSetEvent (thread->suspended_event);\n\n\t\tLeaveCriticalSection (thread->synch_cs);\n\n\t\tif (shutting_down) {\n\t\t\t/* After we left the lock, the runtime might shut down so everything becomes invalid */\n\t\t\tfor (;;)\n\t\t\t\tSleep (1000);\n\t\t}\n\t\t\n\t\tWaitForSingleObject (thread->suspend_event, INFINITE);\n\t\t\n\t\tEnterCriticalSection (thread->synch_cs);\n\n\t\tCloseHandle (thread->suspend_event);\n\t\tthread->suspend_event = NULL;\n\t\tthread->state &= ~ThreadState_Suspended;\n\t\n\t\t/* The thread that requested the resume will have replaced this event\n\t\t * and will be waiting for it\n\t\t */\n\t\tSetEvent (thread->resume_event);\n\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\n\t\treturn NULL;\n\t}\n\telse if ((thread->state & ThreadState_StopRequested) != 0) {\n\t\t/* FIXME: do this through the JIT? */\n\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\n\t\tmono_thread_exit ();\n\t\treturn NULL;\n\t} else if (thread->thread_interrupt_requested) {\n\n\t\tthread->thread_interrupt_requested = FALSE;\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\n\t\treturn(mono_get_exception_thread_interrupted ());\n\t}\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\treturn NULL;\n}\n\n/*\n * mono_thread_request_interruption\n *\n * A signal handler can call this method to request the interruption of a\n * thread. The result of the interruption will depend on the current state of\n * the thread. If the result is an exception that needs to be throw, it is \n * provided as return value.\n */\nMonoException*\nmono_thread_request_interruption (gboolean running_managed)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL) \n\t\treturn NULL;\n\n#ifdef HOST_WIN32\n\tif (thread->interrupt_on_stop && \n\t\tthread->state & ThreadState_StopRequested && \n\t\tthread->state & ThreadState_Background)\n\t\tExitThread (1);\n#endif\n\t\n\tif (InterlockedCompareExchange (&thread->interruption_requested, 1, 0) == 1)\n\t\treturn NULL;\n\n\tif (!running_managed || is_running_protected_wrapper ()) {\n\t\t/* Can't stop while in unmanaged code. Increase the global interruption\n\t\t   request count. When exiting the unmanaged method the count will be\n\t\t   checked and the thread will be interrupted. */\n\t\t\n\t\tInterlockedIncrement (&thread_interruption_requested);\n\n\t\tif (mono_thread_notify_pending_exc_fn && !running_managed)\n\t\t\t/* The JIT will notify the thread about the interruption */\n\t\t\t/* This shouldn't take any locks */\n\t\t\tmono_thread_notify_pending_exc_fn ();\n\n\t\t/* this will awake the thread if it is in WaitForSingleObject \n\t\t   or similar */\n\t\t/* Our implementation of this function ignores the func argument */\n\t\tQueueUserAPC ((PAPCFUNC)dummy_apc, thread->handle, NULL);\n\t\treturn NULL;\n\t}\n\telse {\n\t\treturn mono_thread_execute_interruption (thread);\n\t}\n}\n\n/*This function should be called by a thread after it has exited all of\n * its handle blocks at interruption time.*/\nMonoException*\nmono_thread_resume_interruption (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tgboolean still_aborting;\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn NULL;\n\n\tensure_synch_cs_set (thread);\n\tEnterCriticalSection (thread->synch_cs);\n\tstill_aborting = (thread->state & ThreadState_AbortRequested) != 0;\n\tLeaveCriticalSection (thread->synch_cs);\n\n\t/*This can happen if the protected block called Thread::ResetAbort*/\n\tif (!still_aborting)\n\t\treturn FALSE;\n\n\tif (InterlockedCompareExchange (&thread->interruption_requested, 1, 0) == 1)\n\t\treturn NULL;\n\tInterlockedIncrement (&thread_interruption_requested);\n\n#ifndef HOST_WIN32\n\twapi_self_interrupt ();\n#endif\n\treturn mono_thread_execute_interruption (thread);\n}\n\ngboolean mono_thread_interruption_requested ()\n{\n\tif (thread_interruption_requested) {\n\t\tMonoInternalThread *thread = mono_thread_internal_current ();\n\t\t/* The thread may already be stopping */\n\t\tif (thread != NULL) \n\t\t\treturn (thread->interruption_requested);\n\t}\n\treturn FALSE;\n}\n\nstatic void mono_thread_interruption_checkpoint_request (gboolean bypass_abort_protection)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn;\n\n\tmono_debugger_check_interruption ();\n\n\tif (thread->interruption_requested && (bypass_abort_protection || !is_running_protected_wrapper ())) {\n\t\tMonoException* exc = mono_thread_execute_interruption (thread);\n\t\tif (exc) mono_raise_exception (exc);\n\t}\n}\n\n/*\n * Performs the interruption of the current thread, if one has been requested,\n * and the thread is not running a protected wrapper.\n */\nvoid mono_thread_interruption_checkpoint ()\n{\n\tmono_thread_interruption_checkpoint_request (FALSE);\n}\n\n/*\n * Performs the interruption of the current thread, if one has been requested.\n */\nvoid mono_thread_force_interruption_checkpoint ()\n{\n\tmono_thread_interruption_checkpoint_request (TRUE);\n}\n\n/*\n * mono_thread_get_and_clear_pending_exception:\n *\n *   Return any pending exceptions for the current thread and clear it as a side effect.\n */\nMonoException*\nmono_thread_get_and_clear_pending_exception (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn NULL;\n\n\tif (thread->interruption_requested && !is_running_protected_wrapper ()) {\n\t\treturn mono_thread_execute_interruption (thread);\n\t}\n\t\n\tif (thread->pending_exception) {\n\t\tMonoException *exc = thread->pending_exception;\n\n\t\tthread->pending_exception = NULL;\n\t\treturn exc;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * mono_set_pending_exception:\n *\n *   Set the pending exception of the current thread to EXC. On platforms which \n * support it, the exception will be thrown when execution returns to managed code. \n * On other platforms, this function is equivalent to mono_raise_exception (). \n * Internal calls which report exceptions using this function instead of \n * raise_exception () might be called by JITted code using a more efficient calling \n * convention.\n */\nvoid\nmono_set_pending_exception (MonoException *exc)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn;\n\n\tif (mono_thread_notify_pending_exc_fn) {\n\t\tMONO_OBJECT_SETREF (thread, pending_exception, exc);\n\n\t\tmono_thread_notify_pending_exc_fn ();\n\t} else {\n\t\t/* No way to notify the JIT about the exception, have to throw it now */\n\t\tmono_raise_exception (exc);\n\t}\n}\n\n/**\n * mono_thread_interruption_request_flag:\n *\n * Returns the address of a flag that will be non-zero if an interruption has\n * been requested for a thread. The thread to interrupt may not be the current\n * thread, so an additional call to mono_thread_interruption_requested() or\n * mono_thread_interruption_checkpoint() is allways needed if the flag is not\n * zero.\n */\ngint32* mono_thread_interruption_request_flag ()\n{\n\treturn &thread_interruption_requested;\n}\n\nvoid \nmono_thread_init_apartment_state (void)\n{\n#ifdef HOST_WIN32\n\tMonoInternalThread* thread = mono_thread_internal_current ();\n\n\t/* Positive return value indicates success, either\n\t * S_OK if this is first CoInitialize call, or\n\t * S_FALSE if CoInitialize already called, but with same\n\t * threading model. A negative value indicates failure,\n\t * probably due to trying to change the threading model.\n\t */\n\tif (CoInitializeEx(NULL, (thread->apartment_state == ThreadApartmentState_STA) \n\t\t\t? COINIT_APARTMENTTHREADED \n\t\t\t: COINIT_MULTITHREADED) < 0) {\n\t\tthread->apartment_state = ThreadApartmentState_Unknown;\n\t}\n#endif\n}\n\nvoid \nmono_thread_cleanup_apartment_state (void)\n{\n#ifdef HOST_WIN32\n\tMonoInternalThread* thread = mono_thread_internal_current ();\n\n\tif (thread && thread->apartment_state != ThreadApartmentState_Unknown) {\n\t\tCoUninitialize ();\n\t}\n#endif\n}\n\nvoid\nmono_thread_set_state (MonoInternalThread *thread, MonoThreadState state)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\tthread->state |= state;\n\tLeaveCriticalSection (thread->synch_cs);\n}\n\nvoid\nmono_thread_clr_state (MonoInternalThread *thread, MonoThreadState state)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\tthread->state &= ~state;\n\tLeaveCriticalSection (thread->synch_cs);\n}\n\ngboolean\nmono_thread_test_state (MonoInternalThread *thread, MonoThreadState test)\n{\n\tgboolean ret = FALSE;\n\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & test) != 0) {\n\t\tret = TRUE;\n\t}\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\treturn ret;\n}\n\nstatic MonoClassField *execution_context_field;\n\nstatic MonoObject**\nget_execution_context_addr (void)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tguint32 offset;\n\n\tif (!execution_context_field) {\n\t\texecution_context_field = mono_class_get_field_from_name (mono_defaults.thread_class,\n\t\t\t\t\"_ec\");\n\t\tg_assert (execution_context_field);\n\t}\n\n\tg_assert (mono_class_try_get_vtable (domain, mono_defaults.appdomain_class));\n\n\tmono_domain_lock (domain);\n\toffset = GPOINTER_TO_UINT (g_hash_table_lookup (domain->special_static_fields, execution_context_field));\n\tmono_domain_unlock (domain);\n\tg_assert (offset);\n\n\treturn (MonoObject**) mono_get_special_static_data (offset);\n}\n\nMonoObject*\nmono_thread_get_execution_context (void)\n{\n\treturn *get_execution_context_addr ();\n}\n\nvoid\nmono_thread_set_execution_context (MonoObject *ec)\n{\n\t*get_execution_context_addr () = ec;\n}\n\nstatic gboolean has_tls_get = FALSE;\n\nvoid\nmono_runtime_set_has_tls_get (gboolean val)\n{\n\thas_tls_get = val;\n}\n\ngboolean\nmono_runtime_has_tls_get (void)\n{\n\treturn has_tls_get;\n}\n\nint\nmono_thread_kill (MonoInternalThread *thread, int signal)\n{\n#ifdef HOST_WIN32\n\t/* Win32 uses QueueUserAPC and callers of this are guarded */\n\tg_assert_not_reached ();\n#else\n#  ifdef PTHREAD_POINTER_ID\n\treturn pthread_kill ((gpointer)(gsize)(thread->tid), mono_thread_get_abort_signal ());\n#  else\n#    ifdef PLATFORM_ANDROID\n\tif (thread->android_tid != 0) {\n\t\tint  ret;\n\t\tint  old_errno = errno;\n\n\t\tret = tkill ((pid_t) thread->android_tid, signal);\n\t\tif (ret < 0) {\n\t\t\tret = errno;\n\t\t\terrno = old_errno;\n\t\t}\n\n\t\treturn ret;\n\t}\n\telse\n\t\treturn pthread_kill (thread->tid, mono_thread_get_abort_signal ());\n#    else\n\treturn pthread_kill (thread->tid, mono_thread_get_abort_signal ());\n#    endif\n#  endif\n#endif\n}\n"], "fixing_code": ["/*\n * threads.c: Thread support internal calls\n *\n * Author:\n *\tDick Porter (dick@ximian.com)\n *\tPaolo Molaro (lupus@ximian.com)\n *\tPatrik Torstensson (patrik.torstensson@labs2.com)\n *\n * Copyright 2001-2003 Ximian, Inc (http://www.ximian.com)\n * Copyright 2004-2009 Novell, Inc (http://www.novell.com)\n */\n\n#include <config.h>\n\n#include <glib.h>\n#include <signal.h>\n#include <string.h>\n\n#if defined(__OpenBSD__)\n#include <pthread.h>\n#include <pthread_np.h>\n#endif\n\n#include <mono/metadata/object.h>\n#include <mono/metadata/domain-internals.h>\n#include <mono/metadata/profiler-private.h>\n#include <mono/metadata/threads.h>\n#include <mono/metadata/threadpool.h>\n#include <mono/metadata/threads-types.h>\n#include <mono/metadata/exception.h>\n#include <mono/metadata/environment.h>\n#include <mono/metadata/monitor.h>\n#include <mono/metadata/gc-internal.h>\n#include <mono/metadata/marshal.h>\n#include <mono/io-layer/io-layer.h>\n#ifndef HOST_WIN32\n#include <mono/io-layer/threads.h>\n#endif\n#include <mono/metadata/object-internals.h>\n#include <mono/metadata/mono-debug-debugger.h>\n#include <mono/utils/mono-compiler.h>\n#include <mono/utils/mono-mmap.h>\n#include <mono/utils/mono-membar.h>\n#include <mono/utils/mono-time.h>\n#include <mono/utils/hazard-pointer.h>\n\n#include <mono/metadata/gc-internal.h>\n\n#ifdef PLATFORM_ANDROID\n#include <errno.h>\n\nextern int tkill (pid_t tid, int signal);\n#endif\n\n/*#define THREAD_DEBUG(a) do { a; } while (0)*/\n#define THREAD_DEBUG(a)\n/*#define THREAD_WAIT_DEBUG(a) do { a; } while (0)*/\n#define THREAD_WAIT_DEBUG(a)\n/*#define LIBGC_DEBUG(a) do { a; } while (0)*/\n#define LIBGC_DEBUG(a)\n\n#define SPIN_TRYLOCK(i) (InterlockedCompareExchange (&(i), 1, 0) == 0)\n#define SPIN_LOCK(i) do { \\\n\t\t\t\tif (SPIN_TRYLOCK (i)) \\\n\t\t\t\t\tbreak; \\\n\t\t\t} while (1)\n\n#define SPIN_UNLOCK(i) i = 0\n\n/* Provide this for systems with glib < 2.6 */\n#ifndef G_GSIZE_FORMAT\n#   if GLIB_SIZEOF_LONG == 8\n#       define G_GSIZE_FORMAT \"lu\"\n#   else\n#       define G_GSIZE_FORMAT \"u\"\n#   endif\n#endif\n\nstruct StartInfo \n{\n\tguint32 (*func)(void *);\n\tMonoThread *obj;\n\tMonoObject *delegate;\n\tvoid *start_arg;\n};\n\ntypedef union {\n\tgint32 ival;\n\tgfloat fval;\n} IntFloatUnion;\n\ntypedef union {\n\tgint64 ival;\n\tgdouble fval;\n} LongDoubleUnion;\n \ntypedef struct _MonoThreadDomainTls MonoThreadDomainTls;\nstruct _MonoThreadDomainTls {\n\tMonoThreadDomainTls *next;\n\tguint32 offset;\n\tguint32 size;\n};\n\ntypedef struct {\n\tint idx;\n\tint offset;\n\tMonoThreadDomainTls *freelist;\n} StaticDataInfo;\n\n/* Number of cached culture objects in the MonoThread->cached_culture_info array\n * (per-type): we use the first NUM entries for CultureInfo and the last for\n * UICultureInfo. So the size of the array is really NUM_CACHED_CULTURES * 2.\n */\n#define NUM_CACHED_CULTURES 4\n#define CULTURES_START_IDX 0\n#define UICULTURES_START_IDX NUM_CACHED_CULTURES\n\n/* Controls access to the 'threads' hash table */\n#define mono_threads_lock() EnterCriticalSection (&threads_mutex)\n#define mono_threads_unlock() LeaveCriticalSection (&threads_mutex)\nstatic CRITICAL_SECTION threads_mutex;\n\n/* Controls access to context static data */\n#define mono_contexts_lock() EnterCriticalSection (&contexts_mutex)\n#define mono_contexts_unlock() LeaveCriticalSection (&contexts_mutex)\nstatic CRITICAL_SECTION contexts_mutex;\n\n/* Holds current status of static data heap */\nstatic StaticDataInfo thread_static_info;\nstatic StaticDataInfo context_static_info;\n\n/* The hash of existing threads (key is thread ID, value is\n * MonoInternalThread*) that need joining before exit\n */\nstatic MonoGHashTable *threads=NULL;\n\n/*\n * Threads which are starting up and they are not in the 'threads' hash yet.\n * When handle_store is called for a thread, it will be removed from this hash table.\n * Protected by mono_threads_lock ().\n */\nstatic MonoGHashTable *threads_starting_up = NULL;\n \n/* Maps a MonoThread to its start argument */\n/* Protected by mono_threads_lock () */\nstatic MonoGHashTable *thread_start_args = NULL;\n\n/* The TLS key that holds the MonoObject assigned to each thread */\nstatic guint32 current_object_key = -1;\n\n#ifdef MONO_HAVE_FAST_TLS\n/* we need to use both the Tls* functions and __thread because\n * the gc needs to see all the threads \n */\nMONO_FAST_TLS_DECLARE(tls_current_object);\n#define SET_CURRENT_OBJECT(x) do { \\\n\tMONO_FAST_TLS_SET (tls_current_object, x); \\\n\tTlsSetValue (current_object_key, x); \\\n} while (FALSE)\n#define GET_CURRENT_OBJECT() ((MonoInternalThread*) MONO_FAST_TLS_GET (tls_current_object))\n#else\n#define SET_CURRENT_OBJECT(x) TlsSetValue (current_object_key, x)\n#define GET_CURRENT_OBJECT() (MonoInternalThread*) TlsGetValue (current_object_key)\n#endif\n\n/* function called at thread start */\nstatic MonoThreadStartCB mono_thread_start_cb = NULL;\n\n/* function called at thread attach */\nstatic MonoThreadAttachCB mono_thread_attach_cb = NULL;\n\n/* function called at thread cleanup */\nstatic MonoThreadCleanupFunc mono_thread_cleanup_fn = NULL;\n\n/* function called to notify the runtime about a pending exception on the current thread */\nstatic MonoThreadNotifyPendingExcFunc mono_thread_notify_pending_exc_fn = NULL;\n\n/* The default stack size for each thread */\nstatic guint32 default_stacksize = 0;\n#define default_stacksize_for_thread(thread) ((thread)->stack_size? (thread)->stack_size: default_stacksize)\n\nstatic void thread_adjust_static_data (MonoInternalThread *thread);\nstatic void mono_free_static_data (gpointer* static_data, gboolean threadlocal);\nstatic void mono_init_static_data_info (StaticDataInfo *static_data);\nstatic guint32 mono_alloc_static_data_slot (StaticDataInfo *static_data, guint32 size, guint32 align);\nstatic gboolean mono_thread_resume (MonoInternalThread* thread);\nstatic void mono_thread_start (MonoThread *thread);\nstatic void signal_thread_state_change (MonoInternalThread *thread);\n\nstatic MonoException* mono_thread_execute_interruption (MonoInternalThread *thread);\nstatic void ref_stack_destroy (gpointer rs);\n\n/* Spin lock for InterlockedXXX 64 bit functions */\n#define mono_interlocked_lock() EnterCriticalSection (&interlocked_mutex)\n#define mono_interlocked_unlock() LeaveCriticalSection (&interlocked_mutex)\nstatic CRITICAL_SECTION interlocked_mutex;\n\n/* global count of thread interruptions requested */\nstatic gint32 thread_interruption_requested = 0;\n\n/* Event signaled when a thread changes its background mode */\nstatic HANDLE background_change_event;\n\nstatic gboolean shutting_down = FALSE;\n\nguint32\nmono_thread_get_tls_key (void)\n{\n\treturn current_object_key;\n}\n\ngint32\nmono_thread_get_tls_offset (void)\n{\n\tint offset;\n\tMONO_THREAD_VAR_OFFSET (tls_current_object,offset);\n\treturn offset;\n}\n\n/* handle_store() and handle_remove() manage the array of threads that\n * still need to be waited for when the main thread exits.\n *\n * If handle_store() returns FALSE the thread must not be started\n * because Mono is shutting down.\n */\nstatic gboolean handle_store(MonoThread *thread)\n{\n\tmono_threads_lock ();\n\n\tTHREAD_DEBUG (g_message (\"%s: thread %p ID %\"G_GSIZE_FORMAT, __func__, thread, (gsize)thread->internal_thread->tid));\n\n\tif (threads_starting_up)\n\t\tmono_g_hash_table_remove (threads_starting_up, thread);\n\n\tif (shutting_down) {\n\t\tmono_threads_unlock ();\n\t\treturn FALSE;\n\t}\n\n\tif(threads==NULL) {\n\t\tMONO_GC_REGISTER_ROOT_FIXED (threads);\n\t\tthreads=mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_VALUE_GC);\n\t}\n\n\t/* We don't need to duplicate thread->handle, because it is\n\t * only closed when the thread object is finalized by the GC.\n\t */\n\tg_assert (thread->internal_thread);\n\tmono_g_hash_table_insert(threads, (gpointer)(gsize)(thread->internal_thread->tid),\n\t\t\t\t thread->internal_thread);\n\n\tmono_threads_unlock ();\n\n\treturn TRUE;\n}\n\nstatic gboolean handle_remove(MonoInternalThread *thread)\n{\n\tgboolean ret;\n\tgsize tid = thread->tid;\n\n\tTHREAD_DEBUG (g_message (\"%s: thread ID %\"G_GSIZE_FORMAT, __func__, tid));\n\n\tmono_threads_lock ();\n\n\tif (threads) {\n\t\t/* We have to check whether the thread object for the\n\t\t * tid is still the same in the table because the\n\t\t * thread might have been destroyed and the tid reused\n\t\t * in the meantime, in which case the tid would be in\n\t\t * the table, but with another thread object.\n\t\t */\n\t\tif (mono_g_hash_table_lookup (threads, (gpointer)tid) == thread) {\n\t\t\tmono_g_hash_table_remove (threads, (gpointer)tid);\n\t\t\tret = TRUE;\n\t\t} else {\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\telse\n\t\tret = FALSE;\n\t\n\tmono_threads_unlock ();\n\n\t/* Don't close the handle here, wait for the object finalizer\n\t * to do it. Otherwise, the following race condition applies:\n\t *\n\t * 1) Thread exits (and handle_remove() closes the handle)\n\t *\n\t * 2) Some other handle is reassigned the same slot\n\t *\n\t * 3) Another thread tries to join the first thread, and\n\t * blocks waiting for the reassigned handle to be signalled\n\t * (which might never happen).  This is possible, because the\n\t * thread calling Join() still has a reference to the first\n\t * thread's object.\n\t */\n\treturn ret;\n}\n\nstatic void ensure_synch_cs_set (MonoInternalThread *thread)\n{\n\tCRITICAL_SECTION *synch_cs;\n\t\n\tif (thread->synch_cs != NULL) {\n\t\treturn;\n\t}\n\t\n\tsynch_cs = g_new0 (CRITICAL_SECTION, 1);\n\tInitializeCriticalSection (synch_cs);\n\t\n\tif (InterlockedCompareExchangePointer ((gpointer *)&thread->synch_cs,\n\t\t\t\t\t       synch_cs, NULL) != NULL) {\n\t\t/* Another thread must have installed this CS */\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n}\n\n/*\n * NOTE: this function can be called also for threads different from the current one:\n * make sure no code called from it will ever assume it is run on the thread that is\n * getting cleaned up.\n */\nstatic void thread_cleanup (MonoInternalThread *thread)\n{\n\tg_assert (thread != NULL);\n\n\tif (thread->abort_state_handle) {\n\t\tmono_gchandle_free (thread->abort_state_handle);\n\t\tthread->abort_state_handle = 0;\n\t}\n\tthread->abort_exc = NULL;\n\tthread->current_appcontext = NULL;\n\n\t/*\n\t * This is necessary because otherwise we might have\n\t * cross-domain references which will not get cleaned up when\n\t * the target domain is unloaded.\n\t */\n\tif (thread->cached_culture_info) {\n\t\tint i;\n\t\tfor (i = 0; i < NUM_CACHED_CULTURES * 2; ++i)\n\t\t\tmono_array_set (thread->cached_culture_info, MonoObject*, i, NULL);\n\t}\n\n\t/* if the thread is not in the hash it has been removed already */\n\tif (!handle_remove (thread)) {\n\t\t/* This needs to be called even if handle_remove () fails */\n\t\tif (mono_thread_cleanup_fn)\n\t\t\tmono_thread_cleanup_fn (thread);\n\t\treturn;\n\t}\n\tmono_release_type_locks (thread);\n\n\tEnterCriticalSection (thread->synch_cs);\n\n\tthread->state |= ThreadState_Stopped;\n\tthread->state &= ~ThreadState_Background;\n\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\tmono_profiler_thread_end (thread->tid);\n\n\tif (thread == mono_thread_internal_current ())\n\t\tmono_thread_pop_appdomain_ref ();\n\n\tthread->cached_culture_info = NULL;\n\n\tmono_free_static_data (thread->static_data, TRUE);\n\tthread->static_data = NULL;\n\tref_stack_destroy (thread->appdomain_refs);\n\tthread->appdomain_refs = NULL;\n\n\tif (mono_thread_cleanup_fn)\n\t\tmono_thread_cleanup_fn (thread);\n\n\tmono_thread_small_id_free (thread->small_id);\n\tMONO_GC_UNREGISTER_ROOT (thread->thread_pinning_ref);\n\tthread->small_id = -2;\n}\n\nstatic gpointer\nget_thread_static_data (MonoInternalThread *thread, guint32 offset)\n{\n\tint idx;\n\tg_assert ((offset & 0x80000000) == 0);\n\toffset &= 0x7fffffff;\n\tidx = (offset >> 24) - 1;\n\treturn ((char*) thread->static_data [idx]) + (offset & 0xffffff);\n}\n\nstatic MonoThread**\nget_current_thread_ptr_for_domain (MonoDomain *domain, MonoInternalThread *thread)\n{\n\tstatic MonoClassField *current_thread_field = NULL;\n\n\tguint32 offset;\n\n\tif (!current_thread_field) {\n\t\tcurrent_thread_field = mono_class_get_field_from_name (mono_defaults.thread_class, \"current_thread\");\n\t\tg_assert (current_thread_field);\n\t}\n\n\tmono_class_vtable (domain, mono_defaults.thread_class);\n\tmono_domain_lock (domain);\n\toffset = GPOINTER_TO_UINT (g_hash_table_lookup (domain->special_static_fields, current_thread_field));\n\tmono_domain_unlock (domain);\n\tg_assert (offset);\n\n\treturn get_thread_static_data (thread, offset);\n}\n\nstatic void\nset_current_thread_for_domain (MonoDomain *domain, MonoInternalThread *thread, MonoThread *current)\n{\n\tMonoThread **current_thread_ptr = get_current_thread_ptr_for_domain (domain, thread);\n\n\tg_assert (current->obj.vtable->domain == domain);\n\n\tg_assert (!*current_thread_ptr);\n\t*current_thread_ptr = current;\n}\n\nstatic MonoInternalThread*\ncreate_internal_thread_object (void)\n{\n\tMonoVTable *vt = mono_class_vtable (mono_get_root_domain (), mono_defaults.internal_thread_class);\n\treturn (MonoInternalThread*)mono_gc_alloc_mature (vt);\n}\n\nstatic MonoThread*\ncreate_thread_object (MonoDomain *domain)\n{\n\tMonoVTable *vt = mono_class_vtable (domain, mono_defaults.thread_class);\n\treturn (MonoThread*)mono_gc_alloc_mature (vt);\n}\n\nstatic MonoThread*\nnew_thread_with_internal (MonoDomain *domain, MonoInternalThread *internal)\n{\n\tMonoThread *thread = create_thread_object (domain);\n\tMONO_OBJECT_SETREF (thread, internal_thread, internal);\n\treturn thread;\n}\n\nstatic void\ninit_root_domain_thread (MonoInternalThread *thread, MonoThread *candidate)\n{\n\tMonoDomain *domain = mono_get_root_domain ();\n\n\tif (!candidate || candidate->obj.vtable->domain != domain)\n\t\tcandidate = new_thread_with_internal (domain, thread);\n\tset_current_thread_for_domain (domain, thread, candidate);\n\tg_assert (!thread->root_domain_thread);\n\tMONO_OBJECT_SETREF (thread, root_domain_thread, candidate);\n}\n\nstatic guint32 WINAPI start_wrapper_internal(void *data)\n{\n\tstruct StartInfo *start_info=(struct StartInfo *)data;\n\tguint32 (*start_func)(void *);\n\tvoid *start_arg;\n\tgsize tid;\n\t/* \n\t * We don't create a local to hold start_info->obj, so hopefully it won't get pinned during a\n\t * GC stack walk.\n\t */\n\tMonoInternalThread *internal = start_info->obj->internal_thread;\n\tMonoObject *start_delegate = start_info->delegate;\n\tMonoDomain *domain = start_info->obj->obj.vtable->domain;\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Start wrapper\", __func__, GetCurrentThreadId ()));\n\n\t/* We can be sure start_info->obj->tid and\n\t * start_info->obj->handle have been set, because the thread\n\t * was created suspended, and these values were set before the\n\t * thread resumed\n\t */\n\n\ttid=internal->tid;\n\n\tSET_CURRENT_OBJECT (internal);\n\n\tmono_monitor_init_tls ();\n\n\t/* Every thread references the appdomain which created it */\n\tmono_thread_push_appdomain_ref (domain);\n\t\n\tif (!mono_domain_set (domain, FALSE)) {\n\t\t/* No point in raising an appdomain_unloaded exception here */\n\t\t/* FIXME: Cleanup here */\n\t\tmono_thread_pop_appdomain_ref ();\n\t\treturn 0;\n\t}\n\n\tstart_func = start_info->func;\n\tstart_arg = start_info->start_arg;\n\n\t/* We have to do this here because mono_thread_new_init()\n\t   requires that root_domain_thread is set up. */\n\tthread_adjust_static_data (internal);\n\tinit_root_domain_thread (internal, start_info->obj);\n\n\t/* This MUST be called before any managed code can be\n\t * executed, as it calls the callback function that (for the\n\t * jit) sets the lmf marker.\n\t */\n\tmono_thread_new_init (tid, &tid, start_func);\n\tinternal->stack_ptr = &tid;\n\n\tLIBGC_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\",%d) Setting thread stack to %p\", __func__, GetCurrentThreadId (), getpid (), thread->stack_ptr));\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Setting current_object_key to %p\", __func__, GetCurrentThreadId (), internal));\n\n\t/* On 2.0 profile (and higher), set explicitly since state might have been\n\t   Unknown */\n\tif (internal->apartment_state == ThreadApartmentState_Unknown)\n\t\tinternal->apartment_state = ThreadApartmentState_MTA;\n\n\tmono_thread_init_apartment_state ();\n\n\tif(internal->start_notify!=NULL) {\n\t\t/* Let the thread that called Start() know we're\n\t\t * ready\n\t\t */\n\t\tReleaseSemaphore (internal->start_notify, 1, NULL);\n\t}\n\n\tmono_threads_lock ();\n\tmono_g_hash_table_remove (thread_start_args, start_info->obj);\n\tmono_threads_unlock ();\n\n\tmono_thread_set_execution_context (start_info->obj->ec_to_set);\n\tstart_info->obj->ec_to_set = NULL;\n\n\tg_free (start_info);\n\tTHREAD_DEBUG (g_message (\"%s: start_wrapper for %\"G_GSIZE_FORMAT, __func__,\n\t\t\t\t\t\t\t internal->tid));\n\n\t/* \n\t * Call this after calling start_notify, since the profiler callback might want\n\t * to lock the thread, and the lock is held by thread_start () which waits for\n\t * start_notify.\n\t */\n\tmono_profiler_thread_start (tid);\n\n\t/* start_func is set only for unmanaged start functions */\n\tif (start_func) {\n\t\tstart_func (start_arg);\n\t} else {\n\t\tvoid *args [1];\n\t\tg_assert (start_delegate != NULL);\n\t\targs [0] = start_arg;\n\t\t/* we may want to handle the exception here. See comment below on unhandled exceptions */\n\t\tmono_runtime_delegate_invoke (start_delegate, args, NULL);\n\t}\n\n\t/* If the thread calls ExitThread at all, this remaining code\n\t * will not be executed, but the main thread will eventually\n\t * call thread_cleanup() on this thread's behalf.\n\t */\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Start wrapper terminating\", __func__, GetCurrentThreadId ()));\n\n\tthread_cleanup (internal);\n\n\t/* Do any cleanup needed for apartment state. This\n\t * cannot be done in thread_cleanup since thread_cleanup could be \n\t * called for a thread other than the current thread.\n\t * mono_thread_cleanup_apartment_state cleans up apartment\n\t * for the current thead */\n\tmono_thread_cleanup_apartment_state ();\n\n\t/* Remove the reference to the thread object in the TLS data,\n\t * so the thread object can be finalized.  This won't be\n\t * reached if the thread threw an uncaught exception, so those\n\t * thread handles will stay referenced :-( (This is due to\n\t * missing support for scanning thread-specific data in the\n\t * Boehm GC - the io-layer keeps a GC-visible hash of pointers\n\t * to TLS data.)\n\t */\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\treturn(0);\n}\n\nstatic guint32 WINAPI start_wrapper(void *data)\n{\n#ifdef HAVE_SGEN_GC\n\tvolatile int dummy;\n\n\t/* Avoid scanning the frames above this frame during a GC */\n\tmono_gc_set_stack_end ((void*)&dummy);\n#endif\n\n\treturn start_wrapper_internal (data);\n}\n\nvoid mono_thread_new_init (intptr_t tid, gpointer stack_start, gpointer func)\n{\n\tif (mono_thread_start_cb) {\n\t\tmono_thread_start_cb (tid, stack_start, func);\n\t}\n}\n\nvoid mono_threads_set_default_stacksize (guint32 stacksize)\n{\n\tdefault_stacksize = stacksize;\n}\n\nguint32 mono_threads_get_default_stacksize (void)\n{\n\treturn default_stacksize;\n}\n\n/*\n * mono_create_thread:\n *\n *   This is a wrapper around CreateThread which handles differences in the type of\n * the the 'tid' argument.\n */\ngpointer mono_create_thread (WapiSecurityAttributes *security,\n\t\t\t\t\t\t\t guint32 stacksize, WapiThreadStart start,\n\t\t\t\t\t\t\t gpointer param, guint32 create, gsize *tid)\n{\n\tgpointer res;\n\n#ifdef HOST_WIN32\n\tDWORD real_tid;\n\n\tres = CreateThread (security, stacksize, start, param, create, &real_tid);\n\tif (tid)\n\t\t*tid = real_tid;\n#else\n\tres = CreateThread (security, stacksize, start, param, create, tid);\n#endif\n\n\treturn res;\n}\n\n/* \n * The thread start argument may be an object reference, and there is\n * no ref to keep it alive when the new thread is started but not yet\n * registered with the collector. So we store it in a GC tracked hash\n * table.\n *\n * LOCKING: Assumes the threads lock is held.\n */\nstatic void\nregister_thread_start_argument (MonoThread *thread, struct StartInfo *start_info)\n{\n\tif (thread_start_args == NULL) {\n\t\tMONO_GC_REGISTER_ROOT_FIXED (thread_start_args);\n\t\tthread_start_args = mono_g_hash_table_new (NULL, NULL);\n\t}\n\tmono_g_hash_table_insert (thread_start_args, thread, start_info->start_arg);\n}\n\nMonoInternalThread* mono_thread_create_internal (MonoDomain *domain, gpointer func, gpointer arg, gboolean threadpool_thread, guint32 stack_size)\n{\n\tMonoThread *thread;\n\tMonoInternalThread *internal;\n\tHANDLE thread_handle;\n\tstruct StartInfo *start_info;\n\tgsize tid;\n\n\tthread = create_thread_object (domain);\n\tinternal = create_internal_thread_object ();\n\tMONO_OBJECT_SETREF (thread, internal_thread, internal);\n\n\tstart_info=g_new0 (struct StartInfo, 1);\n\tstart_info->func = func;\n\tstart_info->obj = thread;\n\tstart_info->start_arg = arg;\n\n\tmono_threads_lock ();\n\tif (shutting_down) {\n\t\tmono_threads_unlock ();\n\t\tg_free (start_info);\n\t\treturn NULL;\n\t}\n\tif (threads_starting_up == NULL) {\n\t\tMONO_GC_REGISTER_ROOT_FIXED (threads_starting_up);\n\t\tthreads_starting_up = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_KEY_VALUE_GC);\n\t}\n\n\tregister_thread_start_argument (thread, start_info);\n \tmono_g_hash_table_insert (threads_starting_up, thread, thread);\n\tmono_threads_unlock ();\t\n\n\tif (stack_size == 0)\n\t\tstack_size = default_stacksize_for_thread (internal);\n\n\t/* Create suspended, so we can do some housekeeping before the thread\n\t * starts\n\t */\n\tthread_handle = mono_create_thread (NULL, stack_size, (LPTHREAD_START_ROUTINE)start_wrapper, start_info,\n\t\t\t\t     CREATE_SUSPENDED, &tid);\n\tTHREAD_DEBUG (g_message (\"%s: Started thread ID %\"G_GSIZE_FORMAT\" (handle %p)\", __func__, tid, thread_handle));\n\tif (thread_handle == NULL) {\n\t\t/* The thread couldn't be created, so throw an exception */\n\t\tmono_threads_lock ();\n\t\tmono_g_hash_table_remove (threads_starting_up, thread);\n\t\tmono_threads_unlock ();\n\t\tg_free (start_info);\n\t\tmono_raise_exception (mono_get_exception_execution_engine (\"Couldn't create thread\"));\n\t\treturn NULL;\n\t}\n\n\tinternal->handle=thread_handle;\n\tinternal->tid=tid;\n\tinternal->apartment_state=ThreadApartmentState_Unknown;\n\tinternal->small_id = mono_thread_small_id_alloc ();\n\tinternal->thread_pinning_ref = internal;\n\tMONO_GC_REGISTER_ROOT (internal->thread_pinning_ref);\n\n\tinternal->synch_cs = g_new0 (CRITICAL_SECTION, 1);\n\tInitializeCriticalSection (internal->synch_cs);\n\n\tinternal->threadpool_thread = threadpool_thread;\n\tif (threadpool_thread)\n\t\tmono_thread_set_state (internal, ThreadState_Background);\n\n\tif (handle_store (thread))\n\t\tResumeThread (thread_handle);\n\n\treturn internal;\n}\n\nvoid\nmono_thread_create (MonoDomain *domain, gpointer func, gpointer arg)\n{\n\tmono_thread_create_internal (domain, func, arg, FALSE, 0);\n}\n\n/*\n * mono_thread_get_stack_bounds:\n *\n *   Return the address and size of the current threads stack. Return NULL as the \n * stack address if the stack address cannot be determined.\n */\nvoid\nmono_thread_get_stack_bounds (guint8 **staddr, size_t *stsize)\n{\n#if defined(HAVE_PTHREAD_GET_STACKSIZE_NP) && defined(HAVE_PTHREAD_GET_STACKADDR_NP)\n\t*staddr = (guint8*)pthread_get_stackaddr_np (pthread_self ());\n\t*stsize = pthread_get_stacksize_np (pthread_self ());\n\t*staddr = (guint8*)((gssize)*staddr & ~(mono_pagesize () - 1));\n\treturn;\n\t/* FIXME: simplify the mess below */\n#elif !defined(HOST_WIN32)\n\tpthread_attr_t attr;\n\tguint8 *current = (guint8*)&attr;\n\n\tpthread_attr_init (&attr);\n#  ifdef HAVE_PTHREAD_GETATTR_NP\n\tpthread_getattr_np (pthread_self(), &attr);\n#  else\n#    ifdef HAVE_PTHREAD_ATTR_GET_NP\n\tpthread_attr_get_np (pthread_self(), &attr);\n#    elif defined(sun)\n\t*staddr = NULL;\n\tpthread_attr_getstacksize (&attr, &stsize);\n#    elif defined(__OpenBSD__)\n\tstack_t ss;\n\tint rslt;\n\n\trslt = pthread_stackseg_np(pthread_self(), &ss);\n\tg_assert (rslt == 0);\n\n\t*staddr = (guint8*)((size_t)ss.ss_sp - ss.ss_size);\n\t*stsize = ss.ss_size;\n#    else\n\t*staddr = NULL;\n\t*stsize = 0;\n\treturn;\n#    endif\n#  endif\n\n#  if !defined(sun)\n#    if !defined(__OpenBSD__)\n\tpthread_attr_getstack (&attr, (void**)staddr, stsize);\n#    endif\n\tif (*staddr)\n\t\tg_assert ((current > *staddr) && (current < *staddr + *stsize));\n#  endif\n\n\tpthread_attr_destroy (&attr);\n#else\n\t*staddr = NULL;\n\t*stsize = (size_t)-1;\n#endif\n\n\t/* When running under emacs, sometimes staddr is not aligned to a page size */\n\t*staddr = (guint8*)((gssize)*staddr & ~(mono_pagesize () - 1));\n}\t\n\nMonoThread *\nmono_thread_attach (MonoDomain *domain)\n{\n\tMonoInternalThread *thread;\n\tMonoThread *current_thread;\n\tHANDLE thread_handle;\n\tgsize tid;\n\n\tif ((thread = mono_thread_internal_current ())) {\n\t\tif (domain != mono_domain_get ())\n\t\t\tmono_domain_set (domain, TRUE);\n\t\t/* Already attached */\n\t\treturn mono_thread_current ();\n\t}\n\n\tif (!mono_gc_register_thread (&domain)) {\n\t\tg_error (\"Thread %\"G_GSIZE_FORMAT\" calling into managed code is not registered with the GC. On UNIX, this can be fixed by #include-ing <gc.h> before <pthread.h> in the file containing the thread creation code.\", GetCurrentThreadId ());\n\t}\n\n\tthread = create_internal_thread_object ();\n\n\tthread_handle = GetCurrentThread ();\n\tg_assert (thread_handle);\n\n\ttid=GetCurrentThreadId ();\n\n\t/* \n\t * The handle returned by GetCurrentThread () is a pseudo handle, so it can't be used to\n\t * refer to the thread from other threads for things like aborting.\n\t */\n\tDuplicateHandle (GetCurrentProcess (), thread_handle, GetCurrentProcess (), &thread_handle, \n\t\t\t\t\t THREAD_ALL_ACCESS, TRUE, 0);\n\n\tthread->handle=thread_handle;\n\tthread->tid=tid;\n#ifdef PLATFORM_ANDROID\n\tthread->android_tid = (gpointer) gettid ();\n#endif\n\tthread->apartment_state=ThreadApartmentState_Unknown;\n\tthread->small_id = mono_thread_small_id_alloc ();\n\tthread->thread_pinning_ref = thread;\n\tMONO_GC_REGISTER_ROOT (thread->thread_pinning_ref);\n\n\tthread->stack_ptr = &tid;\n\n\tthread->synch_cs = g_new0 (CRITICAL_SECTION, 1);\n\tInitializeCriticalSection (thread->synch_cs);\n\n\tTHREAD_DEBUG (g_message (\"%s: Attached thread ID %\"G_GSIZE_FORMAT\" (handle %p)\", __func__, tid, thread_handle));\n\n\tcurrent_thread = new_thread_with_internal (domain, thread);\n\n\tif (!handle_store (current_thread)) {\n\t\t/* Mono is shutting down, so just wait for the end */\n\t\tfor (;;)\n\t\t\tSleep (10000);\n\t}\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Setting current_object_key to %p\", __func__, GetCurrentThreadId (), thread));\n\n\tSET_CURRENT_OBJECT (thread);\n\tmono_domain_set (domain, TRUE);\n\n\tmono_monitor_init_tls ();\n\n\tthread_adjust_static_data (thread);\n\n\tinit_root_domain_thread (thread, current_thread);\n\tif (domain != mono_get_root_domain ())\n\t\tset_current_thread_for_domain (domain, thread, current_thread);\n\n\n\tif (mono_thread_attach_cb) {\n\t\tguint8 *staddr;\n\t\tsize_t stsize;\n\n\t\tmono_thread_get_stack_bounds (&staddr, &stsize);\n\n\t\tif (staddr == NULL)\n\t\t\tmono_thread_attach_cb (tid, &tid);\n\t\telse\n\t\t\tmono_thread_attach_cb (tid, staddr + stsize);\n\t}\n\n\t// FIXME: Need a separate callback\n\tmono_profiler_thread_start (tid);\n\n\treturn current_thread;\n}\n\nvoid\nmono_thread_detach (MonoThread *thread)\n{\n\tg_return_if_fail (thread != NULL);\n\n\tTHREAD_DEBUG (g_message (\"%s: mono_thread_detach for %p (%\"G_GSIZE_FORMAT\")\", __func__, thread, (gsize)thread->internal_thread->tid));\n\t\n\tthread_cleanup (thread->internal_thread);\n\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\t/* Don't need to CloseHandle this thread, even though we took a\n\t * reference in mono_thread_attach (), because the GC will do it\n\t * when the Thread object is finalised.\n\t */\n}\n\nvoid\nmono_thread_exit ()\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_DEBUG (g_message (\"%s: mono_thread_exit for %p (%\"G_GSIZE_FORMAT\")\", __func__, thread, (gsize)thread->tid));\n\n\tthread_cleanup (thread);\n\tSET_CURRENT_OBJECT (NULL);\n\tmono_domain_unset ();\n\n\t/* we could add a callback here for embedders to use. */\n\tif (mono_thread_get_main () && (thread == mono_thread_get_main ()->internal_thread))\n\t\texit (mono_environment_exitcode_get ());\n\tExitThread (-1);\n}\n\nvoid\nves_icall_System_Threading_Thread_ConstructInternalThread (MonoThread *this)\n{\n\tMonoInternalThread *internal = create_internal_thread_object ();\n\n\tinternal->state = ThreadState_Unstarted;\n\tinternal->apartment_state = ThreadApartmentState_Unknown;\n\n\tInterlockedCompareExchangePointer ((gpointer)&this->internal_thread, internal, NULL);\n}\n\nHANDLE ves_icall_System_Threading_Thread_Thread_internal(MonoThread *this,\n\t\t\t\t\t\t\t MonoObject *start)\n{\n\tguint32 (*start_func)(void *);\n\tstruct StartInfo *start_info;\n\tHANDLE thread;\n\tgsize tid;\n\tMonoInternalThread *internal;\n\n\tTHREAD_DEBUG (g_message(\"%s: Trying to start a new thread: this (%p) start (%p)\", __func__, this, start));\n\n\tif (!this->internal_thread)\n\t\tves_icall_System_Threading_Thread_ConstructInternalThread (this);\n\tinternal = this->internal_thread;\n\n\tensure_synch_cs_set (internal);\n\n\tEnterCriticalSection (internal->synch_cs);\n\n\tif ((internal->state & ThreadState_Unstarted) == 0) {\n\t\tLeaveCriticalSection (internal->synch_cs);\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has already been started.\"));\n\t\treturn NULL;\n\t}\n\n\tinternal->small_id = -1;\n\n\tif ((internal->state & ThreadState_Aborted) != 0) {\n\t\tLeaveCriticalSection (internal->synch_cs);\n\t\treturn this;\n\t}\n\tstart_func = NULL;\n\t{\n\t\t/* This is freed in start_wrapper */\n\t\tstart_info = g_new0 (struct StartInfo, 1);\n\t\tstart_info->func = start_func;\n\t\tstart_info->start_arg = this->start_obj; /* FIXME: GC object stored in unmanaged memory */\n\t\tstart_info->delegate = start;\n\t\tstart_info->obj = this;\n\t\tg_assert (this->obj.vtable->domain == mono_domain_get ());\n\n\t\tinternal->start_notify=CreateSemaphore (NULL, 0, 0x7fffffff, NULL);\n\t\tif (internal->start_notify==NULL) {\n\t\t\tLeaveCriticalSection (internal->synch_cs);\n\t\t\tg_warning (\"%s: CreateSemaphore error 0x%x\", __func__, GetLastError ());\n\t\t\tg_free (start_info);\n\t\t\treturn(NULL);\n\t\t}\n\n\t\tmono_threads_lock ();\n\t\tregister_thread_start_argument (this, start_info);\n\t\tif (threads_starting_up == NULL) {\n\t\t\tMONO_GC_REGISTER_ROOT_FIXED (threads_starting_up);\n\t\t\tthreads_starting_up = mono_g_hash_table_new_type (NULL, NULL, MONO_HASH_KEY_VALUE_GC);\n\t\t}\n\t\tmono_g_hash_table_insert (threads_starting_up, this, this);\n\t\tmono_threads_unlock ();\t\n\n\t\tthread=mono_create_thread(NULL, default_stacksize_for_thread (internal), (LPTHREAD_START_ROUTINE)start_wrapper, start_info,\n\t\t\t\t    CREATE_SUSPENDED, &tid);\n\t\tif(thread==NULL) {\n\t\t\tLeaveCriticalSection (internal->synch_cs);\n\t\t\tmono_threads_lock ();\n\t\t\tmono_g_hash_table_remove (threads_starting_up, this);\n\t\t\tmono_threads_unlock ();\n\t\t\tg_warning(\"%s: CreateThread error 0x%x\", __func__, GetLastError());\n\t\t\treturn(NULL);\n\t\t}\n\t\t\n\t\tinternal->handle=thread;\n\t\tinternal->tid=tid;\n\t\tinternal->small_id = mono_thread_small_id_alloc ();\n\t\tinternal->thread_pinning_ref = internal;\n\t\tMONO_GC_REGISTER_ROOT (internal->thread_pinning_ref);\n\t\t\n\n\t\t/* Don't call handle_store() here, delay it to Start.\n\t\t * We can't join a thread (trying to will just block\n\t\t * forever) until it actually starts running, so don't\n\t\t * store the handle till then.\n\t\t */\n\n\t\tmono_thread_start (this);\n\t\t\n\t\tinternal->state &= ~ThreadState_Unstarted;\n\n\t\tTHREAD_DEBUG (g_message (\"%s: Started thread ID %\"G_GSIZE_FORMAT\" (handle %p)\", __func__, tid, thread));\n\n\t\tLeaveCriticalSection (internal->synch_cs);\n\t\treturn(thread);\n\t}\n}\n\nvoid ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tCRITICAL_SECTION *synch_cs = this->synch_cs;\n\t\tthis->synch_cs = NULL;\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n\n\tif (this->name) {\n\t\tvoid *name = this->name;\n\t\tthis->name = NULL;\n\t\tg_free (name);\n\t}\n}\n\nstatic void mono_thread_start (MonoThread *thread)\n{\n\tMonoInternalThread *internal = thread->internal_thread;\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Launching thread %p (%\"G_GSIZE_FORMAT\")\", __func__, GetCurrentThreadId (), internal, (gsize)internal->tid));\n\n\t/* Only store the handle when the thread is about to be\n\t * launched, to avoid the main thread deadlocking while trying\n\t * to clean up a thread that will never be signalled.\n\t */\n\tif (!handle_store (thread))\n\t\treturn;\n\n\tResumeThread (internal->handle);\n\n\tif(internal->start_notify!=NULL) {\n\t\t/* Wait for the thread to set up its TLS data etc, so\n\t\t * theres no potential race condition if someone tries\n\t\t * to look up the data believing the thread has\n\t\t * started\n\t\t */\n\n\t\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") waiting for thread %p (%\"G_GSIZE_FORMAT\") to start\", __func__, GetCurrentThreadId (), internal, (gsize)internal->tid));\n\n\t\tWaitForSingleObjectEx (internal->start_notify, INFINITE, FALSE);\n\t\tCloseHandle (internal->start_notify);\n\t\tinternal->start_notify = NULL;\n\t}\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Done launching thread %p (%\"G_GSIZE_FORMAT\")\", __func__, GetCurrentThreadId (), internal, (gsize)internal->tid));\n}\n\nvoid ves_icall_System_Threading_Thread_Sleep_internal(gint32 ms)\n{\n\tguint32 res;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_DEBUG (g_message (\"%s: Sleeping for %d ms\", __func__, ms));\n\n\tmono_thread_current_check_pending_interrupt ();\n\t\n\twhile (TRUE) {\n\t\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\t\tres = SleepEx(ms,TRUE);\n\t\n\t\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\t\tif (res == WAIT_IO_COMPLETION) { /* we might have been interrupted */\n\t\t\tMonoException* exc = mono_thread_execute_interruption (thread);\n\t\t\tif (exc) {\n\t\t\t\tmono_raise_exception (exc);\n\t\t\t} else {\n\t\t\t\t// FIXME: !INFINITE\n\t\t\t\tif (ms != INFINITE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid ves_icall_System_Threading_Thread_SpinWait_nop (void)\n{\n}\n\ngint32\nves_icall_System_Threading_Thread_GetDomainID (void) \n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn mono_domain_get()->domain_id;\n}\n\ngboolean \nves_icall_System_Threading_Thread_Yield (void)\n{\n#ifdef HOST_WIN32\n\treturn SwitchToThread ();\n#else\n\treturn sched_yield () == 0;\n#endif\n}\n\n/*\n * mono_thread_get_name:\n *\n *   Return the name of the thread. NAME_LEN is set to the length of the name.\n * Return NULL if the thread has no name. The returned memory is owned by the\n * caller.\n */\ngunichar2*\nmono_thread_get_name (MonoInternalThread *this_obj, guint32 *name_len)\n{\n\tgunichar2 *res;\n\n\tensure_synch_cs_set (this_obj);\n\t\n\tEnterCriticalSection (this_obj->synch_cs);\n\t\n\tif (!this_obj->name) {\n\t\t*name_len = 0;\n\t\tres = NULL;\n\t} else {\n\t\t*name_len = this_obj->name_len;\n\t\tres = g_new (gunichar2, this_obj->name_len);\n\t\tmemcpy (res, this_obj->name, sizeof (gunichar2) * this_obj->name_len);\n\t}\n\t\n\tLeaveCriticalSection (this_obj->synch_cs);\n\n\treturn res;\n}\n\nMonoString* \nves_icall_System_Threading_Thread_GetName_internal (MonoInternalThread *this_obj)\n{\n\tMonoString* str;\n\n\tensure_synch_cs_set (this_obj);\n\t\n\tEnterCriticalSection (this_obj->synch_cs);\n\t\n\tif (!this_obj->name)\n\t\tstr = NULL;\n\telse\n\t\tstr = mono_string_new_utf16 (mono_domain_get (), this_obj->name, this_obj->name_len);\n\t\n\tLeaveCriticalSection (this_obj->synch_cs);\n\t\n\treturn str;\n}\n\nvoid \nves_icall_System_Threading_Thread_SetName_internal (MonoInternalThread *this_obj, MonoString *name)\n{\n\tensure_synch_cs_set (this_obj);\n\t\n\tEnterCriticalSection (this_obj->synch_cs);\n\t\n\tif (this_obj->name) {\n\t\tLeaveCriticalSection (this_obj->synch_cs);\n\t\t\n\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"Thread.Name can only be set once.\"));\n\t\treturn;\n\t}\n\tif (name) {\n\t\tthis_obj->name = g_new (gunichar2, mono_string_length (name));\n\t\tmemcpy (this_obj->name, mono_string_chars (name), mono_string_length (name) * 2);\n\t\tthis_obj->name_len = mono_string_length (name);\n\t}\n\telse\n\t\tthis_obj->name = NULL;\n\t\n\tLeaveCriticalSection (this_obj->synch_cs);\n\tif (this_obj->name) {\n\t\tchar *tname = mono_string_to_utf8 (name);\n\t\tmono_profiler_thread_name (this_obj->tid, tname);\n\t\tmono_free (tname);\n\t}\n}\n\n/* If the array is already in the requested domain, we just return it,\n   otherwise we return a copy in that domain. */\nstatic MonoArray*\nbyte_array_to_domain (MonoArray *arr, MonoDomain *domain)\n{\n\tMonoArray *copy;\n\n\tif (!arr)\n\t\treturn NULL;\n\n\tif (mono_object_domain (arr) == domain)\n\t\treturn arr;\n\n\tcopy = mono_array_new (domain, mono_defaults.byte_class, arr->max_length);\n\tmemcpy (mono_array_addr (copy, guint8, 0), mono_array_addr (arr, guint8, 0), arr->max_length);\n\treturn copy;\n}\n\nMonoArray*\nves_icall_System_Threading_Thread_ByteArrayToRootDomain (MonoArray *arr)\n{\n\treturn byte_array_to_domain (arr, mono_get_root_domain ());\n}\n\nMonoArray*\nves_icall_System_Threading_Thread_ByteArrayToCurrentDomain (MonoArray *arr)\n{\n\treturn byte_array_to_domain (arr, mono_domain_get ());\n}\n\nMonoThread *\nmono_thread_current (void)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoInternalThread *internal = mono_thread_internal_current ();\n\tMonoThread **current_thread_ptr;\n\n\tg_assert (internal);\n\tcurrent_thread_ptr = get_current_thread_ptr_for_domain (domain, internal);\n\n\tif (!*current_thread_ptr) {\n\t\tg_assert (domain != mono_get_root_domain ());\n\t\t*current_thread_ptr = new_thread_with_internal (domain, internal);\n\t}\n\treturn *current_thread_ptr;\n}\n\nMonoInternalThread*\nmono_thread_internal_current (void)\n{\n\tMonoInternalThread *res = GET_CURRENT_OBJECT ();\n\tTHREAD_DEBUG (g_message (\"%s: returning %p\", __func__, res));\n\treturn res;\n}\n\ngboolean ves_icall_System_Threading_Thread_Join_internal(MonoInternalThread *this,\n\t\t\t\t\t\t\t int ms, HANDLE thread)\n{\n\tMonoInternalThread *cur_thread = mono_thread_internal_current ();\n\tgboolean ret;\n\n\tmono_thread_current_check_pending_interrupt ();\n\n\tensure_synch_cs_set (this);\n\t\n\tEnterCriticalSection (this->synch_cs);\n\t\n\tif ((this->state & ThreadState_Unstarted) != 0) {\n\t\tLeaveCriticalSection (this->synch_cs);\n\t\t\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has not been started.\"));\n\t\treturn FALSE;\n\t}\n\n\tLeaveCriticalSection (this->synch_cs);\n\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\tTHREAD_DEBUG (g_message (\"%s: joining thread handle %p, %d ms\", __func__, thread, ms));\n\t\n\tmono_thread_set_state (cur_thread, ThreadState_WaitSleepJoin);\n\n\tret=WaitForSingleObjectEx (thread, ms, TRUE);\n\n\tmono_thread_clr_state (cur_thread, ThreadState_WaitSleepJoin);\n\t\n\tif(ret==WAIT_OBJECT_0) {\n\t\tTHREAD_DEBUG (g_message (\"%s: join successful\", __func__));\n\n\t\treturn(TRUE);\n\t}\n\t\n\tTHREAD_DEBUG (g_message (\"%s: join failed\", __func__));\n\n\treturn(FALSE);\n}\n\n/* FIXME: exitContext isnt documented */\ngboolean ves_icall_System_Threading_WaitHandle_WaitAll_internal(MonoArray *mono_handles, gint32 ms, gboolean exitContext)\n{\n\tHANDLE *handles;\n\tguint32 numhandles;\n\tguint32 ret;\n\tguint32 i;\n\tMonoObject *waitHandle;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* Do this WaitSleepJoin check before creating objects */\n\tmono_thread_current_check_pending_interrupt ();\n\n\tnumhandles = mono_array_length(mono_handles);\n\thandles = g_new0(HANDLE, numhandles);\n\n\tfor(i = 0; i < numhandles; i++) {\t\n\t\twaitHandle = mono_array_get(mono_handles, MonoObject*, i);\n\t\thandles [i] = mono_wait_handle_get_handle ((MonoWaitHandle *) waitHandle);\n\t}\n\t\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tret=WaitForMultipleObjectsEx(numhandles, handles, TRUE, ms, TRUE);\n\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\tg_free(handles);\n\n\tif(ret==WAIT_FAILED) {\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait failed\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t} else if(ret==WAIT_TIMEOUT || ret == WAIT_IO_COMPLETION) {\n\t\t/* Do we want to try again if we get\n\t\t * WAIT_IO_COMPLETION? The documentation for\n\t\t * WaitHandle doesn't give any clues.  (We'd have to\n\t\t * fiddle with the timeout if we retry.)\n\t\t */\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait timed out\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t}\n\t\n\treturn(TRUE);\n}\n\n/* FIXME: exitContext isnt documented */\ngint32 ves_icall_System_Threading_WaitHandle_WaitAny_internal(MonoArray *mono_handles, gint32 ms, gboolean exitContext)\n{\n\tHANDLE handles [MAXIMUM_WAIT_OBJECTS];\n\tguint32 numhandles;\n\tguint32 ret;\n\tguint32 i;\n\tMonoObject *waitHandle;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tguint32 start;\n\n\t/* Do this WaitSleepJoin check before creating objects */\n\tmono_thread_current_check_pending_interrupt ();\n\n\tnumhandles = mono_array_length(mono_handles);\n\tif (numhandles > MAXIMUM_WAIT_OBJECTS)\n\t\treturn WAIT_FAILED;\n\n\tfor(i = 0; i < numhandles; i++) {\t\n\t\twaitHandle = mono_array_get(mono_handles, MonoObject*, i);\n\t\thandles [i] = mono_wait_handle_get_handle ((MonoWaitHandle *) waitHandle);\n\t}\n\t\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\n\tstart = (ms == -1) ? 0 : mono_msec_ticks ();\n\tdo {\n\t\tret = WaitForMultipleObjectsEx (numhandles, handles, FALSE, ms, TRUE);\n\t\tif (ret != WAIT_IO_COMPLETION)\n\t\t\tbreak;\n\t\tif (ms != -1) {\n\t\t\tguint32 diff;\n\n\t\t\tdiff = mono_msec_ticks () - start;\n\t\t\tms -= diff;\n\t\t\tif (ms <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t} while (ms == -1 || ms > 0);\n\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") returning %d\", __func__, GetCurrentThreadId (), ret));\n\n\t/*\n\t * These need to be here.  See MSDN dos on WaitForMultipleObjects.\n\t */\n\tif (ret >= WAIT_OBJECT_0 && ret <= WAIT_OBJECT_0 + numhandles - 1) {\n\t\treturn ret - WAIT_OBJECT_0;\n\t}\n\telse if (ret >= WAIT_ABANDONED_0 && ret <= WAIT_ABANDONED_0 + numhandles - 1) {\n\t\treturn ret - WAIT_ABANDONED_0;\n\t}\n\telse {\n\t\treturn ret;\n\t}\n}\n\n/* FIXME: exitContext isnt documented */\ngboolean ves_icall_System_Threading_WaitHandle_WaitOne_internal(MonoObject *this, HANDLE handle, gint32 ms, gboolean exitContext)\n{\n\tguint32 ret;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") waiting for %p, %d ms\", __func__, GetCurrentThreadId (), handle, ms));\n\t\n\tif(ms== -1) {\n\t\tms=INFINITE;\n\t}\n\t\n\tmono_thread_current_check_pending_interrupt ();\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tret=WaitForSingleObjectEx (handle, ms, TRUE);\n\t\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tif(ret==WAIT_FAILED) {\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait failed\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t} else if(ret==WAIT_TIMEOUT || ret == WAIT_IO_COMPLETION) {\n\t\t/* Do we want to try again if we get\n\t\t * WAIT_IO_COMPLETION? The documentation for\n\t\t * WaitHandle doesn't give any clues.  (We'd have to\n\t\t * fiddle with the timeout if we retry.)\n\t\t */\n\t\tTHREAD_WAIT_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Wait timed out\", __func__, GetCurrentThreadId ()));\n\t\treturn(FALSE);\n\t}\n\t\n\treturn(TRUE);\n}\n\ngboolean\nves_icall_System_Threading_WaitHandle_SignalAndWait_Internal (HANDLE toSignal, HANDLE toWait, gint32 ms, gboolean exitContext)\n{\n\tguint32 ret;\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (ms == -1)\n\t\tms = INFINITE;\n\n\tmono_thread_current_check_pending_interrupt ();\n\n\tmono_thread_set_state (thread, ThreadState_WaitSleepJoin);\n\t\n\tret = SignalObjectAndWait (toSignal, toWait, ms, TRUE);\n\t\n\tmono_thread_clr_state (thread, ThreadState_WaitSleepJoin);\n\n\treturn  (!(ret == WAIT_TIMEOUT || ret == WAIT_IO_COMPLETION || ret == WAIT_FAILED));\n}\n\nHANDLE ves_icall_System_Threading_Mutex_CreateMutex_internal (MonoBoolean owned, MonoString *name, MonoBoolean *created)\n{ \n\tHANDLE mutex;\n\t\n\tMONO_ARCH_SAVE_REGS;\n   \n\t*created = TRUE;\n\t\n\tif (name == NULL) {\n\t\tmutex = CreateMutex (NULL, owned, NULL);\n\t} else {\n\t\tmutex = CreateMutex (NULL, owned, mono_string_chars (name));\n\t\t\n\t\tif (GetLastError () == ERROR_ALREADY_EXISTS) {\n\t\t\t*created = FALSE;\n\t\t}\n\t}\n\n\treturn(mutex);\n}                                                                   \n\nMonoBoolean ves_icall_System_Threading_Mutex_ReleaseMutex_internal (HANDLE handle ) { \n\tMONO_ARCH_SAVE_REGS;\n\n\treturn(ReleaseMutex (handle));\n}\n\nHANDLE ves_icall_System_Threading_Mutex_OpenMutex_internal (MonoString *name,\n\t\t\t\t\t\t\t    gint32 rights,\n\t\t\t\t\t\t\t    gint32 *error)\n{\n\tHANDLE ret;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\t\n\t*error = ERROR_SUCCESS;\n\t\n\tret = OpenMutex (rights, FALSE, mono_string_chars (name));\n\tif (ret == NULL) {\n\t\t*error = GetLastError ();\n\t}\n\t\n\treturn(ret);\n}\n\n\nHANDLE ves_icall_System_Threading_Semaphore_CreateSemaphore_internal (gint32 initialCount, gint32 maximumCount, MonoString *name, MonoBoolean *created)\n{ \n\tHANDLE sem;\n\t\n\tMONO_ARCH_SAVE_REGS;\n   \n\t*created = TRUE;\n\t\n\tif (name == NULL) {\n\t\tsem = CreateSemaphore (NULL, initialCount, maximumCount, NULL);\n\t} else {\n\t\tsem = CreateSemaphore (NULL, initialCount, maximumCount,\n\t\t\t\t       mono_string_chars (name));\n\t\t\n\t\tif (GetLastError () == ERROR_ALREADY_EXISTS) {\n\t\t\t*created = FALSE;\n\t\t}\n\t}\n\n\treturn(sem);\n}                                                                   \n\ngint32 ves_icall_System_Threading_Semaphore_ReleaseSemaphore_internal (HANDLE handle, gint32 releaseCount, MonoBoolean *fail)\n{ \n\tgint32 prevcount;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\t*fail = !ReleaseSemaphore (handle, releaseCount, &prevcount);\n\n\treturn (prevcount);\n}\n\nHANDLE ves_icall_System_Threading_Semaphore_OpenSemaphore_internal (MonoString *name, gint32 rights, gint32 *error)\n{\n\tHANDLE ret;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\t\n\t*error = ERROR_SUCCESS;\n\t\n\tret = OpenSemaphore (rights, FALSE, mono_string_chars (name));\n\tif (ret == NULL) {\n\t\t*error = GetLastError ();\n\t}\n\t\n\treturn(ret);\n}\n\nHANDLE ves_icall_System_Threading_Events_CreateEvent_internal (MonoBoolean manual, MonoBoolean initial, MonoString *name, MonoBoolean *created)\n{\n\tHANDLE event;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\n\t*created = TRUE;\n\n\tif (name == NULL) {\n\t\tevent = CreateEvent (NULL, manual, initial, NULL);\n\t} else {\n\t\tevent = CreateEvent (NULL, manual, initial,\n\t\t\t\t     mono_string_chars (name));\n\t\t\n\t\tif (GetLastError () == ERROR_ALREADY_EXISTS) {\n\t\t\t*created = FALSE;\n\t\t}\n\t}\n\t\n\treturn(event);\n}\n\ngboolean ves_icall_System_Threading_Events_SetEvent_internal (HANDLE handle) {\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (SetEvent(handle));\n}\n\ngboolean ves_icall_System_Threading_Events_ResetEvent_internal (HANDLE handle) {\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn (ResetEvent(handle));\n}\n\nvoid\nves_icall_System_Threading_Events_CloseEvent_internal (HANDLE handle) {\n\tMONO_ARCH_SAVE_REGS;\n\n\tCloseHandle (handle);\n}\n\nHANDLE ves_icall_System_Threading_Events_OpenEvent_internal (MonoString *name,\n\t\t\t\t\t\t\t     gint32 rights,\n\t\t\t\t\t\t\t     gint32 *error)\n{\n\tHANDLE ret;\n\t\n\tMONO_ARCH_SAVE_REGS;\n\t\n\t*error = ERROR_SUCCESS;\n\t\n\tret = OpenEvent (rights, FALSE, mono_string_chars (name));\n\tif (ret == NULL) {\n\t\t*error = GetLastError ();\n\t}\n\t\n\treturn(ret);\n}\n\ngint32 ves_icall_System_Threading_Interlocked_Increment_Int (gint32 *location)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedIncrement (location);\n}\n\ngint64 ves_icall_System_Threading_Interlocked_Increment_Long (gint64 *location)\n{\n\tgint64 ret;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_interlocked_lock ();\n\n\tret = ++ *location;\n\t\n\tmono_interlocked_unlock ();\n\n\t\n\treturn ret;\n}\n\ngint32 ves_icall_System_Threading_Interlocked_Decrement_Int (gint32 *location)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedDecrement(location);\n}\n\ngint64 ves_icall_System_Threading_Interlocked_Decrement_Long (gint64 * location)\n{\n\tgint64 ret;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tmono_interlocked_lock ();\n\n\tret = -- *location;\n\t\n\tmono_interlocked_unlock ();\n\n\treturn ret;\n}\n\ngint32 ves_icall_System_Threading_Interlocked_Exchange_Int (gint32 *location, gint32 value)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedExchange(location, value);\n}\n\nMonoObject * ves_icall_System_Threading_Interlocked_Exchange_Object (MonoObject **location, MonoObject *value)\n{\n\tMonoObject *res;\n\tres = (MonoObject *) InterlockedExchangePointer((gpointer *) location, value);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\ngpointer ves_icall_System_Threading_Interlocked_Exchange_IntPtr (gpointer *location, gpointer value)\n{\n\treturn InterlockedExchangePointer(location, value);\n}\n\ngfloat ves_icall_System_Threading_Interlocked_Exchange_Single (gfloat *location, gfloat value)\n{\n\tIntFloatUnion val, ret;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tval.fval = value;\n\tret.ival = InterlockedExchange((gint32 *) location, val.ival);\n\n\treturn ret.fval;\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_Exchange_Long (gint64 *location, gint64 value)\n{\n#if SIZEOF_VOID_P == 8\n\treturn (gint64) InterlockedExchangePointer((gpointer *) location, (gpointer)value);\n#else\n\tgint64 res;\n\n\t/* \n\t * According to MSDN, this function is only atomic with regards to the \n\t * other Interlocked functions on 32 bit platforms.\n\t */\n\tmono_interlocked_lock ();\n\tres = *location;\n\t*location = value;\n\tmono_interlocked_unlock ();\n\n\treturn res;\n#endif\n}\n\ngdouble \nves_icall_System_Threading_Interlocked_Exchange_Double (gdouble *location, gdouble value)\n{\n#if SIZEOF_VOID_P == 8\n\tLongDoubleUnion val, ret;\n\n\tval.fval = value;\n\tret.ival = (gint64)InterlockedExchangePointer((gpointer *) location, (gpointer)val.ival);\n\n\treturn ret.fval;\n#else\n\tgdouble res;\n\n\t/* \n\t * According to MSDN, this function is only atomic with regards to the \n\t * other Interlocked functions on 32 bit platforms.\n\t */\n\tmono_interlocked_lock ();\n\tres = *location;\n\t*location = value;\n\tmono_interlocked_unlock ();\n\n\treturn res;\n#endif\n}\n\ngint32 ves_icall_System_Threading_Interlocked_CompareExchange_Int(gint32 *location, gint32 value, gint32 comparand)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\treturn InterlockedCompareExchange(location, value, comparand);\n}\n\nMonoObject * ves_icall_System_Threading_Interlocked_CompareExchange_Object (MonoObject **location, MonoObject *value, MonoObject *comparand)\n{\n\tMonoObject *res;\n\tres = (MonoObject *) InterlockedCompareExchangePointer((gpointer *) location, value, comparand);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\ngpointer ves_icall_System_Threading_Interlocked_CompareExchange_IntPtr(gpointer *location, gpointer value, gpointer comparand)\n{\n\treturn InterlockedCompareExchangePointer(location, value, comparand);\n}\n\ngfloat ves_icall_System_Threading_Interlocked_CompareExchange_Single (gfloat *location, gfloat value, gfloat comparand)\n{\n\tIntFloatUnion val, ret, cmp;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tval.fval = value;\n\tcmp.fval = comparand;\n\tret.ival = InterlockedCompareExchange((gint32 *) location, val.ival, cmp.ival);\n\n\treturn ret.fval;\n}\n\ngdouble\nves_icall_System_Threading_Interlocked_CompareExchange_Double (gdouble *location, gdouble value, gdouble comparand)\n{\n#if SIZEOF_VOID_P == 8\n\tLongDoubleUnion val, comp, ret;\n\n\tval.fval = value;\n\tcomp.fval = comparand;\n\tret.ival = (gint64)InterlockedCompareExchangePointer((gpointer *) location, (gpointer)val.ival, (gpointer)comp.ival);\n\n\treturn ret.fval;\n#else\n\tgdouble old;\n\n\tmono_interlocked_lock ();\n\told = *location;\n\tif (old == comparand)\n\t\t*location = value;\n\tmono_interlocked_unlock ();\n\n\treturn old;\n#endif\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_CompareExchange_Long (gint64 *location, gint64 value, gint64 comparand)\n{\n#if SIZEOF_VOID_P == 8\n\treturn (gint64)InterlockedCompareExchangePointer((gpointer *) location, (gpointer)value, (gpointer)comparand);\n#else\n\tgint64 old;\n\n\tmono_interlocked_lock ();\n\told = *location;\n\tif (old == comparand)\n\t\t*location = value;\n\tmono_interlocked_unlock ();\n\t\n\treturn old;\n#endif\n}\n\nMonoObject*\nves_icall_System_Threading_Interlocked_CompareExchange_T (MonoObject **location, MonoObject *value, MonoObject *comparand)\n{\n\tMonoObject *res;\n\tres = InterlockedCompareExchangePointer ((gpointer *)location, value, comparand);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\nMonoObject*\nves_icall_System_Threading_Interlocked_Exchange_T (MonoObject **location, MonoObject *value)\n{\n\tMonoObject *res;\n\tres = InterlockedExchangePointer ((gpointer *)location, value);\n\tmono_gc_wbarrier_generic_nostore (location);\n\treturn res;\n}\n\ngint32 \nves_icall_System_Threading_Interlocked_Add_Int (gint32 *location, gint32 value)\n{\n#if SIZEOF_VOID_P == 8\n\t/* Should be implemented as a JIT intrinsic */\n\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\treturn 0;\n#else\n\tgint32 orig;\n\n\tmono_interlocked_lock ();\n\torig = *location;\n\t*location = orig + value;\n\tmono_interlocked_unlock ();\n\n\treturn orig + value;\n#endif\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_Add_Long (gint64 *location, gint64 value)\n{\n#if SIZEOF_VOID_P == 8\n\t/* Should be implemented as a JIT intrinsic */\n\tmono_raise_exception (mono_get_exception_not_implemented (NULL));\n\treturn 0;\n#else\n\tgint64 orig;\n\n\tmono_interlocked_lock ();\n\torig = *location;\n\t*location = orig + value;\n\tmono_interlocked_unlock ();\n\n\treturn orig + value;\n#endif\n}\n\ngint64 \nves_icall_System_Threading_Interlocked_Read_Long (gint64 *location)\n{\n#if SIZEOF_VOID_P == 8\n\t/* 64 bit reads are already atomic */\n\treturn *location;\n#else\n\tgint64 res;\n\n\tmono_interlocked_lock ();\n\tres = *location;\n\tmono_interlocked_unlock ();\n\n\treturn res;\n#endif\n}\n\nvoid\nves_icall_System_Threading_Thread_MemoryBarrier (void)\n{\n\tmono_threads_lock ();\n\tmono_threads_unlock ();\n}\n\nvoid\nves_icall_System_Threading_Thread_ClrState (MonoInternalThread* this, guint32 state)\n{\n\tmono_thread_clr_state (this, state);\n\n\tif (state & ThreadState_Background) {\n\t\t/* If the thread changes the background mode, the main thread has to\n\t\t * be notified, since it has to rebuild the list of threads to\n\t\t * wait for.\n\t\t */\n\t\tSetEvent (background_change_event);\n\t}\n}\n\nvoid\nves_icall_System_Threading_Thread_SetState (MonoInternalThread* this, guint32 state)\n{\n\tmono_thread_set_state (this, state);\n\t\n\tif (state & ThreadState_Background) {\n\t\t/* If the thread changes the background mode, the main thread has to\n\t\t * be notified, since it has to rebuild the list of threads to\n\t\t * wait for.\n\t\t */\n\t\tSetEvent (background_change_event);\n\t}\n}\n\nguint32\nves_icall_System_Threading_Thread_GetState (MonoInternalThread* this)\n{\n\tguint32 state;\n\n\tensure_synch_cs_set (this);\n\t\n\tEnterCriticalSection (this->synch_cs);\n\t\n\tstate = this->state;\n\n\tLeaveCriticalSection (this->synch_cs);\n\t\n\treturn state;\n}\n\nvoid ves_icall_System_Threading_Thread_Interrupt_internal (MonoInternalThread *this)\n{\n\tgboolean throw = FALSE;\n\t\n\tensure_synch_cs_set (this);\n\n\tif (this == mono_thread_internal_current ())\n\t\treturn;\n\t\n\tEnterCriticalSection (this->synch_cs);\n\t\n\tthis->thread_interrupt_requested = TRUE;\n\t\n\tif (this->state & ThreadState_WaitSleepJoin) {\n\t\tthrow = TRUE;\n\t}\n\t\n\tLeaveCriticalSection (this->synch_cs);\n\t\n\tif (throw) {\n\t\tsignal_thread_state_change (this);\n\t}\n}\n\nvoid mono_thread_current_check_pending_interrupt ()\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tgboolean throw = FALSE;\n\n\tmono_debugger_check_interruption ();\n\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\t\n\tif (thread->thread_interrupt_requested) {\n\t\tthrow = TRUE;\n\t\tthread->thread_interrupt_requested = FALSE;\n\t}\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tif (throw) {\n\t\tmono_raise_exception (mono_get_exception_thread_interrupted ());\n\t}\n}\n\nint  \nmono_thread_get_abort_signal (void)\n{\n#ifdef HOST_WIN32\n\treturn -1;\n#else\n#ifndef\tSIGRTMIN\n#ifdef SIGUSR1\n\treturn SIGUSR1;\n#else\n\treturn -1;\n#endif\n#else\n\tstatic int abort_signum = -1;\n\tint i;\n\tif (abort_signum != -1)\n\t\treturn abort_signum;\n\t/* we try to avoid SIGRTMIN and any one that might have been set already, see bug #75387 */\n\tfor (i = SIGRTMIN + 1; i < SIGRTMAX; ++i) {\n\t\tstruct sigaction sinfo;\n\t\tsigaction (i, NULL, &sinfo);\n\t\tif (sinfo.sa_handler == SIG_DFL && (void*)sinfo.sa_sigaction == (void*)SIG_DFL) {\n\t\t\tabort_signum = i;\n\t\t\treturn i;\n\t\t}\n\t}\n\t/* fallback to the old way */\n\treturn SIGRTMIN;\n#endif\n#endif /* HOST_WIN32 */\n}\n\n#ifdef HOST_WIN32\nstatic void CALLBACK interruption_request_apc (ULONG_PTR param)\n{\n\tMonoException* exc = mono_thread_request_interruption (FALSE);\n\tif (exc) mono_raise_exception (exc);\n}\n#endif /* HOST_WIN32 */\n\n/*\n * signal_thread_state_change\n *\n * Tells the thread that his state has changed and it has to enter the new\n * state as soon as possible.\n */\nstatic void signal_thread_state_change (MonoInternalThread *thread)\n{\n\tif (thread == mono_thread_internal_current ()) {\n\t\t/* Do it synchronously */\n\t\tMonoException *exc = mono_thread_request_interruption (FALSE); \n\t\tif (exc)\n\t\t\tmono_raise_exception (exc);\n\t}\n\n#ifdef HOST_WIN32\n\tQueueUserAPC ((PAPCFUNC)interruption_request_apc, thread->handle, NULL);\n#else\n\t/* fixme: store the state somewhere */\n\tmono_thread_kill (thread, mono_thread_get_abort_signal ());\n\n\t/* \n\t * This will cause waits to be broken.\n\t * It will also prevent the thread from entering a wait, so if the thread returns\n\t * from the wait before it receives the abort signal, it will just spin in the wait\n\t * functions in the io-layer until the signal handler calls QueueUserAPC which will\n\t * make it return.\n\t */\n\twapi_interrupt_thread (thread->handle);\n#endif /* HOST_WIN32 */\n}\n\nvoid\nves_icall_System_Threading_Thread_Abort (MonoInternalThread *thread, MonoObject *state)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\t\n\tif ((thread->state & ThreadState_AbortRequested) != 0 || \n\t\t(thread->state & ThreadState_StopRequested) != 0 ||\n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn;\n\t}\n\n\tif ((thread->state & ThreadState_Unstarted) != 0) {\n\t\tthread->state |= ThreadState_Aborted;\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn;\n\t}\n\n\tthread->state |= ThreadState_AbortRequested;\n\tif (thread->abort_state_handle)\n\t\tmono_gchandle_free (thread->abort_state_handle);\n\tif (state) {\n\t\tthread->abort_state_handle = mono_gchandle_new (state, FALSE);\n\t\tg_assert (thread->abort_state_handle);\n\t} else {\n\t\tthread->abort_state_handle = 0;\n\t}\n\tthread->abort_exc = NULL;\n\n\t/*\n\t * abort_exc is set in mono_thread_execute_interruption(),\n\t * triggered by the call to signal_thread_state_change(),\n\t * below.  There's a point between where we have\n\t * abort_state_handle set, but abort_exc NULL, but that's not\n\t * a problem.\n\t */\n\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tTHREAD_DEBUG (g_message (\"%s: (%\"G_GSIZE_FORMAT\") Abort requested for %p (%\"G_GSIZE_FORMAT\")\", __func__, GetCurrentThreadId (), thread, (gsize)thread->tid));\n\n\t/* During shutdown, we can't wait for other threads */\n\tif (!shutting_down)\n\t\t/* Make sure the thread is awake */\n\t\tmono_thread_resume (thread);\n\t\n\tsignal_thread_state_change (thread);\n}\n\nvoid\nves_icall_System_Threading_Thread_ResetAbort (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tgboolean was_aborting;\n\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\twas_aborting = thread->state & ThreadState_AbortRequested;\n\tthread->state &= ~ThreadState_AbortRequested;\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tif (!was_aborting) {\n\t\tconst char *msg = \"Unable to reset abort because no abort was requested\";\n\t\tmono_raise_exception (mono_get_exception_thread_state (msg));\n\t}\n\tthread->abort_exc = NULL;\n\tif (thread->abort_state_handle) {\n\t\tmono_gchandle_free (thread->abort_state_handle);\n\t\t/* This is actually not necessary - the handle\n\t\t   only counts if the exception is set */\n\t\tthread->abort_state_handle = 0;\n\t}\n}\n\nvoid\nmono_thread_internal_reset_abort (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\n\tEnterCriticalSection (thread->synch_cs);\n\n\tthread->state &= ~ThreadState_AbortRequested;\n\n\tif (thread->abort_exc) {\n\t\tthread->abort_exc = NULL;\n\t\tif (thread->abort_state_handle) {\n\t\t\tmono_gchandle_free (thread->abort_state_handle);\n\t\t\t/* This is actually not necessary - the handle\n\t\t\t   only counts if the exception is set */\n\t\t\tthread->abort_state_handle = 0;\n\t\t}\n\t}\n\n\tLeaveCriticalSection (thread->synch_cs);\n}\n\nMonoObject*\nves_icall_System_Threading_Thread_GetAbortExceptionState (MonoThread *this)\n{\n\tMonoInternalThread *thread = this->internal_thread;\n\tMonoObject *state, *deserialized = NULL, *exc;\n\tMonoDomain *domain;\n\n\tif (!thread->abort_state_handle)\n\t\treturn NULL;\n\n\tstate = mono_gchandle_get_target (thread->abort_state_handle);\n\tg_assert (state);\n\n\tdomain = mono_domain_get ();\n\tif (mono_object_domain (state) == domain)\n\t\treturn state;\n\n\tdeserialized = mono_object_xdomain_representation (state, domain, &exc);\n\n\tif (!deserialized) {\n\t\tMonoException *invalid_op_exc = mono_get_exception_invalid_operation (\"Thread.ExceptionState cannot access an ExceptionState from a different AppDomain\");\n\t\tif (exc)\n\t\t\tMONO_OBJECT_SETREF (invalid_op_exc, inner_ex, exc);\n\t\tmono_raise_exception (invalid_op_exc);\n\t}\n\n\treturn deserialized;\n}\n\nstatic gboolean\nmono_thread_suspend (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & ThreadState_Unstarted) != 0 || \n\t\t(thread->state & ThreadState_Aborted) != 0 || \n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn FALSE;\n\t}\n\n\tif ((thread->state & ThreadState_Suspended) != 0 || \n\t\t(thread->state & ThreadState_SuspendRequested) != 0 ||\n\t\t(thread->state & ThreadState_StopRequested) != 0) \n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn TRUE;\n\t}\n\t\n\tthread->state |= ThreadState_SuspendRequested;\n\n\tLeaveCriticalSection (thread->synch_cs);\n\n\tsignal_thread_state_change (thread);\n\treturn TRUE;\n}\n\nvoid\nves_icall_System_Threading_Thread_Suspend (MonoInternalThread *thread)\n{\n\tif (!mono_thread_suspend (thread))\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has not been started, or is dead.\"));\n}\n\nstatic gboolean\nmono_thread_resume (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & ThreadState_SuspendRequested) != 0) {\n\t\tthread->state &= ~ThreadState_SuspendRequested;\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn TRUE;\n\t}\n\n\tif ((thread->state & ThreadState_Suspended) == 0 ||\n\t\t(thread->state & ThreadState_Unstarted) != 0 || \n\t\t(thread->state & ThreadState_Aborted) != 0 || \n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn FALSE;\n\t}\n\t\n\tthread->resume_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tif (thread->resume_event == NULL) {\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn(FALSE);\n\t}\n\t\n\t/* Awake the thread */\n\tSetEvent (thread->suspend_event);\n\n\tLeaveCriticalSection (thread->synch_cs);\n\n\t/* Wait for the thread to awake */\n\tWaitForSingleObject (thread->resume_event, INFINITE);\n\tCloseHandle (thread->resume_event);\n\tthread->resume_event = NULL;\n\n\treturn TRUE;\n}\n\nvoid\nves_icall_System_Threading_Thread_Resume (MonoThread *thread)\n{\n\tif (!thread->internal_thread || !mono_thread_resume (thread->internal_thread))\n\t\tmono_raise_exception (mono_get_exception_thread_state (\"Thread has not been started, or is dead.\"));\n}\n\nstatic gboolean\nfind_wrapper (MonoMethod *m, gint no, gint ilo, gboolean managed, gpointer data)\n{\n\tif (managed)\n\t\treturn TRUE;\n\n\tif (m->wrapper_type == MONO_WRAPPER_RUNTIME_INVOKE ||\n\t\tm->wrapper_type == MONO_WRAPPER_XDOMAIN_INVOKE ||\n\t\tm->wrapper_type == MONO_WRAPPER_XDOMAIN_DISPATCH) \n\t{\n\t\t*((gboolean*)data) = TRUE;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\nstatic gboolean \nis_running_protected_wrapper (void)\n{\n\tgboolean found = FALSE;\n\tmono_stack_walk (find_wrapper, &found);\n\treturn found;\n}\n\nvoid mono_thread_internal_stop (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & ThreadState_StopRequested) != 0 ||\n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t{\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\treturn;\n\t}\n\t\n\t/* Make sure the thread is awake */\n\tmono_thread_resume (thread);\n\n\tthread->state |= ThreadState_StopRequested;\n\tthread->state &= ~ThreadState_AbortRequested;\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\tsignal_thread_state_change (thread);\n}\n\nvoid mono_thread_stop (MonoThread *thread)\n{\n\tmono_thread_internal_stop (thread->internal_thread);\n}\n\ngint8\nves_icall_System_Threading_Thread_VolatileRead1 (void *ptr)\n{\n\treturn *((volatile gint8 *) (ptr));\n}\n\ngint16\nves_icall_System_Threading_Thread_VolatileRead2 (void *ptr)\n{\n\treturn *((volatile gint16 *) (ptr));\n}\n\ngint32\nves_icall_System_Threading_Thread_VolatileRead4 (void *ptr)\n{\n\treturn *((volatile gint32 *) (ptr));\n}\n\ngint64\nves_icall_System_Threading_Thread_VolatileRead8 (void *ptr)\n{\n\treturn *((volatile gint64 *) (ptr));\n}\n\nvoid *\nves_icall_System_Threading_Thread_VolatileReadIntPtr (void *ptr)\n{\n\treturn (void *)  *((volatile void **) ptr);\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite1 (void *ptr, gint8 value)\n{\n\t*((volatile gint8 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite2 (void *ptr, gint16 value)\n{\n\t*((volatile gint16 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite4 (void *ptr, gint32 value)\n{\n\t*((volatile gint32 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWrite8 (void *ptr, gint64 value)\n{\n\t*((volatile gint64 *) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWriteIntPtr (void *ptr, void *value)\n{\n\t*((volatile void **) ptr) = value;\n}\n\nvoid\nves_icall_System_Threading_Thread_VolatileWriteObject (void *ptr, void *value)\n{\n\tmono_gc_wbarrier_generic_store (ptr, value);\n}\n\nvoid mono_thread_init (MonoThreadStartCB start_cb,\n\t\t       MonoThreadAttachCB attach_cb)\n{\n\tmono_thread_smr_init ();\n\n\tInitializeCriticalSection(&threads_mutex);\n\tInitializeCriticalSection(&interlocked_mutex);\n\tInitializeCriticalSection(&contexts_mutex);\n\t\n\tbackground_change_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tg_assert(background_change_event != NULL);\n\t\n\tmono_init_static_data_info (&thread_static_info);\n\tmono_init_static_data_info (&context_static_info);\n\n\tMONO_FAST_TLS_INIT (tls_current_object);\n\tcurrent_object_key=TlsAlloc();\n\tTHREAD_DEBUG (g_message (\"%s: Allocated current_object_key %d\", __func__, current_object_key));\n\n\tmono_thread_start_cb = start_cb;\n\tmono_thread_attach_cb = attach_cb;\n\n\t/* Get a pseudo handle to the current process.  This is just a\n\t * kludge so that wapi can build a process handle if needed.\n\t * As a pseudo handle is returned, we don't need to clean\n\t * anything up.\n\t */\n\tGetCurrentProcess ();\n}\n\nvoid mono_thread_cleanup (void)\n{\n#if !defined(HOST_WIN32) && !defined(RUN_IN_SUBTHREAD)\n\t/* The main thread must abandon any held mutexes (particularly\n\t * important for named mutexes as they are shared across\n\t * processes, see bug 74680.)  This will happen when the\n\t * thread exits, but if it's not running in a subthread it\n\t * won't exit in time.\n\t */\n\t/* Using non-w32 API is a nasty kludge, but I couldn't find\n\t * anything in the documentation that would let me do this\n\t * here yet still be safe to call on windows.\n\t */\n\t_wapi_thread_signal_self (mono_environment_exitcode_get ());\n#endif\n\n#if 0\n\t/* This stuff needs more testing, it seems one of these\n\t * critical sections can be locked when mono_thread_cleanup is\n\t * called.\n\t */\n\tDeleteCriticalSection (&threads_mutex);\n\tDeleteCriticalSection (&interlocked_mutex);\n\tDeleteCriticalSection (&contexts_mutex);\n\tDeleteCriticalSection (&delayed_free_table_mutex);\n\tDeleteCriticalSection (&small_id_mutex);\n\tCloseHandle (background_change_event);\n#endif\n\n\tTlsFree (current_object_key);\n}\n\nvoid\nmono_threads_install_cleanup (MonoThreadCleanupFunc func)\n{\n\tmono_thread_cleanup_fn = func;\n}\n\nvoid\nmono_thread_set_manage_callback (MonoThread *thread, MonoThreadManageCallback func)\n{\n\tthread->internal_thread->manage_callback = func;\n}\n\nvoid mono_threads_install_notify_pending_exc (MonoThreadNotifyPendingExcFunc func)\n{\n\tmono_thread_notify_pending_exc_fn = func;\n}\n\nG_GNUC_UNUSED\nstatic void print_tids (gpointer key, gpointer value, gpointer user)\n{\n\t/* GPOINTER_TO_UINT breaks horribly if sizeof(void *) >\n\t * sizeof(uint) and a cast to uint would overflow\n\t */\n\t/* Older versions of glib don't have G_GSIZE_FORMAT, so just\n\t * print this as a pointer.\n\t */\n\tg_message (\"Waiting for: %p\", key);\n}\n\nstruct wait_data \n{\n\tHANDLE handles[MAXIMUM_WAIT_OBJECTS];\n\tMonoInternalThread *threads[MAXIMUM_WAIT_OBJECTS];\n\tguint32 num;\n};\n\nstatic void wait_for_tids (struct wait_data *wait, guint32 timeout)\n{\n\tguint32 i, ret;\n\t\n\tTHREAD_DEBUG (g_message(\"%s: %d threads to wait for in this batch\", __func__, wait->num));\n\n\tret=WaitForMultipleObjectsEx(wait->num, wait->handles, TRUE, timeout, TRUE);\n\n\tif(ret==WAIT_FAILED) {\n\t\t/* See the comment in build_wait_tids() */\n\t\tTHREAD_DEBUG (g_message (\"%s: Wait failed\", __func__));\n\t\treturn;\n\t}\n\t\n\tfor(i=0; i<wait->num; i++)\n\t\tCloseHandle (wait->handles[i]);\n\n\tif (ret == WAIT_TIMEOUT)\n\t\treturn;\n\n\tfor(i=0; i<wait->num; i++) {\n\t\tgsize tid = wait->threads[i]->tid;\n\t\t\n\t\tmono_threads_lock ();\n\t\tif(mono_g_hash_table_lookup (threads, (gpointer)tid)!=NULL) {\n\t\t\t/* This thread must have been killed, because\n\t\t\t * it hasn't cleaned itself up. (It's just\n\t\t\t * possible that the thread exited before the\n\t\t\t * parent thread had a chance to store the\n\t\t\t * handle, and now there is another pointer to\n\t\t\t * the already-exited thread stored.  In this\n\t\t\t * case, we'll just get two\n\t\t\t * mono_profiler_thread_end() calls for the\n\t\t\t * same thread.)\n\t\t\t */\n\t\n\t\t\tmono_threads_unlock ();\n\t\t\tTHREAD_DEBUG (g_message (\"%s: cleaning up after thread %p (%\"G_GSIZE_FORMAT\")\", __func__, wait->threads[i], tid));\n\t\t\tthread_cleanup (wait->threads[i]);\n\t\t} else {\n\t\t\tmono_threads_unlock ();\n\t\t}\n\t}\n}\n\nstatic void wait_for_tids_or_state_change (struct wait_data *wait, guint32 timeout)\n{\n\tguint32 i, ret, count;\n\t\n\tTHREAD_DEBUG (g_message(\"%s: %d threads to wait for in this batch\", __func__, wait->num));\n\n\t/* Add the thread state change event, so it wakes up if a thread changes\n\t * to background mode.\n\t */\n\tcount = wait->num;\n\tif (count < MAXIMUM_WAIT_OBJECTS) {\n\t\twait->handles [count] = background_change_event;\n\t\tcount++;\n\t}\n\n\tret=WaitForMultipleObjectsEx (count, wait->handles, FALSE, timeout, TRUE);\n\n\tif(ret==WAIT_FAILED) {\n\t\t/* See the comment in build_wait_tids() */\n\t\tTHREAD_DEBUG (g_message (\"%s: Wait failed\", __func__));\n\t\treturn;\n\t}\n\t\n\tfor(i=0; i<wait->num; i++)\n\t\tCloseHandle (wait->handles[i]);\n\n\tif (ret == WAIT_TIMEOUT)\n\t\treturn;\n\t\n\tif (ret < wait->num) {\n\t\tgsize tid = wait->threads[ret]->tid;\n\t\tmono_threads_lock ();\n\t\tif (mono_g_hash_table_lookup (threads, (gpointer)tid)!=NULL) {\n\t\t\t/* See comment in wait_for_tids about thread cleanup */\n\t\t\tmono_threads_unlock ();\n\t\t\tTHREAD_DEBUG (g_message (\"%s: cleaning up after thread %\"G_GSIZE_FORMAT, __func__, tid));\n\t\t\tthread_cleanup (wait->threads [ret]);\n\t\t} else\n\t\t\tmono_threads_unlock ();\n\t}\n}\n\nstatic void build_wait_tids (gpointer key, gpointer value, gpointer user)\n{\n\tstruct wait_data *wait=(struct wait_data *)user;\n\n\tif(wait->num<MAXIMUM_WAIT_OBJECTS) {\n\t\tHANDLE handle;\n\t\tMonoInternalThread *thread=(MonoInternalThread *)value;\n\n\t\t/* Ignore background threads, we abort them later */\n\t\t/* Do not lock here since it is not needed and the caller holds threads_lock */\n\t\tif (thread->state & ThreadState_Background) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring background thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn; /* just leave, ignore */\n\t\t}\n\t\t\n\t\tif (mono_gc_is_finalizer_internal_thread (thread)) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring finalizer thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (thread == mono_thread_internal_current ()) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring current thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (mono_thread_get_main () && (thread == mono_thread_get_main ()->internal_thread)) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring main thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\tif (thread->flags & MONO_THREAD_FLAG_DONT_MANAGE) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring thread %\" G_GSIZE_FORMAT \"with DONT_MANAGE flag set.\", __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL) {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring unopenable thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tTHREAD_DEBUG (g_message (\"%s: Invoking mono_thread_manage callback on thread %p\", __func__, thread));\n\t\tif ((thread->manage_callback == NULL) || (thread->manage_callback (thread->root_domain_thread) == TRUE)) {\n\t\t\twait->handles[wait->num]=handle;\n\t\t\twait->threads[wait->num]=thread;\n\t\t\twait->num++;\n\n\t\t\tTHREAD_DEBUG (g_message (\"%s: adding thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t} else {\n\t\t\tTHREAD_DEBUG (g_message (\"%s: ignoring (because of callback) thread %\"G_GSIZE_FORMAT, __func__, (gsize)thread->tid));\n\t\t}\n\t\t\n\t\t\n\t} else {\n\t\t/* Just ignore the rest, we can't do anything with\n\t\t * them yet\n\t\t */\n\t}\n}\n\nstatic gboolean\nremove_and_abort_threads (gpointer key, gpointer value, gpointer user)\n{\n\tstruct wait_data *wait=(struct wait_data *)user;\n\tgsize self = GetCurrentThreadId ();\n\tMonoInternalThread *thread = value;\n\tHANDLE handle;\n\n\tif (wait->num >= MAXIMUM_WAIT_OBJECTS)\n\t\treturn FALSE;\n\n\t/* The finalizer thread is not a background thread */\n\tif (thread->tid != self && (thread->state & ThreadState_Background) != 0 &&\n\t\t!(thread->flags & MONO_THREAD_FLAG_DONT_MANAGE)) {\n\t\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL)\n\t\t\treturn FALSE;\n\n\t\t/* printf (\"A: %d\\n\", wait->num); */\n\t\twait->handles[wait->num]=thread->handle;\n\t\twait->threads[wait->num]=thread;\n\t\twait->num++;\n\n\t\tTHREAD_DEBUG (g_print (\"%s: Aborting id: %\"G_GSIZE_FORMAT\"\\n\", __func__, (gsize)thread->tid));\n\t\tmono_thread_internal_stop (thread);\n\t\treturn TRUE;\n\t}\n\n\treturn (thread->tid != self && !mono_gc_is_finalizer_internal_thread (thread)); \n}\n\n/** \n * mono_threads_set_shutting_down:\n *\n * Is called by a thread that wants to shut down Mono. If the runtime is already\n * shutting down, the calling thread is suspended/stopped, and this function never\n * returns.\n */\nvoid\nmono_threads_set_shutting_down (void)\n{\n\tMonoInternalThread *current_thread = mono_thread_internal_current ();\n\n\tmono_threads_lock ();\n\n\tif (shutting_down) {\n\t\tmono_threads_unlock ();\n\n\t\t/* Make sure we're properly suspended/stopped */\n\n\t\tEnterCriticalSection (current_thread->synch_cs);\n\n\t\tif ((current_thread->state & ThreadState_SuspendRequested) ||\n\t\t    (current_thread->state & ThreadState_AbortRequested) ||\n\t\t    (current_thread->state & ThreadState_StopRequested)) {\n\t\t\tLeaveCriticalSection (current_thread->synch_cs);\n\t\t\tmono_thread_execute_interruption (current_thread);\n\t\t} else {\n\t\t\tcurrent_thread->state |= ThreadState_Stopped;\n\t\t\tLeaveCriticalSection (current_thread->synch_cs);\n\t\t}\n\n\t\t/*since we're killing the thread, unset the current domain.*/\n\t\tmono_domain_unset ();\n\n\t\t/* Wake up other threads potentially waiting for us */\n\t\tExitThread (0);\n\t} else {\n\t\tshutting_down = TRUE;\n\n\t\t/* Not really a background state change, but this will\n\t\t * interrupt the main thread if it is waiting for all\n\t\t * the other threads.\n\t\t */\n\t\tSetEvent (background_change_event);\n\t\t\n\t\tmono_threads_unlock ();\n\t}\n}\n\n/** \n * mono_threads_is_shutting_down:\n *\n * Returns whether a thread has commenced shutdown of Mono.  Note that\n * if the function returns FALSE the caller must not assume that\n * shutdown is not in progress, because the situation might have\n * changed since the function returned.  For that reason this function\n * is of very limited utility.\n */\ngboolean\nmono_threads_is_shutting_down (void)\n{\n\treturn shutting_down;\n}\n\nvoid mono_thread_manage (void)\n{\n\tstruct wait_data wait_data;\n\tstruct wait_data *wait = &wait_data;\n\n\tmemset (wait, 0, sizeof (struct wait_data));\n\t/* join each thread that's still running */\n\tTHREAD_DEBUG (g_message (\"%s: Joining each running thread...\", __func__));\n\t\n\tmono_threads_lock ();\n\tif(threads==NULL) {\n\t\tTHREAD_DEBUG (g_message(\"%s: No threads\", __func__));\n\t\tmono_threads_unlock ();\n\t\treturn;\n\t}\n\tmono_threads_unlock ();\n\t\n\tdo {\n\t\tmono_threads_lock ();\n\t\tif (shutting_down) {\n\t\t\t/* somebody else is shutting down */\n\t\t\tmono_threads_unlock ();\n\t\t\tbreak;\n\t\t}\n\t\tTHREAD_DEBUG (g_message (\"%s: There are %d threads to join\", __func__, mono_g_hash_table_size (threads));\n\t\t\tmono_g_hash_table_foreach (threads, print_tids, NULL));\n\t\n\t\tResetEvent (background_change_event);\n\t\twait->num=0;\n\t\t/*We must zero all InternalThread pointers to avoid making the GC unhappy.*/\n\t\tmemset (wait->threads, 0, MAXIMUM_WAIT_OBJECTS * SIZEOF_VOID_P);\n\t\tmono_g_hash_table_foreach (threads, build_wait_tids, wait);\n\t\tmono_threads_unlock ();\n\t\tif(wait->num>0) {\n\t\t\t/* Something to wait for */\n\t\t\twait_for_tids_or_state_change (wait, INFINITE);\n\t\t}\n\t\tTHREAD_DEBUG (g_message (\"%s: I have %d threads after waiting.\", __func__, wait->num));\n\t} while(wait->num>0);\n\n\tmono_threads_set_shutting_down ();\n\n\t/* No new threads will be created after this point */\n\n\tmono_runtime_set_shutting_down ();\n\n\tTHREAD_DEBUG (g_message (\"%s: threadpool cleanup\", __func__));\n\tmono_thread_pool_cleanup ();\n\n\t/* \n\t * Remove everything but the finalizer thread and self.\n\t * Also abort all the background threads\n\t * */\n\tdo {\n\t\tmono_threads_lock ();\n\n\t\twait->num = 0;\n\t\t/*We must zero all InternalThread pointers to avoid making the GC unhappy.*/\n\t\tmemset (wait->threads, 0, MAXIMUM_WAIT_OBJECTS * SIZEOF_VOID_P);\n\t\tmono_g_hash_table_foreach_remove (threads, remove_and_abort_threads, wait);\n\n\t\tmono_threads_unlock ();\n\n\t\tTHREAD_DEBUG (g_message (\"%s: wait->num is now %d\", __func__, wait->num));\n\t\tif(wait->num>0) {\n\t\t\t/* Something to wait for */\n\t\t\twait_for_tids (wait, INFINITE);\n\t\t}\n\t} while (wait->num > 0);\n\t\n\t/* \n\t * give the subthreads a chance to really quit (this is mainly needed\n\t * to get correct user and system times from getrusage/wait/time(1)).\n\t * This could be removed if we avoid pthread_detach() and use pthread_join().\n\t */\n#ifndef HOST_WIN32\n\tsched_yield ();\n#endif\n}\n\nstatic void terminate_thread (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread=(MonoInternalThread *)value;\n\t\n\tif(thread->tid != (gsize)user) {\n\t\t/*TerminateThread (thread->handle, -1);*/\n\t}\n}\n\nvoid mono_thread_abort_all_other_threads (void)\n{\n\tgsize self = GetCurrentThreadId ();\n\n\tmono_threads_lock ();\n\tTHREAD_DEBUG (g_message (\"%s: There are %d threads to abort\", __func__,\n\t\t\t\t mono_g_hash_table_size (threads));\n\t\t      mono_g_hash_table_foreach (threads, print_tids, NULL));\n\n\tmono_g_hash_table_foreach (threads, terminate_thread, (gpointer)self);\n\t\n\tmono_threads_unlock ();\n}\n\nstatic void\ncollect_threads_for_suspend (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tstruct wait_data *wait = (struct wait_data*)user_data;\n\tHANDLE handle;\n\n\t/* \n\t * We try to exclude threads early, to avoid running into the MAXIMUM_WAIT_OBJECTS\n\t * limitation.\n\t * This needs no locking.\n\t */\n\tif ((thread->state & ThreadState_Suspended) != 0 || \n\t\t(thread->state & ThreadState_Stopped) != 0)\n\t\treturn;\n\n\tif (wait->num<MAXIMUM_WAIT_OBJECTS) {\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL)\n\t\t\treturn;\n\n\t\twait->handles [wait->num] = handle;\n\t\twait->threads [wait->num] = thread;\n\t\twait->num++;\n\t}\n}\n\n/*\n * mono_thread_suspend_all_other_threads:\n *\n *  Suspend all managed threads except the finalizer thread and this thread. It is\n * not possible to resume them later.\n */\nvoid mono_thread_suspend_all_other_threads (void)\n{\n\tstruct wait_data wait_data;\n\tstruct wait_data *wait = &wait_data;\n\tint i;\n\tgsize self = GetCurrentThreadId ();\n\tgpointer *events;\n\tguint32 eventidx = 0;\n\tgboolean starting, finished;\n\n\tmemset (wait, 0, sizeof (struct wait_data));\n\t/*\n\t * The other threads could be in an arbitrary state at this point, i.e.\n\t * they could be starting up, shutting down etc. This means that there could be\n\t * threads which are not even in the threads hash table yet.\n\t */\n\n\t/* \n\t * First we set a barrier which will be checked by all threads before they\n\t * are added to the threads hash table, and they will exit if the flag is set.\n\t * This ensures that no threads could be added to the hash later.\n\t * We will use shutting_down as the barrier for now.\n\t */\n\tg_assert (shutting_down);\n\n\t/*\n\t * We make multiple calls to WaitForMultipleObjects since:\n\t * - we can only wait for MAXIMUM_WAIT_OBJECTS threads\n\t * - some threads could exit without becoming suspended\n\t */\n\tfinished = FALSE;\n\twhile (!finished) {\n\t\t/*\n\t\t * Make a copy of the hashtable since we can't do anything with\n\t\t * threads while threads_mutex is held.\n\t\t */\n\t\twait->num = 0;\n\t\t/*We must zero all InternalThread pointers to avoid making the GC unhappy.*/\n\t\tmemset (wait->threads, 0, MAXIMUM_WAIT_OBJECTS * SIZEOF_VOID_P);\n\t\tmono_threads_lock ();\n\t\tmono_g_hash_table_foreach (threads, collect_threads_for_suspend, wait);\n\t\tmono_threads_unlock ();\n\n\t\tevents = g_new0 (gpointer, wait->num);\n\t\teventidx = 0;\n\t\t/* Get the suspended events that we'll be waiting for */\n\t\tfor (i = 0; i < wait->num; ++i) {\n\t\t\tMonoInternalThread *thread = wait->threads [i];\n\t\t\tgboolean signal_suspend = FALSE;\n\n\t\t\tif ((thread->tid == self) || mono_gc_is_finalizer_internal_thread (thread) || (thread->flags & MONO_THREAD_FLAG_DONT_MANAGE)) {\n\t\t\t\t//CloseHandle (wait->handles [i]);\n\t\t\t\twait->threads [i] = NULL; /* ignore this thread in next loop */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tensure_synch_cs_set (thread);\n\t\t\n\t\t\tEnterCriticalSection (thread->synch_cs);\n\n\t\t\tif (thread->suspended_event == NULL) {\n\t\t\t\tthread->suspended_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\t\t\t\tif (thread->suspended_event == NULL) {\n\t\t\t\t\t/* Forget this one and go on to the next */\n\t\t\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((thread->state & ThreadState_Suspended) != 0 || \n\t\t\t\t(thread->state & ThreadState_StopRequested) != 0 ||\n\t\t\t\t(thread->state & ThreadState_Stopped) != 0) {\n\t\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\t\tCloseHandle (wait->handles [i]);\n\t\t\t\twait->threads [i] = NULL; /* ignore this thread in next loop */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((thread->state & ThreadState_SuspendRequested) == 0)\n\t\t\t\tsignal_suspend = TRUE;\n\n\t\t\tevents [eventidx++] = thread->suspended_event;\n\n\t\t\t/* Convert abort requests into suspend requests */\n\t\t\tif ((thread->state & ThreadState_AbortRequested) != 0)\n\t\t\t\tthread->state &= ~ThreadState_AbortRequested;\n\t\t\t\n\t\t\tthread->state |= ThreadState_SuspendRequested;\n\n\t\t\tLeaveCriticalSection (thread->synch_cs);\n\n\t\t\t/* Signal the thread to suspend */\n\t\t\tif (signal_suspend)\n\t\t\t\tsignal_thread_state_change (thread);\n\t\t}\n\n\t\tif (eventidx > 0) {\n\t\t\tWaitForMultipleObjectsEx (eventidx, events, TRUE, 100, FALSE);\n\t\t\tfor (i = 0; i < wait->num; ++i) {\n\t\t\t\tMonoInternalThread *thread = wait->threads [i];\n\n\t\t\t\tif (thread == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tensure_synch_cs_set (thread);\n\t\t\t\n\t\t\t\tEnterCriticalSection (thread->synch_cs);\n\t\t\t\tif ((thread->state & ThreadState_Suspended) != 0) {\n\t\t\t\t\tCloseHandle (thread->suspended_event);\n\t\t\t\t\tthread->suspended_event = NULL;\n\t\t\t\t}\n\t\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\t}\n\t\t} else {\n\t\t\t/* \n\t\t\t * If there are threads which are starting up, we wait until they\n\t\t\t * are suspended when they try to register in the threads hash.\n\t\t\t * This is guaranteed to finish, since the threads which can create new\n\t\t\t * threads get suspended after a while.\n\t\t\t * FIXME: The finalizer thread can still create new threads.\n\t\t\t */\n\t\t\tmono_threads_lock ();\n\t\t\tif (threads_starting_up)\n\t\t\t\tstarting = mono_g_hash_table_size (threads_starting_up) > 0;\n\t\t\telse\n\t\t\t\tstarting = FALSE;\n\t\t\tmono_threads_unlock ();\n\t\t\tif (starting)\n\t\t\t\tSleep (100);\n\t\t\telse\n\t\t\t\tfinished = TRUE;\n\t\t}\n\n\t\tg_free (events);\n\t}\n}\n\nstatic void\ncollect_threads (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tstruct wait_data *wait = (struct wait_data*)user_data;\n\tHANDLE handle;\n\n\tif (wait->num<MAXIMUM_WAIT_OBJECTS) {\n\t\thandle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\tif (handle == NULL)\n\t\t\treturn;\n\n\t\twait->handles [wait->num] = handle;\n\t\twait->threads [wait->num] = thread;\n\t\twait->num++;\n\t}\n}\n\n/**\n * mono_threads_request_thread_dump:\n *\n *   Ask all threads except the current to print their stacktrace to stdout.\n */\nvoid\nmono_threads_request_thread_dump (void)\n{\n\tstruct wait_data wait_data;\n\tstruct wait_data *wait = &wait_data;\n\tint i;\n\n\tmemset (wait, 0, sizeof (struct wait_data));\n\n\t/* \n\t * Make a copy of the hashtable since we can't do anything with\n\t * threads while threads_mutex is held.\n\t */\n\tmono_threads_lock ();\n\tmono_g_hash_table_foreach (threads, collect_threads, wait);\n\tmono_threads_unlock ();\n\n\tfor (i = 0; i < wait->num; ++i) {\n\t\tMonoInternalThread *thread = wait->threads [i];\n\n\t\tif (!mono_gc_is_finalizer_internal_thread (thread) &&\n\t\t\t\t(thread != mono_thread_internal_current ()) &&\n\t\t\t\t!thread->thread_dump_requested) {\n\t\t\tthread->thread_dump_requested = TRUE;\n\n\t\t\tsignal_thread_state_change (thread);\n\t\t}\n\n\t\tCloseHandle (wait->handles [i]);\n\t}\n}\n\nstruct ref_stack {\n\tgpointer *refs;\n\tgint allocated; /* +1 so that refs [allocated] == NULL */\n\tgint bottom;\n};\n\ntypedef struct ref_stack RefStack;\n\nstatic RefStack *\nref_stack_new (gint initial_size)\n{\n\tRefStack *rs;\n\n\tinitial_size = MAX (initial_size, 16) + 1;\n\trs = g_new0 (RefStack, 1);\n\trs->refs = g_new0 (gpointer, initial_size);\n\trs->allocated = initial_size;\n\treturn rs;\n}\n\nstatic void\nref_stack_destroy (gpointer ptr)\n{\n\tRefStack *rs = ptr;\n\n\tif (rs != NULL) {\n\t\tg_free (rs->refs);\n\t\tg_free (rs);\n\t}\n}\n\nstatic void\nref_stack_push (RefStack *rs, gpointer ptr)\n{\n\tg_assert (rs != NULL);\n\n\tif (rs->bottom >= rs->allocated) {\n\t\trs->refs = g_realloc (rs->refs, rs->allocated * 2 * sizeof (gpointer) + 1);\n\t\trs->allocated <<= 1;\n\t\trs->refs [rs->allocated] = NULL;\n\t}\n\trs->refs [rs->bottom++] = ptr;\n}\n\nstatic void\nref_stack_pop (RefStack *rs)\n{\n\tif (rs == NULL || rs->bottom == 0)\n\t\treturn;\n\n\trs->bottom--;\n\trs->refs [rs->bottom] = NULL;\n}\n\nstatic gboolean\nref_stack_find (RefStack *rs, gpointer ptr)\n{\n\tgpointer *refs;\n\n\tif (rs == NULL)\n\t\treturn FALSE;\n\n\tfor (refs = rs->refs; refs && *refs; refs++) {\n\t\tif (*refs == ptr)\n\t\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}\n\n/*\n * mono_thread_push_appdomain_ref:\n *\n *   Register that the current thread may have references to objects in domain \n * @domain on its stack. Each call to this function should be paired with a \n * call to pop_appdomain_ref.\n */\nvoid \nmono_thread_push_appdomain_ref (MonoDomain *domain)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tif (thread) {\n\t\t/* printf (\"PUSH REF: %\"G_GSIZE_FORMAT\" -> %s.\\n\", (gsize)thread->tid, domain->friendly_name); */\n\t\tSPIN_LOCK (thread->lock_thread_id);\n\t\tif (thread->appdomain_refs == NULL)\n\t\t\tthread->appdomain_refs = ref_stack_new (16);\n\t\tref_stack_push (thread->appdomain_refs, domain);\n\t\tSPIN_UNLOCK (thread->lock_thread_id);\n\t}\n}\n\nvoid\nmono_thread_pop_appdomain_ref (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tif (thread) {\n\t\t/* printf (\"POP REF: %\"G_GSIZE_FORMAT\" -> %s.\\n\", (gsize)thread->tid, ((MonoDomain*)(thread->appdomain_refs->data))->friendly_name); */\n\t\tSPIN_LOCK (thread->lock_thread_id);\n\t\tref_stack_pop (thread->appdomain_refs);\n\t\tSPIN_UNLOCK (thread->lock_thread_id);\n\t}\n}\n\ngboolean\nmono_thread_internal_has_appdomain_ref (MonoInternalThread *thread, MonoDomain *domain)\n{\n\tgboolean res;\n\tSPIN_LOCK (thread->lock_thread_id);\n\tres = ref_stack_find (thread->appdomain_refs, domain);\n\tSPIN_UNLOCK (thread->lock_thread_id);\n\treturn res;\n}\n\ngboolean\nmono_thread_has_appdomain_ref (MonoThread *thread, MonoDomain *domain)\n{\n\treturn mono_thread_internal_has_appdomain_ref (thread->internal_thread, domain);\n}\n\ntypedef struct abort_appdomain_data {\n\tstruct wait_data wait;\n\tMonoDomain *domain;\n} abort_appdomain_data;\n\nstatic void\ncollect_appdomain_thread (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tabort_appdomain_data *data = (abort_appdomain_data*)user_data;\n\tMonoDomain *domain = data->domain;\n\n\tif (mono_thread_internal_has_appdomain_ref (thread, domain)) {\n\t\t/* printf (\"ABORTING THREAD %p BECAUSE IT REFERENCES DOMAIN %s.\\n\", thread->tid, domain->friendly_name); */\n\n\t\tif(data->wait.num<MAXIMUM_WAIT_OBJECTS) {\n\t\t\tHANDLE handle = OpenThread (THREAD_ALL_ACCESS, TRUE, thread->tid);\n\t\t\tif (handle == NULL)\n\t\t\t\treturn;\n\t\t\tdata->wait.handles [data->wait.num] = handle;\n\t\t\tdata->wait.threads [data->wait.num] = thread;\n\t\t\tdata->wait.num++;\n\t\t} else {\n\t\t\t/* Just ignore the rest, we can't do anything with\n\t\t\t * them yet\n\t\t\t */\n\t\t}\n\t}\n}\n\n/*\n * mono_threads_abort_appdomain_threads:\n *\n *   Abort threads which has references to the given appdomain.\n */\ngboolean\nmono_threads_abort_appdomain_threads (MonoDomain *domain, int timeout)\n{\n\tabort_appdomain_data user_data;\n\tguint32 start_time;\n\tint orig_timeout = timeout;\n\tint i;\n\n\tTHREAD_DEBUG (g_message (\"%s: starting abort\", __func__));\n\n\tstart_time = mono_msec_ticks ();\n\tdo {\n\t\tmono_threads_lock ();\n\n\t\tuser_data.domain = domain;\n\t\tuser_data.wait.num = 0;\n\t\t/* This shouldn't take any locks */\n\t\tmono_g_hash_table_foreach (threads, collect_appdomain_thread, &user_data);\n\t\tmono_threads_unlock ();\n\n\t\tif (user_data.wait.num > 0) {\n\t\t\t/* Abort the threads outside the threads lock */\n\t\t\tfor (i = 0; i < user_data.wait.num; ++i)\n\t\t\t\tves_icall_System_Threading_Thread_Abort (user_data.wait.threads [i], NULL);\n\n\t\t\t/*\n\t\t\t * We should wait for the threads either to abort, or to leave the\n\t\t\t * domain. We can't do the latter, so we wait with a timeout.\n\t\t\t */\n\t\t\twait_for_tids (&user_data.wait, 100);\n\t\t}\n\n\t\t/* Update remaining time */\n\t\ttimeout -= mono_msec_ticks () - start_time;\n\t\tstart_time = mono_msec_ticks ();\n\n\t\tif (orig_timeout != -1 && timeout < 0)\n\t\t\treturn FALSE;\n\t}\n\twhile (user_data.wait.num > 0);\n\n\tTHREAD_DEBUG (g_message (\"%s: abort done\", __func__));\n\n\treturn TRUE;\n}\n\nstatic void\nclear_cached_culture (gpointer key, gpointer value, gpointer user_data)\n{\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tMonoDomain *domain = (MonoDomain*)user_data;\n\tint i;\n\n\t/* No locking needed here */\n\t/* FIXME: why no locking? writes to the cache are protected with synch_cs above */\n\n\tif (thread->cached_culture_info) {\n\t\tfor (i = 0; i < NUM_CACHED_CULTURES * 2; ++i) {\n\t\t\tMonoObject *obj = mono_array_get (thread->cached_culture_info, MonoObject*, i);\n\t\t\tif (obj && obj->vtable->domain == domain)\n\t\t\t\tmono_array_set (thread->cached_culture_info, MonoObject*, i, NULL);\n\t\t}\n\t}\n}\n\t\n/*\n * mono_threads_clear_cached_culture:\n *\n *   Clear the cached_current_culture from all threads if it is in the\n * given appdomain.\n */\nvoid\nmono_threads_clear_cached_culture (MonoDomain *domain)\n{\n\tmono_threads_lock ();\n\tmono_g_hash_table_foreach (threads, clear_cached_culture, domain);\n\tmono_threads_unlock ();\n}\n\n/*\n * mono_thread_get_undeniable_exception:\n *\n *   Return an exception which needs to be raised when leaving a catch clause.\n * This is used for undeniable exception propagation.\n */\nMonoException*\nmono_thread_get_undeniable_exception (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\tif (thread && thread->abort_exc && !is_running_protected_wrapper ()) {\n\t\t/*\n\t\t * FIXME: Clear the abort exception and return an AppDomainUnloaded \n\t\t * exception if the thread no longer references a dying appdomain.\n\t\t */\n\t\tthread->abort_exc->trace_ips = NULL;\n\t\tthread->abort_exc->stack_trace = NULL;\n\t\treturn thread->abort_exc;\n\t}\n\n\treturn NULL;\n}\n\n#if MONO_SMALL_CONFIG\n#define NUM_STATIC_DATA_IDX 4\nstatic const int static_data_size [NUM_STATIC_DATA_IDX] = {\n\t64, 256, 1024, 4096\n};\n#else\n#define NUM_STATIC_DATA_IDX 8\nstatic const int static_data_size [NUM_STATIC_DATA_IDX] = {\n\t1024, 4096, 16384, 65536, 262144, 1048576, 4194304, 16777216\n};\n#endif\n\nstatic uintptr_t* static_reference_bitmaps [NUM_STATIC_DATA_IDX];\n\n#ifdef HAVE_SGEN_GC\nstatic void\nmark_tls_slots (void *addr, MonoGCMarkFunc mark_func)\n{\n\tint i;\n\tgpointer *static_data = addr;\n\tfor (i = 0; i < NUM_STATIC_DATA_IDX; ++i) {\n\t\tint j, numwords;\n\t\tvoid **ptr;\n\t\tif (!static_data [i])\n\t\t\tcontinue;\n\t\tnumwords = 1 + static_data_size [i] / sizeof (gpointer) / (sizeof(uintptr_t) * 8);\n\t\tptr = static_data [i];\n\t\tfor (j = 0; j < numwords; ++j, ptr += sizeof (uintptr_t) * 8) {\n\t\t\tuintptr_t bmap = static_reference_bitmaps [i][j];\n\t\t\tvoid ** p = ptr;\n\t\t\twhile (bmap) {\n\t\t\t\tif ((bmap & 1) && *p) {\n\t\t\t\t\tmark_func (p);\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tbmap >>= 1;\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\n/*\n *  mono_alloc_static_data\n *\n *   Allocate memory blocks for storing threads or context static data\n */\nstatic void \nmono_alloc_static_data (gpointer **static_data_ptr, guint32 offset, gboolean threadlocal)\n{\n\tguint idx = (offset >> 24) - 1;\n\tint i;\n\n\tgpointer* static_data = *static_data_ptr;\n\tif (!static_data) {\n\t\tstatic void* tls_desc = NULL;\n#ifdef HAVE_SGEN_GC\n\t\tif (!tls_desc)\n\t\t\ttls_desc = mono_gc_make_root_descr_user (mark_tls_slots);\n#endif\n\t\tstatic_data = mono_gc_alloc_fixed (static_data_size [0], threadlocal?tls_desc:NULL);\n\t\t*static_data_ptr = static_data;\n\t\tstatic_data [0] = static_data;\n\t}\n\n\tfor (i = 1; i <= idx; ++i) {\n\t\tif (static_data [i])\n\t\t\tcontinue;\n#ifdef HAVE_SGEN_GC\n\t\tstatic_data [i] = threadlocal?g_malloc0 (static_data_size [i]):mono_gc_alloc_fixed (static_data_size [i], NULL);\n#else\n\t\tstatic_data [i] = mono_gc_alloc_fixed (static_data_size [i], NULL);\n#endif\n\t}\n}\n\nstatic void \nmono_free_static_data (gpointer* static_data, gboolean threadlocal)\n{\n\tint i;\n\tfor (i = 1; i < NUM_STATIC_DATA_IDX; ++i) {\n\t\tif (!static_data [i])\n\t\t\tcontinue;\n#ifdef HAVE_SGEN_GC\n\t\tif (threadlocal)\n\t\t\tg_free (static_data [i]);\n\t\telse\n\t\t\tmono_gc_free_fixed (static_data [i]);\n#else\n\t\tmono_gc_free_fixed (static_data [i]);\n#endif\n\t}\n\tmono_gc_free_fixed (static_data);\n}\n\n/*\n *  mono_init_static_data_info\n *\n *   Initializes static data counters\n */\nstatic void mono_init_static_data_info (StaticDataInfo *static_data)\n{\n\tstatic_data->idx = 0;\n\tstatic_data->offset = 0;\n\tstatic_data->freelist = NULL;\n}\n\n/*\n *  mono_alloc_static_data_slot\n *\n *   Generates an offset for static data. static_data contains the counters\n *  used to generate it.\n */\nstatic guint32\nmono_alloc_static_data_slot (StaticDataInfo *static_data, guint32 size, guint32 align)\n{\n\tguint32 offset;\n\n\tif (!static_data->idx && !static_data->offset) {\n\t\t/* \n\t\t * we use the first chunk of the first allocation also as\n\t\t * an array for the rest of the data \n\t\t */\n\t\tstatic_data->offset = sizeof (gpointer) * NUM_STATIC_DATA_IDX;\n\t}\n\tstatic_data->offset += align - 1;\n\tstatic_data->offset &= ~(align - 1);\n\tif (static_data->offset + size >= static_data_size [static_data->idx]) {\n\t\tstatic_data->idx ++;\n\t\tg_assert (size <= static_data_size [static_data->idx]);\n\t\tg_assert (static_data->idx < NUM_STATIC_DATA_IDX);\n\t\tstatic_data->offset = 0;\n\t}\n\toffset = static_data->offset | ((static_data->idx + 1) << 24);\n\tstatic_data->offset += size;\n\treturn offset;\n}\n\n/* \n * ensure thread static fields already allocated are valid for thread\n * This function is called when a thread is created or on thread attach.\n */\nstatic void\nthread_adjust_static_data (MonoInternalThread *thread)\n{\n\tguint32 offset;\n\n\tmono_threads_lock ();\n\tif (thread_static_info.offset || thread_static_info.idx > 0) {\n\t\t/* get the current allocated size */\n\t\toffset = thread_static_info.offset | ((thread_static_info.idx + 1) << 24);\n\t\tmono_alloc_static_data (&(thread->static_data), offset, TRUE);\n\t}\n\tmono_threads_unlock ();\n}\n\nstatic void \nalloc_thread_static_data_helper (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread = value;\n\tguint32 offset = GPOINTER_TO_UINT (user);\n\n\tmono_alloc_static_data (&(thread->static_data), offset, TRUE);\n}\n\nstatic MonoThreadDomainTls*\nsearch_tls_slot_in_freelist (StaticDataInfo *static_data, guint32 size, guint32 align)\n{\n\tMonoThreadDomainTls* prev = NULL;\n\tMonoThreadDomainTls* tmp = static_data->freelist;\n\twhile (tmp) {\n\t\tif (tmp->size == size) {\n\t\t\tif (prev)\n\t\t\t\tprev->next = tmp->next;\n\t\t\telse\n\t\t\t\tstatic_data->freelist = tmp->next;\n\t\t\treturn tmp;\n\t\t}\n\t\ttmp = tmp->next;\n\t}\n\treturn NULL;\n}\n\nstatic void\nupdate_tls_reference_bitmap (guint32 offset, uintptr_t *bitmap, int max_set)\n{\n\tint i;\n\tint idx = (offset >> 24) - 1;\n\tuintptr_t *rb;\n\tif (!static_reference_bitmaps [idx])\n\t\tstatic_reference_bitmaps [idx] = g_new0 (uintptr_t, 1 + static_data_size [idx] / sizeof(gpointer) / (sizeof(uintptr_t) * 8));\n\trb = static_reference_bitmaps [idx];\n\toffset &= 0xffffff;\n\toffset /= sizeof (gpointer);\n\t/* offset is now the bitmap offset */\n\tfor (i = 0; i < max_set; ++i) {\n\t\tif (bitmap [i / sizeof (uintptr_t)] & (1L << (i & (sizeof (uintptr_t) * 8 -1))))\n\t\t\trb [(offset + i) / (sizeof (uintptr_t) * 8)] |= (1L << ((offset + i) & (sizeof (uintptr_t) * 8 -1)));\n\t}\n}\n\nstatic void\nclear_reference_bitmap (guint32 offset, guint32 size)\n{\n\tint idx = (offset >> 24) - 1;\n\tuintptr_t *rb;\n\trb = static_reference_bitmaps [idx];\n\toffset &= 0xffffff;\n\toffset /= sizeof (gpointer);\n\tsize /= sizeof (gpointer);\n\tsize += offset;\n\t/* offset is now the bitmap offset */\n\tfor (; offset < size; ++offset)\n\t\trb [offset / (sizeof (uintptr_t) * 8)] &= ~(1L << (offset & (sizeof (uintptr_t) * 8 -1)));\n}\n\n/*\n * The offset for a special static variable is composed of three parts:\n * a bit that indicates the type of static data (0:thread, 1:context),\n * an index in the array of chunks of memory for the thread (thread->static_data)\n * and an offset in that chunk of mem. This allows allocating less memory in the \n * common case.\n */\n\nguint32\nmono_alloc_special_static_data (guint32 static_type, guint32 size, guint32 align, uintptr_t *bitmap, int max_set)\n{\n\tguint32 offset;\n\tif (static_type == SPECIAL_STATIC_THREAD) {\n\t\tMonoThreadDomainTls *item;\n\t\tmono_threads_lock ();\n\t\titem = search_tls_slot_in_freelist (&thread_static_info, size, align);\n\t\t/*g_print (\"TLS alloc: %d in domain %p (total: %d), cached: %p\\n\", size, mono_domain_get (), thread_static_info.offset, item);*/\n\t\tif (item) {\n\t\t\toffset = item->offset;\n\t\t\tg_free (item);\n\t\t} else {\n\t\t\toffset = mono_alloc_static_data_slot (&thread_static_info, size, align);\n\t\t}\n\t\tupdate_tls_reference_bitmap (offset, bitmap, max_set);\n\t\t/* This can be called during startup */\n\t\tif (threads != NULL)\n\t\t\tmono_g_hash_table_foreach (threads, alloc_thread_static_data_helper, GUINT_TO_POINTER (offset));\n\t\tmono_threads_unlock ();\n\t} else {\n\t\tg_assert (static_type == SPECIAL_STATIC_CONTEXT);\n\t\tmono_contexts_lock ();\n\t\toffset = mono_alloc_static_data_slot (&context_static_info, size, align);\n\t\tmono_contexts_unlock ();\n\t\toffset |= 0x80000000;\t/* Set the high bit to indicate context static data */\n\t}\n\treturn offset;\n}\n\ngpointer\nmono_get_special_static_data_for_thread (MonoInternalThread *thread, guint32 offset)\n{\n\t/* The high bit means either thread (0) or static (1) data. */\n\n\tguint32 static_type = (offset & 0x80000000);\n\tint idx;\n\n\toffset &= 0x7fffffff;\n\tidx = (offset >> 24) - 1;\n\n\tif (static_type == 0) {\n\t\treturn get_thread_static_data (thread, offset);\n\t} else {\n\t\t/* Allocate static data block under demand, since we don't have a list\n\t\t// of contexts\n\t\t*/\n\t\tMonoAppContext *context = mono_context_get ();\n\t\tif (!context->static_data || !context->static_data [idx]) {\n\t\t\tmono_contexts_lock ();\n\t\t\tmono_alloc_static_data (&(context->static_data), offset, FALSE);\n\t\t\tmono_contexts_unlock ();\n\t\t}\n\t\treturn ((char*) context->static_data [idx]) + (offset & 0xffffff);\t\n\t}\n}\n\ngpointer\nmono_get_special_static_data (guint32 offset)\n{\n\treturn mono_get_special_static_data_for_thread (mono_thread_internal_current (), offset);\n}\n\ntypedef struct {\n\tguint32 offset;\n\tguint32 size;\n} TlsOffsetSize;\n\nstatic void \nfree_thread_static_data_helper (gpointer key, gpointer value, gpointer user)\n{\n\tMonoInternalThread *thread = value;\n\tTlsOffsetSize *data = user;\n\tint idx = (data->offset >> 24) - 1;\n\tchar *ptr;\n\n\tif (!thread->static_data || !thread->static_data [idx])\n\t\treturn;\n\tptr = ((char*) thread->static_data [idx]) + (data->offset & 0xffffff);\n\tmemset (ptr, 0, data->size);\n}\n\nstatic void\ndo_free_special_slot (guint32 offset, guint32 size)\n{\n\tguint32 static_type = (offset & 0x80000000);\n\t/*g_print (\"free %s , size: %d, offset: %x\\n\", field->name, size, offset);*/\n\tif (static_type == 0) {\n\t\tTlsOffsetSize data;\n\t\tMonoThreadDomainTls *item = g_new0 (MonoThreadDomainTls, 1);\n\t\tdata.offset = offset & 0x7fffffff;\n\t\tdata.size = size;\n\t\tclear_reference_bitmap (data.offset, data.size);\n\t\tif (threads != NULL)\n\t\t\tmono_g_hash_table_foreach (threads, free_thread_static_data_helper, &data);\n\t\titem->offset = offset;\n\t\titem->size = size;\n\n\t\tif (!mono_runtime_is_shutting_down ()) {\n\t\t\titem->next = thread_static_info.freelist;\n\t\t\tthread_static_info.freelist = item;\n\t\t} else {\n\t\t\t/* We could be called during shutdown after mono_thread_cleanup () is called */\n\t\t\tg_free (item);\n\t\t}\n\t} else {\n\t\t/* FIXME: free context static data as well */\n\t}\n}\n\nstatic void\ndo_free_special (gpointer key, gpointer value, gpointer data)\n{\n\tMonoClassField *field = key;\n\tguint32 offset = GPOINTER_TO_UINT (value);\n\tgint32 align;\n\tguint32 size;\n\tsize = mono_type_size (field->type, &align);\n\tdo_free_special_slot (offset, size);\n}\n\nvoid\nmono_alloc_special_static_data_free (GHashTable *special_static_fields)\n{\n\tmono_threads_lock ();\n\tg_hash_table_foreach (special_static_fields, do_free_special, NULL);\n\tmono_threads_unlock ();\n}\n\nvoid\nmono_special_static_data_free_slot (guint32 offset, guint32 size)\n{\n\tmono_threads_lock ();\n\tdo_free_special_slot (offset, size);\n\tmono_threads_unlock ();\n}\n\n/*\n * allocates room in the thread local area for storing an instance of the struct type\n * the allocation is kept track of in domain->tlsrec_list.\n */\nuint32_t\nmono_thread_alloc_tls (MonoReflectionType *type)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tMonoClass *klass;\n\tMonoTlsDataRecord *tlsrec;\n\tint max_set = 0;\n\tgsize *bitmap;\n\tgsize default_bitmap [4] = {0};\n\tuint32_t tls_offset;\n\tguint32 size;\n\tgint32 align;\n\n\tklass = mono_class_from_mono_type (type->type);\n\t/* TlsDatum is a struct, so we subtract the object header size offset */\n\tbitmap = mono_class_compute_bitmap (klass, default_bitmap, sizeof (default_bitmap) * 8, - (int)(sizeof (MonoObject) / sizeof (gpointer)), &max_set, FALSE);\n\tsize = mono_type_size (type->type, &align);\n\ttls_offset = mono_alloc_special_static_data (SPECIAL_STATIC_THREAD, size, align, bitmap, max_set);\n\tif (bitmap != default_bitmap)\n\t\tg_free (bitmap);\n\ttlsrec = g_new0 (MonoTlsDataRecord, 1);\n\ttlsrec->tls_offset = tls_offset;\n\ttlsrec->size = size;\n\tmono_domain_lock (domain);\n\ttlsrec->next = domain->tlsrec_list;\n\tdomain->tlsrec_list = tlsrec;\n\tmono_domain_unlock (domain);\n\treturn tls_offset;\n}\n\nvoid\nmono_thread_destroy_tls (uint32_t tls_offset)\n{\n\tMonoTlsDataRecord *prev = NULL;\n\tMonoTlsDataRecord *cur;\n\tguint32 size = 0;\n\tMonoDomain *domain = mono_domain_get ();\n\tmono_domain_lock (domain);\n\tcur = domain->tlsrec_list;\n\twhile (cur) {\n\t\tif (cur->tls_offset == tls_offset) {\n\t\t\tif (prev)\n\t\t\t\tprev->next = cur->next;\n\t\t\telse\n\t\t\t\tdomain->tlsrec_list = cur->next;\n\t\t\tsize = cur->size;\n\t\t\tg_free (cur);\n\t\t\tbreak;\n\t\t}\n\t\tprev = cur;\n\t\tcur = cur->next;\n\t}\n\tmono_domain_unlock (domain);\n\tif (size)\n\t\tmono_special_static_data_free_slot (tls_offset, size);\n}\n\n/*\n * This is just to ensure cleanup: the finalizers should have taken care, so this is not perf-critical.\n */\nvoid\nmono_thread_destroy_domain_tls (MonoDomain *domain)\n{\n\twhile (domain->tlsrec_list)\n\t\tmono_thread_destroy_tls (domain->tlsrec_list->tls_offset);\n}\n\nstatic MonoClassField *local_slots = NULL;\n\ntypedef struct {\n\t/* local tls data to get locals_slot from a thread */\n\tguint32 offset;\n\tint idx;\n\t/* index in the locals_slot array */\n\tint slot;\n} LocalSlotID;\n\nstatic void\nclear_local_slot (gpointer key, gpointer value, gpointer user_data)\n{\n\tLocalSlotID *sid = user_data;\n\tMonoInternalThread *thread = (MonoInternalThread*)value;\n\tMonoArray *slots_array;\n\t/*\n\t * the static field is stored at: ((char*) thread->static_data [idx]) + (offset & 0xffffff);\n\t * it is for the right domain, so we need to check if it is allocated an initialized\n\t * for the current thread.\n\t */\n\t/*g_print (\"handling thread %p\\n\", thread);*/\n\tif (!thread->static_data || !thread->static_data [sid->idx])\n\t\treturn;\n\tslots_array = *(MonoArray **)(((char*) thread->static_data [sid->idx]) + (sid->offset & 0xffffff));\n\tif (!slots_array || sid->slot >= mono_array_length (slots_array))\n\t\treturn;\n\tmono_array_set (slots_array, MonoObject*, sid->slot, NULL);\n}\n\nvoid\nmono_thread_free_local_slot_values (int slot, MonoBoolean thread_local)\n{\n\tMonoDomain *domain;\n\tLocalSlotID sid;\n\tsid.slot = slot;\n\tif (thread_local) {\n\t\tvoid *addr = NULL;\n\t\tif (!local_slots) {\n\t\t\tlocal_slots = mono_class_get_field_from_name (mono_defaults.thread_class, \"local_slots\");\n\t\t\tif (!local_slots) {\n\t\t\t\tg_warning (\"local_slots field not found in Thread class\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdomain = mono_domain_get ();\n\t\tmono_domain_lock (domain);\n\t\tif (domain->special_static_fields)\n\t\t\taddr = g_hash_table_lookup (domain->special_static_fields, local_slots);\n\t\tmono_domain_unlock (domain);\n\t\tif (!addr)\n\t\t\treturn;\n\t\t/*g_print (\"freeing slot %d at %p\\n\", slot, addr);*/\n\t\tsid.offset = GPOINTER_TO_UINT (addr);\n\t\tsid.offset &= 0x7fffffff;\n\t\tsid.idx = (sid.offset >> 24) - 1;\n\t\tmono_threads_lock ();\n\t\tmono_g_hash_table_foreach (threads, clear_local_slot, &sid);\n\t\tmono_threads_unlock ();\n\t} else {\n\t\t/* FIXME: clear the slot for MonoAppContexts, too */\n\t}\n}\n\n#ifdef HOST_WIN32\nstatic void CALLBACK dummy_apc (ULONG_PTR param)\n{\n}\n#else\nstatic guint32 dummy_apc (gpointer param)\n{\n\treturn 0;\n}\n#endif\n\n/*\n * mono_thread_execute_interruption\n * \n * Performs the operation that the requested thread state requires (abort,\n * suspend or stop)\n */\nstatic MonoException* mono_thread_execute_interruption (MonoInternalThread *thread)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\t/* MonoThread::interruption_requested can only be changed with atomics */\n\tif (InterlockedCompareExchange (&thread->interruption_requested, FALSE, TRUE)) {\n\t\t/* this will consume pending APC calls */\n\t\tWaitForSingleObjectEx (GetCurrentThread(), 0, TRUE);\n\t\tInterlockedDecrement (&thread_interruption_requested);\n#ifndef HOST_WIN32\n\t\t/* Clear the interrupted flag of the thread so it can wait again */\n\t\twapi_clear_interruption ();\n#endif\n\t}\n\n\tif ((thread->state & ThreadState_AbortRequested) != 0) {\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\tif (thread->abort_exc == NULL) {\n\t\t\t/* \n\t\t\t * This might be racy, but it has to be called outside the lock\n\t\t\t * since it calls managed code.\n\t\t\t */\n\t\t\tMONO_OBJECT_SETREF (thread, abort_exc, mono_get_exception_thread_abort ());\n\t\t}\n\t\treturn thread->abort_exc;\n\t}\n\telse if ((thread->state & ThreadState_SuspendRequested) != 0) {\n\t\tthread->state &= ~ThreadState_SuspendRequested;\n\t\tthread->state |= ThreadState_Suspended;\n\t\tthread->suspend_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\t\tif (thread->suspend_event == NULL) {\n\t\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\treturn(NULL);\n\t\t}\n\t\tif (thread->suspended_event)\n\t\t\tSetEvent (thread->suspended_event);\n\n\t\tLeaveCriticalSection (thread->synch_cs);\n\n\t\tif (shutting_down) {\n\t\t\t/* After we left the lock, the runtime might shut down so everything becomes invalid */\n\t\t\tfor (;;)\n\t\t\t\tSleep (1000);\n\t\t}\n\t\t\n\t\tWaitForSingleObject (thread->suspend_event, INFINITE);\n\t\t\n\t\tEnterCriticalSection (thread->synch_cs);\n\n\t\tCloseHandle (thread->suspend_event);\n\t\tthread->suspend_event = NULL;\n\t\tthread->state &= ~ThreadState_Suspended;\n\t\n\t\t/* The thread that requested the resume will have replaced this event\n\t\t * and will be waiting for it\n\t\t */\n\t\tSetEvent (thread->resume_event);\n\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\n\t\treturn NULL;\n\t}\n\telse if ((thread->state & ThreadState_StopRequested) != 0) {\n\t\t/* FIXME: do this through the JIT? */\n\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\n\t\tmono_thread_exit ();\n\t\treturn NULL;\n\t} else if (thread->thread_interrupt_requested) {\n\n\t\tthread->thread_interrupt_requested = FALSE;\n\t\tLeaveCriticalSection (thread->synch_cs);\n\t\t\n\t\treturn(mono_get_exception_thread_interrupted ());\n\t}\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\treturn NULL;\n}\n\n/*\n * mono_thread_request_interruption\n *\n * A signal handler can call this method to request the interruption of a\n * thread. The result of the interruption will depend on the current state of\n * the thread. If the result is an exception that needs to be throw, it is \n * provided as return value.\n */\nMonoException*\nmono_thread_request_interruption (gboolean running_managed)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL) \n\t\treturn NULL;\n\n#ifdef HOST_WIN32\n\tif (thread->interrupt_on_stop && \n\t\tthread->state & ThreadState_StopRequested && \n\t\tthread->state & ThreadState_Background)\n\t\tExitThread (1);\n#endif\n\t\n\tif (InterlockedCompareExchange (&thread->interruption_requested, 1, 0) == 1)\n\t\treturn NULL;\n\n\tif (!running_managed || is_running_protected_wrapper ()) {\n\t\t/* Can't stop while in unmanaged code. Increase the global interruption\n\t\t   request count. When exiting the unmanaged method the count will be\n\t\t   checked and the thread will be interrupted. */\n\t\t\n\t\tInterlockedIncrement (&thread_interruption_requested);\n\n\t\tif (mono_thread_notify_pending_exc_fn && !running_managed)\n\t\t\t/* The JIT will notify the thread about the interruption */\n\t\t\t/* This shouldn't take any locks */\n\t\t\tmono_thread_notify_pending_exc_fn ();\n\n\t\t/* this will awake the thread if it is in WaitForSingleObject \n\t\t   or similar */\n\t\t/* Our implementation of this function ignores the func argument */\n\t\tQueueUserAPC ((PAPCFUNC)dummy_apc, thread->handle, NULL);\n\t\treturn NULL;\n\t}\n\telse {\n\t\treturn mono_thread_execute_interruption (thread);\n\t}\n}\n\n/*This function should be called by a thread after it has exited all of\n * its handle blocks at interruption time.*/\nMonoException*\nmono_thread_resume_interruption (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\tgboolean still_aborting;\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn NULL;\n\n\tensure_synch_cs_set (thread);\n\tEnterCriticalSection (thread->synch_cs);\n\tstill_aborting = (thread->state & ThreadState_AbortRequested) != 0;\n\tLeaveCriticalSection (thread->synch_cs);\n\n\t/*This can happen if the protected block called Thread::ResetAbort*/\n\tif (!still_aborting)\n\t\treturn FALSE;\n\n\tif (InterlockedCompareExchange (&thread->interruption_requested, 1, 0) == 1)\n\t\treturn NULL;\n\tInterlockedIncrement (&thread_interruption_requested);\n\n#ifndef HOST_WIN32\n\twapi_self_interrupt ();\n#endif\n\treturn mono_thread_execute_interruption (thread);\n}\n\ngboolean mono_thread_interruption_requested ()\n{\n\tif (thread_interruption_requested) {\n\t\tMonoInternalThread *thread = mono_thread_internal_current ();\n\t\t/* The thread may already be stopping */\n\t\tif (thread != NULL) \n\t\t\treturn (thread->interruption_requested);\n\t}\n\treturn FALSE;\n}\n\nstatic void mono_thread_interruption_checkpoint_request (gboolean bypass_abort_protection)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn;\n\n\tmono_debugger_check_interruption ();\n\n\tif (thread->interruption_requested && (bypass_abort_protection || !is_running_protected_wrapper ())) {\n\t\tMonoException* exc = mono_thread_execute_interruption (thread);\n\t\tif (exc) mono_raise_exception (exc);\n\t}\n}\n\n/*\n * Performs the interruption of the current thread, if one has been requested,\n * and the thread is not running a protected wrapper.\n */\nvoid mono_thread_interruption_checkpoint ()\n{\n\tmono_thread_interruption_checkpoint_request (FALSE);\n}\n\n/*\n * Performs the interruption of the current thread, if one has been requested.\n */\nvoid mono_thread_force_interruption_checkpoint ()\n{\n\tmono_thread_interruption_checkpoint_request (TRUE);\n}\n\n/*\n * mono_thread_get_and_clear_pending_exception:\n *\n *   Return any pending exceptions for the current thread and clear it as a side effect.\n */\nMonoException*\nmono_thread_get_and_clear_pending_exception (void)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn NULL;\n\n\tif (thread->interruption_requested && !is_running_protected_wrapper ()) {\n\t\treturn mono_thread_execute_interruption (thread);\n\t}\n\t\n\tif (thread->pending_exception) {\n\t\tMonoException *exc = thread->pending_exception;\n\n\t\tthread->pending_exception = NULL;\n\t\treturn exc;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * mono_set_pending_exception:\n *\n *   Set the pending exception of the current thread to EXC. On platforms which \n * support it, the exception will be thrown when execution returns to managed code. \n * On other platforms, this function is equivalent to mono_raise_exception (). \n * Internal calls which report exceptions using this function instead of \n * raise_exception () might be called by JITted code using a more efficient calling \n * convention.\n */\nvoid\nmono_set_pending_exception (MonoException *exc)\n{\n\tMonoInternalThread *thread = mono_thread_internal_current ();\n\n\t/* The thread may already be stopping */\n\tif (thread == NULL)\n\t\treturn;\n\n\tif (mono_thread_notify_pending_exc_fn) {\n\t\tMONO_OBJECT_SETREF (thread, pending_exception, exc);\n\n\t\tmono_thread_notify_pending_exc_fn ();\n\t} else {\n\t\t/* No way to notify the JIT about the exception, have to throw it now */\n\t\tmono_raise_exception (exc);\n\t}\n}\n\n/**\n * mono_thread_interruption_request_flag:\n *\n * Returns the address of a flag that will be non-zero if an interruption has\n * been requested for a thread. The thread to interrupt may not be the current\n * thread, so an additional call to mono_thread_interruption_requested() or\n * mono_thread_interruption_checkpoint() is allways needed if the flag is not\n * zero.\n */\ngint32* mono_thread_interruption_request_flag ()\n{\n\treturn &thread_interruption_requested;\n}\n\nvoid \nmono_thread_init_apartment_state (void)\n{\n#ifdef HOST_WIN32\n\tMonoInternalThread* thread = mono_thread_internal_current ();\n\n\t/* Positive return value indicates success, either\n\t * S_OK if this is first CoInitialize call, or\n\t * S_FALSE if CoInitialize already called, but with same\n\t * threading model. A negative value indicates failure,\n\t * probably due to trying to change the threading model.\n\t */\n\tif (CoInitializeEx(NULL, (thread->apartment_state == ThreadApartmentState_STA) \n\t\t\t? COINIT_APARTMENTTHREADED \n\t\t\t: COINIT_MULTITHREADED) < 0) {\n\t\tthread->apartment_state = ThreadApartmentState_Unknown;\n\t}\n#endif\n}\n\nvoid \nmono_thread_cleanup_apartment_state (void)\n{\n#ifdef HOST_WIN32\n\tMonoInternalThread* thread = mono_thread_internal_current ();\n\n\tif (thread && thread->apartment_state != ThreadApartmentState_Unknown) {\n\t\tCoUninitialize ();\n\t}\n#endif\n}\n\nvoid\nmono_thread_set_state (MonoInternalThread *thread, MonoThreadState state)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\tthread->state |= state;\n\tLeaveCriticalSection (thread->synch_cs);\n}\n\nvoid\nmono_thread_clr_state (MonoInternalThread *thread, MonoThreadState state)\n{\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\tthread->state &= ~state;\n\tLeaveCriticalSection (thread->synch_cs);\n}\n\ngboolean\nmono_thread_test_state (MonoInternalThread *thread, MonoThreadState test)\n{\n\tgboolean ret = FALSE;\n\n\tensure_synch_cs_set (thread);\n\t\n\tEnterCriticalSection (thread->synch_cs);\n\n\tif ((thread->state & test) != 0) {\n\t\tret = TRUE;\n\t}\n\t\n\tLeaveCriticalSection (thread->synch_cs);\n\t\n\treturn ret;\n}\n\nstatic MonoClassField *execution_context_field;\n\nstatic MonoObject**\nget_execution_context_addr (void)\n{\n\tMonoDomain *domain = mono_domain_get ();\n\tguint32 offset;\n\n\tif (!execution_context_field) {\n\t\texecution_context_field = mono_class_get_field_from_name (mono_defaults.thread_class,\n\t\t\t\t\"_ec\");\n\t\tg_assert (execution_context_field);\n\t}\n\n\tg_assert (mono_class_try_get_vtable (domain, mono_defaults.appdomain_class));\n\n\tmono_domain_lock (domain);\n\toffset = GPOINTER_TO_UINT (g_hash_table_lookup (domain->special_static_fields, execution_context_field));\n\tmono_domain_unlock (domain);\n\tg_assert (offset);\n\n\treturn (MonoObject**) mono_get_special_static_data (offset);\n}\n\nMonoObject*\nmono_thread_get_execution_context (void)\n{\n\treturn *get_execution_context_addr ();\n}\n\nvoid\nmono_thread_set_execution_context (MonoObject *ec)\n{\n\t*get_execution_context_addr () = ec;\n}\n\nstatic gboolean has_tls_get = FALSE;\n\nvoid\nmono_runtime_set_has_tls_get (gboolean val)\n{\n\thas_tls_get = val;\n}\n\ngboolean\nmono_runtime_has_tls_get (void)\n{\n\treturn has_tls_get;\n}\n\nint\nmono_thread_kill (MonoInternalThread *thread, int signal)\n{\n#ifdef HOST_WIN32\n\t/* Win32 uses QueueUserAPC and callers of this are guarded */\n\tg_assert_not_reached ();\n#else\n#  ifdef PTHREAD_POINTER_ID\n\treturn pthread_kill ((gpointer)(gsize)(thread->tid), mono_thread_get_abort_signal ());\n#  else\n#    ifdef PLATFORM_ANDROID\n\tif (thread->android_tid != 0) {\n\t\tint  ret;\n\t\tint  old_errno = errno;\n\n\t\tret = tkill ((pid_t) thread->android_tid, signal);\n\t\tif (ret < 0) {\n\t\t\tret = errno;\n\t\t\terrno = old_errno;\n\t\t}\n\n\t\treturn ret;\n\t}\n\telse\n\t\treturn pthread_kill (thread->tid, mono_thread_get_abort_signal ());\n#    else\n\treturn pthread_kill (thread->tid, mono_thread_get_abort_signal ());\n#    endif\n#  endif\n#endif\n}\n"], "filenames": ["mono/metadata/threads.c"], "buggy_code_start_loc": [1039], "buggy_code_end_loc": [1045], "fixing_code_start_loc": [1039], "fixing_code_end_loc": [1050], "type": "CWE-399", "message": "Use-after-free vulnerability in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to cause a denial of service (plugin crash) or obtain sensitive information via vectors related to member data in a resurrected MonoThread instance.", "other": {"cve": {"id": "CVE-2011-0992", "sourceIdentifier": "cve@mitre.org", "published": "2011-04-13T21:55:00.890", "lastModified": "2017-08-17T01:33:46.197", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in Mono, when Moonlight 2.x before 2.4.1 or 3.x before 3.99.3 is used, allows remote attackers to cause a denial of service (plugin crash) or obtain sensitive information via vectors related to member data in a resurrected MonoThread instance."}, {"lang": "es", "value": "Vulnerabilidad de tipo usar despu\u00e9s de liberar en Mono, si Moonlight v2.x anteriores a 2.4.1 o 3.x anteriores a 3.99.3 es utilizado, permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda o cuelgue del plugin) u obtener informaci\u00f3n confidencial a trav\u00e9s de datos miembros de una instancia \"resurrected MonoThread\"."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mono:mono:*:*:*:*:*:*:*:*", "matchCriteriaId": "E062208D-082B-4BFD-85CA-3848ECE6F8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "711824C0-5BFC-4D3A-BAB2-84B8F20BDD7C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "C74F2C01-7E26-474A-B8CA-EFCC5C91D83D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.4:*:*:*:*:*:*:*", "matchCriteriaId": "704EB745-3307-4903-8B3B-DCC6682EE228"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:2.31:*:*:*:*:*:*:*", "matchCriteriaId": "DB7A6358-630E-43FA-B2B8-C99A8808BB09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "AADDCD5B-D116-4BFC-BD2B-4EB6F4470359"}, {"vulnerable": true, "criteria": "cpe:2.3:a:novell:moonlight:3.99:*:*:*:*:*:*:*", "matchCriteriaId": "21676825-737D-4071-A7F1-BFB6047215F1"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2011-04/msg00024.html", "source": "cve@mitre.org"}, {"url": "http://openwall.com/lists/oss-security/2011/04/06/14", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.mono-project.com/Vulnerabilities", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/47208", "source": "cve@mitre.org"}, {"url": "http://www.vupen.com/english/advisories/2011/0904", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=667077", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://bugzilla.novell.com/show_bug.cgi?id=678515", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=694933", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/66627", "source": "cve@mitre.org"}, {"url": "https://github.com/mono/mono/commit/722f9890f09aadfc37ae479e7d946d5fc5ef7b91", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/mono/mono/commit/722f9890f09aadfc37ae479e7d946d5fc5ef7b91"}}