{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     SSSSS   CCCC  RRRR   EEEEE  EEEEE  N   N  SSSSS  H   H   OOO   TTTTT    %\n%     SS     C      R   R  E      E      NN  N  SS     H   H  O   O    T      %\n%      SSS   C      RRRR   EEE    EEE    N N N   SSS   HHHHH  O   O    T      %\n%        SS  C      R R    E      E      N  NN     SS  H   H  O   O    T      %\n%     SSSSS   CCCC  R  R   EEEEE  EEEEE  N   N  SSSSS  H   H   OOO     T      %\n%                                                                             %\n%                                                                             %\n%                  Takes a screenshot from the monitor(s).                    %\n%                                                                             %\n%                              Software Design                                %\n%                                Dirk Lemstra                                 %\n%                                 April 2014                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n#  if defined(__CYGWIN__)\n#    include <windows.h>\n#  else\n     /* All MinGW needs ... */\n#    include \"MagickCore/nt-base-private.h\"\n#    include <wingdi.h>\n#  ifndef DISPLAY_DEVICE_ACTIVE\n#    define DISPLAY_DEVICE_ACTIVE    0x00000001\n#  endif\n#  endif\n#endif\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/nt-feature.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xwindow.h\"\n#include \"MagickCore/xwindow-private.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S C R E E N S H O T I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSCREENSHOTImage() Takes a screenshot from the monitor(s).\n%\n%  The format of the ReadSCREENSHOTImage method is:\n%\n%      Image *ReadXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=(Image *) NULL;\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n  {\n    BITMAPINFO\n      bmi;\n\n    DISPLAY_DEVICE\n      device;\n\n    HBITMAP\n      bitmap,\n      bitmapOld;\n\n    HDC\n      bitmapDC,\n      hDC;\n\n    Image\n      *screen;\n\n    int\n      i;\n\n    MagickBooleanType\n      status;\n\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    RGBTRIPLE\n      *p;\n\n    ssize_t\n      y;\n\n    assert(image_info != (const ImageInfo *) NULL);\n    i=0;\n    device.cb = sizeof(device);\n    image=(Image *) NULL;\n    while(EnumDisplayDevices(NULL,i,&device,0) && ++i)\n    {\n      if ((device.StateFlags & DISPLAY_DEVICE_ACTIVE) != DISPLAY_DEVICE_ACTIVE)\n        continue;\n\n      hDC=CreateDC(device.DeviceName,device.DeviceName,NULL,NULL);\n      if (hDC == (HDC) NULL)\n        ThrowReaderException(CoderError,\"UnableToCreateDC\");\n\n      screen=AcquireImage(image_info,exception);\n      screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n      screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n      screen->storage_class=DirectClass;\n      status=SetImageExtent(screen,screen->columns,screen->rows,exception);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n      if (image == (Image *) NULL)\n        image=screen;\n      else\n        AppendImageToList(&image,screen);\n\n      bitmapDC=CreateCompatibleDC(hDC);\n      if (bitmapDC == (HDC) NULL)\n        {\n          DeleteDC(hDC);\n          ThrowReaderException(CoderError,\"UnableToCreateDC\");\n        }\n      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));\n      bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n      bmi.bmiHeader.biWidth=(LONG) screen->columns;\n      bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;\n      bmi.bmiHeader.biPlanes=1;\n      bmi.bmiHeader.biBitCount=24;\n      bmi.bmiHeader.biCompression=BI_RGB;\n      bitmap=CreateDIBSection(hDC,&bmi,DIB_RGB_COLORS,(void **) &p,NULL,0);\n      if (bitmap == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      bitmapOld=(HBITMAP) SelectObject(bitmapDC,bitmap);\n      if (bitmapOld == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          DeleteObject(bitmap);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      BitBlt(bitmapDC,0,0,(int) screen->columns,(int) screen->rows,hDC,0,0,\n        SRCCOPY);\n      (void) SelectObject(bitmapDC,bitmapOld);\n\n      for (y=0; y < (ssize_t) screen->rows; y++)\n      {\n        q=QueueAuthenticPixels(screen,0,y,screen->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) screen->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(p->rgbtRed),q);\n          SetPixelGreen(image,ScaleCharToQuantum(p->rgbtGreen),q);\n          SetPixelBlue(image,ScaleCharToQuantum(p->rgbtBlue),q);\n          SetPixelAlpha(image,OpaqueAlpha,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(screen,exception) == MagickFalse)\n          break;\n      }\n\n      DeleteDC(hDC);\n      DeleteDC(bitmapDC);\n      DeleteObject(bitmap);\n    }\n  }\n#elif defined(MAGICKCORE_X11_DELEGATE)\n  {\n    const char\n      *option;\n\n    XImportInfo\n      ximage_info;\n\n    XGetImportInfo(&ximage_info);\n    option=GetImageOption(image_info,\"x:screen\");\n    if (option != (const char *) NULL)\n      ximage_info.screen=IsStringTrue(option);\n    option=GetImageOption(image_info,\"x:silent\");\n    if (option != (const char *) NULL)\n      ximage_info.silent=IsStringTrue(option);\n    image=XImportImage(image_info,&ximage_info,exception);\n  }\n#endif\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S C R E E N S H O T I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSCREENSHOTImage() adds attributes for the screen shot format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterScreenShotImage method is:\n%\n%      size_t RegisterScreenShotImage(void)\n%\n*/\nModuleExport size_t RegisterSCREENSHOTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SCREENSHOT\",\"SCREENSHOT\",\"Screen shot\");\n  entry->decoder=(DecodeImageHandler *) ReadSCREENSHOTImage;\n  entry->format_type=ImplicitFormatType;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S C R E E N S H O T I m a g e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterScreenShotImage() removes format registrations made by the\n%  screen shot module from the list of supported formats.\n%\n%  The format of the UnregisterSCREENSHOTImage method is:\n%\n%      UnregisterSCREENSHOTImage(void)\n%\n*/\nModuleExport void UnregisterSCREENSHOTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SCREENSHOT\");\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     SSSSS   CCCC  RRRR   EEEEE  EEEEE  N   N  SSSSS  H   H   OOO   TTTTT    %\n%     SS     C      R   R  E      E      NN  N  SS     H   H  O   O    T      %\n%      SSS   C      RRRR   EEE    EEE    N N N   SSS   HHHHH  O   O    T      %\n%        SS  C      R R    E      E      N  NN     SS  H   H  O   O    T      %\n%     SSSSS   CCCC  R  R   EEEEE  EEEEE  N   N  SSSSS  H   H   OOO     T      %\n%                                                                             %\n%                                                                             %\n%                  Takes a screenshot from the monitor(s).                    %\n%                                                                             %\n%                              Software Design                                %\n%                                Dirk Lemstra                                 %\n%                                 April 2014                                  %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n#  if defined(__CYGWIN__)\n#    include <windows.h>\n#  else\n     /* All MinGW needs ... */\n#    include \"MagickCore/nt-base-private.h\"\n#    include <wingdi.h>\n#  ifndef DISPLAY_DEVICE_ACTIVE\n#    define DISPLAY_DEVICE_ACTIVE    0x00000001\n#  endif\n#  endif\n#endif\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/nt-feature.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/xwindow.h\"\n#include \"MagickCore/xwindow-private.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d S C R E E N S H O T I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadSCREENSHOTImage() Takes a screenshot from the monitor(s).\n%\n%  The format of the ReadSCREENSHOTImage method is:\n%\n%      Image *ReadXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=(Image *) NULL;\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n  {\n    BITMAPINFO\n      bmi;\n\n    DISPLAY_DEVICE\n      device;\n\n    HBITMAP\n      bitmap,\n      bitmapOld;\n\n    HDC\n      bitmapDC,\n      hDC;\n\n    Image\n      *screen;\n\n    int\n      i;\n\n    MagickBooleanType\n      status;\n\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    RGBTRIPLE\n      *p;\n\n    ssize_t\n      y;\n\n    assert(image_info != (const ImageInfo *) NULL);\n    i=0;\n    device.cb = sizeof(device);\n    image=(Image *) NULL;\n    while(EnumDisplayDevices(NULL,i,&device,0) && ++i)\n    {\n      if ((device.StateFlags & DISPLAY_DEVICE_ACTIVE) != DISPLAY_DEVICE_ACTIVE)\n        continue;\n\n      hDC=CreateDC(device.DeviceName,device.DeviceName,NULL,NULL);\n      if (hDC == (HDC) NULL)\n        ThrowReaderException(CoderError,\"UnableToCreateDC\");\n\n      screen=AcquireImage(image_info,exception);\n      screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n      screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n      screen->storage_class=DirectClass;\n      if (image == (Image *) NULL)\n        image=screen;\n      else\n        AppendImageToList(&image,screen);\n      status=SetImageExtent(screen,screen->columns,screen->rows,exception);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n\n      bitmapDC=CreateCompatibleDC(hDC);\n      if (bitmapDC == (HDC) NULL)\n        {\n          DeleteDC(hDC);\n          ThrowReaderException(CoderError,\"UnableToCreateDC\");\n        }\n      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));\n      bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n      bmi.bmiHeader.biWidth=(LONG) screen->columns;\n      bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;\n      bmi.bmiHeader.biPlanes=1;\n      bmi.bmiHeader.biBitCount=24;\n      bmi.bmiHeader.biCompression=BI_RGB;\n      bitmap=CreateDIBSection(hDC,&bmi,DIB_RGB_COLORS,(void **) &p,NULL,0);\n      if (bitmap == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      bitmapOld=(HBITMAP) SelectObject(bitmapDC,bitmap);\n      if (bitmapOld == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          DeleteObject(bitmap);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      BitBlt(bitmapDC,0,0,(int) screen->columns,(int) screen->rows,hDC,0,0,\n        SRCCOPY);\n      (void) SelectObject(bitmapDC,bitmapOld);\n\n      for (y=0; y < (ssize_t) screen->rows; y++)\n      {\n        q=QueueAuthenticPixels(screen,0,y,screen->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) screen->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(p->rgbtRed),q);\n          SetPixelGreen(image,ScaleCharToQuantum(p->rgbtGreen),q);\n          SetPixelBlue(image,ScaleCharToQuantum(p->rgbtBlue),q);\n          SetPixelAlpha(image,OpaqueAlpha,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(screen,exception) == MagickFalse)\n          break;\n      }\n\n      DeleteDC(hDC);\n      DeleteDC(bitmapDC);\n      DeleteObject(bitmap);\n    }\n  }\n#elif defined(MAGICKCORE_X11_DELEGATE)\n  {\n    const char\n      *option;\n\n    XImportInfo\n      ximage_info;\n\n    XGetImportInfo(&ximage_info);\n    option=GetImageOption(image_info,\"x:screen\");\n    if (option != (const char *) NULL)\n      ximage_info.screen=IsStringTrue(option);\n    option=GetImageOption(image_info,\"x:silent\");\n    if (option != (const char *) NULL)\n      ximage_info.silent=IsStringTrue(option);\n    image=XImportImage(image_info,&ximage_info,exception);\n  }\n#endif\n  return(image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r S C R E E N S H O T I m a g e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterSCREENSHOTImage() adds attributes for the screen shot format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterScreenShotImage method is:\n%\n%      size_t RegisterScreenShotImage(void)\n%\n*/\nModuleExport size_t RegisterSCREENSHOTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"SCREENSHOT\",\"SCREENSHOT\",\"Screen shot\");\n  entry->decoder=(DecodeImageHandler *) ReadSCREENSHOTImage;\n  entry->format_type=ImplicitFormatType;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r S C R E E N S H O T I m a g e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterScreenShotImage() removes format registrations made by the\n%  screen shot module from the list of supported formats.\n%\n%  The format of the UnregisterSCREENSHOTImage method is:\n%\n%      UnregisterSCREENSHOTImage(void)\n%\n*/\nModuleExport void UnregisterSCREENSHOTImage(void)\n{\n  (void) UnregisterMagickInfo(\"SCREENSHOT\");\n}\n"], "filenames": ["coders/screenshot.c"], "buggy_code_start_loc": [170], "buggy_code_end_loc": [176], "fixing_code_start_loc": [169], "fixing_code_end_loc": [177], "type": "CWE-772", "message": "The ReadSCREENSHOTImage function in coders/screenshot.c in ImageMagick before 7.0.6-1 has memory leaks, causing denial of service.", "other": {"cve": {"id": "CVE-2017-11447", "sourceIdentifier": "cve@mitre.org", "published": "2017-07-19T07:29:00.470", "lastModified": "2020-10-14T18:16:27.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The ReadSCREENSHOTImage function in coders/screenshot.c in ImageMagick before 7.0.6-1 has memory leaks, causing denial of service."}, {"lang": "es", "value": "La funci\u00f3n ReadSCREENSHOTImage en el archivo coders/screenshot.c en ImageMagick anterior a versi\u00f3n 7.0.6-1, presenta p\u00e9rdida de memoria, causando una denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.0.6-0", "matchCriteriaId": "6DE125EC-DF93-4416-B1ED-2F0017FE7DBB"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/99948", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=867897", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/72a50e400d98d7a2fd610caedfeb9af043dc5582", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/556", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/72a50e400d98d7a2fd610caedfeb9af043dc5582"}}