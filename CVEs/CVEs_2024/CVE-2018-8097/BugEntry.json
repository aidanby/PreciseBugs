{"buggy_code": ["# -*- coding: utf-8 -*-\n\n\"\"\"\n    eve.io.mongo.parser\n    ~~~~~~~~~~~~~~~~~~~\n\n    This module implements a Python-to-Mongo syntax parser. Allows the MongoDB\n    data-layer to seamlessly respond to a Python-like query.\n\n    :copyright: (c) 2017 by Nicola Iarocci.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport ast\nimport sys\nfrom datetime import datetime   # noqa\nfrom bson import ObjectId       # noqa\n\n\ndef parse(expression):\n    \"\"\" Given a python-like conditional statement, returns the equivalent\n    mongo-like query expression. Conditional and boolean operators (==, <=, >=,\n    !=, >, <) along with a couple function calls (ObjectId(), datetime()) are\n    supported.\n    \"\"\"\n    v = MongoVisitor()\n    try:\n        v.visit(ast.parse(expression))\n    except SyntaxError as e:\n        e = ParseError(e)\n        e.__traceback__ = sys.exc_info()[2]\n        raise e\n    return v.mongo_query\n\n\nclass ParseError(ValueError):\n    pass\n\n\nclass MongoVisitor(ast.NodeVisitor):\n    \"\"\" Implements the python-to-mongo parser. Only Python conditional\n    statements are supported, however nested, combined with most common compare\n    and boolean operators (And and Or).\n\n    Supported compare operators: ==, >, <, !=, >=, <=\n    Supported boolean operators: And, Or\n    \"\"\"\n    op_mapper = {\n        ast.Eq: '',\n        ast.Gt: '$gt',\n        ast.GtE: '$gte',\n        ast.Lt: '$lt',\n        ast.LtE: '$lte',\n        ast.NotEq: '$ne',\n        ast.Or: '$or',\n        ast.And: '$and'\n    }\n\n    def visit_Module(self, node):\n        \"\"\" Module handler, our entry point.\n        \"\"\"\n        self.mongo_query = {}\n        self.ops = []\n        self.current_value = None\n\n        # perform the magic.\n        self.generic_visit(node)\n\n        # if we didn't obtain a query, it is likely that an unsupported\n        # python expression has been passed.\n        if self.mongo_query == {}:\n            raise ParseError(\"Only conditional statements with boolean \"\n                             \"(and, or) and comparison operators are \"\n                             \"supported.\")\n\n    def visit_Expr(self, node):\n        \"\"\" Make sure that we are parsing compare or boolean operators\n        \"\"\"\n        if not (isinstance(node.value, ast.Compare) or\n                isinstance(node.value, ast.BoolOp)):\n            raise ParseError(\"Will only parse conditional statements\")\n        self.generic_visit(node)\n\n    def visit_Compare(self, node):\n        \"\"\" Compare operator handler.\n        \"\"\"\n        self.visit(node.left)\n        left = self.current_value\n\n        operator = self.op_mapper[node.ops[0].__class__] if node.ops else None\n\n        if node.comparators:\n            comparator = node.comparators[0]\n            self.visit(comparator)\n\n        if operator != '':\n            value = {operator: self.current_value}\n        else:\n            value = self.current_value\n\n        if self.ops:\n            self.ops[-1].append({left: value})\n        else:\n            self.mongo_query[left] = value\n\n    def visit_BoolOp(self, node):\n        \"\"\" Boolean operator handler.\n        \"\"\"\n        op = self.op_mapper[node.op.__class__]\n        self.ops.append([])\n        for value in node.values:\n            self.visit(value)\n\n        c = self.ops.pop()\n        if self.ops:\n            self.ops[-1].append({op: c})\n        else:\n            self.mongo_query[op] = c\n\n    def visit_Call(self, node):\n        \"\"\" A couple function calls are supported: bson's ObjectId() and\n        datetime().\n        \"\"\"\n        if isinstance(node.func, ast.Name):\n            expr = None\n            if node.func.id == 'ObjectId':\n                expr = \"('\" + node.args[0].s + \"')\"\n            elif node.func.id == 'datetime':\n                values = []\n                for arg in node.args:\n                    values.append(str(arg.n))\n                expr = \"(\" + \", \".join(values) + \")\"\n            if expr:\n                self.current_value = eval(node.func.id + expr)\n\n    def visit_Attribute(self, node):\n        \"\"\" Attribute handler ('Contact.Id').\n        \"\"\"\n        self.visit(node.value)\n        self.current_value += \".\" + node.attr\n\n    def visit_Name(self, node):\n        \"\"\" Names handler.\n        \"\"\"\n        self.current_value = node.id\n\n    def visit_Num(self, node):\n        \"\"\" Numbers handler.\n        \"\"\"\n        self.current_value = node.n\n\n    def visit_Str(self, node):\n        \"\"\" Strings handler.\n        \"\"\"\n        self.current_value = node.s\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n\"\"\"\n    eve.io.mongo.parser\n    ~~~~~~~~~~~~~~~~~~~\n\n    This module implements a Python-to-Mongo syntax parser. Allows the MongoDB\n    data-layer to seamlessly respond to a Python-like query.\n\n    :copyright: (c) 2017 by Nicola Iarocci.\n    :license: BSD, see LICENSE for more details.\n\"\"\"\n\nimport ast\nimport sys\nfrom datetime import datetime   # noqa\nfrom bson import ObjectId       # noqa\n\n\ndef parse(expression):\n    \"\"\" Given a python-like conditional statement, returns the equivalent\n    mongo-like query expression. Conditional and boolean operators (==, <=, >=,\n    !=, >, <) along with a couple function calls (ObjectId(), datetime()) are\n    supported.\n    \"\"\"\n    v = MongoVisitor()\n    try:\n        v.visit(ast.parse(expression))\n    except SyntaxError as e:\n        e = ParseError(e)\n        e.__traceback__ = sys.exc_info()[2]\n        raise e\n    return v.mongo_query\n\n\nclass ParseError(ValueError):\n    pass\n\n\nclass MongoVisitor(ast.NodeVisitor):\n    \"\"\" Implements the python-to-mongo parser. Only Python conditional\n    statements are supported, however nested, combined with most common compare\n    and boolean operators (And and Or).\n\n    Supported compare operators: ==, >, <, !=, >=, <=\n    Supported boolean operators: And, Or\n    \"\"\"\n    op_mapper = {\n        ast.Eq: '',\n        ast.Gt: '$gt',\n        ast.GtE: '$gte',\n        ast.Lt: '$lt',\n        ast.LtE: '$lte',\n        ast.NotEq: '$ne',\n        ast.Or: '$or',\n        ast.And: '$and'\n    }\n\n    def visit_Module(self, node):\n        \"\"\" Module handler, our entry point.\n        \"\"\"\n        self.mongo_query = {}\n        self.ops = []\n        self.current_value = None\n\n        # perform the magic.\n        self.generic_visit(node)\n\n        # if we didn't obtain a query, it is likely that an unsupported\n        # python expression has been passed.\n        if self.mongo_query == {}:\n            raise ParseError(\"Only conditional statements with boolean \"\n                             \"(and, or) and comparison operators are \"\n                             \"supported.\")\n\n    def visit_Expr(self, node):\n        \"\"\" Make sure that we are parsing compare or boolean operators\n        \"\"\"\n        if not (isinstance(node.value, ast.Compare) or\n                isinstance(node.value, ast.BoolOp)):\n            raise ParseError(\"Will only parse conditional statements\")\n        self.generic_visit(node)\n\n    def visit_Compare(self, node):\n        \"\"\" Compare operator handler.\n        \"\"\"\n        self.visit(node.left)\n        left = self.current_value\n\n        operator = self.op_mapper[node.ops[0].__class__] if node.ops else None\n\n        if node.comparators:\n            comparator = node.comparators[0]\n            self.visit(comparator)\n\n        if operator != '':\n            value = {operator: self.current_value}\n        else:\n            value = self.current_value\n\n        if self.ops:\n            self.ops[-1].append({left: value})\n        else:\n            self.mongo_query[left] = value\n\n    def visit_BoolOp(self, node):\n        \"\"\" Boolean operator handler.\n        \"\"\"\n        op = self.op_mapper[node.op.__class__]\n        self.ops.append([])\n        for value in node.values:\n            self.visit(value)\n\n        c = self.ops.pop()\n        if self.ops:\n            self.ops[-1].append({op: c})\n        else:\n            self.mongo_query[op] = c\n\n    def visit_Call(self, node):\n        \"\"\" A couple function calls are supported: bson's ObjectId() and\n        datetime().\n        \"\"\"\n        if isinstance(node.func, ast.Name):\n            if node.func.id == 'ObjectId':\n                try:\n                    self.current_value = ObjectId(node.args[0].s)\n                except:\n                    pass\n            elif node.func.id == 'datetime':\n                values = []\n                for arg in node.args:\n                    values.append(arg.n)\n                try:\n                    self.current_value = datetime(*values)\n                except:\n                    pass\n\n    def visit_Attribute(self, node):\n        \"\"\" Attribute handler ('Contact.Id').\n        \"\"\"\n        self.visit(node.value)\n        self.current_value += \".\" + node.attr\n\n    def visit_Name(self, node):\n        \"\"\" Names handler.\n        \"\"\"\n        self.current_value = node.id\n\n    def visit_Num(self, node):\n        \"\"\" Numbers handler.\n        \"\"\"\n        self.current_value = node.n\n\n    def visit_Str(self, node):\n        \"\"\" Strings handler.\n        \"\"\"\n        self.current_value = node.s\n"], "filenames": ["eve/io/mongo/parser.py"], "buggy_code_start_loc": [125], "buggy_code_end_loc": [135], "fixing_code_start_loc": [124], "fixing_code_end_loc": [138], "type": "CWE-94", "message": "io/mongo/parser.py in Eve (aka pyeve) before 0.7.5 allows remote attackers to execute arbitrary code via Code Injection in the where parameter.", "other": {"cve": {"id": "CVE-2018-8097", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-14T12:29:00.210", "lastModified": "2018-04-10T18:46:25.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "io/mongo/parser.py in Eve (aka pyeve) before 0.7.5 allows remote attackers to execute arbitrary code via Code Injection in the where parameter."}, {"lang": "es", "value": "io/mongo/parser.py en Eve (tambi\u00e9n conocido como pyeve), en versiones anteriores a la 0.7.5, permite que atacantes remotos ejecuten c\u00f3digo arbitrario mediante inyecci\u00f3n de c\u00f3digo en el par\u00e1metro where."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python-eve:eve:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.7.5", "matchCriteriaId": "B47478CE-D9C0-44E5-9805-11A2B77F18A4"}]}]}], "references": [{"url": "https://github.com/pyeve/eve/commit/f8f7019ffdf9b4e05faf95e1f04e204aa4c91f98", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pyeve/eve/issues/1101", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyeve/eve/commit/f8f7019ffdf9b4e05faf95e1f04e204aa4c91f98"}}