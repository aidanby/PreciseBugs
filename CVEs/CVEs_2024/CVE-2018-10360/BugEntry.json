{"buggy_code": ["/*\n * Copyright (c) Christos Zoulas 2003.\n * All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: readelf.c,v 1.142 2018/05/24 18:08:01 christos Exp $\")\n#endif\n\n#ifdef BUILTIN_ELF\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"readelf.h\"\n#include \"magic.h\"\n\n#ifdef\tELFCORE\nprivate int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int *, uint16_t *);\n#endif\nprivate int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int *, uint16_t *);\nprivate int doshn(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int, int *, uint16_t *);\nprivate size_t donote(struct magic_set *, void *, size_t, size_t, int,\n    int, size_t, int *, uint16_t *, int, off_t, int, off_t);\n\n#define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n\n#define isquote(c) (strchr(\"'\\\"`\", (c)) != NULL)\n\nprivate uint16_t getu16(int, uint16_t);\nprivate uint32_t getu32(int, uint32_t);\nprivate uint64_t getu64(int, uint64_t);\n\n#define MAX_PHNUM\t128\n#define\tMAX_SHNUM\t32768\n#define SIZE_UNKNOWN\tCAST(off_t, -1)\n\nprivate int\ntoomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s (%u)\", name, num) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nprivate uint16_t\ngetu16(int swap, uint16_t value)\n{\n\tunion {\n\t\tuint16_t ui;\n\t\tchar c[2];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[1];\n\t\tretval.c[1] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint32_t\ngetu32(int swap, uint32_t value)\n{\n\tunion {\n\t\tuint32_t ui;\n\t\tchar c[4];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[3];\n\t\tretval.c[1] = tmpval.c[2];\n\t\tretval.c[2] = tmpval.c[1];\n\t\tretval.c[3] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint64_t\ngetu64(int swap, uint64_t value)\n{\n\tunion {\n\t\tuint64_t ui;\n\t\tchar c[8];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[7];\n\t\tretval.c[1] = tmpval.c[6];\n\t\tretval.c[2] = tmpval.c[5];\n\t\tretval.c[3] = tmpval.c[4];\n\t\tretval.c[4] = tmpval.c[3];\n\t\tretval.c[5] = tmpval.c[2];\n\t\tretval.c[6] = tmpval.c[1];\n\t\tretval.c[7] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\n#define elf_getu16(swap, value) getu16(swap, value)\n#define elf_getu32(swap, value) getu32(swap, value)\n#define elf_getu64(swap, value) getu64(swap, value)\n\n#define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &sh32)\t\t\t\\\n\t\t\t : CAST(void *, &sh64))\n#define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(sh32)\t\t\t\t\\\n\t\t\t : sizeof(sh64))\n#define xsh_size\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_size)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_size)))\n#define xsh_offset\tCAST(off_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_offset)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_offset)))\n#define xsh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_type)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_type))\n#define xsh_name    \t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_name)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_name))\n\n#define xph_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &ph32)\t\t\t\\\n\t\t\t : CAST(void *, &ph64))\n#define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(ph32)\t\t\t\t\\\n\t\t\t : sizeof(ph64))\n#define xph_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_type)\t\\\n\t\t\t : elf_getu32(swap, ph64.p_type))\n#define xph_offset\tCAST(off_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_offset)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_offset)))\n#define xph_align\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? CAST(off_t, (ph32.p_align ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_align) : 4))\\\n\t\t\t : CAST(off_t, (ph64.p_align ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_align) : 4))))\n#define xph_vaddr\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? CAST(off_t, (ph32.p_vaddr ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_vaddr) : 4))\\\n\t\t\t : CAST(off_t, (ph64.p_vaddr ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_vaddr) : 4))))\n#define xph_filesz\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_filesz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_filesz)))\n#define xph_memsz\tCAST(size_t, ((clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_memsz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_memsz))))\n#define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &nh32)\t\t\t\\\n\t\t\t : CAST(void *, &nh64))\n#define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(nh32)\t\t\t\t\\\n\t\t\t : sizeof(nh64))\n#define xnh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_type)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_type))\n#define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_namesz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_namesz))\n#define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_descsz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_descsz))\n\n#define xdh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &dh32)\t\t\t\\\n\t\t\t : CAST(void *, &dh64))\n#define xdh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(dh32)\t\t\t\t\\\n\t\t\t : sizeof(dh64))\n#define xdh_tag\t\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, dh32.d_tag)\t\t\\\n\t\t\t : elf_getu64(swap, dh64.d_tag))\n#define xdh_val\t\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, dh32.d_un.d_val)\t\\\n\t\t\t : elf_getu64(swap, dh64.d_un.d_val))\n\n#define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &cap32)\t\t\t\\\n\t\t\t : CAST(void *, &cap64))\n#define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(cap32)\t\t\t\\\n\t\t\t : sizeof(cap64))\n#define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_tag))\n#define xcap_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_un.c_val))\n\n#define xauxv_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &auxv32)\t\t\\\n\t\t\t : CAST(void *, &auxv64))\n#define xauxv_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(auxv32)\t\t\t\\\n\t\t\t : sizeof(auxv64))\n#define xauxv_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_type)\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_type))\n#define xauxv_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_v)\t\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_v))\n\n#define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? prpsoffsets32[i]\t\t\t\\\n\t\t\t : prpsoffsets64[i])\n\n#ifdef ELFCORE\n/*\n * Try larger offsets first to avoid false matches\n * from earlier data that happen to look like strings.\n */\nstatic const size_t\tprpsoffsets32[] = {\n#ifdef USE_NT_PSINFO\n\t104,\t\t/* SunOS 5.x (command line) */\n\t88,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t100,\t\t/* SunOS 5.x (command line) */\n\t84,\t\t/* SunOS 5.x (short name) */\n\n\t44,\t\t/* Linux (command line) */\n\t28,\t\t/* Linux 2.0.36 (short name) */\n\n\t8,\t\t/* FreeBSD */\n};\n\nstatic const size_t\tprpsoffsets64[] = {\n#ifdef USE_NT_PSINFO\n\t152,\t\t/* SunOS 5.x (command line) */\n\t136,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t136,\t\t/* SunOS 5.x, 64-bit (command line) */\n\t120,\t\t/* SunOS 5.x, 64-bit (short name) */\n\n\t56,\t\t/* Linux (command line) */\n\t40,             /* Linux (tested on core from 2.4.x, short name) */\n\n\t16,\t\t/* FreeBSD, 64-bit */\n};\n\n#define\tNOFFSETS32\t(sizeof(prpsoffsets32) / sizeof(prpsoffsets32[0]))\n#define NOFFSETS64\t(sizeof(prpsoffsets64) / sizeof(prpsoffsets64[0]))\n\n#define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_NOTE section of type NT_PRPSINFO, with a name \"CORE\" or\n * \"FreeBSD\"; if one is found, try looking in various places in its\n * contents for a 16-character string containing only printable\n * characters - if found, that string should be the name of the program\n * that dropped core.  Note: right after that 16-character string is,\n * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and\n * Linux, a longer string (80 characters, in 5.x, probably other\n * SVR4-flavored systems, and Linux) containing the start of the\n * command line for that program.\n *\n * SunOS 5.x core files contain two PT_NOTE sections, with the types\n * NT_PRPSINFO (old) and NT_PSINFO (new).  These structs contain the\n * same info about the command name and command line, so it probably\n * isn't worthwhile to look for NT_PSINFO, but the offsets are provided\n * above (see USE_NT_PSINFO), in case we ever decide to do so.  The\n * NT_PRPSINFO and NT_PSINFO sections are always in order and adjacent;\n * the SunOS 5.x file command relies on this (and prefers the latter).\n *\n * The signal number probably appears in a section of type NT_PRSTATUS,\n * but that's also rather OS-dependent, in ways that are harder to\n * dissect with heuristics, so I'm not bothering with the signal number.\n * (I suppose the signal number could be of interest in situations where\n * you don't have the binary of the program that dropped core; if you\n * *do* have that binary, the debugger will probably tell you what\n * signal it was.)\n */\n\n#define\tOS_STYLE_SVR4\t\t0\n#define\tOS_STYLE_FREEBSD\t1\n#define\tOS_STYLE_NETBSD\t\t2\n\nprivate const char os_style_names[][8] = {\n\t\"SVR4\",\n\t\"FreeBSD\",\n\t\"NetBSD\",\n};\n\n#define FLAGS_CORE_STYLE\t\t0x0003\n\n#define FLAGS_DID_CORE\t\t\t0x0004\n#define FLAGS_DID_OS_NOTE\t\t0x0008\n#define FLAGS_DID_BUILD_ID\t\t0x0010\n#define FLAGS_DID_CORE_STYLE\t\t0x0020\n#define FLAGS_DID_NETBSD_PAX\t\t0x0040\n#define FLAGS_DID_NETBSD_MARCH\t\t0x0080\n#define FLAGS_DID_NETBSD_CMODEL\t\t0x0100\n#define FLAGS_DID_NETBSD_EMULATION\t0x0200\n#define FLAGS_DID_NETBSD_UNKNOWN\t0x0400\n#define FLAGS_IS_CORE\t\t\t0x0800\n#define FLAGS_DID_AUXV\t\t\t0x1000\n\nprivate int\ndophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\toff_t ph_off = off;\n\tint ph_num = num;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop through all the program headers.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) <\n\t\t    CAST(ssize_t, xph_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t * in the section.\n\t\t */\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags, notecount, fd, ph_off,\n\t\t\t    ph_num, fsize);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void\ndo_note_netbsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\tmemcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\n\tif (file_printf(ms, \", for NetBSD\") == -1)\n\t\treturn;\n\t/*\n\t * The version number used to be stuck as 199905, and was thus\n\t * basically content-free.  Newer versions of NetBSD have fixed\n\t * this and now use the encoding of __NetBSD_Version__:\n\t *\n\t *\tMMmmrrpp00\n\t *\n\t * M = major version\n\t * m = minor version\n\t * r = release [\"\",A-Z,Z[A-Z] but numeric]\n\t * p = patchlevel\n\t */\n\tif (desc > 100000000U) {\n\t\tuint32_t ver_patch = (desc / 100) % 100;\n\t\tuint32_t ver_rel = (desc / 10000) % 100;\n\t\tuint32_t ver_min = (desc / 1000000) % 100;\n\t\tuint32_t ver_maj = desc / 100000000;\n\n\t\tif (file_printf(ms, \" %u.%u\", ver_maj, ver_min) == -1)\n\t\t\treturn;\n\t\tif (ver_rel == 0 && ver_patch != 0) {\n\t\t\tif (file_printf(ms, \".%u\", ver_patch) == -1)\n\t\t\t\treturn;\n\t\t} else if (ver_rel != 0) {\n\t\t\twhile (ver_rel > 26) {\n\t\t\t\tif (file_printf(ms, \"Z\") == -1)\n\t\t\t\t\treturn;\n\t\t\t\tver_rel -= 26;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%c\", 'A' + ver_rel - 1)\n\t\t\t    == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\ndo_note_freebsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\n\tmemcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\tif (file_printf(ms, \", for FreeBSD\") == -1)\n\t\treturn;\n\n\t/*\n\t * Contents is __FreeBSD_version, whose relation to OS\n\t * versions is defined by a huge table in the Porter's\n\t * Handbook.  This is the general scheme:\n\t * \n\t * Releases:\n\t * \tMmp000 (before 4.10)\n\t * \tMmi0p0 (before 5.0)\n\t * \tMmm0p0\n\t * \n\t * Development branches:\n\t * \tMmpxxx (before 4.6)\n\t * \tMmp1xx (before 4.10)\n\t * \tMmi1xx (before 5.0)\n\t * \tM000xx (pre-M.0)\n\t * \tMmm1xx\n\t * \n\t * M = major version\n\t * m = minor version\n\t * i = minor version increment (491000 -> 4.10)\n\t * p = patchlevel\n\t * x = revision\n\t * \n\t * The first release of FreeBSD to use ELF by default\n\t * was version 3.0.\n\t */\n\tif (desc == 460002) {\n\t\tif (file_printf(ms, \" 4.6.2\") == -1)\n\t\t\treturn;\n\t} else if (desc < 460100) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 1000 % 10 > 0)\n\t\t\tif (file_printf(ms, \".%d\", desc / 1000 % 10) == -1)\n\t\t\t\treturn;\n\t\tif ((desc % 1000 > 0) || (desc % 100000 == 0))\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t} else if (desc < 500000) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10 + desc / 1000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 100 % 10 > 0) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 1000 % 100) == -1)\n\t\t\treturn;\n\t\tif ((desc / 100 % 10 > 0) ||\n\t\t    (desc % 100000 / 100 == 0)) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nprivate int\n/*ARGSUSED*/\ndo_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\tmemcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 2) {\n\t    *flags |= FLAGS_DID_OS_NOTE;\n\t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n\t    return 1;\n\t}\n\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 16) {\n\t\tuint32_t desc[4];\n\t\tmemcpy(desc, &nbuf[doff], sizeof(desc));\n\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for GNU/\") == -1)\n\t\t\treturn 1;\n\t\tswitch (elf_getu32(swap, desc[0])) {\n\t\tcase GNU_OS_LINUX:\n\t\t\tif (file_printf(ms, \"Linux\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_HURD:\n\t\t\tif (file_printf(ms, \"Hurd\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_SOLARIS:\n\t\t\tif (file_printf(ms, \"Solaris\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KFREEBSD:\n\t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KNETBSD:\n\t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n\t\t\t\treturn 1; \n\t\t}\n\t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n\t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t    \tif (type == NT_NETBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n\t    \tif (type == NT_FREEBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n\t    type == NT_OPENBSD_VERSION && descsz == 4) {\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n\t\t\treturn 1;\n\t\t/* Content of note is always 0 */\n\t\treturn 1;\n\t}\n\n\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n\t    type == NT_DRAGONFLY_VERSION && descsz == 4) {\n\t\tuint32_t desc;\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n\t\t\treturn 1;\n\t\tmemcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10, desc % 10000) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n\t    type == NT_NETBSD_PAX && descsz == 4) {\n\t\tstatic const char *pax[] = {\n\t\t    \"+mprotect\",\n\t\t    \"-mprotect\",\n\t\t    \"+segvguard\",\n\t\t    \"-segvguard\",\n\t\t    \"+ASLR\",\n\t\t    \"-ASLR\",\n\t\t};\n\t\tuint32_t desc;\n\t\tsize_t i;\n\t\tint did = 0;\n\n\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n\t\tmemcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\n\t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n\t\t\treturn 1;\n\n\t\tfor (i = 0; i < __arraycount(pax); i++) {\n\t\t\tif (((1 << (int)i) & desc) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n\t\t\t    pax[i]) == -1)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\t/*\n\t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n\t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tchar sbuf[512];\n\t\t\tstruct NetBSD_elfcore_procinfo pi;\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tsize_t i, j;\n\t\t\tunsigned char c;\n\t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Try next offsets, in case this match is\n\t\t\t\t * in the middle of a string.\n\t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}\n\nprivate off_t\nget_offset_from_virtaddr(struct magic_set *ms, int swap, int clazz, int fd,\n    off_t off, int num, off_t fsize, uint64_t virtaddr)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\n\t/*\n\t * Loop through all the program headers and find the header with\n\t * virtual address in which the \"virtaddr\" belongs to.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += xph_sizeof;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (virtaddr >= xph_vaddr && virtaddr < xph_vaddr + xph_filesz)\n\t\t\treturn xph_offset + (virtaddr - xph_vaddr);\n\t}\n\treturn 0;\n}\n\nprivate size_t\nget_string_on_virtaddr(struct magic_set *ms,\n    int swap, int clazz, int fd, off_t ph_off, int ph_num,\n    off_t fsize, uint64_t virtaddr, char *buf, ssize_t buflen)\n{\n\tchar *bptr;\n\toff_t offset;\n\n\tif (buflen == 0)\n\t\treturn 0;\n\n\toffset = get_offset_from_virtaddr(ms, swap, clazz, fd, ph_off, ph_num,\n\t    fsize, virtaddr);\n\tif ((buflen = pread(fd, buf, CAST(size_t, buflen), offset)) <= 0) {\n\t\tfile_badread(ms);\n\t\treturn 0;\n\t}\n\n\tbuf[buflen - 1] = '\\0';\n\n\t/* We expect only printable characters, so return if buffer contains\n\t * non-printable character before the '\\0' or just '\\0'. */\n\tfor (bptr = buf; *bptr && isprint((unsigned char)*bptr); bptr++)\n\t\tcontinue;\n\tif (*bptr != '\\0')\n\t\treturn 0;\n\n\treturn bptr - buf;\n}\n\n\n/*ARGSUSED*/\nprivate int\ndo_auxv_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz __attribute__((__unused__)),\n    uint32_t descsz __attribute__((__unused__)),\n    size_t noff __attribute__((__unused__)), size_t doff,\n    int *flags, size_t size __attribute__((__unused__)), int clazz,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n#ifdef ELFCORE\n\tAux32Info auxv32;\n\tAux64Info auxv64;\n\tsize_t elsize = xauxv_sizeof;\n\tconst char *tag;\n\tint is_string;\n\tsize_t nval;\n\n\tif ((*flags & (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE)) !=\n\t    (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE))\n\t\treturn 0;\n\n\tswitch (*flags & FLAGS_CORE_STYLE) {\n\tcase OS_STYLE_SVR4:\n\t\tif (type != NT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#ifdef notyet\n\tcase OS_STYLE_NETBSD:\n\t\tif (type != NT_NETBSD_CORE_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase OS_STYLE_FREEBSD:\n\t\tif (type != NT_FREEBSD_PROCSTAT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t*flags |= FLAGS_DID_AUXV;\n\n\tnval = 0;\n\tfor (size_t off = 0; off + elsize <= descsz; off += elsize) {\n\t\tmemcpy(xauxv_addr, &nbuf[doff + off], xauxv_sizeof);\n\t\t/* Limit processing to 50 vector entries to prevent DoS */\n\t\tif (nval++ >= 50) {\n\t\t\tfile_error(ms, 0, \"Too many ELF Auxv elements\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tswitch(xauxv_type) {\n\t\tcase AT_LINUX_EXECFN:\n\t\t\tis_string = 1;\n\t\t\ttag = \"execfn\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_PLATFORM:\n\t\t\tis_string = 1;\n\t\t\ttag = \"platform\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_UID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_GID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real gid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EUID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EGID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective gid\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tis_string = 0;\n\t\t\ttag = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tag == NULL)\n\t\t\tcontinue;\n\n\t\tif (is_string) {\n\t\t\tchar buf[256];\n\t\t\tssize_t buflen;\n\t\t\tbuflen = get_string_on_virtaddr(ms, swap, clazz, fd,\n\t\t\t    ph_off, ph_num, fsize, xauxv_val, buf, sizeof(buf));\n\n\t\t\tif (buflen == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (file_printf(ms, \", %s: '%s'\", tag, buf) == -1)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (file_printf(ms, \", %s: %d\", tag, (int) xauxv_val)\n\t\t\t    == -1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nprivate size_t\ndodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\n\tif (xdh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xdh_sizeof + offset;\n\t}\n\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val == DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}\n\n\nprivate size_t\ndonote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags, uint16_t *notecount,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\n\tif (*notecount == 0)\n\t\treturn 0;\n\t--*notecount;\n\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\n\tmemcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif (namesz & 0x80000000) {\n\t    file_printf(ms, \", bad note name size %#lx\",\n\t\tCAST(unsigned long, namesz));\n\t    return 0;\n\t}\n\n\tif (descsz & 0x80000000) {\n\t    file_printf(ms, \", bad note description size %#lx\",\n\t\tCAST(unsigned long, descsz));\n\t    return 0;\n\t}\n\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\n\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\t\t\n\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_CORE) == 0) {\n\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_AUXV) == 0) {\n\t\tif (do_auxv_note(ms, nbuf, xnh_type, swap,\n\t\t\tnamesz, descsz, noff, doff, flags, size, clazz,\n\t\t\tfd, ph_off, ph_num, fsize))\n\t\t\treturn offset;\n\t}\n\n\tif (namesz == 7 && strcmp(CAST(char *, &nbuf[noff]), \"NetBSD\") == 0) {\n\t\tint descw, flag;\n\t\tconst char *str, *tag;\n\t\tif (descsz > 100)\n\t\t\tdescsz = 100;\n\t\tswitch (xnh_type) {\n\t    \tcase NT_NETBSD_VERSION:\n\t\t\treturn offset;\n\t\tcase NT_NETBSD_MARCH:\n\t\t\tflag = FLAGS_DID_NETBSD_MARCH;\n\t\t\ttag = \"compiled for\";\n\t\t\tbreak;\n\t\tcase NT_NETBSD_CMODEL:\n\t\t\tflag = FLAGS_DID_NETBSD_CMODEL;\n\t\t\ttag = \"compiler model\";\n\t\t\tbreak;\n\t\tcase NT_NETBSD_EMULATION:\n\t\t\tflag = FLAGS_DID_NETBSD_EMULATION;\n\t\t\ttag = \"emulation:\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n\t\t\t\treturn offset;\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (*flags & flag)\n\t\t\treturn offset;\n\t\tstr = CAST(const char *, &nbuf[doff]);\n\t\tdescw = CAST(int, descsz);\n\t\t*flags |= flag;\n\t\tfile_printf(ms, \", %s: %.*s\", tag, descw, str);\n\t\treturn offset;\n\t}\n\n\treturn offset;\n}\n\n/* SunOS 5.x hardware capability descriptions */\ntypedef struct cap_desc {\n\tuint64_t cd_mask;\n\tconst char *cd_name;\n} cap_desc_t;\n\nstatic const cap_desc_t cap_desc_sparc[] = {\n\t{ AV_SPARC_MUL32,\t\t\"MUL32\" },\n\t{ AV_SPARC_DIV32,\t\t\"DIV32\" },\n\t{ AV_SPARC_FSMULD,\t\t\"FSMULD\" },\n\t{ AV_SPARC_V8PLUS,\t\t\"V8PLUS\" },\n\t{ AV_SPARC_POPC,\t\t\"POPC\" },\n\t{ AV_SPARC_VIS,\t\t\t\"VIS\" },\n\t{ AV_SPARC_VIS2,\t\t\"VIS2\" },\n\t{ AV_SPARC_ASI_BLK_INIT,\t\"ASI_BLK_INIT\" },\n\t{ AV_SPARC_FMAF,\t\t\"FMAF\" },\n\t{ AV_SPARC_FJFMAU,\t\t\"FJFMAU\" },\n\t{ AV_SPARC_IMA,\t\t\t\"IMA\" },\n\t{ 0, NULL }\n};\n\nstatic const cap_desc_t cap_desc_386[] = {\n\t{ AV_386_FPU,\t\t\t\"FPU\" },\n\t{ AV_386_TSC,\t\t\t\"TSC\" },\n\t{ AV_386_CX8,\t\t\t\"CX8\" },\n\t{ AV_386_SEP,\t\t\t\"SEP\" },\n\t{ AV_386_AMD_SYSC,\t\t\"AMD_SYSC\" },\n\t{ AV_386_CMOV,\t\t\t\"CMOV\" },\n\t{ AV_386_MMX,\t\t\t\"MMX\" },\n\t{ AV_386_AMD_MMX,\t\t\"AMD_MMX\" },\n\t{ AV_386_AMD_3DNow,\t\t\"AMD_3DNow\" },\n\t{ AV_386_AMD_3DNowx,\t\t\"AMD_3DNowx\" },\n\t{ AV_386_FXSR,\t\t\t\"FXSR\" },\n\t{ AV_386_SSE,\t\t\t\"SSE\" },\n\t{ AV_386_SSE2,\t\t\t\"SSE2\" },\n\t{ AV_386_PAUSE,\t\t\t\"PAUSE\" },\n\t{ AV_386_SSE3,\t\t\t\"SSE3\" },\n\t{ AV_386_MON,\t\t\t\"MON\" },\n\t{ AV_386_CX16,\t\t\t\"CX16\" },\n\t{ AV_386_AHF,\t\t\t\"AHF\" },\n\t{ AV_386_TSCP,\t\t\t\"TSCP\" },\n\t{ AV_386_AMD_SSE4A,\t\t\"AMD_SSE4A\" },\n\t{ AV_386_POPCNT,\t\t\"POPCNT\" },\n\t{ AV_386_AMD_LZCNT,\t\t\"AMD_LZCNT\" },\n\t{ AV_386_SSSE3,\t\t\t\"SSSE3\" },\n\t{ AV_386_SSE4_1,\t\t\"SSE4.1\" },\n\t{ AV_386_SSE4_2,\t\t\"SSE4.2\" },\n\t{ 0, NULL }\n};\n\nprivate int\ndoshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n    size_t size, off_t fsize, int mach, int strtab, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Shdr sh32;\n\tElf64_Shdr sh64;\n\tint stripped = 1, has_debug_info = 0;\n\tsize_t nbadcap = 0;\n\tvoid *nbuf;\n\toff_t noff, coff, name_off;\n\tuint64_t cap_hw1 = 0;\t/* SunOS 5.x hardware capabilities */\n\tuint64_t cap_sf1 = 0;\t/* SunOS 5.x software capabilities */\n\tchar name[50];\n\tssize_t namesize;\n\n\tif (size != xsh_sizeof) {\n\t\tif (file_printf(ms, \", corrupted section header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* Read offset of name section to be able to read section names later */\n\tif (pread(fd, xsh_addr, xsh_sizeof, CAST(off_t, (off + size * strtab)))\n\t    < CAST(ssize_t, xsh_sizeof)) {\n\t\tif (file_printf(ms, \", missing section headers\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tname_off = xsh_offset;\n\n\tfor ( ; num; num--) {\n\t\t/* Read the name of this section. */\n\t\tif ((namesize = pread(fd, name, sizeof(name) - 1,\n\t\t    name_off + xsh_name)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tname[namesize] = '\\0';\n\t\tif (strcmp(name, \".debug_info\") == 0) {\n\t\t\thas_debug_info = 1;\n\t\t\tstripped = 0;\n\t\t}\n\n\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) <\n\t\t    CAST(ssize_t, xsh_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_SYMTAB:\n#if 0\n\t\tcase SHT_DYNSYM:\n#endif\n\t\t\tstripped = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xsh_offset > fsize) {\n\t\t\t\t/* Perhaps warn here */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_NOTE:\n\t\t\tif (CAST(uintmax_t, (xsh_size + xsh_offset)) >\n\t\t\t    CAST(uintmax_t, fsize)) {\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \", note offset/size %#\" INTMAX_T_FORMAT\n\t\t\t\t    \"x+%#\" INTMAX_T_FORMAT \"x exceeds\"\n\t\t\t\t    \" file size %#\" INTMAX_T_FORMAT \"x\",\n\t\t\t\t    CAST(uintmax_t, xsh_offset),\n\t\t\t\t    CAST(uintmax_t, xsh_size),\n\t\t\t\t    CAST(uintmax_t, fsize)) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0; \n\t\t\t}\n\t\t\tif ((nbuf = malloc(xsh_size)) == NULL) {\n\t\t\t\tfile_error(ms, errno, \"Cannot allocate memory\"\n\t\t\t\t    \" for note\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) <\n\t\t\t    CAST(ssize_t, xsh_size)) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\tfree(nbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (noff >= CAST(off_t, xsh_size))\n\t\t\t\t\tbreak;\n\t\t\t\tnoff = donote(ms, nbuf, CAST(size_t, noff),\n\t\t\t\t    xsh_size, clazz, swap, 4, flags, notecount,\n\t\t\t\t    fd, 0, 0, 0);\n\t\t\t\tif (noff == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(nbuf);\n\t\t\tbreak;\n\t\tcase SHT_SUNW_cap:\n\t\t\tswitch (mach) {\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_IA_64:\n\t\t\tcase EM_386:\n\t\t\tcase EM_AMD64:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tif (nbadcap > 5)\n\t\t\t\tbreak;\n\t\t\tif (lseek(fd, xsh_offset, SEEK_SET)\n\t\t\t    == CAST(off_t, -1)) {\n\t\t\t\tfile_badseek(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tElf32_Cap cap32;\n\t\t\t\tElf64_Cap cap64;\n\t\t\t\tchar cbuf[/*CONSTCOND*/\n\t\t\t\t    MAX(sizeof(cap32), sizeof(cap64))];\n\t\t\t\tif ((coff += xcap_sizeof) >\n\t\t\t\t    CAST(off_t, xsh_size))\n\t\t\t\t\tbreak;\n\t\t\t\tif (read(fd, cbuf, CAST(size_t, xcap_sizeof)) !=\n\t\t\t\t    CAST(ssize_t, xcap_sizeof)) {\n\t\t\t\t\tfile_badread(ms);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (cbuf[0] == 'A') {\n#ifdef notyet\n\t\t\t\t\tchar *p = cbuf + 1;\n\t\t\t\t\tuint32_t len, tag;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (memcmp(\"gnu\", p, 3) != 0) {\n\t\t\t\t\t    if (file_printf(ms,\n\t\t\t\t\t\t\", unknown capability %.3s\", p)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tp += strlen(p) + 1;\n\t\t\t\t\ttag = *p++;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (tag != 1) {\n\t\t\t\t\t    if (file_printf(ms, \", unknown gnu\"\n\t\t\t\t\t\t\" capability tag %d\", tag)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\t// gnu attributes \n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmemcpy(xcap_addr, cbuf, xcap_sizeof);\n\t\t\t\tswitch (xcap_tag) {\n\t\t\t\tcase CA_SUNW_NULL:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_HW_1:\n\t\t\t\t\tcap_hw1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_SF_1:\n\t\t\t\t\tcap_sf1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \", with unknown capability \"\n\t\t\t\t\t    \"%#\" INT64_T_FORMAT \"x = %#\"\n\t\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t\t    CAST(unsigned long long, xcap_tag),\n\t\t\t\t\t    CAST(unsigned long long, xcap_val))\n\t\t\t\t\t    == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tif (nbadcap++ > 2)\n\t\t\t\t\t\tcoff = xsh_size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tskip:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_debug_info) {\n\t\tif (file_printf(ms, \", with debug_info\") == -1)\n\t\t\treturn -1;\n\t}\n\tif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\n\t\treturn -1;\n\tif (cap_hw1) {\n\t\tconst cap_desc_t *cdp;\n\t\tswitch (mach) {\n\t\tcase EM_SPARC:\n\t\tcase EM_SPARC32PLUS:\n\t\tcase EM_SPARCV9:\n\t\t\tcdp = cap_desc_sparc;\n\t\t\tbreak;\n\t\tcase EM_386:\n\t\tcase EM_IA_64:\n\t\tcase EM_AMD64:\n\t\t\tcdp = cap_desc_386;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcdp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (file_printf(ms, \", uses\") == -1)\n\t\t\treturn -1;\n\t\tif (cdp) {\n\t\t\twhile (cdp->cd_name) {\n\t\t\t\tif (cap_hw1 & cdp->cd_mask) {\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \" %s\", cdp->cd_name) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;\n\t\t\t\t}\n\t\t\t\t++cdp;\n\t\t\t}\n\t\t\tif (cap_hw1)\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \" unknown hardware capability %#\"\n\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t    CAST(unsigned long long, cap_hw1)) == -1)\n\t\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (file_printf(ms,\n\t\t\t    \" hardware capability %#\" INT64_T_FORMAT \"x\",\n\t\t\t    CAST(unsigned long long, cap_hw1)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (cap_sf1) {\n\t\tif (cap_sf1 & SF1_SUNW_FPUSED) {\n\t\t\tif (file_printf(ms,\n\t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)\n\t\t\t    ? \", uses frame pointer\"\n\t\t\t    : \", not known to use frame pointer\") == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tcap_sf1 &= ~SF1_SUNW_MASK;\n\t\tif (cap_sf1)\n\t\t\tif (file_printf(ms,\n\t\t\t    \", with unknown software capability %#\"\n\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t    CAST(unsigned long long, cap_sf1)) == -1)\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_INTERP section; if one is found, it's dynamically linked,\n * otherwise it's statically linked.\n */\nprivate int\ndophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int sh_num, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tchar interp[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tinterp[0] = '\\0';\n  \tfor ( ; num; num--) {\n\t\tint doread;\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < \n\t\t    CAST(ssize_t, xph_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tdoread = 1;\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment %#lx\",\n\t\t\t\t    CAST(unsigned long, align)) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tdoread = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdoread = 0;\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (doread) {\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else\n\t\t\tlen = 0;\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = dodynamic(ms, nbuf, offset,\n\t\t\t\t    CAST(size_t, bufsize), clazz, swap);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tmemcpy(interp, nbuf, bufsize);\n\t\t\t} else\n\t\t\t\tstrlcpy(interp, \"*empty*\", sizeof(interp));\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    CAST(size_t, bufsize), clazz, swap, align,\n\t\t\t\t    flags, notecount, fd, 0, 0, 0);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}\n\n\nprotected int\nfile_tryelf(struct magic_set *ms, const struct buffer *b)\n{\n\tint fd = b->fd;\n\tconst unsigned char *buf = b->fbuf;\n\tsize_t nbytes = b->flen;\n\tunion {\n\t\tint32_t l;\n\t\tchar c[sizeof(int32_t)];\n\t} u;\n\tint clazz;\n\tint swap;\n\tstruct stat st;\n\toff_t fsize;\n\tint flags = 0;\n\tElf32_Ehdr elf32hdr;\n\tElf64_Ehdr elf64hdr;\n\tuint16_t type, phnum, shnum, notecount;\n\n\tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE|MAGIC_EXTENSION))\n\t\treturn 0;\n\t/*\n\t * ELF executables have multiple section headers in arbitrary\n\t * file locations and thus file(1) cannot determine it from easily.\n\t * Instead we traverse thru all section headers until a symbol table\n\t * one is found or else the binary is stripped.\n\t * Return immediately if it's not ELF (so we avoid pipe2file unless needed).\n\t */\n\tif (buf[EI_MAG0] != ELFMAG0\n\t    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)\n\t    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)\n\t\treturn 0;\n\n\t/*\n\t * If we cannot seek, it must be a pipe, socket or fifo.\n\t */\n\tif((lseek(fd, CAST(off_t, 0), SEEK_SET) == CAST(off_t, -1))\n\t    && (errno == ESPIPE))\n\t\tfd = file_pipe2file(ms, fd, buf, nbytes);\n\n\tif (fstat(fd, &st) == -1) {\n  \t\tfile_badread(ms);\n\t\treturn -1;\n\t}\n\tif (S_ISREG(st.st_mode) || st.st_size != 0)\n\t\tfsize = st.st_size;\n\telse\n\t\tfsize = SIZE_UNKNOWN;\n\n\tclazz = buf[EI_CLASS];\n\n\tswitch (clazz) {\n\tcase ELFCLASS32:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu32(a, b)\n#undef elfhdr\n#define elfhdr elf32hdr\n#include \"elfclass.h\"\n\tcase ELFCLASS64:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu64(a, b)\n#undef elfhdr\n#define elfhdr elf64hdr\n#include \"elfclass.h\"\n\tdefault:\n\t    if (file_printf(ms, \", unknown class %d\", clazz) == -1)\n\t\t    return -1;\n\t    break;\n\t}\n\treturn 0;\n}\n#endif\n"], "fixing_code": ["/*\n * Copyright (c) Christos Zoulas 2003.\n * All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: readelf.c,v 1.143 2018/06/09 16:00:06 christos Exp $\")\n#endif\n\n#ifdef BUILTIN_ELF\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"readelf.h\"\n#include \"magic.h\"\n\n#ifdef\tELFCORE\nprivate int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int *, uint16_t *);\n#endif\nprivate int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int *, uint16_t *);\nprivate int doshn(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int, int *, uint16_t *);\nprivate size_t donote(struct magic_set *, void *, size_t, size_t, int,\n    int, size_t, int *, uint16_t *, int, off_t, int, off_t);\n\n#define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n\n#define isquote(c) (strchr(\"'\\\"`\", (c)) != NULL)\n\nprivate uint16_t getu16(int, uint16_t);\nprivate uint32_t getu32(int, uint32_t);\nprivate uint64_t getu64(int, uint64_t);\n\n#define MAX_PHNUM\t128\n#define\tMAX_SHNUM\t32768\n#define SIZE_UNKNOWN\tCAST(off_t, -1)\n\nprivate int\ntoomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s (%u)\", name, num) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nprivate uint16_t\ngetu16(int swap, uint16_t value)\n{\n\tunion {\n\t\tuint16_t ui;\n\t\tchar c[2];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[1];\n\t\tretval.c[1] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint32_t\ngetu32(int swap, uint32_t value)\n{\n\tunion {\n\t\tuint32_t ui;\n\t\tchar c[4];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[3];\n\t\tretval.c[1] = tmpval.c[2];\n\t\tretval.c[2] = tmpval.c[1];\n\t\tretval.c[3] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint64_t\ngetu64(int swap, uint64_t value)\n{\n\tunion {\n\t\tuint64_t ui;\n\t\tchar c[8];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[7];\n\t\tretval.c[1] = tmpval.c[6];\n\t\tretval.c[2] = tmpval.c[5];\n\t\tretval.c[3] = tmpval.c[4];\n\t\tretval.c[4] = tmpval.c[3];\n\t\tretval.c[5] = tmpval.c[2];\n\t\tretval.c[6] = tmpval.c[1];\n\t\tretval.c[7] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\n#define elf_getu16(swap, value) getu16(swap, value)\n#define elf_getu32(swap, value) getu32(swap, value)\n#define elf_getu64(swap, value) getu64(swap, value)\n\n#define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &sh32)\t\t\t\\\n\t\t\t : CAST(void *, &sh64))\n#define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(sh32)\t\t\t\t\\\n\t\t\t : sizeof(sh64))\n#define xsh_size\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_size)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_size)))\n#define xsh_offset\tCAST(off_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_offset)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_offset)))\n#define xsh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_type)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_type))\n#define xsh_name    \t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_name)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_name))\n\n#define xph_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &ph32)\t\t\t\\\n\t\t\t : CAST(void *, &ph64))\n#define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(ph32)\t\t\t\t\\\n\t\t\t : sizeof(ph64))\n#define xph_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_type)\t\\\n\t\t\t : elf_getu32(swap, ph64.p_type))\n#define xph_offset\tCAST(off_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_offset)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_offset)))\n#define xph_align\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? CAST(off_t, (ph32.p_align ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_align) : 4))\\\n\t\t\t : CAST(off_t, (ph64.p_align ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_align) : 4))))\n#define xph_vaddr\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? CAST(off_t, (ph32.p_vaddr ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_vaddr) : 4))\\\n\t\t\t : CAST(off_t, (ph64.p_vaddr ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_vaddr) : 4))))\n#define xph_filesz\tCAST(size_t, (clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_filesz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_filesz)))\n#define xph_memsz\tCAST(size_t, ((clazz == ELFCLASS32\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_memsz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_memsz))))\n#define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &nh32)\t\t\t\\\n\t\t\t : CAST(void *, &nh64))\n#define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(nh32)\t\t\t\t\\\n\t\t\t : sizeof(nh64))\n#define xnh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_type)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_type))\n#define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_namesz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_namesz))\n#define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_descsz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_descsz))\n\n#define xdh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &dh32)\t\t\t\\\n\t\t\t : CAST(void *, &dh64))\n#define xdh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(dh32)\t\t\t\t\\\n\t\t\t : sizeof(dh64))\n#define xdh_tag\t\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, dh32.d_tag)\t\t\\\n\t\t\t : elf_getu64(swap, dh64.d_tag))\n#define xdh_val\t\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, dh32.d_un.d_val)\t\\\n\t\t\t : elf_getu64(swap, dh64.d_un.d_val))\n\n#define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &cap32)\t\t\t\\\n\t\t\t : CAST(void *, &cap64))\n#define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(cap32)\t\t\t\\\n\t\t\t : sizeof(cap64))\n#define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_tag))\n#define xcap_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_un.c_val))\n\n#define xauxv_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? CAST(void *, &auxv32)\t\t\\\n\t\t\t : CAST(void *, &auxv64))\n#define xauxv_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(auxv32)\t\t\t\\\n\t\t\t : sizeof(auxv64))\n#define xauxv_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_type)\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_type))\n#define xauxv_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_v)\t\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_v))\n\n#define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? prpsoffsets32[i]\t\t\t\\\n\t\t\t : prpsoffsets64[i])\n\n#ifdef ELFCORE\n/*\n * Try larger offsets first to avoid false matches\n * from earlier data that happen to look like strings.\n */\nstatic const size_t\tprpsoffsets32[] = {\n#ifdef USE_NT_PSINFO\n\t104,\t\t/* SunOS 5.x (command line) */\n\t88,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t100,\t\t/* SunOS 5.x (command line) */\n\t84,\t\t/* SunOS 5.x (short name) */\n\n\t44,\t\t/* Linux (command line) */\n\t28,\t\t/* Linux 2.0.36 (short name) */\n\n\t8,\t\t/* FreeBSD */\n};\n\nstatic const size_t\tprpsoffsets64[] = {\n#ifdef USE_NT_PSINFO\n\t152,\t\t/* SunOS 5.x (command line) */\n\t136,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t136,\t\t/* SunOS 5.x, 64-bit (command line) */\n\t120,\t\t/* SunOS 5.x, 64-bit (short name) */\n\n\t56,\t\t/* Linux (command line) */\n\t40,             /* Linux (tested on core from 2.4.x, short name) */\n\n\t16,\t\t/* FreeBSD, 64-bit */\n};\n\n#define\tNOFFSETS32\t(sizeof(prpsoffsets32) / sizeof(prpsoffsets32[0]))\n#define NOFFSETS64\t(sizeof(prpsoffsets64) / sizeof(prpsoffsets64[0]))\n\n#define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_NOTE section of type NT_PRPSINFO, with a name \"CORE\" or\n * \"FreeBSD\"; if one is found, try looking in various places in its\n * contents for a 16-character string containing only printable\n * characters - if found, that string should be the name of the program\n * that dropped core.  Note: right after that 16-character string is,\n * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and\n * Linux, a longer string (80 characters, in 5.x, probably other\n * SVR4-flavored systems, and Linux) containing the start of the\n * command line for that program.\n *\n * SunOS 5.x core files contain two PT_NOTE sections, with the types\n * NT_PRPSINFO (old) and NT_PSINFO (new).  These structs contain the\n * same info about the command name and command line, so it probably\n * isn't worthwhile to look for NT_PSINFO, but the offsets are provided\n * above (see USE_NT_PSINFO), in case we ever decide to do so.  The\n * NT_PRPSINFO and NT_PSINFO sections are always in order and adjacent;\n * the SunOS 5.x file command relies on this (and prefers the latter).\n *\n * The signal number probably appears in a section of type NT_PRSTATUS,\n * but that's also rather OS-dependent, in ways that are harder to\n * dissect with heuristics, so I'm not bothering with the signal number.\n * (I suppose the signal number could be of interest in situations where\n * you don't have the binary of the program that dropped core; if you\n * *do* have that binary, the debugger will probably tell you what\n * signal it was.)\n */\n\n#define\tOS_STYLE_SVR4\t\t0\n#define\tOS_STYLE_FREEBSD\t1\n#define\tOS_STYLE_NETBSD\t\t2\n\nprivate const char os_style_names[][8] = {\n\t\"SVR4\",\n\t\"FreeBSD\",\n\t\"NetBSD\",\n};\n\n#define FLAGS_CORE_STYLE\t\t0x0003\n\n#define FLAGS_DID_CORE\t\t\t0x0004\n#define FLAGS_DID_OS_NOTE\t\t0x0008\n#define FLAGS_DID_BUILD_ID\t\t0x0010\n#define FLAGS_DID_CORE_STYLE\t\t0x0020\n#define FLAGS_DID_NETBSD_PAX\t\t0x0040\n#define FLAGS_DID_NETBSD_MARCH\t\t0x0080\n#define FLAGS_DID_NETBSD_CMODEL\t\t0x0100\n#define FLAGS_DID_NETBSD_EMULATION\t0x0200\n#define FLAGS_DID_NETBSD_UNKNOWN\t0x0400\n#define FLAGS_IS_CORE\t\t\t0x0800\n#define FLAGS_DID_AUXV\t\t\t0x1000\n\nprivate int\ndophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\toff_t ph_off = off;\n\tint ph_num = num;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop through all the program headers.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) <\n\t\t    CAST(ssize_t, xph_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t * in the section.\n\t\t */\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags, notecount, fd, ph_off,\n\t\t\t    ph_num, fsize);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void\ndo_note_netbsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\tmemcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\n\tif (file_printf(ms, \", for NetBSD\") == -1)\n\t\treturn;\n\t/*\n\t * The version number used to be stuck as 199905, and was thus\n\t * basically content-free.  Newer versions of NetBSD have fixed\n\t * this and now use the encoding of __NetBSD_Version__:\n\t *\n\t *\tMMmmrrpp00\n\t *\n\t * M = major version\n\t * m = minor version\n\t * r = release [\"\",A-Z,Z[A-Z] but numeric]\n\t * p = patchlevel\n\t */\n\tif (desc > 100000000U) {\n\t\tuint32_t ver_patch = (desc / 100) % 100;\n\t\tuint32_t ver_rel = (desc / 10000) % 100;\n\t\tuint32_t ver_min = (desc / 1000000) % 100;\n\t\tuint32_t ver_maj = desc / 100000000;\n\n\t\tif (file_printf(ms, \" %u.%u\", ver_maj, ver_min) == -1)\n\t\t\treturn;\n\t\tif (ver_rel == 0 && ver_patch != 0) {\n\t\t\tif (file_printf(ms, \".%u\", ver_patch) == -1)\n\t\t\t\treturn;\n\t\t} else if (ver_rel != 0) {\n\t\t\twhile (ver_rel > 26) {\n\t\t\t\tif (file_printf(ms, \"Z\") == -1)\n\t\t\t\t\treturn;\n\t\t\t\tver_rel -= 26;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%c\", 'A' + ver_rel - 1)\n\t\t\t    == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\ndo_note_freebsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\n\tmemcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\tif (file_printf(ms, \", for FreeBSD\") == -1)\n\t\treturn;\n\n\t/*\n\t * Contents is __FreeBSD_version, whose relation to OS\n\t * versions is defined by a huge table in the Porter's\n\t * Handbook.  This is the general scheme:\n\t * \n\t * Releases:\n\t * \tMmp000 (before 4.10)\n\t * \tMmi0p0 (before 5.0)\n\t * \tMmm0p0\n\t * \n\t * Development branches:\n\t * \tMmpxxx (before 4.6)\n\t * \tMmp1xx (before 4.10)\n\t * \tMmi1xx (before 5.0)\n\t * \tM000xx (pre-M.0)\n\t * \tMmm1xx\n\t * \n\t * M = major version\n\t * m = minor version\n\t * i = minor version increment (491000 -> 4.10)\n\t * p = patchlevel\n\t * x = revision\n\t * \n\t * The first release of FreeBSD to use ELF by default\n\t * was version 3.0.\n\t */\n\tif (desc == 460002) {\n\t\tif (file_printf(ms, \" 4.6.2\") == -1)\n\t\t\treturn;\n\t} else if (desc < 460100) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 1000 % 10 > 0)\n\t\t\tif (file_printf(ms, \".%d\", desc / 1000 % 10) == -1)\n\t\t\t\treturn;\n\t\tif ((desc % 1000 > 0) || (desc % 100000 == 0))\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t} else if (desc < 500000) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10 + desc / 1000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 100 % 10 > 0) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 1000 % 100) == -1)\n\t\t\treturn;\n\t\tif ((desc / 100 % 10 > 0) ||\n\t\t    (desc % 100000 / 100 == 0)) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nprivate int\n/*ARGSUSED*/\ndo_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\tmemcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 2) {\n\t    *flags |= FLAGS_DID_OS_NOTE;\n\t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n\t    return 1;\n\t}\n\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 16) {\n\t\tuint32_t desc[4];\n\t\tmemcpy(desc, &nbuf[doff], sizeof(desc));\n\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for GNU/\") == -1)\n\t\t\treturn 1;\n\t\tswitch (elf_getu32(swap, desc[0])) {\n\t\tcase GNU_OS_LINUX:\n\t\t\tif (file_printf(ms, \"Linux\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_HURD:\n\t\t\tif (file_printf(ms, \"Hurd\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_SOLARIS:\n\t\t\tif (file_printf(ms, \"Solaris\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KFREEBSD:\n\t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KNETBSD:\n\t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n\t\t\t\treturn 1; \n\t\t}\n\t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n\t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t    \tif (type == NT_NETBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n\t    \tif (type == NT_FREEBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n\t    type == NT_OPENBSD_VERSION && descsz == 4) {\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n\t\t\treturn 1;\n\t\t/* Content of note is always 0 */\n\t\treturn 1;\n\t}\n\n\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n\t    type == NT_DRAGONFLY_VERSION && descsz == 4) {\n\t\tuint32_t desc;\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n\t\t\treturn 1;\n\t\tmemcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10, desc % 10000) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n\t    type == NT_NETBSD_PAX && descsz == 4) {\n\t\tstatic const char *pax[] = {\n\t\t    \"+mprotect\",\n\t\t    \"-mprotect\",\n\t\t    \"+segvguard\",\n\t\t    \"-segvguard\",\n\t\t    \"+ASLR\",\n\t\t    \"-ASLR\",\n\t\t};\n\t\tuint32_t desc;\n\t\tsize_t i;\n\t\tint did = 0;\n\n\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n\t\tmemcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\n\t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n\t\t\treturn 1;\n\n\t\tfor (i = 0; i < __arraycount(pax); i++) {\n\t\t\tif (((1 << (int)i) & desc) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n\t\t\t    pax[i]) == -1)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\t/*\n\t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n\t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tchar sbuf[512];\n\t\t\tstruct NetBSD_elfcore_procinfo pi;\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, (uint32_t)pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tsize_t i, j;\n\t\t\tunsigned char c;\n\t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Try next offsets, in case this match is\n\t\t\t\t * in the middle of a string.\n\t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; cp < nbuf + size && *cp\n\t\t\t\t    && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}\n\nprivate off_t\nget_offset_from_virtaddr(struct magic_set *ms, int swap, int clazz, int fd,\n    off_t off, int num, off_t fsize, uint64_t virtaddr)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\n\t/*\n\t * Loop through all the program headers and find the header with\n\t * virtual address in which the \"virtaddr\" belongs to.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += xph_sizeof;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (virtaddr >= xph_vaddr && virtaddr < xph_vaddr + xph_filesz)\n\t\t\treturn xph_offset + (virtaddr - xph_vaddr);\n\t}\n\treturn 0;\n}\n\nprivate size_t\nget_string_on_virtaddr(struct magic_set *ms,\n    int swap, int clazz, int fd, off_t ph_off, int ph_num,\n    off_t fsize, uint64_t virtaddr, char *buf, ssize_t buflen)\n{\n\tchar *bptr;\n\toff_t offset;\n\n\tif (buflen == 0)\n\t\treturn 0;\n\n\toffset = get_offset_from_virtaddr(ms, swap, clazz, fd, ph_off, ph_num,\n\t    fsize, virtaddr);\n\tif ((buflen = pread(fd, buf, CAST(size_t, buflen), offset)) <= 0) {\n\t\tfile_badread(ms);\n\t\treturn 0;\n\t}\n\n\tbuf[buflen - 1] = '\\0';\n\n\t/* We expect only printable characters, so return if buffer contains\n\t * non-printable character before the '\\0' or just '\\0'. */\n\tfor (bptr = buf; *bptr && isprint((unsigned char)*bptr); bptr++)\n\t\tcontinue;\n\tif (*bptr != '\\0')\n\t\treturn 0;\n\n\treturn bptr - buf;\n}\n\n\n/*ARGSUSED*/\nprivate int\ndo_auxv_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz __attribute__((__unused__)),\n    uint32_t descsz __attribute__((__unused__)),\n    size_t noff __attribute__((__unused__)), size_t doff,\n    int *flags, size_t size __attribute__((__unused__)), int clazz,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n#ifdef ELFCORE\n\tAux32Info auxv32;\n\tAux64Info auxv64;\n\tsize_t elsize = xauxv_sizeof;\n\tconst char *tag;\n\tint is_string;\n\tsize_t nval;\n\n\tif ((*flags & (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE)) !=\n\t    (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE))\n\t\treturn 0;\n\n\tswitch (*flags & FLAGS_CORE_STYLE) {\n\tcase OS_STYLE_SVR4:\n\t\tif (type != NT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#ifdef notyet\n\tcase OS_STYLE_NETBSD:\n\t\tif (type != NT_NETBSD_CORE_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase OS_STYLE_FREEBSD:\n\t\tif (type != NT_FREEBSD_PROCSTAT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t*flags |= FLAGS_DID_AUXV;\n\n\tnval = 0;\n\tfor (size_t off = 0; off + elsize <= descsz; off += elsize) {\n\t\tmemcpy(xauxv_addr, &nbuf[doff + off], xauxv_sizeof);\n\t\t/* Limit processing to 50 vector entries to prevent DoS */\n\t\tif (nval++ >= 50) {\n\t\t\tfile_error(ms, 0, \"Too many ELF Auxv elements\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tswitch(xauxv_type) {\n\t\tcase AT_LINUX_EXECFN:\n\t\t\tis_string = 1;\n\t\t\ttag = \"execfn\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_PLATFORM:\n\t\t\tis_string = 1;\n\t\t\ttag = \"platform\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_UID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_GID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real gid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EUID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EGID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective gid\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tis_string = 0;\n\t\t\ttag = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tag == NULL)\n\t\t\tcontinue;\n\n\t\tif (is_string) {\n\t\t\tchar buf[256];\n\t\t\tssize_t buflen;\n\t\t\tbuflen = get_string_on_virtaddr(ms, swap, clazz, fd,\n\t\t\t    ph_off, ph_num, fsize, xauxv_val, buf, sizeof(buf));\n\n\t\t\tif (buflen == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (file_printf(ms, \", %s: '%s'\", tag, buf) == -1)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (file_printf(ms, \", %s: %d\", tag, (int) xauxv_val)\n\t\t\t    == -1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nprivate size_t\ndodynamic(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap)\n{\n\tElf32_Dyn dh32;\n\tElf64_Dyn dh64;\n\tunsigned char *dbuf = CAST(unsigned char *, vbuf);\n\n\tif (xdh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xdh_sizeof + offset;\n\t}\n\n\tmemcpy(xdh_addr, &dbuf[offset], xdh_sizeof);\n\toffset += xdh_sizeof;\n\n\tswitch (xdh_tag) {\n\tcase DT_FLAGS_1:\n\t\tif (xdh_val == DF_1_PIE)\n\t\t\tms->mode |= 0111;\n\t\telse\n\t\t\tms->mode &= ~0111;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn offset;\n}\n\n\nprivate size_t\ndonote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags, uint16_t *notecount,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\n\tif (*notecount == 0)\n\t\treturn 0;\n\t--*notecount;\n\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\n\tmemcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif (namesz & 0x80000000) {\n\t    file_printf(ms, \", bad note name size %#lx\",\n\t\tCAST(unsigned long, namesz));\n\t    return 0;\n\t}\n\n\tif (descsz & 0x80000000) {\n\t    file_printf(ms, \", bad note description size %#lx\",\n\t\tCAST(unsigned long, descsz));\n\t    return 0;\n\t}\n\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\n\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\t\t\n\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_CORE) == 0) {\n\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_AUXV) == 0) {\n\t\tif (do_auxv_note(ms, nbuf, xnh_type, swap,\n\t\t\tnamesz, descsz, noff, doff, flags, size, clazz,\n\t\t\tfd, ph_off, ph_num, fsize))\n\t\t\treturn offset;\n\t}\n\n\tif (namesz == 7 && strcmp(CAST(char *, &nbuf[noff]), \"NetBSD\") == 0) {\n\t\tint descw, flag;\n\t\tconst char *str, *tag;\n\t\tif (descsz > 100)\n\t\t\tdescsz = 100;\n\t\tswitch (xnh_type) {\n\t    \tcase NT_NETBSD_VERSION:\n\t\t\treturn offset;\n\t\tcase NT_NETBSD_MARCH:\n\t\t\tflag = FLAGS_DID_NETBSD_MARCH;\n\t\t\ttag = \"compiled for\";\n\t\t\tbreak;\n\t\tcase NT_NETBSD_CMODEL:\n\t\t\tflag = FLAGS_DID_NETBSD_CMODEL;\n\t\t\ttag = \"compiler model\";\n\t\t\tbreak;\n\t\tcase NT_NETBSD_EMULATION:\n\t\t\tflag = FLAGS_DID_NETBSD_EMULATION;\n\t\t\ttag = \"emulation:\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n\t\t\t\treturn offset;\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (*flags & flag)\n\t\t\treturn offset;\n\t\tstr = CAST(const char *, &nbuf[doff]);\n\t\tdescw = CAST(int, descsz);\n\t\t*flags |= flag;\n\t\tfile_printf(ms, \", %s: %.*s\", tag, descw, str);\n\t\treturn offset;\n\t}\n\n\treturn offset;\n}\n\n/* SunOS 5.x hardware capability descriptions */\ntypedef struct cap_desc {\n\tuint64_t cd_mask;\n\tconst char *cd_name;\n} cap_desc_t;\n\nstatic const cap_desc_t cap_desc_sparc[] = {\n\t{ AV_SPARC_MUL32,\t\t\"MUL32\" },\n\t{ AV_SPARC_DIV32,\t\t\"DIV32\" },\n\t{ AV_SPARC_FSMULD,\t\t\"FSMULD\" },\n\t{ AV_SPARC_V8PLUS,\t\t\"V8PLUS\" },\n\t{ AV_SPARC_POPC,\t\t\"POPC\" },\n\t{ AV_SPARC_VIS,\t\t\t\"VIS\" },\n\t{ AV_SPARC_VIS2,\t\t\"VIS2\" },\n\t{ AV_SPARC_ASI_BLK_INIT,\t\"ASI_BLK_INIT\" },\n\t{ AV_SPARC_FMAF,\t\t\"FMAF\" },\n\t{ AV_SPARC_FJFMAU,\t\t\"FJFMAU\" },\n\t{ AV_SPARC_IMA,\t\t\t\"IMA\" },\n\t{ 0, NULL }\n};\n\nstatic const cap_desc_t cap_desc_386[] = {\n\t{ AV_386_FPU,\t\t\t\"FPU\" },\n\t{ AV_386_TSC,\t\t\t\"TSC\" },\n\t{ AV_386_CX8,\t\t\t\"CX8\" },\n\t{ AV_386_SEP,\t\t\t\"SEP\" },\n\t{ AV_386_AMD_SYSC,\t\t\"AMD_SYSC\" },\n\t{ AV_386_CMOV,\t\t\t\"CMOV\" },\n\t{ AV_386_MMX,\t\t\t\"MMX\" },\n\t{ AV_386_AMD_MMX,\t\t\"AMD_MMX\" },\n\t{ AV_386_AMD_3DNow,\t\t\"AMD_3DNow\" },\n\t{ AV_386_AMD_3DNowx,\t\t\"AMD_3DNowx\" },\n\t{ AV_386_FXSR,\t\t\t\"FXSR\" },\n\t{ AV_386_SSE,\t\t\t\"SSE\" },\n\t{ AV_386_SSE2,\t\t\t\"SSE2\" },\n\t{ AV_386_PAUSE,\t\t\t\"PAUSE\" },\n\t{ AV_386_SSE3,\t\t\t\"SSE3\" },\n\t{ AV_386_MON,\t\t\t\"MON\" },\n\t{ AV_386_CX16,\t\t\t\"CX16\" },\n\t{ AV_386_AHF,\t\t\t\"AHF\" },\n\t{ AV_386_TSCP,\t\t\t\"TSCP\" },\n\t{ AV_386_AMD_SSE4A,\t\t\"AMD_SSE4A\" },\n\t{ AV_386_POPCNT,\t\t\"POPCNT\" },\n\t{ AV_386_AMD_LZCNT,\t\t\"AMD_LZCNT\" },\n\t{ AV_386_SSSE3,\t\t\t\"SSSE3\" },\n\t{ AV_386_SSE4_1,\t\t\"SSE4.1\" },\n\t{ AV_386_SSE4_2,\t\t\"SSE4.2\" },\n\t{ 0, NULL }\n};\n\nprivate int\ndoshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n    size_t size, off_t fsize, int mach, int strtab, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Shdr sh32;\n\tElf64_Shdr sh64;\n\tint stripped = 1, has_debug_info = 0;\n\tsize_t nbadcap = 0;\n\tvoid *nbuf;\n\toff_t noff, coff, name_off;\n\tuint64_t cap_hw1 = 0;\t/* SunOS 5.x hardware capabilities */\n\tuint64_t cap_sf1 = 0;\t/* SunOS 5.x software capabilities */\n\tchar name[50];\n\tssize_t namesize;\n\n\tif (size != xsh_sizeof) {\n\t\tif (file_printf(ms, \", corrupted section header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* Read offset of name section to be able to read section names later */\n\tif (pread(fd, xsh_addr, xsh_sizeof, CAST(off_t, (off + size * strtab)))\n\t    < CAST(ssize_t, xsh_sizeof)) {\n\t\tif (file_printf(ms, \", missing section headers\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tname_off = xsh_offset;\n\n\tfor ( ; num; num--) {\n\t\t/* Read the name of this section. */\n\t\tif ((namesize = pread(fd, name, sizeof(name) - 1,\n\t\t    name_off + xsh_name)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tname[namesize] = '\\0';\n\t\tif (strcmp(name, \".debug_info\") == 0) {\n\t\t\thas_debug_info = 1;\n\t\t\tstripped = 0;\n\t\t}\n\n\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) <\n\t\t    CAST(ssize_t, xsh_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_SYMTAB:\n#if 0\n\t\tcase SHT_DYNSYM:\n#endif\n\t\t\tstripped = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xsh_offset > fsize) {\n\t\t\t\t/* Perhaps warn here */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_NOTE:\n\t\t\tif (CAST(uintmax_t, (xsh_size + xsh_offset)) >\n\t\t\t    CAST(uintmax_t, fsize)) {\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \", note offset/size %#\" INTMAX_T_FORMAT\n\t\t\t\t    \"x+%#\" INTMAX_T_FORMAT \"x exceeds\"\n\t\t\t\t    \" file size %#\" INTMAX_T_FORMAT \"x\",\n\t\t\t\t    CAST(uintmax_t, xsh_offset),\n\t\t\t\t    CAST(uintmax_t, xsh_size),\n\t\t\t\t    CAST(uintmax_t, fsize)) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0; \n\t\t\t}\n\t\t\tif ((nbuf = malloc(xsh_size)) == NULL) {\n\t\t\t\tfile_error(ms, errno, \"Cannot allocate memory\"\n\t\t\t\t    \" for note\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) <\n\t\t\t    CAST(ssize_t, xsh_size)) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\tfree(nbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (noff >= CAST(off_t, xsh_size))\n\t\t\t\t\tbreak;\n\t\t\t\tnoff = donote(ms, nbuf, CAST(size_t, noff),\n\t\t\t\t    xsh_size, clazz, swap, 4, flags, notecount,\n\t\t\t\t    fd, 0, 0, 0);\n\t\t\t\tif (noff == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(nbuf);\n\t\t\tbreak;\n\t\tcase SHT_SUNW_cap:\n\t\t\tswitch (mach) {\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_IA_64:\n\t\t\tcase EM_386:\n\t\t\tcase EM_AMD64:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tif (nbadcap > 5)\n\t\t\t\tbreak;\n\t\t\tif (lseek(fd, xsh_offset, SEEK_SET)\n\t\t\t    == CAST(off_t, -1)) {\n\t\t\t\tfile_badseek(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tElf32_Cap cap32;\n\t\t\t\tElf64_Cap cap64;\n\t\t\t\tchar cbuf[/*CONSTCOND*/\n\t\t\t\t    MAX(sizeof(cap32), sizeof(cap64))];\n\t\t\t\tif ((coff += xcap_sizeof) >\n\t\t\t\t    CAST(off_t, xsh_size))\n\t\t\t\t\tbreak;\n\t\t\t\tif (read(fd, cbuf, CAST(size_t, xcap_sizeof)) !=\n\t\t\t\t    CAST(ssize_t, xcap_sizeof)) {\n\t\t\t\t\tfile_badread(ms);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (cbuf[0] == 'A') {\n#ifdef notyet\n\t\t\t\t\tchar *p = cbuf + 1;\n\t\t\t\t\tuint32_t len, tag;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (memcmp(\"gnu\", p, 3) != 0) {\n\t\t\t\t\t    if (file_printf(ms,\n\t\t\t\t\t\t\", unknown capability %.3s\", p)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tp += strlen(p) + 1;\n\t\t\t\t\ttag = *p++;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (tag != 1) {\n\t\t\t\t\t    if (file_printf(ms, \", unknown gnu\"\n\t\t\t\t\t\t\" capability tag %d\", tag)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\t// gnu attributes \n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmemcpy(xcap_addr, cbuf, xcap_sizeof);\n\t\t\t\tswitch (xcap_tag) {\n\t\t\t\tcase CA_SUNW_NULL:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_HW_1:\n\t\t\t\t\tcap_hw1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_SF_1:\n\t\t\t\t\tcap_sf1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \", with unknown capability \"\n\t\t\t\t\t    \"%#\" INT64_T_FORMAT \"x = %#\"\n\t\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t\t    CAST(unsigned long long, xcap_tag),\n\t\t\t\t\t    CAST(unsigned long long, xcap_val))\n\t\t\t\t\t    == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tif (nbadcap++ > 2)\n\t\t\t\t\t\tcoff = xsh_size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tskip:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_debug_info) {\n\t\tif (file_printf(ms, \", with debug_info\") == -1)\n\t\t\treturn -1;\n\t}\n\tif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\n\t\treturn -1;\n\tif (cap_hw1) {\n\t\tconst cap_desc_t *cdp;\n\t\tswitch (mach) {\n\t\tcase EM_SPARC:\n\t\tcase EM_SPARC32PLUS:\n\t\tcase EM_SPARCV9:\n\t\t\tcdp = cap_desc_sparc;\n\t\t\tbreak;\n\t\tcase EM_386:\n\t\tcase EM_IA_64:\n\t\tcase EM_AMD64:\n\t\t\tcdp = cap_desc_386;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcdp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (file_printf(ms, \", uses\") == -1)\n\t\t\treturn -1;\n\t\tif (cdp) {\n\t\t\twhile (cdp->cd_name) {\n\t\t\t\tif (cap_hw1 & cdp->cd_mask) {\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \" %s\", cdp->cd_name) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;\n\t\t\t\t}\n\t\t\t\t++cdp;\n\t\t\t}\n\t\t\tif (cap_hw1)\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \" unknown hardware capability %#\"\n\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t    CAST(unsigned long long, cap_hw1)) == -1)\n\t\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (file_printf(ms,\n\t\t\t    \" hardware capability %#\" INT64_T_FORMAT \"x\",\n\t\t\t    CAST(unsigned long long, cap_hw1)) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (cap_sf1) {\n\t\tif (cap_sf1 & SF1_SUNW_FPUSED) {\n\t\t\tif (file_printf(ms,\n\t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)\n\t\t\t    ? \", uses frame pointer\"\n\t\t\t    : \", not known to use frame pointer\") == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tcap_sf1 &= ~SF1_SUNW_MASK;\n\t\tif (cap_sf1)\n\t\t\tif (file_printf(ms,\n\t\t\t    \", with unknown software capability %#\"\n\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t    CAST(unsigned long long, cap_sf1)) == -1)\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_INTERP section; if one is found, it's dynamically linked,\n * otherwise it's statically linked.\n */\nprivate int\ndophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int sh_num, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tchar interp[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\tinterp[0] = '\\0';\n  \tfor ( ; num; num--) {\n\t\tint doread;\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < \n\t\t    CAST(ssize_t, xph_sizeof)) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tdoread = 1;\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment %#lx\",\n\t\t\t\t    CAST(unsigned long, align)) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tdoread = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdoread = 0;\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (doread) {\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else\n\t\t\tlen = 0;\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = dodynamic(ms, nbuf, offset,\n\t\t\t\t    CAST(size_t, bufsize), clazz, swap);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tmemcpy(interp, nbuf, bufsize);\n\t\t\t} else\n\t\t\t\tstrlcpy(interp, \"*empty*\", sizeof(interp));\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    CAST(size_t, bufsize), clazz, swap, align,\n\t\t\t\t    flags, notecount, fd, 0, 0, 0);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}\n\n\nprotected int\nfile_tryelf(struct magic_set *ms, const struct buffer *b)\n{\n\tint fd = b->fd;\n\tconst unsigned char *buf = b->fbuf;\n\tsize_t nbytes = b->flen;\n\tunion {\n\t\tint32_t l;\n\t\tchar c[sizeof(int32_t)];\n\t} u;\n\tint clazz;\n\tint swap;\n\tstruct stat st;\n\toff_t fsize;\n\tint flags = 0;\n\tElf32_Ehdr elf32hdr;\n\tElf64_Ehdr elf64hdr;\n\tuint16_t type, phnum, shnum, notecount;\n\n\tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE|MAGIC_EXTENSION))\n\t\treturn 0;\n\t/*\n\t * ELF executables have multiple section headers in arbitrary\n\t * file locations and thus file(1) cannot determine it from easily.\n\t * Instead we traverse thru all section headers until a symbol table\n\t * one is found or else the binary is stripped.\n\t * Return immediately if it's not ELF (so we avoid pipe2file unless needed).\n\t */\n\tif (buf[EI_MAG0] != ELFMAG0\n\t    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)\n\t    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)\n\t\treturn 0;\n\n\t/*\n\t * If we cannot seek, it must be a pipe, socket or fifo.\n\t */\n\tif((lseek(fd, CAST(off_t, 0), SEEK_SET) == CAST(off_t, -1))\n\t    && (errno == ESPIPE))\n\t\tfd = file_pipe2file(ms, fd, buf, nbytes);\n\n\tif (fstat(fd, &st) == -1) {\n  \t\tfile_badread(ms);\n\t\treturn -1;\n\t}\n\tif (S_ISREG(st.st_mode) || st.st_size != 0)\n\t\tfsize = st.st_size;\n\telse\n\t\tfsize = SIZE_UNKNOWN;\n\n\tclazz = buf[EI_CLASS];\n\n\tswitch (clazz) {\n\tcase ELFCLASS32:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu32(a, b)\n#undef elfhdr\n#define elfhdr elf32hdr\n#include \"elfclass.h\"\n\tcase ELFCLASS64:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu64(a, b)\n#undef elfhdr\n#define elfhdr elf64hdr\n#include \"elfclass.h\"\n\tdefault:\n\t    if (file_printf(ms, \", unknown class %d\", clazz) == -1)\n\t\t    return -1;\n\t    break;\n\t}\n\treturn 0;\n}\n#endif\n"], "filenames": ["src/readelf.c"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [846], "fixing_code_start_loc": [30], "fixing_code_end_loc": [847], "type": "CWE-125", "message": "The do_core_note function in readelf.c in libmagic.a in file 5.33 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted ELF file.", "other": {"cve": {"id": "CVE-2018-10360", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-11T10:29:00.233", "lastModified": "2019-05-02T14:40:46.980", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The do_core_note function in readelf.c in libmagic.a in file 5.33 allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted ELF file."}, {"lang": "es", "value": "La funci\u00f3n do_core_note en readelf.c en libmagic.a en file 5.33 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites y cierre inesperado de la aplicaci\u00f3n) utilizando un archivo ELF manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:file_project:file:5.33:*:*:*:*:*:*:*", "matchCriteriaId": "1D602D40-5DD4-4C74-B806-AC5C22A74187"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.3:*:*:*:*:*:*:*", "matchCriteriaId": "5F65DAB0-3DAD-49FF-BC73-3581CC3D5BF3"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-03/msg00027.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-04/msg00053.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/a642587a9c9e2dd7feacdf513c3643ce26ad3c22", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201806-08", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3686-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3686-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/file/file/commit/a642587a9c9e2dd7feacdf513c3643ce26ad3c22"}}