{"buggy_code": ["/*\n * ADTS muxer.\n * Copyright (c) 2006 Baptiste Coudurier <baptiste.coudurier@smartjog.com>\n *                    Mans Rullgard <mans@mansr.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavcodec/get_bits.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/codec_id.h\"\n#include \"libavcodec/codec_par.h\"\n#include \"libavcodec/packet.h\"\n#include \"libavcodec/mpeg4audio.h\"\n#include \"libavutil/opt.h\"\n#include \"avformat.h\"\n#include \"apetag.h\"\n#include \"id3v2.h\"\n\n#define ADTS_HEADER_SIZE 7\n\ntypedef struct ADTSContext {\n    AVClass *class;\n    int write_adts;\n    int objecttype;\n    int sample_rate_index;\n    int channel_conf;\n    int pce_size;\n    int apetag;\n    int id3v2tag;\n    int mpeg_id;\n    uint8_t pce_data[MAX_PCE_SIZE];\n} ADTSContext;\n\n#define ADTS_MAX_FRAME_BYTES ((1 << 14) - 1)\n\nstatic int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}\n\nstatic int adts_init(AVFormatContext *s)\n{\n    ADTSContext *adts = s->priv_data;\n    AVCodecParameters *par = s->streams[0]->codecpar;\n\n    if (par->codec_id != AV_CODEC_ID_AAC) {\n        av_log(s, AV_LOG_ERROR, \"Only AAC streams can be muxed by the ADTS muxer\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (par->extradata_size > 0)\n        return adts_decode_extradata(s, adts, par->extradata,\n                                     par->extradata_size);\n\n    return 0;\n}\n\nstatic int adts_write_header(AVFormatContext *s)\n{\n    ADTSContext *adts = s->priv_data;\n\n    if (adts->id3v2tag)\n        ff_id3v2_write_simple(s, 4, ID3v2_DEFAULT_MAGIC);\n\n    return 0;\n}\n\nstatic int adts_write_frame_header(ADTSContext *ctx,\n                                   uint8_t *buf, int size, int pce_size)\n{\n    PutBitContext pb;\n\n    unsigned full_frame_size = (unsigned)ADTS_HEADER_SIZE + size + pce_size;\n    if (full_frame_size > ADTS_MAX_FRAME_BYTES) {\n        av_log(NULL, AV_LOG_ERROR, \"ADTS frame size too large: %u (max %d)\\n\",\n               full_frame_size, ADTS_MAX_FRAME_BYTES);\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_put_bits(&pb, buf, ADTS_HEADER_SIZE);\n\n    /* adts_fixed_header */\n    put_bits(&pb, 12, 0xfff);   /* syncword */\n    put_bits(&pb, 1, ctx->mpeg_id); /* ID */\n    put_bits(&pb, 2, 0);        /* layer */\n    put_bits(&pb, 1, 1);        /* protection_absent */\n    put_bits(&pb, 2, ctx->objecttype); /* profile_objecttype */\n    put_bits(&pb, 4, ctx->sample_rate_index);\n    put_bits(&pb, 1, 0);        /* private_bit */\n    put_bits(&pb, 3, ctx->channel_conf); /* channel_configuration */\n    put_bits(&pb, 1, 0);        /* original_copy */\n    put_bits(&pb, 1, 0);        /* home */\n\n    /* adts_variable_header */\n    put_bits(&pb, 1, 0);        /* copyright_identification_bit */\n    put_bits(&pb, 1, 0);        /* copyright_identification_start */\n    put_bits(&pb, 13, full_frame_size); /* aac_frame_length */\n    put_bits(&pb, 11, 0x7ff);   /* adts_buffer_fullness */\n    put_bits(&pb, 2, 0);        /* number_of_raw_data_blocks_in_frame */\n\n    flush_put_bits(&pb);\n\n    return 0;\n}\n\nstatic int adts_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    ADTSContext *adts = s->priv_data;\n    AVCodecParameters *par = s->streams[0]->codecpar;\n    AVIOContext *pb = s->pb;\n    uint8_t buf[ADTS_HEADER_SIZE];\n\n    if (!pkt->size)\n        return 0;\n    if (!par->extradata_size) {\n        uint8_t *side_data;\n        size_t side_data_size;\n        int ret;\n\n        side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                            &side_data_size);\n        if (side_data_size) {\n            ret = adts_decode_extradata(s, adts, side_data, side_data_size);\n            if (ret < 0)\n                return ret;\n            ret = ff_alloc_extradata(par, side_data_size);\n            if (ret < 0)\n                return ret;\n            memcpy(par->extradata, side_data, side_data_size);\n        }\n    }\n    if (adts->write_adts) {\n        int err = adts_write_frame_header(adts, buf, pkt->size,\n                                             adts->pce_size);\n        if (err < 0)\n            return err;\n        avio_write(pb, buf, ADTS_HEADER_SIZE);\n        if (adts->pce_size) {\n            avio_write(pb, adts->pce_data, adts->pce_size);\n            adts->pce_size = 0;\n        }\n    }\n    avio_write(pb, pkt->data, pkt->size);\n\n    return 0;\n}\n\nstatic int adts_write_trailer(AVFormatContext *s)\n{\n    ADTSContext *adts = s->priv_data;\n\n    if (adts->apetag)\n        ff_ape_write_tag(s);\n\n    return 0;\n}\n\n#define ENC AV_OPT_FLAG_ENCODING_PARAM\n#define OFFSET(obj) offsetof(ADTSContext, obj)\nstatic const AVOption options[] = {\n    { \"write_id3v2\",  \"Enable ID3v2 tag writing\",   OFFSET(id3v2tag), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, ENC},\n    { \"write_apetag\", \"Enable APE tag writing\",     OFFSET(apetag),   AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, ENC},\n    { \"write_mpeg2\",  \"Set MPEG version to MPEG-2\", OFFSET(mpeg_id),  AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, ENC},\n    { NULL },\n};\n\nstatic const AVClass adts_muxer_class = {\n    .class_name     = \"ADTS muxer\",\n    .item_name      = av_default_item_name,\n    .option         = options,\n    .version        = LIBAVUTIL_VERSION_INT,\n};\n\nconst AVOutputFormat ff_adts_muxer = {\n    .name              = \"adts\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"ADTS AAC (Advanced Audio Coding)\"),\n    .mime_type         = \"audio/aac\",\n    .extensions        = \"aac,adts\",\n    .priv_data_size    = sizeof(ADTSContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_NONE,\n    .init              = adts_init,\n    .write_header      = adts_write_header,\n    .write_packet      = adts_write_packet,\n    .write_trailer     = adts_write_trailer,\n    .priv_class        = &adts_muxer_class,\n    .flags             = AVFMT_NOTIMESTAMPS,\n};\n"], "fixing_code": ["/*\n * ADTS muxer.\n * Copyright (c) 2006 Baptiste Coudurier <baptiste.coudurier@smartjog.com>\n *                    Mans Rullgard <mans@mansr.com>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavcodec/get_bits.h\"\n#include \"libavcodec/put_bits.h\"\n#include \"libavcodec/codec_id.h\"\n#include \"libavcodec/codec_par.h\"\n#include \"libavcodec/packet.h\"\n#include \"libavcodec/mpeg4audio.h\"\n#include \"libavutil/opt.h\"\n#include \"avformat.h\"\n#include \"apetag.h\"\n#include \"id3v2.h\"\n\n#define ADTS_HEADER_SIZE 7\n\ntypedef struct ADTSContext {\n    AVClass *class;\n    int write_adts;\n    int objecttype;\n    int sample_rate_index;\n    int channel_conf;\n    int pce_size;\n    int apetag;\n    int id3v2tag;\n    int mpeg_id;\n    uint8_t pce_data[MAX_PCE_SIZE];\n} ADTSContext;\n\n#define ADTS_MAX_FRAME_BYTES ((1 << 14) - 1)\n\nstatic int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off, ret;\n\n    ret = init_get_bits8(&gb, buf, size);\n    if (ret < 0)\n        return ret;\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}\n\nstatic int adts_init(AVFormatContext *s)\n{\n    ADTSContext *adts = s->priv_data;\n    AVCodecParameters *par = s->streams[0]->codecpar;\n\n    if (par->codec_id != AV_CODEC_ID_AAC) {\n        av_log(s, AV_LOG_ERROR, \"Only AAC streams can be muxed by the ADTS muxer\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (par->extradata_size > 0)\n        return adts_decode_extradata(s, adts, par->extradata,\n                                     par->extradata_size);\n\n    return 0;\n}\n\nstatic int adts_write_header(AVFormatContext *s)\n{\n    ADTSContext *adts = s->priv_data;\n\n    if (adts->id3v2tag)\n        ff_id3v2_write_simple(s, 4, ID3v2_DEFAULT_MAGIC);\n\n    return 0;\n}\n\nstatic int adts_write_frame_header(ADTSContext *ctx,\n                                   uint8_t *buf, int size, int pce_size)\n{\n    PutBitContext pb;\n\n    unsigned full_frame_size = (unsigned)ADTS_HEADER_SIZE + size + pce_size;\n    if (full_frame_size > ADTS_MAX_FRAME_BYTES) {\n        av_log(NULL, AV_LOG_ERROR, \"ADTS frame size too large: %u (max %d)\\n\",\n               full_frame_size, ADTS_MAX_FRAME_BYTES);\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_put_bits(&pb, buf, ADTS_HEADER_SIZE);\n\n    /* adts_fixed_header */\n    put_bits(&pb, 12, 0xfff);   /* syncword */\n    put_bits(&pb, 1, ctx->mpeg_id); /* ID */\n    put_bits(&pb, 2, 0);        /* layer */\n    put_bits(&pb, 1, 1);        /* protection_absent */\n    put_bits(&pb, 2, ctx->objecttype); /* profile_objecttype */\n    put_bits(&pb, 4, ctx->sample_rate_index);\n    put_bits(&pb, 1, 0);        /* private_bit */\n    put_bits(&pb, 3, ctx->channel_conf); /* channel_configuration */\n    put_bits(&pb, 1, 0);        /* original_copy */\n    put_bits(&pb, 1, 0);        /* home */\n\n    /* adts_variable_header */\n    put_bits(&pb, 1, 0);        /* copyright_identification_bit */\n    put_bits(&pb, 1, 0);        /* copyright_identification_start */\n    put_bits(&pb, 13, full_frame_size); /* aac_frame_length */\n    put_bits(&pb, 11, 0x7ff);   /* adts_buffer_fullness */\n    put_bits(&pb, 2, 0);        /* number_of_raw_data_blocks_in_frame */\n\n    flush_put_bits(&pb);\n\n    return 0;\n}\n\nstatic int adts_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    ADTSContext *adts = s->priv_data;\n    AVCodecParameters *par = s->streams[0]->codecpar;\n    AVIOContext *pb = s->pb;\n    uint8_t buf[ADTS_HEADER_SIZE];\n\n    if (!pkt->size)\n        return 0;\n    if (!par->extradata_size) {\n        uint8_t *side_data;\n        size_t side_data_size;\n        int ret;\n\n        side_data = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                            &side_data_size);\n        if (side_data_size) {\n            ret = adts_decode_extradata(s, adts, side_data, side_data_size);\n            if (ret < 0)\n                return ret;\n            ret = ff_alloc_extradata(par, side_data_size);\n            if (ret < 0)\n                return ret;\n            memcpy(par->extradata, side_data, side_data_size);\n        }\n    }\n    if (adts->write_adts) {\n        int err = adts_write_frame_header(adts, buf, pkt->size,\n                                             adts->pce_size);\n        if (err < 0)\n            return err;\n        avio_write(pb, buf, ADTS_HEADER_SIZE);\n        if (adts->pce_size) {\n            avio_write(pb, adts->pce_data, adts->pce_size);\n            adts->pce_size = 0;\n        }\n    }\n    avio_write(pb, pkt->data, pkt->size);\n\n    return 0;\n}\n\nstatic int adts_write_trailer(AVFormatContext *s)\n{\n    ADTSContext *adts = s->priv_data;\n\n    if (adts->apetag)\n        ff_ape_write_tag(s);\n\n    return 0;\n}\n\n#define ENC AV_OPT_FLAG_ENCODING_PARAM\n#define OFFSET(obj) offsetof(ADTSContext, obj)\nstatic const AVOption options[] = {\n    { \"write_id3v2\",  \"Enable ID3v2 tag writing\",   OFFSET(id3v2tag), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, ENC},\n    { \"write_apetag\", \"Enable APE tag writing\",     OFFSET(apetag),   AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, ENC},\n    { \"write_mpeg2\",  \"Set MPEG version to MPEG-2\", OFFSET(mpeg_id),  AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, ENC},\n    { NULL },\n};\n\nstatic const AVClass adts_muxer_class = {\n    .class_name     = \"ADTS muxer\",\n    .item_name      = av_default_item_name,\n    .option         = options,\n    .version        = LIBAVUTIL_VERSION_INT,\n};\n\nconst AVOutputFormat ff_adts_muxer = {\n    .name              = \"adts\",\n    .long_name         = NULL_IF_CONFIG_SMALL(\"ADTS AAC (Advanced Audio Coding)\"),\n    .mime_type         = \"audio/aac\",\n    .extensions        = \"aac,adts\",\n    .priv_data_size    = sizeof(ADTSContext),\n    .audio_codec       = AV_CODEC_ID_AAC,\n    .video_codec       = AV_CODEC_ID_NONE,\n    .init              = adts_init,\n    .write_header      = adts_write_header,\n    .write_packet      = adts_write_packet,\n    .write_trailer     = adts_write_trailer,\n    .priv_class        = &adts_muxer_class,\n    .flags             = AVFMT_NOTIMESTAMPS,\n};\n"], "filenames": ["libavformat/adtsenc.c"], "buggy_code_start_loc": [56], "buggy_code_end_loc": [59], "fixing_code_start_loc": [56], "fixing_code_end_loc": [61], "type": "CWE-252", "message": "adts_decode_extradata in libavformat/adtsenc.c in FFmpeg 4.4 does not check the init_get_bits return value, which is a necessary step because the second argument to init_get_bits can be crafted.", "other": {"cve": {"id": "CVE-2021-38171", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-21T17:15:07.700", "lastModified": "2021-11-30T21:38:33.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "adts_decode_extradata in libavformat/adtsenc.c in FFmpeg 4.4 does not check the init_get_bits return value, which is a necessary step because the second argument to init_get_bits can be crafted."}, {"lang": "es", "value": "La funci\u00f3n adts_decode_extradata en el archivo libavformat/adtsenc.c en Ffmpeg versi\u00f3n 4.4, no comprueba el valor de retorno de init_get_bits, que es un paso necesario porque el segundo argumento de init_get_bits puede ser dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-252"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.4:*:*:*:*:*:*:*", "matchCriteriaId": "0ADCFDB3-718B-4D16-BDD0-3CF8F1272E5E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://patchwork.ffmpeg.org/project/ffmpeg/patch/AS8P193MB12542A86E22F8207EC971930B6F19@AS8P193MB1254.EURP193.PROD.OUTLOOK.COM/", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4990", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4998", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6"}}