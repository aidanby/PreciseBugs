{"buggy_code": [".\\\" reposync\n.TH \"reposync\" \"1\" \"27 April 2007\" \"\" \"\"\n.SH \"NAME\"\nreposync \\- synchronize yum repositories to a local directory\n.SH \"SYNOPSIS\"\n\\fBreposync\\fP [options]\n.SH \"DESCRIPTION\"\n\\fBreposync\\fP is used to synchronize a remote yum repository to a local\ndirectory, using yum to retrieve the packages.\n.SH \"OPTIONS\"\n.IP \"\\fB\\-h, \\-\\-help\\fP\"\nDisplay a help message, and then quit.\n.IP \"\\fB\\-c CONFIG, \\-\\-config=CONFIG\\fP\"\nConfig file to use (defaults to /etc/yum.conf).\n.IP \"\\fB\\-a ARCH, \\-\\-arch=ARCH\\fP\"\nAct as if running the specified arch (default: current arch, note: does\nnot override $releasever. x86_64 is a superset for i*86.).\n.IP \"\\fB\\-\\-source\\fP\"\nAlso download .src.rpm files.\n.IP \"\\fB\\-r REPOID, \\-\\-repoid=REPOID\\fP\"\nSpecify repo ids to query, can be specified multiple times (default is\nall enabled).\n.IP \"\\fB\\-e\\ CACHEDIR, \\-\\-cachedir CACHEDIR\\fP\"\nDirectory in which to store metadata.\n.IP \"\\fB\\-t, \\-\\-tempcache\\fP\"\nUse a temp dir for storing/accessing yum-cache.\n.IP \"\\fB\\-d, \\-\\-delete\\fP\"\nDelete local packages no longer present in repository.\n.IP \"\\fB\\-p DESTDIR, \\-\\-download_path=DESTDIR\\fP\"\nPath to download packages to: defaults to current directory.\n.IP \"\\fB\\-\\-norepopath\\fP\"\nDon't add the reponame to the download path.\nCan only be used when syncing a single repository (default is\nto add the reponame).\n.IP \"\\fB\\-g, \\-\\-gpgcheck\\fP\"\nRemove packages that fail GPG signature checking after downloading.\nexit status is '1' if at least one package was removed.\n.IP \"\\fB\\-u, \\-\\-urls\\fP\"\nJust list urls of what would be downloaded, don't download.\n.IP \"\\fB\\-l, \\-\\-plugins\\fP\"\nEnable yum plugin support.\n.IP \"\\fB\\-m, \\-\\-downloadcomps\\fP\"\nAlso download comps.xml.\n.IP \"\\fB\\-\\-download-metadata\\fP\"\nDownload all the non-default metadata\n.IP \"\\fB\\-n, \\-\\-newest\\-only\\fP\"\nDownload only newest packages per-repo.\n.IP \"\\fB\\-q, \\-\\-quiet\\fP\"\nOutput as little information as possible.\n.SH \"EXAMPLES\"\n.IP \"Sync all packages from the 'updates' repo to the current directory:\"\n\\fB reposync \\-\\-repoid=updates\\fP\n.IP \"Sync only the newest packages from the 'updates' repo to the current directory:\"\n\\fB reposync \\-n \\-\\-repoid=updates\\fP\n.IP \"Sync packages from the 'updates' and 'extras' repos to the current directory:\"\n\\fB reposync \\-\\-repoid=updates \\-\\-repoid=extras\\fP\n.IP \"Sync all packages from the 'updates' repo to the \\fBrepos\\fP directory:\"\n\\fB reposync \\-p repos \\-\\-repoid=updates\\fP\n.IP \"Sync all packages from the 'updates' repo to the \\fBrepos\\fP directory excluding x86_64 arch. Edit \\fI/etc/yum.conf\\fR adding option \\fBexclude=*.x86_64\\fR. Then: \n\\fBreposync \\-p repos \\-\\-repoid=updates\\fP\n.SH \"FILES\"\n\\fBreposync\\fP uses the yum libraries for retrieving information and\npackages. If no configuration file is specified, the default yum\nconfiguration will be used.\n.PP\n.nf \n/etc/yum.conf\n/etc/yum/repos.d/\n.fi\n.SH \"SEE ALSO\"\n.nf\n.I yum.conf (5)\nhttp://yum.baseurl.org/\n.fi\n.SH \"AUTHORS\"\n.nf \nSee the Authors file included with this program.\n.fi\n\n.PP \n.SH \"BUGS\"\nThere are of course no bugs, but should you find any, you should first\nconsult the FAQ section on http://yum.baseurl.org/wiki/Faq and if unsuccessful\nin finding a resolution contact the mailing list: yum-devel@lists.baseurl.org.\nTo file a bug use http://bugzilla.redhat.com for Fedora/RHEL/Centos\nrelated bugs and http://yum.baseurl.org/report for all other bugs.\n\n.fi\n", "#!/usr/bin/python -tt\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n# copyright 2006 Duke University\n# author seth vidal\n\n# sync all or the newest packages from a repo to the local path\n# TODO:\n#     have it print out list of changes\n#     make it work with mirrorlists (silly, really)\n#     man page/more useful docs\n#     deal nicely with a package changing but not changing names (ie: replacement)\n\n# criteria\n# if a package is not the same and smaller then reget it\n# if a package is not the same and larger, delete it and get it again\n# always replace metadata files if they're not the same.\n\n\n\n\n\nimport os\nimport sys\nimport shutil\nimport stat\n\nfrom optparse import OptionParser\nfrom urlparse import urljoin\n\nfrom yumutils.i18n import _\n\nimport yum\nimport yum.Errors\nfrom yum.packageSack import ListPackageSack\nimport rpmUtils.arch\nimport logging\nfrom urlgrabber.progress import TextMeter, TextMultiFileMeter\nimport urlgrabber\n\nclass RepoSync(yum.YumBase):\n    def __init__(self, opts):\n        yum.YumBase.__init__(self)\n        self.logger = logging.getLogger('yum.verbose.reposync')\n        self.opts = opts\n\ndef localpkgs(directory):\n    names = os.listdir(directory)\n\n    cache = {}\n    for name in names:\n        fn = os.path.join(directory, name)\n        try:\n            st = os.lstat(fn)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            subcache = localpkgs(fn)\n            for pkg in subcache.keys():\n                cache[pkg] = subcache[pkg]\n        elif stat.S_ISREG(st.st_mode) and name.endswith(\".rpm\"):\n            cache[name] = {'path': fn, 'size': st.st_size, 'device': st.st_dev}\n    return cache\n\ndef parseArgs():\n    usage = _(\"\"\"\n    Reposync is used to synchronize a remote yum repository to a local \n    directory using yum to retrieve the packages.\n    \n    %s [options]\n    \"\"\") % sys.argv[0]\n\n    parser = OptionParser(usage=usage)\n    parser.add_option(\"-c\", \"--config\", default='/etc/yum.conf',\n        help=_('config file to use (defaults to /etc/yum.conf)'))\n    parser.add_option(\"-a\", \"--arch\", default=None,\n        help=_('act as if running the specified arch (default: current arch, note: does not override $releasever. x86_64 is a superset for i*86.)'))\n    parser.add_option(\"--source\", default=False, dest=\"source\", action=\"store_true\",\n                      help=_('operate on source packages'))\n    parser.add_option(\"-r\", \"--repoid\", default=[], action='append',\n        help=_(\"specify repo ids to query, can be specified multiple times (default is all enabled)\"))\n    parser.add_option(\"-e\", \"--cachedir\",\n        help=_(\"directory in which to store metadata\"))\n    parser.add_option(\"-t\", \"--tempcache\", default=False, action=\"store_true\",\n        help=_(\"Use a temp dir for storing/accessing yum-cache\"))\n    parser.add_option(\"-d\", \"--delete\", default=False, action=\"store_true\",\n        help=_(\"delete local packages no longer present in repository\"))\n    parser.add_option(\"-p\", \"--download_path\", dest='destdir',\n        default=os.getcwd(), help=_(\"Path to download packages to: defaults to current dir\"))\n    parser.add_option(\"--norepopath\", dest='norepopath', default=False, action=\"store_true\",\n        help=_(\"Don't add the reponame to the download path. Can only be used when syncing a single repository (default is to add the reponame)\"))\n    parser.add_option(\"-g\", \"--gpgcheck\", default=False, action=\"store_true\",\n        help=_(\"Remove packages that fail GPG signature checking after downloading\"))\n    parser.add_option(\"-u\", \"--urls\", default=False, action=\"store_true\",\n        help=_(\"Just list urls of what would be downloaded, don't download\"))\n    parser.add_option(\"-n\", \"--newest-only\", dest='newest', default=False, action=\"store_true\",\n        help=_(\"Download only newest packages per-repo\"))\n    parser.add_option(\"-q\", \"--quiet\", default=False, action=\"store_true\",\n        help=_(\"Output as little as possible\"))\n    parser.add_option(\"-l\", \"--plugins\", default=False, action=\"store_true\",\n        help=_(\"enable yum plugin support\"))\n    parser.add_option(\"-m\", \"--downloadcomps\", default=False, action=\"store_true\",\n        help=_(\"also download comps.xml\"))\n    parser.add_option(\"\", \"--download-metadata\", dest=\"downloadmd\",\n        default=False, action=\"store_true\",\n        help=_(\"download all the non-default metadata\"))\n    (opts, args) = parser.parse_args()\n    return (opts, args)\n\n\ndef main():\n    (opts, dummy) = parseArgs()\n\n    if not os.path.exists(opts.destdir) and not opts.urls:\n        try:\n            os.makedirs(opts.destdir)\n        except OSError, e:\n            print >> sys.stderr, _(\"Error: Cannot create destination dir %s\") % opts.destdir\n            sys.exit(1)\n\n    if not os.access(opts.destdir, os.W_OK) and not opts.urls:\n        print >> sys.stderr, _(\"Error: Cannot write to  destination dir %s\") % opts.destdir\n        sys.exit(1)\n\n    my = RepoSync(opts=opts)\n    my.doConfigSetup(fn=opts.config, init_plugins=opts.plugins)\n\n    # Force unprivileged users to have a private temporary cachedir\n    # if they've not given an explicit cachedir\n    if os.getuid() != 0 and not opts.cachedir:\n        opts.tempcache = True\n\n    if opts.tempcache:\n        if not my.setCacheDir(force=True, reuse=False):\n            print >> sys.stderr, _(\"Error: Could not make cachedir, exiting\")\n            sys.exit(50)\n        my.conf.uid = 1 # force locking of user cache\n    elif opts.cachedir:\n        my.repos.setCacheDir(opts.cachedir)\n\n    # Lock if they've not given an explicit cachedir\n    if not opts.cachedir:\n        try:\n            my.doLock()\n        except yum.Errors.LockError, e:\n            print >> sys.stderr, _(\"Error: %s\") % e\n            sys.exit(50)\n\n    #  Use progress bar display when downloading repo metadata\n    # and package files ... needs to be setup before .repos (ie. RHN/etc.).\n    if not opts.quiet:\n        my.repos.setProgressBar(TextMeter(fo=sys.stdout), TextMultiFileMeter(fo=sys.stdout))\n    my.doRepoSetup()\n\n    if len(opts.repoid) > 0:\n        myrepos = []\n\n        # find the ones we want\n        for glob in opts.repoid:\n            add_repos = my.repos.findRepos(glob)\n            if not add_repos:\n                print >> sys.stderr, _(\"Warning: cannot find repository %s\") % glob\n                continue\n            myrepos.extend(add_repos)\n\n        if not myrepos:\n            print >> sys.stderr, _(\"No repositories found\")\n            sys.exit(1)\n\n        # disable them all\n        for repo in my.repos.repos.values():\n            repo.disable()\n\n        # enable the ones we like\n        for repo in myrepos:\n            repo.enable()\n\n    # --norepopath can only be sensibly used with a single repository:\n    if len(my.repos.listEnabled()) > 1 and opts.norepopath:\n        print >> sys.stderr, _(\"Error: Can't use --norepopath with multiple repositories\")\n        sys.exit(1)\n\n    try:\n        arches = rpmUtils.arch.getArchList(opts.arch)\n        if opts.source:\n            arches += ['src']\n        my.doSackSetup(arches)\n    except yum.Errors.RepoError, e:\n        print >> sys.stderr, _(\"Error setting up repositories: %s\") % e\n        # maybe this shouldn't be entirely fatal\n        sys.exit(1)\n\n    exit_code = 0\n    for repo in my.repos.listEnabled():\n        reposack = ListPackageSack(my.pkgSack.returnPackages(repoid=repo.id))\n\n        if opts.newest:\n            download_list = reposack.returnNewestByNameArch()\n        else:\n            download_list = list(reposack)\n\n        if opts.norepopath:\n            local_repo_path = opts.destdir\n        else:\n            local_repo_path = opts.destdir + '/' + repo.id\n\n        if opts.delete and os.path.exists(local_repo_path):\n            current_pkgs = localpkgs(local_repo_path)\n\n            download_set = {}\n            for pkg in download_list:\n                rpmname = os.path.basename(pkg.remote_path)\n                download_set[rpmname] = 1\n\n            for pkg in current_pkgs:\n                if pkg in download_set:\n                    continue\n\n                if not opts.quiet:\n                    my.logger.info(\"Removing obsolete %s\", pkg)\n                os.unlink(current_pkgs[pkg]['path'])\n\n        if opts.downloadcomps or opts.downloadmd:\n\n            if not os.path.exists(local_repo_path):\n                try:\n                    os.makedirs(local_repo_path)\n                except IOError, e:\n                    my.logger.error(\"Could not make repo subdir: %s\" % e)\n                    my.closeRpmDB()\n                    sys.exit(1)\n\n            if opts.downloadcomps:\n                wanted_types = ['group']\n\n            if opts.downloadmd:\n                wanted_types = repo.repoXML.fileTypes()\n\n            for ftype in repo.repoXML.fileTypes():\n                if ftype in ['primary', 'primary_db', 'filelists',\n                             'filelists_db', 'other', 'other_db']:\n                    continue\n                if ftype not in wanted_types:\n                    continue\n\n                try:\n                    resultfile = repo.retrieveMD(ftype)\n                    basename = os.path.basename(resultfile)\n                    if ftype == 'group' and opts.downloadcomps: # for compat with how --downloadcomps saved the comps file always as comps.xml\n                        basename = 'comps.xml'\n                    shutil.copyfile(resultfile, \"%s/%s\" % (local_repo_path, basename))\n                except yum.Errors.RepoMDError, e:\n                    if not opts.quiet:\n                        my.logger.error(\"Unable to fetch metadata: %s\" % e)\n\n        remote_size = 0\n        if not opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                sz = int(pkg.returnSimple('packagesize'))\n                if os.path.exists(local) and os.path.getsize(local) == sz:\n                    continue\n                remote_size += sz\n\n        if hasattr(urlgrabber.progress, 'text_meter_total_size'):\n            urlgrabber.progress.text_meter_total_size(remote_size)\n\n        download_list.sort(key=lambda pkg: pkg.name)\n        if opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n                    print urljoin(pkg.repo.urls[0], pkg.remote_path)\n            continue\n\n        # create dest dir\n        if not os.path.exists(local_repo_path):\n            os.makedirs(local_repo_path)\n\n        # set localpaths\n        for pkg in download_list:\n            pkg.localpath = os.path.join(local_repo_path, pkg.remote_path)\n            pkg.repo.copy_local = True\n            pkg.repo.cache = 0\n            localdir = os.path.dirname(pkg.localpath)\n            if not os.path.exists(localdir):\n                os.makedirs(localdir)\n\n        # use downloader from YumBase\n        probs = my.downloadPkgs(download_list)\n        if probs:\n            exit_code = 1\n            for key in probs:\n                for error in probs[key]:\n                    my.logger.error('%s: %s', key, error)\n\n        if opts.gpgcheck:\n            for pkg in download_list:\n                result, error = my.sigCheckPkg(pkg)\n                if result != 0:\n                    rpmfn = os.path.basename(pkg.remote_path)\n                    if result == 1:\n                        my.logger.warning('Removing %s, due to missing GPG key.' % rpmfn)\n                    elif result == 2:\n                        my.logger.warning('Removing %s due to failed signature check.' % rpmfn)\n                    else:\n                        my.logger.warning('Removing %s due to failed signature check: %s' % rpmfn)\n                    os.unlink(pkg.localpath)\n                    exit_code = 1\n                    continue\n\n    my.closeRpmDB()\n    sys.exit(exit_code)\n\nif __name__ == \"__main__\":\n    main()\n"], "fixing_code": [".\\\" reposync\n.TH \"reposync\" \"1\" \"27 April 2007\" \"\" \"\"\n.SH \"NAME\"\nreposync \\- synchronize yum repositories to a local directory\n.SH \"SYNOPSIS\"\n\\fBreposync\\fP [options]\n.SH \"DESCRIPTION\"\n\\fBreposync\\fP is used to synchronize a remote yum repository to a local\ndirectory, using yum to retrieve the packages.\n.SH \"OPTIONS\"\n.IP \"\\fB\\-h, \\-\\-help\\fP\"\nDisplay a help message, and then quit.\n.IP \"\\fB\\-c CONFIG, \\-\\-config=CONFIG\\fP\"\nConfig file to use (defaults to /etc/yum.conf).\n.IP \"\\fB\\-a ARCH, \\-\\-arch=ARCH\\fP\"\nAct as if running the specified arch (default: current arch, note: does\nnot override $releasever. x86_64 is a superset for i*86.).\n.IP \"\\fB\\-\\-source\\fP\"\nAlso download .src.rpm files.\n.IP \"\\fB\\-r REPOID, \\-\\-repoid=REPOID\\fP\"\nSpecify repo ids to query, can be specified multiple times (default is\nall enabled).\n.IP \"\\fB\\-e\\ CACHEDIR, \\-\\-cachedir CACHEDIR\\fP\"\nDirectory in which to store metadata.\n.IP \"\\fB\\-t, \\-\\-tempcache\\fP\"\nUse a temp dir for storing/accessing yum-cache.\n.IP \"\\fB\\-d, \\-\\-delete\\fP\"\nDelete local packages no longer present in repository.\n.IP \"\\fB\\-p DESTDIR, \\-\\-download_path=DESTDIR\\fP\"\nPath to download packages to: defaults to current directory.\n.IP \"\\fB\\-\\-norepopath\\fP\"\nDon't add the reponame to the download path.\nCan only be used when syncing a single repository (default is\nto add the reponame).\n.IP \"\\fB\\-g, \\-\\-gpgcheck\\fP\"\nRemove packages that fail GPG signature checking after downloading.\nexit status is '1' if at least one package was removed.\n.IP \"\\fB\\-u, \\-\\-urls\\fP\"\nJust list urls of what would be downloaded, don't download.\n.IP \"\\fB\\-l, \\-\\-plugins\\fP\"\nEnable yum plugin support.\n.IP \"\\fB\\-m, \\-\\-downloadcomps\\fP\"\nAlso download comps.xml.\n.IP \"\\fB\\-\\-download-metadata\\fP\"\nDownload all the non-default metadata\n.IP \"\\fB\\-n, \\-\\-newest\\-only\\fP\"\nDownload only newest packages per-repo.\n.IP \"\\fB\\-q, \\-\\-quiet\\fP\"\nOutput as little information as possible.\n.IP \"\\fB\\-\\-allow-path-traversal\\fP\"\nAllow packages stored outside their repo directory to be synced.\nThese are packages that are referenced in metadata by using absolute paths or\nup-level \"..\" symbols, and are normally skipped by \\fBreposync\\fR for security\nreasons.\n\n\\fBCAUTION:\\fR Using this option has potential security implications since, by\nproviding malicious repodata, an attacker could make \\fBreposync\\fR write to\narbitrary locations on the file system that are accessible by the user running\nit.\n.SH \"EXAMPLES\"\n.IP \"Sync all packages from the 'updates' repo to the current directory:\"\n\\fB reposync \\-\\-repoid=updates\\fP\n.IP \"Sync only the newest packages from the 'updates' repo to the current directory:\"\n\\fB reposync \\-n \\-\\-repoid=updates\\fP\n.IP \"Sync packages from the 'updates' and 'extras' repos to the current directory:\"\n\\fB reposync \\-\\-repoid=updates \\-\\-repoid=extras\\fP\n.IP \"Sync all packages from the 'updates' repo to the \\fBrepos\\fP directory:\"\n\\fB reposync \\-p repos \\-\\-repoid=updates\\fP\n.IP \"Sync all packages from the 'updates' repo to the \\fBrepos\\fP directory excluding x86_64 arch. Edit \\fI/etc/yum.conf\\fR adding option \\fBexclude=*.x86_64\\fR. Then: \n\\fBreposync \\-p repos \\-\\-repoid=updates\\fP\n.SH \"FILES\"\n\\fBreposync\\fP uses the yum libraries for retrieving information and\npackages. If no configuration file is specified, the default yum\nconfiguration will be used.\n.PP\n.nf \n/etc/yum.conf\n/etc/yum/repos.d/\n.fi\n.SH \"SEE ALSO\"\n.nf\n.I yum.conf (5)\nhttp://yum.baseurl.org/\n.fi\n.SH \"AUTHORS\"\n.nf \nSee the Authors file included with this program.\n.fi\n\n.PP \n.SH \"BUGS\"\nThere are of course no bugs, but should you find any, you should first\nconsult the FAQ section on http://yum.baseurl.org/wiki/Faq and if unsuccessful\nin finding a resolution contact the mailing list: yum-devel@lists.baseurl.org.\nTo file a bug use http://bugzilla.redhat.com for Fedora/RHEL/Centos\nrelated bugs and http://yum.baseurl.org/report for all other bugs.\n\n.fi\n", "#!/usr/bin/python -tt\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software Foundation,\n# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n# copyright 2006 Duke University\n# author seth vidal\n\n# sync all or the newest packages from a repo to the local path\n# TODO:\n#     have it print out list of changes\n#     make it work with mirrorlists (silly, really)\n#     man page/more useful docs\n#     deal nicely with a package changing but not changing names (ie: replacement)\n\n# criteria\n# if a package is not the same and smaller then reget it\n# if a package is not the same and larger, delete it and get it again\n# always replace metadata files if they're not the same.\n\n\n\n\n\nimport os\nimport sys\nimport shutil\nimport stat\n\nfrom optparse import OptionParser\nfrom urlparse import urljoin\n\nfrom yumutils.i18n import _\n\nimport yum\nimport yum.Errors\nfrom yum.packageSack import ListPackageSack\nimport rpmUtils.arch\nimport logging\nfrom urlgrabber.progress import TextMeter, TextMultiFileMeter\nimport urlgrabber\n\nclass RepoSync(yum.YumBase):\n    def __init__(self, opts):\n        yum.YumBase.__init__(self)\n        self.logger = logging.getLogger('yum.verbose.reposync')\n        self.opts = opts\n\ndef localpkgs(directory):\n    names = os.listdir(directory)\n\n    cache = {}\n    for name in names:\n        fn = os.path.join(directory, name)\n        try:\n            st = os.lstat(fn)\n        except os.error:\n            continue\n        if stat.S_ISDIR(st.st_mode):\n            subcache = localpkgs(fn)\n            for pkg in subcache.keys():\n                cache[pkg] = subcache[pkg]\n        elif stat.S_ISREG(st.st_mode) and name.endswith(\".rpm\"):\n            cache[name] = {'path': fn, 'size': st.st_size, 'device': st.st_dev}\n    return cache\n\ndef is_subpath(path, root):\n    root = os.path.realpath(root)\n    path = os.path.realpath(os.path.join(root, path))\n    # join() is used below to ensure root ends with a slash\n    return path.startswith(os.path.join(root, ''))\n\ndef parseArgs():\n    usage = _(\"\"\"\n    Reposync is used to synchronize a remote yum repository to a local \n    directory using yum to retrieve the packages.\n    \n    %s [options]\n    \"\"\") % sys.argv[0]\n\n    parser = OptionParser(usage=usage)\n    parser.add_option(\"-c\", \"--config\", default='/etc/yum.conf',\n        help=_('config file to use (defaults to /etc/yum.conf)'))\n    parser.add_option(\"-a\", \"--arch\", default=None,\n        help=_('act as if running the specified arch (default: current arch, note: does not override $releasever. x86_64 is a superset for i*86.)'))\n    parser.add_option(\"--source\", default=False, dest=\"source\", action=\"store_true\",\n                      help=_('operate on source packages'))\n    parser.add_option(\"-r\", \"--repoid\", default=[], action='append',\n        help=_(\"specify repo ids to query, can be specified multiple times (default is all enabled)\"))\n    parser.add_option(\"-e\", \"--cachedir\",\n        help=_(\"directory in which to store metadata\"))\n    parser.add_option(\"-t\", \"--tempcache\", default=False, action=\"store_true\",\n        help=_(\"Use a temp dir for storing/accessing yum-cache\"))\n    parser.add_option(\"-d\", \"--delete\", default=False, action=\"store_true\",\n        help=_(\"delete local packages no longer present in repository\"))\n    parser.add_option(\"-p\", \"--download_path\", dest='destdir',\n        default=os.getcwd(), help=_(\"Path to download packages to: defaults to current dir\"))\n    parser.add_option(\"--norepopath\", dest='norepopath', default=False, action=\"store_true\",\n        help=_(\"Don't add the reponame to the download path. Can only be used when syncing a single repository (default is to add the reponame)\"))\n    parser.add_option(\"-g\", \"--gpgcheck\", default=False, action=\"store_true\",\n        help=_(\"Remove packages that fail GPG signature checking after downloading\"))\n    parser.add_option(\"-u\", \"--urls\", default=False, action=\"store_true\",\n        help=_(\"Just list urls of what would be downloaded, don't download\"))\n    parser.add_option(\"-n\", \"--newest-only\", dest='newest', default=False, action=\"store_true\",\n        help=_(\"Download only newest packages per-repo\"))\n    parser.add_option(\"-q\", \"--quiet\", default=False, action=\"store_true\",\n        help=_(\"Output as little as possible\"))\n    parser.add_option(\"-l\", \"--plugins\", default=False, action=\"store_true\",\n        help=_(\"enable yum plugin support\"))\n    parser.add_option(\"-m\", \"--downloadcomps\", default=False, action=\"store_true\",\n        help=_(\"also download comps.xml\"))\n    parser.add_option(\"\", \"--download-metadata\", dest=\"downloadmd\",\n        default=False, action=\"store_true\",\n        help=_(\"download all the non-default metadata\"))\n    parser.add_option(\"\", \"--allow-path-traversal\", default=False,\n        action=\"store_true\",\n        help=_(\"Allow packages stored outside their repo directory to be synced \"\n               \"(UNSAFE, USE WITH CAUTION!)\"))\n    (opts, args) = parser.parse_args()\n    return (opts, args)\n\n\ndef main():\n    (opts, dummy) = parseArgs()\n\n    if not os.path.exists(opts.destdir) and not opts.urls:\n        try:\n            os.makedirs(opts.destdir)\n        except OSError, e:\n            print >> sys.stderr, _(\"Error: Cannot create destination dir %s\") % opts.destdir\n            sys.exit(1)\n\n    if not os.access(opts.destdir, os.W_OK) and not opts.urls:\n        print >> sys.stderr, _(\"Error: Cannot write to  destination dir %s\") % opts.destdir\n        sys.exit(1)\n\n    my = RepoSync(opts=opts)\n    my.doConfigSetup(fn=opts.config, init_plugins=opts.plugins)\n\n    # Force unprivileged users to have a private temporary cachedir\n    # if they've not given an explicit cachedir\n    if os.getuid() != 0 and not opts.cachedir:\n        opts.tempcache = True\n\n    if opts.tempcache:\n        if not my.setCacheDir(force=True, reuse=False):\n            print >> sys.stderr, _(\"Error: Could not make cachedir, exiting\")\n            sys.exit(50)\n        my.conf.uid = 1 # force locking of user cache\n    elif opts.cachedir:\n        my.repos.setCacheDir(opts.cachedir)\n\n    # Lock if they've not given an explicit cachedir\n    if not opts.cachedir:\n        try:\n            my.doLock()\n        except yum.Errors.LockError, e:\n            print >> sys.stderr, _(\"Error: %s\") % e\n            sys.exit(50)\n\n    #  Use progress bar display when downloading repo metadata\n    # and package files ... needs to be setup before .repos (ie. RHN/etc.).\n    if not opts.quiet:\n        my.repos.setProgressBar(TextMeter(fo=sys.stdout), TextMultiFileMeter(fo=sys.stdout))\n    my.doRepoSetup()\n\n    if len(opts.repoid) > 0:\n        myrepos = []\n\n        # find the ones we want\n        for glob in opts.repoid:\n            add_repos = my.repos.findRepos(glob)\n            if not add_repos:\n                print >> sys.stderr, _(\"Warning: cannot find repository %s\") % glob\n                continue\n            myrepos.extend(add_repos)\n\n        if not myrepos:\n            print >> sys.stderr, _(\"No repositories found\")\n            sys.exit(1)\n\n        # disable them all\n        for repo in my.repos.repos.values():\n            repo.disable()\n\n        # enable the ones we like\n        for repo in myrepos:\n            repo.enable()\n\n    # --norepopath can only be sensibly used with a single repository:\n    if len(my.repos.listEnabled()) > 1 and opts.norepopath:\n        print >> sys.stderr, _(\"Error: Can't use --norepopath with multiple repositories\")\n        sys.exit(1)\n\n    try:\n        arches = rpmUtils.arch.getArchList(opts.arch)\n        if opts.source:\n            arches += ['src']\n        my.doSackSetup(arches)\n    except yum.Errors.RepoError, e:\n        print >> sys.stderr, _(\"Error setting up repositories: %s\") % e\n        # maybe this shouldn't be entirely fatal\n        sys.exit(1)\n\n    exit_code = 0\n    for repo in my.repos.listEnabled():\n        reposack = ListPackageSack(my.pkgSack.returnPackages(repoid=repo.id))\n\n        if opts.newest:\n            download_list = reposack.returnNewestByNameArch()\n        else:\n            download_list = list(reposack)\n\n        if opts.norepopath:\n            local_repo_path = opts.destdir\n        else:\n            local_repo_path = opts.destdir + '/' + repo.id\n\n        # Ensure we don't traverse out of local_repo_path by dropping any\n        # packages whose remote_path is absolute or contains up-level\n        # references (unless explicitly allowed).\n        # See RHBZ#1600221 for details.\n        if not opts.allow_path_traversal:\n            newlist = []\n            skipped = False\n            for pkg in download_list:\n                if is_subpath(pkg.remote_path, local_repo_path):\n                    newlist.append(pkg)\n                    continue\n                my.logger.warning(\n                    _('WARNING: skipping package %s: remote path \"%s\" not '\n                      'within repodir, unsafe to mirror locally')\n                    % (pkg, pkg.remote_path)\n                )\n                skipped = True\n            if skipped:\n                my.logger.info(\n                    _('You can enable unsafe remote paths by using '\n                      '--allow-path-traversal (see reposync(1) for details)')\n                )\n            download_list = newlist\n\n        if opts.delete and os.path.exists(local_repo_path):\n            current_pkgs = localpkgs(local_repo_path)\n\n            download_set = {}\n            for pkg in download_list:\n                rpmname = os.path.basename(pkg.remote_path)\n                download_set[rpmname] = 1\n\n            for pkg in current_pkgs:\n                if pkg in download_set:\n                    continue\n\n                if not opts.quiet:\n                    my.logger.info(\"Removing obsolete %s\", pkg)\n                os.unlink(current_pkgs[pkg]['path'])\n\n        if opts.downloadcomps or opts.downloadmd:\n\n            if not os.path.exists(local_repo_path):\n                try:\n                    os.makedirs(local_repo_path)\n                except IOError, e:\n                    my.logger.error(\"Could not make repo subdir: %s\" % e)\n                    my.closeRpmDB()\n                    sys.exit(1)\n\n            if opts.downloadcomps:\n                wanted_types = ['group']\n\n            if opts.downloadmd:\n                wanted_types = repo.repoXML.fileTypes()\n\n            for ftype in repo.repoXML.fileTypes():\n                if ftype in ['primary', 'primary_db', 'filelists',\n                             'filelists_db', 'other', 'other_db']:\n                    continue\n                if ftype not in wanted_types:\n                    continue\n\n                try:\n                    resultfile = repo.retrieveMD(ftype)\n                    basename = os.path.basename(resultfile)\n                    if ftype == 'group' and opts.downloadcomps: # for compat with how --downloadcomps saved the comps file always as comps.xml\n                        basename = 'comps.xml'\n                    shutil.copyfile(resultfile, \"%s/%s\" % (local_repo_path, basename))\n                except yum.Errors.RepoMDError, e:\n                    if not opts.quiet:\n                        my.logger.error(\"Unable to fetch metadata: %s\" % e)\n\n        remote_size = 0\n        if not opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                sz = int(pkg.returnSimple('packagesize'))\n                if os.path.exists(local) and os.path.getsize(local) == sz:\n                    continue\n                remote_size += sz\n\n        if hasattr(urlgrabber.progress, 'text_meter_total_size'):\n            urlgrabber.progress.text_meter_total_size(remote_size)\n\n        download_list.sort(key=lambda pkg: pkg.name)\n        if opts.urls:\n            for pkg in download_list:\n                local = os.path.join(local_repo_path, pkg.remote_path)\n                if not (os.path.exists(local) and my.verifyPkg(local, pkg, False)):\n                    print urljoin(pkg.repo.urls[0], pkg.remote_path)\n            continue\n\n        # create dest dir\n        if not os.path.exists(local_repo_path):\n            os.makedirs(local_repo_path)\n\n        # set localpaths\n        for pkg in download_list:\n            pkg.localpath = os.path.join(local_repo_path, pkg.remote_path)\n            pkg.repo.copy_local = True\n            pkg.repo.cache = 0\n            localdir = os.path.dirname(pkg.localpath)\n            if not os.path.exists(localdir):\n                os.makedirs(localdir)\n\n        # use downloader from YumBase\n        probs = my.downloadPkgs(download_list)\n        if probs:\n            exit_code = 1\n            for key in probs:\n                for error in probs[key]:\n                    my.logger.error('%s: %s', key, error)\n\n        if opts.gpgcheck:\n            for pkg in download_list:\n                result, error = my.sigCheckPkg(pkg)\n                if result != 0:\n                    rpmfn = os.path.basename(pkg.remote_path)\n                    if result == 1:\n                        my.logger.warning('Removing %s, due to missing GPG key.' % rpmfn)\n                    elif result == 2:\n                        my.logger.warning('Removing %s due to failed signature check.' % rpmfn)\n                    else:\n                        my.logger.warning('Removing %s due to failed signature check: %s' % rpmfn)\n                    os.unlink(pkg.localpath)\n                    exit_code = 1\n                    continue\n\n    my.closeRpmDB()\n    sys.exit(exit_code)\n\nif __name__ == \"__main__\":\n    main()\n"], "filenames": ["docs/reposync.1", "reposync.py"], "buggy_code_start_loc": [49, 75], "buggy_code_end_loc": [49, 217], "fixing_code_start_loc": [50, 76], "fixing_code_end_loc": [60, 252], "type": "CWE-59", "message": "A directory traversal issue was found in reposync, a part of yum-utils, where reposync fails to sanitize paths in remote repository configuration files. If an attacker controls a repository, they may be able to copy files outside of the destination directory on the targeted system via path traversal. If reposync is running with heightened privileges on a targeted system, this flaw could potentially result in system compromise via the overwriting of critical system files. Version 1.1.31 and older are believed to be affected.", "other": {"cve": {"id": "CVE-2018-10897", "sourceIdentifier": "secalert@redhat.com", "published": "2018-08-01T17:29:00.457", "lastModified": "2023-02-13T04:51:38.040", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A directory traversal issue was found in reposync, a part of yum-utils, where reposync fails to sanitize paths in remote repository configuration files. If an attacker controls a repository, they may be able to copy files outside of the destination directory on the targeted system via path traversal. If reposync is running with heightened privileges on a targeted system, this flaw could potentially result in system compromise via the overwriting of critical system files. Version 1.1.31 and older are believed to be affected."}, {"lang": "es", "value": "Se ha detectado un problema de salto de directorio en reposync, de yum-utils, en el que reposync falla a la hora de sanear rutas en los archivos de configuraci\u00f3n del repositorio remoto. Si un atacante controla un repositorio, podr\u00eda ser capaz de copiar archivos fuera del directorio de destino en el sistema objetivo mediante un salto de directorio. Si reposync se est\u00e1 ejecutando con privilegios elevados en un sistema objetivo, este error podr\u00eda resultar en el compromiso del sistema mediante la sobrescritura de archivos cr\u00edticos del sistema. Se cree que la versi\u00f3n 1.1.31 y anteriores se han visto afectadas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rpm:yum-utils:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.31", "matchCriteriaId": "0AB5E5F6-450C-431C-8099-C545861AFC29"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:virtualization:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6BBD7A51-0590-4DDF-8249-5AFA8D645CB6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://www.securitytracker.com/id/1041594", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2284", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2285", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2626", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2018-10897", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/yum-utils/commit/6a8de061f8fdc885e74ebe8c94625bf53643b71c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/yum-utils/commit/7554c0133eb830a71dc01846037cc047d0acbc2c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rpm-software-management/yum-utils/pull/43", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://help.ecostruxureit.com/display/public/UADCE725/Security+fixes+in+StruxureWare+Data+Center+Expert+v7.6.0", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rpm-software-management/yum-utils/commit/6a8de061f8fdc885e74ebe8c94625bf53643b71c"}}