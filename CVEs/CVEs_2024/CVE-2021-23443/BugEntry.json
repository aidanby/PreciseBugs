{"buggy_code": ["/**\n * edge\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Token, TagToken } from 'edge-lexer'\nimport { MacroableConstructorContract } from 'macroable'\nimport { ParserTagDefinitionContract, Parser, EdgeBuffer, ClaimTagFn } from 'edge-parser'\n\n/**\n * The shape in which the loader must resolve the template\n */\nexport type LoaderTemplate = {\n  template: string\n}\n\n/**\n * Loader contract that every loader must adheres to.\n */\nexport interface LoaderContract {\n  /**\n   * List of mounted disks\n   */\n  mounted: { [diskName: string]: string }\n\n  /**\n   * List of pre-registered template\n   */\n  templates: { [templatePath: string]: LoaderTemplate }\n\n  /**\n   * Save disk name and dirPath to resolve views\n   */\n  mount(diskName: string, dirPath: string): void\n\n  /**\n   * Remove disk from the previously saved paths\n   */\n  unmount(diskName: string): void\n\n  /**\n   * Resolve template contents\n   */\n  resolve(templatePath: string): LoaderTemplate\n\n  /**\n   * Make absolute path to a template\n   */\n  makePath(templatePath: string): string\n\n  /**\n   * Register in memory template and presenter\n   */\n  register(templatePath: string, contents: LoaderTemplate): void\n\n  /**\n   * Remove the pre-registered template\n   */\n  remove(templatePath: string): void\n}\n\n/**\n * Shape of template constructor\n */\nexport interface TemplateConstructorContract\n  extends MacroableConstructorContract<TemplateContract> {\n  new (\n    compiler: CompilerContract,\n    globals: any,\n    locals: any,\n    processor: ProcessorContract\n  ): TemplateContract\n}\n\n/**\n * The tag must have a tagName along with other properties\n * required by lexer and parser\n */\nexport interface TagContract extends ParserTagDefinitionContract {\n  tagName: string\n  boot?(template: TemplateConstructorContract): void\n}\n\n/**\n * Shape of required tags\n */\nexport type TagsContract = {\n  [tagName: string]: TagContract\n}\n\n/**\n * Shape of the cache manager\n */\nexport interface CacheManagerContract {\n  enabled: boolean\n  get(templatePath: string): undefined | LoaderTemplate\n  set(templatePath: string, compiledOutput: LoaderTemplate): void\n  has(templatePath: string): boolean\n  delete(templatePath: string): void\n}\n\n/**\n * Compiler constructor options\n */\nexport type CompilerOptions = {\n  cache?: boolean\n  async?: boolean\n}\n\n/**\n * Shape of the compiler\n */\nexport interface CompilerContract {\n  cacheManager: CacheManagerContract\n  async: boolean\n  claimTag(fn: ClaimTagFn): this\n  compile(templatePath: string, localVariables?: string[]): LoaderTemplate\n  tokenize(templatePath: string, parser?: Parser): Token[]\n\n  /**\n   * Compile the raw string as a template\n   */\n  compileRaw(contents: string, templatePath?: string): LoaderTemplate\n\n  /**\n   * Tokenize the raw string as a template\n   */\n  tokenizeRaw(contents: string, templatePath?: string, parser?: Parser): Token[]\n}\n\n/**\n * Shape of the props class passed to the components\n */\nexport interface PropsContract {\n  /**\n   * Find if a key exists inside the props\n   */\n  has(key: string): boolean\n\n  /**\n   * Return values for only the given keys\n   */\n  only(keys: string[]): { [key: string]: any }\n\n  /**\n   * Return values except the given keys\n   */\n  except(keys: string[]): { [key: string]: any }\n\n  /**\n   * Serialize all props to a string of HTML attributes\n   */\n  serialize(mergeProps?: any): { value: string }\n\n  /**\n   * Serialize only the given keys to a string of HTML attributes\n   */\n  serializeOnly(keys: string[], mergeProps?: any): { value: string }\n\n  /**\n   * Serialize except the given keys to a string of HTML attributes\n   */\n  serializeExcept(keys: string[], mergeProps?: any): { value: string }\n}\n\n/**\n * Shape of the template contract\n */\nexport interface TemplateContract {\n  /**\n   * Compiles partial\n   */\n  compilePartial(templatePath: string, ...localVariables: string[]): Function\n\n  /**\n   * Compiles a component\n   */\n  compileComponent(templatePath: string, ...localVariables: string[]): string\n\n  /**\n   * Returns the state for a component\n   */\n  getComponentState(\n    props: { [key: string]: any },\n    slots: { [key: string]: any },\n    caller: { filename: string; line: number; col: number }\n  ): {\n    $props: PropsContract & { [key: string]: any }\n    $slots: { [key: string]: any }\n    $caller: { filename: string; line: number; col: number }\n  }\n\n  /**\n   * Renders a template to a string\n   */\n  render<T extends Promise<string> | string>(template: string, state: any): T\n  renderRaw<T extends Promise<string> | string>(\n    contents: string,\n    state: any,\n    templatePath?: string\n  ): T\n\n  /**\n   * Escape input\n   */\n  escape<T>(input: T): T\n\n  /**\n   * Rethrow exceptions by pointing back to edge source file and line number\n   */\n  reThrow(error: any, filename: string, line: number): never\n}\n\n/**\n * Shape of the renderer that renders the edge templates\n */\nexport interface EdgeRendererContract {\n  /**\n   * Share state with the template and its partials and component\n   */\n  share(locals: any): this\n\n  /**\n   * Render a template asynchronously\n   */\n  render(templatePath: string, state?: any): Promise<string>\n  renderRaw(contents: string, state?: any, templatePath?: string): Promise<string>\n\n  /**\n   * Render a template synchronously\n   */\n  renderSync(templatePath: string, state?: any): string\n  renderRawSync(contents: string, state?: any, templatePath?: string): string\n}\n\n/**\n * The processor is used to execute process functions for different\n * lifecycles\n */\nexport interface ProcessorContract {\n  /**\n   * Hook into the raw text to modify its contents. Make sure to return the\n   * new string back or return \"void\" in case no modifications have been\n   * performed\n   */\n  process(event: 'raw', handler: (data: { raw: string; path: string }) => string | void): this\n\n  /**\n   * Hook into the tag node to modify its properties\n   */\n  process(event: 'tag', handler: (data: { tag: TagToken; path: string }) => void): this\n\n  /**\n   * Hook into the compiled template to modify its contents. Make sure to return the\n   * new string back or return \"void\" in case no modifications have been\n   * performed\n   */\n  process(\n    event: 'compiled',\n    handler: (data: { compiled: string; path: string }) => string | void\n  ): this\n\n  /**\n   * Hook into the compiled output to modify its contents. Make sure to return the\n   * new string back or return \"void\" in case no modifications have been\n   * performed\n   */\n  process(\n    event: 'output',\n    handler: (data: { output: string; template: TemplateContract }) => string | void\n  ): this\n}\n\n/**\n * Shape of options that can be passed to the\n * edge constructor\n */\nexport type EdgeOptions = {\n  loader?: LoaderContract\n  cache?: boolean\n}\n\n/**\n * Shape of the main module\n */\nexport interface EdgeContract {\n  /**\n   * Loader for loading templates. You can also define a custom loader when creating\n   * a new instance of edge\n   */\n  loader: LoaderContract\n\n  /**\n   * Compiler to be used for compiling synchronously\n   */\n  compiler: CompilerContract\n\n  /**\n   * Compiler to be used for compiling asynchronously\n   */\n  asyncCompiler: CompilerContract\n\n  /**\n   * Processor reference to hook into the compile and the rendering\n   * phase of templates\n   */\n  processor: ProcessorContract\n\n  /**\n   * Set of registered globals. One can define custom globals using `edge.global`\n   * method\n   */\n  GLOBALS: { [key: string]: any }\n\n  /**\n   * A custom set of registered tags. One can define a custom tag using `edge.registerTag`\n   * method\n   */\n  tags: { [name: string]: TagContract }\n\n  /**\n   * Register a plugin. Plugins are lazily invoked just before the views are rendered. This\n   * ensures that plugins will receive a fully configured edge instance.\n   *\n   * Also plugins are invoked only once. Unless, the `options.recurring` value is set\n   */\n  use<T extends any>(\n    pluginFn: (edge: this, firstRun: boolean, options: T) => void,\n    options?: T\n  ): this\n\n  /**\n   * Register a custom tag\n   */\n  registerTag(tag: TagContract): this\n\n  /**\n   * Register an inline template\n   */\n  registerTemplate(templatePath: string, contents: LoaderTemplate): this\n\n  /**\n   * Remove the template registered using the \"registerTemplate\" method\n   */\n  removeTemplate(templatePath: string): this\n\n  /**\n   * Register a global value\n   */\n  global(key: string, value: any): this\n\n  /**\n   * Mount/disk\n   */\n  mount(diskName: string): this\n  mount(diskName: string, dirPath: string): this\n\n  /**\n   * Unmount disk\n   */\n  unmount(diskName: string): this\n\n  /**\n   * Get a renderer instance to render templates\n   */\n  getRenderer(): EdgeRendererContract\n\n  /**\n   * Creates a renderer instances and shares the locals with it\n   */\n  share(locals: any): EdgeRendererContract\n\n  /**\n   * Render a template asynchronously\n   */\n  render(templatePath: string, state?: any): Promise<string>\n  renderRaw(contents: string, state?: any, templatePath?: string): Promise<string>\n\n  /**\n   * Render a template synchronously\n   */\n  renderSync(templatePath: string, state?: any): string\n  renderRawSync(contents: string, state?: any, templatePath?: string): string\n}\n\n/**\n * Required for someone creating custom tags\n */\nexport type EdgeBufferContract = EdgeBuffer\nexport type ParserContract = Parser\nexport type TagTokenContract = TagToken\nexport { ClaimTagFn }\n", "/*\n * edge\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Macroable } from 'macroable'\nimport { EdgeError } from 'edge-error'\nimport { lodash } from '@poppinss/utils'\nimport { string } from '@poppinss/utils/build/helpers'\n\nimport { Processor } from '../Processor'\nimport { Props } from '../Component/Props'\nimport { CompilerContract, TemplateContract } from '../Contracts'\n\n/**\n * An instance of this class passed to the escape\n * method ensures that underlying value is never\n * escaped.\n */\nexport class SafeValue {\n  constructor(public value: any) {}\n}\n\n/**\n * Escapes a given string\n */\nexport function escape<T>(input: T): T extends SafeValue ? T['value'] : T {\n  return typeof input === 'string'\n    ? string.escapeHTML(input)\n    : input instanceof SafeValue\n    ? input.value\n    : input\n}\n\n/**\n * Mark value as safe and not to be escaped\n */\nexport function safeValue(value: string) {\n  return new SafeValue(value)\n}\n\n/**\n * The template is used to compile and run templates. Also the instance\n * of template is passed during runtime to render `dynamic partials`\n * and `dynamic components`.\n */\nexport class Template extends Macroable implements TemplateContract {\n  /**\n   * Required by Macroable\n   */\n  protected static macros = {}\n  protected static getters = {}\n\n  /**\n   * The shared state is used to hold the globals and locals,\n   * since it is shared with components too.\n   */\n  private sharedState: any\n\n  constructor(\n    private compiler: CompilerContract,\n    globals: any,\n    locals: any,\n    private processor: Processor\n  ) {\n    super()\n    this.sharedState = lodash.merge({}, globals, locals)\n  }\n\n  /**\n   * Wraps template to a function\n   */\n  private wrapToFunction(template: string, ...localVariables: string[]) {\n    const args = ['template', 'state', '$context'].concat(localVariables)\n\n    if (this.compiler.async) {\n      return new Function(\n        '',\n        `return async function template (${args.join(',')}) { ${template} }`\n      )()\n    }\n\n    return new Function('', `return function template (${args.join(',')}) { ${template} }`)()\n  }\n\n  /**\n   * Trims top and bottom new lines from the content\n   */\n  private trimTopBottomNewLines(value: string) {\n    return value.replace(/^\\n|^\\r\\n/, '').replace(/\\n$|\\r\\n$/, '')\n  }\n\n  /**\n   * Render a compiled template with state\n   */\n  private renderCompiled(compiledTemplate: string, state: any) {\n    const templateState = Object.assign({}, this.sharedState, state)\n    const $context = {}\n\n    /**\n     * Process template as a promise.\n     */\n    if (this.compiler.async) {\n      return this.wrapToFunction(compiledTemplate)(this, templateState, $context).then(\n        (output: string) => {\n          output = this.trimTopBottomNewLines(output)\n          return this.processor.executeOutput({ output, template: this })\n        }\n      )\n    }\n\n    const output = this.trimTopBottomNewLines(\n      this.wrapToFunction(compiledTemplate)(this, templateState, $context)\n    )\n\n    return this.processor.executeOutput({ output, template: this })\n  }\n\n  /**\n   * Render a partial\n   *\n   * ```js\n   * const partialFn = template.compilePartial('includes/user')\n   *\n   * // render and use output\n   * partialFn(template, state, ctx)\n   * ```\n   */\n  public compilePartial(templatePath: string, ...localVariables: string[]): Function {\n    const { template: compiledTemplate } = this.compiler.compile(templatePath, localVariables)\n    return this.wrapToFunction(compiledTemplate, ...localVariables)\n  }\n\n  /**\n   * Render a component\n   *\n   * ```js\n   * const componentFn = template.compileComponent('components/button')\n   *\n   * // render and use output\n   * componentFn(template, template.getComponentState(props, slots, caller), ctx)\n   * ```\n   */\n  public compileComponent(templatePath: string, ...localVariables: string[]): string {\n    const { template: compiledTemplate } = this.compiler.compile(templatePath, localVariables)\n    return this.wrapToFunction(compiledTemplate, ...localVariables)\n  }\n\n  /**\n   * Returns the isolated state for a given component\n   */\n  public getComponentState(\n    props: { [key: string]: any },\n    slots: { [key: string]: any },\n    caller: { filename: string; line: number; col: number }\n  ) {\n    return Object.assign({}, this.sharedState, props, {\n      $slots: slots,\n      $caller: caller,\n      $props: new Props(props),\n    })\n  }\n\n  /**\n   * Render a template with it's state.\n   *\n   * ```js\n   * template.render('welcome', { key: 'value' })\n   * ```\n   */\n  public render<T extends Promise<string> | string>(template: string, state: any): T {\n    let { template: compiledTemplate } = this.compiler.compile(template)\n    return this.renderCompiled(compiledTemplate, state)\n  }\n\n  /**\n   * Render template from a raw string\n   *\n   * ```js\n   * template.renderRaw('Hello {{ username }}', { username: 'virk' })\n   * ```\n   */\n  public renderRaw<T extends Promise<string> | string>(\n    contents: string,\n    state: any,\n    templatePath?: string\n  ): T {\n    let { template: compiledTemplate } = this.compiler.compileRaw(contents, templatePath)\n    return this.renderCompiled(compiledTemplate, state)\n  }\n\n  /**\n   * Escapes the value to be HTML safe. Only strings are escaped\n   * and rest all values will be returned as it is.\n   */\n  public escape<T>(input: T): T extends SafeValue ? T['value'] : T {\n    return escape(input)\n  }\n\n  /**\n   * Raise an error\n   */\n  public newError(errorMessage: string, filename: string, lineNumber: number, column: number) {\n    throw new EdgeError(errorMessage, 'E_RUNTIME_EXCEPTION', {\n      filename: filename,\n      line: lineNumber,\n      col: column,\n    })\n  }\n\n  /**\n   * Rethrows the runtime exception by re-constructing the error message\n   * to point back to the original filename\n   */\n  public reThrow(error: any, filename: string, lineNumber: number): never {\n    if (error instanceof EdgeError) {\n      throw error\n    }\n\n    const message = error.message.replace(/state\\./, '')\n    throw new EdgeError(message, 'E_RUNTIME_EXCEPTION', {\n      filename: filename,\n      line: lineNumber,\n      col: 0,\n    })\n  }\n}\n", "/*\n * edge\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport test from 'japa'\nimport { join } from 'path'\nimport { Filesystem } from '@poppinss/dev-utils'\n\nimport { Loader } from '../src/Loader'\nimport { Compiler } from '../src/Compiler'\nimport { slotTag } from '../src/Tags/Slot'\nimport { Processor } from '../src/Processor'\nimport { includeTag } from '../src/Tags/Include'\nimport { componentTag } from '../src/Tags/Component'\nimport { Template, safeValue } from '../src/Template'\n\nimport './assert-extend'\n\nconst tags = { slot: slotTag, component: componentTag, include: includeTag }\nconst fs = new Filesystem(join(__dirname, 'views'))\n\nconst loader = new Loader()\nloader.mount('default', fs.basePath)\n\ntest.group('Template', (group) => {\n  group.afterEach(async () => {\n    await fs.cleanup()\n    Template.hydrate()\n  })\n\n  test('run template using the given state', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ username }}')\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const output = new Template(compiler, {}, {}, processor).render('foo', {\n      username: 'virk',\n    }) as string\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('run template with shared state', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ getUsername() }}')\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n\n    const output = new Template(\n      compiler,\n      { username: 'virk' },\n      {\n        getUsername() {\n          return this.username.toUpperCase()\n        },\n      },\n      processor\n    ).render('foo', {}) as string\n    assert.equal(output.trim(), 'Hello VIRK')\n  })\n\n  test('run partial inside existing state', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ username }}')\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const output = template.compilePartial('foo')(template, { username: 'virk' })\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('pass local variables to inline templates', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.compilePartial('foo', 'user')(template, {}, {}, user)\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('process file names starting with u', async (assert) => {\n    await fs.add('users.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.render('users', { user }) as string\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('execute output processor function', async (assert) => {\n    assert.plan(3)\n    await fs.add('users.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    processor.process('output', ({ output, template }) => {\n      assert.stringEqual(output, 'Hello virk')\n      assert.instanceOf(template, Template)\n    })\n\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.render('users', { user }) as string\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('use return value of the output processor function', async (assert) => {\n    assert.plan(3)\n    await fs.add('users.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    processor.process('output', ({ output, template }) => {\n      assert.stringEqual(output, 'Hello virk')\n      assert.instanceOf(template, Template)\n      return output.toUpperCase()\n    })\n\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.render('users', { user }) as string\n    assert.equal(output.trim(), 'HELLO VIRK')\n  })\n\n  test('escape HTML', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape('<h2> Hello world </h2>'), '&lt;h2&gt; Hello world &lt;/h2&gt;')\n  })\n\n  test('do not escape values, which are not string', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape(22), 22)\n  })\n\n  test('do not escape values, which instance of safe value', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape(safeValue('<h2> Hello world </h2>')), '<h2> Hello world </h2>')\n  })\n\n  test('add macros to context', (assert) => {\n    Template.macro('upper', (username) => {\n      return username.toUpperCase()\n    })\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template['upper']('virk'), 'VIRK')\n  })\n\n  test('add getters to context', (assert) => {\n    Template.getter('username', function username() {\n      return 'virk'\n    })\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template['username'], 'virk')\n  })\n})\n"], "fixing_code": ["/**\n * edge\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Token, TagToken } from 'edge-lexer'\nimport { MacroableConstructorContract } from 'macroable'\nimport { ParserTagDefinitionContract, Parser, EdgeBuffer, ClaimTagFn } from 'edge-parser'\n\n/**\n * The shape in which the loader must resolve the template\n */\nexport type LoaderTemplate = {\n  template: string\n}\n\n/**\n * Loader contract that every loader must adheres to.\n */\nexport interface LoaderContract {\n  /**\n   * List of mounted disks\n   */\n  mounted: { [diskName: string]: string }\n\n  /**\n   * List of pre-registered template\n   */\n  templates: { [templatePath: string]: LoaderTemplate }\n\n  /**\n   * Save disk name and dirPath to resolve views\n   */\n  mount(diskName: string, dirPath: string): void\n\n  /**\n   * Remove disk from the previously saved paths\n   */\n  unmount(diskName: string): void\n\n  /**\n   * Resolve template contents\n   */\n  resolve(templatePath: string): LoaderTemplate\n\n  /**\n   * Make absolute path to a template\n   */\n  makePath(templatePath: string): string\n\n  /**\n   * Register in memory template and presenter\n   */\n  register(templatePath: string, contents: LoaderTemplate): void\n\n  /**\n   * Remove the pre-registered template\n   */\n  remove(templatePath: string): void\n}\n\n/**\n * Shape of template constructor\n */\nexport interface TemplateConstructorContract\n  extends MacroableConstructorContract<TemplateContract> {\n  new (\n    compiler: CompilerContract,\n    globals: any,\n    locals: any,\n    processor: ProcessorContract\n  ): TemplateContract\n}\n\n/**\n * The tag must have a tagName along with other properties\n * required by lexer and parser\n */\nexport interface TagContract extends ParserTagDefinitionContract {\n  tagName: string\n  boot?(template: TemplateConstructorContract): void\n}\n\n/**\n * Shape of required tags\n */\nexport type TagsContract = {\n  [tagName: string]: TagContract\n}\n\n/**\n * Shape of the cache manager\n */\nexport interface CacheManagerContract {\n  enabled: boolean\n  get(templatePath: string): undefined | LoaderTemplate\n  set(templatePath: string, compiledOutput: LoaderTemplate): void\n  has(templatePath: string): boolean\n  delete(templatePath: string): void\n}\n\n/**\n * Compiler constructor options\n */\nexport type CompilerOptions = {\n  cache?: boolean\n  async?: boolean\n}\n\n/**\n * Shape of the compiler\n */\nexport interface CompilerContract {\n  cacheManager: CacheManagerContract\n  async: boolean\n  claimTag(fn: ClaimTagFn): this\n  compile(templatePath: string, localVariables?: string[]): LoaderTemplate\n  tokenize(templatePath: string, parser?: Parser): Token[]\n\n  /**\n   * Compile the raw string as a template\n   */\n  compileRaw(contents: string, templatePath?: string): LoaderTemplate\n\n  /**\n   * Tokenize the raw string as a template\n   */\n  tokenizeRaw(contents: string, templatePath?: string, parser?: Parser): Token[]\n}\n\n/**\n * Shape of the props class passed to the components\n */\nexport interface PropsContract {\n  /**\n   * Find if a key exists inside the props\n   */\n  has(key: string): boolean\n\n  /**\n   * Return values for only the given keys\n   */\n  only(keys: string[]): { [key: string]: any }\n\n  /**\n   * Return values except the given keys\n   */\n  except(keys: string[]): { [key: string]: any }\n\n  /**\n   * Serialize all props to a string of HTML attributes\n   */\n  serialize(mergeProps?: any): { value: string }\n\n  /**\n   * Serialize only the given keys to a string of HTML attributes\n   */\n  serializeOnly(keys: string[], mergeProps?: any): { value: string }\n\n  /**\n   * Serialize except the given keys to a string of HTML attributes\n   */\n  serializeExcept(keys: string[], mergeProps?: any): { value: string }\n}\n\n/**\n * Shape of the template contract\n */\nexport interface TemplateContract {\n  /**\n   * Compiles partial\n   */\n  compilePartial(templatePath: string, ...localVariables: string[]): Function\n\n  /**\n   * Compiles a component\n   */\n  compileComponent(templatePath: string, ...localVariables: string[]): string\n\n  /**\n   * Returns the state for a component\n   */\n  getComponentState(\n    props: { [key: string]: any },\n    slots: { [key: string]: any },\n    caller: { filename: string; line: number; col: number }\n  ): {\n    $props: PropsContract & { [key: string]: any }\n    $slots: { [key: string]: any }\n    $caller: { filename: string; line: number; col: number }\n  }\n\n  /**\n   * Renders a template to a string\n   */\n  render<T extends Promise<string> | string>(template: string, state: any): T\n  renderRaw<T extends Promise<string> | string>(\n    contents: string,\n    state: any,\n    templatePath?: string\n  ): T\n\n  /**\n   * Escape input\n   */\n  escape(input: any): string\n\n  /**\n   * Rethrow exceptions by pointing back to edge source file and line number\n   */\n  reThrow(error: any, filename: string, line: number): never\n}\n\n/**\n * Shape of the renderer that renders the edge templates\n */\nexport interface EdgeRendererContract {\n  /**\n   * Share state with the template and its partials and component\n   */\n  share(locals: any): this\n\n  /**\n   * Render a template asynchronously\n   */\n  render(templatePath: string, state?: any): Promise<string>\n  renderRaw(contents: string, state?: any, templatePath?: string): Promise<string>\n\n  /**\n   * Render a template synchronously\n   */\n  renderSync(templatePath: string, state?: any): string\n  renderRawSync(contents: string, state?: any, templatePath?: string): string\n}\n\n/**\n * The processor is used to execute process functions for different\n * lifecycles\n */\nexport interface ProcessorContract {\n  /**\n   * Hook into the raw text to modify its contents. Make sure to return the\n   * new string back or return \"void\" in case no modifications have been\n   * performed\n   */\n  process(event: 'raw', handler: (data: { raw: string; path: string }) => string | void): this\n\n  /**\n   * Hook into the tag node to modify its properties\n   */\n  process(event: 'tag', handler: (data: { tag: TagToken; path: string }) => void): this\n\n  /**\n   * Hook into the compiled template to modify its contents. Make sure to return the\n   * new string back or return \"void\" in case no modifications have been\n   * performed\n   */\n  process(\n    event: 'compiled',\n    handler: (data: { compiled: string; path: string }) => string | void\n  ): this\n\n  /**\n   * Hook into the compiled output to modify its contents. Make sure to return the\n   * new string back or return \"void\" in case no modifications have been\n   * performed\n   */\n  process(\n    event: 'output',\n    handler: (data: { output: string; template: TemplateContract }) => string | void\n  ): this\n}\n\n/**\n * Shape of options that can be passed to the\n * edge constructor\n */\nexport type EdgeOptions = {\n  loader?: LoaderContract\n  cache?: boolean\n}\n\n/**\n * Shape of the main module\n */\nexport interface EdgeContract {\n  /**\n   * Loader for loading templates. You can also define a custom loader when creating\n   * a new instance of edge\n   */\n  loader: LoaderContract\n\n  /**\n   * Compiler to be used for compiling synchronously\n   */\n  compiler: CompilerContract\n\n  /**\n   * Compiler to be used for compiling asynchronously\n   */\n  asyncCompiler: CompilerContract\n\n  /**\n   * Processor reference to hook into the compile and the rendering\n   * phase of templates\n   */\n  processor: ProcessorContract\n\n  /**\n   * Set of registered globals. One can define custom globals using `edge.global`\n   * method\n   */\n  GLOBALS: { [key: string]: any }\n\n  /**\n   * A custom set of registered tags. One can define a custom tag using `edge.registerTag`\n   * method\n   */\n  tags: { [name: string]: TagContract }\n\n  /**\n   * Register a plugin. Plugins are lazily invoked just before the views are rendered. This\n   * ensures that plugins will receive a fully configured edge instance.\n   *\n   * Also plugins are invoked only once. Unless, the `options.recurring` value is set\n   */\n  use<T extends any>(\n    pluginFn: (edge: this, firstRun: boolean, options: T) => void,\n    options?: T\n  ): this\n\n  /**\n   * Register a custom tag\n   */\n  registerTag(tag: TagContract): this\n\n  /**\n   * Register an inline template\n   */\n  registerTemplate(templatePath: string, contents: LoaderTemplate): this\n\n  /**\n   * Remove the template registered using the \"registerTemplate\" method\n   */\n  removeTemplate(templatePath: string): this\n\n  /**\n   * Register a global value\n   */\n  global(key: string, value: any): this\n\n  /**\n   * Mount/disk\n   */\n  mount(diskName: string): this\n  mount(diskName: string, dirPath: string): this\n\n  /**\n   * Unmount disk\n   */\n  unmount(diskName: string): this\n\n  /**\n   * Get a renderer instance to render templates\n   */\n  getRenderer(): EdgeRendererContract\n\n  /**\n   * Creates a renderer instances and shares the locals with it\n   */\n  share(locals: any): EdgeRendererContract\n\n  /**\n   * Render a template asynchronously\n   */\n  render(templatePath: string, state?: any): Promise<string>\n  renderRaw(contents: string, state?: any, templatePath?: string): Promise<string>\n\n  /**\n   * Render a template synchronously\n   */\n  renderSync(templatePath: string, state?: any): string\n  renderRawSync(contents: string, state?: any, templatePath?: string): string\n}\n\n/**\n * Required for someone creating custom tags\n */\nexport type EdgeBufferContract = EdgeBuffer\nexport type ParserContract = Parser\nexport type TagTokenContract = TagToken\nexport { ClaimTagFn }\n", "/*\n * edge\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport { Macroable } from 'macroable'\nimport { EdgeError } from 'edge-error'\nimport { lodash } from '@poppinss/utils'\nimport { string } from '@poppinss/utils/build/helpers'\n\nimport { Processor } from '../Processor'\nimport { Props } from '../Component/Props'\nimport { CompilerContract, TemplateContract } from '../Contracts'\n\n/**\n * An instance of this class passed to the escape\n * method ensures that underlying value is never\n * escaped.\n */\nexport class SafeValue {\n  constructor(public value: any) {}\n}\n\n/**\n * Escapes a given string\n */\nexport function escape(input: any): string {\n  return input instanceof SafeValue ? input.value : string.escapeHTML(String(input))\n}\n\n/**\n * Mark value as safe and not to be escaped\n */\nexport function safeValue(value: string) {\n  return new SafeValue(value)\n}\n\n/**\n * The template is used to compile and run templates. Also the instance\n * of template is passed during runtime to render `dynamic partials`\n * and `dynamic components`.\n */\nexport class Template extends Macroable implements TemplateContract {\n  /**\n   * Required by Macroable\n   */\n  protected static macros = {}\n  protected static getters = {}\n\n  /**\n   * The shared state is used to hold the globals and locals,\n   * since it is shared with components too.\n   */\n  private sharedState: any\n\n  constructor(\n    private compiler: CompilerContract,\n    globals: any,\n    locals: any,\n    private processor: Processor\n  ) {\n    super()\n    this.sharedState = lodash.merge({}, globals, locals)\n  }\n\n  /**\n   * Wraps template to a function\n   */\n  private wrapToFunction(template: string, ...localVariables: string[]) {\n    const args = ['template', 'state', '$context'].concat(localVariables)\n\n    if (this.compiler.async) {\n      return new Function(\n        '',\n        `return async function template (${args.join(',')}) { ${template} }`\n      )()\n    }\n\n    return new Function('', `return function template (${args.join(',')}) { ${template} }`)()\n  }\n\n  /**\n   * Trims top and bottom new lines from the content\n   */\n  private trimTopBottomNewLines(value: string) {\n    return value.replace(/^\\n|^\\r\\n/, '').replace(/\\n$|\\r\\n$/, '')\n  }\n\n  /**\n   * Render a compiled template with state\n   */\n  private renderCompiled(compiledTemplate: string, state: any) {\n    const templateState = Object.assign({}, this.sharedState, state)\n    const $context = {}\n\n    /**\n     * Process template as a promise.\n     */\n    if (this.compiler.async) {\n      return this.wrapToFunction(compiledTemplate)(this, templateState, $context).then(\n        (output: string) => {\n          output = this.trimTopBottomNewLines(output)\n          return this.processor.executeOutput({ output, template: this })\n        }\n      )\n    }\n\n    const output = this.trimTopBottomNewLines(\n      this.wrapToFunction(compiledTemplate)(this, templateState, $context)\n    )\n\n    return this.processor.executeOutput({ output, template: this })\n  }\n\n  /**\n   * Render a partial\n   *\n   * ```js\n   * const partialFn = template.compilePartial('includes/user')\n   *\n   * // render and use output\n   * partialFn(template, state, ctx)\n   * ```\n   */\n  public compilePartial(templatePath: string, ...localVariables: string[]): Function {\n    const { template: compiledTemplate } = this.compiler.compile(templatePath, localVariables)\n    return this.wrapToFunction(compiledTemplate, ...localVariables)\n  }\n\n  /**\n   * Render a component\n   *\n   * ```js\n   * const componentFn = template.compileComponent('components/button')\n   *\n   * // render and use output\n   * componentFn(template, template.getComponentState(props, slots, caller), ctx)\n   * ```\n   */\n  public compileComponent(templatePath: string, ...localVariables: string[]): string {\n    const { template: compiledTemplate } = this.compiler.compile(templatePath, localVariables)\n    return this.wrapToFunction(compiledTemplate, ...localVariables)\n  }\n\n  /**\n   * Returns the isolated state for a given component\n   */\n  public getComponentState(\n    props: { [key: string]: any },\n    slots: { [key: string]: any },\n    caller: { filename: string; line: number; col: number }\n  ) {\n    return Object.assign({}, this.sharedState, props, {\n      $slots: slots,\n      $caller: caller,\n      $props: new Props(props),\n    })\n  }\n\n  /**\n   * Render a template with it's state.\n   *\n   * ```js\n   * template.render('welcome', { key: 'value' })\n   * ```\n   */\n  public render<T extends Promise<string> | string>(template: string, state: any): T {\n    let { template: compiledTemplate } = this.compiler.compile(template)\n    return this.renderCompiled(compiledTemplate, state)\n  }\n\n  /**\n   * Render template from a raw string\n   *\n   * ```js\n   * template.renderRaw('Hello {{ username }}', { username: 'virk' })\n   * ```\n   */\n  public renderRaw<T extends Promise<string> | string>(\n    contents: string,\n    state: any,\n    templatePath?: string\n  ): T {\n    let { template: compiledTemplate } = this.compiler.compileRaw(contents, templatePath)\n    return this.renderCompiled(compiledTemplate, state)\n  }\n\n  /**\n   * Escapes the value to be HTML safe. Only strings are escaped\n   * and rest all values will be returned as it is.\n   */\n  public escape(input: any): string {\n    return escape(input)\n  }\n\n  /**\n   * Raise an error\n   */\n  public newError(errorMessage: string, filename: string, lineNumber: number, column: number) {\n    throw new EdgeError(errorMessage, 'E_RUNTIME_EXCEPTION', {\n      filename: filename,\n      line: lineNumber,\n      col: column,\n    })\n  }\n\n  /**\n   * Rethrows the runtime exception by re-constructing the error message\n   * to point back to the original filename\n   */\n  public reThrow(error: any, filename: string, lineNumber: number): never {\n    if (error instanceof EdgeError) {\n      throw error\n    }\n\n    const message = error.message.replace(/state\\./, '')\n    throw new EdgeError(message, 'E_RUNTIME_EXCEPTION', {\n      filename: filename,\n      line: lineNumber,\n      col: 0,\n    })\n  }\n}\n", "/*\n * edge\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nimport test from 'japa'\nimport { join } from 'path'\nimport { Filesystem } from '@poppinss/dev-utils'\n\nimport { Loader } from '../src/Loader'\nimport { Compiler } from '../src/Compiler'\nimport { slotTag } from '../src/Tags/Slot'\nimport { Processor } from '../src/Processor'\nimport { includeTag } from '../src/Tags/Include'\nimport { componentTag } from '../src/Tags/Component'\nimport { Template, safeValue } from '../src/Template'\n\nimport './assert-extend'\n\nconst tags = { slot: slotTag, component: componentTag, include: includeTag }\nconst fs = new Filesystem(join(__dirname, 'views'))\n\nconst loader = new Loader()\nloader.mount('default', fs.basePath)\n\ntest.group('Template', (group) => {\n  group.afterEach(async () => {\n    await fs.cleanup()\n    Template.hydrate()\n  })\n\n  test('run template using the given state', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ username }}')\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const output = new Template(compiler, {}, {}, processor).render('foo', {\n      username: 'virk',\n    }) as string\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('run template with shared state', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ getUsername() }}')\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n\n    const output = new Template(\n      compiler,\n      { username: 'virk' },\n      {\n        getUsername() {\n          return this.username.toUpperCase()\n        },\n      },\n      processor\n    ).render('foo', {}) as string\n    assert.equal(output.trim(), 'Hello VIRK')\n  })\n\n  test('run partial inside existing state', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ username }}')\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const output = template.compilePartial('foo')(template, { username: 'virk' })\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('pass local variables to inline templates', async (assert) => {\n    await fs.add('foo.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.compilePartial('foo', 'user')(template, {}, {}, user)\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('process file names starting with u', async (assert) => {\n    await fs.add('users.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.render('users', { user }) as string\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('execute output processor function', async (assert) => {\n    assert.plan(3)\n    await fs.add('users.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    processor.process('output', ({ output, template }) => {\n      assert.stringEqual(output, 'Hello virk')\n      assert.instanceOf(template, Template)\n    })\n\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.render('users', { user }) as string\n    assert.equal(output.trim(), 'Hello virk')\n  })\n\n  test('use return value of the output processor function', async (assert) => {\n    assert.plan(3)\n    await fs.add('users.edge', 'Hello {{ user.username }}')\n\n    const processor = new Processor()\n    processor.process('output', ({ output, template }) => {\n      assert.stringEqual(output, 'Hello virk')\n      assert.instanceOf(template, Template)\n      return output.toUpperCase()\n    })\n\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n\n    const user = { username: 'virk' }\n    const output = template.render('users', { user }) as string\n    assert.equal(output.trim(), 'HELLO VIRK')\n  })\n\n  test('escape HTML', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape('<h2> Hello world </h2>'), '&lt;h2&gt; Hello world &lt;/h2&gt;')\n  })\n\n  test('stringify value during escape', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape(22), '22')\n  })\n\n  test('do not escape values, which instance of safe value', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape(safeValue('<h2> Hello world </h2>')), '<h2> Hello world </h2>')\n  })\n\n  test('stringify array before escape', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template.escape(['<h2> Hello world </h2>']), '&lt;h2&gt; Hello world &lt;/h2&gt;')\n  })\n\n  test('stringify object before escape', (assert) => {\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(\n      template.escape({\n        toString() {\n          return '<h2> Hello world </h2>'\n        },\n      }),\n      '&lt;h2&gt; Hello world &lt;/h2&gt;'\n    )\n  })\n\n  test('add macros to context', (assert) => {\n    Template.macro('upper', (username) => {\n      return username.toUpperCase()\n    })\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template['upper']('virk'), 'VIRK')\n  })\n\n  test('add getters to context', (assert) => {\n    Template.getter('username', function username() {\n      return 'virk'\n    })\n\n    const processor = new Processor()\n    const compiler = new Compiler(loader, tags, processor, { cache: false })\n    const template = new Template(compiler, {}, {}, processor)\n    assert.equal(template['username'], 'virk')\n  })\n})\n"], "filenames": ["src/Contracts/index.ts", "src/Template/index.ts", "test/template.spec.ts"], "buggy_code_start_loc": [210, 31, 143], "buggy_code_end_loc": [211, 201, 154], "fixing_code_start_loc": [210, 31, 143], "fixing_code_end_loc": [211, 197, 176], "type": "CWE-843", "message": "This affects the package edge.js before 5.3.2. A type confusion vulnerability can be used to bypass input sanitization when the input to be rendered is an array (instead of a string or a SafeValue), even if {{ }} are used.", "other": {"cve": {"id": "CVE-2021-23443", "sourceIdentifier": "report@snyk.io", "published": "2021-09-21T17:15:09.297", "lastModified": "2022-05-03T16:04:40.443", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package edge.js before 5.3.2. A type confusion vulnerability can be used to bypass input sanitization when the input to be rendered is an array (instead of a string or a SafeValue), even if {{ }} are used."}, {"lang": "es", "value": "Esto afecta al paquete edge.js versiones anteriores a 5.3.2. Puede ser  usada una vulnerabilidad de confusi\u00f3n de tipo para omitir el saneamiento de entradas cuando la entrada que se va a representar es una matriz (en lugar de una cadena o un SafeValue), incluso si se usan {{ }}"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-843"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:adonisjs:edge:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.3.2", "matchCriteriaId": "3AE3354D-23C4-405B-880A-A83E469CE818"}]}]}], "references": [{"url": "https://github.com/edge-js/edge/commit/fa2c7fde86327aeae232752e89a6e37e2e469e21", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-EDGEJS-1579556", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/edge-js/edge/commit/fa2c7fde86327aeae232752e89a6e37e2e469e21"}}