{"buggy_code": ["/*    -*- linux-c -*-\n\nGTCO digitizer USB driver\n\nTO CHECK:  Is pressure done right on report 5?\n\nCopyright (C) 2006  GTCO CalComp\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; version 2\nof the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nPermission to use, copy, modify, distribute, and sell this software and its\ndocumentation for any purpose is hereby granted without fee, provided that\nthe above copyright notice appear in all copies and that both that\ncopyright notice and this permission notice appear in supporting\ndocumentation, and that the name of GTCO-CalComp not be used in advertising\nor publicity pertaining to distribution of the software without specific,\nwritten prior permission. GTCO-CalComp makes no representations about the\nsuitability of this software for any purpose.  It is provided \"as is\"\nwithout express or implied warranty.\n\nGTCO-CALCOMP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\nEVENT SHALL GTCO-CALCOMP BE LIABLE FOR ANY SPECIAL, INDIRECT OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\nDATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTIONS, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n\nGTCO CalComp, Inc.\n7125 Riverwood Drive\nColumbia, MD 21046\n\nJeremy Roberson jroberson@gtcocalcomp.com\nScott Hill shill@gtcocalcomp.com\n*/\n\n\n\n/*#define DEBUG*/\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <asm/uaccess.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n\n#include <linux/usb/input.h>\n\n/* Version with a Major number of 2 is for kernel inclusion only. */\n#define  GTCO_VERSION   \"2.00.0006\"\n\n\n/*   MACROS  */\n\n#define VENDOR_ID_GTCO\t      0x078C\n#define PID_400               0x400\n#define PID_401               0x401\n#define PID_1000              0x1000\n#define PID_1001              0x1001\n#define PID_1002              0x1002\n\n/* Max size of a single report */\n#define REPORT_MAX_SIZE       10\n\n\n/* Bitmask whether pen is in range */\n#define MASK_INRANGE 0x20\n#define MASK_BUTTON  0x01F\n\n#define  PATHLENGTH     64\n\n/* DATA STRUCTURES */\n\n/* Device table */\nstatic const struct usb_device_id gtco_usbid_table[] = {\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_400) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_401) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_1000) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_1001) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_1002) },\n\t{ }\n};\nMODULE_DEVICE_TABLE (usb, gtco_usbid_table);\n\n\n/* Structure to hold all of our device specific stuff */\nstruct gtco {\n\n\tstruct input_dev  *inputdevice; /* input device struct pointer  */\n\tstruct usb_device *usbdev; /* the usb device for this device */\n\tstruct usb_interface *intf;\t/* the usb interface for this device */\n\tstruct urb        *urbinfo;\t /* urb for incoming reports      */\n\tdma_addr_t        buf_dma;  /* dma addr of the data buffer*/\n\tunsigned char *   buffer;   /* databuffer for reports */\n\n\tchar  usbpath[PATHLENGTH];\n\tint   openCount;\n\n\t/* Information pulled from Report Descriptor */\n\tu32  usage;\n\tu32  min_X;\n\tu32  max_X;\n\tu32  min_Y;\n\tu32  max_Y;\n\ts8   mintilt_X;\n\ts8   maxtilt_X;\n\ts8   mintilt_Y;\n\ts8   maxtilt_Y;\n\tu32  maxpressure;\n\tu32  minpressure;\n};\n\n\n\n/*   Code for parsing the HID REPORT DESCRIPTOR          */\n\n/* From HID1.11 spec */\nstruct hid_descriptor\n{\n\tstruct usb_descriptor_header header;\n\t__le16   bcdHID;\n\tu8       bCountryCode;\n\tu8       bNumDescriptors;\n\tu8       bDescriptorType;\n\t__le16   wDescriptorLength;\n} __attribute__ ((packed));\n\n\n#define HID_DESCRIPTOR_SIZE   9\n#define HID_DEVICE_TYPE       33\n#define REPORT_DEVICE_TYPE    34\n\n\n#define PREF_TAG(x)     ((x)>>4)\n#define PREF_TYPE(x)    ((x>>2)&0x03)\n#define PREF_SIZE(x)    ((x)&0x03)\n\n#define TYPE_MAIN       0\n#define TYPE_GLOBAL     1\n#define TYPE_LOCAL      2\n#define TYPE_RESERVED   3\n\n#define TAG_MAIN_INPUT        0x8\n#define TAG_MAIN_OUTPUT       0x9\n#define TAG_MAIN_FEATURE      0xB\n#define TAG_MAIN_COL_START    0xA\n#define TAG_MAIN_COL_END      0xC\n\n#define TAG_GLOB_USAGE        0\n#define TAG_GLOB_LOG_MIN      1\n#define TAG_GLOB_LOG_MAX      2\n#define TAG_GLOB_PHYS_MIN     3\n#define TAG_GLOB_PHYS_MAX     4\n#define TAG_GLOB_UNIT_EXP     5\n#define TAG_GLOB_UNIT         6\n#define TAG_GLOB_REPORT_SZ    7\n#define TAG_GLOB_REPORT_ID    8\n#define TAG_GLOB_REPORT_CNT   9\n#define TAG_GLOB_PUSH         10\n#define TAG_GLOB_POP          11\n\n#define TAG_GLOB_MAX          12\n\n#define DIGITIZER_USAGE_TIP_PRESSURE   0x30\n#define DIGITIZER_USAGE_TILT_X         0x3D\n#define DIGITIZER_USAGE_TILT_Y         0x3E\n\n\n/*\n *   This is an abbreviated parser for the HID Report Descriptor.  We\n *   know what devices we are talking to, so this is by no means meant\n *   to be generic.  We can make some safe assumptions:\n *\n *   - We know there are no LONG tags, all short\n *   - We know that we have no MAIN Feature and MAIN Output items\n *   - We know what the IRQ reports are supposed to look like.\n *\n *   The main purpose of this is to use the HID report desc to figure\n *   out the mins and maxs of the fields in the IRQ reports.  The IRQ\n *   reports for 400/401 change slightly if the max X is bigger than 64K.\n *\n */\nstatic void parse_hid_report_descriptor(struct gtco *device, char * report,\n\t\t\t\t\tint length)\n{\n\tstruct device *ddev = &device->intf->dev;\n\tint   x, i = 0;\n\n\t/* Tag primitive vars */\n\t__u8   prefix;\n\t__u8   size;\n\t__u8   tag;\n\t__u8   type;\n\t__u8   data   = 0;\n\t__u16  data16 = 0;\n\t__u32  data32 = 0;\n\n\t/* For parsing logic */\n\tint   inputnum = 0;\n\t__u32 usage = 0;\n\n\t/* Global Values, indexed by TAG */\n\t__u32 globalval[TAG_GLOB_MAX];\n\t__u32 oldval[TAG_GLOB_MAX];\n\n\t/* Debug stuff */\n\tchar  maintype = 'x';\n\tchar  globtype[12];\n\tint   indent = 0;\n\tchar  indentstr[10] = \"\";\n\n\n\tdev_dbg(ddev, \"======>>>>>>PARSE<<<<<<======\\n\");\n\n\t/* Walk  this report and pull out the info we need */\n\twhile (i < length) {\n\t\tprefix = report[i];\n\n\t\t/* Skip over prefix */\n\t\ti++;\n\n\t\t/* Determine data size and save the data in the proper variable */\n\t\tsize = PREF_SIZE(prefix);\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tdata = report[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata16 = get_unaligned_le16(&report[i]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsize = 4;\n\t\t\tdata32 = get_unaligned_le32(&report[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip size of data */\n\t\ti += size;\n\n\t\t/* What we do depends on the tag type */\n\t\ttag  = PREF_TAG(prefix);\n\t\ttype = PREF_TYPE(prefix);\n\t\tswitch (type) {\n\t\tcase TYPE_MAIN:\n\t\t\tstrcpy(globtype, \"\");\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_MAIN_INPUT:\n\t\t\t\t/*\n\t\t\t\t * The INPUT MAIN tag signifies this is\n\t\t\t\t * information from a report.  We need to\n\t\t\t\t * figure out what it is and store the\n\t\t\t\t * min/max values\n\t\t\t\t */\n\n\t\t\t\tmaintype = 'I';\n\t\t\t\tif (data == 2)\n\t\t\t\t\tstrcpy(globtype, \"Variable\");\n\t\t\t\telse if (data == 3)\n\t\t\t\t\tstrcpy(globtype, \"Var|Const\");\n\n\t\t\t\tdev_dbg(ddev, \"::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\\n\",\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_ID], inputnum,\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\n\n\n\t\t\t\t/*\n\t\t\t\t  We can assume that the first two input items\n\t\t\t\t  are always the X and Y coordinates.  After\n\t\t\t\t  that, we look for everything else by\n\t\t\t\t  local usage value\n\t\t\t\t */\n\t\t\t\tswitch (inputnum) {\n\t\t\t\tcase 0:  /* X coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: X Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_X == 0) {\n\t\t\t\t\t\tdevice->max_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  /* Y coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: Y Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_Y == 0) {\n\t\t\t\t\t\tdevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* Tilt X */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_X) {\n\t\t\t\t\t\tif (device->maxtilt_X == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Tilt Y */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_Y) {\n\t\t\t\t\t\tif (device->maxtilt_Y == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Pressure */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\n\t\t\t\t\t\tif (device->maxpressure == 0) {\n\t\t\t\t\t\t\tdevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputnum++;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_OUTPUT:\n\t\t\t\tmaintype = 'O';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_FEATURE:\n\t\t\t\tmaintype = 'F';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_START:\n\t\t\t\tmaintype = 'S';\n\n\t\t\t\tif (data == 0) {\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>> Physical\\n\");\n\t\t\t\t\tstrcpy(globtype, \"Physical\");\n\t\t\t\t} else\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>>\\n\");\n\n\t\t\t\t/* Indent the debug output */\n\t\t\t\tindent++;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Save global tags */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\toldval[x] = globalval[x];\n\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_END:\n\t\t\t\tdev_dbg(ddev, \"<<<<<<======\\n\");\n\t\t\t\tmaintype = 'E';\n\t\t\t\tindent--;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Copy global tags back */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\tglobalval[x] = oldval[x];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_GLOBAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\t/*\n\t\t\t\t * First time we hit the global usage tag,\n\t\t\t\t * it should tell us the type of device\n\t\t\t\t */\n\t\t\t\tif (device->usage == 0)\n\t\t\t\t\tdevice->usage = data;\n\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"LOG_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"LOG_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MIN:\n\t\t\t\tstrcpy(globtype, \"PHYS_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MAX:\n\t\t\t\tstrcpy(globtype, \"PHYS_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT_EXP:\n\t\t\t\tstrcpy(globtype, \"EXP\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT:\n\t\t\t\tstrcpy(globtype, \"UNIT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_SZ:\n\t\t\t\tstrcpy(globtype, \"REPORT_SZ\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_ID:\n\t\t\t\tstrcpy(globtype, \"REPORT_ID\");\n\t\t\t\t/* New report, restart numbering */\n\t\t\t\tinputnum = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_CNT:\n\t\t\t\tstrcpy(globtype, \"REPORT_CNT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PUSH:\n\t\t\t\tstrcpy(globtype, \"PUSH\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_POP:\n\t\t\t\tstrcpy(globtype, \"POP\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check to make sure we have a good tag number\n\t\t\t   so we don't overflow array */\n\t\t\tif (tag < TAG_GLOB_MAX) {\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 1:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data);\n\t\t\t\t\tglobalval[tag] = data;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data16);\n\t\t\t\t\tglobalval[tag] = data16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data32);\n\t\t\t\t\tglobalval[tag] = data32;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\\n\",\n\t\t\t\t\tindentstr, tag, size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_LOCAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\t/* Always 1 byte */\n\t\t\t\tusage = data;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"MAX\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrcpy(globtype, \"UNKNOWN\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*   INPUT DRIVER Routines                               */\n\n/*\n * Called when opening the input device.  This will submit the URB to\n * the usb system so we start getting reports\n */\nstatic int gtco_input_open(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\tdevice->urbinfo->dev = device->usbdev;\n\tif (usb_submit_urb(device->urbinfo, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/*\n * Called when closing the input device.  This will unlink the URB\n */\nstatic void gtco_input_close(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\tusb_kill_urb(device->urbinfo);\n}\n\n\n/*\n *  Setup input device capabilities.  Tell the input system what this\n *  device is capable of generating.\n *\n *  This information is based on what is read from the HID report and\n *  placed in the struct gtco structure\n *\n */\nstatic void gtco_setup_caps(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\t/* Which events */\n\tinputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) |\n\t\tBIT_MASK(EV_MSC);\n\n\t/* Misc event menu block */\n\tinputdev->mscbit[0] = BIT_MASK(MSC_SCAN) | BIT_MASK(MSC_SERIAL) |\n\t\tBIT_MASK(MSC_RAW);\n\n\t/* Absolute values based on HID report info */\n\tinput_set_abs_params(inputdev, ABS_X, device->min_X, device->max_X,\n\t\t\t     0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, device->min_Y, device->max_Y,\n\t\t\t     0, 0);\n\n\t/* Proximity */\n\tinput_set_abs_params(inputdev, ABS_DISTANCE, 0, 1, 0, 0);\n\n\t/* Tilt & pressure */\n\tinput_set_abs_params(inputdev, ABS_TILT_X, device->mintilt_X,\n\t\t\t     device->maxtilt_X, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_Y, device->mintilt_Y,\n\t\t\t     device->maxtilt_Y, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, device->minpressure,\n\t\t\t     device->maxpressure, 0, 0);\n\n\t/* Transducer */\n\tinput_set_abs_params(inputdev, ABS_MISC, 0, 0xFF, 0, 0);\n}\n\n/*   USB Routines  */\n\n/*\n * URB callback routine.  Called when we get IRQ reports from the\n *  digitizer.\n *\n *  This bridges the USB and input device worlds.  It generates events\n *  on the input device based on the USB reports.\n */\nstatic void gtco_urb_callback(struct urb *urbinfo)\n{\n\tstruct gtco *device = urbinfo->context;\n\tstruct input_dev  *inputdev;\n\tint               rc;\n\tu32               val = 0;\n\tchar              le_buffer[2];\n\n\tinputdev = device->inputdevice;\n\n\t/* Was callback OK? */\n\tif (urbinfo->status == -ECONNRESET ||\n\t    urbinfo->status == -ENOENT ||\n\t    urbinfo->status == -ESHUTDOWN) {\n\n\t\t/* Shutdown is occurring. Return and don't queue up any more */\n\t\treturn;\n\t}\n\n\tif (urbinfo->status != 0) {\n\t\t/*\n\t\t * Some unknown error.  Hopefully temporary. Just go and\n\t\t * requeue an URB\n\t\t */\n\t\tgoto resubmit;\n\t}\n\n\t/*\n\t * Good URB, now process\n\t */\n\n\t/* PID dependent when we interpret the report */\n\tif (inputdev->id.product == PID_1000 ||\n\t    inputdev->id.product == PID_1001 ||\n\t    inputdev->id.product == PID_1002) {\n\n\t\t/*\n\t\t * Switch on the report ID\n\t\t * Conveniently, the reports have more information, the higher\n\t\t * the report number.  We can just fall through the case\n\t\t * statements if we start with the highest number report\n\t\t */\n\t\tswitch (device->buffer[0]) {\n\t\tcase 5:\n\t\t\t/* Pressure is 9 bits */\n\t\t\tval = ((u16)(device->buffer[8]) << 1);\n\t\t\tval |= (u16)(device->buffer[7] >> 7);\n\t\t\tinput_report_abs(inputdev, ABS_PRESSURE,\n\t\t\t\t\t device->buffer[8]);\n\n\t\t\t/* Mask out the Y tilt value used for pressure */\n\t\t\tdevice->buffer[7] = (u8)((device->buffer[7]) & 0x7F);\n\n\t\t\t/* Fall thru */\n\t\tcase 4:\n\t\t\t/* Tilt */\n\t\t\tinput_report_abs(inputdev, ABS_TILT_X,\n\t\t\t\t\t sign_extend32(device->buffer[6], 6));\n\n\t\t\tinput_report_abs(inputdev, ABS_TILT_Y,\n\t\t\t\t\t sign_extend32(device->buffer[7], 6));\n\n\t\t\t/* Fall thru */\n\t\tcase 2:\n\t\tcase 3:\n\t\t\t/* Convert buttons, only 5 bits possible */\n\t\t\tval = (device->buffer[5]) & MASK_BUTTON;\n\n\t\t\t/* We don't apply any meaning to the bitmask,\n\t\t\t   just report */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SERIAL, val);\n\n\t\t\t/*  Fall thru */\n\t\tcase 1:\n\t\t\t/* All reports have X and Y coords in the same place */\n\t\t\tval = get_unaligned_le16(&device->buffer[1]);\n\t\t\tinput_report_abs(inputdev, ABS_X, val);\n\n\t\t\tval = get_unaligned_le16(&device->buffer[3]);\n\t\t\tinput_report_abs(inputdev, ABS_Y, val);\n\n\t\t\t/* Ditto for proximity bit */\n\t\t\tval = device->buffer[5] & MASK_INRANGE ? 1 : 0;\n\t\t\tinput_report_abs(inputdev, ABS_DISTANCE, val);\n\n\t\t\t/* Report 1 is an exception to how we handle buttons */\n\t\t\t/* Buttons are an index, not a bitmask */\n\t\t\tif (device->buffer[0] == 1) {\n\n\t\t\t\t/*\n\t\t\t\t * Convert buttons, 5 bit index\n\t\t\t\t * Report value of index set as one,\n\t\t\t\t * the rest as 0\n\t\t\t\t */\n\t\t\t\tval = device->buffer[5] & MASK_BUTTON;\n\t\t\t\tdev_dbg(&device->intf->dev,\n\t\t\t\t\t\"======>>>>>>REPORT 1: val 0x%X(%d)\\n\",\n\t\t\t\t\tval, val);\n\n\t\t\t\t/*\n\t\t\t\t * We don't apply any meaning to the button\n\t\t\t\t * index, just report it\n\t\t\t\t */\n\t\t\t\tinput_event(inputdev, EV_MSC, MSC_SERIAL, val);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\t/* Menu blocks */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SCAN,\n\t\t\t\t    device->buffer[1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Other pid class */\n\tif (inputdev->id.product == PID_400 ||\n\t    inputdev->id.product == PID_401) {\n\n\t\t/* Report 2 */\n\t\tif (device->buffer[0] == 2) {\n\t\t\t/* Menu blocks */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SCAN, device->buffer[1]);\n\t\t}\n\n\t\t/*  Report 1 */\n\t\tif (device->buffer[0] == 1) {\n\t\t\tchar buttonbyte;\n\n\t\t\t/*  IF X max > 64K, we still a bit from the y report */\n\t\t\tif (device->max_X > 0x10000) {\n\n\t\t\t\tval = (u16)(((u16)(device->buffer[2] << 8)) | (u8)device->buffer[1]);\n\t\t\t\tval |= (u32)(((u8)device->buffer[3] & 0x1) << 16);\n\n\t\t\t\tinput_report_abs(inputdev, ABS_X, val);\n\n\t\t\t\tle_buffer[0]  = (u8)((u8)(device->buffer[3]) >> 1);\n\t\t\t\tle_buffer[0] |= (u8)((device->buffer[3] & 0x1) << 7);\n\n\t\t\t\tle_buffer[1]  = (u8)(device->buffer[4] >> 1);\n\t\t\t\tle_buffer[1] |= (u8)((device->buffer[5] & 0x1) << 7);\n\n\t\t\t\tval = get_unaligned_le16(le_buffer);\n\t\t\t\tinput_report_abs(inputdev, ABS_Y, val);\n\n\t\t\t\t/*\n\t\t\t\t * Shift the button byte right by one to\n\t\t\t\t * make it look like the standard report\n\t\t\t\t */\n\t\t\t\tbuttonbyte = device->buffer[5] >> 1;\n\t\t\t} else {\n\n\t\t\t\tval = get_unaligned_le16(&device->buffer[1]);\n\t\t\t\tinput_report_abs(inputdev, ABS_X, val);\n\n\t\t\t\tval = get_unaligned_le16(&device->buffer[3]);\n\t\t\t\tinput_report_abs(inputdev, ABS_Y, val);\n\n\t\t\t\tbuttonbyte = device->buffer[5];\n\t\t\t}\n\n\t\t\t/* BUTTONS and PROXIMITY */\n\t\t\tval = buttonbyte & MASK_INRANGE ? 1 : 0;\n\t\t\tinput_report_abs(inputdev, ABS_DISTANCE, val);\n\n\t\t\t/* Convert buttons, only 4 bits possible */\n\t\t\tval = buttonbyte & 0x0F;\n#ifdef USE_BUTTONS\n\t\t\tfor (i = 0; i < 5; i++)\n\t\t\t\tinput_report_key(inputdev, BTN_DIGI + i, val & (1 << i));\n#else\n\t\t\t/* We don't apply any meaning to the bitmask, just report */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SERIAL, val);\n#endif\n\n\t\t\t/* TRANSDUCER */\n\t\t\tinput_report_abs(inputdev, ABS_MISC, device->buffer[6]);\n\t\t}\n\t}\n\n\t/* Everybody gets report ID's */\n\tinput_event(inputdev, EV_MSC, MSC_RAW,  device->buffer[0]);\n\n\t/* Sync it up */\n\tinput_sync(inputdev);\n\n resubmit:\n\trc = usb_submit_urb(urbinfo, GFP_ATOMIC);\n\tif (rc != 0)\n\t\tdev_err(&device->intf->dev,\n\t\t\t\"usb_submit_urb failed rc=0x%x\\n\", rc);\n}\n\n/*\n *  The probe routine.  This is called when the kernel find the matching USB\n *   vendor/product.  We do the following:\n *\n *    - Allocate mem for a local structure to manage the device\n *    - Request a HID Report Descriptor from the device and parse it to\n *      find out the device parameters\n *    - Create an input device and assign it attributes\n *   - Allocate an URB so the device can talk to us when the input\n *      queue is open\n */\nstatic int gtco_probe(struct usb_interface *usbinterface,\n\t\t      const struct usb_device_id *id)\n{\n\n\tstruct gtco             *gtco;\n\tstruct input_dev        *input_dev;\n\tstruct hid_descriptor   *hid_desc;\n\tchar                    *report;\n\tint                     result = 0, retry;\n\tint\t\t\terror;\n\tstruct usb_endpoint_descriptor *endpoint;\n\n\t/* Allocate memory for device structure */\n\tgtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!gtco || !input_dev) {\n\t\tdev_err(&usbinterface->dev, \"No more memory\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Set pointer to the input device */\n\tgtco->inputdevice = input_dev;\n\n\t/* Save interface information */\n\tgtco->usbdev = interface_to_usbdev(usbinterface);\n\tgtco->intf = usbinterface;\n\n\t/* Allocate some data for incoming reports */\n\tgtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t\t\t  GFP_KERNEL, &gtco->buf_dma);\n\tif (!gtco->buffer) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for us buffers\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Allocate URB for reports */\n\tgtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!gtco->urbinfo) {\n\t\tdev_err(&usbinterface->dev, \"Failed to allocate URB\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_buf;\n\t}\n\n\t/*\n\t * The endpoint is always altsetting 0, we know this since we know\n\t * this device only has one interrupt endpoint\n\t */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\t/* Some debug */\n\tdev_dbg(&usbinterface->dev, \"gtco # interfaces: %d\\n\", usbinterface->num_altsetting);\n\tdev_dbg(&usbinterface->dev, \"num endpoints:     %d\\n\", usbinterface->cur_altsetting->desc.bNumEndpoints);\n\tdev_dbg(&usbinterface->dev, \"interface class:   %d\\n\", usbinterface->cur_altsetting->desc.bInterfaceClass);\n\tdev_dbg(&usbinterface->dev, \"endpoint: attribute:0x%x type:0x%x\\n\", endpoint->bmAttributes, endpoint->bDescriptorType);\n\tif (usb_endpoint_xfer_int(endpoint))\n\t\tdev_dbg(&usbinterface->dev, \"endpoint: we have interrupt endpoint\\n\");\n\n\tdev_dbg(&usbinterface->dev, \"endpoint extra len:%d\\n\", usbinterface->altsetting[0].extralen);\n\n\t/*\n\t * Find the HID descriptor so we can find out the size of the\n\t * HID report descriptor\n\t */\n\tif (usb_get_extra_descriptor(usbinterface->cur_altsetting,\n\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0){\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Can't retrieve exta USB descriptor to get hid report descriptor length\\n\");\n\t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\tdev_dbg(&usbinterface->dev,\n\t\t\"Extra descriptor success: type:%d  len:%d\\n\",\n\t\thid_desc->bDescriptorType,  hid_desc->wDescriptorLength);\n\n\treport = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);\n\tif (!report) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for report\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Couple of tries to get reply */\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tresult = usb_control_msg(gtco->usbdev,\n\t\t\t\t\t usb_rcvctrlpipe(gtco->usbdev, 0),\n\t\t\t\t\t USB_REQ_GET_DESCRIPTOR,\n\t\t\t\t\t USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t\t REPORT_DEVICE_TYPE << 8,\n\t\t\t\t\t 0, /* interface */\n\t\t\t\t\t report,\n\t\t\t\t\t le16_to_cpu(hid_desc->wDescriptorLength),\n\t\t\t\t\t 5000); /* 5 secs */\n\n\t\tdev_dbg(&usbinterface->dev, \"usb_control_msg result: %d\\n\", result);\n\t\tif (result == le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\t\tparse_hid_report_descriptor(gtco, report, result);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(report);\n\n\t/* If we didn't get the report, fail */\n\tif (result != le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Failed to get HID Report Descriptor of size: %d\\n\",\n\t\t\thid_desc->wDescriptorLength);\n\t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Create a device file node */\n\tusb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));\n\tstrlcat(gtco->usbpath, \"/input0\", sizeof(gtco->usbpath));\n\n\t/* Set Input device functions */\n\tinput_dev->open = gtco_input_open;\n\tinput_dev->close = gtco_input_close;\n\n\t/* Set input device information */\n\tinput_dev->name = \"GTCO_CalComp\";\n\tinput_dev->phys = gtco->usbpath;\n\n\tinput_set_drvdata(input_dev, gtco);\n\n\t/* Now set up all the input device capabilities */\n\tgtco_setup_caps(input_dev);\n\n\t/* Set input device required ID information */\n\tusb_to_input_id(gtco->usbdev, &input_dev->id);\n\tinput_dev->dev.parent = &usbinterface->dev;\n\n\t/* Setup the URB, it will be posted later on open of input device */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\tusb_fill_int_urb(gtco->urbinfo,\n\t\t\t gtco->usbdev,\n\t\t\t usb_rcvintpipe(gtco->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t gtco->buffer,\n\t\t\t REPORT_MAX_SIZE,\n\t\t\t gtco_urb_callback,\n\t\t\t gtco,\n\t\t\t endpoint->bInterval);\n\n\tgtco->urbinfo->transfer_dma = gtco->buf_dma;\n\tgtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* Save gtco pointer in USB interface gtco */\n\tusb_set_intfdata(usbinterface, gtco);\n\n\t/* All done, now register the input device */\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\tgoto err_free_urb;\n\n\treturn 0;\n\n err_free_urb:\n\tusb_free_urb(gtco->urbinfo);\n err_free_buf:\n\tusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t  gtco->buffer, gtco->buf_dma);\n err_free_devs:\n\tinput_free_device(input_dev);\n\tkfree(gtco);\n\treturn error;\n}\n\n/*\n *  This function is a standard USB function called when the USB device\n *  is disconnected.  We will get rid of the URV, de-register the input\n *  device, and free up allocated memory\n */\nstatic void gtco_disconnect(struct usb_interface *interface)\n{\n\t/* Grab private device ptr */\n\tstruct gtco *gtco = usb_get_intfdata(interface);\n\n\t/* Now reverse all the registration stuff */\n\tif (gtco) {\n\t\tinput_unregister_device(gtco->inputdevice);\n\t\tusb_kill_urb(gtco->urbinfo);\n\t\tusb_free_urb(gtco->urbinfo);\n\t\tusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t\t  gtco->buffer, gtco->buf_dma);\n\t\tkfree(gtco);\n\t}\n\n\tdev_info(&interface->dev, \"gtco driver disconnected\\n\");\n}\n\n/*   STANDARD MODULE LOAD ROUTINES  */\n\nstatic struct usb_driver gtco_driverinfo_table = {\n\t.name\t\t= \"gtco\",\n\t.id_table\t= gtco_usbid_table,\n\t.probe\t\t= gtco_probe,\n\t.disconnect\t= gtco_disconnect,\n};\n\nmodule_usb_driver(gtco_driverinfo_table);\n\nMODULE_DESCRIPTION(\"GTCO digitizer USB driver\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*    -*- linux-c -*-\n\nGTCO digitizer USB driver\n\nTO CHECK:  Is pressure done right on report 5?\n\nCopyright (C) 2006  GTCO CalComp\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; version 2\nof the License.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nPermission to use, copy, modify, distribute, and sell this software and its\ndocumentation for any purpose is hereby granted without fee, provided that\nthe above copyright notice appear in all copies and that both that\ncopyright notice and this permission notice appear in supporting\ndocumentation, and that the name of GTCO-CalComp not be used in advertising\nor publicity pertaining to distribution of the software without specific,\nwritten prior permission. GTCO-CalComp makes no representations about the\nsuitability of this software for any purpose.  It is provided \"as is\"\nwithout express or implied warranty.\n\nGTCO-CALCOMP DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\nINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\nEVENT SHALL GTCO-CALCOMP BE LIABLE FOR ANY SPECIAL, INDIRECT OR\nCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\nDATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTIONS, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n\nGTCO CalComp, Inc.\n7125 Riverwood Drive\nColumbia, MD 21046\n\nJeremy Roberson jroberson@gtcocalcomp.com\nScott Hill shill@gtcocalcomp.com\n*/\n\n\n\n/*#define DEBUG*/\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <asm/uaccess.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n\n#include <linux/usb/input.h>\n\n/* Version with a Major number of 2 is for kernel inclusion only. */\n#define  GTCO_VERSION   \"2.00.0006\"\n\n\n/*   MACROS  */\n\n#define VENDOR_ID_GTCO\t      0x078C\n#define PID_400               0x400\n#define PID_401               0x401\n#define PID_1000              0x1000\n#define PID_1001              0x1001\n#define PID_1002              0x1002\n\n/* Max size of a single report */\n#define REPORT_MAX_SIZE       10\n\n\n/* Bitmask whether pen is in range */\n#define MASK_INRANGE 0x20\n#define MASK_BUTTON  0x01F\n\n#define  PATHLENGTH     64\n\n/* DATA STRUCTURES */\n\n/* Device table */\nstatic const struct usb_device_id gtco_usbid_table[] = {\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_400) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_401) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_1000) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_1001) },\n\t{ USB_DEVICE(VENDOR_ID_GTCO, PID_1002) },\n\t{ }\n};\nMODULE_DEVICE_TABLE (usb, gtco_usbid_table);\n\n\n/* Structure to hold all of our device specific stuff */\nstruct gtco {\n\n\tstruct input_dev  *inputdevice; /* input device struct pointer  */\n\tstruct usb_device *usbdev; /* the usb device for this device */\n\tstruct usb_interface *intf;\t/* the usb interface for this device */\n\tstruct urb        *urbinfo;\t /* urb for incoming reports      */\n\tdma_addr_t        buf_dma;  /* dma addr of the data buffer*/\n\tunsigned char *   buffer;   /* databuffer for reports */\n\n\tchar  usbpath[PATHLENGTH];\n\tint   openCount;\n\n\t/* Information pulled from Report Descriptor */\n\tu32  usage;\n\tu32  min_X;\n\tu32  max_X;\n\tu32  min_Y;\n\tu32  max_Y;\n\ts8   mintilt_X;\n\ts8   maxtilt_X;\n\ts8   mintilt_Y;\n\ts8   maxtilt_Y;\n\tu32  maxpressure;\n\tu32  minpressure;\n};\n\n\n\n/*   Code for parsing the HID REPORT DESCRIPTOR          */\n\n/* From HID1.11 spec */\nstruct hid_descriptor\n{\n\tstruct usb_descriptor_header header;\n\t__le16   bcdHID;\n\tu8       bCountryCode;\n\tu8       bNumDescriptors;\n\tu8       bDescriptorType;\n\t__le16   wDescriptorLength;\n} __attribute__ ((packed));\n\n\n#define HID_DESCRIPTOR_SIZE   9\n#define HID_DEVICE_TYPE       33\n#define REPORT_DEVICE_TYPE    34\n\n\n#define PREF_TAG(x)     ((x)>>4)\n#define PREF_TYPE(x)    ((x>>2)&0x03)\n#define PREF_SIZE(x)    ((x)&0x03)\n\n#define TYPE_MAIN       0\n#define TYPE_GLOBAL     1\n#define TYPE_LOCAL      2\n#define TYPE_RESERVED   3\n\n#define TAG_MAIN_INPUT        0x8\n#define TAG_MAIN_OUTPUT       0x9\n#define TAG_MAIN_FEATURE      0xB\n#define TAG_MAIN_COL_START    0xA\n#define TAG_MAIN_COL_END      0xC\n\n#define TAG_GLOB_USAGE        0\n#define TAG_GLOB_LOG_MIN      1\n#define TAG_GLOB_LOG_MAX      2\n#define TAG_GLOB_PHYS_MIN     3\n#define TAG_GLOB_PHYS_MAX     4\n#define TAG_GLOB_UNIT_EXP     5\n#define TAG_GLOB_UNIT         6\n#define TAG_GLOB_REPORT_SZ    7\n#define TAG_GLOB_REPORT_ID    8\n#define TAG_GLOB_REPORT_CNT   9\n#define TAG_GLOB_PUSH         10\n#define TAG_GLOB_POP          11\n\n#define TAG_GLOB_MAX          12\n\n#define DIGITIZER_USAGE_TIP_PRESSURE   0x30\n#define DIGITIZER_USAGE_TILT_X         0x3D\n#define DIGITIZER_USAGE_TILT_Y         0x3E\n\n\n/*\n *   This is an abbreviated parser for the HID Report Descriptor.  We\n *   know what devices we are talking to, so this is by no means meant\n *   to be generic.  We can make some safe assumptions:\n *\n *   - We know there are no LONG tags, all short\n *   - We know that we have no MAIN Feature and MAIN Output items\n *   - We know what the IRQ reports are supposed to look like.\n *\n *   The main purpose of this is to use the HID report desc to figure\n *   out the mins and maxs of the fields in the IRQ reports.  The IRQ\n *   reports for 400/401 change slightly if the max X is bigger than 64K.\n *\n */\nstatic void parse_hid_report_descriptor(struct gtco *device, char * report,\n\t\t\t\t\tint length)\n{\n\tstruct device *ddev = &device->intf->dev;\n\tint   x, i = 0;\n\n\t/* Tag primitive vars */\n\t__u8   prefix;\n\t__u8   size;\n\t__u8   tag;\n\t__u8   type;\n\t__u8   data   = 0;\n\t__u16  data16 = 0;\n\t__u32  data32 = 0;\n\n\t/* For parsing logic */\n\tint   inputnum = 0;\n\t__u32 usage = 0;\n\n\t/* Global Values, indexed by TAG */\n\t__u32 globalval[TAG_GLOB_MAX];\n\t__u32 oldval[TAG_GLOB_MAX];\n\n\t/* Debug stuff */\n\tchar  maintype = 'x';\n\tchar  globtype[12];\n\tint   indent = 0;\n\tchar  indentstr[10] = \"\";\n\n\n\tdev_dbg(ddev, \"======>>>>>>PARSE<<<<<<======\\n\");\n\n\t/* Walk  this report and pull out the info we need */\n\twhile (i < length) {\n\t\tprefix = report[i];\n\n\t\t/* Skip over prefix */\n\t\ti++;\n\n\t\t/* Determine data size and save the data in the proper variable */\n\t\tsize = PREF_SIZE(prefix);\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tdata = report[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata16 = get_unaligned_le16(&report[i]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tsize = 4;\n\t\t\tdata32 = get_unaligned_le32(&report[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip size of data */\n\t\ti += size;\n\n\t\t/* What we do depends on the tag type */\n\t\ttag  = PREF_TAG(prefix);\n\t\ttype = PREF_TYPE(prefix);\n\t\tswitch (type) {\n\t\tcase TYPE_MAIN:\n\t\t\tstrcpy(globtype, \"\");\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_MAIN_INPUT:\n\t\t\t\t/*\n\t\t\t\t * The INPUT MAIN tag signifies this is\n\t\t\t\t * information from a report.  We need to\n\t\t\t\t * figure out what it is and store the\n\t\t\t\t * min/max values\n\t\t\t\t */\n\n\t\t\t\tmaintype = 'I';\n\t\t\t\tif (data == 2)\n\t\t\t\t\tstrcpy(globtype, \"Variable\");\n\t\t\t\telse if (data == 3)\n\t\t\t\t\tstrcpy(globtype, \"Var|Const\");\n\n\t\t\t\tdev_dbg(ddev, \"::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\\n\",\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_ID], inputnum,\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\n\n\n\t\t\t\t/*\n\t\t\t\t  We can assume that the first two input items\n\t\t\t\t  are always the X and Y coordinates.  After\n\t\t\t\t  that, we look for everything else by\n\t\t\t\t  local usage value\n\t\t\t\t */\n\t\t\t\tswitch (inputnum) {\n\t\t\t\tcase 0:  /* X coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: X Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_X == 0) {\n\t\t\t\t\t\tdevice->max_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  /* Y coord */\n\t\t\t\t\tdev_dbg(ddev, \"GER: Y Usage: 0x%x\\n\", usage);\n\t\t\t\t\tif (device->max_Y == 0) {\n\t\t\t\t\t\tdevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* Tilt X */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_X) {\n\t\t\t\t\t\tif (device->maxtilt_X == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Tilt Y */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_Y) {\n\t\t\t\t\t\tif (device->maxtilt_Y == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Pressure */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\n\t\t\t\t\t\tif (device->maxpressure == 0) {\n\t\t\t\t\t\t\tdevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputnum++;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_OUTPUT:\n\t\t\t\tmaintype = 'O';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_FEATURE:\n\t\t\t\tmaintype = 'F';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_START:\n\t\t\t\tmaintype = 'S';\n\n\t\t\t\tif (data == 0) {\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>> Physical\\n\");\n\t\t\t\t\tstrcpy(globtype, \"Physical\");\n\t\t\t\t} else\n\t\t\t\t\tdev_dbg(ddev, \"======>>>>>>\\n\");\n\n\t\t\t\t/* Indent the debug output */\n\t\t\t\tindent++;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Save global tags */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\toldval[x] = globalval[x];\n\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_END:\n\t\t\t\tdev_dbg(ddev, \"<<<<<<======\\n\");\n\t\t\t\tmaintype = 'E';\n\t\t\t\tindent--;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = '-';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Copy global tags back */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\tglobalval[x] = oldval[x];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_GLOBAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\t/*\n\t\t\t\t * First time we hit the global usage tag,\n\t\t\t\t * it should tell us the type of device\n\t\t\t\t */\n\t\t\t\tif (device->usage == 0)\n\t\t\t\t\tdevice->usage = data;\n\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"LOG_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"LOG_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MIN:\n\t\t\t\tstrcpy(globtype, \"PHYS_MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MAX:\n\t\t\t\tstrcpy(globtype, \"PHYS_MAX\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT_EXP:\n\t\t\t\tstrcpy(globtype, \"EXP\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT:\n\t\t\t\tstrcpy(globtype, \"UNIT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_SZ:\n\t\t\t\tstrcpy(globtype, \"REPORT_SZ\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_ID:\n\t\t\t\tstrcpy(globtype, \"REPORT_ID\");\n\t\t\t\t/* New report, restart numbering */\n\t\t\t\tinputnum = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_CNT:\n\t\t\t\tstrcpy(globtype, \"REPORT_CNT\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PUSH:\n\t\t\t\tstrcpy(globtype, \"PUSH\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_POP:\n\t\t\t\tstrcpy(globtype, \"POP\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check to make sure we have a good tag number\n\t\t\t   so we don't overflow array */\n\t\t\tif (tag < TAG_GLOB_MAX) {\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 1:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data);\n\t\t\t\t\tglobalval[tag] = data;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data16);\n\t\t\t\t\tglobalval[tag] = data16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data32);\n\t\t\t\t\tglobalval[tag] = data32;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(ddev, \"%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\\n\",\n\t\t\t\t\tindentstr, tag, size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_LOCAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\tstrcpy(globtype, \"USAGE\");\n\t\t\t\t/* Always 1 byte */\n\t\t\t\tusage = data;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, \"MIN\");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, \"MAX\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrcpy(globtype, \"UNKNOWN\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, \"%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n\",\n\t\t\t\t\tindentstr, tag, globtype, size, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*   INPUT DRIVER Routines                               */\n\n/*\n * Called when opening the input device.  This will submit the URB to\n * the usb system so we start getting reports\n */\nstatic int gtco_input_open(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\tdevice->urbinfo->dev = device->usbdev;\n\tif (usb_submit_urb(device->urbinfo, GFP_KERNEL))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n/*\n * Called when closing the input device.  This will unlink the URB\n */\nstatic void gtco_input_close(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\tusb_kill_urb(device->urbinfo);\n}\n\n\n/*\n *  Setup input device capabilities.  Tell the input system what this\n *  device is capable of generating.\n *\n *  This information is based on what is read from the HID report and\n *  placed in the struct gtco structure\n *\n */\nstatic void gtco_setup_caps(struct input_dev *inputdev)\n{\n\tstruct gtco *device = input_get_drvdata(inputdev);\n\n\t/* Which events */\n\tinputdev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) |\n\t\tBIT_MASK(EV_MSC);\n\n\t/* Misc event menu block */\n\tinputdev->mscbit[0] = BIT_MASK(MSC_SCAN) | BIT_MASK(MSC_SERIAL) |\n\t\tBIT_MASK(MSC_RAW);\n\n\t/* Absolute values based on HID report info */\n\tinput_set_abs_params(inputdev, ABS_X, device->min_X, device->max_X,\n\t\t\t     0, 0);\n\tinput_set_abs_params(inputdev, ABS_Y, device->min_Y, device->max_Y,\n\t\t\t     0, 0);\n\n\t/* Proximity */\n\tinput_set_abs_params(inputdev, ABS_DISTANCE, 0, 1, 0, 0);\n\n\t/* Tilt & pressure */\n\tinput_set_abs_params(inputdev, ABS_TILT_X, device->mintilt_X,\n\t\t\t     device->maxtilt_X, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_TILT_Y, device->mintilt_Y,\n\t\t\t     device->maxtilt_Y, 0, 0);\n\tinput_set_abs_params(inputdev, ABS_PRESSURE, device->minpressure,\n\t\t\t     device->maxpressure, 0, 0);\n\n\t/* Transducer */\n\tinput_set_abs_params(inputdev, ABS_MISC, 0, 0xFF, 0, 0);\n}\n\n/*   USB Routines  */\n\n/*\n * URB callback routine.  Called when we get IRQ reports from the\n *  digitizer.\n *\n *  This bridges the USB and input device worlds.  It generates events\n *  on the input device based on the USB reports.\n */\nstatic void gtco_urb_callback(struct urb *urbinfo)\n{\n\tstruct gtco *device = urbinfo->context;\n\tstruct input_dev  *inputdev;\n\tint               rc;\n\tu32               val = 0;\n\tchar              le_buffer[2];\n\n\tinputdev = device->inputdevice;\n\n\t/* Was callback OK? */\n\tif (urbinfo->status == -ECONNRESET ||\n\t    urbinfo->status == -ENOENT ||\n\t    urbinfo->status == -ESHUTDOWN) {\n\n\t\t/* Shutdown is occurring. Return and don't queue up any more */\n\t\treturn;\n\t}\n\n\tif (urbinfo->status != 0) {\n\t\t/*\n\t\t * Some unknown error.  Hopefully temporary. Just go and\n\t\t * requeue an URB\n\t\t */\n\t\tgoto resubmit;\n\t}\n\n\t/*\n\t * Good URB, now process\n\t */\n\n\t/* PID dependent when we interpret the report */\n\tif (inputdev->id.product == PID_1000 ||\n\t    inputdev->id.product == PID_1001 ||\n\t    inputdev->id.product == PID_1002) {\n\n\t\t/*\n\t\t * Switch on the report ID\n\t\t * Conveniently, the reports have more information, the higher\n\t\t * the report number.  We can just fall through the case\n\t\t * statements if we start with the highest number report\n\t\t */\n\t\tswitch (device->buffer[0]) {\n\t\tcase 5:\n\t\t\t/* Pressure is 9 bits */\n\t\t\tval = ((u16)(device->buffer[8]) << 1);\n\t\t\tval |= (u16)(device->buffer[7] >> 7);\n\t\t\tinput_report_abs(inputdev, ABS_PRESSURE,\n\t\t\t\t\t device->buffer[8]);\n\n\t\t\t/* Mask out the Y tilt value used for pressure */\n\t\t\tdevice->buffer[7] = (u8)((device->buffer[7]) & 0x7F);\n\n\t\t\t/* Fall thru */\n\t\tcase 4:\n\t\t\t/* Tilt */\n\t\t\tinput_report_abs(inputdev, ABS_TILT_X,\n\t\t\t\t\t sign_extend32(device->buffer[6], 6));\n\n\t\t\tinput_report_abs(inputdev, ABS_TILT_Y,\n\t\t\t\t\t sign_extend32(device->buffer[7], 6));\n\n\t\t\t/* Fall thru */\n\t\tcase 2:\n\t\tcase 3:\n\t\t\t/* Convert buttons, only 5 bits possible */\n\t\t\tval = (device->buffer[5]) & MASK_BUTTON;\n\n\t\t\t/* We don't apply any meaning to the bitmask,\n\t\t\t   just report */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SERIAL, val);\n\n\t\t\t/*  Fall thru */\n\t\tcase 1:\n\t\t\t/* All reports have X and Y coords in the same place */\n\t\t\tval = get_unaligned_le16(&device->buffer[1]);\n\t\t\tinput_report_abs(inputdev, ABS_X, val);\n\n\t\t\tval = get_unaligned_le16(&device->buffer[3]);\n\t\t\tinput_report_abs(inputdev, ABS_Y, val);\n\n\t\t\t/* Ditto for proximity bit */\n\t\t\tval = device->buffer[5] & MASK_INRANGE ? 1 : 0;\n\t\t\tinput_report_abs(inputdev, ABS_DISTANCE, val);\n\n\t\t\t/* Report 1 is an exception to how we handle buttons */\n\t\t\t/* Buttons are an index, not a bitmask */\n\t\t\tif (device->buffer[0] == 1) {\n\n\t\t\t\t/*\n\t\t\t\t * Convert buttons, 5 bit index\n\t\t\t\t * Report value of index set as one,\n\t\t\t\t * the rest as 0\n\t\t\t\t */\n\t\t\t\tval = device->buffer[5] & MASK_BUTTON;\n\t\t\t\tdev_dbg(&device->intf->dev,\n\t\t\t\t\t\"======>>>>>>REPORT 1: val 0x%X(%d)\\n\",\n\t\t\t\t\tval, val);\n\n\t\t\t\t/*\n\t\t\t\t * We don't apply any meaning to the button\n\t\t\t\t * index, just report it\n\t\t\t\t */\n\t\t\t\tinput_event(inputdev, EV_MSC, MSC_SERIAL, val);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 7:\n\t\t\t/* Menu blocks */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SCAN,\n\t\t\t\t    device->buffer[1]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Other pid class */\n\tif (inputdev->id.product == PID_400 ||\n\t    inputdev->id.product == PID_401) {\n\n\t\t/* Report 2 */\n\t\tif (device->buffer[0] == 2) {\n\t\t\t/* Menu blocks */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SCAN, device->buffer[1]);\n\t\t}\n\n\t\t/*  Report 1 */\n\t\tif (device->buffer[0] == 1) {\n\t\t\tchar buttonbyte;\n\n\t\t\t/*  IF X max > 64K, we still a bit from the y report */\n\t\t\tif (device->max_X > 0x10000) {\n\n\t\t\t\tval = (u16)(((u16)(device->buffer[2] << 8)) | (u8)device->buffer[1]);\n\t\t\t\tval |= (u32)(((u8)device->buffer[3] & 0x1) << 16);\n\n\t\t\t\tinput_report_abs(inputdev, ABS_X, val);\n\n\t\t\t\tle_buffer[0]  = (u8)((u8)(device->buffer[3]) >> 1);\n\t\t\t\tle_buffer[0] |= (u8)((device->buffer[3] & 0x1) << 7);\n\n\t\t\t\tle_buffer[1]  = (u8)(device->buffer[4] >> 1);\n\t\t\t\tle_buffer[1] |= (u8)((device->buffer[5] & 0x1) << 7);\n\n\t\t\t\tval = get_unaligned_le16(le_buffer);\n\t\t\t\tinput_report_abs(inputdev, ABS_Y, val);\n\n\t\t\t\t/*\n\t\t\t\t * Shift the button byte right by one to\n\t\t\t\t * make it look like the standard report\n\t\t\t\t */\n\t\t\t\tbuttonbyte = device->buffer[5] >> 1;\n\t\t\t} else {\n\n\t\t\t\tval = get_unaligned_le16(&device->buffer[1]);\n\t\t\t\tinput_report_abs(inputdev, ABS_X, val);\n\n\t\t\t\tval = get_unaligned_le16(&device->buffer[3]);\n\t\t\t\tinput_report_abs(inputdev, ABS_Y, val);\n\n\t\t\t\tbuttonbyte = device->buffer[5];\n\t\t\t}\n\n\t\t\t/* BUTTONS and PROXIMITY */\n\t\t\tval = buttonbyte & MASK_INRANGE ? 1 : 0;\n\t\t\tinput_report_abs(inputdev, ABS_DISTANCE, val);\n\n\t\t\t/* Convert buttons, only 4 bits possible */\n\t\t\tval = buttonbyte & 0x0F;\n#ifdef USE_BUTTONS\n\t\t\tfor (i = 0; i < 5; i++)\n\t\t\t\tinput_report_key(inputdev, BTN_DIGI + i, val & (1 << i));\n#else\n\t\t\t/* We don't apply any meaning to the bitmask, just report */\n\t\t\tinput_event(inputdev, EV_MSC, MSC_SERIAL, val);\n#endif\n\n\t\t\t/* TRANSDUCER */\n\t\t\tinput_report_abs(inputdev, ABS_MISC, device->buffer[6]);\n\t\t}\n\t}\n\n\t/* Everybody gets report ID's */\n\tinput_event(inputdev, EV_MSC, MSC_RAW,  device->buffer[0]);\n\n\t/* Sync it up */\n\tinput_sync(inputdev);\n\n resubmit:\n\trc = usb_submit_urb(urbinfo, GFP_ATOMIC);\n\tif (rc != 0)\n\t\tdev_err(&device->intf->dev,\n\t\t\t\"usb_submit_urb failed rc=0x%x\\n\", rc);\n}\n\n/*\n *  The probe routine.  This is called when the kernel find the matching USB\n *   vendor/product.  We do the following:\n *\n *    - Allocate mem for a local structure to manage the device\n *    - Request a HID Report Descriptor from the device and parse it to\n *      find out the device parameters\n *    - Create an input device and assign it attributes\n *   - Allocate an URB so the device can talk to us when the input\n *      queue is open\n */\nstatic int gtco_probe(struct usb_interface *usbinterface,\n\t\t      const struct usb_device_id *id)\n{\n\n\tstruct gtco             *gtco;\n\tstruct input_dev        *input_dev;\n\tstruct hid_descriptor   *hid_desc;\n\tchar                    *report;\n\tint                     result = 0, retry;\n\tint\t\t\terror;\n\tstruct usb_endpoint_descriptor *endpoint;\n\n\t/* Allocate memory for device structure */\n\tgtco = kzalloc(sizeof(struct gtco), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!gtco || !input_dev) {\n\t\tdev_err(&usbinterface->dev, \"No more memory\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Set pointer to the input device */\n\tgtco->inputdevice = input_dev;\n\n\t/* Save interface information */\n\tgtco->usbdev = interface_to_usbdev(usbinterface);\n\tgtco->intf = usbinterface;\n\n\t/* Allocate some data for incoming reports */\n\tgtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t\t\t  GFP_KERNEL, &gtco->buf_dma);\n\tif (!gtco->buffer) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for us buffers\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_devs;\n\t}\n\n\t/* Allocate URB for reports */\n\tgtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!gtco->urbinfo) {\n\t\tdev_err(&usbinterface->dev, \"Failed to allocate URB\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_buf;\n\t}\n\n\t/* Sanity check that a device has an endpoint */\n\tif (usbinterface->altsetting[0].desc.bNumEndpoints < 1) {\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Invalid number of endpoints\\n\");\n\t\terror = -EINVAL;\n\t\tgoto err_free_urb;\n\t}\n\n\t/*\n\t * The endpoint is always altsetting 0, we know this since we know\n\t * this device only has one interrupt endpoint\n\t */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\t/* Some debug */\n\tdev_dbg(&usbinterface->dev, \"gtco # interfaces: %d\\n\", usbinterface->num_altsetting);\n\tdev_dbg(&usbinterface->dev, \"num endpoints:     %d\\n\", usbinterface->cur_altsetting->desc.bNumEndpoints);\n\tdev_dbg(&usbinterface->dev, \"interface class:   %d\\n\", usbinterface->cur_altsetting->desc.bInterfaceClass);\n\tdev_dbg(&usbinterface->dev, \"endpoint: attribute:0x%x type:0x%x\\n\", endpoint->bmAttributes, endpoint->bDescriptorType);\n\tif (usb_endpoint_xfer_int(endpoint))\n\t\tdev_dbg(&usbinterface->dev, \"endpoint: we have interrupt endpoint\\n\");\n\n\tdev_dbg(&usbinterface->dev, \"endpoint extra len:%d\\n\", usbinterface->altsetting[0].extralen);\n\n\t/*\n\t * Find the HID descriptor so we can find out the size of the\n\t * HID report descriptor\n\t */\n\tif (usb_get_extra_descriptor(usbinterface->cur_altsetting,\n\t\t\t\t     HID_DEVICE_TYPE, &hid_desc) != 0) {\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Can't retrieve exta USB descriptor to get hid report descriptor length\\n\");\n\t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\tdev_dbg(&usbinterface->dev,\n\t\t\"Extra descriptor success: type:%d  len:%d\\n\",\n\t\thid_desc->bDescriptorType,  hid_desc->wDescriptorLength);\n\n\treport = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL);\n\tif (!report) {\n\t\tdev_err(&usbinterface->dev, \"No more memory for report\\n\");\n\t\terror = -ENOMEM;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Couple of tries to get reply */\n\tfor (retry = 0; retry < 3; retry++) {\n\t\tresult = usb_control_msg(gtco->usbdev,\n\t\t\t\t\t usb_rcvctrlpipe(gtco->usbdev, 0),\n\t\t\t\t\t USB_REQ_GET_DESCRIPTOR,\n\t\t\t\t\t USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t\t REPORT_DEVICE_TYPE << 8,\n\t\t\t\t\t 0, /* interface */\n\t\t\t\t\t report,\n\t\t\t\t\t le16_to_cpu(hid_desc->wDescriptorLength),\n\t\t\t\t\t 5000); /* 5 secs */\n\n\t\tdev_dbg(&usbinterface->dev, \"usb_control_msg result: %d\\n\", result);\n\t\tif (result == le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\t\tparse_hid_report_descriptor(gtco, report, result);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(report);\n\n\t/* If we didn't get the report, fail */\n\tif (result != le16_to_cpu(hid_desc->wDescriptorLength)) {\n\t\tdev_err(&usbinterface->dev,\n\t\t\t\"Failed to get HID Report Descriptor of size: %d\\n\",\n\t\t\thid_desc->wDescriptorLength);\n\t\terror = -EIO;\n\t\tgoto err_free_urb;\n\t}\n\n\t/* Create a device file node */\n\tusb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath));\n\tstrlcat(gtco->usbpath, \"/input0\", sizeof(gtco->usbpath));\n\n\t/* Set Input device functions */\n\tinput_dev->open = gtco_input_open;\n\tinput_dev->close = gtco_input_close;\n\n\t/* Set input device information */\n\tinput_dev->name = \"GTCO_CalComp\";\n\tinput_dev->phys = gtco->usbpath;\n\n\tinput_set_drvdata(input_dev, gtco);\n\n\t/* Now set up all the input device capabilities */\n\tgtco_setup_caps(input_dev);\n\n\t/* Set input device required ID information */\n\tusb_to_input_id(gtco->usbdev, &input_dev->id);\n\tinput_dev->dev.parent = &usbinterface->dev;\n\n\t/* Setup the URB, it will be posted later on open of input device */\n\tendpoint = &usbinterface->altsetting[0].endpoint[0].desc;\n\n\tusb_fill_int_urb(gtco->urbinfo,\n\t\t\t gtco->usbdev,\n\t\t\t usb_rcvintpipe(gtco->usbdev,\n\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t gtco->buffer,\n\t\t\t REPORT_MAX_SIZE,\n\t\t\t gtco_urb_callback,\n\t\t\t gtco,\n\t\t\t endpoint->bInterval);\n\n\tgtco->urbinfo->transfer_dma = gtco->buf_dma;\n\tgtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t/* Save gtco pointer in USB interface gtco */\n\tusb_set_intfdata(usbinterface, gtco);\n\n\t/* All done, now register the input device */\n\terror = input_register_device(input_dev);\n\tif (error)\n\t\tgoto err_free_urb;\n\n\treturn 0;\n\n err_free_urb:\n\tusb_free_urb(gtco->urbinfo);\n err_free_buf:\n\tusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t  gtco->buffer, gtco->buf_dma);\n err_free_devs:\n\tinput_free_device(input_dev);\n\tkfree(gtco);\n\treturn error;\n}\n\n/*\n *  This function is a standard USB function called when the USB device\n *  is disconnected.  We will get rid of the URV, de-register the input\n *  device, and free up allocated memory\n */\nstatic void gtco_disconnect(struct usb_interface *interface)\n{\n\t/* Grab private device ptr */\n\tstruct gtco *gtco = usb_get_intfdata(interface);\n\n\t/* Now reverse all the registration stuff */\n\tif (gtco) {\n\t\tinput_unregister_device(gtco->inputdevice);\n\t\tusb_kill_urb(gtco->urbinfo);\n\t\tusb_free_urb(gtco->urbinfo);\n\t\tusb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE,\n\t\t\t\t  gtco->buffer, gtco->buf_dma);\n\t\tkfree(gtco);\n\t}\n\n\tdev_info(&interface->dev, \"gtco driver disconnected\\n\");\n}\n\n/*   STANDARD MODULE LOAD ROUTINES  */\n\nstatic struct usb_driver gtco_driverinfo_table = {\n\t.name\t\t= \"gtco\",\n\t.id_table\t= gtco_usbid_table,\n\t.probe\t\t= gtco_probe,\n\t.disconnect\t= gtco_disconnect,\n};\n\nmodule_usb_driver(gtco_driverinfo_table);\n\nMODULE_DESCRIPTION(\"GTCO digitizer USB driver\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/input/tablet/gtco.c"], "buggy_code_start_loc": [860], "buggy_code_end_loc": [883], "fixing_code_start_loc": [861], "fixing_code_end_loc": [891], "type": "NVD-CWE-Other", "message": "The gtco_probe function in drivers/input/tablet/gtco.c in the Linux kernel through 4.5.2 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.", "other": {"cve": {"id": "CVE-2016-2187", "sourceIdentifier": "secalert@redhat.com", "published": "2016-05-02T10:59:30.847", "lastModified": "2016-11-28T20:03:44.510", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/476.html\">CWE-476: NULL Pointer Dereference</a>", "descriptions": [{"lang": "en", "value": "The gtco_probe function in drivers/input/tablet/gtco.c in the Linux kernel through 4.5.2 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor."}, {"lang": "es", "value": "La funci\u00f3n gtco_probe en drivers/input/tablet/gtco.c en el kernel de Linux hasta la versi\u00f3n 4.5.2 permite a atacantes f\u00edsicamente pr\u00f3ximos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda de sistema) a trav\u00e9s de un valor de dispositivos finales manipulado en un descriptor de dispositivo USB."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B6B7CAD7-9D4E-4FDB-88E3-1E583210A01F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.5.2", "matchCriteriaId": "8E93DE20-F6CD-4B8B-836D-7844A2697466"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_debuginfo:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "B942E0F5-7FDC-4AE5-985D-25F4EA7406F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:11:extra:*:*:*:*:*:*", "matchCriteriaId": "4B24E780-3254-4577-BCFF-7FBB6D97C780"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "095856BE-4E55-4FEA-BCAC-352C29083545"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_software_development_kit:11.0:sp4:*:*:*:*:*:*", "matchCriteriaId": "F1E42F04-5E14-4CF6-BD26-C54A4ECD99CF"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=162f98dea487206d9ab79fc12ed64700667a894d", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00052.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00007.html", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2016/dsa-3607", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/85425", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2989-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2996-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2997-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2998-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3000-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3001-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3002-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3003-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3004-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3005-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3006-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-3007-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1317017", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/162f98dea487206d9ab79fc12ed64700667a894d"}}