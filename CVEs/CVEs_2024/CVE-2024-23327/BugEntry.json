{"buggy_code": ["date: Pending\n\nbehavior_changes:\n# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nminor_behavior_changes:\n# *Changes that may cause incompatibilities for some users, but should not for most*\n- area: adaptive concurrency filter stats\n  change: |\n    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).\n- area: dns\n  change: |\n    Allowing <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to go as low as 1s.\n- area: upstream\n  change: |\n    Upstream now excludes hosts set to ``DRAINING`` state via EDS from load balancing and panic routing\n    threshold calculation. This feature can be disabled by setting\n    ``envoy.reloadable_features.exclude_host_in_eds_status_draining`` to false.\n- area: golang\n  change: |\n    Change ``RegisterHttpFilterConfigFactoryAndParser`` to ``RegisterHttpFilterFactoryAndConfigParser``.\n- area: QUIC\n  change: |\n    Port migration is default turned off. QUIC client connections will no longer attempt to migrate to a new port when connections\n    is degrading. Can be manually turned on via\n    :ref:`port_migration <envoy_v3_api_field_config.core.v3.QuicProtocolOptions.num_timeouts_to_trigger_port_migration>`.\n- area: aws\n  change: |\n    AWS region string is now retrieved from environment and profile consistently within aws_request_signer and\n    grpc_credentials/aws_iam extensions. Region field in aws_request_signer is now optional, explicitly configured\n    xDS region will take preference. aws_request_signer documentation now reflects the region chain.\n\nbug_fixes:\n# *Changes expected to improve the state of the world and are unlikely to have negative effects*\n- area: tracers\n  change: |\n    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.\n- area: load balancing\n  change: |\n    Added randomization in locality load-balancing initialization. This helps desynchronizing Envoys across\n    a fleet by randomizing the scheduler starting point. This can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.edf_lb_locality_scheduler_init_fix`` to false.\n- area: UDP and TCP tunneling\n  change: |\n    fixed a bug where second HTTP response headers received would cause Envoy to crash in cases where\n    ``propagate_response_headers`` and retry configurations are enabled at the same time, and an upstream\n    request is retried multiple times.\n- area: tracing\n  change: |\n    Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n\nremoved_config_or_runtime:\n# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n- area: http\n  change: |\n    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.\n- area: active health check\n  change: |\n    Removed ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` runtime flag and legacy code paths.\n- area: http1\n  change: |\n    Removed ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers`` runtime flag and legacy code paths.\n- area: overload manager\n  change: |\n    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.\n- area: http\n  change: |\n    Removed ``envoy_reloadable_features_append_xfh_idempotent`` runtime flag and legacy code paths.\n- area: resource_monitors\n  change: |\n    removed ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` runtime flag  and legacy code paths.\n\nnew_features:\n- area: aws_request_signing\n  change: |\n    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: aws_lambda\n  change: |\n    Update ``aws_lambda`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: grpc reverse bridge\n  change: |\n    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter\n    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.\n- area: quic\n  change: |\n    Added QUIC protocol option :ref:`send_disable_active_migration\n    <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.send_disable_active_migration>` to make the server send clients a transport\n    parameter to discourage client endpoints from active migration.\n- area: ext_proc\n  change: |\n    implemented\n    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`\n    and\n    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`\n    config APIs to enable sending and receiving attributes to/from the external processing server.\n- area: access log\n  change: |\n    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection\n    identifier.\n- area: aws_lambda\n  change: |\n    Added :ref:`host_rewrite <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.host_rewrite>` config to be used\n    during signature.\n- area: ext_proc\n  change: |\n    added\n    :ref:`metadata_options <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.metadata_options>`\n    config API to enable sending and receiving metadata from/to the external processing server. Both typed and untyped dynamic\n    metadata may be sent to the server. If\n    :ref:`receiving_namespaces <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.MetadataOptions.receiving_namespaces>`\n    is defined, returned metadata may be written to the specified allowed namespaces.\n- area: monitoring\n  change: |\n    Add ``Envoy::ExecutionContext``, which is notified by ``ScopeTrackerScopeState``'s constructor and destructor. This feature is\n    disabled by default, it can be enabled by runtime feature flag ``envoy.restart_features.enable_execution_context``. For more details,\n    please see https://github.com/envoyproxy/envoy/issues/32012.\n- area: rbac\n  change: |\n    Added :ref:`uri_template<envoy_v3_api_field_config.rbac.v3.Permission.uri_template>` which uses existing\n    :ref:`UriTemplateMatchConfig<envoy_v3_api_msg_extensions.path.match.uri_template.v3.UriTemplateMatchConfig>`\n    to allow use of glob patterns for URI path matching in RBAC.\n- area: upstream\n  change: |\n    Added :ref:`selection_method <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    option to the least request load balancer. If set to ``FULL_SCAN``,\n    Envoy will select the host with the fewest active requests from the entire host set rather than\n    :ref:`choice_count <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    random choices.\n\ndeprecated:\n", "#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\n#include <sstream>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/network/address.h\"\n\n#include \"source/common/network/address_impl.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Common {\nnamespace ProxyProtocol {\n\nvoid generateV1Header(const std::string& src_addr, const std::string& dst_addr, uint32_t src_port,\n                      uint32_t dst_port, Network::Address::IpVersion ip_version,\n                      Buffer::Instance& out) {\n  std::ostringstream stream;\n  stream << PROXY_PROTO_V1_SIGNATURE;\n\n  switch (ip_version) {\n  case Network::Address::IpVersion::v4:\n    stream << PROXY_PROTO_V1_AF_INET << \" \";\n    break;\n  case Network::Address::IpVersion::v6:\n    stream << PROXY_PROTO_V1_AF_INET6 << \" \";\n    break;\n  }\n\n  stream << src_addr << \" \";\n  stream << dst_addr << \" \";\n  stream << src_port << \" \";\n  stream << dst_port << \"\\r\\n\";\n\n  out.add(stream.str());\n}\n\nvoid generateV1Header(const Network::Address::Ip& source_address,\n                      const Network::Address::Ip& dest_address, Buffer::Instance& out) {\n  generateV1Header(source_address.addressAsString(), dest_address.addressAsString(),\n                   source_address.port(), dest_address.port(), source_address.version(), out);\n}\n\nvoid generateV2Header(const std::string& src_addr, const std::string& dst_addr, uint32_t src_port,\n                      uint32_t dst_port, Network::Address::IpVersion ip_version,\n                      uint16_t extension_length, Buffer::Instance& out) {\n  out.add(PROXY_PROTO_V2_SIGNATURE, PROXY_PROTO_V2_SIGNATURE_LEN);\n\n  const uint8_t version_and_command = PROXY_PROTO_V2_VERSION << 4 | PROXY_PROTO_V2_ONBEHALF_OF;\n  out.add(&version_and_command, 1);\n\n  uint8_t address_family_and_protocol;\n  switch (ip_version) {\n  case Network::Address::IpVersion::v4:\n    address_family_and_protocol = PROXY_PROTO_V2_AF_INET << 4;\n    break;\n  case Network::Address::IpVersion::v6:\n    address_family_and_protocol = PROXY_PROTO_V2_AF_INET6 << 4;\n    break;\n  }\n  address_family_and_protocol |= PROXY_PROTO_V2_TRANSPORT_STREAM;\n  out.add(&address_family_and_protocol, 1);\n\n  // Number of following bytes part of the header in V2 protocol.\n  uint16_t addr_length;\n  uint16_t addr_length_n; // Network byte order\n\n  switch (ip_version) {\n  case Network::Address::IpVersion::v4: {\n    addr_length = PROXY_PROTO_V2_ADDR_LEN_INET + extension_length;\n    addr_length_n = htons(addr_length);\n    out.add(&addr_length_n, 2);\n    const uint32_t net_src_addr =\n        Network::Address::Ipv4Instance(src_addr, src_port).ip()->ipv4()->address();\n    const uint32_t net_dst_addr =\n        Network::Address::Ipv4Instance(dst_addr, dst_port).ip()->ipv4()->address();\n    out.add(&net_src_addr, 4);\n    out.add(&net_dst_addr, 4);\n    break;\n  }\n  case Network::Address::IpVersion::v6: {\n    addr_length = PROXY_PROTO_V2_ADDR_LEN_INET6 + extension_length;\n    addr_length_n = htons(addr_length);\n    out.add(&addr_length_n, 2);\n    const absl::uint128 net_src_addr =\n        Network::Address::Ipv6Instance(src_addr, src_port).ip()->ipv6()->address();\n    const absl::uint128 net_dst_addr =\n        Network::Address::Ipv6Instance(dst_addr, dst_port).ip()->ipv6()->address();\n    out.add(&net_src_addr, 16);\n    out.add(&net_dst_addr, 16);\n    break;\n  }\n  }\n\n  const uint16_t net_src_port = htons(static_cast<uint16_t>(src_port));\n  const uint16_t net_dst_port = htons(static_cast<uint16_t>(dst_port));\n  out.add(&net_src_port, 2);\n  out.add(&net_dst_port, 2);\n}\n\nvoid generateV2Header(const std::string& src_addr, const std::string& dst_addr, uint32_t src_port,\n                      uint32_t dst_port, Network::Address::IpVersion ip_version,\n                      Buffer::Instance& out) {\n  generateV2Header(src_addr, dst_addr, src_port, dst_port, ip_version, 0, out);\n}\n\nvoid generateV2Header(const Network::Address::Ip& source_address,\n                      const Network::Address::Ip& dest_address, Buffer::Instance& out) {\n  generateV2Header(source_address.addressAsString(), dest_address.addressAsString(),\n                   source_address.port(), dest_address.port(), source_address.version(), 0, out);\n}\n\nbool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer::Instance& out,\n                      bool pass_all_tlvs, const absl::flat_hash_set<uint8_t>& pass_through_tlvs) {\n  uint64_t extension_length = 0;\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    extension_length += PROXY_PROTO_V2_TLV_TYPE_LENGTH_LEN + tlv.value.size();\n    if (extension_length > std::numeric_limits<uint16_t>::max()) {\n      ENVOY_LOG_MISC(\n          warn, \"Generating Proxy Protocol V2 header: TLVs exceed length limit {}, already got {}\",\n          std::numeric_limits<uint16_t>::max(), extension_length);\n      return false;\n    }\n  }\n\n  ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n  const auto& src = *proxy_proto_data.src_addr_->ip();\n  const auto& dst = *proxy_proto_data.dst_addr_->ip();\n  generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),\n                   src.version(), static_cast<uint16_t>(extension_length), out);\n\n  // Generate the TLV vector.\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    out.add(&tlv.type, 1);\n    uint16_t size = htons(static_cast<uint16_t>(tlv.value.size()));\n    out.add(&size, sizeof(uint16_t));\n    out.add(&tlv.value.front(), tlv.value.size());\n  }\n  return true;\n}\n\nvoid generateProxyProtoHeader(const envoy::config::core::v3::ProxyProtocolConfig& config,\n                              const Network::Connection& connection, Buffer::Instance& out) {\n  const Network::Address::Ip& dest_address =\n      *connection.connectionInfoProvider().localAddress()->ip();\n  const Network::Address::Ip& source_address =\n      *connection.connectionInfoProvider().remoteAddress()->ip();\n  if (config.version() == envoy::config::core::v3::ProxyProtocolConfig::V1) {\n    generateV1Header(source_address, dest_address, out);\n  } else if (config.version() == envoy::config::core::v3::ProxyProtocolConfig::V2) {\n    generateV2Header(source_address, dest_address, out);\n  }\n}\n\nvoid generateV2LocalHeader(Buffer::Instance& out) {\n  out.add(PROXY_PROTO_V2_SIGNATURE, PROXY_PROTO_V2_SIGNATURE_LEN);\n  const uint8_t addr_fam_protocol_and_length[4]{PROXY_PROTO_V2_VERSION << 4, 0, 0, 0};\n  out.add(addr_fam_protocol_and_length, 4);\n}\n\n} // namespace ProxyProtocol\n} // namespace Common\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/listen_socket.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_HEADER_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_LOCAL;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ONBEHALF_OF;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_DGRAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_STREAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_VERSION;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\n\nConfig::Config(\n    Stats::Scope& scope,\n    const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol& proto_config)\n    : stats_{ALL_PROXY_PROTOCOL_STATS(POOL_COUNTER(scope))},\n      allow_requests_without_proxy_protocol_(proto_config.allow_requests_without_proxy_protocol()),\n      pass_all_tlvs_(proto_config.has_pass_through_tlvs()\n                         ? proto_config.pass_through_tlvs().match_type() ==\n                               ProxyProtocolPassThroughTLVs::INCLUDE_ALL\n                         : false) {\n  for (const auto& rule : proto_config.rules()) {\n    tlv_types_[0xFF & rule.tlv_type()] = rule.on_tlv_present();\n  }\n\n  if (proto_config.has_pass_through_tlvs() &&\n      proto_config.pass_through_tlvs().match_type() == ProxyProtocolPassThroughTLVs::INCLUDE) {\n    for (const auto& tlv_type : proto_config.pass_through_tlvs().tlv_type()) {\n      pass_through_tlvs_.insert(0xFF & tlv_type);\n    }\n  }\n}\n\nconst KeyValuePair* Config::isTlvTypeNeeded(uint8_t type) const {\n  auto tlv_type = tlv_types_.find(type);\n  if (tlv_types_.end() != tlv_type) {\n    return &tlv_type->second;\n  }\n\n  return nullptr;\n}\n\nbool Config::isPassThroughTlvTypeNeeded(uint8_t tlv_type) const {\n  if (pass_all_tlvs_) {\n    return true;\n  }\n  return pass_through_tlvs_.contains(tlv_type);\n}\n\nsize_t Config::numberOfNeededTlvTypes() const { return tlv_types_.size(); }\n\nbool Config::allowRequestsWithoutProxyProtocol() const {\n  return allow_requests_without_proxy_protocol_;\n}\n\nNetwork::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {\n  ENVOY_LOG(debug, \"proxy_protocol: New connection accepted\");\n  cb_ = &cb;\n  // Waiting for data.\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Filter::onData(Network::ListenerFilterBuffer& buffer) {\n  const ReadOrParseState read_state = parseBuffer(buffer);\n  switch (read_state) {\n  case ReadOrParseState::Error:\n    config_->stats_.downstream_cx_proxy_proto_error_.inc();\n    cb_->socket().ioHandle().close();\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::TryAgainLater:\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::SkipFilter:\n    return Network::FilterStatus::Continue;\n  case ReadOrParseState::Done:\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::Continue;\n}\n\nReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    if (!proxy_protocol_header_.value().local_command_) {\n      auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, length: {}, buffer: {}, TLV length: {}, TLV buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n    }\n\n    cb_->filterState().setData(\n        Network::ProxyProtocolFilterState::key(),\n        std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n            proxy_protocol_header_.value().remote_address_,\n            proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n        StreamInfo::FilterState::StateType::Mutable, StreamInfo::FilterState::LifeSpan::Connection);\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}\n\nabsl::optional<size_t> Filter::lenV2Address(const char* buf) {\n  const uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  size_t len;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // According to the spec there is no address encoded, len=0, and we must ignore\n    return 0;\n  }\n\n  switch ((proto_family & 0xf0) >> 4) {\n  case PROXY_PROTO_V2_AF_INET:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET;\n    break;\n  case PROXY_PROTO_V2_AF_INET6:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET6;\n    break;\n  default:\n    ENVOY_LOG(debug, \"Unsupported V2 proxy protocol address family\");\n    return absl::nullopt;\n  }\n  return len;\n}\n\nbool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n        proxy_protocol_header_.emplace(\n            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        proxy_protocol_header_.emplace(WireHeader{\n            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}\n\nbool Filter::parseV1Header(const char* buf, size_t len) {\n  std::string proxy_line;\n  proxy_line.assign(buf, len);\n  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);\n\n  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS\n  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.\n  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, \" \", true);\n  if (line_parts.size() < 2 || line_parts[0] != \"PROXY\") {\n    ENVOY_LOG(debug, \"failed to read proxy protocol\");\n    return false;\n  }\n\n  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from\n  // the socket and continue. According to spec \"real connection's parameters\" should be used, so\n  // we should NOT restore the addresses in this case.\n  if (line_parts[1] != \"UNKNOWN\") {\n    // If protocol not UNKNOWN, src and dst addresses have to be present.\n    if (line_parts.size() != 6) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n\n    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view\n    // arguments, so we can eliminate allocation here.\n    if (line_parts[1] == \"TCP4\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + \":\" +\n                                                               std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + \":\" +\n                                                               std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});\n      return true;\n    } else if (line_parts[1] == \"TCP6\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[2]} +\n                                                               \"]:\" + std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[3]} +\n                                                               \"]:\" + std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});\n      return true;\n    } else {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n  }\n  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});\n  return true;\n}\n\n/**\n * @note  A TLV is arranged in the following format:\n *        struct pp2_tlv {\n *          uint8_t type;\n *          uint8_t length_hi;\n *          uint8_t length_lo;\n *          uint8_t value[0];\n *        };\n *        See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details\n */\nbool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}\n\nReadOrParseState Filter::readExtensions(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  // waiting for more data if there is no enough data for extensions.\n  if (raw_slice.len_ < (proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.value().local_command_) {\n    // Ignores the extensions if this is a local command.\n    // Those will drained from the buffer in the end.\n    return ReadOrParseState::Done;\n  }\n\n  const uint8_t* buf = static_cast<const uint8_t*>(raw_slice.mem_) +\n                       proxy_protocol_header_.value().headerLengthWithoutExtension();\n  if (!parseTlvs(buf, proxy_protocol_header_.value().extensions_length_)) {\n    return ReadOrParseState::Error;\n  }\n\n  return ReadOrParseState::Done;\n}\n\nReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  const char* buf = static_cast<const char*>(raw_slice.mem_);\n\n  if (config_.get()->allowRequestsWithoutProxyProtocol()) {\n    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));\n    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));\n    if (!matchv2 && !matchv1) {\n      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely\n      // short-circuit\n      ENVOY_LOG(trace, \"request does not use v1 or v2 proxy protocol, forwarding as is\");\n      return ReadOrParseState::SkipFilter;\n    }\n  }\n\n  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {\n    const char* sig = PROXY_PROTO_V2_SIGNATURE;\n    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {\n      header_version_ = V2;\n    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {\n      // It is not v2, and can't be v1, so no sense hanging around: it is invalid\n      ENVOY_LOG(debug, \"failed to read proxy protocol (exceed max v1 header len)\");\n      return ReadOrParseState::Error;\n    }\n  }\n\n  if (header_version_ == V2) {\n    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {\n      ENVOY_LOG(debug, \"Unsupported V2 proxy protocol version\");\n      return ReadOrParseState::Error;\n    }\n    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);\n    if (!addr_len_opt.has_value()) {\n      return ReadOrParseState::Error;\n    }\n    ssize_t addr_len = addr_len_opt.value();\n    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n    if (hdr_addr_len < addr_len) {\n      ENVOY_LOG(debug,\n                \"incorrect address length, address length = {}, the expected address length = {}\",\n                hdr_addr_len, addr_len);\n      return ReadOrParseState::Error;\n    }\n    // waiting for more data if there is no enough data for address.\n    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {\n      // The TLV remain, they are parsed in `parseTlvs()` which is called from the\n      // parent (if needed).\n      if (parseV2Header(buf)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  } else {\n    // continue searching buffer from where we left off\n    for (; search_index_ < raw_slice.len_; search_index_++) {\n      if (buf[search_index_] == '\\n' && buf[search_index_ - 1] == '\\r') {\n        if (search_index_ == 1) {\n          // There is not enough data to determine if it contains the v2 protocol signature, so wait\n          // for more data.\n          break;\n        } else {\n          header_version_ = V1;\n          search_index_++;\n        }\n        break;\n      }\n    }\n\n    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {\n      return ReadOrParseState::Error;\n    }\n\n    if (header_version_ == V1) {\n      if (parseV1Header(buf, search_index_)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  }\n\n  return ReadOrParseState::TryAgainLater;\n}\n\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/listener_manager/connection_handler_impl.h\"\n#include \"source/common/network/connection_balancer_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/raw_buffer_socket.h\"\n#include \"source/common/network/tcp_listener_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include \"test/mocks/api/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/listener_factory_context.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/threadsafe_singleton_injector.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::ElementsAre;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\nnamespace {\n\n// Build again on the basis of the connection_handler_test.cc\n\nclass ProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                          public Network::ListenerConfig,\n                          public Network::FilterChainManager,\n                          protected Logger::Loggable<Logger::Id::main> {\npublic:\n  ProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getCanonicalLoopbackAddress(GetParam()))),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                                Network::Address::InstanceConstSharedPtr(),\n                                                Network::Test::createRawBufferSocket(), nullptr,\n                                                nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect(bool read = true,\n               const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol*\n                   proto_config = nullptr) {\n    int expected_callbacks = 2;\n    auto maybeExitDispatcher = [&]() -> void {\n      expected_callbacks--;\n      if (expected_callbacks == 0) {\n        dispatcher_->exit();\n      }\n    };\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr, std::make_unique<Filter>(std::make_shared<Config>(\n                           listenerScope(), (nullptr != proto_config)\n                                                ? *proto_config\n                                                : envoy::extensions::filters::listener::\n                                                      proxy_protocol::v3::ProxyProtocol())));\n          maybeExitDispatcher();\n          return true;\n        }));\n    conn_->connect();\n    if (read) {\n      read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n      EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n          .WillOnce(Invoke([&](Network::Connection& connection,\n                               const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n            server_connection_ = &connection;\n            connection.addConnectionCallbacks(server_callbacks_);\n            connection.addReadFilter(read_filter_);\n            return true;\n          }));\n    }\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { maybeExitDispatcher(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const uint8_t* s, ssize_t l) {\n    Buffer::OwnedImpl buf(s, l);\n    conn_->write(buf, false);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void expectConnectionError() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n  void expectProxyProtoError() {\n    expectConnectionError();\n    EXPECT_EQ(stats_store_.counter(\"downstream_cx_proxy_proto_error\").value(), 1);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::TestUtil::TestStore stats_store_;\n  Api::ApiPtr api_;\n  BasicResourceLimitImpl open_connections_;\n  Event::DispatcherPtr dispatcher_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  Api::OsSysCallsImpl os_sys_calls_actual_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(ProxyProtocolTest, V1Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocol) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"data\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN,\n            msg.length()); // Ensure we attempt parsing byte by byte using `search_index_`\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV1First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v1, second two bytes are proxy protocol v2.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"PR\\r\\n\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV2First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v2, second two bytes are proxy protocol v1.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"\\r\\nOX\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowLargeNoProxyProtocol) {\n  // Allows a large request (more bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"more data more data more data\";\n  ASSERT_GT(msg.length(),\n            PROXY_PROTO_V2_HEADER_LEN); // Ensure we attempt parsing as v2 proxy protocol up front\n                                        // rather than parsing byte by byte using `search_index_`\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V1Minimal) {\n  connect();\n  write(\"PROXY UNKNOWN\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  } else {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Basic) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2BasicV6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedAF) {\n  // A well-formed message with an unsupported address family\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x41, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_2) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n// TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_1) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2NotLocalOrOnBehalf) {\n  // An illegal command type: neither 'local' nor 'proxy' command\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x23, 0x1f, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnection) {\n  // A 'local' connection, e.g. health-checking, no address, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n  // A 'local' connection, e.g. health-checking, no address, 1 TLV (0x00,0x00,0x01,0xff) is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xff,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4) {\n  // An ipv4/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4WithAllowNoProxyProtocol) {\n  // An ipv4/tcp PROXY header that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV4) {\n  // An ipv4/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0b, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV6) {\n  // An ipv6/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV6) {\n  // An ipv6/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x23, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2AF_UNIX) {\n  // A well-formed AF_UNIX (0x32 in b14) connection is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2BadCommand) {\n  // A non local/proxy command (0x29 in b13) is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x29, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongVersion) {\n  // A non '2' version is rejected (0x93 in b13)\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x93, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLong) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLongWithAllowNoProxyProtocol) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsRecvError) {\n  // A well-formed ipv4/tcp with a TLV extension. An error is returned on tlv recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n  bool header_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int iovcnt) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, iovcnt);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  header_writed = true;\n  write(tlv, sizeof(tlv));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsFrag) {\n  // A well-formed ipv4/tcp header with 2 TLV/extensions, these are fragmented on delivery\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, Fragmented) {\n  connect();\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  // If there is no data after the PROXY line, the read filter does not receive even the\n  // onNewConnection() callback. We need this in order to run the dispatcher in blocking\n  // mode to make sure that proxy protocol processing is completed before we start testing\n  // the results. Since we must have data we might as well check that we get it.\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented1) {\n  // A well-formed ipv4/tcp message, delivering part of the signature, then part of\n  // the address, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 10, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 20, 17);\n\n  expectData(\"more data\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented2) {\n  // A well-formed ipv4/tcp message, delivering all of the header + 1, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 17, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 27, 10);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented3) {\n  // A well-formed ipv4/tcp message, delivering all of the header, then the remainder.\n  // Do not mistakenly consider that remote has closed when it happens to only read the\n  // header of the message. See: https://github.com/envoyproxy/envoy/pull/18304\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 16);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 16, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 26, 11);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented4Error) {\n  // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error\n  // simulated in recv() on the +1\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_writed = true;\n  write(buffer, 11);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented5Error) {\n  // A well-formed ipv4/tcp message, part of the signature with an error introduced\n  // in recv() on the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_write = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_write = true;\n  write(buffer + 10, 10);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, PartialRead) {\n  connect();\n\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PROXY TCP4\"); // Intentionally larger than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PRO\"); // Intentionally smaller than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"XY TCP4 25\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"4.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2PartialRead) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  connect();\n\n  for (size_t i = 0; i < sizeof(buffer); i += 9) {\n    write(&buffer[i], 9);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 18 intentionally as it is larger than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 18;\n  ASSERT_LT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 3 intentionally as it is smaller than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 3;\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nconst std::string ProxyProtocol = \"envoy.filters.listener.proxy_protocol\";\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsLargeThanInitMaxReadBytes) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // The TLV has 65520 size data.\n  constexpr uint8_t tlv_begin[] = {0x02, 0xff, 0xf0};\n  std::string tlv_data(65520, 'a');\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv_begin, sizeof(tlv_begin));\n  write(tlv_data);\n\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  EXPECT_EQ(tlv_data, value_s);\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterestAndEmitWithSpecifiedMetadataNamespace) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n  rule->mutable_on_tlv_present()->set_metadata_namespace(\"We need a different metadata namespace\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(\"We need a different metadata namespace\"));\n\n  auto fields = metadata.at(\"We need a different metadata namespace\").fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0xea with size of 25 bytes (22 bytes are value)\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0x32, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, 0x32, 0x35, 0x74, 0x65, 0x73, 0x74,\n                          0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WillNotOverwriteTLV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x2a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority1[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                             0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0x02 (again) with size of 10 bytes (7 bytes are value) and different values\n  constexpr uint8_t tlv_type_authority2[] = {0x02, 0x00, 0x07, 0x62, 0x61,\n                                             0x72, 0x2e, 0x6e, 0x65, 0x74};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority1, sizeof(tlv_type_authority1));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_type_authority2, sizeof(tlv_type_authority2));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongTLVLength) {\n  // A well-formed ipv4/tcp with buffer[14]15] being 0x00 and 0x10. It says we should have 16 bytes\n  // following.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // tlv[2] should be 0x1 since there's only one byte for tlv value.\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x2, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv, sizeof(tlv));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2IncompleteTLV) {\n  // A ipv4/tcp with buffer[14]15] being 0x00 and 0x11. It says we should have 17 bytes following,\n  // however we have 20.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x11, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  // a TLV of type 0x01 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv2[] = {0x1, 0x0, 0x1, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  auto rule_01 = proto_config.add_rules();\n  rule_01->set_tlv_type(0x01);\n  rule_01->mutable_on_tlv_present()->set_key(\"01\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv1, sizeof(tlv1));\n  write(tlv2, sizeof(tlv2));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterState) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(2, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x0, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(0xFF, proxy_proto_data.tlv_vector_[0].value[0]);\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_[0].value.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[1].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[1].value.begin(),\n                                   proxy_proto_data.tlv_vector_[1].value.end()));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeEmpty) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(0, proxy_proto_data.tlv_vector_.size());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeTlV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n  pass_through_tlvs->add_tlv_type(0x02);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[0].value.begin(),\n                                   proxy_proto_data.tlv_vector_[0].value.end()));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, MalformedProxyLine) {\n  connect(false);\n\n  write(\"BOGUS\\r\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(\"\\n\");\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ProxyLineTooLarge) {\n  connect(false);\n  write(\"012345678901234567890123456789012345678901234567890123456789\"\n        \"012345678901234567890123456789012345678901234567890123456789\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NotEnoughFields) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, UnsupportedProto) {\n  connect(false);\n  write(\"PROXY UDP6 1:2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidSrcAddress) {\n  connect(false);\n  write(\"PROXY TCP4 230.0.0.1 10.1.1.3 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidDstAddress) {\n  connect(false);\n  write(\"PROXY TCP4 10.1.1.2 0.0.0.0 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadPort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234 abc\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NegativePort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 -1 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, PortOutOfRange) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 66776 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadAddress) {\n  connect(false);\n  write(\"PROXY TCP6 1::2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch) {\n  connect(false);\n  write(\"PROXY TCP4 [1:2:3::4] 1.2.3.4 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch2) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 [1:2:3: 1234 4]:5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, Truncated) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 5.6.7.8 1234 5678\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, Closed) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, ClosedEmpty) {\n  // We may or may not get these, depending on the operating system timing.\n  EXPECT_CALL(factory_, createListenerFilterChain(_)).Times(AtLeast(0));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).Times(AtLeast(0));\n  conn_->connect();\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n}\n\n// There is no chance to have error for Windows since it emulate the drain\n// from a memory buffer.\n#ifndef WIN32\nTEST_P(ProxyProtocolTest, DrainError) {\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        if (flags != MSG_PEEK) {\n          return Api::SysCallSizeResult{-1, 0};\n        } else {\n          const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n          return x;\n        }\n      }));\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectProxyProtoError();\n}\n#endif\n\nclass WildcardProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                  public Network::ListenerConfig,\n                                  public Network::FilterChainManager,\n                                  protected Logger::Loggable<Logger::Id::main> {\npublic:\n  WildcardProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getAnyAddress(GetParam()))),\n        local_dst_address_(Network::Utility::getAddressWithPort(\n            *Network::Test::getCanonicalLoopbackAddress(GetParam()),\n            socket_->connectionInfoProvider().localAddress()->ip()->port())),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(\n        local_dst_address_, Network::Address::InstanceConstSharedPtr(),\n        Network::Test::createRawBufferSocket(), nullptr, nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr,\n              std::make_unique<Filter>(std::make_shared<Config>(\n                  listenerScope(),\n                  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol())));\n          return true;\n        }));\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect() {\n    conn_->connect();\n    read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n    EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n        .WillOnce(Invoke([&](Network::Connection& connection,\n                             const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n          server_connection_ = &connection;\n          connection.addConnectionCallbacks(server_callbacks_);\n          connection.addReadFilter(read_filter_);\n          return true;\n        }));\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::IsolatedStoreImpl stats_store_;\n  Api::ApiPtr api_;\n  Event::DispatcherPtr dispatcher_;\n  BasicResourceLimitImpl open_connections_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  Network::Address::InstanceConstSharedPtr local_dst_address_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, WildcardProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(WildcardProxyProtocolTest, Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 254.254.254.254 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"1.2.3.4:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"254.254.254.254:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(WildcardProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"[1:2:3::4]:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"[5:6::7:8]:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST(ProxyProtocolConfigFactoryTest, TestCreateFactory) {\n  Server::Configuration::NamedListenerFilterConfigFactory* factory = Registry::FactoryRegistry<\n      Server::Configuration::NamedListenerFilterConfigFactory>::getFactory(ProxyProtocol);\n\n  EXPECT_EQ(factory->name(), ProxyProtocol);\n\n  const std::string yaml = R\"EOF(\n      rules:\n        - tlv_type: 0x01\n          on_tlv_present:\n            key: \"PP2_TYPE_ALPN\"\n        - tlv_type: 0x1a\n          on_tlv_present:\n            key: \"PP2_TYPE_CUSTOMER_A\"\n)EOF\";\n\n  ProtobufTypes::MessagePtr proto_config = factory->createEmptyConfigProto();\n  TestUtility::loadFromYaml(yaml, *proto_config);\n\n  Server::Configuration::MockListenerFactoryContext context;\n  EXPECT_CALL(context, scope());\n  EXPECT_CALL(context, messageValidationVisitor());\n  Network::ListenerFilterFactoryCb cb =\n      factory->createListenerFilterFactoryFromProto(*proto_config, nullptr, context);\n\n  Network::MockListenerFilterManager manager;\n  Network::ListenerFilterPtr added_filter;\n  EXPECT_CALL(manager, addAcceptFilter_(_, _))\n      .WillOnce(Invoke([&added_filter](const Network::ListenerFilterMatcherSharedPtr&,\n                                       Network::ListenerFilterPtr& filter) {\n        added_filter = std::move(filter);\n      }));\n  cb(manager);\n\n  // Make sure we actually create the correct type!\n  EXPECT_NE(dynamic_cast<ProxyProtocol::Filter*>(added_filter.get()), nullptr);\n}\n\n} // namespace\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/health_check.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/extensions/filters/listener/proxy_protocol/v3/proxy_protocol.pb.h\"\n#include \"envoy/extensions/transport_sockets/proxy_protocol/v3/upstream_proxy_protocol.pb.h\"\n#include \"envoy/extensions/transport_sockets/raw_buffer/v3/raw_buffer.pb.h\"\n#include \"envoy/extensions/transport_sockets/raw_buffer/v3/raw_buffer.pb.validate.h\"\n\n#include \"test/integration/http_integration.h\"\n#include \"test/integration/integration.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nnamespace Envoy {\nnamespace {\n\nclass ProxyProtocolTcpIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                        public BaseIntegrationTest {\npublic:\n  ProxyProtocolTcpIntegrationTest()\n      : BaseIntegrationTest(GetParam(), ConfigHelper::tcpProxyConfig()) {}\n\n  void TearDown() override {\n    test_server_.reset();\n    fake_upstream_connection_.reset();\n    fake_upstreams_.clear();\n  }\n\n  void setup(envoy::config::core::v3::ProxyProtocolConfig_Version version, bool health_checks,\n             bool inner_tls) {\n    version_ = version;\n    health_checks_ = health_checks;\n    inner_tls_ = inner_tls;\n  }\n\n  void initialize() override {\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* transport_socket =\n          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n      transport_socket->set_name(\"envoy.transport_sockets.upstream_proxy_protocol\");\n      envoy::config::core::v3::TransportSocket inner_socket;\n      if (inner_tls_) {\n        envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls;\n        inner_socket.set_name(\"tls\");\n        inner_socket.mutable_typed_config()->PackFrom(tls);\n      } else {\n        envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;\n        inner_socket.set_name(\"raw\");\n        inner_socket.mutable_typed_config()->PackFrom(raw_buffer);\n      }\n      envoy::config::core::v3::ProxyProtocolConfig proxy_proto_config;\n      proxy_proto_config.set_version(version_);\n      envoy::extensions::transport_sockets::proxy_protocol::v3::ProxyProtocolUpstreamTransport\n          proxy_proto_transport;\n      proxy_proto_transport.mutable_transport_socket()->MergeFrom(inner_socket);\n      proxy_proto_transport.mutable_config()->MergeFrom(proxy_proto_config);\n      transport_socket->mutable_typed_config()->PackFrom(proxy_proto_transport);\n\n      if (health_checks_) {\n        auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n        cluster->set_close_connections_on_host_health_failure(false);\n        cluster->mutable_common_lb_config()->mutable_healthy_panic_threshold()->set_value(0);\n        cluster->add_health_checks()->mutable_timeout()->set_seconds(20);\n        cluster->mutable_health_checks(0)->mutable_reuse_connection()->set_value(true);\n        cluster->mutable_health_checks(0)->mutable_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_no_traffic_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_unhealthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_healthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_tcp_health_check();\n        cluster->mutable_health_checks(0)->mutable_tcp_health_check()->mutable_send()->set_text(\n            \"50696E67\");\n        cluster->mutable_health_checks(0)->mutable_tcp_health_check()->add_receive()->set_text(\n            \"506F6E67\");\n      }\n    });\n    BaseIntegrationTest::initialize();\n  }\n\n  FakeRawConnectionPtr fake_upstream_connection_;\n\nprivate:\n  envoy::config::core::v3::ProxyProtocolConfig_Version version_;\n  bool health_checks_;\n  bool inner_tls_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTcpIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Test sending proxy protocol v1\nTEST_P(ProxyProtocolTcpIntegrationTest, TestV1ProxyProtocol) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false, false);\n  initialize();\n\n  auto listener_port = lookupPort(\"listener_0\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n  std::string observed_data;\n  ASSERT_TRUE(tcp_client->write(\"data\"));\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(48, &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n  } else if (GetParam() == Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(36, &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n  }\n  EXPECT_THAT(observed_data, testing::EndsWith(absl::StrCat(\" \", listener_port, \"\\r\\ndata\")));\n\n  auto previous_data = observed_data;\n  observed_data.clear();\n  ASSERT_TRUE(tcp_client->write(\" more data\"));\n  ASSERT_TRUE(fake_upstream_connection_->waitForData(previous_data.length() + 10, &observed_data));\n  EXPECT_EQ(previous_data + \" more data\", observed_data);\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nTEST_P(ProxyProtocolTcpIntegrationTest, TestV1ProxyProtocolMultipleConnections) {\n  if (GetParam() != Network::Address::IpVersion::v4) {\n    return;\n  }\n\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false, false);\n  initialize();\n  auto listener_port = lookupPort(\"listener_0\");\n\n  auto loopback2 = Network::Utility::resolveUrl(\"tcp://127.0.0.2:0\");\n  auto tcp_client2 = makeTcpConnection(listener_port, nullptr, loopback2);\n\n  auto tcp_client = makeTcpConnection(listener_port);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n  FakeRawConnectionPtr conn2;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(conn2));\n\n  std::string data1, data2;\n  ASSERT_TRUE(\n      fake_upstream_connection_->waitForData(FakeRawConnection::waitForAtLeastBytes(32), &data1));\n  ASSERT_TRUE(conn2->waitForData(FakeRawConnection::waitForAtLeastBytes(32), &data2));\n\n  EXPECT_NE(data1, data2);\n\n  tcp_client->close();\n  tcp_client2->close();\n}\n\n// Test header is sent unencrypted using a TLS inner socket\nTEST_P(ProxyProtocolTcpIntegrationTest, TestTLSSocket) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false, true);\n  initialize();\n\n  auto listener_port = lookupPort(\"listener_0\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n  ASSERT_TRUE(tcp_client->write(\"data\"));\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(\n        fake_upstream_connection_->waitForInexactMatch(\"PROXY TCP4 127.0.0.1 127.0.0.1 \")));\n  } else if (GetParam() == Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(\n        fake_upstream_connection_->waitForInexactMatch(\"PROXY TCP6 ::1 ::1 \")));\n  }\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->close());\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\n// Test sending proxy protocol health check\nTEST_P(ProxyProtocolTcpIntegrationTest, TestProxyProtocolHealthCheck) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, true, false);\n  FakeRawConnectionPtr fake_upstream_health_connection;\n  on_server_init_function_ = [&](void) -> void {\n    std::string observed_data;\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_health_connection));\n    if (GetParam() == Network::Address::IpVersion::v4) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(48, &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n    } else if (GetParam() == Network::Address::IpVersion::v6) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(36, &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n    }\n    ASSERT_TRUE(fake_upstream_health_connection->write(\"Pong\"));\n  };\n\n  initialize();\n\n  ASSERT_TRUE(fake_upstream_health_connection->close());\n  ASSERT_TRUE(fake_upstream_health_connection->waitForDisconnect());\n}\n\n// Test sending proxy protocol v2\nTEST_P(ProxyProtocolTcpIntegrationTest, TestV2ProxyProtocol) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V2, false, false);\n  initialize();\n\n  auto listener_port = lookupPort(\"listener_0\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n  std::string observed_data;\n  ASSERT_TRUE(tcp_client->write(\"data\"));\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(32, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address, dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x0c, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[26]), listener_port >> 8);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[27]), listener_port & 0xFF);\n  } else if (GetParam() == Envoy::Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(56, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address\n    // - dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[50]), listener_port >> 8);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[51]), listener_port & 0xFF);\n  }\n  EXPECT_THAT(observed_data, testing::EndsWith(\"data\"));\n\n  auto previous_data = observed_data;\n  observed_data.clear();\n  ASSERT_TRUE(tcp_client->write(\" more data\"));\n  ASSERT_TRUE(fake_upstream_connection_->waitForData(previous_data.length() + 10, &observed_data));\n  EXPECT_EQ(previous_data + \" more data\", observed_data);\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nclass ProxyProtocolHttpIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                         public HttpIntegrationTest {\npublic:\n  ProxyProtocolHttpIntegrationTest()\n      : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, GetParam()) {}\n\n  void TearDown() override {\n    test_server_.reset();\n    fake_upstream_connection_.reset();\n    fake_upstreams_.clear();\n  }\n\n  void setup(envoy::config::core::v3::ProxyProtocolConfig_Version version, bool health_checks) {\n    version_ = version;\n    health_checks_ = health_checks;\n  }\n\n  void initialize() override {\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* transport_socket =\n          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n      transport_socket->set_name(\"envoy.transport_sockets.upstream_proxy_protocol\");\n      envoy::config::core::v3::TransportSocket inner_socket;\n      envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;\n      inner_socket.set_name(\"raw\");\n      inner_socket.mutable_typed_config()->PackFrom(raw_buffer);\n      envoy::config::core::v3::ProxyProtocolConfig proxy_proto_config;\n      proxy_proto_config.set_version(version_);\n      envoy::extensions::transport_sockets::proxy_protocol::v3::ProxyProtocolUpstreamTransport\n          proxy_proto_transport;\n      proxy_proto_transport.mutable_transport_socket()->MergeFrom(inner_socket);\n      proxy_proto_transport.mutable_config()->MergeFrom(proxy_proto_config);\n      transport_socket->mutable_typed_config()->PackFrom(proxy_proto_transport);\n\n      if (health_checks_) {\n        auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n        cluster->set_close_connections_on_host_health_failure(false);\n        cluster->mutable_common_lb_config()->mutable_healthy_panic_threshold()->set_value(0);\n        cluster->add_health_checks()->mutable_timeout()->set_seconds(20);\n        cluster->mutable_health_checks(0)->mutable_reuse_connection()->set_value(true);\n        cluster->mutable_health_checks(0)->mutable_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_no_traffic_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_unhealthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_healthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_http_health_check()->set_codec_client_type(\n            envoy::type::v3::HTTP1);\n        cluster->mutable_health_checks(0)->mutable_http_health_check()->set_path(\"/healthcheck\");\n      }\n    });\n    BaseIntegrationTest::initialize();\n  }\n\nprivate:\n  envoy::config::core::v3::ProxyProtocolConfig_Version version_;\n  bool health_checks_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolHttpIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Test sending proxy protocol over http\nTEST_P(ProxyProtocolHttpIntegrationTest, TestV1ProxyProtocol) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false);\n  initialize();\n\n  auto tcp_client = makeTcpConnection(lookupPort(\"http\"));\n  auto request = \"GET / HTTP/1.1\\r\\nhost: host\\r\\n\\r\\n\";\n  ASSERT_TRUE(tcp_client->write(request, false));\n  FakeRawConnectionPtr fake_upstream_raw_connection_;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_raw_connection_));\n\n  std::string observed_data;\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_raw_connection_->waitForData(\n        FakeRawConnection::waitForAtLeastBytes(70), &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n  } else if (GetParam() == Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_raw_connection_->waitForData(\n        FakeRawConnection::waitForAtLeastBytes(58), &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n  }\n  EXPECT_TRUE(absl::StrContains(observed_data, \"GET / HTTP/1.1\"));\n  EXPECT_TRUE(absl::StrContains(observed_data, \"host: host\"));\n\n  auto response = \"HTTP/1.1 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\";\n  ASSERT_TRUE(fake_upstream_raw_connection_->write(response, false));\n  tcp_client->waitForData(\"HTTP/1.1 200 OK\\r\\ncontent-length: 0\", true);\n\n  std::string delimiter = \"\\r\\n\";\n  std::string after_proxy_proto_header = observed_data.substr(\n      observed_data.find(delimiter) + delimiter.length(), observed_data.length());\n\n  auto previous_data = observed_data;\n  observed_data.clear();\n  ASSERT_TRUE(tcp_client->write(request, false));\n  ASSERT_TRUE(fake_upstream_raw_connection_->waitForData(\n      previous_data.length() + after_proxy_proto_header.length(), &observed_data));\n  ASSERT_TRUE(observed_data.length() == previous_data.length() + after_proxy_proto_header.length());\n  tcp_client->close();\n}\n\n// Test sending proxy protocol over multiple http connections\nTEST_P(ProxyProtocolHttpIntegrationTest, TestV1ProxyProtocolMultipleConnections) {\n  if (GetParam() != Network::Address::IpVersion::v4) {\n    return;\n  }\n\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false);\n  initialize();\n  auto listener_port = lookupPort(\"http\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  auto loopback2 = Network::Utility::resolveUrl(\"tcp://127.0.0.2:0\");\n  auto tcp_client2 = makeTcpConnection(listener_port, nullptr, loopback2);\n\n  auto request = \"GET / HTTP/1.1\\r\\nhost: host\\r\\n\\r\\n\";\n  ASSERT_TRUE(tcp_client->write(request, false));\n  ASSERT_TRUE(tcp_client2->write(request, false));\n\n  FakeRawConnectionPtr conn1, conn2;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(conn1));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(conn2));\n  std::string data1, data2;\n  ASSERT_TRUE(conn1->waitForData(FakeRawConnection::waitForAtLeastBytes(48), &data1));\n  ASSERT_TRUE(conn2->waitForData(FakeRawConnection::waitForAtLeastBytes(48), &data2));\n\n  std::string delimiter = \"\\r\\n\";\n  std::string conn1_header = data1.substr(0, data1.find(delimiter));\n  std::string conn2_header = data2.substr(0, data2.find(delimiter));\n\n  EXPECT_NE(conn1_header, conn2_header);\n\n  tcp_client->close();\n  tcp_client2->close();\n}\n\n// Test sending proxy protocol http health check\nTEST_P(ProxyProtocolHttpIntegrationTest, TestProxyProtocolHealthCheck) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, true);\n  FakeRawConnectionPtr fake_upstream_health_connection;\n  on_server_init_function_ = [&](void) -> void {\n    std::string observed_data;\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_health_connection));\n    if (GetParam() == Network::Address::IpVersion::v4) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(\n          FakeRawConnection::waitForAtLeastBytes(48), &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n    } else if (GetParam() == Network::Address::IpVersion::v6) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(\n          FakeRawConnection::waitForAtLeastBytes(36), &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n    }\n    auto response = \"HTTP/1.1 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\";\n    ASSERT_TRUE(fake_upstream_health_connection->write(response));\n  };\n\n  initialize();\n\n  ASSERT_TRUE(fake_upstream_health_connection->close());\n  ASSERT_TRUE(fake_upstream_health_connection->waitForDisconnect());\n}\n\nclass ProxyProtocolTLVsIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                         public BaseIntegrationTest {\npublic:\n  ProxyProtocolTLVsIntegrationTest()\n      : BaseIntegrationTest(GetParam(), ConfigHelper::tcpProxyConfig()){};\n\n  void TearDown() override {\n    test_server_.reset();\n    fake_upstream_connection_.reset();\n    fake_upstreams_.clear();\n  }\n\n  void setup(bool pass_all_tlvs, const std::vector<uint8_t>& tlvs_listener,\n             const std::vector<uint8_t>& tlvs_upstream) {\n    pass_all_tlvs_ = pass_all_tlvs;\n    tlvs_listener_.assign(tlvs_listener.begin(), tlvs_listener.end());\n    tlvs_upstream_.assign(tlvs_upstream.begin(), tlvs_upstream.end());\n  }\n\n  void initialize() override {\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proxy_protocol;\n      auto pass_through_tlvs = proxy_protocol.mutable_pass_through_tlvs();\n      if (pass_all_tlvs_) {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n      } else {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n        for (const auto& tlv_type : tlvs_listener_) {\n          pass_through_tlvs->add_tlv_type(tlv_type);\n        }\n      }\n\n      auto* listener = bootstrap.mutable_static_resources()->mutable_listeners(0);\n      auto* ppv_filter = listener->add_listener_filters();\n      ppv_filter->set_name(\"envoy.listener.proxy_protocol\");\n      ppv_filter->mutable_typed_config()->PackFrom(proxy_protocol);\n    });\n\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* transport_socket =\n          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n      transport_socket->set_name(\"envoy.transport_sockets.upstream_proxy_protocol\");\n      envoy::config::core::v3::TransportSocket inner_socket;\n      envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;\n      inner_socket.set_name(\"raw\");\n      inner_socket.mutable_typed_config()->PackFrom(raw_buffer);\n\n      envoy::config::core::v3::ProxyProtocolConfig proxy_protocol;\n      proxy_protocol.set_version(envoy::config::core::v3::ProxyProtocolConfig::V2);\n      auto pass_through_tlvs = proxy_protocol.mutable_pass_through_tlvs();\n\n      if (pass_all_tlvs_) {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n      } else {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n        for (const auto& tlv_type : tlvs_upstream_) {\n          pass_through_tlvs->add_tlv_type(tlv_type);\n        }\n      }\n\n      envoy::extensions::transport_sockets::proxy_protocol::v3::ProxyProtocolUpstreamTransport\n          proxy_proto_transport;\n      proxy_proto_transport.mutable_transport_socket()->MergeFrom(inner_socket);\n      proxy_proto_transport.mutable_config()->MergeFrom(proxy_protocol);\n      transport_socket->mutable_typed_config()->PackFrom(proxy_proto_transport);\n    });\n\n    BaseIntegrationTest::initialize();\n  }\n\n  FakeRawConnectionPtr fake_upstream_connection_;\n\nprivate:\n  bool pass_all_tlvs_ = false;\n  std::vector<uint8_t> tlvs_listener_;\n  std::vector<uint8_t> tlvs_upstream_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTLVsIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// This test adding the listener proxy protocol filter and upstream proxy filter, the TLVs\n// are passed by listener and re-generated in transport socket based on API config.\nTEST_P(ProxyProtocolTLVsIntegrationTest, TestV2TLVProxyProtocolPassSepcificTLVs) {\n  setup(false, {0x05, 0x06}, {0x06});\n  initialize();\n\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n  std::string observed_data;\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x11, 0x12\n    const uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                   0x54, 0x0a, 0x21, 0x11, 0x00, 0x16, 0x7f, 0x00, 0x00, 0x01,\n                                   0x7f, 0x00, 0x00, 0x01, 0x03, 0x05, 0x02, 0x01, 0x05, 0x00,\n                                   0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x11, 0x12};\n    Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(33, &observed_data));\n\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address, dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x11, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x11, 0x12 is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[28]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[29]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[30]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[31]), 0x11);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[32]), 0x12);\n  } else if (GetParam() == Envoy::Network::Address::IpVersion::v6) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x09, 0x0A\n    const uint8_t v2_protocol_ipv6[] = {\n        0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21,\n        0x21, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x02,\n        0x05, 0x00, 0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x09, 0x0A};\n    Buffer::OwnedImpl buffer(v2_protocol_ipv6, sizeof(v2_protocol_ipv6));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(57, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address\n    // - dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x09, 0x0A is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[52]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[53]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[54]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[55]), 0x09);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[56]), 0x0A);\n  }\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nTEST_P(ProxyProtocolTLVsIntegrationTest, TestV2TLVProxyProtocolPassAll) {\n  setup(true, {}, {});\n  initialize();\n\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n\n  std::string observed_data;\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x11, 0x12\n    const uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                   0x54, 0x0a, 0x21, 0x11, 0x00, 0x16, 0x7f, 0x00, 0x00, 0x01,\n                                   0x7f, 0x00, 0x00, 0x01, 0x03, 0x05, 0x02, 0x01, 0x05, 0x00,\n                                   0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x11, 0x12};\n    Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(38, &observed_data));\n\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address, dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x16, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x11, 0x12 is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[28]), 0x05);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[29]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[30]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[31]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[32]), 0x07);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[33]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[34]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[35]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[36]), 0x11);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[37]), 0x12);\n  } else if (GetParam() == Envoy::Network::Address::IpVersion::v6) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x09, 0x0A\n    const uint8_t v2_protocol_ipv6[] = {\n        0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21,\n        0x21, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x02,\n        0x05, 0x00, 0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x09, 0x0A};\n    Buffer::OwnedImpl buffer(v2_protocol_ipv6, sizeof(v2_protocol_ipv6));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(62, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address\n    // - dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x09, 0x0A is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[52]), 0x05);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[53]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[54]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[55]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[56]), 0x07);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[57]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[58]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[59]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[60]), 0x09);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[61]), 0x0A);\n  }\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\n} // namespace\n} // namespace Envoy\n", "#!/bin/bash\n\n# directory:coverage_percent\n# for existing directories with low coverage.\ndeclare -a KNOWN_LOW_COVERAGE=(\n\"source/common:95.9\" # TODO(#32149): increase this once io_uring is tested.\n\"source/common/api:84.5\" # flaky due to posix: be careful adjusting\n\"source/common/api/posix:83.8\" # flaky (accept failover non-deterministic): be careful adjusting\n\"source/common/config:95.4\"\n\"source/common/crypto:95.5\"\n\"source/common/event:95.0\" # Emulated edge events guards don't report LCOV\n\"source/common/filesystem/posix:96.2\" # FileReadToEndNotReadable fails in some env; createPath can't test all failure branches.\n\"source/common/http/http2:95.2\"\n\"source/common/io:57.1\" # TODO(#32149): CI has stopped executing this code.\n\"source/common/json:94.6\"\n\"source/common/matcher:94.6\"\n\"source/common/network:94.4\" # Flaky, `activateFileEvents`, `startSecureTransport` and `ioctl`, listener_socket do not always report LCOV\n\"source/common/network/dns_resolver:91.4\"  # A few lines of MacOS code not tested in linux scripts. Tested in MacOS scripts\n\"source/common/quic:93.4\"\n\"source/common/secret:95.1\"\n\"source/common/signal:87.2\" # Death tests don't report LCOV\n\"source/common/thread:0.0\" # Death tests don't report LCOV\n\"source/common/watchdog:58.6\" # Death tests don't report LCOV\n\"source/exe:90.3\"\n\"source/extensions/clusters/common:91.5\" # This can be increased again once `#24903` lands\n\"source/extensions/common:93.0\" #flaky: be careful adjusting\n\"source/extensions/common/tap:94.5\"\n\"source/extensions/common/wasm:88.0\" # flaky: be careful adjusting\n\"source/extensions/common/wasm/ext:92.0\"\n\"source/extensions/filters/common/fault:94.5\"\n\"source/extensions/filters/common/rbac:90.5\"\n\"source/extensions/filters/http/cache:94.9\"\n\"source/extensions/filters/http/grpc_json_transcoder:93.8\" # TODO(#28232)\n\"source/extensions/filters/http/ip_tagging:88.0\"\n\"source/extensions/filters/http/kill_request:91.7\" # Death tests don't report LCOV\n\"source/extensions/filters/http/wasm:1.8\"\n\"source/extensions/filters/listener/original_src:92.1\"\n\"source/extensions/filters/network/common:96.4\"\n\"source/extensions/filters/network/mongo_proxy:96.0\"\n\"source/extensions/filters/network/sni_cluster:88.9\"\n\"source/extensions/filters/network/wasm:76.9\"\n\"source/extensions/http/cache/simple_http_cache:95.9\"\n\"source/extensions/rate_limit_descriptors:95.0\"\n\"source/extensions/rate_limit_descriptors/expr:95.0\"\n\"source/extensions/stat_sinks/graphite_statsd:78.6\" # Death tests don't report LCOV\n\"source/extensions/stat_sinks/statsd:80.8\" # Death tests don't report LCOV\n\"source/extensions/tracers:96.1\"\n\"source/extensions/tracers/common:74.8\"\n\"source/extensions/tracers/common/ot:72.9\"\n\"source/extensions/tracers/opencensus:94.0\"\n\"source/extensions/tracers/zipkin:95.8\"\n\"source/extensions/transport_sockets:95.8\"\n\"source/extensions/transport_sockets/tls:95.0\"\n\"source/extensions/transport_sockets/tls/cert_validator:95.2\"\n\"source/extensions/transport_sockets/tls/private_key:88.9\"\n\"source/extensions/wasm_runtime/wamr:0.0\" # Not enabled in coverage build\n\"source/extensions/wasm_runtime/wasmtime:0.0\" # Not enabled in coverage build\n\"source/extensions/wasm_runtime/wavm:0.0\" # Not enabled in coverage build\n\"source/extensions/watchdog:83.3\" # Death tests within extensions\n\"source/extensions/listener_managers:70.5\"\n\"source/extensions/listener_managers/validation_listener_manager:70.5\"\n\"source/extensions/watchdog/profile_action:83.3\"\n\"source/server:91.0\" # flaky: be careful adjusting. See https://github.com/envoyproxy/envoy/issues/15239\n\"source/server/config_validation:89.2\"\n\"source/extensions/health_checkers:96.0\"\n\"source/extensions/health_checkers/http:93.9\"\n\"source/extensions/health_checkers/grpc:92.0\"\n\"source/extensions/config_subscription/rest:94.3\"\n\"source/extensions/matching/input_matchers/cel_matcher:91.3\" #Death tests don't report LCOV\n)\n\n[[ -z \"${SRCDIR}\" ]] && SRCDIR=\"${PWD}\"\nCOVERAGE_DIR=\"${SRCDIR}\"/generated/coverage\nCOVERAGE_DATA=\"${COVERAGE_DIR}/coverage.dat\"\n\nFAILED=0\nDEFAULT_COVERAGE_THRESHOLD=96.6\nDIRECTORY_THRESHOLD=$DEFAULT_COVERAGE_THRESHOLD\n\n# Unfortunately we have a bunch of preexisting directory with low coverage.\n# Set their low bar as their current coverage level.\nget_coverage_target() {\n  DIRECTORY_THRESHOLD=$DEFAULT_COVERAGE_THRESHOLD\n  for FILE_PERCENT in \"${KNOWN_LOW_COVERAGE[@]}\"\n  do\n    if [[ $FILE_PERCENT =~ $1: ]]; then\n      DIRECTORY_THRESHOLD=\"${FILE_PERCENT//*:/}\"\n      return\n    fi\n  done\n}\n\n# Make sure that for each directory with code, coverage doesn't dip\n# below the default coverage threshold.\nSOURCES=$(find source/* -type d)\nwhile read -r DIRECTORY\ndo\n  get_coverage_target \"$DIRECTORY\"\n  COVERAGE_VALUE=$(lcov -e \"$COVERAGE_DATA\"  \"${DIRECTORY}/*\" -o /dev/null | grep line |  cut -d ' ' -f 4)\n  COVERAGE_VALUE=${COVERAGE_VALUE%?}\n  # If the coverage number is 'n' (no data found) there is 0% coverage. This is\n  # probably a directory without source code, so we skip checks.\n  #\n  # We could insist that we validate that 0% coverage directories are in a\n  # documented list, but instead of adding busy-work for folks adding\n  # non-source-containing directories, we trust reviewers to notice if there's\n  # absolutely no tests for a full directory.\n  if [[ $COVERAGE_VALUE =~ \"n\" ]]; then\n    continue;\n  fi;\n  COVERAGE_FAILED=$(echo \"${COVERAGE_VALUE}<${DIRECTORY_THRESHOLD}\" | bc)\n  if [[ \"${COVERAGE_FAILED}\" -eq 1 ]]; then\n    echo \"Code coverage for ${DIRECTORY} is lower than limit of ${DIRECTORY_THRESHOLD} (${COVERAGE_VALUE})\"\n    FAILED=1\n  fi\n  if [[ -n ${VERBOSE} && ${COVERAGE_VALUE} > ${DIRECTORY_THRESHOLD} ]]; then\n    if [[ ${DIRECTORY_THRESHOLD} < $DEFAULT_COVERAGE_THRESHOLD ]]; then\n      echo \"Code coverage for ${DIRECTORY} is now ${COVERAGE_VALUE} (previously ${DIRECTORY_THRESHOLD})\"\n    fi\n  fi\n\ndone <<< \"$SOURCES\"\n\nexit $FAILED\n", "# Word list for check_spelling_pedantic.py -- any entry in ALLCAPS will also be accepted in\n# lower case and title case (e.g. HTTP will accept http and Http). Entries in all lower case\n# will accept title case (e.g. lyft matches Lyft). Prefixes (e.g., un-) or suffixes (e.g. -ing)\n# are allowed for any otherwise correctly spelled word.\nABI\nACK\nACL\nAES\nAllMuxes\nALPN\nALS\nAMZ\nAPC\nAPI\nARRAYSIZE\nARN\nASAN\nASCII\nASM\nASN\nASSERTed\nASSERTs\nAST\nAWS\nBACKTRACE\nBEL\nBBR\nBIDIRECTIONAL\nNID\nNIST\nbm\nBSON\nBPF\nBdecoded\nBencoded\nCIO\ndeadcode\nDFP\nDynatrace\nDOM\nGasd\nGiB\nIPTOS\nOTEL\nRepick\nReserializer\nSION\nTRA\nWebsockets\nabc\nabcd\nabd\nar\nbtree\nCAS\nCB\ncartid\ncbor\nCDN\nCDS\nCEL\nCWND\nDLE\nDPE\nDSR\nDSS\nEBADF\nECH\nENDIF\nENOTCONN\nENQ\nEOT\nEPIPE\nESC\nETB\nETX\nFS\nFIXME\nHEXDIG\nHEXDIGIT\nHPE\nKwasi\nLRU\nMensah\nNAK\nOWS\nPreconnecting\nRCVBUF\nRTCP\nRTP\nSOH\nSPC\nSTATNAME\nSTX\nSkyWalking\nTIDs\nTimedout\nWRSQ\nWASI\nceil\nCCM\nCHACHA\nCHLO\nCHMOD\nCHLOS\nCHLOs\nCIDR\nCITT\nCLA\nCLI\nCMSG\nCN\nCNAME\nCOMMANDREPLY\nCP\nCPP\nCPU\nCQ\nCRC\nCRL\nCRT\nCSDS\nCSRF\nCSS\nCSV\nCTX\nCVC\nCVE\nCX\nCxx\nCYGWIN\nDCP\nDER\nDESC\nDFATAL\nDGRAM\nDLOG\nDNS\nDQUOTE\nDS\nDST\nDW\nDWORD\nEAGAIN\nECDH\nECDHE\nECDS\nECDSA\nECONNREFUSED\nEDESTRUCTION\nEDF\nEINVAL\nELB\nENOENT\nENV\nEOF\nEOS\nEQ\nERANGE\nEV\nEVAL\nEVLOOP\nEVP\nEWOULDBLOCK\nEXPECTs\nEXPR\nFAQ\nFASTOPEN\nFB\nFCDS\nFCM\nFFFF\nFIN\nFIPS\nFIRSTHDR\nFQDN\nFREEBIND\ncurr\neslint\nfreeifaddrs\nFUZZER\nFUZZERS\ndelims\ndereferencing\ndifferentially\ndnsresolvers\nendpos\neps\nfo\ngb\nghi\ngolang\nguarddog\nGC\nGCC\nGCE\nGCM\nGCOVR\nGCP\nGETting\nGLB\nGOAWAY\nGRPC\nGRO\nGSO\nGSS\nGTEST\nGURL\nGrabbit\nHC\nHCM\nHDS\nHMAC\nHOL\nHPACK\nHTAB\nHTML\nHTTP\nHTTPS\nHV\nHyperscan\nIAM\nIANA\nIDL\nIETF\nIFADDRS\nINADDR\nINET\nINVAL\nIO\nIOS\nIP\nIPPROTO\nIPV\nIPs\nIPv\nITOA\nInjectable\nIsode\nIters\nJSON\nJSONs\nJWKS\nJWKs\nJWS\nJWT\nJWTs\nKB\nKDS\nKarlsson\nKiB\nKille\nLBs\nLC\nLDS\nLEDS\nLEV\nLF\nLHS\nhls\niframe\nilp\ningressed\nintegrations\niouring\njkl\nlang\nlibcurl\nlibsxg\nLLVM\nLPT\nLRS\nLoggable\nMB\nMD\nMERCHANTABILITY\nMerkle\nMGET\nMPTCP\nMQ\nMSDN\nMSET\nMSVC\nMTLS\nMTU\nMULTIFRAME\nNACK\nNACKed\nNACKs\nNBF\nNBSP\nNDEBUG\nNEXTHDR\nNGHTTP\nNLOHMANN\nNOAUTH\nNOCHECKRESP\nNODELAY\nNOLINT\nNOLINTNEXTLINE\nNONBLOCK\nNONCES\nNOSORT\nNS\nNUL\nNilsson\nNonhashable\nOauth\nOCSP\nOD\nODCDS\nmiddlewildcard\nmonostate\nmpd\nna\noghttp\nOID\nOK\nOOM\nOOMs\nORCA\nOS\nOSI\nOSS\nOSX\nOT\nOTLP\nOU\nOVFL\nPAYLOADLEN\nPB\nPCC\nPCRE\nPEERCRED\nPEM\nPERF\nPGV\nPID\nPKCS12\nPKTINFO\nPNG\nPointwise\nPostCBs\nPREBIND\nPRNG\nPROT\nPostgre\nPostgres\nPrereq\nQDCOUNT\nQPACK\nQUIC\nQoS\nqat\nqatzip\nRAII\nRANLUX\nRBAC\nRDN\nRDS\nREADME\nRECVDSTADDR\nRECVPKTINFO\nREFNIL\nREQ\nREUSEADDR\nREUSEPORT\nRFC\nRHS\nRLE\nRLS\nRLQS\nRNG\nRPC\nRSA\nRST\nRTDS\nRTOS\nRTTI\nRUNDIR\nRVCM\nRW\nRX\nRXQ\nRebalance\nRunn\nSA\nSAN\nSCT\nSDK\nSDS\nSENDSRCADDR\nSHA\nSHM\nSIGABRT\nSIGBUS\nSIGFPE\nSIGILL\nSIGINT\nSIGPIPE\nSIGSEGV\nSIGTERM\nSIMD\nSIO\nSMTP\nSNI\nSOTW\nSPD\nSPDY\nSPIFFE\nSPKI\nSQL\nSR\nSRCDIR\nSRDS\nSRV\nSS\nSSD\nSSL\nSTDSTRING\nSTL\nSTRLEN\nSTS\nSUBCOMMAND\nSVG\nSVID\nSXG\nSymbolizer\nTBD\nTCLAP\nTCP\nTE\nTFO\nTID\nTLS\nTLSv\nTLV\nTMPDIR\nTODO\nTP\nTPM\nTSAN\nTSI\nTTL\nTTLs\nTX\nTXT\nUA\nUBSAN\nUDP\nUDS\nUHV\nUNC\nURI\nURL\nUSEVC\nUTC\nUTF\nUUID\nUUIDs\nVC\nVCHAR\nVCL\nVFS\nVH\nVHDS\nVLOG\nVM\nVPN\nWAITFORONE\nWASM\nWAVM\nWIP\nWKT\nWRONGPASS\nWRR\nWS\nWSA\nWSABUF\nWSS\nWelford's\nWi\nXDS\nXFCC\nXFF\nXML\nXN\nXNOR\nXSS\nYAML\nZXID\nabsl\naccesslog\naccessor\naccessors\nacked\nackless\nacks\nacls\naddr\nagg\nAggregationTemporality\nalice\nalignas\nalignof\nalloc\nalloca\nallocatable\nallocator\nallowlist\nallowlisted\nalls\nalphanumerics\namongst\nanno\nanonymization\nanonymizing\nanys\nappmesh\narg\nargc\nargs\nargv\nartisanal\nary\nasctime\nasm\nasync\natoi\natomicity\natomics\natoull\nauth\nauthenticator\nauthenticators\nauthlen\nauthn\nauths\nauthz\nautomata\nautoscale\nbackend\nbackends\nbackgrounded\nbackoff\nbackpressure\nbackticks\nbacktraces\nbacktracing\nbalancer\nbalancers\nbarbaz\nbasename\nbaz\nbazel\nbehaviour\nbenchmarked\nbidi\nbignum\nbitfield\nbitmask\nbitmasks\nbitset\nbitwise\nblackhole\nblackholed\nbookkeep\nbool\nboolean\nbooleans\nbools\nboringssl\nborks\nbroadcasted\nbrotli\nbuf\nbuflen\nbugprone\nbuiltin\nbuiltins\nbulkstrings\nbursty\nbytecode\nbytestream\nbytestring\ncacert\ncacheable\ncacheability\ncallee\ncallsite\ncallsites\ncallstack\ncancellable\ncancelled\ncancelling\ncanonicalization\ncanonicalize\ncanonicalized\ncanonicalizer\ncanonicalizing\ncardinality\ncasted\ncfg\ncharset\ncheckin\nchecksum\nchrono\nchroot\nchunked\nci\nciphersuite\nciphersuites\ncircllhist\nclientcert\ncloneable\ncloneability\ncmd\ncmsghdr\ncodebase\ncodec\ncodecs\ncodepath\ncodepoints\ncodings\ncombinatorial\ncomparator\ncompat\ncompletable\ncond\ncondvar\nconf\nconfig\nconfigs\nconn\nconns\nconst\nconstexpr\nconstructible\ncopyable\ncoroutine\ncoroutines\ncors\ncout\ncoverity\ncplusplus\ncpuset\ncreds\ncRLSign\ncrypto\ncryptographic\ncryptographically\ncstate\ncstring\nctad\nctor\nctrl\ncustomizations\ndarwin\ndatadog\ndatagram\ndatagrams\nde\ndeallocate\ndeallocated\ndeallocating\ndeallocation\ndec\ndechunk\ndechunked\ndecl\ndecls\ndecompressor\ndecompressors\ndecrement\ndecrypt\ndedup\ndedupe\ndeduplicate\ndeduplicates\ndeduplication\ndeflater\ndeletable\ndeleter\ndelim\ndenylist\ndeque\ndeprecations\ndereference\ndereferences\nderegistered\ndeserialization\ndeserialize\ndeserialized\ndeserializer\ndeserializers\ndeserializes\ndeserializing\ndest\ndestructor\ndestructors\ndesynchronize\ndeterministically\ndeterminize\ndev\ndgst\ndir\ndirname\ndjb\ndowncalls\ndowncasted\ndowncased\ndownstreams\ndrainable\ndtor\ndubbo\ndup\ndurations\ndynamodb\neg\nemplace\nemplaced\nemscripten\nemsdk\nenablement\nencodings\nendian\nendianness\nendl\nenqueue\nenqueued\nenqueues\nenum\nenums\nenviron\nepoll\nerrno\netag\netags\nevaluator\nevbuffer\nevbuffers\nevconnlistener\nevented\neventfd\nevwatch\nexe\nexeclp\nexprfor\nexpectable\nextensibility\nextrahelp\nfaceplant\nfacto\nfailover\nfallbacks\nfastbuild\nfavicon\nfbs\nfcntl\nfd\nfds\nfdstat\nfilename\nfilenames\nfileno\nfilesystem\nfirefox\nfixdate\nfixup\nflatbuffer\nflatc\nfmt\nfmtlib\nfn\nformatter\nformatters\nformedness\nfrontend\nftruncate\nfunc\nfunctor\nfunctors\ngRPC\ngateway\ngcov\ngenrule\ngeolocation\ngeo\ngeoip\nGeoip\ngetaddrinfo\ngetaffinity\ngethostname\ngetifaddrs\ngetpeername\ngetsockname\ngetsockopt\ngetter\ngetters\ngithub\nglobals\ngmock\ngoog\ngoogle\ngoto\ngso\ngzip\nhackery\nhacky\nhandshaker\nhardcoded\nhardcodes\nhardcoding\nhashable\nhasher\nhashtagging\nhd\nhdr\nhealthcheck\nhealthchecker\nhealthcheckers\nhealthchecks\nhealths\nhealthz\nhermeticity\nhighp\nhoc\nhostname\nhostnames\nhostset\nhotrestart\nhrefs\nhtpasswd\nhuffman\nhystrix\nidempotency\nidx\nifdef\niff\nified\nifndef\nimpl\nimplementors\nimpls\nindices\ninflater\ninflight\n-ing\ninit\ninitialize\ninitializer\ninitializers\ninlined\ninlining\ninobservability\ninode\ninodes\ninotify\ninserter\ninstantiation\ninstantiations\ninterpretable\nintra\nints\ninvariance\ninvoker\niov\niovcnt\niovec\niovecs\nips\niptables\nish\nisp\nistio\nistream\nistringstream\niteratively\njavascript\njitter\njittered\njs\nkafka\nkeepalive\nkeepalives\nketama\nkeyder\nkqueue\nkubernetes\nkv\nkvlist\nkvs\nlala\nlatencies\nld\nldd\nlen\nlenenc\nlexically\nlibc\nlibevent\nlibprotobuf\nlibrdkafka\nlibtool\nlibstdc\nlifecycle\nlightstep\nlinearization\nlinearize\nlinearized\nlinux\nlivelock\nllvm\nloc\nlocalhost\nlockless\nlogin\nloglevel\nlogstream\nlookup\nlookups\nloopback\nlossy\nlowp\nlstat\nltrim\nlua\nlyft\nmaglev\nmalloc\nmarshaller\nmatchable\nmatcher\nmatchers\nmaxage\nmaxbuffer\nMaxmind\nmaxmind\nmegamiss\nmem\nmemcmp\nmemcpy\nmemset\nmemoize\nmergeable\nmessagename\nmetadata\nmetamethod\nmetaprogramming\nmetatable\nmicrobenchmarks\nmidp\nmilli\nmimics\nmisconfiguration\nmisconfigured\nmixin\nmkdir\nmmap\nmmdb\nmmsg\nmmsghdr\nmongo\nmoveable\nmsec\nmsg\nmsghdr\nmulti\nmulticast\nmultikill\nmultimap\nmultiple\nmultivalue\nmutator\nmutex\nmutexes\nmux\nmuxed\nmysql\nnamelen\nnameserver\nnamespace\nnamespaced\nnamespaces\nnamespacing\nnan\nnanos\nnatively\nndk\nnegative\nnetblock\nnetblocks\nnetfilter\nnetlink\nnetmask\nNLMSG\nnonblocking\nnoncopyable\nnonresponsive\nnoop\nnop\nnpos\nnthreads\nntohl\nntop\nnullable\nnulled\nnullopt\nnullptr\nnum\nnumkeys\noauth\nobservability\nocagent\noffsetof\noneof\noneway\noob\nopcode\nopencensus\nopenssl\nopentracing\noptimizations\noptname\noptval\nostream\noutlier\noutliers\noverprovisioned\noverprovisioning\noverridable\noversized\npackagename\npageheap\nparam\nparameterization\nparameterize\nparameterized\nparameterizing\nparams\nparen\nparens\nparentid\nparentspanid\nparseable\nparsers\npassphrase\npassthrough\npathname\npatt\npausable\npausedness\npcall\npcap\npchar\npclose\nperformant\npfctl\npipelined\npipelining\npkey\nplaintext\npluggable\npointee\npoller\npopen\npos\nposix\npostfix\npostfixes\npostgres\npostgresql\npragma\npre\npreallocate\npreallocating\npreallocation\nprecalculated\nprecompile\nprecompiled\nprecompute\nprecomputed\npreconnect\npreconnected\npreconnecting\npreconnects\npredeclared\nprefetch\nprefetched\nprefetches\npreflight\npreorder\nprepend\nprepended\nprepends\npreresolve\npreresolved\nprev\nprobabilistically\nproc\nprofiler\nprogrammatically\nprometheus\nproto\nprotobuf\nprotobufs\nprotoc\nprotodoc\nprotos\nprotoxform\nproxied\npseudocode\npthread\npton\nptr\nptrs\npubkey\npwd\npy\nqdtext\nqps\nquantile\nquantiles\nquerydetails\nquiesce\nquitquitquit\nqvalue\nrapidjson\nratelimit\nratelimited\nratelimiter\nrawseti\nrc\nrdsone\nreadded\nreadonly\nreadv\nrealloc\nrebalanced\nrebalancer\nrebalancing\nrebuffer\nrebuilder\nreceival\nreconnection\nrecurse\nrecv\nrecvfrom\nrecvmmsg\nrecvmsg\nredis\nredispatch\nredistributions\nreentrant\nrefactor\nrefactored\nrefcount\nreferencee\nreferer\nrefetch\nrefvec\nregex\nregexes\nreified\nreify\nreimplements\nrele\nreleasor\nreloadable\nremoting\nrenderers\nreparse\nrepeatability\nreperform\nrepicked\nrepo\nreproducibility\nrequirepass\nreselecting\nreserialize\nreservable\nresize\nresized\nresizes\nresizing\nresolv\nresolvers\nresponder\nrestarter\nresync\nret\nretransmissions\nretransmitted\nretransmitting\nretriable\nretriggers\nretryable\nrevalidated\nrevalidation\nreverify\nrfield\nrmdir\nrocketmq\nrewriter\nrollout\nroundtrip\nrpcs\nrq\nrtrim\nrtt\nruleset\nrunfiles\nruntime\nruntimes\nrver\nrxhash\nsandboxed\nsanitization\nsanitizations\nsanitizer\nsatisfiable\nscalability\nsched\nschedulable\nschemas\nscopekey\nsd\nsecp\nsendmsg\nsendmmsg\nsendto\nserializable\nserializer\nserv\nservercert\nsetenv\nsetsockopt\nsfixed\nsig\nsigaction\nsigactions\nsigaltstack\nsiginfo\nsignalstack\nsigv\nsigv4\nsigv4a\nsiloed\nsim\nsinked\nsint\nsizeof\nsmatch\nsnapshotted\nsockaddr\nsocketpair\nsockfd\nsocklen\nsockopt\nsockopts\nsomestring\nspanid\nspdlog\nsplitter\nspoofable\nsrc\nsrtt\nssize\nstackdriver\nstacktrace\nstartpos\nstarttls\nstartup\nstateful\nstatsd\nstderr\nstdev\nstdin\nstdout\nstmt\nstr\nstreambuf\nstrerr\nstrerror\nstringbuf\nstringified\nstringify\nstringstream\nstrtoull\nstruct\nstructs\nsubclassed\nsubclasses\nsubcomponent\nsubdirectories\nsubdirectory\nsubdirs\nsubexpr\nsubexpressions\nsubitems\nsubmatch\nsubmessages\nsubnet\nsubnets\nsuboptimal\nsubsecond\nsubseconds\nsubsegment\nsubsequence\nsubsetting\nsubstr\nsubstring\nsubstrings\nsubtree\nsubtrees\nsubtype\nsubtypes\nsubzone\nsuf\nsuperclass\nsuperroot\nsuperset\nsvc\nsymlink\nsymlinked\nsymlinks\nsynchronizer\nsyncookie\nsys\nsyscall\nsyscalls\nsysctl\nsz\ntchar\ntchars\ntcmalloc\ntcpdump\nteardown\ntempdir\ntemplated\ntemplating\ntemplatize\ntemplatized\ntemplatizing\ntestability\ntestcase\ntestcases\ntestdata\ntestee\nthreadsafe\nthru\ntimespan\ntimestamp\ntimestamps\ntimeval\ntmp\ntmpfile\ntokenize\ntokenized\ntokenizes\ntokenizing\ntoolchain\ntraceid\ntraceparent\ntracestate\ntranscode\ntranscoded\ntranscoder\ntranscoding\ntransferral\ntrds\ntri\ntriaged\ntrie\ntuple\ntuples\ntypedef\ntypeid\ntypesafe\nuber\nucontext\nudpa\nuint\nun-\nunacked\nunary\nunconfigurable\nundef\nunderflowing\nunfreed\nunicast\nunicode\nunicodes\nunindexed\nuninstantiated\nuniq\nunittest\nunix\nunref\nunreferenced\nunzigzag\nupcasts\nupstreams\nuptime\nupvalue\nurlencoded\nurls\nuserdata\nuserinfo\nusername\nusr\nutil\nutils\nva\nvalgrind\nvalidator\nvalidators\nvanishingly\nvarchar\nvariadic\nvarint\nvec\nvectorize\nver\nverifier\nverifiers\nversa\nversioned\nvhost\nviewable\nviewport\nvip\nvirtualhost\nvirtualize\nvptr\nvtable\nvtt\nwakeup\nwakeups\nwamr\nwasmtime\nwebsocket\nwepoll\nwhitespace\nwhitespaces\nwildcard\nwildcards\nwinsock\nworkspace\nwritev\nwrsq\nwww\nxDS\nxDSes\nxdstp\nxeon\nxform\nxhtml\nxid\nxmodem\nxxhash\nxxs\nxyz\nxyzwebservices\nzag\nzig\nzipkin\nzlib\nzstd\nOBQ\nSemVer\nSCM\nSCTP\nCRLF\nclen\ncrlf\nep\nsuri\ntransid\nroutable\nvhosts\ninfos\nElastiCache\npinterest\nNSS\nSSLKEYLOGFILE\nDLB\nPCIE\nEDNS\nCNAME\n"], "fixing_code": ["date: Pending\n\nbehavior_changes:\n# *Changes that are expected to cause an incompatibility if applicable; deployment changes are likely required*\n\nminor_behavior_changes:\n# *Changes that may cause incompatibilities for some users, but should not for most*\n- area: adaptive concurrency filter stats\n  change: |\n    Multiply the gradient value stat by 1000 to make it more granular (values will range between 500 and 2000).\n- area: dns\n  change: |\n    Allowing <envoy_v3_api_field_extensions.common.dynamic_forward_proxy.v3.DnsCacheConfig.dns_min_refresh_rate>` to go as low as 1s.\n- area: upstream\n  change: |\n    Upstream now excludes hosts set to ``DRAINING`` state via EDS from load balancing and panic routing\n    threshold calculation. This feature can be disabled by setting\n    ``envoy.reloadable_features.exclude_host_in_eds_status_draining`` to false.\n- area: golang\n  change: |\n    Change ``RegisterHttpFilterConfigFactoryAndParser`` to ``RegisterHttpFilterFactoryAndConfigParser``.\n- area: QUIC\n  change: |\n    Port migration is default turned off. QUIC client connections will no longer attempt to migrate to a new port when connections\n    is degrading. Can be manually turned on via\n    :ref:`port_migration <envoy_v3_api_field_config.core.v3.QuicProtocolOptions.num_timeouts_to_trigger_port_migration>`.\n- area: aws\n  change: |\n    AWS region string is now retrieved from environment and profile consistently within aws_request_signer and\n    grpc_credentials/aws_iam extensions. Region field in aws_request_signer is now optional, explicitly configured\n    xDS region will take preference. aws_request_signer documentation now reflects the region chain.\n\nbug_fixes:\n# *Changes expected to improve the state of the world and are unlikely to have negative effects*\n- area: tracers\n  change: |\n    use unary RPC calls for OpenTelemetry trace exports, rather than client-side streaming connections.\n- area: load balancing\n  change: |\n    Added randomization in locality load-balancing initialization. This helps desynchronizing Envoys across\n    a fleet by randomizing the scheduler starting point. This can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.edf_lb_locality_scheduler_init_fix`` to false.\n- area: UDP and TCP tunneling\n  change: |\n    fixed a bug where second HTTP response headers received would cause Envoy to crash in cases where\n    ``propagate_response_headers`` and retry configurations are enabled at the same time, and an upstream\n    request is retried multiple times.\n- area: tracing\n  change: |\n    Prevent Envoy from crashing at start up when the OpenTelemetry environment resource detector cannot detect any attributes.\n- area: proxy protocol\n  change: |\n    Fixed a crash when Envoy is configured for PROXY protocol on both a listener and cluster, and the listener receives\n    a PROXY protocol header with address type LOCAL (typically used for health checks).\n\nremoved_config_or_runtime:\n# *Normally occurs at the end of the* :ref:`deprecation period <deprecated>`\n- area: http\n  change: |\n    Removed ``envoy.reloadable_features.allow_absolute_url_with_mixed_scheme`` runtime flag and legacy code paths.\n- area: active health check\n  change: |\n    Removed ``envoy.reloadable_features.keep_endpoint_active_hc_status_on_locality_update`` runtime flag and legacy code paths.\n- area: http1\n  change: |\n    Removed ``envoy.reloadable_features.http1_allow_codec_error_response_after_1xx_headers`` runtime flag and legacy code paths.\n- area: overload manager\n  change: |\n    removed ``envoy.reloadable_features.overload_manager_error_unknown_action`` and legacy code paths.\n- area: http\n  change: |\n    Removed ``envoy_reloadable_features_append_xfh_idempotent`` runtime flag and legacy code paths.\n- area: resource_monitors\n  change: |\n    removed ``envoy.reloadable_features.count_unused_mapped_pages_as_free`` runtime flag  and legacy code paths.\n\nnew_features:\n- area: aws_request_signing\n  change: |\n    Update ``aws_request_signing`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: aws_lambda\n  change: |\n    Update ``aws_lambda`` filter to support use as an upstream HTTP filter. This allows successful calculation of\n    signatures after the forwarding stage has completed, particularly if the path element is modified.\n- area: grpc reverse bridge\n  change: |\n    Change HTTP status to 200 to respect the gRPC protocol. This may cause problems for incorrect gRPC clients expecting the filter\n    to preserve HTTP 1.1 responses.  This behavioral change can be temporarily reverted by setting runtime guard\n    ``envoy.reloadable_features.grpc_http1_reverse_bridge_change_http_status`` to false.\n- area: quic\n  change: |\n    Added QUIC protocol option :ref:`send_disable_active_migration\n    <envoy_v3_api_field_config.listener.v3.QuicProtocolOptions.send_disable_active_migration>` to make the server send clients a transport\n    parameter to discourage client endpoints from active migration.\n- area: ext_proc\n  change: |\n    implemented\n    :ref:`request_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.request_attributes>`\n    and\n    :ref:`response_attributes <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.response_attributes>`\n    config APIs to enable sending and receiving attributes to/from the external processing server.\n- area: access log\n  change: |\n    added support for :ref:`%UPSTREAM_CONNECTION_ID% <config_access_log_format_upstream_connection_id>` for the upstream connection\n    identifier.\n- area: aws_lambda\n  change: |\n    Added :ref:`host_rewrite <envoy_v3_api_field_extensions.filters.http.aws_lambda.v3.Config.host_rewrite>` config to be used\n    during signature.\n- area: ext_proc\n  change: |\n    added\n    :ref:`metadata_options <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.ExternalProcessor.metadata_options>`\n    config API to enable sending and receiving metadata from/to the external processing server. Both typed and untyped dynamic\n    metadata may be sent to the server. If\n    :ref:`receiving_namespaces <envoy_v3_api_field_extensions.filters.http.ext_proc.v3.MetadataOptions.receiving_namespaces>`\n    is defined, returned metadata may be written to the specified allowed namespaces.\n- area: monitoring\n  change: |\n    Add ``Envoy::ExecutionContext``, which is notified by ``ScopeTrackerScopeState``'s constructor and destructor. This feature is\n    disabled by default, it can be enabled by runtime feature flag ``envoy.restart_features.enable_execution_context``. For more details,\n    please see https://github.com/envoyproxy/envoy/issues/32012.\n- area: rbac\n  change: |\n    Added :ref:`uri_template<envoy_v3_api_field_config.rbac.v3.Permission.uri_template>` which uses existing\n    :ref:`UriTemplateMatchConfig<envoy_v3_api_msg_extensions.path.match.uri_template.v3.UriTemplateMatchConfig>`\n    to allow use of glob patterns for URI path matching in RBAC.\n- area: upstream\n  change: |\n    Added :ref:`selection_method <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    option to the least request load balancer. If set to ``FULL_SCAN``,\n    Envoy will select the host with the fewest active requests from the entire host set rather than\n    :ref:`choice_count <envoy_v3_api_msg_extensions.load_balancing_policies.least_request.v3.LeastRequest>`\n    random choices.\n\ndeprecated:\n", "#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\n#include <sstream>\n\n#include \"envoy/buffer/buffer.h\"\n#include \"envoy/network/address.h\"\n\n#include \"source/common/network/address_impl.h\"\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace Common {\nnamespace ProxyProtocol {\n\nvoid generateV1Header(const std::string& src_addr, const std::string& dst_addr, uint32_t src_port,\n                      uint32_t dst_port, Network::Address::IpVersion ip_version,\n                      Buffer::Instance& out) {\n  std::ostringstream stream;\n  stream << PROXY_PROTO_V1_SIGNATURE;\n\n  switch (ip_version) {\n  case Network::Address::IpVersion::v4:\n    stream << PROXY_PROTO_V1_AF_INET << \" \";\n    break;\n  case Network::Address::IpVersion::v6:\n    stream << PROXY_PROTO_V1_AF_INET6 << \" \";\n    break;\n  }\n\n  stream << src_addr << \" \";\n  stream << dst_addr << \" \";\n  stream << src_port << \" \";\n  stream << dst_port << \"\\r\\n\";\n\n  out.add(stream.str());\n}\n\nvoid generateV1Header(const Network::Address::Ip& source_address,\n                      const Network::Address::Ip& dest_address, Buffer::Instance& out) {\n  generateV1Header(source_address.addressAsString(), dest_address.addressAsString(),\n                   source_address.port(), dest_address.port(), source_address.version(), out);\n}\n\nvoid generateV2Header(const std::string& src_addr, const std::string& dst_addr, uint32_t src_port,\n                      uint32_t dst_port, Network::Address::IpVersion ip_version,\n                      uint16_t extension_length, Buffer::Instance& out) {\n  out.add(PROXY_PROTO_V2_SIGNATURE, PROXY_PROTO_V2_SIGNATURE_LEN);\n\n  const uint8_t version_and_command = PROXY_PROTO_V2_VERSION << 4 | PROXY_PROTO_V2_ONBEHALF_OF;\n  out.add(&version_and_command, 1);\n\n  uint8_t address_family_and_protocol;\n  switch (ip_version) {\n  case Network::Address::IpVersion::v4:\n    address_family_and_protocol = PROXY_PROTO_V2_AF_INET << 4;\n    break;\n  case Network::Address::IpVersion::v6:\n    address_family_and_protocol = PROXY_PROTO_V2_AF_INET6 << 4;\n    break;\n  }\n  address_family_and_protocol |= PROXY_PROTO_V2_TRANSPORT_STREAM;\n  out.add(&address_family_and_protocol, 1);\n\n  // Number of following bytes part of the header in V2 protocol.\n  uint16_t addr_length;\n  uint16_t addr_length_n; // Network byte order\n\n  switch (ip_version) {\n  case Network::Address::IpVersion::v4: {\n    addr_length = PROXY_PROTO_V2_ADDR_LEN_INET + extension_length;\n    addr_length_n = htons(addr_length);\n    out.add(&addr_length_n, 2);\n    const uint32_t net_src_addr =\n        Network::Address::Ipv4Instance(src_addr, src_port).ip()->ipv4()->address();\n    const uint32_t net_dst_addr =\n        Network::Address::Ipv4Instance(dst_addr, dst_port).ip()->ipv4()->address();\n    out.add(&net_src_addr, 4);\n    out.add(&net_dst_addr, 4);\n    break;\n  }\n  case Network::Address::IpVersion::v6: {\n    addr_length = PROXY_PROTO_V2_ADDR_LEN_INET6 + extension_length;\n    addr_length_n = htons(addr_length);\n    out.add(&addr_length_n, 2);\n    const absl::uint128 net_src_addr =\n        Network::Address::Ipv6Instance(src_addr, src_port).ip()->ipv6()->address();\n    const absl::uint128 net_dst_addr =\n        Network::Address::Ipv6Instance(dst_addr, dst_port).ip()->ipv6()->address();\n    out.add(&net_src_addr, 16);\n    out.add(&net_dst_addr, 16);\n    break;\n  }\n  }\n\n  const uint16_t net_src_port = htons(static_cast<uint16_t>(src_port));\n  const uint16_t net_dst_port = htons(static_cast<uint16_t>(dst_port));\n  out.add(&net_src_port, 2);\n  out.add(&net_dst_port, 2);\n}\n\nvoid generateV2Header(const std::string& src_addr, const std::string& dst_addr, uint32_t src_port,\n                      uint32_t dst_port, Network::Address::IpVersion ip_version,\n                      Buffer::Instance& out) {\n  generateV2Header(src_addr, dst_addr, src_port, dst_port, ip_version, 0, out);\n}\n\nvoid generateV2Header(const Network::Address::Ip& source_address,\n                      const Network::Address::Ip& dest_address, Buffer::Instance& out) {\n  generateV2Header(source_address.addressAsString(), dest_address.addressAsString(),\n                   source_address.port(), dest_address.port(), source_address.version(), 0, out);\n}\n\nbool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer::Instance& out,\n                      bool pass_all_tlvs, const absl::flat_hash_set<uint8_t>& pass_through_tlvs) {\n  uint64_t extension_length = 0;\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    extension_length += PROXY_PROTO_V2_TLV_TYPE_LENGTH_LEN + tlv.value.size();\n    if (extension_length > std::numeric_limits<uint16_t>::max()) {\n      ENVOY_LOG_MISC(\n          warn, \"Generating Proxy Protocol V2 header: TLVs exceed length limit {}, already got {}\",\n          std::numeric_limits<uint16_t>::max(), extension_length);\n      return false;\n    }\n  }\n\n  ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n  if (proxy_proto_data.src_addr_ == nullptr || proxy_proto_data.src_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect source IP in proxy_proto_data_\");\n    return false;\n  }\n  if (proxy_proto_data.dst_addr_ == nullptr || proxy_proto_data.dst_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect dest IP in proxy_proto_data_\");\n    return false;\n  }\n\n  const auto& src = *proxy_proto_data.src_addr_->ip();\n  const auto& dst = *proxy_proto_data.dst_addr_->ip();\n  generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),\n                   src.version(), static_cast<uint16_t>(extension_length), out);\n\n  // Generate the TLV vector.\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    out.add(&tlv.type, 1);\n    uint16_t size = htons(static_cast<uint16_t>(tlv.value.size()));\n    out.add(&size, sizeof(uint16_t));\n    out.add(&tlv.value.front(), tlv.value.size());\n  }\n  return true;\n}\n\nvoid generateProxyProtoHeader(const envoy::config::core::v3::ProxyProtocolConfig& config,\n                              const Network::Connection& connection, Buffer::Instance& out) {\n  const Network::Address::Ip& dest_address =\n      *connection.connectionInfoProvider().localAddress()->ip();\n  const Network::Address::Ip& source_address =\n      *connection.connectionInfoProvider().remoteAddress()->ip();\n  if (config.version() == envoy::config::core::v3::ProxyProtocolConfig::V1) {\n    generateV1Header(source_address, dest_address, out);\n  } else if (config.version() == envoy::config::core::v3::ProxyProtocolConfig::V2) {\n    generateV2Header(source_address, dest_address, out);\n  }\n}\n\nvoid generateV2LocalHeader(Buffer::Instance& out) {\n  out.add(PROXY_PROTO_V2_SIGNATURE, PROXY_PROTO_V2_SIGNATURE_LEN);\n  const uint8_t addr_fam_protocol_and_length[4]{PROXY_PROTO_V2_VERSION << 4, 0, 0, 0};\n  out.add(addr_fam_protocol_and_length, 4);\n}\n\n} // namespace ProxyProtocol\n} // namespace Common\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/exception.h\"\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/event/dispatcher.h\"\n#include \"envoy/network/listen_socket.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/common/assert.h\"\n#include \"source/common/common/empty_string.h\"\n#include \"source/common/common/fmt.h\"\n#include \"source/common/common/hex.h\"\n#include \"source/common/common/safe_memcpy.h\"\n#include \"source/common/common/utility.h\"\n#include \"source/common/network/address_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/common/proxy_protocol/proxy_protocol_header.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ADDR_LEN_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_AF_INET6;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_HEADER_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_LOCAL;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_ONBEHALF_OF;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_DGRAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_TRANSPORT_STREAM;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_VERSION;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\n\nConfig::Config(\n    Stats::Scope& scope,\n    const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol& proto_config)\n    : stats_{ALL_PROXY_PROTOCOL_STATS(POOL_COUNTER(scope))},\n      allow_requests_without_proxy_protocol_(proto_config.allow_requests_without_proxy_protocol()),\n      pass_all_tlvs_(proto_config.has_pass_through_tlvs()\n                         ? proto_config.pass_through_tlvs().match_type() ==\n                               ProxyProtocolPassThroughTLVs::INCLUDE_ALL\n                         : false) {\n  for (const auto& rule : proto_config.rules()) {\n    tlv_types_[0xFF & rule.tlv_type()] = rule.on_tlv_present();\n  }\n\n  if (proto_config.has_pass_through_tlvs() &&\n      proto_config.pass_through_tlvs().match_type() == ProxyProtocolPassThroughTLVs::INCLUDE) {\n    for (const auto& tlv_type : proto_config.pass_through_tlvs().tlv_type()) {\n      pass_through_tlvs_.insert(0xFF & tlv_type);\n    }\n  }\n}\n\nconst KeyValuePair* Config::isTlvTypeNeeded(uint8_t type) const {\n  auto tlv_type = tlv_types_.find(type);\n  if (tlv_types_.end() != tlv_type) {\n    return &tlv_type->second;\n  }\n\n  return nullptr;\n}\n\nbool Config::isPassThroughTlvTypeNeeded(uint8_t tlv_type) const {\n  if (pass_all_tlvs_) {\n    return true;\n  }\n  return pass_through_tlvs_.contains(tlv_type);\n}\n\nsize_t Config::numberOfNeededTlvTypes() const { return tlv_types_.size(); }\n\nbool Config::allowRequestsWithoutProxyProtocol() const {\n  return allow_requests_without_proxy_protocol_;\n}\n\nNetwork::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {\n  ENVOY_LOG(debug, \"proxy_protocol: New connection accepted\");\n  cb_ = &cb;\n  // Waiting for data.\n  return Network::FilterStatus::StopIteration;\n}\n\nNetwork::FilterStatus Filter::onData(Network::ListenerFilterBuffer& buffer) {\n  const ReadOrParseState read_state = parseBuffer(buffer);\n  switch (read_state) {\n  case ReadOrParseState::Error:\n    config_->stats_.downstream_cx_proxy_proto_error_.inc();\n    cb_->socket().ioHandle().close();\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::TryAgainLater:\n    return Network::FilterStatus::StopIteration;\n  case ReadOrParseState::SkipFilter:\n    return Network::FilterStatus::Continue;\n  case ReadOrParseState::Done:\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::Continue;\n}\n\nReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {\n  Network::ConnectionSocket& socket = cb_->socket();\n\n  // We return if a) we do not yet have the header, b) we have the header but not yet all\n  // the extension data.\n  if (!proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_header_state = readProxyHeader(buffer);\n    if (read_header_state != ReadOrParseState::Done) {\n      return read_header_state;\n    }\n  }\n\n  // After parse the header, the extensions size is discovered. Then extend the buffer\n  // size to receive the extensions.\n  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {\n    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();\n    // The expected header size is changed, waiting for more data.\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.has_value()) {\n    const ReadOrParseState read_ext_state = readExtensions(buffer);\n    if (read_ext_state != ReadOrParseState::Done) {\n      return read_ext_state;\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() &&\n      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(\n          Network::ProxyProtocolFilterState::key())) {\n    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);\n    if (proxy_protocol_header_.value().local_command_) {\n      ENVOY_LOG(trace, \"Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}\",\n                proxy_protocol_header_.value().wholeHeaderLength(),\n                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));\n\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              socket.connectionInfoProvider().remoteAddress(),\n              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    } else {\n      ENVOY_LOG(\n          trace,\n          \"Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV \"\n          \"buffer: {}\",\n          proxy_protocol_header_.value().wholeHeaderLength(),\n          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),\n          proxy_protocol_header_.value().extensions_length_,\n          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),\n                             proxy_protocol_header_.value().extensions_length_));\n      cb_->filterState().setData(\n          Network::ProxyProtocolFilterState::key(),\n          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{\n              proxy_protocol_header_.value().remote_address_,\n              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),\n          StreamInfo::FilterState::StateType::Mutable,\n          StreamInfo::FilterState::LifeSpan::Connection);\n    }\n  }\n\n  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {\n    // If this is a local_command, we are not to override address\n    // Error check the source and destination fields. Most errors are caught by the address\n    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as\n    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the\n    // source address.\n    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();\n    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();\n    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||\n        local_version != proxy_protocol_header_.value().protocol_version_) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n    // Check that both addresses are valid unicast addresses, as required for TCP\n    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||\n        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return ReadOrParseState::Error;\n    }\n\n    // Only set the local address if it really changed, and mark it as address being restored.\n    if (*proxy_protocol_header_.value().local_address_ !=\n        *socket.connectionInfoProvider().localAddress()) {\n      socket.connectionInfoProvider().restoreLocalAddress(\n          proxy_protocol_header_.value().local_address_);\n    }\n    socket.connectionInfoProvider().setRemoteAddress(\n        proxy_protocol_header_.value().remote_address_);\n  }\n\n  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::Error;\n  }\n  return ReadOrParseState::Done;\n}\n\nabsl::optional<size_t> Filter::lenV2Address(const char* buf) {\n  const uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  size_t len;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // According to the spec there is no address encoded, len=0, and we must ignore\n    return 0;\n  }\n\n  switch ((proto_family & 0xf0) >> 4) {\n  case PROXY_PROTO_V2_AF_INET:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET;\n    break;\n  case PROXY_PROTO_V2_AF_INET6:\n    len = PROXY_PROTO_V2_ADDR_LEN_INET6;\n    break;\n  default:\n    ENVOY_LOG(debug, \"Unsupported V2 proxy protocol address family\");\n    return absl::nullopt;\n  }\n  return len;\n}\n\nbool Filter::parseV2Header(const char* buf) {\n  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {\n    // This is locally-initiated, e.g. health-check, and should not override remote address.\n    // According to the spec, this address length should be zero for local connection.\n    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});\n    return true;\n  }\n\n  // Only do connections on behalf of another user, not internally-driven health-checks. If\n  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and\n  // use the real-remote info\n  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {\n    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];\n    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||\n        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {\n      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {\n        PACKED_STRUCT(struct pp_ipv4_addr {\n          uint32_t src_addr;\n          uint32_t dst_addr;\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv4_addr* v4;\n        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in ra4, la4;\n        memset(&ra4, 0, sizeof(ra4));\n        memset(&la4, 0, sizeof(la4));\n        ra4.sin_family = AF_INET;\n        ra4.sin_port = v4->src_port;\n        ra4.sin_addr.s_addr = v4->src_addr;\n\n        la4.sin_family = AF_INET;\n        la4.sin_port = v4->dst_port;\n        la4.sin_addr.s_addr = v4->dst_addr;\n        proxy_protocol_header_.emplace(\n            WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,\n                       hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,\n                       std::make_shared<Network::Address::Ipv4Instance>(&ra4),\n                       std::make_shared<Network::Address::Ipv4Instance>(&la4)});\n        return true;\n      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {\n        PACKED_STRUCT(struct pp_ipv6_addr {\n          uint8_t src_addr[16];\n          uint8_t dst_addr[16];\n          uint16_t src_port;\n          uint16_t dst_port;\n        });\n        const pp_ipv6_addr* v6;\n        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);\n        sockaddr_in6 ra6, la6;\n        memset(&ra6, 0, sizeof(ra6));\n        memset(&la6, 0, sizeof(la6));\n        ra6.sin6_family = AF_INET6;\n        ra6.sin6_port = v6->src_port;\n        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));\n\n        la6.sin6_family = AF_INET6;\n        la6.sin6_port = v6->dst_port;\n        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));\n\n        proxy_protocol_header_.emplace(WireHeader{\n            PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,\n            hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,\n            std::make_shared<Network::Address::Ipv6Instance>(ra6),\n            std::make_shared<Network::Address::Ipv6Instance>(la6)});\n        return true;\n      }\n    }\n  }\n  ENVOY_LOG(debug, \"Unsupported command or address family or transport\");\n  return false;\n}\n\nbool Filter::parseV1Header(const char* buf, size_t len) {\n  std::string proxy_line;\n  proxy_line.assign(buf, len);\n  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);\n\n  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS\n  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.\n  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, \" \", true);\n  if (line_parts.size() < 2 || line_parts[0] != \"PROXY\") {\n    ENVOY_LOG(debug, \"failed to read proxy protocol\");\n    return false;\n  }\n\n  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from\n  // the socket and continue. According to spec \"real connection's parameters\" should be used, so\n  // we should NOT restore the addresses in this case.\n  if (line_parts[1] != \"UNKNOWN\") {\n    // If protocol not UNKNOWN, src and dst addresses have to be present.\n    if (line_parts.size() != 6) {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n\n    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view\n    // arguments, so we can eliminate allocation here.\n    if (line_parts[1] == \"TCP4\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + \":\" +\n                                                               std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + \":\" +\n                                                               std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});\n      return true;\n    } else if (line_parts[1] == \"TCP6\") {\n      const Network::Address::InstanceConstSharedPtr remote_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[2]} +\n                                                               \"]:\" + std::string{line_parts[4]});\n      const Network::Address::InstanceConstSharedPtr local_address =\n          Network::Utility::parseInternetAddressAndPortNoThrow(\"[\" + std::string{line_parts[3]} +\n                                                               \"]:\" + std::string{line_parts[5]});\n\n      if (remote_address == nullptr || local_address == nullptr) {\n        return false;\n      }\n      proxy_protocol_header_.emplace(\n          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});\n      return true;\n    } else {\n      ENVOY_LOG(debug, \"failed to read proxy protocol\");\n      return false;\n    }\n  }\n  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});\n  return true;\n}\n\n/**\n * @note  A TLV is arranged in the following format:\n *        struct pp2_tlv {\n *          uint8_t type;\n *          uint8_t length_hi;\n *          uint8_t length_lo;\n *          uint8_t value[0];\n *        };\n *        See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details\n */\nbool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n\n    // Get the value.\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n\n    // Only save to dynamic metadata if this type of TLV is needed.\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n\n    // Save TLVs to the filter state.\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}\n\nReadOrParseState Filter::readExtensions(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  // waiting for more data if there is no enough data for extensions.\n  if (raw_slice.len_ < (proxy_protocol_header_.value().wholeHeaderLength())) {\n    return ReadOrParseState::TryAgainLater;\n  }\n\n  if (proxy_protocol_header_.value().local_command_) {\n    // Ignores the extensions if this is a local command.\n    // Those will drained from the buffer in the end.\n    return ReadOrParseState::Done;\n  }\n\n  const uint8_t* buf = static_cast<const uint8_t*>(raw_slice.mem_) +\n                       proxy_protocol_header_.value().headerLengthWithoutExtension();\n  if (!parseTlvs(buf, proxy_protocol_header_.value().extensions_length_)) {\n    return ReadOrParseState::Error;\n  }\n\n  return ReadOrParseState::Done;\n}\n\nReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {\n  auto raw_slice = buffer.rawSlice();\n  const char* buf = static_cast<const char*>(raw_slice.mem_);\n\n  if (config_.get()->allowRequestsWithoutProxyProtocol()) {\n    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));\n    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,\n                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));\n    if (!matchv2 && !matchv1) {\n      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely\n      // short-circuit\n      ENVOY_LOG(trace, \"request does not use v1 or v2 proxy protocol, forwarding as is\");\n      return ReadOrParseState::SkipFilter;\n    }\n  }\n\n  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {\n    const char* sig = PROXY_PROTO_V2_SIGNATURE;\n    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {\n      header_version_ = V2;\n    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {\n      // It is not v2, and can't be v1, so no sense hanging around: it is invalid\n      ENVOY_LOG(debug, \"failed to read proxy protocol (exceed max v1 header len)\");\n      return ReadOrParseState::Error;\n    }\n  }\n\n  if (header_version_ == V2) {\n    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];\n    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {\n      ENVOY_LOG(debug, \"Unsupported V2 proxy protocol version\");\n      return ReadOrParseState::Error;\n    }\n    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);\n    if (!addr_len_opt.has_value()) {\n      return ReadOrParseState::Error;\n    }\n    ssize_t addr_len = addr_len_opt.value();\n    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];\n    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];\n    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;\n    if (hdr_addr_len < addr_len) {\n      ENVOY_LOG(debug,\n                \"incorrect address length, address length = {}, the expected address length = {}\",\n                hdr_addr_len, addr_len);\n      return ReadOrParseState::Error;\n    }\n    // waiting for more data if there is no enough data for address.\n    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {\n      // The TLV remain, they are parsed in `parseTlvs()` which is called from the\n      // parent (if needed).\n      if (parseV2Header(buf)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  } else {\n    // continue searching buffer from where we left off\n    for (; search_index_ < raw_slice.len_; search_index_++) {\n      if (buf[search_index_] == '\\n' && buf[search_index_ - 1] == '\\r') {\n        if (search_index_ == 1) {\n          // There is not enough data to determine if it contains the v2 protocol signature, so wait\n          // for more data.\n          break;\n        } else {\n          header_version_ = V1;\n          search_index_++;\n        }\n        break;\n      }\n    }\n\n    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {\n      return ReadOrParseState::Error;\n    }\n\n    if (header_version_ == V1) {\n      if (parseV1Header(buf, search_index_)) {\n        return ReadOrParseState::Done;\n      } else {\n        return ReadOrParseState::Error;\n      }\n    }\n  }\n\n  return ReadOrParseState::TryAgainLater;\n}\n\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include <functional>\n#include <memory>\n#include <string>\n\n#include \"envoy/common/platform.h\"\n#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/stats/scope.h\"\n\n#include \"source/common/api/os_sys_calls_impl.h\"\n#include \"source/common/buffer/buffer_impl.h\"\n#include \"source/common/event/dispatcher_impl.h\"\n#include \"source/common/listener_manager/connection_handler_impl.h\"\n#include \"source/common/network/connection_balancer_impl.h\"\n#include \"source/common/network/listen_socket_impl.h\"\n#include \"source/common/network/proxy_protocol_filter_state.h\"\n#include \"source/common/network/raw_buffer_socket.h\"\n#include \"source/common/network/tcp_listener_impl.h\"\n#include \"source/common/network/utility.h\"\n#include \"source/extensions/filters/listener/proxy_protocol/proxy_protocol.h\"\n\n#include \"test/mocks/api/mocks.h\"\n#include \"test/mocks/buffer/mocks.h\"\n#include \"test/mocks/network/mocks.h\"\n#include \"test/mocks/runtime/mocks.h\"\n#include \"test/mocks/server/listener_factory_context.h\"\n#include \"test/test_common/environment.h\"\n#include \"test/test_common/network_utility.h\"\n#include \"test/test_common/printers.h\"\n#include \"test/test_common/threadsafe_singleton_injector.h\"\n#include \"test/test_common/utility.h\"\n\n#include \"gmock/gmock.h\"\n#include \"gtest/gtest.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V1_SIGNATURE_LEN;\nusing Envoy::Extensions::Common::ProxyProtocol::PROXY_PROTO_V2_SIGNATURE_LEN;\nusing testing::_;\nusing testing::AnyNumber;\nusing testing::AtLeast;\nusing testing::ElementsAre;\nusing testing::Invoke;\nusing testing::NiceMock;\nusing testing::Return;\nusing testing::ReturnRef;\n\nnamespace Envoy {\nnamespace Extensions {\nnamespace ListenerFilters {\nnamespace ProxyProtocol {\nnamespace {\n\n// Build again on the basis of the connection_handler_test.cc\n\nclass ProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                          public Network::ListenerConfig,\n                          public Network::FilterChainManager,\n                          protected Logger::Loggable<Logger::Id::main> {\npublic:\n  ProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getCanonicalLoopbackAddress(GetParam()))),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(socket_->connectionInfoProvider().localAddress(),\n                                                Network::Address::InstanceConstSharedPtr(),\n                                                Network::Test::createRawBufferSocket(), nullptr,\n                                                nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect(bool read = true,\n               const envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol*\n                   proto_config = nullptr) {\n    int expected_callbacks = 2;\n    auto maybeExitDispatcher = [&]() -> void {\n      expected_callbacks--;\n      if (expected_callbacks == 0) {\n        dispatcher_->exit();\n      }\n    };\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr, std::make_unique<Filter>(std::make_shared<Config>(\n                           listenerScope(), (nullptr != proto_config)\n                                                ? *proto_config\n                                                : envoy::extensions::filters::listener::\n                                                      proxy_protocol::v3::ProxyProtocol())));\n          maybeExitDispatcher();\n          return true;\n        }));\n    conn_->connect();\n    if (read) {\n      read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n      EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n          .WillOnce(Invoke([&](Network::Connection& connection,\n                               const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n            server_connection_ = &connection;\n            connection.addConnectionCallbacks(server_callbacks_);\n            connection.addReadFilter(read_filter_);\n            return true;\n          }));\n    }\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { maybeExitDispatcher(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const uint8_t* s, ssize_t l) {\n    Buffer::OwnedImpl buf(s, l);\n    conn_->write(buf, false);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void expectConnectionError() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n  void expectProxyProtoError() {\n    expectConnectionError();\n    EXPECT_EQ(stats_store_.counter(\"downstream_cx_proxy_proto_error\").value(), 1);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::TestUtil::TestStore stats_store_;\n  Api::ApiPtr api_;\n  BasicResourceLimitImpl open_connections_;\n  Event::DispatcherPtr dispatcher_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  Api::OsSysCallsImpl os_sys_calls_actual_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(ProxyProtocolTest, V1Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocol) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"data\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN,\n            msg.length()); // Ensure we attempt parsing byte by byte using `search_index_`\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV1First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v1, second two bytes are proxy protocol v2.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"PR\\r\\n\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowTinyNoProxyProtocolPartialMatchesV2First) {\n  // Allows a small request (less bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol v1/v2 (but it does match parts of both signatures)\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // First two bytes are proxy protocol v2, second two bytes are proxy protocol v1.\n  // This ensures our byte by byte parsing (`search_index_`) has persistence built-in to\n  // remember whether the previous bytes were also valid for the signature\n  std::string msg = \"\\r\\nOX\";\n  ASSERT_GT(PROXY_PROTO_V1_SIGNATURE_LEN, msg.length());\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, msg.length());\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, AllowLargeNoProxyProtocol) {\n  // Allows a large request (more bytes than v1/v2 signature) through even though it doesn't use\n  // proxy protocol\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  std::string msg = \"more data more data more data\";\n  ASSERT_GT(msg.length(),\n            PROXY_PROTO_V2_HEADER_LEN); // Ensure we attempt parsing as v2 proxy protocol up front\n                                        // rather than parsing byte by byte using `search_index_`\n\n  write(msg);\n  expectData(msg);\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V1Minimal) {\n  connect();\n  write(\"PROXY UNKNOWN\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  } else {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Basic) {\n  // A well-formed ipv4/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2BasicV6) {\n  // A well-formed ipv6/tcp message, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x24, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1:2:3::4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2UnsupportedAF) {\n  // A well-formed message with an unsupported address family\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x41, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_2) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv (e.g. socket close)\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n// TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, ErrorRecv_1) {\n  // A well formed v4/tcp message, no extensions, but introduce an error on recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Return(Api::SysCallSizeResult{-1, 0}));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2NotLocalOrOnBehalf) {\n  // An illegal command type: neither 'local' nor 'proxy' command\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x23, 0x1f, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnection) {\n  // A 'local' connection, e.g. health-checking, no address, no extensions\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionExtension) {\n  // A 'local' connection, e.g. health-checking, no address, 1 TLV (0x00,0x00,0x01,0xff) is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x01, 0xff,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, sizeof(buffer));\n  expectData(\"more data\");\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n              \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  // A well-formed local proxy protocol v2 header sampled from an AWS NLB healthcheck request,\n  // no address, 1 TLV is present.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4) {\n  // An ipv4/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV4WithAllowNoProxyProtocol) {\n  // An ipv4/tcp PROXY header that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x21, 0x00, 0x04, 0x00, 0x08, 0x00, 0x02,\n                                'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV4) {\n  // An ipv4/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0b, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortV6) {\n  // An ipv6/tcp connection that has incorrect addr-len encoded\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x22, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ShortAddrV6) {\n  // An ipv6/tcp connection that has insufficient header-length encoded\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x21, 0x22, 0x00, 0x23, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n                                0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,\n                                0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',\n                                'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2AF_UNIX) {\n  // A well-formed AF_UNIX (0x32 in b14) connection is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2BadCommand) {\n  // A non local/proxy command (0x29 in b13) is rejected\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x29, 0x32, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongVersion) {\n  // A non '2' version is rejected (0x93 in b13)\n  constexpr uint8_t buffer[] = {\n      0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21, 0x93, 0x00,\n      0x14, 0x00, 0x01, 0x01, 0x00, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 'm',  'o',  'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect(false);\n  write(buffer, sizeof(buffer));\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLong) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V1TooLongWithAllowNoProxyProtocol) {\n  constexpr uint8_t buffer[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(false, &proto_config);\n  write(\"PROXY TCP4 1.2.3.4 2.3.4.5 100 100\");\n  for (size_t i = 0; i < 256; i += sizeof(buffer)) {\n    write(buffer, sizeof(buffer));\n  }\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsRecvError) {\n  // A well-formed ipv4/tcp with a TLV extension. An error is returned on tlv recv()\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n  bool header_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int iovcnt) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, iovcnt);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (header_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  header_writed = true;\n  write(tlv, sizeof(tlv));\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsFrag) {\n  // A well-formed ipv4/tcp header with 2 TLV/extensions, these are fragmented on delivery\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, Fragmented) {\n  connect();\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  // If there is no data after the PROXY line, the read filter does not receive even the\n  // onNewConnection() callback. We need this in order to run the dispatcher in blocking\n  // mode to make sure that proxy protocol processing is completed before we start testing\n  // the results. Since we must have data we might as well check that we get it.\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented1) {\n  // A well-formed ipv4/tcp message, delivering part of the signature, then part of\n  // the address, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 10, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 20, 17);\n\n  expectData(\"more data\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented2) {\n  // A well-formed ipv4/tcp message, delivering all of the header + 1, then the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 17, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 27, 10);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented3) {\n  // A well-formed ipv4/tcp message, delivering all of the header, then the remainder.\n  // Do not mistakenly consider that remote has closed when it happens to only read the\n  // header of the message. See: https://github.com/envoyproxy/envoy/pull/18304\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n  connect();\n  write(buffer, 16);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 16, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(buffer + 26, 11);\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented4Error) {\n  // A well-formed ipv4/tcp message, delivering all of the header +1, w/ an error\n  // simulated in recv() on the +1\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_writed = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_writed) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 17);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_writed = true;\n  write(buffer, 11);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, V2Fragmented5Error) {\n  // A well-formed ipv4/tcp message, part of the signature with an error introduced\n  // in recv() on the remainder\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02, 'm',  'o',\n                                'r',  'e',  ' ',  'd',  'a',  't',  'a'};\n\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  bool partial_write = false;\n  // TODO(davinci26): Mocking should not be used to provide real system calls.\n#ifdef WIN32\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, const iovec* iov, int num_iov) {\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.readv(fd, iov, num_iov);\n        return x;\n      }));\n#else\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n#endif\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n        if (partial_write) {\n          return Api::SysCallSizeResult{-1, 0};\n        }\n        return x;\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n  connect(false);\n  write(buffer, 10);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  partial_write = true;\n  write(buffer + 10, 10);\n\n  expectConnectionError();\n}\n\nTEST_P(ProxyProtocolTest, PartialRead) {\n  connect();\n\n  write(\"PROXY TCP4\");\n  write(\" 254.254.2\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PROXY TCP4\"); // Intentionally larger than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\" 254.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV1ReadWithAllowNoProxyProtocol) {\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  write(\"PRO\"); // Intentionally smaller than the size of v1 proxy protocol signature\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"XY TCP4 25\");\n\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(\"4.254.2\");\n  write(\"54.254 1.2\");\n  write(\".3.4 65535\");\n  write(\" 1234\\r\\n...\");\n\n  expectData(\"...\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"254.254.254.254\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2PartialRead) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  connect();\n\n  for (size_t i = 0; i < sizeof(buffer); i += 9) {\n    write(&buffer[i], 9);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, PartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 18 intentionally as it is larger than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 18;\n  ASSERT_LT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, TinyPartialV2ReadWithAllowNoProxyProtocol) {\n  // A well-formed ipv4/tcp header, delivered with part of the signature,\n  // part of the header, rest of header + body\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55,\n                                0x49, 0x54, 0x0a, 0x21, 0x11, 0x00, 0x0c, 0x01, 0x02,\n                                0x03, 0x04, 0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00,\n                                0x02, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  proto_config.set_allow_requests_without_proxy_protocol(true);\n  connect(true, &proto_config);\n\n  // Using 3 intentionally as it is smaller than v2 signature length and divides evenly into\n  // len(buffer)\n  auto buffer_incr_size = 3;\n  ASSERT_GT(PROXY_PROTO_V2_SIGNATURE_LEN, buffer_incr_size);\n  for (size_t i = 0; i < sizeof(buffer); i += buffer_incr_size) {\n    write(&buffer[i], buffer_incr_size);\n    if (i == 0) {\n      dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n    }\n  }\n\n  expectData(\"moredata\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->ip()->addressAsString(),\n            \"1.2.3.4\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}\n\nconst std::string ProxyProtocol = \"envoy.filters.listener.proxy_protocol\";\n\nTEST_P(ProxyProtocolTest, V2ParseExtensionsLargeThanInitMaxReadBytes) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0xff, 0xff, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // The TLV has 65520 size data.\n  constexpr uint8_t tlv_begin[] = {0x02, 0xff, 0xf0};\n  std::string tlv_data(65520, 'a');\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv_begin, sizeof(tlv_begin));\n  write(tlv_data);\n\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  EXPECT_EQ(tlv_data, value_s);\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTlvOfInterestAndEmitWithSpecifiedMetadataNamespace) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n  rule->mutable_on_tlv_present()->set_metadata_namespace(\"We need a different metadata namespace\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(\"We need a different metadata namespace\"));\n\n  auto fields = metadata.at(\"We need a different metadata namespace\").fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_s = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_s, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractMultipleTlvsOfInterest) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x39, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0xea with size of 25 bytes (22 bytes are value)\n  constexpr uint8_t tlv_vpc_id[] = {0xea, 0x00, 0x16, 0x01, 0x76, 0x70, 0x63, 0x2d, 0x30,\n                                    0x32, 0x35, 0x74, 0x65, 0x73, 0x74, 0x32, 0x66, 0x61,\n                                    0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto rule_vpc_id = proto_config.add_rules();\n  rule_vpc_id->set_tlv_type(0xea);\n  rule_vpc_id->mutable_on_tlv_present()->set_key(\"PP2 vpc id\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_vpc_id, sizeof(tlv_vpc_id));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(2, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n  EXPECT_EQ(1, fields.count(\"PP2 vpc id\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  auto value_vpc_id = fields.at(\"PP2 vpc id\").string_value();\n  ASSERT_THAT(value_vpc_id,\n              ElementsAre(0x01, 0x76, 0x70, 0x63, 0x2d, 0x30, 0x32, 0x35, 0x74, 0x65, 0x73, 0x74,\n                          0x32, 0x66, 0x61, 0x36, 0x63, 0x36, 0x33, 0x68, 0x61, 0x37));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WillNotOverwriteTLV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x2a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x00, 0x00, 0x01, 0xff};\n  // a TLV of type 0x02 with size of 10 bytes (7 bytes are value)\n  constexpr uint8_t tlv_type_authority1[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                             0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  // a TLV of type 0x0f with size of 6 bytes (3 bytes are value)\n  constexpr uint8_t tlv3[] = {0x0f, 0x00, 0x03, 0xf0, 0x00, 0x0f};\n  // a TLV of type 0x02 (again) with size of 10 bytes (7 bytes are value) and different values\n  constexpr uint8_t tlv_type_authority2[] = {0x02, 0x00, 0x07, 0x62, 0x61,\n                                             0x72, 0x2e, 0x6e, 0x65, 0x74};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_type_authority = proto_config.add_rules();\n  rule_type_authority->set_tlv_type(0x02);\n  rule_type_authority->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority1, sizeof(tlv_type_authority1));\n  write(tlv3, sizeof(tlv3));\n  write(tlv_type_authority2, sizeof(tlv_type_authority2));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  EXPECT_EQ(1, server_connection_->streamInfo().dynamicMetadata().filter_metadata_size());\n\n  auto metadata = server_connection_->streamInfo().dynamicMetadata().filter_metadata();\n  EXPECT_EQ(1, metadata.size());\n  EXPECT_EQ(1, metadata.count(ProxyProtocol));\n\n  auto fields = metadata.at(ProxyProtocol).fields();\n  EXPECT_EQ(1, fields.size());\n  EXPECT_EQ(1, fields.count(\"PP2 type authority\"));\n\n  auto value_type_authority = fields.at(\"PP2 type authority\").string_value();\n  ASSERT_THAT(value_type_authority, ElementsAre(0x66, 0x6f, 0x6f, 0x2e, 0x63, 0x6f, 0x6d));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2WrongTLVLength) {\n  // A well-formed ipv4/tcp with buffer[14]15] being 0x00 and 0x10. It says we should have 16 bytes\n  // following.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x10, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // tlv[2] should be 0x1 since there's only one byte for tlv value.\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x2, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv, sizeof(tlv));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2IncompleteTLV) {\n  // A ipv4/tcp with buffer[14]15] being 0x00 and 0x11. It says we should have 17 bytes following,\n  // however we have 20.\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x11, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n\n  // a TLV of type 0x00 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  // a TLV of type 0x01 with size of 4 (1 byte is value)\n  constexpr uint8_t tlv2[] = {0x1, 0x0, 0x1, 0xff};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule_00 = proto_config.add_rules();\n  rule_00->set_tlv_type(0x00);\n  rule_00->mutable_on_tlv_present()->set_key(\"00\");\n\n  auto rule_01 = proto_config.add_rules();\n  rule_01->set_tlv_type(0x01);\n  rule_01->mutable_on_tlv_present()->set_key(\"01\");\n\n  connect(false, &proto_config);\n  write(buffer, sizeof(buffer));\n  write(tlv1, sizeof(tlv1));\n  write(tlv2, sizeof(tlv2));\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterState) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  auto rule = proto_config.add_rules();\n  rule->set_tlv_type(0x02);\n  rule->mutable_on_tlv_present()->set_key(\"PP2 type authority\");\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(2, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x0, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(0xFF, proxy_proto_data.tlv_vector_[0].value[0]);\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_[0].value.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[1].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[1].value.begin(),\n                                   proxy_proto_data.tlv_vector_[1].value.end()));\n\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeEmpty) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(0, proxy_proto_data.tlv_vector_.size());\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, V2ExtractTLVToFilterStateIncludeTlV) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x1a, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv1[] = {0x0, 0x0, 0x1, 0xff};\n  constexpr uint8_t tlv_type_authority[] = {0x02, 0x00, 0x07, 0x66, 0x6f,\n                                            0x6f, 0x2e, 0x63, 0x6f, 0x6d};\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n\n  auto pass_through_tlvs = proto_config.mutable_pass_through_tlvs();\n  pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n  pass_through_tlvs->add_tlv_type(0x02);\n\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  write(tlv1, sizeof(tlv1));\n  write(tlv_type_authority, sizeof(tlv_type_authority));\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  EXPECT_TRUE(filter_state->hasData<Network::ProxyProtocolFilterState>(\n      Network::ProxyProtocolFilterState::key()));\n\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n\n  EXPECT_EQ(1, proxy_proto_data.tlv_vector_.size());\n  EXPECT_EQ(0x02, proxy_proto_data.tlv_vector_[0].type);\n  EXPECT_EQ(\"foo.com\", std::string(proxy_proto_data.tlv_vector_[0].value.begin(),\n                                   proxy_proto_data.tlv_vector_[0].value.end()));\n  disconnect();\n}\n\nTEST_P(ProxyProtocolTest, MalformedProxyLine) {\n  connect(false);\n\n  write(\"BOGUS\\r\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  write(\"\\n\");\n\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, ProxyLineTooLarge) {\n  connect(false);\n  write(\"012345678901234567890123456789012345678901234567890123456789\"\n        \"012345678901234567890123456789012345678901234567890123456789\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NotEnoughFields) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, UnsupportedProto) {\n  connect(false);\n  write(\"PROXY UDP6 1:2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidSrcAddress) {\n  connect(false);\n  write(\"PROXY TCP4 230.0.0.1 10.1.1.3 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, InvalidDstAddress) {\n  connect(false);\n  write(\"PROXY TCP4 10.1.1.2 0.0.0.0 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadPort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 1234 abc\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, NegativePort) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 -1 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, PortOutOfRange) {\n  connect(false);\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 66776 1234\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, BadAddress) {\n  connect(false);\n  write(\"PROXY TCP6 1::2:3::4 5:6::7:8 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch) {\n  connect(false);\n  write(\"PROXY TCP4 [1:2:3::4] 1.2.3.4 1234 5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, AddressVersionsNotMatch2) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 [1:2:3: 1234 4]:5678\\r\\nmore data\");\n  expectProxyProtoError();\n}\n\nTEST_P(ProxyProtocolTest, Truncated) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 5.6.7.8 1234 5678\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, Closed) {\n  connect(false);\n  write(\"PROXY TCP4 1.2.3\");\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n\n  EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose))\n      .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}\n\nTEST_P(ProxyProtocolTest, ClosedEmpty) {\n  // We may or may not get these, depending on the operating system timing.\n  EXPECT_CALL(factory_, createListenerFilterChain(_)).Times(AtLeast(0));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).Times(AtLeast(0));\n  conn_->connect();\n  conn_->close(Network::ConnectionCloseType::NoFlush);\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n}\n\n// There is no chance to have error for Windows since it emulate the drain\n// from a memory buffer.\n#ifndef WIN32\nTEST_P(ProxyProtocolTest, DrainError) {\n  Api::MockOsSysCalls os_sys_calls;\n  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls(&os_sys_calls);\n\n  EXPECT_CALL(os_sys_calls, recv(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([&](os_fd_t fd, void* buf, size_t n, int flags) {\n        if (flags != MSG_PEEK) {\n          return Api::SysCallSizeResult{-1, 0};\n        } else {\n          const Api::SysCallSizeResult x = os_sys_calls_actual_.recv(fd, buf, n, flags);\n          return x;\n        }\n      }));\n  EXPECT_CALL(os_sys_calls, readv(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.readv(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, connect(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, const sockaddr* addr, socklen_t addrlen) {\n        return os_sys_calls_actual_.connect(sockfd, addr, addrlen);\n      }));\n  EXPECT_CALL(os_sys_calls, writev(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t fd, const iovec* iov, int iovcnt) {\n        return os_sys_calls_actual_.writev(fd, iov, iovcnt);\n      }));\n  EXPECT_CALL(os_sys_calls, send(_, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t socket, void* buffer, size_t length, int flags) {\n        return os_sys_calls_actual_.send(socket, buffer, length, flags);\n      }));\n  EXPECT_CALL(os_sys_calls, getsockopt_(_, _, _, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int level, int optname, void* optval, socklen_t* optlen) -> int {\n            return os_sys_calls_actual_.getsockopt(sockfd, level, optname, optval, optlen)\n                .return_value_;\n          }));\n  EXPECT_CALL(os_sys_calls, getsockname(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* name, socklen_t* namelen) -> Api::SysCallIntResult {\n            return os_sys_calls_actual_.getsockname(sockfd, name, namelen);\n          }));\n  EXPECT_CALL(os_sys_calls, shutdown(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, int how) { return os_sys_calls_actual_.shutdown(sockfd, how); }));\n  EXPECT_CALL(os_sys_calls, close(_)).Times(AnyNumber()).WillRepeatedly(Invoke([this](os_fd_t fd) {\n    return os_sys_calls_actual_.close(fd);\n  }));\n  EXPECT_CALL(os_sys_calls, accept(_, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke(\n          [this](os_fd_t sockfd, sockaddr* addr, socklen_t* addrlen) -> Api::SysCallSocketResult {\n            return os_sys_calls_actual_.accept(sockfd, addr, addrlen);\n          }));\n  EXPECT_CALL(os_sys_calls, supportsGetifaddrs())\n      .Times(AnyNumber())\n      .WillRepeatedly(\n          Invoke([this]() -> bool { return os_sys_calls_actual_.supportsGetifaddrs(); }));\n  EXPECT_CALL(os_sys_calls, getifaddrs(_))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](Api::InterfaceAddressVector& vector) -> Api::SysCallIntResult {\n        return os_sys_calls_actual_.getifaddrs(vector);\n      }));\n  EXPECT_CALL(os_sys_calls, socketTcpInfo(_, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, Api::EnvoyTcpInfo* tcp_info) {\n        return os_sys_calls_actual_.socketTcpInfo(sockfd, tcp_info);\n      }));\n  EXPECT_CALL(os_sys_calls, setsockopt_(_, SOL_SOCKET, SO_LINGER, _, _))\n      .Times(AnyNumber())\n      .WillRepeatedly(Invoke([this](os_fd_t sockfd, int level, int optname, const void* optval,\n                                    socklen_t optlen) -> int {\n        return os_sys_calls_actual_.setsockopt(sockfd, level, optname, optval, optlen)\n            .return_value_;\n      }));\n\n  connect(false);\n  write(\"PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\\r\\nmore data\");\n\n  expectProxyProtoError();\n}\n#endif\n\nclass WildcardProxyProtocolTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                  public Network::ListenerConfig,\n                                  public Network::FilterChainManager,\n                                  protected Logger::Loggable<Logger::Id::main> {\npublic:\n  WildcardProxyProtocolTest()\n      : api_(Api::createApiForTest(stats_store_)),\n        dispatcher_(api_->allocateDispatcher(\"test_thread\")),\n        socket_(std::make_shared<Network::Test::TcpListenSocketImmediateListen>(\n            Network::Test::getAnyAddress(GetParam()))),\n        local_dst_address_(Network::Utility::getAddressWithPort(\n            *Network::Test::getCanonicalLoopbackAddress(GetParam()),\n            socket_->connectionInfoProvider().localAddress()->ip()->port())),\n        connection_handler_(new Server::ConnectionHandlerImpl(*dispatcher_, absl::nullopt)),\n        name_(\"proxy\"), filter_chain_(Network::Test::createEmptyFilterChainWithRawBufferSockets()),\n        init_manager_(nullptr),\n        listener_info_(std::make_shared<NiceMock<Network::MockListenerInfo>>()) {\n    socket_factories_.emplace_back(std::make_unique<Network::MockListenSocketFactory>());\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                socketType())\n        .WillOnce(Return(Network::Socket::Type::Stream));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                localAddress())\n        .WillRepeatedly(ReturnRef(socket_->connectionInfoProvider().localAddress()));\n    EXPECT_CALL(*static_cast<Network::MockListenSocketFactory*>(socket_factories_[0].get()),\n                getListenSocket(_))\n        .WillOnce(Return(socket_));\n    connection_handler_->addListener(absl::nullopt, *this, runtime_, random_);\n    conn_ = dispatcher_->createClientConnection(\n        local_dst_address_, Network::Address::InstanceConstSharedPtr(),\n        Network::Test::createRawBufferSocket(), nullptr, nullptr);\n    conn_->addConnectionCallbacks(connection_callbacks_);\n\n    EXPECT_CALL(factory_, createListenerFilterChain(_))\n        .WillOnce(Invoke([&](Network::ListenerFilterManager& filter_manager) -> bool {\n          filter_manager.addAcceptFilter(\n              nullptr,\n              std::make_unique<Filter>(std::make_shared<Config>(\n                  listenerScope(),\n                  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol())));\n          return true;\n        }));\n  }\n\n  // Network::ListenerConfig\n  Network::FilterChainManager& filterChainManager() override { return *this; }\n  Network::FilterChainFactory& filterChainFactory() override { return factory_; }\n  std::vector<Network::ListenSocketFactoryPtr>& listenSocketFactories() override {\n    return socket_factories_;\n  }\n  bool bindToPort() const override { return true; }\n  bool handOffRestoredDestinationConnections() const override { return false; }\n  uint32_t perConnectionBufferLimitBytes() const override { return 0; }\n  std::chrono::milliseconds listenerFiltersTimeout() const override { return {}; }\n  ResourceLimit& openConnections() override { return open_connections_; }\n  bool continueOnListenerFiltersTimeout() const override { return false; }\n  Stats::Scope& listenerScope() override { return *stats_store_.rootScope(); }\n  uint64_t listenerTag() const override { return 1; }\n  const std::string& name() const override { return name_; }\n  Network::UdpListenerConfigOptRef udpListenerConfig() override { return {}; }\n  Network::InternalListenerConfigOptRef internalListenerConfig() override { return {}; }\n  const Network::ListenerInfoConstSharedPtr& listenerInfo() const override {\n    return listener_info_;\n  }\n  Network::ConnectionBalancer& connectionBalancer(const Network::Address::Instance&) override {\n    return connection_balancer_;\n  }\n  const std::vector<AccessLog::InstanceSharedPtr>& accessLogs() const override {\n    return empty_access_logs_;\n  }\n  uint32_t tcpBacklogSize() const override { return ENVOY_TCP_BACKLOG_SIZE; }\n  uint32_t maxConnectionsToAcceptPerSocketEvent() const override {\n    return Network::DefaultMaxConnectionsToAcceptPerSocketEvent;\n  }\n  Init::Manager& initManager() override { return *init_manager_; }\n  bool ignoreGlobalConnLimit() const override { return false; }\n\n  // Network::FilterChainManager\n  const Network::FilterChain* findFilterChain(const Network::ConnectionSocket&,\n                                              const StreamInfo::StreamInfo&) const override {\n    return filter_chain_.get();\n  }\n\n  void connect() {\n    conn_->connect();\n    read_filter_ = std::make_shared<NiceMock<Network::MockReadFilter>>();\n    EXPECT_CALL(factory_, createNetworkFilterChain(_, _))\n        .WillOnce(Invoke([&](Network::Connection& connection,\n                             const Envoy::Filter::NetworkFilterFactoriesList&) -> bool {\n          server_connection_ = &connection;\n          connection.addConnectionCallbacks(server_callbacks_);\n          connection.addReadFilter(read_filter_);\n          return true;\n        }));\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::Connected))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void write(const std::string& s) {\n    Buffer::OwnedImpl buf(s);\n    conn_->write(buf, false);\n  }\n\n  void expectData(std::string expected) {\n    EXPECT_CALL(*read_filter_, onNewConnection());\n    EXPECT_CALL(*read_filter_, onData(_, _))\n        .WillOnce(Invoke([&](Buffer::Instance& buffer, bool) -> Network::FilterStatus {\n          EXPECT_EQ(buffer.toString(), expected);\n          buffer.drain(expected.length());\n          dispatcher_->exit();\n          return Network::FilterStatus::Continue;\n        }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  void disconnect() {\n    EXPECT_CALL(connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));\n    conn_->close(Network::ConnectionCloseType::NoFlush);\n    EXPECT_CALL(server_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose))\n        .WillOnce(Invoke([&](Network::ConnectionEvent) -> void { dispatcher_->exit(); }));\n\n    dispatcher_->run(Event::Dispatcher::RunType::Block);\n  }\n\n  testing::NiceMock<Runtime::MockLoader> runtime_;\n  testing::NiceMock<Random::MockRandomGenerator> random_;\n  Stats::IsolatedStoreImpl stats_store_;\n  Api::ApiPtr api_;\n  Event::DispatcherPtr dispatcher_;\n  BasicResourceLimitImpl open_connections_;\n  std::vector<Network::ListenSocketFactoryPtr> socket_factories_;\n  std::shared_ptr<Network::TcpListenSocket> socket_;\n  Network::Address::InstanceConstSharedPtr local_dst_address_;\n  Network::NopConnectionBalancerImpl connection_balancer_;\n  Network::ConnectionHandlerPtr connection_handler_;\n  Network::MockFilterChainFactory factory_;\n  Network::ClientConnectionPtr conn_;\n  NiceMock<Network::MockConnectionCallbacks> connection_callbacks_;\n  Network::Connection* server_connection_;\n  Network::MockConnectionCallbacks server_callbacks_;\n  std::shared_ptr<Network::MockReadFilter> read_filter_;\n  std::string name_;\n  const Network::FilterChainSharedPtr filter_chain_;\n  const std::vector<AccessLog::InstanceSharedPtr> empty_access_logs_;\n  std::unique_ptr<Init::Manager> init_manager_;\n  const Network::ListenerInfoConstSharedPtr listener_info_;\n};\n\n// Parameterize the listener socket address version.\nINSTANTIATE_TEST_SUITE_P(IpVersions, WildcardProxyProtocolTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\nTEST_P(WildcardProxyProtocolTest, Basic) {\n  connect();\n  write(\"PROXY TCP4 1.2.3.4 254.254.254.254 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"1.2.3.4:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"254.254.254.254:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST_P(WildcardProxyProtocolTest, BasicV6) {\n  connect();\n  write(\"PROXY TCP6 1:2:3::4 5:6::7:8 65535 1234\\r\\nmore data\");\n\n  expectData(\"more data\");\n\n  EXPECT_EQ(server_connection_->connectionInfoProvider().remoteAddress()->asString(),\n            \"[1:2:3::4]:65535\");\n  EXPECT_EQ(server_connection_->connectionInfoProvider().localAddress()->asString(),\n            \"[5:6::7:8]:1234\");\n  EXPECT_TRUE(server_connection_->connectionInfoProvider().localAddressRestored());\n\n  disconnect();\n}\n\nTEST(ProxyProtocolConfigFactoryTest, TestCreateFactory) {\n  Server::Configuration::NamedListenerFilterConfigFactory* factory = Registry::FactoryRegistry<\n      Server::Configuration::NamedListenerFilterConfigFactory>::getFactory(ProxyProtocol);\n\n  EXPECT_EQ(factory->name(), ProxyProtocol);\n\n  const std::string yaml = R\"EOF(\n      rules:\n        - tlv_type: 0x01\n          on_tlv_present:\n            key: \"PP2_TYPE_ALPN\"\n        - tlv_type: 0x1a\n          on_tlv_present:\n            key: \"PP2_TYPE_CUSTOMER_A\"\n)EOF\";\n\n  ProtobufTypes::MessagePtr proto_config = factory->createEmptyConfigProto();\n  TestUtility::loadFromYaml(yaml, *proto_config);\n\n  Server::Configuration::MockListenerFactoryContext context;\n  EXPECT_CALL(context, scope());\n  EXPECT_CALL(context, messageValidationVisitor());\n  Network::ListenerFilterFactoryCb cb =\n      factory->createListenerFilterFactoryFromProto(*proto_config, nullptr, context);\n\n  Network::MockListenerFilterManager manager;\n  Network::ListenerFilterPtr added_filter;\n  EXPECT_CALL(manager, addAcceptFilter_(_, _))\n      .WillOnce(Invoke([&added_filter](const Network::ListenerFilterMatcherSharedPtr&,\n                                       Network::ListenerFilterPtr& filter) {\n        added_filter = std::move(filter);\n      }));\n  cb(manager);\n\n  // Make sure we actually create the correct type!\n  EXPECT_NE(dynamic_cast<ProxyProtocol::Filter*>(added_filter.get()), nullptr);\n}\n\n} // namespace\n} // namespace ProxyProtocol\n} // namespace ListenerFilters\n} // namespace Extensions\n} // namespace Envoy\n", "#include \"envoy/config/core/v3/base.pb.h\"\n#include \"envoy/config/core/v3/health_check.pb.h\"\n#include \"envoy/config/core/v3/proxy_protocol.pb.h\"\n#include \"envoy/extensions/filters/listener/proxy_protocol/v3/proxy_protocol.pb.h\"\n#include \"envoy/extensions/transport_sockets/proxy_protocol/v3/upstream_proxy_protocol.pb.h\"\n#include \"envoy/extensions/transport_sockets/raw_buffer/v3/raw_buffer.pb.h\"\n#include \"envoy/extensions/transport_sockets/raw_buffer/v3/raw_buffer.pb.validate.h\"\n\n#include \"test/integration/http_integration.h\"\n#include \"test/integration/integration.h\"\n\nusing envoy::config::core::v3::ProxyProtocolPassThroughTLVs;\nnamespace Envoy {\nnamespace {\n\nclass ProxyProtocolTcpIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                        public BaseIntegrationTest {\npublic:\n  ProxyProtocolTcpIntegrationTest()\n      : BaseIntegrationTest(GetParam(), ConfigHelper::tcpProxyConfig()) {}\n\n  void TearDown() override {\n    test_server_.reset();\n    fake_upstream_connection_.reset();\n    fake_upstreams_.clear();\n  }\n\n  void setup(envoy::config::core::v3::ProxyProtocolConfig_Version version, bool health_checks,\n             bool inner_tls) {\n    version_ = version;\n    health_checks_ = health_checks;\n    inner_tls_ = inner_tls;\n  }\n\n  void initialize() override {\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* transport_socket =\n          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n      transport_socket->set_name(\"envoy.transport_sockets.upstream_proxy_protocol\");\n      envoy::config::core::v3::TransportSocket inner_socket;\n      if (inner_tls_) {\n        envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext tls;\n        inner_socket.set_name(\"tls\");\n        inner_socket.mutable_typed_config()->PackFrom(tls);\n      } else {\n        envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;\n        inner_socket.set_name(\"raw\");\n        inner_socket.mutable_typed_config()->PackFrom(raw_buffer);\n      }\n      envoy::config::core::v3::ProxyProtocolConfig proxy_proto_config;\n      proxy_proto_config.set_version(version_);\n      envoy::extensions::transport_sockets::proxy_protocol::v3::ProxyProtocolUpstreamTransport\n          proxy_proto_transport;\n      proxy_proto_transport.mutable_transport_socket()->MergeFrom(inner_socket);\n      proxy_proto_transport.mutable_config()->MergeFrom(proxy_proto_config);\n      transport_socket->mutable_typed_config()->PackFrom(proxy_proto_transport);\n\n      if (health_checks_) {\n        auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n        cluster->set_close_connections_on_host_health_failure(false);\n        cluster->mutable_common_lb_config()->mutable_healthy_panic_threshold()->set_value(0);\n        cluster->add_health_checks()->mutable_timeout()->set_seconds(20);\n        cluster->mutable_health_checks(0)->mutable_reuse_connection()->set_value(true);\n        cluster->mutable_health_checks(0)->mutable_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_no_traffic_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_unhealthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_healthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_tcp_health_check();\n        cluster->mutable_health_checks(0)->mutable_tcp_health_check()->mutable_send()->set_text(\n            \"50696E67\");\n        cluster->mutable_health_checks(0)->mutable_tcp_health_check()->add_receive()->set_text(\n            \"506F6E67\");\n      }\n    });\n    BaseIntegrationTest::initialize();\n  }\n\n  FakeRawConnectionPtr fake_upstream_connection_;\n\nprivate:\n  envoy::config::core::v3::ProxyProtocolConfig_Version version_;\n  bool health_checks_;\n  bool inner_tls_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTcpIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Test sending proxy protocol v1\nTEST_P(ProxyProtocolTcpIntegrationTest, TestV1ProxyProtocol) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false, false);\n  initialize();\n\n  auto listener_port = lookupPort(\"listener_0\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n  std::string observed_data;\n  ASSERT_TRUE(tcp_client->write(\"data\"));\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(48, &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n  } else if (GetParam() == Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(36, &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n  }\n  EXPECT_THAT(observed_data, testing::EndsWith(absl::StrCat(\" \", listener_port, \"\\r\\ndata\")));\n\n  auto previous_data = observed_data;\n  observed_data.clear();\n  ASSERT_TRUE(tcp_client->write(\" more data\"));\n  ASSERT_TRUE(fake_upstream_connection_->waitForData(previous_data.length() + 10, &observed_data));\n  EXPECT_EQ(previous_data + \" more data\", observed_data);\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nTEST_P(ProxyProtocolTcpIntegrationTest, TestV1ProxyProtocolMultipleConnections) {\n  if (GetParam() != Network::Address::IpVersion::v4) {\n    return;\n  }\n\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false, false);\n  initialize();\n  auto listener_port = lookupPort(\"listener_0\");\n\n  auto loopback2 = Network::Utility::resolveUrl(\"tcp://127.0.0.2:0\");\n  auto tcp_client2 = makeTcpConnection(listener_port, nullptr, loopback2);\n\n  auto tcp_client = makeTcpConnection(listener_port);\n\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n  FakeRawConnectionPtr conn2;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(conn2));\n\n  std::string data1, data2;\n  ASSERT_TRUE(\n      fake_upstream_connection_->waitForData(FakeRawConnection::waitForAtLeastBytes(32), &data1));\n  ASSERT_TRUE(conn2->waitForData(FakeRawConnection::waitForAtLeastBytes(32), &data2));\n\n  EXPECT_NE(data1, data2);\n\n  tcp_client->close();\n  tcp_client2->close();\n}\n\n// Test header is sent unencrypted using a TLS inner socket\nTEST_P(ProxyProtocolTcpIntegrationTest, TestTLSSocket) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false, true);\n  initialize();\n\n  auto listener_port = lookupPort(\"listener_0\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n  ASSERT_TRUE(tcp_client->write(\"data\"));\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(\n        fake_upstream_connection_->waitForInexactMatch(\"PROXY TCP4 127.0.0.1 127.0.0.1 \")));\n  } else if (GetParam() == Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(\n        fake_upstream_connection_->waitForInexactMatch(\"PROXY TCP6 ::1 ::1 \")));\n  }\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->close());\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\n// Test sending proxy protocol health check\nTEST_P(ProxyProtocolTcpIntegrationTest, TestProxyProtocolHealthCheck) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, true, false);\n  FakeRawConnectionPtr fake_upstream_health_connection;\n  on_server_init_function_ = [&](void) -> void {\n    std::string observed_data;\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_health_connection));\n    if (GetParam() == Network::Address::IpVersion::v4) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(48, &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n    } else if (GetParam() == Network::Address::IpVersion::v6) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(36, &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n    }\n    ASSERT_TRUE(fake_upstream_health_connection->write(\"Pong\"));\n  };\n\n  initialize();\n\n  ASSERT_TRUE(fake_upstream_health_connection->close());\n  ASSERT_TRUE(fake_upstream_health_connection->waitForDisconnect());\n}\n\n// Test sending proxy protocol v2\nTEST_P(ProxyProtocolTcpIntegrationTest, TestV2ProxyProtocol) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V2, false, false);\n  initialize();\n\n  auto listener_port = lookupPort(\"listener_0\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n  std::string observed_data;\n  ASSERT_TRUE(tcp_client->write(\"data\"));\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(32, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address, dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x0c, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[26]), listener_port >> 8);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[27]), listener_port & 0xFF);\n  } else if (GetParam() == Envoy::Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(56, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address\n    // - dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[50]), listener_port >> 8);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[51]), listener_port & 0xFF);\n  }\n  EXPECT_THAT(observed_data, testing::EndsWith(\"data\"));\n\n  auto previous_data = observed_data;\n  observed_data.clear();\n  ASSERT_TRUE(tcp_client->write(\" more data\"));\n  ASSERT_TRUE(fake_upstream_connection_->waitForData(previous_data.length() + 10, &observed_data));\n  EXPECT_EQ(previous_data + \" more data\", observed_data);\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nclass ProxyProtocolHttpIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                         public HttpIntegrationTest {\npublic:\n  ProxyProtocolHttpIntegrationTest()\n      : HttpIntegrationTest(Http::CodecClient::Type::HTTP1, GetParam()) {}\n\n  void TearDown() override {\n    test_server_.reset();\n    fake_upstream_connection_.reset();\n    fake_upstreams_.clear();\n  }\n\n  void setup(envoy::config::core::v3::ProxyProtocolConfig_Version version, bool health_checks) {\n    version_ = version;\n    health_checks_ = health_checks;\n  }\n\n  void initialize() override {\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* transport_socket =\n          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n      transport_socket->set_name(\"envoy.transport_sockets.upstream_proxy_protocol\");\n      envoy::config::core::v3::TransportSocket inner_socket;\n      envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;\n      inner_socket.set_name(\"raw\");\n      inner_socket.mutable_typed_config()->PackFrom(raw_buffer);\n      envoy::config::core::v3::ProxyProtocolConfig proxy_proto_config;\n      proxy_proto_config.set_version(version_);\n      envoy::extensions::transport_sockets::proxy_protocol::v3::ProxyProtocolUpstreamTransport\n          proxy_proto_transport;\n      proxy_proto_transport.mutable_transport_socket()->MergeFrom(inner_socket);\n      proxy_proto_transport.mutable_config()->MergeFrom(proxy_proto_config);\n      transport_socket->mutable_typed_config()->PackFrom(proxy_proto_transport);\n\n      if (health_checks_) {\n        auto* cluster = bootstrap.mutable_static_resources()->mutable_clusters(0);\n        cluster->set_close_connections_on_host_health_failure(false);\n        cluster->mutable_common_lb_config()->mutable_healthy_panic_threshold()->set_value(0);\n        cluster->add_health_checks()->mutable_timeout()->set_seconds(20);\n        cluster->mutable_health_checks(0)->mutable_reuse_connection()->set_value(true);\n        cluster->mutable_health_checks(0)->mutable_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_no_traffic_interval()->set_seconds(1);\n        cluster->mutable_health_checks(0)->mutable_unhealthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_healthy_threshold()->set_value(1);\n        cluster->mutable_health_checks(0)->mutable_http_health_check()->set_codec_client_type(\n            envoy::type::v3::HTTP1);\n        cluster->mutable_health_checks(0)->mutable_http_health_check()->set_path(\"/healthcheck\");\n      }\n    });\n    BaseIntegrationTest::initialize();\n  }\n\nprivate:\n  envoy::config::core::v3::ProxyProtocolConfig_Version version_;\n  bool health_checks_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolHttpIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// Test sending proxy protocol over http\nTEST_P(ProxyProtocolHttpIntegrationTest, TestV1ProxyProtocol) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false);\n  initialize();\n\n  auto tcp_client = makeTcpConnection(lookupPort(\"http\"));\n  auto request = \"GET / HTTP/1.1\\r\\nhost: host\\r\\n\\r\\n\";\n  ASSERT_TRUE(tcp_client->write(request, false));\n  FakeRawConnectionPtr fake_upstream_raw_connection_;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_raw_connection_));\n\n  std::string observed_data;\n  if (GetParam() == Network::Address::IpVersion::v4) {\n    ASSERT_TRUE(fake_upstream_raw_connection_->waitForData(\n        FakeRawConnection::waitForAtLeastBytes(70), &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n  } else if (GetParam() == Network::Address::IpVersion::v6) {\n    ASSERT_TRUE(fake_upstream_raw_connection_->waitForData(\n        FakeRawConnection::waitForAtLeastBytes(58), &observed_data));\n    EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n  }\n  EXPECT_TRUE(absl::StrContains(observed_data, \"GET / HTTP/1.1\"));\n  EXPECT_TRUE(absl::StrContains(observed_data, \"host: host\"));\n\n  auto response = \"HTTP/1.1 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\";\n  ASSERT_TRUE(fake_upstream_raw_connection_->write(response, false));\n  tcp_client->waitForData(\"HTTP/1.1 200 OK\\r\\ncontent-length: 0\", true);\n\n  std::string delimiter = \"\\r\\n\";\n  std::string after_proxy_proto_header = observed_data.substr(\n      observed_data.find(delimiter) + delimiter.length(), observed_data.length());\n\n  auto previous_data = observed_data;\n  observed_data.clear();\n  ASSERT_TRUE(tcp_client->write(request, false));\n  ASSERT_TRUE(fake_upstream_raw_connection_->waitForData(\n      previous_data.length() + after_proxy_proto_header.length(), &observed_data));\n  ASSERT_TRUE(observed_data.length() == previous_data.length() + after_proxy_proto_header.length());\n  tcp_client->close();\n}\n\n// Test sending proxy protocol over multiple http connections\nTEST_P(ProxyProtocolHttpIntegrationTest, TestV1ProxyProtocolMultipleConnections) {\n  if (GetParam() != Network::Address::IpVersion::v4) {\n    return;\n  }\n\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, false);\n  initialize();\n  auto listener_port = lookupPort(\"http\");\n  auto tcp_client = makeTcpConnection(listener_port);\n  auto loopback2 = Network::Utility::resolveUrl(\"tcp://127.0.0.2:0\");\n  auto tcp_client2 = makeTcpConnection(listener_port, nullptr, loopback2);\n\n  auto request = \"GET / HTTP/1.1\\r\\nhost: host\\r\\n\\r\\n\";\n  ASSERT_TRUE(tcp_client->write(request, false));\n  ASSERT_TRUE(tcp_client2->write(request, false));\n\n  FakeRawConnectionPtr conn1, conn2;\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(conn1));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(conn2));\n  std::string data1, data2;\n  ASSERT_TRUE(conn1->waitForData(FakeRawConnection::waitForAtLeastBytes(48), &data1));\n  ASSERT_TRUE(conn2->waitForData(FakeRawConnection::waitForAtLeastBytes(48), &data2));\n\n  std::string delimiter = \"\\r\\n\";\n  std::string conn1_header = data1.substr(0, data1.find(delimiter));\n  std::string conn2_header = data2.substr(0, data2.find(delimiter));\n\n  EXPECT_NE(conn1_header, conn2_header);\n\n  tcp_client->close();\n  tcp_client2->close();\n}\n\n// Test sending proxy protocol http health check\nTEST_P(ProxyProtocolHttpIntegrationTest, TestProxyProtocolHealthCheck) {\n  setup(envoy::config::core::v3::ProxyProtocolConfig::V1, true);\n  FakeRawConnectionPtr fake_upstream_health_connection;\n  on_server_init_function_ = [&](void) -> void {\n    std::string observed_data;\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_health_connection));\n    if (GetParam() == Network::Address::IpVersion::v4) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(\n          FakeRawConnection::waitForAtLeastBytes(48), &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP4 127.0.0.1 127.0.0.1 \"));\n    } else if (GetParam() == Network::Address::IpVersion::v6) {\n      ASSERT_TRUE(fake_upstream_health_connection->waitForData(\n          FakeRawConnection::waitForAtLeastBytes(36), &observed_data));\n      EXPECT_THAT(observed_data, testing::StartsWith(\"PROXY TCP6 ::1 ::1 \"));\n    }\n    auto response = \"HTTP/1.1 200 OK\\r\\ncontent-length: 0\\r\\n\\r\\n\";\n    ASSERT_TRUE(fake_upstream_health_connection->write(response));\n  };\n\n  initialize();\n\n  ASSERT_TRUE(fake_upstream_health_connection->close());\n  ASSERT_TRUE(fake_upstream_health_connection->waitForDisconnect());\n}\n\nclass ProxyProtocolTLVsIntegrationTest : public testing::TestWithParam<Network::Address::IpVersion>,\n                                         public BaseIntegrationTest {\npublic:\n  ProxyProtocolTLVsIntegrationTest()\n      : BaseIntegrationTest(GetParam(), ConfigHelper::tcpProxyConfig()){};\n\n  void TearDown() override {\n    test_server_.reset();\n    fake_upstream_connection_.reset();\n    fake_upstreams_.clear();\n  }\n\n  void setup(bool pass_all_tlvs, const std::vector<uint8_t>& tlvs_listener,\n             const std::vector<uint8_t>& tlvs_upstream) {\n    pass_all_tlvs_ = pass_all_tlvs;\n    tlvs_listener_.assign(tlvs_listener.begin(), tlvs_listener.end());\n    tlvs_upstream_.assign(tlvs_upstream.begin(), tlvs_upstream.end());\n  }\n\n  void initialize() override {\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proxy_protocol;\n      auto pass_through_tlvs = proxy_protocol.mutable_pass_through_tlvs();\n      if (pass_all_tlvs_) {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n      } else {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n        for (const auto& tlv_type : tlvs_listener_) {\n          pass_through_tlvs->add_tlv_type(tlv_type);\n        }\n      }\n\n      auto* listener = bootstrap.mutable_static_resources()->mutable_listeners(0);\n      auto* ppv_filter = listener->add_listener_filters();\n      ppv_filter->set_name(\"envoy.listener.proxy_protocol\");\n      ppv_filter->mutable_typed_config()->PackFrom(proxy_protocol);\n    });\n\n    config_helper_.addConfigModifier([this](envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n      auto* transport_socket =\n          bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n      transport_socket->set_name(\"envoy.transport_sockets.upstream_proxy_protocol\");\n      envoy::config::core::v3::TransportSocket inner_socket;\n      envoy::extensions::transport_sockets::raw_buffer::v3::RawBuffer raw_buffer;\n      inner_socket.set_name(\"raw\");\n      inner_socket.mutable_typed_config()->PackFrom(raw_buffer);\n\n      envoy::config::core::v3::ProxyProtocolConfig proxy_protocol;\n      proxy_protocol.set_version(envoy::config::core::v3::ProxyProtocolConfig::V2);\n      auto pass_through_tlvs = proxy_protocol.mutable_pass_through_tlvs();\n\n      if (pass_all_tlvs_) {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE_ALL);\n      } else {\n        pass_through_tlvs->set_match_type(ProxyProtocolPassThroughTLVs::INCLUDE);\n        for (const auto& tlv_type : tlvs_upstream_) {\n          pass_through_tlvs->add_tlv_type(tlv_type);\n        }\n      }\n\n      envoy::extensions::transport_sockets::proxy_protocol::v3::ProxyProtocolUpstreamTransport\n          proxy_proto_transport;\n      proxy_proto_transport.mutable_transport_socket()->MergeFrom(inner_socket);\n      proxy_proto_transport.mutable_config()->MergeFrom(proxy_protocol);\n      transport_socket->mutable_typed_config()->PackFrom(proxy_proto_transport);\n    });\n\n    BaseIntegrationTest::initialize();\n  }\n\n  FakeRawConnectionPtr fake_upstream_connection_;\n\nprivate:\n  bool pass_all_tlvs_ = false;\n  std::vector<uint8_t> tlvs_listener_;\n  std::vector<uint8_t> tlvs_upstream_;\n};\n\nINSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTLVsIntegrationTest,\n                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),\n                         TestUtility::ipTestParamsToString);\n\n// This test adding the listener proxy protocol filter and upstream proxy filter, the TLVs\n// are passed by listener and re-generated in transport socket based on API config.\nTEST_P(ProxyProtocolTLVsIntegrationTest, TestV2TLVProxyProtocolPassSepcificTLVs) {\n  setup(false, {0x05, 0x06}, {0x06});\n  initialize();\n\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n  std::string observed_data;\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x11, 0x12\n    const uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                   0x54, 0x0a, 0x21, 0x11, 0x00, 0x16, 0x7f, 0x00, 0x00, 0x01,\n                                   0x7f, 0x00, 0x00, 0x01, 0x03, 0x05, 0x02, 0x01, 0x05, 0x00,\n                                   0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x11, 0x12};\n    Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(33, &observed_data));\n\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address, dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x11, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x11, 0x12 is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[28]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[29]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[30]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[31]), 0x11);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[32]), 0x12);\n  } else if (GetParam() == Envoy::Network::Address::IpVersion::v6) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x09, 0x0A\n    const uint8_t v2_protocol_ipv6[] = {\n        0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21,\n        0x21, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x02,\n        0x05, 0x00, 0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x09, 0x0A};\n    Buffer::OwnedImpl buffer(v2_protocol_ipv6, sizeof(v2_protocol_ipv6));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(57, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address\n    // - dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x09, 0x0A is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[52]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[53]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[54]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[55]), 0x09);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[56]), 0x0A);\n  }\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nTEST_P(ProxyProtocolTLVsIntegrationTest, TestV2TLVProxyProtocolPassAll) {\n  setup(true, {}, {});\n  initialize();\n\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n\n  std::string observed_data;\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x11, 0x12\n    const uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                   0x54, 0x0a, 0x21, 0x11, 0x00, 0x16, 0x7f, 0x00, 0x00, 0x01,\n                                   0x7f, 0x00, 0x00, 0x01, 0x03, 0x05, 0x02, 0x01, 0x05, 0x00,\n                                   0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x11, 0x12};\n    Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(38, &observed_data));\n\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address, dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x16, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x11, 0x12 is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[28]), 0x05);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[29]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[30]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[31]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[32]), 0x07);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[33]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[34]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[35]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[36]), 0x11);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[37]), 0x12);\n  } else if (GetParam() == Envoy::Network::Address::IpVersion::v6) {\n    // 2 TLVs are included:\n    // 0x05, 0x00, 0x02, 0x06, 0x07\n    // 0x06, 0x00, 0x02, 0x09, 0x0A\n    const uint8_t v2_protocol_ipv6[] = {\n        0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a, 0x21,\n        0x21, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x02,\n        0x05, 0x00, 0x02, 0x06, 0x07, 0x06, 0x00, 0x02, 0x09, 0x0A};\n    Buffer::OwnedImpl buffer(v2_protocol_ipv6, sizeof(v2_protocol_ipv6));\n    ASSERT_TRUE(tcp_client->write(buffer.toString()));\n    ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n\n    ASSERT_TRUE(fake_upstream_connection_->waitForData(62, &observed_data));\n    // - signature\n    // - version and command type, address family and protocol, length of addresses\n    // - src address\n    // - dest address\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    absl::string_view header_start(data, sizeof(data));\n    EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n\n    // Only tlv: 0x06, 0x00, 0x02, 0x09, 0x0A is sent to upstream.\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[52]), 0x05);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[53]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[54]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[55]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[56]), 0x07);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[57]), 0x06);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[58]), 0x00);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[59]), 0x02);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[60]), 0x09);\n    EXPECT_EQ(static_cast<uint8_t>(observed_data[61]), 0x0A);\n  }\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\nTEST_P(ProxyProtocolTLVsIntegrationTest, TestV2ProxyProtocolPassWithTypeLocal) {\n  setup(true, {}, {});\n  initialize();\n\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"listener_0\"));\n\n  // A well-formed proxy protocol v2 header sampled from an AWS NLB healthcheck request, with\n  // command type 'LOCAL' (0 for the low 4 bits of the 13th octet).\n  constexpr uint8_t v2_protocol[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51,\n                                     0x55, 0x49, 0x54, 0x0a, 0x20, 0x00, 0x00, 0x00,\n                                     'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  Buffer::OwnedImpl buffer(v2_protocol, sizeof(v2_protocol));\n  ASSERT_TRUE(tcp_client->write(buffer.toString()));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForRawConnection(fake_upstream_connection_));\n  std::string header_start;\n  // - signature\n  // - version and command type, address family and protocol, length of addresses\n  // - src address, dest address\n  if (GetParam() == Envoy::Network::Address::IpVersion::v4) {\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x11, 0x00, 0x0c, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x00, 0x00, 0x01};\n    header_start = std::string(data, sizeof(data));\n  } else {\n    const char data[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54, 0x0a,\n                         0x21, 0x21, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};\n    header_start = std::string(data, sizeof(data));\n  }\n\n  constexpr absl::string_view more_data(\"moredata\");\n  const size_t offset = header_start.length() + (2 * sizeof(uint16_t)); // Skip over the ports\n  std::string observed_data;\n  ASSERT_TRUE(fake_upstream_connection_->waitForData(offset + more_data.length(), &observed_data));\n  EXPECT_THAT(observed_data, testing::StartsWith(header_start));\n  EXPECT_EQ(more_data, absl::string_view(&observed_data[offset], more_data.length()));\n\n  tcp_client->close();\n  ASSERT_TRUE(fake_upstream_connection_->waitForDisconnect());\n}\n\n} // namespace\n} // namespace Envoy\n", "#!/bin/bash\n\n# directory:coverage_percent\n# for existing directories with low coverage.\ndeclare -a KNOWN_LOW_COVERAGE=(\n\"source/common:95.9\" # TODO(#32149): increase this once io_uring is tested.\n\"source/common/api:84.5\" # flaky due to posix: be careful adjusting\n\"source/common/api/posix:83.8\" # flaky (accept failover non-deterministic): be careful adjusting\n\"source/common/config:95.4\"\n\"source/common/crypto:95.5\"\n\"source/common/event:95.0\" # Emulated edge events guards don't report LCOV\n\"source/common/filesystem/posix:96.2\" # FileReadToEndNotReadable fails in some env; createPath can't test all failure branches.\n\"source/common/http/http2:95.2\"\n\"source/common/io:57.1\" # TODO(#32149): CI has stopped executing this code.\n\"source/common/json:94.6\"\n\"source/common/matcher:94.6\"\n\"source/common/network:94.4\" # Flaky, `activateFileEvents`, `startSecureTransport` and `ioctl`, listener_socket do not always report LCOV\n\"source/common/network/dns_resolver:91.4\"  # A few lines of MacOS code not tested in linux scripts. Tested in MacOS scripts\n\"source/common/quic:93.4\"\n\"source/common/secret:95.1\"\n\"source/common/signal:87.2\" # Death tests don't report LCOV\n\"source/common/thread:0.0\" # Death tests don't report LCOV\n\"source/common/watchdog:58.6\" # Death tests don't report LCOV\n\"source/exe:90.3\"\n\"source/extensions/clusters/common:91.5\" # This can be increased again once `#24903` lands\n\"source/extensions/common:93.0\" #flaky: be careful adjusting\n\"source/extensions/common/proxy_protocol:93.8\" # Adjusted for security patch\n\"source/extensions/common/tap:94.5\"\n\"source/extensions/common/wasm:88.0\" # flaky: be careful adjusting\n\"source/extensions/common/wasm/ext:92.0\"\n\"source/extensions/filters/common/fault:94.5\"\n\"source/extensions/filters/common/rbac:90.5\"\n\"source/extensions/filters/http/cache:94.9\"\n\"source/extensions/filters/http/grpc_json_transcoder:93.8\" # TODO(#28232)\n\"source/extensions/filters/http/ip_tagging:88.0\"\n\"source/extensions/filters/http/kill_request:91.7\" # Death tests don't report LCOV\n\"source/extensions/filters/http/wasm:1.8\"\n\"source/extensions/filters/listener/original_src:92.1\"\n\"source/extensions/filters/network/common:96.4\"\n\"source/extensions/filters/network/mongo_proxy:96.0\"\n\"source/extensions/filters/network/sni_cluster:88.9\"\n\"source/extensions/filters/network/wasm:76.9\"\n\"source/extensions/http/cache/simple_http_cache:95.9\"\n\"source/extensions/rate_limit_descriptors:95.0\"\n\"source/extensions/rate_limit_descriptors/expr:95.0\"\n\"source/extensions/stat_sinks/graphite_statsd:78.6\" # Death tests don't report LCOV\n\"source/extensions/stat_sinks/statsd:80.8\" # Death tests don't report LCOV\n\"source/extensions/tracers:96.1\"\n\"source/extensions/tracers/common:74.8\"\n\"source/extensions/tracers/common/ot:72.9\"\n\"source/extensions/tracers/opencensus:94.0\"\n\"source/extensions/tracers/zipkin:95.8\"\n\"source/extensions/transport_sockets:95.8\"\n\"source/extensions/transport_sockets/tls:95.0\"\n\"source/extensions/transport_sockets/tls/cert_validator:95.2\"\n\"source/extensions/transport_sockets/tls/private_key:88.9\"\n\"source/extensions/wasm_runtime/wamr:0.0\" # Not enabled in coverage build\n\"source/extensions/wasm_runtime/wasmtime:0.0\" # Not enabled in coverage build\n\"source/extensions/wasm_runtime/wavm:0.0\" # Not enabled in coverage build\n\"source/extensions/watchdog:83.3\" # Death tests within extensions\n\"source/extensions/listener_managers:70.5\"\n\"source/extensions/listener_managers/validation_listener_manager:70.5\"\n\"source/extensions/watchdog/profile_action:83.3\"\n\"source/server:91.0\" # flaky: be careful adjusting. See https://github.com/envoyproxy/envoy/issues/15239\n\"source/server/config_validation:89.2\"\n\"source/extensions/health_checkers:96.0\"\n\"source/extensions/health_checkers/http:93.9\"\n\"source/extensions/health_checkers/grpc:92.0\"\n\"source/extensions/config_subscription/rest:94.3\"\n\"source/extensions/matching/input_matchers/cel_matcher:91.3\" #Death tests don't report LCOV\n)\n\n[[ -z \"${SRCDIR}\" ]] && SRCDIR=\"${PWD}\"\nCOVERAGE_DIR=\"${SRCDIR}\"/generated/coverage\nCOVERAGE_DATA=\"${COVERAGE_DIR}/coverage.dat\"\n\nFAILED=0\nDEFAULT_COVERAGE_THRESHOLD=96.6\nDIRECTORY_THRESHOLD=$DEFAULT_COVERAGE_THRESHOLD\n\n# Unfortunately we have a bunch of preexisting directory with low coverage.\n# Set their low bar as their current coverage level.\nget_coverage_target() {\n  DIRECTORY_THRESHOLD=$DEFAULT_COVERAGE_THRESHOLD\n  for FILE_PERCENT in \"${KNOWN_LOW_COVERAGE[@]}\"\n  do\n    if [[ $FILE_PERCENT =~ $1: ]]; then\n      DIRECTORY_THRESHOLD=\"${FILE_PERCENT//*:/}\"\n      return\n    fi\n  done\n}\n\n# Make sure that for each directory with code, coverage doesn't dip\n# below the default coverage threshold.\nSOURCES=$(find source/* -type d)\nwhile read -r DIRECTORY\ndo\n  get_coverage_target \"$DIRECTORY\"\n  COVERAGE_VALUE=$(lcov -e \"$COVERAGE_DATA\"  \"${DIRECTORY}/*\" -o /dev/null | grep line |  cut -d ' ' -f 4)\n  COVERAGE_VALUE=${COVERAGE_VALUE%?}\n  # If the coverage number is 'n' (no data found) there is 0% coverage. This is\n  # probably a directory without source code, so we skip checks.\n  #\n  # We could insist that we validate that 0% coverage directories are in a\n  # documented list, but instead of adding busy-work for folks adding\n  # non-source-containing directories, we trust reviewers to notice if there's\n  # absolutely no tests for a full directory.\n  if [[ $COVERAGE_VALUE =~ \"n\" ]]; then\n    continue;\n  fi;\n  COVERAGE_FAILED=$(echo \"${COVERAGE_VALUE}<${DIRECTORY_THRESHOLD}\" | bc)\n  if [[ \"${COVERAGE_FAILED}\" -eq 1 ]]; then\n    echo \"Code coverage for ${DIRECTORY} is lower than limit of ${DIRECTORY_THRESHOLD} (${COVERAGE_VALUE})\"\n    FAILED=1\n  fi\n  if [[ -n ${VERBOSE} && ${COVERAGE_VALUE} > ${DIRECTORY_THRESHOLD} ]]; then\n    if [[ ${DIRECTORY_THRESHOLD} < $DEFAULT_COVERAGE_THRESHOLD ]]; then\n      echo \"Code coverage for ${DIRECTORY} is now ${COVERAGE_VALUE} (previously ${DIRECTORY_THRESHOLD})\"\n    fi\n  fi\n\ndone <<< \"$SOURCES\"\n\nexit $FAILED\n", "# Word list for check_spelling_pedantic.py -- any entry in ALLCAPS will also be accepted in\n# lower case and title case (e.g. HTTP will accept http and Http). Entries in all lower case\n# will accept title case (e.g. lyft matches Lyft). Prefixes (e.g., un-) or suffixes (e.g. -ing)\n# are allowed for any otherwise correctly spelled word.\nABI\nACK\nACL\nAES\nAllMuxes\nALPN\nALS\nAMZ\nAPC\nAPI\nARRAYSIZE\nARN\nASAN\nASCII\nASM\nASN\nASSERTed\nASSERTs\nAST\nAWS\nBACKTRACE\nBEL\nBBR\nBIDIRECTIONAL\nNID\nNIST\nbm\nBSON\nBPF\nBdecoded\nBencoded\nCIO\ndeadcode\nDFP\nDynatrace\nDOM\nGasd\nGiB\nIPTOS\nOTEL\nRepick\nReserializer\nSION\nTRA\nWebsockets\nabc\nabcd\nabd\nar\nbtree\nCAS\nCB\ncartid\ncbor\nCDN\nCDS\nCEL\nCWND\nDLE\nDPE\nDSR\nDSS\nEBADF\nECH\nENDIF\nENOTCONN\nENQ\nEOT\nEPIPE\nESC\nETB\nETX\nFS\nFIXME\nHEXDIG\nHEXDIGIT\nHPE\nKwasi\nLRU\nMensah\nNAK\nOWS\nPreconnecting\nRCVBUF\nRTCP\nRTP\nSOH\nSPC\nSTATNAME\nSTX\nSkyWalking\nTIDs\nTimedout\nWRSQ\nWASI\nceil\nCCM\nCHACHA\nCHLO\nCHMOD\nCHLOS\nCHLOs\nCIDR\nCITT\nCLA\nCLI\nCMSG\nCN\nCNAME\nCOMMANDREPLY\nCP\nCPP\nCPU\nCQ\nCRC\nCRL\nCRT\nCSDS\nCSRF\nCSS\nCSV\nCTX\nCVC\nCVE\nCX\nCxx\nCYGWIN\nDCP\nDER\nDESC\nDFATAL\nDGRAM\nDLOG\nDNS\nDQUOTE\nDS\nDST\nDW\nDWORD\nEAGAIN\nECDH\nECDHE\nECDS\nECDSA\nECONNREFUSED\nEDESTRUCTION\nEDF\nEINVAL\nELB\nENOENT\nENV\nEOF\nEOS\nEQ\nERANGE\nEV\nEVAL\nEVLOOP\nEVP\nEWOULDBLOCK\nEXPECTs\nEXPR\nFAQ\nFASTOPEN\nFB\nFCDS\nFCM\nFFFF\nFIN\nFIPS\nFIRSTHDR\nFQDN\nFREEBIND\ncurr\neslint\nfreeifaddrs\nFUZZER\nFUZZERS\ndelims\ndereferencing\ndifferentially\ndnsresolvers\nendpos\neps\nfo\ngb\nghi\ngolang\nguarddog\nGC\nGCC\nGCE\nGCM\nGCOVR\nGCP\nGETting\nGLB\nGOAWAY\nGRPC\nGRO\nGSO\nGSS\nGTEST\nGURL\nGrabbit\nHC\nHCM\nHDS\nHMAC\nHOL\nHPACK\nHTAB\nHTML\nHTTP\nHTTPS\nHV\nHyperscan\nIAM\nIANA\nIDL\nIETF\nIFADDRS\nINADDR\nINET\nINVAL\nIO\nIOS\nIP\nIPPROTO\nIPV\nIPs\nIPv\nITOA\nInjectable\nIsode\nIters\nJSON\nJSONs\nJWKS\nJWKs\nJWS\nJWT\nJWTs\nKB\nKDS\nKarlsson\nKiB\nKille\nLBs\nLC\nLDS\nLEDS\nLEV\nLF\nLHS\nhls\niframe\nilp\ningressed\nintegrations\niouring\njkl\nlang\nlibcurl\nlibsxg\nLLVM\nLPT\nLRS\nLoggable\nMB\nMD\nMERCHANTABILITY\nMerkle\nMGET\nMPTCP\nMQ\nMSDN\nMSET\nMSVC\nMTLS\nMTU\nMULTIFRAME\nNACK\nNACKed\nNACKs\nNBF\nNBSP\nNDEBUG\nNEXTHDR\nNGHTTP\nNLOHMANN\nNOAUTH\nNOCHECKRESP\nNODELAY\nNOLINT\nNOLINTNEXTLINE\nNONBLOCK\nNONCES\nNOSORT\nNS\nNUL\nNilsson\nNonhashable\nOauth\nOCSP\nOD\nODCDS\nmiddlewildcard\nmonostate\nmpd\nna\noghttp\nOID\nOK\nOOM\nOOMs\nORCA\nOS\nOSI\nOSS\nOSX\nOT\nOTLP\nOU\nOVFL\nPAYLOADLEN\nPB\nPCC\nPCRE\nPEERCRED\nPEM\nPERF\nPGV\nPID\nPKCS12\nPKTINFO\nPNG\nPointwise\nPostCBs\nPREBIND\nPRNG\nPROT\nPostgre\nPostgres\nPrereq\nQDCOUNT\nQPACK\nQUIC\nQoS\nqat\nqatzip\nRAII\nRANLUX\nRBAC\nRDN\nRDS\nREADME\nRECVDSTADDR\nRECVPKTINFO\nREFNIL\nREQ\nREUSEADDR\nREUSEPORT\nRFC\nRHS\nRLE\nRLS\nRLQS\nRNG\nRPC\nRSA\nRST\nRTDS\nRTOS\nRTTI\nRUNDIR\nRVCM\nRW\nRX\nRXQ\nRebalance\nRunn\nSA\nSAN\nSCT\nSDK\nSDS\nSENDSRCADDR\nSHA\nSHM\nSIGABRT\nSIGBUS\nSIGFPE\nSIGILL\nSIGINT\nSIGPIPE\nSIGSEGV\nSIGTERM\nSIMD\nSIO\nSMTP\nSNI\nSOTW\nSPD\nSPDY\nSPIFFE\nSPKI\nSQL\nSR\nSRCDIR\nSRDS\nSRV\nSS\nSSD\nSSL\nSTDSTRING\nSTL\nSTRLEN\nSTS\nSUBCOMMAND\nSVG\nSVID\nSXG\nSymbolizer\nTBD\nTCLAP\nTCP\nTE\nTFO\nTID\nTLS\nTLSv\nTLV\nTMPDIR\nTODO\nTP\nTPM\nTSAN\nTSI\nTTL\nTTLs\nTX\nTXT\nUA\nUBSAN\nUDP\nUDS\nUHV\nUNC\nURI\nURL\nUSEVC\nUTC\nUTF\nUUID\nUUIDs\nVC\nVCHAR\nVCL\nVFS\nVH\nVHDS\nVLOG\nVM\nVPN\nWAITFORONE\nWASM\nWAVM\nWIP\nWKT\nWRONGPASS\nWRR\nWS\nWSA\nWSABUF\nWSS\nWelford's\nWi\nXDS\nXFCC\nXFF\nXML\nXN\nXNOR\nXSS\nYAML\nZXID\nabsl\naccesslog\naccessor\naccessors\nacked\nackless\nacks\nacls\naddr\nagg\nAggregationTemporality\nalice\nalignas\nalignof\nalloc\nalloca\nallocatable\nallocator\nallowlist\nallowlisted\nalls\nalphanumerics\namongst\nanno\nanonymization\nanonymizing\nanys\nappmesh\narg\nargc\nargs\nargv\nartisanal\nary\nasctime\nasm\nasync\natoi\natomicity\natomics\natoull\nauth\nauthenticator\nauthenticators\nauthlen\nauthn\nauths\nauthz\nautomata\nautoscale\nbackend\nbackends\nbackgrounded\nbackoff\nbackpressure\nbackticks\nbacktraces\nbacktracing\nbalancer\nbalancers\nbarbaz\nbasename\nbaz\nbazel\nbehaviour\nbenchmarked\nbidi\nbignum\nbitfield\nbitmask\nbitmasks\nbitset\nbitwise\nblackhole\nblackholed\nbookkeep\nbool\nboolean\nbooleans\nbools\nboringssl\nborks\nbroadcasted\nbrotli\nbuf\nbuflen\nbugprone\nbuiltin\nbuiltins\nbulkstrings\nbursty\nbytecode\nbytestream\nbytestring\ncacert\ncacheable\ncacheability\ncallee\ncallsite\ncallsites\ncallstack\ncancellable\ncancelled\ncancelling\ncanonicalization\ncanonicalize\ncanonicalized\ncanonicalizer\ncanonicalizing\ncardinality\ncasted\ncfg\ncharset\ncheckin\nchecksum\nchrono\nchroot\nchunked\nci\nciphersuite\nciphersuites\ncircllhist\nclientcert\ncloneable\ncloneability\ncmd\ncmsghdr\ncodebase\ncodec\ncodecs\ncodepath\ncodepoints\ncodings\ncombinatorial\ncomparator\ncompat\ncompletable\ncond\ncondvar\nconf\nconfig\nconfigs\nconn\nconns\nconst\nconstexpr\nconstructible\ncopyable\ncoroutine\ncoroutines\ncors\ncout\ncoverity\ncplusplus\ncpuset\ncreds\ncRLSign\ncrypto\ncryptographic\ncryptographically\ncstate\ncstring\nctad\nctor\nctrl\ncustomizations\ndarwin\ndatadog\ndatagram\ndatagrams\nde\ndeallocate\ndeallocated\ndeallocating\ndeallocation\ndec\ndechunk\ndechunked\ndecl\ndecls\ndecompressor\ndecompressors\ndecrement\ndecrypt\ndedup\ndedupe\ndeduplicate\ndeduplicates\ndeduplication\ndeflater\ndeletable\ndeleter\ndelim\ndenylist\ndeque\ndeprecations\ndereference\ndereferences\nderegistered\ndeserialization\ndeserialize\ndeserialized\ndeserializer\ndeserializers\ndeserializes\ndeserializing\ndest\ndestructor\ndestructors\ndesynchronize\ndeterministically\ndeterminize\ndev\ndgst\ndir\ndirname\ndjb\ndowncalls\ndowncasted\ndowncased\ndownstreams\ndrainable\ndtor\ndubbo\ndup\ndurations\ndynamodb\neg\nemplace\nemplaced\nemscripten\nemsdk\nenablement\nencodings\nendian\nendianness\nendl\nenqueue\nenqueued\nenqueues\nenum\nenums\nenviron\nepoll\nerrno\netag\netags\nevaluator\nevbuffer\nevbuffers\nevconnlistener\nevented\neventfd\nevwatch\nexe\nexeclp\nexprfor\nexpectable\nextensibility\nextrahelp\nfaceplant\nfacto\nfailover\nfallbacks\nfastbuild\nfavicon\nfbs\nfcntl\nfd\nfds\nfdstat\nfilename\nfilenames\nfileno\nfilesystem\nfirefox\nfixdate\nfixup\nflatbuffer\nflatc\nfmt\nfmtlib\nfn\nformatter\nformatters\nformedness\nfrontend\nftruncate\nfunc\nfunctor\nfunctors\ngRPC\ngateway\ngcov\ngenrule\ngeolocation\ngeo\ngeoip\nGeoip\ngetaddrinfo\ngetaffinity\ngethostname\ngetifaddrs\ngetpeername\ngetsockname\ngetsockopt\ngetter\ngetters\ngithub\nglobals\ngmock\ngoog\ngoogle\ngoto\ngso\ngzip\nhackery\nhacky\nhandshaker\nhardcoded\nhardcodes\nhardcoding\nhashable\nhasher\nhashtagging\nhd\nhdr\nhealthcheck\nhealthchecker\nhealthcheckers\nhealthchecks\nhealths\nhealthz\nhermeticity\nhighp\nhoc\nhostname\nhostnames\nhostset\nhotrestart\nhrefs\nhtpasswd\nhuffman\nhystrix\nidempotency\nidx\nifdef\niff\nified\nifndef\nimpl\nimplementors\nimpls\nindices\ninflater\ninflight\n-ing\ninit\ninitialize\ninitializer\ninitializers\ninlined\ninlining\ninobservability\ninode\ninodes\ninotify\ninserter\ninstantiation\ninstantiations\ninterpretable\nintra\nints\ninvariance\ninvoker\niov\niovcnt\niovec\niovecs\nips\niptables\nish\nisp\nistio\nistream\nistringstream\niteratively\njavascript\njitter\njittered\njs\nkafka\nkeepalive\nkeepalives\nketama\nkeyder\nkqueue\nkubernetes\nkv\nkvlist\nkvs\nlala\nlatencies\nld\nldd\nlen\nlenenc\nlexically\nlibc\nlibevent\nlibprotobuf\nlibrdkafka\nlibtool\nlibstdc\nlifecycle\nlightstep\nlinearization\nlinearize\nlinearized\nlinux\nlivelock\nllvm\nloc\nlocalhost\nlockless\nlogin\nloglevel\nlogstream\nlookup\nlookups\nloopback\nlossy\nlowp\nlstat\nltrim\nlua\nlyft\nmaglev\nmalloc\nmarshaller\nmatchable\nmatcher\nmatchers\nmaxage\nmaxbuffer\nMaxmind\nmaxmind\nmegamiss\nmem\nmemcmp\nmemcpy\nmemset\nmemoize\nmergeable\nmessagename\nmetadata\nmetamethod\nmetaprogramming\nmetatable\nmicrobenchmarks\nmidp\nmilli\nmimics\nmisconfiguration\nmisconfigured\nmixin\nmkdir\nmmap\nmmdb\nmmsg\nmmsghdr\nmongo\nmoveable\nmsec\nmsg\nmsghdr\nmulti\nmulticast\nmultikill\nmultimap\nmultiple\nmultivalue\nmutator\nmutex\nmutexes\nmux\nmuxed\nmysql\nnamelen\nnameserver\nnamespace\nnamespaced\nnamespaces\nnamespacing\nnan\nnanos\nnatively\nndk\nnegative\nnetblock\nnetblocks\nnetfilter\nnetlink\nnetmask\nNLB\nNLMSG\nnonblocking\nnoncopyable\nnonresponsive\nnoop\nnop\nnpos\nnthreads\nntohl\nntop\nnullable\nnulled\nnullopt\nnullptr\nnum\nnumkeys\noauth\nobservability\nocagent\noffsetof\noneof\noneway\noob\nopcode\nopencensus\nopenssl\nopentracing\noptimizations\noptname\noptval\nostream\noutlier\noutliers\noverprovisioned\noverprovisioning\noverridable\noversized\npackagename\npageheap\nparam\nparameterization\nparameterize\nparameterized\nparameterizing\nparams\nparen\nparens\nparentid\nparentspanid\nparseable\nparsers\npassphrase\npassthrough\npathname\npatt\npausable\npausedness\npcall\npcap\npchar\npclose\nperformant\npfctl\npipelined\npipelining\npkey\nplaintext\npluggable\npointee\npoller\npopen\npos\nposix\npostfix\npostfixes\npostgres\npostgresql\npragma\npre\npreallocate\npreallocating\npreallocation\nprecalculated\nprecompile\nprecompiled\nprecompute\nprecomputed\npreconnect\npreconnected\npreconnecting\npreconnects\npredeclared\nprefetch\nprefetched\nprefetches\npreflight\npreorder\nprepend\nprepended\nprepends\npreresolve\npreresolved\nprev\nprobabilistically\nproc\nprofiler\nprogrammatically\nprometheus\nproto\nprotobuf\nprotobufs\nprotoc\nprotodoc\nprotos\nprotoxform\nproxied\npseudocode\npthread\npton\nptr\nptrs\npubkey\npwd\npy\nqdtext\nqps\nquantile\nquantiles\nquerydetails\nquiesce\nquitquitquit\nqvalue\nrapidjson\nratelimit\nratelimited\nratelimiter\nrawseti\nrc\nrdsone\nreadded\nreadonly\nreadv\nrealloc\nrebalanced\nrebalancer\nrebalancing\nrebuffer\nrebuilder\nreceival\nreconnection\nrecurse\nrecv\nrecvfrom\nrecvmmsg\nrecvmsg\nredis\nredispatch\nredistributions\nreentrant\nrefactor\nrefactored\nrefcount\nreferencee\nreferer\nrefetch\nrefvec\nregex\nregexes\nreified\nreify\nreimplements\nrele\nreleasor\nreloadable\nremoting\nrenderers\nreparse\nrepeatability\nreperform\nrepicked\nrepo\nreproducibility\nrequirepass\nreselecting\nreserialize\nreservable\nresize\nresized\nresizes\nresizing\nresolv\nresolvers\nresponder\nrestarter\nresync\nret\nretransmissions\nretransmitted\nretransmitting\nretriable\nretriggers\nretryable\nrevalidated\nrevalidation\nreverify\nrfield\nrmdir\nrocketmq\nrewriter\nrollout\nroundtrip\nrpcs\nrq\nrtrim\nrtt\nruleset\nrunfiles\nruntime\nruntimes\nrver\nrxhash\nsandboxed\nsanitization\nsanitizations\nsanitizer\nsatisfiable\nscalability\nsched\nschedulable\nschemas\nscopekey\nsd\nsecp\nsendmsg\nsendmmsg\nsendto\nserializable\nserializer\nserv\nservercert\nsetenv\nsetsockopt\nsfixed\nsig\nsigaction\nsigactions\nsigaltstack\nsiginfo\nsignalstack\nsigv\nsigv4\nsigv4a\nsiloed\nsim\nsinked\nsint\nsizeof\nsmatch\nsnapshotted\nsockaddr\nsocketpair\nsockfd\nsocklen\nsockopt\nsockopts\nsomestring\nspanid\nspdlog\nsplitter\nspoofable\nsrc\nsrtt\nssize\nstackdriver\nstacktrace\nstartpos\nstarttls\nstartup\nstateful\nstatsd\nstderr\nstdev\nstdin\nstdout\nstmt\nstr\nstreambuf\nstrerr\nstrerror\nstringbuf\nstringified\nstringify\nstringstream\nstrtoull\nstruct\nstructs\nsubclassed\nsubclasses\nsubcomponent\nsubdirectories\nsubdirectory\nsubdirs\nsubexpr\nsubexpressions\nsubitems\nsubmatch\nsubmessages\nsubnet\nsubnets\nsuboptimal\nsubsecond\nsubseconds\nsubsegment\nsubsequence\nsubsetting\nsubstr\nsubstring\nsubstrings\nsubtree\nsubtrees\nsubtype\nsubtypes\nsubzone\nsuf\nsuperclass\nsuperroot\nsuperset\nsvc\nsymlink\nsymlinked\nsymlinks\nsynchronizer\nsyncookie\nsys\nsyscall\nsyscalls\nsysctl\nsz\ntchar\ntchars\ntcmalloc\ntcpdump\nteardown\ntempdir\ntemplated\ntemplating\ntemplatize\ntemplatized\ntemplatizing\ntestability\ntestcase\ntestcases\ntestdata\ntestee\nthreadsafe\nthru\ntimespan\ntimestamp\ntimestamps\ntimeval\ntmp\ntmpfile\ntokenize\ntokenized\ntokenizes\ntokenizing\ntoolchain\ntraceid\ntraceparent\ntracestate\ntranscode\ntranscoded\ntranscoder\ntranscoding\ntransferral\ntrds\ntri\ntriaged\ntrie\ntuple\ntuples\ntypedef\ntypeid\ntypesafe\nuber\nucontext\nudpa\nuint\nun-\nunacked\nunary\nunconfigurable\nundef\nunderflowing\nunfreed\nunicast\nunicode\nunicodes\nunindexed\nuninstantiated\nuniq\nunittest\nunix\nunref\nunreferenced\nunzigzag\nupcasts\nupstreams\nuptime\nupvalue\nurlencoded\nurls\nuserdata\nuserinfo\nusername\nusr\nutil\nutils\nva\nvalgrind\nvalidator\nvalidators\nvanishingly\nvarchar\nvariadic\nvarint\nvec\nvectorize\nver\nverifier\nverifiers\nversa\nversioned\nvhost\nviewable\nviewport\nvip\nvirtualhost\nvirtualize\nvptr\nvtable\nvtt\nwakeup\nwakeups\nwamr\nwasmtime\nwebsocket\nwepoll\nwhitespace\nwhitespaces\nwildcard\nwildcards\nwinsock\nworkspace\nwritev\nwrsq\nwww\nxDS\nxDSes\nxdstp\nxeon\nxform\nxhtml\nxid\nxmodem\nxxhash\nxxs\nxyz\nxyzwebservices\nzag\nzig\nzipkin\nzlib\nzstd\nOBQ\nSemVer\nSCM\nSCTP\nCRLF\nclen\ncrlf\nep\nsuri\ntransid\nroutable\nvhosts\ninfos\nElastiCache\npinterest\nNSS\nSSLKEYLOGFILE\nDLB\nPCIE\nEDNS\nCNAME\n"], "filenames": ["changelogs/current.yaml", "source/extensions/common/proxy_protocol/proxy_protocol_header.cc", "source/extensions/filters/listener/proxy_protocol/proxy_protocol.cc", "test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc", "test/extensions/transport_sockets/proxy_protocol/proxy_protocol_integration_test.cc", "test/per_file_coverage.sh", "tools/spelling/spelling_dictionary.txt"], "buggy_code_start_loc": [50, 129, 147, 623, 642, 26, 995], "buggy_code_end_loc": [50, 129, 165, 623, 642, 26, 995], "fixing_code_start_loc": [51, 130, 147, 624, 643, 27, 996], "fixing_code_end_loc": [55, 139, 178, 652, 684, 28, 997], "type": "CWE-476", "message": "Envoy is a high-performance edge/middle/service proxy. When PPv2 is enabled both on a listener and subsequent cluster, the Envoy instance will segfault when attempting to craft the upstream PPv2 header. This occurs when the downstream request has a command type of LOCAL and does not have the protocol block. This issue has been addressed in releases 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2024-23327", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-09T23:15:09.647", "lastModified": "2024-02-15T04:45:57.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Envoy is a high-performance edge/middle/service proxy. When PPv2 is enabled both on a listener and subsequent cluster, the Envoy instance will segfault when attempting to craft the upstream PPv2 header. This occurs when the downstream request has a command type of LOCAL and does not have the protocol block. This issue has been addressed in releases 1.29.1, 1.28.1, 1.27.3, and 1.26.7. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Envoy es un proxy de servicio/intermedio/perimetral de alto rendimiento. Cuando PPv2 est\u00e1 habilitado tanto en un oyente como en un cl\u00faster posterior, la instancia de Envoy generar\u00e1 un error de segmentaci\u00f3n al intentar crear el encabezado PPv2 ascendente. Esto ocurre cuando la solicitud descendente tiene un tipo de comando LOCAL y no tiene el bloque de protocolo. Este problema se solucion\u00f3 en las versiones 1.29.1, 1.28.1, 1.27.3 y 1.26.7. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.26.0", "versionEndExcluding": "1.26.7", "matchCriteriaId": "0324E095-98B4-4B78-9242-989EC45E011F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.27.0", "versionEndExcluding": "1.27.3", "matchCriteriaId": "2E838B16-C6DC-4701-B955-D96D4CAEF4F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.28.0", "versionEndExcluding": "1.28.1", "matchCriteriaId": "770D5713-48E3-4F9B-B05C-9CB9C6B272E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:envoyproxy:envoy:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.29.0", "versionEndExcluding": "1.29.1", "matchCriteriaId": "638F3351-3ACD-47C8-9B8F-568A930FAECA"}]}]}], "references": [{"url": "https://github.com/envoyproxy/envoy/commit/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-4h5x-x9vh-m29j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/envoyproxy/envoy/commit/63895ea8e3cca9c5d3ab4c5c128ed1369969d54a"}}