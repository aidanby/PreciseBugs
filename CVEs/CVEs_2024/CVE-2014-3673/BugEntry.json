{"buggy_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001 Intel Corp.\n *\n * This file is part of the SCTP kernel implementation\n *\n * These are definitions needed by the state machine.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email addresses:\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson <karl@athena.chicago.il.us>\n *    Xingang Guo <xingang.guo@intel.com>\n *    Jon Grimm <jgrimm@us.ibm.com>\n *    Dajiang Zhang <dajiang.zhang@nokia.com>\n *    Sridhar Samudrala <sri@us.ibm.com>\n *    Daisy Chang <daisyc@us.ibm.com>\n *    Ardelle Fan <ardelle.fan@intel.com>\n *    Kevin Gao <kevin.gao@intel.com>\n */\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <net/sctp/command.h>\n#include <net/sctp/sctp.h>\n\n#ifndef __sctp_sm_h__\n#define __sctp_sm_h__\n\n/*\n * Possible values for the disposition are:\n */\ntypedef enum {\n\tSCTP_DISPOSITION_DISCARD,\t /* No further processing.  */\n\tSCTP_DISPOSITION_CONSUME,\t /* Process return values normally.  */\n\tSCTP_DISPOSITION_NOMEM,\t\t /* We ran out of memory--recover.  */\n\tSCTP_DISPOSITION_DELETE_TCB,\t /* Close the association.  */\n\tSCTP_DISPOSITION_ABORT,\t\t /* Close the association NOW.  */\n\tSCTP_DISPOSITION_VIOLATION,\t /* The peer is misbehaving.  */\n\tSCTP_DISPOSITION_NOT_IMPL,\t /* This entry is not implemented.  */\n\tSCTP_DISPOSITION_ERROR,\t\t /* This is plain old user error.  */\n\tSCTP_DISPOSITION_BUG,\t\t /* This is a bug.  */\n} sctp_disposition_t;\n\ntypedef struct {\n\tint name;\n\tint action;\n} sctp_sm_command_t;\n\ntypedef sctp_disposition_t (sctp_state_fn_t) (struct net *,\n\t\t\t\t\t      const struct sctp_endpoint *,\n\t\t\t\t\t      const struct sctp_association *,\n\t\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t\t      void *arg,\n\t\t\t\t\t      sctp_cmd_seq_t *);\ntypedef void (sctp_timer_event_t) (unsigned long);\ntypedef struct {\n\tsctp_state_fn_t *fn;\n\tconst char *name;\n} sctp_sm_table_entry_t;\n\n/* A naming convention of \"sctp_sf_xxx\" applies to all the state functions\n * currently in use.\n */\n\n/* Prototypes for generic state functions. */\nsctp_state_fn_t sctp_sf_not_impl;\nsctp_state_fn_t sctp_sf_bug;\n\n/* Prototypes for gener timer state functions. */\nsctp_state_fn_t sctp_sf_timer_ignore;\n\n/* Prototypes for chunk state functions. */\nsctp_state_fn_t sctp_sf_do_9_1_abort;\nsctp_state_fn_t sctp_sf_cookie_wait_abort;\nsctp_state_fn_t sctp_sf_cookie_echoed_abort;\nsctp_state_fn_t sctp_sf_shutdown_pending_abort;\nsctp_state_fn_t sctp_sf_shutdown_sent_abort;\nsctp_state_fn_t sctp_sf_shutdown_ack_sent_abort;\nsctp_state_fn_t sctp_sf_do_5_1B_init;\nsctp_state_fn_t sctp_sf_do_5_1C_ack;\nsctp_state_fn_t sctp_sf_do_5_1D_ce;\nsctp_state_fn_t sctp_sf_do_5_1E_ca;\nsctp_state_fn_t sctp_sf_do_4_C;\nsctp_state_fn_t sctp_sf_eat_data_6_2;\nsctp_state_fn_t sctp_sf_eat_data_fast_4_4;\nsctp_state_fn_t sctp_sf_eat_sack_6_2;\nsctp_state_fn_t sctp_sf_operr_notify;\nsctp_state_fn_t sctp_sf_t1_init_timer_expire;\nsctp_state_fn_t sctp_sf_t1_cookie_timer_expire;\nsctp_state_fn_t sctp_sf_t2_timer_expire;\nsctp_state_fn_t sctp_sf_t4_timer_expire;\nsctp_state_fn_t sctp_sf_t5_timer_expire;\nsctp_state_fn_t sctp_sf_sendbeat_8_3;\nsctp_state_fn_t sctp_sf_beat_8_3;\nsctp_state_fn_t sctp_sf_backbeat_8_3;\nsctp_state_fn_t sctp_sf_do_9_2_final;\nsctp_state_fn_t sctp_sf_do_9_2_shutdown;\nsctp_state_fn_t sctp_sf_do_9_2_shut_ctsn;\nsctp_state_fn_t sctp_sf_do_ecn_cwr;\nsctp_state_fn_t sctp_sf_do_ecne;\nsctp_state_fn_t sctp_sf_ootb;\nsctp_state_fn_t sctp_sf_pdiscard;\nsctp_state_fn_t sctp_sf_violation;\nsctp_state_fn_t sctp_sf_discard_chunk;\nsctp_state_fn_t sctp_sf_do_5_2_1_siminit;\nsctp_state_fn_t sctp_sf_do_5_2_2_dupinit;\nsctp_state_fn_t sctp_sf_do_5_2_3_initack;\nsctp_state_fn_t sctp_sf_do_5_2_4_dupcook;\nsctp_state_fn_t sctp_sf_unk_chunk;\nsctp_state_fn_t sctp_sf_do_8_5_1_E_sa;\nsctp_state_fn_t sctp_sf_cookie_echoed_err;\nsctp_state_fn_t sctp_sf_do_asconf;\nsctp_state_fn_t sctp_sf_do_asconf_ack;\nsctp_state_fn_t sctp_sf_do_9_2_reshutack;\nsctp_state_fn_t sctp_sf_eat_fwd_tsn;\nsctp_state_fn_t sctp_sf_eat_fwd_tsn_fast;\nsctp_state_fn_t sctp_sf_eat_auth;\n\n/* Prototypes for primitive event state functions.  */\nsctp_state_fn_t sctp_sf_do_prm_asoc;\nsctp_state_fn_t sctp_sf_do_prm_send;\nsctp_state_fn_t sctp_sf_do_9_2_prm_shutdown;\nsctp_state_fn_t sctp_sf_cookie_wait_prm_shutdown;\nsctp_state_fn_t sctp_sf_cookie_echoed_prm_shutdown;\nsctp_state_fn_t sctp_sf_do_9_1_prm_abort;\nsctp_state_fn_t sctp_sf_cookie_wait_prm_abort;\nsctp_state_fn_t sctp_sf_cookie_echoed_prm_abort;\nsctp_state_fn_t sctp_sf_shutdown_pending_prm_abort;\nsctp_state_fn_t sctp_sf_shutdown_sent_prm_abort;\nsctp_state_fn_t sctp_sf_shutdown_ack_sent_prm_abort;\nsctp_state_fn_t sctp_sf_error_closed;\nsctp_state_fn_t sctp_sf_error_shutdown;\nsctp_state_fn_t sctp_sf_ignore_primitive;\nsctp_state_fn_t sctp_sf_do_prm_requestheartbeat;\nsctp_state_fn_t sctp_sf_do_prm_asconf;\n\n/* Prototypes for other event state functions.  */\nsctp_state_fn_t sctp_sf_do_no_pending_tsn;\nsctp_state_fn_t sctp_sf_do_9_2_start_shutdown;\nsctp_state_fn_t sctp_sf_do_9_2_shutdown_ack;\nsctp_state_fn_t sctp_sf_ignore_other;\nsctp_state_fn_t sctp_sf_cookie_wait_icmp_abort;\n\n/* Prototypes for timeout event state functions.  */\nsctp_state_fn_t sctp_sf_do_6_3_3_rtx;\nsctp_state_fn_t sctp_sf_do_6_2_sack;\nsctp_state_fn_t sctp_sf_autoclose_timer_expire;\n\n/* Prototypes for utility support functions.  */\n__u8 sctp_get_chunk_type(struct sctp_chunk *chunk);\nconst sctp_sm_table_entry_t *sctp_sm_lookup_event(struct net *,\n\t\t\t\t\t    sctp_event_t,\n\t\t\t\t\t    sctp_state_t,\n\t\t\t\t\t    sctp_subtype_t);\nint sctp_chunk_iif(const struct sctp_chunk *);\nstruct sctp_association *sctp_make_temp_asoc(const struct sctp_endpoint *,\n\t\t\t\t\t     struct sctp_chunk *,\n\t\t\t\t\t     gfp_t gfp);\n__u32 sctp_generate_verification_tag(void);\nvoid sctp_populate_tie_tags(__u8 *cookie, __u32 curTag, __u32 hisTag);\n\n/* Prototypes for chunk-building functions.  */\nstruct sctp_chunk *sctp_make_init(const struct sctp_association *,\n\t\t\t     const struct sctp_bind_addr *,\n\t\t\t     gfp_t gfp, int vparam_len);\nstruct sctp_chunk *sctp_make_init_ack(const struct sctp_association *,\n\t\t\t\t const struct sctp_chunk *,\n\t\t\t\t const gfp_t gfp,\n\t\t\t\t const int unkparam_len);\nstruct sctp_chunk *sctp_make_cookie_echo(const struct sctp_association *,\n\t\t\t\t    const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *,\n\t\t\t\t   const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_cwr(const struct sctp_association *,\n\t\t\t\t const __u32 lowest_tsn,\n\t\t\t\t const struct sctp_chunk *);\nstruct sctp_chunk * sctp_make_datafrag_empty(struct sctp_association *,\n\t\t\t\t\tconst struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t\tint len, const __u8 flags,\n\t\t\t\t\t__u16 ssn);\nstruct sctp_chunk *sctp_make_ecne(const struct sctp_association *,\n\t\t\t\t  const __u32);\nstruct sctp_chunk *sctp_make_sack(const struct sctp_association *);\nstruct sctp_chunk *sctp_make_shutdown(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk);\nstruct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t\t  const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_shutdown_complete(const struct sctp_association *,\n\t\t\t\t\t  const struct sctp_chunk *);\nvoid sctp_init_cause(struct sctp_chunk *, __be16 cause, size_t);\nstruct sctp_chunk *sctp_make_abort(const struct sctp_association *,\n\t\t\t      const struct sctp_chunk *,\n\t\t\t      const size_t hint);\nstruct sctp_chunk *sctp_make_abort_no_data(const struct sctp_association *,\n\t\t\t\t      const struct sctp_chunk *,\n\t\t\t\t      __u32 tsn);\nstruct sctp_chunk *sctp_make_abort_user(const struct sctp_association *,\n\t\t\t\t\tconst struct msghdr *, size_t msg_len);\nstruct sctp_chunk *sctp_make_abort_violation(const struct sctp_association *,\n\t\t\t\t   const struct sctp_chunk *,\n\t\t\t\t   const __u8 *,\n\t\t\t\t   const size_t );\nstruct sctp_chunk *sctp_make_violation_paramlen(const struct sctp_association *,\n\t\t\t\t   const struct sctp_chunk *,\n\t\t\t\t   struct sctp_paramhdr *);\nstruct sctp_chunk *sctp_make_violation_max_retrans(const struct sctp_association *,\n\t\t\t\t\t\t   const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_heartbeat(const struct sctp_association *,\n\t\t\t\t  const struct sctp_transport *);\nstruct sctp_chunk *sctp_make_heartbeat_ack(const struct sctp_association *,\n\t\t\t\t      const struct sctp_chunk *,\n\t\t\t\t      const void *payload,\n\t\t\t\t      const size_t paylen);\nstruct sctp_chunk *sctp_make_op_error(const struct sctp_association *,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t __be16 cause_code,\n\t\t\t\t const void *payload,\n\t\t\t\t size_t paylen,\n\t\t\t\t size_t reserve_tail);\n\nstruct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *,\n\t\t\t\t\t      union sctp_addr *,\n\t\t\t\t\t      struct sockaddr *,\n\t\t\t\t\t      int, __be16);\nstruct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\n\t\t\t\t\t     union sctp_addr *addr);\nint sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp);\nstruct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf);\nint sctp_process_asconf_ack(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *asconf_ack);\nstruct sctp_chunk *sctp_make_fwdtsn(const struct sctp_association *asoc,\n\t\t\t\t    __u32 new_cum_tsn, size_t nstreams,\n\t\t\t\t    struct sctp_fwdtsn_skip *skiplist);\nstruct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc);\n\nvoid sctp_chunk_assign_tsn(struct sctp_chunk *);\nvoid sctp_chunk_assign_ssn(struct sctp_chunk *);\n\n/* Prototypes for statetable processing. */\n\nint sctp_do_sm(struct net *net, sctp_event_t event_type, sctp_subtype_t subtype,\n\t       sctp_state_t state,\n               struct sctp_endpoint *,\n               struct sctp_association *asoc,\n               void *event_arg,\n\t       gfp_t gfp);\n\n/* 2nd level prototypes */\nvoid sctp_generate_t3_rtx_event(unsigned long peer);\nvoid sctp_generate_heartbeat_event(unsigned long peer);\nvoid sctp_generate_proto_unreach_event(unsigned long peer);\n\nvoid sctp_ootb_pkt_free(struct sctp_packet *);\n\nstruct sctp_association *sctp_unpack_cookie(const struct sctp_endpoint *,\n\t\t\t\t       const struct sctp_association *,\n\t\t\t\t       struct sctp_chunk *,\n\t\t\t\t       gfp_t gfp, int *err,\n\t\t\t\t       struct sctp_chunk **err_chk_p);\nint sctp_addip_addr_config(struct sctp_association *, sctp_param_t,\n\t\t\t   struct sockaddr_storage*, int);\n\n/* 3rd level prototypes */\n__u32 sctp_generate_tag(const struct sctp_endpoint *);\n__u32 sctp_generate_tsn(const struct sctp_endpoint *);\n\n/* Extern declarations for major data structures.  */\nextern sctp_timer_event_t *sctp_timer_events[SCTP_NUM_TIMEOUT_TYPES];\n\n\n/* Get the size of a DATA chunk payload. */\nstatic inline __u16 sctp_data_size(struct sctp_chunk *chunk)\n{\n\t__u16 size;\n\n\tsize = ntohs(chunk->chunk_hdr->length);\n\tsize -= sizeof(sctp_data_chunk_t);\n\n\treturn size;\n}\n\n/* Compare two TSNs */\n\n/* RFC 1982 - Serial Number Arithmetic\n *\n * 2. Comparison\n *  Then, s1 is said to be equal to s2 if and only if i1 is equal to i2,\n *  in all other cases, s1 is not equal to s2.\n *\n * s1 is said to be less than s2 if, and only if, s1 is not equal to s2,\n * and\n *\n *      (i1 < i2 and i2 - i1 < 2^(SERIAL_BITS - 1)) or\n *      (i1 > i2 and i1 - i2 > 2^(SERIAL_BITS - 1))\n *\n * s1 is said to be greater than s2 if, and only if, s1 is not equal to\n * s2, and\n *\n *      (i1 < i2 and i2 - i1 > 2^(SERIAL_BITS - 1)) or\n *      (i1 > i2 and i1 - i2 < 2^(SERIAL_BITS - 1))\n */\n\n/*\n * RFC 2960\n *  1.6 Serial Number Arithmetic\n *\n * Comparisons and arithmetic on TSNs in this document SHOULD use Serial\n * Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32.\n */\n\nenum {\n\tTSN_SIGN_BIT = (1<<31)\n};\n\nstatic inline int TSN_lt(__u32 s, __u32 t)\n{\n\treturn ((s) - (t)) & TSN_SIGN_BIT;\n}\n\nstatic inline int TSN_lte(__u32 s, __u32 t)\n{\n\treturn ((s) == (t)) || (((s) - (t)) & TSN_SIGN_BIT);\n}\n\n/* Compare two SSNs */\n\n/*\n * RFC 2960\n *  1.6 Serial Number Arithmetic\n *\n * Comparisons and arithmetic on Stream Sequence Numbers in this document\n * SHOULD use Serial Number Arithmetic as defined in [RFC1982] where\n * SERIAL_BITS = 16.\n */\nenum {\n\tSSN_SIGN_BIT = (1<<15)\n};\n\nstatic inline int SSN_lt(__u16 s, __u16 t)\n{\n\treturn ((s) - (t)) & SSN_SIGN_BIT;\n}\n\nstatic inline int SSN_lte(__u16 s, __u16 t)\n{\n\treturn ((s) == (t)) || (((s) - (t)) & SSN_SIGN_BIT);\n}\n\n/*\n * ADDIP 3.1.1\n * The valid range of Serial Number is from 0 to 4294967295 (2**32 - 1). Serial\n * Numbers wrap back to 0 after reaching 4294967295.\n */\nenum {\n\tADDIP_SERIAL_SIGN_BIT = (1<<31)\n};\n\nstatic inline int ADDIP_SERIAL_gte(__u16 s, __u16 t)\n{\n\treturn ((s) == (t)) || (((t) - (s)) & ADDIP_SERIAL_SIGN_BIT);\n}\n\n/* Check VTAG of the packet matches the sender's own tag. */\nstatic inline int\nsctp_vtag_verify(const struct sctp_chunk *chunk,\n\t\t const struct sctp_association *asoc)\n{\n\t/* RFC 2960 Sec 8.5 When receiving an SCTP packet, the endpoint\n\t * MUST ensure that the value in the Verification Tag field of\n\t * the received SCTP packet matches its own Tag. If the received\n\t * Verification Tag value does not match the receiver's own\n\t * tag value, the receiver shall silently discard the packet...\n\t */\n        if (ntohl(chunk->sctp_hdr->vtag) == asoc->c.my_vtag)\n                return 1;\n\n\treturn 0;\n}\n\n/* Check VTAG of the packet matches the sender's own tag and the T bit is\n * not set, OR its peer's tag and the T bit is set in the Chunk Flags.\n */\nstatic inline int\nsctp_vtag_verify_either(const struct sctp_chunk *chunk,\n\t\t\tconst struct sctp_association *asoc)\n{\n        /* RFC 2960 Section 8.5.1, sctpimpguide Section 2.41\n\t *\n\t * B) The receiver of a ABORT MUST accept the packet\n\t *    if the Verification Tag field of the packet matches its own tag\n\t *    and the T bit is not set\n\t *    OR\n\t *    it is set to its peer's tag and the T bit is set in the Chunk\n\t *    Flags.\n\t *    Otherwise, the receiver MUST silently discard the packet\n\t *    and take no further action.\n\t *\n\t * C) The receiver of a SHUTDOWN COMPLETE shall accept the packet\n\t *    if the Verification Tag field of the packet matches its own tag\n\t *    and the T bit is not set\n\t *    OR\n\t *    it is set to its peer's tag and the T bit is set in the Chunk\n\t *    Flags.\n\t *    Otherwise, the receiver MUST silently discard the packet\n\t *    and take no further action.  An endpoint MUST ignore the\n\t *    SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n\t */\n        if ((!sctp_test_T_bit(chunk) &&\n             (ntohl(chunk->sctp_hdr->vtag) == asoc->c.my_vtag)) ||\n\t    (sctp_test_T_bit(chunk) && asoc->c.peer_vtag &&\n\t     (ntohl(chunk->sctp_hdr->vtag) == asoc->c.peer_vtag))) {\n                return 1;\n\t}\n\n\treturn 0;\n}\n\n#endif /* __sctp_sm_h__ */\n", "/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions work with the state functions in sctp_sm_statefuns.c\n * to implement the state operations.  These functions implement the\n * steps which require modifying existing data structures.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    C. Robin              <chris@hundredacre.ac.uk>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Xingang Guo           <xingang.guo@intel.com>\n *    Dajiang Zhang\t    <dajiang.zhang@nokia.com>\n *    Sridhar Samudrala\t    <sri@us.ibm.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Kevin Gao             <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n\n#include <linux/skbuff.h>\n#include <linux/random.h>\t/* for get_random_bytes */\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen);\nstatic struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen);\nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t   __u8 type, __u8 flags, int paylen);\nstatic sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *init_chunk,\n\t\t\t\t\tint *cookie_len,\n\t\t\t\t\tconst __u8 *raw_addrs, int addrs_len);\nstatic int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp);\nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\n\t\t\t      const void *data);\nstatic void  *sctp_addto_chunk_fixed(struct sctp_chunk *, int len,\n\t\t\t\t     const void *data);\n\n/* Control chunk destructor */\nstatic void sctp_control_release_owner(struct sk_buff *skb)\n{\n\t/*TODO: do memory release */\n}\n\nstatic void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\n\t/* TODO: properly account for control chunks.\n\t * To do it right we'll need:\n\t *  1) endpoint if association isn't known.\n\t *  2) proper memory accounting.\n\t *\n\t *  For now don't do anything for now.\n\t */\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb->destructor = sctp_control_release_owner;\n}\n\n/* What was the inbound interface for this chunk? */\nint sctp_chunk_iif(const struct sctp_chunk *chunk)\n{\n\tstruct sctp_af *af;\n\tint iif = 0;\n\n\taf = sctp_get_af_specific(ipver2af(ip_hdr(chunk->skb)->version));\n\tif (af)\n\t\tiif = af->skb_iif(chunk->skb);\n\n\treturn iif;\n}\n\n/* RFC 2960 3.3.2 Initiation (INIT) (1)\n *\n * Note 2: The ECN capable field is reserved for future use of\n * Explicit Congestion Notification.\n */\nstatic const struct sctp_paramhdr ecap_param = {\n\tSCTP_PARAM_ECN_CAPABLE,\n\tcpu_to_be16(sizeof(struct sctp_paramhdr)),\n};\nstatic const struct sctp_paramhdr prsctp_param = {\n\tSCTP_PARAM_FWD_TSN_SUPPORT,\n\tcpu_to_be16(sizeof(struct sctp_paramhdr)),\n};\n\n/* A helper to initialize an op error inside a\n * provided chunk, as most cause codes will be embedded inside an\n * abort chunk.\n */\nvoid  sctp_init_cause(struct sctp_chunk *chunk, __be16 cause_code,\n\t\t      size_t paylen)\n{\n\tsctp_errhdr_t err;\n\t__u16 len;\n\n\t/* Cause code constants are now defined in network order.  */\n\terr.cause = cause_code;\n\tlen = sizeof(sctp_errhdr_t) + paylen;\n\terr.length  = htons(len);\n\tchunk->subh.err_hdr = sctp_addto_chunk(chunk, sizeof(sctp_errhdr_t), &err);\n}\n\n/* A helper to initialize an op error inside a\n * provided chunk, as most cause codes will be embedded inside an\n * abort chunk.  Differs from sctp_init_cause in that it won't oops\n * if there isn't enough space in the op error chunk\n */\nstatic int sctp_init_cause_fixed(struct sctp_chunk *chunk, __be16 cause_code,\n\t\t      size_t paylen)\n{\n\tsctp_errhdr_t err;\n\t__u16 len;\n\n\t/* Cause code constants are now defined in network order.  */\n\terr.cause = cause_code;\n\tlen = sizeof(sctp_errhdr_t) + paylen;\n\terr.length  = htons(len);\n\n\tif (skb_tailroom(chunk->skb) < len)\n\t\treturn -ENOSPC;\n\tchunk->subh.err_hdr = sctp_addto_chunk_fixed(chunk,\n\t\t\t\t\t\t     sizeof(sctp_errhdr_t),\n\t\t\t\t\t\t     &err);\n\treturn 0;\n}\n/* 3.3.2 Initiation (INIT) (1)\n *\n * This chunk is used to initiate a SCTP association between two\n * endpoints. The format of the INIT chunk is shown below:\n *\n *     0                   1                   2                   3\n *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |   Type = 1    |  Chunk Flags  |      Chunk Length             |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |                         Initiate Tag                          |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |           Advertised Receiver Window Credit (a_rwnd)          |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |  Number of Outbound Streams   |  Number of Inbound Streams    |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |                          Initial TSN                          |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    \\                                                               \\\n *    /              Optional/Variable-Length Parameters              /\n *    \\                                                               \\\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n *\n * The INIT chunk contains the following parameters. Unless otherwise\n * noted, each parameter MUST only be included once in the INIT chunk.\n *\n * Fixed Parameters                     Status\n * ----------------------------------------------\n * Initiate Tag                        Mandatory\n * Advertised Receiver Window Credit   Mandatory\n * Number of Outbound Streams          Mandatory\n * Number of Inbound Streams           Mandatory\n * Initial TSN                         Mandatory\n *\n * Variable Parameters                  Status     Type Value\n * -------------------------------------------------------------\n * IPv4 Address (Note 1)               Optional    5\n * IPv6 Address (Note 1)               Optional    6\n * Cookie Preservative                 Optional    9\n * Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n * Host Name Address (Note 3)          Optional    11\n * Supported Address Types (Note 4)    Optional    12\n */\nstruct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tstruct sctp_endpoint *ep = asoc->ep;\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n\tchunksize += sizeof(ecap_param);\n\n\tif (net->sctp.prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (net->sctp.addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (ep->auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_control(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (net->sctp.prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (ep->auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t gfp_t gfp, int unkparam_len)\n{\n\tsctp_inithdr_t initack;\n\tstruct sctp_chunk *retval;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\tint addrs_len;\n\tsctp_cookie_param_t *cookie;\n\tint cookie_len;\n\tsize_t chunksize;\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL,\n\t\t\t*auth_random = NULL;\n\n\tretval = NULL;\n\n\t/* Note: there may be no addresses to embed. */\n\taddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\n\n\tinitack.init_tag\t        = htonl(asoc->c.my_vtag);\n\tinitack.a_rwnd\t\t\t= htonl(asoc->rwnd);\n\tinitack.num_outbound_streams\t= htons(asoc->c.sinit_num_ostreams);\n\tinitack.num_inbound_streams\t= htons(asoc->c.sinit_max_instreams);\n\tinitack.initial_tsn\t\t= htonl(asoc->c.initial_tsn);\n\n\t/* FIXME:  We really ought to build the cookie right\n\t * into the packet instead of allocating more fresh memory.\n\t */\n\tcookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\n\t\t\t\t  addrs.v, addrs_len);\n\tif (!cookie)\n\t\tgoto nomem_cookie;\n\n\t/* Calculate the total size of allocation, include the reserved\n\t * space for reporting unknown parameters if it is specified.\n\t */\n\tsp = sctp_sk(asoc->base.sk);\n\tchunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;\n\n\t/* Tell peer that we'll do ECN only if peer advertised such cap.  */\n\tif (asoc->peer.ecn_capable)\n\t\tchunksize += sizeof(ecap_param);\n\n\tif (asoc->peer.prsctp_capable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\tif (asoc->peer.asconf_capable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tif (asoc->peer.auth_capable) {\n\t\tauth_random = (sctp_paramhdr_t *)asoc->c.auth_random;\n\t\tchunksize += ntohs(auth_random->length);\n\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* Now allocate and fill out the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_INIT_ACK, 0, chunksize);\n\tif (!retval)\n\t\tgoto nomem_chunk;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [INIT ACK back to where the INIT came from.]\n\t */\n\tretval->transport = chunk->transport;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(initack), &initack);\n\tretval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);\n\tsctp_addto_chunk(retval, cookie_len, cookie);\n\tif (asoc->peer.ecn_capable)\n\t\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t &ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\tif (asoc->peer.prsctp_capable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\tif (asoc->peer.auth_capable) {\n\t\tsctp_addto_chunk(retval, ntohs(auth_random->length),\n\t\t\t\t auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\n\n\t/* We need to remove the const qualifier at this point.  */\n\tretval->asoc = (struct sctp_association *) asoc;\n\nnomem_chunk:\n\tkfree(cookie);\nnomem_cookie:\n\tkfree(addrs.v);\n\treturn retval;\n}\n\n/* 3.3.11 Cookie Echo (COOKIE ECHO) (10):\n *\n * This chunk is used only during the initialization of an association.\n * It is sent by the initiator of an association to its peer to complete\n * the initialization process. This chunk MUST precede any DATA chunk\n * sent within the association, but MAY be bundled with one or more DATA\n * chunks in the same packet.\n *\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |   Type = 10   |Chunk  Flags   |         Length                |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     /                     Cookie                                    /\n *     \\                                                               \\\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Chunk Flags: 8 bit\n *\n *   Set to zero on transmit and ignored on receipt.\n *\n * Length: 16 bits (unsigned integer)\n *\n *   Set to the size of the chunk in bytes, including the 4 bytes of\n *   the chunk header and the size of the Cookie.\n *\n * Cookie: variable size\n *\n *   This field must contain the exact cookie received in the\n *   State Cookie parameter from the previous INIT ACK.\n *\n *   An implementation SHOULD make the cookie as small as possible\n *   to insure interoperability.\n */\nstruct sctp_chunk *sctp_make_cookie_echo(const struct sctp_association *asoc,\n\t\t\t\t    const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tvoid *cookie;\n\tint cookie_len;\n\n\tcookie = asoc->peer.cookie;\n\tcookie_len = asoc->peer.cookie_len;\n\n\t/* Build a cookie echo chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ECHO, 0, cookie_len);\n\tif (!retval)\n\t\tgoto nodata;\n\tretval->subh.cookie_hdr =\n\t\tsctp_addto_chunk(retval, cookie_len, cookie);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [COOKIE ECHO back to where the INIT ACK came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* 3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):\n *\n * This chunk is used only during the initialization of an\n * association.  It is used to acknowledge the receipt of a COOKIE\n * ECHO chunk.  This chunk MUST precede any DATA or SACK chunk sent\n * within the association, but MAY be bundled with one or more DATA\n * chunks or SACK chunk in the same SCTP packet.\n *\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |   Type = 11   |Chunk  Flags   |     Length = 4                |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Chunk Flags: 8 bits\n *\n *   Set to zero on transmit and ignored on receipt.\n */\nstruct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\n\t\t\t\t   const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [COOKIE ACK back to where the COOKIE ECHO came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n/*\n *  Appendix A: Explicit Congestion Notification:\n *  CWR:\n *\n *  RFC 2481 details a specific bit for a sender to send in the header of\n *  its next outbound TCP segment to indicate to its peer that it has\n *  reduced its congestion window.  This is termed the CWR bit.  For\n *  SCTP the same indication is made by including the CWR chunk.\n *  This chunk contains one data element, i.e. the TSN number that\n *  was sent in the ECNE chunk.  This element represents the lowest\n *  TSN number in the datagram that was originally marked with the\n *  CE bit.\n *\n *     0                   1                   2                   3\n *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    | Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |                      Lowest TSN Number                        |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n *     Note: The CWR is considered a Control chunk.\n */\nstruct sctp_chunk *sctp_make_cwr(const struct sctp_association *asoc,\n\t\t\t    const __u32 lowest_tsn,\n\t\t\t    const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_cwrhdr_t cwr;\n\n\tcwr.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_CWR, 0,\n\t\t\t\t   sizeof(sctp_cwrhdr_t));\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.ecn_cwr_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(cwr), &cwr);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [Report a reduced congestion window back to where the ECNE\n\t * came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* Make an ECNE chunk.  This is a congestion experienced report.  */\nstruct sctp_chunk *sctp_make_ecne(const struct sctp_association *asoc,\n\t\t\t     const __u32 lowest_tsn)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_ecnehdr_t ecne;\n\n\tecne.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_ECNE, 0,\n\t\t\t\t   sizeof(sctp_ecnehdr_t));\n\tif (!retval)\n\t\tgoto nodata;\n\tretval->subh.ecne_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ecne), &ecne);\n\nnodata:\n\treturn retval;\n}\n\n/* Make a DATA chunk for the given association from the provided\n * parameters.  However, do not populate the data payload.\n */\nstruct sctp_chunk *sctp_make_datafrag_empty(struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t       int data_len, __u8 flags, __u16 ssn)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_datahdr dp;\n\tint chunk_len;\n\n\t/* We assign the TSN as LATE as possible, not here when\n\t * creating the chunk.\n\t */\n\tdp.tsn = 0;\n\tdp.stream = htons(sinfo->sinfo_stream);\n\tdp.ppid   = sinfo->sinfo_ppid;\n\n\t/* Set the flags for an unordered send.  */\n\tif (sinfo->sinfo_flags & SCTP_UNORDERED) {\n\t\tflags |= SCTP_DATA_UNORDERED;\n\t\tdp.ssn = 0;\n\t} else\n\t\tdp.ssn = htons(ssn);\n\n\tchunk_len = sizeof(dp) + data_len;\n\tretval = sctp_make_data(asoc, flags, chunk_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.data_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp);\n\tmemcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));\n\nnodata:\n\treturn retval;\n}\n\n/* Create a selective ackowledgement (SACK) for the given\n * association.  This reports on which TSN's we've seen to date,\n * including duplicates and gaps.\n */\nstruct sctp_chunk *sctp_make_sack(const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_sackhdr sack;\n\tint len;\n\t__u32 ctsn;\n\t__u16 num_gabs, num_dup_tsns;\n\tstruct sctp_association *aptr = (struct sctp_association *)asoc;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sctp_gap_ack_block gabs[SCTP_MAX_GABS];\n\tstruct sctp_transport *trans;\n\n\tmemset(gabs, 0, sizeof(gabs));\n\tctsn = sctp_tsnmap_get_ctsn(map);\n\n\tpr_debug(\"%s: sackCTSNAck sent:0x%x\\n\", __func__, ctsn);\n\n\t/* How much room is needed in the chunk? */\n\tnum_gabs = sctp_tsnmap_num_gabs(map, gabs);\n\tnum_dup_tsns = sctp_tsnmap_num_dups(map);\n\n\t/* Initialize the SACK header.  */\n\tsack.cum_tsn_ack\t    = htonl(ctsn);\n\tsack.a_rwnd \t\t    = htonl(asoc->a_rwnd);\n\tsack.num_gap_ack_blocks     = htons(num_gabs);\n\tsack.num_dup_tsns           = htons(num_dup_tsns);\n\n\tlen = sizeof(sack)\n\t\t+ sizeof(struct sctp_gap_ack_block) * num_gabs\n\t\t+ sizeof(__u32) * num_dup_tsns;\n\n\t/* Create the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_SACK, 0, len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk to\n\t * which it is replying.  This rule should also be followed if\n\t * the endpoint is bundling DATA chunks together with the\n\t * reply chunk.\n\t *\n\t * However, when acknowledging multiple DATA chunks received\n\t * in packets from different source addresses in a single\n\t * SACK, the SACK chunk may be transmitted to one of the\n\t * destination transport addresses from which the DATA or\n\t * control chunks being acknowledged were received.\n\t *\n\t * [BUG:  We do not implement the following paragraph.\n\t * Perhaps we should remember the last transport we used for a\n\t * SACK and avoid that (if possible) if we have seen any\n\t * duplicates. --piggy]\n\t *\n\t * When a receiver of a duplicate DATA chunk sends a SACK to a\n\t * multi- homed endpoint it MAY be beneficial to vary the\n\t * destination address and not use the source address of the\n\t * DATA chunk.  The reason being that receiving a duplicate\n\t * from a multi-homed endpoint might indicate that the return\n\t * path (as specified in the source address of the DATA chunk)\n\t * for the SACK is broken.\n\t *\n\t * [Send to the address from which we last received a DATA chunk.]\n\t */\n\tretval->transport = asoc->peer.last_data_from;\n\n\tretval->subh.sack_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(sack), &sack);\n\n\t/* Add the gap ack block information.   */\n\tif (num_gabs)\n\t\tsctp_addto_chunk(retval, sizeof(__u32) * num_gabs,\n\t\t\t\t gabs);\n\n\t/* Add the duplicate TSN information.  */\n\tif (num_dup_tsns) {\n\t\taptr->stats.idupchunks += num_dup_tsns;\n\t\tsctp_addto_chunk(retval, sizeof(__u32) * num_dup_tsns,\n\t\t\t\t sctp_tsnmap_get_dups(map));\n\t}\n\t/* Once we have a sack generated, check to see what our sack\n\t * generation is, if its 0, reset the transports to 0, and reset\n\t * the association generation to 1\n\t *\n\t * The idea is that zero is never used as a valid generation for the\n\t * association so no transport will match after a wrap event like this,\n\t * Until the next sack\n\t */\n\tif (++aptr->peer.sack_generation == 0) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports)\n\t\t\ttrans->sack_generation = 0;\n\t\taptr->peer.sack_generation = 1;\n\t}\nnodata:\n\treturn retval;\n}\n\n/* Make a SHUTDOWN chunk. */\nstruct sctp_chunk *sctp_make_shutdown(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_shutdownhdr_t shut;\n\t__u32 ctsn;\n\n\tctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\tshut.cum_tsn_ack = htonl(ctsn);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN, 0,\n\t\t\t\t   sizeof(sctp_shutdownhdr_t));\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.shutdown_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(shut), &shut);\n\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ACK back to where the SHUTDOWN came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_shutdown_complete(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t/* Set the T-bit if we have no association (vtag will be\n\t * reflected)\n\t */\n\tflags |= asoc ? 0 : SCTP_CHUNK_FLAG_T;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [Report SHUTDOWN COMPLETE back to where the SHUTDOWN ACK\n\t * came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n/* Create an ABORT.  Note that we set the T bit if we have no\n * association, except when responding to an INIT (sctpimpguide 2.41).\n */\nstruct sctp_chunk *sctp_make_abort(const struct sctp_association *asoc,\n\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t      const size_t hint)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t/* Set the T-bit if we have no association and 'chunk' is not\n\t * an INIT (vtag will be reflected).\n\t */\n\tif (!asoc) {\n\t\tif (chunk && chunk->chunk_hdr &&\n\t\t    chunk->chunk_hdr->type == SCTP_CID_INIT)\n\t\t\tflags = 0;\n\t\telse\n\t\t\tflags = SCTP_CHUNK_FLAG_T;\n\t}\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ABORT, flags, hint);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ABORT back to where the offender came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n/* Helper to create ABORT with a NO_USER_DATA error.  */\nstruct sctp_chunk *sctp_make_abort_no_data(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk, __u32 tsn)\n{\n\tstruct sctp_chunk *retval;\n\t__be32 payload;\n\n\tretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t)\n\t\t\t\t + sizeof(tsn));\n\n\tif (!retval)\n\t\tgoto no_mem;\n\n\t/* Put the tsn back into network byte order.  */\n\tpayload = htonl(tsn);\n\tsctp_init_cause(retval, SCTP_ERROR_NO_DATA, sizeof(payload));\n\tsctp_addto_chunk(retval, sizeof(payload), (const void *)&payload);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ABORT back to where the offender came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nno_mem:\n\treturn retval;\n}\n\n/* Helper to create ABORT with a SCTP_ERROR_USER_ABORT error.  */\nstruct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,\n\t\t\t\t\tconst struct msghdr *msg,\n\t\t\t\t\tsize_t paylen)\n{\n\tstruct sctp_chunk *retval;\n\tvoid *payload = NULL;\n\tint err;\n\n\tretval = sctp_make_abort(asoc, NULL, sizeof(sctp_errhdr_t) + paylen);\n\tif (!retval)\n\t\tgoto err_chunk;\n\n\tif (paylen) {\n\t\t/* Put the msg_iov together into payload.  */\n\t\tpayload = kmalloc(paylen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto err_payload;\n\n\t\terr = memcpy_fromiovec(payload, msg->msg_iov, paylen);\n\t\tif (err < 0)\n\t\t\tgoto err_copy;\n\t}\n\n\tsctp_init_cause(retval, SCTP_ERROR_USER_ABORT, paylen);\n\tsctp_addto_chunk(retval, paylen, payload);\n\n\tif (paylen)\n\t\tkfree(payload);\n\n\treturn retval;\n\nerr_copy:\n\tkfree(payload);\nerr_payload:\n\tsctp_chunk_free(retval);\n\tretval = NULL;\nerr_chunk:\n\treturn retval;\n}\n\n/* Append bytes to the end of a parameter.  Will panic if chunk is not big\n * enough.\n */\nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\n\t\t\t      const void *data)\n{\n\tvoid *target;\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\n\ttarget = skb_put(chunk->skb, len);\n\n\tif (data)\n\t\tmemcpy(target, data, len);\n\telse\n\t\tmemset(target, 0, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n/* Make an ABORT chunk with a PROTOCOL VIOLATION cause code. */\nstruct sctp_chunk *sctp_make_abort_violation(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk,\n\tconst __u8   *payload,\n\tconst size_t paylen)\n{\n\tstruct sctp_chunk  *retval;\n\tstruct sctp_paramhdr phdr;\n\n\tretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t) + paylen\n\t\t\t\t\t+ sizeof(sctp_paramhdr_t));\n\tif (!retval)\n\t\tgoto end;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, paylen\n\t\t\t\t\t+ sizeof(sctp_paramhdr_t));\n\n\tphdr.type = htons(chunk->chunk_hdr->type);\n\tphdr.length = chunk->chunk_hdr->length;\n\tsctp_addto_chunk(retval, paylen, payload);\n\tsctp_addto_param(retval, sizeof(sctp_paramhdr_t), &phdr);\n\nend:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_violation_paramlen(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk,\n\tstruct sctp_paramhdr *param)\n{\n\tstruct sctp_chunk *retval;\n\tstatic const char error[] = \"The following parameter had invalid length:\";\n\tsize_t payload_len = sizeof(error) + sizeof(sctp_errhdr_t) +\n\t\t\t\tsizeof(sctp_paramhdr_t);\n\n\tretval = sctp_make_abort(asoc, chunk, payload_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION,\n\t\t\tsizeof(error) + sizeof(sctp_paramhdr_t));\n\tsctp_addto_chunk(retval, sizeof(error), error);\n\tsctp_addto_param(retval, sizeof(sctp_paramhdr_t), param);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_violation_max_retrans(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tstatic const char error[] = \"Association exceeded its max_retans count\";\n\tsize_t payload_len = sizeof(error) + sizeof(sctp_errhdr_t);\n\n\tretval = sctp_make_abort(asoc, chunk, payload_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, sizeof(error));\n\tsctp_addto_chunk(retval, sizeof(error), error);\n\nnodata:\n\treturn retval;\n}\n\n/* Make a HEARTBEAT chunk.  */\nstruct sctp_chunk *sctp_make_heartbeat(const struct sctp_association *asoc,\n\t\t\t\t  const struct sctp_transport *transport)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_sender_hb_info_t hbinfo;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_HEARTBEAT, 0, sizeof(hbinfo));\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\thbinfo.param_hdr.type = SCTP_PARAM_HEARTBEAT_INFO;\n\thbinfo.param_hdr.length = htons(sizeof(sctp_sender_hb_info_t));\n\thbinfo.daddr = transport->ipaddr;\n\thbinfo.sent_at = jiffies;\n\thbinfo.hb_nonce = transport->hb_nonce;\n\n\t/* Cast away the 'const', as this is just telling the chunk\n\t * what transport it belongs to.\n\t */\n\tretval->transport = (struct sctp_transport *) transport;\n\tretval->subh.hbs_hdr = sctp_addto_chunk(retval, sizeof(hbinfo),\n\t\t\t\t\t\t&hbinfo);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_heartbeat_ack(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t\t      const void *payload, const size_t paylen)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval  = sctp_make_control(asoc, SCTP_CID_HEARTBEAT_ACK, 0, paylen);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.hbs_hdr = sctp_addto_chunk(retval, paylen, payload);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [HBACK back to where the HEARTBEAT came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* Create an Operation Error chunk with the specified space reserved.\n * This routine can be used for containing multiple causes in the chunk.\n */\nstatic struct sctp_chunk *sctp_make_op_error_space(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk,\n\tsize_t size)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ERROR, 0,\n\t\t\t\t   sizeof(sctp_errhdr_t) + size);\n\tif (!retval)\n\t\tgoto nodata;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* Create an Operation Error chunk of a fixed size,\n * specifically, max(asoc->pathmtu, SCTP_DEFAULT_MAXSEGMENT)\n * This is a helper function to allocate an error chunk for\n * for those invalid parameter codes in which we may not want\n * to report all the errors, if the incoming chunk is large\n */\nstatic inline struct sctp_chunk *sctp_make_op_error_fixed(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tsize_t size = asoc ? asoc->pathmtu : 0;\n\n\tif (!size)\n\t\tsize = SCTP_DEFAULT_MAXSEGMENT;\n\n\treturn sctp_make_op_error_space(asoc, chunk, size);\n}\n\n/* Create an Operation Error chunk.  */\nstruct sctp_chunk *sctp_make_op_error(const struct sctp_association *asoc,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t __be16 cause_code, const void *payload,\n\t\t\t\t size_t paylen, size_t reserve_tail)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_op_error_space(asoc, chunk, paylen + reserve_tail);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, cause_code, paylen + reserve_tail);\n\tsctp_addto_chunk(retval, paylen, payload);\n\tif (reserve_tail)\n\t\tsctp_addto_param(retval, reserve_tail, NULL);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_hmac *hmac_desc;\n\tstruct sctp_authhdr auth_hdr;\n\t__u8 *hmac;\n\n\t/* Get the first hmac that the peer told us to use */\n\thmac_desc = sctp_auth_asoc_get_hmac(asoc);\n\tif (unlikely(!hmac_desc))\n\t\treturn NULL;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_AUTH, 0,\n\t\t\thmac_desc->hmac_len + sizeof(sctp_authhdr_t));\n\tif (!retval)\n\t\treturn NULL;\n\n\tauth_hdr.hmac_id = htons(hmac_desc->hmac_id);\n\tauth_hdr.shkey_id = htons(asoc->active_key_id);\n\n\tretval->subh.auth_hdr = sctp_addto_chunk(retval, sizeof(sctp_authhdr_t),\n\t\t\t\t\t\t&auth_hdr);\n\n\thmac = skb_put(retval->skb, hmac_desc->hmac_len);\n\tmemset(hmac, 0, hmac_desc->hmac_len);\n\n\t/* Adjust the chunk header to include the empty MAC */\n\tretval->chunk_hdr->length =\n\t\thtons(ntohs(retval->chunk_hdr->length) + hmac_desc->hmac_len);\n\tretval->chunk_end = skb_tail_pointer(retval->skb);\n\n\treturn retval;\n}\n\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Turn an skb into a chunk.\n * FIXME: Eventually move the structure directly inside the skb->cb[].\n *\n * sctpimpguide-05.txt Section 2.8.2\n * M1) Each time a new DATA chunk is transmitted\n * set the 'TSN.Missing.Report' count for that TSN to 0. The\n * 'TSN.Missing.Report' count will be used to determine missing chunks\n * and when to fast retransmit.\n *\n */\nstruct sctp_chunk *sctp_chunkify(struct sk_buff *skb,\n\t\t\t    const struct sctp_association *asoc,\n\t\t\t    struct sock *sk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = kmem_cache_zalloc(sctp_chunk_cachep, GFP_ATOMIC);\n\n\tif (!retval)\n\t\tgoto nodata;\n\tif (!sk)\n\t\tpr_debug(\"%s: chunkifying skb:%p w/o an sk\\n\", __func__, skb);\n\n\tINIT_LIST_HEAD(&retval->list);\n\tretval->skb\t\t= skb;\n\tretval->asoc\t\t= (struct sctp_association *)asoc;\n\tretval->singleton\t= 1;\n\n\tretval->fast_retransmit = SCTP_CAN_FRTX;\n\n\t/* Polish the bead hole.  */\n\tINIT_LIST_HEAD(&retval->transmitted_list);\n\tINIT_LIST_HEAD(&retval->frag_list);\n\tSCTP_DBG_OBJCNT_INC(chunk);\n\tatomic_set(&retval->refcnt, 1);\n\nnodata:\n\treturn retval;\n}\n\n/* Set chunk->source and dest based on the IP header in chunk->skb.  */\nvoid sctp_init_addrs(struct sctp_chunk *chunk, union sctp_addr *src,\n\t\t     union sctp_addr *dest)\n{\n\tmemcpy(&chunk->source, src, sizeof(union sctp_addr));\n\tmemcpy(&chunk->dest, dest, sizeof(union sctp_addr));\n}\n\n/* Extract the source address from a chunk.  */\nconst union sctp_addr *sctp_source(const struct sctp_chunk *chunk)\n{\n\t/* If we have a known transport, use that.  */\n\tif (chunk->transport) {\n\t\treturn &chunk->transport->ipaddr;\n\t} else {\n\t\t/* Otherwise, extract it from the IP header.  */\n\t\treturn &chunk->source;\n\t}\n}\n\n/* Create a new chunk, setting the type and flags headers from the\n * arguments, reserving enough space for a 'paylen' byte payload.\n */\nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_chunkhdr_t *chunk_hdr;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\n\t/* No need to allocate LL here, as this is only a chunk. */\n\tskb = alloc_skb(WORD_ROUND(sizeof(sctp_chunkhdr_t) + paylen),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto nodata;\n\n\t/* Make room for the chunk header.  */\n\tchunk_hdr = (sctp_chunkhdr_t *)skb_put(skb, sizeof(sctp_chunkhdr_t));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(sctp_chunkhdr_t));\n\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(struct sctp_chunkhdr);\n\n\t/* Determine if the chunk needs to be authenticated */\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\n\treturn retval;\nnodata:\n\treturn NULL;\n}\n\nstatic struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen)\n{\n\treturn _sctp_make_chunk(asoc, SCTP_CID_DATA, flags, paylen);\n}\n\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen)\n{\n\tstruct sctp_chunk *chunk = _sctp_make_chunk(asoc, type, flags, paylen);\n\n\tif (chunk)\n\t\tsctp_control_set_owner_w(chunk);\n\n\treturn chunk;\n}\n\n/* Release the memory occupied by a chunk.  */\nstatic void sctp_chunk_destroy(struct sctp_chunk *chunk)\n{\n\tBUG_ON(!list_empty(&chunk->list));\n\tlist_del_init(&chunk->transmitted_list);\n\n\tconsume_skb(chunk->skb);\n\tconsume_skb(chunk->auth_chunk);\n\n\tSCTP_DBG_OBJCNT_DEC(chunk);\n\tkmem_cache_free(sctp_chunk_cachep, chunk);\n}\n\n/* Possibly, free the chunk.  */\nvoid sctp_chunk_free(struct sctp_chunk *chunk)\n{\n\t/* Release our reference on the message tracker. */\n\tif (chunk->msg)\n\t\tsctp_datamsg_put(chunk->msg);\n\n\tsctp_chunk_put(chunk);\n}\n\n/* Grab a reference to the chunk. */\nvoid sctp_chunk_hold(struct sctp_chunk *ch)\n{\n\tatomic_inc(&ch->refcnt);\n}\n\n/* Release a reference to the chunk. */\nvoid sctp_chunk_put(struct sctp_chunk *ch)\n{\n\tif (atomic_dec_and_test(&ch->refcnt))\n\t\tsctp_chunk_destroy(ch);\n}\n\n/* Append bytes to the end of a chunk.  Will panic if chunk is not big\n * enough.\n */\nvoid *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)\n{\n\tvoid *target;\n\tvoid *padding;\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tint padlen = WORD_ROUND(chunklen) - chunklen;\n\n\tpadding = skb_put(chunk->skb, padlen);\n\ttarget = skb_put(chunk->skb, len);\n\n\tmemset(padding, 0, padlen);\n\tmemcpy(target, data, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + padlen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n/* Append bytes to the end of a chunk. Returns NULL if there isn't sufficient\n * space in the chunk\n */\nstatic void *sctp_addto_chunk_fixed(struct sctp_chunk *chunk,\n\t\t\t\t    int len, const void *data)\n{\n\tif (skb_tailroom(chunk->skb) >= len)\n\t\treturn sctp_addto_chunk(chunk, len, data);\n\telse\n\t\treturn NULL;\n}\n\n/* Append bytes from user space to the end of a chunk.  Will panic if\n * chunk is not big enough.\n * Returns a kernel err value.\n */\nint sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,\n\t\t\t  struct iovec *data)\n{\n\t__u8 *target;\n\tint err = 0;\n\n\t/* Make room in chunk for data.  */\n\ttarget = skb_put(chunk->skb, len);\n\n\t/* Copy data (whole iovec) into chunk */\n\tif ((err = memcpy_fromiovecend(target, data, off, len)))\n\t\tgoto out;\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length =\n\t\thtons(ntohs(chunk->chunk_hdr->length) + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\nout:\n\treturn err;\n}\n\n/* Helper function to assign a TSN if needed.  This assumes that both\n * the data_hdr and association have already been assigned.\n */\nvoid sctp_chunk_assign_ssn(struct sctp_chunk *chunk)\n{\n\tstruct sctp_datamsg *msg;\n\tstruct sctp_chunk *lchunk;\n\tstruct sctp_stream *stream;\n\t__u16 ssn;\n\t__u16 sid;\n\n\tif (chunk->has_ssn)\n\t\treturn;\n\n\t/* All fragments will be on the same stream */\n\tsid = ntohs(chunk->subh.data_hdr->stream);\n\tstream = &chunk->asoc->ssnmap->out;\n\n\t/* Now assign the sequence number to the entire message.\n\t * All fragments must have the same stream sequence number.\n\t */\n\tmsg = chunk->msg;\n\tlist_for_each_entry(lchunk, &msg->chunks, frag_list) {\n\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\t\tssn = 0;\n\t\t} else {\n\t\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG)\n\t\t\t\tssn = sctp_ssn_next(stream, sid);\n\t\t\telse\n\t\t\t\tssn = sctp_ssn_peek(stream, sid);\n\t\t}\n\n\t\tlchunk->subh.data_hdr->ssn = htons(ssn);\n\t\tlchunk->has_ssn = 1;\n\t}\n}\n\n/* Helper function to assign a TSN if needed.  This assumes that both\n * the data_hdr and association have already been assigned.\n */\nvoid sctp_chunk_assign_tsn(struct sctp_chunk *chunk)\n{\n\tif (!chunk->has_tsn) {\n\t\t/* This is the last possible instant to\n\t\t * assign a TSN.\n\t\t */\n\t\tchunk->subh.data_hdr->tsn =\n\t\t\thtonl(sctp_association_get_next_tsn(chunk->asoc));\n\t\tchunk->has_tsn = 1;\n\t}\n}\n\n/* Create a CLOSED association to use with an incoming packet.  */\nstruct sctp_association *sctp_make_temp_asoc(const struct sctp_endpoint *ep,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_association *asoc;\n\tstruct sk_buff *skb;\n\tsctp_scope_t scope;\n\tstruct sctp_af *af;\n\n\t/* Create the bare association.  */\n\tscope = sctp_scope(sctp_source(chunk));\n\tasoc = sctp_association_new(ep, ep->base.sk, scope, gfp);\n\tif (!asoc)\n\t\tgoto nodata;\n\tasoc->temp = 1;\n\tskb = chunk->skb;\n\t/* Create an entry for the source address of the packet.  */\n\taf = sctp_get_af_specific(ipver2af(ip_hdr(skb)->version));\n\tif (unlikely(!af))\n\t\tgoto fail;\n\taf->from_skb(&asoc->c.peer_addr, skb, 1);\nnodata:\n\treturn asoc;\n\nfail:\n\tsctp_association_free(asoc);\n\treturn NULL;\n}\n\n/* Build a cookie representing asoc.\n * This INCLUDES the param header needed to put the cookie in the INIT ACK.\n */\nstatic sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *init_chunk,\n\t\t\t\t      int *cookie_len,\n\t\t\t\t      const __u8 *raw_addrs, int addrs_len)\n{\n\tsctp_cookie_param_t *retval;\n\tstruct sctp_signed_cookie *cookie;\n\tstruct scatterlist sg;\n\tint headersize, bodysize;\n\n\t/* Header size is static data prior to the actual cookie, including\n\t * any padding.\n\t */\n\theadersize = sizeof(sctp_paramhdr_t) +\n\t\t     (sizeof(struct sctp_signed_cookie) -\n\t\t      sizeof(struct sctp_cookie));\n\tbodysize = sizeof(struct sctp_cookie)\n\t\t+ ntohs(init_chunk->chunk_hdr->length) + addrs_len;\n\n\t/* Pad out the cookie to a multiple to make the signature\n\t * functions simpler to write.\n\t */\n\tif (bodysize % SCTP_COOKIE_MULTIPLE)\n\t\tbodysize += SCTP_COOKIE_MULTIPLE\n\t\t\t- (bodysize % SCTP_COOKIE_MULTIPLE);\n\t*cookie_len = headersize + bodysize;\n\n\t/* Clear this memory since we are sending this data structure\n\t * out on the network.\n\t */\n\tretval = kzalloc(*cookie_len, GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tcookie = (struct sctp_signed_cookie *) retval->body;\n\n\t/* Set up the parameter header.  */\n\tretval->p.type = SCTP_PARAM_STATE_COOKIE;\n\tretval->p.length = htons(*cookie_len);\n\n\t/* Copy the cookie part of the association itself.  */\n\tcookie->c = asoc->c;\n\t/* Save the raw address list length in the cookie. */\n\tcookie->c.raw_addr_list_len = addrs_len;\n\n\t/* Remember PR-SCTP capability. */\n\tcookie->c.prsctp_capable = asoc->peer.prsctp_capable;\n\n\t/* Save adaptation indication in the cookie. */\n\tcookie->c.adaptation_ind = asoc->peer.adaptation_ind;\n\n\t/* Set an expiration time for the cookie.  */\n\tcookie->c.expiration = ktime_add(asoc->cookie_life,\n\t\t\t\t\t ktime_get());\n\n\t/* Copy the peer's init packet.  */\n\tmemcpy(&cookie->c.peer_init[0], init_chunk->chunk_hdr,\n\t       ntohs(init_chunk->chunk_hdr->length));\n\n\t/* Copy the raw local address list of the association. */\n\tmemcpy((__u8 *)&cookie->c.peer_init[0] +\n\t       ntohs(init_chunk->chunk_hdr->length), raw_addrs, addrs_len);\n\n\tif (sctp_sk(ep->base.sk)->hmac) {\n\t\tstruct hash_desc desc;\n\n\t\t/* Sign the message.  */\n\t\tsg_init_one(&sg, &cookie->c, bodysize);\n\t\tdesc.tfm = sctp_sk(ep->base.sk)->hmac;\n\t\tdesc.flags = 0;\n\n\t\tif (crypto_hash_setkey(desc.tfm, ep->secret_key,\n\t\t\t\t       sizeof(ep->secret_key)) ||\n\t\t    crypto_hash_digest(&desc, &sg, bodysize, cookie->signature))\n\t\t\tgoto free_cookie;\n\t}\n\n\treturn retval;\n\nfree_cookie:\n\tkfree(retval);\nnodata:\n\t*cookie_len = 0;\n\treturn NULL;\n}\n\n/* Unpack the cookie from COOKIE ECHO chunk, recreating the association.  */\nstruct sctp_association *sctp_unpack_cookie(\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tstruct sctp_chunk *chunk, gfp_t gfp,\n\tint *error, struct sctp_chunk **errp)\n{\n\tstruct sctp_association *retval = NULL;\n\tstruct sctp_signed_cookie *cookie;\n\tstruct sctp_cookie *bear_cookie;\n\tint headersize, bodysize, fixed_size;\n\t__u8 *digest = ep->digest;\n\tstruct scatterlist sg;\n\tunsigned int len;\n\tsctp_scope_t scope;\n\tstruct sk_buff *skb = chunk->skb;\n\tktime_t kt;\n\tstruct hash_desc desc;\n\n\t/* Header size is static data prior to the actual cookie, including\n\t * any padding.\n\t */\n\theadersize = sizeof(sctp_chunkhdr_t) +\n\t\t     (sizeof(struct sctp_signed_cookie) -\n\t\t      sizeof(struct sctp_cookie));\n\tbodysize = ntohs(chunk->chunk_hdr->length) - headersize;\n\tfixed_size = headersize + sizeof(struct sctp_cookie);\n\n\t/* Verify that the chunk looks like it even has a cookie.\n\t * There must be enough room for our cookie and our peer's\n\t * INIT chunk.\n\t */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len < fixed_size + sizeof(struct sctp_chunkhdr))\n\t\tgoto malformed;\n\n\t/* Verify that the cookie has been padded out. */\n\tif (bodysize % SCTP_COOKIE_MULTIPLE)\n\t\tgoto malformed;\n\n\t/* Process the cookie.  */\n\tcookie = chunk->subh.cookie_hdr;\n\tbear_cookie = &cookie->c;\n\n\tif (!sctp_sk(ep->base.sk)->hmac)\n\t\tgoto no_hmac;\n\n\t/* Check the signature.  */\n\tsg_init_one(&sg, bear_cookie, bodysize);\n\tdesc.tfm = sctp_sk(ep->base.sk)->hmac;\n\tdesc.flags = 0;\n\n\tmemset(digest, 0x00, SCTP_SIGNATURE_SIZE);\n\tif (crypto_hash_setkey(desc.tfm, ep->secret_key,\n\t\t\t       sizeof(ep->secret_key)) ||\n\t    crypto_hash_digest(&desc, &sg, bodysize, digest)) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (memcmp(digest, cookie->signature, SCTP_SIGNATURE_SIZE)) {\n\t\t*error = -SCTP_IERROR_BAD_SIG;\n\t\tgoto fail;\n\t}\n\nno_hmac:\n\t/* IG Section 2.35.2:\n\t *  3) Compare the port numbers and the verification tag contained\n\t *     within the COOKIE ECHO chunk to the actual port numbers and the\n\t *     verification tag within the SCTP common header of the received\n\t *     packet. If these values do not match the packet MUST be silently\n\t *     discarded,\n\t */\n\tif (ntohl(chunk->sctp_hdr->vtag) != bear_cookie->my_vtag) {\n\t\t*error = -SCTP_IERROR_BAD_TAG;\n\t\tgoto fail;\n\t}\n\n\tif (chunk->sctp_hdr->source != bear_cookie->peer_addr.v4.sin_port ||\n\t    ntohs(chunk->sctp_hdr->dest) != bear_cookie->my_port) {\n\t\t*error = -SCTP_IERROR_BAD_PORTS;\n\t\tgoto fail;\n\t}\n\n\t/* Check to see if the cookie is stale.  If there is already\n\t * an association, there is no need to check cookie's expiration\n\t * for init collision case of lost COOKIE ACK.\n\t * If skb has been timestamped, then use the stamp, otherwise\n\t * use current time.  This introduces a small possibility that\n\t * that a cookie may be considered expired, but his would only slow\n\t * down the new association establishment instead of every packet.\n\t */\n\tif (sock_flag(ep->base.sk, SOCK_TIMESTAMP))\n\t\tkt = skb_get_ktime(skb);\n\telse\n\t\tkt = ktime_get();\n\n\tif (!asoc && ktime_before(bear_cookie->expiration, kt)) {\n\t\t/*\n\t\t * Section 3.3.10.3 Stale Cookie Error (3)\n\t\t *\n\t\t * Cause of error\n\t\t * ---------------\n\t\t * Stale Cookie Error:  Indicates the receipt of a valid State\n\t\t * Cookie that has expired.\n\t\t */\n\t\tlen = ntohs(chunk->chunk_hdr->length);\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\t\tif (*errp) {\n\t\t\tsuseconds_t usecs = ktime_to_us(ktime_sub(kt, bear_cookie->expiration));\n\t\t\t__be32 n = htonl(usecs);\n\n\t\t\tsctp_init_cause(*errp, SCTP_ERROR_STALE_COOKIE,\n\t\t\t\t\tsizeof(n));\n\t\t\tsctp_addto_chunk(*errp, sizeof(n), &n);\n\t\t\t*error = -SCTP_IERROR_STALE_COOKIE;\n\t\t} else\n\t\t\t*error = -SCTP_IERROR_NOMEM;\n\n\t\tgoto fail;\n\t}\n\n\t/* Make a new base association.  */\n\tscope = sctp_scope(sctp_source(chunk));\n\tretval = sctp_association_new(ep, ep->base.sk, scope, gfp);\n\tif (!retval) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Set up our peer's port number.  */\n\tretval->peer.port = ntohs(chunk->sctp_hdr->source);\n\n\t/* Populate the association from the cookie.  */\n\tmemcpy(&retval->c, bear_cookie, sizeof(*bear_cookie));\n\n\tif (sctp_assoc_set_bind_addr_from_cookie(retval, bear_cookie,\n\t\t\t\t\t\t GFP_ATOMIC) < 0) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Also, add the destination address. */\n\tif (list_empty(&retval->base.bind_addr.address_list)) {\n\t\tsctp_add_bind_addr(&retval->base.bind_addr, &chunk->dest,\n\t\t\t\tSCTP_ADDR_SRC, GFP_ATOMIC);\n\t}\n\n\tretval->next_tsn = retval->c.initial_tsn;\n\tretval->ctsn_ack_point = retval->next_tsn - 1;\n\tretval->addip_serial = retval->c.initial_tsn;\n\tretval->adv_peer_ack_point = retval->ctsn_ack_point;\n\tretval->peer.prsctp_capable = retval->c.prsctp_capable;\n\tretval->peer.adaptation_ind = retval->c.adaptation_ind;\n\n\t/* The INIT stuff will be done by the side effects.  */\n\treturn retval;\n\nfail:\n\tif (retval)\n\t\tsctp_association_free(retval);\n\n\treturn NULL;\n\nmalformed:\n\t/* Yikes!  The packet is either corrupt or deliberately\n\t * malformed.\n\t */\n\t*error = -SCTP_IERROR_MALFORMED;\n\tgoto fail;\n}\n\n/********************************************************************\n * 3rd Level Abstractions\n ********************************************************************/\n\nstruct __sctp_missing {\n\t__be32 num_missing;\n\t__be16 type;\n}  __packed;\n\n/*\n * Report a missing mandatory parameter.\n */\nstatic int sctp_process_missing_param(const struct sctp_association *asoc,\n\t\t\t\t      sctp_param_t paramtype,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\tstruct __sctp_missing report;\n\t__u16 len;\n\n\tlen = WORD_ROUND(sizeof(report));\n\n\t/* Make an ERROR chunk, preparing enough room for\n\t * returning multiple unknown parameters.\n\t */\n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\n\tif (*errp) {\n\t\treport.num_missing = htonl(1);\n\t\treport.type = paramtype;\n\t\tsctp_init_cause(*errp, SCTP_ERROR_MISS_PARAM,\n\t\t\t\tsizeof(report));\n\t\tsctp_addto_chunk(*errp, sizeof(report), &report);\n\t}\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}\n\n/* Report an Invalid Mandatory Parameter.  */\nstatic int sctp_process_inv_mandatory(const struct sctp_association *asoc,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\t/* Invalid Mandatory Parameter Error has no payload. */\n\n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, 0);\n\n\tif (*errp)\n\t\tsctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}\n\nstatic int sctp_process_inv_paramlength(const struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_paramhdr *param,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\t/* This is a fatal error.  Any accumulated non-fatal errors are\n\t * not reported.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t/* Create an error chunk and fill it in with our payload. */\n\t*errp = sctp_make_violation_paramlen(asoc, chunk, param);\n\n\treturn 0;\n}\n\n\n/* Do not attempt to handle the HOST_NAME parm.  However, do\n * send back an indicator to the peer.\n */\nstatic int sctp_process_hn_param(const struct sctp_association *asoc,\n\t\t\t\t union sctp_params param,\n\t\t\t\t struct sctp_chunk *chunk,\n\t\t\t\t struct sctp_chunk **errp)\n{\n\t__u16 len = ntohs(param.p->length);\n\n\t/* Processing of the HOST_NAME parameter will generate an\n\t * ABORT.  If we've accumulated any non-fatal errors, they\n\t * would be unrecognized parameters and we should not include\n\t * them in the ABORT.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\n\tif (*errp) {\n\t\tsctp_init_cause(*errp, SCTP_ERROR_DNS_FAILED, len);\n\t\tsctp_addto_chunk(*errp, len, param.v);\n\t}\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}\n\nstatic int sctp_verify_ext_param(struct net *net, union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\tint have_auth = 0;\n\tint have_asconf = 0;\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_AUTH:\n\t\t\thave_auth = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\thave_asconf = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* ADD-IP Security: The draft requires us to ABORT or ignore the\n\t * INIT/INIT-ACK if ADD-IP is listed, but AUTH is not.  Do this\n\t * only if ADD-IP is turned on and we are not backward-compatible\n\t * mode.\n\t */\n\tif (net->sctp.addip_noauth)\n\t\treturn 1;\n\n\tif (net->sctp.addip_enable && !have_auth && have_asconf)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t    union sctp_params param)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (net->sctp.prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\t    asoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\t/* if the peer reports AUTH, assume that he\n\t\t\t * supports AUTH.\n\t\t\t */\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* RFC 3.2.1 & the Implementers Guide 2.2.\n *\n * The Parameter Types are encoded such that the\n * highest-order two bits specify the action that must be\n * taken if the processing endpoint does not recognize the\n * Parameter Type.\n *\n * 00 - Stop processing this parameter; do not process any further\n * \tparameters within this chunk\n *\n * 01 - Stop processing this parameter, do not process any further\n *\tparameters within this chunk, and report the unrecognized\n *\tparameter in an 'Unrecognized Parameter' ERROR chunk.\n *\n * 10 - Skip this parameter and continue processing.\n *\n * 11 - Skip this parameter and continue processing but\n *\treport the unrecognized parameter in an\n *\t'Unrecognized Parameter' ERROR chunk.\n *\n * Return value:\n * \tSCTP_IERROR_NO_ERROR - continue with the chunk\n * \tSCTP_IERROR_ERROR    - stop and report an error.\n * \tSCTP_IERROR_NOMEME   - out of memory.\n */\nstatic sctp_ierror_t sctp_process_unk_param(const struct sctp_association *asoc,\n\t\t\t\t\t    union sctp_params param,\n\t\t\t\t\t    struct sctp_chunk *chunk,\n\t\t\t\t\t    struct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\t/* Fall through */\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\t/* Make an ERROR chunk, preparing enough room for\n\t\t * returning multiple unknown parameters.\n\t\t */\n\t\tif (NULL == *errp)\n\t\t\t*errp = sctp_make_op_error_fixed(asoc, chunk);\n\n\t\tif (*errp) {\n\t\t\tif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t\tWORD_ROUND(ntohs(param.p->length))))\n\t\t\t\tsctp_addto_chunk_fixed(*errp,\n\t\t\t\t\t\tWORD_ROUND(ntohs(param.p->length)),\n\t\t\t\t\t\tparam.v);\n\t\t} else {\n\t\t\t/* If there is no memory for generating the ERROR\n\t\t\t * report as specified, an ABORT will be triggered\n\t\t\t * to the peer and the association won't be\n\t\t\t * established.\n\t\t\t */\n\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/* Verify variable length parameters\n * Return values:\n * \tSCTP_IERROR_ABORT - trigger an ABORT\n * \tSCTP_IERROR_NOMEM - out of memory (abort)\n *\tSCTP_IERROR_ERROR - stop processing, trigger an ERROR\n * \tSCTP_IERROR_NO_ERROR - continue with the chunk\n */\nstatic sctp_ierror_t sctp_verify_param(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tsctp_cid_t cid,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **err_chunk)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\tint retval = SCTP_IERROR_NO_ERROR;\n\t__u16 n_elt, id = 0;\n\tint i;\n\n\t/* FIXME - This routine is not looking at each parameter per the\n\t * chunk type, i.e., unrecognized parameters should be further\n\t * identified based on the chunk id.\n\t */\n\n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\tcase SCTP_PARAM_STATE_COOKIE:\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tif (!sctp_verify_ext_param(net, param))\n\t\t\treturn SCTP_IERROR_ABORT;\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (net->sctp.addip_enable)\n\t\t\tbreak;\n\t\tgoto fallthrough;\n\n\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\t/* Tell the peer, we won't support this param.  */\n\t\tsctp_process_hn_param(asoc, param, chunk, err_chunk);\n\t\tretval = SCTP_IERROR_ABORT;\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (net->sctp.prsctp_enable)\n\t\t\tbreak;\n\t\tgoto fallthrough;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fallthrough;\n\n\t\t/* SCTP-AUTH: Secion 6.1\n\t\t * If the random number is not 32 byte long the association\n\t\t * MUST be aborted.  The ABORT chunk SHOULD contain the error\n\t\t * cause 'Protocol Violation'.\n\t\t */\n\t\tif (SCTP_AUTH_RANDOM_LENGTH !=\n\t\t\tntohs(param.p->length) - sizeof(sctp_paramhdr_t)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t\tchunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fallthrough;\n\n\t\t/* SCTP-AUTH: Section 3.2\n\t\t * The CHUNKS parameter MUST be included once in the INIT or\n\t\t *  INIT-ACK chunk if the sender wants to receive authenticated\n\t\t *  chunks.  Its maximum length is 260 bytes.\n\t\t */\n\t\tif (260 < ntohs(param.p->length)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t     chunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fallthrough;\n\n\t\thmacs = (struct sctp_hmac_algo_param *)param.p;\n\t\tn_elt = (ntohs(param.p->length) - sizeof(sctp_paramhdr_t)) >> 1;\n\n\t\t/* SCTP-AUTH: Section 6.1\n\t\t * The HMAC algorithm based on SHA-1 MUST be supported and\n\t\t * included in the HMAC-ALGO parameter.\n\t\t */\n\t\tfor (i = 0; i < n_elt; i++) {\n\t\t\tid = ntohs(hmacs->hmac_ids[i]);\n\n\t\t\tif (id == SCTP_AUTH_HMAC_ID_SHA1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (id != SCTP_AUTH_HMAC_ID_SHA1) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p, chunk,\n\t\t\t\t\t\t     err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\nfallthrough:\n\tdefault:\n\t\tpr_debug(\"%s: unrecognized param:%d for chunk:%d\\n\",\n\t\t\t __func__, ntohs(param.p->type), cid);\n\n\t\tretval = sctp_process_unk_param(asoc, param, chunk, err_chunk);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\n/* Verify the INIT packet before we process it.  */\nint sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,\n\t\t     const struct sctp_association *asoc, sctp_cid_t cid,\n\t\t     sctp_init_chunk_t *peer_init, struct sctp_chunk *chunk,\n\t\t     struct sctp_chunk **errp)\n{\n\tunion sctp_params param;\n\tbool has_cookie = false;\n\tint result;\n\n\t/* Check for missing mandatory parameters. Note: Initial TSN is\n\t * also mandatory, but is not checked here since the valid range\n\t * is 0..2**32-1. RFC4960, section 3.3.3.\n\t */\n\tif (peer_init->init_hdr.num_outbound_streams == 0 ||\n\t    peer_init->init_hdr.num_inbound_streams == 0 ||\n\t    peer_init->init_hdr.init_tag == 0 ||\n\t    ntohl(peer_init->init_hdr.a_rwnd) < SCTP_DEFAULT_MINWINDOW)\n\t\treturn sctp_process_inv_mandatory(asoc, chunk, errp);\n\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\t\tif (param.p->type == SCTP_PARAM_STATE_COOKIE)\n\t\t\thas_cookie = true;\n\t}\n\n\t/* There is a possibility that a parameter length was bad and\n\t * in that case we would have stoped walking the parameters.\n\t * The current param.p would point at the bad one.\n\t * Current consensus on the mailing list is to generate a PROTOCOL\n\t * VIOLATION error.  We build the ERROR chunk here and let the normal\n\t * error handling code build and send the packet.\n\t */\n\tif (param.v != (void *)chunk->chunk_end)\n\t\treturn sctp_process_inv_paramlength(asoc, param.p, chunk, errp);\n\n\t/* The only missing mandatory param possible today is\n\t * the state cookie for an INIT-ACK chunk.\n\t */\n\tif ((SCTP_CID_INIT_ACK == cid) && !has_cookie)\n\t\treturn sctp_process_missing_param(asoc, SCTP_PARAM_STATE_COOKIE,\n\t\t\t\t\t\t  chunk, errp);\n\n\t/* Verify all the variable length parameters */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\t\tresult = sctp_verify_param(net, ep, asoc, param, cid,\n\t\t\t\t\t   chunk, errp);\n\t\tswitch (result) {\n\t\tcase SCTP_IERROR_ABORT:\n\t\tcase SCTP_IERROR_NOMEM:\n\t\t\treturn 0;\n\t\tcase SCTP_IERROR_ERROR:\n\t\t\treturn 1;\n\t\tcase SCTP_IERROR_NO_ERROR:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} /* for (loop through all parameters) */\n\n\treturn 1;\n}\n\n/* Unpack the parameters in an INIT packet into an association.\n * Returns 0 on failure, else success.\n * FIXME:  This is an association method.\n */\nint sctp_process_init(struct sctp_association *asoc, struct sctp_chunk *chunk,\n\t\t      const union sctp_addr *peer_addr,\n\t\t      sctp_init_chunk_t *peer_init, gfp_t gfp)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tunion sctp_params param;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tstruct sctp_af *af;\n\tunion sctp_addr addr;\n\tchar *cookie;\n\tint src_match = 0;\n\n\t/* We must include the address that the INIT packet came from.\n\t * This is the only address that matters for an INIT packet.\n\t * When processing a COOKIE ECHO, we retrieve the from address\n\t * of the INIT from the cookie.\n\t */\n\n\t/* This implementation defaults to making the first transport\n\t * added as the primary transport.  The source address seems to\n\t * be a a better choice than any of the embedded addresses.\n\t */\n\tif (!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\n\t\tgoto nomem;\n\n\tif (sctp_cmp_addr_exact(sctp_source(chunk), peer_addr))\n\t\tsrc_match = 1;\n\n\t/* Process the initialization parameters.  */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\t\tif (!src_match && (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\n\t\t    param.p->type == SCTP_PARAM_IPV6_ADDRESS)) {\n\t\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\t\taf->from_addr_param(&addr, param.addr,\n\t\t\t\t\t    chunk->sctp_hdr->source, 0);\n\t\t\tif (sctp_cmp_addr_exact(sctp_source(chunk), &addr))\n\t\t\t\tsrc_match = 1;\n\t\t}\n\n\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))\n\t\t\tgoto clean_up;\n\t}\n\n\t/* source address of chunk may not match any valid address */\n\tif (!src_match)\n\t\tgoto clean_up;\n\n\t/* AUTH: After processing the parameters, make sure that we\n\t * have all the required info to potentially do authentications.\n\t */\n\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\n\t\t\t\t\t!asoc->peer.peer_hmacs))\n\t\tasoc->peer.auth_capable = 0;\n\n\t/* In a non-backward compatible mode, if the peer claims\n\t * support for ADD-IP but not AUTH,  the ADD-IP spec states\n\t * that we MUST ABORT the association. Section 6.  The section\n\t * also give us an option to silently ignore the packet, which\n\t * is what we'll do here.\n\t */\n\tif (!net->sctp.addip_noauth &&\n\t     (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\n\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\n\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |\n\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);\n\t\tasoc->peer.asconf_capable = 0;\n\t\tgoto clean_up;\n\t}\n\n\t/* Walk list of transports, removing transports in the UNKNOWN state. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state == SCTP_UNKNOWN) {\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t}\n\t}\n\n\t/* The fixed INIT headers are always in network byte\n\t * order.\n\t */\n\tasoc->peer.i.init_tag =\n\t\tntohl(peer_init->init_hdr.init_tag);\n\tasoc->peer.i.a_rwnd =\n\t\tntohl(peer_init->init_hdr.a_rwnd);\n\tasoc->peer.i.num_outbound_streams =\n\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\tasoc->peer.i.num_inbound_streams =\n\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\tasoc->peer.i.initial_tsn =\n\t\tntohl(peer_init->init_hdr.initial_tsn);\n\n\t/* Apply the upper bounds for output streams based on peer's\n\t * number of inbound streams.\n\t */\n\tif (asoc->c.sinit_num_ostreams  >\n\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {\n\t\tasoc->c.sinit_num_ostreams =\n\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\t}\n\n\tif (asoc->c.sinit_max_instreams >\n\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {\n\t\tasoc->c.sinit_max_instreams =\n\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\t}\n\n\t/* Copy Initiation tag from INIT to VT_peer in cookie.   */\n\tasoc->c.peer_vtag = asoc->peer.i.init_tag;\n\n\t/* Peer Rwnd   : Current calculated value of the peer's rwnd.  */\n\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;\n\n\t/* Copy cookie in case we need to resend COOKIE-ECHO. */\n\tcookie = asoc->peer.cookie;\n\tif (cookie) {\n\t\tasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);\n\t\tif (!asoc->peer.cookie)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily\n\t * high (for example, implementations MAY use the size of the receiver\n\t * advertised window).\n\t */\n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;\n\t}\n\n\t/* Set up the TSN tracking pieces.  */\n\tif (!sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t\tasoc->peer.i.initial_tsn, gfp))\n\t\tgoto clean_up;\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * The stream sequence number in all the streams shall start\n\t * from 0 when the association is established.  Also, when the\n\t * stream sequence number reaches the value 65535 the next\n\t * stream sequence number shall be set to 0.\n\t */\n\n\t/* Allocate storage for the negotiated streams if it is not a temporary\n\t * association.\n\t */\n\tif (!asoc->temp) {\n\t\tint error;\n\n\t\tasoc->ssnmap = sctp_ssnmap_new(asoc->c.sinit_max_instreams,\n\t\t\t\t\t       asoc->c.sinit_num_ostreams, gfp);\n\t\tif (!asoc->ssnmap)\n\t\t\tgoto clean_up;\n\n\t\terror = sctp_assoc_set_id(asoc, gfp);\n\t\tif (error)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* ADDIP Section 4.1 ASCONF Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) A serial number should be assigned to the Chunk. The serial\n\t * number should be a monotonically increasing number. All serial\n\t * numbers are defined to be initialized at the start of the\n\t * association to the same value as the Initial TSN.\n\t */\n\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\n\treturn 1;\n\nclean_up:\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state != SCTP_ACTIVE)\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t}\n\nnomem:\n\treturn 0;\n}\n\n\n/* Update asoc with the option described in param.\n *\n * RFC2960 3.3.2.1 Optional/Variable Length Parameters in INIT\n *\n * asoc is the association to update.\n * param is the variable length parameter to use for update.\n * cid tells us if this is an INIT, INIT ACK or COOKIE ECHO.\n * If the current packet is an INIT we want to minimize the amount of\n * work we do.  In particular, we should not build transport\n * structures for the addresses.\n */\nstatic int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tunion sctp_addr addr;\n\tint i;\n\t__u16 sat;\n\tint retval = 1;\n\tsctp_scope_t scope;\n\ttime_t stale;\n\tstruct sctp_af *af;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *t;\n\tstruct sctp_endpoint *ep = asoc->ep;\n\n\t/* We maintain all INIT parameters in network byte order all the\n\t * time.  This allows us to not worry about whether the parameters\n\t * came from a fresh INIT, and INIT ACK, or were stored in a cookie.\n\t */\n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (PF_INET6 != asoc->base.sk->sk_family)\n\t\t\tbreak;\n\t\tgoto do_addr_param;\n\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t/* v4 addresses are not allowed on v6-only socket */\n\t\tif (ipv6_only_sock(asoc->base.sk))\n\t\t\tbreak;\ndo_addr_param:\n\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\taf->from_addr_param(&addr, param.addr, htons(asoc->peer.port), 0);\n\t\tscope = sctp_scope(peer_addr);\n\t\tif (sctp_in_scope(net, &addr, scope))\n\t\t\tif (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))\n\t\t\t\treturn 0;\n\t\tbreak;\n\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\t\tif (!net->sctp.cookie_preserve_enable)\n\t\t\tbreak;\n\n\t\tstale = ntohl(param.life->lifespan_increment);\n\n\t\t/* Suggested Cookie Life span increment's unit is msec,\n\t\t * (1/1000sec).\n\t\t */\n\t\tasoc->cookie_life = ktime_add_ms(asoc->cookie_life, stale);\n\t\tbreak;\n\n\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\tpr_debug(\"%s: unimplemented SCTP_HOST_NAME_ADDRESS\\n\", __func__);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\t\t/* Turn off the default values first so we'll know which\n\t\t * ones are really set by the peer.\n\t\t */\n\t\tasoc->peer.ipv4_address = 0;\n\t\tasoc->peer.ipv6_address = 0;\n\n\t\t/* Assume that peer supports the address family\n\t\t * by which it sends a packet.\n\t\t */\n\t\tif (peer_addr->sa.sa_family == AF_INET6)\n\t\t\tasoc->peer.ipv6_address = 1;\n\t\telse if (peer_addr->sa.sa_family == AF_INET)\n\t\t\tasoc->peer.ipv4_address = 1;\n\n\t\t/* Cycle through address types; avoid divide by 0. */\n\t\tsat = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\t\tif (sat)\n\t\t\tsat /= sizeof(__u16);\n\n\t\tfor (i = 0; i < sat; ++i) {\n\t\t\tswitch (param.sat->types[i]) {\n\t\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\t\tasoc->peer.ipv4_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\t\tif (PF_INET6 == asoc->base.sk->sk_family)\n\t\t\t\t\tasoc->peer.ipv6_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\t\t\tasoc->peer.hostname_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Just ignore anything else.  */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_STATE_COOKIE:\n\t\tasoc->peer.cookie_len =\n\t\t\tntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\t\tasoc->peer.cookie = param.cookie->body;\n\t\tbreak;\n\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\t\t/* Would be odd to receive, but it causes no problems. */\n\t\tbreak;\n\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\t\t/* Rejected during verify stage. */\n\t\tbreak;\n\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\t\tasoc->peer.ecn_capable = 1;\n\t\tbreak;\n\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tasoc->peer.adaptation_ind = ntohl(param.aind->adaptation_ind);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (!net->sctp.addip_enable)\n\t\t\tgoto fall_through;\n\n\t\taddr_param = param.v + sizeof(sctp_addip_param_t);\n\n\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\taf->from_addr_param(&addr, addr_param,\n\t\t\t\t    htons(asoc->peer.port), 0);\n\n\t\t/* if the address is invalid, we can't process it.\n\t\t * XXX: see spec for what to do.\n\t\t */\n\t\tif (!af->addr_valid(&addr, NULL, NULL))\n\t\t\tbreak;\n\n\t\tt = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tsctp_assoc_set_primary(asoc, t);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tsctp_process_ext_param(asoc, param);\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (net->sctp.prsctp_enable) {\n\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through */\n\t\tgoto fall_through;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t/* Save peer's random parameter */\n\t\tasoc->peer.peer_random = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_random) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t/* Save peer's HMAC list */\n\t\tasoc->peer.peer_hmacs = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_hmacs) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set the default HMAC the peer requested*/\n\t\tsctp_auth_asoc_set_default_hmac(asoc, param.hmac_algo);\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\tasoc->peer.peer_chunks = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_chunks)\n\t\t\tretval = 0;\n\t\tbreak;\nfall_through:\n\tdefault:\n\t\t/* Any unrecognized parameters should have been caught\n\t\t * and handled by sctp_verify_param() which should be\n\t\t * called prior to this routine.  Simply log the error\n\t\t * here.\n\t\t */\n\t\tpr_debug(\"%s: ignoring param:%d for association:%p.\\n\",\n\t\t\t __func__, ntohs(param.p->type), asoc);\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/* Select a new verification tag.  */\n__u32 sctp_generate_tag(const struct sctp_endpoint *ep)\n{\n\t/* I believe that this random number generator complies with RFC1750.\n\t * A tag of 0 is reserved for special cases (e.g. INIT).\n\t */\n\t__u32 x;\n\n\tdo {\n\t\tget_random_bytes(&x, sizeof(__u32));\n\t} while (x == 0);\n\n\treturn x;\n}\n\n/* Select an initial TSN to send during startup.  */\n__u32 sctp_generate_tsn(const struct sctp_endpoint *ep)\n{\n\t__u32 retval;\n\n\tget_random_bytes(&retval, sizeof(__u32));\n\treturn retval;\n}\n\n/*\n * ADDIP 3.1.1 Address Configuration Change Chunk (ASCONF)\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     | Type = 0xC1   |  Chunk Flags  |      Chunk Length             |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Serial Number                           |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                    Address Parameter                          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                     ASCONF Parameter #1                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     \\                                                               \\\n *     /                             ....                              /\n *     \\                                                               \\\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                     ASCONF Parameter #N                       |\n *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Address Parameter and other parameter will not be wrapped in this function\n */\nstatic struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\n\t\t\t\t\t   union sctp_addr *addr,\n\t\t\t\t\t   int vparam_len)\n{\n\tsctp_addiphdr_t asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\tunion sctp_addr_param addrparam;\n\tint addrlen;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlength += addrlen;\n\n\t/* Create the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\tasconf.serial = htonl(asoc->addip_serial++);\n\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\n\treturn retval;\n}\n\n/* ADDIP\n * 3.2.1 Add IP Address\n * \t0                   1                   2                   3\n * \t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |        Type = 0xC001          |    Length = Variable          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |               ASCONF-Request Correlation ID                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Address Parameter                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * 3.2.2 Delete IP Address\n * \t0                   1                   2                   3\n * \t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |        Type = 0xC002          |    Length = Variable          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |               ASCONF-Request Correlation ID                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Address Parameter                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n */\nstruct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *asoc,\n\t\t\t\t\t      union sctp_addr\t      *laddr,\n\t\t\t\t\t      struct sockaddr\t      *addrs,\n\t\t\t\t\t      int\t\t      addrcnt,\n\t\t\t\t\t      __be16\t\t      flags)\n{\n\tsctp_addip_param_t\tparam;\n\tstruct sctp_chunk\t*retval;\n\tunion sctp_addr_param\taddr_param;\n\tunion sctp_addr\t\t*addr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tint\t\t\tparamlen = sizeof(param);\n\tint\t\t\taddr_param_len = 0;\n\tint \t\t\ttotallen = 0;\n\tint \t\t\ti;\n\tint\t\t\tdel_pickup = 0;\n\n\t/* Get total length of all the address parameters. */\n\taddr_buf = addrs;\n\tfor (i = 0; i < addrcnt; i++) {\n\t\taddr = addr_buf;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\n\t\ttotallen += paramlen;\n\t\ttotallen += addr_param_len;\n\n\t\taddr_buf += af->sockaddr_len;\n\t\tif (asoc->asconf_addr_del_pending && !del_pickup) {\n\t\t\t/* reuse the parameter length from the same scope one */\n\t\t\ttotallen += paramlen;\n\t\t\ttotallen += addr_param_len;\n\t\t\tdel_pickup = 1;\n\n\t\t\tpr_debug(\"%s: picked same-scope del_pending addr, \"\n\t\t\t\t \"totallen for all addresses is %d\\n\",\n\t\t\t\t __func__, totallen);\n\t\t}\n\t}\n\n\t/* Create an asconf chunk with the required length. */\n\tretval = sctp_make_asconf(asoc, laddr, totallen);\n\tif (!retval)\n\t\treturn NULL;\n\n\t/* Add the address parameters to the asconf chunk. */\n\taddr_buf = addrs;\n\tfor (i = 0; i < addrcnt; i++) {\n\t\taddr = addr_buf;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\t\tparam.param_hdr.type = flags;\n\t\tparam.param_hdr.length = htons(paramlen + addr_param_len);\n\t\tparam.crr_id = i;\n\n\t\tsctp_addto_chunk(retval, paramlen, &param);\n\t\tsctp_addto_chunk(retval, addr_param_len, &addr_param);\n\n\t\taddr_buf += af->sockaddr_len;\n\t}\n\tif (flags == SCTP_PARAM_ADD_IP && del_pickup) {\n\t\taddr = asoc->asconf_addr_del_pending;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\t\tparam.param_hdr.type = SCTP_PARAM_DEL_IP;\n\t\tparam.param_hdr.length = htons(paramlen + addr_param_len);\n\t\tparam.crr_id = i;\n\n\t\tsctp_addto_chunk(retval, paramlen, &param);\n\t\tsctp_addto_chunk(retval, addr_param_len, &addr_param);\n\t}\n\treturn retval;\n}\n\n/* ADDIP\n * 3.2.4 Set Primary IP Address\n *\t0                   1                   2                   3\n *\t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |        Type =0xC004           |    Length = Variable          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |               ASCONF-Request Correlation ID                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Address Parameter                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Create an ASCONF chunk with Set Primary IP address parameter.\n */\nstruct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\n\t\t\t\t\t     union sctp_addr *addr)\n{\n\tsctp_addip_param_t\tparam;\n\tstruct sctp_chunk \t*retval;\n\tint \t\t\tlen = sizeof(param);\n\tunion sctp_addr_param\taddrparam;\n\tint\t\t\taddrlen;\n\tstruct sctp_af\t\t*af = sctp_get_af_specific(addr->v4.sin_family);\n\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlen += addrlen;\n\n\t/* Create the chunk and make asconf header. */\n\tretval = sctp_make_asconf(asoc, addr, len);\n\tif (!retval)\n\t\treturn NULL;\n\n\tparam.param_hdr.type = SCTP_PARAM_SET_PRIMARY;\n\tparam.param_hdr.length = htons(len);\n\tparam.crr_id = 0;\n\n\tsctp_addto_chunk(retval, sizeof(param), &param);\n\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\n\treturn retval;\n}\n\n/* ADDIP 3.1.2 Address Configuration Acknowledgement Chunk (ASCONF-ACK)\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     | Type = 0x80   |  Chunk Flags  |      Chunk Length             |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Serial Number                           |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                 ASCONF Parameter Response#1                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     \\                                                               \\\n *     /                             ....                              /\n *     \\                                                               \\\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                 ASCONF Parameter Response#N                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Create an ASCONF_ACK chunk with enough space for the parameter responses.\n */\nstatic struct sctp_chunk *sctp_make_asconf_ack(const struct sctp_association *asoc,\n\t\t\t\t\t       __u32 serial, int vparam_len)\n{\n\tsctp_addiphdr_t\t\tasconf;\n\tstruct sctp_chunk\t*retval;\n\tint\t\t\tlength = sizeof(asconf) + vparam_len;\n\n\t/* Create the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF_ACK, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\tasconf.serial = htonl(serial);\n\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\n\treturn retval;\n}\n\n/* Add response parameters to an ASCONF_ACK chunk. */\nstatic void sctp_add_asconf_response(struct sctp_chunk *chunk, __be32 crr_id,\n\t\t\t      __be16 err_code, sctp_addip_param_t *asconf_param)\n{\n\tsctp_addip_param_t \tack_param;\n\tsctp_errhdr_t\t\terr_param;\n\tint\t\t\tasconf_param_len = 0;\n\tint\t\t\terr_param_len = 0;\n\t__be16\t\t\tresponse_type;\n\n\tif (SCTP_ERROR_NO_ERROR == err_code) {\n\t\tresponse_type = SCTP_PARAM_SUCCESS_REPORT;\n\t} else {\n\t\tresponse_type = SCTP_PARAM_ERR_CAUSE;\n\t\terr_param_len = sizeof(err_param);\n\t\tif (asconf_param)\n\t\t\tasconf_param_len =\n\t\t\t\t ntohs(asconf_param->param_hdr.length);\n\t}\n\n\t/* Add Success Indication or Error Cause Indication parameter. */\n\tack_param.param_hdr.type = response_type;\n\tack_param.param_hdr.length = htons(sizeof(ack_param) +\n\t\t\t\t\t   err_param_len +\n\t\t\t\t\t   asconf_param_len);\n\tack_param.crr_id = crr_id;\n\tsctp_addto_chunk(chunk, sizeof(ack_param), &ack_param);\n\n\tif (SCTP_ERROR_NO_ERROR == err_code)\n\t\treturn;\n\n\t/* Add Error Cause parameter. */\n\terr_param.cause = err_code;\n\terr_param.length = htons(err_param_len + asconf_param_len);\n\tsctp_addto_chunk(chunk, err_param_len, &err_param);\n\n\t/* Add the failed TLV copied from ASCONF chunk. */\n\tif (asconf_param)\n\t\tsctp_addto_chunk(chunk, asconf_param_len, asconf_param);\n}\n\n/* Process a asconf parameter. */\nstatic __be16 sctp_process_asconf_param(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf,\n\t\t\t\t       sctp_addip_param_t *asconf_param)\n{\n\tstruct sctp_transport *peer;\n\tstruct sctp_af *af;\n\tunion sctp_addr\taddr;\n\tunion sctp_addr_param *addr_param;\n\n\taddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\n\n\tif (asconf_param->param_hdr.type != SCTP_PARAM_ADD_IP &&\n\t    asconf_param->param_hdr.type != SCTP_PARAM_DEL_IP &&\n\t    asconf_param->param_hdr.type != SCTP_PARAM_SET_PRIMARY)\n\t\treturn SCTP_ERROR_UNKNOWN_PARAM;\n\n\tswitch (addr_param->p.type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (!asoc->peer.ipv6_address)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\t\tbreak;\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\tif (!asoc->peer.ipv4_address)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\t}\n\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\tif (unlikely(!af))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\taf->from_addr_param(&addr, addr_param, htons(asoc->peer.port), 0);\n\n\t/* ADDIP 4.2.1  This parameter MUST NOT contain a broadcast\n\t * or multicast address.\n\t * (note: wildcard is permitted and requires special handling so\n\t *  make sure we check for that)\n\t */\n\tif (!af->is_any(&addr) && !af->addr_valid(&addr, NULL, asconf->skb))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t/* Section 4.2.1:\n\t\t * If the address 0.0.0.0 or ::0 is provided, the source\n\t\t * address of the packet MUST be added.\n\t\t */\n\t\tif (af->is_any(&addr))\n\t\t\tmemcpy(&addr, &asconf->source, sizeof(addr));\n\n\t\t/* ADDIP 4.3 D9) If an endpoint receives an ADD IP address\n\t\t * request and does not have the local resources to add this\n\t\t * new address to the association, it MUST return an Error\n\t\t * Cause TLV set to the new error code 'Operation Refused\n\t\t * Due to Resource Shortage'.\n\t\t */\n\n\t\tpeer = sctp_assoc_add_peer(asoc, &addr, GFP_ATOMIC, SCTP_UNCONFIRMED);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_RSRC_LOW;\n\n\t\t/* Start the heartbeat timer. */\n\t\tif (!mod_timer(&peer->hb_timer, sctp_transport_timeout(peer)))\n\t\t\tsctp_transport_hold(peer);\n\t\tasoc->new_transport = peer;\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\t/* ADDIP 4.3 D7) If a request is received to delete the\n\t\t * last remaining IP address of a peer endpoint, the receiver\n\t\t * MUST send an Error Cause TLV with the error cause set to the\n\t\t * new error code 'Request to Delete Last Remaining IP Address'.\n\t\t */\n\t\tif (asoc->peer.transport_count == 1)\n\t\t\treturn SCTP_ERROR_DEL_LAST_IP;\n\n\t\t/* ADDIP 4.3 D8) If a request is received to delete an IP\n\t\t * address which is also the source address of the IP packet\n\t\t * which contained the ASCONF chunk, the receiver MUST reject\n\t\t * this request. To reject the request the receiver MUST send\n\t\t * an Error Cause TLV set to the new error code 'Request to\n\t\t * Delete Source IP Address'\n\t\t */\n\t\tif (sctp_cmp_addr_exact(&asconf->source, &addr))\n\t\t\treturn SCTP_ERROR_DEL_SRC_IP;\n\n\t\t/* Section 4.2.2\n\t\t * If the address 0.0.0.0 or ::0 is provided, all\n\t\t * addresses of the peer except\tthe source address of the\n\t\t * packet MUST be deleted.\n\t\t */\n\t\tif (af->is_any(&addr)) {\n\t\t\tsctp_assoc_set_primary(asoc, asconf->transport);\n\t\t\tsctp_assoc_del_nonprimary_peers(asoc,\n\t\t\t\t\t\t\tasconf->transport);\n\t\t} else\n\t\t\tsctp_assoc_del_peer(asoc, &addr);\n\t\tbreak;\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t/* ADDIP Section 4.2.4\n\t\t * If the address 0.0.0.0 or ::0 is provided, the receiver\n\t\t * MAY mark the source address of the packet as its\n\t\t * primary.\n\t\t */\n\t\tif (af->is_any(&addr))\n\t\t\tmemcpy(&addr.v4, sctp_source(asconf), sizeof(addr));\n\n\t\tpeer = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tbreak;\n\t}\n\n\treturn SCTP_ERROR_NO_ERROR;\n}\n\n/* Verify the ASCONF packet before we process it.  */\nint sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp) {\n\tsctp_addip_param_t *asconf_param;\n\tunion sctp_params param;\n\tint length, plen;\n\n\tparam.v = (sctp_paramhdr_t *) param_hdr;\n\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n\t\tlength = ntohs(param.p->length);\n\t\t*errp = param.p;\n\n\t\tif (param.v > chunk_end - length ||\n\t\t    length < sizeof(sctp_paramhdr_t))\n\t\t\treturn 0;\n\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n\t\t\t    sizeof(sctp_paramhdr_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn 0;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tparam.v += WORD_ROUND(length);\n\t}\n\n\tif (param.v != chunk_end)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/* Process an incoming ASCONF chunk with the next expected serial no. and\n * return an ASCONF_ACK chunk to be sent in response.\n */\nstruct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tstruct sctp_chunk\t*asconf_ack;\n\n\t__be16\terr_code;\n\tint\tlength = 0;\n\tint\tchunk_len;\n\t__u32\tserial;\n\tint\tall_param_pass = 1;\n\n\tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\thdr = (sctp_addiphdr_t *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t/* Skip the addiphdr and store a pointer to address parameter.  */\n\tlength = sizeof(sctp_addiphdr_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\n\t/* Skip the address parameter and store a pointer to the first\n\t * asconf parameter.\n\t */\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tchunk_len -= length;\n\n\t/* create an ASCONF_ACK chunk.\n\t * Based on the definitions of parameters, we know that the size of\n\t * ASCONF_ACK parameters are less than or equal to the fourfold of ASCONF\n\t * parameters.\n\t */\n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\n\t/* Process the TLVs contained within the ASCONF chunk. */\n\twhile (chunk_len > 0) {\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     asconf_param);\n\t\t/* ADDIP 4.1 A7)\n\t\t * If an error response is received for a TLV parameter,\n\t\t * all TLVs with no response before the failed TLV are\n\t\t * considered successful if not reported.  All TLVs after\n\t\t * the failed response are considered unsuccessful unless\n\t\t * a specific success indication is present for the parameter.\n\t\t */\n\t\tif (SCTP_ERROR_NO_ERROR != err_code)\n\t\t\tall_param_pass = 0;\n\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack,\n\t\t\t\t\t\t asconf_param->crr_id, err_code,\n\t\t\t\t\t\t asconf_param);\n\n\t\t/* ADDIP 4.3 D11) When an endpoint receiving an ASCONF to add\n\t\t * an IP address sends an 'Out of Resource' in its response, it\n\t\t * MUST also fail any subsequent add or delete requests bundled\n\t\t * in the ASCONF.\n\t\t */\n\t\tif (SCTP_ERROR_RSRC_LOW == err_code)\n\t\t\tgoto done;\n\n\t\t/* Move to the next ASCONF param. */\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tchunk_len -= length;\n\t}\n\ndone:\n\tasoc->peer.addip_serial++;\n\n\t/* If we are sending a new ASCONF_ACK hold a reference to it in assoc\n\t * after freeing the reference to old asconf ack if any.\n\t */\n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\n\treturn asconf_ack;\n}\n\n/* Process a asconf parameter that is successfully acked. */\nstatic void sctp_asconf_param_success(struct sctp_association *asoc,\n\t\t\t\t     sctp_addip_param_t *asconf_param)\n{\n\tstruct sctp_af *af;\n\tunion sctp_addr\taddr;\n\tstruct sctp_bind_addr *bp = &asoc->base.bind_addr;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *transport;\n\tstruct sctp_sockaddr_entry *saddr;\n\n\taddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\n\n\t/* We have checked the packet before, so we do not check again.\t*/\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\taf->from_addr_param(&addr, addr_param, htons(bp->port), 0);\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t/* This is always done in BH context with a socket lock\n\t\t * held, so the list can not change.\n\t\t */\n\t\tlocal_bh_disable();\n\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\tif (sctp_cmp_addr_exact(&saddr->a, &addr))\n\t\t\t\tsaddr->state = SCTP_ADDR_SRC;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\ttransport->dst = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\tlocal_bh_disable();\n\t\tsctp_del_bind_addr(bp, &addr);\n\t\tif (asoc->asconf_addr_del_pending != NULL &&\n\t\t    sctp_cmp_addr_exact(asoc->asconf_addr_del_pending, &addr)) {\n\t\t\tkfree(asoc->asconf_addr_del_pending);\n\t\t\tasoc->asconf_addr_del_pending = NULL;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\ttransport->dst = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/* Get the corresponding ASCONF response error code from the ASCONF_ACK chunk\n * for the given asconf parameter.  If there is no response for this parameter,\n * return the error code based on the third argument 'no_err'.\n * ADDIP 4.1\n * A7) If an error response is received for a TLV parameter, all TLVs with no\n * response before the failed TLV are considered successful if not reported.\n * All TLVs after the failed response are considered unsuccessful unless a\n * specific success indication is present for the parameter.\n */\nstatic __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\n\t/* Skip the addiphdr from the asconf_ack chunk and store a pointer to\n\t * the first asconf_ack parameter.\n\t */\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\n\treturn err_code;\n}\n\n/* Process an incoming ASCONF_ACK chunk against the cached last ASCONF chunk. */\nint sctp_process_asconf_ack(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *asconf_ack)\n{\n\tstruct sctp_chunk\t*asconf = asoc->addip_last_asconf;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tint\tlength = 0;\n\tint\tasconf_len = asconf->skb->len;\n\tint\tall_param_pass = 0;\n\tint\tno_err = 1;\n\tint\tretval = 0;\n\t__be16\terr_code = SCTP_ERROR_NO_ERROR;\n\n\t/* Skip the chunkhdr and addiphdr from the last asconf sent and store\n\t * a pointer to address parameter.\n\t */\n\tlength = sizeof(sctp_addip_chunk_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tasconf_len -= length;\n\n\t/* Skip the address parameter in the last asconf sent and store a\n\t * pointer to the first asconf parameter.\n\t */\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tasconf_len -= length;\n\n\t/* ADDIP 4.1\n\t * A8) If there is no response(s) to specific TLV parameter(s), and no\n\t * failures are indicated, then all request(s) are considered\n\t * successful.\n\t */\n\tif (asconf_ack->skb->len == sizeof(sctp_addiphdr_t))\n\t\tall_param_pass = 1;\n\n\t/* Process the TLVs contained in the last sent ASCONF chunk. */\n\twhile (asconf_len > 0) {\n\t\tif (all_param_pass)\n\t\t\terr_code = SCTP_ERROR_NO_ERROR;\n\t\telse {\n\t\t\terr_code = sctp_get_asconf_response(asconf_ack,\n\t\t\t\t\t\t\t    asconf_param,\n\t\t\t\t\t\t\t    no_err);\n\t\t\tif (no_err && (SCTP_ERROR_NO_ERROR != err_code))\n\t\t\t\tno_err = 0;\n\t\t}\n\n\t\tswitch (err_code) {\n\t\tcase SCTP_ERROR_NO_ERROR:\n\t\t\tsctp_asconf_param_success(asoc, asconf_param);\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_RSRC_LOW:\n\t\t\tretval = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_UNKNOWN_PARAM:\n\t\t\t/* Disable sending this type of asconf parameter in\n\t\t\t * future.\n\t\t\t */\n\t\t\tasoc->peer.addip_disabled_mask |=\n\t\t\t\tasconf_param->param_hdr.type;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_REQ_REFUSED:\n\t\tcase SCTP_ERROR_DEL_LAST_IP:\n\t\tcase SCTP_ERROR_DEL_SRC_IP:\n\t\tdefault:\n\t\t\t break;\n\t\t}\n\n\t\t/* Skip the processed asconf parameter and move to the next\n\t\t * one.\n\t\t */\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tasconf_len -= length;\n\t}\n\n\tif (no_err && asoc->src_out_of_asoc_ok) {\n\t\tasoc->src_out_of_asoc_ok = 0;\n\t\tsctp_transport_immediate_rtx(asoc->peer.primary_path);\n\t}\n\n\t/* Free the cached last sent asconf chunk. */\n\tlist_del_init(&asconf->transmitted_list);\n\tsctp_chunk_free(asconf);\n\tasoc->addip_last_asconf = NULL;\n\n\treturn retval;\n}\n\n/* Make a FWD TSN chunk. */\nstruct sctp_chunk *sctp_make_fwdtsn(const struct sctp_association *asoc,\n\t\t\t\t    __u32 new_cum_tsn, size_t nstreams,\n\t\t\t\t    struct sctp_fwdtsn_skip *skiplist)\n{\n\tstruct sctp_chunk *retval = NULL;\n\tstruct sctp_fwdtsn_hdr ftsn_hdr;\n\tstruct sctp_fwdtsn_skip skip;\n\tsize_t hint;\n\tint i;\n\n\thint = (nstreams + 1) * sizeof(__u32);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_FWD_TSN, 0, hint);\n\n\tif (!retval)\n\t\treturn NULL;\n\n\tftsn_hdr.new_cum_tsn = htonl(new_cum_tsn);\n\tretval->subh.fwdtsn_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ftsn_hdr), &ftsn_hdr);\n\n\tfor (i = 0; i < nstreams; i++) {\n\t\tskip.stream = skiplist[i].stream;\n\t\tskip.ssn = skiplist[i].ssn;\n\t\tsctp_addto_chunk(retval, sizeof(skip), &skip);\n\t}\n\n\treturn retval;\n}\n", "/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n * Copyright (c) 2002      Nokia Corp.\n *\n * This is part of the SCTP Linux Kernel Implementation.\n *\n * These are the state functions for the state machine.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Mathew Kotowsky       <kotowsky@sctp.org>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Hui Huang \t    <hui.huang@nokia.com>\n *    Dajiang Zhang \t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Kevin Gao\t\t    <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport);\n\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen);\n\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\n\n/* Small helper function that checks if the chunk length\n * is of the appropriate length.  The 'required_length' argument\n * is set to be the size of a specific chunk we are testing.\n * Return Values:  1 = Valid length\n * \t\t   0 = Invalid length\n *\n */\nstatic inline int\nsctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**********************************************************\n * These are the state functions for handling chunk events.\n **********************************************************/\n\n/*\n * Process the final SHUTDOWN COMPLETE.\n *\n * Section: 4 (C) (diagram), 9.2\n * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify\n * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be\n * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint\n * should stop the T2-shutdown timer and remove all knowledge of the\n * association (and thus the association enters the CLOSED state).\n *\n * Verification Tag: 8.5.1(C), sctpimpguide 2.41.\n * C) Rules for packet carrying SHUTDOWN COMPLETE:\n * ...\n * - The receiver of a SHUTDOWN COMPLETE shall accept the packet\n *   if the Verification Tag field of the packet matches its own tag and\n *   the T bit is not set\n *   OR\n *   it is set to its peer's tag and the T bit is set in the Chunk\n *   Flags.\n *   Otherwise, the receiver MUST silently discard the packet\n *   and take no further action.  An endpoint MUST ignore the\n *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_4_C(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t  void *arg,\n\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * Respond to a normal INIT chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, B\n * B) \"Z\" shall respond immediately with an INIT ACK chunk.  The\n *    destination IP address of the INIT ACK MUST be set to the source\n *    IP address of the INIT to which this INIT ACK is responding.  In\n *    the response, besides filling in other parameters, \"Z\" must set the\n *    Verification Tag field to Tag_A, and also provide its own\n *    Verification Tag (Tag_Z) in the Initiate Tag field.\n *\n * Verification Tag: Must be 0.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * Normally, this would cause an ABORT with a Protocol Violation\n\t * error, but since we don't have an association, we'll\n\t * just discard the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the INIT is coming toward a closing socket, we'll send back\n\t * and ABORT.  Essentially, this catches the race of INIT being\n\t * backloged to the socket at the same time as the user isses close().\n\t * Since the socket and all its associations are going away, we\n\t * can treat this OOTB\n\t */\n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t/* The call, sctp_process_init(), can fail on memory allocation.  */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note:  After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources, nor keep any states for the\n\t * new association.  Otherwise, \"Z\" will be vulnerable to resource\n\t * attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal INIT ACK chunk.\n * We are the side that is initiating the association.\n *\n * Section: 5.1 Normal Establishment of an Association, C\n * C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-init\n *    timer and leave COOKIE-WAIT state. \"A\" shall then send the State\n *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start\n *    the T1-cookie timer, and enter the COOKIE-ECHOED state.\n *\n *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound\n *    DATA chunks, but it MUST be the first chunk in the packet and\n *    until the COOKIE ACK is returned the sender MUST NOT send any\n *    other packets to the peer.\n *\n * Verification Tag: 3.3.3\n *   If the value of the Initiate Tag in a received INIT ACK chunk is\n *   found to be 0, the receiver MUST treat it as an error and close the\n *   association by transmitting an ABORT.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_init_chunk_t *initchunk;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT-ACK chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tsctp_error_t error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes.  If there are no causes,\n\t\t * then there wasn't enough memory.  Just terminate\n\t\t * the association.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t/* SCTP-AUTH, Section 6.3:\n\t\t *    It should be noted that if the receiver wants to tear\n\t\t *    down an association in an authenticated way only, the\n\t\t *    handling of malformed packets should not result in\n\t\t *    tearing down the association.\n\t\t *\n\t\t * This means that if we only want to abort associations\n\t\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t\t * can't destroy this association just because the packet\n\t\t * was malformed.\n\t\t */\n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t/* Tag the variable length parameters.  Note that we never\n\t * convert the parameters in an INIT chunk.\n\t */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tinitchunk = (sctp_init_chunk_t *) chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t/* Reset init error count upon receipt of INIT-ACK.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall stop the T1-init timer and leave\n\t * COOKIE-WAIT state.  \"A\" shall then ... start the T1-cookie\n\t * timer, and enter the COOKIE-ECHOED state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t/* SCTP-AUTH: genereate the assocition shared keys so that\n\t * we can potentially signe the COOKIE-ECHO.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall then send the State Cookie received in the\n\t * INIT ACK chunk in a COOKIE ECHO chunk, ...\n\t */\n\t/* If there is any errors to report, send the ERROR chunk generated\n\t * for unknown parameters as well.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Respond to a normal COOKIE ECHO chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, D\n * D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply\n *    with a COOKIE ACK chunk after building a TCB and moving to\n *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with\n *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK\n *    chunk MUST be the first chunk in the packet.\n *\n *   IMPLEMENTATION NOTE: An implementation may choose to send the\n *   Communication Up notification to the SCTP user upon reception\n *   of a valid COOKIE ECHO chunk.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * D) Rules for packet carrying a COOKIE ECHO\n *\n * - When sending a COOKIE ECHO, the endpoint MUST use the value of the\n *   Initial Tag received in the INIT ACK.\n *\n * - The receiver of a COOKIE ECHO follows the procedures in Section 5.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* Make sure that we and the peer are AUTH capable */\n\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal COOKIE ACK chunk.\n * We are the side that is being asked for an association.\n *\n * RFC 2960 5.1 Normal Establishment of an Association\n *\n * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie\n *    timer. It may also notify its ULP about the successful\n *    establishment of the association with a Communication Up\n *    notification (see Section 10).\n *\n * Verification Tag:\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Verify that the chunk length for the COOKIE-ACK is OK.\n\t * If we don't do this, any bundled chunks may be junked.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Reset init error count upon receipt of COOKIE-ACK,\n\t * to avoid problems with the managemement of this\n\t * counter in stale cookie situations when a transition back\n\t * from the COOKIE-ECHOED state to the COOKIE-WAIT\n\t * state is performed.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move\n\t * from the COOKIE-ECHOED state to the ESTABLISHED state,\n\t * stopping the T1-cookie timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* It may also notify its ULP about the successful\n\t * establishment of the association with a Communication Up\n\t * notification (see Section 10).\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Generate and sendout a heartbeat packet.  */\nstatic sctp_disposition_t sctp_sf_heartbeat(const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Send a heartbeat to our peer.  */\n\treply = sctp_make_heartbeat(asoc, transport);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Set rto_pending indicating that an RTT measurement\n\t * is started with this heartbeat chunk.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Generate a HEARTBEAT packet on the given transport.  */\nsctp_disposition_t sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t/* Section 3.3.5.\n\t * The Sender-specific Heartbeat Info field should normally include\n\t * information about the sender's current time when this HEARTBEAT\n\t * chunk is sent and the destination transport address to which this\n\t * HEARTBEAT is sent (see Section 8.3).\n\t */\n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Set transport error counter and association error counter\n\t\t * when sending heartbeat.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an heartbeat request.\n *\n * Section: 8.3 Path Heartbeat\n * The receiver of the HEARTBEAT should immediately respond with a\n * HEARTBEAT ACK that contains the Heartbeat Information field copied\n * from the received HEARTBEAT chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * When receiving an SCTP packet, the endpoint MUST ensure that the\n * value in the Verification Tag field of the received SCTP packet\n * matches its own Tag. If the received Verification Tag value does not\n * match the receiver's own tag value, the receiver shall silently\n * discard the packet and shall not process it any further except for\n * those cases listed in Section 8.5.1 below.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tsctp_paramhdr_t *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_heartbeat_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* 8.3 The receiver of the HEARTBEAT should immediately\n\t * respond with a HEARTBEAT ACK that contains the Heartbeat\n\t * Information field copied from the received HEARTBEAT chunk.\n\t */\n\tchunk->subh.hb_hdr = (sctp_heartbeathdr_t *) chunk->skb->data;\n\tparam_hdr = (sctp_paramhdr_t *) chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the returning HEARTBEAT ACK.\n *\n * Section: 8.3 Path Heartbeat\n * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n * should clear the error counter of the destination transport\n * address to which the HEARTBEAT was sent, and mark the destination\n * transport address as active if it is not so marked. The endpoint may\n * optionally report to the upper layer when an inactive destination\n * address is marked as active due to the reception of the latest\n * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also\n * clear the association overall error count as well (as defined\n * in section 8.1).\n *\n * The receiver of the HEARTBEAT ACK should also perform an RTT\n * measurement for that destination transport address using the time\n * value carried in the HEARTBEAT ACK chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunion sctp_addr from_addr;\n\tstruct sctp_transport *link;\n\tsctp_sender_hb_info_t *hbinfo;\n\tunsigned long max_interval;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t) +\n\t\t\t\t\t    sizeof(sctp_sender_hb_info_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\n\t/* Make sure that the length of the parameter is what we expect */\n\tif (ntohs(hbinfo->param_hdr.length) !=\n\t\t\t\t    sizeof(sctp_sender_hb_info_t)) {\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t/* This should never happen, but lets log it if so.  */\n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Validate the 64-bit random nonce. */\n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t/* Check if the timestamp looks valid.  */\n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tpr_debug(\"%s: HEARTBEAT ACK with invalid timestamp received \"\n\t\t\t \"for transport:%p\\n\", __func__, link);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of\n\t * the HEARTBEAT should clear the error counter of the\n\t * destination transport address to which the HEARTBEAT was\n\t * sent and mark the destination transport address as active if\n\t * it is not so marked.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Helper function to send out an abort for the restart\n * condition.\n */\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\n\t/* Build the error on the stack.   We are way to malloc crazy\n\t * throughout the code today.\n\t */\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\n\t/* Copy into a parm format. */\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t/* Assign to the control socket. */\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t/* Association is NULL since this may be a restart attack and we\n\t * want to send back the attacker's vtag.\n\t */\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* Discard the rest of the inbound packet. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t/* Even if there is no memory, treat as a failure so\n\t * the packet will get dropped.\n\t */\n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n/* A restart is occurring, check to make sure no new addresses\n * are being added as we may be under a takeover attack.\n */\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct net *net = sock_net(new_asoc->base.sk);\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t/* Implementor's Guide - Section 5.2.2\n\t * ...\n\t * Before responding the endpoint MUST check to see if the\n\t * unexpected INIT adds new addresses to the association. If new\n\t * addresses are added to the association, the endpoint MUST respond\n\t * with an ABORT..\n\t */\n\n\t/* Search through all current addresses and make sure\n\t * we aren't adding any new ones.\n\t */\n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Return success if all addresses were found. */\n\treturn ret;\n}\n\n/* Populate the verification/tie tags based on overlapping INIT\n * scenario.\n *\n * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.\n */\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n/*\n * Compare vtag/tietag values to determine unexpected COOKIE-ECHO\n * handling action.\n *\n * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.\n *\n * Returns value representing action to be taken.   These action values\n * correspond to Action/Description values in RFC 2960, Table 2.\n */\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t/* In this case, the peer may have restarted.  */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t/* Collision case B. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t/* Collision case D. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t/* Collision case C. */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t/* No match to any of the special cases; discard this packet. */\n\treturn 'E';\n}\n\n/* Common helper routine for both duplicate and simulataneous INIT\n * chunk handling.\n */\nstatic sctp_disposition_t sctp_sf_do_unexpected_init(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * In this case, we generate a protocol violation since we have\n\t * an association established.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/*\n\t * Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t * FIXME:  We are copying parameters from the endpoint not the\n\t * association.\n\t */\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t/* In the outbound INIT ACK the endpoint MUST copy its current\n\t * Verification Tag and Peers Verification tag into a reserved\n\t * place (local tie-tag and per tie-tag) within the state cookie.\n\t */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.   Do not do this check for COOKIE-WAIT state,\n\t * since there are no peer addresses to check against.\n\t * Upon return an ABORT will have been sent if needed.\n\t */\n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note: After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources for this new association.\n\t * Otherwise, \"Z\" will be vulnerable to resource attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n/*\n * Handle simultaneous INIT.\n * This means we started an INIT and then we got an INIT request from\n * our peer.\n *\n * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n * This usually indicates an initialization collision, i.e., each\n * endpoint is attempting, at about the same time, to establish an\n * association with the other endpoint.\n *\n * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n * endpoint MUST respond with an INIT ACK using the same parameters it\n * sent in its original INIT chunk (including its Verification Tag,\n * unchanged). These original parameters are combined with those from the\n * newly received INIT chunk. The endpoint shall also generate a State\n * Cookie with the INIT ACK. The endpoint uses the parameters sent in its\n * INIT to calculate the State Cookie.\n *\n * After that, the endpoint MUST NOT change its state, the T1-init\n * timer shall be left running and the corresponding TCB MUST NOT be\n * destroyed. The normal procedures for handling State Cookies when\n * a TCB exists will resolve the duplicate INITs to a single association.\n *\n * For an endpoint that is in the COOKIE-ECHOED state it MUST populate\n * its Tie-Tags with the Tag information of itself and its peer (see\n * section 5.2.2 for a description of the Tie-Tags).\n *\n * Verification Tag: Not explicit, but an INIT can not have a valid\n * verification tag, so we skip the check.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle duplicated INIT messages.  These are usually delayed\n * restransmissions.\n *\n * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,\n * COOKIE-ECHOED and COOKIE-WAIT\n *\n * Unless otherwise stated, upon reception of an unexpected INIT for\n * this association, the endpoint shall generate an INIT ACK with a\n * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n * current Verification Tag and peer's Verification Tag into a reserved\n * place within the state cookie.  We shall refer to these locations as\n * the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n * containing this INIT ACK MUST carry a Verification Tag value equal to\n * the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n * MUST contain a new Initiation Tag (randomly generated see Section\n * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the\n * existing parameters of the association (e.g. number of outbound\n * streams) into the INIT ACK and cookie.\n *\n * After sending out the INIT ACK, the endpoint shall take no further\n * actions, i.e., the existing association, including its current state,\n * and the corresponding TCB MUST NOT be changed.\n *\n * Note: Only when a TCB exists and the association is not in a COOKIE-\n * WAIT state are the Tie-Tags populated.  For a normal association INIT\n * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n * set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n * State Cookie are populated as specified in section 5.2.1.\n *\n * Verification Tag: Not specified, but an INIT has no way of knowing\n * what the verification tag could be, so we ignore it.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_2_dupinit(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n/*\n * Unexpected INIT-ACK handler.\n *\n * Section 5.2.3\n * If an INIT ACK received by an endpoint in any state other than the\n * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.\n * An unexpected INIT ACK usually indicates the processing of an old or\n * duplicated INIT chunk.\n*/\nsctp_disposition_t sctp_sf_do_5_2_3_initack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg, sctp_cmd_seq_t *commands)\n{\n\t/* Per the above section, we'll discard the chunk if we have an\n\t * endpoint.  If this is an OOTB INIT-ACK, treat it as such.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\n/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action 'A')\n *\n * Section 5.2.4\n *  A)  In this case, the peer may have restarted.\n */\nstatic sctp_disposition_t sctp_sf_do_dupcook_a(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\tsctp_disposition_t disposition;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.  Though this is a pretty complicated attack\n\t * since you'd have to get inside the cookie.\n\t */\n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands)) {\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes\n\t * the peer has restarted (Action A), it MUST NOT setup a new\n\t * association but instead resend the SHUTDOWN ACK and send an ERROR\n\t * chunk with a \"Cookie Received while Shutting Down\" error cause to\n\t * its peer.\n\t*/\n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\tSCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\tchunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked\n\t * data. Consider the optional choice of resending of this data.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue\n\t * and ASCONF-ACK cache.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Report association restart to upper layer. */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Update the content of current association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tif (sctp_state(asoc, SHUTDOWN_PENDING) &&\n\t    (sctp_sstate(asoc->base.sk, CLOSING) ||\n\t     sock_flag(asoc->base.sk, SOCK_DEAD))) {\n\t\t/* if were currently in SHUTDOWN_PENDING, but the socket\n\t\t * has been closed by user, don't transition to ESTABLISHED.\n\t\t * Instead trigger SHUTDOWN bundled with COOKIE_ACK.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t\treturn sctp_sf_do_9_2_start_shutdown(net, ep, asoc,\n\t\t\t\t\t\t     SCTP_ST_CHUNK(0), NULL,\n\t\t\t\t\t\t     commands);\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'B')\n *\n * Section 5.2.4\n *   B) In this case, both sides may be attempting to start an association\n *      at about the same time but the peer endpoint started its INIT\n *      after responding to the local endpoint's INIT\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Update the content of current association.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'C')\n *\n * Section 5.2.4\n *  C) In this case, the local endpoint's cookie has arrived late.\n *     Before it arrived, the local endpoint sent an INIT and received an\n *     INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n *     but a new tag of its own.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_c(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t/* The cookie should be silently discarded.\n\t * The endpoint SHOULD NOT change states and should leave\n\t * any timers running.\n\t */\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action 'D')\n *\n * Section 5.2.4\n *\n * D) When both local and remote tags match the endpoint should always\n *    enter the ESTABLISHED state, if it has not already done so.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_d(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t/* Clarification from Implementor's Guide:\n\t * D) When both local and remote tags match the endpoint should\n\t * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.\n\t * It should stop any cookie timer that may be running and send\n\t * a COOKIE ACK.\n\t */\n\n\t/* Don't accidentally move back into established state. */\n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t\t *\n\t\t * D) IMPLEMENTATION NOTE: An implementation may choose\n\t\t * to send the Communication Up notification to the\n\t\t * SCTP user upon reception of a valid COOKIE\n\t\t * ECHO chunk.\n\t\t */\n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t/* Sockets API Draft Section 5.3.1.6\n\t\t * When a peer sends a Adaptation Layer Indication parameter,\n\t\t * SCTP delivers this notification to inform the application\n\t\t * that of the peers requested adaptation layer.\n\t\t */\n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying\n * chunk was retransmitted and then delayed in the network.\n *\n * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists\n *\n * Verification Tag: None.  Do cookie validation.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tint error = 0;\n\tchar action;\n\tstruct sctp_chunk *err_chk_p;\n\n\t/* Make sure that the chunk has a valid length from the protocol\n\t * perspective.  In this case check to make sure we have at least\n\t * enough for the chunk header.  Cookie length verification is\n\t * done later.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie\n\t * of a duplicate COOKIE ECHO match the Verification Tags of the\n\t * current association, consider the State Cookie valid even if\n\t * the lifespan is exceeded.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t/* Compare the tie_tag in cookie with the verification tag of\n\t * current association.\n\t */\n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A': /* Association restart. */\n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B': /* Collision case B. */\n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C': /* Collision case C. */\n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D': /* Collision case D. */\n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault: /* Discard packet for all others. */\n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t/* Delete the tempory new association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t/* Restore association pointer to provide SCTP command interpeter\n\t * with a valid context in case it needs to manipulate\n\t * the queues */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-PENDING state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_pending_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_sent_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Stop the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-ACK-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an Error received in COOKIE_ECHOED state.\n *\n * Only handle the error type of stale COOKIE Error, the other errors will\n * be ignored.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_cookie_echoed_err(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle a Stale COOKIE Error\n *\n * Section: 5.2.6 Handle Stale COOKIE Error\n * If the association is in the COOKIE-ECHOED state, the endpoint may elect\n * one of the following three alternatives.\n * ...\n * 3) Send a new INIT chunk to the endpoint, adding a Cookie\n *    Preservative parameter requesting an extension to the lifetime of\n *    the State Cookie. When calculating the time extension, an\n *    implementation SHOULD use the RTT information measured based on the\n *    previous COOKIE ECHO / ERROR exchange, and should add no more\n *    than 1 second beyond the measured RTT, due to long State Cookie\n *    lifetimes making the endpoint more subject to a replay attack.\n *\n * Verification Tag:  Not explicit, but safe to ignore.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\ttime_t stale;\n\tsctp_cookie_preserve_param_t bht;\n\tsctp_errhdr_t *err;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (sctp_errhdr_t *)(chunk->skb->data);\n\n\t/* When calculating the time extension, an implementation\n\t * SHOULD use the RTT information measured based on the\n\t * previous COOKIE ECHO / ERROR exchange, and should add no\n\t * more than 1 second beyond the measured RTT, due to long\n\t * State Cookie lifetimes making the endpoint more subject to\n\t * a replay attack.\n\t * Measure of Staleness's unit is usec. (1/1000000 sec)\n\t * Suggested Cookie Life-span Increment's unit is msec.\n\t * (1/1000 sec)\n\t * In general, if you use the suggested cookie life, the value\n\t * found in the field of measure of staleness should be doubled\n\t * to give ample time to retransmit the new cookie and thus\n\t * yield a higher probability of success on the reattempt.\n\t */\n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(sctp_errhdr_t)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t/* Build that new INIT chunk.  */\n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t/* Clear peer's init_tag cached in assoc as we are sending a new INIT */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t/* Stop pending T3-rtx and heartbeat timers */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t/* Delete non-primary peer ip addresses since we are transitioning\n\t * back to the COOKIE-WAIT state\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t/* If we've sent any data bundled with COOKIE-ECHO we will need to\n\t * resend\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.\n *\n * Section: 9.1\n * After checking the Verification Tag, the receiving endpoint shall\n * remove the association from its record, and shall report the\n * termination to its upper layer.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * B) Rules for packet carrying ABORT:\n *\n *  - The endpoint shall always fill in the Verification Tag field of the\n *    outbound packet with the destination endpoint's tag value if it\n *    is known.\n *\n *  - If the ABORT is sent in response to an OOTB packet, the endpoint\n *    MUST follow the procedure described in Section 8.4.\n *\n *  - The receiver MUST accept the packet if the Verification Tag\n *    matches either its own tag, OR the tag of its peer. Otherwise, the\n *    receiver MUST silently discard the packet and take no further\n *    action.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr)) {\n\n\t\tsctp_errhdr_t *err;\n\t\tsctp_walk_errors(err, chunk->chunk_hdr);\n\t\tif ((void *)err != (void *)chunk->chunk_end)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t/* ASSOC_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * Process an ABORT.  (COOKIE-WAIT state)\n *\n * See sctp_sf_do_9_1_abort() above.\n */\nsctp_disposition_t sctp_sf_cookie_wait_abort(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n/*\n * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)\n */\nsctp_disposition_t sctp_sf_cookie_wait_icmp_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n/*\n * Process an ABORT.  (COOKIE-ECHOED state)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_abort(struct net *net,\n\t\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t\t       void *arg,\n\t\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Stop T1 timer and abort association with \"INIT failed\".\n *\n * This is common code called by several sctp_sf_*_abort() functions above.\n */\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_do_9_2_shut\n *\n * Section: 9.2\n * Upon the reception of the SHUTDOWN, the peer endpoint shall\n *  - enter the SHUTDOWN-RECEIVED state,\n *\n *  - stop accepting new data from its SCTP user\n *\n *  - verify, by checking the Cumulative TSN Ack field of the chunk,\n *    that all its outstanding DATA chunks have been received by the\n *    SHUTDOWN sender.\n *\n * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT\n * send a SHUTDOWN in response to a ULP request. And should discard\n * subsequent SHUTDOWN chunks.\n *\n * If there are still outstanding DATA chunks left, the SHUTDOWN\n * receiver shall continue to follow normal data transmission\n * procedures defined in Section 6 until all outstanding DATA chunks\n * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept\n * new data from its SCTP user.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\tsctp_disposition_t disposition;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Convert the elaborate header.  */\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_shutdownhdr_t));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT\n\t * When a peer sends a SHUTDOWN, SCTP delivers this notification to\n\t * inform the application that it should cease sending data.\n\t */\n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the reception of the SHUTDOWN, the peer endpoint shall\n\t *  - enter the SHUTDOWN-RECEIVED state,\n\t *  - stop accepting new data from its SCTP user\n\t *\n\t * [This is implicit in the new state.]\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t/*  - verify, by checking the Cumulative TSN Ack field of the\n\t *    chunk, that all its outstanding DATA chunks have been\n\t *    received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n/*\n * sctp_sf_do_9_2_shut_ctsn\n *\n * Once an endpoint has reached the SHUTDOWN-RECEIVED state,\n * it MUST NOT send a SHUTDOWN in response to a ULP request.\n * The Cumulative TSN Ack of the received SHUTDOWN chunk\n * MUST be processed.\n */\nsctp_disposition_t sctp_sf_do_9_2_shut_ctsn(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* verify, by checking the Cumulative TSN Ack field of the\n\t * chunk, that all its outstanding DATA chunks have been\n\t * received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC 2960 9.2\n * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk\n * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination\n * transport addresses (either in the IP addresses or in the INIT chunk)\n * that belong to this association, it should discard the INIT chunk and\n * retransmit the SHUTDOWN ACK chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_reshutack(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Make sure that the chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Since we are not going to really process this INIT, there\n\t * is no point in verifying chunk boundries.  Just generate\n\t * the SHUTDOWN ACK.\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-SHUTDOWN timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and restart the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * sctp_sf_do_ecn_cwr\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * CWR:\n *\n * RFC 2481 details a specific bit for a sender to send in the header of\n * its next outbound TCP segment to indicate to its peer that it has\n * reduced its congestion window.  This is termed the CWR bit.  For\n * SCTP the same indication is made by including the CWR chunk.\n * This chunk contains one data element, i.e. the TSN number that\n * was sent in the ECNE chunk.  This element represents the lowest\n * TSN number in the datagram that was originally marked with the\n * CE bit.\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tsctp_cwrhdr_t *cwr;\n\tstruct sctp_chunk *chunk = arg;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (sctp_cwrhdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_do_ecne\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * ECN-Echo\n *\n * RFC 2481 details a specific bit for a receiver to send back in its\n * TCP acknowledgements to notify the sender of the Congestion\n * Experienced (CE) bit having arrived from the network.  For SCTP this\n * same indication is made by including the ECNE chunk.  This chunk\n * contains one data element, i.e. the lowest TSN associated with the IP\n * datagram marked with the CE bit.....\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecne(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t   void *arg,\n\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tsctp_ecnehdr_t *ecne;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (sctp_ecnehdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_ecnehdr_t));\n\n\t/* If this is a newer ECNE than the last CWR packet we sent out */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The SCTP endpoint MUST always acknowledge the reception of each valid\n * DATA chunk.\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated within\n * 200 ms of the arrival of any unacknowledged DATA chunk. In some\n * situations it may be beneficial for an SCTP transmitter to be more\n * conservative than the algorithms detailed in this document allow.\n * However, an SCTP transmitter MUST NOT be more aggressive than the\n * following algorithms allow.\n *\n * A SCTP receiver MUST NOT generate more than one SACK for every\n * incoming packet, other than to update the offered window as the\n * receiving application consumes new data.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_arg_t force = SCTP_NOFORCE();\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* If this is the last chunk in a packet, we need to count it\n\t * toward sack generation.  Note that we need to SACK every\n\t * OTHER packet containing data chunks, EVEN IF WE DISCARD\n\t * THEM.  We elect to NOT generate SACK's if the chunk fails\n\t * the verification tag test.\n\t *\n\t * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * The SCTP endpoint MUST always acknowledge the reception of\n\t * each valid DATA chunk.\n\t *\n\t * The guidelines on delayed acknowledgement algorithm\n\t * specified in  Section 4.2 of [RFC2581] SHOULD be followed.\n\t * Specifically, an acknowledgement SHOULD be generated for at\n\t * least every second packet (not every second DATA chunk)\n\t * received, and SHOULD be generated within 200 ms of the\n\t * arrival of any unacknowledged DATA chunk.  In some\n\t * situations it may be beneficial for an SCTP transmitter to\n\t * be more conservative than the algorithms detailed in this\n\t * document allow. However, an SCTP transmitter MUST NOT be\n\t * more aggressive than the following algorithms allow.\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * When a packet arrives with duplicate DATA chunk(s) and with\n\t * no new DATA chunk(s), the endpoint MUST immediately send a\n\t * SACK with no delay.  If a packet arrives with duplicate\n\t * DATA chunk(s) bundled with new DATA chunks, the endpoint\n\t * MAY immediately send a SACK.  Normally receipt of duplicate\n\t * DATA chunks will occur when the original SACK chunk was lost\n\t * and the peer's RTO has expired.  The duplicate TSN number(s)\n\t * SHOULD be reported in the SACK as duplicate.\n\t */\n\t/* In our case, we split the MAY SACK advice up whether or not\n\t * the last chunk is a duplicate.'\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n\n}\n\n/*\n * sctp_sf_eat_data_fast_4_4\n *\n * Section: 4 (4)\n * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received\n *    DATA chunks without delay.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_fast_4_4(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Go a head and force a SACK, since we are shutting down. */\n\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tif (chunk->end_of_packet) {\n\t\t/* We must delay the chunk creation since the cumulative\n\t\t * TSN has not been updated yet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Processing a Received SACK\n * D) Any time a SACK arrives, the endpoint performs the following:\n *\n *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,\n *     then drop the SACK.   Since Cumulative TSN Ack is monotonically\n *     increasing, a SACK whose Cumulative TSN Ack is less than the\n *     Cumulative TSN Ack Point indicates an out-of-order SACK.\n *\n *     ii) Set rwnd equal to the newly received a_rwnd minus the number\n *     of bytes still outstanding after processing the Cumulative TSN Ack\n *     and the Gap Ack Blocks.\n *\n *     iii) If the SACK is missing a TSN that was previously\n *     acknowledged via a Gap Ack Block (e.g., the data receiver\n *     reneged on the data), then mark the corresponding DATA chunk\n *     as available for retransmit:  Mark it as missing for fast\n *     retransmit as described in Section 7.2.4 and if no retransmit\n *     timer is running for the destination address to which the DATA\n *     chunk was originally transmitted, then T3-rtx is started for\n *     that destination address.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_sackhdr_t *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_sack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Pull the SACK chunk from the data buffer */\n\tsackh = sctp_sm_pull_sack(chunk);\n\t/* Was this a bogus SACK? */\n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t/* i) If Cumulative TSN Ack is less than the Cumulative TSN\n\t *     Ack Point, then drop the SACK.  Since Cumulative TSN\n\t *     Ack is monotonically increasing, a SACK whose\n\t *     Cumulative TSN Ack is less than the Cumulative TSN Ack\n\t *     Point indicates an out-of-order SACK.\n\t */\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* Return this SACK for further processing.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t/* Note: We do the rest of the work on the PROCESS_SACK\n\t * sideeffect.\n\t */\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate an ABORT in response to a packet.\n *\n * Section: 8.4 Handle \"Out of the blue\" Packets, sctpimpguide 2.41\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n *\n * Verification Tag:\n *\n * The return value is the disposition of the chunk.\n*/\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT. The T bit will be set if the asoc\n\t\t * is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, 0);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR\n * event as ULP notification for each cause included in the chunk.\n *\n * API 5.3.1.3 - SCTP_REMOTE_ERROR\n *\n * The return value is the disposition of the chunk.\n*/\nsctp_disposition_t sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an inbound SHUTDOWN ACK.\n *\n * From Section 9.2:\n * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its\n * peer, and remove all record of the association.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* 10.2 H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t/* ...send a SHUTDOWN COMPLETE chunk to its peer, */\n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t/* Do all the commands now (after allocation), so that we\n\t * have consistent state if memory allocation failes\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n\t * stop the T2-shutdown timer,\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t/* ...and remove all record of the association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n */\nsctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an \"Out of the blue\" SHUTDOWN ACK.\n *\n * Section: 8.4 5, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * Inputs\n * (endpoint, asoc, type, arg, commands)\n *\n * Outputs\n * (sctp_disposition_t)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an SHUTDOWN_COMPLETE.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\t\tif (!shut) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(shut))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tshut->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, shut);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\t/* If the chunk length is invalid, we don't want to process\n\t\t * the reset of the packet.\n\t\t */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* We need to discard the rest of the packet to prevent\n\t\t * potential bomming attacks from additional bundled chunks.\n\t\t * This is documented in SCTP Threats ID.\n\t\t */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.\n *\n * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK\n *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the\n *   procedures in section 8.4 SHOULD be followed, in other words it\n *   should be treated as an Out Of The Blue packet.\n *   [This means that we do NOT check the Verification Tag on these\n *   chunks. --piggy ]\n *\n */\nsctp_disposition_t sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Although we do have an association in this case, it corresponds\n\t * to a restarted association. So the packet is treated as an OOTB\n\t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n\t * called with a NULL association.\n\t */\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */\nsctp_disposition_t sctp_sf_do_asconf(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\t__u32\t\t\tserial;\n\tint\t\t\tlength;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\taddr_param = (union sctp_addr_param *)hdr->params;\n\tlength = ntohs(addr_param->p.length);\n\tif (length < sizeof(sctp_paramhdr_t))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)addr_param, commands);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n\t\t\t    (void *)chunk->chunk_end,\n\t\t\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t/* Reset the transport so that we select the correct one\n\t\t * this time around.  This is to make sure that we don't\n\t\t * accidentally use a stale transport that's been removed.\n\t\t */\n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created until we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t\tsctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.3 General rules for address manipulation\n * When building TLV parameters for the ASCONF Chunk that will add or\n * delete IP addresses the D0 to D13 rules should be applied:\n */\nsctp_disposition_t sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc,\n\t    (sctp_paramhdr_t *)addip_hdr->params,\n\t    (void *)asconf_ack->chunk_end,\n\t    &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack)) {\n\t\t\t/* Successfully processed ASCONF_ACK.  We can\n\t\t\t * release the next asconf if we have one.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_NEXT_ASCONF,\n\t\t\t\t\tSCTP_NULL());\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t}\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP\n *\n * When a FORWARD TSN chunk arrives, the data receiver MUST first update\n * its cumulative TSN point to the value carried in the FORWARD TSN\n * chunk, and then MUST further advance its cumulative TSN point locally\n * if possible.\n * After the above processing, the data receiver MUST stop reporting any\n * missing TSNs earlier than or equal to the new cumulative TSN point.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto discard_noforce;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nsctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto gen_shutdown;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * SCTP-AUTH Section 6.3 Receiving authenticated chukns\n *\n *    The receiver MUST use the HMAC algorithm indicated in the HMAC\n *    Identifier field.  If this algorithm was not specified by the\n *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk\n *    during association setup, the AUTH chunk and all chunks after it MUST\n *    be discarded and an ERROR chunk SHOULD be sent with the error cause\n *    defined in Section 4.1.\n *\n *    If an endpoint with no shared key receives a Shared Key Identifier\n *    other than 0, it MUST silently discard all authenticated chunks.  If\n *    the endpoint has at least one endpoint pair shared key for the peer,\n *    it MUST use the key specified by the Shared Key Identifier if a\n *    key has been configured for that Shared Key Identifier.  If no\n *    endpoint pair shared key has been configured for that Shared Key\n *    Identifier, all authenticated chunks MUST be silently discarded.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\t__u8 *save_digest;\n\t__u8 *digest;\n\n\t/* Pull in the auth header, so we can do some more verification */\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(struct sctp_authhdr));\n\n\t/* Make sure that we support the HMAC algorithm from the auth\n\t * chunk.\n\t */\n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t/* Make sure that the provided shared key identifier has been\n\t * configured\n\t */\n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id && !sctp_auth_get_shkey(asoc, key_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\n\n\t/* Make sure that the length of the signature matches what\n\t * we expect.\n\t */\n\tsig_len = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_auth_chunk_t);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Now that we've done validation checks, we can compute and\n\t * verify the hmac.  The steps involved are:\n\t *  1. Save the digest from the chunk.\n\t *  2. Zero out the digest in the chunk.\n\t *  3. Compute the new digest\n\t *  4. Compare saved and new digests.\n\t */\n\tdigest = auth_hdr->hmac;\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t(struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\tGFP_ATOMIC);\n\n\t/* Discard the packet if the digests do not match */\n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nsctp_disposition_t sctp_sf_eat_auth(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_ierror_t error;\n\n\t/* Make sure that the peer has AUTH capable */\n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the AUTH chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(net, ep, asoc, type, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t/* Generate the ERROR chunk and discard the rest\n\t\t * of the packet\n\t\t */\n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Fall Through */\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t/* Prevent gcc warnings */\n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEWKEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn -ENOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an unknown chunk.\n *\n * Section: 3.2. Also, 2.1 in the implementor's guide.\n *\n * Chunk Types are encoded such that the highest-order two bits specify\n * the action that must be taken if the processing endpoint does not\n * recognize the Chunk Type.\n *\n * 00 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it.\n *\n * 01 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it, and report the unrecognized\n *      chunk in an 'Unrecognized Chunk Type'.\n *\n * 10 - Skip this chunk and continue processing.\n *\n * 11 - Skip this chunk and continue processing, but report in an ERROR\n *      Chunk using the 'Unrecognized Chunk Type' cause of error.\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_chunkhdr_t *hdr;\n\n\tpr_debug(\"%s: processing unknown chunk id:%d\\n\", __func__, type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t/* Discard the packet.  */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t/* Discard the packet.  */\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the chunk.\n *\n * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2\n * [Too numerous to mention...]\n * Verification Tag: No verification needed.\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tpr_debug(\"%s: chunk:%d is discarded\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the whole packet.\n *\n * Section: 8.4 2)\n *\n * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n *    silently discard the OOTB packet and take no further action.\n *\n * Verification Tag: No verification necessary\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_pdiscard(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n/*\n * The other end is violating protocol.\n *\n * Section: Not specified\n * Verification Tag: Not specified\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * We simply tag the chunk as a violation.  The state machine will log\n * the violation and continue.\n */\nsctp_disposition_t sctp_sf_violation(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n/*\n * Common function to handle a protocol violation.\n */\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t\t\t     sizeof(sctp_initack_chunk_t)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a protocol violation when the chunk length is invalid.\n * \"Invalid\" length is identified as smaller than the minimal length a\n * given chunk can be.  For example, a SACK chunk has invalid length\n * if its length is set to be smaller than the size of sctp_sack_chunk_t.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n *\n * Section: Not specified\n * Verification Tag:  Nothing to do\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (reply_msg, msg_up, counters)\n *\n * Generate an  ABORT chunk and terminate the association.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/*\n * Handle a protocol violation when the parameter length is invalid.\n * If the length is smaller than the minimum length of a given parameter,\n * or accumulated length in multi parameters exceeds the end of the chunk,\n * the length is considered as invalid.\n */\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle a protocol violation when the peer trying to advance the\n * cumulative tsn ack to a point beyond the max tsn currently sent.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n */\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/* Handle protocol violation of an invalid chunk bundling.  For example,\n * when we have an association and we receive bundled INIT-ACK, or\n * SHUDOWN-COMPLETE, our peer is clearly violationg the \"MUST NOT bundle\"\n * statement from the specs.  Additionally, there might be an attacker\n * on the path and we may not want to continue this communication.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n/***************************************************************************\n * These are the state functions for handling primitive (Section 10) events.\n ***************************************************************************/\n/*\n * sctp_sf_do_prm_asoc\n *\n * Section: 10.1 ULP-to-SCTP\n * B) Associate\n *\n * Format: ASSOCIATE(local SCTP instance name, destination transport addr,\n * outbound stream count)\n * -> association id [,destination transport addr list] [,outbound stream\n * count]\n *\n * This primitive allows the upper layer to initiate an association to a\n * specific peer endpoint.\n *\n * The peer endpoint shall be specified by one of the transport addresses\n * which defines the endpoint (see Section 1.4).  If the local SCTP\n * instance has not been initialized, the ASSOCIATE is considered an\n * error.\n * [This is not relevant for the kernel implementation since we do all\n * initialization at boot time.  It we hadn't initialized we wouldn't\n * get anywhere near this code.]\n *\n * An association id, which is a local handle to the SCTP association,\n * will be returned on successful establishment of the association. If\n * SCTP is not able to open an SCTP association with the peer endpoint,\n * an error is returned.\n * [In the kernel implementation, the struct sctp_association needs to\n * be created BEFORE causing this primitive to run.]\n *\n * Other association parameters may be returned, including the\n * complete destination transport addresses of the peer as well as the\n * outbound stream count of the local endpoint. One of the transport\n * address from the returned destination addresses will be selected by\n * the local endpoint as default primary path for sending SCTP packets\n * to this peer.  The returned \"destination transport addr list\" can\n * be used by the ULP to change the default primary path or to force\n * sending a packet to a specific transport address.  [All of this\n * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING\n * function.]\n *\n * Mandatory attributes:\n *\n * o local SCTP instance name - obtained from the INITIALIZE operation.\n *   [This is the argument asoc.]\n * o destination transport addr - specified as one of the transport\n * addresses of the peer endpoint with which the association is to be\n * established.\n *  [This is asoc->peer.active_path.]\n * o outbound stream count - the number of outbound streams the ULP\n * would like to open towards this peer endpoint.\n * [BUG: This is not currently implemented.]\n * Optional attributes:\n *\n * None.\n *\n * The return value is a disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *my_asoc;\n\n\t/* The comment below says that we enter COOKIE-WAIT AFTER\n\t * sending the INIT, but that doesn't actually work in our\n\t * implementation...\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\"\n\t * must provide its Verification Tag (Tag_A) in the Initiate\n\t * Tag field.  Tag_A SHOULD be a random number in the range of\n\t * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...\n\t */\n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Choose transport for INIT. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t/* After sending the INIT, \"A\" starts the T1-init timer and\n\t * enters the COOKIE-WAIT state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the SEND primitive.\n *\n * Section: 10.1 ULP-to-SCTP\n * E) Send\n *\n * Format: SEND(association id, buffer address, byte count [,context]\n *         [,stream id] [,life time] [,destination transport address]\n *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n * -> result\n *\n * This is the main method to send user data via SCTP.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n *  o buffer address - the location where the user message to be\n *    transmitted is stored;\n *\n *  o byte count - The size of the user data in number of bytes;\n *\n * Optional attributes:\n *\n *  o context - an optional 32 bit integer that will be carried in the\n *    sending failure notification to the ULP if the transportation of\n *    this User Message fails.\n *\n *  o stream id - to indicate which stream to send the data on. If not\n *    specified, stream 0 will be used.\n *\n *  o life time - specifies the life time of the user data. The user data\n *    will not be sent by SCTP after the life time expires. This\n *    parameter can be used to avoid efforts to transmit stale\n *    user messages. SCTP notifies the ULP if the data cannot be\n *    initiated to transport (i.e. sent to the destination via SCTP's\n *    send primitive) within the life time variable. However, the\n *    user data will be transmitted if SCTP has attempted to transmit a\n *    chunk before the life time expired.\n *\n *  o destination transport address - specified as one of the destination\n *    transport addresses of the peer endpoint to which this packet\n *    should be sent. Whenever possible, SCTP should use this destination\n *    transport address for sending the packets, instead of the current\n *    primary path.\n *\n *  o unorder flag - this flag, if present, indicates that the user\n *    would like the data delivered in an unordered fashion to the peer\n *    (i.e., the U flag is set to 1 on all DATA chunks carrying this\n *    message).\n *\n *  o no-bundle flag - instructs SCTP not to bundle this user data with\n *    other outbound DATA chunks. SCTP MAY still bundle even when\n *    this flag is present, when faced with network congestion.\n *\n *  o payload protocol-id - A 32 bit unsigned integer that is to be\n *    passed to the peer indicating the type of payload protocol data\n *    being transmitted. This value is passed as opaque data by SCTP.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process the SHUTDOWN primitive.\n *\n * Section: 10.1:\n * C) Shutdown\n *\n * Format: SHUTDOWN(association id)\n * -> result\n *\n * Gracefully closes an association. Any locally queued user data\n * will be delivered to the peer. The association will be terminated only\n * after the peer acknowledges all the SCTP packets sent.  A success code\n * will be returned on successful termination of the association. If\n * attempting to terminate the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*\n * Process the ABORT primitive.\n *\n * Section: 10.1:\n * C) Abort\n *\n * Format: Abort(association id [, cause code])\n * -> result\n *\n * Ungracefully closes an association. Any locally queued user data\n * will be discarded and an ABORT chunk is sent to the peer.  A success code\n * will be returned on successful abortion of the association. If\n * attempting to abort the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n *  o cause code - reason of the abort to be passed to the peer\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_1_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn retval;\n}\n\n/* We tried an illegal operation on an association which is closed.  */\nsctp_disposition_t sctp_sf_error_closed(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* We tried an illegal operation on an association which is shutting\n * down.\n */\nsctp_disposition_t sctp_sf_error_shutdown(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_cookie_wait_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * sctp_cookie_echoed_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_wait_prm_abort\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\t/* Stop T1-init timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn retval;\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Section: 4 Note: 3\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_pending_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-PENDING state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_pending_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_sent_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-SENT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process the REQUESTHEARTBEAT primitive\n *\n * 10.1 ULP-to-SCTP\n * J) Request Heartbeat\n *\n * Format: REQUESTHEARTBEAT(association id, destination transport address)\n *\n * -> result\n *\n * Instructs the local endpoint to perform a HeartBeat on the specified\n * destination transport address of the given association. The returned\n * result should indicate whether the transmission of the HEARTBEAT\n * chunk to the destination address is successful.\n *\n * Mandatory attributes:\n *\n * o association id - local handle to the SCTP association\n *\n * o destination transport address - the transport address of the\n *   association on which a heartbeat should be issued.\n */\nsctp_disposition_t sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/*\n\t * RFC 2960 (bis), section 8.3\n\t *\n\t *    D) Request an on-demand HEARTBEAT on a specific destination\n\t *    transport address of a given association.\n\t *\n\t *    The endpoint should increment the respective error  counter of\n\t *    the destination transport address each time a HEARTBEAT is sent\n\t *    to that address and not acknowledged within one RTO.\n\t *\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * When an endpoint has an ASCONF signaled change to be sent to the\n * remote endpoint it should do A1 to A9\n */\nsctp_disposition_t sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Ignore the primitive event\n *\n * The return value is the disposition of the primitive.\n */\nsctp_disposition_t sctp_sf_ignore_primitive(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tpr_debug(\"%s: primitive type:%d is ignored\\n\", __func__,\n\t\t type.primitive);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/***************************************************************************\n * These are the state functions for the OTHER events.\n ***************************************************************************/\n\n/*\n * When the SCTP stack has no more user data to send or retransmit, this\n * notification is given to the user. Also, at the time when a user app\n * subscribes to this event, if there is no data to be sent or\n * retransmit, the stack will immediately send up this notification.\n */\nsctp_disposition_t sctp_sf_do_no_pending_tsn(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Start the shutdown negotiation.\n *\n * From Section 9.2:\n * Once all its outstanding data has been acknowledged, the endpoint\n * shall send a SHUTDOWN chunk to its peer including in the Cumulative\n * TSN Ack field the last sequential TSN it has received from the peer.\n * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n * state. If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_start_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t/* Once all its outstanding data has been acknowledged, the\n\t * endpoint shall send a SHUTDOWN chunk to its peer including\n\t * in the Cumulative TSN Ack field the last sequential TSN it\n\t * has received from the peer.\n\t */\n\treply = sctp_make_shutdown(asoc, NULL);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN chunk and the timeout for the\n\t * T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* It shall then start the T2-shutdown timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* RFC 4960 Section 9.2\n\t * The sender of the SHUTDOWN MAY also start an overall guard timer\n\t * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* and enter the SHUTDOWN-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Generate a SHUTDOWN ACK now that everything is SACK'd.\n *\n * From Section 9.2:\n *\n * If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the\n * endpoint must re-send the SHUTDOWN ACK.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t\t  commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Ignore the event defined as other\n *\n * The return value is the disposition of the event.\n */\nsctp_disposition_t sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tpr_debug(\"%s: the event other type:%d is ignored\\n\",\n\t\t __func__, type.other);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/************************************************************\n * These are the state functions for handling timeout events.\n ************************************************************/\n\n/*\n * RTX Timeout\n *\n * Section: 6.3.3 Handle T3-rtx Expiration\n *\n * Whenever the retransmission timer T3-rtx expires for a destination\n * address, do the following:\n * [See below]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate delayed SACK on timeout\n *\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated\n * within 200 ms of the arrival of any unacknowledged DATA chunk.  In\n * some situations it may be beneficial for an SCTP transmitter to be\n * more conservative than the algorithms detailed in this document\n * allow. However, an SCTP transmitter MUST NOT be more aggressive than\n * the following algorithms allow.\n */\nsctp_disposition_t sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_init_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT\n *     and re-start the T1-init timer without changing state.  This MUST\n *     be repeated up to 'Max.Init.Retransmits' times.  After that, the\n *     endpoint MUST abort the initialization process and report the\n *     error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_init_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tpr_debug(\"%s: timer T1 expired (INIT)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Choose transport for INIT. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tpr_debug(\"%s: giving up on INIT, attempts:%d \"\n\t\t\t \"max_init_attempts:%d\\n\", __func__, attempts,\n\t\t\t asoc->max_init_attempts);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_cookie_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  3) If the T1-cookie timer expires, the endpoint MUST retransmit\n *     COOKIE ECHO and re-start the T1-cookie timer without changing\n *     state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n *     After that, the endpoint MUST abort the initialization process and\n *     report the error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_cookie_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tpr_debug(\"%s: timer T1 expired (COOKIE-ECHO)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * An endpoint should limit the number of retransmissions of the\n * SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n * If this threshold is exceeded the endpoint should destroy the TCB and\n * MUST report the peer endpoint unreachable to the upper layer (and\n * thus the association enters the CLOSED state).  The reception of any\n * packet from its peer (i.e. as the peer sends all of its queued DATA\n * chunks) should clear the endpoint's retransmission count and restart\n * the T2-Shutdown timer,  giving its peer ample opportunity to transmit\n * all of its queued DATA chunks that have not yet been sent.\n */\nsctp_disposition_t sctp_sf_t2_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T2 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Do some failure management (Section 8.2).\n\t * If we remove the transport an SHUTDOWN was last sent to, don't\n\t * do failure management.\n\t */\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* Restart the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF CHunk Procedures\n * If the T4 RTO timer expires the endpoint should do B1 to B5\n */\nsctp_disposition_t sctp_sf_t4_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t/* ADDIP 4.1 B1) Increment the error counters and perform path failure\n\t * detection on the appropriate destination address as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t */\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t/* Reconfig T4 timer and transport. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t/* ADDIP 4.1 B2) Increment the association error counters and perform\n\t * endpoint failure detection on the association as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t * association error counter is incremented in SCTP_CMD_STRIKE.\n\t */\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t/* ADDIP 4.1 B3) Back-off the destination address RTO value to which\n\t * the ASCONF chunk was sent by doubling the RTO timer value.\n\t * This is done in SCTP_CMD_STRIKE.\n\t */\n\n\t/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible\n\t * choose an alternate destination address (please refer to RFC2960\n\t * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this\n\t * chunk, it MUST be the same (including its serial number) as the last\n\t * ASCONF sent.\n\t */\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different\n\t * destination is selected, then the RTO used will be that of the new\n\t * destination address.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* sctpimpguide-05 Section 2.12.2\n * The sender of the SHUTDOWN MAY also start an overall guard timer\n * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n * At the expiration of this timer the sender SHOULD abort the association\n * by sending an ABORT chunk.\n */\nsctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T5 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,\n * the association is automatically closed by starting the shutdown process.\n * The work that needs to be done is same as when SHUTDOWN is initiated by\n * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().\n */\nsctp_disposition_t sctp_sf_autoclose_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*****************************************************************************\n * These are sa state functions which could apply to all types of events.\n ****************************************************************************/\n\n/*\n * This table entry is not implemented.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_not_impl(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n/*\n * This table entry represents a bug.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_bug(struct net *net,\n\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t       const struct sctp_association *asoc,\n\t\t\t       const sctp_subtype_t type,\n\t\t\t       void *arg,\n\t\t\t       sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n/*\n * This table entry represents the firing of a timer in the wrong state.\n * Since timer deletion cannot be guaranteed a timer 'may' end up firing\n * when the association is in the wrong state.   This event should\n * be ignored, so as to prevent any rearming of the timer.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tpr_debug(\"%s: timer %d ignored\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Pull the SACK chunk based on the SACK header. */\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\tunsigned int len;\n\t__u16 num_blocks;\n\t__u16 num_dup_tsns;\n\n\t/* Protect ourselves from reading too far into\n\t * the skb from a bogus sender.\n\t */\n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n/* Create an ABORT packet to be sent as a response, with the specified\n * error causes.\n */\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Add specified error causes, i.e., payload, to the\n\t\t * end of the chunk.\n\t\t */\n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n/* Allocate a packet for responding in the OOTB conditions.  */\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_transport *transport;\n\t__u16 sport;\n\t__u16 dport;\n\t__u32 vtag;\n\n\t/* Get the source and destination port from the inbound packet.  */\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t/* The V-tag is going to be the same as the inbound packet if no\n\t * association exists, otherwise, use the peer's vtag.\n\t */\n\tif (asoc) {\n\t\t/* Special case the INIT-ACK as there is no peer's vtag\n\t\t * yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Special case the INIT and stale COOKIE_ECHO as there is no\n\t\t * vtag yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tsctp_init_chunk_t *init;\n\n\t\t\tinit = (sctp_init_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make a transport for the bucket, Eliza... */\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\t/* Cache a route for the transport with the chunk's destination as\n\t * the source address.\n\t */\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = sctp_packet_init(&transport->packet, transport, sport, dport);\n\tpacket = sctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n/* Free the packet allocated earlier for responding in the OOTB condition.  */\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t/* Override the OOTB vtag from the cookie. */\n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t/* Set the skb to the belonging sock for accounting. */\n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n/* Process a data chunk */\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (!chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\taf = sctp_get_af_specific(\n\t\t\tipver2af(ip_hdr(chunk->skb)->version));\n\n\t\tif (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n"], "fixing_code": ["/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001 Intel Corp.\n *\n * This file is part of the SCTP kernel implementation\n *\n * These are definitions needed by the state machine.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email addresses:\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson <karl@athena.chicago.il.us>\n *    Xingang Guo <xingang.guo@intel.com>\n *    Jon Grimm <jgrimm@us.ibm.com>\n *    Dajiang Zhang <dajiang.zhang@nokia.com>\n *    Sridhar Samudrala <sri@us.ibm.com>\n *    Daisy Chang <daisyc@us.ibm.com>\n *    Ardelle Fan <ardelle.fan@intel.com>\n *    Kevin Gao <kevin.gao@intel.com>\n */\n\n#include <linux/types.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/in.h>\n#include <net/sctp/command.h>\n#include <net/sctp/sctp.h>\n\n#ifndef __sctp_sm_h__\n#define __sctp_sm_h__\n\n/*\n * Possible values for the disposition are:\n */\ntypedef enum {\n\tSCTP_DISPOSITION_DISCARD,\t /* No further processing.  */\n\tSCTP_DISPOSITION_CONSUME,\t /* Process return values normally.  */\n\tSCTP_DISPOSITION_NOMEM,\t\t /* We ran out of memory--recover.  */\n\tSCTP_DISPOSITION_DELETE_TCB,\t /* Close the association.  */\n\tSCTP_DISPOSITION_ABORT,\t\t /* Close the association NOW.  */\n\tSCTP_DISPOSITION_VIOLATION,\t /* The peer is misbehaving.  */\n\tSCTP_DISPOSITION_NOT_IMPL,\t /* This entry is not implemented.  */\n\tSCTP_DISPOSITION_ERROR,\t\t /* This is plain old user error.  */\n\tSCTP_DISPOSITION_BUG,\t\t /* This is a bug.  */\n} sctp_disposition_t;\n\ntypedef struct {\n\tint name;\n\tint action;\n} sctp_sm_command_t;\n\ntypedef sctp_disposition_t (sctp_state_fn_t) (struct net *,\n\t\t\t\t\t      const struct sctp_endpoint *,\n\t\t\t\t\t      const struct sctp_association *,\n\t\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t\t      void *arg,\n\t\t\t\t\t      sctp_cmd_seq_t *);\ntypedef void (sctp_timer_event_t) (unsigned long);\ntypedef struct {\n\tsctp_state_fn_t *fn;\n\tconst char *name;\n} sctp_sm_table_entry_t;\n\n/* A naming convention of \"sctp_sf_xxx\" applies to all the state functions\n * currently in use.\n */\n\n/* Prototypes for generic state functions. */\nsctp_state_fn_t sctp_sf_not_impl;\nsctp_state_fn_t sctp_sf_bug;\n\n/* Prototypes for gener timer state functions. */\nsctp_state_fn_t sctp_sf_timer_ignore;\n\n/* Prototypes for chunk state functions. */\nsctp_state_fn_t sctp_sf_do_9_1_abort;\nsctp_state_fn_t sctp_sf_cookie_wait_abort;\nsctp_state_fn_t sctp_sf_cookie_echoed_abort;\nsctp_state_fn_t sctp_sf_shutdown_pending_abort;\nsctp_state_fn_t sctp_sf_shutdown_sent_abort;\nsctp_state_fn_t sctp_sf_shutdown_ack_sent_abort;\nsctp_state_fn_t sctp_sf_do_5_1B_init;\nsctp_state_fn_t sctp_sf_do_5_1C_ack;\nsctp_state_fn_t sctp_sf_do_5_1D_ce;\nsctp_state_fn_t sctp_sf_do_5_1E_ca;\nsctp_state_fn_t sctp_sf_do_4_C;\nsctp_state_fn_t sctp_sf_eat_data_6_2;\nsctp_state_fn_t sctp_sf_eat_data_fast_4_4;\nsctp_state_fn_t sctp_sf_eat_sack_6_2;\nsctp_state_fn_t sctp_sf_operr_notify;\nsctp_state_fn_t sctp_sf_t1_init_timer_expire;\nsctp_state_fn_t sctp_sf_t1_cookie_timer_expire;\nsctp_state_fn_t sctp_sf_t2_timer_expire;\nsctp_state_fn_t sctp_sf_t4_timer_expire;\nsctp_state_fn_t sctp_sf_t5_timer_expire;\nsctp_state_fn_t sctp_sf_sendbeat_8_3;\nsctp_state_fn_t sctp_sf_beat_8_3;\nsctp_state_fn_t sctp_sf_backbeat_8_3;\nsctp_state_fn_t sctp_sf_do_9_2_final;\nsctp_state_fn_t sctp_sf_do_9_2_shutdown;\nsctp_state_fn_t sctp_sf_do_9_2_shut_ctsn;\nsctp_state_fn_t sctp_sf_do_ecn_cwr;\nsctp_state_fn_t sctp_sf_do_ecne;\nsctp_state_fn_t sctp_sf_ootb;\nsctp_state_fn_t sctp_sf_pdiscard;\nsctp_state_fn_t sctp_sf_violation;\nsctp_state_fn_t sctp_sf_discard_chunk;\nsctp_state_fn_t sctp_sf_do_5_2_1_siminit;\nsctp_state_fn_t sctp_sf_do_5_2_2_dupinit;\nsctp_state_fn_t sctp_sf_do_5_2_3_initack;\nsctp_state_fn_t sctp_sf_do_5_2_4_dupcook;\nsctp_state_fn_t sctp_sf_unk_chunk;\nsctp_state_fn_t sctp_sf_do_8_5_1_E_sa;\nsctp_state_fn_t sctp_sf_cookie_echoed_err;\nsctp_state_fn_t sctp_sf_do_asconf;\nsctp_state_fn_t sctp_sf_do_asconf_ack;\nsctp_state_fn_t sctp_sf_do_9_2_reshutack;\nsctp_state_fn_t sctp_sf_eat_fwd_tsn;\nsctp_state_fn_t sctp_sf_eat_fwd_tsn_fast;\nsctp_state_fn_t sctp_sf_eat_auth;\n\n/* Prototypes for primitive event state functions.  */\nsctp_state_fn_t sctp_sf_do_prm_asoc;\nsctp_state_fn_t sctp_sf_do_prm_send;\nsctp_state_fn_t sctp_sf_do_9_2_prm_shutdown;\nsctp_state_fn_t sctp_sf_cookie_wait_prm_shutdown;\nsctp_state_fn_t sctp_sf_cookie_echoed_prm_shutdown;\nsctp_state_fn_t sctp_sf_do_9_1_prm_abort;\nsctp_state_fn_t sctp_sf_cookie_wait_prm_abort;\nsctp_state_fn_t sctp_sf_cookie_echoed_prm_abort;\nsctp_state_fn_t sctp_sf_shutdown_pending_prm_abort;\nsctp_state_fn_t sctp_sf_shutdown_sent_prm_abort;\nsctp_state_fn_t sctp_sf_shutdown_ack_sent_prm_abort;\nsctp_state_fn_t sctp_sf_error_closed;\nsctp_state_fn_t sctp_sf_error_shutdown;\nsctp_state_fn_t sctp_sf_ignore_primitive;\nsctp_state_fn_t sctp_sf_do_prm_requestheartbeat;\nsctp_state_fn_t sctp_sf_do_prm_asconf;\n\n/* Prototypes for other event state functions.  */\nsctp_state_fn_t sctp_sf_do_no_pending_tsn;\nsctp_state_fn_t sctp_sf_do_9_2_start_shutdown;\nsctp_state_fn_t sctp_sf_do_9_2_shutdown_ack;\nsctp_state_fn_t sctp_sf_ignore_other;\nsctp_state_fn_t sctp_sf_cookie_wait_icmp_abort;\n\n/* Prototypes for timeout event state functions.  */\nsctp_state_fn_t sctp_sf_do_6_3_3_rtx;\nsctp_state_fn_t sctp_sf_do_6_2_sack;\nsctp_state_fn_t sctp_sf_autoclose_timer_expire;\n\n/* Prototypes for utility support functions.  */\n__u8 sctp_get_chunk_type(struct sctp_chunk *chunk);\nconst sctp_sm_table_entry_t *sctp_sm_lookup_event(struct net *,\n\t\t\t\t\t    sctp_event_t,\n\t\t\t\t\t    sctp_state_t,\n\t\t\t\t\t    sctp_subtype_t);\nint sctp_chunk_iif(const struct sctp_chunk *);\nstruct sctp_association *sctp_make_temp_asoc(const struct sctp_endpoint *,\n\t\t\t\t\t     struct sctp_chunk *,\n\t\t\t\t\t     gfp_t gfp);\n__u32 sctp_generate_verification_tag(void);\nvoid sctp_populate_tie_tags(__u8 *cookie, __u32 curTag, __u32 hisTag);\n\n/* Prototypes for chunk-building functions.  */\nstruct sctp_chunk *sctp_make_init(const struct sctp_association *,\n\t\t\t     const struct sctp_bind_addr *,\n\t\t\t     gfp_t gfp, int vparam_len);\nstruct sctp_chunk *sctp_make_init_ack(const struct sctp_association *,\n\t\t\t\t const struct sctp_chunk *,\n\t\t\t\t const gfp_t gfp,\n\t\t\t\t const int unkparam_len);\nstruct sctp_chunk *sctp_make_cookie_echo(const struct sctp_association *,\n\t\t\t\t    const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *,\n\t\t\t\t   const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_cwr(const struct sctp_association *,\n\t\t\t\t const __u32 lowest_tsn,\n\t\t\t\t const struct sctp_chunk *);\nstruct sctp_chunk * sctp_make_datafrag_empty(struct sctp_association *,\n\t\t\t\t\tconst struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t\tint len, const __u8 flags,\n\t\t\t\t\t__u16 ssn);\nstruct sctp_chunk *sctp_make_ecne(const struct sctp_association *,\n\t\t\t\t  const __u32);\nstruct sctp_chunk *sctp_make_sack(const struct sctp_association *);\nstruct sctp_chunk *sctp_make_shutdown(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk);\nstruct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t\t  const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_shutdown_complete(const struct sctp_association *,\n\t\t\t\t\t  const struct sctp_chunk *);\nvoid sctp_init_cause(struct sctp_chunk *, __be16 cause, size_t);\nstruct sctp_chunk *sctp_make_abort(const struct sctp_association *,\n\t\t\t      const struct sctp_chunk *,\n\t\t\t      const size_t hint);\nstruct sctp_chunk *sctp_make_abort_no_data(const struct sctp_association *,\n\t\t\t\t      const struct sctp_chunk *,\n\t\t\t\t      __u32 tsn);\nstruct sctp_chunk *sctp_make_abort_user(const struct sctp_association *,\n\t\t\t\t\tconst struct msghdr *, size_t msg_len);\nstruct sctp_chunk *sctp_make_abort_violation(const struct sctp_association *,\n\t\t\t\t   const struct sctp_chunk *,\n\t\t\t\t   const __u8 *,\n\t\t\t\t   const size_t );\nstruct sctp_chunk *sctp_make_violation_paramlen(const struct sctp_association *,\n\t\t\t\t   const struct sctp_chunk *,\n\t\t\t\t   struct sctp_paramhdr *);\nstruct sctp_chunk *sctp_make_violation_max_retrans(const struct sctp_association *,\n\t\t\t\t\t\t   const struct sctp_chunk *);\nstruct sctp_chunk *sctp_make_heartbeat(const struct sctp_association *,\n\t\t\t\t  const struct sctp_transport *);\nstruct sctp_chunk *sctp_make_heartbeat_ack(const struct sctp_association *,\n\t\t\t\t      const struct sctp_chunk *,\n\t\t\t\t      const void *payload,\n\t\t\t\t      const size_t paylen);\nstruct sctp_chunk *sctp_make_op_error(const struct sctp_association *,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t __be16 cause_code,\n\t\t\t\t const void *payload,\n\t\t\t\t size_t paylen,\n\t\t\t\t size_t reserve_tail);\n\nstruct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *,\n\t\t\t\t\t      union sctp_addr *,\n\t\t\t\t\t      struct sockaddr *,\n\t\t\t\t\t      int, __be16);\nstruct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\n\t\t\t\t\t     union sctp_addr *addr);\nbool sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n\t\t\tstruct sctp_paramhdr **errp);\nstruct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf);\nint sctp_process_asconf_ack(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *asconf_ack);\nstruct sctp_chunk *sctp_make_fwdtsn(const struct sctp_association *asoc,\n\t\t\t\t    __u32 new_cum_tsn, size_t nstreams,\n\t\t\t\t    struct sctp_fwdtsn_skip *skiplist);\nstruct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc);\n\nvoid sctp_chunk_assign_tsn(struct sctp_chunk *);\nvoid sctp_chunk_assign_ssn(struct sctp_chunk *);\n\n/* Prototypes for statetable processing. */\n\nint sctp_do_sm(struct net *net, sctp_event_t event_type, sctp_subtype_t subtype,\n\t       sctp_state_t state,\n               struct sctp_endpoint *,\n               struct sctp_association *asoc,\n               void *event_arg,\n\t       gfp_t gfp);\n\n/* 2nd level prototypes */\nvoid sctp_generate_t3_rtx_event(unsigned long peer);\nvoid sctp_generate_heartbeat_event(unsigned long peer);\nvoid sctp_generate_proto_unreach_event(unsigned long peer);\n\nvoid sctp_ootb_pkt_free(struct sctp_packet *);\n\nstruct sctp_association *sctp_unpack_cookie(const struct sctp_endpoint *,\n\t\t\t\t       const struct sctp_association *,\n\t\t\t\t       struct sctp_chunk *,\n\t\t\t\t       gfp_t gfp, int *err,\n\t\t\t\t       struct sctp_chunk **err_chk_p);\nint sctp_addip_addr_config(struct sctp_association *, sctp_param_t,\n\t\t\t   struct sockaddr_storage*, int);\n\n/* 3rd level prototypes */\n__u32 sctp_generate_tag(const struct sctp_endpoint *);\n__u32 sctp_generate_tsn(const struct sctp_endpoint *);\n\n/* Extern declarations for major data structures.  */\nextern sctp_timer_event_t *sctp_timer_events[SCTP_NUM_TIMEOUT_TYPES];\n\n\n/* Get the size of a DATA chunk payload. */\nstatic inline __u16 sctp_data_size(struct sctp_chunk *chunk)\n{\n\t__u16 size;\n\n\tsize = ntohs(chunk->chunk_hdr->length);\n\tsize -= sizeof(sctp_data_chunk_t);\n\n\treturn size;\n}\n\n/* Compare two TSNs */\n\n/* RFC 1982 - Serial Number Arithmetic\n *\n * 2. Comparison\n *  Then, s1 is said to be equal to s2 if and only if i1 is equal to i2,\n *  in all other cases, s1 is not equal to s2.\n *\n * s1 is said to be less than s2 if, and only if, s1 is not equal to s2,\n * and\n *\n *      (i1 < i2 and i2 - i1 < 2^(SERIAL_BITS - 1)) or\n *      (i1 > i2 and i1 - i2 > 2^(SERIAL_BITS - 1))\n *\n * s1 is said to be greater than s2 if, and only if, s1 is not equal to\n * s2, and\n *\n *      (i1 < i2 and i2 - i1 > 2^(SERIAL_BITS - 1)) or\n *      (i1 > i2 and i1 - i2 < 2^(SERIAL_BITS - 1))\n */\n\n/*\n * RFC 2960\n *  1.6 Serial Number Arithmetic\n *\n * Comparisons and arithmetic on TSNs in this document SHOULD use Serial\n * Number Arithmetic as defined in [RFC1982] where SERIAL_BITS = 32.\n */\n\nenum {\n\tTSN_SIGN_BIT = (1<<31)\n};\n\nstatic inline int TSN_lt(__u32 s, __u32 t)\n{\n\treturn ((s) - (t)) & TSN_SIGN_BIT;\n}\n\nstatic inline int TSN_lte(__u32 s, __u32 t)\n{\n\treturn ((s) == (t)) || (((s) - (t)) & TSN_SIGN_BIT);\n}\n\n/* Compare two SSNs */\n\n/*\n * RFC 2960\n *  1.6 Serial Number Arithmetic\n *\n * Comparisons and arithmetic on Stream Sequence Numbers in this document\n * SHOULD use Serial Number Arithmetic as defined in [RFC1982] where\n * SERIAL_BITS = 16.\n */\nenum {\n\tSSN_SIGN_BIT = (1<<15)\n};\n\nstatic inline int SSN_lt(__u16 s, __u16 t)\n{\n\treturn ((s) - (t)) & SSN_SIGN_BIT;\n}\n\nstatic inline int SSN_lte(__u16 s, __u16 t)\n{\n\treturn ((s) == (t)) || (((s) - (t)) & SSN_SIGN_BIT);\n}\n\n/*\n * ADDIP 3.1.1\n * The valid range of Serial Number is from 0 to 4294967295 (2**32 - 1). Serial\n * Numbers wrap back to 0 after reaching 4294967295.\n */\nenum {\n\tADDIP_SERIAL_SIGN_BIT = (1<<31)\n};\n\nstatic inline int ADDIP_SERIAL_gte(__u16 s, __u16 t)\n{\n\treturn ((s) == (t)) || (((t) - (s)) & ADDIP_SERIAL_SIGN_BIT);\n}\n\n/* Check VTAG of the packet matches the sender's own tag. */\nstatic inline int\nsctp_vtag_verify(const struct sctp_chunk *chunk,\n\t\t const struct sctp_association *asoc)\n{\n\t/* RFC 2960 Sec 8.5 When receiving an SCTP packet, the endpoint\n\t * MUST ensure that the value in the Verification Tag field of\n\t * the received SCTP packet matches its own Tag. If the received\n\t * Verification Tag value does not match the receiver's own\n\t * tag value, the receiver shall silently discard the packet...\n\t */\n        if (ntohl(chunk->sctp_hdr->vtag) == asoc->c.my_vtag)\n                return 1;\n\n\treturn 0;\n}\n\n/* Check VTAG of the packet matches the sender's own tag and the T bit is\n * not set, OR its peer's tag and the T bit is set in the Chunk Flags.\n */\nstatic inline int\nsctp_vtag_verify_either(const struct sctp_chunk *chunk,\n\t\t\tconst struct sctp_association *asoc)\n{\n        /* RFC 2960 Section 8.5.1, sctpimpguide Section 2.41\n\t *\n\t * B) The receiver of a ABORT MUST accept the packet\n\t *    if the Verification Tag field of the packet matches its own tag\n\t *    and the T bit is not set\n\t *    OR\n\t *    it is set to its peer's tag and the T bit is set in the Chunk\n\t *    Flags.\n\t *    Otherwise, the receiver MUST silently discard the packet\n\t *    and take no further action.\n\t *\n\t * C) The receiver of a SHUTDOWN COMPLETE shall accept the packet\n\t *    if the Verification Tag field of the packet matches its own tag\n\t *    and the T bit is not set\n\t *    OR\n\t *    it is set to its peer's tag and the T bit is set in the Chunk\n\t *    Flags.\n\t *    Otherwise, the receiver MUST silently discard the packet\n\t *    and take no further action.  An endpoint MUST ignore the\n\t *    SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n\t */\n        if ((!sctp_test_T_bit(chunk) &&\n             (ntohl(chunk->sctp_hdr->vtag) == asoc->c.my_vtag)) ||\n\t    (sctp_test_T_bit(chunk) && asoc->c.peer_vtag &&\n\t     (ntohl(chunk->sctp_hdr->vtag) == asoc->c.peer_vtag))) {\n                return 1;\n\t}\n\n\treturn 0;\n}\n\n#endif /* __sctp_sm_h__ */\n", "/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n *\n * This file is part of the SCTP kernel implementation\n *\n * These functions work with the state functions in sctp_sm_statefuns.c\n * to implement the state operations.  These functions implement the\n * steps which require modifying existing data structures.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    C. Robin              <chris@hundredacre.ac.uk>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Xingang Guo           <xingang.guo@intel.com>\n *    Dajiang Zhang\t    <dajiang.zhang@nokia.com>\n *    Sridhar Samudrala\t    <sri@us.ibm.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Kevin Gao             <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n\n#include <linux/skbuff.h>\n#include <linux/random.h>\t/* for get_random_bytes */\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen);\nstatic struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen);\nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t   __u8 type, __u8 flags, int paylen);\nstatic sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst struct sctp_chunk *init_chunk,\n\t\t\t\t\tint *cookie_len,\n\t\t\t\t\tconst __u8 *raw_addrs, int addrs_len);\nstatic int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp);\nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\n\t\t\t      const void *data);\nstatic void  *sctp_addto_chunk_fixed(struct sctp_chunk *, int len,\n\t\t\t\t     const void *data);\n\n/* Control chunk destructor */\nstatic void sctp_control_release_owner(struct sk_buff *skb)\n{\n\t/*TODO: do memory release */\n}\n\nstatic void sctp_control_set_owner_w(struct sctp_chunk *chunk)\n{\n\tstruct sctp_association *asoc = chunk->asoc;\n\tstruct sk_buff *skb = chunk->skb;\n\n\t/* TODO: properly account for control chunks.\n\t * To do it right we'll need:\n\t *  1) endpoint if association isn't known.\n\t *  2) proper memory accounting.\n\t *\n\t *  For now don't do anything for now.\n\t */\n\tskb->sk = asoc ? asoc->base.sk : NULL;\n\tskb->destructor = sctp_control_release_owner;\n}\n\n/* What was the inbound interface for this chunk? */\nint sctp_chunk_iif(const struct sctp_chunk *chunk)\n{\n\tstruct sctp_af *af;\n\tint iif = 0;\n\n\taf = sctp_get_af_specific(ipver2af(ip_hdr(chunk->skb)->version));\n\tif (af)\n\t\tiif = af->skb_iif(chunk->skb);\n\n\treturn iif;\n}\n\n/* RFC 2960 3.3.2 Initiation (INIT) (1)\n *\n * Note 2: The ECN capable field is reserved for future use of\n * Explicit Congestion Notification.\n */\nstatic const struct sctp_paramhdr ecap_param = {\n\tSCTP_PARAM_ECN_CAPABLE,\n\tcpu_to_be16(sizeof(struct sctp_paramhdr)),\n};\nstatic const struct sctp_paramhdr prsctp_param = {\n\tSCTP_PARAM_FWD_TSN_SUPPORT,\n\tcpu_to_be16(sizeof(struct sctp_paramhdr)),\n};\n\n/* A helper to initialize an op error inside a\n * provided chunk, as most cause codes will be embedded inside an\n * abort chunk.\n */\nvoid  sctp_init_cause(struct sctp_chunk *chunk, __be16 cause_code,\n\t\t      size_t paylen)\n{\n\tsctp_errhdr_t err;\n\t__u16 len;\n\n\t/* Cause code constants are now defined in network order.  */\n\terr.cause = cause_code;\n\tlen = sizeof(sctp_errhdr_t) + paylen;\n\terr.length  = htons(len);\n\tchunk->subh.err_hdr = sctp_addto_chunk(chunk, sizeof(sctp_errhdr_t), &err);\n}\n\n/* A helper to initialize an op error inside a\n * provided chunk, as most cause codes will be embedded inside an\n * abort chunk.  Differs from sctp_init_cause in that it won't oops\n * if there isn't enough space in the op error chunk\n */\nstatic int sctp_init_cause_fixed(struct sctp_chunk *chunk, __be16 cause_code,\n\t\t      size_t paylen)\n{\n\tsctp_errhdr_t err;\n\t__u16 len;\n\n\t/* Cause code constants are now defined in network order.  */\n\terr.cause = cause_code;\n\tlen = sizeof(sctp_errhdr_t) + paylen;\n\terr.length  = htons(len);\n\n\tif (skb_tailroom(chunk->skb) < len)\n\t\treturn -ENOSPC;\n\tchunk->subh.err_hdr = sctp_addto_chunk_fixed(chunk,\n\t\t\t\t\t\t     sizeof(sctp_errhdr_t),\n\t\t\t\t\t\t     &err);\n\treturn 0;\n}\n/* 3.3.2 Initiation (INIT) (1)\n *\n * This chunk is used to initiate a SCTP association between two\n * endpoints. The format of the INIT chunk is shown below:\n *\n *     0                   1                   2                   3\n *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |   Type = 1    |  Chunk Flags  |      Chunk Length             |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |                         Initiate Tag                          |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |           Advertised Receiver Window Credit (a_rwnd)          |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |  Number of Outbound Streams   |  Number of Inbound Streams    |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |                          Initial TSN                          |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    \\                                                               \\\n *    /              Optional/Variable-Length Parameters              /\n *    \\                                                               \\\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n *\n * The INIT chunk contains the following parameters. Unless otherwise\n * noted, each parameter MUST only be included once in the INIT chunk.\n *\n * Fixed Parameters                     Status\n * ----------------------------------------------\n * Initiate Tag                        Mandatory\n * Advertised Receiver Window Credit   Mandatory\n * Number of Outbound Streams          Mandatory\n * Number of Inbound Streams           Mandatory\n * Initial TSN                         Mandatory\n *\n * Variable Parameters                  Status     Type Value\n * -------------------------------------------------------------\n * IPv4 Address (Note 1)               Optional    5\n * IPv6 Address (Note 1)               Optional    6\n * Cookie Preservative                 Optional    9\n * Reserved for ECN Capable (Note 2)   Optional    32768 (0x8000)\n * Host Name Address (Note 3)          Optional    11\n * Supported Address Types (Note 4)    Optional    12\n */\nstruct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tstruct sctp_endpoint *ep = asoc->ep;\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n\tchunksize += sizeof(ecap_param);\n\n\tif (net->sctp.prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (net->sctp.addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (ep->auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_control(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (net->sctp.prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (ep->auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t gfp_t gfp, int unkparam_len)\n{\n\tsctp_inithdr_t initack;\n\tstruct sctp_chunk *retval;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\tint addrs_len;\n\tsctp_cookie_param_t *cookie;\n\tint cookie_len;\n\tsize_t chunksize;\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL,\n\t\t\t*auth_random = NULL;\n\n\tretval = NULL;\n\n\t/* Note: there may be no addresses to embed. */\n\taddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\n\n\tinitack.init_tag\t        = htonl(asoc->c.my_vtag);\n\tinitack.a_rwnd\t\t\t= htonl(asoc->rwnd);\n\tinitack.num_outbound_streams\t= htons(asoc->c.sinit_num_ostreams);\n\tinitack.num_inbound_streams\t= htons(asoc->c.sinit_max_instreams);\n\tinitack.initial_tsn\t\t= htonl(asoc->c.initial_tsn);\n\n\t/* FIXME:  We really ought to build the cookie right\n\t * into the packet instead of allocating more fresh memory.\n\t */\n\tcookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\n\t\t\t\t  addrs.v, addrs_len);\n\tif (!cookie)\n\t\tgoto nomem_cookie;\n\n\t/* Calculate the total size of allocation, include the reserved\n\t * space for reporting unknown parameters if it is specified.\n\t */\n\tsp = sctp_sk(asoc->base.sk);\n\tchunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;\n\n\t/* Tell peer that we'll do ECN only if peer advertised such cap.  */\n\tif (asoc->peer.ecn_capable)\n\t\tchunksize += sizeof(ecap_param);\n\n\tif (asoc->peer.prsctp_capable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\tif (asoc->peer.asconf_capable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tif (asoc->peer.auth_capable) {\n\t\tauth_random = (sctp_paramhdr_t *)asoc->c.auth_random;\n\t\tchunksize += ntohs(auth_random->length);\n\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* Now allocate and fill out the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_INIT_ACK, 0, chunksize);\n\tif (!retval)\n\t\tgoto nomem_chunk;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [INIT ACK back to where the INIT came from.]\n\t */\n\tretval->transport = chunk->transport;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(initack), &initack);\n\tretval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);\n\tsctp_addto_chunk(retval, cookie_len, cookie);\n\tif (asoc->peer.ecn_capable)\n\t\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t &ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\tif (asoc->peer.prsctp_capable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\tif (asoc->peer.auth_capable) {\n\t\tsctp_addto_chunk(retval, ntohs(auth_random->length),\n\t\t\t\t auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\n\n\t/* We need to remove the const qualifier at this point.  */\n\tretval->asoc = (struct sctp_association *) asoc;\n\nnomem_chunk:\n\tkfree(cookie);\nnomem_cookie:\n\tkfree(addrs.v);\n\treturn retval;\n}\n\n/* 3.3.11 Cookie Echo (COOKIE ECHO) (10):\n *\n * This chunk is used only during the initialization of an association.\n * It is sent by the initiator of an association to its peer to complete\n * the initialization process. This chunk MUST precede any DATA chunk\n * sent within the association, but MAY be bundled with one or more DATA\n * chunks in the same packet.\n *\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |   Type = 10   |Chunk  Flags   |         Length                |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     /                     Cookie                                    /\n *     \\                                                               \\\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Chunk Flags: 8 bit\n *\n *   Set to zero on transmit and ignored on receipt.\n *\n * Length: 16 bits (unsigned integer)\n *\n *   Set to the size of the chunk in bytes, including the 4 bytes of\n *   the chunk header and the size of the Cookie.\n *\n * Cookie: variable size\n *\n *   This field must contain the exact cookie received in the\n *   State Cookie parameter from the previous INIT ACK.\n *\n *   An implementation SHOULD make the cookie as small as possible\n *   to insure interoperability.\n */\nstruct sctp_chunk *sctp_make_cookie_echo(const struct sctp_association *asoc,\n\t\t\t\t    const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tvoid *cookie;\n\tint cookie_len;\n\n\tcookie = asoc->peer.cookie;\n\tcookie_len = asoc->peer.cookie_len;\n\n\t/* Build a cookie echo chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ECHO, 0, cookie_len);\n\tif (!retval)\n\t\tgoto nodata;\n\tretval->subh.cookie_hdr =\n\t\tsctp_addto_chunk(retval, cookie_len, cookie);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [COOKIE ECHO back to where the INIT ACK came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* 3.3.12 Cookie Acknowledgement (COOKIE ACK) (11):\n *\n * This chunk is used only during the initialization of an\n * association.  It is used to acknowledge the receipt of a COOKIE\n * ECHO chunk.  This chunk MUST precede any DATA or SACK chunk sent\n * within the association, but MAY be bundled with one or more DATA\n * chunks or SACK chunk in the same SCTP packet.\n *\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |   Type = 11   |Chunk  Flags   |     Length = 4                |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Chunk Flags: 8 bits\n *\n *   Set to zero on transmit and ignored on receipt.\n */\nstruct sctp_chunk *sctp_make_cookie_ack(const struct sctp_association *asoc,\n\t\t\t\t   const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_COOKIE_ACK, 0, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [COOKIE ACK back to where the COOKIE ECHO came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n/*\n *  Appendix A: Explicit Congestion Notification:\n *  CWR:\n *\n *  RFC 2481 details a specific bit for a sender to send in the header of\n *  its next outbound TCP segment to indicate to its peer that it has\n *  reduced its congestion window.  This is termed the CWR bit.  For\n *  SCTP the same indication is made by including the CWR chunk.\n *  This chunk contains one data element, i.e. the TSN number that\n *  was sent in the ECNE chunk.  This element represents the lowest\n *  TSN number in the datagram that was originally marked with the\n *  CE bit.\n *\n *     0                   1                   2                   3\n *     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    | Chunk Type=13 | Flags=00000000|    Chunk Length = 8           |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *    |                      Lowest TSN Number                        |\n *    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n *     Note: The CWR is considered a Control chunk.\n */\nstruct sctp_chunk *sctp_make_cwr(const struct sctp_association *asoc,\n\t\t\t    const __u32 lowest_tsn,\n\t\t\t    const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_cwrhdr_t cwr;\n\n\tcwr.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_CWR, 0,\n\t\t\t\t   sizeof(sctp_cwrhdr_t));\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.ecn_cwr_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(cwr), &cwr);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [Report a reduced congestion window back to where the ECNE\n\t * came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* Make an ECNE chunk.  This is a congestion experienced report.  */\nstruct sctp_chunk *sctp_make_ecne(const struct sctp_association *asoc,\n\t\t\t     const __u32 lowest_tsn)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_ecnehdr_t ecne;\n\n\tecne.lowest_tsn = htonl(lowest_tsn);\n\tretval = sctp_make_control(asoc, SCTP_CID_ECN_ECNE, 0,\n\t\t\t\t   sizeof(sctp_ecnehdr_t));\n\tif (!retval)\n\t\tgoto nodata;\n\tretval->subh.ecne_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ecne), &ecne);\n\nnodata:\n\treturn retval;\n}\n\n/* Make a DATA chunk for the given association from the provided\n * parameters.  However, do not populate the data payload.\n */\nstruct sctp_chunk *sctp_make_datafrag_empty(struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_sndrcvinfo *sinfo,\n\t\t\t\t       int data_len, __u8 flags, __u16 ssn)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_datahdr dp;\n\tint chunk_len;\n\n\t/* We assign the TSN as LATE as possible, not here when\n\t * creating the chunk.\n\t */\n\tdp.tsn = 0;\n\tdp.stream = htons(sinfo->sinfo_stream);\n\tdp.ppid   = sinfo->sinfo_ppid;\n\n\t/* Set the flags for an unordered send.  */\n\tif (sinfo->sinfo_flags & SCTP_UNORDERED) {\n\t\tflags |= SCTP_DATA_UNORDERED;\n\t\tdp.ssn = 0;\n\t} else\n\t\tdp.ssn = htons(ssn);\n\n\tchunk_len = sizeof(dp) + data_len;\n\tretval = sctp_make_data(asoc, flags, chunk_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.data_hdr = sctp_addto_chunk(retval, sizeof(dp), &dp);\n\tmemcpy(&retval->sinfo, sinfo, sizeof(struct sctp_sndrcvinfo));\n\nnodata:\n\treturn retval;\n}\n\n/* Create a selective ackowledgement (SACK) for the given\n * association.  This reports on which TSN's we've seen to date,\n * including duplicates and gaps.\n */\nstruct sctp_chunk *sctp_make_sack(const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_sackhdr sack;\n\tint len;\n\t__u32 ctsn;\n\t__u16 num_gabs, num_dup_tsns;\n\tstruct sctp_association *aptr = (struct sctp_association *)asoc;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sctp_gap_ack_block gabs[SCTP_MAX_GABS];\n\tstruct sctp_transport *trans;\n\n\tmemset(gabs, 0, sizeof(gabs));\n\tctsn = sctp_tsnmap_get_ctsn(map);\n\n\tpr_debug(\"%s: sackCTSNAck sent:0x%x\\n\", __func__, ctsn);\n\n\t/* How much room is needed in the chunk? */\n\tnum_gabs = sctp_tsnmap_num_gabs(map, gabs);\n\tnum_dup_tsns = sctp_tsnmap_num_dups(map);\n\n\t/* Initialize the SACK header.  */\n\tsack.cum_tsn_ack\t    = htonl(ctsn);\n\tsack.a_rwnd \t\t    = htonl(asoc->a_rwnd);\n\tsack.num_gap_ack_blocks     = htons(num_gabs);\n\tsack.num_dup_tsns           = htons(num_dup_tsns);\n\n\tlen = sizeof(sack)\n\t\t+ sizeof(struct sctp_gap_ack_block) * num_gabs\n\t\t+ sizeof(__u32) * num_dup_tsns;\n\n\t/* Create the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_SACK, 0, len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk to\n\t * which it is replying.  This rule should also be followed if\n\t * the endpoint is bundling DATA chunks together with the\n\t * reply chunk.\n\t *\n\t * However, when acknowledging multiple DATA chunks received\n\t * in packets from different source addresses in a single\n\t * SACK, the SACK chunk may be transmitted to one of the\n\t * destination transport addresses from which the DATA or\n\t * control chunks being acknowledged were received.\n\t *\n\t * [BUG:  We do not implement the following paragraph.\n\t * Perhaps we should remember the last transport we used for a\n\t * SACK and avoid that (if possible) if we have seen any\n\t * duplicates. --piggy]\n\t *\n\t * When a receiver of a duplicate DATA chunk sends a SACK to a\n\t * multi- homed endpoint it MAY be beneficial to vary the\n\t * destination address and not use the source address of the\n\t * DATA chunk.  The reason being that receiving a duplicate\n\t * from a multi-homed endpoint might indicate that the return\n\t * path (as specified in the source address of the DATA chunk)\n\t * for the SACK is broken.\n\t *\n\t * [Send to the address from which we last received a DATA chunk.]\n\t */\n\tretval->transport = asoc->peer.last_data_from;\n\n\tretval->subh.sack_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(sack), &sack);\n\n\t/* Add the gap ack block information.   */\n\tif (num_gabs)\n\t\tsctp_addto_chunk(retval, sizeof(__u32) * num_gabs,\n\t\t\t\t gabs);\n\n\t/* Add the duplicate TSN information.  */\n\tif (num_dup_tsns) {\n\t\taptr->stats.idupchunks += num_dup_tsns;\n\t\tsctp_addto_chunk(retval, sizeof(__u32) * num_dup_tsns,\n\t\t\t\t sctp_tsnmap_get_dups(map));\n\t}\n\t/* Once we have a sack generated, check to see what our sack\n\t * generation is, if its 0, reset the transports to 0, and reset\n\t * the association generation to 1\n\t *\n\t * The idea is that zero is never used as a valid generation for the\n\t * association so no transport will match after a wrap event like this,\n\t * Until the next sack\n\t */\n\tif (++aptr->peer.sack_generation == 0) {\n\t\tlist_for_each_entry(trans, &asoc->peer.transport_addr_list,\n\t\t\t\t    transports)\n\t\t\ttrans->sack_generation = 0;\n\t\taptr->peer.sack_generation = 1;\n\t}\nnodata:\n\treturn retval;\n}\n\n/* Make a SHUTDOWN chunk. */\nstruct sctp_chunk *sctp_make_shutdown(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_shutdownhdr_t shut;\n\t__u32 ctsn;\n\n\tctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\n\tshut.cum_tsn_ack = htonl(ctsn);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN, 0,\n\t\t\t\t   sizeof(sctp_shutdownhdr_t));\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.shutdown_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(shut), &shut);\n\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ACK back to where the SHUTDOWN came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_shutdown_complete(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t/* Set the T-bit if we have no association (vtag will be\n\t * reflected)\n\t */\n\tflags |= asoc ? 0 : SCTP_CHUNK_FLAG_T;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_COMPLETE, flags, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [Report SHUTDOWN COMPLETE back to where the SHUTDOWN ACK\n\t * came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n/* Create an ABORT.  Note that we set the T bit if we have no\n * association, except when responding to an INIT (sctpimpguide 2.41).\n */\nstruct sctp_chunk *sctp_make_abort(const struct sctp_association *asoc,\n\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t      const size_t hint)\n{\n\tstruct sctp_chunk *retval;\n\t__u8 flags = 0;\n\n\t/* Set the T-bit if we have no association and 'chunk' is not\n\t * an INIT (vtag will be reflected).\n\t */\n\tif (!asoc) {\n\t\tif (chunk && chunk->chunk_hdr &&\n\t\t    chunk->chunk_hdr->type == SCTP_CID_INIT)\n\t\t\tflags = 0;\n\t\telse\n\t\t\tflags = SCTP_CHUNK_FLAG_T;\n\t}\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ABORT, flags, hint);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ABORT back to where the offender came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n\n/* Helper to create ABORT with a NO_USER_DATA error.  */\nstruct sctp_chunk *sctp_make_abort_no_data(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk, __u32 tsn)\n{\n\tstruct sctp_chunk *retval;\n\t__be32 payload;\n\n\tretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t)\n\t\t\t\t + sizeof(tsn));\n\n\tif (!retval)\n\t\tgoto no_mem;\n\n\t/* Put the tsn back into network byte order.  */\n\tpayload = htonl(tsn);\n\tsctp_init_cause(retval, SCTP_ERROR_NO_DATA, sizeof(payload));\n\tsctp_addto_chunk(retval, sizeof(payload), (const void *)&payload);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ABORT back to where the offender came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nno_mem:\n\treturn retval;\n}\n\n/* Helper to create ABORT with a SCTP_ERROR_USER_ABORT error.  */\nstruct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,\n\t\t\t\t\tconst struct msghdr *msg,\n\t\t\t\t\tsize_t paylen)\n{\n\tstruct sctp_chunk *retval;\n\tvoid *payload = NULL;\n\tint err;\n\n\tretval = sctp_make_abort(asoc, NULL, sizeof(sctp_errhdr_t) + paylen);\n\tif (!retval)\n\t\tgoto err_chunk;\n\n\tif (paylen) {\n\t\t/* Put the msg_iov together into payload.  */\n\t\tpayload = kmalloc(paylen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto err_payload;\n\n\t\terr = memcpy_fromiovec(payload, msg->msg_iov, paylen);\n\t\tif (err < 0)\n\t\t\tgoto err_copy;\n\t}\n\n\tsctp_init_cause(retval, SCTP_ERROR_USER_ABORT, paylen);\n\tsctp_addto_chunk(retval, paylen, payload);\n\n\tif (paylen)\n\t\tkfree(payload);\n\n\treturn retval;\n\nerr_copy:\n\tkfree(payload);\nerr_payload:\n\tsctp_chunk_free(retval);\n\tretval = NULL;\nerr_chunk:\n\treturn retval;\n}\n\n/* Append bytes to the end of a parameter.  Will panic if chunk is not big\n * enough.\n */\nstatic void *sctp_addto_param(struct sctp_chunk *chunk, int len,\n\t\t\t      const void *data)\n{\n\tvoid *target;\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\n\ttarget = skb_put(chunk->skb, len);\n\n\tif (data)\n\t\tmemcpy(target, data, len);\n\telse\n\t\tmemset(target, 0, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n/* Make an ABORT chunk with a PROTOCOL VIOLATION cause code. */\nstruct sctp_chunk *sctp_make_abort_violation(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk,\n\tconst __u8   *payload,\n\tconst size_t paylen)\n{\n\tstruct sctp_chunk  *retval;\n\tstruct sctp_paramhdr phdr;\n\n\tretval = sctp_make_abort(asoc, chunk, sizeof(sctp_errhdr_t) + paylen\n\t\t\t\t\t+ sizeof(sctp_paramhdr_t));\n\tif (!retval)\n\t\tgoto end;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, paylen\n\t\t\t\t\t+ sizeof(sctp_paramhdr_t));\n\n\tphdr.type = htons(chunk->chunk_hdr->type);\n\tphdr.length = chunk->chunk_hdr->length;\n\tsctp_addto_chunk(retval, paylen, payload);\n\tsctp_addto_param(retval, sizeof(sctp_paramhdr_t), &phdr);\n\nend:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_violation_paramlen(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk,\n\tstruct sctp_paramhdr *param)\n{\n\tstruct sctp_chunk *retval;\n\tstatic const char error[] = \"The following parameter had invalid length:\";\n\tsize_t payload_len = sizeof(error) + sizeof(sctp_errhdr_t) +\n\t\t\t\tsizeof(sctp_paramhdr_t);\n\n\tretval = sctp_make_abort(asoc, chunk, payload_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION,\n\t\t\tsizeof(error) + sizeof(sctp_paramhdr_t));\n\tsctp_addto_chunk(retval, sizeof(error), error);\n\tsctp_addto_param(retval, sizeof(sctp_paramhdr_t), param);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_violation_max_retrans(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\tstatic const char error[] = \"Association exceeded its max_retans count\";\n\tsize_t payload_len = sizeof(error) + sizeof(sctp_errhdr_t);\n\n\tretval = sctp_make_abort(asoc, chunk, payload_len);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, SCTP_ERROR_PROTO_VIOLATION, sizeof(error));\n\tsctp_addto_chunk(retval, sizeof(error), error);\n\nnodata:\n\treturn retval;\n}\n\n/* Make a HEARTBEAT chunk.  */\nstruct sctp_chunk *sctp_make_heartbeat(const struct sctp_association *asoc,\n\t\t\t\t  const struct sctp_transport *transport)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_sender_hb_info_t hbinfo;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_HEARTBEAT, 0, sizeof(hbinfo));\n\n\tif (!retval)\n\t\tgoto nodata;\n\n\thbinfo.param_hdr.type = SCTP_PARAM_HEARTBEAT_INFO;\n\thbinfo.param_hdr.length = htons(sizeof(sctp_sender_hb_info_t));\n\thbinfo.daddr = transport->ipaddr;\n\thbinfo.sent_at = jiffies;\n\thbinfo.hb_nonce = transport->hb_nonce;\n\n\t/* Cast away the 'const', as this is just telling the chunk\n\t * what transport it belongs to.\n\t */\n\tretval->transport = (struct sctp_transport *) transport;\n\tretval->subh.hbs_hdr = sctp_addto_chunk(retval, sizeof(hbinfo),\n\t\t\t\t\t\t&hbinfo);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_heartbeat_ack(const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *chunk,\n\t\t\t\t      const void *payload, const size_t paylen)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval  = sctp_make_control(asoc, SCTP_CID_HEARTBEAT_ACK, 0, paylen);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.hbs_hdr = sctp_addto_chunk(retval, paylen, payload);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [HBACK back to where the HEARTBEAT came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* Create an Operation Error chunk with the specified space reserved.\n * This routine can be used for containing multiple causes in the chunk.\n */\nstatic struct sctp_chunk *sctp_make_op_error_space(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk,\n\tsize_t size)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_ERROR, 0,\n\t\t\t\t   sizeof(sctp_errhdr_t) + size);\n\tif (!retval)\n\t\tgoto nodata;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnodata:\n\treturn retval;\n}\n\n/* Create an Operation Error chunk of a fixed size,\n * specifically, max(asoc->pathmtu, SCTP_DEFAULT_MAXSEGMENT)\n * This is a helper function to allocate an error chunk for\n * for those invalid parameter codes in which we may not want\n * to report all the errors, if the incoming chunk is large\n */\nstatic inline struct sctp_chunk *sctp_make_op_error_fixed(\n\tconst struct sctp_association *asoc,\n\tconst struct sctp_chunk *chunk)\n{\n\tsize_t size = asoc ? asoc->pathmtu : 0;\n\n\tif (!size)\n\t\tsize = SCTP_DEFAULT_MAXSEGMENT;\n\n\treturn sctp_make_op_error_space(asoc, chunk, size);\n}\n\n/* Create an Operation Error chunk.  */\nstruct sctp_chunk *sctp_make_op_error(const struct sctp_association *asoc,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t __be16 cause_code, const void *payload,\n\t\t\t\t size_t paylen, size_t reserve_tail)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_op_error_space(asoc, chunk, paylen + reserve_tail);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tsctp_init_cause(retval, cause_code, paylen + reserve_tail);\n\tsctp_addto_chunk(retval, paylen, payload);\n\tif (reserve_tail)\n\t\tsctp_addto_param(retval, reserve_tail, NULL);\n\nnodata:\n\treturn retval;\n}\n\nstruct sctp_chunk *sctp_make_auth(const struct sctp_association *asoc)\n{\n\tstruct sctp_chunk *retval;\n\tstruct sctp_hmac *hmac_desc;\n\tstruct sctp_authhdr auth_hdr;\n\t__u8 *hmac;\n\n\t/* Get the first hmac that the peer told us to use */\n\thmac_desc = sctp_auth_asoc_get_hmac(asoc);\n\tif (unlikely(!hmac_desc))\n\t\treturn NULL;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_AUTH, 0,\n\t\t\thmac_desc->hmac_len + sizeof(sctp_authhdr_t));\n\tif (!retval)\n\t\treturn NULL;\n\n\tauth_hdr.hmac_id = htons(hmac_desc->hmac_id);\n\tauth_hdr.shkey_id = htons(asoc->active_key_id);\n\n\tretval->subh.auth_hdr = sctp_addto_chunk(retval, sizeof(sctp_authhdr_t),\n\t\t\t\t\t\t&auth_hdr);\n\n\thmac = skb_put(retval->skb, hmac_desc->hmac_len);\n\tmemset(hmac, 0, hmac_desc->hmac_len);\n\n\t/* Adjust the chunk header to include the empty MAC */\n\tretval->chunk_hdr->length =\n\t\thtons(ntohs(retval->chunk_hdr->length) + hmac_desc->hmac_len);\n\tretval->chunk_end = skb_tail_pointer(retval->skb);\n\n\treturn retval;\n}\n\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Turn an skb into a chunk.\n * FIXME: Eventually move the structure directly inside the skb->cb[].\n *\n * sctpimpguide-05.txt Section 2.8.2\n * M1) Each time a new DATA chunk is transmitted\n * set the 'TSN.Missing.Report' count for that TSN to 0. The\n * 'TSN.Missing.Report' count will be used to determine missing chunks\n * and when to fast retransmit.\n *\n */\nstruct sctp_chunk *sctp_chunkify(struct sk_buff *skb,\n\t\t\t    const struct sctp_association *asoc,\n\t\t\t    struct sock *sk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = kmem_cache_zalloc(sctp_chunk_cachep, GFP_ATOMIC);\n\n\tif (!retval)\n\t\tgoto nodata;\n\tif (!sk)\n\t\tpr_debug(\"%s: chunkifying skb:%p w/o an sk\\n\", __func__, skb);\n\n\tINIT_LIST_HEAD(&retval->list);\n\tretval->skb\t\t= skb;\n\tretval->asoc\t\t= (struct sctp_association *)asoc;\n\tretval->singleton\t= 1;\n\n\tretval->fast_retransmit = SCTP_CAN_FRTX;\n\n\t/* Polish the bead hole.  */\n\tINIT_LIST_HEAD(&retval->transmitted_list);\n\tINIT_LIST_HEAD(&retval->frag_list);\n\tSCTP_DBG_OBJCNT_INC(chunk);\n\tatomic_set(&retval->refcnt, 1);\n\nnodata:\n\treturn retval;\n}\n\n/* Set chunk->source and dest based on the IP header in chunk->skb.  */\nvoid sctp_init_addrs(struct sctp_chunk *chunk, union sctp_addr *src,\n\t\t     union sctp_addr *dest)\n{\n\tmemcpy(&chunk->source, src, sizeof(union sctp_addr));\n\tmemcpy(&chunk->dest, dest, sizeof(union sctp_addr));\n}\n\n/* Extract the source address from a chunk.  */\nconst union sctp_addr *sctp_source(const struct sctp_chunk *chunk)\n{\n\t/* If we have a known transport, use that.  */\n\tif (chunk->transport) {\n\t\treturn &chunk->transport->ipaddr;\n\t} else {\n\t\t/* Otherwise, extract it from the IP header.  */\n\t\treturn &chunk->source;\n\t}\n}\n\n/* Create a new chunk, setting the type and flags headers from the\n * arguments, reserving enough space for a 'paylen' byte payload.\n */\nstatic struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_chunkhdr_t *chunk_hdr;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\n\t/* No need to allocate LL here, as this is only a chunk. */\n\tskb = alloc_skb(WORD_ROUND(sizeof(sctp_chunkhdr_t) + paylen),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto nodata;\n\n\t/* Make room for the chunk header.  */\n\tchunk_hdr = (sctp_chunkhdr_t *)skb_put(skb, sizeof(sctp_chunkhdr_t));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(sctp_chunkhdr_t));\n\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(struct sctp_chunkhdr);\n\n\t/* Determine if the chunk needs to be authenticated */\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\n\treturn retval;\nnodata:\n\treturn NULL;\n}\n\nstatic struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen)\n{\n\treturn _sctp_make_chunk(asoc, SCTP_CID_DATA, flags, paylen);\n}\n\nstatic struct sctp_chunk *sctp_make_control(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen)\n{\n\tstruct sctp_chunk *chunk = _sctp_make_chunk(asoc, type, flags, paylen);\n\n\tif (chunk)\n\t\tsctp_control_set_owner_w(chunk);\n\n\treturn chunk;\n}\n\n/* Release the memory occupied by a chunk.  */\nstatic void sctp_chunk_destroy(struct sctp_chunk *chunk)\n{\n\tBUG_ON(!list_empty(&chunk->list));\n\tlist_del_init(&chunk->transmitted_list);\n\n\tconsume_skb(chunk->skb);\n\tconsume_skb(chunk->auth_chunk);\n\n\tSCTP_DBG_OBJCNT_DEC(chunk);\n\tkmem_cache_free(sctp_chunk_cachep, chunk);\n}\n\n/* Possibly, free the chunk.  */\nvoid sctp_chunk_free(struct sctp_chunk *chunk)\n{\n\t/* Release our reference on the message tracker. */\n\tif (chunk->msg)\n\t\tsctp_datamsg_put(chunk->msg);\n\n\tsctp_chunk_put(chunk);\n}\n\n/* Grab a reference to the chunk. */\nvoid sctp_chunk_hold(struct sctp_chunk *ch)\n{\n\tatomic_inc(&ch->refcnt);\n}\n\n/* Release a reference to the chunk. */\nvoid sctp_chunk_put(struct sctp_chunk *ch)\n{\n\tif (atomic_dec_and_test(&ch->refcnt))\n\t\tsctp_chunk_destroy(ch);\n}\n\n/* Append bytes to the end of a chunk.  Will panic if chunk is not big\n * enough.\n */\nvoid *sctp_addto_chunk(struct sctp_chunk *chunk, int len, const void *data)\n{\n\tvoid *target;\n\tvoid *padding;\n\tint chunklen = ntohs(chunk->chunk_hdr->length);\n\tint padlen = WORD_ROUND(chunklen) - chunklen;\n\n\tpadding = skb_put(chunk->skb, padlen);\n\ttarget = skb_put(chunk->skb, len);\n\n\tmemset(padding, 0, padlen);\n\tmemcpy(target, data, len);\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length = htons(chunklen + padlen + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\n\treturn target;\n}\n\n/* Append bytes to the end of a chunk. Returns NULL if there isn't sufficient\n * space in the chunk\n */\nstatic void *sctp_addto_chunk_fixed(struct sctp_chunk *chunk,\n\t\t\t\t    int len, const void *data)\n{\n\tif (skb_tailroom(chunk->skb) >= len)\n\t\treturn sctp_addto_chunk(chunk, len, data);\n\telse\n\t\treturn NULL;\n}\n\n/* Append bytes from user space to the end of a chunk.  Will panic if\n * chunk is not big enough.\n * Returns a kernel err value.\n */\nint sctp_user_addto_chunk(struct sctp_chunk *chunk, int off, int len,\n\t\t\t  struct iovec *data)\n{\n\t__u8 *target;\n\tint err = 0;\n\n\t/* Make room in chunk for data.  */\n\ttarget = skb_put(chunk->skb, len);\n\n\t/* Copy data (whole iovec) into chunk */\n\tif ((err = memcpy_fromiovecend(target, data, off, len)))\n\t\tgoto out;\n\n\t/* Adjust the chunk length field.  */\n\tchunk->chunk_hdr->length =\n\t\thtons(ntohs(chunk->chunk_hdr->length) + len);\n\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\nout:\n\treturn err;\n}\n\n/* Helper function to assign a TSN if needed.  This assumes that both\n * the data_hdr and association have already been assigned.\n */\nvoid sctp_chunk_assign_ssn(struct sctp_chunk *chunk)\n{\n\tstruct sctp_datamsg *msg;\n\tstruct sctp_chunk *lchunk;\n\tstruct sctp_stream *stream;\n\t__u16 ssn;\n\t__u16 sid;\n\n\tif (chunk->has_ssn)\n\t\treturn;\n\n\t/* All fragments will be on the same stream */\n\tsid = ntohs(chunk->subh.data_hdr->stream);\n\tstream = &chunk->asoc->ssnmap->out;\n\n\t/* Now assign the sequence number to the entire message.\n\t * All fragments must have the same stream sequence number.\n\t */\n\tmsg = chunk->msg;\n\tlist_for_each_entry(lchunk, &msg->chunks, frag_list) {\n\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\t\tssn = 0;\n\t\t} else {\n\t\t\tif (lchunk->chunk_hdr->flags & SCTP_DATA_LAST_FRAG)\n\t\t\t\tssn = sctp_ssn_next(stream, sid);\n\t\t\telse\n\t\t\t\tssn = sctp_ssn_peek(stream, sid);\n\t\t}\n\n\t\tlchunk->subh.data_hdr->ssn = htons(ssn);\n\t\tlchunk->has_ssn = 1;\n\t}\n}\n\n/* Helper function to assign a TSN if needed.  This assumes that both\n * the data_hdr and association have already been assigned.\n */\nvoid sctp_chunk_assign_tsn(struct sctp_chunk *chunk)\n{\n\tif (!chunk->has_tsn) {\n\t\t/* This is the last possible instant to\n\t\t * assign a TSN.\n\t\t */\n\t\tchunk->subh.data_hdr->tsn =\n\t\t\thtonl(sctp_association_get_next_tsn(chunk->asoc));\n\t\tchunk->has_tsn = 1;\n\t}\n}\n\n/* Create a CLOSED association to use with an incoming packet.  */\nstruct sctp_association *sctp_make_temp_asoc(const struct sctp_endpoint *ep,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tgfp_t gfp)\n{\n\tstruct sctp_association *asoc;\n\tstruct sk_buff *skb;\n\tsctp_scope_t scope;\n\tstruct sctp_af *af;\n\n\t/* Create the bare association.  */\n\tscope = sctp_scope(sctp_source(chunk));\n\tasoc = sctp_association_new(ep, ep->base.sk, scope, gfp);\n\tif (!asoc)\n\t\tgoto nodata;\n\tasoc->temp = 1;\n\tskb = chunk->skb;\n\t/* Create an entry for the source address of the packet.  */\n\taf = sctp_get_af_specific(ipver2af(ip_hdr(skb)->version));\n\tif (unlikely(!af))\n\t\tgoto fail;\n\taf->from_skb(&asoc->c.peer_addr, skb, 1);\nnodata:\n\treturn asoc;\n\nfail:\n\tsctp_association_free(asoc);\n\treturn NULL;\n}\n\n/* Build a cookie representing asoc.\n * This INCLUDES the param header needed to put the cookie in the INIT ACK.\n */\nstatic sctp_cookie_param_t *sctp_pack_cookie(const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const struct sctp_chunk *init_chunk,\n\t\t\t\t      int *cookie_len,\n\t\t\t\t      const __u8 *raw_addrs, int addrs_len)\n{\n\tsctp_cookie_param_t *retval;\n\tstruct sctp_signed_cookie *cookie;\n\tstruct scatterlist sg;\n\tint headersize, bodysize;\n\n\t/* Header size is static data prior to the actual cookie, including\n\t * any padding.\n\t */\n\theadersize = sizeof(sctp_paramhdr_t) +\n\t\t     (sizeof(struct sctp_signed_cookie) -\n\t\t      sizeof(struct sctp_cookie));\n\tbodysize = sizeof(struct sctp_cookie)\n\t\t+ ntohs(init_chunk->chunk_hdr->length) + addrs_len;\n\n\t/* Pad out the cookie to a multiple to make the signature\n\t * functions simpler to write.\n\t */\n\tif (bodysize % SCTP_COOKIE_MULTIPLE)\n\t\tbodysize += SCTP_COOKIE_MULTIPLE\n\t\t\t- (bodysize % SCTP_COOKIE_MULTIPLE);\n\t*cookie_len = headersize + bodysize;\n\n\t/* Clear this memory since we are sending this data structure\n\t * out on the network.\n\t */\n\tretval = kzalloc(*cookie_len, GFP_ATOMIC);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tcookie = (struct sctp_signed_cookie *) retval->body;\n\n\t/* Set up the parameter header.  */\n\tretval->p.type = SCTP_PARAM_STATE_COOKIE;\n\tretval->p.length = htons(*cookie_len);\n\n\t/* Copy the cookie part of the association itself.  */\n\tcookie->c = asoc->c;\n\t/* Save the raw address list length in the cookie. */\n\tcookie->c.raw_addr_list_len = addrs_len;\n\n\t/* Remember PR-SCTP capability. */\n\tcookie->c.prsctp_capable = asoc->peer.prsctp_capable;\n\n\t/* Save adaptation indication in the cookie. */\n\tcookie->c.adaptation_ind = asoc->peer.adaptation_ind;\n\n\t/* Set an expiration time for the cookie.  */\n\tcookie->c.expiration = ktime_add(asoc->cookie_life,\n\t\t\t\t\t ktime_get());\n\n\t/* Copy the peer's init packet.  */\n\tmemcpy(&cookie->c.peer_init[0], init_chunk->chunk_hdr,\n\t       ntohs(init_chunk->chunk_hdr->length));\n\n\t/* Copy the raw local address list of the association. */\n\tmemcpy((__u8 *)&cookie->c.peer_init[0] +\n\t       ntohs(init_chunk->chunk_hdr->length), raw_addrs, addrs_len);\n\n\tif (sctp_sk(ep->base.sk)->hmac) {\n\t\tstruct hash_desc desc;\n\n\t\t/* Sign the message.  */\n\t\tsg_init_one(&sg, &cookie->c, bodysize);\n\t\tdesc.tfm = sctp_sk(ep->base.sk)->hmac;\n\t\tdesc.flags = 0;\n\n\t\tif (crypto_hash_setkey(desc.tfm, ep->secret_key,\n\t\t\t\t       sizeof(ep->secret_key)) ||\n\t\t    crypto_hash_digest(&desc, &sg, bodysize, cookie->signature))\n\t\t\tgoto free_cookie;\n\t}\n\n\treturn retval;\n\nfree_cookie:\n\tkfree(retval);\nnodata:\n\t*cookie_len = 0;\n\treturn NULL;\n}\n\n/* Unpack the cookie from COOKIE ECHO chunk, recreating the association.  */\nstruct sctp_association *sctp_unpack_cookie(\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tstruct sctp_chunk *chunk, gfp_t gfp,\n\tint *error, struct sctp_chunk **errp)\n{\n\tstruct sctp_association *retval = NULL;\n\tstruct sctp_signed_cookie *cookie;\n\tstruct sctp_cookie *bear_cookie;\n\tint headersize, bodysize, fixed_size;\n\t__u8 *digest = ep->digest;\n\tstruct scatterlist sg;\n\tunsigned int len;\n\tsctp_scope_t scope;\n\tstruct sk_buff *skb = chunk->skb;\n\tktime_t kt;\n\tstruct hash_desc desc;\n\n\t/* Header size is static data prior to the actual cookie, including\n\t * any padding.\n\t */\n\theadersize = sizeof(sctp_chunkhdr_t) +\n\t\t     (sizeof(struct sctp_signed_cookie) -\n\t\t      sizeof(struct sctp_cookie));\n\tbodysize = ntohs(chunk->chunk_hdr->length) - headersize;\n\tfixed_size = headersize + sizeof(struct sctp_cookie);\n\n\t/* Verify that the chunk looks like it even has a cookie.\n\t * There must be enough room for our cookie and our peer's\n\t * INIT chunk.\n\t */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len < fixed_size + sizeof(struct sctp_chunkhdr))\n\t\tgoto malformed;\n\n\t/* Verify that the cookie has been padded out. */\n\tif (bodysize % SCTP_COOKIE_MULTIPLE)\n\t\tgoto malformed;\n\n\t/* Process the cookie.  */\n\tcookie = chunk->subh.cookie_hdr;\n\tbear_cookie = &cookie->c;\n\n\tif (!sctp_sk(ep->base.sk)->hmac)\n\t\tgoto no_hmac;\n\n\t/* Check the signature.  */\n\tsg_init_one(&sg, bear_cookie, bodysize);\n\tdesc.tfm = sctp_sk(ep->base.sk)->hmac;\n\tdesc.flags = 0;\n\n\tmemset(digest, 0x00, SCTP_SIGNATURE_SIZE);\n\tif (crypto_hash_setkey(desc.tfm, ep->secret_key,\n\t\t\t       sizeof(ep->secret_key)) ||\n\t    crypto_hash_digest(&desc, &sg, bodysize, digest)) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (memcmp(digest, cookie->signature, SCTP_SIGNATURE_SIZE)) {\n\t\t*error = -SCTP_IERROR_BAD_SIG;\n\t\tgoto fail;\n\t}\n\nno_hmac:\n\t/* IG Section 2.35.2:\n\t *  3) Compare the port numbers and the verification tag contained\n\t *     within the COOKIE ECHO chunk to the actual port numbers and the\n\t *     verification tag within the SCTP common header of the received\n\t *     packet. If these values do not match the packet MUST be silently\n\t *     discarded,\n\t */\n\tif (ntohl(chunk->sctp_hdr->vtag) != bear_cookie->my_vtag) {\n\t\t*error = -SCTP_IERROR_BAD_TAG;\n\t\tgoto fail;\n\t}\n\n\tif (chunk->sctp_hdr->source != bear_cookie->peer_addr.v4.sin_port ||\n\t    ntohs(chunk->sctp_hdr->dest) != bear_cookie->my_port) {\n\t\t*error = -SCTP_IERROR_BAD_PORTS;\n\t\tgoto fail;\n\t}\n\n\t/* Check to see if the cookie is stale.  If there is already\n\t * an association, there is no need to check cookie's expiration\n\t * for init collision case of lost COOKIE ACK.\n\t * If skb has been timestamped, then use the stamp, otherwise\n\t * use current time.  This introduces a small possibility that\n\t * that a cookie may be considered expired, but his would only slow\n\t * down the new association establishment instead of every packet.\n\t */\n\tif (sock_flag(ep->base.sk, SOCK_TIMESTAMP))\n\t\tkt = skb_get_ktime(skb);\n\telse\n\t\tkt = ktime_get();\n\n\tif (!asoc && ktime_before(bear_cookie->expiration, kt)) {\n\t\t/*\n\t\t * Section 3.3.10.3 Stale Cookie Error (3)\n\t\t *\n\t\t * Cause of error\n\t\t * ---------------\n\t\t * Stale Cookie Error:  Indicates the receipt of a valid State\n\t\t * Cookie that has expired.\n\t\t */\n\t\tlen = ntohs(chunk->chunk_hdr->length);\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\t\tif (*errp) {\n\t\t\tsuseconds_t usecs = ktime_to_us(ktime_sub(kt, bear_cookie->expiration));\n\t\t\t__be32 n = htonl(usecs);\n\n\t\t\tsctp_init_cause(*errp, SCTP_ERROR_STALE_COOKIE,\n\t\t\t\t\tsizeof(n));\n\t\t\tsctp_addto_chunk(*errp, sizeof(n), &n);\n\t\t\t*error = -SCTP_IERROR_STALE_COOKIE;\n\t\t} else\n\t\t\t*error = -SCTP_IERROR_NOMEM;\n\n\t\tgoto fail;\n\t}\n\n\t/* Make a new base association.  */\n\tscope = sctp_scope(sctp_source(chunk));\n\tretval = sctp_association_new(ep, ep->base.sk, scope, gfp);\n\tif (!retval) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Set up our peer's port number.  */\n\tretval->peer.port = ntohs(chunk->sctp_hdr->source);\n\n\t/* Populate the association from the cookie.  */\n\tmemcpy(&retval->c, bear_cookie, sizeof(*bear_cookie));\n\n\tif (sctp_assoc_set_bind_addr_from_cookie(retval, bear_cookie,\n\t\t\t\t\t\t GFP_ATOMIC) < 0) {\n\t\t*error = -SCTP_IERROR_NOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Also, add the destination address. */\n\tif (list_empty(&retval->base.bind_addr.address_list)) {\n\t\tsctp_add_bind_addr(&retval->base.bind_addr, &chunk->dest,\n\t\t\t\tSCTP_ADDR_SRC, GFP_ATOMIC);\n\t}\n\n\tretval->next_tsn = retval->c.initial_tsn;\n\tretval->ctsn_ack_point = retval->next_tsn - 1;\n\tretval->addip_serial = retval->c.initial_tsn;\n\tretval->adv_peer_ack_point = retval->ctsn_ack_point;\n\tretval->peer.prsctp_capable = retval->c.prsctp_capable;\n\tretval->peer.adaptation_ind = retval->c.adaptation_ind;\n\n\t/* The INIT stuff will be done by the side effects.  */\n\treturn retval;\n\nfail:\n\tif (retval)\n\t\tsctp_association_free(retval);\n\n\treturn NULL;\n\nmalformed:\n\t/* Yikes!  The packet is either corrupt or deliberately\n\t * malformed.\n\t */\n\t*error = -SCTP_IERROR_MALFORMED;\n\tgoto fail;\n}\n\n/********************************************************************\n * 3rd Level Abstractions\n ********************************************************************/\n\nstruct __sctp_missing {\n\t__be32 num_missing;\n\t__be16 type;\n}  __packed;\n\n/*\n * Report a missing mandatory parameter.\n */\nstatic int sctp_process_missing_param(const struct sctp_association *asoc,\n\t\t\t\t      sctp_param_t paramtype,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\tstruct __sctp_missing report;\n\t__u16 len;\n\n\tlen = WORD_ROUND(sizeof(report));\n\n\t/* Make an ERROR chunk, preparing enough room for\n\t * returning multiple unknown parameters.\n\t */\n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\n\tif (*errp) {\n\t\treport.num_missing = htonl(1);\n\t\treport.type = paramtype;\n\t\tsctp_init_cause(*errp, SCTP_ERROR_MISS_PARAM,\n\t\t\t\tsizeof(report));\n\t\tsctp_addto_chunk(*errp, sizeof(report), &report);\n\t}\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}\n\n/* Report an Invalid Mandatory Parameter.  */\nstatic int sctp_process_inv_mandatory(const struct sctp_association *asoc,\n\t\t\t\t      struct sctp_chunk *chunk,\n\t\t\t\t      struct sctp_chunk **errp)\n{\n\t/* Invalid Mandatory Parameter Error has no payload. */\n\n\tif (!*errp)\n\t\t*errp = sctp_make_op_error_space(asoc, chunk, 0);\n\n\tif (*errp)\n\t\tsctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}\n\nstatic int sctp_process_inv_paramlength(const struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_paramhdr *param,\n\t\t\t\t\tconst struct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\t/* This is a fatal error.  Any accumulated non-fatal errors are\n\t * not reported.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t/* Create an error chunk and fill it in with our payload. */\n\t*errp = sctp_make_violation_paramlen(asoc, chunk, param);\n\n\treturn 0;\n}\n\n\n/* Do not attempt to handle the HOST_NAME parm.  However, do\n * send back an indicator to the peer.\n */\nstatic int sctp_process_hn_param(const struct sctp_association *asoc,\n\t\t\t\t union sctp_params param,\n\t\t\t\t struct sctp_chunk *chunk,\n\t\t\t\t struct sctp_chunk **errp)\n{\n\t__u16 len = ntohs(param.p->length);\n\n\t/* Processing of the HOST_NAME parameter will generate an\n\t * ABORT.  If we've accumulated any non-fatal errors, they\n\t * would be unrecognized parameters and we should not include\n\t * them in the ABORT.\n\t */\n\tif (*errp)\n\t\tsctp_chunk_free(*errp);\n\n\t*errp = sctp_make_op_error_space(asoc, chunk, len);\n\n\tif (*errp) {\n\t\tsctp_init_cause(*errp, SCTP_ERROR_DNS_FAILED, len);\n\t\tsctp_addto_chunk(*errp, len, param.v);\n\t}\n\n\t/* Stop processing this chunk. */\n\treturn 0;\n}\n\nstatic int sctp_verify_ext_param(struct net *net, union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\tint have_auth = 0;\n\tint have_asconf = 0;\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_AUTH:\n\t\t\thave_auth = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\thave_asconf = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* ADD-IP Security: The draft requires us to ABORT or ignore the\n\t * INIT/INIT-ACK if ADD-IP is listed, but AUTH is not.  Do this\n\t * only if ADD-IP is turned on and we are not backward-compatible\n\t * mode.\n\t */\n\tif (net->sctp.addip_noauth)\n\t\treturn 1;\n\n\tif (net->sctp.addip_enable && !have_auth && have_asconf)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t    union sctp_params param)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\tint i;\n\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (net->sctp.prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\t    asoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\t/* if the peer reports AUTH, assume that he\n\t\t\t * supports AUTH.\n\t\t\t */\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/* RFC 3.2.1 & the Implementers Guide 2.2.\n *\n * The Parameter Types are encoded such that the\n * highest-order two bits specify the action that must be\n * taken if the processing endpoint does not recognize the\n * Parameter Type.\n *\n * 00 - Stop processing this parameter; do not process any further\n * \tparameters within this chunk\n *\n * 01 - Stop processing this parameter, do not process any further\n *\tparameters within this chunk, and report the unrecognized\n *\tparameter in an 'Unrecognized Parameter' ERROR chunk.\n *\n * 10 - Skip this parameter and continue processing.\n *\n * 11 - Skip this parameter and continue processing but\n *\treport the unrecognized parameter in an\n *\t'Unrecognized Parameter' ERROR chunk.\n *\n * Return value:\n * \tSCTP_IERROR_NO_ERROR - continue with the chunk\n * \tSCTP_IERROR_ERROR    - stop and report an error.\n * \tSCTP_IERROR_NOMEME   - out of memory.\n */\nstatic sctp_ierror_t sctp_process_unk_param(const struct sctp_association *asoc,\n\t\t\t\t\t    union sctp_params param,\n\t\t\t\t\t    struct sctp_chunk *chunk,\n\t\t\t\t\t    struct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\t/* Fall through */\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\t/* Make an ERROR chunk, preparing enough room for\n\t\t * returning multiple unknown parameters.\n\t\t */\n\t\tif (NULL == *errp)\n\t\t\t*errp = sctp_make_op_error_fixed(asoc, chunk);\n\n\t\tif (*errp) {\n\t\t\tif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t\tWORD_ROUND(ntohs(param.p->length))))\n\t\t\t\tsctp_addto_chunk_fixed(*errp,\n\t\t\t\t\t\tWORD_ROUND(ntohs(param.p->length)),\n\t\t\t\t\t\tparam.v);\n\t\t} else {\n\t\t\t/* If there is no memory for generating the ERROR\n\t\t\t * report as specified, an ABORT will be triggered\n\t\t\t * to the peer and the association won't be\n\t\t\t * established.\n\t\t\t */\n\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/* Verify variable length parameters\n * Return values:\n * \tSCTP_IERROR_ABORT - trigger an ABORT\n * \tSCTP_IERROR_NOMEM - out of memory (abort)\n *\tSCTP_IERROR_ERROR - stop processing, trigger an ERROR\n * \tSCTP_IERROR_NO_ERROR - continue with the chunk\n */\nstatic sctp_ierror_t sctp_verify_param(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tsctp_cid_t cid,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **err_chunk)\n{\n\tstruct sctp_hmac_algo_param *hmacs;\n\tint retval = SCTP_IERROR_NO_ERROR;\n\t__u16 n_elt, id = 0;\n\tint i;\n\n\t/* FIXME - This routine is not looking at each parameter per the\n\t * chunk type, i.e., unrecognized parameters should be further\n\t * identified based on the chunk id.\n\t */\n\n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\tcase SCTP_PARAM_STATE_COOKIE:\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tif (!sctp_verify_ext_param(net, param))\n\t\t\treturn SCTP_IERROR_ABORT;\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (net->sctp.addip_enable)\n\t\t\tbreak;\n\t\tgoto fallthrough;\n\n\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\t/* Tell the peer, we won't support this param.  */\n\t\tsctp_process_hn_param(asoc, param, chunk, err_chunk);\n\t\tretval = SCTP_IERROR_ABORT;\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (net->sctp.prsctp_enable)\n\t\t\tbreak;\n\t\tgoto fallthrough;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fallthrough;\n\n\t\t/* SCTP-AUTH: Secion 6.1\n\t\t * If the random number is not 32 byte long the association\n\t\t * MUST be aborted.  The ABORT chunk SHOULD contain the error\n\t\t * cause 'Protocol Violation'.\n\t\t */\n\t\tif (SCTP_AUTH_RANDOM_LENGTH !=\n\t\t\tntohs(param.p->length) - sizeof(sctp_paramhdr_t)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t\tchunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fallthrough;\n\n\t\t/* SCTP-AUTH: Section 3.2\n\t\t * The CHUNKS parameter MUST be included once in the INIT or\n\t\t *  INIT-ACK chunk if the sender wants to receive authenticated\n\t\t *  chunks.  Its maximum length is 260 bytes.\n\t\t */\n\t\tif (260 < ntohs(param.p->length)) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p,\n\t\t\t\t\t\t     chunk, err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fallthrough;\n\n\t\thmacs = (struct sctp_hmac_algo_param *)param.p;\n\t\tn_elt = (ntohs(param.p->length) - sizeof(sctp_paramhdr_t)) >> 1;\n\n\t\t/* SCTP-AUTH: Section 6.1\n\t\t * The HMAC algorithm based on SHA-1 MUST be supported and\n\t\t * included in the HMAC-ALGO parameter.\n\t\t */\n\t\tfor (i = 0; i < n_elt; i++) {\n\t\t\tid = ntohs(hmacs->hmac_ids[i]);\n\n\t\t\tif (id == SCTP_AUTH_HMAC_ID_SHA1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (id != SCTP_AUTH_HMAC_ID_SHA1) {\n\t\t\tsctp_process_inv_paramlength(asoc, param.p, chunk,\n\t\t\t\t\t\t     err_chunk);\n\t\t\tretval = SCTP_IERROR_ABORT;\n\t\t}\n\t\tbreak;\nfallthrough:\n\tdefault:\n\t\tpr_debug(\"%s: unrecognized param:%d for chunk:%d\\n\",\n\t\t\t __func__, ntohs(param.p->type), cid);\n\n\t\tretval = sctp_process_unk_param(asoc, param, chunk, err_chunk);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\n/* Verify the INIT packet before we process it.  */\nint sctp_verify_init(struct net *net, const struct sctp_endpoint *ep,\n\t\t     const struct sctp_association *asoc, sctp_cid_t cid,\n\t\t     sctp_init_chunk_t *peer_init, struct sctp_chunk *chunk,\n\t\t     struct sctp_chunk **errp)\n{\n\tunion sctp_params param;\n\tbool has_cookie = false;\n\tint result;\n\n\t/* Check for missing mandatory parameters. Note: Initial TSN is\n\t * also mandatory, but is not checked here since the valid range\n\t * is 0..2**32-1. RFC4960, section 3.3.3.\n\t */\n\tif (peer_init->init_hdr.num_outbound_streams == 0 ||\n\t    peer_init->init_hdr.num_inbound_streams == 0 ||\n\t    peer_init->init_hdr.init_tag == 0 ||\n\t    ntohl(peer_init->init_hdr.a_rwnd) < SCTP_DEFAULT_MINWINDOW)\n\t\treturn sctp_process_inv_mandatory(asoc, chunk, errp);\n\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\t\tif (param.p->type == SCTP_PARAM_STATE_COOKIE)\n\t\t\thas_cookie = true;\n\t}\n\n\t/* There is a possibility that a parameter length was bad and\n\t * in that case we would have stoped walking the parameters.\n\t * The current param.p would point at the bad one.\n\t * Current consensus on the mailing list is to generate a PROTOCOL\n\t * VIOLATION error.  We build the ERROR chunk here and let the normal\n\t * error handling code build and send the packet.\n\t */\n\tif (param.v != (void *)chunk->chunk_end)\n\t\treturn sctp_process_inv_paramlength(asoc, param.p, chunk, errp);\n\n\t/* The only missing mandatory param possible today is\n\t * the state cookie for an INIT-ACK chunk.\n\t */\n\tif ((SCTP_CID_INIT_ACK == cid) && !has_cookie)\n\t\treturn sctp_process_missing_param(asoc, SCTP_PARAM_STATE_COOKIE,\n\t\t\t\t\t\t  chunk, errp);\n\n\t/* Verify all the variable length parameters */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\t\tresult = sctp_verify_param(net, ep, asoc, param, cid,\n\t\t\t\t\t   chunk, errp);\n\t\tswitch (result) {\n\t\tcase SCTP_IERROR_ABORT:\n\t\tcase SCTP_IERROR_NOMEM:\n\t\t\treturn 0;\n\t\tcase SCTP_IERROR_ERROR:\n\t\t\treturn 1;\n\t\tcase SCTP_IERROR_NO_ERROR:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t} /* for (loop through all parameters) */\n\n\treturn 1;\n}\n\n/* Unpack the parameters in an INIT packet into an association.\n * Returns 0 on failure, else success.\n * FIXME:  This is an association method.\n */\nint sctp_process_init(struct sctp_association *asoc, struct sctp_chunk *chunk,\n\t\t      const union sctp_addr *peer_addr,\n\t\t      sctp_init_chunk_t *peer_init, gfp_t gfp)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tunion sctp_params param;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tstruct sctp_af *af;\n\tunion sctp_addr addr;\n\tchar *cookie;\n\tint src_match = 0;\n\n\t/* We must include the address that the INIT packet came from.\n\t * This is the only address that matters for an INIT packet.\n\t * When processing a COOKIE ECHO, we retrieve the from address\n\t * of the INIT from the cookie.\n\t */\n\n\t/* This implementation defaults to making the first transport\n\t * added as the primary transport.  The source address seems to\n\t * be a a better choice than any of the embedded addresses.\n\t */\n\tif (!sctp_assoc_add_peer(asoc, peer_addr, gfp, SCTP_ACTIVE))\n\t\tgoto nomem;\n\n\tif (sctp_cmp_addr_exact(sctp_source(chunk), peer_addr))\n\t\tsrc_match = 1;\n\n\t/* Process the initialization parameters.  */\n\tsctp_walk_params(param, peer_init, init_hdr.params) {\n\t\tif (!src_match && (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\n\t\t    param.p->type == SCTP_PARAM_IPV6_ADDRESS)) {\n\t\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\t\taf->from_addr_param(&addr, param.addr,\n\t\t\t\t\t    chunk->sctp_hdr->source, 0);\n\t\t\tif (sctp_cmp_addr_exact(sctp_source(chunk), &addr))\n\t\t\t\tsrc_match = 1;\n\t\t}\n\n\t\tif (!sctp_process_param(asoc, param, peer_addr, gfp))\n\t\t\tgoto clean_up;\n\t}\n\n\t/* source address of chunk may not match any valid address */\n\tif (!src_match)\n\t\tgoto clean_up;\n\n\t/* AUTH: After processing the parameters, make sure that we\n\t * have all the required info to potentially do authentications.\n\t */\n\tif (asoc->peer.auth_capable && (!asoc->peer.peer_random ||\n\t\t\t\t\t!asoc->peer.peer_hmacs))\n\t\tasoc->peer.auth_capable = 0;\n\n\t/* In a non-backward compatible mode, if the peer claims\n\t * support for ADD-IP but not AUTH,  the ADD-IP spec states\n\t * that we MUST ABORT the association. Section 6.  The section\n\t * also give us an option to silently ignore the packet, which\n\t * is what we'll do here.\n\t */\n\tif (!net->sctp.addip_noauth &&\n\t     (asoc->peer.asconf_capable && !asoc->peer.auth_capable)) {\n\t\tasoc->peer.addip_disabled_mask |= (SCTP_PARAM_ADD_IP |\n\t\t\t\t\t\t  SCTP_PARAM_DEL_IP |\n\t\t\t\t\t\t  SCTP_PARAM_SET_PRIMARY);\n\t\tasoc->peer.asconf_capable = 0;\n\t\tgoto clean_up;\n\t}\n\n\t/* Walk list of transports, removing transports in the UNKNOWN state. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state == SCTP_UNKNOWN) {\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t\t}\n\t}\n\n\t/* The fixed INIT headers are always in network byte\n\t * order.\n\t */\n\tasoc->peer.i.init_tag =\n\t\tntohl(peer_init->init_hdr.init_tag);\n\tasoc->peer.i.a_rwnd =\n\t\tntohl(peer_init->init_hdr.a_rwnd);\n\tasoc->peer.i.num_outbound_streams =\n\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\tasoc->peer.i.num_inbound_streams =\n\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\tasoc->peer.i.initial_tsn =\n\t\tntohl(peer_init->init_hdr.initial_tsn);\n\n\t/* Apply the upper bounds for output streams based on peer's\n\t * number of inbound streams.\n\t */\n\tif (asoc->c.sinit_num_ostreams  >\n\t    ntohs(peer_init->init_hdr.num_inbound_streams)) {\n\t\tasoc->c.sinit_num_ostreams =\n\t\t\tntohs(peer_init->init_hdr.num_inbound_streams);\n\t}\n\n\tif (asoc->c.sinit_max_instreams >\n\t    ntohs(peer_init->init_hdr.num_outbound_streams)) {\n\t\tasoc->c.sinit_max_instreams =\n\t\t\tntohs(peer_init->init_hdr.num_outbound_streams);\n\t}\n\n\t/* Copy Initiation tag from INIT to VT_peer in cookie.   */\n\tasoc->c.peer_vtag = asoc->peer.i.init_tag;\n\n\t/* Peer Rwnd   : Current calculated value of the peer's rwnd.  */\n\tasoc->peer.rwnd = asoc->peer.i.a_rwnd;\n\n\t/* Copy cookie in case we need to resend COOKIE-ECHO. */\n\tcookie = asoc->peer.cookie;\n\tif (cookie) {\n\t\tasoc->peer.cookie = kmemdup(cookie, asoc->peer.cookie_len, gfp);\n\t\tif (!asoc->peer.cookie)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* RFC 2960 7.2.1 The initial value of ssthresh MAY be arbitrarily\n\t * high (for example, implementations MAY use the size of the receiver\n\t * advertised window).\n\t */\n\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\ttransports) {\n\t\ttransport->ssthresh = asoc->peer.i.a_rwnd;\n\t}\n\n\t/* Set up the TSN tracking pieces.  */\n\tif (!sctp_tsnmap_init(&asoc->peer.tsn_map, SCTP_TSN_MAP_INITIAL,\n\t\t\t\tasoc->peer.i.initial_tsn, gfp))\n\t\tgoto clean_up;\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * The stream sequence number in all the streams shall start\n\t * from 0 when the association is established.  Also, when the\n\t * stream sequence number reaches the value 65535 the next\n\t * stream sequence number shall be set to 0.\n\t */\n\n\t/* Allocate storage for the negotiated streams if it is not a temporary\n\t * association.\n\t */\n\tif (!asoc->temp) {\n\t\tint error;\n\n\t\tasoc->ssnmap = sctp_ssnmap_new(asoc->c.sinit_max_instreams,\n\t\t\t\t\t       asoc->c.sinit_num_ostreams, gfp);\n\t\tif (!asoc->ssnmap)\n\t\t\tgoto clean_up;\n\n\t\terror = sctp_assoc_set_id(asoc, gfp);\n\t\tif (error)\n\t\t\tgoto clean_up;\n\t}\n\n\t/* ADDIP Section 4.1 ASCONF Chunk Procedures\n\t *\n\t * When an endpoint has an ASCONF signaled change to be sent to the\n\t * remote endpoint it should do the following:\n\t * ...\n\t * A2) A serial number should be assigned to the Chunk. The serial\n\t * number should be a monotonically increasing number. All serial\n\t * numbers are defined to be initialized at the start of the\n\t * association to the same value as the Initial TSN.\n\t */\n\tasoc->peer.addip_serial = asoc->peer.i.initial_tsn - 1;\n\treturn 1;\n\nclean_up:\n\t/* Release the transport structures. */\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tif (transport->state != SCTP_ACTIVE)\n\t\t\tsctp_assoc_rm_peer(asoc, transport);\n\t}\n\nnomem:\n\treturn 0;\n}\n\n\n/* Update asoc with the option described in param.\n *\n * RFC2960 3.3.2.1 Optional/Variable Length Parameters in INIT\n *\n * asoc is the association to update.\n * param is the variable length parameter to use for update.\n * cid tells us if this is an INIT, INIT ACK or COOKIE ECHO.\n * If the current packet is an INIT we want to minimize the amount of\n * work we do.  In particular, we should not build transport\n * structures for the addresses.\n */\nstatic int sctp_process_param(struct sctp_association *asoc,\n\t\t\t      union sctp_params param,\n\t\t\t      const union sctp_addr *peer_addr,\n\t\t\t      gfp_t gfp)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tunion sctp_addr addr;\n\tint i;\n\t__u16 sat;\n\tint retval = 1;\n\tsctp_scope_t scope;\n\ttime_t stale;\n\tstruct sctp_af *af;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *t;\n\tstruct sctp_endpoint *ep = asoc->ep;\n\n\t/* We maintain all INIT parameters in network byte order all the\n\t * time.  This allows us to not worry about whether the parameters\n\t * came from a fresh INIT, and INIT ACK, or were stored in a cookie.\n\t */\n\tswitch (param.p->type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (PF_INET6 != asoc->base.sk->sk_family)\n\t\t\tbreak;\n\t\tgoto do_addr_param;\n\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t/* v4 addresses are not allowed on v6-only socket */\n\t\tif (ipv6_only_sock(asoc->base.sk))\n\t\t\tbreak;\ndo_addr_param:\n\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\taf->from_addr_param(&addr, param.addr, htons(asoc->peer.port), 0);\n\t\tscope = sctp_scope(peer_addr);\n\t\tif (sctp_in_scope(net, &addr, scope))\n\t\t\tif (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))\n\t\t\t\treturn 0;\n\t\tbreak;\n\n\tcase SCTP_PARAM_COOKIE_PRESERVATIVE:\n\t\tif (!net->sctp.cookie_preserve_enable)\n\t\t\tbreak;\n\n\t\tstale = ntohl(param.life->lifespan_increment);\n\n\t\t/* Suggested Cookie Life span increment's unit is msec,\n\t\t * (1/1000sec).\n\t\t */\n\t\tasoc->cookie_life = ktime_add_ms(asoc->cookie_life, stale);\n\t\tbreak;\n\n\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\tpr_debug(\"%s: unimplemented SCTP_HOST_NAME_ADDRESS\\n\", __func__);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_ADDRESS_TYPES:\n\t\t/* Turn off the default values first so we'll know which\n\t\t * ones are really set by the peer.\n\t\t */\n\t\tasoc->peer.ipv4_address = 0;\n\t\tasoc->peer.ipv6_address = 0;\n\n\t\t/* Assume that peer supports the address family\n\t\t * by which it sends a packet.\n\t\t */\n\t\tif (peer_addr->sa.sa_family == AF_INET6)\n\t\t\tasoc->peer.ipv6_address = 1;\n\t\telse if (peer_addr->sa.sa_family == AF_INET)\n\t\t\tasoc->peer.ipv4_address = 1;\n\n\t\t/* Cycle through address types; avoid divide by 0. */\n\t\tsat = ntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\t\tif (sat)\n\t\t\tsat /= sizeof(__u16);\n\n\t\tfor (i = 0; i < sat; ++i) {\n\t\t\tswitch (param.sat->types[i]) {\n\t\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\t\tasoc->peer.ipv4_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\t\tif (PF_INET6 == asoc->base.sk->sk_family)\n\t\t\t\t\tasoc->peer.ipv6_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tcase SCTP_PARAM_HOST_NAME_ADDRESS:\n\t\t\t\tasoc->peer.hostname_address = 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Just ignore anything else.  */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_STATE_COOKIE:\n\t\tasoc->peer.cookie_len =\n\t\t\tntohs(param.p->length) - sizeof(sctp_paramhdr_t);\n\t\tasoc->peer.cookie = param.cookie->body;\n\t\tbreak;\n\n\tcase SCTP_PARAM_HEARTBEAT_INFO:\n\t\t/* Would be odd to receive, but it causes no problems. */\n\t\tbreak;\n\n\tcase SCTP_PARAM_UNRECOGNIZED_PARAMETERS:\n\t\t/* Rejected during verify stage. */\n\t\tbreak;\n\n\tcase SCTP_PARAM_ECN_CAPABLE:\n\t\tasoc->peer.ecn_capable = 1;\n\t\tbreak;\n\n\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\tasoc->peer.adaptation_ind = ntohl(param.aind->adaptation_ind);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\tif (!net->sctp.addip_enable)\n\t\t\tgoto fall_through;\n\n\t\taddr_param = param.v + sizeof(sctp_addip_param_t);\n\n\t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n\t\taf->from_addr_param(&addr, addr_param,\n\t\t\t\t    htons(asoc->peer.port), 0);\n\n\t\t/* if the address is invalid, we can't process it.\n\t\t * XXX: see spec for what to do.\n\t\t */\n\t\tif (!af->addr_valid(&addr, NULL, NULL))\n\t\t\tbreak;\n\n\t\tt = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!t)\n\t\t\tbreak;\n\n\t\tsctp_assoc_set_primary(asoc, t);\n\t\tbreak;\n\n\tcase SCTP_PARAM_SUPPORTED_EXT:\n\t\tsctp_process_ext_param(asoc, param);\n\t\tbreak;\n\n\tcase SCTP_PARAM_FWD_TSN_SUPPORT:\n\t\tif (net->sctp.prsctp_enable) {\n\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/* Fall Through */\n\t\tgoto fall_through;\n\n\tcase SCTP_PARAM_RANDOM:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t/* Save peer's random parameter */\n\t\tasoc->peer.peer_random = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_random) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SCTP_PARAM_HMAC_ALGO:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\t/* Save peer's HMAC list */\n\t\tasoc->peer.peer_hmacs = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_hmacs) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Set the default HMAC the peer requested*/\n\t\tsctp_auth_asoc_set_default_hmac(asoc, param.hmac_algo);\n\t\tbreak;\n\n\tcase SCTP_PARAM_CHUNKS:\n\t\tif (!ep->auth_enable)\n\t\t\tgoto fall_through;\n\n\t\tasoc->peer.peer_chunks = kmemdup(param.p,\n\t\t\t\t\t    ntohs(param.p->length), gfp);\n\t\tif (!asoc->peer.peer_chunks)\n\t\t\tretval = 0;\n\t\tbreak;\nfall_through:\n\tdefault:\n\t\t/* Any unrecognized parameters should have been caught\n\t\t * and handled by sctp_verify_param() which should be\n\t\t * called prior to this routine.  Simply log the error\n\t\t * here.\n\t\t */\n\t\tpr_debug(\"%s: ignoring param:%d for association:%p.\\n\",\n\t\t\t __func__, ntohs(param.p->type), asoc);\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n/* Select a new verification tag.  */\n__u32 sctp_generate_tag(const struct sctp_endpoint *ep)\n{\n\t/* I believe that this random number generator complies with RFC1750.\n\t * A tag of 0 is reserved for special cases (e.g. INIT).\n\t */\n\t__u32 x;\n\n\tdo {\n\t\tget_random_bytes(&x, sizeof(__u32));\n\t} while (x == 0);\n\n\treturn x;\n}\n\n/* Select an initial TSN to send during startup.  */\n__u32 sctp_generate_tsn(const struct sctp_endpoint *ep)\n{\n\t__u32 retval;\n\n\tget_random_bytes(&retval, sizeof(__u32));\n\treturn retval;\n}\n\n/*\n * ADDIP 3.1.1 Address Configuration Change Chunk (ASCONF)\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     | Type = 0xC1   |  Chunk Flags  |      Chunk Length             |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Serial Number                           |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                    Address Parameter                          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                     ASCONF Parameter #1                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     \\                                                               \\\n *     /                             ....                              /\n *     \\                                                               \\\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                     ASCONF Parameter #N                       |\n *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Address Parameter and other parameter will not be wrapped in this function\n */\nstatic struct sctp_chunk *sctp_make_asconf(struct sctp_association *asoc,\n\t\t\t\t\t   union sctp_addr *addr,\n\t\t\t\t\t   int vparam_len)\n{\n\tsctp_addiphdr_t asconf;\n\tstruct sctp_chunk *retval;\n\tint length = sizeof(asconf) + vparam_len;\n\tunion sctp_addr_param addrparam;\n\tint addrlen;\n\tstruct sctp_af *af = sctp_get_af_specific(addr->v4.sin_family);\n\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlength += addrlen;\n\n\t/* Create the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\tasconf.serial = htonl(asoc->addip_serial++);\n\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\n\treturn retval;\n}\n\n/* ADDIP\n * 3.2.1 Add IP Address\n * \t0                   1                   2                   3\n * \t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |        Type = 0xC001          |    Length = Variable          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |               ASCONF-Request Correlation ID                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Address Parameter                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * 3.2.2 Delete IP Address\n * \t0                   1                   2                   3\n * \t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |        Type = 0xC002          |    Length = Variable          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |               ASCONF-Request Correlation ID                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Address Parameter                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n */\nstruct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *asoc,\n\t\t\t\t\t      union sctp_addr\t      *laddr,\n\t\t\t\t\t      struct sockaddr\t      *addrs,\n\t\t\t\t\t      int\t\t      addrcnt,\n\t\t\t\t\t      __be16\t\t      flags)\n{\n\tsctp_addip_param_t\tparam;\n\tstruct sctp_chunk\t*retval;\n\tunion sctp_addr_param\taddr_param;\n\tunion sctp_addr\t\t*addr;\n\tvoid\t\t\t*addr_buf;\n\tstruct sctp_af\t\t*af;\n\tint\t\t\tparamlen = sizeof(param);\n\tint\t\t\taddr_param_len = 0;\n\tint \t\t\ttotallen = 0;\n\tint \t\t\ti;\n\tint\t\t\tdel_pickup = 0;\n\n\t/* Get total length of all the address parameters. */\n\taddr_buf = addrs;\n\tfor (i = 0; i < addrcnt; i++) {\n\t\taddr = addr_buf;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\n\t\ttotallen += paramlen;\n\t\ttotallen += addr_param_len;\n\n\t\taddr_buf += af->sockaddr_len;\n\t\tif (asoc->asconf_addr_del_pending && !del_pickup) {\n\t\t\t/* reuse the parameter length from the same scope one */\n\t\t\ttotallen += paramlen;\n\t\t\ttotallen += addr_param_len;\n\t\t\tdel_pickup = 1;\n\n\t\t\tpr_debug(\"%s: picked same-scope del_pending addr, \"\n\t\t\t\t \"totallen for all addresses is %d\\n\",\n\t\t\t\t __func__, totallen);\n\t\t}\n\t}\n\n\t/* Create an asconf chunk with the required length. */\n\tretval = sctp_make_asconf(asoc, laddr, totallen);\n\tif (!retval)\n\t\treturn NULL;\n\n\t/* Add the address parameters to the asconf chunk. */\n\taddr_buf = addrs;\n\tfor (i = 0; i < addrcnt; i++) {\n\t\taddr = addr_buf;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\t\tparam.param_hdr.type = flags;\n\t\tparam.param_hdr.length = htons(paramlen + addr_param_len);\n\t\tparam.crr_id = i;\n\n\t\tsctp_addto_chunk(retval, paramlen, &param);\n\t\tsctp_addto_chunk(retval, addr_param_len, &addr_param);\n\n\t\taddr_buf += af->sockaddr_len;\n\t}\n\tif (flags == SCTP_PARAM_ADD_IP && del_pickup) {\n\t\taddr = asoc->asconf_addr_del_pending;\n\t\taf = sctp_get_af_specific(addr->v4.sin_family);\n\t\taddr_param_len = af->to_addr_param(addr, &addr_param);\n\t\tparam.param_hdr.type = SCTP_PARAM_DEL_IP;\n\t\tparam.param_hdr.length = htons(paramlen + addr_param_len);\n\t\tparam.crr_id = i;\n\n\t\tsctp_addto_chunk(retval, paramlen, &param);\n\t\tsctp_addto_chunk(retval, addr_param_len, &addr_param);\n\t}\n\treturn retval;\n}\n\n/* ADDIP\n * 3.2.4 Set Primary IP Address\n *\t0                   1                   2                   3\n *\t0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |        Type =0xC004           |    Length = Variable          |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |               ASCONF-Request Correlation ID                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Address Parameter                       |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Create an ASCONF chunk with Set Primary IP address parameter.\n */\nstruct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\n\t\t\t\t\t     union sctp_addr *addr)\n{\n\tsctp_addip_param_t\tparam;\n\tstruct sctp_chunk \t*retval;\n\tint \t\t\tlen = sizeof(param);\n\tunion sctp_addr_param\taddrparam;\n\tint\t\t\taddrlen;\n\tstruct sctp_af\t\t*af = sctp_get_af_specific(addr->v4.sin_family);\n\n\taddrlen = af->to_addr_param(addr, &addrparam);\n\tif (!addrlen)\n\t\treturn NULL;\n\tlen += addrlen;\n\n\t/* Create the chunk and make asconf header. */\n\tretval = sctp_make_asconf(asoc, addr, len);\n\tif (!retval)\n\t\treturn NULL;\n\n\tparam.param_hdr.type = SCTP_PARAM_SET_PRIMARY;\n\tparam.param_hdr.length = htons(len);\n\tparam.crr_id = 0;\n\n\tsctp_addto_chunk(retval, sizeof(param), &param);\n\tsctp_addto_chunk(retval, addrlen, &addrparam);\n\n\treturn retval;\n}\n\n/* ADDIP 3.1.2 Address Configuration Acknowledgement Chunk (ASCONF-ACK)\n *      0                   1                   2                   3\n *      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     | Type = 0x80   |  Chunk Flags  |      Chunk Length             |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                       Serial Number                           |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                 ASCONF Parameter Response#1                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     \\                                                               \\\n *     /                             ....                              /\n *     \\                                                               \\\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *     |                 ASCONF Parameter Response#N                   |\n *     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * Create an ASCONF_ACK chunk with enough space for the parameter responses.\n */\nstatic struct sctp_chunk *sctp_make_asconf_ack(const struct sctp_association *asoc,\n\t\t\t\t\t       __u32 serial, int vparam_len)\n{\n\tsctp_addiphdr_t\t\tasconf;\n\tstruct sctp_chunk\t*retval;\n\tint\t\t\tlength = sizeof(asconf) + vparam_len;\n\n\t/* Create the chunk.  */\n\tretval = sctp_make_control(asoc, SCTP_CID_ASCONF_ACK, 0, length);\n\tif (!retval)\n\t\treturn NULL;\n\n\tasconf.serial = htonl(serial);\n\n\tretval->subh.addip_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(asconf), &asconf);\n\n\treturn retval;\n}\n\n/* Add response parameters to an ASCONF_ACK chunk. */\nstatic void sctp_add_asconf_response(struct sctp_chunk *chunk, __be32 crr_id,\n\t\t\t      __be16 err_code, sctp_addip_param_t *asconf_param)\n{\n\tsctp_addip_param_t \tack_param;\n\tsctp_errhdr_t\t\terr_param;\n\tint\t\t\tasconf_param_len = 0;\n\tint\t\t\terr_param_len = 0;\n\t__be16\t\t\tresponse_type;\n\n\tif (SCTP_ERROR_NO_ERROR == err_code) {\n\t\tresponse_type = SCTP_PARAM_SUCCESS_REPORT;\n\t} else {\n\t\tresponse_type = SCTP_PARAM_ERR_CAUSE;\n\t\terr_param_len = sizeof(err_param);\n\t\tif (asconf_param)\n\t\t\tasconf_param_len =\n\t\t\t\t ntohs(asconf_param->param_hdr.length);\n\t}\n\n\t/* Add Success Indication or Error Cause Indication parameter. */\n\tack_param.param_hdr.type = response_type;\n\tack_param.param_hdr.length = htons(sizeof(ack_param) +\n\t\t\t\t\t   err_param_len +\n\t\t\t\t\t   asconf_param_len);\n\tack_param.crr_id = crr_id;\n\tsctp_addto_chunk(chunk, sizeof(ack_param), &ack_param);\n\n\tif (SCTP_ERROR_NO_ERROR == err_code)\n\t\treturn;\n\n\t/* Add Error Cause parameter. */\n\terr_param.cause = err_code;\n\terr_param.length = htons(err_param_len + asconf_param_len);\n\tsctp_addto_chunk(chunk, err_param_len, &err_param);\n\n\t/* Add the failed TLV copied from ASCONF chunk. */\n\tif (asconf_param)\n\t\tsctp_addto_chunk(chunk, asconf_param_len, asconf_param);\n}\n\n/* Process a asconf parameter. */\nstatic __be16 sctp_process_asconf_param(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf,\n\t\t\t\t       sctp_addip_param_t *asconf_param)\n{\n\tstruct sctp_transport *peer;\n\tstruct sctp_af *af;\n\tunion sctp_addr\taddr;\n\tunion sctp_addr_param *addr_param;\n\n\taddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\n\n\tif (asconf_param->param_hdr.type != SCTP_PARAM_ADD_IP &&\n\t    asconf_param->param_hdr.type != SCTP_PARAM_DEL_IP &&\n\t    asconf_param->param_hdr.type != SCTP_PARAM_SET_PRIMARY)\n\t\treturn SCTP_ERROR_UNKNOWN_PARAM;\n\n\tswitch (addr_param->p.type) {\n\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\tif (!asoc->peer.ipv6_address)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\t\tbreak;\n\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\tif (!asoc->peer.ipv4_address)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\t}\n\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\tif (unlikely(!af))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\taf->from_addr_param(&addr, addr_param, htons(asoc->peer.port), 0);\n\n\t/* ADDIP 4.2.1  This parameter MUST NOT contain a broadcast\n\t * or multicast address.\n\t * (note: wildcard is permitted and requires special handling so\n\t *  make sure we check for that)\n\t */\n\tif (!af->is_any(&addr) && !af->addr_valid(&addr, NULL, asconf->skb))\n\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t/* Section 4.2.1:\n\t\t * If the address 0.0.0.0 or ::0 is provided, the source\n\t\t * address of the packet MUST be added.\n\t\t */\n\t\tif (af->is_any(&addr))\n\t\t\tmemcpy(&addr, &asconf->source, sizeof(addr));\n\n\t\t/* ADDIP 4.3 D9) If an endpoint receives an ADD IP address\n\t\t * request and does not have the local resources to add this\n\t\t * new address to the association, it MUST return an Error\n\t\t * Cause TLV set to the new error code 'Operation Refused\n\t\t * Due to Resource Shortage'.\n\t\t */\n\n\t\tpeer = sctp_assoc_add_peer(asoc, &addr, GFP_ATOMIC, SCTP_UNCONFIRMED);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_RSRC_LOW;\n\n\t\t/* Start the heartbeat timer. */\n\t\tif (!mod_timer(&peer->hb_timer, sctp_transport_timeout(peer)))\n\t\t\tsctp_transport_hold(peer);\n\t\tasoc->new_transport = peer;\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\t/* ADDIP 4.3 D7) If a request is received to delete the\n\t\t * last remaining IP address of a peer endpoint, the receiver\n\t\t * MUST send an Error Cause TLV with the error cause set to the\n\t\t * new error code 'Request to Delete Last Remaining IP Address'.\n\t\t */\n\t\tif (asoc->peer.transport_count == 1)\n\t\t\treturn SCTP_ERROR_DEL_LAST_IP;\n\n\t\t/* ADDIP 4.3 D8) If a request is received to delete an IP\n\t\t * address which is also the source address of the IP packet\n\t\t * which contained the ASCONF chunk, the receiver MUST reject\n\t\t * this request. To reject the request the receiver MUST send\n\t\t * an Error Cause TLV set to the new error code 'Request to\n\t\t * Delete Source IP Address'\n\t\t */\n\t\tif (sctp_cmp_addr_exact(&asconf->source, &addr))\n\t\t\treturn SCTP_ERROR_DEL_SRC_IP;\n\n\t\t/* Section 4.2.2\n\t\t * If the address 0.0.0.0 or ::0 is provided, all\n\t\t * addresses of the peer except\tthe source address of the\n\t\t * packet MUST be deleted.\n\t\t */\n\t\tif (af->is_any(&addr)) {\n\t\t\tsctp_assoc_set_primary(asoc, asconf->transport);\n\t\t\tsctp_assoc_del_nonprimary_peers(asoc,\n\t\t\t\t\t\t\tasconf->transport);\n\t\t} else\n\t\t\tsctp_assoc_del_peer(asoc, &addr);\n\t\tbreak;\n\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t/* ADDIP Section 4.2.4\n\t\t * If the address 0.0.0.0 or ::0 is provided, the receiver\n\t\t * MAY mark the source address of the packet as its\n\t\t * primary.\n\t\t */\n\t\tif (af->is_any(&addr))\n\t\t\tmemcpy(&addr.v4, sctp_source(asconf), sizeof(addr));\n\n\t\tpeer = sctp_assoc_lookup_paddr(asoc, &addr);\n\t\tif (!peer)\n\t\t\treturn SCTP_ERROR_DNS_FAILED;\n\n\t\tsctp_assoc_set_primary(asoc, peer);\n\t\tbreak;\n\t}\n\n\treturn SCTP_ERROR_NO_ERROR;\n}\n\n/* Verify the ASCONF packet before we process it. */\nbool sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n\t\t\tstruct sctp_paramhdr **errp)\n{\n\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) chunk->chunk_hdr;\n\tunion sctp_params param;\n\tbool addr_param_seen = false;\n\n\tsctp_walk_params(param, addip, addip_hdr.params) {\n\t\tsize_t length = ntohs(param.p->length);\n\n\t\t*errp = param.p;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv4addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n\t\t\tif (length != sizeof(sctp_ipv6addr_param_t))\n\t\t\t\treturn false;\n\t\t\taddr_param_seen = true;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\t/* In ASCONF chunks, these need to be first. */\n\t\t\tif (addr_param_needed && !addr_param_seen)\n\t\t\t\treturn false;\n\t\t\tlength = ntohs(param.addip->param_hdr.length);\n\t\t\tif (length < sizeof(sctp_addip_param_t) +\n\t\t\t\t     sizeof(sctp_paramhdr_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* This is unkown to us, reject! */\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Remaining sanity checks. */\n\tif (addr_param_needed && !addr_param_seen)\n\t\treturn false;\n\tif (!addr_param_needed && addr_param_seen)\n\t\treturn false;\n\tif (param.v != chunk->chunk_end)\n\t\treturn false;\n\n\treturn true;\n}\n\n/* Process an incoming ASCONF chunk with the next expected serial no. and\n * return an ASCONF_ACK chunk to be sent in response.\n */\nstruct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) asconf->chunk_hdr;\n\tbool all_param_pass = true;\n\tunion sctp_params param;\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tstruct sctp_chunk\t*asconf_ack;\n\t__be16\terr_code;\n\tint\tlength = 0;\n\tint\tchunk_len;\n\t__u32\tserial;\n\n\tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\thdr = (sctp_addiphdr_t *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t/* Skip the addiphdr and store a pointer to address parameter.  */\n\tlength = sizeof(sctp_addiphdr_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\n\t/* Skip the address parameter and store a pointer to the first\n\t * asconf parameter.\n\t */\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tchunk_len -= length;\n\n\t/* create an ASCONF_ACK chunk.\n\t * Based on the definitions of parameters, we know that the size of\n\t * ASCONF_ACK parameters are less than or equal to the fourfold of ASCONF\n\t * parameters.\n\t */\n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\n\t/* Process the TLVs contained within the ASCONF chunk. */\n\tsctp_walk_params(param, addip, addip_hdr.params) {\n\t\t/* Skip preceeding address parameters. */\n\t\tif (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\n\t\t    param.p->type == SCTP_PARAM_IPV6_ADDRESS)\n\t\t\tcontinue;\n\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     param.addip);\n\t\t/* ADDIP 4.1 A7)\n\t\t * If an error response is received for a TLV parameter,\n\t\t * all TLVs with no response before the failed TLV are\n\t\t * considered successful if not reported.  All TLVs after\n\t\t * the failed response are considered unsuccessful unless\n\t\t * a specific success indication is present for the parameter.\n\t\t */\n\t\tif (err_code != SCTP_ERROR_NO_ERROR)\n\t\t\tall_param_pass = false;\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack, param.addip->crr_id,\n\t\t\t\t\t\t err_code, param.addip);\n\n\t\t/* ADDIP 4.3 D11) When an endpoint receiving an ASCONF to add\n\t\t * an IP address sends an 'Out of Resource' in its response, it\n\t\t * MUST also fail any subsequent add or delete requests bundled\n\t\t * in the ASCONF.\n\t\t */\n\t\tif (err_code == SCTP_ERROR_RSRC_LOW)\n\t\t\tgoto done;\n\t}\ndone:\n\tasoc->peer.addip_serial++;\n\n\t/* If we are sending a new ASCONF_ACK hold a reference to it in assoc\n\t * after freeing the reference to old asconf ack if any.\n\t */\n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\n\treturn asconf_ack;\n}\n\n/* Process a asconf parameter that is successfully acked. */\nstatic void sctp_asconf_param_success(struct sctp_association *asoc,\n\t\t\t\t     sctp_addip_param_t *asconf_param)\n{\n\tstruct sctp_af *af;\n\tunion sctp_addr\taddr;\n\tstruct sctp_bind_addr *bp = &asoc->base.bind_addr;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *transport;\n\tstruct sctp_sockaddr_entry *saddr;\n\n\taddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\n\n\t/* We have checked the packet before, so we do not check again.\t*/\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\taf->from_addr_param(&addr, addr_param, htons(bp->port), 0);\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t/* This is always done in BH context with a socket lock\n\t\t * held, so the list can not change.\n\t\t */\n\t\tlocal_bh_disable();\n\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\tif (sctp_cmp_addr_exact(&saddr->a, &addr))\n\t\t\t\tsaddr->state = SCTP_ADDR_SRC;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\ttransport->dst = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\tlocal_bh_disable();\n\t\tsctp_del_bind_addr(bp, &addr);\n\t\tif (asoc->asconf_addr_del_pending != NULL &&\n\t\t    sctp_cmp_addr_exact(asoc->asconf_addr_del_pending, &addr)) {\n\t\t\tkfree(asoc->asconf_addr_del_pending);\n\t\t\tasoc->asconf_addr_del_pending = NULL;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\ttransport->dst = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/* Get the corresponding ASCONF response error code from the ASCONF_ACK chunk\n * for the given asconf parameter.  If there is no response for this parameter,\n * return the error code based on the third argument 'no_err'.\n * ADDIP 4.1\n * A7) If an error response is received for a TLV parameter, all TLVs with no\n * response before the failed TLV are considered successful if not reported.\n * All TLVs after the failed response are considered unsuccessful unless a\n * specific success indication is present for the parameter.\n */\nstatic __be16 sctp_get_asconf_response(struct sctp_chunk *asconf_ack,\n\t\t\t\t      sctp_addip_param_t *asconf_param,\n\t\t\t\t      int no_err)\n{\n\tsctp_addip_param_t\t*asconf_ack_param;\n\tsctp_errhdr_t\t\t*err_param;\n\tint\t\t\tlength;\n\tint\t\t\tasconf_ack_len;\n\t__be16\t\t\terr_code;\n\n\tif (no_err)\n\t\terr_code = SCTP_ERROR_NO_ERROR;\n\telse\n\t\terr_code = SCTP_ERROR_REQ_REFUSED;\n\n\tasconf_ack_len = ntohs(asconf_ack->chunk_hdr->length) -\n\t\t\t     sizeof(sctp_chunkhdr_t);\n\n\t/* Skip the addiphdr from the asconf_ack chunk and store a pointer to\n\t * the first asconf_ack parameter.\n\t */\n\tlength = sizeof(sctp_addiphdr_t);\n\tasconf_ack_param = (sctp_addip_param_t *)(asconf_ack->skb->data +\n\t\t\t\t\t\t  length);\n\tasconf_ack_len -= length;\n\n\twhile (asconf_ack_len > 0) {\n\t\tif (asconf_ack_param->crr_id == asconf_param->crr_id) {\n\t\t\tswitch (asconf_ack_param->param_hdr.type) {\n\t\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\t\t\treturn SCTP_ERROR_NO_ERROR;\n\t\t\tcase SCTP_PARAM_ERR_CAUSE:\n\t\t\t\tlength = sizeof(sctp_addip_param_t);\n\t\t\t\terr_param = (void *)asconf_ack_param + length;\n\t\t\t\tasconf_ack_len -= length;\n\t\t\t\tif (asconf_ack_len > 0)\n\t\t\t\t\treturn err_param->cause;\n\t\t\t\telse\n\t\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\tlength = ntohs(asconf_ack_param->param_hdr.length);\n\t\tasconf_ack_param = (void *)asconf_ack_param + length;\n\t\tasconf_ack_len -= length;\n\t}\n\n\treturn err_code;\n}\n\n/* Process an incoming ASCONF_ACK chunk against the cached last ASCONF chunk. */\nint sctp_process_asconf_ack(struct sctp_association *asoc,\n\t\t\t    struct sctp_chunk *asconf_ack)\n{\n\tstruct sctp_chunk\t*asconf = asoc->addip_last_asconf;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tint\tlength = 0;\n\tint\tasconf_len = asconf->skb->len;\n\tint\tall_param_pass = 0;\n\tint\tno_err = 1;\n\tint\tretval = 0;\n\t__be16\terr_code = SCTP_ERROR_NO_ERROR;\n\n\t/* Skip the chunkhdr and addiphdr from the last asconf sent and store\n\t * a pointer to address parameter.\n\t */\n\tlength = sizeof(sctp_addip_chunk_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tasconf_len -= length;\n\n\t/* Skip the address parameter in the last asconf sent and store a\n\t * pointer to the first asconf parameter.\n\t */\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tasconf_len -= length;\n\n\t/* ADDIP 4.1\n\t * A8) If there is no response(s) to specific TLV parameter(s), and no\n\t * failures are indicated, then all request(s) are considered\n\t * successful.\n\t */\n\tif (asconf_ack->skb->len == sizeof(sctp_addiphdr_t))\n\t\tall_param_pass = 1;\n\n\t/* Process the TLVs contained in the last sent ASCONF chunk. */\n\twhile (asconf_len > 0) {\n\t\tif (all_param_pass)\n\t\t\terr_code = SCTP_ERROR_NO_ERROR;\n\t\telse {\n\t\t\terr_code = sctp_get_asconf_response(asconf_ack,\n\t\t\t\t\t\t\t    asconf_param,\n\t\t\t\t\t\t\t    no_err);\n\t\t\tif (no_err && (SCTP_ERROR_NO_ERROR != err_code))\n\t\t\t\tno_err = 0;\n\t\t}\n\n\t\tswitch (err_code) {\n\t\tcase SCTP_ERROR_NO_ERROR:\n\t\t\tsctp_asconf_param_success(asoc, asconf_param);\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_RSRC_LOW:\n\t\t\tretval = 1;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_UNKNOWN_PARAM:\n\t\t\t/* Disable sending this type of asconf parameter in\n\t\t\t * future.\n\t\t\t */\n\t\t\tasoc->peer.addip_disabled_mask |=\n\t\t\t\tasconf_param->param_hdr.type;\n\t\t\tbreak;\n\n\t\tcase SCTP_ERROR_REQ_REFUSED:\n\t\tcase SCTP_ERROR_DEL_LAST_IP:\n\t\tcase SCTP_ERROR_DEL_SRC_IP:\n\t\tdefault:\n\t\t\t break;\n\t\t}\n\n\t\t/* Skip the processed asconf parameter and move to the next\n\t\t * one.\n\t\t */\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tasconf_len -= length;\n\t}\n\n\tif (no_err && asoc->src_out_of_asoc_ok) {\n\t\tasoc->src_out_of_asoc_ok = 0;\n\t\tsctp_transport_immediate_rtx(asoc->peer.primary_path);\n\t}\n\n\t/* Free the cached last sent asconf chunk. */\n\tlist_del_init(&asconf->transmitted_list);\n\tsctp_chunk_free(asconf);\n\tasoc->addip_last_asconf = NULL;\n\n\treturn retval;\n}\n\n/* Make a FWD TSN chunk. */\nstruct sctp_chunk *sctp_make_fwdtsn(const struct sctp_association *asoc,\n\t\t\t\t    __u32 new_cum_tsn, size_t nstreams,\n\t\t\t\t    struct sctp_fwdtsn_skip *skiplist)\n{\n\tstruct sctp_chunk *retval = NULL;\n\tstruct sctp_fwdtsn_hdr ftsn_hdr;\n\tstruct sctp_fwdtsn_skip skip;\n\tsize_t hint;\n\tint i;\n\n\thint = (nstreams + 1) * sizeof(__u32);\n\n\tretval = sctp_make_control(asoc, SCTP_CID_FWD_TSN, 0, hint);\n\n\tif (!retval)\n\t\treturn NULL;\n\n\tftsn_hdr.new_cum_tsn = htonl(new_cum_tsn);\n\tretval->subh.fwdtsn_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(ftsn_hdr), &ftsn_hdr);\n\n\tfor (i = 0; i < nstreams; i++) {\n\t\tskip.stream = skiplist[i].stream;\n\t\tskip.ssn = skiplist[i].ssn;\n\t\tsctp_addto_chunk(retval, sizeof(skip), &skip);\n\t}\n\n\treturn retval;\n}\n", "/* SCTP kernel implementation\n * (C) Copyright IBM Corp. 2001, 2004\n * Copyright (c) 1999-2000 Cisco, Inc.\n * Copyright (c) 1999-2001 Motorola, Inc.\n * Copyright (c) 2001-2002 Intel Corp.\n * Copyright (c) 2002      Nokia Corp.\n *\n * This is part of the SCTP Linux Kernel Implementation.\n *\n * These are the state functions for the state machine.\n *\n * This SCTP implementation is free software;\n * you can redistribute it and/or modify it under the terms of\n * the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This SCTP implementation is distributed in the hope that it\n * will be useful, but WITHOUT ANY WARRANTY; without even the implied\n *                 ************************\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with GNU CC; see the file COPYING.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n * Please send any bug reports or fixes you make to the\n * email address(es):\n *    lksctp developers <linux-sctp@vger.kernel.org>\n *\n * Written or modified by:\n *    La Monte H.P. Yarroll <piggy@acm.org>\n *    Karl Knutson          <karl@athena.chicago.il.us>\n *    Mathew Kotowsky       <kotowsky@sctp.org>\n *    Sridhar Samudrala     <samudrala@us.ibm.com>\n *    Jon Grimm             <jgrimm@us.ibm.com>\n *    Hui Huang \t    <hui.huang@nokia.com>\n *    Dajiang Zhang \t    <dajiang.zhang@nokia.com>\n *    Daisy Chang\t    <daisyc@us.ibm.com>\n *    Ardelle Fan\t    <ardelle.fan@intel.com>\n *    Ryan Layer\t    <rmlayer@us.ibm.com>\n *    Kevin Gao\t\t    <kevin.gao@intel.com>\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <net/sock.h>\n#include <net/inet_ecn.h>\n#include <linux/skbuff.h>\n#include <net/sctp/sctp.h>\n#include <net/sctp/sm.h>\n#include <net/sctp/structs.h>\n\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen);\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands);\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk);\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk);\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands);\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport);\n\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen);\n\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands);\n\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk);\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands);\n\n/* Small helper function that checks if the chunk length\n * is of the appropriate length.  The 'required_length' argument\n * is set to be the size of a specific chunk we are testing.\n * Return Values:  1 = Valid length\n * \t\t   0 = Invalid length\n *\n */\nstatic inline int\nsctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/**********************************************************\n * These are the state functions for handling chunk events.\n **********************************************************/\n\n/*\n * Process the final SHUTDOWN COMPLETE.\n *\n * Section: 4 (C) (diagram), 9.2\n * Upon reception of the SHUTDOWN COMPLETE chunk the endpoint will verify\n * that it is in SHUTDOWN-ACK-SENT state, if it is not the chunk should be\n * discarded. If the endpoint is in the SHUTDOWN-ACK-SENT state the endpoint\n * should stop the T2-shutdown timer and remove all knowledge of the\n * association (and thus the association enters the CLOSED state).\n *\n * Verification Tag: 8.5.1(C), sctpimpguide 2.41.\n * C) Rules for packet carrying SHUTDOWN COMPLETE:\n * ...\n * - The receiver of a SHUTDOWN COMPLETE shall accept the packet\n *   if the Verification Tag field of the packet matches its own tag and\n *   the T bit is not set\n *   OR\n *   it is set to its peer's tag and the T bit is set in the Chunk\n *   Flags.\n *   Otherwise, the receiver MUST silently discard the packet\n *   and take no further action.  An endpoint MUST ignore the\n *   SHUTDOWN COMPLETE if it is not in the SHUTDOWN-ACK-SENT state.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_4_C(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t  void *arg,\n\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* RFC 2960 6.10 Bundling\n\t *\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* RFC 2960 10.2 SCTP-to-ULP\n\t *\n\t * H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\n\t/* Upon reception of the SHUTDOWN COMPLETE chunk the endpoint\n\t * will verify that it is in SHUTDOWN-ACK-SENT state, if it is\n\t * not the chunk should be discarded. If the endpoint is in\n\t * the SHUTDOWN-ACK-SENT state the endpoint should stop the\n\t * T2-shutdown timer and remove all knowledge of the\n\t * association (and thus the association enters the CLOSED\n\t * state).\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * Respond to a normal INIT chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, B\n * B) \"Z\" shall respond immediately with an INIT ACK chunk.  The\n *    destination IP address of the INIT ACK MUST be set to the source\n *    IP address of the INIT to which this INIT ACK is responding.  In\n *    the response, besides filling in other parameters, \"Z\" must set the\n *    Verification Tag field to Tag_A, and also provide its own\n *    Verification Tag (Tag_Z) in the Initiate Tag field.\n *\n * Verification Tag: Must be 0.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1B_init(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * Normally, this would cause an ABORT with a Protocol Violation\n\t * error, but since we don't have an association, we'll\n\t * just discard the packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the INIT is coming toward a closing socket, we'll send back\n\t * and ABORT.  Essentially, this catches the race of INIT being\n\t * backloged to the socket at the same time as the user isses close().\n\t * Since the socket and all its associations are going away, we\n\t * can treat this OOTB\n\t */\n\tif (sctp_sstate(ep->base.sk, CLOSING))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *)chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\t\t     sctp_scope(sctp_source(chunk)),\n\t\t\t\t\t     GFP_ATOMIC) < 0)\n\t\tgoto nomem_init;\n\n\t/* The call, sctp_process_init(), can fail on memory allocation.  */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk)\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t\tsctp_chunk_free(err_chunk);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note:  After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources, nor keep any states for the\n\t * new association.  Otherwise, \"Z\" will be vulnerable to resource\n\t * attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal INIT ACK chunk.\n * We are the side that is initiating the association.\n *\n * Section: 5.1 Normal Establishment of an Association, C\n * C) Upon reception of the INIT ACK from \"Z\", \"A\" shall stop the T1-init\n *    timer and leave COOKIE-WAIT state. \"A\" shall then send the State\n *    Cookie received in the INIT ACK chunk in a COOKIE ECHO chunk, start\n *    the T1-cookie timer, and enter the COOKIE-ECHOED state.\n *\n *    Note: The COOKIE ECHO chunk can be bundled with any pending outbound\n *    DATA chunks, but it MUST be the first chunk in the packet and\n *    until the COOKIE ACK is returned the sender MUST NOT send any\n *    other packets to the peer.\n *\n * Verification Tag: 3.3.3\n *   If the value of the Initiate Tag in a received INIT ACK chunk is\n *   found to be 0, the receiver MUST treat it as an error and close the\n *   association by transmitting an ABORT.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1C_ack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_init_chunk_t *initchunk;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_violation_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT-ACK chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\n\t\tsctp_error_t error = SCTP_ERROR_NO_RESOURCE;\n\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes.  If there are no causes,\n\t\t * then there wasn't enough memory.  Just terminate\n\t\t * the association.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tsctp_chunk_free(err_chunk);\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\terror = SCTP_ERROR_INV_PARAM;\n\t\t\t}\n\t\t}\n\n\t\t/* SCTP-AUTH, Section 6.3:\n\t\t *    It should be noted that if the receiver wants to tear\n\t\t *    down an association in an authenticated way only, the\n\t\t *    handling of malformed packets should not result in\n\t\t *    tearing down the association.\n\t\t *\n\t\t * This means that if we only want to abort associations\n\t\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t\t * can't destroy this association just because the packet\n\t\t * was malformed.\n\t\t */\n\t\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED,\n\t\t\t\t\t\tasoc, chunk->transport);\n\t}\n\n\t/* Tag the variable length parameters.  Note that we never\n\t * convert the parameters in an INIT chunk.\n\t */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\tinitchunk = (sctp_init_chunk_t *) chunk->chunk_hdr;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PEER_INIT,\n\t\t\tSCTP_PEER_INIT(initchunk));\n\n\t/* Reset init error count upon receipt of INIT-ACK.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall stop the T1-init timer and leave\n\t * COOKIE-WAIT state.  \"A\" shall then ... start the T1-cookie\n\t * timer, and enter the COOKIE-ECHOED state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_ECHOED));\n\n\t/* SCTP-AUTH: genereate the assocition shared keys so that\n\t * we can potentially signe the COOKIE-ECHO.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_SHKEY, SCTP_NULL());\n\n\t/* 5.1 C) \"A\" shall then send the State Cookie received in the\n\t * INIT ACK chunk in a COOKIE ECHO chunk, ...\n\t */\n\t/* If there is any errors to report, send the ERROR chunk generated\n\t * for unknown parameters as well.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_COOKIE_ECHO,\n\t\t\tSCTP_CHUNK(err_chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Respond to a normal COOKIE ECHO chunk.\n * We are the side that is being asked for an association.\n *\n * Section: 5.1 Normal Establishment of an Association, D\n * D) Upon reception of the COOKIE ECHO chunk, Endpoint \"Z\" will reply\n *    with a COOKIE ACK chunk after building a TCB and moving to\n *    the ESTABLISHED state. A COOKIE ACK chunk may be bundled with\n *    any pending DATA chunks (and/or SACK chunks), but the COOKIE ACK\n *    chunk MUST be the first chunk in the packet.\n *\n *   IMPLEMENTATION NOTE: An implementation may choose to send the\n *   Communication Up notification to the SCTP user upon reception\n *   of a valid COOKIE ECHO chunk.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * D) Rules for packet carrying a COOKIE ECHO\n *\n * - When sending a COOKIE ECHO, the endpoint MUST use the value of the\n *   Initial Tag received in the INIT ACK.\n *\n * - The receiver of a COOKIE ECHO follows the procedures in Section 5.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_ulpevent *ev, *ai_ev = NULL;\n\tint error = 0;\n\tstruct sctp_chunk *err_chk_p;\n\tstruct sock *sk;\n\n\t/* If the packet is an OOTB packet which is temporarily on the\n\t * control endpoint, respond with an ABORT.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the COOKIE_ECHO chunk has a valid length.\n\t * In this case, we check that we have enough for at least a\n\t * chunk header.  More detailed verification is done\n\t * in sctp_unpack_cookie().\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* If the endpoint is not listening or if the number of associations\n\t * on the TCP-style socket exceed the max backlog, respond with an\n\t * ABORT.\n\t */\n\tsk = ep->base.sk;\n\tif (!sctp_sstate(sk, LISTENING) ||\n\t    (sctp_style(sk, TCP) && sk_acceptq_is_full(sk)))\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr =\n\t\t(struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\t sizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* 5.1 D) Upon reception of the COOKIE ECHO chunk, Endpoint\n\t * \"Z\" will reply with a COOKIE ACK chunk after building a TCB\n\t * and moving to the ESTABLISHED state.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\n\t/* Delay state machine commands until later.\n\t *\n\t * Re-build the bind address for the association is done in\n\t * the sctp_unpack_cookie() already.\n\t */\n\t/* This is a brand-new association, so these are not yet side\n\t * effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk,\n\t\t\t       &chunk->subh.cookie_hdr->c.peer_addr,\n\t\t\t       peer_init, GFP_ATOMIC))\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  Now that we've populate required fields in\n\t * sctp_process_init, set up the assocaition shared keys as\n\t * necessary so that we can potentially authenticate the ACK\n\t */\n\terror = sctp_auth_asoc_init_active_key(new_asoc, GFP_ATOMIC);\n\tif (error)\n\t\tgoto nomem_init;\n\n\t/* SCTP-AUTH:  auth_chunk pointer is only set when the cookie-echo\n\t * is supposed to be authenticated and we have to do delayed\n\t * authentication.  We've just recreated the association using\n\t * the information in the cookie and now it's much easier to\n\t * do the authentication.\n\t */\n\tif (chunk->auth_chunk) {\n\t\tstruct sctp_chunk auth;\n\t\tsctp_ierror_t ret;\n\n\t\t/* Make sure that we and the peer are AUTH capable */\n\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\n\t\t/* set-up our fake chunk so that we can process it */\n\t\tauth.skb = chunk->auth_chunk;\n\t\tauth.asoc = chunk->asoc;\n\t\tauth.sctp_hdr = chunk->sctp_hdr;\n\t\tauth.chunk_hdr = (sctp_chunkhdr_t *)skb_push(chunk->auth_chunk,\n\t\t\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\tskb_pull(chunk->auth_chunk, sizeof(sctp_chunkhdr_t));\n\t\tauth.transport = chunk->transport;\n\n\t\tret = sctp_sf_authenticate(net, ep, new_asoc, type, &auth);\n\t\tif (ret != SCTP_IERROR_NO_ERROR) {\n\t\t\tsctp_association_free(new_asoc);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem_init;\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(new_asoc, 0, SCTP_COMM_UP, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (new_asoc->peer.adaptation_ind) {\n\t\tai_ev = sctp_ulpevent_make_adaptation_indication(new_asoc,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!ai_ev)\n\t\t\tgoto nomem_aiev;\n\t}\n\n\t/* Add all the state machine commands now since we've created\n\t * everything.  This way we don't introduce memory corruptions\n\t * during side-effect processing and correclty count established\n\t * associations.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_PASSIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\tif (new_asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* This will send the COOKIE ACK */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* Queue the ASSOC_CHANGE event */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Send up the Adaptation Layer Indication event */\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_aiev:\n\tsctp_ulpevent_free(ev);\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem_init:\n\tsctp_association_free(new_asoc);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Respond to a normal COOKIE ACK chunk.\n * We are the side that is being asked for an association.\n *\n * RFC 2960 5.1 Normal Establishment of an Association\n *\n * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move from the\n *    COOKIE-ECHOED state to the ESTABLISHED state, stopping the T1-cookie\n *    timer. It may also notify its ULP about the successful\n *    establishment of the association with a Communication Up\n *    notification (see Section 10).\n *\n * Verification Tag:\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_1E_ca(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type, void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Verify that the chunk length for the COOKIE-ACK is OK.\n\t * If we don't do this, any bundled chunks may be junked.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Reset init error count upon receipt of COOKIE-ACK,\n\t * to avoid problems with the managemement of this\n\t * counter in stale cookie situations when a transition back\n\t * from the COOKIE-ECHOED state to the COOKIE-WAIT\n\t * state is performed.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_RESET, SCTP_NULL());\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * E) Upon reception of the COOKIE ACK, endpoint \"A\" will move\n\t * from the COOKIE-ECHOED state to the ESTABLISHED state,\n\t * stopping the T1-cookie timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ACTIVEESTABS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* It may also notify its ULP about the successful\n\t * establishment of the association with a Communication Up\n\t * notification (see Section 10).\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_UP,\n\t\t\t\t\t     0, asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\n\tif (!ev)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t */\n\tif (asoc->peer.adaptation_ind) {\n\t\tev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Generate and sendout a heartbeat packet.  */\nstatic sctp_disposition_t sctp_sf_heartbeat(const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg,\n\t\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Send a heartbeat to our peer.  */\n\treply = sctp_make_heartbeat(asoc, transport);\n\tif (!reply)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/* Set rto_pending indicating that an RTT measurement\n\t * is started with this heartbeat chunk.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RTO_PENDING,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Generate a HEARTBEAT packet on the given transport.  */\nsctp_disposition_t sctp_sf_sendbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) arg;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\t/* Section 3.3.5.\n\t * The Sender-specific Heartbeat Info field should normally include\n\t * information about the sender's current time when this HEARTBEAT\n\t * chunk is sent and the destination transport address to which this\n\t * HEARTBEAT is sent (see Section 8.3).\n\t */\n\n\tif (transport->param_flags & SPP_HB_ENABLE) {\n\t\tif (SCTP_DISPOSITION_NOMEM ==\n\t\t\t\tsctp_sf_heartbeat(ep, asoc, type, arg,\n\t\t\t\t\t\t  commands))\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Set transport error counter and association error counter\n\t\t * when sending heartbeat.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_IDLE,\n\t\t\tSCTP_TRANSPORT(transport));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMER_UPDATE,\n\t\t\tSCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an heartbeat request.\n *\n * Section: 8.3 Path Heartbeat\n * The receiver of the HEARTBEAT should immediately respond with a\n * HEARTBEAT ACK that contains the Heartbeat Information field copied\n * from the received HEARTBEAT chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * When receiving an SCTP packet, the endpoint MUST ensure that the\n * value in the Verification Tag field of the received SCTP packet\n * matches its own Tag. If the received Verification Tag value does not\n * match the receiver's own tag value, the receiver shall silently\n * discard the packet and shall not process it any further except for\n * those cases listed in Section 8.5.1 below.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_beat_8_3(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tsctp_paramhdr_t *param_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tsize_t paylen = 0;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_heartbeat_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* 8.3 The receiver of the HEARTBEAT should immediately\n\t * respond with a HEARTBEAT ACK that contains the Heartbeat\n\t * Information field copied from the received HEARTBEAT chunk.\n\t */\n\tchunk->subh.hb_hdr = (sctp_heartbeathdr_t *) chunk->skb->data;\n\tparam_hdr = (sctp_paramhdr_t *) chunk->subh.hb_hdr;\n\tpaylen = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\n\tif (ntohs(param_hdr->length) > paylen)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  param_hdr, commands);\n\n\tif (!pskb_pull(chunk->skb, paylen))\n\t\tgoto nomem;\n\n\treply = sctp_make_heartbeat_ack(asoc, chunk, param_hdr, paylen);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the returning HEARTBEAT ACK.\n *\n * Section: 8.3 Path Heartbeat\n * Upon the receipt of the HEARTBEAT ACK, the sender of the HEARTBEAT\n * should clear the error counter of the destination transport\n * address to which the HEARTBEAT was sent, and mark the destination\n * transport address as active if it is not so marked. The endpoint may\n * optionally report to the upper layer when an inactive destination\n * address is marked as active due to the reception of the latest\n * HEARTBEAT ACK. The receiver of the HEARTBEAT ACK must also\n * clear the association overall error count as well (as defined\n * in section 8.1).\n *\n * The receiver of the HEARTBEAT ACK should also perform an RTT\n * measurement for that destination transport address using the time\n * value carried in the HEARTBEAT ACK chunk.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_backbeat_8_3(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunion sctp_addr from_addr;\n\tstruct sctp_transport *link;\n\tsctp_sender_hb_info_t *hbinfo;\n\tunsigned long max_interval;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the HEARTBEAT-ACK chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t) +\n\t\t\t\t\t    sizeof(sctp_sender_hb_info_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\n\t/* Make sure that the length of the parameter is what we expect */\n\tif (ntohs(hbinfo->param_hdr.length) !=\n\t\t\t\t    sizeof(sctp_sender_hb_info_t)) {\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\tfrom_addr = hbinfo->daddr;\n\tlink = sctp_assoc_lookup_paddr(asoc, &from_addr);\n\n\t/* This should never happen, but lets log it if so.  */\n\tif (unlikely(!link)) {\n\t\tif (from_addr.sa.sa_family == AF_INET6) {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI6\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v6.sin6_addr);\n\t\t} else {\n\t\t\tnet_warn_ratelimited(\"%s association %p could not find address %pI4\\n\",\n\t\t\t\t\t     __func__,\n\t\t\t\t\t     asoc,\n\t\t\t\t\t     &from_addr.v4.sin_addr.s_addr);\n\t\t}\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* Validate the 64-bit random nonce. */\n\tif (hbinfo->hb_nonce != link->hb_nonce)\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\tmax_interval = link->hbinterval + link->rto;\n\n\t/* Check if the timestamp looks valid.  */\n\tif (time_after(hbinfo->sent_at, jiffies) ||\n\t    time_after(jiffies, hbinfo->sent_at + max_interval)) {\n\t\tpr_debug(\"%s: HEARTBEAT ACK with invalid timestamp received \"\n\t\t\t \"for transport:%p\\n\", __func__, link);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* 8.3 Upon the receipt of the HEARTBEAT ACK, the sender of\n\t * the HEARTBEAT should clear the error counter of the\n\t * destination transport address to which the HEARTBEAT was\n\t * sent and mark the destination transport address as active if\n\t * it is not so marked.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_ON, SCTP_TRANSPORT(link));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* Helper function to send out an abort for the restart\n * condition.\n */\nstatic int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\n\t/* Build the error on the stack.   We are way to malloc crazy\n\t * throughout the code today.\n\t */\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\n\t/* Copy into a parm format. */\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\n\t/* Assign to the control socket. */\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\n\t/* Association is NULL since this may be a restart attack and we\n\t * want to send back the attacker's vtag.\n\t */\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t/* Discard the rest of the inbound packet. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\nout:\n\t/* Even if there is no memory, treat as a failure so\n\t * the packet will get dropped.\n\t */\n\treturn 0;\n}\n\nstatic bool list_has_sctp_addr(const struct list_head *list,\n\t\t\t       union sctp_addr *ipaddr)\n{\n\tstruct sctp_transport *addr;\n\n\tlist_for_each_entry(addr, list, transports) {\n\t\tif (sctp_cmp_addr_exact(ipaddr, &addr->ipaddr))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n/* A restart is occurring, check to make sure no new addresses\n * are being added as we may be under a takeover attack.\n */\nstatic int sctp_sf_check_restart_addrs(const struct sctp_association *new_asoc,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *init,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct net *net = sock_net(new_asoc->base.sk);\n\tstruct sctp_transport *new_addr;\n\tint ret = 1;\n\n\t/* Implementor's Guide - Section 5.2.2\n\t * ...\n\t * Before responding the endpoint MUST check to see if the\n\t * unexpected INIT adds new addresses to the association. If new\n\t * addresses are added to the association, the endpoint MUST respond\n\t * with an ABORT..\n\t */\n\n\t/* Search through all current addresses and make sure\n\t * we aren't adding any new ones.\n\t */\n\tlist_for_each_entry(new_addr, &new_asoc->peer.transport_addr_list,\n\t\t\t    transports) {\n\t\tif (!list_has_sctp_addr(&asoc->peer.transport_addr_list,\n\t\t\t\t\t&new_addr->ipaddr)) {\n\t\t\tsctp_sf_send_restart_abort(net, &new_addr->ipaddr, init,\n\t\t\t\t\t\t   commands);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Return success if all addresses were found. */\n\treturn ret;\n}\n\n/* Populate the verification/tie tags based on overlapping INIT\n * scenario.\n *\n * Note: Do not use in CLOSED or SHUTDOWN-ACK-SENT state.\n */\nstatic void sctp_tietags_populate(struct sctp_association *new_asoc,\n\t\t\t\t  const struct sctp_association *asoc)\n{\n\tswitch (asoc->state) {\n\n\t/* 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State */\n\n\tcase SCTP_STATE_COOKIE_WAIT:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = 0;\n\t\tbreak;\n\n\tcase SCTP_STATE_COOKIE_ECHOED:\n\t\tnew_asoc->c.my_vtag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.my_ttag     = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag   = asoc->c.peer_vtag;\n\t\tbreak;\n\n\t/* 5.2.2 Unexpected INIT in States Other than CLOSED, COOKIE-ECHOED,\n\t * COOKIE-WAIT and SHUTDOWN-ACK-SENT\n\t */\n\tdefault:\n\t\tnew_asoc->c.my_ttag   = asoc->c.my_vtag;\n\t\tnew_asoc->c.peer_ttag = asoc->c.peer_vtag;\n\t\tbreak;\n\t}\n\n\t/* Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t */\n\tnew_asoc->rwnd                  = asoc->rwnd;\n\tnew_asoc->c.sinit_num_ostreams  = asoc->c.sinit_num_ostreams;\n\tnew_asoc->c.sinit_max_instreams = asoc->c.sinit_max_instreams;\n\tnew_asoc->c.initial_tsn         = asoc->c.initial_tsn;\n}\n\n/*\n * Compare vtag/tietag values to determine unexpected COOKIE-ECHO\n * handling action.\n *\n * RFC 2960 5.2.4 Handle a COOKIE ECHO when a TCB exists.\n *\n * Returns value representing action to be taken.   These action values\n * correspond to Action/Description values in RFC 2960, Table 2.\n */\nstatic char sctp_tietags_compare(struct sctp_association *new_asoc,\n\t\t\t\t const struct sctp_association *asoc)\n{\n\t/* In this case, the peer may have restarted.  */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag != new_asoc->c.peer_vtag) &&\n\t    (asoc->c.my_vtag == new_asoc->c.my_ttag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_ttag))\n\t\treturn 'A';\n\n\t/* Collision case B. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    ((asoc->c.peer_vtag != new_asoc->c.peer_vtag) ||\n\t     (0 == asoc->c.peer_vtag))) {\n\t\treturn 'B';\n\t}\n\n\t/* Collision case D. */\n\tif ((asoc->c.my_vtag == new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag))\n\t\treturn 'D';\n\n\t/* Collision case C. */\n\tif ((asoc->c.my_vtag != new_asoc->c.my_vtag) &&\n\t    (asoc->c.peer_vtag == new_asoc->c.peer_vtag) &&\n\t    (0 == new_asoc->c.my_ttag) &&\n\t    (0 == new_asoc->c.peer_ttag))\n\t\treturn 'C';\n\n\t/* No match to any of the special cases; discard this packet. */\n\treturn 'E';\n}\n\n/* Common helper routine for both duplicate and simulataneous INIT\n * chunk handling.\n */\nstatic sctp_disposition_t sctp_sf_do_unexpected_init(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *new_asoc;\n\tstruct sctp_chunk *err_chunk;\n\tstruct sctp_packet *packet;\n\tsctp_unrecognized_param_t *unk_param;\n\tint len;\n\n\t/* 6.10 Bundling\n\t * An endpoint MUST NOT bundle INIT, INIT ACK or\n\t * SHUTDOWN COMPLETE with any other chunks.\n\t *\n\t * IG Section 2.11.2\n\t * Furthermore, we require that the receiver of an INIT chunk MUST\n\t * enforce these rules by silently discarding an arriving packet\n\t * with an INIT chunk that is bundled with other chunks.\n\t */\n\tif (!chunk->singleton)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* 3.1 A packet containing an INIT chunk MUST have a zero Verification\n\t * Tag.\n\t */\n\tif (chunk->sctp_hdr->vtag != 0)\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the INIT chunk has a valid length.\n\t * In this case, we generate a protocol violation since we have\n\t * an association established.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_init_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* Grab the INIT header.  */\n\tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n\n\t/* Tag the variable length parameters.  */\n\tchunk->param_hdr.v = skb_pull(chunk->skb, sizeof(sctp_inithdr_t));\n\n\t/* Verify the INIT chunk before processing it. */\n\terr_chunk = NULL;\n\tif (!sctp_verify_init(net, ep, asoc, chunk->chunk_hdr->type,\n\t\t\t      (sctp_init_chunk_t *)chunk->chunk_hdr, chunk,\n\t\t\t      &err_chunk)) {\n\t\t/* This chunk contains fatal error. It is to be discarded.\n\t\t * Send an ABORT, with causes if there is any.\n\t\t */\n\t\tif (err_chunk) {\n\t\t\tpacket = sctp_abort_pkt_new(net, ep, asoc, arg,\n\t\t\t\t\t(__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t\t\tsizeof(sctp_chunkhdr_t),\n\t\t\t\t\tntohs(err_chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t));\n\n\t\t\tif (packet) {\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\t} else {\n\t\t\t\tretval = SCTP_DISPOSITION_NOMEM;\n\t\t\t}\n\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg,\n\t\t\t\t\t\t    commands);\n\t\t}\n\t}\n\n\t/*\n\t * Other parameters for the endpoint SHOULD be copied from the\n\t * existing parameters of the association (e.g. number of\n\t * outbound streams) into the INIT ACK and cookie.\n\t * FIXME:  We are copying parameters from the endpoint not the\n\t * association.\n\t */\n\tnew_asoc = sctp_make_temp_asoc(ep, chunk, GFP_ATOMIC);\n\tif (!new_asoc)\n\t\tgoto nomem;\n\n\tif (sctp_assoc_set_bind_addr_from_ep(new_asoc,\n\t\t\t\tsctp_scope(sctp_source(chunk)), GFP_ATOMIC) < 0)\n\t\tgoto nomem;\n\n\t/* In the outbound INIT ACK the endpoint MUST copy its current\n\t * Verification Tag and Peers Verification tag into a reserved\n\t * place (local tie-tag and per tie-tag) within the state cookie.\n\t */\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk),\n\t\t\t       (sctp_init_chunk_t *)chunk->chunk_hdr,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.   Do not do this check for COOKIE-WAIT state,\n\t * since there are no peer addresses to check against.\n\t * Upon return an ABORT will have been sent if needed.\n\t */\n\tif (!sctp_state(asoc, COOKIE_WAIT)) {\n\t\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk,\n\t\t\t\t\t\t commands)) {\n\t\t\tretval = SCTP_DISPOSITION_CONSUME;\n\t\t\tgoto nomem_retval;\n\t\t}\n\t}\n\n\tsctp_tietags_populate(new_asoc, asoc);\n\n\t/* B) \"Z\" shall respond immediately with an INIT ACK chunk.  */\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * make sure to reserve enough room in the INIT ACK for them.\n\t */\n\tlen = 0;\n\tif (err_chunk) {\n\t\tlen = ntohs(err_chunk->chunk_hdr->length) -\n\t\t\tsizeof(sctp_chunkhdr_t);\n\t}\n\n\trepl = sctp_make_init_ack(new_asoc, chunk, GFP_ATOMIC, len);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* If there are errors need to be reported for unknown parameters,\n\t * include them in the outgoing INIT ACK as \"Unrecognized parameter\"\n\t * parameter.\n\t */\n\tif (err_chunk) {\n\t\t/* Get the \"Unrecognized parameter\" parameter(s) out of the\n\t\t * ERROR chunk generated by sctp_verify_init(). Since the\n\t\t * error cause code for \"unknown parameter\" and the\n\t\t * \"Unrecognized parameter\" type is the same, we can\n\t\t * construct the parameters in INIT ACK by copying the\n\t\t * ERROR causes over.\n\t\t */\n\t\tunk_param = (sctp_unrecognized_param_t *)\n\t\t\t    ((__u8 *)(err_chunk->chunk_hdr) +\n\t\t\t    sizeof(sctp_chunkhdr_t));\n\t\t/* Replace the cause code with the \"Unrecognized parameter\"\n\t\t * parameter type.\n\t\t */\n\t\tsctp_addto_chunk(repl, len, unk_param);\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/*\n\t * Note: After sending out INIT ACK with the State Cookie parameter,\n\t * \"Z\" MUST NOT allocate any resources for this new association.\n\t * Otherwise, \"Z\" will be vulnerable to resource attacks.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\treturn retval;\n\nnomem:\n\tretval = SCTP_DISPOSITION_NOMEM;\nnomem_retval:\n\tif (new_asoc)\n\t\tsctp_association_free(new_asoc);\ncleanup:\n\tif (err_chunk)\n\t\tsctp_chunk_free(err_chunk);\n\treturn retval;\n}\n\n/*\n * Handle simultaneous INIT.\n * This means we started an INIT and then we got an INIT request from\n * our peer.\n *\n * Section: 5.2.1 INIT received in COOKIE-WAIT or COOKIE-ECHOED State (Item B)\n * This usually indicates an initialization collision, i.e., each\n * endpoint is attempting, at about the same time, to establish an\n * association with the other endpoint.\n *\n * Upon receipt of an INIT in the COOKIE-WAIT or COOKIE-ECHOED state, an\n * endpoint MUST respond with an INIT ACK using the same parameters it\n * sent in its original INIT chunk (including its Verification Tag,\n * unchanged). These original parameters are combined with those from the\n * newly received INIT chunk. The endpoint shall also generate a State\n * Cookie with the INIT ACK. The endpoint uses the parameters sent in its\n * INIT to calculate the State Cookie.\n *\n * After that, the endpoint MUST NOT change its state, the T1-init\n * timer shall be left running and the corresponding TCB MUST NOT be\n * destroyed. The normal procedures for handling State Cookies when\n * a TCB exists will resolve the duplicate INITs to a single association.\n *\n * For an endpoint that is in the COOKIE-ECHOED state it MUST populate\n * its Tie-Tags with the Tag information of itself and its peer (see\n * section 5.2.2 for a description of the Tie-Tags).\n *\n * Verification Tag: Not explicit, but an INIT can not have a valid\n * verification tag, so we skip the check.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle duplicated INIT messages.  These are usually delayed\n * restransmissions.\n *\n * Section: 5.2.2 Unexpected INIT in States Other than CLOSED,\n * COOKIE-ECHOED and COOKIE-WAIT\n *\n * Unless otherwise stated, upon reception of an unexpected INIT for\n * this association, the endpoint shall generate an INIT ACK with a\n * State Cookie.  In the outbound INIT ACK the endpoint MUST copy its\n * current Verification Tag and peer's Verification Tag into a reserved\n * place within the state cookie.  We shall refer to these locations as\n * the Peer's-Tie-Tag and the Local-Tie-Tag.  The outbound SCTP packet\n * containing this INIT ACK MUST carry a Verification Tag value equal to\n * the Initiation Tag found in the unexpected INIT.  And the INIT ACK\n * MUST contain a new Initiation Tag (randomly generated see Section\n * 5.3.1).  Other parameters for the endpoint SHOULD be copied from the\n * existing parameters of the association (e.g. number of outbound\n * streams) into the INIT ACK and cookie.\n *\n * After sending out the INIT ACK, the endpoint shall take no further\n * actions, i.e., the existing association, including its current state,\n * and the corresponding TCB MUST NOT be changed.\n *\n * Note: Only when a TCB exists and the association is not in a COOKIE-\n * WAIT state are the Tie-Tags populated.  For a normal association INIT\n * (i.e. the endpoint is in a COOKIE-WAIT state), the Tie-Tags MUST be\n * set to 0 (indicating that no previous TCB existed).  The INIT ACK and\n * State Cookie are populated as specified in section 5.2.1.\n *\n * Verification Tag: Not specified, but an INIT has no way of knowing\n * what the verification tag could be, so we ignore it.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_2_dupinit(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\t/* Call helper to do the real work for both simulataneous and\n\t * duplicate INIT chunk handling.\n\t */\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}\n\n\n/*\n * Unexpected INIT-ACK handler.\n *\n * Section 5.2.3\n * If an INIT ACK received by an endpoint in any state other than the\n * COOKIE-WAIT state, the endpoint should discard the INIT ACK chunk.\n * An unexpected INIT ACK usually indicates the processing of an old or\n * duplicated INIT chunk.\n*/\nsctp_disposition_t sctp_sf_do_5_2_3_initack(struct net *net,\n\t\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t\t    void *arg, sctp_cmd_seq_t *commands)\n{\n\t/* Per the above section, we'll discard the chunk if we have an\n\t * endpoint.  If this is an OOTB INIT-ACK, treat it as such.\n\t */\n\tif (ep == sctp_sk(net->sctp.ctl_sock)->ep)\n\t\treturn sctp_sf_ootb(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n}\n\n/* Unexpected COOKIE-ECHO handler for peer restart (Table 2, action 'A')\n *\n * Section 5.2.4\n *  A)  In this case, the peer may have restarted.\n */\nstatic sctp_disposition_t sctp_sf_do_dupcook_a(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_ulpevent *ev;\n\tstruct sctp_chunk *repl;\n\tstruct sctp_chunk *err;\n\tsctp_disposition_t disposition;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Make sure no new addresses are being added during the\n\t * restart.  Though this is a pretty complicated attack\n\t * since you'd have to get inside the cookie.\n\t */\n\tif (!sctp_sf_check_restart_addrs(new_asoc, asoc, chunk, commands)) {\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* If the endpoint is in the SHUTDOWN-ACK-SENT state and recognizes\n\t * the peer has restarted (Action A), it MUST NOT setup a new\n\t * association but instead resend the SHUTDOWN ACK and send an ERROR\n\t * chunk with a \"Cookie Received while Shutting Down\" error cause to\n\t * its peer.\n\t*/\n\tif (sctp_state(asoc, SHUTDOWN_ACK_SENT)) {\n\t\tdisposition = sctp_sf_do_9_2_reshutack(net, ep, asoc,\n\t\t\t\tSCTP_ST_CHUNK(chunk->chunk_hdr->type),\n\t\t\t\tchunk, commands);\n\t\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\t\tgoto nomem;\n\n\t\terr = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t SCTP_ERROR_COOKIE_IN_SHUTDOWN,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\t/* For now, stop pending T3-rtx and SACK timers, fail any unsent/unacked\n\t * data. Consider the optional choice of resending of this data.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_OUTQUEUE, SCTP_NULL());\n\n\t/* Stop pending T4-rto timer, teardown ASCONF queue, ASCONF-ACK queue\n\t * and ASCONF-ACK cache.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PURGE_ASCONF_QUEUE, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Report association restart to upper layer. */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_RESTART, 0,\n\t\t\t\t\t     new_asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     new_asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem_ev;\n\n\t/* Update the content of current association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\tif (sctp_state(asoc, SHUTDOWN_PENDING) &&\n\t    (sctp_sstate(asoc->base.sk, CLOSING) ||\n\t     sock_flag(asoc->base.sk, SOCK_DEAD))) {\n\t\t/* if were currently in SHUTDOWN_PENDING, but the socket\n\t\t * has been closed by user, don't transition to ESTABLISHED.\n\t\t * Instead trigger SHUTDOWN bundled with COOKIE_ACK.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t\treturn sctp_sf_do_9_2_start_shutdown(net, ep, asoc,\n\t\t\t\t\t\t     SCTP_ST_CHUNK(0), NULL,\n\t\t\t\t\t\t     commands);\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem_ev:\n\tsctp_chunk_free(repl);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'B')\n *\n * Section 5.2.4\n *   B) In this case, both sides may be attempting to start an association\n *      at about the same time but the peer endpoint started its INIT\n *      after responding to the local endpoint's INIT\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_b(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tsctp_init_chunk_t *peer_init;\n\tstruct sctp_chunk *repl;\n\n\t/* new_asoc is a brand-new association, so these are not yet\n\t * side effects--it is safe to run them here.\n\t */\n\tpeer_init = &chunk->subh.cookie_hdr->c.peer_init[0];\n\tif (!sctp_process_init(new_asoc, chunk, sctp_source(chunk), peer_init,\n\t\t\t       GFP_ATOMIC))\n\t\tgoto nomem;\n\n\t/* Update the content of current association.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_ASSOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START, SCTP_NULL());\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * D) IMPLEMENTATION NOTE: An implementation may choose to\n\t * send the Communication Up notification to the SCTP user\n\t * upon reception of a valid COOKIE ECHO chunk.\n\t *\n\t * Sadly, this needs to be implemented as a side-effect, because\n\t * we are not guaranteed to have set the association id of the real\n\t * association and so these notifications need to be delayed until\n\t * the association id is allocated.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_CHANGE, SCTP_U8(SCTP_COMM_UP));\n\n\t/* Sockets API Draft Section 5.3.1.6\n\t * When a peer sends a Adaptation Layer Indication parameter , SCTP\n\t * delivers this notification to inform the application that of the\n\t * peers requested adaptation layer.\n\t *\n\t * This also needs to be done as a side effect for the same reason as\n\t * above.\n\t */\n\tif (asoc->peer.adaptation_ind)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ADAPTATION_IND, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Unexpected COOKIE-ECHO handler for setup collision (Table 2, action 'C')\n *\n * Section 5.2.4\n *  C) In this case, the local endpoint's cookie has arrived late.\n *     Before it arrived, the local endpoint sent an INIT and received an\n *     INIT-ACK and finally sent a COOKIE ECHO with the peer's same tag\n *     but a new tag of its own.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_c(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\t/* The cookie should be silently discarded.\n\t * The endpoint SHOULD NOT change states and should leave\n\t * any timers running.\n\t */\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/* Unexpected COOKIE-ECHO handler lost chunk (Table 2, action 'D')\n *\n * Section 5.2.4\n *\n * D) When both local and remote tags match the endpoint should always\n *    enter the ESTABLISHED state, if it has not already done so.\n */\n/* This case represents an initialization collision.  */\nstatic sctp_disposition_t sctp_sf_do_dupcook_d(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tsctp_cmd_seq_t *commands,\n\t\t\t\t\tstruct sctp_association *new_asoc)\n{\n\tstruct sctp_ulpevent *ev = NULL, *ai_ev = NULL;\n\tstruct sctp_chunk *repl;\n\n\t/* Clarification from Implementor's Guide:\n\t * D) When both local and remote tags match the endpoint should\n\t * enter the ESTABLISHED state, if it is in the COOKIE-ECHOED state.\n\t * It should stop any cookie timer that may be running and send\n\t * a COOKIE ACK.\n\t */\n\n\t/* Don't accidentally move back into established state. */\n\tif (asoc->state < SCTP_STATE_ESTABLISHED) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\t\tSCTP_STATE(SCTP_STATE_ESTABLISHED));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_START,\n\t\t\t\tSCTP_NULL());\n\n\t\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t\t *\n\t\t * D) IMPLEMENTATION NOTE: An implementation may choose\n\t\t * to send the Communication Up notification to the\n\t\t * SCTP user upon reception of a valid COOKIE\n\t\t * ECHO chunk.\n\t\t */\n\t\tev = sctp_ulpevent_make_assoc_change(asoc, 0,\n\t\t\t\t\t     SCTP_COMM_UP, 0,\n\t\t\t\t\t     asoc->c.sinit_num_ostreams,\n\t\t\t\t\t     asoc->c.sinit_max_instreams,\n\t\t\t\t\t     NULL, GFP_ATOMIC);\n\t\tif (!ev)\n\t\t\tgoto nomem;\n\n\t\t/* Sockets API Draft Section 5.3.1.6\n\t\t * When a peer sends a Adaptation Layer Indication parameter,\n\t\t * SCTP delivers this notification to inform the application\n\t\t * that of the peers requested adaptation layer.\n\t\t */\n\t\tif (asoc->peer.adaptation_ind) {\n\t\t\tai_ev = sctp_ulpevent_make_adaptation_indication(asoc,\n\t\t\t\t\t\t\t\t GFP_ATOMIC);\n\t\t\tif (!ai_ev)\n\t\t\t\tgoto nomem;\n\n\t\t}\n\t}\n\n\trepl = sctp_make_cookie_ack(new_asoc, chunk);\n\tif (!repl)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\n\tif (ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\tif (ai_ev)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\t\tSCTP_ULPEVENT(ai_ev));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\tif (ai_ev)\n\t\tsctp_ulpevent_free(ai_ev);\n\tif (ev)\n\t\tsctp_ulpevent_free(ev);\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a duplicate COOKIE-ECHO.  This usually means a cookie-carrying\n * chunk was retransmitted and then delayed in the network.\n *\n * Section: 5.2.4 Handle a COOKIE ECHO when a TCB exists\n *\n * Verification Tag: None.  Do cookie validation.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_5_2_4_dupcook(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_disposition_t retval;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_association *new_asoc;\n\tint error = 0;\n\tchar action;\n\tstruct sctp_chunk *err_chk_p;\n\n\t/* Make sure that the chunk has a valid length from the protocol\n\t * perspective.  In this case check to make sure we have at least\n\t * enough for the chunk header.  Cookie length verification is\n\t * done later.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* \"Decode\" the chunk.  We have no optional parameters so we\n\t * are in good shape.\n\t */\n\tchunk->subh.cookie_hdr = (struct sctp_signed_cookie *)chunk->skb->data;\n\tif (!pskb_pull(chunk->skb, ntohs(chunk->chunk_hdr->length) -\n\t\t\t\t\tsizeof(sctp_chunkhdr_t)))\n\t\tgoto nomem;\n\n\t/* In RFC 2960 5.2.4 3, if both Verification Tags in the State Cookie\n\t * of a duplicate COOKIE ECHO match the Verification Tags of the\n\t * current association, consider the State Cookie valid even if\n\t * the lifespan is exceeded.\n\t */\n\tnew_asoc = sctp_unpack_cookie(ep, asoc, chunk, GFP_ATOMIC, &error,\n\t\t\t\t      &err_chk_p);\n\n\t/* FIXME:\n\t * If the re-build failed, what is the proper error path\n\t * from here?\n\t *\n\t * [We should abort the association. --piggy]\n\t */\n\tif (!new_asoc) {\n\t\t/* FIXME: Several errors are possible.  A bad cookie should\n\t\t * be silently discarded, but think about logging it too.\n\t\t */\n\t\tswitch (error) {\n\t\tcase -SCTP_IERROR_NOMEM:\n\t\t\tgoto nomem;\n\n\t\tcase -SCTP_IERROR_STALE_COOKIE:\n\t\t\tsctp_send_stale_cookie_err(net, ep, asoc, chunk, commands,\n\t\t\t\t\t\t   err_chk_p);\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tcase -SCTP_IERROR_BAD_SIG:\n\t\tdefault:\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\t}\n\t}\n\n\t/* Compare the tie_tag in cookie with the verification tag of\n\t * current association.\n\t */\n\taction = sctp_tietags_compare(new_asoc, asoc);\n\n\tswitch (action) {\n\tcase 'A': /* Association restart. */\n\t\tretval = sctp_sf_do_dupcook_a(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'B': /* Collision case B. */\n\t\tretval = sctp_sf_do_dupcook_b(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'C': /* Collision case C. */\n\t\tretval = sctp_sf_do_dupcook_c(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tcase 'D': /* Collision case D. */\n\t\tretval = sctp_sf_do_dupcook_d(net, ep, asoc, chunk, commands,\n\t\t\t\t\t      new_asoc);\n\t\tbreak;\n\n\tdefault: /* Discard packet for all others. */\n\t\tretval = sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tbreak;\n\t}\n\n\t/* Delete the tempory new association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC, SCTP_ASOC(new_asoc));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\t/* Restore association pointer to provide SCTP command interpeter\n\t * with a valid context in case it needs to manipulate\n\t * the queues */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_ASOC,\n\t\t\t SCTP_ASOC((struct sctp_association *)asoc));\n\n\treturn retval;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-PENDING state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_pending_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_sent_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Stop the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process an ABORT.  (SHUTDOWN-ACK-SENT state)\n *\n * See sctp_sf_do_9_1_abort().\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an Error received in COOKIE_ECHOED state.\n *\n * Only handle the error type of stale COOKIE Error, the other errors will\n * be ignored.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_cookie_echoed_err(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length.\n\t * The parameter walking depends on this as well.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Process the error here */\n\t/* FUTURE FIXME:  When PR-SCTP related and other optional\n\t * parms are emitted, this will have to change to handle multiple\n\t * errors.\n\t */\n\tsctp_walk_errors(err, chunk->chunk_hdr) {\n\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause)\n\t\t\treturn sctp_sf_do_5_2_6_stale(net, ep, asoc, type,\n\t\t\t\t\t\t\targ, commands);\n\t}\n\n\t/* It is possible to have malformed error causes, and that\n\t * will cause us to end the walk early.  However, since\n\t * we are discarding the packet, there should be no adverse\n\t * affects.\n\t */\n\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle a Stale COOKIE Error\n *\n * Section: 5.2.6 Handle Stale COOKIE Error\n * If the association is in the COOKIE-ECHOED state, the endpoint may elect\n * one of the following three alternatives.\n * ...\n * 3) Send a new INIT chunk to the endpoint, adding a Cookie\n *    Preservative parameter requesting an extension to the lifetime of\n *    the State Cookie. When calculating the time extension, an\n *    implementation SHOULD use the RTT information measured based on the\n *    previous COOKIE ECHO / ERROR exchange, and should add no more\n *    than 1 second beyond the measured RTT, due to long State Cookie\n *    lifetimes making the endpoint more subject to a replay attack.\n *\n * Verification Tag:  Not explicit, but safe to ignore.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_do_5_2_6_stale(struct net *net,\n\t\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t\t void *arg,\n\t\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\ttime_t stale;\n\tsctp_cookie_preserve_param_t bht;\n\tsctp_errhdr_t *err;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tif (attempts > asoc->max_init_attempts) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_STALE_COOKIE));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\terr = (sctp_errhdr_t *)(chunk->skb->data);\n\n\t/* When calculating the time extension, an implementation\n\t * SHOULD use the RTT information measured based on the\n\t * previous COOKIE ECHO / ERROR exchange, and should add no\n\t * more than 1 second beyond the measured RTT, due to long\n\t * State Cookie lifetimes making the endpoint more subject to\n\t * a replay attack.\n\t * Measure of Staleness's unit is usec. (1/1000000 sec)\n\t * Suggested Cookie Life-span Increment's unit is msec.\n\t * (1/1000 sec)\n\t * In general, if you use the suggested cookie life, the value\n\t * found in the field of measure of staleness should be doubled\n\t * to give ample time to retransmit the new cookie and thus\n\t * yield a higher probability of success on the reattempt.\n\t */\n\tstale = ntohl(*(__be32 *)((u8 *)err + sizeof(sctp_errhdr_t)));\n\tstale = (stale * 2) / 1000;\n\n\tbht.param_hdr.type = SCTP_PARAM_COOKIE_PRESERVATIVE;\n\tbht.param_hdr.length = htons(sizeof(bht));\n\tbht.lifespan_increment = htonl(stale);\n\n\t/* Build that new INIT chunk.  */\n\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\treply = sctp_make_init(asoc, bp, GFP_ATOMIC, sizeof(bht));\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_addto_chunk(reply, sizeof(bht), &bht);\n\n\t/* Clear peer's init_tag cached in assoc as we are sending a new INIT */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_CLEAR_INIT_TAG, SCTP_NULL());\n\n\t/* Stop pending T3-rtx and heartbeat timers */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T3_RTX_TIMERS_STOP, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\t/* Delete non-primary peer ip addresses since we are transitioning\n\t * back to the COOKIE-WAIT state\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DEL_NON_PRIMARY, SCTP_NULL());\n\n\t/* If we've sent any data bundled with COOKIE-ECHO we will need to\n\t * resend\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_T1_RETRAN,\n\t\t\tSCTP_TRANSPORT(asoc->peer.primary_path));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_COUNTER_INC, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process an ABORT.\n *\n * Section: 9.1\n * After checking the Verification Tag, the receiving endpoint shall\n * remove the association from its record, and shall report the\n * termination to its upper layer.\n *\n * Verification Tag: 8.5.1 Exceptions in Verification Tag Rules\n * B) Rules for packet carrying ABORT:\n *\n *  - The endpoint shall always fill in the Verification Tag field of the\n *    outbound packet with the destination endpoint's tag value if it\n *    is known.\n *\n *  - If the ABORT is sent in response to an OOTB packet, the endpoint\n *    MUST follow the procedure described in Section 8.4.\n *\n *  - The receiver MUST accept the packet if the Verification Tag\n *    matches either its own tag, OR the tag of its peer. Otherwise, the\n *    receiver MUST silently discard the packet and take no further\n *    action.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* ADD-IP: Special case for ABORT chunks\n\t * F4)  One special consideration is that ABORT Chunks arriving\n\t * destined to the IP address being deleted MUST be\n\t * ignored (see Section 5.3.1 for further details).\n\t */\n\tif (SCTP_ADDR_DEL ==\n\t\t    sctp_bind_addr_state(&asoc->base.bind_addr, &chunk->dest))\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\treturn __sctp_sf_do_9_1_abort(net, ep, asoc, type, arg, commands);\n}\n\nstatic sctp_disposition_t __sctp_sf_do_9_1_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr)) {\n\n\t\tsctp_errhdr_t *err;\n\t\tsctp_walk_errors(err, chunk->chunk_hdr);\n\t\tif ((void *)err != (void *)chunk->chunk_end)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(ECONNRESET));\n\t/* ASSOC_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED, SCTP_PERR(error));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * Process an ABORT.  (COOKIE-WAIT state)\n *\n * See sctp_sf_do_9_1_abort() above.\n */\nsctp_disposition_t sctp_sf_cookie_wait_abort(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tunsigned int len;\n\t__be16 error = SCTP_ERROR_NO_ERROR;\n\n\tif (!sctp_vtag_verify_either(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ABORT chunk has a valid length.\n\t * Since this is an ABORT chunk, we have to discard it\n\t * because of the following text:\n\t * RFC 2960, Section 3.3.7\n\t *    If an endpoint receives an ABORT with a format error or for an\n\t *    association that doesn't exist, it MUST silently discard it.\n\t * Because the length is \"invalid\", we can't really discard just\n\t * as we do not know its true length.  So, to be safe, discard the\n\t * packet.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_abort_chunk_t)))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* See if we have an error cause code in the chunk.  */\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tif (len >= sizeof(struct sctp_chunkhdr) + sizeof(struct sctp_errhdr))\n\t\terror = ((sctp_errhdr_t *)chunk->skb->data)->cause;\n\n\treturn sctp_stop_t1_and_abort(net, commands, error, ECONNREFUSED, asoc,\n\t\t\t\t      chunk->transport);\n}\n\n/*\n * Process an incoming ICMP as an ABORT.  (COOKIE-WAIT state)\n */\nsctp_disposition_t sctp_sf_cookie_wait_icmp_abort(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\treturn sctp_stop_t1_and_abort(net, commands, SCTP_ERROR_NO_ERROR,\n\t\t\t\t      ENOPROTOOPT, asoc,\n\t\t\t\t      (struct sctp_transport *)arg);\n}\n\n/*\n * Process an ABORT.  (COOKIE-ECHOED state)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_abort(struct net *net,\n\t\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t\t       void *arg,\n\t\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Stop T1 timer and abort association with \"INIT failed\".\n *\n * This is common code called by several sctp_sf_*_abort() functions above.\n */\nstatic sctp_disposition_t sctp_stop_t1_and_abort(struct net *net,\n\t\t\t\t\t   sctp_cmd_seq_t *commands,\n\t\t\t\t\t   __be16 error, int sk_err,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   struct sctp_transport *transport)\n{\n\tpr_debug(\"%s: ABORT received (INIT)\\n\", __func__);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR, SCTP_ERROR(sk_err));\n\t/* CMD_INIT_FAILED will DELETE_TCB. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(error));\n\n\treturn SCTP_DISPOSITION_ABORT;\n}\n\n/*\n * sctp_sf_do_9_2_shut\n *\n * Section: 9.2\n * Upon the reception of the SHUTDOWN, the peer endpoint shall\n *  - enter the SHUTDOWN-RECEIVED state,\n *\n *  - stop accepting new data from its SCTP user\n *\n *  - verify, by checking the Cumulative TSN Ack field of the chunk,\n *    that all its outstanding DATA chunks have been received by the\n *    SHUTDOWN sender.\n *\n * Once an endpoint as reached the SHUTDOWN-RECEIVED state it MUST NOT\n * send a SHUTDOWN in response to a ULP request. And should discard\n * subsequent SHUTDOWN chunks.\n *\n * If there are still outstanding DATA chunks left, the SHUTDOWN\n * receiver shall continue to follow normal data transmission\n * procedures defined in Section 6 until all outstanding DATA chunks\n * are acknowledged; however, the SHUTDOWN receiver MUST NOT accept\n * new data from its SCTP user.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\tsctp_disposition_t disposition;\n\tstruct sctp_ulpevent *ev;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Convert the elaborate header.  */\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_shutdownhdr_t));\n\tchunk->subh.shutdown_hdr = sdh;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* API 5.3.1.5 SCTP_SHUTDOWN_EVENT\n\t * When a peer sends a SHUTDOWN, SCTP delivers this notification to\n\t * inform the application that it should cease sending data.\n\t */\n\tev = sctp_ulpevent_make_shutdown_event(asoc, 0, GFP_ATOMIC);\n\tif (!ev) {\n\t\tdisposition = SCTP_DISPOSITION_NOMEM;\n\t\tgoto out;\n\t}\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the reception of the SHUTDOWN, the peer endpoint shall\n\t *  - enter the SHUTDOWN-RECEIVED state,\n\t *  - stop accepting new data from its SCTP user\n\t *\n\t * [This is implicit in the new state.]\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_RECEIVED));\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_shutdown_ack(net, ep, asoc, type,\n\t\t\t\t\t\t\t  arg, commands);\n\t}\n\n\tif (SCTP_DISPOSITION_NOMEM == disposition)\n\t\tgoto out;\n\n\t/*  - verify, by checking the Cumulative TSN Ack field of the\n\t *    chunk, that all its outstanding DATA chunks have been\n\t *    received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(chunk->subh.shutdown_hdr->cum_tsn_ack));\n\nout:\n\treturn disposition;\n}\n\n/*\n * sctp_sf_do_9_2_shut_ctsn\n *\n * Once an endpoint has reached the SHUTDOWN-RECEIVED state,\n * it MUST NOT send a SHUTDOWN in response to a ULP request.\n * The Cumulative TSN Ack of the received SHUTDOWN chunk\n * MUST be processed.\n */\nsctp_disposition_t sctp_sf_do_9_2_shut_ctsn(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* verify, by checking the Cumulative TSN Ack field of the\n\t * chunk, that all its outstanding DATA chunks have been\n\t * received by the SHUTDOWN sender.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC 2960 9.2\n * If an endpoint is in SHUTDOWN-ACK-SENT state and receives an INIT chunk\n * (e.g., if the SHUTDOWN COMPLETE was lost) with source and destination\n * transport addresses (either in the IP addresses or in the INIT chunk)\n * that belong to this association, it should discard the INIT chunk and\n * retransmit the SHUTDOWN ACK chunk.\n */\nsctp_disposition_t sctp_sf_do_9_2_reshutack(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* Make sure that the chunk has a valid length */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Since we are not going to really process this INIT, there\n\t * is no point in verifying chunk boundries.  Just generate\n\t * the SHUTDOWN ACK.\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (NULL == reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-SHUTDOWN timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and restart the T2-shutdown timer. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * sctp_sf_do_ecn_cwr\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * CWR:\n *\n * RFC 2481 details a specific bit for a sender to send in the header of\n * its next outbound TCP segment to indicate to its peer that it has\n * reduced its congestion window.  This is termed the CWR bit.  For\n * SCTP the same indication is made by including the CWR chunk.\n * This chunk contains one data element, i.e. the TSN number that\n * was sent in the ECNE chunk.  This element represents the lowest\n * TSN number in the datagram that was originally marked with the\n * CE bit.\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecn_cwr(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tsctp_cwrhdr_t *cwr;\n\tstruct sctp_chunk *chunk = arg;\n\tu32 lowest_tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcwr = (sctp_cwrhdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_cwrhdr_t));\n\n\tlowest_tsn = ntohl(cwr->lowest_tsn);\n\n\t/* Does this CWR ack the last sent congestion notification? */\n\tif (TSN_lte(asoc->last_ecne_tsn, lowest_tsn)) {\n\t\t/* Stop sending ECNE. */\n\t\tsctp_add_cmd_sf(commands,\n\t\t\t\tSCTP_CMD_ECN_CWR,\n\t\t\t\tSCTP_U32(lowest_tsn));\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_do_ecne\n *\n * Section:  Appendix A: Explicit Congestion Notification\n *\n * ECN-Echo\n *\n * RFC 2481 details a specific bit for a receiver to send back in its\n * TCP acknowledgements to notify the sender of the Congestion\n * Experienced (CE) bit having arrived from the network.  For SCTP this\n * same indication is made by including the ECNE chunk.  This chunk\n * contains one data element, i.e. the lowest TSN associated with the IP\n * datagram marked with the CE bit.....\n *\n * Verification Tag: 8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_ecne(struct net *net,\n\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t   void *arg,\n\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tsctp_ecnehdr_t *ecne;\n\tstruct sctp_chunk *chunk = arg;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_ecne_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tecne = (sctp_ecnehdr_t *) chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_ecnehdr_t));\n\n\t/* If this is a newer ECNE than the last CWR packet we sent out */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_ECNE,\n\t\t\tSCTP_U32(ntohl(ecne->lowest_tsn)));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The SCTP endpoint MUST always acknowledge the reception of each valid\n * DATA chunk.\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed. Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated within\n * 200 ms of the arrival of any unacknowledged DATA chunk. In some\n * situations it may be beneficial for an SCTP transmitter to be more\n * conservative than the algorithms detailed in this document allow.\n * However, an SCTP transmitter MUST NOT be more aggressive than the\n * following algorithms allow.\n *\n * A SCTP receiver MUST NOT generate more than one SACK for every\n * incoming packet, other than to update the offered window as the\n * receiving application consumes new data.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_arg_t force = SCTP_NOFORCE();\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\t\tbreak;\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_noforce;\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\t\tSCTP_INC_STATS(net, SCTP_MIB_IN_DATA_CHUNK_DISCARDS);\n\t\tgoto discard_force;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_SACK_IMM)\n\t\tforce = SCTP_FORCE();\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* If this is the last chunk in a packet, we need to count it\n\t * toward sack generation.  Note that we need to SACK every\n\t * OTHER packet containing data chunks, EVEN IF WE DISCARD\n\t * THEM.  We elect to NOT generate SACK's if the chunk fails\n\t * the verification tag test.\n\t *\n\t * RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * The SCTP endpoint MUST always acknowledge the reception of\n\t * each valid DATA chunk.\n\t *\n\t * The guidelines on delayed acknowledgement algorithm\n\t * specified in  Section 4.2 of [RFC2581] SHOULD be followed.\n\t * Specifically, an acknowledgement SHOULD be generated for at\n\t * least every second packet (not every second DATA chunk)\n\t * received, and SHOULD be generated within 200 ms of the\n\t * arrival of any unacknowledged DATA chunk.  In some\n\t * situations it may be beneficial for an SCTP transmitter to\n\t * be more conservative than the algorithms detailed in this\n\t * document allow. However, an SCTP transmitter MUST NOT be\n\t * more aggressive than the following algorithms allow.\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_force:\n\t/* RFC 2960 6.2 Acknowledgement on Reception of DATA Chunks\n\t *\n\t * When a packet arrives with duplicate DATA chunk(s) and with\n\t * no new DATA chunk(s), the endpoint MUST immediately send a\n\t * SACK with no delay.  If a packet arrives with duplicate\n\t * DATA chunk(s) bundled with new DATA chunks, the endpoint\n\t * MAY immediately send a SACK.  Normally receipt of duplicate\n\t * DATA chunks will occur when the original SACK chunk was lost\n\t * and the peer's RTO has expired.  The duplicate TSN number(s)\n\t * SHOULD be reported in the SACK as duplicate.\n\t */\n\t/* In our case, we split the MAY SACK advice up whether or not\n\t * the last chunk is a duplicate.'\n\t */\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_DISCARD;\n\ndiscard_noforce:\n\tif (chunk->end_of_packet)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, force);\n\n\treturn SCTP_DISPOSITION_DISCARD;\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n\n}\n\n/*\n * sctp_sf_eat_data_fast_4_4\n *\n * Section: 4 (4)\n * (4) In SHUTDOWN-SENT state the endpoint MUST acknowledge any received\n *    DATA chunks without delay.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_data_fast_4_4(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tint error;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_data_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\terror = sctp_eat_data(asoc, chunk, commands);\n\tswitch (error) {\n\tcase SCTP_IERROR_NO_ERROR:\n\tcase SCTP_IERROR_HIGH_TSN:\n\tcase SCTP_IERROR_DUP_TSN:\n\tcase SCTP_IERROR_IGNORE_TSN:\n\tcase SCTP_IERROR_BAD_STREAM:\n\t\tbreak;\n\tcase SCTP_IERROR_NO_DATA:\n\t\tgoto consume;\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_abort_violation(net, ep, asoc, chunk, commands,\n\t\t\t(u8 *)chunk->subh.data_hdr, sizeof(sctp_datahdr_t));\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Go a head and force a SACK, since we are shutting down. */\n\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tif (chunk->end_of_packet) {\n\t\t/* We must delay the chunk creation since the cumulative\n\t\t * TSN has not been updated yet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\t}\n\nconsume:\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Section: 6.2  Processing a Received SACK\n * D) Any time a SACK arrives, the endpoint performs the following:\n *\n *     i) If Cumulative TSN Ack is less than the Cumulative TSN Ack Point,\n *     then drop the SACK.   Since Cumulative TSN Ack is monotonically\n *     increasing, a SACK whose Cumulative TSN Ack is less than the\n *     Cumulative TSN Ack Point indicates an out-of-order SACK.\n *\n *     ii) Set rwnd equal to the newly received a_rwnd minus the number\n *     of bytes still outstanding after processing the Cumulative TSN Ack\n *     and the Gap Ack Blocks.\n *\n *     iii) If the SACK is missing a TSN that was previously\n *     acknowledged via a Gap Ack Block (e.g., the data receiver\n *     reneged on the data), then mark the corresponding DATA chunk\n *     as available for retransmit:  Mark it as missing for fast\n *     retransmit as described in Section 7.2.4 and if no retransmit\n *     timer is running for the destination address to which the DATA\n *     chunk was originally transmitted, then T3-rtx is started for\n *     that destination address.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_sack_6_2(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_sackhdr_t *sackh;\n\t__u32 ctsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_sack_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Pull the SACK chunk from the data buffer */\n\tsackh = sctp_sm_pull_sack(chunk);\n\t/* Was this a bogus SACK? */\n\tif (!sackh)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tchunk->subh.sack_hdr = sackh;\n\tctsn = ntohl(sackh->cum_tsn_ack);\n\n\t/* i) If Cumulative TSN Ack is less than the Cumulative TSN\n\t *     Ack Point, then drop the SACK.  Since Cumulative TSN\n\t *     Ack is monotonically increasing, a SACK whose\n\t *     Cumulative TSN Ack is less than the Cumulative TSN Ack\n\t *     Point indicates an out-of-order SACK.\n\t */\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tpr_debug(\"%s: ctsn:%x, ctsn_ack_point:%x\\n\", __func__, ctsn,\n\t\t\t asoc->ctsn_ack_point);\n\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* If Cumulative TSN Ack beyond the max tsn currently\n\t * send, terminating the association and respond to the\n\t * sender with an ABORT.\n\t */\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\n\t/* Return this SACK for further processing.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK, SCTP_CHUNK(chunk));\n\n\t/* Note: We do the rest of the work on the PROCESS_SACK\n\t * sideeffect.\n\t */\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate an ABORT in response to a packet.\n *\n * Section: 8.4 Handle \"Out of the blue\" Packets, sctpimpguide 2.41\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n *\n * Verification Tag:\n *\n * The return value is the disposition of the chunk.\n*/\nstatic sctp_disposition_t sctp_sf_tabort_8_4_8(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT. The T bit will be set if the asoc\n\t\t * is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, 0);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Received an ERROR chunk from peer.  Generate SCTP_REMOTE_ERROR\n * event as ULP notification for each cause included in the chunk.\n *\n * API 5.3.1.3 - SCTP_REMOTE_ERROR\n *\n * The return value is the disposition of the chunk.\n*/\nsctp_disposition_t sctp_sf_operr_notify(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_errhdr_t *err;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ERROR chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_operr_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsctp_walk_errors(err, chunk->chunk_hdr);\n\tif ((void *)err != (void *)chunk->chunk_end)\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err, commands);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_OPERR,\n\t\t\tSCTP_CHUNK(chunk));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an inbound SHUTDOWN ACK.\n *\n * From Section 9.2:\n * Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n * stop the T2-shutdown timer, send a SHUTDOWN COMPLETE chunk to its\n * peer, and remove all record of the association.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_final(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *reply;\n\tstruct sctp_ulpevent *ev;\n\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t/* 10.2 H) SHUTDOWN COMPLETE notification\n\t *\n\t * When SCTP completes the shutdown procedures (section 9.2) this\n\t * notification is passed to the upper layer.\n\t */\n\tev = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_SHUTDOWN_COMP,\n\t\t\t\t\t     0, 0, 0, NULL, GFP_ATOMIC);\n\tif (!ev)\n\t\tgoto nomem;\n\n\t/* ...send a SHUTDOWN COMPLETE chunk to its peer, */\n\treply = sctp_make_shutdown_complete(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem_chunk;\n\n\t/* Do all the commands now (after allocation), so that we\n\t * have consistent state if memory allocation failes\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(ev));\n\n\t/* Upon the receipt of the SHUTDOWN ACK, the SHUTDOWN sender shall\n\t * stop the T2-shutdown timer,\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\t/* ...and remove all record of the association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n\nnomem_chunk:\n\tsctp_ulpevent_free(ev);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * RFC 2960, 8.4 - Handle \"Out of the blue\" Packets, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * 8) The receiver should respond to the sender of the OOTB packet with\n *    an ABORT.  When sending the ABORT, the receiver of the OOTB packet\n *    MUST fill in the Verification Tag field of the outbound packet\n *    with the value found in the Verification Tag field of the OOTB\n *    packet and set the T-bit in the Chunk Flags to indicate that the\n *    Verification Tag is reflected.  After sending this ABORT, the\n *    receiver of the OOTB packet shall discard the OOTB packet and take\n *    no further action.\n */\nsctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\t/* Report violation if the chunk is less then minimal */\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\t/* Now that we know we at least have a chunk header,\n\t\t * do things that are type appropriate.\n\t\t */\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\n\t\t/* RFC 2960, Section 3.3.7\n\t\t *   Moreover, under any circumstances, an endpoint that\n\t\t *   receives an ABORT  MUST NOT respond to that ABORT by\n\t\t *   sending an ABORT of its own.\n\t\t */\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* RFC 8.4, 7) If the packet contains a \"Stale cookie\" ERROR\n\t\t * or a COOKIE ACK the SCTP Packet should be silently\n\t\t * discarded.\n\t\t */\n\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Report violation if chunk len overflows */\n\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Handle an \"Out of the blue\" SHUTDOWN ACK.\n *\n * Section: 8.4 5, sctpimpguide 2.41.\n *\n * 5) If the packet contains a SHUTDOWN ACK chunk, the receiver should\n *    respond to the sender of the OOTB packet with a SHUTDOWN COMPLETE.\n *    When sending the SHUTDOWN COMPLETE, the receiver of the OOTB\n *    packet must fill in the Verification Tag field of the outbound\n *    packet with the Verification Tag received in the SHUTDOWN ACK and\n *    set the T-bit in the Chunk Flags to indicate that the Verification\n *    Tag is reflected.\n *\n * Inputs\n * (endpoint, asoc, type, arg, commands)\n *\n * Outputs\n * (sctp_disposition_t)\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_disposition_t sctp_sf_shut_8_4_5(struct net *net,\n\t\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t\t     void *arg,\n\t\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *shut;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an SHUTDOWN_COMPLETE.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tshut = sctp_make_shutdown_complete(asoc, chunk);\n\t\tif (!shut) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(shut))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tshut->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, shut);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\t/* If the chunk length is invalid, we don't want to process\n\t\t * the reset of the packet.\n\t\t */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* We need to discard the rest of the packet to prevent\n\t\t * potential bomming attacks from additional bundled chunks.\n\t\t * This is documented in SCTP Threats ID.\n\t\t */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle SHUTDOWN ACK in COOKIE_ECHOED or COOKIE_WAIT state.\n *\n * Verification Tag:  8.5.1 E) Rules for packet carrying a SHUTDOWN ACK\n *   If the receiver is in COOKIE-ECHOED or COOKIE-WAIT state the\n *   procedures in section 8.4 SHOULD be followed, in other words it\n *   should be treated as an Out Of The Blue packet.\n *   [This means that we do NOT check the Verification Tag on these\n *   chunks. --piggy ]\n *\n */\nsctp_disposition_t sctp_sf_do_8_5_1_E_sa(struct net *net,\n\t\t\t\t      const struct sctp_endpoint *ep,\n\t\t\t\t      const struct sctp_association *asoc,\n\t\t\t\t      const sctp_subtype_t type,\n\t\t\t\t      void *arg,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the SHUTDOWN_ACK chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\t/* Although we do have an association in this case, it corresponds\n\t * to a restarted association. So the packet is treated as an OOTB\n\t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n\t * called with a NULL association.\n\t */\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\n\treturn sctp_sf_shut_8_4_5(net, ep, NULL, type, arg, commands);\n}\n\n/* ADDIP Section 4.2 Upon reception of an ASCONF Chunk.  */\nsctp_disposition_t sctp_sf_do_asconf(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type, void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*chunk = arg;\n\tstruct sctp_chunk\t*asconf_ack = NULL;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*hdr;\n\t__u32\t\t\tserial;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP: Section 4.1.1\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !chunk->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ASCONF ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\thdr = (sctp_addiphdr_t *)chunk->skb->data;\n\tserial = ntohl(hdr->serial);\n\n\t/* Verify the ASCONF chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc, chunk, true, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  (void *)err_param, commands);\n\n\t/* ADDIP 5.2 E1) Compare the value of the serial number to the value\n\t * the endpoint stored in a new association variable\n\t * 'Peer-Serial-Number'.\n\t */\n\tif (serial == asoc->peer.addip_serial + 1) {\n\t\t/* If this is the first instance of ASCONF in the packet,\n\t\t * we can clean our old ASCONF-ACKs.\n\t\t */\n\t\tif (!chunk->has_asconf)\n\t\t\tsctp_assoc_clean_asconf_ack_cache(asoc);\n\n\t\t/* ADDIP 5.2 E4) When the Sequence Number matches the next one\n\t\t * expected, process the ASCONF as described below and after\n\t\t * processing the ASCONF Chunk, append an ASCONF-ACK Chunk to\n\t\t * the response packet and cache a copy of it (in the event it\n\t\t * later needs to be retransmitted).\n\t\t *\n\t\t * Essentially, do V1-V5.\n\t\t */\n\t\tasconf_ack = sctp_process_asconf((struct sctp_association *)\n\t\t\t\t\t\t asoc, chunk);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t} else if (serial < asoc->peer.addip_serial + 1) {\n\t\t/* ADDIP 5.2 E2)\n\t\t * If the value found in the Sequence Number is less than the\n\t\t * ('Peer- Sequence-Number' + 1), simply skip to the next\n\t\t * ASCONF, and include in the outbound response packet\n\t\t * any previously cached ASCONF-ACK response that was\n\t\t * sent and saved that matches the Sequence Number of the\n\t\t * ASCONF.  Note: It is possible that no cached ASCONF-ACK\n\t\t * Chunk exists.  This will occur when an older ASCONF\n\t\t * arrives out of order.  In such a case, the receiver\n\t\t * should skip the ASCONF Chunk and not include ASCONF-ACK\n\t\t * Chunk for that chunk.\n\t\t */\n\t\tasconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial);\n\t\tif (!asconf_ack)\n\t\t\treturn SCTP_DISPOSITION_DISCARD;\n\n\t\t/* Reset the transport so that we select the correct one\n\t\t * this time around.  This is to make sure that we don't\n\t\t * accidentally use a stale transport that's been removed.\n\t\t */\n\t\tasconf_ack->transport = NULL;\n\t} else {\n\t\t/* ADDIP 5.2 E5) Otherwise, the ASCONF Chunk is discarded since\n\t\t * it must be either a stale packet or from an attacker.\n\t\t */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\n\t/* ADDIP 5.2 E6)  The destination address of the SCTP packet\n\t * containing the ASCONF-ACK Chunks MUST be the source address of\n\t * the SCTP packet that held the ASCONF Chunks.\n\t *\n\t * To do this properly, we'll set the destination address of the chunk\n\t * and at the transmit time, will try look up the transport to use.\n\t * Since ASCONFs may be bundled, the correct transport may not be\n\t * created until we process the entire packet, thus this workaround.\n\t */\n\tasconf_ack->dest = chunk->source;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack));\n\tif (asoc->new_transport) {\n\t\tsctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands);\n\t\t((struct sctp_association *)asoc)->new_transport = NULL;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.3 General rules for address manipulation\n * When building TLV parameters for the ASCONF Chunk that will add or\n * delete IP addresses the D0 to D13 rules should be applied:\n */\nsctp_disposition_t sctp_sf_do_asconf_ack(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type, void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk\t*asconf_ack = arg;\n\tstruct sctp_chunk\t*last_asconf = asoc->addip_last_asconf;\n\tstruct sctp_chunk\t*abort;\n\tstruct sctp_paramhdr\t*err_param = NULL;\n\tsctp_addiphdr_t\t\t*addip_hdr;\n\t__u32\t\t\tsent_serial, rcvd_serial;\n\n\tif (!sctp_vtag_verify(asconf_ack, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* ADD-IP, Section 4.1.2:\n\t * This chunk MUST be sent in an authenticated way by using\n\t * the mechanism defined in [I-D.ietf-tsvwg-sctp-auth]. If this chunk\n\t * is received unauthenticated it MUST be silently discarded as\n\t * described in [I-D.ietf-tsvwg-sctp-auth].\n\t */\n\tif (!net->sctp.addip_noauth && !asconf_ack->auth)\n\t\treturn sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the ADDIP chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(asconf_ack, sizeof(sctp_addip_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\taddip_hdr = (sctp_addiphdr_t *)asconf_ack->skb->data;\n\trcvd_serial = ntohl(addip_hdr->serial);\n\n\t/* Verify the ASCONF-ACK chunk before processing it. */\n\tif (!sctp_verify_asconf(asoc, asconf_ack, false, &err_param))\n\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n\t\t\t   (void *)err_param, commands);\n\n\tif (last_asconf) {\n\t\taddip_hdr = (sctp_addiphdr_t *)last_asconf->subh.addip_hdr;\n\t\tsent_serial = ntohl(addip_hdr->serial);\n\t} else {\n\t\tsent_serial = asoc->addip_serial - 1;\n\t}\n\n\t/* D0) If an endpoint receives an ASCONF-ACK that is greater than or\n\t * equal to the next serial number to be used but no ASCONF chunk is\n\t * outstanding the endpoint MUST ABORT the association. Note that a\n\t * sequence number is greater than if it is no more than 2^^31-1\n\t * larger than the current sequence number (using serial arithmetic).\n\t */\n\tif (ADDIP_SERIAL_gte(rcvd_serial, sent_serial + 1) &&\n\t    !(asoc->addip_last_asconf)) {\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_ASCONF_ACK, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\tif ((rcvd_serial == sent_serial) && asoc->addip_last_asconf) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\t\tif (!sctp_process_asconf_ack((struct sctp_association *)asoc,\n\t\t\t\t\t     asconf_ack)) {\n\t\t\t/* Successfully processed ASCONF_ACK.  We can\n\t\t\t * release the next asconf if we have one.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_NEXT_ASCONF,\n\t\t\t\t\tSCTP_NULL());\n\t\t\treturn SCTP_DISPOSITION_CONSUME;\n\t\t}\n\n\t\tabort = sctp_make_abort(asoc, asconf_ack,\n\t\t\t\t\tsizeof(sctp_errhdr_t));\n\t\tif (abort) {\n\t\t\tsctp_init_cause(abort, SCTP_ERROR_RSRC_LOW, 0);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(abort));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_ASCONF_ACK));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * PR-SCTP Section 3.6 Receiver Side Implementation of PR-SCTP\n *\n * When a FORWARD TSN chunk arrives, the data receiver MUST first update\n * its cumulative TSN point to the value carried in the FORWARD TSN\n * chunk, and then MUST further advance its cumulative TSN point locally\n * if possible.\n * After the above processing, the data receiver MUST stop reporting any\n * missing TSNs earlier than or equal to the new cumulative TSN point.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_eat_fwd_tsn(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto discard_noforce;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto discard_noforce;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Count this as receiving DATA. */\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE]) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\t}\n\n\t/* FIXME: For now send a SACK, but DATA processing may\n\t * send another.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_NOFORCE());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\ndiscard_noforce:\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\nsctp_disposition_t sctp_sf_eat_fwd_tsn_fast(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_fwdtsn_hdr *fwdtsn_hdr;\n\tstruct sctp_fwdtsn_skip *skip;\n\t__u16 len;\n\t__u32 tsn;\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the FORWARD_TSN chunk has a valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_fwdtsn_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tfwdtsn_hdr = (struct sctp_fwdtsn_hdr *)chunk->skb->data;\n\tchunk->subh.fwdtsn_hdr = fwdtsn_hdr;\n\tlen = ntohs(chunk->chunk_hdr->length);\n\tlen -= sizeof(struct sctp_chunkhdr);\n\tskb_pull(chunk->skb, len);\n\n\ttsn = ntohl(fwdtsn_hdr->new_cum_tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* The TSN is too high--silently discard the chunk and count on it\n\t * getting retransmitted later.\n\t */\n\tif (sctp_tsnmap_check(&asoc->peer.tsn_map, tsn) < 0)\n\t\tgoto gen_shutdown;\n\n\t/* Silently discard the chunk if stream-id is not valid */\n\tsctp_walk_fwdtsn(skip, chunk) {\n\t\tif (ntohs(skip->stream) >= asoc->c.sinit_max_instreams)\n\t\t\tgoto gen_shutdown;\n\t}\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_FWDTSN, SCTP_U32(tsn));\n\tif (len > sizeof(struct sctp_fwdtsn_hdr))\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_FWDTSN,\n\t\t\t\tSCTP_CHUNK(chunk));\n\n\t/* Go a head and force a SACK, since we are shutting down. */\ngen_shutdown:\n\t/* Implementor's Guide.\n\t *\n\t * While in SHUTDOWN-SENT state, the SHUTDOWN sender MUST immediately\n\t * respond to each received packet containing one or more DATA chunk(s)\n\t * with a SACK, a SHUTDOWN chunk, and restart the T2-shutdown timer\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SHUTDOWN, SCTP_NULL());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * SCTP-AUTH Section 6.3 Receiving authenticated chukns\n *\n *    The receiver MUST use the HMAC algorithm indicated in the HMAC\n *    Identifier field.  If this algorithm was not specified by the\n *    receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk\n *    during association setup, the AUTH chunk and all chunks after it MUST\n *    be discarded and an ERROR chunk SHOULD be sent with the error cause\n *    defined in Section 4.1.\n *\n *    If an endpoint with no shared key receives a Shared Key Identifier\n *    other than 0, it MUST silently discard all authenticated chunks.  If\n *    the endpoint has at least one endpoint pair shared key for the peer,\n *    it MUST use the key specified by the Shared Key Identifier if a\n *    key has been configured for that Shared Key Identifier.  If no\n *    endpoint pair shared key has been configured for that Shared Key\n *    Identifier, all authenticated chunks MUST be silently discarded.\n *\n * Verification Tag:  8.5 Verification Tag [Normal verification]\n *\n * The return value is the disposition of the chunk.\n */\nstatic sctp_ierror_t sctp_sf_authenticate(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    struct sctp_chunk *chunk)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_hmac *hmac;\n\tunsigned int sig_len;\n\t__u16 key_id;\n\t__u8 *save_digest;\n\t__u8 *digest;\n\n\t/* Pull in the auth header, so we can do some more verification */\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\tchunk->subh.auth_hdr = auth_hdr;\n\tskb_pull(chunk->skb, sizeof(struct sctp_authhdr));\n\n\t/* Make sure that we support the HMAC algorithm from the auth\n\t * chunk.\n\t */\n\tif (!sctp_auth_asoc_verify_hmac_id(asoc, auth_hdr->hmac_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_HMAC;\n\n\t/* Make sure that the provided shared key identifier has been\n\t * configured\n\t */\n\tkey_id = ntohs(auth_hdr->shkey_id);\n\tif (key_id != asoc->active_key_id && !sctp_auth_get_shkey(asoc, key_id))\n\t\treturn SCTP_IERROR_AUTH_BAD_KEYID;\n\n\n\t/* Make sure that the length of the signature matches what\n\t * we expect.\n\t */\n\tsig_len = ntohs(chunk->chunk_hdr->length) - sizeof(sctp_auth_chunk_t);\n\thmac = sctp_auth_get_hmac(ntohs(auth_hdr->hmac_id));\n\tif (sig_len != hmac->hmac_len)\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\n\t/* Now that we've done validation checks, we can compute and\n\t * verify the hmac.  The steps involved are:\n\t *  1. Save the digest from the chunk.\n\t *  2. Zero out the digest in the chunk.\n\t *  3. Compute the new digest\n\t *  4. Compare saved and new digests.\n\t */\n\tdigest = auth_hdr->hmac;\n\tskb_pull(chunk->skb, sig_len);\n\n\tsave_digest = kmemdup(digest, sig_len, GFP_ATOMIC);\n\tif (!save_digest)\n\t\tgoto nomem;\n\n\tmemset(digest, 0, sig_len);\n\n\tsctp_auth_calculate_hmac(asoc, chunk->skb,\n\t\t\t\t(struct sctp_auth_chunk *)chunk->chunk_hdr,\n\t\t\t\tGFP_ATOMIC);\n\n\t/* Discard the packet if the digests do not match */\n\tif (memcmp(save_digest, digest, sig_len)) {\n\t\tkfree(save_digest);\n\t\treturn SCTP_IERROR_BAD_SIG;\n\t}\n\n\tkfree(save_digest);\n\tchunk->auth = 1;\n\n\treturn SCTP_IERROR_NO_ERROR;\nnomem:\n\treturn SCTP_IERROR_NOMEM;\n}\n\nsctp_disposition_t sctp_sf_eat_auth(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_authhdr *auth_hdr;\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_ierror_t error;\n\n\t/* Make sure that the peer has AUTH capable */\n\tif (!asoc->peer.auth_capable)\n\t\treturn sctp_sf_unk_chunk(net, ep, asoc, type, arg, commands);\n\n\tif (!sctp_vtag_verify(chunk, asoc)) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n\t\t\t\tSCTP_NULL());\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t}\n\n\t/* Make sure that the AUTH chunk has valid length.  */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_auth_chunk)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tauth_hdr = (struct sctp_authhdr *)chunk->skb->data;\n\terror = sctp_sf_authenticate(net, ep, asoc, type, chunk);\n\tswitch (error) {\n\tcase SCTP_IERROR_AUTH_BAD_HMAC:\n\t\t/* Generate the ERROR chunk and discard the rest\n\t\t * of the packet\n\t\t */\n\t\terr_chunk = sctp_make_op_error(asoc, chunk,\n\t\t\t\t\t       SCTP_ERROR_UNSUP_HMAC,\n\t\t\t\t\t       &auth_hdr->hmac_id,\n\t\t\t\t\t       sizeof(__u16), 0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Fall Through */\n\tcase SCTP_IERROR_AUTH_BAD_KEYID:\n\tcase SCTP_IERROR_BAD_SIG:\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\tcase SCTP_IERROR_PROTO_VIOLATION:\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tcase SCTP_IERROR_NOMEM:\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tdefault:\t\t\t/* Prevent gcc warnings */\n\t\tbreak;\n\t}\n\n\tif (asoc->active_key_id != ntohs(auth_hdr->shkey_id)) {\n\t\tstruct sctp_ulpevent *ev;\n\n\t\tev = sctp_ulpevent_make_authkey(asoc, ntohs(auth_hdr->shkey_id),\n\t\t\t\t    SCTP_AUTH_NEWKEY, GFP_ATOMIC);\n\n\t\tif (!ev)\n\t\t\treturn -ENOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\n\t\t\t\tSCTP_ULPEVENT(ev));\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process an unknown chunk.\n *\n * Section: 3.2. Also, 2.1 in the implementor's guide.\n *\n * Chunk Types are encoded such that the highest-order two bits specify\n * the action that must be taken if the processing endpoint does not\n * recognize the Chunk Type.\n *\n * 00 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it.\n *\n * 01 - Stop processing this SCTP packet and discard it, do not process\n *      any further chunks within it, and report the unrecognized\n *      chunk in an 'Unrecognized Chunk Type'.\n *\n * 10 - Skip this chunk and continue processing.\n *\n * 11 - Skip this chunk and continue processing, but report in an ERROR\n *      Chunk using the 'Unrecognized Chunk Type' cause of error.\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_unk_chunk(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *unk_chunk = arg;\n\tstruct sctp_chunk *err_chunk;\n\tsctp_chunkhdr_t *hdr;\n\n\tpr_debug(\"%s: processing unknown chunk id:%d\\n\", __func__, type.chunk);\n\n\tif (!sctp_vtag_verify(unk_chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(unk_chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tswitch (type.chunk & SCTP_CID_ACTION_MASK) {\n\tcase SCTP_CID_ACTION_DISCARD:\n\t\t/* Discard the packet.  */\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tcase SCTP_CID_ACTION_DISCARD_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\n\t\t/* Discard the packet.  */\n\t\tsctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tcase SCTP_CID_ACTION_SKIP:\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\tcase SCTP_CID_ACTION_SKIP_ERR:\n\t\t/* Generate an ERROR chunk as response. */\n\t\thdr = unk_chunk->chunk_hdr;\n\t\terr_chunk = sctp_make_op_error(asoc, unk_chunk,\n\t\t\t\t\t       SCTP_ERROR_UNKNOWN_CHUNK, hdr,\n\t\t\t\t\t       WORD_ROUND(ntohs(hdr->length)),\n\t\t\t\t\t       0);\n\t\tif (err_chunk) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err_chunk));\n\t\t}\n\t\t/* Skip the chunk.  */\n\t\treturn SCTP_DISPOSITION_CONSUME;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the chunk.\n *\n * Section: 0.2, 5.2.3, 5.2.5, 5.2.6, 6.0, 8.4.6, 8.5.1c, 9.2\n * [Too numerous to mention...]\n * Verification Tag: No verification needed.\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length.\n\t * Since we don't know the chunk type, we use a general\n\t * chunkhdr structure to make a comparison.\n\t */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\tpr_debug(\"%s: chunk:%d is discarded\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/*\n * Discard the whole packet.\n *\n * Section: 8.4 2)\n *\n * 2) If the OOTB packet contains an ABORT chunk, the receiver MUST\n *    silently discard the OOTB packet and take no further action.\n *\n * Verification Tag: No verification necessary\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_pdiscard(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_IN_PKT_DISCARDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n\n/*\n * The other end is violating protocol.\n *\n * Section: Not specified\n * Verification Tag: Not specified\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (asoc, reply_msg, msg_up, timers, counters)\n *\n * We simply tag the chunk as a violation.  The state machine will log\n * the violation and continue.\n */\nsctp_disposition_t sctp_sf_violation(struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\t/* Make sure that the chunk has a valid length. */\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\n\treturn SCTP_DISPOSITION_VIOLATION;\n}\n\n/*\n * Common function to handle a protocol violation.\n */\nstatic sctp_disposition_t sctp_sf_abort_violation(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands,\n\t\t\t\t     const __u8 *payload,\n\t\t\t\t     const size_t paylen)\n{\n\tstruct sctp_packet *packet = NULL;\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_chunk *abort = NULL;\n\n\t/* SCTP-AUTH, Section 6.3:\n\t *    It should be noted that if the receiver wants to tear\n\t *    down an association in an authenticated way only, the\n\t *    handling of malformed packets should not result in\n\t *    tearing down the association.\n\t *\n\t * This means that if we only want to abort associations\n\t * in an authenticated way (i.e AUTH+ABORT), then we\n\t * can't destroy this association just because the packet\n\t * was malformed.\n\t */\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_abort_violation(asoc, chunk, payload, paylen);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tif (asoc) {\n\t\t/* Treat INIT-ACK as a special case during COOKIE-WAIT. */\n\t\tif (chunk->chunk_hdr->type == SCTP_CID_INIT_ACK &&\n\t\t    !asoc->peer.i.init_tag) {\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t\t\t     sizeof(sctp_initack_chunk_t)))\n\t\t\t\tabort->chunk_hdr->flags |= SCTP_CHUNK_FLAG_T;\n\t\t\telse {\n\t\t\t\tunsigned int inittag;\n\n\t\t\t\tinittag = ntohl(initack->init_hdr.init_tag);\n\t\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_UPDATE_INITTAG,\n\t\t\t\t\t\tSCTP_U32(inittag));\n\t\t\t}\n\t\t}\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t}\n\t} else {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\t\tif (!packet)\n\t\t\tgoto nomem_pkt;\n\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\tSCTP_PACKET(packet));\n\n\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t}\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\n\nnomem_pkt:\n\tsctp_chunk_free(abort);\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Handle a protocol violation when the chunk length is invalid.\n * \"Invalid\" length is identified as smaller than the minimal length a\n * given chunk can be.  For example, a SACK chunk has invalid length\n * if its length is set to be smaller than the size of sctp_sack_chunk_t.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n *\n * Section: Not specified\n * Verification Tag:  Nothing to do\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * Outputs\n * (reply_msg, msg_up, counters)\n *\n * Generate an  ABORT chunk and terminate the association.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunklen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The following chunk had invalid length:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/*\n * Handle a protocol violation when the parameter length is invalid.\n * If the length is smaller than the minimum length of a given parameter,\n * or accumulated length in multi parameters exceeds the end of the chunk,\n * the length is considered as invalid.\n */\nstatic sctp_disposition_t sctp_sf_violation_paramlen(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg, void *ext,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk =  arg;\n\tstruct sctp_paramhdr *param = ext;\n\tstruct sctp_chunk *abort = NULL;\n\n\tif (sctp_auth_recv_cid(SCTP_CID_ABORT, asoc))\n\t\tgoto discard;\n\n\t/* Make the abort chunk. */\n\tabort = sctp_make_violation_paramlen(asoc, chunk, param);\n\tif (!abort)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\ndiscard:\n\tsctp_sf_pdiscard(net, ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n\treturn SCTP_DISPOSITION_ABORT;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle a protocol violation when the peer trying to advance the\n * cumulative tsn ack to a point beyond the max tsn currently sent.\n *\n * We inform the other end by sending an ABORT with a Protocol Violation\n * error code.\n */\nstatic sctp_disposition_t sctp_sf_violation_ctsn(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The cumulative tsn ack beyond the max tsn currently sent:\";\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n\n/* Handle protocol violation of an invalid chunk bundling.  For example,\n * when we have an association and we receive bundled INIT-ACK, or\n * SHUDOWN-COMPLETE, our peer is clearly violationg the \"MUST NOT bundle\"\n * statement from the specs.  Additionally, there might be an attacker\n * on the path and we may not want to continue this communication.\n */\nstatic sctp_disposition_t sctp_sf_violation_chunk(\n\t\t\t\t     struct net *net,\n\t\t\t\t     const struct sctp_endpoint *ep,\n\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t     const sctp_subtype_t type,\n\t\t\t\t     void *arg,\n\t\t\t\t     sctp_cmd_seq_t *commands)\n{\n\tstatic const char err_str[] = \"The following chunk violates protocol:\";\n\n\tif (!asoc)\n\t\treturn sctp_sf_violation(net, ep, asoc, type, arg, commands);\n\n\treturn sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,\n\t\t\t\t\tsizeof(err_str));\n}\n/***************************************************************************\n * These are the state functions for handling primitive (Section 10) events.\n ***************************************************************************/\n/*\n * sctp_sf_do_prm_asoc\n *\n * Section: 10.1 ULP-to-SCTP\n * B) Associate\n *\n * Format: ASSOCIATE(local SCTP instance name, destination transport addr,\n * outbound stream count)\n * -> association id [,destination transport addr list] [,outbound stream\n * count]\n *\n * This primitive allows the upper layer to initiate an association to a\n * specific peer endpoint.\n *\n * The peer endpoint shall be specified by one of the transport addresses\n * which defines the endpoint (see Section 1.4).  If the local SCTP\n * instance has not been initialized, the ASSOCIATE is considered an\n * error.\n * [This is not relevant for the kernel implementation since we do all\n * initialization at boot time.  It we hadn't initialized we wouldn't\n * get anywhere near this code.]\n *\n * An association id, which is a local handle to the SCTP association,\n * will be returned on successful establishment of the association. If\n * SCTP is not able to open an SCTP association with the peer endpoint,\n * an error is returned.\n * [In the kernel implementation, the struct sctp_association needs to\n * be created BEFORE causing this primitive to run.]\n *\n * Other association parameters may be returned, including the\n * complete destination transport addresses of the peer as well as the\n * outbound stream count of the local endpoint. One of the transport\n * address from the returned destination addresses will be selected by\n * the local endpoint as default primary path for sending SCTP packets\n * to this peer.  The returned \"destination transport addr list\" can\n * be used by the ULP to change the default primary path or to force\n * sending a packet to a specific transport address.  [All of this\n * stuff happens when the INIT ACK arrives.  This is a NON-BLOCKING\n * function.]\n *\n * Mandatory attributes:\n *\n * o local SCTP instance name - obtained from the INITIALIZE operation.\n *   [This is the argument asoc.]\n * o destination transport addr - specified as one of the transport\n * addresses of the peer endpoint with which the association is to be\n * established.\n *  [This is asoc->peer.active_path.]\n * o outbound stream count - the number of outbound streams the ULP\n * would like to open towards this peer endpoint.\n * [BUG: This is not currently implemented.]\n * Optional attributes:\n *\n * None.\n *\n * The return value is a disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_asoc(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl;\n\tstruct sctp_association *my_asoc;\n\n\t/* The comment below says that we enter COOKIE-WAIT AFTER\n\t * sending the INIT, but that doesn't actually work in our\n\t * implementation...\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_COOKIE_WAIT));\n\n\t/* RFC 2960 5.1 Normal Establishment of an Association\n\t *\n\t * A) \"A\" first sends an INIT chunk to \"Z\".  In the INIT, \"A\"\n\t * must provide its Verification Tag (Tag_A) in the Initiate\n\t * Tag field.  Tag_A SHOULD be a random number in the range of\n\t * 1 to 4294967295 (see 5.3.1 for Tag value selection). ...\n\t */\n\n\trepl = sctp_make_init(asoc, &asoc->base.bind_addr, GFP_ATOMIC, 0);\n\tif (!repl)\n\t\tgoto nomem;\n\n\t/* Choose transport for INIT. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\tSCTP_CHUNK(repl));\n\n\t/* Cast away the const modifier, as we want to just\n\t * rerun it through as a sideffect.\n\t */\n\tmy_asoc = (struct sctp_association *)asoc;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_ASOC, SCTP_ASOC(my_asoc));\n\n\t/* After sending the INIT, \"A\" starts the T1-init timer and\n\t * enters the COOKIE-WAIT state.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Process the SEND primitive.\n *\n * Section: 10.1 ULP-to-SCTP\n * E) Send\n *\n * Format: SEND(association id, buffer address, byte count [,context]\n *         [,stream id] [,life time] [,destination transport address]\n *         [,unorder flag] [,no-bundle flag] [,payload protocol-id] )\n * -> result\n *\n * This is the main method to send user data via SCTP.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n *  o buffer address - the location where the user message to be\n *    transmitted is stored;\n *\n *  o byte count - The size of the user data in number of bytes;\n *\n * Optional attributes:\n *\n *  o context - an optional 32 bit integer that will be carried in the\n *    sending failure notification to the ULP if the transportation of\n *    this User Message fails.\n *\n *  o stream id - to indicate which stream to send the data on. If not\n *    specified, stream 0 will be used.\n *\n *  o life time - specifies the life time of the user data. The user data\n *    will not be sent by SCTP after the life time expires. This\n *    parameter can be used to avoid efforts to transmit stale\n *    user messages. SCTP notifies the ULP if the data cannot be\n *    initiated to transport (i.e. sent to the destination via SCTP's\n *    send primitive) within the life time variable. However, the\n *    user data will be transmitted if SCTP has attempted to transmit a\n *    chunk before the life time expired.\n *\n *  o destination transport address - specified as one of the destination\n *    transport addresses of the peer endpoint to which this packet\n *    should be sent. Whenever possible, SCTP should use this destination\n *    transport address for sending the packets, instead of the current\n *    primary path.\n *\n *  o unorder flag - this flag, if present, indicates that the user\n *    would like the data delivered in an unordered fashion to the peer\n *    (i.e., the U flag is set to 1 on all DATA chunks carrying this\n *    message).\n *\n *  o no-bundle flag - instructs SCTP not to bundle this user data with\n *    other outbound DATA chunks. SCTP MAY still bundle even when\n *    this flag is present, when faced with network congestion.\n *\n *  o payload protocol-id - A 32 bit unsigned integer that is to be\n *    passed to the peer indicating the type of payload protocol data\n *    being transmitted. This value is passed as opaque data by SCTP.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_prm_send(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_datamsg *msg = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_MSG, SCTP_DATAMSG(msg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Process the SHUTDOWN primitive.\n *\n * Section: 10.1:\n * C) Shutdown\n *\n * Format: SHUTDOWN(association id)\n * -> result\n *\n * Gracefully closes an association. Any locally queued user data\n * will be delivered to the peer. The association will be terminated only\n * after the peer acknowledges all the SCTP packets sent.  A success code\n * will be returned on successful termination of the association. If\n * attempting to terminate the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*\n * Process the ABORT primitive.\n *\n * Section: 10.1:\n * C) Abort\n *\n * Format: Abort(association id [, cause code])\n * -> result\n *\n * Ungracefully closes an association. Any locally queued user data\n * will be discarded and an ABORT chunk is sent to the peer.  A success code\n * will be returned on successful abortion of the association. If\n * attempting to abort the association results in a failure, an error\n * code shall be returned.\n *\n * Mandatory attributes:\n *\n *  o association id - local handle to the SCTP association\n *\n * Optional attributes:\n *\n *  o cause code - reason of the abort to be passed to the peer\n *\n * None.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_1_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* From 9.1 Abort of an Association\n\t * Upon receipt of the ABORT primitive from its upper\n\t * layer, the endpoint enters CLOSED state and\n\t * discard all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNABORTED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn retval;\n}\n\n/* We tried an illegal operation on an association which is closed.  */\nsctp_disposition_t sctp_sf_error_closed(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR, SCTP_ERROR(-EINVAL));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* We tried an illegal operation on an association which is shutting\n * down.\n */\nsctp_disposition_t sctp_sf_error_shutdown(struct net *net,\n\t\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t\t  const sctp_subtype_t type,\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  sctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_ERROR,\n\t\t\tSCTP_ERROR(-ESHUTDOWN));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_cookie_wait_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_SHUTDOWNS);\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\n}\n\n/*\n * sctp_cookie_echoed_prm_shutdown\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues a shutdown while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg, sctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_shutdown(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_wait_prm_abort\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_WAIT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_wait_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *abort = arg;\n\tsctp_disposition_t retval;\n\n\t/* Stop T1-init timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\tretval = SCTP_DISPOSITION_CONSUME;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_CLOSED));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\n\t/* Even if we can't send the ABORT due to low memory delete the\n\t * TCB.  This is a departure from our typical NOMEM handling.\n\t */\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ECONNREFUSED));\n\t/* Delete the established association. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_USER_ABORT));\n\n\treturn retval;\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Section: 4 Note: 3\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_cookie_echoed_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* There is a single T1 timer, so we should be able to use\n\t * common function with the COOKIE-WAIT state.\n\t */\n\treturn sctp_sf_cookie_wait_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_pending_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-PENDING state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_pending_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_shutdown_sent_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explicitly address this issue, but is the route through the\n * state table when someone issues an abort while in SHUTDOWN-SENT state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* Stop the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* Stop the T5-shutdown guard timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\treturn sctp_sf_do_9_1_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * sctp_sf_cookie_echoed_prm_abort\n *\n * Inputs\n * (endpoint, asoc)\n *\n * The RFC does not explcitly address this issue, but is the route through the\n * state table when someone issues an abort while in COOKIE_ECHOED state.\n *\n * Outputs\n * (timers)\n */\nsctp_disposition_t sctp_sf_shutdown_ack_sent_prm_abort(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\t/* The same T2 timer, so we should be able to use\n\t * common function with the SHUTDOWN-SENT state.\n\t */\n\treturn sctp_sf_shutdown_sent_prm_abort(net, ep, asoc, type, arg, commands);\n}\n\n/*\n * Process the REQUESTHEARTBEAT primitive\n *\n * 10.1 ULP-to-SCTP\n * J) Request Heartbeat\n *\n * Format: REQUESTHEARTBEAT(association id, destination transport address)\n *\n * -> result\n *\n * Instructs the local endpoint to perform a HeartBeat on the specified\n * destination transport address of the given association. The returned\n * result should indicate whether the transmission of the HEARTBEAT\n * chunk to the destination address is successful.\n *\n * Mandatory attributes:\n *\n * o association id - local handle to the SCTP association\n *\n * o destination transport address - the transport address of the\n *   association on which a heartbeat should be issued.\n */\nsctp_disposition_t sctp_sf_do_prm_requestheartbeat(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tif (SCTP_DISPOSITION_NOMEM == sctp_sf_heartbeat(ep, asoc, type,\n\t\t\t\t      (struct sctp_transport *)arg, commands))\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t/*\n\t * RFC 2960 (bis), section 8.3\n\t *\n\t *    D) Request an on-demand HEARTBEAT on a specific destination\n\t *    transport address of a given association.\n\t *\n\t *    The endpoint should increment the respective error  counter of\n\t *    the destination transport address each time a HEARTBEAT is sent\n\t *    to that address and not acknowledged within one RTO.\n\t *\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TRANSPORT_HB_SENT,\n\t\t\tSCTP_TRANSPORT(arg));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF Chunk Procedures\n * When an endpoint has an ASCONF signaled change to be sent to the\n * remote endpoint it should do A1 to A9\n */\nsctp_disposition_t sctp_sf_do_prm_asconf(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(chunk));\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Ignore the primitive event\n *\n * The return value is the disposition of the primitive.\n */\nsctp_disposition_t sctp_sf_ignore_primitive(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tpr_debug(\"%s: primitive type:%d is ignored\\n\", __func__,\n\t\t type.primitive);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/***************************************************************************\n * These are the state functions for the OTHER events.\n ***************************************************************************/\n\n/*\n * When the SCTP stack has no more user data to send or retransmit, this\n * notification is given to the user. Also, at the time when a user app\n * subscribes to this event, if there is no data to be sent or\n * retransmit, the stack will immediately send up this notification.\n */\nsctp_disposition_t sctp_sf_do_no_pending_tsn(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_ulpevent *event;\n\n\tevent = sctp_ulpevent_make_sender_dry_event(asoc, GFP_ATOMIC);\n\tif (!event)\n\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP, SCTP_ULPEVENT(event));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Start the shutdown negotiation.\n *\n * From Section 9.2:\n * Once all its outstanding data has been acknowledged, the endpoint\n * shall send a SHUTDOWN chunk to its peer including in the Cumulative\n * TSN Ack field the last sequential TSN it has received from the peer.\n * It shall then start the T2-shutdown timer and enter the SHUTDOWN-SENT\n * state. If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_start_shutdown(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply;\n\n\t/* Once all its outstanding data has been acknowledged, the\n\t * endpoint shall send a SHUTDOWN chunk to its peer including\n\t * in the Cumulative TSN Ack field the last sequential TSN it\n\t * has received from the peer.\n\t */\n\treply = sctp_make_shutdown(asoc, NULL);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN chunk and the timeout for the\n\t * T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* It shall then start the T2-shutdown timer */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\t/* RFC 4960 Section 9.2\n\t * The sender of the SHUTDOWN MAY also start an overall guard timer\n\t * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* and enter the SHUTDOWN-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Generate a SHUTDOWN ACK now that everything is SACK'd.\n *\n * From Section 9.2:\n *\n * If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n * shall send a SHUTDOWN ACK and start a T2-shutdown timer of its own,\n * entering the SHUTDOWN-ACK-SENT state. If the timer expires, the\n * endpoint must re-send the SHUTDOWN ACK.\n *\n * The return value is the disposition.\n */\nsctp_disposition_t sctp_sf_do_9_2_shutdown_ack(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n\tstruct sctp_chunk *reply;\n\n\t/* There are 2 ways of getting here:\n\t *    1) called in response to a SHUTDOWN chunk\n\t *    2) called when SCTP_EVENT_NO_PENDING_TSN event is issued.\n\t *\n\t * For the case (2), the arg parameter is set to NULL.  We need\n\t * to check that we have a chunk before accessing it's fields.\n\t */\n\tif (chunk) {\n\t\tif (!sctp_vtag_verify(chunk, asoc))\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\n\t\t/* Make sure that the SHUTDOWN chunk has a valid length. */\n\t\tif (!sctp_chunk_length_valid(chunk, sizeof(struct sctp_shutdown_chunk_t)))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t\t  commands);\n\t}\n\n\t/* If it has no more outstanding DATA chunks, the SHUTDOWN receiver\n\t * shall send a SHUTDOWN ACK ...\n\t */\n\treply = sctp_make_shutdown_ack(asoc, chunk);\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Set the transport for the SHUTDOWN ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* and start/restart a T2-shutdown timer of its own, */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\n\tif (asoc->timeouts[SCTP_EVENT_TIMEOUT_AUTOCLOSE])\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_AUTOCLOSE));\n\n\t/* Enter the SHUTDOWN-ACK-SENT state.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_ACK_SENT));\n\n\t/* sctp-implguide 2.10 Issues with Heartbeating and failover\n\t *\n\t * HEARTBEAT ... is discontinued after sending either SHUTDOWN\n\t * or SHUTDOWN-ACK.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_HB_TIMERS_STOP, SCTP_NULL());\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * Ignore the event defined as other\n *\n * The return value is the disposition of the event.\n */\nsctp_disposition_t sctp_sf_ignore_other(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tpr_debug(\"%s: the event other type:%d is ignored\\n\",\n\t\t __func__, type.other);\n\n\treturn SCTP_DISPOSITION_DISCARD;\n}\n\n/************************************************************\n * These are the state functions for handling timeout events.\n ************************************************************/\n\n/*\n * RTX Timeout\n *\n * Section: 6.3.3 Handle T3-rtx Expiration\n *\n * Whenever the retransmission timer T3-rtx expires for a destination\n * address, do the following:\n * [See below]\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_do_6_3_3_rtx(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_transport *transport = arg;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T3_RTX_EXPIREDS);\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tif (asoc->state == SCTP_STATE_SHUTDOWN_PENDING) {\n\t\t\t/*\n\t\t\t * We are here likely because the receiver had its rwnd\n\t\t\t * closed for a while and we have not been able to\n\t\t\t * transmit the locally queued data within the maximum\n\t\t\t * retransmission attempts limit.  Start the T5\n\t\t\t * shutdown guard timer to give the receiver one last\n\t\t\t * chance and some additional time to recover before\n\t\t\t * aborting.\n\t\t\t */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_START_ONCE,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD));\n\t\t} else {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t\t/* CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t\t}\n\t}\n\n\t/* E1) For the destination address for which the timer\n\t * expires, adjust its ssthresh with rules defined in Section\n\t * 7.2.3 and set the cwnd <- MTU.\n\t */\n\n\t/* E2) For the destination address for which the timer\n\t * expires, set RTO <- RTO * 2 (\"back off the timer\").  The\n\t * maximum value discussed in rule C7 above (RTO.max) may be\n\t * used to provide an upper bound to this doubling operation.\n\t */\n\n\t/* E3) Determine how many of the earliest (i.e., lowest TSN)\n\t * outstanding DATA chunks for the address for which the\n\t * T3-rtx has expired will fit into a single packet, subject\n\t * to the MTU constraint for the path corresponding to the\n\t * destination transport address to which the retransmission\n\t * is being sent (this may be different from the address for\n\t * which the timer expires [see Section 6.4]).  Call this\n\t * value K. Bundle and retransmit those K DATA chunks in a\n\t * single packet to the destination endpoint.\n\t *\n\t * Note: Any DATA chunks that were sent to the address for\n\t * which the T3-rtx timer expired but did not fit in one MTU\n\t * (rule E3 above), should be marked for retransmission and\n\t * sent as soon as cwnd allows (normally when a SACK arrives).\n\t */\n\n\t/* Do some failure management (Section 8.2). */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE, SCTP_TRANSPORT(transport));\n\n\t/* NB: Rules E4 and F1 are implicit in R1.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_RETRAN, SCTP_TRANSPORT(transport));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * Generate delayed SACK on timeout\n *\n * Section: 6.2  Acknowledgement on Reception of DATA Chunks\n *\n * The guidelines on delayed acknowledgement algorithm specified in\n * Section 4.2 of [RFC2581] SHOULD be followed.  Specifically, an\n * acknowledgement SHOULD be generated for at least every second packet\n * (not every second DATA chunk) received, and SHOULD be generated\n * within 200 ms of the arrival of any unacknowledged DATA chunk.  In\n * some situations it may be beneficial for an SCTP transmitter to be\n * more conservative than the algorithms detailed in this document\n * allow. However, an SCTP transmitter MUST NOT be more aggressive than\n * the following algorithms allow.\n */\nsctp_disposition_t sctp_sf_do_6_2_sack(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const sctp_subtype_t type,\n\t\t\t\t       void *arg,\n\t\t\t\t       sctp_cmd_seq_t *commands)\n{\n\tSCTP_INC_STATS(net, SCTP_MIB_DELAY_SACK_EXPIREDS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_GEN_SACK, SCTP_FORCE());\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_init_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  2) If the T1-init timer expires, the endpoint MUST retransmit INIT\n *     and re-start the T1-init timer without changing state.  This MUST\n *     be repeated up to 'Max.Init.Retransmits' times.  After that, the\n *     endpoint MUST abort the initialization process and report the\n *     error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_init_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tpr_debug(\"%s: timer T1 expired (INIT)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\t/* Choose transport for INIT. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tpr_debug(\"%s: giving up on INIT, attempts:%d \"\n\t\t\t \"max_init_attempts:%d\\n\", __func__, attempts,\n\t\t\t asoc->max_init_attempts);\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/*\n * sctp_sf_t1_cookie_timer_expire\n *\n * Section: 4 Note: 2\n * Verification Tag:\n * Inputs\n * (endpoint, asoc)\n *\n *  RFC 2960 Section 4 Notes\n *  3) If the T1-cookie timer expires, the endpoint MUST retransmit\n *     COOKIE ECHO and re-start the T1-cookie timer without changing\n *     state.  This MUST be repeated up to 'Max.Init.Retransmits' times.\n *     After that, the endpoint MUST abort the initialization process and\n *     report the error to SCTP user.\n *\n * Outputs\n * (timers, events)\n *\n */\nsctp_disposition_t sctp_sf_t1_cookie_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tint attempts = asoc->init_err_counter + 1;\n\n\tpr_debug(\"%s: timer T1 expired (COOKIE-ECHO)\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_COOKIE_EXPIREDS);\n\n\tif (attempts <= asoc->max_init_attempts) {\n\t\trepl = sctp_make_cookie_echo(asoc, NULL);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\t/* Issue a sideeffect to do the needed accounting. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_COOKIEECHO_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\n\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* RFC2960 9.2 If the timer expires, the endpoint must re-send the SHUTDOWN\n * with the updated last sequential TSN received from its peer.\n *\n * An endpoint should limit the number of retransmissions of the\n * SHUTDOWN chunk to the protocol parameter 'Association.Max.Retrans'.\n * If this threshold is exceeded the endpoint should destroy the TCB and\n * MUST report the peer endpoint unreachable to the upper layer (and\n * thus the association enters the CLOSED state).  The reception of any\n * packet from its peer (i.e. as the peer sends all of its queued DATA\n * chunks) should clear the endpoint's retransmission count and restart\n * the T2-Shutdown timer,  giving its peer ample opportunity to transmit\n * all of its queued DATA chunks that have not yet been sent.\n */\nsctp_disposition_t sctp_sf_t2_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T2 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T2_SHUTDOWN_EXPIREDS);\n\n\t((struct sctp_association *)asoc)->shutdown_retries++;\n\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\t/* Note:  CMD_ASSOC_FAILED calls CMD_DELETE_TCB. */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\treply = sctp_make_shutdown(asoc, NULL);\n\t\tbreak;\n\n\tcase SCTP_STATE_SHUTDOWN_ACK_SENT:\n\t\treply = sctp_make_shutdown_ack(asoc, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tif (!reply)\n\t\tgoto nomem;\n\n\t/* Do some failure management (Section 8.2).\n\t * If we remove the transport an SHUTDOWN was last sent to, don't\n\t * do failure management.\n\t */\n\tif (asoc->shutdown_last_sent_to)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(asoc->shutdown_last_sent_to));\n\n\t/* Set the transport for the SHUTDOWN/ACK chunk and the timeout for\n\t * the T2-shutdown timer.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T2, SCTP_CHUNK(reply));\n\n\t/* Restart the T2-shutdown timer.  */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T2_SHUTDOWN));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\treturn SCTP_DISPOSITION_CONSUME;\n\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/*\n * ADDIP Section 4.1 ASCONF CHunk Procedures\n * If the T4 RTO timer expires the endpoint should do B1 to B5\n */\nsctp_disposition_t sctp_sf_t4_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = asoc->addip_last_asconf;\n\tstruct sctp_transport *transport = chunk->transport;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T4_RTO_EXPIREDS);\n\n\t/* ADDIP 4.1 B1) Increment the error counters and perform path failure\n\t * detection on the appropriate destination address as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t */\n\tif (transport)\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_STRIKE,\n\t\t\t\tSCTP_TRANSPORT(transport));\n\n\t/* Reconfig T4 timer and transport. */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SETUP_T4, SCTP_CHUNK(chunk));\n\n\t/* ADDIP 4.1 B2) Increment the association error counters and perform\n\t * endpoint failure detection on the association as defined in\n\t * RFC2960 [5] section 8.1 and 8.2.\n\t * association error counter is incremented in SCTP_CMD_STRIKE.\n\t */\n\tif (asoc->overall_error_count >= asoc->max_retrans) {\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_DISPOSITION_ABORT;\n\t}\n\n\t/* ADDIP 4.1 B3) Back-off the destination address RTO value to which\n\t * the ASCONF chunk was sent by doubling the RTO timer value.\n\t * This is done in SCTP_CMD_STRIKE.\n\t */\n\n\t/* ADDIP 4.1 B4) Re-transmit the ASCONF Chunk last sent and if possible\n\t * choose an alternate destination address (please refer to RFC2960\n\t * [5] section 6.4.1). An endpoint MUST NOT add new parameters to this\n\t * chunk, it MUST be the same (including its serial number) as the last\n\t * ASCONF sent.\n\t */\n\tsctp_chunk_hold(asoc->addip_last_asconf);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\tSCTP_CHUNK(asoc->addip_last_asconf));\n\n\t/* ADDIP 4.1 B5) Restart the T-4 RTO timer. Note that if a different\n\t * destination is selected, then the RTO used will be that of the new\n\t * destination address.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\n\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/* sctpimpguide-05 Section 2.12.2\n * The sender of the SHUTDOWN MAY also start an overall guard timer\n * 'T5-shutdown-guard' to bound the overall time for shutdown sequence.\n * At the expiration of this timer the sender SHOULD abort the association\n * by sending an ABORT chunk.\n */\nsctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *reply = NULL;\n\n\tpr_debug(\"%s: timer T5 expired\\n\", __func__);\n\n\tSCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);\n\n\treply = sctp_make_abort(asoc, NULL, 0);\n\tif (!reply)\n\t\tgoto nomem;\n\n\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\tSCTP_ERROR(ETIMEDOUT));\n\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\n\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\n\treturn SCTP_DISPOSITION_DELETE_TCB;\nnomem:\n\treturn SCTP_DISPOSITION_NOMEM;\n}\n\n/* Handle expiration of AUTOCLOSE timer.  When the autoclose timer expires,\n * the association is automatically closed by starting the shutdown process.\n * The work that needs to be done is same as when SHUTDOWN is initiated by\n * the user.  So this routine looks same as sctp_sf_do_9_2_prm_shutdown().\n */\nsctp_disposition_t sctp_sf_autoclose_timer_expire(\n\tstruct net *net,\n\tconst struct sctp_endpoint *ep,\n\tconst struct sctp_association *asoc,\n\tconst sctp_subtype_t type,\n\tvoid *arg,\n\tsctp_cmd_seq_t *commands)\n{\n\tint disposition;\n\n\tSCTP_INC_STATS(net, SCTP_MIB_AUTOCLOSE_EXPIREDS);\n\n\t/* From 9.2 Shutdown of an Association\n\t * Upon receipt of the SHUTDOWN primitive from its upper\n\t * layer, the endpoint enters SHUTDOWN-PENDING state and\n\t * remains there until all outstanding data has been\n\t * acknowledged by its peer. The endpoint accepts no new data\n\t * from its upper layer, but retransmits data to the far end\n\t * if necessary to fill gaps.\n\t */\n\tsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\n\t\t\tSCTP_STATE(SCTP_STATE_SHUTDOWN_PENDING));\n\n\tdisposition = SCTP_DISPOSITION_CONSUME;\n\tif (sctp_outq_is_empty(&asoc->outqueue)) {\n\t\tdisposition = sctp_sf_do_9_2_start_shutdown(net, ep, asoc, type,\n\t\t\t\t\t\t\t    arg, commands);\n\t}\n\treturn disposition;\n}\n\n/*****************************************************************************\n * These are sa state functions which could apply to all types of events.\n ****************************************************************************/\n\n/*\n * This table entry is not implemented.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_not_impl(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_NOT_IMPL;\n}\n\n/*\n * This table entry represents a bug.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_bug(struct net *net,\n\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t       const struct sctp_association *asoc,\n\t\t\t       const sctp_subtype_t type,\n\t\t\t       void *arg,\n\t\t\t       sctp_cmd_seq_t *commands)\n{\n\treturn SCTP_DISPOSITION_BUG;\n}\n\n/*\n * This table entry represents the firing of a timer in the wrong state.\n * Since timer deletion cannot be guaranteed a timer 'may' end up firing\n * when the association is in the wrong state.   This event should\n * be ignored, so as to prevent any rearming of the timer.\n *\n * Inputs\n * (endpoint, asoc, chunk)\n *\n * The return value is the disposition of the chunk.\n */\nsctp_disposition_t sctp_sf_timer_ignore(struct net *net,\n\t\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\t\tvoid *arg,\n\t\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tpr_debug(\"%s: timer %d ignored\\n\", __func__, type.chunk);\n\n\treturn SCTP_DISPOSITION_CONSUME;\n}\n\n/********************************************************************\n * 2nd Level Abstractions\n ********************************************************************/\n\n/* Pull the SACK chunk based on the SACK header. */\nstatic struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk)\n{\n\tstruct sctp_sackhdr *sack;\n\tunsigned int len;\n\t__u16 num_blocks;\n\t__u16 num_dup_tsns;\n\n\t/* Protect ourselves from reading too far into\n\t * the skb from a bogus sender.\n\t */\n\tsack = (struct sctp_sackhdr *) chunk->skb->data;\n\n\tnum_blocks = ntohs(sack->num_gap_ack_blocks);\n\tnum_dup_tsns = ntohs(sack->num_dup_tsns);\n\tlen = sizeof(struct sctp_sackhdr);\n\tlen += (num_blocks + num_dup_tsns) * sizeof(__u32);\n\tif (len > chunk->skb->len)\n\t\treturn NULL;\n\n\tskb_pull(chunk->skb, len);\n\n\treturn sack;\n}\n\n/* Create an ABORT packet to be sent as a response, with the specified\n * error causes.\n */\nstatic struct sctp_packet *sctp_abort_pkt_new(struct net *net,\n\t\t\t\t  const struct sctp_endpoint *ep,\n\t\t\t\t  const struct sctp_association *asoc,\n\t\t\t\t  struct sctp_chunk *chunk,\n\t\t\t\t  const void *payload,\n\t\t\t\t  size_t paylen)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_chunk *abort;\n\n\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\n\tif (packet) {\n\t\t/* Make an ABORT.\n\t\t * The T bit will be set if the asoc is NULL.\n\t\t */\n\t\tabort = sctp_make_abort(asoc, chunk, paylen);\n\t\tif (!abort) {\n\t\t\tsctp_ootb_pkt_free(packet);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* Reflect vtag if T-Bit is set */\n\t\tif (sctp_test_T_bit(abort))\n\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n\n\t\t/* Add specified error causes, i.e., payload, to the\n\t\t * end of the chunk.\n\t\t */\n\t\tsctp_addto_chunk(abort, paylen, payload);\n\n\t\t/* Set the skb to the belonging sock for accounting.  */\n\t\tabort->skb->sk = ep->base.sk;\n\n\t\tsctp_packet_append_chunk(packet, abort);\n\n\t}\n\n\treturn packet;\n}\n\n/* Allocate a packet for responding in the OOTB conditions.  */\nstatic struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_transport *transport;\n\t__u16 sport;\n\t__u16 dport;\n\t__u32 vtag;\n\n\t/* Get the source and destination port from the inbound packet.  */\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t/* The V-tag is going to be the same as the inbound packet if no\n\t * association exists, otherwise, use the peer's vtag.\n\t */\n\tif (asoc) {\n\t\t/* Special case the INIT-ACK as there is no peer's vtag\n\t\t * yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Special case the INIT and stale COOKIE_ECHO as there is no\n\t\t * vtag yet.\n\t\t */\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tsctp_init_chunk_t *init;\n\n\t\t\tinit = (sctp_init_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Make a transport for the bucket, Eliza... */\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\t/* Cache a route for the transport with the chunk's destination as\n\t * the source address.\n\t */\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = sctp_packet_init(&transport->packet, transport, sport, dport);\n\tpacket = sctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}\n\n/* Free the packet allocated earlier for responding in the OOTB condition.  */\nvoid sctp_ootb_pkt_free(struct sctp_packet *packet)\n{\n\tsctp_transport_free(packet->transport);\n}\n\n/* Send a stale cookie error when a invalid COOKIE ECHO chunk is found  */\nstatic void sctp_send_stale_cookie_err(struct net *net,\n\t\t\t\t       const struct sctp_endpoint *ep,\n\t\t\t\t       const struct sctp_association *asoc,\n\t\t\t\t       const struct sctp_chunk *chunk,\n\t\t\t\t       sctp_cmd_seq_t *commands,\n\t\t\t\t       struct sctp_chunk *err_chunk)\n{\n\tstruct sctp_packet *packet;\n\n\tif (err_chunk) {\n\t\tpacket = sctp_ootb_pkt_new(net, asoc, chunk);\n\t\tif (packet) {\n\t\t\tstruct sctp_signed_cookie *cookie;\n\n\t\t\t/* Override the OOTB vtag from the cookie. */\n\t\t\tcookie = chunk->subh.cookie_hdr;\n\t\t\tpacket->vtag = cookie->c.peer_vtag;\n\n\t\t\t/* Set the skb to the belonging sock for accounting. */\n\t\t\terr_chunk->skb->sk = ep->base.sk;\n\t\t\tsctp_packet_append_chunk(packet, err_chunk);\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n\t\t\t\t\tSCTP_PACKET(packet));\n\t\t\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\t\t} else\n\t\t\tsctp_chunk_free (err_chunk);\n\t}\n}\n\n\n/* Process a data chunk */\nstatic int sctp_eat_data(const struct sctp_association *asoc,\n\t\t\t struct sctp_chunk *chunk,\n\t\t\t sctp_cmd_seq_t *commands)\n{\n\tsctp_datahdr_t *data_hdr;\n\tstruct sctp_chunk *err;\n\tsize_t datalen;\n\tsctp_verb_t deliver;\n\tint tmp;\n\t__u32 tsn;\n\tstruct sctp_tsnmap *map = (struct sctp_tsnmap *)&asoc->peer.tsn_map;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tu16 ssn;\n\tu16 sid;\n\tu8 ordered = 0;\n\n\tdata_hdr = chunk->subh.data_hdr = (sctp_datahdr_t *)chunk->skb->data;\n\tskb_pull(chunk->skb, sizeof(sctp_datahdr_t));\n\n\ttsn = ntohl(data_hdr->tsn);\n\tpr_debug(\"%s: TSN 0x%x\\n\", __func__, tsn);\n\n\t/* ASSERT:  Now skb->data is really the user data.  */\n\n\t/* Process ECN based congestion.\n\t *\n\t * Since the chunk structure is reused for all chunks within\n\t * a packet, we use ecn_ce_done to track if we've already\n\t * done CE processing for this packet.\n\t *\n\t * We need to do ECN processing even if we plan to discard the\n\t * chunk later.\n\t */\n\n\tif (!chunk->ecn_ce_done) {\n\t\tstruct sctp_af *af;\n\t\tchunk->ecn_ce_done = 1;\n\n\t\taf = sctp_get_af_specific(\n\t\t\tipver2af(ip_hdr(chunk->skb)->version));\n\n\t\tif (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {\n\t\t\t/* Do real work as sideffect. */\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ECN_CE,\n\t\t\t\t\tSCTP_U32(tsn));\n\t\t}\n\t}\n\n\ttmp = sctp_tsnmap_check(&asoc->peer.tsn_map, tsn);\n\tif (tmp < 0) {\n\t\t/* The TSN is too high--silently discard the chunk and\n\t\t * count on it getting retransmitted later.\n\t\t */\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.outofseqtsns++;\n\t\treturn SCTP_IERROR_HIGH_TSN;\n\t} else if (tmp > 0) {\n\t\t/* This is a duplicate.  Record it.  */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_DUP, SCTP_U32(tsn));\n\t\treturn SCTP_IERROR_DUP_TSN;\n\t}\n\n\t/* This is a new TSN.  */\n\n\t/* Discard if there is no room in the receive window.\n\t * Actually, allow a little bit of overflow (up to a MTU).\n\t */\n\tdatalen = ntohs(chunk->chunk_hdr->length);\n\tdatalen -= sizeof(sctp_data_chunk_t);\n\n\tdeliver = SCTP_CMD_CHUNK_ULP;\n\n\t/* Think about partial delivery. */\n\tif ((datalen >= asoc->rwnd) && (!asoc->ulpq.pd_mode)) {\n\n\t\t/* Even if we don't accept this chunk there is\n\t\t * memory pressure.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_PART_DELIVER, SCTP_NULL());\n\t}\n\n\t/* Spill over rwnd a little bit.  Note: While allowed, this spill over\n\t * seems a bit troublesome in that frag_point varies based on\n\t * PMTU.  In cases, such as loopback, this might be a rather\n\t * large spill over.\n\t */\n\tif ((!chunk->data_accepted) && (!asoc->rwnd || asoc->rwnd_over ||\n\t    (datalen > asoc->rwnd + asoc->frag_point))) {\n\n\t\t/* If this is the next TSN, consider reneging to make\n\t\t * room.   Note: Playing nice with a confused sender.  A\n\t\t * malicious sender can still eat up all our buffer\n\t\t * space and in the future we may want to detect and\n\t\t * do more drastic reneging.\n\t\t */\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: reneging for tsn:%u\\n\", __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t} else {\n\t\t\tpr_debug(\"%s: discard tsn:%u len:%zu, rwnd:%d\\n\",\n\t\t\t\t __func__, tsn, datalen, asoc->rwnd);\n\n\t\t\treturn SCTP_IERROR_IGNORE_TSN;\n\t\t}\n\t}\n\n\t/*\n\t * Also try to renege to limit our memory usage in the event that\n\t * we are under memory pressure\n\t * If we can't renege, don't worry about it, the sk_rmem_schedule\n\t * in sctp_ulpevent_make_rcvmsg will drop the frame if we grow our\n\t * memory usage too much\n\t */\n\tif (*sk->sk_prot_creator->memory_pressure) {\n\t\tif (sctp_tsnmap_has_gap(map) &&\n\t\t    (sctp_tsnmap_get_ctsn(map) + 1) == tsn) {\n\t\t\tpr_debug(\"%s: under pressure, reneging for tsn:%u\\n\",\n\t\t\t\t __func__, tsn);\n\t\t\tdeliver = SCTP_CMD_RENEGE;\n\t\t }\n\t}\n\n\t/*\n\t * Section 3.3.10.9 No User Data (9)\n\t *\n\t * Cause of error\n\t * ---------------\n\t * No User Data:  This error cause is returned to the originator of a\n\t * DATA chunk if a received DATA chunk has no user data.\n\t */\n\tif (unlikely(0 == datalen)) {\n\t\terr = sctp_make_abort_no_data(asoc, chunk, tsn);\n\t\tif (err) {\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\t}\n\t\t/* We are going to ABORT, so we might as well stop\n\t\t * processing the rest of the chunks in the packet.\n\t\t */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ECONNABORTED));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_DATA));\n\t\tSCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);\n\t\tSCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);\n\t\treturn SCTP_IERROR_NO_DATA;\n\t}\n\n\tchunk->data_accepted = 1;\n\n\t/* Note: Some chunks may get overcounted (if we drop) or overcounted\n\t * if we renege and the chunk arrives again.\n\t */\n\tif (chunk->chunk_hdr->flags & SCTP_DATA_UNORDERED) {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INUNORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iuodchunks++;\n\t} else {\n\t\tSCTP_INC_STATS(net, SCTP_MIB_INORDERCHUNKS);\n\t\tif (chunk->asoc)\n\t\t\tchunk->asoc->stats.iodchunks++;\n\t\tordered = 1;\n\t}\n\n\t/* RFC 2960 6.5 Stream Identifier and Stream Sequence Number\n\t *\n\t * If an endpoint receive a DATA chunk with an invalid stream\n\t * identifier, it shall acknowledge the reception of the DATA chunk\n\t * following the normal procedure, immediately send an ERROR chunk\n\t * with cause set to \"Invalid Stream Identifier\" (See Section 3.3.10)\n\t * and discard the DATA chunk.\n\t */\n\tsid = ntohs(data_hdr->stream);\n\tif (sid >= asoc->c.sinit_max_instreams) {\n\t\t/* Mark tsn as received even though we drop it */\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_TSN, SCTP_U32(tsn));\n\n\t\terr = sctp_make_op_error(asoc, chunk, SCTP_ERROR_INV_STRM,\n\t\t\t\t\t &data_hdr->stream,\n\t\t\t\t\t sizeof(data_hdr->stream),\n\t\t\t\t\t sizeof(u16));\n\t\tif (err)\n\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\n\t\t\t\t\tSCTP_CHUNK(err));\n\t\treturn SCTP_IERROR_BAD_STREAM;\n\t}\n\n\t/* Check to see if the SSN is possible for this TSN.\n\t * The biggest gap we can record is 4K wide.  Since SSNs wrap\n\t * at an unsigned short, there is no way that an SSN can\n\t * wrap and for a valid TSN.  We can simply check if the current\n\t * SSN is smaller then the next expected one.  If it is, it wrapped\n\t * and is invalid.\n\t */\n\tssn = ntohs(data_hdr->ssn);\n\tif (ordered && SSN_lt(ssn, sctp_ssn_peek(&asoc->ssnmap->in, sid))) {\n\t\treturn SCTP_IERROR_PROTO_VIOLATION;\n\t}\n\n\t/* Send the data up to the user.  Note:  Schedule  the\n\t * SCTP_CMD_CHUNK_ULP cmd before the SCTP_CMD_GEN_SACK, as the SACK\n\t * chunk needs the updated rwnd.\n\t */\n\tsctp_add_cmd_sf(commands, deliver, SCTP_CHUNK(chunk));\n\n\treturn SCTP_IERROR_NO_ERROR;\n}\n"], "filenames": ["include/net/sctp/sm.h", "net/sctp/sm_make_chunk.c", "net/sctp/sm_statefuns.c"], "buggy_code_start_loc": [251, 3113, 3594], "buggy_code_end_loc": [254, 3234, 3752], "fixing_code_start_loc": [251, 3113, 3593], "fixing_code_end_loc": [254, 3245, 3738], "type": "CWE-20", "message": "The SCTP implementation in the Linux kernel through 3.17.2 allows remote attackers to cause a denial of service (system crash) via a malformed ASCONF chunk, related to net/sctp/sm_make_chunk.c and net/sctp/sm_statefuns.c.", "other": {"cve": {"id": "CVE-2014-3673", "sourceIdentifier": "secalert@redhat.com", "published": "2014-11-10T11:55:06.580", "lastModified": "2023-02-13T00:41:46.940", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The SCTP implementation in the Linux kernel through 3.17.2 allows remote attackers to cause a denial of service (system crash) via a malformed ASCONF chunk, related to net/sctp/sm_make_chunk.c and net/sctp/sm_statefuns.c."}, {"lang": "es", "value": "La implementaci\u00f3n SCTP en el kernel de Linux hasta 3.17.2 permite a atacantes remotos causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) a trav\u00e9s de un chunk ASCONF malformado, relacionado con net/sctp/sm_make_chunk.c y net/sctp/sm_statefuns.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.6.12", "versionEndExcluding": "3.2.64", "matchCriteriaId": "81B7DEC7-B0D1-4A97-AFCC-888945125BF4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.4.107", "matchCriteriaId": "E15A5939-878C-4DD2-9BDF-308A9616CAC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5", "versionEndExcluding": "3.10.61", "matchCriteriaId": "6F6F5B79-847B-40A4-A86A-02ECF5222C5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.11", "versionEndExcluding": "3.12.34", "matchCriteriaId": "7EE4711D-12D9-4BDA-86F5-6F6C3AF22A59"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.13", "versionEndExcluding": "3.14.25", "matchCriteriaId": "FFEC5060-1B1C-4215-BD50-21710B905775"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.15", "versionEndExcluding": "3.16.35", "matchCriteriaId": "7DC4BA70-B111-4D2E-BC78-6601CED68F08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.17.4", "matchCriteriaId": "C15DCCA4-4748-46FF-B6BC-C1F5C70E3B2B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:5.0:*:*:*:*:*:*:*", "matchCriteriaId": "1D8B549B-E57B-4DFE-8A13-CAB06B5356B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_mrg:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "C60FA8B1-1802-4522-A088-22171DCF7A93"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:evergreen:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "CCE4D64E-8C4B-4F21-A9B0-90637C85C1D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:-:*:*:*:*:*:*", "matchCriteriaId": "1831D45A-EE6E-4220-8F8C-248B69520948"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_workstation_extension:12:*:*:*:*:*:*:*", "matchCriteriaId": "9DFA18B6-2642-470A-A350-68947529EE5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:10:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "61853C27-E1A3-49BC-993D-6B32802F668F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp1:*:*:ltss:*:*:*", "matchCriteriaId": "ED960EC0-D881-428E-ACE7-516B92C44EF4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "C202F75B-221A-40BB-8A0D-451335B39937"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:12:*:*:*:*:*:*:*", "matchCriteriaId": "9C649194-B8C2-49F7-A819-C635EE584ABF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:5:-:*:*:*:*:*:*", "matchCriteriaId": "62A2AC02-A933-4E51-810E-5D040B476B7B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:7:-:*:*:*:*:*:*", "matchCriteriaId": "44B8FEDF-6CB0-46E9-9AD7-4445B001C158"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=9de7922bc709eee2f609cd01d98aaedc4cf5ea74", "source": "secalert@redhat.com"}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3087.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3088.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://linux.oracle.com/errata/ELSA-2014-3089.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00010.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-03/msg00025.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00000.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://marc.info/?l=bugtraq&m=142722450701342&w=2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://marc.info/?l=bugtraq&m=142722544401658&w=2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0062.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0115.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-3060", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/70883", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2417-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2418-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1147850", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74"}}