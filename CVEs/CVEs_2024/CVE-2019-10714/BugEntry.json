{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                  L       OOO    CCCC   AAA   L      EEEEE                   %\n%                  L      O   O  C      A   A  L      E                       %\n%                  L      O   O  C      AAAAA  L      EEE                     %\n%                  L      O   O  C      A   A  L      E                       %\n%                  LLLLL   OOO    CCCC  A   A  LLLLL  EEEEE                   %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Locale Methods                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 2003                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/locale_.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_HAVE_NEWLOCALE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\n#  define MAGICKCORE_LOCALE_SUPPORT\n#endif\n#define LocaleFilename  \"locale.xml\"\n\f\n/*\n  Static declarations.\n*/\nstatic const char\n  *LocaleMap =\n    \"<?xml version=\\\"1.0\\\"?>\"\n    \"<localemap>\"\n    \"  <locale name=\\\"C\\\">\"\n    \"    <Exception>\"\n    \"     <Message name=\\\"\\\">\"\n    \"     </Message>\"\n    \"    </Exception>\"\n    \"  </locale>\"\n    \"</localemap>\";\n\n#ifdef __VMS\n#define asciimap AsciiMap\n#endif\n#if !defined(MAGICKCORE_HAVE_STRCASECMP) || !defined(MAGICKCORE_HAVE_STRNCASECMP)\nstatic const unsigned char\n  AsciiMap[] =\n  {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xe1, 0xe2, 0xe3, 0xe4, 0xc5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff,\n  };\n#endif\n\nstatic SemaphoreInfo\n  *locale_semaphore = (SemaphoreInfo *) NULL;\n\nstatic SplayTreeInfo\n  *locale_cache = (SplayTreeInfo *) NULL;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\nstatic volatile locale_t\n  c_locale = (locale_t) NULL;\n#endif\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  IsLocaleTreeInstantiated(ExceptionInfo *),\n  LoadLocaleCache(SplayTreeInfo *,const char *,const char *,const char *,\n    const size_t,ExceptionInfo *);\n\f\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e C L o c a l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireCLocale() allocates the C locale object, or (locale_t) 0 with\n%  errno set if it cannot be acquired.\n%\n%  The format of the AcquireCLocale method is:\n%\n%      locale_t AcquireCLocale(void)\n%\n*/\nstatic locale_t AcquireCLocale(void)\n{\n#if defined(MAGICKCORE_HAVE_NEWLOCALE)\n  if (c_locale == (locale_t) NULL)\n    c_locale=newlocale(LC_ALL_MASK,\"C\",(locale_t) 0);\n#elif defined(MAGICKCORE_WINDOWS_SUPPORT) && !defined(__MINGW32__)\n  if (c_locale == (locale_t) NULL)\n    c_locale=_create_locale(LC_ALL,\"C\");\n#endif\n  return(c_locale);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  A c q u i r e L o c a l e S p l a y T r e e                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireLocaleSplayTree() caches one or more locale configurations which\n%  provides a mapping between locale attributes and a locale tag.\n%\n%  The format of the AcquireLocaleSplayTree method is:\n%\n%      SplayTreeInfo *AcquireLocaleSplayTree(const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: the font file tag.\n%\n%    o locale: the actual locale.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void *DestroyLocaleNode(void *locale_info)\n{\n  register LocaleInfo\n    *p;\n\n  p=(LocaleInfo *) locale_info;\n  if (p->path != (char *) NULL)\n    p->path=DestroyString(p->path);\n  if (p->tag != (char *) NULL)\n    p->tag=DestroyString(p->tag);\n  if (p->message != (char *) NULL)\n    p->message=DestroyString(p->message);\n  return(RelinquishMagickMemory(p));\n}\n\nstatic SplayTreeInfo *AcquireLocaleSplayTree(const char *filename,\n  const char *locale,ExceptionInfo *exception)\n{\n  MagickStatusType\n    status;\n\n  SplayTreeInfo\n    *cache;\n\n  cache=NewSplayTree(CompareSplayTreeString,(void *(*)(void *)) NULL,\n    DestroyLocaleNode);\n  status=MagickTrue;\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  {\n    const StringInfo\n      *option;\n\n    LinkedListInfo\n      *options;\n\n    options=GetLocaleOptions(filename,exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n    while (option != (const StringInfo *) NULL)\n    {\n      status&=LoadLocaleCache(cache,(const char *)\n        GetStringInfoDatum(option),GetStringInfoPath(option),locale,0,\n        exception);\n      option=(const StringInfo *) GetNextValueInLinkedList(options);\n    }\n    options=DestroyLocaleOptions(options);\n    if (GetNumberOfNodesInSplayTree(cache) == 0)\n      {\n        options=GetLocaleOptions(\"english.xml\",exception);\n        option=(const StringInfo *) GetNextValueInLinkedList(options);\n        while (option != (const StringInfo *) NULL)\n        {\n          status&=LoadLocaleCache(cache,(const char *)\n            GetStringInfoDatum(option),GetStringInfoPath(option),locale,0,\n            exception);\n          option=(const StringInfo *) GetNextValueInLinkedList(options);\n        }\n        options=DestroyLocaleOptions(options);\n      }\n  }\n#endif\n  if (GetNumberOfNodesInSplayTree(cache) == 0)\n    status&=LoadLocaleCache(cache,LocaleMap,\"built-in\",locale,0,\n      exception);\n  return(cache);\n}\n\f\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y C L o c a l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyCLocale() releases the resources allocated for a locale object\n%  returned by a call to the AcquireCLocale() method.\n%\n%  The format of the DestroyCLocale method is:\n%\n%      void DestroyCLocale(void)\n%\n*/\nstatic void DestroyCLocale(void)\n{\n  if (c_locale != (locale_t) NULL)\n    freelocale(c_locale);\n  c_locale=(locale_t) NULL;\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y L o c a l e O p t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyLocaleOptions() releases memory associated with an locale\n%  messages.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      LinkedListInfo *DestroyLocaleOptions(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic void *DestroyOptions(void *message)\n{\n  return(DestroyStringInfo((StringInfo *) message));\n}\n\nMagickExport LinkedListInfo *DestroyLocaleOptions(LinkedListInfo *messages)\n{\n  assert(messages != (LinkedListInfo *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  return(DestroyLinkedList(messages,DestroyOptions));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  F o r m a t L o c a l e F i l e                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatLocaleFile() prints formatted output of a variable argument list to a\n%  file in the \"C\" locale.\n%\n%  The format of the FormatLocaleFile method is:\n%\n%      ssize_t FormatLocaleFile(FILE *file,const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o file:  the file.\n%\n%   o format:  A file describing the format to use to write the remaining\n%     arguments.\n%\n*/\n\nMagickPrivate ssize_t FormatLocaleFileList(FILE *file,\n  const char *magick_restrict format,va_list operands)\n{\n  ssize_t\n    n;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_VFPRINTF_L)\n  {\n    locale_t\n      locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vfprintf(file,format,operands);\n    else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      n=(ssize_t) vfprintf_l(file,format,locale,operands);\n#else\n      n=(ssize_t) vfprintf_l(file,locale,format,operands);\n#endif\n  }\n#else\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_USELOCALE)\n  {\n    locale_t\n      locale,\n      previous_locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vfprintf(file,format,operands);\n    else\n      {\n        previous_locale=uselocale(locale);\n        n=(ssize_t) vfprintf(file,format,operands);\n        uselocale(previous_locale);\n      }\n  }\n#else\n  n=(ssize_t) vfprintf(file,format,operands);\n#endif\n#endif\n  return(n);\n}\n\nMagickExport ssize_t FormatLocaleFile(FILE *file,\n  const char *magick_restrict format,...)\n{\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleFileList(file,format,operands);\n  va_end(operands);\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  F o r m a t L o c a l e S t r i n g                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatLocaleString() prints formatted output of a variable argument list to\n%  a string buffer in the \"C\" locale.\n%\n%  The format of the FormatLocaleString method is:\n%\n%      ssize_t FormatLocaleString(char *string,const size_t length,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o string:  FormatLocaleString() returns the formatted string in this\n%     character buffer.\n%\n%   o length: the maximum length of the string.\n%\n%   o format:  A string describing the format to use to write the remaining\n%     arguments.\n%\n*/\n\nMagickPrivate ssize_t FormatLocaleStringList(char *magick_restrict string,\n  const size_t length,const char *magick_restrict format,va_list operands)\n{\n  ssize_t\n    n;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_VSNPRINTF_L)\n  {\n    locale_t\n      locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vsnprintf(string,length,format,operands);\n    else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      n=(ssize_t) vsnprintf_l(string,length,format,locale,operands);\n#else\n      n=(ssize_t) vsnprintf_l(string,length,locale,format,operands);\n#endif\n  }\n#elif defined(MAGICKCORE_HAVE_VSNPRINTF)\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_USELOCALE)\n  {\n    locale_t\n      locale,\n      previous_locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vsnprintf(string,length,format,operands);\n    else\n      {\n        previous_locale=uselocale(locale);\n        n=(ssize_t) vsnprintf(string,length,format,operands);\n        uselocale(previous_locale);\n      }\n  }\n#else\n  n=(ssize_t) vsnprintf(string,length,format,operands);\n#endif\n#else\n  n=(ssize_t) vsprintf(string,format,operands);\n#endif\n  if (n < 0)\n    string[length-1]='\\0';\n  return(n);\n}\n\nMagickExport ssize_t FormatLocaleString(char *magick_restrict string,\n  const size_t length,const char *magick_restrict format,...)\n{\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(string,length,format,operands);\n  va_end(operands);\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t L o c a l e I n f o _                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleInfo_() searches the locale list for the specified tag and if\n%  found returns attributes for that element.\n%\n%  The format of the GetLocaleInfo method is:\n%\n%      const LocaleInfo *GetLocaleInfo_(const char *tag,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o tag: the locale tag.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const LocaleInfo *GetLocaleInfo_(const char *tag,\n  ExceptionInfo *exception)\n{\n  const LocaleInfo\n    *locale_info;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  if (IsLocaleTreeInstantiated(exception) == MagickFalse)\n    return((const LocaleInfo *) NULL);\n  LockSemaphoreInfo(locale_semaphore);\n  if ((tag == (const char *) NULL) || (LocaleCompare(tag,\"*\") == 0))\n    {\n      ResetSplayTreeIterator(locale_cache);\n      locale_info=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n      UnlockSemaphoreInfo(locale_semaphore);\n      return(locale_info);\n    }\n  locale_info=(const LocaleInfo *) GetValueFromSplayTree(locale_cache,tag);\n  UnlockSemaphoreInfo(locale_semaphore);\n  return(locale_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e I n f o L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleInfoList() returns any locale messages that match the\n%  specified pattern.\n%\n%  The format of the GetLocaleInfoList function is:\n%\n%      const LocaleInfo **GetLocaleInfoList(const char *pattern,\n%        size_t *number_messages,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o number_messages:  This integer returns the number of locale messages in\n%    the list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int LocaleInfoCompare(const void *x,const void *y)\n{\n  const LocaleInfo\n    **p,\n    **q;\n\n  p=(const LocaleInfo **) x,\n  q=(const LocaleInfo **) y;\n  if (LocaleCompare((*p)->path,(*q)->path) == 0)\n    return(LocaleCompare((*p)->tag,(*q)->tag));\n  return(LocaleCompare((*p)->path,(*q)->path));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport const LocaleInfo **GetLocaleInfoList(const char *pattern,\n  size_t *number_messages,ExceptionInfo *exception)\n{\n  const LocaleInfo\n    **messages;\n\n  register const LocaleInfo\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Allocate locale list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_messages != (size_t *) NULL);\n  *number_messages=0;\n  p=GetLocaleInfo_(\"*\",exception);\n  if (p == (const LocaleInfo *) NULL)\n    return((const LocaleInfo **) NULL);\n  messages=(const LocaleInfo **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(locale_cache)+1UL,sizeof(*messages));\n  if (messages == (const LocaleInfo **) NULL)\n    return((const LocaleInfo **) NULL);\n  /*\n    Generate locale list.\n  */\n  LockSemaphoreInfo(locale_semaphore);\n  ResetSplayTreeIterator(locale_cache);\n  p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  for (i=0; p != (const LocaleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickTrue) != MagickFalse))\n      messages[i++]=p;\n    p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  }\n  UnlockSemaphoreInfo(locale_semaphore);\n  qsort((void *) messages,(size_t) i,sizeof(*messages),LocaleInfoCompare);\n  messages[i]=(LocaleInfo *) NULL;\n  *number_messages=(size_t) i;\n  return(messages);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e L i s t                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleList() returns any locale messages that match the specified\n%  pattern.\n%\n%  The format of the GetLocaleList function is:\n%\n%      char **GetLocaleList(const char *pattern,size_t *number_messages,\n%        Exceptioninfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o number_messages:  This integer returns the number of messages in the\n%      list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int LocaleTagCompare(const void *x,const void *y)\n{\n  register char\n    **p,\n    **q;\n\n  p=(char **) x;\n  q=(char **) y;\n  return(LocaleCompare(*p,*q));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport char **GetLocaleList(const char *pattern,size_t *number_messages,\n  ExceptionInfo *exception)\n{\n  char\n    **messages;\n\n  register const LocaleInfo\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Allocate locale list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_messages != (size_t *) NULL);\n  *number_messages=0;\n  p=GetLocaleInfo_(\"*\",exception);\n  if (p == (const LocaleInfo *) NULL)\n    return((char **) NULL);\n  messages=(char **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(locale_cache)+1UL,sizeof(*messages));\n  if (messages == (char **) NULL)\n    return((char **) NULL);\n  LockSemaphoreInfo(locale_semaphore);\n  p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  for (i=0; p != (const LocaleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickTrue) != MagickFalse))\n      messages[i++]=ConstantString(p->tag);\n    p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  }\n  UnlockSemaphoreInfo(locale_semaphore);\n  qsort((void *) messages,(size_t) i,sizeof(*messages),LocaleTagCompare);\n  messages[i]=(char *) NULL;\n  *number_messages=(size_t) i;\n  return(messages);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e M e s s a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleMessage() returns a message in the current locale that matches the\n%  supplied tag.\n%\n%  The format of the GetLocaleMessage method is:\n%\n%      const char *GetLocaleMessage(const char *tag)\n%\n%  A description of each parameter follows:\n%\n%    o tag: Return a message that matches this tag in the current locale.\n%\n*/\nMagickExport const char *GetLocaleMessage(const char *tag)\n{\n  char\n    name[MagickLocaleExtent];\n\n  const LocaleInfo\n    *locale_info;\n\n  ExceptionInfo\n    *exception;\n\n  if ((tag == (const char *) NULL) || (*tag == '\\0'))\n    return(tag);\n  exception=AcquireExceptionInfo();\n  (void) FormatLocaleString(name,MagickLocaleExtent,\"%s/\",tag);\n  locale_info=GetLocaleInfo_(name,exception);\n  exception=DestroyExceptionInfo(exception);\n  if (locale_info != (const LocaleInfo *) NULL)\n    return(locale_info->message);\n  return(tag);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t L o c a l e O p t i o n s                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleOptions() returns any Magick configuration messages associated\n%  with the specified filename.\n%\n%  The format of the GetLocaleOptions method is:\n%\n%      LinkedListInfo *GetLocaleOptions(const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: the locale file tag.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n\n  const char\n    *element;\n\n  LinkedListInfo\n    *messages,\n    *paths;\n\n  StringInfo\n    *xml;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  /*\n    Load XML from configuration files to linked-list.\n  */\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e V a l u e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleValue() returns the message associated with the locale info.\n%\n%  The format of the GetLocaleValue method is:\n%\n%      const char *GetLocaleValue(const LocaleInfo *locale_info)\n%\n%  A description of each parameter follows:\n%\n%    o locale_info:  The locale info.\n%\n*/\nMagickExport const char *GetLocaleValue(const LocaleInfo *locale_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(locale_info != (LocaleInfo *) NULL);\n  assert(locale_info->signature == MagickCoreSignature);\n  return(locale_info->message);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   I s L o c a l e T r e e I n s t a n t i a t e d                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsLocaleTreeInstantiated() determines if the locale tree is instantiated.\n%  If not, it instantiates the tree and returns it.\n%\n%  The format of the IsLocaleInstantiated method is:\n%\n%      MagickBooleanType IsLocaleTreeInstantiated(ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType IsLocaleTreeInstantiated(ExceptionInfo *exception)\n{\n  if (locale_cache == (SplayTreeInfo *) NULL)\n    {\n      if (locale_semaphore == (SemaphoreInfo *) NULL)\n        ActivateSemaphoreInfo(&locale_semaphore);\n      LockSemaphoreInfo(locale_semaphore);\n      if (locale_cache == (SplayTreeInfo *) NULL)\n        {\n          char\n            *locale;\n\n          register const char\n            *p;\n\n          locale=(char *) NULL;\n          p=setlocale(LC_CTYPE,(const char *) NULL);\n          if (p != (const char *) NULL)\n            locale=ConstantString(p);\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LC_ALL\");\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LC_MESSAGES\");\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LC_CTYPE\");\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LANG\");\n          if (locale == (char *) NULL)\n            locale=ConstantString(\"C\");\n          locale_cache=AcquireLocaleSplayTree(LocaleFilename,locale,exception);\n          locale=DestroyString(locale);\n        }\n      UnlockSemaphoreInfo(locale_semaphore);\n    }\n  return(locale_cache != (SplayTreeInfo *) NULL ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   I n t e r p r e t L o c a l e V a l u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretLocaleValue() interprets the string as a floating point number in\n%  the \"C\" locale and returns its value as a double. If sentinal is not a null\n%  pointer, the method also sets the value pointed by sentinal to point to the\n%  first character after the number.\n%\n%  The format of the InterpretLocaleValue method is:\n%\n%      double InterpretLocaleValue(const char *value,char **sentinal)\n%\n%  A description of each parameter follows:\n%\n%    o value: the string value.\n%\n%    o sentinal:  if sentinal is not NULL, a pointer to the character after the\n%      last character used in the conversion is stored in the location\n%      referenced by sentinal.\n%\n*/\nMagickExport double InterpretLocaleValue(const char *magick_restrict string,\n  char **magick_restrict sentinal)\n{\n  char\n    *q;\n\n  double\n    value;\n\n  if ((*string == '0') && ((string[1] | 0x20)=='x'))\n    value=(double) strtoul(string,&q,16);\n  else\n    {\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_STRTOD_L)\n      locale_t\n        locale;\n\n      locale=AcquireCLocale();\n      if (locale == (locale_t) NULL)\n        value=strtod(string,&q);\n      else\n        value=strtod_l(string,&q,locale);\n#else\n      value=strtod(string,&q);\n#endif\n    }\n  if (sentinal != (char **) NULL)\n    *sentinal=q;\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t L o c a l e I n f o                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListLocaleInfo() lists the locale info to a file.\n%\n%  The format of the ListLocaleInfo method is:\n%\n%      MagickBooleanType ListLocaleInfo(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to a FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListLocaleInfo(FILE *file,\n  ExceptionInfo *exception)\n{\n  const char\n    *path;\n\n  const LocaleInfo\n    **locale_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_messages;\n\n  if (file == (const FILE *) NULL)\n    file=stdout;\n  number_messages=0;\n  locale_info=GetLocaleInfoList(\"*\",&number_messages,exception);\n  if (locale_info == (const LocaleInfo **) NULL)\n    return(MagickFalse);\n  path=(const char *) NULL;\n  for (i=0; i < (ssize_t) number_messages; i++)\n  {\n    if (locale_info[i]->stealth != MagickFalse)\n      continue;\n    if ((path == (const char *) NULL) ||\n        (LocaleCompare(path,locale_info[i]->path) != 0))\n      {\n        if (locale_info[i]->path != (char *) NULL)\n          (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",locale_info[i]->path);\n        (void) FormatLocaleFile(file,\"Tag/Message\\n\");\n        (void) FormatLocaleFile(file,\n          \"-------------------------------------------------\"\n          \"------------------------------\\n\");\n      }\n    path=locale_info[i]->path;\n    (void) FormatLocaleFile(file,\"%s\\n\",locale_info[i]->tag);\n    if (locale_info[i]->message != (char *) NULL)\n      (void) FormatLocaleFile(file,\"  %s\",locale_info[i]->message);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  locale_info=(const LocaleInfo **)\n    RelinquishMagickMemory((void *) locale_info);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   L o a d L o c a l e C a c h e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LoadLocaleCache() loads the locale configurations which provides a mapping\n%  between locale attributes and a locale name.\n%\n%  The format of the LoadLocaleCache method is:\n%\n%      MagickBooleanType LoadLocaleCache(SplayTreeInfo *cache,const char *xml,\n%        const char *filename,const size_t depth,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o xml:  The locale list in XML format.\n%\n%    o filename:  The locale list filename.\n%\n%    o depth: depth of <include /> statements.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void ChopLocaleComponents(char *path,const size_t components)\n{\n  register char\n    *p;\n\n  ssize_t\n    count;\n\n  if (*path == '\\0')\n    return;\n  p=path+strlen(path)-1;\n  if (*p == '/')\n    *p='\\0';\n  for (count=0; (count < (ssize_t) components) && (p > path); p--)\n    if (*p == '/')\n      {\n        *p='\\0';\n        count++;\n      }\n  if (count < (ssize_t) components)\n    *path='\\0';\n}\n\nstatic void LocaleFatalErrorHandler(\n  const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n  exit(1);\n}\n\nstatic MagickBooleanType LoadLocaleCache(SplayTreeInfo *cache,const char *xml,\n  const char *filename,const char *locale,const size_t depth,ExceptionInfo *exception)\n{\n  char\n    keyword[MagickLocaleExtent],\n    message[MagickLocaleExtent],\n    tag[MagickLocaleExtent],\n    *token;\n\n  const char\n    *q;\n\n  FatalErrorHandler\n    fatal_handler;\n\n  LocaleInfo\n    *locale_info;\n\n  MagickStatusType\n    status;\n\n  register char\n    *p;\n\n  size_t\n    extent;\n\n  /*\n    Read the locale configure file.\n  */\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading locale configure file \\\"%s\\\" ...\",filename);\n  if (xml == (const char *) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  locale_info=(LocaleInfo *) NULL;\n  *tag='\\0';\n  *message='\\0';\n  *keyword='\\0';\n  fatal_handler=SetFatalErrorHandler(LocaleFatalErrorHandler);\n  token=AcquireString(xml);\n  extent=strlen(token)+MagickPathExtent;\n  for (q=(char *) xml; *q != '\\0'; )\n  {\n    /*\n      Interpret XML.\n    */\n    GetNextToken(q,&q,extent,token);\n    if (*token == '\\0')\n      break;\n    (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n    if (LocaleNCompare(keyword,\"<!DOCTYPE\",9) == 0)\n      {\n        /*\n          Doctype element.\n        */\n        while ((LocaleNCompare(q,\"]>\",2) != 0) && (*q != '\\0'))\n        {\n          GetNextToken(q,&q,extent,token);\n          while (isspace((int) ((unsigned char) *q)) != 0)\n            q++;\n        }\n        continue;\n      }\n    if (LocaleNCompare(keyword,\"<!--\",4) == 0)\n      {\n        /*\n          Comment element.\n        */\n        while ((LocaleNCompare(q,\"->\",2) != 0) && (*q != '\\0'))\n        {\n          GetNextToken(q,&q,extent,token);\n          while (isspace((int) ((unsigned char) *q)) != 0)\n            q++;\n        }\n        continue;\n      }\n    if (LocaleCompare(keyword,\"<include\") == 0)\n      {\n        /*\n          Include element.\n        */\n        while (((*token != '/') && (*(token+1) != '>')) && (*q != '\\0'))\n        {\n          (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n          GetNextToken(q,&q,extent,token);\n          if (*token != '=')\n            continue;\n          GetNextToken(q,&q,extent,token);\n          if (LocaleCompare(keyword,\"locale\") == 0)\n            {\n              if (LocaleCompare(locale,token) != 0)\n                break;\n              continue;\n            }\n          if (LocaleCompare(keyword,\"file\") == 0)\n            {\n              if (depth > MagickMaxRecursionDepth)\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ConfigureError,\"IncludeElementNestedTooDeeply\",\"`%s'\",token);\n              else\n                {\n                  char\n                    path[MagickPathExtent],\n                    *file_xml;\n\n                  *path='\\0';\n                  GetPathComponent(filename,HeadPath,path);\n                  if (*path != '\\0')\n                    (void) ConcatenateMagickString(path,DirectorySeparator,\n                      MagickPathExtent);\n                  if (*token == *DirectorySeparator)\n                    (void) CopyMagickString(path,token,MagickPathExtent);\n                  else\n                    (void) ConcatenateMagickString(path,token,MagickPathExtent);\n                  file_xml=FileToXML(path,~0UL);\n                  if (file_xml != (char *) NULL)\n                    {\n                      status&=LoadLocaleCache(cache,file_xml,path,locale,\n                        depth+1,exception);\n                      file_xml=DestroyString(file_xml);\n                    }\n                }\n            }\n        }\n        continue;\n      }\n    if (LocaleCompare(keyword,\"<locale\") == 0)\n      {\n        /*\n          Locale element.\n        */\n        while ((*token != '>') && (*q != '\\0'))\n        {\n          (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n          GetNextToken(q,&q,extent,token);\n          if (*token != '=')\n            continue;\n          GetNextToken(q,&q,extent,token);\n        }\n        continue;\n      }\n    if (LocaleCompare(keyword,\"</locale>\") == 0)\n      {\n        ChopLocaleComponents(tag,1);\n        (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n        continue;\n      }\n    if (LocaleCompare(keyword,\"<localemap>\") == 0)\n      continue;\n    if (LocaleCompare(keyword,\"</localemap>\") == 0)\n      continue;\n    if (LocaleCompare(keyword,\"<message\") == 0)\n      {\n        /*\n          Message element.\n        */\n        while ((*token != '>') && (*q != '\\0'))\n        {\n          (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n          GetNextToken(q,&q,extent,token);\n          if (*token != '=')\n            continue;\n          GetNextToken(q,&q,extent,token);\n          if (LocaleCompare(keyword,\"name\") == 0)\n            {\n              (void) ConcatenateMagickString(tag,token,MagickLocaleExtent);\n              (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n            }\n        }\n        for (p=(char *) q; (*q != '<') && (*q != '\\0'); q++) ;\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          p++;\n        q--;\n        while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n          q--;\n        (void) CopyMagickString(message,p,MagickMin((size_t) (q-p+2),\n          MagickLocaleExtent));\n        locale_info=(LocaleInfo *) AcquireCriticalMemory(sizeof(*locale_info));\n        (void) memset(locale_info,0,sizeof(*locale_info));\n        locale_info->path=ConstantString(filename);\n        locale_info->tag=ConstantString(tag);\n        locale_info->message=ConstantString(message);\n        locale_info->signature=MagickCoreSignature;\n        status=AddValueToSplayTree(cache,locale_info->tag,locale_info);\n        if (status == MagickFalse)\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            locale_info->tag);\n        (void) ConcatenateMagickString(tag,message,MagickLocaleExtent);\n        (void) ConcatenateMagickString(tag,\"\\n\",MagickLocaleExtent);\n        q++;\n        continue;\n      }\n    if (LocaleCompare(keyword,\"</message>\") == 0)\n      {\n        ChopLocaleComponents(tag,2);\n        (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n        continue;\n      }\n    if (*keyword == '<')\n      {\n        /*\n          Subpath element.\n        */\n        if (*(keyword+1) == '?')\n          continue;\n        if (*(keyword+1) == '/')\n          {\n            ChopLocaleComponents(tag,1);\n            if (*tag != '\\0')\n              (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n            continue;\n          }\n        token[strlen(token)-1]='\\0';\n        (void) CopyMagickString(token,token+1,MagickLocaleExtent);\n        (void) ConcatenateMagickString(tag,token,MagickLocaleExtent);\n        (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n        continue;\n      }\n    GetNextToken(q,(const char **) NULL,extent,token);\n    if (*token != '=')\n      continue;\n  }\n  token=(char *) RelinquishMagickMemory(token);\n  (void) SetFatalErrorHandler(fatal_handler);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e C o m p a r e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleCompare() performs a case-insensitive comparison of two strings\n%  byte-by-byte, according to the ordering of the current locale encoding.\n%  LocaleCompare returns an integer greater than, equal to, or less than 0,\n%  if the string pointed to by p is greater than, equal to, or less than the\n%  string pointed to by q respectively.  The sign of a non-zero return value\n%  is determined by the sign of the difference between the values of the first\n%  pair of bytes that differ in the strings being compared.\n%\n%  The format of the LocaleCompare method is:\n%\n%      int LocaleCompare(const char *p,const char *q)\n%\n%  A description of each parameter follows:\n%\n%    o p: A pointer to a character string.\n%\n%    o q: A pointer to a character string to compare to p.\n%\n*/\nMagickExport int LocaleCompare(const char *p,const char *q)\n{\n  if (p == (char *) NULL)\n    {\n      if (q == (char *) NULL)\n        return(0);\n      return(-1);\n    }\n  if (q == (char *) NULL)\n    return(1);\n#if defined(MAGICKCORE_HAVE_STRCASECMP)\n  return(strcasecmp(p,q));\n#else\n  {\n    register int\n      c,\n      d;\n\n    for ( ; ; )\n    {\n      c=(int) *((unsigned char *) p);\n      d=(int) *((unsigned char *) q);\n      if ((c == 0) || (AsciiMap[c] != AsciiMap[d]))\n        break;\n      p++;\n      q++;\n    }\n    return(AsciiMap[c]-(int) AsciiMap[d]);\n  }\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e L o w e r                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleLower() transforms all of the characters in the supplied\n%  null-terminated string, changing all uppercase letters to lowercase.\n%\n%  The format of the LocaleLower method is:\n%\n%      void LocaleLower(char *string)\n%\n%  A description of each parameter follows:\n%\n%    o string: A pointer to the string to convert to lower-case Locale.\n%\n*/\nMagickExport void LocaleLower(char *string)\n{\n  register char\n    *q;\n\n  assert(string != (char *) NULL);\n  for (q=string; *q != '\\0'; q++)\n    *q=(char) LocaleLowercase((int) *q);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e L o w e r c a s e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleLowercase() convert to lowercase.\n%\n%  The format of the LocaleLowercase method is:\n%\n%      void LocaleLowercase(const int c)\n%\n%  A description of each parameter follows:\n%\n%    o If c is a uppercase letter, return its lowercase equivalent.\n%\n*/\nMagickExport int LocaleLowercase(const int c)\n{\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(tolower_l(c,c_locale));\n#endif\n  return(tolower(c));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e N C o m p a r e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleNCompare() performs a case-insensitive comparison of two strings\n%  byte-by-byte, according to the ordering of the current locale encoding.\n%\n%  LocaleNCompare returns an integer greater than, equal to, or less than 0,\n%  if the string pointed to by p is greater than, equal to, or less than the\n%  string pointed to by q respectively.  The sign of a non-zero return value\n%  is determined by the sign of the difference between the values of the first\n%  pair of bytes that differ in the strings being compared.\n%\n%  The LocaleNCompare method makes the same comparison as LocaleCompare but\n%  looks at a maximum of n bytes.  Bytes following a null byte are not\n%  compared.\n%\n%  The format of the LocaleNCompare method is:\n%\n%      int LocaleNCompare(const char *p,const char *q,const size_t n)\n%\n%  A description of each parameter follows:\n%\n%    o p: A pointer to a character string.\n%\n%    o q: A pointer to a character string to compare to p.\n%\n%    o length: the number of characters to compare in strings p and q.\n%\n*/\nMagickExport int LocaleNCompare(const char *p,const char *q,const size_t length)\n{\n  if (p == (char *) NULL)\n    {\n      if (q == (char *) NULL)\n        return(0);\n      return(-1);\n    }\n  if (q == (char *) NULL)\n    return(1);\n#if defined(MAGICKCORE_HAVE_STRNCASECMP)\n  return(strncasecmp(p,q,length));\n#else\n  {\n    register int\n      c,\n      d;\n\n    register size_t\n      i;\n\n    for (i=length; i != 0; i--)\n    {\n      c=(int) *((unsigned char *) p);\n      d=(int) *((unsigned char *) q);\n      if (AsciiMap[c] != AsciiMap[d])\n        return(AsciiMap[c]-(int) AsciiMap[d]);\n      if (c == 0)\n        return(0);\n      p++;\n      q++;\n    }\n    return(0);\n  }\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e U p p e r                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleUpper() transforms all of the characters in the supplied\n%  null-terminated string, changing all lowercase letters to uppercase.\n%\n%  The format of the LocaleUpper method is:\n%\n%      void LocaleUpper(char *string)\n%\n%  A description of each parameter follows:\n%\n%    o string: A pointer to the string to convert to upper-case Locale.\n%\n*/\nMagickExport void LocaleUpper(char *string)\n{\n  register char\n    *q;\n\n  assert(string != (char *) NULL);\n  for (q=string; *q != '\\0'; q++)\n    *q=(char) LocaleUppercase((int) *q);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e U p p e r c a s e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleUppercase() convert to uppercase.\n%\n%  The format of the LocaleUppercase method is:\n%\n%      void LocaleUppercase(const int c)\n%\n%  A description of each parameter follows:\n%\n%    o If c is a lowercase letter, return its uppercase equivalent.\n%\n*/\nMagickExport int LocaleUppercase(const int c)\n{\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(toupper_l(c,c_locale));\n#endif\n  return(toupper(c));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   L o c a l e C o m p o n e n t G e n e s i s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleComponentGenesis() instantiates the locale component.\n%\n%  The format of the LocaleComponentGenesis method is:\n%\n%      MagickBooleanType LocaleComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType LocaleComponentGenesis(void)\n{\n  if (locale_semaphore == (SemaphoreInfo *) NULL)\n    locale_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   L o c a l e C o m p o n e n t T e r m i n u s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleComponentTerminus() destroys the locale component.\n%\n%  The format of the LocaleComponentTerminus method is:\n%\n%      LocaleComponentTerminus(void)\n%\n*/\nMagickPrivate void LocaleComponentTerminus(void)\n{\n  if (locale_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&locale_semaphore);\n  LockSemaphoreInfo(locale_semaphore);\n  if (locale_cache != (SplayTreeInfo *) NULL)\n    locale_cache=DestroySplayTree(locale_cache);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  DestroyCLocale();\n#endif\n  UnlockSemaphoreInfo(locale_semaphore);\n  RelinquishSemaphoreInfo(&locale_semaphore);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                  L       OOO    CCCC   AAA   L      EEEEE                   %\n%                  L      O   O  C      A   A  L      E                       %\n%                  L      O   O  C      AAAAA  L      EEE                     %\n%                  L      O   O  C      A   A  L      E                       %\n%                  LLLLL   OOO    CCCC  A   A  LLLLL  EEEEE                   %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Locale Methods                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 2003                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/locale_.h\"\n#include \"MagickCore/locale-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/nt-base-private.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/xml-tree.h\"\n#include \"MagickCore/xml-tree-private.h\"\n\f\n/*\n  Define declarations.\n*/\n#if defined(MAGICKCORE_HAVE_NEWLOCALE) || defined(MAGICKCORE_WINDOWS_SUPPORT)\n#  define MAGICKCORE_LOCALE_SUPPORT\n#endif\n#define LocaleFilename  \"locale.xml\"\n\f\n/*\n  Static declarations.\n*/\nstatic const char\n  *LocaleMap =\n    \"<?xml version=\\\"1.0\\\"?>\"\n    \"<localemap>\"\n    \"  <locale name=\\\"C\\\">\"\n    \"    <Exception>\"\n    \"     <Message name=\\\"\\\">\"\n    \"     </Message>\"\n    \"    </Exception>\"\n    \"  </locale>\"\n    \"</localemap>\";\n\n#ifdef __VMS\n#define asciimap AsciiMap\n#endif\n#if !defined(MAGICKCORE_HAVE_STRCASECMP) || !defined(MAGICKCORE_HAVE_STRNCASECMP)\nstatic const unsigned char\n  AsciiMap[] =\n  {\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n    0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,\n    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,\n    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,\n    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,\n    0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,\n    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,\n    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,\n    0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,\n    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,\n    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,\n    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,\n    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,\n    0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,\n    0xc0, 0xe1, 0xe2, 0xe3, 0xe4, 0xc5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,\n    0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,\n    0xf8, 0xf9, 0xfa, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,\n    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,\n    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,\n    0xfc, 0xfd, 0xfe, 0xff,\n  };\n#endif\n\nstatic SemaphoreInfo\n  *locale_semaphore = (SemaphoreInfo *) NULL;\n\nstatic SplayTreeInfo\n  *locale_cache = (SplayTreeInfo *) NULL;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\nstatic volatile locale_t\n  c_locale = (locale_t) NULL;\n#endif\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  IsLocaleTreeInstantiated(ExceptionInfo *),\n  LoadLocaleCache(SplayTreeInfo *,const char *,const char *,const char *,\n    const size_t,ExceptionInfo *);\n\f\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e C L o c a l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireCLocale() allocates the C locale object, or (locale_t) 0 with\n%  errno set if it cannot be acquired.\n%\n%  The format of the AcquireCLocale method is:\n%\n%      locale_t AcquireCLocale(void)\n%\n*/\nstatic locale_t AcquireCLocale(void)\n{\n#if defined(MAGICKCORE_HAVE_NEWLOCALE)\n  if (c_locale == (locale_t) NULL)\n    c_locale=newlocale(LC_ALL_MASK,\"C\",(locale_t) 0);\n#elif defined(MAGICKCORE_WINDOWS_SUPPORT) && !defined(__MINGW32__)\n  if (c_locale == (locale_t) NULL)\n    c_locale=_create_locale(LC_ALL,\"C\");\n#endif\n  return(c_locale);\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  A c q u i r e L o c a l e S p l a y T r e e                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquireLocaleSplayTree() caches one or more locale configurations which\n%  provides a mapping between locale attributes and a locale tag.\n%\n%  The format of the AcquireLocaleSplayTree method is:\n%\n%      SplayTreeInfo *AcquireLocaleSplayTree(const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: the font file tag.\n%\n%    o locale: the actual locale.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void *DestroyLocaleNode(void *locale_info)\n{\n  register LocaleInfo\n    *p;\n\n  p=(LocaleInfo *) locale_info;\n  if (p->path != (char *) NULL)\n    p->path=DestroyString(p->path);\n  if (p->tag != (char *) NULL)\n    p->tag=DestroyString(p->tag);\n  if (p->message != (char *) NULL)\n    p->message=DestroyString(p->message);\n  return(RelinquishMagickMemory(p));\n}\n\nstatic SplayTreeInfo *AcquireLocaleSplayTree(const char *filename,\n  const char *locale,ExceptionInfo *exception)\n{\n  MagickStatusType\n    status;\n\n  SplayTreeInfo\n    *cache;\n\n  cache=NewSplayTree(CompareSplayTreeString,(void *(*)(void *)) NULL,\n    DestroyLocaleNode);\n  status=MagickTrue;\n#if !defined(MAGICKCORE_ZERO_CONFIGURATION_SUPPORT)\n  {\n    const StringInfo\n      *option;\n\n    LinkedListInfo\n      *options;\n\n    options=GetLocaleOptions(filename,exception);\n    option=(const StringInfo *) GetNextValueInLinkedList(options);\n    while (option != (const StringInfo *) NULL)\n    {\n      status&=LoadLocaleCache(cache,(const char *)\n        GetStringInfoDatum(option),GetStringInfoPath(option),locale,0,\n        exception);\n      option=(const StringInfo *) GetNextValueInLinkedList(options);\n    }\n    options=DestroyLocaleOptions(options);\n    if (GetNumberOfNodesInSplayTree(cache) == 0)\n      {\n        options=GetLocaleOptions(\"english.xml\",exception);\n        option=(const StringInfo *) GetNextValueInLinkedList(options);\n        while (option != (const StringInfo *) NULL)\n        {\n          status&=LoadLocaleCache(cache,(const char *)\n            GetStringInfoDatum(option),GetStringInfoPath(option),locale,0,\n            exception);\n          option=(const StringInfo *) GetNextValueInLinkedList(options);\n        }\n        options=DestroyLocaleOptions(options);\n      }\n  }\n#endif\n  if (GetNumberOfNodesInSplayTree(cache) == 0)\n    status&=LoadLocaleCache(cache,LocaleMap,\"built-in\",locale,0,\n      exception);\n  return(cache);\n}\n\f\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y C L o c a l e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyCLocale() releases the resources allocated for a locale object\n%  returned by a call to the AcquireCLocale() method.\n%\n%  The format of the DestroyCLocale method is:\n%\n%      void DestroyCLocale(void)\n%\n*/\nstatic void DestroyCLocale(void)\n{\n  if (c_locale != (locale_t) NULL)\n    freelocale(c_locale);\n  c_locale=(locale_t) NULL;\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y L o c a l e O p t i o n s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyLocaleOptions() releases memory associated with an locale\n%  messages.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      LinkedListInfo *DestroyLocaleOptions(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic void *DestroyOptions(void *message)\n{\n  return(DestroyStringInfo((StringInfo *) message));\n}\n\nMagickExport LinkedListInfo *DestroyLocaleOptions(LinkedListInfo *messages)\n{\n  assert(messages != (LinkedListInfo *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  return(DestroyLinkedList(messages,DestroyOptions));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  F o r m a t L o c a l e F i l e                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatLocaleFile() prints formatted output of a variable argument list to a\n%  file in the \"C\" locale.\n%\n%  The format of the FormatLocaleFile method is:\n%\n%      ssize_t FormatLocaleFile(FILE *file,const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o file:  the file.\n%\n%   o format:  A file describing the format to use to write the remaining\n%     arguments.\n%\n*/\n\nMagickPrivate ssize_t FormatLocaleFileList(FILE *file,\n  const char *magick_restrict format,va_list operands)\n{\n  ssize_t\n    n;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_VFPRINTF_L)\n  {\n    locale_t\n      locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vfprintf(file,format,operands);\n    else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      n=(ssize_t) vfprintf_l(file,format,locale,operands);\n#else\n      n=(ssize_t) vfprintf_l(file,locale,format,operands);\n#endif\n  }\n#else\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_USELOCALE)\n  {\n    locale_t\n      locale,\n      previous_locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vfprintf(file,format,operands);\n    else\n      {\n        previous_locale=uselocale(locale);\n        n=(ssize_t) vfprintf(file,format,operands);\n        uselocale(previous_locale);\n      }\n  }\n#else\n  n=(ssize_t) vfprintf(file,format,operands);\n#endif\n#endif\n  return(n);\n}\n\nMagickExport ssize_t FormatLocaleFile(FILE *file,\n  const char *magick_restrict format,...)\n{\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleFileList(file,format,operands);\n  va_end(operands);\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+  F o r m a t L o c a l e S t r i n g                                        %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatLocaleString() prints formatted output of a variable argument list to\n%  a string buffer in the \"C\" locale.\n%\n%  The format of the FormatLocaleString method is:\n%\n%      ssize_t FormatLocaleString(char *string,const size_t length,\n%        const char *format,...)\n%\n%  A description of each parameter follows.\n%\n%   o string:  FormatLocaleString() returns the formatted string in this\n%     character buffer.\n%\n%   o length: the maximum length of the string.\n%\n%   o format:  A string describing the format to use to write the remaining\n%     arguments.\n%\n*/\n\nMagickPrivate ssize_t FormatLocaleStringList(char *magick_restrict string,\n  const size_t length,const char *magick_restrict format,va_list operands)\n{\n  ssize_t\n    n;\n\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_VSNPRINTF_L)\n  {\n    locale_t\n      locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vsnprintf(string,length,format,operands);\n    else\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      n=(ssize_t) vsnprintf_l(string,length,format,locale,operands);\n#else\n      n=(ssize_t) vsnprintf_l(string,length,locale,format,operands);\n#endif\n  }\n#elif defined(MAGICKCORE_HAVE_VSNPRINTF)\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_USELOCALE)\n  {\n    locale_t\n      locale,\n      previous_locale;\n\n    locale=AcquireCLocale();\n    if (locale == (locale_t) NULL)\n      n=(ssize_t) vsnprintf(string,length,format,operands);\n    else\n      {\n        previous_locale=uselocale(locale);\n        n=(ssize_t) vsnprintf(string,length,format,operands);\n        uselocale(previous_locale);\n      }\n  }\n#else\n  n=(ssize_t) vsnprintf(string,length,format,operands);\n#endif\n#else\n  n=(ssize_t) vsprintf(string,format,operands);\n#endif\n  if (n < 0)\n    string[length-1]='\\0';\n  return(n);\n}\n\nMagickExport ssize_t FormatLocaleString(char *magick_restrict string,\n  const size_t length,const char *magick_restrict format,...)\n{\n  ssize_t\n    n;\n\n  va_list\n    operands;\n\n  va_start(operands,format);\n  n=FormatLocaleStringList(string,length,format,operands);\n  va_end(operands);\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t L o c a l e I n f o _                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleInfo_() searches the locale list for the specified tag and if\n%  found returns attributes for that element.\n%\n%  The format of the GetLocaleInfo method is:\n%\n%      const LocaleInfo *GetLocaleInfo_(const char *tag,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o tag: the locale tag.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const LocaleInfo *GetLocaleInfo_(const char *tag,\n  ExceptionInfo *exception)\n{\n  const LocaleInfo\n    *locale_info;\n\n  assert(exception != (ExceptionInfo *) NULL);\n  if (IsLocaleTreeInstantiated(exception) == MagickFalse)\n    return((const LocaleInfo *) NULL);\n  LockSemaphoreInfo(locale_semaphore);\n  if ((tag == (const char *) NULL) || (LocaleCompare(tag,\"*\") == 0))\n    {\n      ResetSplayTreeIterator(locale_cache);\n      locale_info=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n      UnlockSemaphoreInfo(locale_semaphore);\n      return(locale_info);\n    }\n  locale_info=(const LocaleInfo *) GetValueFromSplayTree(locale_cache,tag);\n  UnlockSemaphoreInfo(locale_semaphore);\n  return(locale_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e I n f o L i s t                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleInfoList() returns any locale messages that match the\n%  specified pattern.\n%\n%  The format of the GetLocaleInfoList function is:\n%\n%      const LocaleInfo **GetLocaleInfoList(const char *pattern,\n%        size_t *number_messages,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o number_messages:  This integer returns the number of locale messages in\n%    the list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int LocaleInfoCompare(const void *x,const void *y)\n{\n  const LocaleInfo\n    **p,\n    **q;\n\n  p=(const LocaleInfo **) x,\n  q=(const LocaleInfo **) y;\n  if (LocaleCompare((*p)->path,(*q)->path) == 0)\n    return(LocaleCompare((*p)->tag,(*q)->tag));\n  return(LocaleCompare((*p)->path,(*q)->path));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport const LocaleInfo **GetLocaleInfoList(const char *pattern,\n  size_t *number_messages,ExceptionInfo *exception)\n{\n  const LocaleInfo\n    **messages;\n\n  register const LocaleInfo\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Allocate locale list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_messages != (size_t *) NULL);\n  *number_messages=0;\n  p=GetLocaleInfo_(\"*\",exception);\n  if (p == (const LocaleInfo *) NULL)\n    return((const LocaleInfo **) NULL);\n  messages=(const LocaleInfo **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(locale_cache)+1UL,sizeof(*messages));\n  if (messages == (const LocaleInfo **) NULL)\n    return((const LocaleInfo **) NULL);\n  /*\n    Generate locale list.\n  */\n  LockSemaphoreInfo(locale_semaphore);\n  ResetSplayTreeIterator(locale_cache);\n  p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  for (i=0; p != (const LocaleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickTrue) != MagickFalse))\n      messages[i++]=p;\n    p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  }\n  UnlockSemaphoreInfo(locale_semaphore);\n  qsort((void *) messages,(size_t) i,sizeof(*messages),LocaleInfoCompare);\n  messages[i]=(LocaleInfo *) NULL;\n  *number_messages=(size_t) i;\n  return(messages);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e L i s t                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleList() returns any locale messages that match the specified\n%  pattern.\n%\n%  The format of the GetLocaleList function is:\n%\n%      char **GetLocaleList(const char *pattern,size_t *number_messages,\n%        Exceptioninfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o pattern: Specifies a pointer to a text string containing a pattern.\n%\n%    o number_messages:  This integer returns the number of messages in the\n%      list.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic int LocaleTagCompare(const void *x,const void *y)\n{\n  register char\n    **p,\n    **q;\n\n  p=(char **) x;\n  q=(char **) y;\n  return(LocaleCompare(*p,*q));\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nMagickExport char **GetLocaleList(const char *pattern,size_t *number_messages,\n  ExceptionInfo *exception)\n{\n  char\n    **messages;\n\n  register const LocaleInfo\n    *p;\n\n  register ssize_t\n    i;\n\n  /*\n    Allocate locale list.\n  */\n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",pattern);\n  assert(number_messages != (size_t *) NULL);\n  *number_messages=0;\n  p=GetLocaleInfo_(\"*\",exception);\n  if (p == (const LocaleInfo *) NULL)\n    return((char **) NULL);\n  messages=(char **) AcquireQuantumMemory((size_t)\n    GetNumberOfNodesInSplayTree(locale_cache)+1UL,sizeof(*messages));\n  if (messages == (char **) NULL)\n    return((char **) NULL);\n  LockSemaphoreInfo(locale_semaphore);\n  p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  for (i=0; p != (const LocaleInfo *) NULL; )\n  {\n    if ((p->stealth == MagickFalse) &&\n        (GlobExpression(p->tag,pattern,MagickTrue) != MagickFalse))\n      messages[i++]=ConstantString(p->tag);\n    p=(const LocaleInfo *) GetNextValueInSplayTree(locale_cache);\n  }\n  UnlockSemaphoreInfo(locale_semaphore);\n  qsort((void *) messages,(size_t) i,sizeof(*messages),LocaleTagCompare);\n  messages[i]=(char *) NULL;\n  *number_messages=(size_t) i;\n  return(messages);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e M e s s a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleMessage() returns a message in the current locale that matches the\n%  supplied tag.\n%\n%  The format of the GetLocaleMessage method is:\n%\n%      const char *GetLocaleMessage(const char *tag)\n%\n%  A description of each parameter follows:\n%\n%    o tag: Return a message that matches this tag in the current locale.\n%\n*/\nMagickExport const char *GetLocaleMessage(const char *tag)\n{\n  char\n    name[MagickLocaleExtent];\n\n  const LocaleInfo\n    *locale_info;\n\n  ExceptionInfo\n    *exception;\n\n  if ((tag == (const char *) NULL) || (*tag == '\\0'))\n    return(tag);\n  exception=AcquireExceptionInfo();\n  (void) FormatLocaleString(name,MagickLocaleExtent,\"%s/\",tag);\n  locale_info=GetLocaleInfo_(name,exception);\n  exception=DestroyExceptionInfo(exception);\n  if (locale_info != (const LocaleInfo *) NULL)\n    return(locale_info->message);\n  return(tag);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  G e t L o c a l e O p t i o n s                                            %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleOptions() returns any Magick configuration messages associated\n%  with the specified filename.\n%\n%  The format of the GetLocaleOptions method is:\n%\n%      LinkedListInfo *GetLocaleOptions(const char *filename,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o filename: the locale file tag.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport LinkedListInfo *GetLocaleOptions(const char *filename,\n  ExceptionInfo *exception)\n{\n  char\n    path[MagickPathExtent];\n\n  const char\n    *element;\n\n  LinkedListInfo\n    *messages,\n    *paths;\n\n  StringInfo\n    *xml;\n\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) CopyMagickString(path,filename,MagickPathExtent);\n  /*\n    Load XML from configuration files to linked-list.\n  */\n  messages=NewLinkedList(0);\n  paths=GetConfigurePaths(filename,exception);\n  if (paths != (LinkedListInfo *) NULL)\n    {\n      ResetLinkedListIterator(paths);\n      element=(const char *) GetNextValueInLinkedList(paths);\n      while (element != (const char *) NULL)\n      {\n        (void) FormatLocaleString(path,MagickPathExtent,\"%s%s\",element,\n          filename);\n        (void) LogMagickEvent(LocaleEvent,GetMagickModule(),\n          \"Searching for locale file: \\\"%s\\\"\",path);\n        xml=ConfigureFileToStringInfo(path);\n        if (xml != (StringInfo *) NULL)\n          (void) AppendValueToLinkedList(messages,xml);\n        element=(const char *) GetNextValueInLinkedList(paths);\n      }\n      paths=DestroyLinkedList(paths,RelinquishMagickMemory);\n    }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n  {\n    char\n      *blob;\n\n    blob=(char *) NTResourceToBlob(filename);\n    if (blob != (char *) NULL)\n      {\n        xml=AcquireStringInfo(0);\n        SetStringInfoLength(xml,strlen(blob)+1);\n        SetStringInfoDatum(xml,(const unsigned char *) blob);\n        blob=(char *) RelinquishMagickMemory(blob);\n        SetStringInfoPath(xml,filename);\n        (void) AppendValueToLinkedList(messages,xml);\n      }\n  }\n#endif\n  ResetLinkedListIterator(messages);\n  return(messages);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t L o c a l e V a l u e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetLocaleValue() returns the message associated with the locale info.\n%\n%  The format of the GetLocaleValue method is:\n%\n%      const char *GetLocaleValue(const LocaleInfo *locale_info)\n%\n%  A description of each parameter follows:\n%\n%    o locale_info:  The locale info.\n%\n*/\nMagickExport const char *GetLocaleValue(const LocaleInfo *locale_info)\n{\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(locale_info != (LocaleInfo *) NULL);\n  assert(locale_info->signature == MagickCoreSignature);\n  return(locale_info->message);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   I s L o c a l e T r e e I n s t a n t i a t e d                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsLocaleTreeInstantiated() determines if the locale tree is instantiated.\n%  If not, it instantiates the tree and returns it.\n%\n%  The format of the IsLocaleInstantiated method is:\n%\n%      MagickBooleanType IsLocaleTreeInstantiated(ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType IsLocaleTreeInstantiated(ExceptionInfo *exception)\n{\n  if (locale_cache == (SplayTreeInfo *) NULL)\n    {\n      if (locale_semaphore == (SemaphoreInfo *) NULL)\n        ActivateSemaphoreInfo(&locale_semaphore);\n      LockSemaphoreInfo(locale_semaphore);\n      if (locale_cache == (SplayTreeInfo *) NULL)\n        {\n          char\n            *locale;\n\n          register const char\n            *p;\n\n          locale=(char *) NULL;\n          p=setlocale(LC_CTYPE,(const char *) NULL);\n          if (p != (const char *) NULL)\n            locale=ConstantString(p);\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LC_ALL\");\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LC_MESSAGES\");\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LC_CTYPE\");\n          if (locale == (char *) NULL)\n            locale=GetEnvironmentValue(\"LANG\");\n          if (locale == (char *) NULL)\n            locale=ConstantString(\"C\");\n          locale_cache=AcquireLocaleSplayTree(LocaleFilename,locale,exception);\n          locale=DestroyString(locale);\n        }\n      UnlockSemaphoreInfo(locale_semaphore);\n    }\n  return(locale_cache != (SplayTreeInfo *) NULL ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   I n t e r p r e t L o c a l e V a l u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InterpretLocaleValue() interprets the string as a floating point number in\n%  the \"C\" locale and returns its value as a double. If sentinal is not a null\n%  pointer, the method also sets the value pointed by sentinal to point to the\n%  first character after the number.\n%\n%  The format of the InterpretLocaleValue method is:\n%\n%      double InterpretLocaleValue(const char *value,char **sentinal)\n%\n%  A description of each parameter follows:\n%\n%    o value: the string value.\n%\n%    o sentinal:  if sentinal is not NULL, a pointer to the character after the\n%      last character used in the conversion is stored in the location\n%      referenced by sentinal.\n%\n*/\nMagickExport double InterpretLocaleValue(const char *magick_restrict string,\n  char **magick_restrict sentinal)\n{\n  char\n    *q;\n\n  double\n    value;\n\n  if ((*string == '0') && ((string[1] | 0x20)=='x'))\n    value=(double) strtoul(string,&q,16);\n  else\n    {\n#if defined(MAGICKCORE_LOCALE_SUPPORT) && defined(MAGICKCORE_HAVE_STRTOD_L)\n      locale_t\n        locale;\n\n      locale=AcquireCLocale();\n      if (locale == (locale_t) NULL)\n        value=strtod(string,&q);\n      else\n        value=strtod_l(string,&q,locale);\n#else\n      value=strtod(string,&q);\n#endif\n    }\n  if (sentinal != (char **) NULL)\n    *sentinal=q;\n  return(value);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  L i s t L o c a l e I n f o                                                %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ListLocaleInfo() lists the locale info to a file.\n%\n%  The format of the ListLocaleInfo method is:\n%\n%      MagickBooleanType ListLocaleInfo(FILE *file,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o file:  An pointer to a FILE.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType ListLocaleInfo(FILE *file,\n  ExceptionInfo *exception)\n{\n  const char\n    *path;\n\n  const LocaleInfo\n    **locale_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_messages;\n\n  if (file == (const FILE *) NULL)\n    file=stdout;\n  number_messages=0;\n  locale_info=GetLocaleInfoList(\"*\",&number_messages,exception);\n  if (locale_info == (const LocaleInfo **) NULL)\n    return(MagickFalse);\n  path=(const char *) NULL;\n  for (i=0; i < (ssize_t) number_messages; i++)\n  {\n    if (locale_info[i]->stealth != MagickFalse)\n      continue;\n    if ((path == (const char *) NULL) ||\n        (LocaleCompare(path,locale_info[i]->path) != 0))\n      {\n        if (locale_info[i]->path != (char *) NULL)\n          (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",locale_info[i]->path);\n        (void) FormatLocaleFile(file,\"Tag/Message\\n\");\n        (void) FormatLocaleFile(file,\n          \"-------------------------------------------------\"\n          \"------------------------------\\n\");\n      }\n    path=locale_info[i]->path;\n    (void) FormatLocaleFile(file,\"%s\\n\",locale_info[i]->tag);\n    if (locale_info[i]->message != (char *) NULL)\n      (void) FormatLocaleFile(file,\"  %s\",locale_info[i]->message);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  locale_info=(const LocaleInfo **)\n    RelinquishMagickMemory((void *) locale_info);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   L o a d L o c a l e C a c h e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LoadLocaleCache() loads the locale configurations which provides a mapping\n%  between locale attributes and a locale name.\n%\n%  The format of the LoadLocaleCache method is:\n%\n%      MagickBooleanType LoadLocaleCache(SplayTreeInfo *cache,const char *xml,\n%        const char *filename,const size_t depth,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o xml:  The locale list in XML format.\n%\n%    o filename:  The locale list filename.\n%\n%    o depth: depth of <include /> statements.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic void ChopLocaleComponents(char *path,const size_t components)\n{\n  register char\n    *p;\n\n  ssize_t\n    count;\n\n  if (*path == '\\0')\n    return;\n  p=path+strlen(path)-1;\n  if (*p == '/')\n    *p='\\0';\n  for (count=0; (count < (ssize_t) components) && (p > path); p--)\n    if (*p == '/')\n      {\n        *p='\\0';\n        count++;\n      }\n  if (count < (ssize_t) components)\n    *path='\\0';\n}\n\nstatic void LocaleFatalErrorHandler(\n  const ExceptionType magick_unused(severity),\n  const char *reason,const char *description)\n{\n  magick_unreferenced(severity);\n\n  if (reason == (char *) NULL)\n    return;\n  (void) FormatLocaleFile(stderr,\"%s: %s\",GetClientName(),reason);\n  if (description != (char *) NULL)\n    (void) FormatLocaleFile(stderr,\" (%s)\",description);\n  (void) FormatLocaleFile(stderr,\".\\n\");\n  (void) fflush(stderr);\n  exit(1);\n}\n\nstatic MagickBooleanType LoadLocaleCache(SplayTreeInfo *cache,const char *xml,\n  const char *filename,const char *locale,const size_t depth,ExceptionInfo *exception)\n{\n  char\n    keyword[MagickLocaleExtent],\n    message[MagickLocaleExtent],\n    tag[MagickLocaleExtent],\n    *token;\n\n  const char\n    *q;\n\n  FatalErrorHandler\n    fatal_handler;\n\n  LocaleInfo\n    *locale_info;\n\n  MagickStatusType\n    status;\n\n  register char\n    *p;\n\n  size_t\n    extent;\n\n  /*\n    Read the locale configure file.\n  */\n  (void) LogMagickEvent(ConfigureEvent,GetMagickModule(),\n    \"Loading locale configure file \\\"%s\\\" ...\",filename);\n  if (xml == (const char *) NULL)\n    return(MagickFalse);\n  status=MagickTrue;\n  locale_info=(LocaleInfo *) NULL;\n  *tag='\\0';\n  *message='\\0';\n  *keyword='\\0';\n  fatal_handler=SetFatalErrorHandler(LocaleFatalErrorHandler);\n  token=AcquireString(xml);\n  extent=strlen(token)+MagickPathExtent;\n  for (q=(char *) xml; *q != '\\0'; )\n  {\n    /*\n      Interpret XML.\n    */\n    GetNextToken(q,&q,extent,token);\n    if (*token == '\\0')\n      break;\n    (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n    if (LocaleNCompare(keyword,\"<!DOCTYPE\",9) == 0)\n      {\n        /*\n          Doctype element.\n        */\n        while ((LocaleNCompare(q,\"]>\",2) != 0) && (*q != '\\0'))\n        {\n          GetNextToken(q,&q,extent,token);\n          while (isspace((int) ((unsigned char) *q)) != 0)\n            q++;\n        }\n        continue;\n      }\n    if (LocaleNCompare(keyword,\"<!--\",4) == 0)\n      {\n        /*\n          Comment element.\n        */\n        while ((LocaleNCompare(q,\"->\",2) != 0) && (*q != '\\0'))\n        {\n          GetNextToken(q,&q,extent,token);\n          while (isspace((int) ((unsigned char) *q)) != 0)\n            q++;\n        }\n        continue;\n      }\n    if (LocaleCompare(keyword,\"<include\") == 0)\n      {\n        /*\n          Include element.\n        */\n        while (((*token != '/') && (*(token+1) != '>')) && (*q != '\\0'))\n        {\n          (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n          GetNextToken(q,&q,extent,token);\n          if (*token != '=')\n            continue;\n          GetNextToken(q,&q,extent,token);\n          if (LocaleCompare(keyword,\"locale\") == 0)\n            {\n              if (LocaleCompare(locale,token) != 0)\n                break;\n              continue;\n            }\n          if (LocaleCompare(keyword,\"file\") == 0)\n            {\n              if (depth > MagickMaxRecursionDepth)\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  ConfigureError,\"IncludeElementNestedTooDeeply\",\"`%s'\",token);\n              else\n                {\n                  char\n                    path[MagickPathExtent],\n                    *file_xml;\n\n                  *path='\\0';\n                  GetPathComponent(filename,HeadPath,path);\n                  if (*path != '\\0')\n                    (void) ConcatenateMagickString(path,DirectorySeparator,\n                      MagickPathExtent);\n                  if (*token == *DirectorySeparator)\n                    (void) CopyMagickString(path,token,MagickPathExtent);\n                  else\n                    (void) ConcatenateMagickString(path,token,MagickPathExtent);\n                  file_xml=FileToXML(path,~0UL);\n                  if (file_xml != (char *) NULL)\n                    {\n                      status&=LoadLocaleCache(cache,file_xml,path,locale,\n                        depth+1,exception);\n                      file_xml=DestroyString(file_xml);\n                    }\n                }\n            }\n        }\n        continue;\n      }\n    if (LocaleCompare(keyword,\"<locale\") == 0)\n      {\n        /*\n          Locale element.\n        */\n        while ((*token != '>') && (*q != '\\0'))\n        {\n          (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n          GetNextToken(q,&q,extent,token);\n          if (*token != '=')\n            continue;\n          GetNextToken(q,&q,extent,token);\n        }\n        continue;\n      }\n    if (LocaleCompare(keyword,\"</locale>\") == 0)\n      {\n        ChopLocaleComponents(tag,1);\n        (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n        continue;\n      }\n    if (LocaleCompare(keyword,\"<localemap>\") == 0)\n      continue;\n    if (LocaleCompare(keyword,\"</localemap>\") == 0)\n      continue;\n    if (LocaleCompare(keyword,\"<message\") == 0)\n      {\n        /*\n          Message element.\n        */\n        while ((*token != '>') && (*q != '\\0'))\n        {\n          (void) CopyMagickString(keyword,token,MagickLocaleExtent);\n          GetNextToken(q,&q,extent,token);\n          if (*token != '=')\n            continue;\n          GetNextToken(q,&q,extent,token);\n          if (LocaleCompare(keyword,\"name\") == 0)\n            {\n              (void) ConcatenateMagickString(tag,token,MagickLocaleExtent);\n              (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n            }\n        }\n        for (p=(char *) q; (*q != '<') && (*q != '\\0'); q++) ;\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          p++;\n        q--;\n        while ((isspace((int) ((unsigned char) *q)) != 0) && (q > p))\n          q--;\n        (void) CopyMagickString(message,p,MagickMin((size_t) (q-p+2),\n          MagickLocaleExtent));\n        locale_info=(LocaleInfo *) AcquireCriticalMemory(sizeof(*locale_info));\n        (void) memset(locale_info,0,sizeof(*locale_info));\n        locale_info->path=ConstantString(filename);\n        locale_info->tag=ConstantString(tag);\n        locale_info->message=ConstantString(message);\n        locale_info->signature=MagickCoreSignature;\n        status=AddValueToSplayTree(cache,locale_info->tag,locale_info);\n        if (status == MagickFalse)\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            locale_info->tag);\n        (void) ConcatenateMagickString(tag,message,MagickLocaleExtent);\n        (void) ConcatenateMagickString(tag,\"\\n\",MagickLocaleExtent);\n        q++;\n        continue;\n      }\n    if (LocaleCompare(keyword,\"</message>\") == 0)\n      {\n        ChopLocaleComponents(tag,2);\n        (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n        continue;\n      }\n    if (*keyword == '<')\n      {\n        /*\n          Subpath element.\n        */\n        if (*(keyword+1) == '?')\n          continue;\n        if (*(keyword+1) == '/')\n          {\n            ChopLocaleComponents(tag,1);\n            if (*tag != '\\0')\n              (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n            continue;\n          }\n        token[strlen(token)-1]='\\0';\n        (void) CopyMagickString(token,token+1,MagickLocaleExtent);\n        (void) ConcatenateMagickString(tag,token,MagickLocaleExtent);\n        (void) ConcatenateMagickString(tag,\"/\",MagickLocaleExtent);\n        continue;\n      }\n    GetNextToken(q,(const char **) NULL,extent,token);\n    if (*token != '=')\n      continue;\n  }\n  token=(char *) RelinquishMagickMemory(token);\n  (void) SetFatalErrorHandler(fatal_handler);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e C o m p a r e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleCompare() performs a case-insensitive comparison of two strings\n%  byte-by-byte, according to the ordering of the current locale encoding.\n%  LocaleCompare returns an integer greater than, equal to, or less than 0,\n%  if the string pointed to by p is greater than, equal to, or less than the\n%  string pointed to by q respectively.  The sign of a non-zero return value\n%  is determined by the sign of the difference between the values of the first\n%  pair of bytes that differ in the strings being compared.\n%\n%  The format of the LocaleCompare method is:\n%\n%      int LocaleCompare(const char *p,const char *q)\n%\n%  A description of each parameter follows:\n%\n%    o p: A pointer to a character string.\n%\n%    o q: A pointer to a character string to compare to p.\n%\n*/\nMagickExport int LocaleCompare(const char *p,const char *q)\n{\n  if (p == (char *) NULL)\n    {\n      if (q == (char *) NULL)\n        return(0);\n      return(-1);\n    }\n  if (q == (char *) NULL)\n    return(1);\n#if defined(MAGICKCORE_HAVE_STRCASECMP)\n  return(strcasecmp(p,q));\n#else\n  {\n    register int\n      c,\n      d;\n\n    for ( ; ; )\n    {\n      c=(int) *((unsigned char *) p);\n      d=(int) *((unsigned char *) q);\n      if ((c == 0) || (AsciiMap[c] != AsciiMap[d]))\n        break;\n      p++;\n      q++;\n    }\n    return(AsciiMap[c]-(int) AsciiMap[d]);\n  }\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e L o w e r                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleLower() transforms all of the characters in the supplied\n%  null-terminated string, changing all uppercase letters to lowercase.\n%\n%  The format of the LocaleLower method is:\n%\n%      void LocaleLower(char *string)\n%\n%  A description of each parameter follows:\n%\n%    o string: A pointer to the string to convert to lower-case Locale.\n%\n*/\nMagickExport void LocaleLower(char *string)\n{\n  register char\n    *q;\n\n  assert(string != (char *) NULL);\n  for (q=string; *q != '\\0'; q++)\n    *q=(char) LocaleLowercase((int) *q);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e L o w e r c a s e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleLowercase() convert to lowercase.\n%\n%  The format of the LocaleLowercase method is:\n%\n%      void LocaleLowercase(const int c)\n%\n%  A description of each parameter follows:\n%\n%    o If c is a uppercase letter, return its lowercase equivalent.\n%\n*/\nMagickExport int LocaleLowercase(const int c)\n{\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e N C o m p a r e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleNCompare() performs a case-insensitive comparison of two strings\n%  byte-by-byte, according to the ordering of the current locale encoding.\n%\n%  LocaleNCompare returns an integer greater than, equal to, or less than 0,\n%  if the string pointed to by p is greater than, equal to, or less than the\n%  string pointed to by q respectively.  The sign of a non-zero return value\n%  is determined by the sign of the difference between the values of the first\n%  pair of bytes that differ in the strings being compared.\n%\n%  The LocaleNCompare method makes the same comparison as LocaleCompare but\n%  looks at a maximum of n bytes.  Bytes following a null byte are not\n%  compared.\n%\n%  The format of the LocaleNCompare method is:\n%\n%      int LocaleNCompare(const char *p,const char *q,const size_t n)\n%\n%  A description of each parameter follows:\n%\n%    o p: A pointer to a character string.\n%\n%    o q: A pointer to a character string to compare to p.\n%\n%    o length: the number of characters to compare in strings p and q.\n%\n*/\nMagickExport int LocaleNCompare(const char *p,const char *q,const size_t length)\n{\n  if (p == (char *) NULL)\n    {\n      if (q == (char *) NULL)\n        return(0);\n      return(-1);\n    }\n  if (q == (char *) NULL)\n    return(1);\n#if defined(MAGICKCORE_HAVE_STRNCASECMP)\n  return(strncasecmp(p,q,length));\n#else\n  {\n    register int\n      c,\n      d;\n\n    register size_t\n      i;\n\n    for (i=length; i != 0; i--)\n    {\n      c=(int) *((unsigned char *) p);\n      d=(int) *((unsigned char *) q);\n      if (AsciiMap[c] != AsciiMap[d])\n        return(AsciiMap[c]-(int) AsciiMap[d]);\n      if (c == 0)\n        return(0);\n      p++;\n      q++;\n    }\n    return(0);\n  }\n#endif\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e U p p e r                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleUpper() transforms all of the characters in the supplied\n%  null-terminated string, changing all lowercase letters to uppercase.\n%\n%  The format of the LocaleUpper method is:\n%\n%      void LocaleUpper(char *string)\n%\n%  A description of each parameter follows:\n%\n%    o string: A pointer to the string to convert to upper-case Locale.\n%\n*/\nMagickExport void LocaleUpper(char *string)\n{\n  register char\n    *q;\n\n  assert(string != (char *) NULL);\n  for (q=string; *q != '\\0'; q++)\n    *q=(char) LocaleUppercase((int) *q);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   L o c a l e U p p e r c a s e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleUppercase() convert to uppercase.\n%\n%  The format of the LocaleUppercase method is:\n%\n%      void LocaleUppercase(const int c)\n%\n%  A description of each parameter follows:\n%\n%    o If c is a lowercase letter, return its uppercase equivalent.\n%\n*/\nMagickExport int LocaleUppercase(const int c)\n{\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(toupper_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(toupper((int) ((unsigned char) c)));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   L o c a l e C o m p o n e n t G e n e s i s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleComponentGenesis() instantiates the locale component.\n%\n%  The format of the LocaleComponentGenesis method is:\n%\n%      MagickBooleanType LocaleComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType LocaleComponentGenesis(void)\n{\n  if (locale_semaphore == (SemaphoreInfo *) NULL)\n    locale_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   L o c a l e C o m p o n e n t T e r m i n u s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  LocaleComponentTerminus() destroys the locale component.\n%\n%  The format of the LocaleComponentTerminus method is:\n%\n%      LocaleComponentTerminus(void)\n%\n*/\nMagickPrivate void LocaleComponentTerminus(void)\n{\n  if (locale_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&locale_semaphore);\n  LockSemaphoreInfo(locale_semaphore);\n  if (locale_cache != (SplayTreeInfo *) NULL)\n    locale_cache=DestroySplayTree(locale_cache);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  DestroyCLocale();\n#endif\n  UnlockSemaphoreInfo(locale_semaphore);\n  RelinquishSemaphoreInfo(&locale_semaphore);\n}\n"], "filenames": ["MagickCore/locale.c"], "buggy_code_start_loc": [1549], "buggy_code_end_loc": [1693], "fixing_code_start_loc": [1549], "fixing_code_end_loc": [1693], "type": "CWE-125", "message": "LocaleLowercase in MagickCore/locale.c in ImageMagick before 7.0.8-32 allows out-of-bounds access, leading to a SIGSEGV.", "other": {"cve": {"id": "CVE-2019-10714", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-02T21:29:00.250", "lastModified": "2021-04-28T19:08:56.787", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LocaleLowercase in MagickCore/locale.c in ImageMagick before 7.0.8-32 allows out-of-bounds access, leading to a SIGSEGV."}, {"lang": "es", "value": "En ImageMagick, en versiones anteriores a la 7.0.8-32, LocaleLowercase en MagickCore/locale.c permite un acceso fuera de l\u00edmties, conduciendo a un SIGSEGV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.9.10-32", "matchCriteriaId": "78CC3088-3ED5-4CED-B051-2A3B58EDA881"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-32", "matchCriteriaId": "44A0DE96-7F73-47AE-852D-3EC40C3A3D18"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/07eebcd72f45c8fd7563d3f9ec5d2bed48f65f36", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/58d9c46929ca0828edde34d263700c3a5fe8dc3c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/edc7d3035883ddca8413e4fe7689aa2e579ef04a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1495", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/07eebcd72f45c8fd7563d3f9ec5d2bed48f65f36"}}