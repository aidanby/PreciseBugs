{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * COPYRIGHT (C) 2006,2007\n * THE REGENTS OF THE UNIVERSITY OF MICHIGAN\n * ALL RIGHTS RESERVED\n *\n * Permission is granted to use, copy, create derivative works\n * and redistribute this software and such derivative works\n * for any purpose, so long as the name of The University of\n * Michigan is not used in any advertising or publicity\n * pertaining to the use of distribution of this software\n * without specific, written prior authorization.  If the\n * above copyright notice or any other identification of the\n * University of Michigan is included in any copy of any\n * portion of this software, then the disclaimer below must\n * also be included.\n *\n * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION\n * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY\n * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF\n * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING\n * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE\n * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE\n * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR\n * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN\n * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGES.\n */\n\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <arpa/inet.h>\n\n#include \"k5-platform.h\"\n#include \"k5-buf.h\"\n\n#include \"pkinit_crypto_openssl.h\"\n\nstatic void openssl_init(void);\n\nstatic krb5_error_code pkinit_init_pkinit_oids(pkinit_plg_crypto_context );\nstatic void pkinit_fini_pkinit_oids(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_dh_params(pkinit_plg_crypto_context );\nstatic void pkinit_fini_dh_params(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_certs(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_certs(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_init_pkcs11(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_pkcs11(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_encode_dh_params\n(BIGNUM *, BIGNUM *, BIGNUM *, unsigned char **, unsigned int *);\nstatic DH *pkinit_decode_dh_params\n(DH **, unsigned char **, unsigned int );\nstatic int pkinit_check_dh_params\n(BIGNUM * p1, BIGNUM * p2, BIGNUM * g1, BIGNUM * q1);\n\nstatic krb5_error_code pkinit_sign_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\n\nstatic krb5_error_code create_signature\n(unsigned char **, unsigned int *, unsigned char *, unsigned int,\n EVP_PKEY *pkey);\n\nstatic krb5_error_code pkinit_decode_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **decoded, unsigned int *decoded_len);\n\nstatic krb5_error_code decode_data\n(unsigned char **, unsigned int *, unsigned char *, unsigned int,\n EVP_PKEY *pkey, X509 *cert);\n\n#ifdef DEBUG_DH\nstatic void print_dh(DH *, char *);\nstatic void print_pubkey(BIGNUM *, char *);\n#endif\n\nstatic int prepare_enc_data\n(unsigned char *indata, int indata_len, unsigned char **outdata,\n int *outdata_len);\n\nstatic int openssl_callback (int, X509_STORE_CTX *);\nstatic int openssl_callback_ignore_crls (int, X509_STORE_CTX *);\n\nstatic int pkcs7_decrypt\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n PKCS7 *p7, BIO *bio);\n\nstatic BIO * pkcs7_dataDecode\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n PKCS7 *p7);\n\nstatic ASN1_OBJECT * pkinit_pkcs7type2oid\n(pkinit_plg_crypto_context plg_cryptoctx, int pkcs7_type);\n\nstatic krb5_error_code pkinit_create_sequence_of_principal_identifiers\n(krb5_context context, pkinit_plg_crypto_context plg_cryptoctx,\n pkinit_req_crypto_context req_cryptoctx,\n pkinit_identity_crypto_context id_cryptoctx,\n int type, krb5_pa_data ***e_data_out);\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code pkinit_find_private_key\n(pkinit_identity_crypto_context, CK_ATTRIBUTE_TYPE usage,\n CK_OBJECT_HANDLE *objp);\nstatic krb5_error_code pkinit_login\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n CK_TOKEN_INFO *tip);\nstatic krb5_error_code pkinit_open_session\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx);\nstatic void * pkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p);\nstatic CK_RV pkinit_C_UnloadModule(void *handle);\n#ifdef SILLYDECRYPT\nCK_RV pkinit_C_Decrypt\n(pkinit_identity_crypto_context id_cryptoctx,\n CK_BYTE_PTR pEncryptedData, CK_ULONG  ulEncryptedDataLen,\n CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen);\n#endif\n\nstatic krb5_error_code pkinit_sign_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **decoded_data, unsigned int *decoded_data_len);\n#endif  /* WITHOUT_PKCS11 */\n\nstatic krb5_error_code pkinit_sign_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **decoded_data, unsigned int *decoded_data_len);\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids);\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids);\n#ifdef LONGHORN_BETA_COMPAT\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len,\n                int is_longhorn_server);\n#else\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len);\n#endif\n\nstatic char *\npkinit_pkcs11_code_to_text(int err);\n\n\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n/* Use CMS support present in OpenSSL 1.0 and later. */\n#include <openssl/cms.h>\n#define pkinit_CMS_get0_content_signed(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_get0_content_data(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_free1_crls(_sk_x509crl) sk_X509_CRL_free((_sk_x509crl))\n#define pkinit_CMS_free1_certs(_sk_x509) sk_X509_free((_sk_x509))\n#define pkinit_CMS_SignerInfo_get_cert(_cms,_si,_x509_pp)       \\\n    CMS_SignerInfo_get0_algs(_si,NULL,_x509_pp,NULL,NULL)\n#else\n/* Fake up CMS support using PKCS7. */\n#define pkinit_CMS_free1_crls(_stack_of_x509crls)   /* Don't free these */\n#define pkinit_CMS_free1_certs(_stack_of_x509certs) /* Don't free these */\n#define CMS_NO_SIGNER_CERT_VERIFY PKCS7_NOVERIFY\n#define CMS_NOATTR PKCS7_NOATTR\n#define CMS_ContentInfo PKCS7\n#define CMS_SignerInfo PKCS7_SIGNER_INFO\n#define d2i_CMS_ContentInfo d2i_PKCS7\n#define CMS_get0_type(_p7) ((_p7)->type)\n#define pkinit_CMS_get0_content_signed(_p7) (&((_p7)->d.sign->contents->d.other->value.octet_string))\n#define pkinit_CMS_get0_content_data(_p7) (&((_p7)->d.other->value.octet_string))\n#define CMS_set1_signers_certs(_p7,_stack_of_x509,_uint)\n#define CMS_get0_SignerInfos PKCS7_get_signer_info\n#define stack_st_CMS_SignerInfo stack_st_PKCS7_SIGNER_INFO\n#undef  sk_CMS_SignerInfo_value\n#define sk_CMS_SignerInfo_value sk_PKCS7_SIGNER_INFO_value\n#define CMS_get0_eContentType(_p7) (_p7->d.sign->contents->type)\n#define CMS_verify PKCS7_verify\n#define CMS_get1_crls(_p7) (_p7->d.sign->crl)\n#define CMS_get1_certs(_p7) (_p7->d.sign->cert)\n#define CMS_ContentInfo_free(_p7) PKCS7_free(_p7)\n#define pkinit_CMS_SignerInfo_get_cert(_p7,_si,_x509_pp)        \\\n    (*_x509_pp) = PKCS7_cert_from_signer_info(_p7,_si)\n#endif\n\nstatic struct pkcs11_errstrings {\n    short code;\n    char *text;\n} pkcs11_errstrings[] = {\n    { 0x0,      \"ok\" },\n    { 0x1,      \"cancel\" },\n    { 0x2,      \"host memory\" },\n    { 0x3,      \"slot id invalid\" },\n    { 0x5,      \"general error\" },\n    { 0x6,      \"function failed\" },\n    { 0x7,      \"arguments bad\" },\n    { 0x8,      \"no event\" },\n    { 0x9,      \"need to create threads\" },\n    { 0xa,      \"cant lock\" },\n    { 0x10,     \"attribute read only\" },\n    { 0x11,     \"attribute sensitive\" },\n    { 0x12,     \"attribute type invalid\" },\n    { 0x13,     \"attribute value invalid\" },\n    { 0x20,     \"data invalid\" },\n    { 0x21,     \"data len range\" },\n    { 0x30,     \"device error\" },\n    { 0x31,     \"device memory\" },\n    { 0x32,     \"device removed\" },\n    { 0x40,     \"encrypted data invalid\" },\n    { 0x41,     \"encrypted data len range\" },\n    { 0x50,     \"function canceled\" },\n    { 0x51,     \"function not parallel\" },\n    { 0x54,     \"function not supported\" },\n    { 0x60,     \"key handle invalid\" },\n    { 0x62,     \"key size range\" },\n    { 0x63,     \"key type inconsistent\" },\n    { 0x64,     \"key not needed\" },\n    { 0x65,     \"key changed\" },\n    { 0x66,     \"key needed\" },\n    { 0x67,     \"key indigestible\" },\n    { 0x68,     \"key function not permitted\" },\n    { 0x69,     \"key not wrappable\" },\n    { 0x6a,     \"key unextractable\" },\n    { 0x70,     \"mechanism invalid\" },\n    { 0x71,     \"mechanism param invalid\" },\n    { 0x82,     \"object handle invalid\" },\n    { 0x90,     \"operation active\" },\n    { 0x91,     \"operation not initialized\" },\n    { 0xa0,     \"pin incorrect\" },\n    { 0xa1,     \"pin invalid\" },\n    { 0xa2,     \"pin len range\" },\n    { 0xa3,     \"pin expired\" },\n    { 0xa4,     \"pin locked\" },\n    { 0xb0,     \"session closed\" },\n    { 0xb1,     \"session count\" },\n    { 0xb3,     \"session handle invalid\" },\n    { 0xb4,     \"session parallel not supported\" },\n    { 0xb5,     \"session read only\" },\n    { 0xb6,     \"session exists\" },\n    { 0xb7,     \"session read only exists\" },\n    { 0xb8,     \"session read write so exists\" },\n    { 0xc0,     \"signature invalid\" },\n    { 0xc1,     \"signature len range\" },\n    { 0xd0,     \"template incomplete\" },\n    { 0xd1,     \"template inconsistent\" },\n    { 0xe0,     \"token not present\" },\n    { 0xe1,     \"token not recognized\" },\n    { 0xe2,     \"token write protected\" },\n    { 0xf0,     \"unwrapping key handle invalid\" },\n    { 0xf1,     \"unwrapping key size range\" },\n    { 0xf2,     \"unwrapping key type inconsistent\" },\n    { 0x100,    \"user already logged in\" },\n    { 0x101,    \"user not logged in\" },\n    { 0x102,    \"user pin not initialized\" },\n    { 0x103,    \"user type invalid\" },\n    { 0x104,    \"user another already logged in\" },\n    { 0x105,    \"user too many types\" },\n    { 0x110,    \"wrapped key invalid\" },\n    { 0x112,    \"wrapped key len range\" },\n    { 0x113,    \"wrapping key handle invalid\" },\n    { 0x114,    \"wrapping key size range\" },\n    { 0x115,    \"wrapping key type inconsistent\" },\n    { 0x120,    \"random seed not supported\" },\n    { 0x121,    \"random no rng\" },\n    { 0x130,    \"domain params invalid\" },\n    { 0x150,    \"buffer too small\" },\n    { 0x160,    \"saved state invalid\" },\n    { 0x170,    \"information sensitive\" },\n    { 0x180,    \"state unsaveable\" },\n    { 0x190,    \"cryptoki not initialized\" },\n    { 0x191,    \"cryptoki already initialized\" },\n    { 0x1a0,    \"mutex bad\" },\n    { 0x1a1,    \"mutex not locked\" },\n    { 0x200,    \"function rejected\" },\n    { -1,       NULL }\n};\n\n/* DH parameters */\nunsigned char pkinit_1024_dhprime[128] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nunsigned char pkinit_2048_dhprime[2048/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nunsigned char pkinit_4096_dhprime[4096/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\n    0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\n    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\n    0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\n    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\n    0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\n    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\n    0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\n    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\n    0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\n    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\n    0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\n    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\n    0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\n    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\n    0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\n    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\n    0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\n    0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\n    0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\n    0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\n    0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\n    0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\n    0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\n    0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\n    0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\n    0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\n    0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\n    0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\n    0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\n    0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\n    0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\n    0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nstatic int pkinit_oids_refs = 0;\n\nkrb5_error_code\npkinit_init_plg_crypto(pkinit_plg_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_plg_crypto_context ctx = NULL;\n\n    /* initialize openssl routines */\n    openssl_init();\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    pkiDebug(\"%s: initializing openssl crypto context at %p\\n\",\n             __FUNCTION__, ctx);\n    retval = pkinit_init_pkinit_oids(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_dh_params(ctx);\n    if (retval)\n        goto out;\n\n    *cryptoctx = ctx;\n\nout:\n    if (retval && ctx != NULL)\n        pkinit_fini_plg_crypto(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_plg_crypto(pkinit_plg_crypto_context cryptoctx)\n{\n    pkiDebug(\"%s: freeing context at %p\\n\", __FUNCTION__, cryptoctx);\n\n    if (cryptoctx == NULL)\n        return;\n    pkinit_fini_pkinit_oids(cryptoctx);\n    pkinit_fini_dh_params(cryptoctx);\n    free(cryptoctx);\n}\n\nkrb5_error_code\npkinit_init_identity_crypto(pkinit_identity_crypto_context *idctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_identity_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->identity = NULL;\n\n    retval = pkinit_init_certs(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_pkcs11(ctx);\n    if (retval)\n        goto out;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    *idctx = ctx;\n\nout:\n    if (retval) {\n        if (ctx)\n            pkinit_fini_identity_crypto(ctx);\n    }\n\n    return retval;\n}\n\nvoid\npkinit_fini_identity_crypto(pkinit_identity_crypto_context idctx)\n{\n    if (idctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing   ctx at %p\\n\", __FUNCTION__, idctx);\n    free(idctx->identity);\n    pkinit_fini_certs(idctx);\n    pkinit_fini_pkcs11(idctx);\n    free(idctx);\n}\n\nkrb5_error_code\npkinit_init_req_crypto(pkinit_req_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_req_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->dh = NULL;\n    ctx->received_cert = NULL;\n\n    *cryptoctx = ctx;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    retval = 0;\nout:\n    if (retval)\n        free(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_req_crypto(pkinit_req_crypto_context req_cryptoctx)\n{\n    if (req_cryptoctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing   ctx at %p\\n\", __FUNCTION__, req_cryptoctx);\n    if (req_cryptoctx->dh != NULL)\n        DH_free(req_cryptoctx->dh);\n    if (req_cryptoctx->received_cert != NULL)\n        X509_free(req_cryptoctx->received_cert);\n\n    free(req_cryptoctx);\n}\n\nstatic krb5_error_code\npkinit_init_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    int nid = 0;\n\n    /*\n     * If OpenSSL already knows about the OID, use the\n     * existing definition. Otherwise, create an OID object.\n     */\n#define CREATE_OBJ_IF_NEEDED(oid, vn, sn, ln)                           \\\n    nid = OBJ_txt2nid(oid);                                             \\\n    if (nid == NID_undef) {                                             \\\n        nid = OBJ_create(oid, sn, ln);                                  \\\n        if (nid == NID_undef) {                                         \\\n            pkiDebug(\"Error creating oid object for '%s'\\n\", oid);      \\\n            goto out;                                                   \\\n        }                                                               \\\n    }                                                                   \\\n    ctx->vn = OBJ_nid2obj(nid);\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.2\", id_pkinit_san,\n                         \"id-pkinit-san\", \"KRB5PrincipalName\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.1\", id_pkinit_authData,\n                         \"id-pkinit-authdata\", \"PKINIT signedAuthPack\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.2\", id_pkinit_DHKeyData,\n                         \"id-pkinit-DHKeyData\", \"PKINIT dhSignedData\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.3\", id_pkinit_rkeyData,\n                         \"id-pkinit-rkeyData\", \"PKINIT encKeyPack\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.4\", id_pkinit_KPClientAuth,\n                         \"id-pkinit-KPClientAuth\", \"PKINIT Client EKU\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.5\", id_pkinit_KPKdc,\n                         \"id-pkinit-KPKdc\", \"KDC EKU\");\n\n#if 0\n    CREATE_OBJ_IF_NEEDED(\"1.2.840.113549.1.7.1\", id_pkinit_authData9,\n                         \"id-pkcs7-data\", \"PKCS7 data\");\n#else\n    /* See note in pkinit_pkcs7type2oid() */\n    ctx->id_pkinit_authData9 = NULL;\n#endif\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.4.1.311.20.2.2\", id_ms_kp_sc_logon,\n                         \"id-ms-kp-sc-logon EKU\", \"Microsoft SmartCard Login EKU\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.4.1.311.20.2.3\", id_ms_san_upn,\n                         \"id-ms-san-upn\", \"Microsoft Universal Principal Name\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.5.7.3.1\", id_kp_serverAuth,\n                         \"id-kp-serverAuth EKU\", \"Server Authentication EKU\");\n\n    /* Success */\n    retval = 0;\n    pkinit_oids_refs++;\n\nout:\n    return retval;\n}\n\nstatic krb5_error_code\nget_cert(char *filename, X509 **retcert)\n{\n    X509 *cert = NULL;\n    BIO *tmp = NULL;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retcert == NULL)\n        return EINVAL;\n\n    *retcert = NULL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n\n    cert = (X509 *) PEM_read_bio_X509(tmp, NULL, NULL, NULL);\n    if (cert == NULL) {\n        retval = EIO;\n        pkiDebug(\"failed to read certificate from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retcert = cert;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstatic krb5_error_code\nget_key(char *filename, EVP_PKEY **retkey)\n{\n    EVP_PKEY *pkey = NULL;\n    BIO *tmp = NULL;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retkey == NULL)\n        return EINVAL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n    pkey = (EVP_PKEY *) PEM_read_bio_PrivateKey(tmp, NULL, NULL, NULL);\n    if (pkey == NULL) {\n        retval = EIO;\n        pkiDebug(\"failed to read private key from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retkey = pkey;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstatic void\npkinit_fini_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    /* Only call OBJ_cleanup once! */\n    if (--pkinit_oids_refs == 0)\n        OBJ_cleanup();\n}\n\nstatic krb5_error_code\npkinit_init_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n    plgctx->dh_1024 = DH_new();\n    if (plgctx->dh_1024 == NULL)\n        goto cleanup;\n    plgctx->dh_1024->p = BN_bin2bn(pkinit_1024_dhprime,\n                                   sizeof(pkinit_1024_dhprime), NULL);\n    if ((plgctx->dh_1024->g = BN_new()) == NULL ||\n        (plgctx->dh_1024->q = BN_new()) == NULL)\n        goto cleanup;\n    BN_set_word(plgctx->dh_1024->g, DH_GENERATOR_2);\n    BN_rshift1(plgctx->dh_1024->q, plgctx->dh_1024->p);\n\n    plgctx->dh_2048 = DH_new();\n    if (plgctx->dh_2048 == NULL)\n        goto cleanup;\n    plgctx->dh_2048->p = BN_bin2bn(pkinit_2048_dhprime,\n                                   sizeof(pkinit_2048_dhprime), NULL);\n    if ((plgctx->dh_2048->g = BN_new()) == NULL ||\n        (plgctx->dh_2048->q = BN_new()) == NULL)\n        goto cleanup;\n    BN_set_word(plgctx->dh_2048->g, DH_GENERATOR_2);\n    BN_rshift1(plgctx->dh_2048->q, plgctx->dh_2048->p);\n\n    plgctx->dh_4096 = DH_new();\n    if (plgctx->dh_4096 == NULL)\n        goto cleanup;\n    plgctx->dh_4096->p = BN_bin2bn(pkinit_4096_dhprime,\n                                   sizeof(pkinit_4096_dhprime), NULL);\n    if ((plgctx->dh_4096->g = BN_new()) == NULL ||\n        (plgctx->dh_4096->q = BN_new()) == NULL)\n        goto cleanup;\n    BN_set_word(plgctx->dh_4096->g, DH_GENERATOR_2);\n    BN_rshift1(plgctx->dh_4096->q, plgctx->dh_4096->p);\n\n    retval = 0;\n\ncleanup:\n    if (retval)\n        pkinit_fini_dh_params(plgctx);\n\n    return retval;\n}\n\nstatic void\npkinit_fini_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    if (plgctx->dh_1024 != NULL)\n        DH_free(plgctx->dh_1024);\n    if (plgctx->dh_2048 != NULL)\n        DH_free(plgctx->dh_2048);\n    if (plgctx->dh_4096 != NULL)\n        DH_free(plgctx->dh_4096);\n\n    plgctx->dh_1024 = plgctx->dh_2048 = plgctx->dh_4096 = NULL;\n}\n\nstatic krb5_error_code\npkinit_init_certs(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    int i;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++)\n        ctx->creds[i] = NULL;\n    ctx->my_certs = NULL;\n    ctx->cert_index = 0;\n    ctx->my_key = NULL;\n    ctx->trustedCAs = NULL;\n    ctx->intermediateCAs = NULL;\n    ctx->revoked = NULL;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_certs(pkinit_identity_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    if (ctx->my_certs != NULL)\n        sk_X509_pop_free(ctx->my_certs, X509_free);\n\n    if (ctx->my_key != NULL)\n        EVP_PKEY_free(ctx->my_key);\n\n    if (ctx->trustedCAs != NULL)\n        sk_X509_pop_free(ctx->trustedCAs, X509_free);\n\n    if (ctx->intermediateCAs != NULL)\n        sk_X509_pop_free(ctx->intermediateCAs, X509_free);\n\n    if (ctx->revoked != NULL)\n        sk_X509_CRL_pop_free(ctx->revoked, X509_CRL_free);\n}\n\nstatic krb5_error_code\npkinit_init_pkcs11(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n#ifndef WITHOUT_PKCS11\n    ctx->p11_module_name = strdup(PKCS11_MODNAME);\n    if (ctx->p11_module_name == NULL)\n        return retval;\n    ctx->p11_module = NULL;\n    ctx->slotid = PK_NOSLOT;\n    ctx->token_label = NULL;\n    ctx->cert_label = NULL;\n    ctx->session = CK_INVALID_HANDLE;\n    ctx->p11 = NULL;\n#endif\n    ctx->pkcs11_method = 0;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_pkcs11(pkinit_identity_crypto_context ctx)\n{\n#ifndef WITHOUT_PKCS11\n    if (ctx == NULL)\n        return;\n\n    if (ctx->p11 != NULL) {\n        if (ctx->session) {\n            ctx->p11->C_CloseSession(ctx->session);\n            ctx->session = CK_INVALID_HANDLE;\n        }\n        ctx->p11->C_Finalize(NULL_PTR);\n        ctx->p11 = NULL;\n    }\n    if (ctx->p11_module != NULL) {\n        pkinit_C_UnloadModule(ctx->p11_module);\n        ctx->p11_module = NULL;\n    }\n    free(ctx->p11_module_name);\n    free(ctx->token_label);\n    free(ctx->cert_id);\n    free(ctx->cert_label);\n#endif\n}\n\nkrb5_error_code\npkinit_identity_set_prompter(pkinit_identity_crypto_context id_cryptoctx,\n                             krb5_prompter_fct prompter,\n                             void *prompter_data)\n{\n    id_cryptoctx->prompter = prompter;\n    id_cryptoctx->prompter_data = prompter_data;\n\n    return 0;\n}\n\n/*helper function for creating pkinit ContentInfo*/\nstatic krb5_error_code\ncreate_contentinfo(krb5_context context,\n                   pkinit_plg_crypto_context plg_crypto_context,\n                   ASN1_OBJECT *oid, unsigned char *data, size_t data_len,\n                   PKCS7 **out_p7)\n{\n    krb5_error_code retval = EINVAL;\n    PKCS7 *inner_p7;\n    ASN1_TYPE *pkinit_data = NULL;\n\n    *out_p7 = NULL;\n    if ((inner_p7 = PKCS7_new()) == NULL)\n        goto cleanup;\n    if ((pkinit_data = ASN1_TYPE_new()) == NULL)\n        goto cleanup;\n    pkinit_data->type = V_ASN1_OCTET_STRING;\n    if ((pkinit_data->value.octet_string = ASN1_OCTET_STRING_new()) == NULL)\n        goto cleanup;\n    if (!ASN1_OCTET_STRING_set(pkinit_data->value.octet_string,\n                               (unsigned char *) data, data_len)) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to add pkcs7 data\\n\");\n        goto cleanup;\n    }\n    if (!PKCS7_set0_type_other(inner_p7, OBJ_obj2nid(oid), pkinit_data))\n        goto cleanup;\n    retval = 0;\n    *out_p7 = inner_p7;\n    inner_p7 = NULL;\n    pkinit_data = NULL;\ncleanup:\n    if (inner_p7)\n        PKCS7_free(inner_p7);\n    if (pkinit_data)\n        ASN1_TYPE_free(pkinit_data);\n    return retval;\n}\n\nkrb5_error_code\ncms_contentinfo_create(krb5_context context,                          /* IN */\n                       pkinit_plg_crypto_context plg_cryptoctx,       /* IN */\n                       pkinit_req_crypto_context req_cryptoctx,       /* IN */\n                       pkinit_identity_crypto_context id_cryptoctx,   /* IN */\n                       int cms_msg_type,\n                       unsigned char *data, unsigned int data_len,\n                       unsigned char **out_data, unsigned int *out_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    ASN1_OBJECT *oid = NULL;\n    PKCS7 *p7 = NULL;\n    unsigned char *p;\n\n    /* Pick the correct oid for the eContentInfo. */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n    retval = create_contentinfo(context, plg_cryptoctx, oid,\n                                data, data_len, &p7);\n    if (retval != 0)\n        goto cleanup;\n    *out_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*out_data_len)) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup;\n    }\n    retval = ENOMEM;\n    if ((p = *out_data = malloc(*out_data_len)) == NULL)\n        goto cleanup;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup;\n    }\n    retval = 0;\ncleanup:\n    if (p7)\n        PKCS7_free(p7);\n    if (oid)\n        ASN1_OBJECT_free(oid);\n    return retval;\n}\n\n\n\nkrb5_error_code\ncms_signeddata_create(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int cms_msg_type,\n                      int include_certchain,\n                      unsigned char *data,\n                      unsigned int data_len,\n                      unsigned char **signed_data,\n                      unsigned int *signed_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    PKCS7  *p7 = NULL, *inner_p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    PKCS7_SIGNER_INFO *p7si = NULL;\n    unsigned char *p;\n    STACK_OF(X509) * cert_stack = NULL;\n    ASN1_OCTET_STRING *digest_attr = NULL;\n    EVP_MD_CTX ctx, ctx2;\n    const EVP_MD *md_tmp = NULL;\n    unsigned char md_data[EVP_MAX_MD_SIZE], md_data2[EVP_MAX_MD_SIZE];\n    unsigned char *digestInfo_buf = NULL, *abuf = NULL;\n    unsigned int md_len, md_len2, alen, digestInfo_len;\n    STACK_OF(X509_ATTRIBUTE) * sk;\n    unsigned char *sig = NULL;\n    unsigned int sig_len = 0;\n    X509_ALGOR *alg = NULL;\n    ASN1_OCTET_STRING *digest = NULL;\n    unsigned int alg_len = 0, digest_len = 0;\n    unsigned char *y = NULL, *alg_buf = NULL, *digest_buf = NULL;\n    X509 *cert = NULL;\n    ASN1_OBJECT *oid = NULL;\n\n    /* Start creating PKCS7 data. */\n    if ((p7 = PKCS7_new()) == NULL)\n        goto cleanup;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto cleanup;\n    p7->d.sign = p7s;\n    if (!ASN1_INTEGER_set(p7s->version, 3))\n        goto cleanup;\n\n    /* pick the correct oid for the eContentInfo */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    if (id_cryptoctx->my_certs != NULL) {\n        /* create a cert chain that has at least the signer's certificate */\n        if ((cert_stack = sk_X509_new_null()) == NULL)\n            goto cleanup;\n\n        cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n        if (!include_certchain) {\n            pkiDebug(\"only including signer's certificate\\n\");\n            sk_X509_push(cert_stack, X509_dup(cert));\n        } else {\n            /* create a cert chain */\n            X509_STORE *certstore = NULL;\n            X509_STORE_CTX certctx;\n            STACK_OF(X509) *certstack = NULL;\n            char buf[DN_BUF_LEN];\n            unsigned int i = 0, size = 0;\n\n            if ((certstore = X509_STORE_new()) == NULL)\n                goto cleanup;\n            pkiDebug(\"building certificate chain\\n\");\n            X509_STORE_set_verify_cb_func(certstore, openssl_callback);\n            X509_STORE_CTX_init(&certctx, certstore, cert,\n                                id_cryptoctx->intermediateCAs);\n            X509_STORE_CTX_trusted_stack(&certctx, id_cryptoctx->trustedCAs);\n            if (!X509_verify_cert(&certctx)) {\n                int code = X509_STORE_CTX_get_error(&certctx);\n                const char *msg = X509_verify_cert_error_string(code);\n                pkiDebug(\"failed to create a certificate chain: %s\\n\", msg);\n                if (!sk_X509_num(id_cryptoctx->trustedCAs))\n                    pkiDebug(\"No trusted CAs found. Check your X509_anchors\\n\");\n                retval = KRB5_PREAUTH_FAILED;\n                krb5_set_error_message(context, retval,\n                                       _(\"Cannot create cert chain: %s\"), msg);\n                goto cleanup;\n            }\n            certstack = X509_STORE_CTX_get1_chain(&certctx);\n            size = sk_X509_num(certstack);\n            pkiDebug(\"size of certificate chain = %d\\n\", size);\n            for(i = 0; i < size - 1; i++) {\n                X509 *x = sk_X509_value(certstack, i);\n                X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n                sk_X509_push(cert_stack, X509_dup(x));\n            }\n            X509_STORE_CTX_cleanup(&certctx);\n            X509_STORE_free(certstore);\n            sk_X509_pop_free(certstack, X509_free);\n        }\n        p7s->cert = cert_stack;\n\n        /* fill-in PKCS7_SIGNER_INFO */\n        if ((p7si = PKCS7_SIGNER_INFO_new()) == NULL)\n            goto cleanup;\n        if (!ASN1_INTEGER_set(p7si->version, 1))\n            goto cleanup;\n        if (!X509_NAME_set(&p7si->issuer_and_serial->issuer,\n                           X509_get_issuer_name(cert)))\n            goto cleanup;\n        /* because ASN1_INTEGER_set is used to set a 'long' we will do\n         * things the ugly way. */\n        M_ASN1_INTEGER_free(p7si->issuer_and_serial->serial);\n        if (!(p7si->issuer_and_serial->serial =\n              M_ASN1_INTEGER_dup(X509_get_serialNumber(cert))))\n            goto cleanup;\n\n        /* will not fill-out EVP_PKEY because it's on the smartcard */\n\n        /* Set digest algs */\n        p7si->digest_alg->algorithm = OBJ_nid2obj(NID_sha1);\n\n        if (p7si->digest_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_alg->parameter);\n        if ((p7si->digest_alg->parameter = ASN1_TYPE_new()) == NULL)\n            goto cleanup;\n        p7si->digest_alg->parameter->type = V_ASN1_NULL;\n\n        /* Set sig algs */\n        if (p7si->digest_enc_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_enc_alg->parameter);\n        p7si->digest_enc_alg->algorithm = OBJ_nid2obj(NID_sha1WithRSAEncryption);\n        if (!(p7si->digest_enc_alg->parameter = ASN1_TYPE_new()))\n            goto cleanup;\n        p7si->digest_enc_alg->parameter->type = V_ASN1_NULL;\n\n        if (cms_msg_type == CMS_SIGN_DRAFT9){\n            /* don't include signed attributes for pa-type 15 request */\n            abuf = data;\n            alen = data_len;\n        } else {\n            /* add signed attributes */\n            /* compute sha1 digest over the EncapsulatedContentInfo */\n            EVP_MD_CTX_init(&ctx);\n            EVP_DigestInit_ex(&ctx, EVP_sha1(), NULL);\n            EVP_DigestUpdate(&ctx, data, data_len);\n            md_tmp = EVP_MD_CTX_md(&ctx);\n            EVP_DigestFinal_ex(&ctx, md_data, &md_len);\n\n            /* create a message digest attr */\n            digest_attr = ASN1_OCTET_STRING_new();\n            ASN1_OCTET_STRING_set(digest_attr, md_data, (int)md_len);\n            PKCS7_add_signed_attribute(p7si, NID_pkcs9_messageDigest,\n                                       V_ASN1_OCTET_STRING, (char *) digest_attr);\n\n            /* create a content-type attr */\n            PKCS7_add_signed_attribute(p7si, NID_pkcs9_contentType,\n                                       V_ASN1_OBJECT, oid);\n\n            /* create the signature over signed attributes. get DER encoded value */\n            /* This is the place where smartcard signature needs to be calculated */\n            sk = p7si->auth_attr;\n            alen = ASN1_item_i2d((ASN1_VALUE *) sk, &abuf,\n                                 ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\n            if (abuf == NULL)\n                goto cleanup2;\n        } /* signed attributes */\n\n#ifndef WITHOUT_PKCS11\n        /* Some tokens can only do RSAEncryption without sha1 hash */\n        /* to compute sha1WithRSAEncryption, encode the algorithm ID for the hash\n         * function and the hash value into an ASN.1 value of type DigestInfo\n         * DigestInfo::=SEQUENCE {\n         *  digestAlgorithm  AlgorithmIdentifier,\n         *  digest OCTET STRING }\n         */\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            pkiDebug(\"mech = CKM_RSA_PKCS\\n\");\n            EVP_MD_CTX_init(&ctx2);\n            /* if this is not draft9 request, include digest signed attribute */\n            if (cms_msg_type != CMS_SIGN_DRAFT9)\n                EVP_DigestInit_ex(&ctx2, md_tmp, NULL);\n            else\n                EVP_DigestInit_ex(&ctx2, EVP_sha1(), NULL);\n            EVP_DigestUpdate(&ctx2, abuf, alen);\n            EVP_DigestFinal_ex(&ctx2, md_data2, &md_len2);\n\n            alg = X509_ALGOR_new();\n            if (alg == NULL)\n                goto cleanup2;\n            alg->algorithm = OBJ_nid2obj(NID_sha1);\n            alg->parameter = NULL;\n            alg_len = i2d_X509_ALGOR(alg, NULL);\n            alg_buf = malloc(alg_len);\n            if (alg_buf == NULL)\n                goto cleanup2;\n\n            digest = ASN1_OCTET_STRING_new();\n            if (digest == NULL)\n                goto cleanup2;\n            ASN1_OCTET_STRING_set(digest, md_data2, (int)md_len2);\n            digest_len = i2d_ASN1_OCTET_STRING(digest, NULL);\n            digest_buf = malloc(digest_len);\n            if (digest_buf == NULL)\n                goto cleanup2;\n\n            digestInfo_len = ASN1_object_size(1, (int)(alg_len + digest_len),\n                                              V_ASN1_SEQUENCE);\n            y = digestInfo_buf = malloc(digestInfo_len);\n            if (digestInfo_buf == NULL)\n                goto cleanup2;\n            ASN1_put_object(&y, 1, (int)(alg_len + digest_len), V_ASN1_SEQUENCE,\n                            V_ASN1_UNIVERSAL);\n            i2d_X509_ALGOR(alg, &y);\n            i2d_ASN1_OCTET_STRING(digest, &y);\n#ifdef DEBUG_SIG\n            pkiDebug(\"signing buffer\\n\");\n            print_buffer(digestInfo_buf, digestInfo_len);\n            print_buffer_bin(digestInfo_buf, digestInfo_len, \"/tmp/pkcs7_tosign\");\n#endif\n            retval = pkinit_sign_data(context, id_cryptoctx, digestInfo_buf,\n                                      digestInfo_len, &sig, &sig_len);\n        } else\n#endif\n        {\n            pkiDebug(\"mech = %s\\n\",\n                     id_cryptoctx->pkcs11_method == 1 ? \"CKM_SHA1_RSA_PKCS\" : \"FS\");\n            retval = pkinit_sign_data(context, id_cryptoctx, abuf, alen,\n                                      &sig, &sig_len);\n        }\n#ifdef DEBUG_SIG\n        print_buffer(sig, sig_len);\n#endif\n        if (cms_msg_type != CMS_SIGN_DRAFT9 )\n            free(abuf);\n        if (retval)\n            goto cleanup2;\n\n        /* Add signature */\n        if (!ASN1_STRING_set(p7si->enc_digest, (unsigned char *) sig,\n                             (int)sig_len)) {\n            unsigned long err = ERR_peek_error();\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   ERR_error_string(err, NULL));\n            pkiDebug(\"failed to add a signed digest attribute\\n\");\n            goto cleanup2;\n        }\n        /* adder signer_info to pkcs7 signed */\n        if (!PKCS7_add_signer(p7, p7si))\n            goto cleanup2;\n    } /* we have a certificate */\n\n    /* start on adding data to the pkcs7 signed */\n    retval = create_contentinfo(context, plg_cryptoctx, oid,\n                                data, data_len, &inner_p7);\n    if (p7s->contents != NULL)\n        PKCS7_free(p7s->contents);\n    p7s->contents = inner_p7;\n\n    *signed_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*signed_data_len)) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup2;\n    }\n    retval = ENOMEM;\n    if ((p = *signed_data = malloc(*signed_data_len)) == NULL)\n        goto cleanup2;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup2;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    if (cms_msg_type == CMS_SIGN_CLIENT) {\n        print_buffer_bin(*signed_data, *signed_data_len,\n                         \"/tmp/client_pkcs7_signeddata\");\n    } else {\n        if (cms_msg_type == CMS_SIGN_SERVER) {\n            print_buffer_bin(*signed_data, *signed_data_len,\n                             \"/tmp/kdc_pkcs7_signeddata\");\n        } else {\n            print_buffer_bin(*signed_data, *signed_data_len,\n                             \"/tmp/draft9_pkcs7_signeddata\");\n        }\n    }\n#endif\n\ncleanup2:\n    if (p7si) {\n        if (cms_msg_type != CMS_SIGN_DRAFT9)\n            EVP_MD_CTX_cleanup(&ctx);\n#ifndef WITHOUT_PKCS11\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            EVP_MD_CTX_cleanup(&ctx2);\n            free(digest_buf);\n            free(digestInfo_buf);\n            free(alg_buf);\n            if (digest != NULL)\n                ASN1_OCTET_STRING_free(digest);\n        }\n#endif\n        if (alg != NULL)\n            X509_ALGOR_free(alg);\n    }\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    free(sig);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_signeddata_verify(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int cms_msg_type,\n                      int require_crl_checking,\n                      unsigned char *signed_data,\n                      unsigned int signed_data_len,\n                      unsigned char **data,\n                      unsigned int *data_len,\n                      unsigned char **authz_data,\n                      unsigned int *authz_data_len,\n                      int *is_signed)\n{\n    /*\n     * Warning: Since most openssl functions do not set retval, large chunks of\n     * this function assume that retval is always a failure and may go to\n     * cleanup without setting retval explicitly. Make sure retval is not set\n     * to 0 or errors such as signature verification failure may be converted\n     * to success with significant security consequences.\n     */\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    CMS_ContentInfo *cms = NULL;\n    BIO *out = NULL;\n    int flags = CMS_NO_SIGNER_CERT_VERIFY;\n    int valid_oid = 0;\n    unsigned int i = 0;\n    unsigned int vflags = 0, size = 0;\n    const unsigned char *p = signed_data;\n    STACK_OF(CMS_SignerInfo) *si_sk = NULL;\n    CMS_SignerInfo *si = NULL;\n    X509 *x = NULL;\n    X509_STORE *store = NULL;\n    X509_STORE_CTX cert_ctx;\n    STACK_OF(X509) *signerCerts = NULL;\n    STACK_OF(X509) *intermediateCAs = NULL;\n    STACK_OF(X509_CRL) *signerRevoked = NULL;\n    STACK_OF(X509_CRL) *revoked = NULL;\n    STACK_OF(X509) *verified_chain = NULL;\n    ASN1_OBJECT *oid = NULL;\n    const ASN1_OBJECT *type = NULL, *etype = NULL;\n    ASN1_OCTET_STRING **octets;\n    krb5_external_principal_identifier **krb5_verified_chain = NULL;\n    krb5_data *authz = NULL;\n    char buf[DN_BUF_LEN];\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(signed_data, signed_data_len,\n                     \"/tmp/client_received_pkcs7_signeddata\");\n#endif\n    if (is_signed)\n        *is_signed = 1;\n    /* Do this early enough to create the shadow OID for pkcs7-data if needed */\n    oid = pkinit_pkcs7type2oid(plgctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    /* decode received CMS message */\n    if ((cms = d2i_CMS_ContentInfo(NULL, &p, (int)signed_data_len)) == NULL) {\n        unsigned long err = ERR_peek_error();\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"%s: failed to decode message: %s\\n\",\n                 __FUNCTION__, ERR_error_string(err, NULL));\n        goto cleanup;\n    }\n    etype = CMS_get0_eContentType(cms);\n\n    /*\n     * Prior to 1.10 the MIT client incorrectly omitted the pkinit structure\n     * directly in a CMS ContentInfo rather than using SignedData with no\n     * signers. Handle that case.\n     */\n    type = CMS_get0_type(cms);\n    if (is_signed && !OBJ_cmp(type, oid)) {\n        unsigned char *d;\n        *is_signed = 0;\n        octets = pkinit_CMS_get0_content_data(cms);\n        if (!octets || ((*octets)->type != V_ASN1_OCTET_STRING)) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Invalid pkinit packet: octet string \"\n                                     \"expected\"));\n            goto cleanup;\n        }\n        *data_len = ASN1_STRING_length(*octets);\n        d = malloc(*data_len);\n        if (d == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        memcpy(d, ASN1_STRING_data(*octets),\n               *data_len);\n        *data = d;\n        goto out;\n    } else {\n        /* Verify that the received message is CMS SignedData message. */\n        if (OBJ_obj2nid(type) != NID_pkcs7_signed) {\n            pkiDebug(\"Expected id-signedData CMS msg (received type = %d)\\n\",\n                     OBJ_obj2nid(type));\n            krb5_set_error_message(context, retval, _(\"wrong oid\\n\"));\n            goto cleanup;\n        }\n    }\n\n    /* setup to verify X509 certificate used to sign CMS message */\n    if (!(store = X509_STORE_new()))\n        goto cleanup;\n\n    /* check if we are inforcing CRL checking */\n    vflags = X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\n    if (require_crl_checking)\n        X509_STORE_set_verify_cb_func(store, openssl_callback);\n    else\n        X509_STORE_set_verify_cb_func(store, openssl_callback_ignore_crls);\n    X509_STORE_set_flags(store, vflags);\n\n    /*\n     * Get the signer's information from the CMS message.  Match signer ID\n     * against anchors and intermediate CAs in case no certs are present in the\n     * SignedData.  If we start sending kdcPkId values in requests, we'll need\n     * to match against the source of that information too.\n     */\n    CMS_set1_signers_certs(cms, NULL, 0);\n    CMS_set1_signers_certs(cms, idctx->trustedCAs, CMS_NOINTERN);\n    CMS_set1_signers_certs(cms, idctx->intermediateCAs, CMS_NOINTERN);\n    if (((si_sk = CMS_get0_SignerInfos(cms)) == NULL) ||\n        ((si = sk_CMS_SignerInfo_value(si_sk, 0)) == NULL)) {\n        /* Not actually signed; anonymous case */\n        if (!is_signed)\n            goto cleanup;\n        *is_signed = 0;\n        /* We cannot use CMS_dataInit because there may be no digest */\n        octets = pkinit_CMS_get0_content_signed(cms);\n        if (octets)\n            out = BIO_new_mem_buf((*octets)->data, (*octets)->length);\n        if (out == NULL)\n            goto cleanup;\n    } else {\n        pkinit_CMS_SignerInfo_get_cert(cms, si, &x);\n        if (x == NULL)\n            goto cleanup;\n\n        /* create available CRL information (get local CRLs and include CRLs\n         * received in the CMS message\n         */\n        signerRevoked = CMS_get1_crls(cms);\n        if (idctx->revoked == NULL)\n            revoked = signerRevoked;\n        else if (signerRevoked == NULL)\n            revoked = idctx->revoked;\n        else {\n            size = sk_X509_CRL_num(idctx->revoked);\n            revoked = sk_X509_CRL_new_null();\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(idctx->revoked, i));\n            size = sk_X509_CRL_num(signerRevoked);\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(signerRevoked, i));\n        }\n\n        /* create available intermediate CAs chains (get local intermediateCAs and\n         * include the CA chain received in the CMS message\n         */\n        signerCerts = CMS_get1_certs(cms);\n        if (idctx->intermediateCAs == NULL)\n            intermediateCAs = signerCerts;\n        else if (signerCerts == NULL)\n            intermediateCAs = idctx->intermediateCAs;\n        else {\n            size = sk_X509_num(idctx->intermediateCAs);\n            intermediateCAs = sk_X509_new_null();\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs,\n                             sk_X509_value(idctx->intermediateCAs, i));\n            }\n            size = sk_X509_num(signerCerts);\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs, sk_X509_value(signerCerts, i));\n            }\n        }\n\n        /* initialize x509 context with the received certificate and\n         * trusted and intermediate CA chains and CRLs\n         */\n        if (!X509_STORE_CTX_init(&cert_ctx, store, x, intermediateCAs))\n            goto cleanup;\n\n        X509_STORE_CTX_set0_crls(&cert_ctx, revoked);\n\n        /* add trusted CAs certificates for cert verification */\n        if (idctx->trustedCAs != NULL)\n            X509_STORE_CTX_trusted_stack(&cert_ctx, idctx->trustedCAs);\n        else {\n            pkiDebug(\"unable to find any trusted CAs\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_CERTCHAIN\n        if (intermediateCAs != NULL) {\n            size = sk_X509_num(intermediateCAs);\n            pkiDebug(\"untrusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(intermediateCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (idctx->trustedCAs != NULL) {\n            size = sk_X509_num(idctx->trustedCAs);\n            pkiDebug(\"trusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(idctx->trustedCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (revoked != NULL) {\n            size = sk_X509_CRL_num(revoked);\n            pkiDebug(\"CRL chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_CRL *crl = sk_X509_CRL_value(revoked, i);\n                X509_NAME_oneline(X509_CRL_get_issuer(crl), buf, sizeof(buf));\n                pkiDebug(\"crls by CA #%d: %s\\n\", i , buf);\n            }\n        }\n#endif\n\n        i = X509_verify_cert(&cert_ctx);\n        if (i <= 0) {\n            int j = X509_STORE_CTX_get_error(&cert_ctx);\n\n            reqctx->received_cert = X509_dup(cert_ctx.current_cert);\n            switch(j) {\n            case X509_V_ERR_CERT_REVOKED:\n                retval = KRB5KDC_ERR_REVOKED_CERTIFICATE;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_CRL:\n                retval = KRB5KDC_ERR_REVOCATION_STATUS_UNKNOWN;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n                retval = KRB5KDC_ERR_CANT_VERIFY_CERTIFICATE;\n                break;\n            default:\n                retval = KRB5KDC_ERR_INVALID_CERTIFICATE;\n            }\n            if (reqctx->received_cert == NULL)\n                strlcpy(buf, \"(none)\", sizeof(buf));\n            else\n                X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                                  buf, sizeof(buf));\n            pkiDebug(\"problem with cert DN = %s (error=%d) %s\\n\", buf, j,\n                     X509_verify_cert_error_string(j));\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   X509_verify_cert_error_string(j));\n#ifdef DEBUG_CERTCHAIN\n            size = sk_X509_num(signerCerts);\n            pkiDebug(\"received cert chain of size %d\\n\", size);\n            for (j = 0; j < size; j++) {\n                X509 *tmp_cert = sk_X509_value(signerCerts, j);\n                X509_NAME_oneline(X509_get_subject_name(tmp_cert), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", j, buf);\n            }\n#endif\n        } else {\n            /* retrieve verified certificate chain */\n            if (cms_msg_type == CMS_SIGN_CLIENT || cms_msg_type == CMS_SIGN_DRAFT9)\n                verified_chain = X509_STORE_CTX_get1_chain(&cert_ctx);\n        }\n        X509_STORE_CTX_cleanup(&cert_ctx);\n        if (i <= 0)\n            goto cleanup;\n        out = BIO_new(BIO_s_mem());\n        if (cms_msg_type == CMS_SIGN_DRAFT9)\n            flags |= CMS_NOATTR;\n        if (CMS_verify(cms, NULL, store, NULL, out, flags) == 0) {\n            unsigned long err = ERR_peek_error();\n            switch(ERR_GET_REASON(err)) {\n            case PKCS7_R_DIGEST_FAILURE:\n                retval = KRB5KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED;\n                break;\n            case PKCS7_R_SIGNATURE_FAILURE:\n            default:\n                retval = KRB5KDC_ERR_INVALID_SIG;\n            }\n            pkiDebug(\"CMS Verification failure\\n\");\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   ERR_error_string(err, NULL));\n            goto cleanup;\n        }\n    } /* message was signed */\n    if (!OBJ_cmp(etype, oid))\n        valid_oid = 1;\n    else if (cms_msg_type == CMS_SIGN_DRAFT9) {\n        /*\n         * Various implementations of the pa-type 15 request use\n         * different OIDS.  We check that the returned object\n         * has any of the acceptable OIDs\n         */\n        ASN1_OBJECT *client_oid = NULL, *server_oid = NULL, *rsa_oid = NULL;\n        client_oid = pkinit_pkcs7type2oid(plgctx, CMS_SIGN_CLIENT);\n        server_oid = pkinit_pkcs7type2oid(plgctx, CMS_SIGN_SERVER);\n        rsa_oid = pkinit_pkcs7type2oid(plgctx, CMS_ENVEL_SERVER);\n        if (!OBJ_cmp(etype, client_oid) ||\n            !OBJ_cmp(etype, server_oid) ||\n            !OBJ_cmp(etype, rsa_oid))\n            valid_oid = 1;\n    }\n\n    if (valid_oid)\n        pkiDebug(\"CMS Verification successful\\n\");\n    else {\n        pkiDebug(\"wrong oid in eContentType\\n\");\n        print_buffer(etype->data,\n                     (unsigned int)etype->length);\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* transfer the data from CMS message into return buffer */\n    for (size = 0;;) {\n        int remain;\n        retval = ENOMEM;\n        if ((*data = realloc(*data, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        remain = BIO_read(out, &((*data)[size]), 1024 * 10);\n        if (remain <= 0)\n            break;\n        else\n            size += remain;\n    }\n    *data_len = size;\n\n    if (x) {\n        reqctx->received_cert = X509_dup(x);\n\n        /* generate authorization data */\n        if (cms_msg_type == CMS_SIGN_CLIENT || cms_msg_type == CMS_SIGN_DRAFT9) {\n\n            if (authz_data == NULL || authz_data_len == NULL)\n                goto out;\n\n            *authz_data = NULL;\n            retval = create_identifiers_from_stack(verified_chain,\n                                                   &krb5_verified_chain);\n            if (retval) {\n                pkiDebug(\"create_identifiers_from_stack failed\\n\");\n                goto cleanup;\n            }\n\n            retval = k5int_encode_krb5_td_trusted_certifiers((const krb5_external_principal_identifier **)krb5_verified_chain, &authz);\n            if (retval) {\n                pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_ASN1\n            print_buffer_bin((unsigned char *)authz->data, authz->length,\n                             \"/tmp/kdc_ad_initial_verified_cas\");\n#endif\n            *authz_data = malloc(authz->length);\n            if (*authz_data == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            memcpy(*authz_data, authz->data, authz->length);\n            *authz_data_len = authz->length;\n        }\n    }\nout:\n    retval = 0;\n\ncleanup:\n    if (out != NULL)\n        BIO_free(out);\n    if (store != NULL)\n        X509_STORE_free(store);\n    if (cms != NULL) {\n        if (signerCerts != NULL)\n            pkinit_CMS_free1_certs(signerCerts);\n        if (idctx->intermediateCAs != NULL && signerCerts)\n            sk_X509_free(intermediateCAs);\n        if (signerRevoked != NULL)\n            pkinit_CMS_free1_crls(signerRevoked);\n        if (idctx->revoked != NULL && signerRevoked)\n            sk_X509_CRL_free(revoked);\n        CMS_ContentInfo_free(cms);\n    }\n    if (verified_chain != NULL)\n        sk_X509_pop_free(verified_chain, X509_free);\n    if (krb5_verified_chain != NULL)\n        free_krb5_external_principal_identifier(&krb5_verified_chain);\n    if (authz != NULL)\n        krb5_free_data(context, authz);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_create(krb5_context context,\n                         pkinit_plg_crypto_context plgctx,\n                         pkinit_req_crypto_context reqctx,\n                         pkinit_identity_crypto_context idctx,\n                         krb5_preauthtype pa_type,\n                         int include_certchain,\n                         unsigned char *key_pack,\n                         unsigned int key_pack_len,\n                         unsigned char **out,\n                         unsigned int *out_len)\n{\n\n    krb5_error_code retval = ENOMEM;\n    PKCS7 *p7 = NULL;\n    BIO *in = NULL;\n    unsigned char *p = NULL, *signed_data = NULL, *enc_data = NULL;\n    int signed_data_len = 0, enc_data_len = 0, flags = PKCS7_BINARY;\n    STACK_OF(X509) *encerts = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int cms_msg_type;\n\n    /* create the PKCS7 SignedData portion of the PKCS7 EnvelopedData */\n    switch ((int)pa_type) {\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        cms_msg_type = CMS_SIGN_DRAFT9;\n        break;\n    case KRB5_PADATA_PK_AS_REQ:\n        cms_msg_type = CMS_ENVEL_SERVER;\n        break;\n    default:\n        goto cleanup;\n    }\n\n    retval = cms_signeddata_create(context, plgctx, reqctx, idctx,\n                                   cms_msg_type, include_certchain, key_pack, key_pack_len,\n                                   &signed_data, (unsigned int *)&signed_data_len);\n    if (retval) {\n        pkiDebug(\"failed to create pkcs7 signed data\\n\");\n        goto cleanup;\n    }\n\n    /* check we have client's certificate */\n    if (reqctx->received_cert == NULL) {\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    encerts = sk_X509_new_null();\n    sk_X509_push(encerts, reqctx->received_cert);\n\n    cipher = EVP_des_ede3_cbc();\n    in = BIO_new(BIO_s_mem());\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        prepare_enc_data(signed_data, signed_data_len, &enc_data,\n                         &enc_data_len);\n        retval = BIO_write(in, enc_data, enc_data_len);\n        if (retval != enc_data_len) {\n            pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n            goto cleanup;\n        }\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = BIO_write(in, signed_data, signed_data_len);\n        if (retval != signed_data_len) {\n            pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    p7 = PKCS7_encrypt(encerts, in, cipher, flags);\n    if (p7 == NULL) {\n        pkiDebug(\"failed to encrypt PKCS7 object\\n\");\n        retval = -1;\n        goto cleanup;\n    }\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        p7->d.enveloped->enc_data->content_type =\n            OBJ_nid2obj(NID_pkcs7_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        p7->d.enveloped->enc_data->content_type =\n            OBJ_nid2obj(NID_pkcs7_data);\n        break;\n        break;\n        break;\n        break;\n    }\n\n    *out_len = i2d_PKCS7(p7, NULL);\n    if (!*out_len || (p = *out = malloc(*out_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        pkiDebug(\"unable to write pkcs7 object\\n\");\n        goto cleanup;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(*out, *out_len, \"/tmp/kdc_enveloped_data\");\n#endif\n\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (in != NULL)\n        BIO_free(in);\n    free(signed_data);\n    free(enc_data);\n    if (encerts != NULL)\n        sk_X509_free(encerts);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_verify(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         krb5_preauthtype pa_type,\n                         int require_crl_checking,\n                         unsigned char *enveloped_data,\n                         unsigned int enveloped_data_len,\n                         unsigned char **data,\n                         unsigned int *data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7 *p7 = NULL;\n    BIO *out = NULL;\n    int i = 0;\n    unsigned int size = 0;\n    const unsigned char *p = enveloped_data;\n    unsigned int tmp_buf_len = 0, tmp_buf2_len = 0, vfy_buf_len = 0;\n    unsigned char *tmp_buf = NULL, *tmp_buf2 = NULL, *vfy_buf = NULL;\n    int msg_type = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(enveloped_data, enveloped_data_len,\n                     \"/tmp/client_envelopeddata\");\n#endif\n    /* decode received PKCS7 message */\n    if ((p7 = d2i_PKCS7(NULL, &p, (int)enveloped_data_len)) == NULL) {\n        unsigned long err = ERR_peek_error();\n        pkiDebug(\"failed to decode pkcs7\\n\");\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        goto cleanup;\n    }\n\n    /* verify that the received message is PKCS7 EnvelopedData message */\n    if (OBJ_obj2nid(p7->type) != NID_pkcs7_enveloped) {\n        pkiDebug(\"Expected id-enveloped PKCS7 msg (received type = %d)\\n\",\n                 OBJ_obj2nid(p7->type));\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* decrypt received PKCS7 message */\n    out = BIO_new(BIO_s_mem());\n    if (pkcs7_decrypt(context, id_cryptoctx, p7, out)) {\n        pkiDebug(\"PKCS7 decryption successful\\n\");\n    } else {\n        unsigned long err = ERR_peek_error();\n        if (err != 0)\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   ERR_error_string(err, NULL));\n        pkiDebug(\"PKCS7 decryption failed\\n\");\n        goto cleanup;\n    }\n\n    /* transfer the decoded PKCS7 SignedData message into a separate buffer */\n    for (;;) {\n        if ((tmp_buf = realloc(tmp_buf, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        i = BIO_read(out, &(tmp_buf[size]), 1024 * 10);\n        if (i <= 0)\n            break;\n        else\n            size += i;\n    }\n    tmp_buf_len = size;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(tmp_buf, tmp_buf_len, \"/tmp/client_enc_keypack\");\n#endif\n    /* verify PKCS7 SignedData message */\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REP:\n        msg_type = CMS_ENVEL_SERVER;\n\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        msg_type = CMS_SIGN_DRAFT9;\n        break;\n    default:\n        pkiDebug(\"%s: unrecognized pa_type = %d\\n\", __FUNCTION__, pa_type);\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    /*\n     * If this is the RFC style, wrap the signed data to make\n     * decoding easier in the verify routine.\n     * For draft9-compatible, we don't do anything because it\n     * is already wrapped.\n     */\n#ifdef LONGHORN_BETA_COMPAT\n    /*\n     * The Longhorn server returns the expected RFC-style data, but\n     * it is missing the sequence tag and length, so it requires\n     * special processing when wrapping.\n     * This will hopefully be fixed before the final release and\n     * this can all be removed.\n     */\n    if (msg_type == CMS_ENVEL_SERVER || longhorn == 1) {\n        retval = wrap_signeddata(tmp_buf, tmp_buf_len,\n                                 &tmp_buf2, &tmp_buf2_len, longhorn);\n        if (retval) {\n            pkiDebug(\"failed to encode signeddata\\n\");\n            goto cleanup;\n        }\n        vfy_buf = tmp_buf2;\n        vfy_buf_len = tmp_buf2_len;\n\n    } else {\n        vfy_buf = tmp_buf;\n        vfy_buf_len = tmp_buf_len;\n    }\n#else\n    if (msg_type == CMS_ENVEL_SERVER) {\n        retval = wrap_signeddata(tmp_buf, tmp_buf_len,\n                                 &tmp_buf2, &tmp_buf2_len);\n        if (retval) {\n            pkiDebug(\"failed to encode signeddata\\n\");\n            goto cleanup;\n        }\n        vfy_buf = tmp_buf2;\n        vfy_buf_len = tmp_buf2_len;\n\n    } else {\n        vfy_buf = tmp_buf;\n        vfy_buf_len = tmp_buf_len;\n    }\n#endif\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(vfy_buf, vfy_buf_len, \"/tmp/client_enc_keypack2\");\n#endif\n\n    retval = cms_signeddata_verify(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, msg_type,\n                                   require_crl_checking,\n                                   vfy_buf, vfy_buf_len,\n                                   data, data_len, NULL, NULL, NULL);\n\n    if (!retval)\n        pkiDebug(\"PKCS7 Verification Success\\n\");\n    else {\n        pkiDebug(\"PKCS7 Verification Failure\\n\");\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (out != NULL)\n        BIO_free(out);\n    free(tmp_buf);\n    free(tmp_buf2);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    if ((l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1)) >= 0) {\n        X509_EXTENSION *ext = NULL;\n        GENERAL_NAMES *ialt = NULL;\n        GENERAL_NAME *gen = NULL;\n        int ret = 0;\n        unsigned int num_sans = 0;\n\n        if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n            pkiDebug(\"%s: found no subject alt name extensions\\n\",\n                     __FUNCTION__);\n            goto cleanup;\n        }\n        num_sans = sk_GENERAL_NAME_num(ialt);\n\n        pkiDebug(\"%s: found %d subject alt name extension(s)\\n\",\n                 __FUNCTION__, num_sans);\n\n        /* OK, we're likely returning something. Allocate return values */\n        if (princs_ret != NULL) {\n            princs = calloc(num_sans + 1, sizeof(krb5_principal));\n            if (princs == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n        }\n        if (upn_ret != NULL) {\n            upns = calloc(num_sans + 1, sizeof(krb5_principal));\n            if (upns == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n        }\n        if (dns_ret != NULL) {\n            dnss = calloc(num_sans + 1, sizeof(*dnss));\n            if (dnss == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n        }\n\n        for (i = 0; i < num_sans; i++) {\n            krb5_data name = { 0, 0, NULL };\n\n            gen = sk_GENERAL_NAME_value(ialt, i);\n            switch (gen->type) {\n            case GEN_OTHERNAME:\n                name.length = gen->d.otherName->value->value.sequence->length;\n                name.data = (char *)gen->d.otherName->value->value.sequence->data;\n                if (princs != NULL\n                    && OBJ_cmp(plgctx->id_pkinit_san,\n                               gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                    print_buffer_bin((unsigned char *)name.data, name.length,\n                                     \"/tmp/pkinit_san\");\n#endif\n                    ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                    if (ret) {\n                        pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                                 __FUNCTION__);\n                    } else {\n                        p++;\n                        num_found++;\n                    }\n                } else if (upns != NULL\n                           && OBJ_cmp(plgctx->id_ms_san_upn,\n                                      gen->d.otherName->type_id) == 0) {\n                    /* Prevent abuse of embedded null characters. */\n                    if (memchr(name.data, '\\0', name.length))\n                        break;\n                    ret = krb5_parse_name(context, name.data, &upns[u]);\n                    if (ret) {\n                        pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                                 __FUNCTION__);\n                    } else {\n                        u++;\n                        num_found++;\n                    }\n                } else {\n                    pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                             __FUNCTION__);\n                    continue;\n                }\n\n                break;\n            case GEN_DNS:\n                if (dnss != NULL) {\n                    /* Prevent abuse of embedded null characters. */\n                    if (memchr(gen->d.dNSName->data, '\\0',\n                               gen->d.dNSName->length))\n                        break;\n                    pkiDebug(\"%s: found dns name = %s\\n\",\n                             __FUNCTION__, gen->d.dNSName->data);\n                    dnss[d] = (unsigned char *)\n                        strdup((char *)gen->d.dNSName->data);\n                    if (dnss[d] == NULL) {\n                        pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                                 __FUNCTION__);\n                    } else {\n                        d++;\n                        num_found++;\n                    }\n                }\n                break;\n            default:\n                pkiDebug(\"%s: SAN type = %d expecting %d\\n\",\n                         __FUNCTION__, gen->type, GEN_OTHERNAME);\n            }\n        }\n        sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n    }\n\n    retval = 0;\n    if (princs)\n        *princs_ret = princs;\n    if (upns)\n        *upn_ret = upns;\n    if (dnss)\n        *dns_ret = dnss;\n\ncleanup:\n    if (retval) {\n        if (princs != NULL) {\n            for (i = 0; princs[i] != NULL; i++)\n                krb5_free_principal(context, princs[i]);\n            free(princs);\n        }\n        if (upns != NULL) {\n            for (i = 0; upns[i] != NULL; i++)\n                krb5_free_principal(context, upns[i]);\n            free(upns);\n        }\n        if (dnss != NULL) {\n            for (i = 0; dnss[i] != NULL; i++)\n                free(dnss[i]);\n            free(dnss);\n        }\n    }\n    return retval;\n}\n\nkrb5_error_code\ncrypto_retrieve_signer_identity(krb5_context context,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                const char **identity)\n{\n    *identity = id_cryptoctx->identity;\n    if (*identity == NULL)\n        return ENOENT;\n    return 0;\n}\n\nkrb5_error_code\ncrypto_retrieve_cert_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          pkinit_identity_crypto_context idctx,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n\n    if (reqctx->received_cert == NULL) {\n        pkiDebug(\"%s: No certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    return crypto_retrieve_X509_sans(context, plgctx, reqctx,\n                                     reqctx->received_cert, princs_ret,\n                                     upn_ret, dns_ret);\n}\n\nkrb5_error_code\ncrypto_check_cert_eku(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int checking_kdc_cert,\n                      int allow_secondary_usage,\n                      int *valid_eku)\n{\n    char buf[DN_BUF_LEN];\n    int found_eku = 0;\n    krb5_error_code retval = EINVAL;\n    int i;\n\n    *valid_eku = 0;\n    if (reqctx->received_cert == NULL)\n        goto cleanup;\n\n    X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for EKUs in cert = %s\\n\", __FUNCTION__, buf);\n\n    if ((i = X509_get_ext_by_NID(reqctx->received_cert,\n                                 NID_ext_key_usage, -1)) >= 0) {\n        EXTENDED_KEY_USAGE *extusage;\n\n        extusage = X509_get_ext_d2i(reqctx->received_cert, NID_ext_key_usage,\n                                    NULL, NULL);\n        if (extusage) {\n            pkiDebug(\"%s: found eku info in the cert\\n\", __FUNCTION__);\n            for (i = 0; found_eku == 0 && i < sk_ASN1_OBJECT_num(extusage); i++) {\n                ASN1_OBJECT *tmp_oid;\n\n                tmp_oid = sk_ASN1_OBJECT_value(extusage, i);\n                pkiDebug(\"%s: checking eku %d of %d, allow_secondary = %d\\n\",\n                         __FUNCTION__, i+1, sk_ASN1_OBJECT_num(extusage),\n                         allow_secondary_usage);\n                if (checking_kdc_cert) {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPKdc) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_kp_serverAuth) == 0))\n                        found_eku = 1;\n                } else {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPClientAuth) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_ms_kp_sc_logon) == 0))\n                        found_eku = 1;\n                }\n            }\n        }\n        EXTENDED_KEY_USAGE_free(extusage);\n\n        if (found_eku) {\n            ASN1_BIT_STRING *usage = NULL;\n            pkiDebug(\"%s: found acceptable EKU, checking for digitalSignature\\n\", __FUNCTION__);\n\n            /* check that digitalSignature KeyUsage is present */\n            X509_check_ca(reqctx->received_cert);\n            if ((usage = X509_get_ext_d2i(reqctx->received_cert,\n                                          NID_key_usage, NULL, NULL))) {\n\n                if (!ku_reject(reqctx->received_cert,\n                               X509v3_KU_DIGITAL_SIGNATURE)) {\n                    pkiDebug(\"%s: found digitalSignature KU\\n\",\n                             __FUNCTION__);\n                    *valid_eku = 1;\n                } else\n                    pkiDebug(\"%s: didn't find digitalSignature KU\\n\",\n                             __FUNCTION__);\n            }\n            ASN1_BIT_STRING_free(usage);\n        }\n    }\n    retval = 0;\ncleanup:\n    pkiDebug(\"%s: returning retval %d, valid_eku %d\\n\",\n             __FUNCTION__, retval, *valid_eku);\n    return retval;\n}\n\nkrb5_error_code\npkinit_octetstring2key(krb5_context context,\n                       krb5_enctype etype,\n                       unsigned char *key,\n                       unsigned int dh_key_len,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval;\n    unsigned char *buf = NULL;\n    unsigned char md[SHA_DIGEST_LENGTH];\n    unsigned char counter;\n    size_t keybytes, keylength, offset;\n    krb5_data random_data;\n\n    if ((buf = malloc(dh_key_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    memset(buf, 0, dh_key_len);\n\n    counter = 0;\n    offset = 0;\n    do {\n        SHA_CTX c;\n\n        SHA1_Init(&c);\n        SHA1_Update(&c, &counter, 1);\n        SHA1_Update(&c, key, dh_key_len);\n        SHA1_Final(md, &c);\n\n        if (dh_key_len - offset < sizeof(md))\n            memcpy(buf + offset, md, dh_key_len - offset);\n        else\n            memcpy(buf + offset, md, sizeof(md));\n\n        offset += sizeof(md);\n        counter++;\n    } while (offset < dh_key_len);\n\n    key_block->magic = 0;\n    key_block->enctype = etype;\n\n    retval = krb5_c_keylengths(context, etype, &keybytes, &keylength);\n    if (retval)\n        goto cleanup;\n\n    key_block->length = keylength;\n    key_block->contents = malloc(keylength);\n    if (key_block->contents == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    random_data.length = keybytes;\n    random_data.data = (char *)buf;\n\n    retval = krb5_c_random_to_key(context, etype, &random_data, key_block);\n\ncleanup:\n    free(buf);\n    /* If this is an error return, free the allocated keyblock, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    return retval;\n}\n\n\n/**\n * Given an algorithm_identifier, this function returns the hash length\n * and EVP function associated with that algorithm.\n */\nstatic krb5_error_code\npkinit_alg_values(krb5_context context,\n                  const krb5_data *alg_id,\n                  size_t *hash_bytes,\n                  const EVP_MD *(**func)(void))\n{\n    *hash_bytes = 0;\n    *func = NULL;\n    if ((alg_id->length == krb5_pkinit_sha1_oid_len) &&\n        (0 == memcmp(alg_id->data, &krb5_pkinit_sha1_oid,\n                     krb5_pkinit_sha1_oid_len))) {\n        *hash_bytes = 20;\n        *func = &EVP_sha1;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha256_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha256_oid,\n                            krb5_pkinit_sha256_oid_len))) {\n        *hash_bytes = 32;\n        *func = &EVP_sha256;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha512_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha512_oid,\n                            krb5_pkinit_sha512_oid_len))) {\n        *hash_bytes = 64;\n        *func = &EVP_sha512;\n        return 0;\n    } else {\n        krb5_set_error_message(context, KRB5_ERR_BAD_S2K_PARAMS,\n                               \"Bad algorithm ID passed to PK-INIT KDF.\");\n        return KRB5_ERR_BAD_S2K_PARAMS;\n    }\n} /* pkinit_alg_values() */\n\n\n/* pkinit_alg_agility_kdf() --\n * This function generates a key using the KDF described in\n * draft_ietf_krb_wg_pkinit_alg_agility-04.txt.  The algorithm is\n * described as follows:\n *\n *     1.  reps = keydatalen (K) / hash length (H)\n *\n *     2.  Initialize a 32-bit, big-endian bit string counter as 1.\n *\n *     3.  For i = 1 to reps by 1, do the following:\n *\n *         -  Compute Hashi = H(counter || Z || OtherInfo).\n *\n *         -  Increment counter (modulo 2^32)\n *\n *     4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes.\n */\nkrb5_error_code\npkinit_alg_agility_kdf(krb5_context context,\n                       krb5_data *secret,\n                       krb5_data *alg_oid,\n                       krb5_const_principal party_u_info,\n                       krb5_const_principal party_v_info,\n                       krb5_enctype enctype,\n                       krb5_data *as_req,\n                       krb5_data *pk_as_rep,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval = 0;\n\n    unsigned int reps = 0;\n    uint32_t counter = 1;       /* Does this type work on Windows? */\n    size_t offset = 0;\n    size_t hash_len = 0;\n    size_t rand_len = 0;\n    size_t key_len = 0;\n    krb5_data random_data;\n    krb5_sp80056a_other_info other_info_fields;\n    krb5_pkinit_supp_pub_info supp_pub_info_fields;\n    krb5_data *other_info = NULL;\n    krb5_data *supp_pub_info = NULL;\n    krb5_algorithm_identifier alg_id;\n    const EVP_MD *(*EVP_func)(void);\n\n    /* initialize random_data here to make clean-up safe */\n    random_data.length = 0;\n    random_data.data = NULL;\n\n    /* allocate and initialize the key block */\n    key_block->magic = 0;\n    key_block->enctype = enctype;\n    if (0 != (retval = krb5_c_keylengths(context, enctype, &rand_len,\n                                         &key_len)))\n        goto cleanup;\n\n    random_data.length = rand_len;\n    key_block->length = key_len;\n\n    if (NULL == (key_block->contents = malloc(key_block->length))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    memset (key_block->contents, 0, key_block->length);\n\n    /* If this is anonymous pkinit, use the anonymous principle for party_u_info */\n    if (party_u_info && krb5_principal_compare_any_realm(context, party_u_info,\n                                                         krb5_anonymous_principal()))\n        party_u_info = (krb5_principal)krb5_anonymous_principal();\n\n    if (0 != (retval = pkinit_alg_values(context, alg_oid, &hash_len, &EVP_func)))\n        goto cleanup;\n\n    /* 1.  reps = keydatalen (K) / hash length (H) */\n    reps = key_block->length/hash_len;\n\n    /* ... and round up, if necessary */\n    if (key_block->length > (reps * hash_len))\n        reps++;\n\n    /* Allocate enough space in the random data buffer to hash directly into\n     * it, even if the last hash will make it bigger than the key length. */\n    if (NULL == (random_data.data = malloc(reps * hash_len))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Encode the ASN.1 octet string for \"SuppPubInfo\" */\n    supp_pub_info_fields.enctype = enctype;\n    supp_pub_info_fields.as_req = *as_req;\n    supp_pub_info_fields.pk_as_rep = *pk_as_rep;\n    if (0 != ((retval = encode_krb5_pkinit_supp_pub_info(&supp_pub_info_fields,\n                                                         &supp_pub_info))))\n        goto cleanup;\n\n    /* Now encode the ASN.1 octet string for \"OtherInfo\" */\n    memset(&alg_id, 0, sizeof alg_id);\n    alg_id.algorithm = *alg_oid; /*alias*/\n\n    other_info_fields.algorithm_identifier = alg_id;\n    other_info_fields.party_u_info = (krb5_principal) party_u_info;\n    other_info_fields.party_v_info = (krb5_principal) party_v_info;\n    other_info_fields.supp_pub_info = *supp_pub_info;\n    if (0 != (retval = encode_krb5_sp80056a_other_info(&other_info_fields, &other_info)))\n        goto cleanup;\n\n    /* 2.  Initialize a 32-bit, big-endian bit string counter as 1.\n     * 3.  For i = 1 to reps by 1, do the following:\n     *     -   Compute Hashi = H(counter || Z || OtherInfo).\n     *     -   Increment counter (modulo 2^32)\n     */\n    for (counter = 1; counter <= reps; counter++) {\n        EVP_MD_CTX c;\n        uint s = 0;\n        uint32_t be_counter = htonl(counter);\n\n        EVP_MD_CTX_init(&c);\n\n        /* -   Compute Hashi = H(counter || Z || OtherInfo). */\n        if (0 == EVP_DigestInit(&c, EVP_func())) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestInit() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        if ((0 == EVP_DigestUpdate(&c, &be_counter, 4)) ||\n            (0 == EVP_DigestUpdate(&c, secret->data, secret->length)) ||\n            (0 == EVP_DigestUpdate(&c, other_info->data, other_info->length))) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        /* 4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes. */\n        if (0 == EVP_DigestFinal(&c, (unsigned char *)(random_data.data + offset), &s)) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n        offset += s;\n        assert(s == hash_len);\n\n        EVP_MD_CTX_cleanup(&c);\n    }\n\n    retval = krb5_c_random_to_key(context, enctype, &random_data,\n                                  key_block);\n\ncleanup:\n    /* If this has been an error, free the allocated key_block, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    /* free other allocated resources, either way */\n    if (random_data.data)\n        free(random_data.data);\n    krb5_free_data(context, other_info);\n    krb5_free_data(context, supp_pub_info);\n\n    return retval;\n} /*pkinit_alg_agility_kdf() */\n\n/* Call DH_compute_key() and ensure that we left-pad short results instead of\n * leaving junk bytes at the end of the buffer. */\nstatic void\ncompute_dh(unsigned char *buf, int size, BIGNUM *server_pub_key, DH *dh)\n{\n    int len, pad;\n\n    len = DH_compute_key(buf, server_pub_key, dh);\n    assert(len >= 0 && len <= size);\n    if (len < size) {\n        pad = size - len;\n        memmove(buf + pad, buf, len);\n        memset(buf, 0, pad);\n    }\n}\n\nkrb5_error_code\nclient_create_dh(krb5_context context,\n                 pkinit_plg_crypto_context plg_cryptoctx,\n                 pkinit_req_crypto_context cryptoctx,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 int dh_size,\n                 unsigned char **dh_params,\n                 unsigned int *dh_params_len,\n                 unsigned char **dh_pubkey,\n                 unsigned int *dh_pubkey_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    unsigned char *buf = NULL;\n    int dh_err = 0;\n    ASN1_INTEGER *pub_key = NULL;\n\n    if (cryptoctx->dh == NULL) {\n        if ((cryptoctx->dh = DH_new()) == NULL)\n            goto cleanup;\n        if ((cryptoctx->dh->g = BN_new()) == NULL ||\n            (cryptoctx->dh->q = BN_new()) == NULL)\n            goto cleanup;\n\n        switch(dh_size) {\n        case 1024:\n            pkiDebug(\"client uses 1024 DH keys\\n\");\n            cryptoctx->dh->p = get_rfc2409_prime_1024(NULL);\n            break;\n        case 2048:\n            pkiDebug(\"client uses 2048 DH keys\\n\");\n            cryptoctx->dh->p = BN_bin2bn(pkinit_2048_dhprime,\n                                         sizeof(pkinit_2048_dhprime), NULL);\n            break;\n        case 4096:\n            pkiDebug(\"client uses 4096 DH keys\\n\");\n            cryptoctx->dh->p = BN_bin2bn(pkinit_4096_dhprime,\n                                         sizeof(pkinit_4096_dhprime), NULL);\n            break;\n        default:\n            goto cleanup;\n        }\n\n        BN_set_word((cryptoctx->dh->g), DH_GENERATOR_2);\n        BN_rshift1(cryptoctx->dh->q, cryptoctx->dh->p);\n    }\n\n    DH_generate_key(cryptoctx->dh);\n    DH_check(cryptoctx->dh, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"Warning: dh_check failed with %d\\n\", dh_err);\n        if (dh_err & DH_CHECK_P_NOT_PRIME)\n            pkiDebug(\"p value is not prime\\n\");\n        if (dh_err & DH_CHECK_P_NOT_SAFE_PRIME)\n            pkiDebug(\"p value is not a safe prime\\n\");\n        if (dh_err & DH_UNABLE_TO_CHECK_GENERATOR)\n            pkiDebug(\"unable to check the generator value\\n\");\n        if (dh_err & DH_NOT_SUITABLE_GENERATOR)\n            pkiDebug(\"the g value is not a generator\\n\");\n    }\n#ifdef DEBUG_DH\n    print_dh(cryptoctx->dh, \"client's DH params\\n\");\n    print_pubkey(cryptoctx->dh->pub_key, \"client's pub_key=\");\n#endif\n\n    DH_check_pub_key(cryptoctx->dh, cryptoctx->dh->pub_key, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"dh_check_pub_key failed with %d\\n\", dh_err);\n        goto cleanup;\n    }\n\n    /* pack DHparams */\n    /* aglo: usually we could just call i2d_DHparams to encode DH params\n     * however, PKINIT requires RFC3279 encoding and openssl does pkcs#3.\n     */\n    retval = pkinit_encode_dh_params(cryptoctx->dh->p, cryptoctx->dh->g,\n                                     cryptoctx->dh->q, dh_params, dh_params_len);\n    if (retval)\n        goto cleanup;\n\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    if ((pub_key = BN_to_ASN1_INTEGER(cryptoctx->dh->pub_key, NULL)) == NULL)\n        goto cleanup;\n    *dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    if ((buf = *dh_pubkey = malloc(*dh_pubkey_len)) == NULL) {\n        retval  = ENOMEM;\n        goto cleanup;\n    }\n    i2d_ASN1_INTEGER(pub_key, &buf);\n\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    retval = 0;\n    return retval;\n\ncleanup:\n    if (cryptoctx->dh != NULL)\n        DH_free(cryptoctx->dh);\n    cryptoctx->dh = NULL;\n    free(*dh_params);\n    *dh_params = NULL;\n    free(*dh_pubkey);\n    *dh_pubkey = NULL;\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    return retval;\n}\n\nkrb5_error_code\nclient_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *subjectPublicKey_data,\n                  unsigned int subjectPublicKey_length,\n                  unsigned char **client_key,\n                  unsigned int *client_key_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    BIGNUM *server_pub_key = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n    const unsigned char *p = NULL;\n\n    *client_key_len = DH_size(cryptoctx->dh);\n    if ((*client_key = malloc(*client_key_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    p = subjectPublicKey_data;\n    pub_key = d2i_ASN1_INTEGER(NULL, &p, (long)subjectPublicKey_length);\n    if (pub_key == NULL)\n        goto cleanup;\n    if ((server_pub_key = ASN1_INTEGER_to_BN(pub_key, NULL)) == NULL)\n        goto cleanup;\n\n    compute_dh(*client_key, *client_key_len, server_pub_key, cryptoctx->dh);\n#ifdef DEBUG_DH\n    print_pubkey(server_pub_key, \"server's pub_key=\");\n    pkiDebug(\"client computed key (%d)= \", *client_key_len);\n    print_buffer(*client_key, *client_key_len);\n#endif\n\n    retval = 0;\n    if (server_pub_key != NULL)\n        BN_free(server_pub_key);\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    return retval;\n\ncleanup:\n    free(*client_key);\n    *client_key = NULL;\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    return retval;\n}\n\nkrb5_error_code\nserver_check_dh(krb5_context context,\n                pkinit_plg_crypto_context cryptoctx,\n                pkinit_req_crypto_context req_cryptoctx,\n                pkinit_identity_crypto_context id_cryptoctx,\n                krb5_data *dh_params,\n                int minbits)\n{\n    DH *dh = NULL;\n    unsigned char *tmp = NULL;\n    int dh_prime_bits;\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n\n    tmp = (unsigned char *)dh_params->data;\n    dh = DH_new();\n    dh = pkinit_decode_dh_params(&dh, &tmp, dh_params->length);\n    if (dh == NULL) {\n        pkiDebug(\"failed to decode dhparams\\n\");\n        goto cleanup;\n    }\n\n    /* KDC SHOULD check to see if the key parameters satisfy its policy */\n    dh_prime_bits = BN_num_bits(dh->p);\n    if (minbits && dh_prime_bits < minbits) {\n        pkiDebug(\"client sent dh params with %d bits, we require %d\\n\",\n                 dh_prime_bits, minbits);\n        goto cleanup;\n    }\n\n    /* check dhparams is group 2 */\n    if (pkinit_check_dh_params(cryptoctx->dh_1024->p,\n                               dh->p, dh->g, dh->q) == 0) {\n        retval = 0;\n        goto cleanup;\n    }\n\n    /* check dhparams is group 14 */\n    if (pkinit_check_dh_params(cryptoctx->dh_2048->p,\n                               dh->p, dh->g, dh->q) == 0) {\n        retval = 0;\n        goto cleanup;\n    }\n\n    /* check dhparams is group 16 */\n    if (pkinit_check_dh_params(cryptoctx->dh_4096->p,\n                               dh->p, dh->g, dh->q) == 0) {\n        retval = 0;\n        goto cleanup;\n    }\n\ncleanup:\n    if (retval == 0)\n        req_cryptoctx->dh = dh;\n    else\n        DH_free(dh);\n\n    return retval;\n}\n\n/* kdc's dh function */\nkrb5_error_code\nserver_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *data,\n                  unsigned int data_len,\n                  unsigned char **dh_pubkey,\n                  unsigned int *dh_pubkey_len,\n                  unsigned char **server_key,\n                  unsigned int *server_key_len)\n{\n    krb5_error_code retval = ENOMEM;\n    DH *dh = NULL, *dh_server = NULL;\n    unsigned char *p = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n\n    *dh_pubkey = *server_key = NULL;\n    *dh_pubkey_len = *server_key_len = 0;\n\n    /* get client's received DH parameters that we saved in server_check_dh */\n    dh = cryptoctx->dh;\n\n    dh_server = DH_new();\n    if (dh_server == NULL)\n        goto cleanup;\n    dh_server->p = BN_dup(dh->p);\n    dh_server->g = BN_dup(dh->g);\n    dh_server->q = BN_dup(dh->q);\n\n    /* decode client's public key */\n    p = data;\n    pub_key = d2i_ASN1_INTEGER(NULL, (const unsigned char **)&p, (int)data_len);\n    if (pub_key == NULL)\n        goto cleanup;\n    dh->pub_key = ASN1_INTEGER_to_BN(pub_key, NULL);\n    if (dh->pub_key == NULL)\n        goto cleanup;\n    ASN1_INTEGER_free(pub_key);\n\n    if (!DH_generate_key(dh_server))\n        goto cleanup;\n\n    /* generate DH session key */\n    *server_key_len = DH_size(dh_server);\n    if ((*server_key = malloc(*server_key_len)) == NULL)\n        goto cleanup;\n    compute_dh(*server_key, *server_key_len, dh->pub_key, dh_server);\n\n#ifdef DEBUG_DH\n    print_dh(dh_server, \"client&server's DH params\\n\");\n    print_pubkey(dh->pub_key, \"client's pub_key=\");\n    print_pubkey(dh_server->pub_key, \"server's pub_key=\");\n    pkiDebug(\"server computed key=\");\n    print_buffer(*server_key, *server_key_len);\n#endif\n\n    /* KDC reply */\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    if ((pub_key = BN_to_ASN1_INTEGER(dh_server->pub_key, NULL)) == NULL)\n        goto cleanup;\n    *dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    if ((p = *dh_pubkey = malloc(*dh_pubkey_len)) == NULL)\n        goto cleanup;\n    i2d_ASN1_INTEGER(pub_key, &p);\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    retval = 0;\n\n    if (dh_server != NULL)\n        DH_free(dh_server);\n    return retval;\n\ncleanup:\n    if (dh_server != NULL)\n        DH_free(dh_server);\n    free(*dh_pubkey);\n    free(*server_key);\n\n    return retval;\n}\n\nstatic void\nopenssl_init()\n{\n    static int did_init = 0;\n\n    if (!did_init) {\n        /* initialize openssl routines */\n        CRYPTO_malloc_init();\n        ERR_load_crypto_strings();\n        OpenSSL_add_all_algorithms();\n        did_init++;\n    }\n}\n\nstatic krb5_error_code\npkinit_encode_dh_params(BIGNUM *p, BIGNUM *g, BIGNUM *q,\n                        unsigned char **buf, unsigned int *buf_len)\n{\n    krb5_error_code retval = ENOMEM;\n    int bufsize = 0, r = 0;\n    unsigned char *tmp = NULL;\n    ASN1_INTEGER *ap = NULL, *ag = NULL, *aq = NULL;\n\n    if ((ap = BN_to_ASN1_INTEGER(p, NULL)) == NULL)\n        goto cleanup;\n    if ((ag = BN_to_ASN1_INTEGER(g, NULL)) == NULL)\n        goto cleanup;\n    if ((aq = BN_to_ASN1_INTEGER(q, NULL)) == NULL)\n        goto cleanup;\n    bufsize = i2d_ASN1_INTEGER(ap, NULL);\n    bufsize += i2d_ASN1_INTEGER(ag, NULL);\n    bufsize += i2d_ASN1_INTEGER(aq, NULL);\n\n    r = ASN1_object_size(1, bufsize, V_ASN1_SEQUENCE);\n\n    tmp = *buf = malloc((size_t) r);\n    if (tmp == NULL)\n        goto cleanup;\n\n    ASN1_put_object(&tmp, 1, bufsize, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_INTEGER(ap, &tmp);\n    i2d_ASN1_INTEGER(ag, &tmp);\n    i2d_ASN1_INTEGER(aq, &tmp);\n\n    *buf_len = r;\n\n    retval = 0;\n\ncleanup:\n    if (ap != NULL)\n        ASN1_INTEGER_free(ap);\n    if (ag != NULL)\n        ASN1_INTEGER_free(ag);\n    if (aq != NULL)\n        ASN1_INTEGER_free(aq);\n\n    return retval;\n}\n\nstatic DH *\npkinit_decode_dh_params(DH ** a, unsigned char **pp, unsigned int len)\n{\n    ASN1_INTEGER ai, *aip = NULL;\n    long length = (long) len;\n\n    M_ASN1_D2I_vars(a, DH *, DH_new);\n\n    M_ASN1_D2I_Init();\n    M_ASN1_D2I_start_sequence();\n    aip = &ai;\n    ai.data = NULL;\n    ai.length = 0;\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        (*a)->p = ASN1_INTEGER_to_BN(aip, NULL);\n        if ((*a)->p == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n    }\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        (*a)->g = ASN1_INTEGER_to_BN(aip, NULL);\n        if ((*a)->g == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        (*a)->q = ASN1_INTEGER_to_BN(aip, NULL);\n        if ((*a)->q == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_end_sequence();\n    M_ASN1_D2I_Finish(a, DH_free, 0);\n\n}\n\nstatic krb5_error_code\npkinit_create_sequence_of_principal_identifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    int type,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n    krb5_external_principal_identifier **krb5_trusted_certifiers = NULL;\n    krb5_data *td_certifiers = NULL;\n    krb5_pa_data **pa_data = NULL;\n\n    switch(type) {\n    case TD_TRUSTED_CERTIFIERS:\n        retval = create_krb5_trustedCertifiers(context, plg_cryptoctx,\n                                               req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_trustedCertifiers failed\\n\");\n            goto cleanup;\n        }\n        break;\n    case TD_INVALID_CERTIFICATES:\n        retval = create_krb5_invalidCertificates(context, plg_cryptoctx,\n                                                 req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_invalidCertificates failed\\n\");\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    retval = k5int_encode_krb5_td_trusted_certifiers((const krb5_external_principal_identifier **)krb5_trusted_certifiers, &td_certifiers);\n    if (retval) {\n        pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)td_certifiers->data,\n                     td_certifiers->length, \"/tmp/kdc_td_certifiers\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = type;\n    pa_data[0]->length = td_certifiers->length;\n    pa_data[0]->contents = (krb5_octet *)td_certifiers->data;\n    *e_data_out = pa_data;\n    retval = 0;\n\ncleanup:\n    if (krb5_trusted_certifiers != NULL)\n        free_krb5_external_principal_identifier(&krb5_trusted_certifiers);\n    free(td_certifiers);\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_trusted_certifiers(krb5_context context,\n                                    pkinit_plg_crypto_context plg_cryptoctx,\n                                    pkinit_req_crypto_context req_cryptoctx,\n                                    pkinit_identity_crypto_context id_cryptoctx,\n                                    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_TRUSTED_CERTIFIERS, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_invalid_certificate(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_INVALID_CERTIFICATES, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_dh_parameters(krb5_context context,\n                               pkinit_plg_crypto_context plg_cryptoctx,\n                               pkinit_req_crypto_context req_cryptoctx,\n                               pkinit_identity_crypto_context id_cryptoctx,\n                               pkinit_plg_opts *opts,\n                               krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = ENOMEM;\n    unsigned int buf1_len = 0, buf2_len = 0, buf3_len = 0, i = 0;\n    unsigned char *buf1 = NULL, *buf2 = NULL, *buf3 = NULL;\n    krb5_pa_data **pa_data = NULL;\n    krb5_data *encoded_algId = NULL;\n    krb5_algorithm_identifier **algId = NULL;\n\n    if (opts->dh_min_bits > 4096)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        retval = pkinit_encode_dh_params(plg_cryptoctx->dh_1024->p,\n                                         plg_cryptoctx->dh_1024->g, plg_cryptoctx->dh_1024->q,\n                                         &buf1, &buf1_len);\n        if (retval)\n            goto cleanup;\n    }\n    if (opts->dh_min_bits <= 2048) {\n        retval = pkinit_encode_dh_params(plg_cryptoctx->dh_2048->p,\n                                         plg_cryptoctx->dh_2048->g, plg_cryptoctx->dh_2048->q,\n                                         &buf2, &buf2_len);\n        if (retval)\n            goto cleanup;\n    }\n    retval = pkinit_encode_dh_params(plg_cryptoctx->dh_4096->p,\n                                     plg_cryptoctx->dh_4096->g, plg_cryptoctx->dh_4096->q,\n                                     &buf3, &buf3_len);\n    if (retval)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        algId = malloc(4 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[3] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n        algId[2] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[2] == NULL)\n            goto cleanup;\n        algId[2]->parameters.data = malloc(buf1_len);\n        if (algId[2]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[2]->parameters.data, buf1, buf1_len);\n        algId[2]->parameters.length = buf1_len;\n        algId[2]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 2048) {\n        algId = malloc(3 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[2] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 4096) {\n        algId = malloc(2 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[1] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf3_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf3, buf3_len);\n        algId[0]->parameters.length = buf3_len;\n        algId[0]->algorithm = dh_oid;\n\n    }\n    retval = k5int_encode_krb5_td_dh_parameters((const krb5_algorithm_identifier **)algId, &encoded_algId);\n    if (retval)\n        goto cleanup;\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)encoded_algId->data,\n                     encoded_algId->length, \"/tmp/kdc_td_dh_params\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = TD_DH_PARAMETERS;\n    pa_data[0]->length = encoded_algId->length;\n    pa_data[0]->contents = (krb5_octet *)encoded_algId->data;\n    *e_data_out = pa_data;\n    retval = 0;\ncleanup:\n\n    free(buf1);\n    free(buf2);\n    free(buf3);\n    free(encoded_algId);\n\n    if (algId != NULL) {\n        while(algId[i] != NULL) {\n            free(algId[i]->parameters.data);\n            free(algId[i]);\n            i++;\n        }\n        free(algId);\n    }\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        goto cleanup;\n\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n\n    retval = 0;\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}\n\nstatic int\npkinit_check_dh_params(BIGNUM * p1, BIGNUM * p2, BIGNUM * g1, BIGNUM * q1)\n{\n    BIGNUM *g2 = NULL, *q2 = NULL;\n    int retval = -1;\n\n    if (!BN_cmp(p1, p2)) {\n        g2 = BN_new();\n        BN_set_word(g2, DH_GENERATOR_2);\n        if (!BN_cmp(g1, g2)) {\n            q2 = BN_new();\n            BN_rshift1(q2, p1);\n            if (!BN_cmp(q1, q2)) {\n                pkiDebug(\"good %d dhparams\\n\", BN_num_bits(p1));\n                retval = 0;\n            } else\n                pkiDebug(\"bad group 2 q dhparameter\\n\");\n            BN_free(q2);\n        } else\n            pkiDebug(\"bad g dhparameter\\n\");\n        BN_free(g2);\n    } else\n        pkiDebug(\"p is not well-known group 2 dhparameter\\n\");\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_process_td_dh_params(krb5_context context,\n                            pkinit_plg_crypto_context cryptoctx,\n                            pkinit_req_crypto_context req_cryptoctx,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            krb5_algorithm_identifier **algId,\n                            int *new_dh_size)\n{\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n    int i = 0, use_sent_dh = 0, ok = 0;\n\n    pkiDebug(\"dh parameters\\n\");\n\n    while (algId[i] != NULL) {\n        DH *dh = NULL;\n        unsigned char *tmp = NULL;\n        int dh_prime_bits = 0;\n\n        if (algId[i]->algorithm.length != dh_oid.length ||\n            memcmp(algId[i]->algorithm.data, dh_oid.data, dh_oid.length))\n            goto cleanup;\n\n        tmp = (unsigned char *)algId[i]->parameters.data;\n        dh = DH_new();\n        dh = pkinit_decode_dh_params(&dh, &tmp, algId[i]->parameters.length);\n        dh_prime_bits = BN_num_bits(dh->p);\n        pkiDebug(\"client sent %d DH bits server prefers %d DH bits\\n\",\n                 *new_dh_size, dh_prime_bits);\n        switch(dh_prime_bits) {\n        case 1024:\n            if (pkinit_check_dh_params(cryptoctx->dh_1024->p, dh->p,\n                                       dh->g, dh->q) == 0) {\n                *new_dh_size = 1024;\n                ok = 1;\n            }\n            break;\n        case 2048:\n            if (pkinit_check_dh_params(cryptoctx->dh_2048->p, dh->p,\n                                       dh->g, dh->q) == 0) {\n                *new_dh_size = 2048;\n                ok = 1;\n            }\n            break;\n        case 4096:\n            if (pkinit_check_dh_params(cryptoctx->dh_4096->p, dh->p,\n                                       dh->g, dh->q) == 0) {\n                *new_dh_size = 4096;\n                ok = 1;\n            }\n            break;\n        default:\n            break;\n        }\n        if (!ok) {\n            DH_check(dh, &retval);\n            if (retval != 0) {\n                pkiDebug(\"DH parameters provided by server are unacceptable\\n\");\n                retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n            }\n            else {\n                use_sent_dh = 1;\n                ok = 1;\n            }\n        }\n        if (!use_sent_dh)\n            DH_free(dh);\n        if (ok) {\n            if (req_cryptoctx->dh != NULL) {\n                DH_free(req_cryptoctx->dh);\n                req_cryptoctx->dh = NULL;\n            }\n            if (use_sent_dh)\n                req_cryptoctx->dh = dh;\n            break;\n        }\n        i++;\n    }\n\n    if (ok)\n        retval = 0;\n\ncleanup:\n    return retval;\n}\n\nstatic int\nopenssl_callback(int ok, X509_STORE_CTX * ctx)\n{\n#ifdef DEBUG\n    if (!ok) {\n        char buf[DN_BUF_LEN];\n\n        X509_NAME_oneline(X509_get_subject_name(ctx->current_cert), buf, sizeof(buf));\n        pkiDebug(\"cert = %s\\n\", buf);\n        pkiDebug(\"callback function: %d (%s)\\n\", ctx->error,\n                 X509_verify_cert_error_string(ctx->error));\n    }\n#endif\n    return ok;\n}\n\nstatic int\nopenssl_callback_ignore_crls(int ok, X509_STORE_CTX * ctx)\n{\n    if (!ok) {\n        switch (ctx->error) {\n        case X509_V_ERR_UNABLE_TO_GET_CRL:\n            return 1;\n        default:\n            return 0;\n        }\n    }\n    return ok;\n}\n\nstatic ASN1_OBJECT *\npkinit_pkcs7type2oid(pkinit_plg_crypto_context cryptoctx, int pkcs7_type)\n{\n    int nid;\n\n    switch (pkcs7_type) {\n    case CMS_SIGN_CLIENT:\n        return cryptoctx->id_pkinit_authData;\n    case CMS_SIGN_DRAFT9:\n        /*\n         * Delay creating this OID until we know we need it.\n         * It shadows an existing OpenSSL oid.  If it\n         * is created too early, it breaks things like\n         * the use of pkcs12 (which uses pkcs7 structures).\n         * We need this shadow version because our code\n         * depends on the \"other\" type to be unknown to the\n         * OpenSSL code.\n         */\n        if (cryptoctx->id_pkinit_authData9 == NULL) {\n            pkiDebug(\"%s: Creating shadow instance of pkcs7-data oid\\n\",\n                     __FUNCTION__);\n            nid = OBJ_create(\"1.2.840.113549.1.7.1\", \"id-pkcs7-data\",\n                             \"PKCS7 data\");\n            if (nid == NID_undef)\n                return NULL;\n            cryptoctx->id_pkinit_authData9 = OBJ_nid2obj(nid);\n        }\n        return cryptoctx->id_pkinit_authData9;\n    case CMS_SIGN_SERVER:\n        return cryptoctx->id_pkinit_DHKeyData;\n    case CMS_ENVEL_SERVER:\n        return cryptoctx->id_pkinit_rkeyData;\n    default:\n        return NULL;\n    }\n\n}\n\n#ifdef LONGHORN_BETA_COMPAT\n#if 0\n/*\n * This is a version that worked with Longhorn Beta 3.\n */\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len,\n                int is_longhorn_server)\n{\n\n    unsigned int orig_len = 0, oid_len = 0, tot_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    pkiDebug(\"%s: This is the Longhorn version and is_longhorn_server = %d\\n\",\n             __FUNCTION__, is_longhorn_server);\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tot_len = orig_len = ASN1_object_size(1, (int)data_len, V_ASN1_SEQUENCE);\n\n    if (is_longhorn_server == 0) {\n        /* Add the signedData OID and adjust lengths */\n        oid = OBJ_nid2obj(NID_pkcs7_signed);\n        oid_len = i2d_ASN1_OBJECT(oid, NULL);\n\n        tot_len = ASN1_object_size(1, (int)(orig_len+oid_len), V_ASN1_SEQUENCE);\n    }\n\n    p = *out = malloc(tot_len);\n    if (p == NULL) return -1;\n\n    if (is_longhorn_server == 0) {\n        ASN1_put_object(&p, 1, (int)(orig_len+oid_len),\n                        V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n        i2d_ASN1_OBJECT(oid, &p);\n\n        ASN1_put_object(&p, 1, (int)data_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n    } else {\n        ASN1_put_object(&p, 1, (int)data_len, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n    }\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n#else\n/*\n * This is a version that works with a patched Longhorn KDC.\n * (Which should match SP1 ??).\n */\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len,\n                int is_longhorn_server)\n{\n\n    unsigned int oid_len = 0, tot_len = 0, wrap_len = 0, tag_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    pkiDebug(\"%s: This is the Longhorn version and is_longhorn_server = %d\\n\",\n             __FUNCTION__, is_longhorn_server);\n\n    /* New longhorn is missing another sequence */\n    if (is_longhorn_server == 1)\n        wrap_len = ASN1_object_size(1, (int)(data_len), V_ASN1_SEQUENCE);\n    else\n        wrap_len = data_len;\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tag_len = ASN1_object_size(1, (int)wrap_len, V_ASN1_SEQUENCE);\n\n    /* Always add oid */\n    oid = OBJ_nid2obj(NID_pkcs7_signed);\n    oid_len = i2d_ASN1_OBJECT(oid, NULL);\n    oid_len += tag_len;\n\n    tot_len = ASN1_object_size(1, (int)(oid_len), V_ASN1_SEQUENCE);\n\n    p = *out = malloc(tot_len);\n    if (p == NULL)\n        return -1;\n\n    ASN1_put_object(&p, 1, (int)(oid_len),\n                    V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_OBJECT(oid, &p);\n\n    ASN1_put_object(&p, 1, (int)wrap_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n\n    /* Wrap in extra seq tag */\n    if (is_longhorn_server == 1) {\n        ASN1_put_object(&p, 1, (int)data_len, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n    }\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n\n#endif\n#else\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len)\n{\n\n    unsigned int orig_len = 0, oid_len = 0, tot_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tot_len = orig_len = ASN1_object_size(1, (int)data_len, V_ASN1_SEQUENCE);\n\n    /* Add the signedData OID and adjust lengths */\n    oid = OBJ_nid2obj(NID_pkcs7_signed);\n    oid_len = i2d_ASN1_OBJECT(oid, NULL);\n\n    tot_len = ASN1_object_size(1, (int)(orig_len+oid_len), V_ASN1_SEQUENCE);\n\n    p = *out = malloc(tot_len);\n    if (p == NULL) return -1;\n\n    ASN1_put_object(&p, 1, (int)(orig_len+oid_len),\n                    V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_OBJECT(oid, &p);\n\n    ASN1_put_object(&p, 1, (int)data_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n#endif\n\nstatic int\nprepare_enc_data(unsigned char *indata,\n                 int indata_len,\n                 unsigned char **outdata,\n                 int *outdata_len)\n{\n    int retval = -1;\n    ASN1_const_CTX c;\n    long length = indata_len;\n    int Ttag, Tclass;\n    long Tlen;\n\n    c.pp = (const unsigned char **)&indata;\n    c.q = *(const unsigned char **)&indata;\n    c.error = ERR_R_NESTED_ASN1_ERROR;\n    c.p= *(const unsigned char **)&indata;\n    c.max = (length == 0)?0:(c.p+length);\n\n    asn1_GetSequence(&c,&length);\n\n    ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen);\n    c.p += Tlen;\n    ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen);\n\n    asn1_const_Finish(&c);\n\n    *outdata = malloc((size_t)Tlen);\n    if (*outdata == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    memcpy(*outdata, c.p, (size_t)Tlen);\n    *outdata_len = Tlen;\n\n    retval = 0;\ncleanup:\n\n    return retval;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic void *\npkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p)\n{\n    void *handle;\n    CK_RV (*getflist)(CK_FUNCTION_LIST_PTR_PTR);\n\n    pkiDebug(\"loading module \\\"%s\\\"... \", modname);\n    handle = dlopen(modname, RTLD_NOW);\n    if (handle == NULL) {\n        pkiDebug(\"not found\\n\");\n        return NULL;\n    }\n    getflist = (CK_RV (*)(CK_FUNCTION_LIST_PTR_PTR)) dlsym(handle, \"C_GetFunctionList\");\n    if (getflist == NULL || (*getflist)(p11p) != CKR_OK) {\n        dlclose(handle);\n        pkiDebug(\"failed\\n\");\n        return NULL;\n    }\n    pkiDebug(\"ok\\n\");\n    return handle;\n}\n\nstatic CK_RV\npkinit_C_UnloadModule(void *handle)\n{\n    dlclose(handle);\n    return CKR_OK;\n}\n\nstatic krb5_error_code\npkinit_login(krb5_context context,\n             pkinit_identity_crypto_context id_cryptoctx,\n             CK_TOKEN_INFO *tip)\n{\n    krb5_data rdat;\n    char *prompt;\n    const char *warning;\n    krb5_prompt kprompt;\n    krb5_prompt_type prompt_type;\n    int r = 0;\n\n    if (tip->flags & CKF_PROTECTED_AUTHENTICATION_PATH) {\n        rdat.data = NULL;\n        rdat.length = 0;\n    } else {\n        if (tip->flags & CKF_USER_PIN_LOCKED)\n            warning = \" (Warning: PIN locked)\";\n        else if (tip->flags & CKF_USER_PIN_FINAL_TRY)\n            warning = \" (Warning: PIN final try)\";\n        else if (tip->flags & CKF_USER_PIN_COUNT_LOW)\n            warning = \" (Warning: PIN count low)\";\n        else\n            warning = \"\";\n        if (asprintf(&prompt, \"%.*s PIN%s\", (int) sizeof (tip->label),\n                     tip->label, warning) < 0)\n            return ENOMEM;\n        rdat.data = malloc(tip->ulMaxPinLen + 2);\n        rdat.length = tip->ulMaxPinLen + 1;\n\n        kprompt.prompt = prompt;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(context, &prompt_type);\n        r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                      NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(context, 0);\n        free(prompt);\n    }\n\n    if (r == 0) {\n        r = id_cryptoctx->p11->C_Login(id_cryptoctx->session, CKU_USER,\n                                       (u_char *) rdat.data, rdat.length);\n\n        if (r != CKR_OK) {\n            pkiDebug(\"C_Login: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            r = KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n    }\n    free(rdat.data);\n\n    return r;\n}\n\nstatic krb5_error_code\npkinit_open_session(krb5_context context,\n                    pkinit_identity_crypto_context cctx)\n{\n    CK_ULONG i, r;\n    unsigned char *cp;\n    CK_ULONG count = 0;\n    CK_SLOT_ID_PTR slotlist;\n    CK_TOKEN_INFO tinfo;\n\n    if (cctx->p11_module != NULL)\n        return 0; /* session already open */\n\n    /* Load module */\n    cctx->p11_module =\n        pkinit_C_LoadModule(cctx->p11_module_name, &cctx->p11);\n    if (cctx->p11_module == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    /* Init */\n    if ((r = cctx->p11->C_Initialize(NULL)) != CKR_OK) {\n        pkiDebug(\"C_Initialize: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /* Get the list of available slots */\n    if (cctx->slotid != PK_NOSLOT) {\n        /* A slot was specified, so that's the only one in the list */\n        count = 1;\n        slotlist = malloc(sizeof(CK_SLOT_ID));\n        slotlist[0] = cctx->slotid;\n    } else {\n        if (cctx->p11->C_GetSlotList(TRUE, NULL, &count) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        if (count == 0)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        slotlist = malloc(count * sizeof (CK_SLOT_ID));\n        if (cctx->p11->C_GetSlotList(TRUE, slotlist, &count) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /* Look for the given token label, or if none given take the first one */\n    for (i = 0; i < count; i++) {\n        /* Open session */\n        if ((r = cctx->p11->C_OpenSession(slotlist[i], CKF_SERIAL_SESSION,\n                                          NULL, NULL, &cctx->session)) != CKR_OK) {\n            pkiDebug(\"C_OpenSession: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        /* Get token info */\n        if ((r = cctx->p11->C_GetTokenInfo(slotlist[i], &tinfo)) != CKR_OK) {\n            pkiDebug(\"C_GetTokenInfo: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n        for (cp = tinfo.label + sizeof (tinfo.label) - 1;\n             *cp == '\\0' || *cp == ' '; cp--)\n            *cp = '\\0';\n        pkiDebug(\"open_session: slotid %d token \\\"%s\\\"\\n\",\n                 (int) slotlist[i], tinfo.label);\n        if (cctx->token_label == NULL ||\n            !strcmp((char *) cctx->token_label, (char *) tinfo.label))\n            break;\n        cctx->p11->C_CloseSession(cctx->session);\n    }\n    if (i >= count) {\n        free(slotlist);\n        pkiDebug(\"open_session: no matching token found\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    cctx->slotid = slotlist[i];\n    free(slotlist);\n    pkiDebug(\"open_session: slotid %d (%lu of %d)\\n\", (int) cctx->slotid,\n             i + 1, (int) count);\n\n    /* Login if needed */\n    if (tinfo.flags & CKF_LOGIN_REQUIRED)\n        r = pkinit_login(context, cctx, &tinfo);\n\n    return r;\n}\n\n/*\n * Look for a key that's:\n * 1. private\n * 2. capable of the specified operation (usually signing or decrypting)\n * 3. RSA (this may be wrong but it's all we can do for now)\n * 4. matches the id of the cert we chose\n *\n * You must call pkinit_get_certs before calling pkinit_find_private_key\n * (that's because we need the ID of the private key)\n *\n * pkcs11 says the id of the key doesn't have to match that of the cert, but\n * I can't figure out any other way to decide which key to use.\n *\n * We should only find one key that fits all the requirements.\n * If there are more than one, we just take the first one.\n */\n\nkrb5_error_code\npkinit_find_private_key(pkinit_identity_crypto_context id_cryptoctx,\n                        CK_ATTRIBUTE_TYPE usage,\n                        CK_OBJECT_HANDLE *objp)\n{\n    CK_OBJECT_CLASS cls;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_KEY_TYPE keytype;\n    unsigned int nattrs = 0;\n    int r;\n#ifdef PKINIT_USE_KEY_USAGE\n    CK_BBOOL true_false;\n#endif\n\n    cls = CKO_PRIVATE_KEY;\n    attrs[nattrs].type = CKA_CLASS;\n    attrs[nattrs].pValue = &cls;\n    attrs[nattrs].ulValueLen = sizeof cls;\n    nattrs++;\n\n#ifdef PKINIT_USE_KEY_USAGE\n    /*\n     * Some cards get confused if you try to specify a key usage,\n     * so don't, and hope for the best. This will fail if you have\n     * several keys with the same id and different usages but I have\n     * not seen this on real cards.\n     */\n    true_false = TRUE;\n    attrs[nattrs].type = usage;\n    attrs[nattrs].pValue = &true_false;\n    attrs[nattrs].ulValueLen = sizeof true_false;\n    nattrs++;\n#endif\n\n    keytype = CKK_RSA;\n    attrs[nattrs].type = CKA_KEY_TYPE;\n    attrs[nattrs].pValue = &keytype;\n    attrs[nattrs].ulValueLen = sizeof keytype;\n    nattrs++;\n\n    attrs[nattrs].type = CKA_ID;\n    attrs[nattrs].pValue = id_cryptoctx->cert_id;\n    attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n    nattrs++;\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"krb5_pkinit_sign_data: C_FindObjectsInit: %s\\n\",\n                 pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session, objp, 1, &count);\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    pkiDebug(\"found %d private keys (%s)\\n\", (int) count, pkinit_pkcs11_code_to_text(r));\n    if (r != CKR_OK || count < 1)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\nstatic krb5_error_code\npkinit_decode_data_fs(krb5_context context,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *data,\n                      unsigned int data_len,\n                      unsigned char **decoded_data,\n                      unsigned int *decoded_data_len)\n{\n    if (decode_data(decoded_data, decoded_data_len, data, data_len,\n                    id_cryptoctx->my_key, sk_X509_value(id_cryptoctx->my_certs,\n                                                        id_cryptoctx->cert_index)) <= 0) {\n        pkiDebug(\"failed to decode data\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\n/*\n * When using the ActivCard Linux pkcs11 library (v2.0.1), the decrypt function\n * fails.  By inserting an extra function call, which serves nothing but to\n * change the stack, we were able to work around the issue.  If the ActivCard\n * library is fixed in the future, this function can be inlined back into the\n * caller.\n */\nstatic CK_RV\npkinit_C_Decrypt(pkinit_identity_crypto_context id_cryptoctx,\n                 CK_BYTE_PTR pEncryptedData,\n                 CK_ULONG  ulEncryptedDataLen,\n                 CK_BYTE_PTR pData,\n                 CK_ULONG_PTR pulDataLen)\n{\n    CK_RV rv = CKR_OK;\n\n    rv = id_cryptoctx->p11->C_Decrypt(id_cryptoctx->session, pEncryptedData,\n                                      ulEncryptedDataLen, pData, pulDataLen);\n    if (rv == CKR_OK) {\n        pkiDebug(\"pData %p *pulDataLen %d\\n\", (void *) pData,\n                 (int) *pulDataLen);\n    }\n    return rv;\n}\n\nstatic krb5_error_code\npkinit_decode_data_pkcs11(krb5_context context,\n                          pkinit_identity_crypto_context id_cryptoctx,\n                          unsigned char *data,\n                          unsigned int data_len,\n                          unsigned char **decoded_data,\n                          unsigned int *decoded_data_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    unsigned char *cp;\n    int r;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_DECRYPT, &obj);\n\n    mech.mechanism = CKM_RSA_PKCS;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_DecryptInit(id_cryptoctx->session, &mech,\n                                              obj)) != CKR_OK) {\n        pkiDebug(\"C_DecryptInit: 0x%x\\n\", (int) r);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"data_len = %d\\n\", data_len);\n    cp = malloc((size_t) data_len);\n    if (cp == NULL)\n        return ENOMEM;\n    len = data_len;\n    pkiDebug(\"session %p edata %p edata_len %d data %p datalen @%p %d\\n\",\n             (void *) id_cryptoctx->session, (void *) data, (int) data_len,\n             (void *) cp, (void *) &len, (int) len);\n    if ((r = pkinit_C_Decrypt(id_cryptoctx, data, (CK_ULONG) data_len,\n                              cp, &len)) != CKR_OK) {\n        pkiDebug(\"C_Decrypt: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        if (r == CKR_BUFFER_TOO_SMALL)\n            pkiDebug(\"decrypt %d needs %d\\n\", (int) data_len, (int) len);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"decrypt %d -> %d\\n\", (int) data_len, (int) len);\n    *decoded_data_len = len;\n    *decoded_data = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_decode_data(krb5_context context,\n                   pkinit_identity_crypto_context id_cryptoctx,\n                   unsigned char *data,\n                   unsigned int data_len,\n                   unsigned char **decoded_data,\n                   unsigned int *decoded_data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_decode_data_fs(context, id_cryptoctx, data, data_len,\n                                       decoded_data, decoded_data_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_decode_data_pkcs11(context, id_cryptoctx, data,\n                                           data_len, decoded_data, decoded_data_len);\n#endif\n\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_sign_data_fs(krb5_context context,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    unsigned char *data,\n                    unsigned int data_len,\n                    unsigned char **sig,\n                    unsigned int *sig_len)\n{\n    if (create_signature(sig, sig_len, data, data_len,\n                         id_cryptoctx->my_key) != 0) {\n        pkiDebug(\"failed to create the signature\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code\npkinit_sign_data_pkcs11(krb5_context context,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        unsigned char *data,\n                        unsigned int data_len,\n                        unsigned char **sig,\n                        unsigned int *sig_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    unsigned char *cp;\n    int r;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_SIGN, &obj);\n\n    mech.mechanism = id_cryptoctx->mech;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_SignInit(id_cryptoctx->session, &mech,\n                                           obj)) != CKR_OK) {\n        pkiDebug(\"C_SignInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /*\n     * Key len would give an upper bound on sig size, but there's no way to\n     * get that. So guess, and if it's too small, re-malloc.\n     */\n    len = PK_SIGLEN_GUESS;\n    cp = malloc((size_t) len);\n    if (cp == NULL)\n        return ENOMEM;\n\n    r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                  (CK_ULONG) data_len, cp, &len);\n    if (r == CKR_BUFFER_TOO_SMALL || (r == CKR_OK && len >= PK_SIGLEN_GUESS)) {\n        free(cp);\n        pkiDebug(\"C_Sign realloc %d\\n\", (int) len);\n        cp = malloc((size_t) len);\n        r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                      (CK_ULONG) data_len, cp, &len);\n    }\n    if (r != CKR_OK) {\n        pkiDebug(\"C_Sign: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"sign %d -> %d\\n\", (int) data_len, (int) len);\n    *sig_len = len;\n    *sig = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_sign_data(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 unsigned char *data,\n                 unsigned int data_len,\n                 unsigned char **sig,\n                 unsigned int *sig_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (id_cryptoctx == NULL || id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_sign_data_fs(context, id_cryptoctx, data, data_len,\n                                     sig, sig_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_sign_data_pkcs11(context, id_cryptoctx, data, data_len,\n                                         sig, sig_len);\n#endif\n\n    return retval;\n}\n\n\nstatic krb5_error_code\ndecode_data(unsigned char **out_data, unsigned int *out_data_len,\n            unsigned char *data, unsigned int data_len,\n            EVP_PKEY *pkey, X509 *cert)\n{\n    krb5_error_code retval = ENOMEM;\n    unsigned char *buf = NULL;\n    int buf_len = 0;\n\n    if (cert && !X509_check_private_key(cert, pkey)) {\n        pkiDebug(\"private key does not match certificate\\n\");\n        goto cleanup;\n    }\n\n    buf_len = EVP_PKEY_size(pkey);\n    buf = malloc((size_t) buf_len + 10);\n    if (buf == NULL)\n        goto cleanup;\n\n#if OPENSSL_VERSION_NUMBER >= 0x00909000L\n    retval = EVP_PKEY_decrypt_old(buf, data, (int)data_len, pkey);\n#else\n    retval = EVP_PKEY_decrypt(buf, data, (int)data_len, pkey);\n#endif\n    if (retval <= 0) {\n        pkiDebug(\"unable to decrypt received data (len=%d)\\n\", data_len);\n        goto cleanup;\n    }\n    *out_data = buf;\n    *out_data_len = retval;\n\ncleanup:\n    if (retval == ENOMEM)\n        free(buf);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncreate_signature(unsigned char **sig, unsigned int *sig_len,\n                 unsigned char *data, unsigned int data_len, EVP_PKEY *pkey)\n{\n    krb5_error_code retval = ENOMEM;\n    EVP_MD_CTX md_ctx;\n\n    if (pkey == NULL)\n        return retval;\n\n    EVP_VerifyInit(&md_ctx, EVP_sha1());\n    EVP_SignUpdate(&md_ctx, data, data_len);\n    *sig_len = EVP_PKEY_size(pkey);\n    if ((*sig = malloc(*sig_len)) == NULL)\n        goto cleanup;\n    EVP_SignFinal(&md_ctx, *sig, sig_len, pkey);\n\n    retval = 0;\n\ncleanup:\n    EVP_MD_CTX_cleanup(&md_ctx);\n\n    return retval;\n}\n\n/*\n * Note:\n * This is not the routine the KDC uses to get its certificate.\n * This routine is intended to be called by the client\n * to obtain the KDC's certificate from some local storage\n * to be sent as a hint in its request to the KDC.\n */\nkrb5_error_code\npkinit_get_kdc_cert(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    req_cryptoctx->received_cert = NULL;\n    retval = 0;\n    return retval;\n}\n\nstatic char *\nreassemble_pkcs12_name(const char *filename)\n{\n    char *ret;\n\n    if (asprintf(&ret, \"PKCS12:%s\", filename) < 0)\n        return NULL;\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs12(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    X509 *x = NULL;\n    PKCS12 *p12 = NULL;\n    int ret;\n    FILE *fp;\n    EVP_PKEY *y = NULL;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's private key location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    fp = fopen(idopts->cert_filename, \"rb\");\n    if (fp == NULL) {\n        pkiDebug(\"Failed to open PKCS12 file '%s', error %d\\n\",\n                 idopts->cert_filename, errno);\n        goto cleanup;\n    }\n    set_cloexec_file(fp);\n\n    p12 = d2i_PKCS12_fp(fp, NULL);\n    fclose(fp);\n    if (p12 == NULL) {\n        pkiDebug(\"Failed to decode PKCS12 file '%s' contents\\n\",\n                 idopts->cert_filename);\n        goto cleanup;\n    }\n    /*\n     * Try parsing with no pass phrase first.  If that fails,\n     * prompt for the pass phrase and try again.\n     */\n    ret = PKCS12_parse(p12, NULL, &y, &x, NULL);\n    if (ret == 0) {\n        krb5_data rdat;\n        krb5_prompt kprompt;\n        krb5_prompt_type prompt_type;\n        int r = 0;\n        char prompt_string[128];\n        char prompt_reply[128];\n        char *prompt_prefix = _(\"Pass phrase for\");\n\n        pkiDebug(\"Initial PKCS12_parse with no password failed\\n\");\n\n        memset(prompt_reply, '\\0', sizeof(prompt_reply));\n        rdat.data = prompt_reply;\n        rdat.length = sizeof(prompt_reply);\n\n        r = snprintf(prompt_string, sizeof(prompt_string), \"%s %s\",\n                     prompt_prefix, idopts->cert_filename);\n        if (r >= (int) sizeof(prompt_string)) {\n            pkiDebug(\"Prompt string, '%s %s', is too long!\\n\",\n                     prompt_prefix, idopts->cert_filename);\n            goto cleanup;\n        }\n        kprompt.prompt = prompt_string;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(context, &prompt_type);\n        r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                      NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(context, 0);\n\n        ret = PKCS12_parse(p12, rdat.data, &y, &x, NULL);\n        if (ret == 0) {\n            pkiDebug(\"Seconde PKCS12_parse with password failed\\n\");\n            goto cleanup;\n        }\n    }\n    id_cryptoctx->creds[0] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[0] == NULL)\n        goto cleanup;\n    id_cryptoctx->creds[0]->name =\n        reassemble_pkcs12_name(idopts->cert_filename);\n    id_cryptoctx->creds[0]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[0]->cert_id = NULL;\n    id_cryptoctx->creds[0]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[0]->key = y;\n    id_cryptoctx->creds[1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    if (p12)\n        PKCS12_free(p12);\n    if (retval) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic char *\nreassemble_files_name(const char *certfile, const char *keyfile)\n{\n    char *ret;\n\n    if (keyfile != NULL) {\n        if (asprintf(&ret, \"FILE:%s,%s\", certfile, keyfile) < 0)\n            return NULL;\n    } else {\n        if (asprintf(&ret, \"FILE:%s\", certfile) < 0)\n            return NULL;\n    }\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_load_fs_cert_and_key(krb5_context context,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            char *certname,\n                            char *keyname,\n                            int cindex)\n{\n    krb5_error_code retval;\n    X509 *x = NULL;\n    EVP_PKEY *y = NULL;\n\n    /* load the certificate */\n    retval = get_cert(certname, &x);\n    if (retval != 0 || x == NULL) {\n        pkiDebug(\"failed to load user's certificate from '%s'\\n\", certname);\n        goto cleanup;\n    }\n    retval = get_key(keyname, &y);\n    if (retval != 0 || y == NULL) {\n        pkiDebug(\"failed to load user's private key from '%s'\\n\", keyname);\n        goto cleanup;\n    }\n\n    id_cryptoctx->creds[cindex] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[cindex] == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    id_cryptoctx->creds[cindex]->name = reassemble_files_name(certname,\n                                                              keyname);\n    id_cryptoctx->creds[cindex]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[cindex]->cert_id = NULL;\n    id_cryptoctx->creds[cindex]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[cindex]->key = y;\n    id_cryptoctx->creds[cindex+1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    if (retval) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_fs(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_opts *idopts,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's private key location\\n\",\n                 __FUNCTION__);\n        goto cleanup;\n    }\n\n    retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                         idopts->cert_filename,\n                                         idopts->key_filename, 0);\ncleanup:\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_dir(krb5_context context,\n                     pkinit_plg_crypto_context plg_cryptoctx,\n                     pkinit_req_crypto_context req_cryptoctx,\n                     pkinit_identity_opts *idopts,\n                     pkinit_identity_crypto_context id_cryptoctx,\n                     krb5_principal princ)\n{\n    krb5_error_code retval = ENOMEM;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char certname[1024];\n    char keyname[1024];\n    int i = 0, len;\n    char *dirname, *suf;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's certificate directory location\\n\",\n                 __FUNCTION__);\n        return ENOENT;\n    }\n\n    dirname = idopts->cert_filename;\n    d = opendir(dirname);\n    if (d == NULL)\n        return errno;\n\n    /*\n     * We'll assume that certs are named XXX.crt and the corresponding\n     * key is named XXX.key\n     */\n    while ((i < MAX_CREDS_ALLOWED) &&  (dentry = readdir(d)) != NULL) {\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        len = strlen(dentry->d_name);\n        if (len < 5)\n            continue;\n        suf = dentry->d_name + (len - 4);\n        if (strncmp(suf, \".crt\", 4) != 0)\n            continue;\n\n        /* Checked length */\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(certname)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            continue;\n        }\n        snprintf(certname, sizeof(certname), \"%s/%s\", dirname, dentry->d_name);\n        snprintf(keyname, sizeof(keyname), \"%s/%s\", dirname, dentry->d_name);\n        len = strlen(keyname);\n        keyname[len - 3] = 'k';\n        keyname[len - 2] = 'e';\n        keyname[len - 1] = 'y';\n\n        retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                             certname, keyname, i);\n        if (retval == 0) {\n            pkiDebug(\"%s: Successfully loaded cert (and key) for %s\\n\",\n                     __FUNCTION__, dentry->d_name);\n            i++;\n        }\n        else\n            continue;\n    }\n\n    if (i == 0) {\n        pkiDebug(\"%s: No cert/key pairs found in directory '%s'\\n\",\n                 __FUNCTION__, idopts->cert_filename);\n        retval = ENOENT;\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d)\n        closedir(d);\n\n    return retval;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic char *\nreassemble_pkcs11_name(pkinit_identity_opts *idopts)\n{\n    struct k5buf buf;\n    int n = 0;\n    char *ret;\n\n    krb5int_buf_init_dynamic(&buf);\n    krb5int_buf_add(&buf, \"PKCS11:\");\n    n = 0;\n    if (idopts->p11_module_name != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%smodule_name=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->p11_module_name);\n    }\n    if (idopts->token_label != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%stoken=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->token_label);\n    }\n    if (idopts->cert_label != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%scertlabel=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->cert_label);\n    }\n    if (idopts->cert_id_string != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%scertid=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->cert_id_string);\n    }\n    if (idopts->slotid != PK_NOSLOT) {\n        krb5int_buf_add_fmt(&buf, \"%sslotid=%ld\",\n                            n++ ? \",\" : \"\",\n                            (long)idopts->slotid);\n    }\n    if (krb5int_buf_len(&buf) >= 0)\n        ret = strdup(krb5int_buf_data(&buf));\n    else\n        ret = NULL;\n    krb5int_free_buf(&buf);\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs11(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n#ifdef PKINIT_USE_MECH_LIST\n    CK_MECHANISM_TYPE_PTR mechp;\n    CK_MECHANISM_INFO info;\n#endif\n    CK_OBJECT_CLASS cls;\n    CK_OBJECT_HANDLE obj;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_CERTIFICATE_TYPE certtype;\n    CK_BYTE_PTR cert = NULL, cert_id;\n    const unsigned char *cp;\n    int i, r;\n    unsigned int nattrs;\n    X509 *x = NULL;\n\n    /* Copy stuff from idopts -> id_cryptoctx */\n    if (idopts->p11_module_name != NULL) {\n        id_cryptoctx->p11_module_name = strdup(idopts->p11_module_name);\n        if (id_cryptoctx->p11_module_name == NULL)\n            return ENOMEM;\n    }\n    if (idopts->token_label != NULL) {\n        id_cryptoctx->token_label = strdup(idopts->token_label);\n        if (id_cryptoctx->token_label == NULL)\n            return ENOMEM;\n    }\n    if (idopts->cert_label != NULL) {\n        id_cryptoctx->cert_label = strdup(idopts->cert_label);\n        if (id_cryptoctx->cert_label == NULL)\n            return ENOMEM;\n    }\n    /* Convert the ascii cert_id string into a binary blob */\n    if (idopts->cert_id_string != NULL) {\n        BIGNUM *bn = NULL;\n        BN_hex2bn(&bn, idopts->cert_id_string);\n        if (bn == NULL)\n            return ENOMEM;\n        id_cryptoctx->cert_id_len = BN_num_bytes(bn);\n        id_cryptoctx->cert_id = malloc((size_t) id_cryptoctx->cert_id_len);\n        if (id_cryptoctx->cert_id == NULL) {\n            BN_free(bn);\n            return ENOMEM;\n        }\n        BN_bn2bin(bn, id_cryptoctx->cert_id);\n        BN_free(bn);\n    }\n    id_cryptoctx->slotid = idopts->slotid;\n    id_cryptoctx->pkcs11_method = 1;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n#ifndef PKINIT_USE_MECH_LIST\n    /*\n     * We'd like to use CKM_SHA1_RSA_PKCS for signing if it's available, but\n     * many cards seems to be confused about whether they are capable of\n     * this or not. The safe thing seems to be to ignore the mechanism list,\n     * always use CKM_RSA_PKCS and calculate the sha1 digest ourselves.\n     */\n\n    id_cryptoctx->mech = CKM_RSA_PKCS;\n#else\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid, NULL,\n                                                   &count)) != CKR_OK || count <= 0) {\n        pkiDebug(\"C_GetMechanismList: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    mechp = malloc(count * sizeof (CK_MECHANISM_TYPE));\n    if (mechp == NULL)\n        return ENOMEM;\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid,\n                                                   mechp, &count)) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    for (i = 0; i < count; i++) {\n        if ((r = id_cryptoctx->p11->C_GetMechanismInfo(id_cryptoctx->slotid,\n                                                       mechp[i], &info)) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n#ifdef DEBUG_MECHINFO\n        pkiDebug(\"mech %x flags %x\\n\", (int) mechp[i], (int) info.flags);\n        if ((info.flags & (CKF_SIGN|CKF_DECRYPT)) == (CKF_SIGN|CKF_DECRYPT))\n            pkiDebug(\"  this mech is good for sign & decrypt\\n\");\n#endif\n        if (mechp[i] == CKM_RSA_PKCS) {\n            /* This seems backwards... */\n            id_cryptoctx->mech =\n                (info.flags & CKF_SIGN) ? CKM_SHA1_RSA_PKCS : CKM_RSA_PKCS;\n        }\n    }\n    free(mechp);\n\n    pkiDebug(\"got %d mechs from card\\n\", (int) count);\n#endif\n\n    cls = CKO_CERTIFICATE;\n    attrs[0].type = CKA_CLASS;\n    attrs[0].pValue = &cls;\n    attrs[0].ulValueLen = sizeof cls;\n\n    certtype = CKC_X_509;\n    attrs[1].type = CKA_CERTIFICATE_TYPE;\n    attrs[1].pValue = &certtype;\n    attrs[1].ulValueLen = sizeof certtype;\n\n    nattrs = 2;\n\n    /* If a cert id and/or label were given, use them too */\n    if (id_cryptoctx->cert_id_len > 0) {\n        attrs[nattrs].type = CKA_ID;\n        attrs[nattrs].pValue = id_cryptoctx->cert_id;\n        attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n        nattrs++;\n    }\n    if (id_cryptoctx->cert_label != NULL) {\n        attrs[nattrs].type = CKA_LABEL;\n        attrs[nattrs].pValue = id_cryptoctx->cert_label;\n        attrs[nattrs].ulValueLen = strlen(id_cryptoctx->cert_label);\n        nattrs++;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"C_FindObjectsInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    for (i = 0; ; i++) {\n        if (i >= MAX_CREDS_ALLOWED)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n\n        /* Look for x.509 cert */\n        if ((r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session,\n                                                  &obj, 1, &count)) != CKR_OK || count <= 0) {\n            id_cryptoctx->creds[i] = NULL;\n            break;\n        }\n\n        /* Get cert and id len */\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = NULL;\n        attrs[0].ulValueLen = 0;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = NULL;\n        attrs[1].ulValueLen = 0;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK && r != CKR_BUFFER_TOO_SMALL) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n        cert = (CK_BYTE_PTR) malloc((size_t) attrs[0].ulValueLen + 1);\n        cert_id = (CK_BYTE_PTR) malloc((size_t) attrs[1].ulValueLen + 1);\n        if (cert == NULL || cert_id == NULL)\n            return ENOMEM;\n\n        /* Read the cert and id off the card */\n\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = cert;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = cert_id;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        pkiDebug(\"cert %d size %d id %d idlen %d\\n\", i,\n                 (int) attrs[0].ulValueLen, (int) cert_id[0],\n                 (int) attrs[1].ulValueLen);\n\n        cp = (unsigned char *) cert;\n        x = d2i_X509(NULL, &cp, (int) attrs[0].ulValueLen);\n        if (x == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i] = malloc(sizeof(struct _pkinit_cred_info));\n        if (id_cryptoctx->creds[i] == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i]->name = reassemble_pkcs11_name(idopts);\n        id_cryptoctx->creds[i]->cert = x;\n        id_cryptoctx->creds[i]->key = NULL;\n        id_cryptoctx->creds[i]->cert_id = cert_id;\n        id_cryptoctx->creds[i]->cert_id_len = attrs[1].ulValueLen;\n        free(cert);\n    }\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    if (cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\n\nstatic void\nfree_cred_info(krb5_context context,\n               pkinit_identity_crypto_context id_cryptoctx,\n               struct _pkinit_cred_info *cred)\n{\n    if (cred != NULL) {\n        if (cred->cert != NULL)\n            X509_free(cred->cert);\n        if (cred->key != NULL)\n            EVP_PKEY_free(cred->key);\n#ifndef WITHOUT_PKCS11\n        free(cred->cert_id);\n#endif\n        free(cred->name);\n        free(cred);\n    }\n}\n\nkrb5_error_code\ncrypto_free_cert_info(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx)\n{\n    int i;\n\n    if (id_cryptoctx == NULL)\n        return EINVAL;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++) {\n        if (id_cryptoctx->creds[i] != NULL) {\n            free_cred_info(context, id_cryptoctx, id_cryptoctx->creds[i]);\n            id_cryptoctx->creds[i] = NULL;\n        }\n    }\n    return 0;\n}\n\nkrb5_error_code\ncrypto_load_certs(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_opts *idopts,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  krb5_principal princ)\n{\n    krb5_error_code retval;\n\n    switch(idopts->idtype) {\n    case IDTYPE_FILE:\n        retval = pkinit_get_certs_fs(context, plg_cryptoctx,\n                                     req_cryptoctx, idopts,\n                                     id_cryptoctx, princ);\n        break;\n    case IDTYPE_DIR:\n        retval = pkinit_get_certs_dir(context, plg_cryptoctx,\n                                      req_cryptoctx, idopts,\n                                      id_cryptoctx, princ);\n        break;\n#ifndef WITHOUT_PKCS11\n    case IDTYPE_PKCS11:\n        retval = pkinit_get_certs_pkcs11(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n#endif\n    case IDTYPE_PKCS12:\n        retval = pkinit_get_certs_pkcs12(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n    default:\n        retval = EINVAL;\n    }\n    if (retval)\n        goto cleanup;\n\ncleanup:\n    return retval;\n}\n\n/*\n * Get number of certificates available after crypto_load_certs()\n */\nkrb5_error_code\ncrypto_cert_get_count(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int *cert_count)\n{\n    int count;\n\n    if (id_cryptoctx == NULL || id_cryptoctx->creds[0] == NULL)\n        return EINVAL;\n\n    for (count = 0;\n         count <= MAX_CREDS_ALLOWED && id_cryptoctx->creds[count] != NULL;\n         count++);\n    *cert_count = count;\n    return 0;\n}\n\n\n/*\n * Begin iteration over the certs loaded in crypto_load_certs()\n */\nkrb5_error_code\ncrypto_cert_iteration_begin(krb5_context context,\n                            pkinit_plg_crypto_context plg_cryptoctx,\n                            pkinit_req_crypto_context req_cryptoctx,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            pkinit_cert_iter_handle *ih_ret)\n{\n    struct _pkinit_cert_iter_data *id;\n\n    if (id_cryptoctx == NULL || ih_ret == NULL)\n        return EINVAL;\n    if (id_cryptoctx->creds[0] == NULL) /* No cred info available */\n        return ENOENT;\n\n    id = calloc(1, sizeof(*id));\n    if (id == NULL)\n        return ENOMEM;\n    id->magic = ITER_MAGIC;\n    id->plgctx = plg_cryptoctx,\n        id->reqctx = req_cryptoctx,\n        id->idctx = id_cryptoctx;\n    id->index = 0;\n    *ih_ret = (pkinit_cert_iter_handle) id;\n    return 0;\n}\n\n/*\n * End iteration over the certs loaded in crypto_load_certs()\n */\nkrb5_error_code\ncrypto_cert_iteration_end(krb5_context context,\n                          pkinit_cert_iter_handle ih)\n{\n    struct _pkinit_cert_iter_data *id = (struct _pkinit_cert_iter_data *)ih;\n\n    if (id == NULL || id->magic != ITER_MAGIC)\n        return EINVAL;\n    free(ih);\n    return 0;\n}\n\n/*\n * Get next certificate handle\n */\nkrb5_error_code\ncrypto_cert_iteration_next(krb5_context context,\n                           pkinit_cert_iter_handle ih,\n                           pkinit_cert_handle *ch_ret)\n{\n    struct _pkinit_cert_iter_data *id = (struct _pkinit_cert_iter_data *)ih;\n    struct _pkinit_cert_data *cd;\n    pkinit_identity_crypto_context id_cryptoctx;\n\n    if (id == NULL || id->magic != ITER_MAGIC)\n        return EINVAL;\n\n    if (ch_ret == NULL)\n        return EINVAL;\n\n    id_cryptoctx = id->idctx;\n    if (id_cryptoctx == NULL)\n        return EINVAL;\n\n    if (id_cryptoctx->creds[id->index] == NULL)\n        return PKINIT_ITER_NO_MORE;\n\n    cd = calloc(1, sizeof(*cd));\n    if (cd == NULL)\n        return ENOMEM;\n\n    cd->magic = CERT_MAGIC;\n    cd->plgctx = id->plgctx;\n    cd->reqctx = id->reqctx;\n    cd->idctx = id->idctx;\n    cd->index = id->index;\n    cd->cred = id_cryptoctx->creds[id->index++];\n    *ch_ret = (pkinit_cert_handle)cd;\n    return 0;\n}\n\n/*\n * Release cert handle\n */\nkrb5_error_code\ncrypto_cert_release(krb5_context context,\n                    pkinit_cert_handle ch)\n{\n    struct _pkinit_cert_data *cd = (struct _pkinit_cert_data *)ch;\n    if (cd == NULL || cd->magic != CERT_MAGIC)\n        return EINVAL;\n    free(cd);\n    return 0;\n}\n\n/*\n * Get certificate Key Usage and Extended Key Usage\n */\nstatic krb5_error_code\ncrypto_retieve_X509_key_usage(krb5_context context,\n                              pkinit_plg_crypto_context plgcctx,\n                              pkinit_req_crypto_context reqcctx,\n                              X509 *x,\n                              unsigned int *ret_ku_bits,\n                              unsigned int *ret_eku_bits)\n{\n    krb5_error_code retval = 0;\n    int i;\n    unsigned int eku_bits = 0, ku_bits = 0;\n    ASN1_BIT_STRING *usage = NULL;\n\n    if (ret_ku_bits == NULL && ret_eku_bits == NULL)\n        return EINVAL;\n\n    if (ret_eku_bits)\n        *ret_eku_bits = 0;\n    else {\n        pkiDebug(\"%s: EKUs not requested, not checking\\n\", __FUNCTION__);\n        goto check_kus;\n    }\n\n    /* Start with Extended Key usage */\n    i = X509_get_ext_by_NID(x, NID_ext_key_usage, -1);\n    if (i >= 0) {\n        EXTENDED_KEY_USAGE *eku;\n\n        eku = X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL);\n        if (eku) {\n            for (i = 0; i < sk_ASN1_OBJECT_num(eku); i++) {\n                ASN1_OBJECT *certoid;\n                certoid = sk_ASN1_OBJECT_value(eku, i);\n                if ((OBJ_cmp(certoid, plgcctx->id_pkinit_KPClientAuth)) == 0)\n                    eku_bits |= PKINIT_EKU_PKINIT;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_ms_smartcard_login))) == 0)\n                    eku_bits |= PKINIT_EKU_MSSCLOGIN;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_client_auth))) == 0)\n                    eku_bits |= PKINIT_EKU_CLIENTAUTH;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_email_protect))) == 0)\n                    eku_bits |= PKINIT_EKU_EMAILPROTECTION;\n            }\n            EXTENDED_KEY_USAGE_free(eku);\n        }\n    }\n    pkiDebug(\"%s: returning eku 0x%08x\\n\", __FUNCTION__, eku_bits);\n    *ret_eku_bits = eku_bits;\n\ncheck_kus:\n    /* Now the Key Usage bits */\n    if (ret_ku_bits)\n        *ret_ku_bits = 0;\n    else {\n        pkiDebug(\"%s: KUs not requested, not checking\\n\", __FUNCTION__);\n        goto out;\n    }\n\n    /* Make sure usage exists before checking bits */\n    X509_check_ca(x);\n    usage = X509_get_ext_d2i(x, NID_key_usage, NULL, NULL);\n    if (usage) {\n        if (!ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))\n            ku_bits |= PKINIT_KU_DIGITALSIGNATURE;\n        if (!ku_reject(x, X509v3_KU_KEY_ENCIPHERMENT))\n            ku_bits |= PKINIT_KU_KEYENCIPHERMENT;\n        ASN1_BIT_STRING_free(usage);\n    }\n\n    pkiDebug(\"%s: returning ku 0x%08x\\n\", __FUNCTION__, ku_bits);\n    *ret_ku_bits = ku_bits;\n    retval = 0;\nout:\n    return retval;\n}\n\n/*\n * Return a string format of an X509_NAME in buf where\n * size is an in/out parameter.  On input it is the size\n * of the buffer, and on output it is the actual length\n * of the name.\n * If buf is NULL, returns the length req'd to hold name\n */\nstatic char *\nX509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}\n\n/*\n * Get certificate information\n */\nkrb5_error_code\ncrypto_cert_get_matching_data(krb5_context context,\n                              pkinit_cert_handle ch,\n                              pkinit_cert_matching_data **ret_md)\n{\n    krb5_error_code retval;\n    pkinit_cert_matching_data *md;\n    krb5_principal *pkinit_sans =NULL, *upn_sans = NULL;\n    struct _pkinit_cert_data *cd = (struct _pkinit_cert_data *)ch;\n    unsigned int i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    if (cd == NULL || cd->magic != CERT_MAGIC)\n        return EINVAL;\n    if (ret_md == NULL)\n        return EINVAL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        return ENOMEM;\n\n    md->ch = ch;\n\n    /* get the subject name (in rfc2253 format) */\n    X509_NAME_oneline_ex(X509_get_subject_name(cd->cred->cert),\n                         buf, &bufsize, XN_FLAG_SEP_COMMA_PLUS);\n    md->subject_dn = strdup(buf);\n    if (md->subject_dn == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* get the issuer name (in rfc2253 format) */\n    X509_NAME_oneline_ex(X509_get_issuer_name(cd->cred->cert),\n                         buf, &bufsize, XN_FLAG_SEP_COMMA_PLUS);\n    md->issuer_dn = strdup(buf);\n    if (md->issuer_dn == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* get the san data */\n    retval = crypto_retrieve_X509_sans(context, cd->plgctx, cd->reqctx,\n                                       cd->cred->cert, &pkinit_sans,\n                                       &upn_sans, NULL);\n    if (retval)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* get the KU and EKU data */\n\n    retval = crypto_retieve_X509_key_usage(context, cd->plgctx, cd->reqctx,\n                                           cd->cred->cert,\n                                           &md->ku_bits, &md->eku_bits);\n    if (retval)\n        goto cleanup;\n\n    *ret_md = md;\n    retval = 0;\ncleanup:\n    if (retval) {\n        if (md)\n            crypto_cert_free_matching_data(context, md);\n    }\n    return retval;\n}\n\n/*\n * Free certificate information\n */\nkrb5_error_code\ncrypto_cert_free_matching_data(krb5_context context,\n                               pkinit_cert_matching_data *md)\n{\n    krb5_principal p;\n    int i;\n\n    if (md == NULL)\n        return EINVAL;\n    if (md->subject_dn)\n        free(md->subject_dn);\n    if (md->issuer_dn)\n        free(md->issuer_dn);\n    if (md->sans) {\n        for (i = 0, p = md->sans[i]; p != NULL; p = md->sans[++i])\n            krb5_free_principal(context, p);\n        free(md->sans);\n    }\n    free(md);\n    return 0;\n}\n\n/*\n * Make this matching certificate \"the chosen one\"\n */\nkrb5_error_code\ncrypto_cert_select(krb5_context context,\n                   pkinit_cert_matching_data *md)\n{\n    struct _pkinit_cert_data *cd;\n    if (md == NULL)\n        return EINVAL;\n\n    cd = (struct _pkinit_cert_data *)md->ch;\n    if (cd == NULL || cd->magic != CERT_MAGIC)\n        return EINVAL;\n\n    /* copy the selected cert into our id_cryptoctx */\n    if (cd->idctx->my_certs != NULL) {\n        sk_X509_pop_free(cd->idctx->my_certs, X509_free);\n    }\n    cd->idctx->my_certs = sk_X509_new_null();\n    sk_X509_push(cd->idctx->my_certs, cd->cred->cert);\n    free(cd->idctx->identity);\n    /* hang on to the selected credential name */\n    if (cd->idctx->creds[cd->index]->name != NULL)\n        cd->idctx->identity = strdup(cd->idctx->creds[cd->index]->name);\n    else\n        cd->idctx->identity = NULL;\n    cd->idctx->creds[cd->index]->cert = NULL;       /* Don't free it twice */\n    cd->idctx->cert_index = 0;\n\n    if (cd->idctx->pkcs11_method != 1) {\n        cd->idctx->my_key = cd->cred->key;\n        cd->idctx->creds[cd->index]->key = NULL;    /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        cd->idctx->cert_id = cd->cred->cert_id;\n        cd->idctx->creds[cd->index]->cert_id = NULL; /* Don't free it twice */\n        cd->idctx->cert_id_len = cd->cred->cert_id_len;\n    }\n#endif\n    return 0;\n}\n\n/*\n * Choose the default certificate as \"the chosen one\"\n */\nkrb5_error_code\ncrypto_cert_select_default(krb5_context context,\n                           pkinit_plg_crypto_context plg_cryptoctx,\n                           pkinit_req_crypto_context req_cryptoctx,\n                           pkinit_identity_crypto_context id_cryptoctx)\n{\n    krb5_error_code retval;\n    int cert_count = 0;\n\n    retval = crypto_cert_get_count(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, &cert_count);\n    if (retval) {\n        pkiDebug(\"%s: crypto_cert_get_count error %d, %s\\n\",\n                 __FUNCTION__, retval, error_message(retval));\n        goto errout;\n    }\n    if (cert_count != 1) {\n        pkiDebug(\"%s: ERROR: There are %d certs to choose from, \"\n                 \"but there must be exactly one.\\n\",\n                 __FUNCTION__, cert_count);\n        retval = EINVAL;\n        goto errout;\n    }\n    /* copy the selected cert into our id_cryptoctx */\n    if (id_cryptoctx->my_certs != NULL) {\n        sk_X509_pop_free(id_cryptoctx->my_certs, X509_free);\n    }\n    id_cryptoctx->my_certs = sk_X509_new_null();\n    sk_X509_push(id_cryptoctx->my_certs, id_cryptoctx->creds[0]->cert);\n    id_cryptoctx->creds[0]->cert = NULL;        /* Don't free it twice */\n    id_cryptoctx->cert_index = 0;\n    /* hang on to the selected credential name */\n    if (id_cryptoctx->creds[0]->name != NULL)\n        id_cryptoctx->identity = strdup(id_cryptoctx->creds[0]->name);\n    else\n        id_cryptoctx->identity = NULL;\n\n    if (id_cryptoctx->pkcs11_method != 1) {\n        id_cryptoctx->my_key = id_cryptoctx->creds[0]->key;\n        id_cryptoctx->creds[0]->key = NULL;     /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        id_cryptoctx->cert_id = id_cryptoctx->creds[0]->cert_id;\n        id_cryptoctx->creds[0]->cert_id = NULL; /* Don't free it twice */\n        id_cryptoctx->cert_id_len = id_cryptoctx->creds[0]->cert_id_len;\n    }\n#endif\n    retval = 0;\nerrout:\n    return retval;\n}\n\n\n\nstatic krb5_error_code\nload_cas_and_crls(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  int catype,\n                  char *filename)\n{\n    STACK_OF(X509_INFO) *sk = NULL;\n    STACK_OF(X509) *ca_certs = NULL;\n    STACK_OF(X509_CRL) *ca_crls = NULL;\n    BIO *in = NULL;\n    krb5_error_code retval = ENOMEM;\n    int i = 0;\n\n    /* If there isn't already a stack in the context,\n     * create a temporary one now */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (id_cryptoctx->trustedCAs != NULL)\n            ca_certs = id_cryptoctx->trustedCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (id_cryptoctx->intermediateCAs != NULL)\n            ca_certs = id_cryptoctx->intermediateCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (id_cryptoctx->revoked != NULL)\n            ca_crls = id_cryptoctx->revoked;\n        else {\n            ca_crls = sk_X509_CRL_new_null();\n            if (ca_crls == NULL)\n                return ENOMEM;\n        }\n        break;\n    default:\n        return ENOTSUP;\n    }\n\n    if (!(in = BIO_new_file(filename, \"r\"))) {\n        retval = errno;\n        pkiDebug(\"%s: error opening file '%s': %s\\n\", __FUNCTION__,\n                 filename, error_message(errno));\n        goto cleanup;\n    }\n\n    /* This loads from a file, a stack of x509/crl/pkey sets */\n    if ((sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL)) == NULL) {\n        pkiDebug(\"%s: error reading file '%s'\\n\", __FUNCTION__, filename);\n        retval = EIO;\n        goto cleanup;\n    }\n\n    /* scan over the stack created from loading the file contents,\n     * weed out duplicates, and push new ones onto the return stack\n     */\n    for (i = 0; i < sk_X509_INFO_num(sk); i++) {\n        X509_INFO *xi = sk_X509_INFO_value(sk, i);\n        if (xi != NULL && xi->x509 != NULL && catype != CATYPE_CRLS) {\n            int j = 0, size = sk_X509_num(ca_certs), flag = 0;\n\n            if (!size) {\n                sk_X509_push(ca_certs, xi->x509);\n                xi->x509 = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509 *x = sk_X509_value(ca_certs, j);\n                flag = X509_cmp(x, xi->x509);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_push(ca_certs, X509_dup(xi->x509));\n            }\n        } else if (xi != NULL && xi->crl != NULL && catype == CATYPE_CRLS) {\n            int j = 0, size = sk_X509_CRL_num(ca_crls), flag = 0;\n            if (!size) {\n                sk_X509_CRL_push(ca_crls, xi->crl);\n                xi->crl = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509_CRL *x = sk_X509_CRL_value(ca_crls, j);\n                flag = X509_CRL_cmp(x, xi->crl);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_CRL_push(ca_crls, X509_CRL_dup(xi->crl));\n            }\n        }\n    }\n\n    /* If we added something and there wasn't a stack in the\n     * context before, add the temporary stack to the context.\n     */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (sk_X509_num(ca_certs) == 0) {\n            pkiDebug(\"no anchors in file, %s\\n\", filename);\n            if (id_cryptoctx->trustedCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->trustedCAs == NULL)\n                id_cryptoctx->trustedCAs = ca_certs;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (sk_X509_num(ca_certs) == 0) {\n            pkiDebug(\"no intermediates in file, %s\\n\", filename);\n            if (id_cryptoctx->intermediateCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->intermediateCAs == NULL)\n                id_cryptoctx->intermediateCAs = ca_certs;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (sk_X509_CRL_num(ca_crls) == 0) {\n            pkiDebug(\"no crls in file, %s\\n\", filename);\n            if (id_cryptoctx->revoked == NULL)\n                sk_X509_CRL_free(ca_crls);\n        } else {\n            if (id_cryptoctx->revoked == NULL)\n                id_cryptoctx->revoked = ca_crls;\n        }\n        break;\n    default:\n        /* Should have been caught above! */\n        retval = EINVAL;\n        goto cleanup;\n        break;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (in != NULL)\n        BIO_free(in);\n    if (sk != NULL)\n        sk_X509_INFO_pop_free(sk, X509_INFO_free);\n\n    return retval;\n}\n\nstatic krb5_error_code\nload_cas_and_crls_dir(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int catype,\n                      char *dirname)\n{\n    krb5_error_code retval = EINVAL;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char filename[1024];\n\n    if (dirname == NULL)\n        return EINVAL;\n\n    d = opendir(dirname);\n    if (d == NULL)\n        return ENOENT;\n\n    while ((dentry = readdir(d))) {\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(filename)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            goto cleanup;\n        }\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        snprintf(filename, sizeof(filename), \"%s/%s\", dirname, dentry->d_name);\n\n        retval = load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, catype, filename);\n        if (retval)\n            goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d != NULL)\n        closedir(d);\n\n    return retval;\n}\n\nkrb5_error_code\ncrypto_load_cas_and_crls(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_opts *idopts,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         int idtype,\n                         int catype,\n                         char *id)\n{\n    pkiDebug(\"%s: called with idtype %s and catype %s\\n\",\n             __FUNCTION__, idtype2string(idtype), catype2string(catype));\n    switch (idtype) {\n    case IDTYPE_FILE:\n        return load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                 id_cryptoctx, catype, id);\n        break;\n    case IDTYPE_DIR:\n        return load_cas_and_crls_dir(context, plg_cryptoctx, req_cryptoctx,\n                                     id_cryptoctx, catype, id);\n        break;\n    default:\n        return ENOTSUP;\n        break;\n    }\n}\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids)\n{\n    krb5_error_code retval = ENOMEM;\n    int i = 0, sk_size = sk_X509_num(sk);\n    krb5_external_principal_identifier **krb5_cas = NULL;\n    X509 *x = NULL;\n    X509_NAME *xn = NULL;\n    unsigned char *p = NULL;\n    int len = 0;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    char buf[DN_BUF_LEN];\n\n    *ids = NULL;\n\n    krb5_cas =\n        malloc((sk_size + 1) * sizeof(krb5_external_principal_identifier *));\n    if (krb5_cas == NULL)\n        return ENOMEM;\n    krb5_cas[sk_size] = NULL;\n\n    for (i = 0; i < sk_size; i++) {\n        krb5_cas[i] = malloc(sizeof(krb5_external_principal_identifier));\n\n        x = sk_X509_value(sk, i);\n\n        X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n        pkiDebug(\"#%d cert= %s\\n\", i, buf);\n\n        /* fill-in subjectName */\n        krb5_cas[i]->subjectName.magic = 0;\n        krb5_cas[i]->subjectName.length = 0;\n        krb5_cas[i]->subjectName.data = NULL;\n\n        xn = X509_get_subject_name(x);\n        len = i2d_X509_NAME(xn, NULL);\n        if ((p = malloc((size_t) len)) == NULL)\n            goto cleanup;\n        krb5_cas[i]->subjectName.data = (char *)p;\n        i2d_X509_NAME(xn, &p);\n        krb5_cas[i]->subjectName.length = len;\n\n        /* fill-in issuerAndSerialNumber */\n        krb5_cas[i]->issuerAndSerialNumber.length = 0;\n        krb5_cas[i]->issuerAndSerialNumber.magic = 0;\n        krb5_cas[i]->issuerAndSerialNumber.data = NULL;\n\n#ifdef LONGHORN_BETA_COMPAT\n        if (longhorn == 0) { /* XXX Longhorn doesn't like this */\n#endif\n            is = PKCS7_ISSUER_AND_SERIAL_new();\n            X509_NAME_set(&is->issuer, X509_get_issuer_name(x));\n            M_ASN1_INTEGER_free(is->serial);\n            is->serial = M_ASN1_INTEGER_dup(X509_get_serialNumber(x));\n            len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n            if ((p = malloc((size_t) len)) == NULL)\n                goto cleanup;\n            krb5_cas[i]->issuerAndSerialNumber.data = (char *)p;\n            i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n            krb5_cas[i]->issuerAndSerialNumber.length = len;\n#ifdef LONGHORN_BETA_COMPAT\n        }\n#endif\n\n        /* fill-in subjectKeyIdentifier */\n        krb5_cas[i]->subjectKeyIdentifier.length = 0;\n        krb5_cas[i]->subjectKeyIdentifier.magic = 0;\n        krb5_cas[i]->subjectKeyIdentifier.data = NULL;\n\n\n#ifdef LONGHORN_BETA_COMPAT\n        if (longhorn == 0) {    /* XXX Longhorn doesn't like this */\n#endif\n            if (X509_get_ext_by_NID(x, NID_subject_key_identifier, -1) >= 0) {\n                ASN1_OCTET_STRING *ikeyid = NULL;\n\n                if ((ikeyid = X509_get_ext_d2i(x, NID_subject_key_identifier, NULL,\n                                               NULL))) {\n                    len = i2d_ASN1_OCTET_STRING(ikeyid, NULL);\n                    if ((p = malloc((size_t) len)) == NULL)\n                        goto cleanup;\n                    krb5_cas[i]->subjectKeyIdentifier.data = (char *)p;\n                    i2d_ASN1_OCTET_STRING(ikeyid, &p);\n                    krb5_cas[i]->subjectKeyIdentifier.length = len;\n                }\n                if (ikeyid != NULL)\n                    ASN1_OCTET_STRING_free(ikeyid);\n            }\n#ifdef LONGHORN_BETA_COMPAT\n        }\n#endif\n        if (is != NULL) {\n            if (is->issuer != NULL)\n                X509_NAME_free(is->issuer);\n            if (is->serial != NULL)\n                ASN1_INTEGER_free(is->serial);\n            free(is);\n        }\n    }\n\n    *ids = krb5_cas;\n\n    retval = 0;\ncleanup:\n    if (retval)\n        free_krb5_external_principal_identifier(&krb5_cas);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = NULL;\n\n    *ids = NULL;\n    if (req_cryptoctx->received_cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    sk = sk_X509_new_null();\n    if (sk == NULL)\n        goto cleanup;\n    sk_X509_push(sk, req_cryptoctx->received_cert);\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    sk_X509_free(sk);\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_supportedCMSTypes(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_algorithm_identifier ***oids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    krb5_algorithm_identifier **loids = NULL;\n    krb5_data des3oid = {0, 8, \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x03\\x07\" };\n\n    *oids = NULL;\n    loids = malloc(2 * sizeof(krb5_algorithm_identifier *));\n    if (loids == NULL)\n        goto cleanup;\n    loids[1] = NULL;\n    loids[0] = malloc(sizeof(krb5_algorithm_identifier));\n    if (loids[0] == NULL) {\n        free(loids);\n        goto cleanup;\n    }\n    retval = pkinit_copy_krb5_data(&loids[0]->algorithm, &des3oid);\n    if (retval) {\n        free(loids[0]);\n        free(loids);\n        goto cleanup;\n    }\n    loids[0]->parameters.length = 0;\n    loids[0]->parameters.data = NULL;\n\n    *oids = loids;\n    retval = 0;\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_trustedCertifiers(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = id_cryptoctx->trustedCAs;\n\n    *ids = NULL;\n    if (id_cryptoctx->trustedCAs == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_issuerAndSerial(krb5_context context,\n                       pkinit_plg_crypto_context plg_cryptoctx,\n                       pkinit_req_crypto_context req_cryptoctx,\n                       pkinit_identity_crypto_context id_cryptoctx,\n                       unsigned char **out,\n                       unsigned int *out_len)\n{\n    unsigned char *p = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    int len = 0;\n    krb5_error_code retval = ENOMEM;\n    X509 *cert = req_cryptoctx->received_cert;\n\n    *out = NULL;\n    *out_len = 0;\n    if (req_cryptoctx->received_cert == NULL)\n        return 0;\n\n    is = PKCS7_ISSUER_AND_SERIAL_new();\n    X509_NAME_set(&is->issuer, X509_get_issuer_name(cert));\n    M_ASN1_INTEGER_free(is->serial);\n    is->serial = M_ASN1_INTEGER_dup(X509_get_serialNumber(cert));\n    len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n    if ((p = *out = malloc((size_t) len)) == NULL)\n        goto cleanup;\n    i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n    *out_len = len;\n    retval = 0;\n\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}\n\nstatic int\npkcs7_decrypt(krb5_context context,\n              pkinit_identity_crypto_context id_cryptoctx,\n              PKCS7 *p7,\n              BIO *data)\n{\n    BIO *tmpmem = NULL;\n    int retval = 0, i = 0;\n    char buf[4096];\n\n    if(p7 == NULL)\n        return 0;\n\n    if(!PKCS7_type_is_enveloped(p7)) {\n        pkiDebug(\"wrong pkcs7 content type\\n\");\n        return 0;\n    }\n\n    if(!(tmpmem = pkcs7_dataDecode(context, id_cryptoctx, p7))) {\n        pkiDebug(\"unable to decrypt pkcs7 object\\n\");\n        return 0;\n    }\n\n    for(;;) {\n        i = BIO_read(tmpmem, buf, sizeof(buf));\n        if (i <= 0) break;\n        BIO_write(data, buf, i);\n        BIO_free_all(tmpmem);\n        return 1;\n    }\n    return retval;\n}\n\nkrb5_error_code\npkinit_process_td_trusted_certifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_external_principal_identifier **krb5_trusted_certifiers,\n    int td_type)\n{\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509_NAME) *sk_xn = NULL;\n    X509_NAME *xn = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    ASN1_OCTET_STRING *id = NULL;\n    const unsigned char *p = NULL;\n    char buf[DN_BUF_LEN];\n    int i = 0;\n\n    if (td_type == TD_TRUSTED_CERTIFIERS)\n        pkiDebug(\"received trusted certifiers\\n\");\n    else\n        pkiDebug(\"received invalid certificate\\n\");\n\n    sk_xn = sk_X509_NAME_new_null();\n    while(krb5_trusted_certifiers[i] != NULL) {\n        if (krb5_trusted_certifiers[i]->subjectName.data != NULL) {\n            p = (unsigned char *)krb5_trusted_certifiers[i]->subjectName.data;\n            xn = d2i_X509_NAME(NULL, &p,\n                               (int)krb5_trusted_certifiers[i]->subjectName.length);\n            if (xn == NULL)\n                goto cleanup;\n            X509_NAME_oneline(xn, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d cert = %s is trusted by kdc\\n\", i, buf);\n            else\n                pkiDebug(\"#%d cert = %s is invalid\\n\", i, buf);\n            sk_X509_NAME_push(sk_xn, xn);\n        }\n\n        if (krb5_trusted_certifiers[i]->issuerAndSerialNumber.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->issuerAndSerialNumber.data;\n            is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p,\n                                             (int)krb5_trusted_certifiers[i]->issuerAndSerialNumber.length);\n            if (is == NULL)\n                goto cleanup;\n            X509_NAME_oneline(is->issuer, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d issuer = %s serial = %ld is trusted bu kdc\\n\", i,\n                         buf, ASN1_INTEGER_get(is->serial));\n            else\n                pkiDebug(\"#%d issuer = %s serial = %ld is invalid\\n\", i, buf,\n                         ASN1_INTEGER_get(is->serial));\n            PKCS7_ISSUER_AND_SERIAL_free(is);\n        }\n\n        if (krb5_trusted_certifiers[i]->subjectKeyIdentifier.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->subjectKeyIdentifier.data;\n            id = d2i_ASN1_OCTET_STRING(NULL, &p,\n                                       (int)krb5_trusted_certifiers[i]->subjectKeyIdentifier.length);\n            if (id == NULL)\n                goto cleanup;\n            /* XXX */\n            ASN1_OCTET_STRING_free(id);\n        }\n        i++;\n    }\n    /* XXX Since we not doing anything with received trusted certifiers\n     * return an error. this is the place where we can pick a different\n     * client certificate based on the information in td_trusted_certifiers\n     */\n    retval = KRB5KDC_ERR_PREAUTH_FAILED;\ncleanup:\n    if (sk_xn != NULL)\n        sk_X509_NAME_pop_free(sk_xn, X509_NAME_free);\n\n    return retval;\n}\n\nstatic BIO *\npkcs7_dataDecode(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 PKCS7 *p7)\n{\n    int i = 0;\n    unsigned int jj = 0, tmp_len = 0;\n    BIO *out=NULL,*etmp=NULL,*bio=NULL;\n    unsigned char *tmp=NULL;\n    ASN1_OCTET_STRING *data_body=NULL;\n    const EVP_CIPHER *evp_cipher=NULL;\n    EVP_CIPHER_CTX *evp_ctx=NULL;\n    X509_ALGOR *enc_alg=NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\n    PKCS7_RECIP_INFO *ri=NULL;\n    X509 *cert = sk_X509_value(id_cryptoctx->my_certs,\n                               id_cryptoctx->cert_index);\n\n    p7->state=PKCS7_S_HEADER;\n\n    rsk=p7->d.enveloped->recipientinfo;\n    enc_alg=p7->d.enveloped->enc_data->algorithm;\n    data_body=p7->d.enveloped->enc_data->enc_data;\n    evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);\n    if (evp_cipher == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n        goto cleanup;\n    }\n\n    if ((etmp=BIO_new(BIO_f_cipher())) == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\n        goto cleanup;\n    }\n\n    /* It was encrypted, we need to decrypt the secret key\n     * with the private key */\n\n    /* Find the recipientInfo which matches the passed certificate\n     * (if any)\n     */\n\n    if (cert) {\n        for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n            int tmp_ret = 0;\n            ri=sk_PKCS7_RECIP_INFO_value(rsk,i);\n            tmp_ret = X509_NAME_cmp(ri->issuer_and_serial->issuer,\n                                    cert->cert_info->issuer);\n            if (!tmp_ret) {\n                tmp_ret = M_ASN1_INTEGER_cmp(cert->cert_info->serialNumber,\n                                             ri->issuer_and_serial->serial);\n                if (!tmp_ret)\n                    break;\n            }\n            ri=NULL;\n        }\n        if (ri == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n            goto cleanup;\n        }\n\n    }\n\n    /* If we haven't got a certificate try each ri in turn */\n\n    if (cert == NULL) {\n        for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n            ri=sk_PKCS7_RECIP_INFO_value(rsk,i);\n            jj = pkinit_decode_data(context, id_cryptoctx,\n                                    M_ASN1_STRING_data(ri->enc_key),\n                                    (unsigned int) M_ASN1_STRING_length(ri->enc_key),\n                                    &tmp, &tmp_len);\n            if (jj) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_EVP_LIB);\n                goto cleanup;\n            }\n\n            if (!jj && tmp_len > 0) {\n                jj = tmp_len;\n                break;\n            }\n\n            ERR_clear_error();\n            ri = NULL;\n        }\n\n        if (ri == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_RECIPIENT_MATCHES_KEY);\n            goto cleanup;\n        }\n    }\n    else {\n        jj = pkinit_decode_data(context, id_cryptoctx,\n                                M_ASN1_STRING_data(ri->enc_key),\n                                (unsigned int) M_ASN1_STRING_length(ri->enc_key),\n                                &tmp, &tmp_len);\n        if (jj || tmp_len <= 0) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_EVP_LIB);\n            goto cleanup;\n        }\n        jj = tmp_len;\n    }\n\n    evp_ctx=NULL;\n    BIO_get_cipher_ctx(etmp,&evp_ctx);\n    if (EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0) <= 0)\n        goto cleanup;\n    if (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)\n        goto cleanup;\n\n    if (jj != (unsigned) EVP_CIPHER_CTX_key_length(evp_ctx)) {\n        /* Some S/MIME clients don't use the same key\n         * and effective key length. The key length is\n         * determined by the size of the decrypted RSA key.\n         */\n        if(!EVP_CIPHER_CTX_set_key_length(evp_ctx, (int)jj)) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH);\n            goto cleanup;\n        }\n    }\n    if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0) <= 0)\n        goto cleanup;\n\n    OPENSSL_cleanse(tmp,jj);\n\n    if (out == NULL)\n        out=etmp;\n    else\n        BIO_push(out,etmp);\n    etmp=NULL;\n\n    if (data_body->length > 0)\n        bio = BIO_new_mem_buf(data_body->data, data_body->length);\n    else {\n        bio=BIO_new(BIO_s_mem());\n        BIO_set_mem_eof_return(bio,0);\n    }\n    BIO_push(out,bio);\n    bio=NULL;\n\n    if (0) {\n    cleanup:\n        if (out != NULL) BIO_free_all(out);\n        if (etmp != NULL) BIO_free_all(etmp);\n        if (bio != NULL) BIO_free_all(bio);\n        out=NULL;\n    }\n\n    if (tmp != NULL)\n        free(tmp);\n\n    return(out);\n}\n\n#ifdef DEBUG_DH\nstatic void\nprint_dh(DH * dh, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (dh)\n        DHparams_print(bio_err, dh);\n\n    BIO_puts(bio_err, \"private key: \");\n    BN_print(bio_err, dh->priv_key);\n    BIO_puts(bio_err, (const char *)\"\\n\");\n    BIO_free(bio_err);\n\n}\n\nstatic void\nprint_pubkey(BIGNUM * key, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (key)\n        BN_print(bio_err, key);\n    BIO_puts(bio_err, \"\\n\");\n\n    BIO_free(bio_err);\n\n}\n#endif\n\nstatic char *\npkinit_pkcs11_code_to_text(int err)\n{\n    int i;\n    static char uc[32];\n\n    for (i = 0; pkcs11_errstrings[i].text != NULL; i++)\n        if (pkcs11_errstrings[i].code == err)\n            break;\n    if (pkcs11_errstrings[i].text != NULL)\n        return (pkcs11_errstrings[i].text);\n    snprintf(uc, sizeof(uc), _(\"unknown code 0x%x\"), err);\n    return (uc);\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * COPYRIGHT (C) 2006,2007\n * THE REGENTS OF THE UNIVERSITY OF MICHIGAN\n * ALL RIGHTS RESERVED\n *\n * Permission is granted to use, copy, create derivative works\n * and redistribute this software and such derivative works\n * for any purpose, so long as the name of The University of\n * Michigan is not used in any advertising or publicity\n * pertaining to the use of distribution of this software\n * without specific, written prior authorization.  If the\n * above copyright notice or any other identification of the\n * University of Michigan is included in any copy of any\n * portion of this software, then the disclaimer below must\n * also be included.\n *\n * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION\n * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY\n * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF\n * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING\n * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE\n * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE\n * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR\n * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN\n * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGES.\n */\n\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <dlfcn.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <arpa/inet.h>\n\n#include \"k5-platform.h\"\n#include \"k5-buf.h\"\n\n#include \"pkinit_crypto_openssl.h\"\n\nstatic void openssl_init(void);\n\nstatic krb5_error_code pkinit_init_pkinit_oids(pkinit_plg_crypto_context );\nstatic void pkinit_fini_pkinit_oids(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_dh_params(pkinit_plg_crypto_context );\nstatic void pkinit_fini_dh_params(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_certs(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_certs(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_init_pkcs11(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_pkcs11(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_encode_dh_params\n(BIGNUM *, BIGNUM *, BIGNUM *, unsigned char **, unsigned int *);\nstatic DH *pkinit_decode_dh_params\n(DH **, unsigned char **, unsigned int );\nstatic int pkinit_check_dh_params\n(BIGNUM * p1, BIGNUM * p2, BIGNUM * g1, BIGNUM * q1);\n\nstatic krb5_error_code pkinit_sign_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\n\nstatic krb5_error_code create_signature\n(unsigned char **, unsigned int *, unsigned char *, unsigned int,\n EVP_PKEY *pkey);\n\nstatic krb5_error_code pkinit_decode_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **decoded, unsigned int *decoded_len);\n\nstatic krb5_error_code decode_data\n(unsigned char **, unsigned int *, unsigned char *, unsigned int,\n EVP_PKEY *pkey, X509 *cert);\n\n#ifdef DEBUG_DH\nstatic void print_dh(DH *, char *);\nstatic void print_pubkey(BIGNUM *, char *);\n#endif\n\nstatic int prepare_enc_data\n(unsigned char *indata, int indata_len, unsigned char **outdata,\n int *outdata_len);\n\nstatic int openssl_callback (int, X509_STORE_CTX *);\nstatic int openssl_callback_ignore_crls (int, X509_STORE_CTX *);\n\nstatic int pkcs7_decrypt\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n PKCS7 *p7, BIO *bio);\n\nstatic BIO * pkcs7_dataDecode\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n PKCS7 *p7);\n\nstatic ASN1_OBJECT * pkinit_pkcs7type2oid\n(pkinit_plg_crypto_context plg_cryptoctx, int pkcs7_type);\n\nstatic krb5_error_code pkinit_create_sequence_of_principal_identifiers\n(krb5_context context, pkinit_plg_crypto_context plg_cryptoctx,\n pkinit_req_crypto_context req_cryptoctx,\n pkinit_identity_crypto_context id_cryptoctx,\n int type, krb5_pa_data ***e_data_out);\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code pkinit_find_private_key\n(pkinit_identity_crypto_context, CK_ATTRIBUTE_TYPE usage,\n CK_OBJECT_HANDLE *objp);\nstatic krb5_error_code pkinit_login\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n CK_TOKEN_INFO *tip);\nstatic krb5_error_code pkinit_open_session\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx);\nstatic void * pkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p);\nstatic CK_RV pkinit_C_UnloadModule(void *handle);\n#ifdef SILLYDECRYPT\nCK_RV pkinit_C_Decrypt\n(pkinit_identity_crypto_context id_cryptoctx,\n CK_BYTE_PTR pEncryptedData, CK_ULONG  ulEncryptedDataLen,\n CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen);\n#endif\n\nstatic krb5_error_code pkinit_sign_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **decoded_data, unsigned int *decoded_data_len);\n#endif  /* WITHOUT_PKCS11 */\n\nstatic krb5_error_code pkinit_sign_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **decoded_data, unsigned int *decoded_data_len);\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids);\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids);\n#ifdef LONGHORN_BETA_COMPAT\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len,\n                int is_longhorn_server);\n#else\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len);\n#endif\n\nstatic char *\npkinit_pkcs11_code_to_text(int err);\n\n\n#if OPENSSL_VERSION_NUMBER >= 0x10000000L\n/* Use CMS support present in OpenSSL 1.0 and later. */\n#include <openssl/cms.h>\n#define pkinit_CMS_get0_content_signed(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_get0_content_data(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_free1_crls(_sk_x509crl) sk_X509_CRL_free((_sk_x509crl))\n#define pkinit_CMS_free1_certs(_sk_x509) sk_X509_free((_sk_x509))\n#define pkinit_CMS_SignerInfo_get_cert(_cms,_si,_x509_pp)       \\\n    CMS_SignerInfo_get0_algs(_si,NULL,_x509_pp,NULL,NULL)\n#else\n/* Fake up CMS support using PKCS7. */\n#define pkinit_CMS_free1_crls(_stack_of_x509crls)   /* Don't free these */\n#define pkinit_CMS_free1_certs(_stack_of_x509certs) /* Don't free these */\n#define CMS_NO_SIGNER_CERT_VERIFY PKCS7_NOVERIFY\n#define CMS_NOATTR PKCS7_NOATTR\n#define CMS_ContentInfo PKCS7\n#define CMS_SignerInfo PKCS7_SIGNER_INFO\n#define d2i_CMS_ContentInfo d2i_PKCS7\n#define CMS_get0_type(_p7) ((_p7)->type)\n#define pkinit_CMS_get0_content_signed(_p7) (&((_p7)->d.sign->contents->d.other->value.octet_string))\n#define pkinit_CMS_get0_content_data(_p7) (&((_p7)->d.other->value.octet_string))\n#define CMS_set1_signers_certs(_p7,_stack_of_x509,_uint)\n#define CMS_get0_SignerInfos PKCS7_get_signer_info\n#define stack_st_CMS_SignerInfo stack_st_PKCS7_SIGNER_INFO\n#undef  sk_CMS_SignerInfo_value\n#define sk_CMS_SignerInfo_value sk_PKCS7_SIGNER_INFO_value\n#define CMS_get0_eContentType(_p7) (_p7->d.sign->contents->type)\n#define CMS_verify PKCS7_verify\n#define CMS_get1_crls(_p7) (_p7->d.sign->crl)\n#define CMS_get1_certs(_p7) (_p7->d.sign->cert)\n#define CMS_ContentInfo_free(_p7) PKCS7_free(_p7)\n#define pkinit_CMS_SignerInfo_get_cert(_p7,_si,_x509_pp)        \\\n    (*_x509_pp) = PKCS7_cert_from_signer_info(_p7,_si)\n#endif\n\nstatic struct pkcs11_errstrings {\n    short code;\n    char *text;\n} pkcs11_errstrings[] = {\n    { 0x0,      \"ok\" },\n    { 0x1,      \"cancel\" },\n    { 0x2,      \"host memory\" },\n    { 0x3,      \"slot id invalid\" },\n    { 0x5,      \"general error\" },\n    { 0x6,      \"function failed\" },\n    { 0x7,      \"arguments bad\" },\n    { 0x8,      \"no event\" },\n    { 0x9,      \"need to create threads\" },\n    { 0xa,      \"cant lock\" },\n    { 0x10,     \"attribute read only\" },\n    { 0x11,     \"attribute sensitive\" },\n    { 0x12,     \"attribute type invalid\" },\n    { 0x13,     \"attribute value invalid\" },\n    { 0x20,     \"data invalid\" },\n    { 0x21,     \"data len range\" },\n    { 0x30,     \"device error\" },\n    { 0x31,     \"device memory\" },\n    { 0x32,     \"device removed\" },\n    { 0x40,     \"encrypted data invalid\" },\n    { 0x41,     \"encrypted data len range\" },\n    { 0x50,     \"function canceled\" },\n    { 0x51,     \"function not parallel\" },\n    { 0x54,     \"function not supported\" },\n    { 0x60,     \"key handle invalid\" },\n    { 0x62,     \"key size range\" },\n    { 0x63,     \"key type inconsistent\" },\n    { 0x64,     \"key not needed\" },\n    { 0x65,     \"key changed\" },\n    { 0x66,     \"key needed\" },\n    { 0x67,     \"key indigestible\" },\n    { 0x68,     \"key function not permitted\" },\n    { 0x69,     \"key not wrappable\" },\n    { 0x6a,     \"key unextractable\" },\n    { 0x70,     \"mechanism invalid\" },\n    { 0x71,     \"mechanism param invalid\" },\n    { 0x82,     \"object handle invalid\" },\n    { 0x90,     \"operation active\" },\n    { 0x91,     \"operation not initialized\" },\n    { 0xa0,     \"pin incorrect\" },\n    { 0xa1,     \"pin invalid\" },\n    { 0xa2,     \"pin len range\" },\n    { 0xa3,     \"pin expired\" },\n    { 0xa4,     \"pin locked\" },\n    { 0xb0,     \"session closed\" },\n    { 0xb1,     \"session count\" },\n    { 0xb3,     \"session handle invalid\" },\n    { 0xb4,     \"session parallel not supported\" },\n    { 0xb5,     \"session read only\" },\n    { 0xb6,     \"session exists\" },\n    { 0xb7,     \"session read only exists\" },\n    { 0xb8,     \"session read write so exists\" },\n    { 0xc0,     \"signature invalid\" },\n    { 0xc1,     \"signature len range\" },\n    { 0xd0,     \"template incomplete\" },\n    { 0xd1,     \"template inconsistent\" },\n    { 0xe0,     \"token not present\" },\n    { 0xe1,     \"token not recognized\" },\n    { 0xe2,     \"token write protected\" },\n    { 0xf0,     \"unwrapping key handle invalid\" },\n    { 0xf1,     \"unwrapping key size range\" },\n    { 0xf2,     \"unwrapping key type inconsistent\" },\n    { 0x100,    \"user already logged in\" },\n    { 0x101,    \"user not logged in\" },\n    { 0x102,    \"user pin not initialized\" },\n    { 0x103,    \"user type invalid\" },\n    { 0x104,    \"user another already logged in\" },\n    { 0x105,    \"user too many types\" },\n    { 0x110,    \"wrapped key invalid\" },\n    { 0x112,    \"wrapped key len range\" },\n    { 0x113,    \"wrapping key handle invalid\" },\n    { 0x114,    \"wrapping key size range\" },\n    { 0x115,    \"wrapping key type inconsistent\" },\n    { 0x120,    \"random seed not supported\" },\n    { 0x121,    \"random no rng\" },\n    { 0x130,    \"domain params invalid\" },\n    { 0x150,    \"buffer too small\" },\n    { 0x160,    \"saved state invalid\" },\n    { 0x170,    \"information sensitive\" },\n    { 0x180,    \"state unsaveable\" },\n    { 0x190,    \"cryptoki not initialized\" },\n    { 0x191,    \"cryptoki already initialized\" },\n    { 0x1a0,    \"mutex bad\" },\n    { 0x1a1,    \"mutex not locked\" },\n    { 0x200,    \"function rejected\" },\n    { -1,       NULL }\n};\n\n/* DH parameters */\nunsigned char pkinit_1024_dhprime[128] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nunsigned char pkinit_2048_dhprime[2048/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nunsigned char pkinit_4096_dhprime[4096/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\n    0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\n    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\n    0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\n    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\n    0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\n    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\n    0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\n    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\n    0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\n    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\n    0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\n    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\n    0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\n    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\n    0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\n    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\n    0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\n    0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\n    0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\n    0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\n    0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\n    0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\n    0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\n    0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\n    0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\n    0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\n    0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\n    0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\n    0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\n    0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\n    0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\n    0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nstatic int pkinit_oids_refs = 0;\n\nkrb5_error_code\npkinit_init_plg_crypto(pkinit_plg_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_plg_crypto_context ctx = NULL;\n\n    /* initialize openssl routines */\n    openssl_init();\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    pkiDebug(\"%s: initializing openssl crypto context at %p\\n\",\n             __FUNCTION__, ctx);\n    retval = pkinit_init_pkinit_oids(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_dh_params(ctx);\n    if (retval)\n        goto out;\n\n    *cryptoctx = ctx;\n\nout:\n    if (retval && ctx != NULL)\n        pkinit_fini_plg_crypto(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_plg_crypto(pkinit_plg_crypto_context cryptoctx)\n{\n    pkiDebug(\"%s: freeing context at %p\\n\", __FUNCTION__, cryptoctx);\n\n    if (cryptoctx == NULL)\n        return;\n    pkinit_fini_pkinit_oids(cryptoctx);\n    pkinit_fini_dh_params(cryptoctx);\n    free(cryptoctx);\n}\n\nkrb5_error_code\npkinit_init_identity_crypto(pkinit_identity_crypto_context *idctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_identity_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->identity = NULL;\n\n    retval = pkinit_init_certs(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_pkcs11(ctx);\n    if (retval)\n        goto out;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    *idctx = ctx;\n\nout:\n    if (retval) {\n        if (ctx)\n            pkinit_fini_identity_crypto(ctx);\n    }\n\n    return retval;\n}\n\nvoid\npkinit_fini_identity_crypto(pkinit_identity_crypto_context idctx)\n{\n    if (idctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing   ctx at %p\\n\", __FUNCTION__, idctx);\n    free(idctx->identity);\n    pkinit_fini_certs(idctx);\n    pkinit_fini_pkcs11(idctx);\n    free(idctx);\n}\n\nkrb5_error_code\npkinit_init_req_crypto(pkinit_req_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_req_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->dh = NULL;\n    ctx->received_cert = NULL;\n\n    *cryptoctx = ctx;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    retval = 0;\nout:\n    if (retval)\n        free(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_req_crypto(pkinit_req_crypto_context req_cryptoctx)\n{\n    if (req_cryptoctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing   ctx at %p\\n\", __FUNCTION__, req_cryptoctx);\n    if (req_cryptoctx->dh != NULL)\n        DH_free(req_cryptoctx->dh);\n    if (req_cryptoctx->received_cert != NULL)\n        X509_free(req_cryptoctx->received_cert);\n\n    free(req_cryptoctx);\n}\n\nstatic krb5_error_code\npkinit_init_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    int nid = 0;\n\n    /*\n     * If OpenSSL already knows about the OID, use the\n     * existing definition. Otherwise, create an OID object.\n     */\n#define CREATE_OBJ_IF_NEEDED(oid, vn, sn, ln)                           \\\n    nid = OBJ_txt2nid(oid);                                             \\\n    if (nid == NID_undef) {                                             \\\n        nid = OBJ_create(oid, sn, ln);                                  \\\n        if (nid == NID_undef) {                                         \\\n            pkiDebug(\"Error creating oid object for '%s'\\n\", oid);      \\\n            goto out;                                                   \\\n        }                                                               \\\n    }                                                                   \\\n    ctx->vn = OBJ_nid2obj(nid);\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.2\", id_pkinit_san,\n                         \"id-pkinit-san\", \"KRB5PrincipalName\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.1\", id_pkinit_authData,\n                         \"id-pkinit-authdata\", \"PKINIT signedAuthPack\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.2\", id_pkinit_DHKeyData,\n                         \"id-pkinit-DHKeyData\", \"PKINIT dhSignedData\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.3\", id_pkinit_rkeyData,\n                         \"id-pkinit-rkeyData\", \"PKINIT encKeyPack\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.4\", id_pkinit_KPClientAuth,\n                         \"id-pkinit-KPClientAuth\", \"PKINIT Client EKU\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.2.3.5\", id_pkinit_KPKdc,\n                         \"id-pkinit-KPKdc\", \"KDC EKU\");\n\n#if 0\n    CREATE_OBJ_IF_NEEDED(\"1.2.840.113549.1.7.1\", id_pkinit_authData9,\n                         \"id-pkcs7-data\", \"PKCS7 data\");\n#else\n    /* See note in pkinit_pkcs7type2oid() */\n    ctx->id_pkinit_authData9 = NULL;\n#endif\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.4.1.311.20.2.2\", id_ms_kp_sc_logon,\n                         \"id-ms-kp-sc-logon EKU\", \"Microsoft SmartCard Login EKU\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.4.1.311.20.2.3\", id_ms_san_upn,\n                         \"id-ms-san-upn\", \"Microsoft Universal Principal Name\");\n\n    CREATE_OBJ_IF_NEEDED(\"1.3.6.1.5.5.7.3.1\", id_kp_serverAuth,\n                         \"id-kp-serverAuth EKU\", \"Server Authentication EKU\");\n\n    /* Success */\n    retval = 0;\n    pkinit_oids_refs++;\n\nout:\n    return retval;\n}\n\nstatic krb5_error_code\nget_cert(char *filename, X509 **retcert)\n{\n    X509 *cert = NULL;\n    BIO *tmp = NULL;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retcert == NULL)\n        return EINVAL;\n\n    *retcert = NULL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n\n    cert = (X509 *) PEM_read_bio_X509(tmp, NULL, NULL, NULL);\n    if (cert == NULL) {\n        retval = EIO;\n        pkiDebug(\"failed to read certificate from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retcert = cert;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstatic krb5_error_code\nget_key(char *filename, EVP_PKEY **retkey)\n{\n    EVP_PKEY *pkey = NULL;\n    BIO *tmp = NULL;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retkey == NULL)\n        return EINVAL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n    pkey = (EVP_PKEY *) PEM_read_bio_PrivateKey(tmp, NULL, NULL, NULL);\n    if (pkey == NULL) {\n        retval = EIO;\n        pkiDebug(\"failed to read private key from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retkey = pkey;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstatic void\npkinit_fini_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    /* Only call OBJ_cleanup once! */\n    if (--pkinit_oids_refs == 0)\n        OBJ_cleanup();\n}\n\nstatic krb5_error_code\npkinit_init_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n    plgctx->dh_1024 = DH_new();\n    if (plgctx->dh_1024 == NULL)\n        goto cleanup;\n    plgctx->dh_1024->p = BN_bin2bn(pkinit_1024_dhprime,\n                                   sizeof(pkinit_1024_dhprime), NULL);\n    if ((plgctx->dh_1024->g = BN_new()) == NULL ||\n        (plgctx->dh_1024->q = BN_new()) == NULL)\n        goto cleanup;\n    BN_set_word(plgctx->dh_1024->g, DH_GENERATOR_2);\n    BN_rshift1(plgctx->dh_1024->q, plgctx->dh_1024->p);\n\n    plgctx->dh_2048 = DH_new();\n    if (plgctx->dh_2048 == NULL)\n        goto cleanup;\n    plgctx->dh_2048->p = BN_bin2bn(pkinit_2048_dhprime,\n                                   sizeof(pkinit_2048_dhprime), NULL);\n    if ((plgctx->dh_2048->g = BN_new()) == NULL ||\n        (plgctx->dh_2048->q = BN_new()) == NULL)\n        goto cleanup;\n    BN_set_word(plgctx->dh_2048->g, DH_GENERATOR_2);\n    BN_rshift1(plgctx->dh_2048->q, plgctx->dh_2048->p);\n\n    plgctx->dh_4096 = DH_new();\n    if (plgctx->dh_4096 == NULL)\n        goto cleanup;\n    plgctx->dh_4096->p = BN_bin2bn(pkinit_4096_dhprime,\n                                   sizeof(pkinit_4096_dhprime), NULL);\n    if ((plgctx->dh_4096->g = BN_new()) == NULL ||\n        (plgctx->dh_4096->q = BN_new()) == NULL)\n        goto cleanup;\n    BN_set_word(plgctx->dh_4096->g, DH_GENERATOR_2);\n    BN_rshift1(plgctx->dh_4096->q, plgctx->dh_4096->p);\n\n    retval = 0;\n\ncleanup:\n    if (retval)\n        pkinit_fini_dh_params(plgctx);\n\n    return retval;\n}\n\nstatic void\npkinit_fini_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    if (plgctx->dh_1024 != NULL)\n        DH_free(plgctx->dh_1024);\n    if (plgctx->dh_2048 != NULL)\n        DH_free(plgctx->dh_2048);\n    if (plgctx->dh_4096 != NULL)\n        DH_free(plgctx->dh_4096);\n\n    plgctx->dh_1024 = plgctx->dh_2048 = plgctx->dh_4096 = NULL;\n}\n\nstatic krb5_error_code\npkinit_init_certs(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    int i;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++)\n        ctx->creds[i] = NULL;\n    ctx->my_certs = NULL;\n    ctx->cert_index = 0;\n    ctx->my_key = NULL;\n    ctx->trustedCAs = NULL;\n    ctx->intermediateCAs = NULL;\n    ctx->revoked = NULL;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_certs(pkinit_identity_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    if (ctx->my_certs != NULL)\n        sk_X509_pop_free(ctx->my_certs, X509_free);\n\n    if (ctx->my_key != NULL)\n        EVP_PKEY_free(ctx->my_key);\n\n    if (ctx->trustedCAs != NULL)\n        sk_X509_pop_free(ctx->trustedCAs, X509_free);\n\n    if (ctx->intermediateCAs != NULL)\n        sk_X509_pop_free(ctx->intermediateCAs, X509_free);\n\n    if (ctx->revoked != NULL)\n        sk_X509_CRL_pop_free(ctx->revoked, X509_CRL_free);\n}\n\nstatic krb5_error_code\npkinit_init_pkcs11(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n#ifndef WITHOUT_PKCS11\n    ctx->p11_module_name = strdup(PKCS11_MODNAME);\n    if (ctx->p11_module_name == NULL)\n        return retval;\n    ctx->p11_module = NULL;\n    ctx->slotid = PK_NOSLOT;\n    ctx->token_label = NULL;\n    ctx->cert_label = NULL;\n    ctx->session = CK_INVALID_HANDLE;\n    ctx->p11 = NULL;\n#endif\n    ctx->pkcs11_method = 0;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_pkcs11(pkinit_identity_crypto_context ctx)\n{\n#ifndef WITHOUT_PKCS11\n    if (ctx == NULL)\n        return;\n\n    if (ctx->p11 != NULL) {\n        if (ctx->session) {\n            ctx->p11->C_CloseSession(ctx->session);\n            ctx->session = CK_INVALID_HANDLE;\n        }\n        ctx->p11->C_Finalize(NULL_PTR);\n        ctx->p11 = NULL;\n    }\n    if (ctx->p11_module != NULL) {\n        pkinit_C_UnloadModule(ctx->p11_module);\n        ctx->p11_module = NULL;\n    }\n    free(ctx->p11_module_name);\n    free(ctx->token_label);\n    free(ctx->cert_id);\n    free(ctx->cert_label);\n#endif\n}\n\nkrb5_error_code\npkinit_identity_set_prompter(pkinit_identity_crypto_context id_cryptoctx,\n                             krb5_prompter_fct prompter,\n                             void *prompter_data)\n{\n    id_cryptoctx->prompter = prompter;\n    id_cryptoctx->prompter_data = prompter_data;\n\n    return 0;\n}\n\n/*helper function for creating pkinit ContentInfo*/\nstatic krb5_error_code\ncreate_contentinfo(krb5_context context,\n                   pkinit_plg_crypto_context plg_crypto_context,\n                   ASN1_OBJECT *oid, unsigned char *data, size_t data_len,\n                   PKCS7 **out_p7)\n{\n    krb5_error_code retval = EINVAL;\n    PKCS7 *inner_p7;\n    ASN1_TYPE *pkinit_data = NULL;\n\n    *out_p7 = NULL;\n    if ((inner_p7 = PKCS7_new()) == NULL)\n        goto cleanup;\n    if ((pkinit_data = ASN1_TYPE_new()) == NULL)\n        goto cleanup;\n    pkinit_data->type = V_ASN1_OCTET_STRING;\n    if ((pkinit_data->value.octet_string = ASN1_OCTET_STRING_new()) == NULL)\n        goto cleanup;\n    if (!ASN1_OCTET_STRING_set(pkinit_data->value.octet_string,\n                               (unsigned char *) data, data_len)) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to add pkcs7 data\\n\");\n        goto cleanup;\n    }\n    if (!PKCS7_set0_type_other(inner_p7, OBJ_obj2nid(oid), pkinit_data))\n        goto cleanup;\n    retval = 0;\n    *out_p7 = inner_p7;\n    inner_p7 = NULL;\n    pkinit_data = NULL;\ncleanup:\n    if (inner_p7)\n        PKCS7_free(inner_p7);\n    if (pkinit_data)\n        ASN1_TYPE_free(pkinit_data);\n    return retval;\n}\n\nkrb5_error_code\ncms_contentinfo_create(krb5_context context,                          /* IN */\n                       pkinit_plg_crypto_context plg_cryptoctx,       /* IN */\n                       pkinit_req_crypto_context req_cryptoctx,       /* IN */\n                       pkinit_identity_crypto_context id_cryptoctx,   /* IN */\n                       int cms_msg_type,\n                       unsigned char *data, unsigned int data_len,\n                       unsigned char **out_data, unsigned int *out_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    ASN1_OBJECT *oid = NULL;\n    PKCS7 *p7 = NULL;\n    unsigned char *p;\n\n    /* Pick the correct oid for the eContentInfo. */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n    retval = create_contentinfo(context, plg_cryptoctx, oid,\n                                data, data_len, &p7);\n    if (retval != 0)\n        goto cleanup;\n    *out_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*out_data_len)) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup;\n    }\n    retval = ENOMEM;\n    if ((p = *out_data = malloc(*out_data_len)) == NULL)\n        goto cleanup;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup;\n    }\n    retval = 0;\ncleanup:\n    if (p7)\n        PKCS7_free(p7);\n    if (oid)\n        ASN1_OBJECT_free(oid);\n    return retval;\n}\n\n\n\nkrb5_error_code\ncms_signeddata_create(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int cms_msg_type,\n                      int include_certchain,\n                      unsigned char *data,\n                      unsigned int data_len,\n                      unsigned char **signed_data,\n                      unsigned int *signed_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    PKCS7  *p7 = NULL, *inner_p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    PKCS7_SIGNER_INFO *p7si = NULL;\n    unsigned char *p;\n    STACK_OF(X509) * cert_stack = NULL;\n    ASN1_OCTET_STRING *digest_attr = NULL;\n    EVP_MD_CTX ctx, ctx2;\n    const EVP_MD *md_tmp = NULL;\n    unsigned char md_data[EVP_MAX_MD_SIZE], md_data2[EVP_MAX_MD_SIZE];\n    unsigned char *digestInfo_buf = NULL, *abuf = NULL;\n    unsigned int md_len, md_len2, alen, digestInfo_len;\n    STACK_OF(X509_ATTRIBUTE) * sk;\n    unsigned char *sig = NULL;\n    unsigned int sig_len = 0;\n    X509_ALGOR *alg = NULL;\n    ASN1_OCTET_STRING *digest = NULL;\n    unsigned int alg_len = 0, digest_len = 0;\n    unsigned char *y = NULL, *alg_buf = NULL, *digest_buf = NULL;\n    X509 *cert = NULL;\n    ASN1_OBJECT *oid = NULL;\n\n    /* Start creating PKCS7 data. */\n    if ((p7 = PKCS7_new()) == NULL)\n        goto cleanup;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto cleanup;\n    p7->d.sign = p7s;\n    if (!ASN1_INTEGER_set(p7s->version, 3))\n        goto cleanup;\n\n    /* pick the correct oid for the eContentInfo */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    if (id_cryptoctx->my_certs != NULL) {\n        /* create a cert chain that has at least the signer's certificate */\n        if ((cert_stack = sk_X509_new_null()) == NULL)\n            goto cleanup;\n\n        cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n        if (!include_certchain) {\n            pkiDebug(\"only including signer's certificate\\n\");\n            sk_X509_push(cert_stack, X509_dup(cert));\n        } else {\n            /* create a cert chain */\n            X509_STORE *certstore = NULL;\n            X509_STORE_CTX certctx;\n            STACK_OF(X509) *certstack = NULL;\n            char buf[DN_BUF_LEN];\n            unsigned int i = 0, size = 0;\n\n            if ((certstore = X509_STORE_new()) == NULL)\n                goto cleanup;\n            pkiDebug(\"building certificate chain\\n\");\n            X509_STORE_set_verify_cb_func(certstore, openssl_callback);\n            X509_STORE_CTX_init(&certctx, certstore, cert,\n                                id_cryptoctx->intermediateCAs);\n            X509_STORE_CTX_trusted_stack(&certctx, id_cryptoctx->trustedCAs);\n            if (!X509_verify_cert(&certctx)) {\n                int code = X509_STORE_CTX_get_error(&certctx);\n                const char *msg = X509_verify_cert_error_string(code);\n                pkiDebug(\"failed to create a certificate chain: %s\\n\", msg);\n                if (!sk_X509_num(id_cryptoctx->trustedCAs))\n                    pkiDebug(\"No trusted CAs found. Check your X509_anchors\\n\");\n                retval = KRB5_PREAUTH_FAILED;\n                krb5_set_error_message(context, retval,\n                                       _(\"Cannot create cert chain: %s\"), msg);\n                goto cleanup;\n            }\n            certstack = X509_STORE_CTX_get1_chain(&certctx);\n            size = sk_X509_num(certstack);\n            pkiDebug(\"size of certificate chain = %d\\n\", size);\n            for(i = 0; i < size - 1; i++) {\n                X509 *x = sk_X509_value(certstack, i);\n                X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n                sk_X509_push(cert_stack, X509_dup(x));\n            }\n            X509_STORE_CTX_cleanup(&certctx);\n            X509_STORE_free(certstore);\n            sk_X509_pop_free(certstack, X509_free);\n        }\n        p7s->cert = cert_stack;\n\n        /* fill-in PKCS7_SIGNER_INFO */\n        if ((p7si = PKCS7_SIGNER_INFO_new()) == NULL)\n            goto cleanup;\n        if (!ASN1_INTEGER_set(p7si->version, 1))\n            goto cleanup;\n        if (!X509_NAME_set(&p7si->issuer_and_serial->issuer,\n                           X509_get_issuer_name(cert)))\n            goto cleanup;\n        /* because ASN1_INTEGER_set is used to set a 'long' we will do\n         * things the ugly way. */\n        M_ASN1_INTEGER_free(p7si->issuer_and_serial->serial);\n        if (!(p7si->issuer_and_serial->serial =\n              M_ASN1_INTEGER_dup(X509_get_serialNumber(cert))))\n            goto cleanup;\n\n        /* will not fill-out EVP_PKEY because it's on the smartcard */\n\n        /* Set digest algs */\n        p7si->digest_alg->algorithm = OBJ_nid2obj(NID_sha1);\n\n        if (p7si->digest_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_alg->parameter);\n        if ((p7si->digest_alg->parameter = ASN1_TYPE_new()) == NULL)\n            goto cleanup;\n        p7si->digest_alg->parameter->type = V_ASN1_NULL;\n\n        /* Set sig algs */\n        if (p7si->digest_enc_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_enc_alg->parameter);\n        p7si->digest_enc_alg->algorithm = OBJ_nid2obj(NID_sha1WithRSAEncryption);\n        if (!(p7si->digest_enc_alg->parameter = ASN1_TYPE_new()))\n            goto cleanup;\n        p7si->digest_enc_alg->parameter->type = V_ASN1_NULL;\n\n        if (cms_msg_type == CMS_SIGN_DRAFT9){\n            /* don't include signed attributes for pa-type 15 request */\n            abuf = data;\n            alen = data_len;\n        } else {\n            /* add signed attributes */\n            /* compute sha1 digest over the EncapsulatedContentInfo */\n            EVP_MD_CTX_init(&ctx);\n            EVP_DigestInit_ex(&ctx, EVP_sha1(), NULL);\n            EVP_DigestUpdate(&ctx, data, data_len);\n            md_tmp = EVP_MD_CTX_md(&ctx);\n            EVP_DigestFinal_ex(&ctx, md_data, &md_len);\n\n            /* create a message digest attr */\n            digest_attr = ASN1_OCTET_STRING_new();\n            ASN1_OCTET_STRING_set(digest_attr, md_data, (int)md_len);\n            PKCS7_add_signed_attribute(p7si, NID_pkcs9_messageDigest,\n                                       V_ASN1_OCTET_STRING, (char *) digest_attr);\n\n            /* create a content-type attr */\n            PKCS7_add_signed_attribute(p7si, NID_pkcs9_contentType,\n                                       V_ASN1_OBJECT, oid);\n\n            /* create the signature over signed attributes. get DER encoded value */\n            /* This is the place where smartcard signature needs to be calculated */\n            sk = p7si->auth_attr;\n            alen = ASN1_item_i2d((ASN1_VALUE *) sk, &abuf,\n                                 ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\n            if (abuf == NULL)\n                goto cleanup2;\n        } /* signed attributes */\n\n#ifndef WITHOUT_PKCS11\n        /* Some tokens can only do RSAEncryption without sha1 hash */\n        /* to compute sha1WithRSAEncryption, encode the algorithm ID for the hash\n         * function and the hash value into an ASN.1 value of type DigestInfo\n         * DigestInfo::=SEQUENCE {\n         *  digestAlgorithm  AlgorithmIdentifier,\n         *  digest OCTET STRING }\n         */\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            pkiDebug(\"mech = CKM_RSA_PKCS\\n\");\n            EVP_MD_CTX_init(&ctx2);\n            /* if this is not draft9 request, include digest signed attribute */\n            if (cms_msg_type != CMS_SIGN_DRAFT9)\n                EVP_DigestInit_ex(&ctx2, md_tmp, NULL);\n            else\n                EVP_DigestInit_ex(&ctx2, EVP_sha1(), NULL);\n            EVP_DigestUpdate(&ctx2, abuf, alen);\n            EVP_DigestFinal_ex(&ctx2, md_data2, &md_len2);\n\n            alg = X509_ALGOR_new();\n            if (alg == NULL)\n                goto cleanup2;\n            alg->algorithm = OBJ_nid2obj(NID_sha1);\n            alg->parameter = NULL;\n            alg_len = i2d_X509_ALGOR(alg, NULL);\n            alg_buf = malloc(alg_len);\n            if (alg_buf == NULL)\n                goto cleanup2;\n\n            digest = ASN1_OCTET_STRING_new();\n            if (digest == NULL)\n                goto cleanup2;\n            ASN1_OCTET_STRING_set(digest, md_data2, (int)md_len2);\n            digest_len = i2d_ASN1_OCTET_STRING(digest, NULL);\n            digest_buf = malloc(digest_len);\n            if (digest_buf == NULL)\n                goto cleanup2;\n\n            digestInfo_len = ASN1_object_size(1, (int)(alg_len + digest_len),\n                                              V_ASN1_SEQUENCE);\n            y = digestInfo_buf = malloc(digestInfo_len);\n            if (digestInfo_buf == NULL)\n                goto cleanup2;\n            ASN1_put_object(&y, 1, (int)(alg_len + digest_len), V_ASN1_SEQUENCE,\n                            V_ASN1_UNIVERSAL);\n            i2d_X509_ALGOR(alg, &y);\n            i2d_ASN1_OCTET_STRING(digest, &y);\n#ifdef DEBUG_SIG\n            pkiDebug(\"signing buffer\\n\");\n            print_buffer(digestInfo_buf, digestInfo_len);\n            print_buffer_bin(digestInfo_buf, digestInfo_len, \"/tmp/pkcs7_tosign\");\n#endif\n            retval = pkinit_sign_data(context, id_cryptoctx, digestInfo_buf,\n                                      digestInfo_len, &sig, &sig_len);\n        } else\n#endif\n        {\n            pkiDebug(\"mech = %s\\n\",\n                     id_cryptoctx->pkcs11_method == 1 ? \"CKM_SHA1_RSA_PKCS\" : \"FS\");\n            retval = pkinit_sign_data(context, id_cryptoctx, abuf, alen,\n                                      &sig, &sig_len);\n        }\n#ifdef DEBUG_SIG\n        print_buffer(sig, sig_len);\n#endif\n        if (cms_msg_type != CMS_SIGN_DRAFT9 )\n            free(abuf);\n        if (retval)\n            goto cleanup2;\n\n        /* Add signature */\n        if (!ASN1_STRING_set(p7si->enc_digest, (unsigned char *) sig,\n                             (int)sig_len)) {\n            unsigned long err = ERR_peek_error();\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   ERR_error_string(err, NULL));\n            pkiDebug(\"failed to add a signed digest attribute\\n\");\n            goto cleanup2;\n        }\n        /* adder signer_info to pkcs7 signed */\n        if (!PKCS7_add_signer(p7, p7si))\n            goto cleanup2;\n    } /* we have a certificate */\n\n    /* start on adding data to the pkcs7 signed */\n    retval = create_contentinfo(context, plg_cryptoctx, oid,\n                                data, data_len, &inner_p7);\n    if (p7s->contents != NULL)\n        PKCS7_free(p7s->contents);\n    p7s->contents = inner_p7;\n\n    *signed_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*signed_data_len)) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup2;\n    }\n    retval = ENOMEM;\n    if ((p = *signed_data = malloc(*signed_data_len)) == NULL)\n        goto cleanup2;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        unsigned long err = ERR_peek_error();\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"failed to der encode pkcs7\\n\");\n        goto cleanup2;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    if (cms_msg_type == CMS_SIGN_CLIENT) {\n        print_buffer_bin(*signed_data, *signed_data_len,\n                         \"/tmp/client_pkcs7_signeddata\");\n    } else {\n        if (cms_msg_type == CMS_SIGN_SERVER) {\n            print_buffer_bin(*signed_data, *signed_data_len,\n                             \"/tmp/kdc_pkcs7_signeddata\");\n        } else {\n            print_buffer_bin(*signed_data, *signed_data_len,\n                             \"/tmp/draft9_pkcs7_signeddata\");\n        }\n    }\n#endif\n\ncleanup2:\n    if (p7si) {\n        if (cms_msg_type != CMS_SIGN_DRAFT9)\n            EVP_MD_CTX_cleanup(&ctx);\n#ifndef WITHOUT_PKCS11\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            EVP_MD_CTX_cleanup(&ctx2);\n            free(digest_buf);\n            free(digestInfo_buf);\n            free(alg_buf);\n            if (digest != NULL)\n                ASN1_OCTET_STRING_free(digest);\n        }\n#endif\n        if (alg != NULL)\n            X509_ALGOR_free(alg);\n    }\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    free(sig);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_signeddata_verify(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int cms_msg_type,\n                      int require_crl_checking,\n                      unsigned char *signed_data,\n                      unsigned int signed_data_len,\n                      unsigned char **data,\n                      unsigned int *data_len,\n                      unsigned char **authz_data,\n                      unsigned int *authz_data_len,\n                      int *is_signed)\n{\n    /*\n     * Warning: Since most openssl functions do not set retval, large chunks of\n     * this function assume that retval is always a failure and may go to\n     * cleanup without setting retval explicitly. Make sure retval is not set\n     * to 0 or errors such as signature verification failure may be converted\n     * to success with significant security consequences.\n     */\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    CMS_ContentInfo *cms = NULL;\n    BIO *out = NULL;\n    int flags = CMS_NO_SIGNER_CERT_VERIFY;\n    int valid_oid = 0;\n    unsigned int i = 0;\n    unsigned int vflags = 0, size = 0;\n    const unsigned char *p = signed_data;\n    STACK_OF(CMS_SignerInfo) *si_sk = NULL;\n    CMS_SignerInfo *si = NULL;\n    X509 *x = NULL;\n    X509_STORE *store = NULL;\n    X509_STORE_CTX cert_ctx;\n    STACK_OF(X509) *signerCerts = NULL;\n    STACK_OF(X509) *intermediateCAs = NULL;\n    STACK_OF(X509_CRL) *signerRevoked = NULL;\n    STACK_OF(X509_CRL) *revoked = NULL;\n    STACK_OF(X509) *verified_chain = NULL;\n    ASN1_OBJECT *oid = NULL;\n    const ASN1_OBJECT *type = NULL, *etype = NULL;\n    ASN1_OCTET_STRING **octets;\n    krb5_external_principal_identifier **krb5_verified_chain = NULL;\n    krb5_data *authz = NULL;\n    char buf[DN_BUF_LEN];\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(signed_data, signed_data_len,\n                     \"/tmp/client_received_pkcs7_signeddata\");\n#endif\n    if (is_signed)\n        *is_signed = 1;\n    /* Do this early enough to create the shadow OID for pkcs7-data if needed */\n    oid = pkinit_pkcs7type2oid(plgctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    /* decode received CMS message */\n    if ((cms = d2i_CMS_ContentInfo(NULL, &p, (int)signed_data_len)) == NULL) {\n        unsigned long err = ERR_peek_error();\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        pkiDebug(\"%s: failed to decode message: %s\\n\",\n                 __FUNCTION__, ERR_error_string(err, NULL));\n        goto cleanup;\n    }\n    etype = CMS_get0_eContentType(cms);\n\n    /*\n     * Prior to 1.10 the MIT client incorrectly omitted the pkinit structure\n     * directly in a CMS ContentInfo rather than using SignedData with no\n     * signers. Handle that case.\n     */\n    type = CMS_get0_type(cms);\n    if (is_signed && !OBJ_cmp(type, oid)) {\n        unsigned char *d;\n        *is_signed = 0;\n        octets = pkinit_CMS_get0_content_data(cms);\n        if (!octets || ((*octets)->type != V_ASN1_OCTET_STRING)) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Invalid pkinit packet: octet string \"\n                                     \"expected\"));\n            goto cleanup;\n        }\n        *data_len = ASN1_STRING_length(*octets);\n        d = malloc(*data_len);\n        if (d == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        memcpy(d, ASN1_STRING_data(*octets),\n               *data_len);\n        *data = d;\n        goto out;\n    } else {\n        /* Verify that the received message is CMS SignedData message. */\n        if (OBJ_obj2nid(type) != NID_pkcs7_signed) {\n            pkiDebug(\"Expected id-signedData CMS msg (received type = %d)\\n\",\n                     OBJ_obj2nid(type));\n            krb5_set_error_message(context, retval, _(\"wrong oid\\n\"));\n            goto cleanup;\n        }\n    }\n\n    /* setup to verify X509 certificate used to sign CMS message */\n    if (!(store = X509_STORE_new()))\n        goto cleanup;\n\n    /* check if we are inforcing CRL checking */\n    vflags = X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\n    if (require_crl_checking)\n        X509_STORE_set_verify_cb_func(store, openssl_callback);\n    else\n        X509_STORE_set_verify_cb_func(store, openssl_callback_ignore_crls);\n    X509_STORE_set_flags(store, vflags);\n\n    /*\n     * Get the signer's information from the CMS message.  Match signer ID\n     * against anchors and intermediate CAs in case no certs are present in the\n     * SignedData.  If we start sending kdcPkId values in requests, we'll need\n     * to match against the source of that information too.\n     */\n    CMS_set1_signers_certs(cms, NULL, 0);\n    CMS_set1_signers_certs(cms, idctx->trustedCAs, CMS_NOINTERN);\n    CMS_set1_signers_certs(cms, idctx->intermediateCAs, CMS_NOINTERN);\n    if (((si_sk = CMS_get0_SignerInfos(cms)) == NULL) ||\n        ((si = sk_CMS_SignerInfo_value(si_sk, 0)) == NULL)) {\n        /* Not actually signed; anonymous case */\n        if (!is_signed)\n            goto cleanup;\n        *is_signed = 0;\n        /* We cannot use CMS_dataInit because there may be no digest */\n        octets = pkinit_CMS_get0_content_signed(cms);\n        if (octets)\n            out = BIO_new_mem_buf((*octets)->data, (*octets)->length);\n        if (out == NULL)\n            goto cleanup;\n    } else {\n        pkinit_CMS_SignerInfo_get_cert(cms, si, &x);\n        if (x == NULL)\n            goto cleanup;\n\n        /* create available CRL information (get local CRLs and include CRLs\n         * received in the CMS message\n         */\n        signerRevoked = CMS_get1_crls(cms);\n        if (idctx->revoked == NULL)\n            revoked = signerRevoked;\n        else if (signerRevoked == NULL)\n            revoked = idctx->revoked;\n        else {\n            size = sk_X509_CRL_num(idctx->revoked);\n            revoked = sk_X509_CRL_new_null();\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(idctx->revoked, i));\n            size = sk_X509_CRL_num(signerRevoked);\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(signerRevoked, i));\n        }\n\n        /* create available intermediate CAs chains (get local intermediateCAs and\n         * include the CA chain received in the CMS message\n         */\n        signerCerts = CMS_get1_certs(cms);\n        if (idctx->intermediateCAs == NULL)\n            intermediateCAs = signerCerts;\n        else if (signerCerts == NULL)\n            intermediateCAs = idctx->intermediateCAs;\n        else {\n            size = sk_X509_num(idctx->intermediateCAs);\n            intermediateCAs = sk_X509_new_null();\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs,\n                             sk_X509_value(idctx->intermediateCAs, i));\n            }\n            size = sk_X509_num(signerCerts);\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs, sk_X509_value(signerCerts, i));\n            }\n        }\n\n        /* initialize x509 context with the received certificate and\n         * trusted and intermediate CA chains and CRLs\n         */\n        if (!X509_STORE_CTX_init(&cert_ctx, store, x, intermediateCAs))\n            goto cleanup;\n\n        X509_STORE_CTX_set0_crls(&cert_ctx, revoked);\n\n        /* add trusted CAs certificates for cert verification */\n        if (idctx->trustedCAs != NULL)\n            X509_STORE_CTX_trusted_stack(&cert_ctx, idctx->trustedCAs);\n        else {\n            pkiDebug(\"unable to find any trusted CAs\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_CERTCHAIN\n        if (intermediateCAs != NULL) {\n            size = sk_X509_num(intermediateCAs);\n            pkiDebug(\"untrusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(intermediateCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (idctx->trustedCAs != NULL) {\n            size = sk_X509_num(idctx->trustedCAs);\n            pkiDebug(\"trusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(idctx->trustedCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (revoked != NULL) {\n            size = sk_X509_CRL_num(revoked);\n            pkiDebug(\"CRL chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_CRL *crl = sk_X509_CRL_value(revoked, i);\n                X509_NAME_oneline(X509_CRL_get_issuer(crl), buf, sizeof(buf));\n                pkiDebug(\"crls by CA #%d: %s\\n\", i , buf);\n            }\n        }\n#endif\n\n        i = X509_verify_cert(&cert_ctx);\n        if (i <= 0) {\n            int j = X509_STORE_CTX_get_error(&cert_ctx);\n\n            reqctx->received_cert = X509_dup(cert_ctx.current_cert);\n            switch(j) {\n            case X509_V_ERR_CERT_REVOKED:\n                retval = KRB5KDC_ERR_REVOKED_CERTIFICATE;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_CRL:\n                retval = KRB5KDC_ERR_REVOCATION_STATUS_UNKNOWN;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n                retval = KRB5KDC_ERR_CANT_VERIFY_CERTIFICATE;\n                break;\n            default:\n                retval = KRB5KDC_ERR_INVALID_CERTIFICATE;\n            }\n            if (reqctx->received_cert == NULL)\n                strlcpy(buf, \"(none)\", sizeof(buf));\n            else\n                X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                                  buf, sizeof(buf));\n            pkiDebug(\"problem with cert DN = %s (error=%d) %s\\n\", buf, j,\n                     X509_verify_cert_error_string(j));\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   X509_verify_cert_error_string(j));\n#ifdef DEBUG_CERTCHAIN\n            size = sk_X509_num(signerCerts);\n            pkiDebug(\"received cert chain of size %d\\n\", size);\n            for (j = 0; j < size; j++) {\n                X509 *tmp_cert = sk_X509_value(signerCerts, j);\n                X509_NAME_oneline(X509_get_subject_name(tmp_cert), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", j, buf);\n            }\n#endif\n        } else {\n            /* retrieve verified certificate chain */\n            if (cms_msg_type == CMS_SIGN_CLIENT || cms_msg_type == CMS_SIGN_DRAFT9)\n                verified_chain = X509_STORE_CTX_get1_chain(&cert_ctx);\n        }\n        X509_STORE_CTX_cleanup(&cert_ctx);\n        if (i <= 0)\n            goto cleanup;\n        out = BIO_new(BIO_s_mem());\n        if (cms_msg_type == CMS_SIGN_DRAFT9)\n            flags |= CMS_NOATTR;\n        if (CMS_verify(cms, NULL, store, NULL, out, flags) == 0) {\n            unsigned long err = ERR_peek_error();\n            switch(ERR_GET_REASON(err)) {\n            case PKCS7_R_DIGEST_FAILURE:\n                retval = KRB5KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED;\n                break;\n            case PKCS7_R_SIGNATURE_FAILURE:\n            default:\n                retval = KRB5KDC_ERR_INVALID_SIG;\n            }\n            pkiDebug(\"CMS Verification failure\\n\");\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   ERR_error_string(err, NULL));\n            goto cleanup;\n        }\n    } /* message was signed */\n    if (!OBJ_cmp(etype, oid))\n        valid_oid = 1;\n    else if (cms_msg_type == CMS_SIGN_DRAFT9) {\n        /*\n         * Various implementations of the pa-type 15 request use\n         * different OIDS.  We check that the returned object\n         * has any of the acceptable OIDs\n         */\n        ASN1_OBJECT *client_oid = NULL, *server_oid = NULL, *rsa_oid = NULL;\n        client_oid = pkinit_pkcs7type2oid(plgctx, CMS_SIGN_CLIENT);\n        server_oid = pkinit_pkcs7type2oid(plgctx, CMS_SIGN_SERVER);\n        rsa_oid = pkinit_pkcs7type2oid(plgctx, CMS_ENVEL_SERVER);\n        if (!OBJ_cmp(etype, client_oid) ||\n            !OBJ_cmp(etype, server_oid) ||\n            !OBJ_cmp(etype, rsa_oid))\n            valid_oid = 1;\n    }\n\n    if (valid_oid)\n        pkiDebug(\"CMS Verification successful\\n\");\n    else {\n        pkiDebug(\"wrong oid in eContentType\\n\");\n        print_buffer(etype->data,\n                     (unsigned int)etype->length);\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* transfer the data from CMS message into return buffer */\n    for (size = 0;;) {\n        int remain;\n        retval = ENOMEM;\n        if ((*data = realloc(*data, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        remain = BIO_read(out, &((*data)[size]), 1024 * 10);\n        if (remain <= 0)\n            break;\n        else\n            size += remain;\n    }\n    *data_len = size;\n\n    if (x) {\n        reqctx->received_cert = X509_dup(x);\n\n        /* generate authorization data */\n        if (cms_msg_type == CMS_SIGN_CLIENT || cms_msg_type == CMS_SIGN_DRAFT9) {\n\n            if (authz_data == NULL || authz_data_len == NULL)\n                goto out;\n\n            *authz_data = NULL;\n            retval = create_identifiers_from_stack(verified_chain,\n                                                   &krb5_verified_chain);\n            if (retval) {\n                pkiDebug(\"create_identifiers_from_stack failed\\n\");\n                goto cleanup;\n            }\n\n            retval = k5int_encode_krb5_td_trusted_certifiers((const krb5_external_principal_identifier **)krb5_verified_chain, &authz);\n            if (retval) {\n                pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_ASN1\n            print_buffer_bin((unsigned char *)authz->data, authz->length,\n                             \"/tmp/kdc_ad_initial_verified_cas\");\n#endif\n            *authz_data = malloc(authz->length);\n            if (*authz_data == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            memcpy(*authz_data, authz->data, authz->length);\n            *authz_data_len = authz->length;\n        }\n    }\nout:\n    retval = 0;\n\ncleanup:\n    if (out != NULL)\n        BIO_free(out);\n    if (store != NULL)\n        X509_STORE_free(store);\n    if (cms != NULL) {\n        if (signerCerts != NULL)\n            pkinit_CMS_free1_certs(signerCerts);\n        if (idctx->intermediateCAs != NULL && signerCerts)\n            sk_X509_free(intermediateCAs);\n        if (signerRevoked != NULL)\n            pkinit_CMS_free1_crls(signerRevoked);\n        if (idctx->revoked != NULL && signerRevoked)\n            sk_X509_CRL_free(revoked);\n        CMS_ContentInfo_free(cms);\n    }\n    if (verified_chain != NULL)\n        sk_X509_pop_free(verified_chain, X509_free);\n    if (krb5_verified_chain != NULL)\n        free_krb5_external_principal_identifier(&krb5_verified_chain);\n    if (authz != NULL)\n        krb5_free_data(context, authz);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_create(krb5_context context,\n                         pkinit_plg_crypto_context plgctx,\n                         pkinit_req_crypto_context reqctx,\n                         pkinit_identity_crypto_context idctx,\n                         krb5_preauthtype pa_type,\n                         int include_certchain,\n                         unsigned char *key_pack,\n                         unsigned int key_pack_len,\n                         unsigned char **out,\n                         unsigned int *out_len)\n{\n\n    krb5_error_code retval = ENOMEM;\n    PKCS7 *p7 = NULL;\n    BIO *in = NULL;\n    unsigned char *p = NULL, *signed_data = NULL, *enc_data = NULL;\n    int signed_data_len = 0, enc_data_len = 0, flags = PKCS7_BINARY;\n    STACK_OF(X509) *encerts = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int cms_msg_type;\n\n    /* create the PKCS7 SignedData portion of the PKCS7 EnvelopedData */\n    switch ((int)pa_type) {\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        cms_msg_type = CMS_SIGN_DRAFT9;\n        break;\n    case KRB5_PADATA_PK_AS_REQ:\n        cms_msg_type = CMS_ENVEL_SERVER;\n        break;\n    default:\n        goto cleanup;\n    }\n\n    retval = cms_signeddata_create(context, plgctx, reqctx, idctx,\n                                   cms_msg_type, include_certchain, key_pack, key_pack_len,\n                                   &signed_data, (unsigned int *)&signed_data_len);\n    if (retval) {\n        pkiDebug(\"failed to create pkcs7 signed data\\n\");\n        goto cleanup;\n    }\n\n    /* check we have client's certificate */\n    if (reqctx->received_cert == NULL) {\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    encerts = sk_X509_new_null();\n    sk_X509_push(encerts, reqctx->received_cert);\n\n    cipher = EVP_des_ede3_cbc();\n    in = BIO_new(BIO_s_mem());\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        prepare_enc_data(signed_data, signed_data_len, &enc_data,\n                         &enc_data_len);\n        retval = BIO_write(in, enc_data, enc_data_len);\n        if (retval != enc_data_len) {\n            pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n            goto cleanup;\n        }\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        retval = BIO_write(in, signed_data, signed_data_len);\n        if (retval != signed_data_len) {\n            pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    p7 = PKCS7_encrypt(encerts, in, cipher, flags);\n    if (p7 == NULL) {\n        pkiDebug(\"failed to encrypt PKCS7 object\\n\");\n        retval = -1;\n        goto cleanup;\n    }\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REQ:\n        p7->d.enveloped->enc_data->content_type =\n            OBJ_nid2obj(NID_pkcs7_signed);\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n    case KRB5_PADATA_PK_AS_REQ_OLD:\n        p7->d.enveloped->enc_data->content_type =\n            OBJ_nid2obj(NID_pkcs7_data);\n        break;\n        break;\n        break;\n        break;\n    }\n\n    *out_len = i2d_PKCS7(p7, NULL);\n    if (!*out_len || (p = *out = malloc(*out_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        pkiDebug(\"unable to write pkcs7 object\\n\");\n        goto cleanup;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(*out, *out_len, \"/tmp/kdc_enveloped_data\");\n#endif\n\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (in != NULL)\n        BIO_free(in);\n    free(signed_data);\n    free(enc_data);\n    if (encerts != NULL)\n        sk_X509_free(encerts);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_verify(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         krb5_preauthtype pa_type,\n                         int require_crl_checking,\n                         unsigned char *enveloped_data,\n                         unsigned int enveloped_data_len,\n                         unsigned char **data,\n                         unsigned int *data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7 *p7 = NULL;\n    BIO *out = NULL;\n    int i = 0;\n    unsigned int size = 0;\n    const unsigned char *p = enveloped_data;\n    unsigned int tmp_buf_len = 0, tmp_buf2_len = 0, vfy_buf_len = 0;\n    unsigned char *tmp_buf = NULL, *tmp_buf2 = NULL, *vfy_buf = NULL;\n    int msg_type = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(enveloped_data, enveloped_data_len,\n                     \"/tmp/client_envelopeddata\");\n#endif\n    /* decode received PKCS7 message */\n    if ((p7 = d2i_PKCS7(NULL, &p, (int)enveloped_data_len)) == NULL) {\n        unsigned long err = ERR_peek_error();\n        pkiDebug(\"failed to decode pkcs7\\n\");\n        krb5_set_error_message(context, retval, \"%s\\n\",\n                               ERR_error_string(err, NULL));\n        goto cleanup;\n    }\n\n    /* verify that the received message is PKCS7 EnvelopedData message */\n    if (OBJ_obj2nid(p7->type) != NID_pkcs7_enveloped) {\n        pkiDebug(\"Expected id-enveloped PKCS7 msg (received type = %d)\\n\",\n                 OBJ_obj2nid(p7->type));\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* decrypt received PKCS7 message */\n    out = BIO_new(BIO_s_mem());\n    if (pkcs7_decrypt(context, id_cryptoctx, p7, out)) {\n        pkiDebug(\"PKCS7 decryption successful\\n\");\n    } else {\n        unsigned long err = ERR_peek_error();\n        if (err != 0)\n            krb5_set_error_message(context, retval, \"%s\\n\",\n                                   ERR_error_string(err, NULL));\n        pkiDebug(\"PKCS7 decryption failed\\n\");\n        goto cleanup;\n    }\n\n    /* transfer the decoded PKCS7 SignedData message into a separate buffer */\n    for (;;) {\n        if ((tmp_buf = realloc(tmp_buf, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        i = BIO_read(out, &(tmp_buf[size]), 1024 * 10);\n        if (i <= 0)\n            break;\n        else\n            size += i;\n    }\n    tmp_buf_len = size;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(tmp_buf, tmp_buf_len, \"/tmp/client_enc_keypack\");\n#endif\n    /* verify PKCS7 SignedData message */\n    switch (pa_type) {\n    case KRB5_PADATA_PK_AS_REP:\n        msg_type = CMS_ENVEL_SERVER;\n\n        break;\n    case KRB5_PADATA_PK_AS_REP_OLD:\n        msg_type = CMS_SIGN_DRAFT9;\n        break;\n    default:\n        pkiDebug(\"%s: unrecognized pa_type = %d\\n\", __FUNCTION__, pa_type);\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    /*\n     * If this is the RFC style, wrap the signed data to make\n     * decoding easier in the verify routine.\n     * For draft9-compatible, we don't do anything because it\n     * is already wrapped.\n     */\n#ifdef LONGHORN_BETA_COMPAT\n    /*\n     * The Longhorn server returns the expected RFC-style data, but\n     * it is missing the sequence tag and length, so it requires\n     * special processing when wrapping.\n     * This will hopefully be fixed before the final release and\n     * this can all be removed.\n     */\n    if (msg_type == CMS_ENVEL_SERVER || longhorn == 1) {\n        retval = wrap_signeddata(tmp_buf, tmp_buf_len,\n                                 &tmp_buf2, &tmp_buf2_len, longhorn);\n        if (retval) {\n            pkiDebug(\"failed to encode signeddata\\n\");\n            goto cleanup;\n        }\n        vfy_buf = tmp_buf2;\n        vfy_buf_len = tmp_buf2_len;\n\n    } else {\n        vfy_buf = tmp_buf;\n        vfy_buf_len = tmp_buf_len;\n    }\n#else\n    if (msg_type == CMS_ENVEL_SERVER) {\n        retval = wrap_signeddata(tmp_buf, tmp_buf_len,\n                                 &tmp_buf2, &tmp_buf2_len);\n        if (retval) {\n            pkiDebug(\"failed to encode signeddata\\n\");\n            goto cleanup;\n        }\n        vfy_buf = tmp_buf2;\n        vfy_buf_len = tmp_buf2_len;\n\n    } else {\n        vfy_buf = tmp_buf;\n        vfy_buf_len = tmp_buf_len;\n    }\n#endif\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(vfy_buf, vfy_buf_len, \"/tmp/client_enc_keypack2\");\n#endif\n\n    retval = cms_signeddata_verify(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, msg_type,\n                                   require_crl_checking,\n                                   vfy_buf, vfy_buf_len,\n                                   data, data_len, NULL, NULL, NULL);\n\n    if (!retval)\n        pkiDebug(\"PKCS7 Verification Success\\n\");\n    else {\n        pkiDebug(\"PKCS7 Verification Failure\\n\");\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (out != NULL)\n        BIO_free(out);\n    free(tmp_buf);\n    free(tmp_buf2);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    if ((l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1)) >= 0) {\n        X509_EXTENSION *ext = NULL;\n        GENERAL_NAMES *ialt = NULL;\n        GENERAL_NAME *gen = NULL;\n        int ret = 0;\n        unsigned int num_sans = 0;\n\n        if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n            pkiDebug(\"%s: found no subject alt name extensions\\n\",\n                     __FUNCTION__);\n            goto cleanup;\n        }\n        num_sans = sk_GENERAL_NAME_num(ialt);\n\n        pkiDebug(\"%s: found %d subject alt name extension(s)\\n\",\n                 __FUNCTION__, num_sans);\n\n        /* OK, we're likely returning something. Allocate return values */\n        if (princs_ret != NULL) {\n            princs = calloc(num_sans + 1, sizeof(krb5_principal));\n            if (princs == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n        }\n        if (upn_ret != NULL) {\n            upns = calloc(num_sans + 1, sizeof(krb5_principal));\n            if (upns == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n        }\n        if (dns_ret != NULL) {\n            dnss = calloc(num_sans + 1, sizeof(*dnss));\n            if (dnss == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n        }\n\n        for (i = 0; i < num_sans; i++) {\n            krb5_data name = { 0, 0, NULL };\n\n            gen = sk_GENERAL_NAME_value(ialt, i);\n            switch (gen->type) {\n            case GEN_OTHERNAME:\n                name.length = gen->d.otherName->value->value.sequence->length;\n                name.data = (char *)gen->d.otherName->value->value.sequence->data;\n                if (princs != NULL\n                    && OBJ_cmp(plgctx->id_pkinit_san,\n                               gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                    print_buffer_bin((unsigned char *)name.data, name.length,\n                                     \"/tmp/pkinit_san\");\n#endif\n                    ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                    if (ret) {\n                        pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                                 __FUNCTION__);\n                    } else {\n                        p++;\n                        num_found++;\n                    }\n                } else if (upns != NULL\n                           && OBJ_cmp(plgctx->id_ms_san_upn,\n                                      gen->d.otherName->type_id) == 0) {\n                    /* Prevent abuse of embedded null characters. */\n                    if (memchr(name.data, '\\0', name.length))\n                        break;\n                    ret = krb5_parse_name(context, name.data, &upns[u]);\n                    if (ret) {\n                        pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                                 __FUNCTION__);\n                    } else {\n                        u++;\n                        num_found++;\n                    }\n                } else {\n                    pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                             __FUNCTION__);\n                    continue;\n                }\n\n                break;\n            case GEN_DNS:\n                if (dnss != NULL) {\n                    /* Prevent abuse of embedded null characters. */\n                    if (memchr(gen->d.dNSName->data, '\\0',\n                               gen->d.dNSName->length))\n                        break;\n                    pkiDebug(\"%s: found dns name = %s\\n\",\n                             __FUNCTION__, gen->d.dNSName->data);\n                    dnss[d] = (unsigned char *)\n                        strdup((char *)gen->d.dNSName->data);\n                    if (dnss[d] == NULL) {\n                        pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                                 __FUNCTION__);\n                    } else {\n                        d++;\n                        num_found++;\n                    }\n                }\n                break;\n            default:\n                pkiDebug(\"%s: SAN type = %d expecting %d\\n\",\n                         __FUNCTION__, gen->type, GEN_OTHERNAME);\n            }\n        }\n        sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n    }\n\n    retval = 0;\n    if (princs)\n        *princs_ret = princs;\n    if (upns)\n        *upn_ret = upns;\n    if (dnss)\n        *dns_ret = dnss;\n\ncleanup:\n    if (retval) {\n        if (princs != NULL) {\n            for (i = 0; princs[i] != NULL; i++)\n                krb5_free_principal(context, princs[i]);\n            free(princs);\n        }\n        if (upns != NULL) {\n            for (i = 0; upns[i] != NULL; i++)\n                krb5_free_principal(context, upns[i]);\n            free(upns);\n        }\n        if (dnss != NULL) {\n            for (i = 0; dnss[i] != NULL; i++)\n                free(dnss[i]);\n            free(dnss);\n        }\n    }\n    return retval;\n}\n\nkrb5_error_code\ncrypto_retrieve_signer_identity(krb5_context context,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                const char **identity)\n{\n    *identity = id_cryptoctx->identity;\n    if (*identity == NULL)\n        return ENOENT;\n    return 0;\n}\n\nkrb5_error_code\ncrypto_retrieve_cert_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          pkinit_identity_crypto_context idctx,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n\n    if (reqctx->received_cert == NULL) {\n        pkiDebug(\"%s: No certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    return crypto_retrieve_X509_sans(context, plgctx, reqctx,\n                                     reqctx->received_cert, princs_ret,\n                                     upn_ret, dns_ret);\n}\n\nkrb5_error_code\ncrypto_check_cert_eku(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int checking_kdc_cert,\n                      int allow_secondary_usage,\n                      int *valid_eku)\n{\n    char buf[DN_BUF_LEN];\n    int found_eku = 0;\n    krb5_error_code retval = EINVAL;\n    int i;\n\n    *valid_eku = 0;\n    if (reqctx->received_cert == NULL)\n        goto cleanup;\n\n    X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for EKUs in cert = %s\\n\", __FUNCTION__, buf);\n\n    if ((i = X509_get_ext_by_NID(reqctx->received_cert,\n                                 NID_ext_key_usage, -1)) >= 0) {\n        EXTENDED_KEY_USAGE *extusage;\n\n        extusage = X509_get_ext_d2i(reqctx->received_cert, NID_ext_key_usage,\n                                    NULL, NULL);\n        if (extusage) {\n            pkiDebug(\"%s: found eku info in the cert\\n\", __FUNCTION__);\n            for (i = 0; found_eku == 0 && i < sk_ASN1_OBJECT_num(extusage); i++) {\n                ASN1_OBJECT *tmp_oid;\n\n                tmp_oid = sk_ASN1_OBJECT_value(extusage, i);\n                pkiDebug(\"%s: checking eku %d of %d, allow_secondary = %d\\n\",\n                         __FUNCTION__, i+1, sk_ASN1_OBJECT_num(extusage),\n                         allow_secondary_usage);\n                if (checking_kdc_cert) {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPKdc) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_kp_serverAuth) == 0))\n                        found_eku = 1;\n                } else {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPClientAuth) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_ms_kp_sc_logon) == 0))\n                        found_eku = 1;\n                }\n            }\n        }\n        EXTENDED_KEY_USAGE_free(extusage);\n\n        if (found_eku) {\n            ASN1_BIT_STRING *usage = NULL;\n            pkiDebug(\"%s: found acceptable EKU, checking for digitalSignature\\n\", __FUNCTION__);\n\n            /* check that digitalSignature KeyUsage is present */\n            X509_check_ca(reqctx->received_cert);\n            if ((usage = X509_get_ext_d2i(reqctx->received_cert,\n                                          NID_key_usage, NULL, NULL))) {\n\n                if (!ku_reject(reqctx->received_cert,\n                               X509v3_KU_DIGITAL_SIGNATURE)) {\n                    pkiDebug(\"%s: found digitalSignature KU\\n\",\n                             __FUNCTION__);\n                    *valid_eku = 1;\n                } else\n                    pkiDebug(\"%s: didn't find digitalSignature KU\\n\",\n                             __FUNCTION__);\n            }\n            ASN1_BIT_STRING_free(usage);\n        }\n    }\n    retval = 0;\ncleanup:\n    pkiDebug(\"%s: returning retval %d, valid_eku %d\\n\",\n             __FUNCTION__, retval, *valid_eku);\n    return retval;\n}\n\nkrb5_error_code\npkinit_octetstring2key(krb5_context context,\n                       krb5_enctype etype,\n                       unsigned char *key,\n                       unsigned int dh_key_len,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval;\n    unsigned char *buf = NULL;\n    unsigned char md[SHA_DIGEST_LENGTH];\n    unsigned char counter;\n    size_t keybytes, keylength, offset;\n    krb5_data random_data;\n\n    if ((buf = malloc(dh_key_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    memset(buf, 0, dh_key_len);\n\n    counter = 0;\n    offset = 0;\n    do {\n        SHA_CTX c;\n\n        SHA1_Init(&c);\n        SHA1_Update(&c, &counter, 1);\n        SHA1_Update(&c, key, dh_key_len);\n        SHA1_Final(md, &c);\n\n        if (dh_key_len - offset < sizeof(md))\n            memcpy(buf + offset, md, dh_key_len - offset);\n        else\n            memcpy(buf + offset, md, sizeof(md));\n\n        offset += sizeof(md);\n        counter++;\n    } while (offset < dh_key_len);\n\n    key_block->magic = 0;\n    key_block->enctype = etype;\n\n    retval = krb5_c_keylengths(context, etype, &keybytes, &keylength);\n    if (retval)\n        goto cleanup;\n\n    key_block->length = keylength;\n    key_block->contents = malloc(keylength);\n    if (key_block->contents == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    random_data.length = keybytes;\n    random_data.data = (char *)buf;\n\n    retval = krb5_c_random_to_key(context, etype, &random_data, key_block);\n\ncleanup:\n    free(buf);\n    /* If this is an error return, free the allocated keyblock, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    return retval;\n}\n\n\n/**\n * Given an algorithm_identifier, this function returns the hash length\n * and EVP function associated with that algorithm.\n */\nstatic krb5_error_code\npkinit_alg_values(krb5_context context,\n                  const krb5_data *alg_id,\n                  size_t *hash_bytes,\n                  const EVP_MD *(**func)(void))\n{\n    *hash_bytes = 0;\n    *func = NULL;\n    if ((alg_id->length == krb5_pkinit_sha1_oid_len) &&\n        (0 == memcmp(alg_id->data, &krb5_pkinit_sha1_oid,\n                     krb5_pkinit_sha1_oid_len))) {\n        *hash_bytes = 20;\n        *func = &EVP_sha1;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha256_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha256_oid,\n                            krb5_pkinit_sha256_oid_len))) {\n        *hash_bytes = 32;\n        *func = &EVP_sha256;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha512_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha512_oid,\n                            krb5_pkinit_sha512_oid_len))) {\n        *hash_bytes = 64;\n        *func = &EVP_sha512;\n        return 0;\n    } else {\n        krb5_set_error_message(context, KRB5_ERR_BAD_S2K_PARAMS,\n                               \"Bad algorithm ID passed to PK-INIT KDF.\");\n        return KRB5_ERR_BAD_S2K_PARAMS;\n    }\n} /* pkinit_alg_values() */\n\n\n/* pkinit_alg_agility_kdf() --\n * This function generates a key using the KDF described in\n * draft_ietf_krb_wg_pkinit_alg_agility-04.txt.  The algorithm is\n * described as follows:\n *\n *     1.  reps = keydatalen (K) / hash length (H)\n *\n *     2.  Initialize a 32-bit, big-endian bit string counter as 1.\n *\n *     3.  For i = 1 to reps by 1, do the following:\n *\n *         -  Compute Hashi = H(counter || Z || OtherInfo).\n *\n *         -  Increment counter (modulo 2^32)\n *\n *     4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes.\n */\nkrb5_error_code\npkinit_alg_agility_kdf(krb5_context context,\n                       krb5_data *secret,\n                       krb5_data *alg_oid,\n                       krb5_const_principal party_u_info,\n                       krb5_const_principal party_v_info,\n                       krb5_enctype enctype,\n                       krb5_data *as_req,\n                       krb5_data *pk_as_rep,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval = 0;\n\n    unsigned int reps = 0;\n    uint32_t counter = 1;       /* Does this type work on Windows? */\n    size_t offset = 0;\n    size_t hash_len = 0;\n    size_t rand_len = 0;\n    size_t key_len = 0;\n    krb5_data random_data;\n    krb5_sp80056a_other_info other_info_fields;\n    krb5_pkinit_supp_pub_info supp_pub_info_fields;\n    krb5_data *other_info = NULL;\n    krb5_data *supp_pub_info = NULL;\n    krb5_algorithm_identifier alg_id;\n    const EVP_MD *(*EVP_func)(void);\n\n    /* initialize random_data here to make clean-up safe */\n    random_data.length = 0;\n    random_data.data = NULL;\n\n    /* allocate and initialize the key block */\n    key_block->magic = 0;\n    key_block->enctype = enctype;\n    if (0 != (retval = krb5_c_keylengths(context, enctype, &rand_len,\n                                         &key_len)))\n        goto cleanup;\n\n    random_data.length = rand_len;\n    key_block->length = key_len;\n\n    if (NULL == (key_block->contents = malloc(key_block->length))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    memset (key_block->contents, 0, key_block->length);\n\n    /* If this is anonymous pkinit, use the anonymous principle for party_u_info */\n    if (party_u_info && krb5_principal_compare_any_realm(context, party_u_info,\n                                                         krb5_anonymous_principal()))\n        party_u_info = (krb5_principal)krb5_anonymous_principal();\n\n    if (0 != (retval = pkinit_alg_values(context, alg_oid, &hash_len, &EVP_func)))\n        goto cleanup;\n\n    /* 1.  reps = keydatalen (K) / hash length (H) */\n    reps = key_block->length/hash_len;\n\n    /* ... and round up, if necessary */\n    if (key_block->length > (reps * hash_len))\n        reps++;\n\n    /* Allocate enough space in the random data buffer to hash directly into\n     * it, even if the last hash will make it bigger than the key length. */\n    if (NULL == (random_data.data = malloc(reps * hash_len))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Encode the ASN.1 octet string for \"SuppPubInfo\" */\n    supp_pub_info_fields.enctype = enctype;\n    supp_pub_info_fields.as_req = *as_req;\n    supp_pub_info_fields.pk_as_rep = *pk_as_rep;\n    if (0 != ((retval = encode_krb5_pkinit_supp_pub_info(&supp_pub_info_fields,\n                                                         &supp_pub_info))))\n        goto cleanup;\n\n    /* Now encode the ASN.1 octet string for \"OtherInfo\" */\n    memset(&alg_id, 0, sizeof alg_id);\n    alg_id.algorithm = *alg_oid; /*alias*/\n\n    other_info_fields.algorithm_identifier = alg_id;\n    other_info_fields.party_u_info = (krb5_principal) party_u_info;\n    other_info_fields.party_v_info = (krb5_principal) party_v_info;\n    other_info_fields.supp_pub_info = *supp_pub_info;\n    if (0 != (retval = encode_krb5_sp80056a_other_info(&other_info_fields, &other_info)))\n        goto cleanup;\n\n    /* 2.  Initialize a 32-bit, big-endian bit string counter as 1.\n     * 3.  For i = 1 to reps by 1, do the following:\n     *     -   Compute Hashi = H(counter || Z || OtherInfo).\n     *     -   Increment counter (modulo 2^32)\n     */\n    for (counter = 1; counter <= reps; counter++) {\n        EVP_MD_CTX c;\n        uint s = 0;\n        uint32_t be_counter = htonl(counter);\n\n        EVP_MD_CTX_init(&c);\n\n        /* -   Compute Hashi = H(counter || Z || OtherInfo). */\n        if (0 == EVP_DigestInit(&c, EVP_func())) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestInit() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        if ((0 == EVP_DigestUpdate(&c, &be_counter, 4)) ||\n            (0 == EVP_DigestUpdate(&c, secret->data, secret->length)) ||\n            (0 == EVP_DigestUpdate(&c, other_info->data, other_info->length))) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        /* 4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes. */\n        if (0 == EVP_DigestFinal(&c, (unsigned char *)(random_data.data + offset), &s)) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n        offset += s;\n        assert(s == hash_len);\n\n        EVP_MD_CTX_cleanup(&c);\n    }\n\n    retval = krb5_c_random_to_key(context, enctype, &random_data,\n                                  key_block);\n\ncleanup:\n    /* If this has been an error, free the allocated key_block, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    /* free other allocated resources, either way */\n    if (random_data.data)\n        free(random_data.data);\n    krb5_free_data(context, other_info);\n    krb5_free_data(context, supp_pub_info);\n\n    return retval;\n} /*pkinit_alg_agility_kdf() */\n\n/* Call DH_compute_key() and ensure that we left-pad short results instead of\n * leaving junk bytes at the end of the buffer. */\nstatic void\ncompute_dh(unsigned char *buf, int size, BIGNUM *server_pub_key, DH *dh)\n{\n    int len, pad;\n\n    len = DH_compute_key(buf, server_pub_key, dh);\n    assert(len >= 0 && len <= size);\n    if (len < size) {\n        pad = size - len;\n        memmove(buf + pad, buf, len);\n        memset(buf, 0, pad);\n    }\n}\n\nkrb5_error_code\nclient_create_dh(krb5_context context,\n                 pkinit_plg_crypto_context plg_cryptoctx,\n                 pkinit_req_crypto_context cryptoctx,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 int dh_size,\n                 unsigned char **dh_params,\n                 unsigned int *dh_params_len,\n                 unsigned char **dh_pubkey,\n                 unsigned int *dh_pubkey_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    unsigned char *buf = NULL;\n    int dh_err = 0;\n    ASN1_INTEGER *pub_key = NULL;\n\n    if (cryptoctx->dh == NULL) {\n        if ((cryptoctx->dh = DH_new()) == NULL)\n            goto cleanup;\n        if ((cryptoctx->dh->g = BN_new()) == NULL ||\n            (cryptoctx->dh->q = BN_new()) == NULL)\n            goto cleanup;\n\n        switch(dh_size) {\n        case 1024:\n            pkiDebug(\"client uses 1024 DH keys\\n\");\n            cryptoctx->dh->p = get_rfc2409_prime_1024(NULL);\n            break;\n        case 2048:\n            pkiDebug(\"client uses 2048 DH keys\\n\");\n            cryptoctx->dh->p = BN_bin2bn(pkinit_2048_dhprime,\n                                         sizeof(pkinit_2048_dhprime), NULL);\n            break;\n        case 4096:\n            pkiDebug(\"client uses 4096 DH keys\\n\");\n            cryptoctx->dh->p = BN_bin2bn(pkinit_4096_dhprime,\n                                         sizeof(pkinit_4096_dhprime), NULL);\n            break;\n        default:\n            goto cleanup;\n        }\n\n        BN_set_word((cryptoctx->dh->g), DH_GENERATOR_2);\n        BN_rshift1(cryptoctx->dh->q, cryptoctx->dh->p);\n    }\n\n    DH_generate_key(cryptoctx->dh);\n    DH_check(cryptoctx->dh, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"Warning: dh_check failed with %d\\n\", dh_err);\n        if (dh_err & DH_CHECK_P_NOT_PRIME)\n            pkiDebug(\"p value is not prime\\n\");\n        if (dh_err & DH_CHECK_P_NOT_SAFE_PRIME)\n            pkiDebug(\"p value is not a safe prime\\n\");\n        if (dh_err & DH_UNABLE_TO_CHECK_GENERATOR)\n            pkiDebug(\"unable to check the generator value\\n\");\n        if (dh_err & DH_NOT_SUITABLE_GENERATOR)\n            pkiDebug(\"the g value is not a generator\\n\");\n    }\n#ifdef DEBUG_DH\n    print_dh(cryptoctx->dh, \"client's DH params\\n\");\n    print_pubkey(cryptoctx->dh->pub_key, \"client's pub_key=\");\n#endif\n\n    DH_check_pub_key(cryptoctx->dh, cryptoctx->dh->pub_key, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"dh_check_pub_key failed with %d\\n\", dh_err);\n        goto cleanup;\n    }\n\n    /* pack DHparams */\n    /* aglo: usually we could just call i2d_DHparams to encode DH params\n     * however, PKINIT requires RFC3279 encoding and openssl does pkcs#3.\n     */\n    retval = pkinit_encode_dh_params(cryptoctx->dh->p, cryptoctx->dh->g,\n                                     cryptoctx->dh->q, dh_params, dh_params_len);\n    if (retval)\n        goto cleanup;\n\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    if ((pub_key = BN_to_ASN1_INTEGER(cryptoctx->dh->pub_key, NULL)) == NULL)\n        goto cleanup;\n    *dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    if ((buf = *dh_pubkey = malloc(*dh_pubkey_len)) == NULL) {\n        retval  = ENOMEM;\n        goto cleanup;\n    }\n    i2d_ASN1_INTEGER(pub_key, &buf);\n\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    retval = 0;\n    return retval;\n\ncleanup:\n    if (cryptoctx->dh != NULL)\n        DH_free(cryptoctx->dh);\n    cryptoctx->dh = NULL;\n    free(*dh_params);\n    *dh_params = NULL;\n    free(*dh_pubkey);\n    *dh_pubkey = NULL;\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    return retval;\n}\n\nkrb5_error_code\nclient_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *subjectPublicKey_data,\n                  unsigned int subjectPublicKey_length,\n                  unsigned char **client_key,\n                  unsigned int *client_key_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    BIGNUM *server_pub_key = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n    const unsigned char *p = NULL;\n\n    *client_key_len = DH_size(cryptoctx->dh);\n    if ((*client_key = malloc(*client_key_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    p = subjectPublicKey_data;\n    pub_key = d2i_ASN1_INTEGER(NULL, &p, (long)subjectPublicKey_length);\n    if (pub_key == NULL)\n        goto cleanup;\n    if ((server_pub_key = ASN1_INTEGER_to_BN(pub_key, NULL)) == NULL)\n        goto cleanup;\n\n    compute_dh(*client_key, *client_key_len, server_pub_key, cryptoctx->dh);\n#ifdef DEBUG_DH\n    print_pubkey(server_pub_key, \"server's pub_key=\");\n    pkiDebug(\"client computed key (%d)= \", *client_key_len);\n    print_buffer(*client_key, *client_key_len);\n#endif\n\n    retval = 0;\n    if (server_pub_key != NULL)\n        BN_free(server_pub_key);\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    return retval;\n\ncleanup:\n    free(*client_key);\n    *client_key = NULL;\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    return retval;\n}\n\nkrb5_error_code\nserver_check_dh(krb5_context context,\n                pkinit_plg_crypto_context cryptoctx,\n                pkinit_req_crypto_context req_cryptoctx,\n                pkinit_identity_crypto_context id_cryptoctx,\n                krb5_data *dh_params,\n                int minbits)\n{\n    DH *dh = NULL;\n    unsigned char *tmp = NULL;\n    int dh_prime_bits;\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n\n    tmp = (unsigned char *)dh_params->data;\n    dh = DH_new();\n    dh = pkinit_decode_dh_params(&dh, &tmp, dh_params->length);\n    if (dh == NULL) {\n        pkiDebug(\"failed to decode dhparams\\n\");\n        goto cleanup;\n    }\n\n    /* KDC SHOULD check to see if the key parameters satisfy its policy */\n    dh_prime_bits = BN_num_bits(dh->p);\n    if (minbits && dh_prime_bits < minbits) {\n        pkiDebug(\"client sent dh params with %d bits, we require %d\\n\",\n                 dh_prime_bits, minbits);\n        goto cleanup;\n    }\n\n    /* check dhparams is group 2 */\n    if (pkinit_check_dh_params(cryptoctx->dh_1024->p,\n                               dh->p, dh->g, dh->q) == 0) {\n        retval = 0;\n        goto cleanup;\n    }\n\n    /* check dhparams is group 14 */\n    if (pkinit_check_dh_params(cryptoctx->dh_2048->p,\n                               dh->p, dh->g, dh->q) == 0) {\n        retval = 0;\n        goto cleanup;\n    }\n\n    /* check dhparams is group 16 */\n    if (pkinit_check_dh_params(cryptoctx->dh_4096->p,\n                               dh->p, dh->g, dh->q) == 0) {\n        retval = 0;\n        goto cleanup;\n    }\n\ncleanup:\n    if (retval == 0)\n        req_cryptoctx->dh = dh;\n    else\n        DH_free(dh);\n\n    return retval;\n}\n\n/* kdc's dh function */\nkrb5_error_code\nserver_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *data,\n                  unsigned int data_len,\n                  unsigned char **dh_pubkey,\n                  unsigned int *dh_pubkey_len,\n                  unsigned char **server_key,\n                  unsigned int *server_key_len)\n{\n    krb5_error_code retval = ENOMEM;\n    DH *dh = NULL, *dh_server = NULL;\n    unsigned char *p = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n\n    *dh_pubkey = *server_key = NULL;\n    *dh_pubkey_len = *server_key_len = 0;\n\n    /* get client's received DH parameters that we saved in server_check_dh */\n    dh = cryptoctx->dh;\n\n    dh_server = DH_new();\n    if (dh_server == NULL)\n        goto cleanup;\n    dh_server->p = BN_dup(dh->p);\n    dh_server->g = BN_dup(dh->g);\n    dh_server->q = BN_dup(dh->q);\n\n    /* decode client's public key */\n    p = data;\n    pub_key = d2i_ASN1_INTEGER(NULL, (const unsigned char **)&p, (int)data_len);\n    if (pub_key == NULL)\n        goto cleanup;\n    dh->pub_key = ASN1_INTEGER_to_BN(pub_key, NULL);\n    if (dh->pub_key == NULL)\n        goto cleanup;\n    ASN1_INTEGER_free(pub_key);\n\n    if (!DH_generate_key(dh_server))\n        goto cleanup;\n\n    /* generate DH session key */\n    *server_key_len = DH_size(dh_server);\n    if ((*server_key = malloc(*server_key_len)) == NULL)\n        goto cleanup;\n    compute_dh(*server_key, *server_key_len, dh->pub_key, dh_server);\n\n#ifdef DEBUG_DH\n    print_dh(dh_server, \"client&server's DH params\\n\");\n    print_pubkey(dh->pub_key, \"client's pub_key=\");\n    print_pubkey(dh_server->pub_key, \"server's pub_key=\");\n    pkiDebug(\"server computed key=\");\n    print_buffer(*server_key, *server_key_len);\n#endif\n\n    /* KDC reply */\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    if ((pub_key = BN_to_ASN1_INTEGER(dh_server->pub_key, NULL)) == NULL)\n        goto cleanup;\n    *dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    if ((p = *dh_pubkey = malloc(*dh_pubkey_len)) == NULL)\n        goto cleanup;\n    i2d_ASN1_INTEGER(pub_key, &p);\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    retval = 0;\n\n    if (dh_server != NULL)\n        DH_free(dh_server);\n    return retval;\n\ncleanup:\n    if (dh_server != NULL)\n        DH_free(dh_server);\n    free(*dh_pubkey);\n    free(*server_key);\n\n    return retval;\n}\n\nstatic void\nopenssl_init()\n{\n    static int did_init = 0;\n\n    if (!did_init) {\n        /* initialize openssl routines */\n        CRYPTO_malloc_init();\n        ERR_load_crypto_strings();\n        OpenSSL_add_all_algorithms();\n        did_init++;\n    }\n}\n\nstatic krb5_error_code\npkinit_encode_dh_params(BIGNUM *p, BIGNUM *g, BIGNUM *q,\n                        unsigned char **buf, unsigned int *buf_len)\n{\n    krb5_error_code retval = ENOMEM;\n    int bufsize = 0, r = 0;\n    unsigned char *tmp = NULL;\n    ASN1_INTEGER *ap = NULL, *ag = NULL, *aq = NULL;\n\n    if ((ap = BN_to_ASN1_INTEGER(p, NULL)) == NULL)\n        goto cleanup;\n    if ((ag = BN_to_ASN1_INTEGER(g, NULL)) == NULL)\n        goto cleanup;\n    if ((aq = BN_to_ASN1_INTEGER(q, NULL)) == NULL)\n        goto cleanup;\n    bufsize = i2d_ASN1_INTEGER(ap, NULL);\n    bufsize += i2d_ASN1_INTEGER(ag, NULL);\n    bufsize += i2d_ASN1_INTEGER(aq, NULL);\n\n    r = ASN1_object_size(1, bufsize, V_ASN1_SEQUENCE);\n\n    tmp = *buf = malloc((size_t) r);\n    if (tmp == NULL)\n        goto cleanup;\n\n    ASN1_put_object(&tmp, 1, bufsize, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_INTEGER(ap, &tmp);\n    i2d_ASN1_INTEGER(ag, &tmp);\n    i2d_ASN1_INTEGER(aq, &tmp);\n\n    *buf_len = r;\n\n    retval = 0;\n\ncleanup:\n    if (ap != NULL)\n        ASN1_INTEGER_free(ap);\n    if (ag != NULL)\n        ASN1_INTEGER_free(ag);\n    if (aq != NULL)\n        ASN1_INTEGER_free(aq);\n\n    return retval;\n}\n\nstatic DH *\npkinit_decode_dh_params(DH ** a, unsigned char **pp, unsigned int len)\n{\n    ASN1_INTEGER ai, *aip = NULL;\n    long length = (long) len;\n\n    M_ASN1_D2I_vars(a, DH *, DH_new);\n\n    M_ASN1_D2I_Init();\n    M_ASN1_D2I_start_sequence();\n    aip = &ai;\n    ai.data = NULL;\n    ai.length = 0;\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        (*a)->p = ASN1_INTEGER_to_BN(aip, NULL);\n        if ((*a)->p == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n    }\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        (*a)->g = ASN1_INTEGER_to_BN(aip, NULL);\n        if ((*a)->g == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        (*a)->q = ASN1_INTEGER_to_BN(aip, NULL);\n        if ((*a)->q == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_end_sequence();\n    M_ASN1_D2I_Finish(a, DH_free, 0);\n\n}\n\nstatic krb5_error_code\npkinit_create_sequence_of_principal_identifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    int type,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n    krb5_external_principal_identifier **krb5_trusted_certifiers = NULL;\n    krb5_data *td_certifiers = NULL;\n    krb5_pa_data **pa_data = NULL;\n\n    switch(type) {\n    case TD_TRUSTED_CERTIFIERS:\n        retval = create_krb5_trustedCertifiers(context, plg_cryptoctx,\n                                               req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_trustedCertifiers failed\\n\");\n            goto cleanup;\n        }\n        break;\n    case TD_INVALID_CERTIFICATES:\n        retval = create_krb5_invalidCertificates(context, plg_cryptoctx,\n                                                 req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_invalidCertificates failed\\n\");\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    retval = k5int_encode_krb5_td_trusted_certifiers((const krb5_external_principal_identifier **)krb5_trusted_certifiers, &td_certifiers);\n    if (retval) {\n        pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)td_certifiers->data,\n                     td_certifiers->length, \"/tmp/kdc_td_certifiers\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = type;\n    pa_data[0]->length = td_certifiers->length;\n    pa_data[0]->contents = (krb5_octet *)td_certifiers->data;\n    *e_data_out = pa_data;\n    retval = 0;\n\ncleanup:\n    if (krb5_trusted_certifiers != NULL)\n        free_krb5_external_principal_identifier(&krb5_trusted_certifiers);\n    free(td_certifiers);\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_trusted_certifiers(krb5_context context,\n                                    pkinit_plg_crypto_context plg_cryptoctx,\n                                    pkinit_req_crypto_context req_cryptoctx,\n                                    pkinit_identity_crypto_context id_cryptoctx,\n                                    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_TRUSTED_CERTIFIERS, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_invalid_certificate(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_INVALID_CERTIFICATES, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_dh_parameters(krb5_context context,\n                               pkinit_plg_crypto_context plg_cryptoctx,\n                               pkinit_req_crypto_context req_cryptoctx,\n                               pkinit_identity_crypto_context id_cryptoctx,\n                               pkinit_plg_opts *opts,\n                               krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = ENOMEM;\n    unsigned int buf1_len = 0, buf2_len = 0, buf3_len = 0, i = 0;\n    unsigned char *buf1 = NULL, *buf2 = NULL, *buf3 = NULL;\n    krb5_pa_data **pa_data = NULL;\n    krb5_data *encoded_algId = NULL;\n    krb5_algorithm_identifier **algId = NULL;\n\n    if (opts->dh_min_bits > 4096)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        retval = pkinit_encode_dh_params(plg_cryptoctx->dh_1024->p,\n                                         plg_cryptoctx->dh_1024->g, plg_cryptoctx->dh_1024->q,\n                                         &buf1, &buf1_len);\n        if (retval)\n            goto cleanup;\n    }\n    if (opts->dh_min_bits <= 2048) {\n        retval = pkinit_encode_dh_params(plg_cryptoctx->dh_2048->p,\n                                         plg_cryptoctx->dh_2048->g, plg_cryptoctx->dh_2048->q,\n                                         &buf2, &buf2_len);\n        if (retval)\n            goto cleanup;\n    }\n    retval = pkinit_encode_dh_params(plg_cryptoctx->dh_4096->p,\n                                     plg_cryptoctx->dh_4096->g, plg_cryptoctx->dh_4096->q,\n                                     &buf3, &buf3_len);\n    if (retval)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        algId = malloc(4 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[3] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n        algId[2] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[2] == NULL)\n            goto cleanup;\n        algId[2]->parameters.data = malloc(buf1_len);\n        if (algId[2]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[2]->parameters.data, buf1, buf1_len);\n        algId[2]->parameters.length = buf1_len;\n        algId[2]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 2048) {\n        algId = malloc(3 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[2] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 4096) {\n        algId = malloc(2 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[1] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf3_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf3, buf3_len);\n        algId[0]->parameters.length = buf3_len;\n        algId[0]->algorithm = dh_oid;\n\n    }\n    retval = k5int_encode_krb5_td_dh_parameters((const krb5_algorithm_identifier **)algId, &encoded_algId);\n    if (retval)\n        goto cleanup;\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)encoded_algId->data,\n                     encoded_algId->length, \"/tmp/kdc_td_dh_params\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = TD_DH_PARAMETERS;\n    pa_data[0]->length = encoded_algId->length;\n    pa_data[0]->contents = (krb5_octet *)encoded_algId->data;\n    *e_data_out = pa_data;\n    retval = 0;\ncleanup:\n\n    free(buf1);\n    free(buf2);\n    free(buf3);\n    free(encoded_algId);\n\n    if (algId != NULL) {\n        while(algId[i] != NULL) {\n            free(algId[i]->parameters.data);\n            free(algId[i]);\n            i++;\n        }\n        free(algId);\n    }\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        return retval;\n\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n\n    retval = 0;\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}\n\nstatic int\npkinit_check_dh_params(BIGNUM * p1, BIGNUM * p2, BIGNUM * g1, BIGNUM * q1)\n{\n    BIGNUM *g2 = NULL, *q2 = NULL;\n    int retval = -1;\n\n    if (!BN_cmp(p1, p2)) {\n        g2 = BN_new();\n        BN_set_word(g2, DH_GENERATOR_2);\n        if (!BN_cmp(g1, g2)) {\n            q2 = BN_new();\n            BN_rshift1(q2, p1);\n            if (!BN_cmp(q1, q2)) {\n                pkiDebug(\"good %d dhparams\\n\", BN_num_bits(p1));\n                retval = 0;\n            } else\n                pkiDebug(\"bad group 2 q dhparameter\\n\");\n            BN_free(q2);\n        } else\n            pkiDebug(\"bad g dhparameter\\n\");\n        BN_free(g2);\n    } else\n        pkiDebug(\"p is not well-known group 2 dhparameter\\n\");\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_process_td_dh_params(krb5_context context,\n                            pkinit_plg_crypto_context cryptoctx,\n                            pkinit_req_crypto_context req_cryptoctx,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            krb5_algorithm_identifier **algId,\n                            int *new_dh_size)\n{\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n    int i = 0, use_sent_dh = 0, ok = 0;\n\n    pkiDebug(\"dh parameters\\n\");\n\n    while (algId[i] != NULL) {\n        DH *dh = NULL;\n        unsigned char *tmp = NULL;\n        int dh_prime_bits = 0;\n\n        if (algId[i]->algorithm.length != dh_oid.length ||\n            memcmp(algId[i]->algorithm.data, dh_oid.data, dh_oid.length))\n            goto cleanup;\n\n        tmp = (unsigned char *)algId[i]->parameters.data;\n        dh = DH_new();\n        dh = pkinit_decode_dh_params(&dh, &tmp, algId[i]->parameters.length);\n        dh_prime_bits = BN_num_bits(dh->p);\n        pkiDebug(\"client sent %d DH bits server prefers %d DH bits\\n\",\n                 *new_dh_size, dh_prime_bits);\n        switch(dh_prime_bits) {\n        case 1024:\n            if (pkinit_check_dh_params(cryptoctx->dh_1024->p, dh->p,\n                                       dh->g, dh->q) == 0) {\n                *new_dh_size = 1024;\n                ok = 1;\n            }\n            break;\n        case 2048:\n            if (pkinit_check_dh_params(cryptoctx->dh_2048->p, dh->p,\n                                       dh->g, dh->q) == 0) {\n                *new_dh_size = 2048;\n                ok = 1;\n            }\n            break;\n        case 4096:\n            if (pkinit_check_dh_params(cryptoctx->dh_4096->p, dh->p,\n                                       dh->g, dh->q) == 0) {\n                *new_dh_size = 4096;\n                ok = 1;\n            }\n            break;\n        default:\n            break;\n        }\n        if (!ok) {\n            DH_check(dh, &retval);\n            if (retval != 0) {\n                pkiDebug(\"DH parameters provided by server are unacceptable\\n\");\n                retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n            }\n            else {\n                use_sent_dh = 1;\n                ok = 1;\n            }\n        }\n        if (!use_sent_dh)\n            DH_free(dh);\n        if (ok) {\n            if (req_cryptoctx->dh != NULL) {\n                DH_free(req_cryptoctx->dh);\n                req_cryptoctx->dh = NULL;\n            }\n            if (use_sent_dh)\n                req_cryptoctx->dh = dh;\n            break;\n        }\n        i++;\n    }\n\n    if (ok)\n        retval = 0;\n\ncleanup:\n    return retval;\n}\n\nstatic int\nopenssl_callback(int ok, X509_STORE_CTX * ctx)\n{\n#ifdef DEBUG\n    if (!ok) {\n        char buf[DN_BUF_LEN];\n\n        X509_NAME_oneline(X509_get_subject_name(ctx->current_cert), buf, sizeof(buf));\n        pkiDebug(\"cert = %s\\n\", buf);\n        pkiDebug(\"callback function: %d (%s)\\n\", ctx->error,\n                 X509_verify_cert_error_string(ctx->error));\n    }\n#endif\n    return ok;\n}\n\nstatic int\nopenssl_callback_ignore_crls(int ok, X509_STORE_CTX * ctx)\n{\n    if (!ok) {\n        switch (ctx->error) {\n        case X509_V_ERR_UNABLE_TO_GET_CRL:\n            return 1;\n        default:\n            return 0;\n        }\n    }\n    return ok;\n}\n\nstatic ASN1_OBJECT *\npkinit_pkcs7type2oid(pkinit_plg_crypto_context cryptoctx, int pkcs7_type)\n{\n    int nid;\n\n    switch (pkcs7_type) {\n    case CMS_SIGN_CLIENT:\n        return cryptoctx->id_pkinit_authData;\n    case CMS_SIGN_DRAFT9:\n        /*\n         * Delay creating this OID until we know we need it.\n         * It shadows an existing OpenSSL oid.  If it\n         * is created too early, it breaks things like\n         * the use of pkcs12 (which uses pkcs7 structures).\n         * We need this shadow version because our code\n         * depends on the \"other\" type to be unknown to the\n         * OpenSSL code.\n         */\n        if (cryptoctx->id_pkinit_authData9 == NULL) {\n            pkiDebug(\"%s: Creating shadow instance of pkcs7-data oid\\n\",\n                     __FUNCTION__);\n            nid = OBJ_create(\"1.2.840.113549.1.7.1\", \"id-pkcs7-data\",\n                             \"PKCS7 data\");\n            if (nid == NID_undef)\n                return NULL;\n            cryptoctx->id_pkinit_authData9 = OBJ_nid2obj(nid);\n        }\n        return cryptoctx->id_pkinit_authData9;\n    case CMS_SIGN_SERVER:\n        return cryptoctx->id_pkinit_DHKeyData;\n    case CMS_ENVEL_SERVER:\n        return cryptoctx->id_pkinit_rkeyData;\n    default:\n        return NULL;\n    }\n\n}\n\n#ifdef LONGHORN_BETA_COMPAT\n#if 0\n/*\n * This is a version that worked with Longhorn Beta 3.\n */\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len,\n                int is_longhorn_server)\n{\n\n    unsigned int orig_len = 0, oid_len = 0, tot_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    pkiDebug(\"%s: This is the Longhorn version and is_longhorn_server = %d\\n\",\n             __FUNCTION__, is_longhorn_server);\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tot_len = orig_len = ASN1_object_size(1, (int)data_len, V_ASN1_SEQUENCE);\n\n    if (is_longhorn_server == 0) {\n        /* Add the signedData OID and adjust lengths */\n        oid = OBJ_nid2obj(NID_pkcs7_signed);\n        oid_len = i2d_ASN1_OBJECT(oid, NULL);\n\n        tot_len = ASN1_object_size(1, (int)(orig_len+oid_len), V_ASN1_SEQUENCE);\n    }\n\n    p = *out = malloc(tot_len);\n    if (p == NULL) return -1;\n\n    if (is_longhorn_server == 0) {\n        ASN1_put_object(&p, 1, (int)(orig_len+oid_len),\n                        V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n        i2d_ASN1_OBJECT(oid, &p);\n\n        ASN1_put_object(&p, 1, (int)data_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n    } else {\n        ASN1_put_object(&p, 1, (int)data_len, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n    }\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n#else\n/*\n * This is a version that works with a patched Longhorn KDC.\n * (Which should match SP1 ??).\n */\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len,\n                int is_longhorn_server)\n{\n\n    unsigned int oid_len = 0, tot_len = 0, wrap_len = 0, tag_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    pkiDebug(\"%s: This is the Longhorn version and is_longhorn_server = %d\\n\",\n             __FUNCTION__, is_longhorn_server);\n\n    /* New longhorn is missing another sequence */\n    if (is_longhorn_server == 1)\n        wrap_len = ASN1_object_size(1, (int)(data_len), V_ASN1_SEQUENCE);\n    else\n        wrap_len = data_len;\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tag_len = ASN1_object_size(1, (int)wrap_len, V_ASN1_SEQUENCE);\n\n    /* Always add oid */\n    oid = OBJ_nid2obj(NID_pkcs7_signed);\n    oid_len = i2d_ASN1_OBJECT(oid, NULL);\n    oid_len += tag_len;\n\n    tot_len = ASN1_object_size(1, (int)(oid_len), V_ASN1_SEQUENCE);\n\n    p = *out = malloc(tot_len);\n    if (p == NULL)\n        return -1;\n\n    ASN1_put_object(&p, 1, (int)(oid_len),\n                    V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_OBJECT(oid, &p);\n\n    ASN1_put_object(&p, 1, (int)wrap_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n\n    /* Wrap in extra seq tag */\n    if (is_longhorn_server == 1) {\n        ASN1_put_object(&p, 1, (int)data_len, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n    }\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n\n#endif\n#else\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len)\n{\n\n    unsigned int orig_len = 0, oid_len = 0, tot_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tot_len = orig_len = ASN1_object_size(1, (int)data_len, V_ASN1_SEQUENCE);\n\n    /* Add the signedData OID and adjust lengths */\n    oid = OBJ_nid2obj(NID_pkcs7_signed);\n    oid_len = i2d_ASN1_OBJECT(oid, NULL);\n\n    tot_len = ASN1_object_size(1, (int)(orig_len+oid_len), V_ASN1_SEQUENCE);\n\n    p = *out = malloc(tot_len);\n    if (p == NULL) return -1;\n\n    ASN1_put_object(&p, 1, (int)(orig_len+oid_len),\n                    V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_OBJECT(oid, &p);\n\n    ASN1_put_object(&p, 1, (int)data_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n#endif\n\nstatic int\nprepare_enc_data(unsigned char *indata,\n                 int indata_len,\n                 unsigned char **outdata,\n                 int *outdata_len)\n{\n    int retval = -1;\n    ASN1_const_CTX c;\n    long length = indata_len;\n    int Ttag, Tclass;\n    long Tlen;\n\n    c.pp = (const unsigned char **)&indata;\n    c.q = *(const unsigned char **)&indata;\n    c.error = ERR_R_NESTED_ASN1_ERROR;\n    c.p= *(const unsigned char **)&indata;\n    c.max = (length == 0)?0:(c.p+length);\n\n    asn1_GetSequence(&c,&length);\n\n    ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen);\n    c.p += Tlen;\n    ASN1_get_object(&c.p,&Tlen,&Ttag,&Tclass,c.slen);\n\n    asn1_const_Finish(&c);\n\n    *outdata = malloc((size_t)Tlen);\n    if (*outdata == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    memcpy(*outdata, c.p, (size_t)Tlen);\n    *outdata_len = Tlen;\n\n    retval = 0;\ncleanup:\n\n    return retval;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic void *\npkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p)\n{\n    void *handle;\n    CK_RV (*getflist)(CK_FUNCTION_LIST_PTR_PTR);\n\n    pkiDebug(\"loading module \\\"%s\\\"... \", modname);\n    handle = dlopen(modname, RTLD_NOW);\n    if (handle == NULL) {\n        pkiDebug(\"not found\\n\");\n        return NULL;\n    }\n    getflist = (CK_RV (*)(CK_FUNCTION_LIST_PTR_PTR)) dlsym(handle, \"C_GetFunctionList\");\n    if (getflist == NULL || (*getflist)(p11p) != CKR_OK) {\n        dlclose(handle);\n        pkiDebug(\"failed\\n\");\n        return NULL;\n    }\n    pkiDebug(\"ok\\n\");\n    return handle;\n}\n\nstatic CK_RV\npkinit_C_UnloadModule(void *handle)\n{\n    dlclose(handle);\n    return CKR_OK;\n}\n\nstatic krb5_error_code\npkinit_login(krb5_context context,\n             pkinit_identity_crypto_context id_cryptoctx,\n             CK_TOKEN_INFO *tip)\n{\n    krb5_data rdat;\n    char *prompt;\n    const char *warning;\n    krb5_prompt kprompt;\n    krb5_prompt_type prompt_type;\n    int r = 0;\n\n    if (tip->flags & CKF_PROTECTED_AUTHENTICATION_PATH) {\n        rdat.data = NULL;\n        rdat.length = 0;\n    } else {\n        if (tip->flags & CKF_USER_PIN_LOCKED)\n            warning = \" (Warning: PIN locked)\";\n        else if (tip->flags & CKF_USER_PIN_FINAL_TRY)\n            warning = \" (Warning: PIN final try)\";\n        else if (tip->flags & CKF_USER_PIN_COUNT_LOW)\n            warning = \" (Warning: PIN count low)\";\n        else\n            warning = \"\";\n        if (asprintf(&prompt, \"%.*s PIN%s\", (int) sizeof (tip->label),\n                     tip->label, warning) < 0)\n            return ENOMEM;\n        rdat.data = malloc(tip->ulMaxPinLen + 2);\n        rdat.length = tip->ulMaxPinLen + 1;\n\n        kprompt.prompt = prompt;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(context, &prompt_type);\n        r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                      NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(context, 0);\n        free(prompt);\n    }\n\n    if (r == 0) {\n        r = id_cryptoctx->p11->C_Login(id_cryptoctx->session, CKU_USER,\n                                       (u_char *) rdat.data, rdat.length);\n\n        if (r != CKR_OK) {\n            pkiDebug(\"C_Login: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            r = KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n    }\n    free(rdat.data);\n\n    return r;\n}\n\nstatic krb5_error_code\npkinit_open_session(krb5_context context,\n                    pkinit_identity_crypto_context cctx)\n{\n    CK_ULONG i, r;\n    unsigned char *cp;\n    CK_ULONG count = 0;\n    CK_SLOT_ID_PTR slotlist;\n    CK_TOKEN_INFO tinfo;\n\n    if (cctx->p11_module != NULL)\n        return 0; /* session already open */\n\n    /* Load module */\n    cctx->p11_module =\n        pkinit_C_LoadModule(cctx->p11_module_name, &cctx->p11);\n    if (cctx->p11_module == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    /* Init */\n    if ((r = cctx->p11->C_Initialize(NULL)) != CKR_OK) {\n        pkiDebug(\"C_Initialize: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /* Get the list of available slots */\n    if (cctx->slotid != PK_NOSLOT) {\n        /* A slot was specified, so that's the only one in the list */\n        count = 1;\n        slotlist = malloc(sizeof(CK_SLOT_ID));\n        slotlist[0] = cctx->slotid;\n    } else {\n        if (cctx->p11->C_GetSlotList(TRUE, NULL, &count) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        if (count == 0)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        slotlist = malloc(count * sizeof (CK_SLOT_ID));\n        if (cctx->p11->C_GetSlotList(TRUE, slotlist, &count) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /* Look for the given token label, or if none given take the first one */\n    for (i = 0; i < count; i++) {\n        /* Open session */\n        if ((r = cctx->p11->C_OpenSession(slotlist[i], CKF_SERIAL_SESSION,\n                                          NULL, NULL, &cctx->session)) != CKR_OK) {\n            pkiDebug(\"C_OpenSession: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        /* Get token info */\n        if ((r = cctx->p11->C_GetTokenInfo(slotlist[i], &tinfo)) != CKR_OK) {\n            pkiDebug(\"C_GetTokenInfo: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n        for (cp = tinfo.label + sizeof (tinfo.label) - 1;\n             *cp == '\\0' || *cp == ' '; cp--)\n            *cp = '\\0';\n        pkiDebug(\"open_session: slotid %d token \\\"%s\\\"\\n\",\n                 (int) slotlist[i], tinfo.label);\n        if (cctx->token_label == NULL ||\n            !strcmp((char *) cctx->token_label, (char *) tinfo.label))\n            break;\n        cctx->p11->C_CloseSession(cctx->session);\n    }\n    if (i >= count) {\n        free(slotlist);\n        pkiDebug(\"open_session: no matching token found\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    cctx->slotid = slotlist[i];\n    free(slotlist);\n    pkiDebug(\"open_session: slotid %d (%lu of %d)\\n\", (int) cctx->slotid,\n             i + 1, (int) count);\n\n    /* Login if needed */\n    if (tinfo.flags & CKF_LOGIN_REQUIRED)\n        r = pkinit_login(context, cctx, &tinfo);\n\n    return r;\n}\n\n/*\n * Look for a key that's:\n * 1. private\n * 2. capable of the specified operation (usually signing or decrypting)\n * 3. RSA (this may be wrong but it's all we can do for now)\n * 4. matches the id of the cert we chose\n *\n * You must call pkinit_get_certs before calling pkinit_find_private_key\n * (that's because we need the ID of the private key)\n *\n * pkcs11 says the id of the key doesn't have to match that of the cert, but\n * I can't figure out any other way to decide which key to use.\n *\n * We should only find one key that fits all the requirements.\n * If there are more than one, we just take the first one.\n */\n\nkrb5_error_code\npkinit_find_private_key(pkinit_identity_crypto_context id_cryptoctx,\n                        CK_ATTRIBUTE_TYPE usage,\n                        CK_OBJECT_HANDLE *objp)\n{\n    CK_OBJECT_CLASS cls;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_KEY_TYPE keytype;\n    unsigned int nattrs = 0;\n    int r;\n#ifdef PKINIT_USE_KEY_USAGE\n    CK_BBOOL true_false;\n#endif\n\n    cls = CKO_PRIVATE_KEY;\n    attrs[nattrs].type = CKA_CLASS;\n    attrs[nattrs].pValue = &cls;\n    attrs[nattrs].ulValueLen = sizeof cls;\n    nattrs++;\n\n#ifdef PKINIT_USE_KEY_USAGE\n    /*\n     * Some cards get confused if you try to specify a key usage,\n     * so don't, and hope for the best. This will fail if you have\n     * several keys with the same id and different usages but I have\n     * not seen this on real cards.\n     */\n    true_false = TRUE;\n    attrs[nattrs].type = usage;\n    attrs[nattrs].pValue = &true_false;\n    attrs[nattrs].ulValueLen = sizeof true_false;\n    nattrs++;\n#endif\n\n    keytype = CKK_RSA;\n    attrs[nattrs].type = CKA_KEY_TYPE;\n    attrs[nattrs].pValue = &keytype;\n    attrs[nattrs].ulValueLen = sizeof keytype;\n    nattrs++;\n\n    attrs[nattrs].type = CKA_ID;\n    attrs[nattrs].pValue = id_cryptoctx->cert_id;\n    attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n    nattrs++;\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"krb5_pkinit_sign_data: C_FindObjectsInit: %s\\n\",\n                 pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session, objp, 1, &count);\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    pkiDebug(\"found %d private keys (%s)\\n\", (int) count, pkinit_pkcs11_code_to_text(r));\n    if (r != CKR_OK || count < 1)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\nstatic krb5_error_code\npkinit_decode_data_fs(krb5_context context,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *data,\n                      unsigned int data_len,\n                      unsigned char **decoded_data,\n                      unsigned int *decoded_data_len)\n{\n    if (decode_data(decoded_data, decoded_data_len, data, data_len,\n                    id_cryptoctx->my_key, sk_X509_value(id_cryptoctx->my_certs,\n                                                        id_cryptoctx->cert_index)) <= 0) {\n        pkiDebug(\"failed to decode data\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\n/*\n * When using the ActivCard Linux pkcs11 library (v2.0.1), the decrypt function\n * fails.  By inserting an extra function call, which serves nothing but to\n * change the stack, we were able to work around the issue.  If the ActivCard\n * library is fixed in the future, this function can be inlined back into the\n * caller.\n */\nstatic CK_RV\npkinit_C_Decrypt(pkinit_identity_crypto_context id_cryptoctx,\n                 CK_BYTE_PTR pEncryptedData,\n                 CK_ULONG  ulEncryptedDataLen,\n                 CK_BYTE_PTR pData,\n                 CK_ULONG_PTR pulDataLen)\n{\n    CK_RV rv = CKR_OK;\n\n    rv = id_cryptoctx->p11->C_Decrypt(id_cryptoctx->session, pEncryptedData,\n                                      ulEncryptedDataLen, pData, pulDataLen);\n    if (rv == CKR_OK) {\n        pkiDebug(\"pData %p *pulDataLen %d\\n\", (void *) pData,\n                 (int) *pulDataLen);\n    }\n    return rv;\n}\n\nstatic krb5_error_code\npkinit_decode_data_pkcs11(krb5_context context,\n                          pkinit_identity_crypto_context id_cryptoctx,\n                          unsigned char *data,\n                          unsigned int data_len,\n                          unsigned char **decoded_data,\n                          unsigned int *decoded_data_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    unsigned char *cp;\n    int r;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_DECRYPT, &obj);\n\n    mech.mechanism = CKM_RSA_PKCS;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_DecryptInit(id_cryptoctx->session, &mech,\n                                              obj)) != CKR_OK) {\n        pkiDebug(\"C_DecryptInit: 0x%x\\n\", (int) r);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"data_len = %d\\n\", data_len);\n    cp = malloc((size_t) data_len);\n    if (cp == NULL)\n        return ENOMEM;\n    len = data_len;\n    pkiDebug(\"session %p edata %p edata_len %d data %p datalen @%p %d\\n\",\n             (void *) id_cryptoctx->session, (void *) data, (int) data_len,\n             (void *) cp, (void *) &len, (int) len);\n    if ((r = pkinit_C_Decrypt(id_cryptoctx, data, (CK_ULONG) data_len,\n                              cp, &len)) != CKR_OK) {\n        pkiDebug(\"C_Decrypt: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        if (r == CKR_BUFFER_TOO_SMALL)\n            pkiDebug(\"decrypt %d needs %d\\n\", (int) data_len, (int) len);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"decrypt %d -> %d\\n\", (int) data_len, (int) len);\n    *decoded_data_len = len;\n    *decoded_data = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_decode_data(krb5_context context,\n                   pkinit_identity_crypto_context id_cryptoctx,\n                   unsigned char *data,\n                   unsigned int data_len,\n                   unsigned char **decoded_data,\n                   unsigned int *decoded_data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_decode_data_fs(context, id_cryptoctx, data, data_len,\n                                       decoded_data, decoded_data_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_decode_data_pkcs11(context, id_cryptoctx, data,\n                                           data_len, decoded_data, decoded_data_len);\n#endif\n\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_sign_data_fs(krb5_context context,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    unsigned char *data,\n                    unsigned int data_len,\n                    unsigned char **sig,\n                    unsigned int *sig_len)\n{\n    if (create_signature(sig, sig_len, data, data_len,\n                         id_cryptoctx->my_key) != 0) {\n        pkiDebug(\"failed to create the signature\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code\npkinit_sign_data_pkcs11(krb5_context context,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        unsigned char *data,\n                        unsigned int data_len,\n                        unsigned char **sig,\n                        unsigned int *sig_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    unsigned char *cp;\n    int r;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_SIGN, &obj);\n\n    mech.mechanism = id_cryptoctx->mech;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_SignInit(id_cryptoctx->session, &mech,\n                                           obj)) != CKR_OK) {\n        pkiDebug(\"C_SignInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /*\n     * Key len would give an upper bound on sig size, but there's no way to\n     * get that. So guess, and if it's too small, re-malloc.\n     */\n    len = PK_SIGLEN_GUESS;\n    cp = malloc((size_t) len);\n    if (cp == NULL)\n        return ENOMEM;\n\n    r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                  (CK_ULONG) data_len, cp, &len);\n    if (r == CKR_BUFFER_TOO_SMALL || (r == CKR_OK && len >= PK_SIGLEN_GUESS)) {\n        free(cp);\n        pkiDebug(\"C_Sign realloc %d\\n\", (int) len);\n        cp = malloc((size_t) len);\n        r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                      (CK_ULONG) data_len, cp, &len);\n    }\n    if (r != CKR_OK) {\n        pkiDebug(\"C_Sign: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"sign %d -> %d\\n\", (int) data_len, (int) len);\n    *sig_len = len;\n    *sig = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_sign_data(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 unsigned char *data,\n                 unsigned int data_len,\n                 unsigned char **sig,\n                 unsigned int *sig_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (id_cryptoctx == NULL || id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_sign_data_fs(context, id_cryptoctx, data, data_len,\n                                     sig, sig_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_sign_data_pkcs11(context, id_cryptoctx, data, data_len,\n                                         sig, sig_len);\n#endif\n\n    return retval;\n}\n\n\nstatic krb5_error_code\ndecode_data(unsigned char **out_data, unsigned int *out_data_len,\n            unsigned char *data, unsigned int data_len,\n            EVP_PKEY *pkey, X509 *cert)\n{\n    krb5_error_code retval = ENOMEM;\n    unsigned char *buf = NULL;\n    int buf_len = 0;\n\n    if (cert && !X509_check_private_key(cert, pkey)) {\n        pkiDebug(\"private key does not match certificate\\n\");\n        goto cleanup;\n    }\n\n    buf_len = EVP_PKEY_size(pkey);\n    buf = malloc((size_t) buf_len + 10);\n    if (buf == NULL)\n        goto cleanup;\n\n#if OPENSSL_VERSION_NUMBER >= 0x00909000L\n    retval = EVP_PKEY_decrypt_old(buf, data, (int)data_len, pkey);\n#else\n    retval = EVP_PKEY_decrypt(buf, data, (int)data_len, pkey);\n#endif\n    if (retval <= 0) {\n        pkiDebug(\"unable to decrypt received data (len=%d)\\n\", data_len);\n        goto cleanup;\n    }\n    *out_data = buf;\n    *out_data_len = retval;\n\ncleanup:\n    if (retval == ENOMEM)\n        free(buf);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncreate_signature(unsigned char **sig, unsigned int *sig_len,\n                 unsigned char *data, unsigned int data_len, EVP_PKEY *pkey)\n{\n    krb5_error_code retval = ENOMEM;\n    EVP_MD_CTX md_ctx;\n\n    if (pkey == NULL)\n        return retval;\n\n    EVP_VerifyInit(&md_ctx, EVP_sha1());\n    EVP_SignUpdate(&md_ctx, data, data_len);\n    *sig_len = EVP_PKEY_size(pkey);\n    if ((*sig = malloc(*sig_len)) == NULL)\n        goto cleanup;\n    EVP_SignFinal(&md_ctx, *sig, sig_len, pkey);\n\n    retval = 0;\n\ncleanup:\n    EVP_MD_CTX_cleanup(&md_ctx);\n\n    return retval;\n}\n\n/*\n * Note:\n * This is not the routine the KDC uses to get its certificate.\n * This routine is intended to be called by the client\n * to obtain the KDC's certificate from some local storage\n * to be sent as a hint in its request to the KDC.\n */\nkrb5_error_code\npkinit_get_kdc_cert(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    req_cryptoctx->received_cert = NULL;\n    retval = 0;\n    return retval;\n}\n\nstatic char *\nreassemble_pkcs12_name(const char *filename)\n{\n    char *ret;\n\n    if (asprintf(&ret, \"PKCS12:%s\", filename) < 0)\n        return NULL;\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs12(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    X509 *x = NULL;\n    PKCS12 *p12 = NULL;\n    int ret;\n    FILE *fp;\n    EVP_PKEY *y = NULL;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's private key location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    fp = fopen(idopts->cert_filename, \"rb\");\n    if (fp == NULL) {\n        pkiDebug(\"Failed to open PKCS12 file '%s', error %d\\n\",\n                 idopts->cert_filename, errno);\n        goto cleanup;\n    }\n    set_cloexec_file(fp);\n\n    p12 = d2i_PKCS12_fp(fp, NULL);\n    fclose(fp);\n    if (p12 == NULL) {\n        pkiDebug(\"Failed to decode PKCS12 file '%s' contents\\n\",\n                 idopts->cert_filename);\n        goto cleanup;\n    }\n    /*\n     * Try parsing with no pass phrase first.  If that fails,\n     * prompt for the pass phrase and try again.\n     */\n    ret = PKCS12_parse(p12, NULL, &y, &x, NULL);\n    if (ret == 0) {\n        krb5_data rdat;\n        krb5_prompt kprompt;\n        krb5_prompt_type prompt_type;\n        int r = 0;\n        char prompt_string[128];\n        char prompt_reply[128];\n        char *prompt_prefix = _(\"Pass phrase for\");\n\n        pkiDebug(\"Initial PKCS12_parse with no password failed\\n\");\n\n        memset(prompt_reply, '\\0', sizeof(prompt_reply));\n        rdat.data = prompt_reply;\n        rdat.length = sizeof(prompt_reply);\n\n        r = snprintf(prompt_string, sizeof(prompt_string), \"%s %s\",\n                     prompt_prefix, idopts->cert_filename);\n        if (r >= (int) sizeof(prompt_string)) {\n            pkiDebug(\"Prompt string, '%s %s', is too long!\\n\",\n                     prompt_prefix, idopts->cert_filename);\n            goto cleanup;\n        }\n        kprompt.prompt = prompt_string;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(context, &prompt_type);\n        r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                      NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(context, 0);\n\n        ret = PKCS12_parse(p12, rdat.data, &y, &x, NULL);\n        if (ret == 0) {\n            pkiDebug(\"Seconde PKCS12_parse with password failed\\n\");\n            goto cleanup;\n        }\n    }\n    id_cryptoctx->creds[0] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[0] == NULL)\n        goto cleanup;\n    id_cryptoctx->creds[0]->name =\n        reassemble_pkcs12_name(idopts->cert_filename);\n    id_cryptoctx->creds[0]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[0]->cert_id = NULL;\n    id_cryptoctx->creds[0]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[0]->key = y;\n    id_cryptoctx->creds[1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    if (p12)\n        PKCS12_free(p12);\n    if (retval) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic char *\nreassemble_files_name(const char *certfile, const char *keyfile)\n{\n    char *ret;\n\n    if (keyfile != NULL) {\n        if (asprintf(&ret, \"FILE:%s,%s\", certfile, keyfile) < 0)\n            return NULL;\n    } else {\n        if (asprintf(&ret, \"FILE:%s\", certfile) < 0)\n            return NULL;\n    }\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_load_fs_cert_and_key(krb5_context context,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            char *certname,\n                            char *keyname,\n                            int cindex)\n{\n    krb5_error_code retval;\n    X509 *x = NULL;\n    EVP_PKEY *y = NULL;\n\n    /* load the certificate */\n    retval = get_cert(certname, &x);\n    if (retval != 0 || x == NULL) {\n        pkiDebug(\"failed to load user's certificate from '%s'\\n\", certname);\n        goto cleanup;\n    }\n    retval = get_key(keyname, &y);\n    if (retval != 0 || y == NULL) {\n        pkiDebug(\"failed to load user's private key from '%s'\\n\", keyname);\n        goto cleanup;\n    }\n\n    id_cryptoctx->creds[cindex] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[cindex] == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    id_cryptoctx->creds[cindex]->name = reassemble_files_name(certname,\n                                                              keyname);\n    id_cryptoctx->creds[cindex]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[cindex]->cert_id = NULL;\n    id_cryptoctx->creds[cindex]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[cindex]->key = y;\n    id_cryptoctx->creds[cindex+1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    if (retval) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_fs(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_opts *idopts,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's private key location\\n\",\n                 __FUNCTION__);\n        goto cleanup;\n    }\n\n    retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                         idopts->cert_filename,\n                                         idopts->key_filename, 0);\ncleanup:\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_dir(krb5_context context,\n                     pkinit_plg_crypto_context plg_cryptoctx,\n                     pkinit_req_crypto_context req_cryptoctx,\n                     pkinit_identity_opts *idopts,\n                     pkinit_identity_crypto_context id_cryptoctx,\n                     krb5_principal princ)\n{\n    krb5_error_code retval = ENOMEM;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char certname[1024];\n    char keyname[1024];\n    int i = 0, len;\n    char *dirname, *suf;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's certificate directory location\\n\",\n                 __FUNCTION__);\n        return ENOENT;\n    }\n\n    dirname = idopts->cert_filename;\n    d = opendir(dirname);\n    if (d == NULL)\n        return errno;\n\n    /*\n     * We'll assume that certs are named XXX.crt and the corresponding\n     * key is named XXX.key\n     */\n    while ((i < MAX_CREDS_ALLOWED) &&  (dentry = readdir(d)) != NULL) {\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        len = strlen(dentry->d_name);\n        if (len < 5)\n            continue;\n        suf = dentry->d_name + (len - 4);\n        if (strncmp(suf, \".crt\", 4) != 0)\n            continue;\n\n        /* Checked length */\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(certname)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            continue;\n        }\n        snprintf(certname, sizeof(certname), \"%s/%s\", dirname, dentry->d_name);\n        snprintf(keyname, sizeof(keyname), \"%s/%s\", dirname, dentry->d_name);\n        len = strlen(keyname);\n        keyname[len - 3] = 'k';\n        keyname[len - 2] = 'e';\n        keyname[len - 1] = 'y';\n\n        retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                             certname, keyname, i);\n        if (retval == 0) {\n            pkiDebug(\"%s: Successfully loaded cert (and key) for %s\\n\",\n                     __FUNCTION__, dentry->d_name);\n            i++;\n        }\n        else\n            continue;\n    }\n\n    if (i == 0) {\n        pkiDebug(\"%s: No cert/key pairs found in directory '%s'\\n\",\n                 __FUNCTION__, idopts->cert_filename);\n        retval = ENOENT;\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d)\n        closedir(d);\n\n    return retval;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic char *\nreassemble_pkcs11_name(pkinit_identity_opts *idopts)\n{\n    struct k5buf buf;\n    int n = 0;\n    char *ret;\n\n    krb5int_buf_init_dynamic(&buf);\n    krb5int_buf_add(&buf, \"PKCS11:\");\n    n = 0;\n    if (idopts->p11_module_name != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%smodule_name=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->p11_module_name);\n    }\n    if (idopts->token_label != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%stoken=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->token_label);\n    }\n    if (idopts->cert_label != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%scertlabel=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->cert_label);\n    }\n    if (idopts->cert_id_string != NULL) {\n        krb5int_buf_add_fmt(&buf, \"%scertid=%s\",\n                            n++ ? \",\" : \"\",\n                            idopts->cert_id_string);\n    }\n    if (idopts->slotid != PK_NOSLOT) {\n        krb5int_buf_add_fmt(&buf, \"%sslotid=%ld\",\n                            n++ ? \",\" : \"\",\n                            (long)idopts->slotid);\n    }\n    if (krb5int_buf_len(&buf) >= 0)\n        ret = strdup(krb5int_buf_data(&buf));\n    else\n        ret = NULL;\n    krb5int_free_buf(&buf);\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs11(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n#ifdef PKINIT_USE_MECH_LIST\n    CK_MECHANISM_TYPE_PTR mechp;\n    CK_MECHANISM_INFO info;\n#endif\n    CK_OBJECT_CLASS cls;\n    CK_OBJECT_HANDLE obj;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_CERTIFICATE_TYPE certtype;\n    CK_BYTE_PTR cert = NULL, cert_id;\n    const unsigned char *cp;\n    int i, r;\n    unsigned int nattrs;\n    X509 *x = NULL;\n\n    /* Copy stuff from idopts -> id_cryptoctx */\n    if (idopts->p11_module_name != NULL) {\n        id_cryptoctx->p11_module_name = strdup(idopts->p11_module_name);\n        if (id_cryptoctx->p11_module_name == NULL)\n            return ENOMEM;\n    }\n    if (idopts->token_label != NULL) {\n        id_cryptoctx->token_label = strdup(idopts->token_label);\n        if (id_cryptoctx->token_label == NULL)\n            return ENOMEM;\n    }\n    if (idopts->cert_label != NULL) {\n        id_cryptoctx->cert_label = strdup(idopts->cert_label);\n        if (id_cryptoctx->cert_label == NULL)\n            return ENOMEM;\n    }\n    /* Convert the ascii cert_id string into a binary blob */\n    if (idopts->cert_id_string != NULL) {\n        BIGNUM *bn = NULL;\n        BN_hex2bn(&bn, idopts->cert_id_string);\n        if (bn == NULL)\n            return ENOMEM;\n        id_cryptoctx->cert_id_len = BN_num_bytes(bn);\n        id_cryptoctx->cert_id = malloc((size_t) id_cryptoctx->cert_id_len);\n        if (id_cryptoctx->cert_id == NULL) {\n            BN_free(bn);\n            return ENOMEM;\n        }\n        BN_bn2bin(bn, id_cryptoctx->cert_id);\n        BN_free(bn);\n    }\n    id_cryptoctx->slotid = idopts->slotid;\n    id_cryptoctx->pkcs11_method = 1;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n#ifndef PKINIT_USE_MECH_LIST\n    /*\n     * We'd like to use CKM_SHA1_RSA_PKCS for signing if it's available, but\n     * many cards seems to be confused about whether they are capable of\n     * this or not. The safe thing seems to be to ignore the mechanism list,\n     * always use CKM_RSA_PKCS and calculate the sha1 digest ourselves.\n     */\n\n    id_cryptoctx->mech = CKM_RSA_PKCS;\n#else\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid, NULL,\n                                                   &count)) != CKR_OK || count <= 0) {\n        pkiDebug(\"C_GetMechanismList: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    mechp = malloc(count * sizeof (CK_MECHANISM_TYPE));\n    if (mechp == NULL)\n        return ENOMEM;\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid,\n                                                   mechp, &count)) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    for (i = 0; i < count; i++) {\n        if ((r = id_cryptoctx->p11->C_GetMechanismInfo(id_cryptoctx->slotid,\n                                                       mechp[i], &info)) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n#ifdef DEBUG_MECHINFO\n        pkiDebug(\"mech %x flags %x\\n\", (int) mechp[i], (int) info.flags);\n        if ((info.flags & (CKF_SIGN|CKF_DECRYPT)) == (CKF_SIGN|CKF_DECRYPT))\n            pkiDebug(\"  this mech is good for sign & decrypt\\n\");\n#endif\n        if (mechp[i] == CKM_RSA_PKCS) {\n            /* This seems backwards... */\n            id_cryptoctx->mech =\n                (info.flags & CKF_SIGN) ? CKM_SHA1_RSA_PKCS : CKM_RSA_PKCS;\n        }\n    }\n    free(mechp);\n\n    pkiDebug(\"got %d mechs from card\\n\", (int) count);\n#endif\n\n    cls = CKO_CERTIFICATE;\n    attrs[0].type = CKA_CLASS;\n    attrs[0].pValue = &cls;\n    attrs[0].ulValueLen = sizeof cls;\n\n    certtype = CKC_X_509;\n    attrs[1].type = CKA_CERTIFICATE_TYPE;\n    attrs[1].pValue = &certtype;\n    attrs[1].ulValueLen = sizeof certtype;\n\n    nattrs = 2;\n\n    /* If a cert id and/or label were given, use them too */\n    if (id_cryptoctx->cert_id_len > 0) {\n        attrs[nattrs].type = CKA_ID;\n        attrs[nattrs].pValue = id_cryptoctx->cert_id;\n        attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n        nattrs++;\n    }\n    if (id_cryptoctx->cert_label != NULL) {\n        attrs[nattrs].type = CKA_LABEL;\n        attrs[nattrs].pValue = id_cryptoctx->cert_label;\n        attrs[nattrs].ulValueLen = strlen(id_cryptoctx->cert_label);\n        nattrs++;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"C_FindObjectsInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    for (i = 0; ; i++) {\n        if (i >= MAX_CREDS_ALLOWED)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n\n        /* Look for x.509 cert */\n        if ((r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session,\n                                                  &obj, 1, &count)) != CKR_OK || count <= 0) {\n            id_cryptoctx->creds[i] = NULL;\n            break;\n        }\n\n        /* Get cert and id len */\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = NULL;\n        attrs[0].ulValueLen = 0;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = NULL;\n        attrs[1].ulValueLen = 0;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK && r != CKR_BUFFER_TOO_SMALL) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n        cert = (CK_BYTE_PTR) malloc((size_t) attrs[0].ulValueLen + 1);\n        cert_id = (CK_BYTE_PTR) malloc((size_t) attrs[1].ulValueLen + 1);\n        if (cert == NULL || cert_id == NULL)\n            return ENOMEM;\n\n        /* Read the cert and id off the card */\n\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = cert;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = cert_id;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        pkiDebug(\"cert %d size %d id %d idlen %d\\n\", i,\n                 (int) attrs[0].ulValueLen, (int) cert_id[0],\n                 (int) attrs[1].ulValueLen);\n\n        cp = (unsigned char *) cert;\n        x = d2i_X509(NULL, &cp, (int) attrs[0].ulValueLen);\n        if (x == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i] = malloc(sizeof(struct _pkinit_cred_info));\n        if (id_cryptoctx->creds[i] == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i]->name = reassemble_pkcs11_name(idopts);\n        id_cryptoctx->creds[i]->cert = x;\n        id_cryptoctx->creds[i]->key = NULL;\n        id_cryptoctx->creds[i]->cert_id = cert_id;\n        id_cryptoctx->creds[i]->cert_id_len = attrs[1].ulValueLen;\n        free(cert);\n    }\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    if (cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\n\nstatic void\nfree_cred_info(krb5_context context,\n               pkinit_identity_crypto_context id_cryptoctx,\n               struct _pkinit_cred_info *cred)\n{\n    if (cred != NULL) {\n        if (cred->cert != NULL)\n            X509_free(cred->cert);\n        if (cred->key != NULL)\n            EVP_PKEY_free(cred->key);\n#ifndef WITHOUT_PKCS11\n        free(cred->cert_id);\n#endif\n        free(cred->name);\n        free(cred);\n    }\n}\n\nkrb5_error_code\ncrypto_free_cert_info(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx)\n{\n    int i;\n\n    if (id_cryptoctx == NULL)\n        return EINVAL;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++) {\n        if (id_cryptoctx->creds[i] != NULL) {\n            free_cred_info(context, id_cryptoctx, id_cryptoctx->creds[i]);\n            id_cryptoctx->creds[i] = NULL;\n        }\n    }\n    return 0;\n}\n\nkrb5_error_code\ncrypto_load_certs(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_opts *idopts,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  krb5_principal princ)\n{\n    krb5_error_code retval;\n\n    switch(idopts->idtype) {\n    case IDTYPE_FILE:\n        retval = pkinit_get_certs_fs(context, plg_cryptoctx,\n                                     req_cryptoctx, idopts,\n                                     id_cryptoctx, princ);\n        break;\n    case IDTYPE_DIR:\n        retval = pkinit_get_certs_dir(context, plg_cryptoctx,\n                                      req_cryptoctx, idopts,\n                                      id_cryptoctx, princ);\n        break;\n#ifndef WITHOUT_PKCS11\n    case IDTYPE_PKCS11:\n        retval = pkinit_get_certs_pkcs11(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n#endif\n    case IDTYPE_PKCS12:\n        retval = pkinit_get_certs_pkcs12(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n    default:\n        retval = EINVAL;\n    }\n    if (retval)\n        goto cleanup;\n\ncleanup:\n    return retval;\n}\n\n/*\n * Get number of certificates available after crypto_load_certs()\n */\nkrb5_error_code\ncrypto_cert_get_count(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int *cert_count)\n{\n    int count;\n\n    if (id_cryptoctx == NULL || id_cryptoctx->creds[0] == NULL)\n        return EINVAL;\n\n    for (count = 0;\n         count <= MAX_CREDS_ALLOWED && id_cryptoctx->creds[count] != NULL;\n         count++);\n    *cert_count = count;\n    return 0;\n}\n\n\n/*\n * Begin iteration over the certs loaded in crypto_load_certs()\n */\nkrb5_error_code\ncrypto_cert_iteration_begin(krb5_context context,\n                            pkinit_plg_crypto_context plg_cryptoctx,\n                            pkinit_req_crypto_context req_cryptoctx,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            pkinit_cert_iter_handle *ih_ret)\n{\n    struct _pkinit_cert_iter_data *id;\n\n    if (id_cryptoctx == NULL || ih_ret == NULL)\n        return EINVAL;\n    if (id_cryptoctx->creds[0] == NULL) /* No cred info available */\n        return ENOENT;\n\n    id = calloc(1, sizeof(*id));\n    if (id == NULL)\n        return ENOMEM;\n    id->magic = ITER_MAGIC;\n    id->plgctx = plg_cryptoctx,\n        id->reqctx = req_cryptoctx,\n        id->idctx = id_cryptoctx;\n    id->index = 0;\n    *ih_ret = (pkinit_cert_iter_handle) id;\n    return 0;\n}\n\n/*\n * End iteration over the certs loaded in crypto_load_certs()\n */\nkrb5_error_code\ncrypto_cert_iteration_end(krb5_context context,\n                          pkinit_cert_iter_handle ih)\n{\n    struct _pkinit_cert_iter_data *id = (struct _pkinit_cert_iter_data *)ih;\n\n    if (id == NULL || id->magic != ITER_MAGIC)\n        return EINVAL;\n    free(ih);\n    return 0;\n}\n\n/*\n * Get next certificate handle\n */\nkrb5_error_code\ncrypto_cert_iteration_next(krb5_context context,\n                           pkinit_cert_iter_handle ih,\n                           pkinit_cert_handle *ch_ret)\n{\n    struct _pkinit_cert_iter_data *id = (struct _pkinit_cert_iter_data *)ih;\n    struct _pkinit_cert_data *cd;\n    pkinit_identity_crypto_context id_cryptoctx;\n\n    if (id == NULL || id->magic != ITER_MAGIC)\n        return EINVAL;\n\n    if (ch_ret == NULL)\n        return EINVAL;\n\n    id_cryptoctx = id->idctx;\n    if (id_cryptoctx == NULL)\n        return EINVAL;\n\n    if (id_cryptoctx->creds[id->index] == NULL)\n        return PKINIT_ITER_NO_MORE;\n\n    cd = calloc(1, sizeof(*cd));\n    if (cd == NULL)\n        return ENOMEM;\n\n    cd->magic = CERT_MAGIC;\n    cd->plgctx = id->plgctx;\n    cd->reqctx = id->reqctx;\n    cd->idctx = id->idctx;\n    cd->index = id->index;\n    cd->cred = id_cryptoctx->creds[id->index++];\n    *ch_ret = (pkinit_cert_handle)cd;\n    return 0;\n}\n\n/*\n * Release cert handle\n */\nkrb5_error_code\ncrypto_cert_release(krb5_context context,\n                    pkinit_cert_handle ch)\n{\n    struct _pkinit_cert_data *cd = (struct _pkinit_cert_data *)ch;\n    if (cd == NULL || cd->magic != CERT_MAGIC)\n        return EINVAL;\n    free(cd);\n    return 0;\n}\n\n/*\n * Get certificate Key Usage and Extended Key Usage\n */\nstatic krb5_error_code\ncrypto_retieve_X509_key_usage(krb5_context context,\n                              pkinit_plg_crypto_context plgcctx,\n                              pkinit_req_crypto_context reqcctx,\n                              X509 *x,\n                              unsigned int *ret_ku_bits,\n                              unsigned int *ret_eku_bits)\n{\n    krb5_error_code retval = 0;\n    int i;\n    unsigned int eku_bits = 0, ku_bits = 0;\n    ASN1_BIT_STRING *usage = NULL;\n\n    if (ret_ku_bits == NULL && ret_eku_bits == NULL)\n        return EINVAL;\n\n    if (ret_eku_bits)\n        *ret_eku_bits = 0;\n    else {\n        pkiDebug(\"%s: EKUs not requested, not checking\\n\", __FUNCTION__);\n        goto check_kus;\n    }\n\n    /* Start with Extended Key usage */\n    i = X509_get_ext_by_NID(x, NID_ext_key_usage, -1);\n    if (i >= 0) {\n        EXTENDED_KEY_USAGE *eku;\n\n        eku = X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL);\n        if (eku) {\n            for (i = 0; i < sk_ASN1_OBJECT_num(eku); i++) {\n                ASN1_OBJECT *certoid;\n                certoid = sk_ASN1_OBJECT_value(eku, i);\n                if ((OBJ_cmp(certoid, plgcctx->id_pkinit_KPClientAuth)) == 0)\n                    eku_bits |= PKINIT_EKU_PKINIT;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_ms_smartcard_login))) == 0)\n                    eku_bits |= PKINIT_EKU_MSSCLOGIN;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_client_auth))) == 0)\n                    eku_bits |= PKINIT_EKU_CLIENTAUTH;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_email_protect))) == 0)\n                    eku_bits |= PKINIT_EKU_EMAILPROTECTION;\n            }\n            EXTENDED_KEY_USAGE_free(eku);\n        }\n    }\n    pkiDebug(\"%s: returning eku 0x%08x\\n\", __FUNCTION__, eku_bits);\n    *ret_eku_bits = eku_bits;\n\ncheck_kus:\n    /* Now the Key Usage bits */\n    if (ret_ku_bits)\n        *ret_ku_bits = 0;\n    else {\n        pkiDebug(\"%s: KUs not requested, not checking\\n\", __FUNCTION__);\n        goto out;\n    }\n\n    /* Make sure usage exists before checking bits */\n    X509_check_ca(x);\n    usage = X509_get_ext_d2i(x, NID_key_usage, NULL, NULL);\n    if (usage) {\n        if (!ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))\n            ku_bits |= PKINIT_KU_DIGITALSIGNATURE;\n        if (!ku_reject(x, X509v3_KU_KEY_ENCIPHERMENT))\n            ku_bits |= PKINIT_KU_KEYENCIPHERMENT;\n        ASN1_BIT_STRING_free(usage);\n    }\n\n    pkiDebug(\"%s: returning ku 0x%08x\\n\", __FUNCTION__, ku_bits);\n    *ret_ku_bits = ku_bits;\n    retval = 0;\nout:\n    return retval;\n}\n\n/*\n * Return a string format of an X509_NAME in buf where\n * size is an in/out parameter.  On input it is the size\n * of the buffer, and on output it is the actual length\n * of the name.\n * If buf is NULL, returns the length req'd to hold name\n */\nstatic char *\nX509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}\n\n/*\n * Get certificate information\n */\nkrb5_error_code\ncrypto_cert_get_matching_data(krb5_context context,\n                              pkinit_cert_handle ch,\n                              pkinit_cert_matching_data **ret_md)\n{\n    krb5_error_code retval;\n    pkinit_cert_matching_data *md;\n    krb5_principal *pkinit_sans =NULL, *upn_sans = NULL;\n    struct _pkinit_cert_data *cd = (struct _pkinit_cert_data *)ch;\n    unsigned int i, j;\n    char buf[DN_BUF_LEN];\n    unsigned int bufsize = sizeof(buf);\n\n    if (cd == NULL || cd->magic != CERT_MAGIC)\n        return EINVAL;\n    if (ret_md == NULL)\n        return EINVAL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        return ENOMEM;\n\n    md->ch = ch;\n\n    /* get the subject name (in rfc2253 format) */\n    X509_NAME_oneline_ex(X509_get_subject_name(cd->cred->cert),\n                         buf, &bufsize, XN_FLAG_SEP_COMMA_PLUS);\n    md->subject_dn = strdup(buf);\n    if (md->subject_dn == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* get the issuer name (in rfc2253 format) */\n    X509_NAME_oneline_ex(X509_get_issuer_name(cd->cred->cert),\n                         buf, &bufsize, XN_FLAG_SEP_COMMA_PLUS);\n    md->issuer_dn = strdup(buf);\n    if (md->issuer_dn == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* get the san data */\n    retval = crypto_retrieve_X509_sans(context, cd->plgctx, cd->reqctx,\n                                       cd->cred->cert, &pkinit_sans,\n                                       &upn_sans, NULL);\n    if (retval)\n        goto cleanup;\n\n    j = 0;\n    if (pkinit_sans != NULL) {\n        for (i = 0; pkinit_sans[i] != NULL; i++)\n            j++;\n    }\n    if (upn_sans != NULL) {\n        for (i = 0; upn_sans[i] != NULL; i++)\n            j++;\n    }\n    if (j != 0) {\n        md->sans = calloc((size_t)j+1, sizeof(*md->sans));\n        if (md->sans == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        j = 0;\n        if (pkinit_sans != NULL) {\n            for (i = 0; pkinit_sans[i] != NULL; i++)\n                md->sans[j++] = pkinit_sans[i];\n            free(pkinit_sans);\n        }\n        if (upn_sans != NULL) {\n            for (i = 0; upn_sans[i] != NULL; i++)\n                md->sans[j++] = upn_sans[i];\n            free(upn_sans);\n        }\n        md->sans[j] = NULL;\n    } else\n        md->sans = NULL;\n\n    /* get the KU and EKU data */\n\n    retval = crypto_retieve_X509_key_usage(context, cd->plgctx, cd->reqctx,\n                                           cd->cred->cert,\n                                           &md->ku_bits, &md->eku_bits);\n    if (retval)\n        goto cleanup;\n\n    *ret_md = md;\n    retval = 0;\ncleanup:\n    if (retval) {\n        if (md)\n            crypto_cert_free_matching_data(context, md);\n    }\n    return retval;\n}\n\n/*\n * Free certificate information\n */\nkrb5_error_code\ncrypto_cert_free_matching_data(krb5_context context,\n                               pkinit_cert_matching_data *md)\n{\n    krb5_principal p;\n    int i;\n\n    if (md == NULL)\n        return EINVAL;\n    if (md->subject_dn)\n        free(md->subject_dn);\n    if (md->issuer_dn)\n        free(md->issuer_dn);\n    if (md->sans) {\n        for (i = 0, p = md->sans[i]; p != NULL; p = md->sans[++i])\n            krb5_free_principal(context, p);\n        free(md->sans);\n    }\n    free(md);\n    return 0;\n}\n\n/*\n * Make this matching certificate \"the chosen one\"\n */\nkrb5_error_code\ncrypto_cert_select(krb5_context context,\n                   pkinit_cert_matching_data *md)\n{\n    struct _pkinit_cert_data *cd;\n    if (md == NULL)\n        return EINVAL;\n\n    cd = (struct _pkinit_cert_data *)md->ch;\n    if (cd == NULL || cd->magic != CERT_MAGIC)\n        return EINVAL;\n\n    /* copy the selected cert into our id_cryptoctx */\n    if (cd->idctx->my_certs != NULL) {\n        sk_X509_pop_free(cd->idctx->my_certs, X509_free);\n    }\n    cd->idctx->my_certs = sk_X509_new_null();\n    sk_X509_push(cd->idctx->my_certs, cd->cred->cert);\n    free(cd->idctx->identity);\n    /* hang on to the selected credential name */\n    if (cd->idctx->creds[cd->index]->name != NULL)\n        cd->idctx->identity = strdup(cd->idctx->creds[cd->index]->name);\n    else\n        cd->idctx->identity = NULL;\n    cd->idctx->creds[cd->index]->cert = NULL;       /* Don't free it twice */\n    cd->idctx->cert_index = 0;\n\n    if (cd->idctx->pkcs11_method != 1) {\n        cd->idctx->my_key = cd->cred->key;\n        cd->idctx->creds[cd->index]->key = NULL;    /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        cd->idctx->cert_id = cd->cred->cert_id;\n        cd->idctx->creds[cd->index]->cert_id = NULL; /* Don't free it twice */\n        cd->idctx->cert_id_len = cd->cred->cert_id_len;\n    }\n#endif\n    return 0;\n}\n\n/*\n * Choose the default certificate as \"the chosen one\"\n */\nkrb5_error_code\ncrypto_cert_select_default(krb5_context context,\n                           pkinit_plg_crypto_context plg_cryptoctx,\n                           pkinit_req_crypto_context req_cryptoctx,\n                           pkinit_identity_crypto_context id_cryptoctx)\n{\n    krb5_error_code retval;\n    int cert_count = 0;\n\n    retval = crypto_cert_get_count(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, &cert_count);\n    if (retval) {\n        pkiDebug(\"%s: crypto_cert_get_count error %d, %s\\n\",\n                 __FUNCTION__, retval, error_message(retval));\n        goto errout;\n    }\n    if (cert_count != 1) {\n        pkiDebug(\"%s: ERROR: There are %d certs to choose from, \"\n                 \"but there must be exactly one.\\n\",\n                 __FUNCTION__, cert_count);\n        retval = EINVAL;\n        goto errout;\n    }\n    /* copy the selected cert into our id_cryptoctx */\n    if (id_cryptoctx->my_certs != NULL) {\n        sk_X509_pop_free(id_cryptoctx->my_certs, X509_free);\n    }\n    id_cryptoctx->my_certs = sk_X509_new_null();\n    sk_X509_push(id_cryptoctx->my_certs, id_cryptoctx->creds[0]->cert);\n    id_cryptoctx->creds[0]->cert = NULL;        /* Don't free it twice */\n    id_cryptoctx->cert_index = 0;\n    /* hang on to the selected credential name */\n    if (id_cryptoctx->creds[0]->name != NULL)\n        id_cryptoctx->identity = strdup(id_cryptoctx->creds[0]->name);\n    else\n        id_cryptoctx->identity = NULL;\n\n    if (id_cryptoctx->pkcs11_method != 1) {\n        id_cryptoctx->my_key = id_cryptoctx->creds[0]->key;\n        id_cryptoctx->creds[0]->key = NULL;     /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        id_cryptoctx->cert_id = id_cryptoctx->creds[0]->cert_id;\n        id_cryptoctx->creds[0]->cert_id = NULL; /* Don't free it twice */\n        id_cryptoctx->cert_id_len = id_cryptoctx->creds[0]->cert_id_len;\n    }\n#endif\n    retval = 0;\nerrout:\n    return retval;\n}\n\n\n\nstatic krb5_error_code\nload_cas_and_crls(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  int catype,\n                  char *filename)\n{\n    STACK_OF(X509_INFO) *sk = NULL;\n    STACK_OF(X509) *ca_certs = NULL;\n    STACK_OF(X509_CRL) *ca_crls = NULL;\n    BIO *in = NULL;\n    krb5_error_code retval = ENOMEM;\n    int i = 0;\n\n    /* If there isn't already a stack in the context,\n     * create a temporary one now */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (id_cryptoctx->trustedCAs != NULL)\n            ca_certs = id_cryptoctx->trustedCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (id_cryptoctx->intermediateCAs != NULL)\n            ca_certs = id_cryptoctx->intermediateCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (id_cryptoctx->revoked != NULL)\n            ca_crls = id_cryptoctx->revoked;\n        else {\n            ca_crls = sk_X509_CRL_new_null();\n            if (ca_crls == NULL)\n                return ENOMEM;\n        }\n        break;\n    default:\n        return ENOTSUP;\n    }\n\n    if (!(in = BIO_new_file(filename, \"r\"))) {\n        retval = errno;\n        pkiDebug(\"%s: error opening file '%s': %s\\n\", __FUNCTION__,\n                 filename, error_message(errno));\n        goto cleanup;\n    }\n\n    /* This loads from a file, a stack of x509/crl/pkey sets */\n    if ((sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL)) == NULL) {\n        pkiDebug(\"%s: error reading file '%s'\\n\", __FUNCTION__, filename);\n        retval = EIO;\n        goto cleanup;\n    }\n\n    /* scan over the stack created from loading the file contents,\n     * weed out duplicates, and push new ones onto the return stack\n     */\n    for (i = 0; i < sk_X509_INFO_num(sk); i++) {\n        X509_INFO *xi = sk_X509_INFO_value(sk, i);\n        if (xi != NULL && xi->x509 != NULL && catype != CATYPE_CRLS) {\n            int j = 0, size = sk_X509_num(ca_certs), flag = 0;\n\n            if (!size) {\n                sk_X509_push(ca_certs, xi->x509);\n                xi->x509 = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509 *x = sk_X509_value(ca_certs, j);\n                flag = X509_cmp(x, xi->x509);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_push(ca_certs, X509_dup(xi->x509));\n            }\n        } else if (xi != NULL && xi->crl != NULL && catype == CATYPE_CRLS) {\n            int j = 0, size = sk_X509_CRL_num(ca_crls), flag = 0;\n            if (!size) {\n                sk_X509_CRL_push(ca_crls, xi->crl);\n                xi->crl = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509_CRL *x = sk_X509_CRL_value(ca_crls, j);\n                flag = X509_CRL_cmp(x, xi->crl);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_CRL_push(ca_crls, X509_CRL_dup(xi->crl));\n            }\n        }\n    }\n\n    /* If we added something and there wasn't a stack in the\n     * context before, add the temporary stack to the context.\n     */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (sk_X509_num(ca_certs) == 0) {\n            pkiDebug(\"no anchors in file, %s\\n\", filename);\n            if (id_cryptoctx->trustedCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->trustedCAs == NULL)\n                id_cryptoctx->trustedCAs = ca_certs;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (sk_X509_num(ca_certs) == 0) {\n            pkiDebug(\"no intermediates in file, %s\\n\", filename);\n            if (id_cryptoctx->intermediateCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->intermediateCAs == NULL)\n                id_cryptoctx->intermediateCAs = ca_certs;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (sk_X509_CRL_num(ca_crls) == 0) {\n            pkiDebug(\"no crls in file, %s\\n\", filename);\n            if (id_cryptoctx->revoked == NULL)\n                sk_X509_CRL_free(ca_crls);\n        } else {\n            if (id_cryptoctx->revoked == NULL)\n                id_cryptoctx->revoked = ca_crls;\n        }\n        break;\n    default:\n        /* Should have been caught above! */\n        retval = EINVAL;\n        goto cleanup;\n        break;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (in != NULL)\n        BIO_free(in);\n    if (sk != NULL)\n        sk_X509_INFO_pop_free(sk, X509_INFO_free);\n\n    return retval;\n}\n\nstatic krb5_error_code\nload_cas_and_crls_dir(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int catype,\n                      char *dirname)\n{\n    krb5_error_code retval = EINVAL;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char filename[1024];\n\n    if (dirname == NULL)\n        return EINVAL;\n\n    d = opendir(dirname);\n    if (d == NULL)\n        return ENOENT;\n\n    while ((dentry = readdir(d))) {\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(filename)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            goto cleanup;\n        }\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        snprintf(filename, sizeof(filename), \"%s/%s\", dirname, dentry->d_name);\n\n        retval = load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, catype, filename);\n        if (retval)\n            goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d != NULL)\n        closedir(d);\n\n    return retval;\n}\n\nkrb5_error_code\ncrypto_load_cas_and_crls(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_opts *idopts,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         int idtype,\n                         int catype,\n                         char *id)\n{\n    pkiDebug(\"%s: called with idtype %s and catype %s\\n\",\n             __FUNCTION__, idtype2string(idtype), catype2string(catype));\n    switch (idtype) {\n    case IDTYPE_FILE:\n        return load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                 id_cryptoctx, catype, id);\n        break;\n    case IDTYPE_DIR:\n        return load_cas_and_crls_dir(context, plg_cryptoctx, req_cryptoctx,\n                                     id_cryptoctx, catype, id);\n        break;\n    default:\n        return ENOTSUP;\n        break;\n    }\n}\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids)\n{\n    krb5_error_code retval = ENOMEM;\n    int i = 0, sk_size = sk_X509_num(sk);\n    krb5_external_principal_identifier **krb5_cas = NULL;\n    X509 *x = NULL;\n    X509_NAME *xn = NULL;\n    unsigned char *p = NULL;\n    int len = 0;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    char buf[DN_BUF_LEN];\n\n    *ids = NULL;\n\n    krb5_cas =\n        malloc((sk_size + 1) * sizeof(krb5_external_principal_identifier *));\n    if (krb5_cas == NULL)\n        return ENOMEM;\n    krb5_cas[sk_size] = NULL;\n\n    for (i = 0; i < sk_size; i++) {\n        krb5_cas[i] = malloc(sizeof(krb5_external_principal_identifier));\n\n        x = sk_X509_value(sk, i);\n\n        X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n        pkiDebug(\"#%d cert= %s\\n\", i, buf);\n\n        /* fill-in subjectName */\n        krb5_cas[i]->subjectName.magic = 0;\n        krb5_cas[i]->subjectName.length = 0;\n        krb5_cas[i]->subjectName.data = NULL;\n\n        xn = X509_get_subject_name(x);\n        len = i2d_X509_NAME(xn, NULL);\n        if ((p = malloc((size_t) len)) == NULL)\n            goto cleanup;\n        krb5_cas[i]->subjectName.data = (char *)p;\n        i2d_X509_NAME(xn, &p);\n        krb5_cas[i]->subjectName.length = len;\n\n        /* fill-in issuerAndSerialNumber */\n        krb5_cas[i]->issuerAndSerialNumber.length = 0;\n        krb5_cas[i]->issuerAndSerialNumber.magic = 0;\n        krb5_cas[i]->issuerAndSerialNumber.data = NULL;\n\n#ifdef LONGHORN_BETA_COMPAT\n        if (longhorn == 0) { /* XXX Longhorn doesn't like this */\n#endif\n            is = PKCS7_ISSUER_AND_SERIAL_new();\n            X509_NAME_set(&is->issuer, X509_get_issuer_name(x));\n            M_ASN1_INTEGER_free(is->serial);\n            is->serial = M_ASN1_INTEGER_dup(X509_get_serialNumber(x));\n            len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n            if ((p = malloc((size_t) len)) == NULL)\n                goto cleanup;\n            krb5_cas[i]->issuerAndSerialNumber.data = (char *)p;\n            i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n            krb5_cas[i]->issuerAndSerialNumber.length = len;\n#ifdef LONGHORN_BETA_COMPAT\n        }\n#endif\n\n        /* fill-in subjectKeyIdentifier */\n        krb5_cas[i]->subjectKeyIdentifier.length = 0;\n        krb5_cas[i]->subjectKeyIdentifier.magic = 0;\n        krb5_cas[i]->subjectKeyIdentifier.data = NULL;\n\n\n#ifdef LONGHORN_BETA_COMPAT\n        if (longhorn == 0) {    /* XXX Longhorn doesn't like this */\n#endif\n            if (X509_get_ext_by_NID(x, NID_subject_key_identifier, -1) >= 0) {\n                ASN1_OCTET_STRING *ikeyid = NULL;\n\n                if ((ikeyid = X509_get_ext_d2i(x, NID_subject_key_identifier, NULL,\n                                               NULL))) {\n                    len = i2d_ASN1_OCTET_STRING(ikeyid, NULL);\n                    if ((p = malloc((size_t) len)) == NULL)\n                        goto cleanup;\n                    krb5_cas[i]->subjectKeyIdentifier.data = (char *)p;\n                    i2d_ASN1_OCTET_STRING(ikeyid, &p);\n                    krb5_cas[i]->subjectKeyIdentifier.length = len;\n                }\n                if (ikeyid != NULL)\n                    ASN1_OCTET_STRING_free(ikeyid);\n            }\n#ifdef LONGHORN_BETA_COMPAT\n        }\n#endif\n        if (is != NULL) {\n            if (is->issuer != NULL)\n                X509_NAME_free(is->issuer);\n            if (is->serial != NULL)\n                ASN1_INTEGER_free(is->serial);\n            free(is);\n        }\n    }\n\n    *ids = krb5_cas;\n\n    retval = 0;\ncleanup:\n    if (retval)\n        free_krb5_external_principal_identifier(&krb5_cas);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = NULL;\n\n    *ids = NULL;\n    if (req_cryptoctx->received_cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    sk = sk_X509_new_null();\n    if (sk == NULL)\n        goto cleanup;\n    sk_X509_push(sk, req_cryptoctx->received_cert);\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    sk_X509_free(sk);\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_supportedCMSTypes(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_algorithm_identifier ***oids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    krb5_algorithm_identifier **loids = NULL;\n    krb5_data des3oid = {0, 8, \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x03\\x07\" };\n\n    *oids = NULL;\n    loids = malloc(2 * sizeof(krb5_algorithm_identifier *));\n    if (loids == NULL)\n        goto cleanup;\n    loids[1] = NULL;\n    loids[0] = malloc(sizeof(krb5_algorithm_identifier));\n    if (loids[0] == NULL) {\n        free(loids);\n        goto cleanup;\n    }\n    retval = pkinit_copy_krb5_data(&loids[0]->algorithm, &des3oid);\n    if (retval) {\n        free(loids[0]);\n        free(loids);\n        goto cleanup;\n    }\n    loids[0]->parameters.length = 0;\n    loids[0]->parameters.data = NULL;\n\n    *oids = loids;\n    retval = 0;\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_trustedCertifiers(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = id_cryptoctx->trustedCAs;\n\n    *ids = NULL;\n    if (id_cryptoctx->trustedCAs == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_issuerAndSerial(krb5_context context,\n                       pkinit_plg_crypto_context plg_cryptoctx,\n                       pkinit_req_crypto_context req_cryptoctx,\n                       pkinit_identity_crypto_context id_cryptoctx,\n                       unsigned char **out,\n                       unsigned int *out_len)\n{\n    unsigned char *p = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    int len = 0;\n    krb5_error_code retval = ENOMEM;\n    X509 *cert = req_cryptoctx->received_cert;\n\n    *out = NULL;\n    *out_len = 0;\n    if (req_cryptoctx->received_cert == NULL)\n        return 0;\n\n    is = PKCS7_ISSUER_AND_SERIAL_new();\n    X509_NAME_set(&is->issuer, X509_get_issuer_name(cert));\n    M_ASN1_INTEGER_free(is->serial);\n    is->serial = M_ASN1_INTEGER_dup(X509_get_serialNumber(cert));\n    len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n    if ((p = *out = malloc((size_t) len)) == NULL)\n        goto cleanup;\n    i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n    *out_len = len;\n    retval = 0;\n\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}\n\nstatic int\npkcs7_decrypt(krb5_context context,\n              pkinit_identity_crypto_context id_cryptoctx,\n              PKCS7 *p7,\n              BIO *data)\n{\n    BIO *tmpmem = NULL;\n    int retval = 0, i = 0;\n    char buf[4096];\n\n    if(p7 == NULL)\n        return 0;\n\n    if(!PKCS7_type_is_enveloped(p7)) {\n        pkiDebug(\"wrong pkcs7 content type\\n\");\n        return 0;\n    }\n\n    if(!(tmpmem = pkcs7_dataDecode(context, id_cryptoctx, p7))) {\n        pkiDebug(\"unable to decrypt pkcs7 object\\n\");\n        return 0;\n    }\n\n    for(;;) {\n        i = BIO_read(tmpmem, buf, sizeof(buf));\n        if (i <= 0) break;\n        BIO_write(data, buf, i);\n        BIO_free_all(tmpmem);\n        return 1;\n    }\n    return retval;\n}\n\nkrb5_error_code\npkinit_process_td_trusted_certifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_external_principal_identifier **krb5_trusted_certifiers,\n    int td_type)\n{\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509_NAME) *sk_xn = NULL;\n    X509_NAME *xn = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    ASN1_OCTET_STRING *id = NULL;\n    const unsigned char *p = NULL;\n    char buf[DN_BUF_LEN];\n    int i = 0;\n\n    if (td_type == TD_TRUSTED_CERTIFIERS)\n        pkiDebug(\"received trusted certifiers\\n\");\n    else\n        pkiDebug(\"received invalid certificate\\n\");\n\n    sk_xn = sk_X509_NAME_new_null();\n    while(krb5_trusted_certifiers[i] != NULL) {\n        if (krb5_trusted_certifiers[i]->subjectName.data != NULL) {\n            p = (unsigned char *)krb5_trusted_certifiers[i]->subjectName.data;\n            xn = d2i_X509_NAME(NULL, &p,\n                               (int)krb5_trusted_certifiers[i]->subjectName.length);\n            if (xn == NULL)\n                goto cleanup;\n            X509_NAME_oneline(xn, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d cert = %s is trusted by kdc\\n\", i, buf);\n            else\n                pkiDebug(\"#%d cert = %s is invalid\\n\", i, buf);\n            sk_X509_NAME_push(sk_xn, xn);\n        }\n\n        if (krb5_trusted_certifiers[i]->issuerAndSerialNumber.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->issuerAndSerialNumber.data;\n            is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p,\n                                             (int)krb5_trusted_certifiers[i]->issuerAndSerialNumber.length);\n            if (is == NULL)\n                goto cleanup;\n            X509_NAME_oneline(is->issuer, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d issuer = %s serial = %ld is trusted bu kdc\\n\", i,\n                         buf, ASN1_INTEGER_get(is->serial));\n            else\n                pkiDebug(\"#%d issuer = %s serial = %ld is invalid\\n\", i, buf,\n                         ASN1_INTEGER_get(is->serial));\n            PKCS7_ISSUER_AND_SERIAL_free(is);\n        }\n\n        if (krb5_trusted_certifiers[i]->subjectKeyIdentifier.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->subjectKeyIdentifier.data;\n            id = d2i_ASN1_OCTET_STRING(NULL, &p,\n                                       (int)krb5_trusted_certifiers[i]->subjectKeyIdentifier.length);\n            if (id == NULL)\n                goto cleanup;\n            /* XXX */\n            ASN1_OCTET_STRING_free(id);\n        }\n        i++;\n    }\n    /* XXX Since we not doing anything with received trusted certifiers\n     * return an error. this is the place where we can pick a different\n     * client certificate based on the information in td_trusted_certifiers\n     */\n    retval = KRB5KDC_ERR_PREAUTH_FAILED;\ncleanup:\n    if (sk_xn != NULL)\n        sk_X509_NAME_pop_free(sk_xn, X509_NAME_free);\n\n    return retval;\n}\n\nstatic BIO *\npkcs7_dataDecode(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 PKCS7 *p7)\n{\n    int i = 0;\n    unsigned int jj = 0, tmp_len = 0;\n    BIO *out=NULL,*etmp=NULL,*bio=NULL;\n    unsigned char *tmp=NULL;\n    ASN1_OCTET_STRING *data_body=NULL;\n    const EVP_CIPHER *evp_cipher=NULL;\n    EVP_CIPHER_CTX *evp_ctx=NULL;\n    X509_ALGOR *enc_alg=NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk=NULL;\n    PKCS7_RECIP_INFO *ri=NULL;\n    X509 *cert = sk_X509_value(id_cryptoctx->my_certs,\n                               id_cryptoctx->cert_index);\n\n    p7->state=PKCS7_S_HEADER;\n\n    rsk=p7->d.enveloped->recipientinfo;\n    enc_alg=p7->d.enveloped->enc_data->algorithm;\n    data_body=p7->d.enveloped->enc_data->enc_data;\n    evp_cipher=EVP_get_cipherbyobj(enc_alg->algorithm);\n    if (evp_cipher == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE,PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n        goto cleanup;\n    }\n\n    if ((etmp=BIO_new(BIO_f_cipher())) == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE,ERR_R_BIO_LIB);\n        goto cleanup;\n    }\n\n    /* It was encrypted, we need to decrypt the secret key\n     * with the private key */\n\n    /* Find the recipientInfo which matches the passed certificate\n     * (if any)\n     */\n\n    if (cert) {\n        for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n            int tmp_ret = 0;\n            ri=sk_PKCS7_RECIP_INFO_value(rsk,i);\n            tmp_ret = X509_NAME_cmp(ri->issuer_and_serial->issuer,\n                                    cert->cert_info->issuer);\n            if (!tmp_ret) {\n                tmp_ret = M_ASN1_INTEGER_cmp(cert->cert_info->serialNumber,\n                                             ri->issuer_and_serial->serial);\n                if (!tmp_ret)\n                    break;\n            }\n            ri=NULL;\n        }\n        if (ri == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n            goto cleanup;\n        }\n\n    }\n\n    /* If we haven't got a certificate try each ri in turn */\n\n    if (cert == NULL) {\n        for (i=0; i<sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n            ri=sk_PKCS7_RECIP_INFO_value(rsk,i);\n            jj = pkinit_decode_data(context, id_cryptoctx,\n                                    M_ASN1_STRING_data(ri->enc_key),\n                                    (unsigned int) M_ASN1_STRING_length(ri->enc_key),\n                                    &tmp, &tmp_len);\n            if (jj) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_EVP_LIB);\n                goto cleanup;\n            }\n\n            if (!jj && tmp_len > 0) {\n                jj = tmp_len;\n                break;\n            }\n\n            ERR_clear_error();\n            ri = NULL;\n        }\n\n        if (ri == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_RECIPIENT_MATCHES_KEY);\n            goto cleanup;\n        }\n    }\n    else {\n        jj = pkinit_decode_data(context, id_cryptoctx,\n                                M_ASN1_STRING_data(ri->enc_key),\n                                (unsigned int) M_ASN1_STRING_length(ri->enc_key),\n                                &tmp, &tmp_len);\n        if (jj || tmp_len <= 0) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_EVP_LIB);\n            goto cleanup;\n        }\n        jj = tmp_len;\n    }\n\n    evp_ctx=NULL;\n    BIO_get_cipher_ctx(etmp,&evp_ctx);\n    if (EVP_CipherInit_ex(evp_ctx,evp_cipher,NULL,NULL,NULL,0) <= 0)\n        goto cleanup;\n    if (EVP_CIPHER_asn1_to_param(evp_ctx,enc_alg->parameter) < 0)\n        goto cleanup;\n\n    if (jj != (unsigned) EVP_CIPHER_CTX_key_length(evp_ctx)) {\n        /* Some S/MIME clients don't use the same key\n         * and effective key length. The key length is\n         * determined by the size of the decrypted RSA key.\n         */\n        if(!EVP_CIPHER_CTX_set_key_length(evp_ctx, (int)jj)) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_DECRYPTED_KEY_IS_WRONG_LENGTH);\n            goto cleanup;\n        }\n    }\n    if (EVP_CipherInit_ex(evp_ctx,NULL,NULL,tmp,NULL,0) <= 0)\n        goto cleanup;\n\n    OPENSSL_cleanse(tmp,jj);\n\n    if (out == NULL)\n        out=etmp;\n    else\n        BIO_push(out,etmp);\n    etmp=NULL;\n\n    if (data_body->length > 0)\n        bio = BIO_new_mem_buf(data_body->data, data_body->length);\n    else {\n        bio=BIO_new(BIO_s_mem());\n        BIO_set_mem_eof_return(bio,0);\n    }\n    BIO_push(out,bio);\n    bio=NULL;\n\n    if (0) {\n    cleanup:\n        if (out != NULL) BIO_free_all(out);\n        if (etmp != NULL) BIO_free_all(etmp);\n        if (bio != NULL) BIO_free_all(bio);\n        out=NULL;\n    }\n\n    if (tmp != NULL)\n        free(tmp);\n\n    return(out);\n}\n\n#ifdef DEBUG_DH\nstatic void\nprint_dh(DH * dh, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (dh)\n        DHparams_print(bio_err, dh);\n\n    BIO_puts(bio_err, \"private key: \");\n    BN_print(bio_err, dh->priv_key);\n    BIO_puts(bio_err, (const char *)\"\\n\");\n    BIO_free(bio_err);\n\n}\n\nstatic void\nprint_pubkey(BIGNUM * key, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (key)\n        BN_print(bio_err, key);\n    BIO_puts(bio_err, \"\\n\");\n\n    BIO_free(bio_err);\n\n}\n#endif\n\nstatic char *\npkinit_pkcs11_code_to_text(int err)\n{\n    int i;\n    static char uc[32];\n\n    for (i = 0; pkcs11_errstrings[i].text != NULL; i++)\n        if (pkcs11_errstrings[i].code == err)\n            break;\n    if (pkcs11_errstrings[i].text != NULL)\n        return (pkcs11_errstrings[i].text);\n    snprintf(uc, sizeof(uc), _(\"unknown code 0x%x\"), err);\n    return (uc);\n}\n"], "filenames": ["src/plugins/preauth/pkinit/pkinit_crypto_openssl.c"], "buggy_code_start_loc": [3256], "buggy_code_end_loc": [3267], "fixing_code_start_loc": [3256], "fixing_code_end_loc": [3265], "type": "CWE-476", "message": "The pkinit_check_kdc_pkid function in plugins/preauth/pkinit/pkinit_crypto_openssl.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 and 1.11.x before 1.11.1 does not properly handle errors during extraction of fields from an X.509 certificate, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a malformed KRB5_PADATA_PK_AS_REQ AS-REQ request.", "other": {"cve": {"id": "CVE-2013-1415", "sourceIdentifier": "cve@mitre.org", "published": "2013-03-05T05:05:57.457", "lastModified": "2021-02-02T18:39:29.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The pkinit_check_kdc_pkid function in plugins/preauth/pkinit/pkinit_crypto_openssl.c in the PKINIT implementation in the Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.10.4 and 1.11.x before 1.11.1 does not properly handle errors during extraction of fields from an X.509 certificate, which allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via a malformed KRB5_PADATA_PK_AS_REQ AS-REQ request."}, {"lang": "es", "value": "La funci\u00f3n pkinit_check_kdc_pkid en plugins / PREAUTH / pkinit / pkinit_crypto_openssl.c en la aplicaci\u00f3n PKINIT en el Centro de distribuci\u00f3n de claves (KDC) en MIT Kerberos 5 (alias krb5) antes de v1.10.4 y 1.11.x antes de v1.11.1 no trata correctamente los errores durante la extracci\u00f3n de los campos de un certificado X.509, que permite a atacantes remotos provocar una denegaci\u00f3n de servicio (desreferencia puntero NULL y la ca\u00edda del demonio) a trav\u00e9s de un formato incorrecto KRB5_PADATA_PK_AS_REQ AS-REQ petici\u00f3n."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.4", "matchCriteriaId": "B945C00A-A9EF-4A3E-98E7-FD655A068319"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.11:*:*:*:*:*:*:*", "matchCriteriaId": "2D554BDC-CD7D-4572-B1E8-5F627F2C5916"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:11.4:*:*:*:*:*:*:*", "matchCriteriaId": "DE554781-1EB9-446E-911F-6C11970C47F4"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7570", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=7577", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2013-03/msg00090.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://web.mit.edu/kerberos/www/krb5-1.10/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://web.mit.edu/kerberos/www/krb5-1.11/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2013:157", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/f249555301940c6df3a2cdda13b56b5674eebc2e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/f249555301940c6df3a2cdda13b56b5674eebc2e"}}