{"buggy_code": ["Changelog\n=========\n\n.. _v41-0-5:\n\n41.0.5 - 2023-10-24\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.4.\n* Added a function to support an upcoming ``pyOpenSSL`` release.\n\n.. _v41-0-4:\n\n41.0.4 - 2023-09-19\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.3.\n\n.. _v41-0-3:\n\n41.0.3 - 2023-08-01\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed performance regression loading DH public keys.\n* Fixed a memory leak when using\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`.\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.2.\n\n.. _v41-0-2:\n\n41.0.2 - 2023-07-10\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed bugs in creating and parsing SSH certificates where critical options\n  with values were handled incorrectly. Certificates are now created correctly\n  and parsing accepts correct values as well as the previously generated\n  invalid forms with a warning. In the next release, support for parsing these\n  invalid forms will be removed.\n\n.. _v41-0-1:\n\n41.0.1 - 2023-06-01\n~~~~~~~~~~~~~~~~~~~\n\n* Temporarily allow invalid ECDSA signature algorithm parameters in X.509\n  certificates, which are generated by older versions of Java.\n* Allow null bytes in pass phrases when serializing private keys.\n\n.. _v41-0-0:\n\n41.0.0 - 2023-05-30\n~~~~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL less than 1.1.1d has been\n  removed.  Users on older version of OpenSSL will need to upgrade.\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.6 has been removed.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL < 3.6.\n* Updated the minimum supported Rust version (MSRV) to 1.56.0, from 1.48.0.\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.1.\n* Added support for the :class:`~cryptography.x509.OCSPAcceptableResponses`\n  OCSP extension.\n* Added support for the :class:`~cryptography.x509.MSCertificateTemplate`\n  proprietary Microsoft certificate extension.\n* Implemented support for equality checks on all asymmetric public key types.\n* Added support for ``aes256-gcm@openssh.com`` encrypted keys in\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_private_key`.\n* Added support for obtaining X.509 certificate signature algorithm parameters\n  (including PSS) via\n  :meth:`~cryptography.x509.Certificate.signature_algorithm_parameters`.\n* Support signing :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`\n  X.509 certificates via the new keyword-only argument ``rsa_padding`` on\n  :meth:`~cryptography.x509.CertificateBuilder.sign`.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`\n  on BoringSSL.\n\n.. _v40-0-2:\n\n40.0.2 - 2023-04-14\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed compilation when using LibreSSL 3.7.2.\n* Added some functions to support an upcoming ``pyOpenSSL`` release.\n\n.. _v40-0-1:\n\n40.0.1 - 2023-03-24\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed a bug where certain operations would fail if an object happened to be\n  in the top-half of the memory-space. This only impacted 32-bit systems.\n\n.. _v40-0-0:\n\n40.0.0 - 2023-03-24\n~~~~~~~~~~~~~~~~~~~\n\n\n* **BACKWARDS INCOMPATIBLE:** As announced in the 39.0.0 changelog, the way\n  ``cryptography`` links OpenSSL has changed. This only impacts users who\n  build ``cryptography`` from source (i.e., not from a ``wheel``), and\n  specify their own version of OpenSSL. For those users, the ``CFLAGS``,\n  ``LDFLAGS``, ``INCLUDE``, ``LIB``, and ``CRYPTOGRAPHY_SUPPRESS_LINK_FLAGS``\n  environment variables are no longer valid. Instead, users need to configure\n  their builds `as documented here`_.\n* Support for Python 3.6 is deprecated and will be removed in the next\n  release.\n* Deprecated the current minimum supported Rust version (MSRV) of 1.48.0.\n  In the next release we will raise MSRV to 1.56.0. Users with the latest\n  ``pip`` will typically get a wheel and not need Rust installed, but check\n  :doc:`/installation` for documentation on installing a newer ``rustc`` if\n  required.\n* Deprecated support for OpenSSL less than 1.1.1d. The next release of\n  ``cryptography`` will drop support for older versions.\n* Deprecated support for DSA keys in\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_private_key`.\n* Deprecated support for OpenSSH serialization in\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`.\n* The minimum supported version of PyPy3 is now 7.3.10.\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.0.\n* Added support for parsing SSH certificates in addition to public keys with\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_identity`.\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key`\n  continues to support only public keys.\n* Added support for generating SSH certificates with\n  :class:`~cryptography.hazmat.primitives.serialization.SSHCertificateBuilder`.\n* Added :meth:`~cryptography.x509.Certificate.verify_directly_issued_by` to\n  :class:`~cryptography.x509.Certificate`.\n* Added a check to :class:`~cryptography.x509.NameConstraints` to ensure that\n  :class:`~cryptography.x509.DNSName` constraints do not contain any ``*``\n  wildcards.\n* Removed many unused CFFI OpenSSL bindings. This will not impact you unless\n  you are using ``cryptography`` to directly invoke OpenSSL's C API. Note that\n  these have never been considered a stable, supported, public API by\n  ``cryptography``, this note is included as a courtesy.\n* The X.509 builder classes now raise ``UnsupportedAlgorithm`` instead of\n  ``ValueError`` if an unsupported hash algorithm is passed.\n* Added public union type aliases for type hinting:\n\n  * Asymmetric types:\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.PublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.PrivateKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.CertificatePublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.CertificateIssuerPublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.CertificateIssuerPrivateKeyTypes`.\n  * SSH keys:\n    :const:`~cryptography.hazmat.primitives.serialization.SSHPublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.SSHPrivateKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.SSHCertPublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.SSHCertPrivateKeyTypes`.\n  * PKCS12:\n    :const:`~cryptography.hazmat.primitives.serialization.pkcs12.PKCS12PrivateKeyTypes`\n  * PKCS7:\n    :const:`~cryptography.hazmat.primitives.serialization.pkcs7.PKCS7HashTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.pkcs7.PKCS7PrivateKeyTypes`.\n  * Two-factor:\n    :const:`~cryptography.hazmat.primitives.twofactor.hotp.HOTPHashTypes`\n\n* Deprecated previously undocumented but not private type aliases in the\n  ``cryptography.hazmat.primitives.asymmetric.types`` module in favor of new\n  ones above.\n\n\n.. _v39-0-2:\n\n\n39.0.2 - 2023-03-02\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed a bug where the content type header was not properly encoded for\n  PKCS7 signatures when using the ``Text`` option and ``SMIME`` encoding.\n\n\n.. _v39-0-1:\n\n39.0.1 - 2023-02-07\n~~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE** - Fixed a bug where ``Cipher.update_into`` accepted Python\n  buffer protocol objects, but allowed immutable buffers. **CVE-2023-23931**\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.8.\n\n.. _v39-0-0:\n\n39.0.0 - 2023-01-01\n~~~~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL 1.1.0 has been removed.\n  Users on older version of OpenSSL will need to upgrade.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL < 3.5. The new\n  minimum LibreSSL version is 3.5.0. Going forward our policy is to support\n  versions of LibreSSL that are available in versions of OpenBSD that are\n  still receiving security support.\n* **BACKWARDS INCOMPATIBLE:** Removed the ``encode_point`` and\n  ``from_encoded_point`` methods on\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers`,\n  which had been deprecated for several years.\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.public_bytes`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.from_encoded_point`\n  should be used instead.\n* **BACKWARDS INCOMPATIBLE:** Support for using MD5 or SHA1 in\n  :class:`~cryptography.x509.CertificateBuilder`, other X.509 builders, and\n  PKCS7 has been removed.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.10 and 10.11, macOS\n  users must upgrade to 10.12 or newer.\n* **ANNOUNCEMENT:** The next version of ``cryptography`` (40.0) will change\n  the way we link OpenSSL. This will only impact users who build\n  ``cryptography`` from source (i.e., not from a ``wheel``), and specify their\n  own version of OpenSSL. For those users, the ``CFLAGS``, ``LDFLAGS``,\n  ``INCLUDE``, ``LIB``, and ``CRYPTOGRAPHY_SUPPRESS_LINK_FLAGS`` environment\n  variables will no longer be respected. Instead, users will need to\n  configure their builds `as documented here`_.\n* Added support for\n  :ref:`disabling the legacy provider in OpenSSL 3.0.x<legacy-provider>`.\n* Added support for disabling RSA key validation checks when loading RSA\n  keys via\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`,\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`,\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers.private_key`.\n  This speeds up key loading but is :term:`unsafe` if you are loading potentially\n  attacker supplied keys.\n* Significantly improved performance for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`\n  when repeatedly calling ``encrypt`` or ``decrypt`` with the same key.\n* Added support for creating OCSP requests with precomputed hashes using\n  :meth:`~cryptography.x509.ocsp.OCSPRequestBuilder.add_certificate_by_hash`.\n* Added support for loading multiple PEM-encoded X.509 certificates from\n  a single input via :func:`~cryptography.x509.load_pem_x509_certificates`.\n\n.. _v38-0-4:\n\n38.0.4 - 2022-11-27\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed compilation when using LibreSSL 3.6.0.\n* Fixed error when using ``py2app`` to build an application with a\n  ``cryptography`` dependency.\n\n.. _v38-0-3:\n\n38.0.3 - 2022-11-01\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.7,\n  which resolves *CVE-2022-3602* and *CVE-2022-3786*.\n\n.. _v38-0-2:\n\n38.0.2 - 2022-10-11 (YANKED)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. attention::\n\n    This release was subsequently yanked from PyPI due to a regression in OpenSSL.\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.6.\n\n\n.. _v38-0-1:\n\n38.0.1 - 2022-09-07\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed parsing TLVs in ASN.1 with length greater than 65535 bytes (typically\n  seen in large CRLs).\n\n.. _v38-0-0:\n\n38.0.0 - 2022-09-06\n~~~~~~~~~~~~~~~~~~~\n\n* Final deprecation of OpenSSL 1.1.0. The next release of ``cryptography``\n  will drop support.\n* We no longer ship ``manylinux2010`` wheels. Users should upgrade to the\n  latest ``pip`` to ensure this doesn't cause issues downloading wheels on\n  their platform. We now ship ``manylinux_2_28`` wheels for users on new\n  enough platforms.\n* Updated the minimum supported Rust version (MSRV) to 1.48.0, from 1.41.0.\n  Users with the latest ``pip`` will typically get a wheel and not need Rust\n  installed, but check :doc:`/installation` for documentation on installing a\n  newer ``rustc`` if required.\n* :meth:`~cryptography.fernet.Fernet.decrypt` and related methods now accept\n  both ``str`` and ``bytes`` tokens.\n* Parsing ``CertificateSigningRequest`` restores the behavior of enforcing\n  that the ``Extension`` ``critical`` field must be correctly encoded DER. See\n  `the issue <https://github.com/pyca/cryptography/issues/6368>`_ for complete\n  details.\n* Added two new OpenSSL functions to the bindings to support an upcoming\n  ``pyOpenSSL`` release.\n* When parsing :class:`~cryptography.x509.CertificateRevocationList` and\n  :class:`~cryptography.x509.CertificateSigningRequest` values, it is now\n  enforced that the ``version`` value in the input must be valid according to\n  the rules of :rfc:`2986` and :rfc:`5280`.\n* Using MD5 or SHA1 in :class:`~cryptography.x509.CertificateBuilder` and\n  other X.509 builders is deprecated and support will be removed in the next\n  version.\n* Added additional APIs to\n  :class:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp`, including\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.signature_hash_algorithm`,\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.signature_algorithm`,\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.signature`, and\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.extension_bytes`.\n* Added :attr:`~cryptography.x509.Certificate.tbs_precertificate_bytes`, allowing\n  users to access the to-be-signed pre-certificate data needed for signed\n  certificate timestamp verification.\n* :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFHMAC` and\n  :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFCMAC` now support\n  :attr:`~cryptography.hazmat.primitives.kdf.kbkdf.CounterLocation.MiddleFixed`\n  counter location.\n* Fixed :rfc:`4514` name parsing to reverse the order of the RDNs according\n  to the section 2.1 of the RFC, affecting method\n  :meth:`~cryptography.x509.Name.from_rfc4514_string`.\n* It is now possible to customize some aspects of encryption when serializing\n  private keys, using\n  :meth:`~cryptography.hazmat.primitives.serialization.PrivateFormat.encryption_builder`.\n* Removed several legacy symbols from our OpenSSL bindings. Users of pyOpenSSL\n  versions older than 22.0 will need to upgrade.\n* Added\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES128` and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES256` classes.\n  These classes do not replace\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` (which\n  allows all AES key lengths), but are intended for applications where\n  developers want to be explicit about key length.\n\n.. _v37-0-4:\n\n37.0.4 - 2022-07-05\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.5.\n\n.. _v37-0-3:\n\n37.0.3 - 2022-06-21 (YANKED)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. attention::\n\n    This release was subsequently yanked from PyPI due to a regression in OpenSSL.\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.4.\n\n.. _v37-0-2:\n\n37.0.2 - 2022-05-03\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.3.\n* Added a constant needed for an upcoming pyOpenSSL release.\n\n.. _v37-0-1:\n\n37.0.1 - 2022-04-27\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed an issue where parsing an encrypted private key with the public\n  loader functions would hang waiting for console input on OpenSSL 3.0.x rather\n  than raising an error.\n* Restored some legacy symbols for older ``pyOpenSSL`` users. These will be\n  removed again in the future, so ``pyOpenSSL`` users should still upgrade\n  to the latest version of that package when they upgrade ``cryptography``.\n\n.. _v37-0-0:\n\n37.0.0 - 2022-04-26\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.2.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL 2.9.x and 3.0.x.\n  The new minimum LibreSSL version is 3.1+.\n* **BACKWARDS INCOMPATIBLE:** Removed ``signer`` and ``verifier`` methods\n  from the public key and private key classes. These methods were originally\n  deprecated in version 2.0, but had an extended deprecation timeline due\n  to usage. Any remaining users should transition to ``sign`` and ``verify``.\n* Deprecated OpenSSL 1.1.0 support. OpenSSL 1.1.0 is no longer supported by\n  the OpenSSL project. The next release of ``cryptography`` will be the last\n  to support compiling with OpenSSL 1.1.0.\n* Deprecated Python 3.6 support. Python 3.6 is no longer supported by the\n  Python core team. Support for Python 3.6 will be removed in a future\n  ``cryptography`` release.\n* Deprecated the current minimum supported Rust version (MSRV) of 1.41.0.\n  In the next release we will raise MSRV to 1.48.0. Users with the latest\n  ``pip`` will typically get a wheel and not need Rust installed, but check\n  :doc:`/installation` for documentation on installing a newer ``rustc`` if\n  required.\n* Deprecated\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.CAST5`,\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SEED`,\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.IDEA`, and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.Blowfish` because\n  they are legacy algorithms with extremely low usage. These will be removed\n  in a future version of ``cryptography``.\n* Added limited support for distinguished names containing a bit string.\n* We now ship ``universal2`` wheels on macOS, which contain both ``arm64``\n  and ``x86_64`` architectures. Users on macOS should upgrade to the latest\n  ``pip`` to ensure they can use this wheel, although we will continue to\n  ship ``x86_64`` specific wheels for now to ease the transition.\n* This will be the final release for which we ship ``manylinux2010`` wheels.\n  Going forward the minimum supported ``manylinux`` ABI for our wheels will\n  be ``manylinux2014``. The vast majority of users will continue to receive\n  ``manylinux`` wheels provided they have an up to date ``pip``. For PyPy\n  wheels this release already requires ``manylinux2014`` for compatibility\n  with binaries distributed by upstream.\n* Added support for multiple\n  :class:`~cryptography.x509.ocsp.OCSPSingleResponse` in a\n  :class:`~cryptography.x509.ocsp.OCSPResponse`.\n* Restored support for signing certificates and other structures in\n  :doc:`/x509/index` with SHA3 hash algorithms.\n* :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` is\n  disabled in FIPS mode.\n* Added support for serialization of PKCS#12 CA friendly names/aliases in\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates`\n* Added support for 12-15 byte (96 to 120 bit) nonces to\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESOCB3`. This class\n  previously supported only 12 byte (96 bit).\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESSIV` when using\n  OpenSSL 3.0.0+.\n* Added support for serializing PKCS7 structures from a list of\n  certificates with\n  :class:`~cryptography.hazmat.primitives.serialization.pkcs7.serialize_certificates`.\n* Added support for parsing :rfc:`4514` strings with\n  :meth:`~cryptography.x509.Name.from_rfc4514_string`.\n* Added :attr:`~cryptography.hazmat.primitives.asymmetric.padding.PSS.AUTO` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. This can\n  be used to verify a signature where the salt length is not already known.\n* Added :attr:`~cryptography.hazmat.primitives.asymmetric.padding.PSS.DIGEST_LENGTH`\n  to :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. This\n  constant will set the salt length to the same length as the ``PSS`` hash\n  algorithm.\n* Added support for loading RSA-PSS key types with\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`.\n  This functionality is limited to OpenSSL 1.1.1e+ and loads the key as a\n  normal RSA private key, discarding the PSS constraint information.\n\n.. _v36-0-2:\n\n36.0.2 - 2022-03-15\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 1.1.1n.\n\n.. _v36-0-1:\n\n36.0.1 - 2021-12-14\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 1.1.1m.\n\n.. _v36-0-0:\n\n36.0.0 - 2021-11-21\n~~~~~~~~~~~~~~~~~~~\n\n* **FINAL DEPRECATION** Support for ``verifier`` and ``signer`` on our\n  asymmetric key classes was deprecated in version 2.0. These functions had an\n  extended deprecation due to usage, however the next version of\n  ``cryptography`` will drop support. Users should migrate to ``sign`` and\n  ``verify``.\n* The entire :doc:`/x509/index` layer is now written in Rust. This allows\n  alternate asymmetric key implementations that can support cloud key\n  management services or hardware security modules provided they implement\n  the necessary interface (for example:\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`).\n* :ref:`Deprecated the backend argument<faq-missing-backend>` for all\n  functions.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESOCB3`.\n* Added support for iterating over arbitrary request\n  :attr:`~cryptography.x509.CertificateSigningRequest.attributes`.\n* Deprecated the ``get_attribute_for_oid`` method on\n  :class:`~cryptography.x509.CertificateSigningRequest` in favor of\n  :meth:`~cryptography.x509.Attributes.get_attribute_for_oid` on the new\n  :class:`~cryptography.x509.Attributes` object.\n* Fixed handling of PEM files to allow loading when certificate and key are\n  in the same file.\n* Fixed parsing of :class:`~cryptography.x509.CertificatePolicies` extensions\n  containing legacy ``BMPString`` values in their ``explicitText``.\n* Allow parsing of negative serial numbers in certificates. Negative serial\n  numbers are prohibited by :rfc:`5280` so a deprecation warning will be\n  raised whenever they are encountered. A future version of ``cryptography``\n  will drop support for parsing them.\n* Added support for parsing PKCS12 files with friendly names for all\n  certificates with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.load_pkcs12`,\n  which will return an object of type\n  :class:`~cryptography.hazmat.primitives.serialization.pkcs12.PKCS12KeyAndCertificates`.\n* :meth:`~cryptography.x509.Name.rfc4514_string` and related methods now have\n  an optional ``attr_name_overrides`` parameter to supply custom OID to name\n  mappings, which can be used to match vendor-specific extensions.\n* **BACKWARDS INCOMPATIBLE:** Reverted the nonstandard formatting of\n  email address fields as ``E`` in\n  :meth:`~cryptography.x509.Name.rfc4514_string` methods from version 35.0.\n\n  The previous behavior can be restored with:\n  ``name.rfc4514_string({NameOID.EMAIL_ADDRESS: \"E\"})``\n* Allow\n  :class:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey`\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.x448.X448PublicKey` to\n  be used as public keys when parsing certificates or creating them with\n  :class:`~cryptography.x509.CertificateBuilder`. These key types must be\n  signed with a different signing algorithm as ``X25519`` and ``X448`` do\n  not support signing.\n* Extension values can now be serialized to a DER byte string by calling\n  :func:`~cryptography.x509.ExtensionType.public_bytes`.\n* Added experimental support for compiling against BoringSSL. As BoringSSL\n  does not commit to a stable API, ``cryptography`` tests against the\n  latest commit only. Please note that several features are not available\n  when building against BoringSSL.\n* Parsing ``CertificateSigningRequest`` from DER and PEM now, for a limited\n  time period, allows the ``Extension`` ``critical`` field to be incorrectly\n  encoded. See `the issue <https://github.com/pyca/cryptography/issues/6368>`_\n  for complete details. This will be reverted in a future ``cryptography``\n  release.\n* When :class:`~cryptography.x509.OCSPNonce` are parsed and generated their\n  value is now correctly wrapped in an ASN.1 ``OCTET STRING``. This conforms\n  to :rfc:`6960` but conflicts with the original behavior specified in\n  :rfc:`2560`. For a temporary period for backwards compatibility, we will\n  also parse values that are encoded as specified in :rfc:`2560` but this\n  behavior will be removed in a future release.\n\n.. _v35-0-0:\n\n35.0.0 - 2021-09-29\n~~~~~~~~~~~~~~~~~~~\n\n* Changed the :ref:`version scheme <api-stability:versioning>`. This will\n  result in us incrementing the major version more frequently, but does not\n  change our existing backwards compatibility policy.\n* **BACKWARDS INCOMPATIBLE:** The :doc:`/x509/index` PEM parsers now require\n  that the PEM string passed have PEM delimiters of the correct type. For\n  example, parsing a private key PEM concatenated with a certificate PEM will\n  no longer be accepted by the PEM certificate parser.\n* **BACKWARDS INCOMPATIBLE:** The X.509 certificate parser no longer allows\n  negative serial numbers. :rfc:`5280` has always prohibited these.\n* **BACKWARDS INCOMPATIBLE:** Additional forms of invalid ASN.1 found during\n  :doc:`/x509/index` parsing will raise an error on initial parse rather than\n  when the malformed field is accessed.\n* Rust is now required for building ``cryptography``, the\n  ``CRYPTOGRAPHY_DONT_BUILD_RUST`` environment variable is no longer\n  respected.\n* Parsers for :doc:`/x509/index` no longer use OpenSSL and have been\n  rewritten in Rust. This should be backwards compatible (modulo the items\n  listed above) and improve both security and performance.\n* Added support for OpenSSL 3.0.0 as a compilation target.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.hashes.SM3` and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SM4`,\n  when using OpenSSL 1.1.1. These algorithms are provided for compatibility\n  in regions where they may be required, and are not generally recommended.\n* We now ship ``manylinux_2_24`` and ``musllinux_1_1`` wheels, in addition to\n  our ``manylinux2010`` and ``manylinux2014`` wheels. Users on distributions\n  like Alpine Linux should ensure they upgrade to the latest ``pip`` to\n  correctly receive wheels.\n* Added ``rfc4514_attribute_name`` attribute to :attr:`x509.NameAttribute\n  <cryptography.x509.NameAttribute.rfc4514_attribute_name>`.\n* Added :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFCMAC`.\n\n.. _v3-4-8:\n\n3.4.8 - 2021-08-24\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1l.\n\n.. _v3-4-7:\n\n3.4.7 - 2021-03-25\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1k.\n\n.. _v3-4-6:\n\n3.4.6 - 2021-02-16\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1j.\n\n.. _v3-4-5:\n\n3.4.5 - 2021-02-13\n~~~~~~~~~~~~~~~~~~\n\n* Various improvements to type hints.\n* Lower the minimum supported Rust version (MSRV) to >=1.41.0. This change\n  improves compatibility with system-provided Rust on several Linux\n  distributions.\n* ``cryptography`` will be switching to a new versioning scheme with its next\n  feature release. More information is available in our\n  :doc:`/api-stability` documentation.\n\n.. _v3-4-4:\n\n3.4.4 - 2021-02-09\n~~~~~~~~~~~~~~~~~~\n\n* Added a ``py.typed`` file so that ``mypy`` will know to use our type\n  annotations.\n* Fixed an import cycle that could be triggered by certain import sequences.\n\n.. _v3-4-3:\n\n3.4.3 - 2021-02-08\n~~~~~~~~~~~~~~~~~~\n\n* Specify our supported Rust version (>=1.45.0) in our ``setup.py`` so users\n  on older versions will get a clear error message.\n\n.. _v3-4-2:\n\n3.4.2 - 2021-02-08\n~~~~~~~~~~~~~~~~~~\n\n* Improvements to make the rust transition a bit easier. This includes some\n  better error messages and small dependency fixes. If you experience\n  installation problems **Be sure to update pip** first, then check the\n  :doc:`FAQ </faq>`.\n\n.. _v3-4-1:\n\n3.4.1 - 2021-02-07\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a circular import issue.\n* Added additional debug output to assist users seeing installation errors\n  due to outdated ``pip`` or missing ``rustc``.\n\n.. _v3-4:\n\n3.4 - 2021-02-07\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 2 has been removed.\n* We now ship ``manylinux2014`` wheels and no longer ship ``manylinux1``\n  wheels. Users should upgrade to the latest ``pip`` to ensure this doesn't\n  cause issues downloading wheels on their platform.\n* ``cryptography`` now incorporates Rust code. Users building ``cryptography``\n  themselves will need to have the Rust toolchain installed. Users who use an\n  officially produced wheel will not need to make any changes. The minimum\n  supported Rust version is 1.45.0.\n* ``cryptography`` now has :pep:`484` type hints on nearly all of of its public\n  APIs. Users can begin using them to type check their code with ``mypy``.\n\n.. _v3-3-2:\n\n3.3.2 - 2021-02-07\n~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE:** Fixed a bug where certain sequences of ``update()`` calls\n  when symmetrically encrypting very large payloads (>2GB) could result in an\n  integer overflow, leading to buffer overflows. *CVE-2020-36242* **Update:**\n  This fix is a workaround for *CVE-2021-23840* in OpenSSL, fixed in OpenSSL\n  1.1.1j.\n\n.. _v3-3-1:\n\n3.3.1 - 2020-12-09\n~~~~~~~~~~~~~~~~~~\n\n* Re-added a legacy symbol causing problems for older ``pyOpenSSL`` users.\n\n.. _v3-3:\n\n3.3 - 2020-12-08\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.5 has been removed due to\n  low usage and maintenance burden.\n* **BACKWARDS INCOMPATIBLE:** The\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` and\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESGCM` now require\n  64-bit to 1024-bit (8 byte to 128 byte) initialization vectors. This change\n  is to conform with an upcoming OpenSSL release that will no longer support\n  sizes outside this window.\n* **BACKWARDS INCOMPATIBLE:** When deserializing asymmetric keys we now\n  raise ``ValueError`` rather than ``UnsupportedAlgorithm`` when an\n  unsupported cipher is used. This change is to conform with an upcoming\n  OpenSSL release that will no longer distinguish between error types.\n* **BACKWARDS INCOMPATIBLE:** We no longer allow loading of finite field\n  Diffie-Hellman parameters of less than 512 bits in length. This change is to\n  conform with an upcoming OpenSSL release that no longer supports smaller\n  sizes. These keys were already wildly insecure and should not have been used\n  in any application outside of testing.\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1i.\n* Python 2 support is deprecated in ``cryptography``. This is the last release\n  that will support Python 2.\n* Added the\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey.recover_data_from_signature`\n  function to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`\n  for recovering the signed data from an RSA signature.\n\n.. _v3-2-1:\n\n3.2.1 - 2020-10-27\n~~~~~~~~~~~~~~~~~~\n\n* Disable blinding on RSA public keys to address an error with some versions\n  of OpenSSL.\n\n.. _v3-2:\n\n3.2 - 2020-10-25\n~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE:** Attempted to make RSA PKCS#1v1.5 decryption more constant\n  time, to protect against Bleichenbacher vulnerabilities. Due to limitations\n  imposed by our API, we cannot completely mitigate this vulnerability and a\n  future release will contain a new API which is designed to be resilient to\n  these for contexts where it is required. Credit to **Hubert Kario** for\n  reporting the issue. *CVE-2020-25659*\n* Support for OpenSSL 1.0.2 has been removed. Users on older version of OpenSSL\n  will need to upgrade.\n* Added basic support for PKCS7 signing (including SMIME) via\n  :class:`~cryptography.hazmat.primitives.serialization.pkcs7.PKCS7SignatureBuilder`.\n\n.. _v3-1-1:\n\n3.1.1 - 2020-09-22\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1h.\n\n.. _v3-1:\n\n3.1 - 2020-08-26\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Removed support for ``idna`` based\n  :term:`U-label` parsing in various X.509 classes. This support was originally\n  deprecated in version 2.1 and moved to an extra in 2.5.\n* Deprecated OpenSSL 1.0.2 support. OpenSSL 1.0.2 is no longer supported by\n  the OpenSSL project. The next version of ``cryptography`` will drop support\n  for it.\n* Deprecated support for Python 3.5. This version sees very little use and will\n  be removed in the next release.\n* ``backend`` arguments to functions are no longer required and the\n  default backend will automatically be selected if no ``backend`` is provided.\n* Added initial support for parsing certificates from PKCS7 files with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`\n  .\n* Calling ``update`` or ``update_into`` on\n  :class:`~cryptography.hazmat.primitives.ciphers.CipherContext` with ``data``\n  longer than 2\\ :sup:`31` bytes no longer raises an ``OverflowError``. This\n  also resolves the same issue in :doc:`/fernet`.\n\n.. _v3-0:\n\n3.0 - 2020-07-20\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Removed support for passing an\n  :class:`~cryptography.x509.Extension` instance to\n  :meth:`~cryptography.x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier`,\n  as per our deprecation policy.\n* **BACKWARDS INCOMPATIBLE:** Support for LibreSSL 2.7.x, 2.8.x, and 2.9.0 has\n  been removed (2.9.1+ is still supported).\n* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.9, macOS users must\n  upgrade to 10.10 or newer.\n* **BACKWARDS INCOMPATIBLE:** RSA\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key`\n  no longer accepts ``public_exponent`` values except 65537 and 3 (the latter\n  for legacy purposes).\n* **BACKWARDS INCOMPATIBLE:** X.509 certificate parsing now enforces that the\n  ``version`` field contains a valid value, rather than deferring this check\n  until :attr:`~cryptography.x509.Certificate.version` is accessed.\n* Deprecated support for Python 2. At the time there is no time table for\n  actually dropping support, however we strongly encourage all users to upgrade\n  their Python, as Python 2 no longer receives support from the Python core\n  team.\n\n  If you have trouble suppressing this warning in tests view the :ref:`FAQ\n  entry addressing this issue <faq-howto-handle-deprecation-warning>`.\n\n* Added support for ``OpenSSH`` serialization format for\n  ``ec``, ``ed25519``, ``rsa`` and ``dsa`` private keys:\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_private_key`\n  for loading and\n  :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.OpenSSH`\n  for writing.\n* Added support for ``OpenSSH`` certificates to\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key`.\n* Added :meth:`~cryptography.fernet.Fernet.encrypt_at_time` and\n  :meth:`~cryptography.fernet.Fernet.decrypt_at_time` to\n  :class:`~cryptography.fernet.Fernet`.\n* Added support for the :class:`~cryptography.x509.SubjectInformationAccess`\n  X.509 extension.\n* Added support for parsing\n  :class:`~cryptography.x509.SignedCertificateTimestamps` in OCSP responses.\n* Added support for parsing attributes in certificate signing requests via\n  ``CertificateSigningRequest.get_attribute_for_oid``.\n* Added support for encoding attributes in certificate signing requests via\n  :meth:`~cryptography.x509.CertificateSigningRequestBuilder.add_attribute`.\n* On OpenSSL 1.1.1d and higher ``cryptography`` now uses OpenSSL's\n  built-in CSPRNG instead of its own OS random engine because these versions of\n  OpenSSL properly reseed on fork.\n* Added initial support for creating PKCS12 files with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates`.\n\n.. _v2-9-2:\n\n2.9.2 - 2020-04-22\n~~~~~~~~~~~~~~~~~~\n\n* Updated the macOS wheel to fix an issue where it would not run on macOS\n  versions older than 10.15.\n\n.. _v2-9-1:\n\n2.9.1 - 2020-04-21\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1g.\n\n.. _v2-9:\n\n2.9 - 2020-04-02\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.4 has been removed due to\n  low usage and maintenance burden.\n* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL 1.0.1 has been removed.\n  Users on older version of OpenSSL will need to upgrade.\n* **BACKWARDS INCOMPATIBLE:** Support for LibreSSL 2.6.x has been removed.\n* Removed support for calling\n  :meth:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey.public_bytes`\n  with no arguments, as per our deprecation policy. You must now pass\n  ``encoding`` and ``format``.\n* **BACKWARDS INCOMPATIBLE:** Reversed the order in which\n  :meth:`~cryptography.x509.Name.rfc4514_string` returns the RDNs\n  as required by :rfc:`4514`.\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1f.\n* Added support for parsing\n  :attr:`~cryptography.x509.ocsp.OCSPResponse.single_extensions` in an OCSP\n  response.\n* :class:`~cryptography.x509.NameAttribute` values can now be empty strings.\n\n.. _v2-8:\n\n2.8 - 2019-10-16\n~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1d.\n* Added support for Python 3.8.\n* Added class methods\n  :meth:`Poly1305.generate_tag\n  <cryptography.hazmat.primitives.poly1305.Poly1305.generate_tag>`\n  and\n  :meth:`Poly1305.verify_tag\n  <cryptography.hazmat.primitives.poly1305.Poly1305.verify_tag>`\n  for Poly1305 sign and verify operations.\n* Deprecated support for OpenSSL 1.0.1. Support will be removed in\n  ``cryptography`` 2.9.\n* We now ship ``manylinux2010`` wheels in addition to our ``manylinux1``\n  wheels.\n* Added support for ``ed25519`` and ``ed448`` keys in the\n  :class:`~cryptography.x509.CertificateBuilder`,\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`,\n  :class:`~cryptography.x509.CertificateRevocationListBuilder` and\n  :class:`~cryptography.x509.ocsp.OCSPResponseBuilder`.\n* ``cryptography`` no longer depends on ``asn1crypto``.\n* :class:`~cryptography.x509.FreshestCRL` is now allowed as a\n  :class:`~cryptography.x509.CertificateRevocationList` extension.\n\n.. _v2-7:\n\n2.7 - 2019-05-30\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** We no longer distribute 32-bit ``manylinux1``\n  wheels. Continuing to produce them was a maintenance burden.\n* **BACKWARDS INCOMPATIBLE:** Removed the\n  ``cryptography.hazmat.primitives.mac.MACContext`` interface. The ``CMAC`` and\n  ``HMAC`` APIs have not changed, but they are no longer registered as\n  ``MACContext`` instances.\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.1c.\n* Removed support for running our tests with ``setup.py test``. Users\n  interested in running our tests can continue to follow the directions in our\n  :doc:`development documentation</development/getting-started>`.\n* Add support for :class:`~cryptography.hazmat.primitives.poly1305.Poly1305`\n  when using OpenSSL 1.1.1 or newer.\n* Support serialization with ``Encoding.OpenSSH`` and ``PublicFormat.OpenSSH``\n  in\n  :meth:`Ed25519PublicKey.public_bytes\n  <cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey.public_bytes>`\n  .\n* Correctly allow passing a ``SubjectKeyIdentifier`` to\n  :meth:`~cryptography.x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier`\n  and deprecate passing an ``Extension`` object. The documentation always\n  required ``SubjectKeyIdentifier`` but the implementation previously\n  required an ``Extension``.\n\n.. _v2-6-1:\n\n2.6.1 - 2019-02-27\n~~~~~~~~~~~~~~~~~~\n\n* Resolved an error in our build infrastructure that broke our Python3 wheels\n  for macOS and Linux.\n\n.. _v2-6:\n\n2.6 - 2019-02-27\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Removed\n  ``cryptography.hazmat.primitives.asymmetric.utils.encode_rfc6979_signature``\n  and\n  ``cryptography.hazmat.primitives.asymmetric.utils.decode_rfc6979_signature``,\n  which had been deprecated for nearly 4 years. Use\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.encode_dss_signature`\n  and\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`\n  instead.\n* **BACKWARDS INCOMPATIBLE**: Removed ``cryptography.x509.Certificate.serial``,\n  which had been deprecated for nearly 3 years. Use\n  :attr:`~cryptography.x509.Certificate.serial_number` instead.\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.1b.\n* Added support for :doc:`/hazmat/primitives/asymmetric/ed448` when using\n  OpenSSL 1.1.1b or newer.\n* Added support for :doc:`/hazmat/primitives/asymmetric/ed25519` when using\n  OpenSSL 1.1.1b or newer.\n* :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` can\n  now load ``ed25519`` public keys.\n* Add support for easily mapping an object identifier to its elliptic curve\n  class via\n  :func:`~cryptography.hazmat.primitives.asymmetric.ec.get_curve_for_oid`.\n* Add support for OpenSSL when compiled with the ``no-engine``\n  (``OPENSSL_NO_ENGINE``) flag.\n\n.. _v2-5:\n\n2.5 - 2019-01-22\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** :term:`U-label` strings were deprecated in\n  version 2.1, but this version removes the default ``idna`` dependency as\n  well. If you still need this deprecated path please install cryptography\n  with the ``idna`` extra: ``pip install cryptography[idna]``.\n* **BACKWARDS INCOMPATIBLE:** The minimum supported PyPy version is now 5.4.\n* Numerous classes and functions have been updated to allow :term:`bytes-like`\n  types for keying material and passwords, including symmetric algorithms, AEAD\n  ciphers, KDFs, loading asymmetric keys, and one time password classes.\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.1a.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.SHA512_224`\n  and :class:`~cryptography.hazmat.primitives.hashes.SHA512_256` when using\n  OpenSSL 1.1.1.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.SHA3_224`,\n  :class:`~cryptography.hazmat.primitives.hashes.SHA3_256`,\n  :class:`~cryptography.hazmat.primitives.hashes.SHA3_384`, and\n  :class:`~cryptography.hazmat.primitives.hashes.SHA3_512` when using OpenSSL\n  1.1.1.\n* Added support for :doc:`/hazmat/primitives/asymmetric/x448` when using\n  OpenSSL 1.1.1.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.SHAKE128`\n  and :class:`~cryptography.hazmat.primitives.hashes.SHAKE256` when using\n  OpenSSL 1.1.1.\n* Added initial support for parsing PKCS12 files with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.load_key_and_certificates`.\n* Added support for :class:`~cryptography.x509.IssuingDistributionPoint`.\n* Added ``rfc4514_string()`` method to\n  :meth:`x509.Name <cryptography.x509.Name.rfc4514_string>`,\n  :meth:`x509.RelativeDistinguishedName\n  <cryptography.x509.RelativeDistinguishedName.rfc4514_string>`, and\n  :meth:`x509.NameAttribute <cryptography.x509.NameAttribute.rfc4514_string>`\n  to format the name or component an :rfc:`4514` Distinguished Name string.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.from_encoded_point`,\n  which immediately checks if the point is on the curve and supports compressed\n  points. Deprecated the previous method\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.from_encoded_point`.\n* Added :attr:`~cryptography.x509.ocsp.OCSPResponse.signature_hash_algorithm`\n  to ``OCSPResponse``.\n* Updated :doc:`/hazmat/primitives/asymmetric/x25519` support to allow\n  additional serialization methods. Calling\n  :meth:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey.public_bytes`\n  with no arguments has been deprecated.\n* Added support for encoding compressed and uncompressed points via\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.public_bytes`. Deprecated the previous method\n  ``cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.encode_point``.\n\n\n.. _v2-4-2:\n\n2.4.2 - 2018-11-21\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0j.\n\n.. _v2-4-1:\n\n2.4.1 - 2018-11-11\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a build breakage in our ``manylinux1`` wheels.\n\n.. _v2-4:\n\n2.4 - 2018-11-11\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL 2.4.x.\n* Deprecated OpenSSL 1.0.1 support. OpenSSL 1.0.1 is no longer supported by\n  the OpenSSL project. At this time there is no time table for dropping\n  support, however we strongly encourage all users to upgrade or install\n  ``cryptography`` from a wheel.\n* Added initial :doc:`OCSP </x509/ocsp>` support.\n* Added support for :class:`~cryptography.x509.PrecertPoison`.\n\n.. _v2-3-1:\n\n2.3.1 - 2018-08-14\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0i.\n\n.. _v2-3:\n\n2.3 - 2018-07-18\n~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE:**\n  :meth:`~cryptography.hazmat.primitives.ciphers.AEADDecryptionContext.finalize_with_tag`\n  allowed tag truncation by default which can allow tag forgery in some cases.\n  The method now enforces the ``min_tag_length`` provided to the\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` constructor.\n  *CVE-2018-10903*\n* Added support for Python 3.7.\n* Added :meth:`~cryptography.fernet.Fernet.extract_timestamp` to get the\n  authenticated timestamp of a :doc:`Fernet </fernet>` token.\n* Support for Python 2.7.x without ``hmac.compare_digest`` has been deprecated.\n  We will require Python 2.7.7 or higher (or 2.7.6 on Ubuntu) in the next\n  ``cryptography`` release.\n* Fixed multiple issues preventing ``cryptography`` from compiling against\n  LibreSSL 2.7.x.\n* Added\n  :class:`~cryptography.x509.CertificateRevocationList.get_revoked_certificate_by_serial_number`\n  for quick serial number searches in CRLs.\n* The :class:`~cryptography.x509.RelativeDistinguishedName` class now\n  preserves the order of attributes. Duplicate attributes now raise an error\n  instead of silently discarding duplicates.\n* :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap` and\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap_with_padding`\n  now raise :class:`~cryptography.hazmat.primitives.keywrap.InvalidUnwrap` if\n  the wrapped key is an invalid length, instead of ``ValueError``.\n\n.. _v2-2-2:\n\n2.2.2 - 2018-03-27\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0h.\n\n.. _v2-2-1:\n\n2.2.1 - 2018-03-20\n~~~~~~~~~~~~~~~~~~\n\n* Reverted a change to ``GeneralNames`` which prohibited having zero elements,\n  due to breakages.\n* Fixed a bug in\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap_with_padding`\n  that caused it to raise ``InvalidUnwrap`` when key length modulo 8 was\n  zero.\n\n\n.. _v2-2:\n\n2.2 - 2018-03-19\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 2.6 has been dropped.\n* Resolved a bug in ``HKDF`` that incorrectly constrained output size.\n* Added :class:`~cryptography.hazmat.primitives.asymmetric.ec.BrainpoolP256R1`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.BrainpoolP384R1`, and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.BrainpoolP512R1` to\n  support inter-operating with systems like German smart meters.\n* Added token rotation support to :doc:`Fernet </fernet>` with\n  :meth:`~cryptography.fernet.MultiFernet.rotate`.\n* Fixed a memory leak in\n  :func:`~cryptography.hazmat.primitives.asymmetric.ec.derive_private_key`.\n* Added support for AES key wrapping with padding via\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_wrap_with_padding`\n  and\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap_with_padding`\n  .\n* Allow loading DSA keys with 224 bit ``q``.\n\n.. _v2-1-4:\n\n2.1.4 - 2017-11-29\n~~~~~~~~~~~~~~~~~~\n\n* Added ``X509_up_ref`` for an upcoming ``pyOpenSSL`` release.\n\n.. _v2-1-3:\n\n2.1.3 - 2017-11-02\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0g.\n\n.. _v2-1-2:\n\n2.1.2 - 2017-10-24\n~~~~~~~~~~~~~~~~~~\n\n* Corrected a bug with the ``manylinux1`` wheels where OpenSSL's stack was\n  marked executable.\n\n.. _v2-1-1:\n\n2.1.1 - 2017-10-12\n~~~~~~~~~~~~~~~~~~\n\n* Fixed support for install with the system ``pip`` on Ubuntu 16.04.\n\n.. _v2-1:\n\n2.1 - 2017-10-11\n~~~~~~~~~~~~~~~~\n\n* **FINAL DEPRECATION** Python 2.6 support is deprecated, and will be removed\n  in the next release of ``cryptography``.\n* **BACKWARDS INCOMPATIBLE:** ``Whirlpool``, ``RIPEMD160``, and\n  ``UnsupportedExtension`` have been removed in accordance with our\n  :doc:`/api-stability` policy.\n* **BACKWARDS INCOMPATIBLE:**\n  :attr:`DNSName.value <cryptography.x509.DNSName.value>`,\n  :attr:`RFC822Name.value <cryptography.x509.RFC822Name.value>`, and\n  :attr:`UniformResourceIdentifier.value\n  <cryptography.x509.UniformResourceIdentifier.value>`\n  will now return an :term:`A-label` string when parsing a certificate\n  containing an internationalized domain name (IDN) or if the caller passed\n  a :term:`U-label` to the constructor. See below for additional deprecations\n  related to this change.\n* Installing ``cryptography`` now requires ``pip`` 6 or newer.\n* Deprecated passing :term:`U-label` strings to the\n  :class:`~cryptography.x509.DNSName`,\n  :class:`~cryptography.x509.UniformResourceIdentifier`, and\n  :class:`~cryptography.x509.RFC822Name` constructors. Instead, users should\n  pass values as :term:`A-label` strings with ``idna`` encoding if necessary.\n  This change will not affect anyone who is not processing internationalized\n  domains.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.ChaCha20`. In\n  most cases users should choose\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`\n  rather than using this unauthenticated form.\n* Added :meth:`~cryptography.x509.CertificateRevocationList.is_signature_valid`\n  to :class:`~cryptography.x509.CertificateRevocationList`.\n* Support :class:`~cryptography.hazmat.primitives.hashes.BLAKE2b` and\n  :class:`~cryptography.hazmat.primitives.hashes.BLAKE2s` with\n  :class:`~cryptography.hazmat.primitives.hmac.HMAC`.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.XTS` mode for\n  AES.\n* Added support for using labels with\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.OAEP` when using\n  OpenSSL 1.0.2 or greater.\n* Improved compatibility with NSS when issuing certificates from an issuer\n  that has a subject with non-``UTF8String`` string types.\n* Add support for the :class:`~cryptography.x509.DeltaCRLIndicator` extension.\n* Add support for the :class:`~cryptography.x509.TLSFeature`\n  extension. This is commonly used for enabling ``OCSP Must-Staple`` in\n  certificates.\n* Add support for the :class:`~cryptography.x509.FreshestCRL` extension.\n\n.. _v2-0-3:\n\n2.0.3 - 2017-08-03\n~~~~~~~~~~~~~~~~~~\n\n* Fixed an issue with weak linking symbols when compiling on macOS\n  versions older than 10.12.\n\n\n.. _v2-0-2:\n\n2.0.2 - 2017-07-27\n~~~~~~~~~~~~~~~~~~\n\n* Marked all symbols as hidden in the ``manylinux1`` wheel to avoid a\n  bug with symbol resolution in certain scenarios.\n\n\n.. _v2-0-1:\n\n2.0.1 - 2017-07-26\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a compilation bug affecting OpenBSD.\n* Altered the ``manylinux1`` wheels to statically link OpenSSL instead of\n  dynamically linking and bundling the shared object. This should resolve\n  crashes seen when using ``uwsgi`` or other binaries that link against\n  OpenSSL independently.\n* Fixed the stack level for the ``signer`` and ``verifier`` warnings.\n\n\n.. _v2-0:\n\n2.0 - 2017-07-17\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.3 has been dropped.\n* We now ship ``manylinux1`` wheels linked against OpenSSL 1.1.0f. These wheels\n  will be automatically used with most Linux distributions if you are running\n  the latest pip.\n* Deprecated the use of ``signer`` on\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`\n  in favor of ``sign``.\n* Deprecated the use of ``verifier`` on\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`\n  in favor of ``verify``.\n* Added support for parsing\n  :class:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp`\n  objects from X.509 certificate extensions.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESCCM`.\n* Added\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESGCM`, a \"one shot\"\n  API for AES GCM encryption.\n* Added support for :doc:`/hazmat/primitives/asymmetric/x25519`.\n* Added support for serializing and deserializing Diffie-Hellman parameters\n  with\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_parameters`,\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_parameters`,\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters.parameter_bytes`\n  .\n* The ``extensions`` attribute on :class:`~cryptography.x509.Certificate`,\n  :class:`~cryptography.x509.CertificateSigningRequest`,\n  :class:`~cryptography.x509.CertificateRevocationList`, and\n  :class:`~cryptography.x509.RevokedCertificate` now caches the computed\n  ``Extensions`` object. There should be no performance change, just a\n  performance improvement for programs accessing the ``extensions`` attribute\n  multiple times.\n\n\n.. _v1-9:\n\n1.9 - 2017-05-29\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Elliptic Curve signature verification no longer\n  returns ``True`` on success. This brings it in line with the interface's\n  documentation, and our intent. The correct way to use\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.verify`\n  has always been to check whether or not\n  :class:`~cryptography.exceptions.InvalidSignature` was raised.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.7 and 10.8.\n* **BACKWARDS INCOMPATIBLE:** The minimum supported PyPy version is now 5.3.\n* Python 3.3 support has been deprecated, and will be removed in the next\n  ``cryptography`` release.\n* Add support for providing ``tag`` during\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` finalization via\n  :meth:`~cryptography.hazmat.primitives.ciphers.AEADDecryptionContext.finalize_with_tag`.\n* Fixed an issue preventing ``cryptography`` from compiling against\n  LibreSSL 2.5.x.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.key_size`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey.key_size`\n  as convenience methods for determining the bit size of a secret scalar for\n  the curve.\n* Accessing an unrecognized extension marked critical on an X.509 object will\n  no longer raise an ``UnsupportedExtension`` exception, instead an\n  :class:`~cryptography.x509.UnrecognizedExtension` object will be returned.\n  This behavior was based on a poor reading of the RFC, unknown critical\n  extensions only need to be rejected on certificate verification.\n* The CommonCrypto backend has been removed.\n* MultiBackend has been removed.\n* ``Whirlpool`` and ``RIPEMD160`` have been deprecated.\n\n\n.. _v1-8-2:\n\n1.8.2 - 2017-05-26\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a compilation bug affecting OpenSSL 1.1.0f.\n* Updated Windows and macOS wheels to be compiled against OpenSSL 1.1.0f.\n\n\n.. _v1-8-1:\n\n1.8.1 - 2017-03-10\n~~~~~~~~~~~~~~~~~~\n\n* Fixed macOS wheels to properly link against 1.1.0 rather than 1.0.2.\n\n\n.. _v1-8:\n\n1.8 - 2017-03-09\n~~~~~~~~~~~~~~~~\n\n* Added support for Python 3.6.\n* Windows and macOS wheels now link against OpenSSL 1.1.0.\n* macOS wheels are no longer universal. This change significantly shrinks the\n  size of the wheels. Users on macOS 32-bit Python (if there are any) should\n  migrate to 64-bit or build their own packages.\n* Changed ASN.1 dependency from ``pyasn1`` to ``asn1crypto`` resulting in a\n  general performance increase when encoding/decoding ASN.1 structures. Also,\n  the ``pyasn1_modules`` test dependency is no longer required.\n* Added support for\n  :meth:`~cryptography.hazmat.primitives.ciphers.CipherContext.update_into` on\n  :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey.public_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey`.\n* :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`\n  now require that ``password`` must be bytes if provided. Previously this\n  was documented but not enforced.\n* Added support for subgroup order in :doc:`/hazmat/primitives/asymmetric/dh`.\n\n\n.. _v1-7-2:\n\n1.7.2 - 2017-01-27\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and macOS wheels to be compiled against OpenSSL 1.0.2k.\n\n\n.. _v1-7-1:\n\n1.7.1 - 2016-12-13\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a regression in ``int_from_bytes`` where it failed to accept\n  ``bytearray``.\n\n\n.. _v1-7:\n\n1.7 - 2016-12-12\n~~~~~~~~~~~~~~~~\n\n* Support for OpenSSL 1.0.0 has been removed. Users on older version of OpenSSL\n  will need to upgrade.\n* Added support for Diffie-Hellman key exchange using\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey.exchange`.\n* The OS random engine for OpenSSL has been rewritten to improve compatibility\n  with embedded Python and other edge cases. More information about this change\n  can be found in the\n  `pull request <https://github.com/pyca/cryptography/pull/3229>`_.\n\n\n.. _v1-6:\n\n1.6 - 2016-11-22\n~~~~~~~~~~~~~~~~\n\n* Deprecated support for OpenSSL 1.0.0. Support will be removed in\n  ``cryptography`` 1.7.\n* Replaced the Python-based OpenSSL locking callbacks with a C version to fix\n  a potential deadlock that could occur if a garbage collection cycle occurred\n  while inside the lock.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.BLAKE2b` and\n  :class:`~cryptography.hazmat.primitives.hashes.BLAKE2s` when using OpenSSL\n  1.1.0.\n* Added\n  :attr:`~cryptography.x509.Certificate.signature_algorithm_oid` support to\n  :class:`~cryptography.x509.Certificate`.\n* Added\n  :attr:`~cryptography.x509.CertificateSigningRequest.signature_algorithm_oid`\n  support to :class:`~cryptography.x509.CertificateSigningRequest`.\n* Added\n  :attr:`~cryptography.x509.CertificateRevocationList.signature_algorithm_oid`\n  support to :class:`~cryptography.x509.CertificateRevocationList`.\n* Added support for :class:`~cryptography.hazmat.primitives.kdf.scrypt.Scrypt`\n  when using OpenSSL 1.1.0.\n* Added a workaround to improve compatibility with Python application bundling\n  tools like ``PyInstaller`` and ``cx_freeze``.\n* Added support for generating a\n  :meth:`~cryptography.x509.random_serial_number`.\n* Added support for encoding ``IPv4Network`` and ``IPv6Network`` in X.509\n  certificates for use with :class:`~cryptography.x509.NameConstraints`.\n* Added :meth:`~cryptography.x509.Name.public_bytes` to\n  :class:`~cryptography.x509.Name`.\n* Added :class:`~cryptography.x509.RelativeDistinguishedName`\n* :class:`~cryptography.x509.DistributionPoint` now accepts\n  :class:`~cryptography.x509.RelativeDistinguishedName` for\n  :attr:`~cryptography.x509.DistributionPoint.relative_name`.\n  Deprecated use of :class:`~cryptography.x509.Name` as\n  :attr:`~cryptography.x509.DistributionPoint.relative_name`.\n* :class:`~cryptography.x509.Name` now accepts an iterable of\n  :class:`~cryptography.x509.RelativeDistinguishedName`.  RDNs can\n  be accessed via the :attr:`~cryptography.x509.Name.rdns`\n  attribute.  When constructed with an iterable of\n  :class:`~cryptography.x509.NameAttribute`, each attribute becomes\n  a single-valued RDN.\n* Added\n  :func:`~cryptography.hazmat.primitives.asymmetric.ec.derive_private_key`.\n* Added support for signing and verifying RSA, DSA, and ECDSA signatures with\n  :class:`~cryptography.hazmat.primitives.asymmetric.utils.Prehashed`\n  digests.\n\n\n.. _v1-5-3:\n\n1.5.3 - 2016-11-05\n~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE**: Fixed a bug where ``HKDF`` would return an empty\n  byte-string if used with a ``length`` less than ``algorithm.digest_size``.\n  Credit to **Markus D\u00f6ring** for reporting the issue. *CVE-2016-9243*\n\n\n.. _v1-5-2:\n\n1.5.2 - 2016-09-26\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2j.\n\n\n.. _v1-5-1:\n\n1.5.1 - 2016-09-22\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2i.\n* Resolved a ``UserWarning`` when used with cffi 1.8.3.\n* Fixed a memory leak in name creation with X.509.\n* Added a workaround for old versions of setuptools.\n* Fixed an issue preventing ``cryptography`` from compiling against\n  OpenSSL 1.0.2i.\n\n\n\n.. _v1-5:\n\n1.5 - 2016-08-26\n~~~~~~~~~~~~~~~~\n\n* Added\n  :func:`~cryptography.hazmat.primitives.asymmetric.padding.calculate_max_pss_salt_length`.\n* Added \"one shot\"\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey.sign`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey.verify`\n  methods to DSA keys.\n* Added \"one shot\"\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey.sign`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.verify`\n  methods to ECDSA keys.\n* Switched back to the older callback model on Python 3.5 in order to mitigate\n  the locking callback problem with OpenSSL <1.1.0.\n* :class:`~cryptography.x509.CertificateBuilder`,\n  :class:`~cryptography.x509.CertificateRevocationListBuilder`, and\n  :class:`~cryptography.x509.RevokedCertificateBuilder` now accept timezone\n  aware ``datetime`` objects as method arguments\n* ``cryptography`` now supports OpenSSL 1.1.0 as a compilation target.\n\n\n\n.. _v1-4:\n\n1.4 - 2016-06-04\n~~~~~~~~~~~~~~~~\n\n* Support for OpenSSL 0.9.8 has been removed. Users on older versions of\n  OpenSSL will need to upgrade.\n* Added :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFHMAC`.\n* Added support for ``OpenSSH`` public key serialization.\n* Added support for SHA-2 in RSA\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.OAEP` when using\n  OpenSSL 1.0.2 or greater.\n* Added \"one shot\"\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey.sign`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey.verify`\n  methods to RSA keys.\n* Deprecated the ``serial`` attribute on\n  :class:`~cryptography.x509.Certificate`, in favor of\n  :attr:`~cryptography.x509.Certificate.serial_number`.\n\n\n\n.. _v1-3-4:\n\n1.3.4 - 2016-06-03\n~~~~~~~~~~~~~~~~~~\n\n* Added another OpenSSL function to the bindings to support an upcoming\n  ``pyOpenSSL`` release.\n\n\n\n.. _v1-3-3:\n\n1.3.3 - 2016-06-02\n~~~~~~~~~~~~~~~~~~\n\n* Added two new OpenSSL functions to the bindings to support an upcoming\n  ``pyOpenSSL`` release.\n\n\n.. _v1-3-2:\n\n1.3.2 - 2016-05-04\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2h.\n* Fixed an issue preventing ``cryptography`` from compiling against\n  LibreSSL 2.3.x.\n\n\n.. _v1-3-1:\n\n1.3.1 - 2016-03-21\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a bug that caused an ``AttributeError`` when using ``mock`` to patch\n  some ``cryptography`` modules.\n\n\n.. _v1-3:\n\n1.3 - 2016-03-18\n~~~~~~~~~~~~~~~~\n\n* Added support for padding ANSI X.923 with\n  :class:`~cryptography.hazmat.primitives.padding.ANSIX923`.\n* Deprecated support for OpenSSL 0.9.8. Support will be removed in\n  ``cryptography`` 1.4.\n* Added support for the :class:`~cryptography.x509.PolicyConstraints`\n  X.509 extension including both parsing and generation using\n  :class:`~cryptography.x509.CertificateBuilder` and\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`.\n* Added :attr:`~cryptography.x509.CertificateSigningRequest.is_signature_valid`\n  to :class:`~cryptography.x509.CertificateSigningRequest`.\n* Fixed an intermittent ``AssertionError`` when performing an RSA decryption on\n  an invalid ciphertext, ``ValueError`` is now correctly raised in all cases.\n* Added\n  :meth:`~cryptography.x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier`.\n\n\n.. _v1-2-3:\n\n1.2.3 - 2016-03-01\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2g.\n\n\n.. _v1-2-2:\n\n1.2.2 - 2016-01-29\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2f.\n\n\n.. _v1-2-1:\n\n1.2.1 - 2016-01-08\n~~~~~~~~~~~~~~~~~~\n\n* Reverts a change to an OpenSSL ``EVP_PKEY`` object that caused errors with\n  ``pyOpenSSL``.\n\n\n.. _v1-2:\n\n1.2 - 2016-01-08\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:**\n  :class:`~cryptography.x509.RevokedCertificate`\n  :attr:`~cryptography.x509.RevokedCertificate.extensions` now uses extension\n  classes rather than returning raw values inside the\n  :class:`~cryptography.x509.Extension`\n  :attr:`~cryptography.x509.Extension.value`. The new classes\n  are:\n\n  * :class:`~cryptography.x509.CertificateIssuer`\n  * :class:`~cryptography.x509.CRLReason`\n  * :class:`~cryptography.x509.InvalidityDate`\n* Deprecated support for OpenSSL 0.9.8 and 1.0.0. At this time there is no time\n  table for actually dropping support, however we strongly encourage all users\n  to upgrade, as those versions no longer receive support from the OpenSSL\n  project.\n* The :class:`~cryptography.x509.Certificate` class now has\n  :attr:`~cryptography.x509.Certificate.signature` and\n  :attr:`~cryptography.x509.Certificate.tbs_certificate_bytes` attributes.\n* The :class:`~cryptography.x509.CertificateSigningRequest` class now has\n  :attr:`~cryptography.x509.CertificateSigningRequest.signature` and\n  :attr:`~cryptography.x509.CertificateSigningRequest.tbs_certrequest_bytes`\n  attributes.\n* The :class:`~cryptography.x509.CertificateRevocationList` class now has\n  :attr:`~cryptography.x509.CertificateRevocationList.signature` and\n  :attr:`~cryptography.x509.CertificateRevocationList.tbs_certlist_bytes`\n  attributes.\n* :class:`~cryptography.x509.NameConstraints` are now supported in the\n  :class:`~cryptography.x509.CertificateBuilder` and\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`.\n* Support serialization of certificate revocation lists using the\n  :meth:`~cryptography.x509.CertificateRevocationList.public_bytes` method of\n  :class:`~cryptography.x509.CertificateRevocationList`.\n* Add support for parsing :class:`~cryptography.x509.CertificateRevocationList`\n  :meth:`~cryptography.x509.CertificateRevocationList.extensions` in the\n  OpenSSL backend. The following extensions are currently supported:\n\n  * :class:`~cryptography.x509.AuthorityInformationAccess`\n  * :class:`~cryptography.x509.AuthorityKeyIdentifier`\n  * :class:`~cryptography.x509.CRLNumber`\n  * :class:`~cryptography.x509.IssuerAlternativeName`\n* Added :class:`~cryptography.x509.CertificateRevocationListBuilder` and\n  :class:`~cryptography.x509.RevokedCertificateBuilder` to allow creation of\n  CRLs.\n* Unrecognized non-critical X.509 extensions are now parsed into an\n  :class:`~cryptography.x509.UnrecognizedExtension` object.\n\n\n.. _v1-1-2:\n\n1.1.2 - 2015-12-10\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a SIGBUS crash with the OS X wheels caused by redefinition of a\n  method.\n* Fixed a runtime error ``undefined symbol EC_GFp_nistp224_method`` that\n  occurred with some OpenSSL installations.\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2e.\n\n\n.. _v1-1-1:\n\n1.1.1 - 2015-11-19\n~~~~~~~~~~~~~~~~~~\n\n* Fixed several small bugs related to compiling the OpenSSL bindings with\n  unusual OpenSSL configurations.\n* Resolved an issue where, depending on the method of installation and\n  which Python interpreter they were using, users on El Capitan (OS X 10.11)\n  may have seen an ``InternalError`` on import.\n\n\n.. _v1-1:\n\n1.1 - 2015-10-28\n~~~~~~~~~~~~~~~~\n\n* Added support for Elliptic Curve Diffie-Hellman with\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.ECDH`.\n* Added :class:`~cryptography.hazmat.primitives.kdf.x963kdf.X963KDF`.\n* Added support for parsing certificate revocation lists (CRLs) using\n  :func:`~cryptography.x509.load_pem_x509_crl` and\n  :func:`~cryptography.x509.load_der_x509_crl`.\n* Add support for AES key wrapping with\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_wrap` and\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap`.\n* Added a ``__hash__`` method to :class:`~cryptography.x509.Name`.\n* Add support for encoding and decoding elliptic curve points to a byte string\n  form using\n  ``cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.encode_point``\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.from_encoded_point`.\n* Added :meth:`~cryptography.x509.Extensions.get_extension_for_class`.\n* :class:`~cryptography.x509.CertificatePolicies` are now supported in the\n  :class:`~cryptography.x509.CertificateBuilder`.\n* ``countryName`` is now encoded as a ``PrintableString`` when creating subject\n  and issuer distinguished names with the Certificate and CSR builder classes.\n\n\n.. _v1-0-2:\n\n1.0.2 - 2015-09-27\n~~~~~~~~~~~~~~~~~~\n* **SECURITY ISSUE**: The OpenSSL backend prior to 1.0.2 made extensive use\n  of assertions to check response codes where our tests could not trigger a\n  failure.  However, when Python is run with ``-O`` these asserts are optimized\n  away.  If a user ran Python with this flag and got an invalid response code\n  this could result in undefined behavior or worse. Accordingly, all response\n  checks from the OpenSSL backend have been converted from ``assert``\n  to a true function call. Credit **Emilia K\u00e4sper (Google Security Team)**\n  for the report.\n\n\n.. _v1-0-1:\n\n1.0.1 - 2015-09-05\n~~~~~~~~~~~~~~~~~~\n\n* We now ship OS X wheels that statically link OpenSSL by default. When\n  installing a wheel on OS X 10.10+ (and using a Python compiled against the\n  10.10 SDK) users will no longer need to compile. See :doc:`/installation` for\n  alternate installation methods if required.\n* Set the default string mask to UTF-8 in the OpenSSL backend to resolve\n  character encoding issues with older versions of OpenSSL.\n* Several new OpenSSL bindings have been added to support a future pyOpenSSL\n  release.\n* Raise an error during install on PyPy < 2.6. 1.0+ requires PyPy 2.6+.\n\n\n.. _v1-0:\n\n1.0 - 2015-08-12\n~~~~~~~~~~~~~~~~\n\n* Switched to the new `cffi`_ ``set_source`` out-of-line API mode for\n  compilation. This results in significantly faster imports and lowered\n  memory consumption. Due to this change we no longer support PyPy releases\n  older than 2.6 nor do we support any released version of PyPy3 (until a\n  version supporting cffi 1.0 comes out).\n* Fix parsing of OpenSSH public keys that have spaces in comments.\n* Support serialization of certificate signing requests using the\n  ``public_bytes`` method of\n  :class:`~cryptography.x509.CertificateSigningRequest`.\n* Support serialization of certificates using the ``public_bytes`` method of\n  :class:`~cryptography.x509.Certificate`.\n* Add ``get_provisioning_uri`` method to\n  :class:`~cryptography.hazmat.primitives.twofactor.hotp.HOTP` and\n  :class:`~cryptography.hazmat.primitives.twofactor.totp.TOTP` for generating\n  provisioning URIs.\n* Add :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHash`\n  and :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHMAC`.\n* Raise a ``TypeError`` when passing objects that are not text as the value to\n  :class:`~cryptography.x509.NameAttribute`.\n* Add support for :class:`~cryptography.x509.OtherName` as a general name\n  type.\n* Added new X.509 extension support in :class:`~cryptography.x509.Certificate`\n  The following new extensions are now supported:\n\n  * :class:`~cryptography.x509.OCSPNoCheck`\n  * :class:`~cryptography.x509.InhibitAnyPolicy`\n  * :class:`~cryptography.x509.IssuerAlternativeName`\n  * :class:`~cryptography.x509.NameConstraints`\n\n* Extension support was added to\n  :class:`~cryptography.x509.CertificateSigningRequest`.\n* Add support for creating signed certificates with\n  :class:`~cryptography.x509.CertificateBuilder`. This includes support for\n  the following extensions:\n\n  * :class:`~cryptography.x509.BasicConstraints`\n  * :class:`~cryptography.x509.SubjectAlternativeName`\n  * :class:`~cryptography.x509.KeyUsage`\n  * :class:`~cryptography.x509.ExtendedKeyUsage`\n  * :class:`~cryptography.x509.SubjectKeyIdentifier`\n  * :class:`~cryptography.x509.AuthorityKeyIdentifier`\n  * :class:`~cryptography.x509.AuthorityInformationAccess`\n  * :class:`~cryptography.x509.CRLDistributionPoints`\n  * :class:`~cryptography.x509.InhibitAnyPolicy`\n  * :class:`~cryptography.x509.IssuerAlternativeName`\n  * :class:`~cryptography.x509.OCSPNoCheck`\n\n* Add support for creating certificate signing requests with\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`. This includes\n  support for the same extensions supported in the ``CertificateBuilder``.\n* Deprecate ``encode_rfc6979_signature`` and ``decode_rfc6979_signature`` in\n  favor of\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.encode_dss_signature`\n  and\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`.\n\n\n\n.. _v0-9-3:\n\n0.9.3 - 2015-07-09\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2d.\n\n\n.. _v0-9-2:\n\n0.9.2 - 2015-07-04\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2c.\n\n\n.. _v0-9-1:\n\n0.9.1 - 2015-06-06\n~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE**: Fixed a double free in the OpenSSL backend when using DSA\n  to verify signatures. Note that this only affects PyPy 2.6.0 and (presently\n  unreleased) CFFI versions greater than 1.1.0.\n\n\n.. _v0-9:\n\n0.9 - 2015-05-13\n~~~~~~~~~~~~~~~~\n\n* Removed support for Python 3.2. This version of Python is rarely used\n  and caused support headaches. Users affected by this should upgrade to 3.3+.\n* Deprecated support for Python 2.6. At the time there is no time table for\n  actually dropping support, however we strongly encourage all users to upgrade\n  their Python, as Python 2.6 no longer receives support from the Python core\n  team.\n* Add support for the\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.SECP256K1` elliptic\n  curve.\n* Fixed compilation when using an OpenSSL which was compiled with the\n  ``no-comp`` (``OPENSSL_NO_COMP``) option.\n* Support :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`\n  serialization of public keys using the ``public_bytes`` method of\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`.\n* Support :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`\n  serialization of private keys using the ``private_bytes`` method of\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`.\n* Add support for parsing X.509 certificate signing requests (CSRs) with\n  :func:`~cryptography.x509.load_pem_x509_csr` and\n  :func:`~cryptography.x509.load_der_x509_csr`.\n* Moved ``cryptography.exceptions.InvalidToken`` to\n  :class:`cryptography.hazmat.primitives.twofactor.InvalidToken` and deprecated\n  the old location. This was moved to minimize confusion between this exception\n  and :class:`cryptography.fernet.InvalidToken`.\n* Added support for X.509 extensions in :class:`~cryptography.x509.Certificate`\n  objects. The following extensions are supported as of this release:\n\n  * :class:`~cryptography.x509.BasicConstraints`\n  * :class:`~cryptography.x509.AuthorityKeyIdentifier`\n  * :class:`~cryptography.x509.SubjectKeyIdentifier`\n  * :class:`~cryptography.x509.KeyUsage`\n  * :class:`~cryptography.x509.SubjectAlternativeName`\n  * :class:`~cryptography.x509.ExtendedKeyUsage`\n  * :class:`~cryptography.x509.CRLDistributionPoints`\n  * :class:`~cryptography.x509.AuthorityInformationAccess`\n  * :class:`~cryptography.x509.CertificatePolicies`\n\n  Note that unsupported extensions with the critical flag raise\n  ``UnsupportedExtension`` while unsupported extensions set to non-critical are\n  silently ignored. Read the :doc:`X.509 documentation</x509/index>` for more\n  information.\n\n\n.. _v0-8-2:\n\n0.8.2 - 2015-04-10\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a race condition when initializing the OpenSSL or CommonCrypto backends\n  in a multi-threaded scenario.\n\n\n.. _v0-8-1:\n\n0.8.1 - 2015-03-20\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2a.\n\n\n.. _v0-8:\n\n0.8 - 2015-03-08\n~~~~~~~~~~~~~~~~\n\n* :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` can\n  now load elliptic curve public keys.\n* Added\n  :attr:`~cryptography.x509.Certificate.signature_hash_algorithm` support to\n  :class:`~cryptography.x509.Certificate`.\n* Added\n  :func:`~cryptography.hazmat.primitives.asymmetric.rsa.rsa_recover_prime_factors`\n* :class:`~cryptography.hazmat.primitives.kdf.KeyDerivationFunction` was moved\n  from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.kdf`.\n* Added support for parsing X.509 names. See the\n  :doc:`X.509 documentation</x509/index>` for more information.\n* Added\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key` to\n  support loading of DER encoded private keys and\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_public_key` to\n  support loading DER encoded public keys.\n* Fixed building against LibreSSL, a compile-time substitute for OpenSSL.\n* FreeBSD 9.2 was removed from the continuous integration system.\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2.\n* :func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key`\n  and :func:`~cryptography.hazmat.primitives.serialization.load_der_public_key`\n  now support PKCS1 RSA public keys (in addition to the previous support for\n  SubjectPublicKeyInfo format for RSA, EC, and DSA).\n* Added ``EllipticCurvePrivateKeyWithSerialization`` and deprecated\n  ``EllipticCurvePrivateKeyWithNumbers``.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`.\n* Added ``RSAPrivateKeyWithSerialization`` and deprecated ``RSAPrivateKeyWithNumbers``.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`.\n* Added ``DSAPrivateKeyWithSerialization`` and deprecated ``DSAPrivateKeyWithNumbers``.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`.\n* Added ``RSAPublicKeyWithSerialization`` and deprecated ``RSAPublicKeyWithNumbers``.\n* Added ``public_bytes`` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.\n* Added ``EllipticCurvePublicKeyWithSerialization`` and deprecated\n  ``EllipticCurvePublicKeyWithNumbers``.\n* Added ``public_bytes`` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`.\n* Added ``DSAPublicKeyWithSerialization`` and deprecated ``DSAPublicKeyWithNumbers``.\n* Added ``public_bytes`` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`.\n* :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` and\n  :class:`~cryptography.hazmat.primitives.hashes.HashContext` were moved from\n  ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.hashes`.\n* :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`,\n  :class:`~cryptography.hazmat.primitives.ciphers.AEADCipherContext`,\n  :class:`~cryptography.hazmat.primitives.ciphers.AEADEncryptionContext`,\n  :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`, and\n  :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.ciphers`.\n* :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode`,\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithInitializationVector`,\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithNonce`, and\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithAuthenticationTag`\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.ciphers.modes`.\n* :class:`~cryptography.hazmat.primitives.padding.PaddingContext` was moved\n  from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.padding`.\n*\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`\n  was moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.padding`.\n* ``AsymmetricSignatureContext`` and ``AsymmetricVerificationContext``\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  ``cryptography.hazmat.primitives.asymmetric``.\n* :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`,\n  ``DSAParametersWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,\n  ``DSAPrivateKeyWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` and\n  ``DSAPublicKeyWithNumbers`` were moved from\n  ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.dsa`\n* :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurveSignatureAlgorithm`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`,\n  ``EllipticCurvePrivateKeyWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`,\n  and ``EllipticCurvePublicKeyWithNumbers``\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.ec`.\n* :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,\n  ``RSAPrivateKeyWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey` and\n  ``RSAPublicKeyWithNumbers`` were moved from\n  ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.rsa`.\n\n\n.. _v0-7-2:\n\n0.7.2 - 2015-01-16\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.1l.\n* ``enum34`` is no longer installed on Python 3.4, where it is included in\n  the standard library.\n* Added a new function to the OpenSSL bindings to support additional\n  functionality in pyOpenSSL.\n\n\n.. _v0-7-1:\n\n0.7.1 - 2014-12-28\n~~~~~~~~~~~~~~~~~~\n\n* Fixed an issue preventing compilation on platforms where ``OPENSSL_NO_SSL3``\n  was defined.\n\n\n.. _v0-7:\n\n0.7 - 2014-12-17\n~~~~~~~~~~~~~~~~\n\n* Cryptography has been relicensed from the Apache Software License, Version\n  2.0, to being available under *either* the Apache Software License, Version\n  2.0, or the BSD license.\n* Added key-rotation support to :doc:`Fernet </fernet>` with\n  :class:`~cryptography.fernet.MultiFernet`.\n* More bit-lengths are now supported for ``p`` and ``q`` when loading DSA keys\n  from numbers.\n* Added ``MACContext`` as a common interface for CMAC and HMAC and\n  deprecated ``CMACContext``.\n* Added support for encoding and decoding :rfc:`6979` signatures in\n  :doc:`/hazmat/primitives/asymmetric/utils`.\n* Added\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` to\n  support the loading of OpenSSH public keys (:rfc:`4253`). Only RSA and DSA\n  keys are currently supported.\n* Added initial support for X.509 certificate parsing. See the\n  :doc:`X.509 documentation</x509/index>` for more information.\n\n\n.. _v0-6-1:\n\n0.6.1 - 2014-10-15\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.1j.\n* Fixed an issue where OpenSSL 1.0.1j changed the errors returned by some\n  functions.\n* Added our license file to the ``cryptography-vectors`` package.\n* Implemented DSA hash truncation support (per FIPS 186-3) in the OpenSSL\n  backend. This works around an issue in 1.0.0, 1.0.0a, and 1.0.0b where\n  truncation was not implemented.\n\n\n.. _v0-6:\n\n0.6 - 2014-09-29\n~~~~~~~~~~~~~~~~\n\n* Added\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key` to\n  ease loading private keys, and\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key` to\n  support loading public keys.\n* Removed the, deprecated in 0.4, support for the ``salt_length`` argument to\n  the :class:`~cryptography.hazmat.primitives.asymmetric.padding.MGF1`\n  constructor. The ``salt_length`` should be passed to\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS` instead.\n* Fix compilation on OS X Yosemite.\n* Deprecated ``elliptic_curve_private_key_from_numbers`` and\n  ``elliptic_curve_public_key_from_numbers`` in favor of\n  ``load_elliptic_curve_private_numbers`` and\n  ``load_elliptic_curve_public_numbers`` on ``EllipticCurveBackend``.\n* Added ``EllipticCurvePrivateKeyWithNumbers`` and\n  ``EllipticCurvePublicKeyWithNumbers`` support.\n* Work around three GCM related bugs in CommonCrypto and OpenSSL.\n\n  * On the CommonCrypto backend adding AAD but not subsequently calling update\n    would return null tag bytes.\n\n  * One the CommonCrypto backend a call to update without an empty add AAD call\n    would return null ciphertext bytes.\n\n  * On the OpenSSL backend with certain versions adding AAD only would give\n    invalid tag bytes.\n\n* Support loading EC private keys from PEM.\n\n\n.. _v0-5-4:\n\n0.5.4 - 2014-08-20\n~~~~~~~~~~~~~~~~~~\n\n* Added several functions to the OpenSSL bindings to support new\n  functionality in pyOpenSSL.\n* Fixed a redefined constant causing compilation failure with Solaris 11.2.\n\n\n.. _v0-5-3:\n\n0.5.3 - 2014-08-06\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.1i.\n\n\n.. _v0-5-2:\n\n0.5.2 - 2014-07-09\n~~~~~~~~~~~~~~~~~~\n\n* Add ``TraditionalOpenSSLSerializationBackend`` support to ``multibackend``.\n* Fix compilation error on OS X 10.8 (Mountain Lion).\n\n\n.. _v0-5-1:\n\n0.5.1 - 2014-07-07\n~~~~~~~~~~~~~~~~~~\n\n* Add ``PKCS8SerializationBackend`` support to ``multibackend``.\n\n\n.. _v0-5:\n\n0.5 - 2014-07-07\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:**\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` no longer allows\n  truncation of tags by default. Previous versions of ``cryptography`` allowed\n  tags to be truncated by default, applications wishing to preserve this\n  behavior (not recommended) can pass the ``min_tag_length`` argument.\n* Windows builds now statically link OpenSSL by default. When installing a\n  wheel on Windows you no longer need to install OpenSSL separately. Windows\n  users can switch between static and dynamic linking with an environment\n  variable. See :doc:`/installation` for more details.\n* Added :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDFExpand`.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.modes.CFB8` support\n  for :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` on\n  ``commoncrypto`` and ``openssl``.\n* Added ``AES`` :class:`~cryptography.hazmat.primitives.ciphers.modes.CTR`\n  support to the OpenSSL backend when linked against 0.9.8.\n* Added ``PKCS8SerializationBackend`` and\n  ``TraditionalOpenSSLSerializationBackend`` support to ``openssl``.\n* Added :doc:`/hazmat/primitives/asymmetric/ec` and ``EllipticCurveBackend``.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.modes.ECB` support\n  for :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` on\n  ``commoncrypto`` and ``openssl``.\n* Deprecated the concrete ``RSAPrivateKey`` class in favor of backend\n  specific providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`\n  interface.\n* Deprecated the concrete ``RSAPublicKey`` in favor of backend specific\n  providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`\n  interface.\n* Deprecated the concrete ``DSAPrivateKey`` class in favor of backend\n  specific providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`\n  interface.\n* Deprecated the concrete ``DSAPublicKey`` class in favor of backend specific\n  providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`\n  interface.\n* Deprecated the concrete ``DSAParameters`` class in favor of backend specific\n  providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`\n  interface.\n* Deprecated ``encrypt_rsa``, ``decrypt_rsa``, ``create_rsa_signature_ctx`` and\n  ``create_rsa_verification_ctx`` on ``RSABackend``.\n* Deprecated ``create_dsa_signature_ctx`` and ``create_dsa_verification_ctx``\n  on ``DSABackend``.\n\n\n.. _v0-4:\n\n0.4 - 2014-05-03\n~~~~~~~~~~~~~~~~\n\n* Deprecated ``salt_length`` on\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.MGF1` and added it\n  to :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. It will\n  be removed from ``MGF1`` in two releases per our :doc:`/api-stability`\n  policy.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SEED`\n  support.\n* Added :class:`~cryptography.hazmat.primitives.cmac.CMAC`.\n* Added decryption support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`\n  and encryption support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.\n* Added signature support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`\n  and verification support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`.\n\n\n.. _v0-3:\n\n0.3 - 2014-03-27\n~~~~~~~~~~~~~~~~\n\n* Added :class:`~cryptography.hazmat.primitives.twofactor.hotp.HOTP`.\n* Added :class:`~cryptography.hazmat.primitives.twofactor.totp.TOTP`.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.IDEA`\n  support.\n* Added signature support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`\n  and verification support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.\n* Moved test vectors to the new ``cryptography_vectors`` package.\n\n\n.. _v0-2-2:\n\n0.2.2 - 2014-03-03\n~~~~~~~~~~~~~~~~~~\n\n* Removed a constant definition that was causing compilation problems with\n  specific versions of OpenSSL.\n\n\n.. _v0-2-1:\n\n0.2.1 - 2014-02-22\n~~~~~~~~~~~~~~~~~~\n\n* Fix a bug where importing cryptography from multiple paths could cause\n  initialization to fail.\n\n\n.. _v0-2:\n\n0.2 - 2014-02-20\n~~~~~~~~~~~~~~~~\n\n* Added ``commoncrypto``.\n* Added initial ``commoncrypto``.\n* Removed ``register_cipher_adapter`` method from ``CipherBackend``.\n* Added support for the OpenSSL backend under Windows.\n* Improved thread-safety for the OpenSSL backend.\n* Fixed compilation on systems where OpenSSL's ``ec.h`` header is not\n  available, such as CentOS.\n* Added :class:`~cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC`.\n* Added :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDF`.\n* Added ``multibackend``.\n* Set default random for ``openssl`` to the OS random engine.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.CAST5`\n  (CAST-128) support.\n\n\n.. _v0-1:\n\n0.1 - 2014-01-08\n~~~~~~~~~~~~~~~~\n\n* Initial release.\n\n.. _`as documented here`: https://docs.rs/openssl/latest/openssl/#automatic\n.. _`main`: https://github.com/pyca/cryptography/\n.. _`cffi`: https://cffi.readthedocs.io/\n", "AArch\naccessor\naffine\nAuthenticator\nauthenticator\nbackend\nBackends\nbackends\nbcrypt\nBleichenbacher\nBlowfish\nboolean\nBoringSSL\nBotan\nBrainpool\nBullseye\nCapitan\nCentOS\nchangelog\nChangelog\nciphertext\ncodebook\ncommitter\ncommitters\nconda\nCPython\nCryptanalysis\ncrypto\ncryptographic\ncryptographically\nde\nDebian\ndeallocated\ndecrypt\ndecrypts\nDecrypts\ndecrypted\ndecrypting\ndeprecations\nDER\ndeserialize\ndeserialized\nDeserialization\ndeserializing\nDiffie\nDiffie\ndisambiguating\nDjango\nDocstrings\nEl\nEncodings\nendian\nextendable\nfacto\nfallback\nFernet\nfernet\nFIPS\nGoogle\nhazmat\nHomebrew\nhostname\nhostnames\nimplementor\nincrementing\nindistinguishability\ninitialisms\ninteroperability\ninteroperable\nintrospectability\ninvariants\niOS\niterable\nKerberos\nKeychain\nKoblitz\nLange\nlogins\nmetadata\nMGF\nMonterey\nMozilla\nmulti\nnamespace\nnamespaces\nmacOS\nna\u00efve\nNonces\nnonces\nonline\npaddings\nParallelization\npersonalization\nRHEL\nparsers\nParsers\nPEM\npickleable\nplaintext\nPoly\npre\nprecompute\nprecomputed\npreprocessor\npreprocessors\npresentational\npseudorandom\npyOpenSSL\npytest\nrelicensed\nresponder\nruntime\nSchneier\nscrypt\nserializer\nSerializers\nSHA\nSolaris\nSur\nsyscall\nTanja\ntestability\nThawte\ntimestamp\ntimestamps\ntoolchain\ntunable\nUbuntu\nunencrypted\nunicode\nunpadded\nunpadding\nVentura\nverifier\nVerifier\nVerisign\nversioning\nwildcard\nWoSign\nWycheproof\nXcode\nXEX\n", "[build-system]\nrequires = [\n    # First version of setuptools to support pyproject.toml configuration\n    \"setuptools>=61.0.0\",\n    \"wheel\",\n    # Must be kept in sync with `project.dependencies`\n    \"cffi>=1.12; platform_python_implementation != 'PyPy'\",\n    \"setuptools-rust>=0.11.4\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cryptography\"\nversion = \"41.0.5\"\nauthors = [\n    {name = \"The Python Cryptographic Authority and individual contributors\", email = \"cryptography-dev@python.org\"}\n]\ndescription = \"cryptography is a package which provides cryptographic recipes and primitives to Python developers.\"\nreadme = \"README.rst\"\nlicense = {text = \"Apache-2.0 OR BSD-3-Clause\"}\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Natural Language :: English\",\n    \"Operating System :: MacOS :: MacOS X\",\n    \"Operating System :: POSIX\",\n    \"Operating System :: POSIX :: BSD\",\n    \"Operating System :: POSIX :: Linux\",\n    'Operating System :: Microsoft :: Windows',\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3 :: Only\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n    \"Topic :: Security :: Cryptography\",\n]\nrequires-python = \">=3.7\"\ndependencies = [\n    # Must be kept in sync with `build-system.requires`\n    \"cffi >=1.12\",\n]\n\n[project.urls]\nhomepage = \"https://github.com/pyca/cryptography\"\ndocumentation = \"https://cryptography.io/\"\nsource = \"https://github.com/pyca/cryptography/\"\nissues = \"https://github.com/pyca/cryptography/issues\"\nchangelog = \"https://cryptography.io/en/latest/changelog/\"\n\n[tool.setuptools]\nzip-safe = false\npackage-dir = {\"\" = \"src\"}\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\ninclude = [\"cryptography*\"]\n\n[project.optional-dependencies]\nssh = [\"bcrypt >=3.1.5\"]\n\n# All the following are used for our own testing.\nnox = [\"nox\"]\ntest = [\n    \"pytest >=6.2.0\",\n    \"pytest-benchmark\",\n    \"pytest-cov\",\n    \"pytest-xdist\",\n    \"pretend\",\n]\ntest-randomorder = [\"pytest-randomly\"]\ndocs = [\"sphinx >=5.3.0\", \"sphinx-rtd-theme >=1.1.1\"]\ndocstest =  [\"pyenchant >=1.6.11\", \"twine >=1.12.0\", \"sphinxcontrib-spelling >=4.0.1\"]\nsdist = [\"build\"]\npep8test = [\"black\", \"ruff\", \"mypy\", \"check-sdist\"]\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py37\"]\n\n[tool.pytest.ini_options]\naddopts = \"-r s --capture=no --strict-markers --benchmark-disable\"\nconsole_output_style = \"progress-even-when-capture-no\"\nmarkers = [\n    \"skip_fips: this test is not executed in FIPS mode\",\n    \"supported: parametrized test requiring only_if and skip_message\",\n]\n\n[tool.mypy]\nshow_error_codes = true\ncheck_untyped_defs = true\nno_implicit_reexport = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_unused_configs = true\nstrict_equality = true\n\n[[tool.mypy.overrides]]\nmodule = [\n    \"pretend\"\n]\nignore_missing_imports = true\n\n[tool.coverage.run]\nbranch = true\nrelative_files = true\nsource = [\n    \"cryptography\",\n    \"tests/\",\n]\n\n[tool.coverage.paths]\nsource = [\n   \"src/cryptography\",\n   \"*.nox/*/lib*/python*/site-packages/cryptography\",\n   \"*.nox\\\\*\\\\Lib\\\\site-packages\\\\cryptography\",\n   \"*.nox/pypy/site-packages/cryptography\",\n]\ntests =[\n   \"tests/\",\n   \"*tests\\\\\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"@abc.abstractmethod\",\n    \"@typing.overload\",\n    \"if typing.TYPE_CHECKING\",\n]\n\n[tool.ruff]\n# UP006: Minimum Python 3.9\n# UP007, UP038: Minimum Python 3.10\nignore = ['N818', 'UP006', 'UP007', 'UP038']\nselect = ['E', 'F', 'I', 'N', 'W', 'UP']\nline-length = 79\n\n[tool.ruff.isort]\nknown-first-party = [\"cryptography\", \"cryptography_vectors\", \"tests\"]\n\n[tool.check-sdist]\ngit-only = [\n    \"vectors/*\",\n    \"release.py\",\n    \"ci-constraints-requirements.txt\",\n    \".gitattributes\",\n    \".gitignore\",\n]", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"__version__\",\n    \"__author__\",\n    \"__copyright__\",\n]\n\n__version__ = \"41.0.5\"\n\n\n__author__ = \"The Python Cryptographic Authority and individual contributors\"\n__copyright__ = f\"Copyright 2013-2023 {__author__}\"\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport collections\nimport contextlib\nimport itertools\nimport typing\nfrom contextlib import contextmanager\n\nfrom cryptography import utils, x509\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.backends.openssl import aead\nfrom cryptography.hazmat.backends.openssl.ciphers import _CipherContext\nfrom cryptography.hazmat.backends.openssl.cmac import _CMACContext\nfrom cryptography.hazmat.backends.openssl.ec import (\n    _EllipticCurvePrivateKey,\n    _EllipticCurvePublicKey,\n)\nfrom cryptography.hazmat.backends.openssl.rsa import (\n    _RSAPrivateKey,\n    _RSAPublicKey,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.bindings.openssl import binding\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives._asymmetric import AsymmetricPadding\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dh,\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n    x448,\n    x25519,\n)\nfrom cryptography.hazmat.primitives.asymmetric.padding import (\n    MGF1,\n    OAEP,\n    PSS,\n    PKCS1v15,\n)\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    PrivateKeyTypes,\n    PublicKeyTypes,\n)\nfrom cryptography.hazmat.primitives.ciphers import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.algorithms import (\n    AES,\n    AES128,\n    AES256,\n    ARC4,\n    SM4,\n    Camellia,\n    ChaCha20,\n    TripleDES,\n    _BlowfishInternal,\n    _CAST5Internal,\n    _IDEAInternal,\n    _SEEDInternal,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import (\n    CBC,\n    CFB,\n    CFB8,\n    CTR,\n    ECB,\n    GCM,\n    OFB,\n    XTS,\n    Mode,\n)\nfrom cryptography.hazmat.primitives.serialization import ssh\nfrom cryptography.hazmat.primitives.serialization.pkcs12 import (\n    PBES,\n    PKCS12Certificate,\n    PKCS12KeyAndCertificates,\n    PKCS12PrivateKeyTypes,\n    _PKCS12CATypes,\n)\n\n_MemoryBIO = collections.namedtuple(\"_MemoryBIO\", [\"bio\", \"char_ptr\"])\n\n\n# Not actually supported, just used as a marker for some serialization tests.\nclass _RC2:\n    pass\n\n\nclass Backend:\n    \"\"\"\n    OpenSSL API binding interfaces.\n    \"\"\"\n\n    name = \"openssl\"\n\n    # FIPS has opinions about acceptable algorithms and key sizes, but the\n    # disallowed algorithms are still present in OpenSSL. They just error if\n    # you try to use them. To avoid that we allowlist the algorithms in\n    # FIPS 140-3. This isn't ideal, but FIPS 140-3 is trash so here we are.\n    _fips_aead = {\n        b\"aes-128-ccm\",\n        b\"aes-192-ccm\",\n        b\"aes-256-ccm\",\n        b\"aes-128-gcm\",\n        b\"aes-192-gcm\",\n        b\"aes-256-gcm\",\n    }\n    # TripleDES encryption is disallowed/deprecated throughout 2023 in\n    # FIPS 140-3. To keep it simple we denylist any use of TripleDES (TDEA).\n    _fips_ciphers = (AES,)\n    # Sometimes SHA1 is still permissible. That logic is contained\n    # within the various *_supported methods.\n    _fips_hashes = (\n        hashes.SHA224,\n        hashes.SHA256,\n        hashes.SHA384,\n        hashes.SHA512,\n        hashes.SHA512_224,\n        hashes.SHA512_256,\n        hashes.SHA3_224,\n        hashes.SHA3_256,\n        hashes.SHA3_384,\n        hashes.SHA3_512,\n        hashes.SHAKE128,\n        hashes.SHAKE256,\n    )\n    _fips_ecdh_curves = (\n        ec.SECP224R1,\n        ec.SECP256R1,\n        ec.SECP384R1,\n        ec.SECP521R1,\n    )\n    _fips_rsa_min_key_size = 2048\n    _fips_rsa_min_public_exponent = 65537\n    _fips_dsa_min_modulus = 1 << 2048\n    _fips_dh_min_key_size = 2048\n    _fips_dh_min_modulus = 1 << _fips_dh_min_key_size\n\n    def __init__(self) -> None:\n        self._binding = binding.Binding()\n        self._ffi = self._binding.ffi\n        self._lib = self._binding.lib\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n        self._cipher_registry: typing.Dict[\n            typing.Tuple[typing.Type[CipherAlgorithm], typing.Type[Mode]],\n            typing.Callable,\n        ] = {}\n        self._register_default_ciphers()\n        self._dh_types = [self._lib.EVP_PKEY_DH]\n        if self._lib.Cryptography_HAS_EVP_PKEY_DHX:\n            self._dh_types.append(self._lib.EVP_PKEY_DHX)\n\n    def __repr__(self) -> str:\n        return \"<OpenSSLBackend(version: {}, FIPS: {}, Legacy: {})>\".format(\n            self.openssl_version_text(),\n            self._fips_enabled,\n            self._binding._legacy_provider_loaded,\n        )\n\n    def openssl_assert(\n        self,\n        ok: bool,\n        errors: typing.Optional[typing.List[rust_openssl.OpenSSLError]] = None,\n    ) -> None:\n        return binding._openssl_assert(self._lib, ok, errors=errors)\n\n    def _enable_fips(self) -> None:\n        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that\n        # have the FIPS provider installed properly.\n        self._binding._enable_fips()\n        assert rust_openssl.is_fips_enabled()\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n    def openssl_version_text(self) -> str:\n        \"\"\"\n        Friendly string name of the loaded OpenSSL library. This is not\n        necessarily the same version as it was compiled against.\n\n        Example: OpenSSL 1.1.1d  10 Sep 2019\n        \"\"\"\n        return self._ffi.string(\n            self._lib.OpenSSL_version(self._lib.OPENSSL_VERSION)\n        ).decode(\"ascii\")\n\n    def openssl_version_number(self) -> int:\n        return self._lib.OpenSSL_version_num()\n\n    def _evp_md_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        if algorithm.name == \"blake2b\" or algorithm.name == \"blake2s\":\n            alg = \"{}{}\".format(\n                algorithm.name, algorithm.digest_size * 8\n            ).encode(\"ascii\")\n        else:\n            alg = algorithm.name.encode(\"ascii\")\n\n        evp_md = self._lib.EVP_get_digestbyname(alg)\n        return evp_md\n\n    def _evp_md_non_null_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        self.openssl_assert(evp_md != self._ffi.NULL)\n        return evp_md\n\n    def hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and not isinstance(algorithm, self._fips_hashes):\n            return False\n\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        return evp_md != self._ffi.NULL\n\n    def signature_hash_supported(\n        self, algorithm: hashes.HashAlgorithm\n    ) -> bool:\n        # Dedicated check for hashing algorithm use in message digest for\n        # signatures, e.g. RSA PKCS#1 v1.5 SHA1 (sha1WithRSAEncryption).\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n        return self.hash_supported(algorithm)\n\n    def scrypt_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        else:\n            return self._lib.Cryptography_HAS_SCRYPT == 1\n\n    def hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        # FIPS mode still allows SHA1 for HMAC\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return True\n\n        return self.hash_supported(algorithm)\n\n    def cipher_supported(self, cipher: CipherAlgorithm, mode: Mode) -> bool:\n        if self._fips_enabled:\n            # FIPS mode requires AES. TripleDES is disallowed/deprecated in\n            # FIPS 140-3.\n            if not isinstance(cipher, self._fips_ciphers):\n                return False\n\n        try:\n            adapter = self._cipher_registry[type(cipher), type(mode)]\n        except KeyError:\n            return False\n        evp_cipher = adapter(self, cipher, mode)\n        return self._ffi.NULL != evp_cipher\n\n    def register_cipher_adapter(self, cipher_cls, mode_cls, adapter) -> None:\n        if (cipher_cls, mode_cls) in self._cipher_registry:\n            raise ValueError(\n                \"Duplicate registration for: {} {}.\".format(\n                    cipher_cls, mode_cls\n                )\n            )\n        self._cipher_registry[cipher_cls, mode_cls] = adapter\n\n    def _register_default_ciphers(self) -> None:\n        for cipher_cls in [AES, AES128, AES256]:\n            for mode_cls in [CBC, CTR, ECB, OFB, CFB, CFB8, GCM]:\n                self.register_cipher_adapter(\n                    cipher_cls,\n                    mode_cls,\n                    GetCipherByName(\n                        \"{cipher.name}-{cipher.key_size}-{mode.name}\"\n                    ),\n                )\n        for mode_cls in [CBC, CTR, ECB, OFB, CFB]:\n            self.register_cipher_adapter(\n                Camellia,\n                mode_cls,\n                GetCipherByName(\"{cipher.name}-{cipher.key_size}-{mode.name}\"),\n            )\n        for mode_cls in [CBC, CFB, CFB8, OFB]:\n            self.register_cipher_adapter(\n                TripleDES, mode_cls, GetCipherByName(\"des-ede3-{mode.name}\")\n            )\n        self.register_cipher_adapter(\n            TripleDES, ECB, GetCipherByName(\"des-ede3\")\n        )\n        self.register_cipher_adapter(\n            ChaCha20, type(None), GetCipherByName(\"chacha20\")\n        )\n        self.register_cipher_adapter(AES, XTS, _get_xts_cipher)\n        for mode_cls in [ECB, CBC, OFB, CFB, CTR]:\n            self.register_cipher_adapter(\n                SM4, mode_cls, GetCipherByName(\"sm4-{mode.name}\")\n            )\n        # Don't register legacy ciphers if they're unavailable. Hypothetically\n        # this wouldn't be necessary because we test availability by seeing if\n        # we get an EVP_CIPHER * in the _CipherContext __init__, but OpenSSL 3\n        # will return a valid pointer even though the cipher is unavailable.\n        if (\n            self._binding._legacy_provider_loaded\n            or not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n        ):\n            for mode_cls in [CBC, CFB, OFB, ECB]:\n                self.register_cipher_adapter(\n                    _BlowfishInternal,\n                    mode_cls,\n                    GetCipherByName(\"bf-{mode.name}\"),\n                )\n            for mode_cls in [CBC, CFB, OFB, ECB]:\n                self.register_cipher_adapter(\n                    _SEEDInternal,\n                    mode_cls,\n                    GetCipherByName(\"seed-{mode.name}\"),\n                )\n            for cipher_cls, mode_cls in itertools.product(\n                [_CAST5Internal, _IDEAInternal],\n                [CBC, OFB, CFB, ECB],\n            ):\n                self.register_cipher_adapter(\n                    cipher_cls,\n                    mode_cls,\n                    GetCipherByName(\"{cipher.name}-{mode.name}\"),\n                )\n            self.register_cipher_adapter(\n                ARC4, type(None), GetCipherByName(\"rc4\")\n            )\n            # We don't actually support RC2, this is just used by some tests.\n            self.register_cipher_adapter(\n                _RC2, type(None), GetCipherByName(\"rc2\")\n            )\n\n    def create_symmetric_encryption_ctx(\n        self, cipher: CipherAlgorithm, mode: Mode\n    ) -> _CipherContext:\n        return _CipherContext(self, cipher, mode, _CipherContext._ENCRYPT)\n\n    def create_symmetric_decryption_ctx(\n        self, cipher: CipherAlgorithm, mode: Mode\n    ) -> _CipherContext:\n        return _CipherContext(self, cipher, mode, _CipherContext._DECRYPT)\n\n    def pbkdf2_hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        return self.hmac_supported(algorithm)\n\n    def _consume_errors(self) -> typing.List[rust_openssl.OpenSSLError]:\n        return rust_openssl.capture_error_stack()\n\n    def _bn_to_int(self, bn) -> int:\n        assert bn != self._ffi.NULL\n        self.openssl_assert(not self._lib.BN_is_negative(bn))\n\n        bn_num_bytes = self._lib.BN_num_bytes(bn)\n        bin_ptr = self._ffi.new(\"unsigned char[]\", bn_num_bytes)\n        bin_len = self._lib.BN_bn2bin(bn, bin_ptr)\n        # A zero length means the BN has value 0\n        self.openssl_assert(bin_len >= 0)\n        val = int.from_bytes(self._ffi.buffer(bin_ptr)[:bin_len], \"big\")\n        return val\n\n    def _int_to_bn(self, num: int):\n        \"\"\"\n        Converts a python integer to a BIGNUM. The returned BIGNUM will not\n        be garbage collected (to support adding them to structs that take\n        ownership of the object). Be sure to register it for GC if it will\n        be discarded after use.\n        \"\"\"\n        binary = num.to_bytes(int(num.bit_length() / 8.0 + 1), \"big\")\n        bn_ptr = self._lib.BN_bin2bn(binary, len(binary), self._ffi.NULL)\n        self.openssl_assert(bn_ptr != self._ffi.NULL)\n        return bn_ptr\n\n    def generate_rsa_private_key(\n        self, public_exponent: int, key_size: int\n    ) -> rsa.RSAPrivateKey:\n        rsa._verify_rsa_parameters(public_exponent, key_size)\n\n        rsa_cdata = self._lib.RSA_new()\n        self.openssl_assert(rsa_cdata != self._ffi.NULL)\n        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n\n        bn = self._int_to_bn(public_exponent)\n        bn = self._ffi.gc(bn, self._lib.BN_free)\n\n        res = self._lib.RSA_generate_key_ex(\n            rsa_cdata, key_size, bn, self._ffi.NULL\n        )\n        self.openssl_assert(res == 1)\n        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n\n        # We can skip RSA key validation here since we just generated the key\n        return _RSAPrivateKey(\n            self, rsa_cdata, evp_pkey, unsafe_skip_rsa_key_validation=True\n        )\n\n    def generate_rsa_parameters_supported(\n        self, public_exponent: int, key_size: int\n    ) -> bool:\n        return (\n            public_exponent >= 3\n            and public_exponent & 1 != 0\n            and key_size >= 512\n        )\n\n    def load_rsa_private_numbers(\n        self,\n        numbers: rsa.RSAPrivateNumbers,\n        unsafe_skip_rsa_key_validation: bool,\n    ) -> rsa.RSAPrivateKey:\n        rsa._check_private_key_components(\n            numbers.p,\n            numbers.q,\n            numbers.d,\n            numbers.dmp1,\n            numbers.dmq1,\n            numbers.iqmp,\n            numbers.public_numbers.e,\n            numbers.public_numbers.n,\n        )\n        rsa_cdata = self._lib.RSA_new()\n        self.openssl_assert(rsa_cdata != self._ffi.NULL)\n        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n        p = self._int_to_bn(numbers.p)\n        q = self._int_to_bn(numbers.q)\n        d = self._int_to_bn(numbers.d)\n        dmp1 = self._int_to_bn(numbers.dmp1)\n        dmq1 = self._int_to_bn(numbers.dmq1)\n        iqmp = self._int_to_bn(numbers.iqmp)\n        e = self._int_to_bn(numbers.public_numbers.e)\n        n = self._int_to_bn(numbers.public_numbers.n)\n        res = self._lib.RSA_set0_factors(rsa_cdata, p, q)\n        self.openssl_assert(res == 1)\n        res = self._lib.RSA_set0_key(rsa_cdata, n, e, d)\n        self.openssl_assert(res == 1)\n        res = self._lib.RSA_set0_crt_params(rsa_cdata, dmp1, dmq1, iqmp)\n        self.openssl_assert(res == 1)\n        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n\n        return _RSAPrivateKey(\n            self,\n            rsa_cdata,\n            evp_pkey,\n            unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,\n        )\n\n    def load_rsa_public_numbers(\n        self, numbers: rsa.RSAPublicNumbers\n    ) -> rsa.RSAPublicKey:\n        rsa._check_public_key_components(numbers.e, numbers.n)\n        rsa_cdata = self._lib.RSA_new()\n        self.openssl_assert(rsa_cdata != self._ffi.NULL)\n        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n        e = self._int_to_bn(numbers.e)\n        n = self._int_to_bn(numbers.n)\n        res = self._lib.RSA_set0_key(rsa_cdata, n, e, self._ffi.NULL)\n        self.openssl_assert(res == 1)\n        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n\n        return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n\n    def _create_evp_pkey_gc(self):\n        evp_pkey = self._lib.EVP_PKEY_new()\n        self.openssl_assert(evp_pkey != self._ffi.NULL)\n        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n        return evp_pkey\n\n    def _rsa_cdata_to_evp_pkey(self, rsa_cdata):\n        evp_pkey = self._create_evp_pkey_gc()\n        res = self._lib.EVP_PKEY_set1_RSA(evp_pkey, rsa_cdata)\n        self.openssl_assert(res == 1)\n        return evp_pkey\n\n    def _bytes_to_bio(self, data: bytes) -> _MemoryBIO:\n        \"\"\"\n        Return a _MemoryBIO namedtuple of (BIO, char*).\n\n        The char* is the storage for the BIO and it must stay alive until the\n        BIO is finished with.\n        \"\"\"\n        data_ptr = self._ffi.from_buffer(data)\n        bio = self._lib.BIO_new_mem_buf(data_ptr, len(data))\n        self.openssl_assert(bio != self._ffi.NULL)\n\n        return _MemoryBIO(self._ffi.gc(bio, self._lib.BIO_free), data_ptr)\n\n    def _create_mem_bio_gc(self):\n        \"\"\"\n        Creates an empty memory BIO.\n        \"\"\"\n        bio_method = self._lib.BIO_s_mem()\n        self.openssl_assert(bio_method != self._ffi.NULL)\n        bio = self._lib.BIO_new(bio_method)\n        self.openssl_assert(bio != self._ffi.NULL)\n        bio = self._ffi.gc(bio, self._lib.BIO_free)\n        return bio\n\n    def _read_mem_bio(self, bio) -> bytes:\n        \"\"\"\n        Reads a memory BIO. This only works on memory BIOs.\n        \"\"\"\n        buf = self._ffi.new(\"char **\")\n        buf_len = self._lib.BIO_get_mem_data(bio, buf)\n        self.openssl_assert(buf_len > 0)\n        self.openssl_assert(buf[0] != self._ffi.NULL)\n        bio_data = self._ffi.buffer(buf[0], buf_len)[:]\n        return bio_data\n\n    def _evp_pkey_to_private_key(\n        self, evp_pkey, unsafe_skip_rsa_key_validation: bool\n    ) -> PrivateKeyTypes:\n        \"\"\"\n        Return the appropriate type of PrivateKey given an evp_pkey cdata\n        pointer.\n        \"\"\"\n\n        key_type = self._lib.EVP_PKEY_id(evp_pkey)\n\n        if key_type == self._lib.EVP_PKEY_RSA:\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            return _RSAPrivateKey(\n                self,\n                rsa_cdata,\n                evp_pkey,\n                unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,\n            )\n        elif (\n            key_type == self._lib.EVP_PKEY_RSA_PSS\n            and not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n            and not self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111E\n        ):\n            # At the moment the way we handle RSA PSS keys is to strip the\n            # PSS constraints from them and treat them as normal RSA keys\n            # Unfortunately the RSA * itself tracks this data so we need to\n            # extract, serialize, and reload it without the constraints.\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            bio = self._create_mem_bio_gc()\n            res = self._lib.i2d_RSAPrivateKey_bio(bio, rsa_cdata)\n            self.openssl_assert(res == 1)\n            return self.load_der_private_key(\n                self._read_mem_bio(bio),\n                password=None,\n                unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,\n            )\n        elif key_type == self._lib.EVP_PKEY_DSA:\n            return rust_openssl.dsa.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_EC:\n            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)\n            self.openssl_assert(ec_cdata != self._ffi.NULL)\n            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)\n            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n        elif key_type in self._dh_types:\n            return rust_openssl.dh.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED25519\", None):\n            # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed25519.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_X448\", None):\n            # EVP_PKEY_X448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.x448.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_X25519:\n            return rust_openssl.x25519.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED448\", None):\n            # EVP_PKEY_ED448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed448.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        else:\n            raise UnsupportedAlgorithm(\"Unsupported key type.\")\n\n    def _evp_pkey_to_public_key(self, evp_pkey) -> PublicKeyTypes:\n        \"\"\"\n        Return the appropriate type of PublicKey given an evp_pkey cdata\n        pointer.\n        \"\"\"\n\n        key_type = self._lib.EVP_PKEY_id(evp_pkey)\n\n        if key_type == self._lib.EVP_PKEY_RSA:\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n        elif (\n            key_type == self._lib.EVP_PKEY_RSA_PSS\n            and not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n            and not self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111E\n        ):\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            bio = self._create_mem_bio_gc()\n            res = self._lib.i2d_RSAPublicKey_bio(bio, rsa_cdata)\n            self.openssl_assert(res == 1)\n            return self.load_der_public_key(self._read_mem_bio(bio))\n        elif key_type == self._lib.EVP_PKEY_DSA:\n            return rust_openssl.dsa.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_EC:\n            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)\n            if ec_cdata == self._ffi.NULL:\n                errors = self._consume_errors()\n                raise ValueError(\"Unable to load EC key\", errors)\n            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)\n            return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)\n        elif key_type in self._dh_types:\n            return rust_openssl.dh.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED25519\", None):\n            # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed25519.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_X448\", None):\n            # EVP_PKEY_X448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.x448.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_X25519:\n            return rust_openssl.x25519.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED448\", None):\n            # EVP_PKEY_ED448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed448.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        else:\n            raise UnsupportedAlgorithm(\"Unsupported key type.\")\n\n    def _oaep_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n\n        return isinstance(\n            algorithm,\n            (\n                hashes.SHA1,\n                hashes.SHA224,\n                hashes.SHA256,\n                hashes.SHA384,\n                hashes.SHA512,\n            ),\n        )\n\n    def rsa_padding_supported(self, padding: AsymmetricPadding) -> bool:\n        if isinstance(padding, PKCS1v15):\n            return True\n        elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):\n            # SHA1 is permissible in MGF1 in FIPS even when SHA1 is blocked\n            # as signature algorithm.\n            if self._fips_enabled and isinstance(\n                padding._mgf._algorithm, hashes.SHA1\n            ):\n                return True\n            else:\n                return self.hash_supported(padding._mgf._algorithm)\n        elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):\n            return self._oaep_hash_supported(\n                padding._mgf._algorithm\n            ) and self._oaep_hash_supported(padding._algorithm)\n        else:\n            return False\n\n    def rsa_encryption_supported(self, padding: AsymmetricPadding) -> bool:\n        if self._fips_enabled and isinstance(padding, PKCS1v15):\n            return False\n        else:\n            return self.rsa_padding_supported(padding)\n\n    def generate_dsa_parameters(self, key_size: int) -> dsa.DSAParameters:\n        if key_size not in (1024, 2048, 3072, 4096):\n            raise ValueError(\n                \"Key size must be 1024, 2048, 3072, or 4096 bits.\"\n            )\n\n        return rust_openssl.dsa.generate_parameters(key_size)\n\n    def generate_dsa_private_key(\n        self, parameters: dsa.DSAParameters\n    ) -> dsa.DSAPrivateKey:\n        return parameters.generate_private_key()\n\n    def generate_dsa_private_key_and_parameters(\n        self, key_size: int\n    ) -> dsa.DSAPrivateKey:\n        parameters = self.generate_dsa_parameters(key_size)\n        return self.generate_dsa_private_key(parameters)\n\n    def load_dsa_private_numbers(\n        self, numbers: dsa.DSAPrivateNumbers\n    ) -> dsa.DSAPrivateKey:\n        dsa._check_dsa_private_numbers(numbers)\n        return rust_openssl.dsa.from_private_numbers(numbers)\n\n    def load_dsa_public_numbers(\n        self, numbers: dsa.DSAPublicNumbers\n    ) -> dsa.DSAPublicKey:\n        dsa._check_dsa_parameters(numbers.parameter_numbers)\n        return rust_openssl.dsa.from_public_numbers(numbers)\n\n    def load_dsa_parameter_numbers(\n        self, numbers: dsa.DSAParameterNumbers\n    ) -> dsa.DSAParameters:\n        dsa._check_dsa_parameters(numbers)\n        return rust_openssl.dsa.from_parameter_numbers(numbers)\n\n    def dsa_supported(self) -> bool:\n        return (\n            not self._lib.CRYPTOGRAPHY_IS_BORINGSSL and not self._fips_enabled\n        )\n\n    def dsa_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if not self.dsa_supported():\n            return False\n        return self.signature_hash_supported(algorithm)\n\n    def cmac_algorithm_supported(self, algorithm) -> bool:\n        return self.cipher_supported(\n            algorithm, CBC(b\"\\x00\" * algorithm.block_size)\n        )\n\n    def create_cmac_ctx(self, algorithm: BlockCipherAlgorithm) -> _CMACContext:\n        return _CMACContext(self, algorithm)\n\n    def load_pem_private_key(\n        self,\n        data: bytes,\n        password: typing.Optional[bytes],\n        unsafe_skip_rsa_key_validation: bool,\n    ) -> PrivateKeyTypes:\n        return self._load_key(\n            self._lib.PEM_read_bio_PrivateKey,\n            data,\n            password,\n            unsafe_skip_rsa_key_validation,\n        )\n\n    def load_pem_public_key(self, data: bytes) -> PublicKeyTypes:\n        mem_bio = self._bytes_to_bio(data)\n        # In OpenSSL 3.0.x the PEM_read_bio_PUBKEY function will invoke\n        # the default password callback if you pass an encrypted private\n        # key. This is very, very, very bad as the default callback can\n        # trigger an interactive console prompt, which will hang the\n        # Python process. We therefore provide our own callback to\n        # catch this and error out properly.\n        userdata = self._ffi.new(\"CRYPTOGRAPHY_PASSWORD_DATA *\")\n        evp_pkey = self._lib.PEM_read_bio_PUBKEY(\n            mem_bio.bio,\n            self._ffi.NULL,\n            self._ffi.addressof(\n                self._lib._original_lib, \"Cryptography_pem_password_cb\"\n            ),\n            userdata,\n        )\n        if evp_pkey != self._ffi.NULL:\n            evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n            return self._evp_pkey_to_public_key(evp_pkey)\n        else:\n            # It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still\n            # need to check to see if it is a pure PKCS1 RSA public key (not\n            # embedded in a subjectPublicKeyInfo)\n            self._consume_errors()\n            res = self._lib.BIO_reset(mem_bio.bio)\n            self.openssl_assert(res == 1)\n            rsa_cdata = self._lib.PEM_read_bio_RSAPublicKey(\n                mem_bio.bio,\n                self._ffi.NULL,\n                self._ffi.addressof(\n                    self._lib._original_lib, \"Cryptography_pem_password_cb\"\n                ),\n                userdata,\n            )\n            if rsa_cdata != self._ffi.NULL:\n                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n                return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n            else:\n                self._handle_key_loading_error()\n\n    def load_pem_parameters(self, data: bytes) -> dh.DHParameters:\n        return rust_openssl.dh.from_pem_parameters(data)\n\n    def load_der_private_key(\n        self,\n        data: bytes,\n        password: typing.Optional[bytes],\n        unsafe_skip_rsa_key_validation: bool,\n    ) -> PrivateKeyTypes:\n        # OpenSSL has a function called d2i_AutoPrivateKey that in theory\n        # handles this automatically, however it doesn't handle encrypted\n        # private keys. Instead we try to load the key two different ways.\n        # First we'll try to load it as a traditional key.\n        bio_data = self._bytes_to_bio(data)\n        key = self._evp_pkey_from_der_traditional_key(bio_data, password)\n        if key:\n            return self._evp_pkey_to_private_key(\n                key, unsafe_skip_rsa_key_validation\n            )\n        else:\n            # Finally we try to load it with the method that handles encrypted\n            # PKCS8 properly.\n            return self._load_key(\n                self._lib.d2i_PKCS8PrivateKey_bio,\n                data,\n                password,\n                unsafe_skip_rsa_key_validation,\n            )\n\n    def _evp_pkey_from_der_traditional_key(self, bio_data, password):\n        key = self._lib.d2i_PrivateKey_bio(bio_data.bio, self._ffi.NULL)\n        if key != self._ffi.NULL:\n            key = self._ffi.gc(key, self._lib.EVP_PKEY_free)\n            if password is not None:\n                raise TypeError(\n                    \"Password was given but private key is not encrypted.\"\n                )\n\n            return key\n        else:\n            self._consume_errors()\n            return None\n\n    def load_der_public_key(self, data: bytes) -> PublicKeyTypes:\n        mem_bio = self._bytes_to_bio(data)\n        evp_pkey = self._lib.d2i_PUBKEY_bio(mem_bio.bio, self._ffi.NULL)\n        if evp_pkey != self._ffi.NULL:\n            evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n            return self._evp_pkey_to_public_key(evp_pkey)\n        else:\n            # It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still\n            # need to check to see if it is a pure PKCS1 RSA public key (not\n            # embedded in a subjectPublicKeyInfo)\n            self._consume_errors()\n            res = self._lib.BIO_reset(mem_bio.bio)\n            self.openssl_assert(res == 1)\n            rsa_cdata = self._lib.d2i_RSAPublicKey_bio(\n                mem_bio.bio, self._ffi.NULL\n            )\n            if rsa_cdata != self._ffi.NULL:\n                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n                return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n            else:\n                self._handle_key_loading_error()\n\n    def load_der_parameters(self, data: bytes) -> dh.DHParameters:\n        return rust_openssl.dh.from_der_parameters(data)\n\n    def _cert2ossl(self, cert: x509.Certificate) -> typing.Any:\n        data = cert.public_bytes(serialization.Encoding.DER)\n        mem_bio = self._bytes_to_bio(data)\n        x509 = self._lib.d2i_X509_bio(mem_bio.bio, self._ffi.NULL)\n        self.openssl_assert(x509 != self._ffi.NULL)\n        x509 = self._ffi.gc(x509, self._lib.X509_free)\n        return x509\n\n    def _ossl2cert(self, x509_ptr: typing.Any) -> x509.Certificate:\n        bio = self._create_mem_bio_gc()\n        res = self._lib.i2d_X509_bio(bio, x509_ptr)\n        self.openssl_assert(res == 1)\n        return x509.load_der_x509_certificate(self._read_mem_bio(bio))\n\n    def _key2ossl(self, key: PKCS12PrivateKeyTypes) -> typing.Any:\n        data = key.private_bytes(\n            serialization.Encoding.DER,\n            serialization.PrivateFormat.PKCS8,\n            serialization.NoEncryption(),\n        )\n        mem_bio = self._bytes_to_bio(data)\n\n        evp_pkey = self._lib.d2i_PrivateKey_bio(\n            mem_bio.bio,\n            self._ffi.NULL,\n        )\n        self.openssl_assert(evp_pkey != self._ffi.NULL)\n        return self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n\n    def _load_key(\n        self, openssl_read_func, data, password, unsafe_skip_rsa_key_validation\n    ) -> PrivateKeyTypes:\n        mem_bio = self._bytes_to_bio(data)\n\n        userdata = self._ffi.new(\"CRYPTOGRAPHY_PASSWORD_DATA *\")\n        if password is not None:\n            utils._check_byteslike(\"password\", password)\n            password_ptr = self._ffi.from_buffer(password)\n            userdata.password = password_ptr\n            userdata.length = len(password)\n\n        evp_pkey = openssl_read_func(\n            mem_bio.bio,\n            self._ffi.NULL,\n            self._ffi.addressof(\n                self._lib._original_lib, \"Cryptography_pem_password_cb\"\n            ),\n            userdata,\n        )\n\n        if evp_pkey == self._ffi.NULL:\n            if userdata.error != 0:\n                self._consume_errors()\n                if userdata.error == -1:\n                    raise TypeError(\n                        \"Password was not given but private key is encrypted\"\n                    )\n                else:\n                    assert userdata.error == -2\n                    raise ValueError(\n                        \"Passwords longer than {} bytes are not supported \"\n                        \"by this backend.\".format(userdata.maxsize - 1)\n                    )\n            else:\n                self._handle_key_loading_error()\n\n        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n\n        if password is not None and userdata.called == 0:\n            raise TypeError(\n                \"Password was given but private key is not encrypted.\"\n            )\n\n        assert (\n            password is not None and userdata.called == 1\n        ) or password is None\n\n        return self._evp_pkey_to_private_key(\n            evp_pkey, unsafe_skip_rsa_key_validation\n        )\n\n    def _handle_key_loading_error(self) -> typing.NoReturn:\n        errors = self._consume_errors()\n\n        if not errors:\n            raise ValueError(\n                \"Could not deserialize key data. The data may be in an \"\n                \"incorrect format or it may be encrypted with an unsupported \"\n                \"algorithm.\"\n            )\n\n        elif (\n            errors[0]._lib_reason_match(\n                self._lib.ERR_LIB_EVP, self._lib.EVP_R_BAD_DECRYPT\n            )\n            or errors[0]._lib_reason_match(\n                self._lib.ERR_LIB_PKCS12,\n                self._lib.PKCS12_R_PKCS12_CIPHERFINAL_ERROR,\n            )\n            or (\n                self._lib.Cryptography_HAS_PROVIDERS\n                and errors[0]._lib_reason_match(\n                    self._lib.ERR_LIB_PROV,\n                    self._lib.PROV_R_BAD_DECRYPT,\n                )\n            )\n        ):\n            raise ValueError(\"Bad decrypt. Incorrect password?\")\n\n        elif any(\n            error._lib_reason_match(\n                self._lib.ERR_LIB_EVP,\n                self._lib.EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM,\n            )\n            for error in errors\n        ):\n            raise ValueError(\"Unsupported public key algorithm.\")\n\n        else:\n            raise ValueError(\n                \"Could not deserialize key data. The data may be in an \"\n                \"incorrect format, it may be encrypted with an unsupported \"\n                \"algorithm, or it may be an unsupported key type (e.g. EC \"\n                \"curves with explicit parameters).\",\n                errors,\n            )\n\n    def elliptic_curve_supported(self, curve: ec.EllipticCurve) -> bool:\n        try:\n            curve_nid = self._elliptic_curve_to_nid(curve)\n        except UnsupportedAlgorithm:\n            curve_nid = self._lib.NID_undef\n\n        group = self._lib.EC_GROUP_new_by_curve_name(curve_nid)\n\n        if group == self._ffi.NULL:\n            self._consume_errors()\n            return False\n        else:\n            self.openssl_assert(curve_nid != self._lib.NID_undef)\n            self._lib.EC_GROUP_free(group)\n            return True\n\n    def elliptic_curve_signature_algorithm_supported(\n        self,\n        signature_algorithm: ec.EllipticCurveSignatureAlgorithm,\n        curve: ec.EllipticCurve,\n    ) -> bool:\n        # We only support ECDSA right now.\n        if not isinstance(signature_algorithm, ec.ECDSA):\n            return False\n\n        return self.elliptic_curve_supported(curve)\n\n    def generate_elliptic_curve_private_key(\n        self, curve: ec.EllipticCurve\n    ) -> ec.EllipticCurvePrivateKey:\n        \"\"\"\n        Generate a new private key on the named curve.\n        \"\"\"\n\n        if self.elliptic_curve_supported(curve):\n            ec_cdata = self._ec_key_new_by_curve(curve)\n\n            res = self._lib.EC_KEY_generate_key(ec_cdata)\n            self.openssl_assert(res == 1)\n\n            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n        else:\n            raise UnsupportedAlgorithm(\n                f\"Backend object does not support {curve.name}.\",\n                _Reasons.UNSUPPORTED_ELLIPTIC_CURVE,\n            )\n\n    def load_elliptic_curve_private_numbers(\n        self, numbers: ec.EllipticCurvePrivateNumbers\n    ) -> ec.EllipticCurvePrivateKey:\n        public = numbers.public_numbers\n\n        ec_cdata = self._ec_key_new_by_curve(public.curve)\n\n        private_value = self._ffi.gc(\n            self._int_to_bn(numbers.private_value), self._lib.BN_clear_free\n        )\n        res = self._lib.EC_KEY_set_private_key(ec_cdata, private_value)\n        if res != 1:\n            self._consume_errors()\n            raise ValueError(\"Invalid EC key.\")\n\n        with self._tmp_bn_ctx() as bn_ctx:\n            self._ec_key_set_public_key_affine_coordinates(\n                ec_cdata, public.x, public.y, bn_ctx\n            )\n            # derive the expected public point and compare it to the one we\n            # just set based on the values we were given. If they don't match\n            # this isn't a valid key pair.\n            group = self._lib.EC_KEY_get0_group(ec_cdata)\n            self.openssl_assert(group != self._ffi.NULL)\n            set_point = backend._lib.EC_KEY_get0_public_key(ec_cdata)\n            self.openssl_assert(set_point != self._ffi.NULL)\n            computed_point = self._lib.EC_POINT_new(group)\n            self.openssl_assert(computed_point != self._ffi.NULL)\n            computed_point = self._ffi.gc(\n                computed_point, self._lib.EC_POINT_free\n            )\n            res = self._lib.EC_POINT_mul(\n                group,\n                computed_point,\n                private_value,\n                self._ffi.NULL,\n                self._ffi.NULL,\n                bn_ctx,\n            )\n            self.openssl_assert(res == 1)\n            if (\n                self._lib.EC_POINT_cmp(\n                    group, set_point, computed_point, bn_ctx\n                )\n                != 0\n            ):\n                raise ValueError(\"Invalid EC key.\")\n\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n\n    def load_elliptic_curve_public_numbers(\n        self, numbers: ec.EllipticCurvePublicNumbers\n    ) -> ec.EllipticCurvePublicKey:\n        ec_cdata = self._ec_key_new_by_curve(numbers.curve)\n        with self._tmp_bn_ctx() as bn_ctx:\n            self._ec_key_set_public_key_affine_coordinates(\n                ec_cdata, numbers.x, numbers.y, bn_ctx\n            )\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)\n\n    def load_elliptic_curve_public_bytes(\n        self, curve: ec.EllipticCurve, point_bytes: bytes\n    ) -> ec.EllipticCurvePublicKey:\n        ec_cdata = self._ec_key_new_by_curve(curve)\n        group = self._lib.EC_KEY_get0_group(ec_cdata)\n        self.openssl_assert(group != self._ffi.NULL)\n        point = self._lib.EC_POINT_new(group)\n        self.openssl_assert(point != self._ffi.NULL)\n        point = self._ffi.gc(point, self._lib.EC_POINT_free)\n        with self._tmp_bn_ctx() as bn_ctx:\n            res = self._lib.EC_POINT_oct2point(\n                group, point, point_bytes, len(point_bytes), bn_ctx\n            )\n            if res != 1:\n                self._consume_errors()\n                raise ValueError(\"Invalid public bytes for the given curve\")\n\n        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)\n        self.openssl_assert(res == 1)\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)\n\n    def derive_elliptic_curve_private_key(\n        self, private_value: int, curve: ec.EllipticCurve\n    ) -> ec.EllipticCurvePrivateKey:\n        ec_cdata = self._ec_key_new_by_curve(curve)\n\n        group = self._lib.EC_KEY_get0_group(ec_cdata)\n        self.openssl_assert(group != self._ffi.NULL)\n\n        point = self._lib.EC_POINT_new(group)\n        self.openssl_assert(point != self._ffi.NULL)\n        point = self._ffi.gc(point, self._lib.EC_POINT_free)\n\n        value = self._int_to_bn(private_value)\n        value = self._ffi.gc(value, self._lib.BN_clear_free)\n\n        with self._tmp_bn_ctx() as bn_ctx:\n            res = self._lib.EC_POINT_mul(\n                group, point, value, self._ffi.NULL, self._ffi.NULL, bn_ctx\n            )\n            self.openssl_assert(res == 1)\n\n            bn_x = self._lib.BN_CTX_get(bn_ctx)\n            bn_y = self._lib.BN_CTX_get(bn_ctx)\n\n            res = self._lib.EC_POINT_get_affine_coordinates(\n                group, point, bn_x, bn_y, bn_ctx\n            )\n            if res != 1:\n                self._consume_errors()\n                raise ValueError(\"Unable to derive key from private_value\")\n\n        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)\n        self.openssl_assert(res == 1)\n        private = self._int_to_bn(private_value)\n        private = self._ffi.gc(private, self._lib.BN_clear_free)\n        res = self._lib.EC_KEY_set_private_key(ec_cdata, private)\n        self.openssl_assert(res == 1)\n\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n\n    def _ec_key_new_by_curve(self, curve: ec.EllipticCurve):\n        curve_nid = self._elliptic_curve_to_nid(curve)\n        return self._ec_key_new_by_curve_nid(curve_nid)\n\n    def _ec_key_new_by_curve_nid(self, curve_nid: int):\n        ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)\n        self.openssl_assert(ec_cdata != self._ffi.NULL)\n        return self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)\n\n    def elliptic_curve_exchange_algorithm_supported(\n        self, algorithm: ec.ECDH, curve: ec.EllipticCurve\n    ) -> bool:\n        if self._fips_enabled and not isinstance(\n            curve, self._fips_ecdh_curves\n        ):\n            return False\n\n        return self.elliptic_curve_supported(curve) and isinstance(\n            algorithm, ec.ECDH\n        )\n\n    def _ec_cdata_to_evp_pkey(self, ec_cdata):\n        evp_pkey = self._create_evp_pkey_gc()\n        res = self._lib.EVP_PKEY_set1_EC_KEY(evp_pkey, ec_cdata)\n        self.openssl_assert(res == 1)\n        return evp_pkey\n\n    def _elliptic_curve_to_nid(self, curve: ec.EllipticCurve) -> int:\n        \"\"\"\n        Get the NID for a curve name.\n        \"\"\"\n\n        curve_aliases = {\"secp192r1\": \"prime192v1\", \"secp256r1\": \"prime256v1\"}\n\n        curve_name = curve_aliases.get(curve.name, curve.name)\n\n        curve_nid = self._lib.OBJ_sn2nid(curve_name.encode())\n        if curve_nid == self._lib.NID_undef:\n            raise UnsupportedAlgorithm(\n                f\"{curve.name} is not a supported elliptic curve\",\n                _Reasons.UNSUPPORTED_ELLIPTIC_CURVE,\n            )\n        return curve_nid\n\n    @contextmanager\n    def _tmp_bn_ctx(self):\n        bn_ctx = self._lib.BN_CTX_new()\n        self.openssl_assert(bn_ctx != self._ffi.NULL)\n        bn_ctx = self._ffi.gc(bn_ctx, self._lib.BN_CTX_free)\n        self._lib.BN_CTX_start(bn_ctx)\n        try:\n            yield bn_ctx\n        finally:\n            self._lib.BN_CTX_end(bn_ctx)\n\n    def _ec_key_set_public_key_affine_coordinates(\n        self,\n        ec_cdata,\n        x: int,\n        y: int,\n        bn_ctx,\n    ) -> None:\n        \"\"\"\n        Sets the public key point in the EC_KEY context to the affine x and y\n        values.\n        \"\"\"\n\n        if x < 0 or y < 0:\n            raise ValueError(\n                \"Invalid EC key. Both x and y must be non-negative.\"\n            )\n\n        x = self._ffi.gc(self._int_to_bn(x), self._lib.BN_free)\n        y = self._ffi.gc(self._int_to_bn(y), self._lib.BN_free)\n        group = self._lib.EC_KEY_get0_group(ec_cdata)\n        self.openssl_assert(group != self._ffi.NULL)\n        point = self._lib.EC_POINT_new(group)\n        self.openssl_assert(point != self._ffi.NULL)\n        point = self._ffi.gc(point, self._lib.EC_POINT_free)\n        res = self._lib.EC_POINT_set_affine_coordinates(\n            group, point, x, y, bn_ctx\n        )\n        if res != 1:\n            self._consume_errors()\n            raise ValueError(\"Invalid EC key.\")\n        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)\n        self.openssl_assert(res == 1)\n\n    def _private_key_bytes(\n        self,\n        encoding: serialization.Encoding,\n        format: serialization.PrivateFormat,\n        encryption_algorithm: serialization.KeySerializationEncryption,\n        key,\n        evp_pkey,\n        cdata,\n    ) -> bytes:\n        # validate argument types\n        if not isinstance(encoding, serialization.Encoding):\n            raise TypeError(\"encoding must be an item from the Encoding enum\")\n        if not isinstance(format, serialization.PrivateFormat):\n            raise TypeError(\n                \"format must be an item from the PrivateFormat enum\"\n            )\n        if not isinstance(\n            encryption_algorithm, serialization.KeySerializationEncryption\n        ):\n            raise TypeError(\n                \"Encryption algorithm must be a KeySerializationEncryption \"\n                \"instance\"\n            )\n\n        # validate password\n        if isinstance(encryption_algorithm, serialization.NoEncryption):\n            password = b\"\"\n        elif isinstance(\n            encryption_algorithm, serialization.BestAvailableEncryption\n        ):\n            password = encryption_algorithm.password\n            if len(password) > 1023:\n                raise ValueError(\n                    \"Passwords longer than 1023 bytes are not supported by \"\n                    \"this backend\"\n                )\n        elif (\n            isinstance(\n                encryption_algorithm, serialization._KeySerializationEncryption\n            )\n            and encryption_algorithm._format\n            is format\n            is serialization.PrivateFormat.OpenSSH\n        ):\n            password = encryption_algorithm.password\n        else:\n            raise ValueError(\"Unsupported encryption type\")\n\n        # PKCS8 + PEM/DER\n        if format is serialization.PrivateFormat.PKCS8:\n            if encoding is serialization.Encoding.PEM:\n                write_bio = self._lib.PEM_write_bio_PKCS8PrivateKey\n            elif encoding is serialization.Encoding.DER:\n                write_bio = self._lib.i2d_PKCS8PrivateKey_bio\n            else:\n                raise ValueError(\"Unsupported encoding for PKCS8\")\n            return self._private_key_bytes_via_bio(\n                write_bio, evp_pkey, password\n            )\n\n        # TraditionalOpenSSL + PEM/DER\n        if format is serialization.PrivateFormat.TraditionalOpenSSL:\n            if self._fips_enabled and not isinstance(\n                encryption_algorithm, serialization.NoEncryption\n            ):\n                raise ValueError(\n                    \"Encrypted traditional OpenSSL format is not \"\n                    \"supported in FIPS mode.\"\n                )\n            key_type = self._lib.EVP_PKEY_id(evp_pkey)\n\n            if encoding is serialization.Encoding.PEM:\n                if key_type == self._lib.EVP_PKEY_RSA:\n                    write_bio = self._lib.PEM_write_bio_RSAPrivateKey\n                else:\n                    assert key_type == self._lib.EVP_PKEY_EC\n                    write_bio = self._lib.PEM_write_bio_ECPrivateKey\n                return self._private_key_bytes_via_bio(\n                    write_bio, cdata, password\n                )\n\n            if encoding is serialization.Encoding.DER:\n                if password:\n                    raise ValueError(\n                        \"Encryption is not supported for DER encoded \"\n                        \"traditional OpenSSL keys\"\n                    )\n                if key_type == self._lib.EVP_PKEY_RSA:\n                    write_bio = self._lib.i2d_RSAPrivateKey_bio\n                else:\n                    assert key_type == self._lib.EVP_PKEY_EC\n                    write_bio = self._lib.i2d_ECPrivateKey_bio\n                return self._bio_func_output(write_bio, cdata)\n\n            raise ValueError(\"Unsupported encoding for TraditionalOpenSSL\")\n\n        # OpenSSH + PEM\n        if format is serialization.PrivateFormat.OpenSSH:\n            if encoding is serialization.Encoding.PEM:\n                return ssh._serialize_ssh_private_key(\n                    key, password, encryption_algorithm\n                )\n\n            raise ValueError(\n                \"OpenSSH private key format can only be used\"\n                \" with PEM encoding\"\n            )\n\n        # Anything that key-specific code was supposed to handle earlier,\n        # like Raw.\n        raise ValueError(\"format is invalid with this key\")\n\n    def _private_key_bytes_via_bio(\n        self, write_bio, evp_pkey, password\n    ) -> bytes:\n        if not password:\n            evp_cipher = self._ffi.NULL\n        else:\n            # This is a curated value that we will update over time.\n            evp_cipher = self._lib.EVP_get_cipherbyname(b\"aes-256-cbc\")\n\n        return self._bio_func_output(\n            write_bio,\n            evp_pkey,\n            evp_cipher,\n            password,\n            len(password),\n            self._ffi.NULL,\n            self._ffi.NULL,\n        )\n\n    def _bio_func_output(self, write_bio, *args) -> bytes:\n        bio = self._create_mem_bio_gc()\n        res = write_bio(bio, *args)\n        self.openssl_assert(res == 1)\n        return self._read_mem_bio(bio)\n\n    def _public_key_bytes(\n        self,\n        encoding: serialization.Encoding,\n        format: serialization.PublicFormat,\n        key,\n        evp_pkey,\n        cdata,\n    ) -> bytes:\n        if not isinstance(encoding, serialization.Encoding):\n            raise TypeError(\"encoding must be an item from the Encoding enum\")\n        if not isinstance(format, serialization.PublicFormat):\n            raise TypeError(\n                \"format must be an item from the PublicFormat enum\"\n            )\n\n        # SubjectPublicKeyInfo + PEM/DER\n        if format is serialization.PublicFormat.SubjectPublicKeyInfo:\n            if encoding is serialization.Encoding.PEM:\n                write_bio = self._lib.PEM_write_bio_PUBKEY\n            elif encoding is serialization.Encoding.DER:\n                write_bio = self._lib.i2d_PUBKEY_bio\n            else:\n                raise ValueError(\n                    \"SubjectPublicKeyInfo works only with PEM or DER encoding\"\n                )\n            return self._bio_func_output(write_bio, evp_pkey)\n\n        # PKCS1 + PEM/DER\n        if format is serialization.PublicFormat.PKCS1:\n            # Only RSA is supported here.\n            key_type = self._lib.EVP_PKEY_id(evp_pkey)\n            if key_type != self._lib.EVP_PKEY_RSA:\n                raise ValueError(\"PKCS1 format is supported only for RSA keys\")\n\n            if encoding is serialization.Encoding.PEM:\n                write_bio = self._lib.PEM_write_bio_RSAPublicKey\n            elif encoding is serialization.Encoding.DER:\n                write_bio = self._lib.i2d_RSAPublicKey_bio\n            else:\n                raise ValueError(\"PKCS1 works only with PEM or DER encoding\")\n            return self._bio_func_output(write_bio, cdata)\n\n        # OpenSSH + OpenSSH\n        if format is serialization.PublicFormat.OpenSSH:\n            if encoding is serialization.Encoding.OpenSSH:\n                return ssh.serialize_ssh_public_key(key)\n\n            raise ValueError(\n                \"OpenSSH format must be used with OpenSSH encoding\"\n            )\n\n        # Anything that key-specific code was supposed to handle earlier,\n        # like Raw, CompressedPoint, UncompressedPoint\n        raise ValueError(\"format is invalid with this key\")\n\n    def dh_supported(self) -> bool:\n        return not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n\n    def generate_dh_parameters(\n        self, generator: int, key_size: int\n    ) -> dh.DHParameters:\n        return rust_openssl.dh.generate_parameters(generator, key_size)\n\n    def generate_dh_private_key(\n        self, parameters: dh.DHParameters\n    ) -> dh.DHPrivateKey:\n        return parameters.generate_private_key()\n\n    def generate_dh_private_key_and_parameters(\n        self, generator: int, key_size: int\n    ) -> dh.DHPrivateKey:\n        return self.generate_dh_private_key(\n            self.generate_dh_parameters(generator, key_size)\n        )\n\n    def load_dh_private_numbers(\n        self, numbers: dh.DHPrivateNumbers\n    ) -> dh.DHPrivateKey:\n        return rust_openssl.dh.from_private_numbers(numbers)\n\n    def load_dh_public_numbers(\n        self, numbers: dh.DHPublicNumbers\n    ) -> dh.DHPublicKey:\n        return rust_openssl.dh.from_public_numbers(numbers)\n\n    def load_dh_parameter_numbers(\n        self, numbers: dh.DHParameterNumbers\n    ) -> dh.DHParameters:\n        return rust_openssl.dh.from_parameter_numbers(numbers)\n\n    def dh_parameters_supported(\n        self, p: int, g: int, q: typing.Optional[int] = None\n    ) -> bool:\n        try:\n            rust_openssl.dh.from_parameter_numbers(\n                dh.DHParameterNumbers(p=p, g=g, q=q)\n            )\n        except ValueError:\n            return False\n        else:\n            return True\n\n    def dh_x942_serialization_supported(self) -> bool:\n        return self._lib.Cryptography_HAS_EVP_PKEY_DHX == 1\n\n    def x25519_load_public_bytes(self, data: bytes) -> x25519.X25519PublicKey:\n        return rust_openssl.x25519.from_public_bytes(data)\n\n    def x25519_load_private_bytes(\n        self, data: bytes\n    ) -> x25519.X25519PrivateKey:\n        return rust_openssl.x25519.from_private_bytes(data)\n\n    def x25519_generate_key(self) -> x25519.X25519PrivateKey:\n        return rust_openssl.x25519.generate_key()\n\n    def x25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return not self._lib.CRYPTOGRAPHY_LIBRESSL_LESS_THAN_370\n\n    def x448_load_public_bytes(self, data: bytes) -> x448.X448PublicKey:\n        return rust_openssl.x448.from_public_bytes(data)\n\n    def x448_load_private_bytes(self, data: bytes) -> x448.X448PrivateKey:\n        return rust_openssl.x448.from_private_bytes(data)\n\n    def x448_generate_key(self) -> x448.X448PrivateKey:\n        return rust_openssl.x448.generate_key()\n\n    def x448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ed25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return self._lib.CRYPTOGRAPHY_HAS_WORKING_ED25519\n\n    def ed25519_load_public_bytes(\n        self, data: bytes\n    ) -> ed25519.Ed25519PublicKey:\n        return rust_openssl.ed25519.from_public_bytes(data)\n\n    def ed25519_load_private_bytes(\n        self, data: bytes\n    ) -> ed25519.Ed25519PrivateKey:\n        return rust_openssl.ed25519.from_private_bytes(data)\n\n    def ed25519_generate_key(self) -> ed25519.Ed25519PrivateKey:\n        return rust_openssl.ed25519.generate_key()\n\n    def ed448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ed448_load_public_bytes(self, data: bytes) -> ed448.Ed448PublicKey:\n        return rust_openssl.ed448.from_public_bytes(data)\n\n    def ed448_load_private_bytes(self, data: bytes) -> ed448.Ed448PrivateKey:\n        return rust_openssl.ed448.from_private_bytes(data)\n\n    def ed448_generate_key(self) -> ed448.Ed448PrivateKey:\n        return rust_openssl.ed448.generate_key()\n\n    def aead_cipher_supported(self, cipher) -> bool:\n        return aead._aead_cipher_supported(self, cipher)\n\n    def _zero_data(self, data, length: int) -> None:\n        # We clear things this way because at the moment we're not\n        # sure of a better way that can guarantee it overwrites the\n        # memory of a bytearray and doesn't just replace the underlying char *.\n        for i in range(length):\n            data[i] = 0\n\n    @contextlib.contextmanager\n    def _zeroed_null_terminated_buf(self, data):\n        \"\"\"\n        This method takes bytes, which can be a bytestring or a mutable\n        buffer like a bytearray, and yields a null-terminated version of that\n        data. This is required because PKCS12_parse doesn't take a length with\n        its password char * and ffi.from_buffer doesn't provide null\n        termination. So, to support zeroing the data via bytearray we\n        need to build this ridiculous construct that copies the memory, but\n        zeroes it after use.\n        \"\"\"\n        if data is None:\n            yield self._ffi.NULL\n        else:\n            data_len = len(data)\n            buf = self._ffi.new(\"char[]\", data_len + 1)\n            self._ffi.memmove(buf, data, data_len)\n            try:\n                yield buf\n            finally:\n                # Cast to a uint8_t * so we can assign by integer\n                self._zero_data(self._ffi.cast(\"uint8_t *\", buf), data_len)\n\n    def load_key_and_certificates_from_pkcs12(\n        self, data: bytes, password: typing.Optional[bytes]\n    ) -> typing.Tuple[\n        typing.Optional[PrivateKeyTypes],\n        typing.Optional[x509.Certificate],\n        typing.List[x509.Certificate],\n    ]:\n        pkcs12 = self.load_pkcs12(data, password)\n        return (\n            pkcs12.key,\n            pkcs12.cert.certificate if pkcs12.cert else None,\n            [cert.certificate for cert in pkcs12.additional_certs],\n        )\n\n    def load_pkcs12(\n        self, data: bytes, password: typing.Optional[bytes]\n    ) -> PKCS12KeyAndCertificates:\n        if password is not None:\n            utils._check_byteslike(\"password\", password)\n\n        bio = self._bytes_to_bio(data)\n        p12 = self._lib.d2i_PKCS12_bio(bio.bio, self._ffi.NULL)\n        if p12 == self._ffi.NULL:\n            self._consume_errors()\n            raise ValueError(\"Could not deserialize PKCS12 data\")\n\n        p12 = self._ffi.gc(p12, self._lib.PKCS12_free)\n        evp_pkey_ptr = self._ffi.new(\"EVP_PKEY **\")\n        x509_ptr = self._ffi.new(\"X509 **\")\n        sk_x509_ptr = self._ffi.new(\"Cryptography_STACK_OF_X509 **\")\n        with self._zeroed_null_terminated_buf(password) as password_buf:\n            res = self._lib.PKCS12_parse(\n                p12, password_buf, evp_pkey_ptr, x509_ptr, sk_x509_ptr\n            )\n        if res == 0:\n            self._consume_errors()\n            raise ValueError(\"Invalid password or PKCS12 data\")\n\n        cert = None\n        key = None\n        additional_certificates = []\n\n        if evp_pkey_ptr[0] != self._ffi.NULL:\n            evp_pkey = self._ffi.gc(evp_pkey_ptr[0], self._lib.EVP_PKEY_free)\n            # We don't support turning off RSA key validation when loading\n            # PKCS12 keys\n            key = self._evp_pkey_to_private_key(\n                evp_pkey, unsafe_skip_rsa_key_validation=False\n            )\n\n        if x509_ptr[0] != self._ffi.NULL:\n            x509 = self._ffi.gc(x509_ptr[0], self._lib.X509_free)\n            cert_obj = self._ossl2cert(x509)\n            name = None\n            maybe_name = self._lib.X509_alias_get0(x509, self._ffi.NULL)\n            if maybe_name != self._ffi.NULL:\n                name = self._ffi.string(maybe_name)\n            cert = PKCS12Certificate(cert_obj, name)\n\n        if sk_x509_ptr[0] != self._ffi.NULL:\n            sk_x509 = self._ffi.gc(sk_x509_ptr[0], self._lib.sk_X509_free)\n            num = self._lib.sk_X509_num(sk_x509_ptr[0])\n\n            # In OpenSSL < 3.0.0 PKCS12 parsing reverses the order of the\n            # certificates.\n            indices: typing.Iterable[int]\n            if (\n                self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n                or self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n            ):\n                indices = range(num)\n            else:\n                indices = reversed(range(num))\n\n            for i in indices:\n                x509 = self._lib.sk_X509_value(sk_x509, i)\n                self.openssl_assert(x509 != self._ffi.NULL)\n                x509 = self._ffi.gc(x509, self._lib.X509_free)\n                addl_cert = self._ossl2cert(x509)\n                addl_name = None\n                maybe_name = self._lib.X509_alias_get0(x509, self._ffi.NULL)\n                if maybe_name != self._ffi.NULL:\n                    addl_name = self._ffi.string(maybe_name)\n                additional_certificates.append(\n                    PKCS12Certificate(addl_cert, addl_name)\n                )\n\n        return PKCS12KeyAndCertificates(key, cert, additional_certificates)\n\n    def serialize_key_and_certificates_to_pkcs12(\n        self,\n        name: typing.Optional[bytes],\n        key: typing.Optional[PKCS12PrivateKeyTypes],\n        cert: typing.Optional[x509.Certificate],\n        cas: typing.Optional[typing.List[_PKCS12CATypes]],\n        encryption_algorithm: serialization.KeySerializationEncryption,\n    ) -> bytes:\n        password = None\n        if name is not None:\n            utils._check_bytes(\"name\", name)\n\n        if isinstance(encryption_algorithm, serialization.NoEncryption):\n            nid_cert = -1\n            nid_key = -1\n            pkcs12_iter = 0\n            mac_iter = 0\n            mac_alg = self._ffi.NULL\n        elif isinstance(\n            encryption_algorithm, serialization.BestAvailableEncryption\n        ):\n            # PKCS12 encryption is hopeless trash and can never be fixed.\n            # OpenSSL 3 supports PBESv2, but Libre and Boring do not, so\n            # we use PBESv1 with 3DES on the older paths.\n            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            # At least we can set this higher than OpenSSL's default\n            pkcs12_iter = 20000\n            # mac_iter chosen for compatibility reasons, see:\n            # https://www.openssl.org/docs/man1.1.1/man3/PKCS12_create.html\n            # Did we mention how lousy PKCS12 encryption is?\n            mac_iter = 1\n            # MAC algorithm can only be set on OpenSSL 3.0.0+\n            mac_alg = self._ffi.NULL\n            password = encryption_algorithm.password\n        elif (\n            isinstance(\n                encryption_algorithm, serialization._KeySerializationEncryption\n            )\n            and encryption_algorithm._format\n            is serialization.PrivateFormat.PKCS12\n        ):\n            # Default to OpenSSL's defaults. Behavior will vary based on the\n            # version of OpenSSL cryptography is compiled against.\n            nid_cert = 0\n            nid_key = 0\n            # Use the default iters we use in best available\n            pkcs12_iter = 20000\n            # See the Best Available comment for why this is 1\n            mac_iter = 1\n            password = encryption_algorithm.password\n            keycertalg = encryption_algorithm._key_cert_algorithm\n            if keycertalg is PBES.PBESv1SHA1And3KeyTripleDESCBC:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            elif keycertalg is PBES.PBESv2SHA256AndAES256CBC:\n                if not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                    raise UnsupportedAlgorithm(\n                        \"PBESv2 is not supported by this version of OpenSSL\"\n                    )\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                assert keycertalg is None\n                # We use OpenSSL's defaults\n\n            if encryption_algorithm._hmac_hash is not None:\n                if not self._lib.Cryptography_HAS_PKCS12_SET_MAC:\n                    raise UnsupportedAlgorithm(\n                        \"Setting MAC algorithm is not supported by this \"\n                        \"version of OpenSSL.\"\n                    )\n                mac_alg = self._evp_md_non_null_from_algorithm(\n                    encryption_algorithm._hmac_hash\n                )\n                self.openssl_assert(mac_alg != self._ffi.NULL)\n            else:\n                mac_alg = self._ffi.NULL\n\n            if encryption_algorithm._kdf_rounds is not None:\n                pkcs12_iter = encryption_algorithm._kdf_rounds\n\n        else:\n            raise ValueError(\"Unsupported key encryption type\")\n\n        if cas is None or len(cas) == 0:\n            sk_x509 = self._ffi.NULL\n        else:\n            sk_x509 = self._lib.sk_X509_new_null()\n            sk_x509 = self._ffi.gc(sk_x509, self._lib.sk_X509_free)\n\n            # This list is to keep the x509 values alive until end of function\n            ossl_cas = []\n            for ca in cas:\n                if isinstance(ca, PKCS12Certificate):\n                    ca_alias = ca.friendly_name\n                    ossl_ca = self._cert2ossl(ca.certificate)\n                    if ca_alias is None:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, self._ffi.NULL, -1\n                        )\n                    else:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, ca_alias, len(ca_alias)\n                        )\n                    self.openssl_assert(res == 1)\n                else:\n                    ossl_ca = self._cert2ossl(ca)\n                ossl_cas.append(ossl_ca)\n                res = self._lib.sk_X509_push(sk_x509, ossl_ca)\n                backend.openssl_assert(res >= 1)\n\n        with self._zeroed_null_terminated_buf(password) as password_buf:\n            with self._zeroed_null_terminated_buf(name) as name_buf:\n                ossl_cert = self._cert2ossl(cert) if cert else self._ffi.NULL\n                ossl_pkey = (\n                    self._key2ossl(key) if key is not None else self._ffi.NULL\n                )\n\n                p12 = self._lib.PKCS12_create(\n                    password_buf,\n                    name_buf,\n                    ossl_pkey,\n                    ossl_cert,\n                    sk_x509,\n                    nid_key,\n                    nid_cert,\n                    pkcs12_iter,\n                    mac_iter,\n                    0,\n                )\n\n            if (\n                self._lib.Cryptography_HAS_PKCS12_SET_MAC\n                and mac_alg != self._ffi.NULL\n            ):\n                self._lib.PKCS12_set_mac(\n                    p12,\n                    password_buf,\n                    -1,\n                    self._ffi.NULL,\n                    0,\n                    mac_iter,\n                    mac_alg,\n                )\n\n        self.openssl_assert(p12 != self._ffi.NULL)\n        p12 = self._ffi.gc(p12, self._lib.PKCS12_free)\n\n        bio = self._create_mem_bio_gc()\n        res = self._lib.i2d_PKCS12_bio(bio, p12)\n        self.openssl_assert(res > 0)\n        return self._read_mem_bio(bio)\n\n    def poly1305_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return self._lib.Cryptography_HAS_POLY1305 == 1\n\n    def pkcs7_supported(self) -> bool:\n        return not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n\n    def load_pem_pkcs7_certificates(\n        self, data: bytes\n    ) -> typing.List[x509.Certificate]:\n        utils._check_bytes(\"data\", data)\n        bio = self._bytes_to_bio(data)\n        p7 = self._lib.PEM_read_bio_PKCS7(\n            bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL\n        )\n        if p7 == self._ffi.NULL:\n            self._consume_errors()\n            raise ValueError(\"Unable to parse PKCS7 data\")\n\n        p7 = self._ffi.gc(p7, self._lib.PKCS7_free)\n        return self._load_pkcs7_certificates(p7)\n\n    def load_der_pkcs7_certificates(\n        self, data: bytes\n    ) -> typing.List[x509.Certificate]:\n        utils._check_bytes(\"data\", data)\n        bio = self._bytes_to_bio(data)\n        p7 = self._lib.d2i_PKCS7_bio(bio.bio, self._ffi.NULL)\n        if p7 == self._ffi.NULL:\n            self._consume_errors()\n            raise ValueError(\"Unable to parse PKCS7 data\")\n\n        p7 = self._ffi.gc(p7, self._lib.PKCS7_free)\n        return self._load_pkcs7_certificates(p7)\n\n    def _load_pkcs7_certificates(self, p7) -> typing.List[x509.Certificate]:\n        nid = self._lib.OBJ_obj2nid(p7.type)\n        self.openssl_assert(nid != self._lib.NID_undef)\n        if nid != self._lib.NID_pkcs7_signed:\n            raise UnsupportedAlgorithm(\n                \"Only basic signed structures are currently supported. NID\"\n                \" for this data was {}\".format(nid),\n                _Reasons.UNSUPPORTED_SERIALIZATION,\n            )\n\n        sk_x509 = p7.d.sign.cert\n        num = self._lib.sk_X509_num(sk_x509)\n        certs = []\n        for i in range(num):\n            x509 = self._lib.sk_X509_value(sk_x509, i)\n            self.openssl_assert(x509 != self._ffi.NULL)\n            cert = self._ossl2cert(x509)\n            certs.append(cert)\n\n        return certs\n\n\nclass GetCipherByName:\n    def __init__(self, fmt: str):\n        self._fmt = fmt\n\n    def __call__(self, backend: Backend, cipher: CipherAlgorithm, mode: Mode):\n        cipher_name = self._fmt.format(cipher=cipher, mode=mode).lower()\n        evp_cipher = backend._lib.EVP_get_cipherbyname(\n            cipher_name.encode(\"ascii\")\n        )\n\n        # try EVP_CIPHER_fetch if present\n        if (\n            evp_cipher == backend._ffi.NULL\n            and backend._lib.Cryptography_HAS_300_EVP_CIPHER\n        ):\n            evp_cipher = backend._lib.EVP_CIPHER_fetch(\n                backend._ffi.NULL,\n                cipher_name.encode(\"ascii\"),\n                backend._ffi.NULL,\n            )\n\n        backend._consume_errors()\n        return evp_cipher\n\n\ndef _get_xts_cipher(backend: Backend, cipher: AES, mode):\n    cipher_name = f\"aes-{cipher.key_size // 2}-xts\"\n    return backend._lib.EVP_get_cipherbyname(cipher_name.encode(\"ascii\"))\n\n\nbackend = Backend()\n", "// This file is dual licensed under the terms of the Apache License, Version\n// 2.0, and the BSD License. See the LICENSE file in the root of this repository\n// for complete details.\n\n#![deny(rust_2018_idioms)]\n\nmod asn1;\nmod backend;\nmod buf;\nmod error;\nmod exceptions;\npub(crate) mod oid;\nmod pkcs7;\nmod pool;\nmod x509;\n\n/// Returns the value of the input with the most-significant-bit copied to all\n/// of the bits.\nfn duplicate_msb_to_all(a: u8) -> u8 {\n    0u8.wrapping_sub(a >> 7)\n}\n\n/// This returns 0xFF if a < b else 0x00, but does so in a constant time\n/// fashion.\nfn constant_time_lt(a: u8, b: u8) -> u8 {\n    // Derived from:\n    // https://github.com/openssl/openssl/blob/OpenSSL_1_1_1i/include/internal/constant_time.h#L120\n    duplicate_msb_to_all(a ^ ((a ^ b) | (a.wrapping_sub(b) ^ b)))\n}\n\n#[pyo3::prelude::pyfunction]\nfn check_pkcs7_padding(data: &[u8]) -> bool {\n    let mut mismatch = 0;\n    let pad_size = *data.last().unwrap();\n    let len: u8 = data.len().try_into().expect(\"data too long\");\n    for (i, b) in (0..len).zip(data.iter().rev()) {\n        let mask = constant_time_lt(i, pad_size);\n        mismatch |= mask & (pad_size ^ b);\n    }\n\n    // Check to make sure the pad_size was within the valid range.\n    mismatch |= !constant_time_lt(0, pad_size);\n    mismatch |= constant_time_lt(len, pad_size);\n\n    // Make sure any bits set are copied to the lowest bit\n    mismatch |= mismatch >> 4;\n    mismatch |= mismatch >> 2;\n    mismatch |= mismatch >> 1;\n\n    // Now check the low bit to see if it's set\n    (mismatch & 1) == 0\n}\n\n#[pyo3::prelude::pyfunction]\nfn check_ansix923_padding(data: &[u8]) -> bool {\n    let mut mismatch = 0;\n    let pad_size = *data.last().unwrap();\n    let len: u8 = data.len().try_into().expect(\"data too long\");\n    // Skip the first one with the pad size\n    for (i, b) in (1..len).zip(data[..data.len() - 1].iter().rev()) {\n        let mask = constant_time_lt(i, pad_size);\n        mismatch |= mask & b;\n    }\n\n    // Check to make sure the pad_size was within the valid range.\n    mismatch |= !constant_time_lt(0, pad_size);\n    mismatch |= constant_time_lt(len, pad_size);\n\n    // Make sure any bits set are copied to the lowest bit\n    mismatch |= mismatch >> 4;\n    mismatch |= mismatch >> 2;\n    mismatch |= mismatch >> 1;\n\n    // Now check the low bit to see if it's set\n    (mismatch & 1) == 0\n}\n\n#[pyo3::prelude::pyfunction]\nfn openssl_version() -> i64 {\n    openssl::version::number()\n}\n\n#[pyo3::prelude::pyfunction]\nfn raise_openssl_error() -> crate::error::CryptographyResult<()> {\n    Err(openssl::error::ErrorStack::get().into())\n}\n\n#[pyo3::prelude::pyclass(module = \"cryptography.hazmat.bindings._rust.openssl\")]\nstruct OpenSSLError {\n    e: openssl::error::Error,\n}\n\n#[pyo3::pymethods]\nimpl OpenSSLError {\n    #[getter]\n    fn lib(&self) -> i32 {\n        self.e.library_code()\n    }\n\n    #[getter]\n    fn reason(&self) -> i32 {\n        self.e.reason_code()\n    }\n\n    #[getter]\n    fn reason_text(&self) -> &[u8] {\n        self.e.reason().unwrap_or(\"\").as_bytes()\n    }\n\n    fn _lib_reason_match(&self, lib: i32, reason: i32) -> bool {\n        self.e.library_code() == lib && self.e.reason_code() == reason\n    }\n\n    fn __repr__(&self) -> pyo3::PyResult<String> {\n        Ok(format!(\n            \"<OpenSSLError(code={}, lib={}, reason={}, reason_text={})>\",\n            self.e.code(),\n            self.e.library_code(),\n            self.e.reason_code(),\n            self.e.reason().unwrap_or(\"\")\n        ))\n    }\n}\n\n#[pyo3::prelude::pyfunction]\nfn capture_error_stack(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::types::PyList> {\n    let errs = pyo3::types::PyList::empty(py);\n    for e in openssl::error::ErrorStack::get().errors() {\n        errs.append(pyo3::PyCell::new(py, OpenSSLError { e: e.clone() })?)?;\n    }\n    Ok(errs)\n}\n\n#[pyo3::prelude::pyfunction]\nfn is_fips_enabled() -> bool {\n    cryptography_openssl::fips::is_enabled()\n}\n\n#[pyo3::prelude::pymodule]\nfn _rust(py: pyo3::Python<'_>, m: &pyo3::types::PyModule) -> pyo3::PyResult<()> {\n    m.add_function(pyo3::wrap_pyfunction!(check_pkcs7_padding, m)?)?;\n    m.add_function(pyo3::wrap_pyfunction!(check_ansix923_padding, m)?)?;\n    m.add_class::<oid::ObjectIdentifier>()?;\n    m.add_class::<pool::FixedPool>()?;\n\n    m.add_submodule(asn1::create_submodule(py)?)?;\n    m.add_submodule(pkcs7::create_submodule(py)?)?;\n    m.add_submodule(exceptions::create_submodule(py)?)?;\n\n    let x509_mod = pyo3::prelude::PyModule::new(py, \"x509\")?;\n    crate::x509::certificate::add_to_module(x509_mod)?;\n    crate::x509::common::add_to_module(x509_mod)?;\n    crate::x509::crl::add_to_module(x509_mod)?;\n    crate::x509::csr::add_to_module(x509_mod)?;\n    crate::x509::sct::add_to_module(x509_mod)?;\n    m.add_submodule(x509_mod)?;\n\n    let ocsp_mod = pyo3::prelude::PyModule::new(py, \"ocsp\")?;\n    crate::x509::ocsp_req::add_to_module(ocsp_mod)?;\n    crate::x509::ocsp_resp::add_to_module(ocsp_mod)?;\n    m.add_submodule(ocsp_mod)?;\n\n    m.add_submodule(cryptography_cffi::create_module(py)?)?;\n\n    let openssl_mod = pyo3::prelude::PyModule::new(py, \"openssl\")?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(openssl_version, m)?)?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(raise_openssl_error, m)?)?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(capture_error_stack, m)?)?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(is_fips_enabled, m)?)?;\n    openssl_mod.add_class::<OpenSSLError>()?;\n    crate::backend::add_to_module(openssl_mod)?;\n    m.add_submodule(openssl_mod)?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::constant_time_lt;\n\n    #[test]\n    fn test_constant_time_lt() {\n        for a in 0..=255 {\n            for b in 0..=255 {\n                let expected = if a < b { 0xff } else { 0 };\n                assert_eq!(constant_time_lt(a, b), expected);\n            }\n        }\n    }\n}\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport email.parser\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.exceptions import _Reasons\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ed25519, rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs7\n\nfrom ...utils import load_vectors_from_file, raises_unsupported_algorithm\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7Loading:\n    def test_load_invalid_der_pkcs7(self, backend):\n        with pytest.raises(ValueError):\n            pkcs7.load_der_pkcs7_certificates(b\"nonsense\")\n\n    def test_load_invalid_pem_pkcs7(self, backend):\n        with pytest.raises(ValueError):\n            pkcs7.load_pem_pkcs7_certificates(b\"nonsense\")\n\n    def test_not_bytes_der(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.load_der_pkcs7_certificates(38)  # type: ignore[arg-type]\n\n    def test_not_bytes_pem(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.load_pem_pkcs7_certificates(38)  # type: ignore[arg-type]\n\n    def test_load_pkcs7_pem(self, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"isrg.pem\"),\n            lambda pemfile: pkcs7.load_pem_pkcs7_certificates(pemfile.read()),\n            mode=\"rb\",\n        )\n        assert len(certs) == 1\n        assert certs[0].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, \"ISRG Root X1\")]\n\n    @pytest.mark.parametrize(\n        \"filepath\",\n        [\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            os.path.join(\"pkcs7\", \"amazon-roots.p7b\"),\n        ],\n    )\n    def test_load_pkcs7_der(self, filepath, backend):\n        certs = load_vectors_from_file(\n            filepath,\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        assert len(certs) == 2\n        assert certs[0].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [\n            x509.NameAttribute(\n                x509.oid.NameOID.COMMON_NAME, \"Amazon Root CA 3\"\n            )\n        ]\n        assert certs[1].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [\n            x509.NameAttribute(\n                x509.oid.NameOID.COMMON_NAME, \"Amazon Root CA 2\"\n            )\n        ]\n\n    def test_load_pkcs7_unsupported_type(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):\n            load_vectors_from_file(\n                os.path.join(\"pkcs7\", \"enveloped.pem\"),\n                lambda pemfile: pkcs7.load_pem_pkcs7_certificates(\n                    pemfile.read()\n                ),\n                mode=\"rb\",\n            )\n\n\n# We have no public verification API and won't be adding one until we get\n# some requirements from users so this function exists to give us basic\n# verification for the signing tests.\ndef _pkcs7_verify(encoding, sig, msg, certs, options, backend):\n    sig_bio = backend._bytes_to_bio(sig)\n    if encoding is serialization.Encoding.DER:\n        p7 = backend._lib.d2i_PKCS7_bio(sig_bio.bio, backend._ffi.NULL)\n    elif encoding is serialization.Encoding.PEM:\n        p7 = backend._lib.PEM_read_bio_PKCS7(\n            sig_bio.bio,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n        )\n    else:\n        p7 = backend._lib.SMIME_read_PKCS7(sig_bio.bio, backend._ffi.NULL)\n    backend.openssl_assert(p7 != backend._ffi.NULL)\n    p7 = backend._ffi.gc(p7, backend._lib.PKCS7_free)\n    flags = 0\n    for option in options:\n        if option is pkcs7.PKCS7Options.Text:\n            flags |= backend._lib.PKCS7_TEXT\n    store = backend._lib.X509_STORE_new()\n    backend.openssl_assert(store != backend._ffi.NULL)\n    store = backend._ffi.gc(store, backend._lib.X509_STORE_free)\n    # This list is to keep the x509 values alive until end of function\n    ossl_certs = []\n    for cert in certs:\n        ossl_cert = backend._cert2ossl(cert)\n        ossl_certs.append(ossl_cert)\n        res = backend._lib.X509_STORE_add_cert(store, ossl_cert)\n        backend.openssl_assert(res == 1)\n    if msg is None:\n        res = backend._lib.PKCS7_verify(\n            p7,\n            backend._ffi.NULL,\n            store,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n            flags,\n        )\n    else:\n        msg_bio = backend._bytes_to_bio(msg)\n        # libressl 3.7.0 has a bug when NULL is passed as an `out_bio`. Work\n        # around it for now.\n        out_bio = backend._create_mem_bio_gc()\n        res = backend._lib.PKCS7_verify(\n            p7, backend._ffi.NULL, store, msg_bio.bio, out_bio, flags\n        )\n    backend.openssl_assert(res == 1)\n    # OpenSSL 3.0 leaves a random bio error on the stack:\n    # https://github.com/openssl/openssl/issues/16681\n    if backend._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n        backend._consume_errors()\n\n\ndef _load_cert_key():\n    key = load_vectors_from_file(\n        os.path.join(\"x509\", \"custom\", \"ca\", \"ca_key.pem\"),\n        lambda pemfile: serialization.load_pem_private_key(\n            pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n        ),\n        mode=\"rb\",\n    )\n    cert = load_vectors_from_file(\n        os.path.join(\"x509\", \"custom\", \"ca\", \"ca.pem\"),\n        loader=lambda pemfile: x509.load_pem_x509_certificate(pemfile.read()),\n        mode=\"rb\",\n    )\n    return cert, key\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7Builder:\n    def test_invalid_data(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder()\n        with pytest.raises(TypeError):\n            builder.set_data(\"not bytes\")  # type: ignore[arg-type]\n\n    def test_set_data_twice(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder().set_data(b\"test\")\n        with pytest.raises(ValueError):\n            builder.set_data(b\"test\")\n\n    def test_sign_no_signer(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder().set_data(b\"test\")\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, [])\n\n    def test_sign_no_data(self, backend):\n        cert, key = _load_cert_key()\n        builder = pkcs7.PKCS7SignatureBuilder().add_signer(\n            cert, key, hashes.SHA256()\n        )\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, [])\n\n    def test_unsupported_hash_alg(self, backend):\n        cert, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert, key, hashes.SHA512_256()  # type: ignore[arg-type]\n            )\n\n    def test_not_a_cert(self, backend):\n        cert, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                b\"notacert\", key, hashes.SHA256()  # type: ignore[arg-type]\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Does not support ed25519.\",\n    )\n    def test_unsupported_key_type(self, backend):\n        cert, _ = _load_cert_key()\n        key = ed25519.Ed25519PrivateKey.generate()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert, key, hashes.SHA256()  # type: ignore[arg-type]\n            )\n\n    def test_sign_invalid_options(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        with pytest.raises(ValueError):\n            builder.sign(\n                serialization.Encoding.SMIME,\n                [b\"invalid\"],  # type: ignore[list-item]\n            )\n\n    def test_sign_invalid_encoding(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.Raw, [])\n\n    def test_sign_invalid_options_text_no_detached(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [pkcs7.PKCS7Options.Text]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, options)\n\n    def test_sign_invalid_options_text_der_encoding(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [\n            pkcs7.PKCS7Options.Text,\n            pkcs7.PKCS7Options.DetachedSignature,\n        ]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.DER, options)\n\n    def test_sign_invalid_options_no_attrs_and_no_caps(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [\n            pkcs7.PKCS7Options.NoAttributes,\n            pkcs7.PKCS7Options.NoCapabilities,\n        ]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, options)\n\n    def test_smime_sign_detached(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        assert b\"text/plain\" not in sig\n        # We don't have a generic ASN.1 parser available to us so we instead\n        # will assert on specific byte sequences being present based on the\n        # parameters chosen above.\n        assert b\"sha-256\" in sig\n        # Detached signature means that the signed data is *not* embedded into\n        # the PKCS7 structure itself, but is present in the SMIME serialization\n        # as a separate section before the PKCS7 data. So we should expect to\n        # have data in sig but not in sig_binary\n        assert data in sig\n        # Parse the message to get the signed data, which is the\n        # first payload in the message\n        message = email.parser.BytesParser().parsebytes(sig)\n        signed_data = message.get_payload()[0].get_payload().encode()\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            signed_data,\n            [cert],\n            options,\n            backend,\n        )\n        assert data not in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_byteslike(self, backend):\n        data = bytearray(b\"hello world\")\n        cert, key = _load_cert_key()\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        assert bytes(data) in sig\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n        data = bytearray(b\"\")\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_pem(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options: typing.List[pkcs7.PKCS7Options] = []\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.PEM, options)\n        _pkcs7_verify(\n            serialization.Encoding.PEM,\n            sig,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    @pytest.mark.parametrize(\n        (\"hash_alg\", \"expected_value\"),\n        [\n            (hashes.SHA256(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x01\"),\n            (hashes.SHA384(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x02\"),\n            (hashes.SHA512(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\"),\n        ],\n    )\n    def test_sign_alternate_digests_der(\n        self, hash_alg, expected_value, backend\n    ):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hash_alg)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert expected_value in sig\n        _pkcs7_verify(\n            serialization.Encoding.DER, sig, None, [cert], options, backend\n        )\n\n    @pytest.mark.parametrize(\n        (\"hash_alg\", \"expected_value\"),\n        [\n            (hashes.SHA256(), b\"sha-256\"),\n            (hashes.SHA384(), b\"sha-384\"),\n            (hashes.SHA512(), b\"sha-512\"),\n        ],\n    )\n    def test_sign_alternate_digests_detached(\n        self, hash_alg, expected_value, backend\n    ):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hash_alg)\n        )\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        # When in detached signature mode the hash algorithm is stored as a\n        # byte string like \"sha-384\".\n        assert expected_value in sig\n\n    def test_sign_attached(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options: typing.List[pkcs7.PKCS7Options] = []\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # When not passing detached signature the signed data is embedded into\n        # the PKCS7 structure itself\n        assert data in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_binary(self, backend):\n        data = b\"hello\\nworld\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig_no_binary = builder.sign(serialization.Encoding.DER, options)\n        sig_binary = builder.sign(\n            serialization.Encoding.DER, [pkcs7.PKCS7Options.Binary]\n        )\n        # Binary prevents translation of LF to CR+LF (SMIME canonical form)\n        # so data should not be present in sig_no_binary, but should be present\n        # in sig_binary\n        assert data not in sig_no_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_no_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n        assert data in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_smime_canonicalization(self, backend):\n        data = b\"hello\\nworld\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # LF gets converted to CR+LF (SMIME canonical form)\n        # so data should not be present in the sig\n        assert data not in sig_binary\n        assert b\"hello\\r\\nworld\" in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_text(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [\n            pkcs7.PKCS7Options.Text,\n            pkcs7.PKCS7Options.DetachedSignature,\n        ]\n        sig_pem = builder.sign(serialization.Encoding.SMIME, options)\n        # The text option adds text/plain headers to the S/MIME message\n        # These headers are only relevant in SMIME mode, not binary, which is\n        # just the PKCS7 structure itself.\n        assert sig_pem.count(b\"text/plain\") == 1\n        assert b\"Content-Type: text/plain\\r\\n\\r\\nhello world\\r\\n\" in sig_pem\n        # Parse the message to get the signed data, which is the\n        # first payload in the message\n        message = email.parser.BytesParser().parsebytes(sig_pem)\n        signed_data = message.get_payload()[0].as_bytes(\n            policy=message.policy.clone(linesep=\"\\r\\n\")\n        )\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig_pem,\n            signed_data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_capabilities(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [pkcs7.PKCS7Options.NoCapabilities]\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # NoCapabilities removes the SMIMECapabilities attribute from the\n        # PKCS7 structure. This is an ASN.1 sequence with the\n        # OID 1.2.840.113549.1.9.15. It does NOT remove all authenticated\n        # attributes, so we verify that by looking for the signingTime OID.\n\n        # 1.2.840.113549.1.9.15 SMIMECapabilities as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" not in sig_binary\n        # 1.2.840.113549.1.9.5 signingTime as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x05\" in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_attributes(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [pkcs7.PKCS7Options.NoAttributes]\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # NoAttributes removes all authenticated attributes, so we shouldn't\n        # find SMIMECapabilities or signingTime.\n\n        # 1.2.840.113549.1.9.15 SMIMECapabilities as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" not in sig_binary\n        # 1.2.840.113549.1.9.5 signingTime as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x05\" not in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_certs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert sig.count(cert.public_bytes(serialization.Encoding.DER)) == 1\n\n        options = [pkcs7.PKCS7Options.NoCerts]\n        sig_no = builder.sign(serialization.Encoding.DER, options)\n        assert sig_no.count(cert.public_bytes(serialization.Encoding.DER)) == 0\n\n    def test_multiple_signers(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA512())\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # There should be three SHA512 OIDs in this structure\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 3\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig,\n            None,\n            [cert, rsa_cert],\n            options,\n            backend,\n        )\n\n    def test_multiple_signers_different_hash_algs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # There should be two SHA384 and two SHA512 OIDs in this structure\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x02\") == 2\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 2\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig,\n            None,\n            [cert, rsa_cert],\n            options,\n            backend,\n        )\n\n    def test_add_additional_cert_not_a_cert(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_certificate(\n                b\"notacert\"  # type: ignore[arg-type]\n            )\n\n    def test_add_additional_cert(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_certificate(rsa_cert)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert (\n            sig.count(rsa_cert.public_bytes(serialization.Encoding.DER)) == 1\n        )\n\n    def test_add_multiple_additional_certs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_certificate(rsa_cert)\n            .add_certificate(rsa_cert)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert (\n            sig.count(rsa_cert.public_bytes(serialization.Encoding.DER)) == 2\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7SerializeCerts:\n    @pytest.mark.parametrize(\n        (\"encoding\", \"loader\"),\n        [\n            (serialization.Encoding.PEM, pkcs7.load_pem_pkcs7_certificates),\n            (serialization.Encoding.DER, pkcs7.load_der_pkcs7_certificates),\n        ],\n    )\n    def test_roundtrip(self, encoding, loader, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        p7 = pkcs7.serialize_certificates(certs, encoding)\n        certs2 = loader(p7)\n        assert certs == certs2\n\n    def test_ordering(self, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        p7 = pkcs7.serialize_certificates(\n            list(reversed(certs)), serialization.Encoding.DER\n        )\n        certs2 = pkcs7.load_der_pkcs7_certificates(p7)\n        assert certs == certs2\n\n    def test_pem_matches_vector(self, backend):\n        p7_pem = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"isrg.pem\"),\n            lambda p: p.read(),\n            mode=\"rb\",\n        )\n        certs = pkcs7.load_pem_pkcs7_certificates(p7_pem)\n        p7 = pkcs7.serialize_certificates(certs, serialization.Encoding.PEM)\n        assert p7 == p7_pem\n\n    def test_der_matches_vector(self, backend):\n        p7_der = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda p: p.read(),\n            mode=\"rb\",\n        )\n        certs = pkcs7.load_der_pkcs7_certificates(p7_der)\n        p7 = pkcs7.serialize_certificates(certs, serialization.Encoding.DER)\n        assert p7 == p7_der\n\n    def test_invalid_types(self):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates(\n                object(),  # type: ignore[arg-type]\n                serialization.Encoding.PEM,\n            )\n\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates([], serialization.Encoding.PEM)\n\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates(\n                certs, \"not an encoding\"  # type: ignore[arg-type]\n            )\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__all__ = [\n    \"__version__\",\n]\n\n__version__ = \"41.0.5\"\n", "[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cryptography_vectors\"\nversion = \"41.0.5\"\nauthors = [\n    {name = \"The Python Cryptographic Authority and individual contributors\", email = \"cryptography-dev@python.org\"}\n]\ndescription = \"Test vectors for the cryptography package.\"\nlicense = {text = \"Apache-2.0 OR BSD-3-Clause\"}\n\n[project.urls]\nhomepage = \"https://github.com/pyca/cryptography\"\n\n[tool.setuptools]\nzip-safe = false\ninclude-package-data = true\n\n[tool.distutils.bdist_wheel]\nuniversal = true\n"], "fixing_code": ["Changelog\n=========\n\n.. _v41-0-6:\n\n41.0.6 - 2023-11-27\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed a null-pointer-dereference and segfault that could occur when loading\n  certificates from a PKCS#7 bundle.  Credit to **pkuzco** for reporting the\n  issue. **CVE-2023-49083**\n\n.. _v41-0-5:\n\n41.0.5 - 2023-10-24\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.4.\n* Added a function to support an upcoming ``pyOpenSSL`` release.\n\n.. _v41-0-4:\n\n41.0.4 - 2023-09-19\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.3.\n\n.. _v41-0-3:\n\n41.0.3 - 2023-08-01\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed performance regression loading DH public keys.\n* Fixed a memory leak when using\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`.\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.2.\n\n.. _v41-0-2:\n\n41.0.2 - 2023-07-10\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed bugs in creating and parsing SSH certificates where critical options\n  with values were handled incorrectly. Certificates are now created correctly\n  and parsing accepts correct values as well as the previously generated\n  invalid forms with a warning. In the next release, support for parsing these\n  invalid forms will be removed.\n\n.. _v41-0-1:\n\n41.0.1 - 2023-06-01\n~~~~~~~~~~~~~~~~~~~\n\n* Temporarily allow invalid ECDSA signature algorithm parameters in X.509\n  certificates, which are generated by older versions of Java.\n* Allow null bytes in pass phrases when serializing private keys.\n\n.. _v41-0-0:\n\n41.0.0 - 2023-05-30\n~~~~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL less than 1.1.1d has been\n  removed.  Users on older version of OpenSSL will need to upgrade.\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.6 has been removed.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL < 3.6.\n* Updated the minimum supported Rust version (MSRV) to 1.56.0, from 1.48.0.\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.1.\n* Added support for the :class:`~cryptography.x509.OCSPAcceptableResponses`\n  OCSP extension.\n* Added support for the :class:`~cryptography.x509.MSCertificateTemplate`\n  proprietary Microsoft certificate extension.\n* Implemented support for equality checks on all asymmetric public key types.\n* Added support for ``aes256-gcm@openssh.com`` encrypted keys in\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_private_key`.\n* Added support for obtaining X.509 certificate signature algorithm parameters\n  (including PSS) via\n  :meth:`~cryptography.x509.Certificate.signature_algorithm_parameters`.\n* Support signing :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`\n  X.509 certificates via the new keyword-only argument ``rsa_padding`` on\n  :meth:`~cryptography.x509.CertificateBuilder.sign`.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`\n  on BoringSSL.\n\n.. _v40-0-2:\n\n40.0.2 - 2023-04-14\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed compilation when using LibreSSL 3.7.2.\n* Added some functions to support an upcoming ``pyOpenSSL`` release.\n\n.. _v40-0-1:\n\n40.0.1 - 2023-03-24\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed a bug where certain operations would fail if an object happened to be\n  in the top-half of the memory-space. This only impacted 32-bit systems.\n\n.. _v40-0-0:\n\n40.0.0 - 2023-03-24\n~~~~~~~~~~~~~~~~~~~\n\n\n* **BACKWARDS INCOMPATIBLE:** As announced in the 39.0.0 changelog, the way\n  ``cryptography`` links OpenSSL has changed. This only impacts users who\n  build ``cryptography`` from source (i.e., not from a ``wheel``), and\n  specify their own version of OpenSSL. For those users, the ``CFLAGS``,\n  ``LDFLAGS``, ``INCLUDE``, ``LIB``, and ``CRYPTOGRAPHY_SUPPRESS_LINK_FLAGS``\n  environment variables are no longer valid. Instead, users need to configure\n  their builds `as documented here`_.\n* Support for Python 3.6 is deprecated and will be removed in the next\n  release.\n* Deprecated the current minimum supported Rust version (MSRV) of 1.48.0.\n  In the next release we will raise MSRV to 1.56.0. Users with the latest\n  ``pip`` will typically get a wheel and not need Rust installed, but check\n  :doc:`/installation` for documentation on installing a newer ``rustc`` if\n  required.\n* Deprecated support for OpenSSL less than 1.1.1d. The next release of\n  ``cryptography`` will drop support for older versions.\n* Deprecated support for DSA keys in\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_private_key`.\n* Deprecated support for OpenSSH serialization in\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`.\n* The minimum supported version of PyPy3 is now 7.3.10.\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.1.0.\n* Added support for parsing SSH certificates in addition to public keys with\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_identity`.\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key`\n  continues to support only public keys.\n* Added support for generating SSH certificates with\n  :class:`~cryptography.hazmat.primitives.serialization.SSHCertificateBuilder`.\n* Added :meth:`~cryptography.x509.Certificate.verify_directly_issued_by` to\n  :class:`~cryptography.x509.Certificate`.\n* Added a check to :class:`~cryptography.x509.NameConstraints` to ensure that\n  :class:`~cryptography.x509.DNSName` constraints do not contain any ``*``\n  wildcards.\n* Removed many unused CFFI OpenSSL bindings. This will not impact you unless\n  you are using ``cryptography`` to directly invoke OpenSSL's C API. Note that\n  these have never been considered a stable, supported, public API by\n  ``cryptography``, this note is included as a courtesy.\n* The X.509 builder classes now raise ``UnsupportedAlgorithm`` instead of\n  ``ValueError`` if an unsupported hash algorithm is passed.\n* Added public union type aliases for type hinting:\n\n  * Asymmetric types:\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.PublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.PrivateKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.CertificatePublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.CertificateIssuerPublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.asymmetric.types.CertificateIssuerPrivateKeyTypes`.\n  * SSH keys:\n    :const:`~cryptography.hazmat.primitives.serialization.SSHPublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.SSHPrivateKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.SSHCertPublicKeyTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.SSHCertPrivateKeyTypes`.\n  * PKCS12:\n    :const:`~cryptography.hazmat.primitives.serialization.pkcs12.PKCS12PrivateKeyTypes`\n  * PKCS7:\n    :const:`~cryptography.hazmat.primitives.serialization.pkcs7.PKCS7HashTypes`,\n    :const:`~cryptography.hazmat.primitives.serialization.pkcs7.PKCS7PrivateKeyTypes`.\n  * Two-factor:\n    :const:`~cryptography.hazmat.primitives.twofactor.hotp.HOTPHashTypes`\n\n* Deprecated previously undocumented but not private type aliases in the\n  ``cryptography.hazmat.primitives.asymmetric.types`` module in favor of new\n  ones above.\n\n\n.. _v39-0-2:\n\n\n39.0.2 - 2023-03-02\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed a bug where the content type header was not properly encoded for\n  PKCS7 signatures when using the ``Text`` option and ``SMIME`` encoding.\n\n\n.. _v39-0-1:\n\n39.0.1 - 2023-02-07\n~~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE** - Fixed a bug where ``Cipher.update_into`` accepted Python\n  buffer protocol objects, but allowed immutable buffers. **CVE-2023-23931**\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.8.\n\n.. _v39-0-0:\n\n39.0.0 - 2023-01-01\n~~~~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL 1.1.0 has been removed.\n  Users on older version of OpenSSL will need to upgrade.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL < 3.5. The new\n  minimum LibreSSL version is 3.5.0. Going forward our policy is to support\n  versions of LibreSSL that are available in versions of OpenBSD that are\n  still receiving security support.\n* **BACKWARDS INCOMPATIBLE:** Removed the ``encode_point`` and\n  ``from_encoded_point`` methods on\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers`,\n  which had been deprecated for several years.\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.public_bytes`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.from_encoded_point`\n  should be used instead.\n* **BACKWARDS INCOMPATIBLE:** Support for using MD5 or SHA1 in\n  :class:`~cryptography.x509.CertificateBuilder`, other X.509 builders, and\n  PKCS7 has been removed.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.10 and 10.11, macOS\n  users must upgrade to 10.12 or newer.\n* **ANNOUNCEMENT:** The next version of ``cryptography`` (40.0) will change\n  the way we link OpenSSL. This will only impact users who build\n  ``cryptography`` from source (i.e., not from a ``wheel``), and specify their\n  own version of OpenSSL. For those users, the ``CFLAGS``, ``LDFLAGS``,\n  ``INCLUDE``, ``LIB``, and ``CRYPTOGRAPHY_SUPPRESS_LINK_FLAGS`` environment\n  variables will no longer be respected. Instead, users will need to\n  configure their builds `as documented here`_.\n* Added support for\n  :ref:`disabling the legacy provider in OpenSSL 3.0.x<legacy-provider>`.\n* Added support for disabling RSA key validation checks when loading RSA\n  keys via\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`,\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`,\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers.private_key`.\n  This speeds up key loading but is :term:`unsafe` if you are loading potentially\n  attacker supplied keys.\n* Significantly improved performance for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`\n  when repeatedly calling ``encrypt`` or ``decrypt`` with the same key.\n* Added support for creating OCSP requests with precomputed hashes using\n  :meth:`~cryptography.x509.ocsp.OCSPRequestBuilder.add_certificate_by_hash`.\n* Added support for loading multiple PEM-encoded X.509 certificates from\n  a single input via :func:`~cryptography.x509.load_pem_x509_certificates`.\n\n.. _v38-0-4:\n\n38.0.4 - 2022-11-27\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed compilation when using LibreSSL 3.6.0.\n* Fixed error when using ``py2app`` to build an application with a\n  ``cryptography`` dependency.\n\n.. _v38-0-3:\n\n38.0.3 - 2022-11-01\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.7,\n  which resolves *CVE-2022-3602* and *CVE-2022-3786*.\n\n.. _v38-0-2:\n\n38.0.2 - 2022-10-11 (YANKED)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. attention::\n\n    This release was subsequently yanked from PyPI due to a regression in OpenSSL.\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.6.\n\n\n.. _v38-0-1:\n\n38.0.1 - 2022-09-07\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed parsing TLVs in ASN.1 with length greater than 65535 bytes (typically\n  seen in large CRLs).\n\n.. _v38-0-0:\n\n38.0.0 - 2022-09-06\n~~~~~~~~~~~~~~~~~~~\n\n* Final deprecation of OpenSSL 1.1.0. The next release of ``cryptography``\n  will drop support.\n* We no longer ship ``manylinux2010`` wheels. Users should upgrade to the\n  latest ``pip`` to ensure this doesn't cause issues downloading wheels on\n  their platform. We now ship ``manylinux_2_28`` wheels for users on new\n  enough platforms.\n* Updated the minimum supported Rust version (MSRV) to 1.48.0, from 1.41.0.\n  Users with the latest ``pip`` will typically get a wheel and not need Rust\n  installed, but check :doc:`/installation` for documentation on installing a\n  newer ``rustc`` if required.\n* :meth:`~cryptography.fernet.Fernet.decrypt` and related methods now accept\n  both ``str`` and ``bytes`` tokens.\n* Parsing ``CertificateSigningRequest`` restores the behavior of enforcing\n  that the ``Extension`` ``critical`` field must be correctly encoded DER. See\n  `the issue <https://github.com/pyca/cryptography/issues/6368>`_ for complete\n  details.\n* Added two new OpenSSL functions to the bindings to support an upcoming\n  ``pyOpenSSL`` release.\n* When parsing :class:`~cryptography.x509.CertificateRevocationList` and\n  :class:`~cryptography.x509.CertificateSigningRequest` values, it is now\n  enforced that the ``version`` value in the input must be valid according to\n  the rules of :rfc:`2986` and :rfc:`5280`.\n* Using MD5 or SHA1 in :class:`~cryptography.x509.CertificateBuilder` and\n  other X.509 builders is deprecated and support will be removed in the next\n  version.\n* Added additional APIs to\n  :class:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp`, including\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.signature_hash_algorithm`,\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.signature_algorithm`,\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.signature`, and\n  :attr:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp.extension_bytes`.\n* Added :attr:`~cryptography.x509.Certificate.tbs_precertificate_bytes`, allowing\n  users to access the to-be-signed pre-certificate data needed for signed\n  certificate timestamp verification.\n* :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFHMAC` and\n  :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFCMAC` now support\n  :attr:`~cryptography.hazmat.primitives.kdf.kbkdf.CounterLocation.MiddleFixed`\n  counter location.\n* Fixed :rfc:`4514` name parsing to reverse the order of the RDNs according\n  to the section 2.1 of the RFC, affecting method\n  :meth:`~cryptography.x509.Name.from_rfc4514_string`.\n* It is now possible to customize some aspects of encryption when serializing\n  private keys, using\n  :meth:`~cryptography.hazmat.primitives.serialization.PrivateFormat.encryption_builder`.\n* Removed several legacy symbols from our OpenSSL bindings. Users of pyOpenSSL\n  versions older than 22.0 will need to upgrade.\n* Added\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES128` and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES256` classes.\n  These classes do not replace\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` (which\n  allows all AES key lengths), but are intended for applications where\n  developers want to be explicit about key length.\n\n.. _v37-0-4:\n\n37.0.4 - 2022-07-05\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.5.\n\n.. _v37-0-3:\n\n37.0.3 - 2022-06-21 (YANKED)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. attention::\n\n    This release was subsequently yanked from PyPI due to a regression in OpenSSL.\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.4.\n\n.. _v37-0-2:\n\n37.0.2 - 2022-05-03\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.3.\n* Added a constant needed for an upcoming pyOpenSSL release.\n\n.. _v37-0-1:\n\n37.0.1 - 2022-04-27\n~~~~~~~~~~~~~~~~~~~\n\n* Fixed an issue where parsing an encrypted private key with the public\n  loader functions would hang waiting for console input on OpenSSL 3.0.x rather\n  than raising an error.\n* Restored some legacy symbols for older ``pyOpenSSL`` users. These will be\n  removed again in the future, so ``pyOpenSSL`` users should still upgrade\n  to the latest version of that package when they upgrade ``cryptography``.\n\n.. _v37-0-0:\n\n37.0.0 - 2022-04-26\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.2.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL 2.9.x and 3.0.x.\n  The new minimum LibreSSL version is 3.1+.\n* **BACKWARDS INCOMPATIBLE:** Removed ``signer`` and ``verifier`` methods\n  from the public key and private key classes. These methods were originally\n  deprecated in version 2.0, but had an extended deprecation timeline due\n  to usage. Any remaining users should transition to ``sign`` and ``verify``.\n* Deprecated OpenSSL 1.1.0 support. OpenSSL 1.1.0 is no longer supported by\n  the OpenSSL project. The next release of ``cryptography`` will be the last\n  to support compiling with OpenSSL 1.1.0.\n* Deprecated Python 3.6 support. Python 3.6 is no longer supported by the\n  Python core team. Support for Python 3.6 will be removed in a future\n  ``cryptography`` release.\n* Deprecated the current minimum supported Rust version (MSRV) of 1.41.0.\n  In the next release we will raise MSRV to 1.48.0. Users with the latest\n  ``pip`` will typically get a wheel and not need Rust installed, but check\n  :doc:`/installation` for documentation on installing a newer ``rustc`` if\n  required.\n* Deprecated\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.CAST5`,\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SEED`,\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.IDEA`, and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.Blowfish` because\n  they are legacy algorithms with extremely low usage. These will be removed\n  in a future version of ``cryptography``.\n* Added limited support for distinguished names containing a bit string.\n* We now ship ``universal2`` wheels on macOS, which contain both ``arm64``\n  and ``x86_64`` architectures. Users on macOS should upgrade to the latest\n  ``pip`` to ensure they can use this wheel, although we will continue to\n  ship ``x86_64`` specific wheels for now to ease the transition.\n* This will be the final release for which we ship ``manylinux2010`` wheels.\n  Going forward the minimum supported ``manylinux`` ABI for our wheels will\n  be ``manylinux2014``. The vast majority of users will continue to receive\n  ``manylinux`` wheels provided they have an up to date ``pip``. For PyPy\n  wheels this release already requires ``manylinux2014`` for compatibility\n  with binaries distributed by upstream.\n* Added support for multiple\n  :class:`~cryptography.x509.ocsp.OCSPSingleResponse` in a\n  :class:`~cryptography.x509.ocsp.OCSPResponse`.\n* Restored support for signing certificates and other structures in\n  :doc:`/x509/index` with SHA3 hash algorithms.\n* :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` is\n  disabled in FIPS mode.\n* Added support for serialization of PKCS#12 CA friendly names/aliases in\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates`\n* Added support for 12-15 byte (96 to 120 bit) nonces to\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESOCB3`. This class\n  previously supported only 12 byte (96 bit).\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESSIV` when using\n  OpenSSL 3.0.0+.\n* Added support for serializing PKCS7 structures from a list of\n  certificates with\n  :class:`~cryptography.hazmat.primitives.serialization.pkcs7.serialize_certificates`.\n* Added support for parsing :rfc:`4514` strings with\n  :meth:`~cryptography.x509.Name.from_rfc4514_string`.\n* Added :attr:`~cryptography.hazmat.primitives.asymmetric.padding.PSS.AUTO` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. This can\n  be used to verify a signature where the salt length is not already known.\n* Added :attr:`~cryptography.hazmat.primitives.asymmetric.padding.PSS.DIGEST_LENGTH`\n  to :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. This\n  constant will set the salt length to the same length as the ``PSS`` hash\n  algorithm.\n* Added support for loading RSA-PSS key types with\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`.\n  This functionality is limited to OpenSSL 1.1.1e+ and loads the key as a\n  normal RSA private key, discarding the PSS constraint information.\n\n.. _v36-0-2:\n\n36.0.2 - 2022-03-15\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 1.1.1n.\n\n.. _v36-0-1:\n\n36.0.1 - 2021-12-14\n~~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 1.1.1m.\n\n.. _v36-0-0:\n\n36.0.0 - 2021-11-21\n~~~~~~~~~~~~~~~~~~~\n\n* **FINAL DEPRECATION** Support for ``verifier`` and ``signer`` on our\n  asymmetric key classes was deprecated in version 2.0. These functions had an\n  extended deprecation due to usage, however the next version of\n  ``cryptography`` will drop support. Users should migrate to ``sign`` and\n  ``verify``.\n* The entire :doc:`/x509/index` layer is now written in Rust. This allows\n  alternate asymmetric key implementations that can support cloud key\n  management services or hardware security modules provided they implement\n  the necessary interface (for example:\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`).\n* :ref:`Deprecated the backend argument<faq-missing-backend>` for all\n  functions.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESOCB3`.\n* Added support for iterating over arbitrary request\n  :attr:`~cryptography.x509.CertificateSigningRequest.attributes`.\n* Deprecated the ``get_attribute_for_oid`` method on\n  :class:`~cryptography.x509.CertificateSigningRequest` in favor of\n  :meth:`~cryptography.x509.Attributes.get_attribute_for_oid` on the new\n  :class:`~cryptography.x509.Attributes` object.\n* Fixed handling of PEM files to allow loading when certificate and key are\n  in the same file.\n* Fixed parsing of :class:`~cryptography.x509.CertificatePolicies` extensions\n  containing legacy ``BMPString`` values in their ``explicitText``.\n* Allow parsing of negative serial numbers in certificates. Negative serial\n  numbers are prohibited by :rfc:`5280` so a deprecation warning will be\n  raised whenever they are encountered. A future version of ``cryptography``\n  will drop support for parsing them.\n* Added support for parsing PKCS12 files with friendly names for all\n  certificates with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.load_pkcs12`,\n  which will return an object of type\n  :class:`~cryptography.hazmat.primitives.serialization.pkcs12.PKCS12KeyAndCertificates`.\n* :meth:`~cryptography.x509.Name.rfc4514_string` and related methods now have\n  an optional ``attr_name_overrides`` parameter to supply custom OID to name\n  mappings, which can be used to match vendor-specific extensions.\n* **BACKWARDS INCOMPATIBLE:** Reverted the nonstandard formatting of\n  email address fields as ``E`` in\n  :meth:`~cryptography.x509.Name.rfc4514_string` methods from version 35.0.\n\n  The previous behavior can be restored with:\n  ``name.rfc4514_string({NameOID.EMAIL_ADDRESS: \"E\"})``\n* Allow\n  :class:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey`\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.x448.X448PublicKey` to\n  be used as public keys when parsing certificates or creating them with\n  :class:`~cryptography.x509.CertificateBuilder`. These key types must be\n  signed with a different signing algorithm as ``X25519`` and ``X448`` do\n  not support signing.\n* Extension values can now be serialized to a DER byte string by calling\n  :func:`~cryptography.x509.ExtensionType.public_bytes`.\n* Added experimental support for compiling against BoringSSL. As BoringSSL\n  does not commit to a stable API, ``cryptography`` tests against the\n  latest commit only. Please note that several features are not available\n  when building against BoringSSL.\n* Parsing ``CertificateSigningRequest`` from DER and PEM now, for a limited\n  time period, allows the ``Extension`` ``critical`` field to be incorrectly\n  encoded. See `the issue <https://github.com/pyca/cryptography/issues/6368>`_\n  for complete details. This will be reverted in a future ``cryptography``\n  release.\n* When :class:`~cryptography.x509.OCSPNonce` are parsed and generated their\n  value is now correctly wrapped in an ASN.1 ``OCTET STRING``. This conforms\n  to :rfc:`6960` but conflicts with the original behavior specified in\n  :rfc:`2560`. For a temporary period for backwards compatibility, we will\n  also parse values that are encoded as specified in :rfc:`2560` but this\n  behavior will be removed in a future release.\n\n.. _v35-0-0:\n\n35.0.0 - 2021-09-29\n~~~~~~~~~~~~~~~~~~~\n\n* Changed the :ref:`version scheme <api-stability:versioning>`. This will\n  result in us incrementing the major version more frequently, but does not\n  change our existing backwards compatibility policy.\n* **BACKWARDS INCOMPATIBLE:** The :doc:`/x509/index` PEM parsers now require\n  that the PEM string passed have PEM delimiters of the correct type. For\n  example, parsing a private key PEM concatenated with a certificate PEM will\n  no longer be accepted by the PEM certificate parser.\n* **BACKWARDS INCOMPATIBLE:** The X.509 certificate parser no longer allows\n  negative serial numbers. :rfc:`5280` has always prohibited these.\n* **BACKWARDS INCOMPATIBLE:** Additional forms of invalid ASN.1 found during\n  :doc:`/x509/index` parsing will raise an error on initial parse rather than\n  when the malformed field is accessed.\n* Rust is now required for building ``cryptography``, the\n  ``CRYPTOGRAPHY_DONT_BUILD_RUST`` environment variable is no longer\n  respected.\n* Parsers for :doc:`/x509/index` no longer use OpenSSL and have been\n  rewritten in Rust. This should be backwards compatible (modulo the items\n  listed above) and improve both security and performance.\n* Added support for OpenSSL 3.0.0 as a compilation target.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.hashes.SM3` and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SM4`,\n  when using OpenSSL 1.1.1. These algorithms are provided for compatibility\n  in regions where they may be required, and are not generally recommended.\n* We now ship ``manylinux_2_24`` and ``musllinux_1_1`` wheels, in addition to\n  our ``manylinux2010`` and ``manylinux2014`` wheels. Users on distributions\n  like Alpine Linux should ensure they upgrade to the latest ``pip`` to\n  correctly receive wheels.\n* Added ``rfc4514_attribute_name`` attribute to :attr:`x509.NameAttribute\n  <cryptography.x509.NameAttribute.rfc4514_attribute_name>`.\n* Added :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFCMAC`.\n\n.. _v3-4-8:\n\n3.4.8 - 2021-08-24\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1l.\n\n.. _v3-4-7:\n\n3.4.7 - 2021-03-25\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1k.\n\n.. _v3-4-6:\n\n3.4.6 - 2021-02-16\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1j.\n\n.. _v3-4-5:\n\n3.4.5 - 2021-02-13\n~~~~~~~~~~~~~~~~~~\n\n* Various improvements to type hints.\n* Lower the minimum supported Rust version (MSRV) to >=1.41.0. This change\n  improves compatibility with system-provided Rust on several Linux\n  distributions.\n* ``cryptography`` will be switching to a new versioning scheme with its next\n  feature release. More information is available in our\n  :doc:`/api-stability` documentation.\n\n.. _v3-4-4:\n\n3.4.4 - 2021-02-09\n~~~~~~~~~~~~~~~~~~\n\n* Added a ``py.typed`` file so that ``mypy`` will know to use our type\n  annotations.\n* Fixed an import cycle that could be triggered by certain import sequences.\n\n.. _v3-4-3:\n\n3.4.3 - 2021-02-08\n~~~~~~~~~~~~~~~~~~\n\n* Specify our supported Rust version (>=1.45.0) in our ``setup.py`` so users\n  on older versions will get a clear error message.\n\n.. _v3-4-2:\n\n3.4.2 - 2021-02-08\n~~~~~~~~~~~~~~~~~~\n\n* Improvements to make the rust transition a bit easier. This includes some\n  better error messages and small dependency fixes. If you experience\n  installation problems **Be sure to update pip** first, then check the\n  :doc:`FAQ </faq>`.\n\n.. _v3-4-1:\n\n3.4.1 - 2021-02-07\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a circular import issue.\n* Added additional debug output to assist users seeing installation errors\n  due to outdated ``pip`` or missing ``rustc``.\n\n.. _v3-4:\n\n3.4 - 2021-02-07\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 2 has been removed.\n* We now ship ``manylinux2014`` wheels and no longer ship ``manylinux1``\n  wheels. Users should upgrade to the latest ``pip`` to ensure this doesn't\n  cause issues downloading wheels on their platform.\n* ``cryptography`` now incorporates Rust code. Users building ``cryptography``\n  themselves will need to have the Rust toolchain installed. Users who use an\n  officially produced wheel will not need to make any changes. The minimum\n  supported Rust version is 1.45.0.\n* ``cryptography`` now has :pep:`484` type hints on nearly all of of its public\n  APIs. Users can begin using them to type check their code with ``mypy``.\n\n.. _v3-3-2:\n\n3.3.2 - 2021-02-07\n~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE:** Fixed a bug where certain sequences of ``update()`` calls\n  when symmetrically encrypting very large payloads (>2GB) could result in an\n  integer overflow, leading to buffer overflows. *CVE-2020-36242* **Update:**\n  This fix is a workaround for *CVE-2021-23840* in OpenSSL, fixed in OpenSSL\n  1.1.1j.\n\n.. _v3-3-1:\n\n3.3.1 - 2020-12-09\n~~~~~~~~~~~~~~~~~~\n\n* Re-added a legacy symbol causing problems for older ``pyOpenSSL`` users.\n\n.. _v3-3:\n\n3.3 - 2020-12-08\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.5 has been removed due to\n  low usage and maintenance burden.\n* **BACKWARDS INCOMPATIBLE:** The\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` and\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESGCM` now require\n  64-bit to 1024-bit (8 byte to 128 byte) initialization vectors. This change\n  is to conform with an upcoming OpenSSL release that will no longer support\n  sizes outside this window.\n* **BACKWARDS INCOMPATIBLE:** When deserializing asymmetric keys we now\n  raise ``ValueError`` rather than ``UnsupportedAlgorithm`` when an\n  unsupported cipher is used. This change is to conform with an upcoming\n  OpenSSL release that will no longer distinguish between error types.\n* **BACKWARDS INCOMPATIBLE:** We no longer allow loading of finite field\n  Diffie-Hellman parameters of less than 512 bits in length. This change is to\n  conform with an upcoming OpenSSL release that no longer supports smaller\n  sizes. These keys were already wildly insecure and should not have been used\n  in any application outside of testing.\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1i.\n* Python 2 support is deprecated in ``cryptography``. This is the last release\n  that will support Python 2.\n* Added the\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey.recover_data_from_signature`\n  function to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`\n  for recovering the signed data from an RSA signature.\n\n.. _v3-2-1:\n\n3.2.1 - 2020-10-27\n~~~~~~~~~~~~~~~~~~\n\n* Disable blinding on RSA public keys to address an error with some versions\n  of OpenSSL.\n\n.. _v3-2:\n\n3.2 - 2020-10-25\n~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE:** Attempted to make RSA PKCS#1v1.5 decryption more constant\n  time, to protect against Bleichenbacher vulnerabilities. Due to limitations\n  imposed by our API, we cannot completely mitigate this vulnerability and a\n  future release will contain a new API which is designed to be resilient to\n  these for contexts where it is required. Credit to **Hubert Kario** for\n  reporting the issue. *CVE-2020-25659*\n* Support for OpenSSL 1.0.2 has been removed. Users on older version of OpenSSL\n  will need to upgrade.\n* Added basic support for PKCS7 signing (including SMIME) via\n  :class:`~cryptography.hazmat.primitives.serialization.pkcs7.PKCS7SignatureBuilder`.\n\n.. _v3-1-1:\n\n3.1.1 - 2020-09-22\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1h.\n\n.. _v3-1:\n\n3.1 - 2020-08-26\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Removed support for ``idna`` based\n  :term:`U-label` parsing in various X.509 classes. This support was originally\n  deprecated in version 2.1 and moved to an extra in 2.5.\n* Deprecated OpenSSL 1.0.2 support. OpenSSL 1.0.2 is no longer supported by\n  the OpenSSL project. The next version of ``cryptography`` will drop support\n  for it.\n* Deprecated support for Python 3.5. This version sees very little use and will\n  be removed in the next release.\n* ``backend`` arguments to functions are no longer required and the\n  default backend will automatically be selected if no ``backend`` is provided.\n* Added initial support for parsing certificates from PKCS7 files with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs7.load_pem_pkcs7_certificates`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs7.load_der_pkcs7_certificates`\n  .\n* Calling ``update`` or ``update_into`` on\n  :class:`~cryptography.hazmat.primitives.ciphers.CipherContext` with ``data``\n  longer than 2\\ :sup:`31` bytes no longer raises an ``OverflowError``. This\n  also resolves the same issue in :doc:`/fernet`.\n\n.. _v3-0:\n\n3.0 - 2020-07-20\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Removed support for passing an\n  :class:`~cryptography.x509.Extension` instance to\n  :meth:`~cryptography.x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier`,\n  as per our deprecation policy.\n* **BACKWARDS INCOMPATIBLE:** Support for LibreSSL 2.7.x, 2.8.x, and 2.9.0 has\n  been removed (2.9.1+ is still supported).\n* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.9, macOS users must\n  upgrade to 10.10 or newer.\n* **BACKWARDS INCOMPATIBLE:** RSA\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key`\n  no longer accepts ``public_exponent`` values except 65537 and 3 (the latter\n  for legacy purposes).\n* **BACKWARDS INCOMPATIBLE:** X.509 certificate parsing now enforces that the\n  ``version`` field contains a valid value, rather than deferring this check\n  until :attr:`~cryptography.x509.Certificate.version` is accessed.\n* Deprecated support for Python 2. At the time there is no time table for\n  actually dropping support, however we strongly encourage all users to upgrade\n  their Python, as Python 2 no longer receives support from the Python core\n  team.\n\n  If you have trouble suppressing this warning in tests view the :ref:`FAQ\n  entry addressing this issue <faq-howto-handle-deprecation-warning>`.\n\n* Added support for ``OpenSSH`` serialization format for\n  ``ec``, ``ed25519``, ``rsa`` and ``dsa`` private keys:\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_private_key`\n  for loading and\n  :attr:`~cryptography.hazmat.primitives.serialization.PrivateFormat.OpenSSH`\n  for writing.\n* Added support for ``OpenSSH`` certificates to\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key`.\n* Added :meth:`~cryptography.fernet.Fernet.encrypt_at_time` and\n  :meth:`~cryptography.fernet.Fernet.decrypt_at_time` to\n  :class:`~cryptography.fernet.Fernet`.\n* Added support for the :class:`~cryptography.x509.SubjectInformationAccess`\n  X.509 extension.\n* Added support for parsing\n  :class:`~cryptography.x509.SignedCertificateTimestamps` in OCSP responses.\n* Added support for parsing attributes in certificate signing requests via\n  ``CertificateSigningRequest.get_attribute_for_oid``.\n* Added support for encoding attributes in certificate signing requests via\n  :meth:`~cryptography.x509.CertificateSigningRequestBuilder.add_attribute`.\n* On OpenSSL 1.1.1d and higher ``cryptography`` now uses OpenSSL's\n  built-in CSPRNG instead of its own OS random engine because these versions of\n  OpenSSL properly reseed on fork.\n* Added initial support for creating PKCS12 files with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates`.\n\n.. _v2-9-2:\n\n2.9.2 - 2020-04-22\n~~~~~~~~~~~~~~~~~~\n\n* Updated the macOS wheel to fix an issue where it would not run on macOS\n  versions older than 10.15.\n\n.. _v2-9-1:\n\n2.9.1 - 2020-04-21\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1g.\n\n.. _v2-9:\n\n2.9 - 2020-04-02\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.4 has been removed due to\n  low usage and maintenance burden.\n* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL 1.0.1 has been removed.\n  Users on older version of OpenSSL will need to upgrade.\n* **BACKWARDS INCOMPATIBLE:** Support for LibreSSL 2.6.x has been removed.\n* Removed support for calling\n  :meth:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey.public_bytes`\n  with no arguments, as per our deprecation policy. You must now pass\n  ``encoding`` and ``format``.\n* **BACKWARDS INCOMPATIBLE:** Reversed the order in which\n  :meth:`~cryptography.x509.Name.rfc4514_string` returns the RDNs\n  as required by :rfc:`4514`.\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1f.\n* Added support for parsing\n  :attr:`~cryptography.x509.ocsp.OCSPResponse.single_extensions` in an OCSP\n  response.\n* :class:`~cryptography.x509.NameAttribute` values can now be empty strings.\n\n.. _v2-8:\n\n2.8 - 2019-10-16\n~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux`` wheels to be compiled with\n  OpenSSL 1.1.1d.\n* Added support for Python 3.8.\n* Added class methods\n  :meth:`Poly1305.generate_tag\n  <cryptography.hazmat.primitives.poly1305.Poly1305.generate_tag>`\n  and\n  :meth:`Poly1305.verify_tag\n  <cryptography.hazmat.primitives.poly1305.Poly1305.verify_tag>`\n  for Poly1305 sign and verify operations.\n* Deprecated support for OpenSSL 1.0.1. Support will be removed in\n  ``cryptography`` 2.9.\n* We now ship ``manylinux2010`` wheels in addition to our ``manylinux1``\n  wheels.\n* Added support for ``ed25519`` and ``ed448`` keys in the\n  :class:`~cryptography.x509.CertificateBuilder`,\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`,\n  :class:`~cryptography.x509.CertificateRevocationListBuilder` and\n  :class:`~cryptography.x509.ocsp.OCSPResponseBuilder`.\n* ``cryptography`` no longer depends on ``asn1crypto``.\n* :class:`~cryptography.x509.FreshestCRL` is now allowed as a\n  :class:`~cryptography.x509.CertificateRevocationList` extension.\n\n.. _v2-7:\n\n2.7 - 2019-05-30\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** We no longer distribute 32-bit ``manylinux1``\n  wheels. Continuing to produce them was a maintenance burden.\n* **BACKWARDS INCOMPATIBLE:** Removed the\n  ``cryptography.hazmat.primitives.mac.MACContext`` interface. The ``CMAC`` and\n  ``HMAC`` APIs have not changed, but they are no longer registered as\n  ``MACContext`` instances.\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.1c.\n* Removed support for running our tests with ``setup.py test``. Users\n  interested in running our tests can continue to follow the directions in our\n  :doc:`development documentation</development/getting-started>`.\n* Add support for :class:`~cryptography.hazmat.primitives.poly1305.Poly1305`\n  when using OpenSSL 1.1.1 or newer.\n* Support serialization with ``Encoding.OpenSSH`` and ``PublicFormat.OpenSSH``\n  in\n  :meth:`Ed25519PublicKey.public_bytes\n  <cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PublicKey.public_bytes>`\n  .\n* Correctly allow passing a ``SubjectKeyIdentifier`` to\n  :meth:`~cryptography.x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier`\n  and deprecate passing an ``Extension`` object. The documentation always\n  required ``SubjectKeyIdentifier`` but the implementation previously\n  required an ``Extension``.\n\n.. _v2-6-1:\n\n2.6.1 - 2019-02-27\n~~~~~~~~~~~~~~~~~~\n\n* Resolved an error in our build infrastructure that broke our Python3 wheels\n  for macOS and Linux.\n\n.. _v2-6:\n\n2.6 - 2019-02-27\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Removed\n  ``cryptography.hazmat.primitives.asymmetric.utils.encode_rfc6979_signature``\n  and\n  ``cryptography.hazmat.primitives.asymmetric.utils.decode_rfc6979_signature``,\n  which had been deprecated for nearly 4 years. Use\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.encode_dss_signature`\n  and\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`\n  instead.\n* **BACKWARDS INCOMPATIBLE**: Removed ``cryptography.x509.Certificate.serial``,\n  which had been deprecated for nearly 3 years. Use\n  :attr:`~cryptography.x509.Certificate.serial_number` instead.\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.1b.\n* Added support for :doc:`/hazmat/primitives/asymmetric/ed448` when using\n  OpenSSL 1.1.1b or newer.\n* Added support for :doc:`/hazmat/primitives/asymmetric/ed25519` when using\n  OpenSSL 1.1.1b or newer.\n* :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` can\n  now load ``ed25519`` public keys.\n* Add support for easily mapping an object identifier to its elliptic curve\n  class via\n  :func:`~cryptography.hazmat.primitives.asymmetric.ec.get_curve_for_oid`.\n* Add support for OpenSSL when compiled with the ``no-engine``\n  (``OPENSSL_NO_ENGINE``) flag.\n\n.. _v2-5:\n\n2.5 - 2019-01-22\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** :term:`U-label` strings were deprecated in\n  version 2.1, but this version removes the default ``idna`` dependency as\n  well. If you still need this deprecated path please install cryptography\n  with the ``idna`` extra: ``pip install cryptography[idna]``.\n* **BACKWARDS INCOMPATIBLE:** The minimum supported PyPy version is now 5.4.\n* Numerous classes and functions have been updated to allow :term:`bytes-like`\n  types for keying material and passwords, including symmetric algorithms, AEAD\n  ciphers, KDFs, loading asymmetric keys, and one time password classes.\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.1a.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.SHA512_224`\n  and :class:`~cryptography.hazmat.primitives.hashes.SHA512_256` when using\n  OpenSSL 1.1.1.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.SHA3_224`,\n  :class:`~cryptography.hazmat.primitives.hashes.SHA3_256`,\n  :class:`~cryptography.hazmat.primitives.hashes.SHA3_384`, and\n  :class:`~cryptography.hazmat.primitives.hashes.SHA3_512` when using OpenSSL\n  1.1.1.\n* Added support for :doc:`/hazmat/primitives/asymmetric/x448` when using\n  OpenSSL 1.1.1.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.SHAKE128`\n  and :class:`~cryptography.hazmat.primitives.hashes.SHAKE256` when using\n  OpenSSL 1.1.1.\n* Added initial support for parsing PKCS12 files with\n  :func:`~cryptography.hazmat.primitives.serialization.pkcs12.load_key_and_certificates`.\n* Added support for :class:`~cryptography.x509.IssuingDistributionPoint`.\n* Added ``rfc4514_string()`` method to\n  :meth:`x509.Name <cryptography.x509.Name.rfc4514_string>`,\n  :meth:`x509.RelativeDistinguishedName\n  <cryptography.x509.RelativeDistinguishedName.rfc4514_string>`, and\n  :meth:`x509.NameAttribute <cryptography.x509.NameAttribute.rfc4514_string>`\n  to format the name or component an :rfc:`4514` Distinguished Name string.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.from_encoded_point`,\n  which immediately checks if the point is on the curve and supports compressed\n  points. Deprecated the previous method\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.from_encoded_point`.\n* Added :attr:`~cryptography.x509.ocsp.OCSPResponse.signature_hash_algorithm`\n  to ``OCSPResponse``.\n* Updated :doc:`/hazmat/primitives/asymmetric/x25519` support to allow\n  additional serialization methods. Calling\n  :meth:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PublicKey.public_bytes`\n  with no arguments has been deprecated.\n* Added support for encoding compressed and uncompressed points via\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.public_bytes`. Deprecated the previous method\n  ``cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.encode_point``.\n\n\n.. _v2-4-2:\n\n2.4.2 - 2018-11-21\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0j.\n\n.. _v2-4-1:\n\n2.4.1 - 2018-11-11\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a build breakage in our ``manylinux1`` wheels.\n\n.. _v2-4:\n\n2.4 - 2018-11-11\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL 2.4.x.\n* Deprecated OpenSSL 1.0.1 support. OpenSSL 1.0.1 is no longer supported by\n  the OpenSSL project. At this time there is no time table for dropping\n  support, however we strongly encourage all users to upgrade or install\n  ``cryptography`` from a wheel.\n* Added initial :doc:`OCSP </x509/ocsp>` support.\n* Added support for :class:`~cryptography.x509.PrecertPoison`.\n\n.. _v2-3-1:\n\n2.3.1 - 2018-08-14\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0i.\n\n.. _v2-3:\n\n2.3 - 2018-07-18\n~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE:**\n  :meth:`~cryptography.hazmat.primitives.ciphers.AEADDecryptionContext.finalize_with_tag`\n  allowed tag truncation by default which can allow tag forgery in some cases.\n  The method now enforces the ``min_tag_length`` provided to the\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` constructor.\n  *CVE-2018-10903*\n* Added support for Python 3.7.\n* Added :meth:`~cryptography.fernet.Fernet.extract_timestamp` to get the\n  authenticated timestamp of a :doc:`Fernet </fernet>` token.\n* Support for Python 2.7.x without ``hmac.compare_digest`` has been deprecated.\n  We will require Python 2.7.7 or higher (or 2.7.6 on Ubuntu) in the next\n  ``cryptography`` release.\n* Fixed multiple issues preventing ``cryptography`` from compiling against\n  LibreSSL 2.7.x.\n* Added\n  :class:`~cryptography.x509.CertificateRevocationList.get_revoked_certificate_by_serial_number`\n  for quick serial number searches in CRLs.\n* The :class:`~cryptography.x509.RelativeDistinguishedName` class now\n  preserves the order of attributes. Duplicate attributes now raise an error\n  instead of silently discarding duplicates.\n* :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap` and\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap_with_padding`\n  now raise :class:`~cryptography.hazmat.primitives.keywrap.InvalidUnwrap` if\n  the wrapped key is an invalid length, instead of ``ValueError``.\n\n.. _v2-2-2:\n\n2.2.2 - 2018-03-27\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0h.\n\n.. _v2-2-1:\n\n2.2.1 - 2018-03-20\n~~~~~~~~~~~~~~~~~~\n\n* Reverted a change to ``GeneralNames`` which prohibited having zero elements,\n  due to breakages.\n* Fixed a bug in\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap_with_padding`\n  that caused it to raise ``InvalidUnwrap`` when key length modulo 8 was\n  zero.\n\n\n.. _v2-2:\n\n2.2 - 2018-03-19\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 2.6 has been dropped.\n* Resolved a bug in ``HKDF`` that incorrectly constrained output size.\n* Added :class:`~cryptography.hazmat.primitives.asymmetric.ec.BrainpoolP256R1`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.BrainpoolP384R1`, and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.BrainpoolP512R1` to\n  support inter-operating with systems like German smart meters.\n* Added token rotation support to :doc:`Fernet </fernet>` with\n  :meth:`~cryptography.fernet.MultiFernet.rotate`.\n* Fixed a memory leak in\n  :func:`~cryptography.hazmat.primitives.asymmetric.ec.derive_private_key`.\n* Added support for AES key wrapping with padding via\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_wrap_with_padding`\n  and\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap_with_padding`\n  .\n* Allow loading DSA keys with 224 bit ``q``.\n\n.. _v2-1-4:\n\n2.1.4 - 2017-11-29\n~~~~~~~~~~~~~~~~~~\n\n* Added ``X509_up_ref`` for an upcoming ``pyOpenSSL`` release.\n\n.. _v2-1-3:\n\n2.1.3 - 2017-11-02\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows, macOS, and ``manylinux1`` wheels to be compiled with\n  OpenSSL 1.1.0g.\n\n.. _v2-1-2:\n\n2.1.2 - 2017-10-24\n~~~~~~~~~~~~~~~~~~\n\n* Corrected a bug with the ``manylinux1`` wheels where OpenSSL's stack was\n  marked executable.\n\n.. _v2-1-1:\n\n2.1.1 - 2017-10-12\n~~~~~~~~~~~~~~~~~~\n\n* Fixed support for install with the system ``pip`` on Ubuntu 16.04.\n\n.. _v2-1:\n\n2.1 - 2017-10-11\n~~~~~~~~~~~~~~~~\n\n* **FINAL DEPRECATION** Python 2.6 support is deprecated, and will be removed\n  in the next release of ``cryptography``.\n* **BACKWARDS INCOMPATIBLE:** ``Whirlpool``, ``RIPEMD160``, and\n  ``UnsupportedExtension`` have been removed in accordance with our\n  :doc:`/api-stability` policy.\n* **BACKWARDS INCOMPATIBLE:**\n  :attr:`DNSName.value <cryptography.x509.DNSName.value>`,\n  :attr:`RFC822Name.value <cryptography.x509.RFC822Name.value>`, and\n  :attr:`UniformResourceIdentifier.value\n  <cryptography.x509.UniformResourceIdentifier.value>`\n  will now return an :term:`A-label` string when parsing a certificate\n  containing an internationalized domain name (IDN) or if the caller passed\n  a :term:`U-label` to the constructor. See below for additional deprecations\n  related to this change.\n* Installing ``cryptography`` now requires ``pip`` 6 or newer.\n* Deprecated passing :term:`U-label` strings to the\n  :class:`~cryptography.x509.DNSName`,\n  :class:`~cryptography.x509.UniformResourceIdentifier`, and\n  :class:`~cryptography.x509.RFC822Name` constructors. Instead, users should\n  pass values as :term:`A-label` strings with ``idna`` encoding if necessary.\n  This change will not affect anyone who is not processing internationalized\n  domains.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.ChaCha20`. In\n  most cases users should choose\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`\n  rather than using this unauthenticated form.\n* Added :meth:`~cryptography.x509.CertificateRevocationList.is_signature_valid`\n  to :class:`~cryptography.x509.CertificateRevocationList`.\n* Support :class:`~cryptography.hazmat.primitives.hashes.BLAKE2b` and\n  :class:`~cryptography.hazmat.primitives.hashes.BLAKE2s` with\n  :class:`~cryptography.hazmat.primitives.hmac.HMAC`.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.XTS` mode for\n  AES.\n* Added support for using labels with\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.OAEP` when using\n  OpenSSL 1.0.2 or greater.\n* Improved compatibility with NSS when issuing certificates from an issuer\n  that has a subject with non-``UTF8String`` string types.\n* Add support for the :class:`~cryptography.x509.DeltaCRLIndicator` extension.\n* Add support for the :class:`~cryptography.x509.TLSFeature`\n  extension. This is commonly used for enabling ``OCSP Must-Staple`` in\n  certificates.\n* Add support for the :class:`~cryptography.x509.FreshestCRL` extension.\n\n.. _v2-0-3:\n\n2.0.3 - 2017-08-03\n~~~~~~~~~~~~~~~~~~\n\n* Fixed an issue with weak linking symbols when compiling on macOS\n  versions older than 10.12.\n\n\n.. _v2-0-2:\n\n2.0.2 - 2017-07-27\n~~~~~~~~~~~~~~~~~~\n\n* Marked all symbols as hidden in the ``manylinux1`` wheel to avoid a\n  bug with symbol resolution in certain scenarios.\n\n\n.. _v2-0-1:\n\n2.0.1 - 2017-07-26\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a compilation bug affecting OpenBSD.\n* Altered the ``manylinux1`` wheels to statically link OpenSSL instead of\n  dynamically linking and bundling the shared object. This should resolve\n  crashes seen when using ``uwsgi`` or other binaries that link against\n  OpenSSL independently.\n* Fixed the stack level for the ``signer`` and ``verifier`` warnings.\n\n\n.. _v2-0:\n\n2.0 - 2017-07-17\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Support for Python 3.3 has been dropped.\n* We now ship ``manylinux1`` wheels linked against OpenSSL 1.1.0f. These wheels\n  will be automatically used with most Linux distributions if you are running\n  the latest pip.\n* Deprecated the use of ``signer`` on\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`\n  in favor of ``sign``.\n* Deprecated the use of ``verifier`` on\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`\n  in favor of ``verify``.\n* Added support for parsing\n  :class:`~cryptography.x509.certificate_transparency.SignedCertificateTimestamp`\n  objects from X.509 certificate extensions.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`.\n* Added support for\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESCCM`.\n* Added\n  :class:`~cryptography.hazmat.primitives.ciphers.aead.AESGCM`, a \"one shot\"\n  API for AES GCM encryption.\n* Added support for :doc:`/hazmat/primitives/asymmetric/x25519`.\n* Added support for serializing and deserializing Diffie-Hellman parameters\n  with\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_parameters`,\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_parameters`,\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHParameters.parameter_bytes`\n  .\n* The ``extensions`` attribute on :class:`~cryptography.x509.Certificate`,\n  :class:`~cryptography.x509.CertificateSigningRequest`,\n  :class:`~cryptography.x509.CertificateRevocationList`, and\n  :class:`~cryptography.x509.RevokedCertificate` now caches the computed\n  ``Extensions`` object. There should be no performance change, just a\n  performance improvement for programs accessing the ``extensions`` attribute\n  multiple times.\n\n\n.. _v1-9:\n\n1.9 - 2017-05-29\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:** Elliptic Curve signature verification no longer\n  returns ``True`` on success. This brings it in line with the interface's\n  documentation, and our intent. The correct way to use\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.verify`\n  has always been to check whether or not\n  :class:`~cryptography.exceptions.InvalidSignature` was raised.\n* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.7 and 10.8.\n* **BACKWARDS INCOMPATIBLE:** The minimum supported PyPy version is now 5.3.\n* Python 3.3 support has been deprecated, and will be removed in the next\n  ``cryptography`` release.\n* Add support for providing ``tag`` during\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` finalization via\n  :meth:`~cryptography.hazmat.primitives.ciphers.AEADDecryptionContext.finalize_with_tag`.\n* Fixed an issue preventing ``cryptography`` from compiling against\n  LibreSSL 2.5.x.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.key_size`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey.key_size`\n  as convenience methods for determining the bit size of a secret scalar for\n  the curve.\n* Accessing an unrecognized extension marked critical on an X.509 object will\n  no longer raise an ``UnsupportedExtension`` exception, instead an\n  :class:`~cryptography.x509.UnrecognizedExtension` object will be returned.\n  This behavior was based on a poor reading of the RFC, unknown critical\n  extensions only need to be rejected on certificate verification.\n* The CommonCrypto backend has been removed.\n* MultiBackend has been removed.\n* ``Whirlpool`` and ``RIPEMD160`` have been deprecated.\n\n\n.. _v1-8-2:\n\n1.8.2 - 2017-05-26\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a compilation bug affecting OpenSSL 1.1.0f.\n* Updated Windows and macOS wheels to be compiled against OpenSSL 1.1.0f.\n\n\n.. _v1-8-1:\n\n1.8.1 - 2017-03-10\n~~~~~~~~~~~~~~~~~~\n\n* Fixed macOS wheels to properly link against 1.1.0 rather than 1.0.2.\n\n\n.. _v1-8:\n\n1.8 - 2017-03-09\n~~~~~~~~~~~~~~~~\n\n* Added support for Python 3.6.\n* Windows and macOS wheels now link against OpenSSL 1.1.0.\n* macOS wheels are no longer universal. This change significantly shrinks the\n  size of the wheels. Users on macOS 32-bit Python (if there are any) should\n  migrate to 64-bit or build their own packages.\n* Changed ASN.1 dependency from ``pyasn1`` to ``asn1crypto`` resulting in a\n  general performance increase when encoding/decoding ASN.1 structures. Also,\n  the ``pyasn1_modules`` test dependency is no longer required.\n* Added support for\n  :meth:`~cryptography.hazmat.primitives.ciphers.CipherContext.update_into` on\n  :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey`.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey.public_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dh.DHPublicKey`.\n* :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`\n  and\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`\n  now require that ``password`` must be bytes if provided. Previously this\n  was documented but not enforced.\n* Added support for subgroup order in :doc:`/hazmat/primitives/asymmetric/dh`.\n\n\n.. _v1-7-2:\n\n1.7.2 - 2017-01-27\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and macOS wheels to be compiled against OpenSSL 1.0.2k.\n\n\n.. _v1-7-1:\n\n1.7.1 - 2016-12-13\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a regression in ``int_from_bytes`` where it failed to accept\n  ``bytearray``.\n\n\n.. _v1-7:\n\n1.7 - 2016-12-12\n~~~~~~~~~~~~~~~~\n\n* Support for OpenSSL 1.0.0 has been removed. Users on older version of OpenSSL\n  will need to upgrade.\n* Added support for Diffie-Hellman key exchange using\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dh.DHPrivateKey.exchange`.\n* The OS random engine for OpenSSL has been rewritten to improve compatibility\n  with embedded Python and other edge cases. More information about this change\n  can be found in the\n  `pull request <https://github.com/pyca/cryptography/pull/3229>`_.\n\n\n.. _v1-6:\n\n1.6 - 2016-11-22\n~~~~~~~~~~~~~~~~\n\n* Deprecated support for OpenSSL 1.0.0. Support will be removed in\n  ``cryptography`` 1.7.\n* Replaced the Python-based OpenSSL locking callbacks with a C version to fix\n  a potential deadlock that could occur if a garbage collection cycle occurred\n  while inside the lock.\n* Added support for :class:`~cryptography.hazmat.primitives.hashes.BLAKE2b` and\n  :class:`~cryptography.hazmat.primitives.hashes.BLAKE2s` when using OpenSSL\n  1.1.0.\n* Added\n  :attr:`~cryptography.x509.Certificate.signature_algorithm_oid` support to\n  :class:`~cryptography.x509.Certificate`.\n* Added\n  :attr:`~cryptography.x509.CertificateSigningRequest.signature_algorithm_oid`\n  support to :class:`~cryptography.x509.CertificateSigningRequest`.\n* Added\n  :attr:`~cryptography.x509.CertificateRevocationList.signature_algorithm_oid`\n  support to :class:`~cryptography.x509.CertificateRevocationList`.\n* Added support for :class:`~cryptography.hazmat.primitives.kdf.scrypt.Scrypt`\n  when using OpenSSL 1.1.0.\n* Added a workaround to improve compatibility with Python application bundling\n  tools like ``PyInstaller`` and ``cx_freeze``.\n* Added support for generating a\n  :meth:`~cryptography.x509.random_serial_number`.\n* Added support for encoding ``IPv4Network`` and ``IPv6Network`` in X.509\n  certificates for use with :class:`~cryptography.x509.NameConstraints`.\n* Added :meth:`~cryptography.x509.Name.public_bytes` to\n  :class:`~cryptography.x509.Name`.\n* Added :class:`~cryptography.x509.RelativeDistinguishedName`\n* :class:`~cryptography.x509.DistributionPoint` now accepts\n  :class:`~cryptography.x509.RelativeDistinguishedName` for\n  :attr:`~cryptography.x509.DistributionPoint.relative_name`.\n  Deprecated use of :class:`~cryptography.x509.Name` as\n  :attr:`~cryptography.x509.DistributionPoint.relative_name`.\n* :class:`~cryptography.x509.Name` now accepts an iterable of\n  :class:`~cryptography.x509.RelativeDistinguishedName`.  RDNs can\n  be accessed via the :attr:`~cryptography.x509.Name.rdns`\n  attribute.  When constructed with an iterable of\n  :class:`~cryptography.x509.NameAttribute`, each attribute becomes\n  a single-valued RDN.\n* Added\n  :func:`~cryptography.hazmat.primitives.asymmetric.ec.derive_private_key`.\n* Added support for signing and verifying RSA, DSA, and ECDSA signatures with\n  :class:`~cryptography.hazmat.primitives.asymmetric.utils.Prehashed`\n  digests.\n\n\n.. _v1-5-3:\n\n1.5.3 - 2016-11-05\n~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE**: Fixed a bug where ``HKDF`` would return an empty\n  byte-string if used with a ``length`` less than ``algorithm.digest_size``.\n  Credit to **Markus D\u0102\u00b6ring** for reporting the issue. *CVE-2016-9243*\n\n\n.. _v1-5-2:\n\n1.5.2 - 2016-09-26\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2j.\n\n\n.. _v1-5-1:\n\n1.5.1 - 2016-09-22\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2i.\n* Resolved a ``UserWarning`` when used with cffi 1.8.3.\n* Fixed a memory leak in name creation with X.509.\n* Added a workaround for old versions of setuptools.\n* Fixed an issue preventing ``cryptography`` from compiling against\n  OpenSSL 1.0.2i.\n\n\n\n.. _v1-5:\n\n1.5 - 2016-08-26\n~~~~~~~~~~~~~~~~\n\n* Added\n  :func:`~cryptography.hazmat.primitives.asymmetric.padding.calculate_max_pss_salt_length`.\n* Added \"one shot\"\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey.sign`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey.verify`\n  methods to DSA keys.\n* Added \"one shot\"\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey.sign`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.verify`\n  methods to ECDSA keys.\n* Switched back to the older callback model on Python 3.5 in order to mitigate\n  the locking callback problem with OpenSSL <1.1.0.\n* :class:`~cryptography.x509.CertificateBuilder`,\n  :class:`~cryptography.x509.CertificateRevocationListBuilder`, and\n  :class:`~cryptography.x509.RevokedCertificateBuilder` now accept timezone\n  aware ``datetime`` objects as method arguments\n* ``cryptography`` now supports OpenSSL 1.1.0 as a compilation target.\n\n\n\n.. _v1-4:\n\n1.4 - 2016-06-04\n~~~~~~~~~~~~~~~~\n\n* Support for OpenSSL 0.9.8 has been removed. Users on older versions of\n  OpenSSL will need to upgrade.\n* Added :class:`~cryptography.hazmat.primitives.kdf.kbkdf.KBKDFHMAC`.\n* Added support for ``OpenSSH`` public key serialization.\n* Added support for SHA-2 in RSA\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.OAEP` when using\n  OpenSSL 1.0.2 or greater.\n* Added \"one shot\"\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey.sign`\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey.verify`\n  methods to RSA keys.\n* Deprecated the ``serial`` attribute on\n  :class:`~cryptography.x509.Certificate`, in favor of\n  :attr:`~cryptography.x509.Certificate.serial_number`.\n\n\n\n.. _v1-3-4:\n\n1.3.4 - 2016-06-03\n~~~~~~~~~~~~~~~~~~\n\n* Added another OpenSSL function to the bindings to support an upcoming\n  ``pyOpenSSL`` release.\n\n\n\n.. _v1-3-3:\n\n1.3.3 - 2016-06-02\n~~~~~~~~~~~~~~~~~~\n\n* Added two new OpenSSL functions to the bindings to support an upcoming\n  ``pyOpenSSL`` release.\n\n\n.. _v1-3-2:\n\n1.3.2 - 2016-05-04\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2h.\n* Fixed an issue preventing ``cryptography`` from compiling against\n  LibreSSL 2.3.x.\n\n\n.. _v1-3-1:\n\n1.3.1 - 2016-03-21\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a bug that caused an ``AttributeError`` when using ``mock`` to patch\n  some ``cryptography`` modules.\n\n\n.. _v1-3:\n\n1.3 - 2016-03-18\n~~~~~~~~~~~~~~~~\n\n* Added support for padding ANSI X.923 with\n  :class:`~cryptography.hazmat.primitives.padding.ANSIX923`.\n* Deprecated support for OpenSSL 0.9.8. Support will be removed in\n  ``cryptography`` 1.4.\n* Added support for the :class:`~cryptography.x509.PolicyConstraints`\n  X.509 extension including both parsing and generation using\n  :class:`~cryptography.x509.CertificateBuilder` and\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`.\n* Added :attr:`~cryptography.x509.CertificateSigningRequest.is_signature_valid`\n  to :class:`~cryptography.x509.CertificateSigningRequest`.\n* Fixed an intermittent ``AssertionError`` when performing an RSA decryption on\n  an invalid ciphertext, ``ValueError`` is now correctly raised in all cases.\n* Added\n  :meth:`~cryptography.x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier`.\n\n\n.. _v1-2-3:\n\n1.2.3 - 2016-03-01\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2g.\n\n\n.. _v1-2-2:\n\n1.2.2 - 2016-01-29\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2f.\n\n\n.. _v1-2-1:\n\n1.2.1 - 2016-01-08\n~~~~~~~~~~~~~~~~~~\n\n* Reverts a change to an OpenSSL ``EVP_PKEY`` object that caused errors with\n  ``pyOpenSSL``.\n\n\n.. _v1-2:\n\n1.2 - 2016-01-08\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:**\n  :class:`~cryptography.x509.RevokedCertificate`\n  :attr:`~cryptography.x509.RevokedCertificate.extensions` now uses extension\n  classes rather than returning raw values inside the\n  :class:`~cryptography.x509.Extension`\n  :attr:`~cryptography.x509.Extension.value`. The new classes\n  are:\n\n  * :class:`~cryptography.x509.CertificateIssuer`\n  * :class:`~cryptography.x509.CRLReason`\n  * :class:`~cryptography.x509.InvalidityDate`\n* Deprecated support for OpenSSL 0.9.8 and 1.0.0. At this time there is no time\n  table for actually dropping support, however we strongly encourage all users\n  to upgrade, as those versions no longer receive support from the OpenSSL\n  project.\n* The :class:`~cryptography.x509.Certificate` class now has\n  :attr:`~cryptography.x509.Certificate.signature` and\n  :attr:`~cryptography.x509.Certificate.tbs_certificate_bytes` attributes.\n* The :class:`~cryptography.x509.CertificateSigningRequest` class now has\n  :attr:`~cryptography.x509.CertificateSigningRequest.signature` and\n  :attr:`~cryptography.x509.CertificateSigningRequest.tbs_certrequest_bytes`\n  attributes.\n* The :class:`~cryptography.x509.CertificateRevocationList` class now has\n  :attr:`~cryptography.x509.CertificateRevocationList.signature` and\n  :attr:`~cryptography.x509.CertificateRevocationList.tbs_certlist_bytes`\n  attributes.\n* :class:`~cryptography.x509.NameConstraints` are now supported in the\n  :class:`~cryptography.x509.CertificateBuilder` and\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`.\n* Support serialization of certificate revocation lists using the\n  :meth:`~cryptography.x509.CertificateRevocationList.public_bytes` method of\n  :class:`~cryptography.x509.CertificateRevocationList`.\n* Add support for parsing :class:`~cryptography.x509.CertificateRevocationList`\n  :meth:`~cryptography.x509.CertificateRevocationList.extensions` in the\n  OpenSSL backend. The following extensions are currently supported:\n\n  * :class:`~cryptography.x509.AuthorityInformationAccess`\n  * :class:`~cryptography.x509.AuthorityKeyIdentifier`\n  * :class:`~cryptography.x509.CRLNumber`\n  * :class:`~cryptography.x509.IssuerAlternativeName`\n* Added :class:`~cryptography.x509.CertificateRevocationListBuilder` and\n  :class:`~cryptography.x509.RevokedCertificateBuilder` to allow creation of\n  CRLs.\n* Unrecognized non-critical X.509 extensions are now parsed into an\n  :class:`~cryptography.x509.UnrecognizedExtension` object.\n\n\n.. _v1-1-2:\n\n1.1.2 - 2015-12-10\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a SIGBUS crash with the OS X wheels caused by redefinition of a\n  method.\n* Fixed a runtime error ``undefined symbol EC_GFp_nistp224_method`` that\n  occurred with some OpenSSL installations.\n* Updated Windows and OS X wheels to be compiled against OpenSSL 1.0.2e.\n\n\n.. _v1-1-1:\n\n1.1.1 - 2015-11-19\n~~~~~~~~~~~~~~~~~~\n\n* Fixed several small bugs related to compiling the OpenSSL bindings with\n  unusual OpenSSL configurations.\n* Resolved an issue where, depending on the method of installation and\n  which Python interpreter they were using, users on El Capitan (OS X 10.11)\n  may have seen an ``InternalError`` on import.\n\n\n.. _v1-1:\n\n1.1 - 2015-10-28\n~~~~~~~~~~~~~~~~\n\n* Added support for Elliptic Curve Diffie-Hellman with\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.ECDH`.\n* Added :class:`~cryptography.hazmat.primitives.kdf.x963kdf.X963KDF`.\n* Added support for parsing certificate revocation lists (CRLs) using\n  :func:`~cryptography.x509.load_pem_x509_crl` and\n  :func:`~cryptography.x509.load_der_x509_crl`.\n* Add support for AES key wrapping with\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_wrap` and\n  :func:`~cryptography.hazmat.primitives.keywrap.aes_key_unwrap`.\n* Added a ``__hash__`` method to :class:`~cryptography.x509.Name`.\n* Add support for encoding and decoding elliptic curve points to a byte string\n  form using\n  ``cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.encode_point``\n  and\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers.from_encoded_point`.\n* Added :meth:`~cryptography.x509.Extensions.get_extension_for_class`.\n* :class:`~cryptography.x509.CertificatePolicies` are now supported in the\n  :class:`~cryptography.x509.CertificateBuilder`.\n* ``countryName`` is now encoded as a ``PrintableString`` when creating subject\n  and issuer distinguished names with the Certificate and CSR builder classes.\n\n\n.. _v1-0-2:\n\n1.0.2 - 2015-09-27\n~~~~~~~~~~~~~~~~~~\n* **SECURITY ISSUE**: The OpenSSL backend prior to 1.0.2 made extensive use\n  of assertions to check response codes where our tests could not trigger a\n  failure.  However, when Python is run with ``-O`` these asserts are optimized\n  away.  If a user ran Python with this flag and got an invalid response code\n  this could result in undefined behavior or worse. Accordingly, all response\n  checks from the OpenSSL backend have been converted from ``assert``\n  to a true function call. Credit **Emilia K\u0102\u00a4sper (Google Security Team)**\n  for the report.\n\n\n.. _v1-0-1:\n\n1.0.1 - 2015-09-05\n~~~~~~~~~~~~~~~~~~\n\n* We now ship OS X wheels that statically link OpenSSL by default. When\n  installing a wheel on OS X 10.10+ (and using a Python compiled against the\n  10.10 SDK) users will no longer need to compile. See :doc:`/installation` for\n  alternate installation methods if required.\n* Set the default string mask to UTF-8 in the OpenSSL backend to resolve\n  character encoding issues with older versions of OpenSSL.\n* Several new OpenSSL bindings have been added to support a future pyOpenSSL\n  release.\n* Raise an error during install on PyPy < 2.6. 1.0+ requires PyPy 2.6+.\n\n\n.. _v1-0:\n\n1.0 - 2015-08-12\n~~~~~~~~~~~~~~~~\n\n* Switched to the new `cffi`_ ``set_source`` out-of-line API mode for\n  compilation. This results in significantly faster imports and lowered\n  memory consumption. Due to this change we no longer support PyPy releases\n  older than 2.6 nor do we support any released version of PyPy3 (until a\n  version supporting cffi 1.0 comes out).\n* Fix parsing of OpenSSH public keys that have spaces in comments.\n* Support serialization of certificate signing requests using the\n  ``public_bytes`` method of\n  :class:`~cryptography.x509.CertificateSigningRequest`.\n* Support serialization of certificates using the ``public_bytes`` method of\n  :class:`~cryptography.x509.Certificate`.\n* Add ``get_provisioning_uri`` method to\n  :class:`~cryptography.hazmat.primitives.twofactor.hotp.HOTP` and\n  :class:`~cryptography.hazmat.primitives.twofactor.totp.TOTP` for generating\n  provisioning URIs.\n* Add :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHash`\n  and :class:`~cryptography.hazmat.primitives.kdf.concatkdf.ConcatKDFHMAC`.\n* Raise a ``TypeError`` when passing objects that are not text as the value to\n  :class:`~cryptography.x509.NameAttribute`.\n* Add support for :class:`~cryptography.x509.OtherName` as a general name\n  type.\n* Added new X.509 extension support in :class:`~cryptography.x509.Certificate`\n  The following new extensions are now supported:\n\n  * :class:`~cryptography.x509.OCSPNoCheck`\n  * :class:`~cryptography.x509.InhibitAnyPolicy`\n  * :class:`~cryptography.x509.IssuerAlternativeName`\n  * :class:`~cryptography.x509.NameConstraints`\n\n* Extension support was added to\n  :class:`~cryptography.x509.CertificateSigningRequest`.\n* Add support for creating signed certificates with\n  :class:`~cryptography.x509.CertificateBuilder`. This includes support for\n  the following extensions:\n\n  * :class:`~cryptography.x509.BasicConstraints`\n  * :class:`~cryptography.x509.SubjectAlternativeName`\n  * :class:`~cryptography.x509.KeyUsage`\n  * :class:`~cryptography.x509.ExtendedKeyUsage`\n  * :class:`~cryptography.x509.SubjectKeyIdentifier`\n  * :class:`~cryptography.x509.AuthorityKeyIdentifier`\n  * :class:`~cryptography.x509.AuthorityInformationAccess`\n  * :class:`~cryptography.x509.CRLDistributionPoints`\n  * :class:`~cryptography.x509.InhibitAnyPolicy`\n  * :class:`~cryptography.x509.IssuerAlternativeName`\n  * :class:`~cryptography.x509.OCSPNoCheck`\n\n* Add support for creating certificate signing requests with\n  :class:`~cryptography.x509.CertificateSigningRequestBuilder`. This includes\n  support for the same extensions supported in the ``CertificateBuilder``.\n* Deprecate ``encode_rfc6979_signature`` and ``decode_rfc6979_signature`` in\n  favor of\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.encode_dss_signature`\n  and\n  :func:`~cryptography.hazmat.primitives.asymmetric.utils.decode_dss_signature`.\n\n\n\n.. _v0-9-3:\n\n0.9.3 - 2015-07-09\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2d.\n\n\n.. _v0-9-2:\n\n0.9.2 - 2015-07-04\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2c.\n\n\n.. _v0-9-1:\n\n0.9.1 - 2015-06-06\n~~~~~~~~~~~~~~~~~~\n\n* **SECURITY ISSUE**: Fixed a double free in the OpenSSL backend when using DSA\n  to verify signatures. Note that this only affects PyPy 2.6.0 and (presently\n  unreleased) CFFI versions greater than 1.1.0.\n\n\n.. _v0-9:\n\n0.9 - 2015-05-13\n~~~~~~~~~~~~~~~~\n\n* Removed support for Python 3.2. This version of Python is rarely used\n  and caused support headaches. Users affected by this should upgrade to 3.3+.\n* Deprecated support for Python 2.6. At the time there is no time table for\n  actually dropping support, however we strongly encourage all users to upgrade\n  their Python, as Python 2.6 no longer receives support from the Python core\n  team.\n* Add support for the\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.SECP256K1` elliptic\n  curve.\n* Fixed compilation when using an OpenSSL which was compiled with the\n  ``no-comp`` (``OPENSSL_NO_COMP``) option.\n* Support :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`\n  serialization of public keys using the ``public_bytes`` method of\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`.\n* Support :attr:`~cryptography.hazmat.primitives.serialization.Encoding.DER`\n  serialization of private keys using the ``private_bytes`` method of\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,\n  and\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`.\n* Add support for parsing X.509 certificate signing requests (CSRs) with\n  :func:`~cryptography.x509.load_pem_x509_csr` and\n  :func:`~cryptography.x509.load_der_x509_csr`.\n* Moved ``cryptography.exceptions.InvalidToken`` to\n  :class:`cryptography.hazmat.primitives.twofactor.InvalidToken` and deprecated\n  the old location. This was moved to minimize confusion between this exception\n  and :class:`cryptography.fernet.InvalidToken`.\n* Added support for X.509 extensions in :class:`~cryptography.x509.Certificate`\n  objects. The following extensions are supported as of this release:\n\n  * :class:`~cryptography.x509.BasicConstraints`\n  * :class:`~cryptography.x509.AuthorityKeyIdentifier`\n  * :class:`~cryptography.x509.SubjectKeyIdentifier`\n  * :class:`~cryptography.x509.KeyUsage`\n  * :class:`~cryptography.x509.SubjectAlternativeName`\n  * :class:`~cryptography.x509.ExtendedKeyUsage`\n  * :class:`~cryptography.x509.CRLDistributionPoints`\n  * :class:`~cryptography.x509.AuthorityInformationAccess`\n  * :class:`~cryptography.x509.CertificatePolicies`\n\n  Note that unsupported extensions with the critical flag raise\n  ``UnsupportedExtension`` while unsupported extensions set to non-critical are\n  silently ignored. Read the :doc:`X.509 documentation</x509/index>` for more\n  information.\n\n\n.. _v0-8-2:\n\n0.8.2 - 2015-04-10\n~~~~~~~~~~~~~~~~~~\n\n* Fixed a race condition when initializing the OpenSSL or CommonCrypto backends\n  in a multi-threaded scenario.\n\n\n.. _v0-8-1:\n\n0.8.1 - 2015-03-20\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2a.\n\n\n.. _v0-8:\n\n0.8 - 2015-03-08\n~~~~~~~~~~~~~~~~\n\n* :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` can\n  now load elliptic curve public keys.\n* Added\n  :attr:`~cryptography.x509.Certificate.signature_hash_algorithm` support to\n  :class:`~cryptography.x509.Certificate`.\n* Added\n  :func:`~cryptography.hazmat.primitives.asymmetric.rsa.rsa_recover_prime_factors`\n* :class:`~cryptography.hazmat.primitives.kdf.KeyDerivationFunction` was moved\n  from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.kdf`.\n* Added support for parsing X.509 names. See the\n  :doc:`X.509 documentation</x509/index>` for more information.\n* Added\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key` to\n  support loading of DER encoded private keys and\n  :func:`~cryptography.hazmat.primitives.serialization.load_der_public_key` to\n  support loading DER encoded public keys.\n* Fixed building against LibreSSL, a compile-time substitute for OpenSSL.\n* FreeBSD 9.2 was removed from the continuous integration system.\n* Updated Windows wheels to be compiled against OpenSSL 1.0.2.\n* :func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key`\n  and :func:`~cryptography.hazmat.primitives.serialization.load_der_public_key`\n  now support PKCS1 RSA public keys (in addition to the previous support for\n  SubjectPublicKeyInfo format for RSA, EC, and DSA).\n* Added ``EllipticCurvePrivateKeyWithSerialization`` and deprecated\n  ``EllipticCurvePrivateKeyWithNumbers``.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`.\n* Added ``RSAPrivateKeyWithSerialization`` and deprecated ``RSAPrivateKeyWithNumbers``.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`.\n* Added ``DSAPrivateKeyWithSerialization`` and deprecated ``DSAPrivateKeyWithNumbers``.\n* Added\n  :meth:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey.private_bytes`\n  to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`.\n* Added ``RSAPublicKeyWithSerialization`` and deprecated ``RSAPublicKeyWithNumbers``.\n* Added ``public_bytes`` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.\n* Added ``EllipticCurvePublicKeyWithSerialization`` and deprecated\n  ``EllipticCurvePublicKeyWithNumbers``.\n* Added ``public_bytes`` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`.\n* Added ``DSAPublicKeyWithSerialization`` and deprecated ``DSAPublicKeyWithNumbers``.\n* Added ``public_bytes`` to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`.\n* :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm` and\n  :class:`~cryptography.hazmat.primitives.hashes.HashContext` were moved from\n  ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.hashes`.\n* :class:`~cryptography.hazmat.primitives.ciphers.CipherContext`,\n  :class:`~cryptography.hazmat.primitives.ciphers.AEADCipherContext`,\n  :class:`~cryptography.hazmat.primitives.ciphers.AEADEncryptionContext`,\n  :class:`~cryptography.hazmat.primitives.ciphers.CipherAlgorithm`, and\n  :class:`~cryptography.hazmat.primitives.ciphers.BlockCipherAlgorithm`\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.ciphers`.\n* :class:`~cryptography.hazmat.primitives.ciphers.modes.Mode`,\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithInitializationVector`,\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithNonce`, and\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.ModeWithAuthenticationTag`\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.ciphers.modes`.\n* :class:`~cryptography.hazmat.primitives.padding.PaddingContext` was moved\n  from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.padding`.\n*\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.AsymmetricPadding`\n  was moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.padding`.\n* ``AsymmetricSignatureContext`` and ``AsymmetricVerificationContext``\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  ``cryptography.hazmat.primitives.asymmetric``.\n* :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`,\n  ``DSAParametersWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`,\n  ``DSAPrivateKeyWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey` and\n  ``DSAPublicKeyWithNumbers`` were moved from\n  ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.dsa`\n* :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurve`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurveSignatureAlgorithm`,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePrivateKey`,\n  ``EllipticCurvePrivateKeyWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey`,\n  and ``EllipticCurvePublicKeyWithNumbers``\n  were moved from ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.ec`.\n* :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`,\n  ``RSAPrivateKeyWithNumbers``,\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey` and\n  ``RSAPublicKeyWithNumbers`` were moved from\n  ``cryptography.hazmat.primitives.interfaces`` to\n  :mod:`~cryptography.hazmat.primitives.asymmetric.rsa`.\n\n\n.. _v0-7-2:\n\n0.7.2 - 2015-01-16\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.1l.\n* ``enum34`` is no longer installed on Python 3.4, where it is included in\n  the standard library.\n* Added a new function to the OpenSSL bindings to support additional\n  functionality in pyOpenSSL.\n\n\n.. _v0-7-1:\n\n0.7.1 - 2014-12-28\n~~~~~~~~~~~~~~~~~~\n\n* Fixed an issue preventing compilation on platforms where ``OPENSSL_NO_SSL3``\n  was defined.\n\n\n.. _v0-7:\n\n0.7 - 2014-12-17\n~~~~~~~~~~~~~~~~\n\n* Cryptography has been relicensed from the Apache Software License, Version\n  2.0, to being available under *either* the Apache Software License, Version\n  2.0, or the BSD license.\n* Added key-rotation support to :doc:`Fernet </fernet>` with\n  :class:`~cryptography.fernet.MultiFernet`.\n* More bit-lengths are now supported for ``p`` and ``q`` when loading DSA keys\n  from numbers.\n* Added ``MACContext`` as a common interface for CMAC and HMAC and\n  deprecated ``CMACContext``.\n* Added support for encoding and decoding :rfc:`6979` signatures in\n  :doc:`/hazmat/primitives/asymmetric/utils`.\n* Added\n  :func:`~cryptography.hazmat.primitives.serialization.load_ssh_public_key` to\n  support the loading of OpenSSH public keys (:rfc:`4253`). Only RSA and DSA\n  keys are currently supported.\n* Added initial support for X.509 certificate parsing. See the\n  :doc:`X.509 documentation</x509/index>` for more information.\n\n\n.. _v0-6-1:\n\n0.6.1 - 2014-10-15\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.1j.\n* Fixed an issue where OpenSSL 1.0.1j changed the errors returned by some\n  functions.\n* Added our license file to the ``cryptography-vectors`` package.\n* Implemented DSA hash truncation support (per FIPS 186-3) in the OpenSSL\n  backend. This works around an issue in 1.0.0, 1.0.0a, and 1.0.0b where\n  truncation was not implemented.\n\n\n.. _v0-6:\n\n0.6 - 2014-09-29\n~~~~~~~~~~~~~~~~\n\n* Added\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key` to\n  ease loading private keys, and\n  :func:`~cryptography.hazmat.primitives.serialization.load_pem_public_key` to\n  support loading public keys.\n* Removed the, deprecated in 0.4, support for the ``salt_length`` argument to\n  the :class:`~cryptography.hazmat.primitives.asymmetric.padding.MGF1`\n  constructor. The ``salt_length`` should be passed to\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS` instead.\n* Fix compilation on OS X Yosemite.\n* Deprecated ``elliptic_curve_private_key_from_numbers`` and\n  ``elliptic_curve_public_key_from_numbers`` in favor of\n  ``load_elliptic_curve_private_numbers`` and\n  ``load_elliptic_curve_public_numbers`` on ``EllipticCurveBackend``.\n* Added ``EllipticCurvePrivateKeyWithNumbers`` and\n  ``EllipticCurvePublicKeyWithNumbers`` support.\n* Work around three GCM related bugs in CommonCrypto and OpenSSL.\n\n  * On the CommonCrypto backend adding AAD but not subsequently calling update\n    would return null tag bytes.\n\n  * One the CommonCrypto backend a call to update without an empty add AAD call\n    would return null ciphertext bytes.\n\n  * On the OpenSSL backend with certain versions adding AAD only would give\n    invalid tag bytes.\n\n* Support loading EC private keys from PEM.\n\n\n.. _v0-5-4:\n\n0.5.4 - 2014-08-20\n~~~~~~~~~~~~~~~~~~\n\n* Added several functions to the OpenSSL bindings to support new\n  functionality in pyOpenSSL.\n* Fixed a redefined constant causing compilation failure with Solaris 11.2.\n\n\n.. _v0-5-3:\n\n0.5.3 - 2014-08-06\n~~~~~~~~~~~~~~~~~~\n\n* Updated Windows wheels to be compiled against OpenSSL 1.0.1i.\n\n\n.. _v0-5-2:\n\n0.5.2 - 2014-07-09\n~~~~~~~~~~~~~~~~~~\n\n* Add ``TraditionalOpenSSLSerializationBackend`` support to ``multibackend``.\n* Fix compilation error on OS X 10.8 (Mountain Lion).\n\n\n.. _v0-5-1:\n\n0.5.1 - 2014-07-07\n~~~~~~~~~~~~~~~~~~\n\n* Add ``PKCS8SerializationBackend`` support to ``multibackend``.\n\n\n.. _v0-5:\n\n0.5 - 2014-07-07\n~~~~~~~~~~~~~~~~\n\n* **BACKWARDS INCOMPATIBLE:**\n  :class:`~cryptography.hazmat.primitives.ciphers.modes.GCM` no longer allows\n  truncation of tags by default. Previous versions of ``cryptography`` allowed\n  tags to be truncated by default, applications wishing to preserve this\n  behavior (not recommended) can pass the ``min_tag_length`` argument.\n* Windows builds now statically link OpenSSL by default. When installing a\n  wheel on Windows you no longer need to install OpenSSL separately. Windows\n  users can switch between static and dynamic linking with an environment\n  variable. See :doc:`/installation` for more details.\n* Added :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDFExpand`.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.modes.CFB8` support\n  for :class:`~cryptography.hazmat.primitives.ciphers.algorithms.AES` and\n  :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` on\n  ``commoncrypto`` and ``openssl``.\n* Added ``AES`` :class:`~cryptography.hazmat.primitives.ciphers.modes.CTR`\n  support to the OpenSSL backend when linked against 0.9.8.\n* Added ``PKCS8SerializationBackend`` and\n  ``TraditionalOpenSSLSerializationBackend`` support to ``openssl``.\n* Added :doc:`/hazmat/primitives/asymmetric/ec` and ``EllipticCurveBackend``.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.modes.ECB` support\n  for :class:`~cryptography.hazmat.primitives.ciphers.algorithms.TripleDES` on\n  ``commoncrypto`` and ``openssl``.\n* Deprecated the concrete ``RSAPrivateKey`` class in favor of backend\n  specific providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`\n  interface.\n* Deprecated the concrete ``RSAPublicKey`` in favor of backend specific\n  providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`\n  interface.\n* Deprecated the concrete ``DSAPrivateKey`` class in favor of backend\n  specific providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`\n  interface.\n* Deprecated the concrete ``DSAPublicKey`` class in favor of backend specific\n  providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`\n  interface.\n* Deprecated the concrete ``DSAParameters`` class in favor of backend specific\n  providers of the\n  :class:`cryptography.hazmat.primitives.asymmetric.dsa.DSAParameters`\n  interface.\n* Deprecated ``encrypt_rsa``, ``decrypt_rsa``, ``create_rsa_signature_ctx`` and\n  ``create_rsa_verification_ctx`` on ``RSABackend``.\n* Deprecated ``create_dsa_signature_ctx`` and ``create_dsa_verification_ctx``\n  on ``DSABackend``.\n\n\n.. _v0-4:\n\n0.4 - 2014-05-03\n~~~~~~~~~~~~~~~~\n\n* Deprecated ``salt_length`` on\n  :class:`~cryptography.hazmat.primitives.asymmetric.padding.MGF1` and added it\n  to :class:`~cryptography.hazmat.primitives.asymmetric.padding.PSS`. It will\n  be removed from ``MGF1`` in two releases per our :doc:`/api-stability`\n  policy.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.SEED`\n  support.\n* Added :class:`~cryptography.hazmat.primitives.cmac.CMAC`.\n* Added decryption support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`\n  and encryption support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.\n* Added signature support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPrivateKey`\n  and verification support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.dsa.DSAPublicKey`.\n\n\n.. _v0-3:\n\n0.3 - 2014-03-27\n~~~~~~~~~~~~~~~~\n\n* Added :class:`~cryptography.hazmat.primitives.twofactor.hotp.HOTP`.\n* Added :class:`~cryptography.hazmat.primitives.twofactor.totp.TOTP`.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.IDEA`\n  support.\n* Added signature support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`\n  and verification support to\n  :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`.\n* Moved test vectors to the new ``cryptography_vectors`` package.\n\n\n.. _v0-2-2:\n\n0.2.2 - 2014-03-03\n~~~~~~~~~~~~~~~~~~\n\n* Removed a constant definition that was causing compilation problems with\n  specific versions of OpenSSL.\n\n\n.. _v0-2-1:\n\n0.2.1 - 2014-02-22\n~~~~~~~~~~~~~~~~~~\n\n* Fix a bug where importing cryptography from multiple paths could cause\n  initialization to fail.\n\n\n.. _v0-2:\n\n0.2 - 2014-02-20\n~~~~~~~~~~~~~~~~\n\n* Added ``commoncrypto``.\n* Added initial ``commoncrypto``.\n* Removed ``register_cipher_adapter`` method from ``CipherBackend``.\n* Added support for the OpenSSL backend under Windows.\n* Improved thread-safety for the OpenSSL backend.\n* Fixed compilation on systems where OpenSSL's ``ec.h`` header is not\n  available, such as CentOS.\n* Added :class:`~cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC`.\n* Added :class:`~cryptography.hazmat.primitives.kdf.hkdf.HKDF`.\n* Added ``multibackend``.\n* Set default random for ``openssl`` to the OS random engine.\n* Added :class:`~cryptography.hazmat.primitives.ciphers.algorithms.CAST5`\n  (CAST-128) support.\n\n\n.. _v0-1:\n\n0.1 - 2014-01-08\n~~~~~~~~~~~~~~~~\n\n* Initial release.\n\n.. _`as documented here`: https://docs.rs/openssl/latest/openssl/#automatic\n.. _`main`: https://github.com/pyca/cryptography/\n.. _`cffi`: https://cffi.readthedocs.io/\n", "AArch\naccessor\naffine\nAuthenticator\nauthenticator\nbackend\nBackends\nbackends\nbcrypt\nBleichenbacher\nBlowfish\nboolean\nBoringSSL\nBotan\nBrainpool\nBullseye\nCapitan\nCentOS\nchangelog\nChangelog\nciphertext\ncodebook\ncommitter\ncommitters\nconda\nCPython\nCryptanalysis\ncrypto\ncryptographic\ncryptographically\nde\nDebian\ndeallocated\ndecrypt\ndecrypts\nDecrypts\ndecrypted\ndecrypting\ndeprecations\nDER\ndereference\ndeserialize\ndeserialized\nDeserialization\ndeserializing\nDiffie\nDiffie\ndisambiguating\nDjango\nDocstrings\nEl\nEncodings\nendian\nextendable\nfacto\nfallback\nFernet\nfernet\nFIPS\nGoogle\nhazmat\nHomebrew\nhostname\nhostnames\nimplementor\nincrementing\nindistinguishability\ninitialisms\ninteroperability\ninteroperable\nintrospectability\ninvariants\niOS\niterable\nKerberos\nKeychain\nKoblitz\nLange\nlogins\nmetadata\nMGF\nMonterey\nMozilla\nmulti\nnamespace\nnamespaces\nmacOS\nna\u00efve\nNonces\nnonces\nonline\npaddings\nParallelization\npersonalization\nRHEL\nparsers\nParsers\nPEM\npickleable\nplaintext\nPoly\npre\nprecompute\nprecomputed\npreprocessor\npreprocessors\npresentational\npseudorandom\npyOpenSSL\npytest\nrelicensed\nresponder\nruntime\nSchneier\nscrypt\nserializer\nSerializers\nSHA\nSolaris\nSur\nsyscall\nTanja\ntestability\nThawte\ntimestamp\ntimestamps\ntoolchain\ntunable\nUbuntu\nunencrypted\nunicode\nunpadded\nunpadding\nVentura\nverifier\nVerifier\nVerisign\nversioning\nwildcard\nWoSign\nWycheproof\nXcode\nXEX\n", "[build-system]\nrequires = [\n    # First version of setuptools to support pyproject.toml configuration\n    \"setuptools>=61.0.0\",\n    \"wheel\",\n    # Must be kept in sync with `project.dependencies`\n    \"cffi>=1.12; platform_python_implementation != 'PyPy'\",\n    \"setuptools-rust>=0.11.4\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cryptography\"\nversion = \"41.0.6\"\nauthors = [\n    {name = \"The Python Cryptographic Authority and individual contributors\", email = \"cryptography-dev@python.org\"}\n]\ndescription = \"cryptography is a package which provides cryptographic recipes and primitives to Python developers.\"\nreadme = \"README.rst\"\nlicense = {text = \"Apache-2.0 OR BSD-3-Clause\"}\nclassifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: Apache Software License\",\n    \"License :: OSI Approved :: BSD License\",\n    \"Natural Language :: English\",\n    \"Operating System :: MacOS :: MacOS X\",\n    \"Operating System :: POSIX\",\n    \"Operating System :: POSIX :: BSD\",\n    \"Operating System :: POSIX :: Linux\",\n    'Operating System :: Microsoft :: Windows',\n    \"Programming Language :: Python\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3 :: Only\",\n    \"Programming Language :: Python :: 3.7\",\n    \"Programming Language :: Python :: 3.8\",\n    \"Programming Language :: Python :: 3.9\",\n    \"Programming Language :: Python :: 3.10\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n    \"Topic :: Security :: Cryptography\",\n]\nrequires-python = \">=3.7\"\ndependencies = [\n    # Must be kept in sync with `build-system.requires`\n    \"cffi >=1.12\",\n]\n\n[project.urls]\nhomepage = \"https://github.com/pyca/cryptography\"\ndocumentation = \"https://cryptography.io/\"\nsource = \"https://github.com/pyca/cryptography/\"\nissues = \"https://github.com/pyca/cryptography/issues\"\nchangelog = \"https://cryptography.io/en/latest/changelog/\"\n\n[tool.setuptools]\nzip-safe = false\npackage-dir = {\"\" = \"src\"}\n\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\ninclude = [\"cryptography*\"]\n\n[project.optional-dependencies]\nssh = [\"bcrypt >=3.1.5\"]\n\n# All the following are used for our own testing.\nnox = [\"nox\"]\ntest = [\n    \"pytest >=6.2.0\",\n    \"pytest-benchmark\",\n    \"pytest-cov\",\n    \"pytest-xdist\",\n    \"pretend\",\n]\ntest-randomorder = [\"pytest-randomly\"]\ndocs = [\"sphinx >=5.3.0\", \"sphinx-rtd-theme >=1.1.1\"]\ndocstest =  [\"pyenchant >=1.6.11\", \"twine >=1.12.0\", \"sphinxcontrib-spelling >=4.0.1\"]\nsdist = [\"build\"]\npep8test = [\"black\", \"ruff\", \"mypy\", \"check-sdist\"]\n\n[tool.black]\nline-length = 79\ntarget-version = [\"py37\"]\n\n[tool.pytest.ini_options]\naddopts = \"-r s --capture=no --strict-markers --benchmark-disable\"\nconsole_output_style = \"progress-even-when-capture-no\"\nmarkers = [\n    \"skip_fips: this test is not executed in FIPS mode\",\n    \"supported: parametrized test requiring only_if and skip_message\",\n]\n\n[tool.mypy]\nshow_error_codes = true\ncheck_untyped_defs = true\nno_implicit_reexport = true\nwarn_redundant_casts = true\nwarn_unused_ignores = true\nwarn_unused_configs = true\nstrict_equality = true\n\n[[tool.mypy.overrides]]\nmodule = [\n    \"pretend\"\n]\nignore_missing_imports = true\n\n[tool.coverage.run]\nbranch = true\nrelative_files = true\nsource = [\n    \"cryptography\",\n    \"tests/\",\n]\n\n[tool.coverage.paths]\nsource = [\n   \"src/cryptography\",\n   \"*.nox/*/lib*/python*/site-packages/cryptography\",\n   \"*.nox\\\\*\\\\Lib\\\\site-packages\\\\cryptography\",\n   \"*.nox/pypy/site-packages/cryptography\",\n]\ntests =[\n   \"tests/\",\n   \"*tests\\\\\",\n]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"@abc.abstractmethod\",\n    \"@typing.overload\",\n    \"if typing.TYPE_CHECKING\",\n]\n\n[tool.ruff]\n# UP006: Minimum Python 3.9\n# UP007, UP038: Minimum Python 3.10\nignore = ['N818', 'UP006', 'UP007', 'UP038']\nselect = ['E', 'F', 'I', 'N', 'W', 'UP']\nline-length = 79\n\n[tool.ruff.isort]\nknown-first-party = [\"cryptography\", \"cryptography_vectors\", \"tests\"]\n\n[tool.check-sdist]\ngit-only = [\n    \"vectors/*\",\n    \"release.py\",\n    \"ci-constraints-requirements.txt\",\n    \".gitattributes\",\n    \".gitignore\",\n]", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"__version__\",\n    \"__author__\",\n    \"__copyright__\",\n]\n\n__version__ = \"41.0.6\"\n\n\n__author__ = \"The Python Cryptographic Authority and individual contributors\"\n__copyright__ = f\"Copyright 2013-2023 {__author__}\"\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport collections\nimport contextlib\nimport itertools\nimport typing\nfrom contextlib import contextmanager\n\nfrom cryptography import utils, x509\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.backends.openssl import aead\nfrom cryptography.hazmat.backends.openssl.ciphers import _CipherContext\nfrom cryptography.hazmat.backends.openssl.cmac import _CMACContext\nfrom cryptography.hazmat.backends.openssl.ec import (\n    _EllipticCurvePrivateKey,\n    _EllipticCurvePublicKey,\n)\nfrom cryptography.hazmat.backends.openssl.rsa import (\n    _RSAPrivateKey,\n    _RSAPublicKey,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.bindings.openssl import binding\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives._asymmetric import AsymmetricPadding\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dh,\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n    x448,\n    x25519,\n)\nfrom cryptography.hazmat.primitives.asymmetric.padding import (\n    MGF1,\n    OAEP,\n    PSS,\n    PKCS1v15,\n)\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    PrivateKeyTypes,\n    PublicKeyTypes,\n)\nfrom cryptography.hazmat.primitives.ciphers import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.algorithms import (\n    AES,\n    AES128,\n    AES256,\n    ARC4,\n    SM4,\n    Camellia,\n    ChaCha20,\n    TripleDES,\n    _BlowfishInternal,\n    _CAST5Internal,\n    _IDEAInternal,\n    _SEEDInternal,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import (\n    CBC,\n    CFB,\n    CFB8,\n    CTR,\n    ECB,\n    GCM,\n    OFB,\n    XTS,\n    Mode,\n)\nfrom cryptography.hazmat.primitives.serialization import ssh\nfrom cryptography.hazmat.primitives.serialization.pkcs12 import (\n    PBES,\n    PKCS12Certificate,\n    PKCS12KeyAndCertificates,\n    PKCS12PrivateKeyTypes,\n    _PKCS12CATypes,\n)\n\n_MemoryBIO = collections.namedtuple(\"_MemoryBIO\", [\"bio\", \"char_ptr\"])\n\n\n# Not actually supported, just used as a marker for some serialization tests.\nclass _RC2:\n    pass\n\n\nclass Backend:\n    \"\"\"\n    OpenSSL API binding interfaces.\n    \"\"\"\n\n    name = \"openssl\"\n\n    # FIPS has opinions about acceptable algorithms and key sizes, but the\n    # disallowed algorithms are still present in OpenSSL. They just error if\n    # you try to use them. To avoid that we allowlist the algorithms in\n    # FIPS 140-3. This isn't ideal, but FIPS 140-3 is trash so here we are.\n    _fips_aead = {\n        b\"aes-128-ccm\",\n        b\"aes-192-ccm\",\n        b\"aes-256-ccm\",\n        b\"aes-128-gcm\",\n        b\"aes-192-gcm\",\n        b\"aes-256-gcm\",\n    }\n    # TripleDES encryption is disallowed/deprecated throughout 2023 in\n    # FIPS 140-3. To keep it simple we denylist any use of TripleDES (TDEA).\n    _fips_ciphers = (AES,)\n    # Sometimes SHA1 is still permissible. That logic is contained\n    # within the various *_supported methods.\n    _fips_hashes = (\n        hashes.SHA224,\n        hashes.SHA256,\n        hashes.SHA384,\n        hashes.SHA512,\n        hashes.SHA512_224,\n        hashes.SHA512_256,\n        hashes.SHA3_224,\n        hashes.SHA3_256,\n        hashes.SHA3_384,\n        hashes.SHA3_512,\n        hashes.SHAKE128,\n        hashes.SHAKE256,\n    )\n    _fips_ecdh_curves = (\n        ec.SECP224R1,\n        ec.SECP256R1,\n        ec.SECP384R1,\n        ec.SECP521R1,\n    )\n    _fips_rsa_min_key_size = 2048\n    _fips_rsa_min_public_exponent = 65537\n    _fips_dsa_min_modulus = 1 << 2048\n    _fips_dh_min_key_size = 2048\n    _fips_dh_min_modulus = 1 << _fips_dh_min_key_size\n\n    def __init__(self) -> None:\n        self._binding = binding.Binding()\n        self._ffi = self._binding.ffi\n        self._lib = self._binding.lib\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n        self._cipher_registry: typing.Dict[\n            typing.Tuple[typing.Type[CipherAlgorithm], typing.Type[Mode]],\n            typing.Callable,\n        ] = {}\n        self._register_default_ciphers()\n        self._dh_types = [self._lib.EVP_PKEY_DH]\n        if self._lib.Cryptography_HAS_EVP_PKEY_DHX:\n            self._dh_types.append(self._lib.EVP_PKEY_DHX)\n\n    def __repr__(self) -> str:\n        return \"<OpenSSLBackend(version: {}, FIPS: {}, Legacy: {})>\".format(\n            self.openssl_version_text(),\n            self._fips_enabled,\n            self._binding._legacy_provider_loaded,\n        )\n\n    def openssl_assert(\n        self,\n        ok: bool,\n        errors: typing.Optional[typing.List[rust_openssl.OpenSSLError]] = None,\n    ) -> None:\n        return binding._openssl_assert(self._lib, ok, errors=errors)\n\n    def _enable_fips(self) -> None:\n        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that\n        # have the FIPS provider installed properly.\n        self._binding._enable_fips()\n        assert rust_openssl.is_fips_enabled()\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n    def openssl_version_text(self) -> str:\n        \"\"\"\n        Friendly string name of the loaded OpenSSL library. This is not\n        necessarily the same version as it was compiled against.\n\n        Example: OpenSSL 1.1.1d  10 Sep 2019\n        \"\"\"\n        return self._ffi.string(\n            self._lib.OpenSSL_version(self._lib.OPENSSL_VERSION)\n        ).decode(\"ascii\")\n\n    def openssl_version_number(self) -> int:\n        return self._lib.OpenSSL_version_num()\n\n    def _evp_md_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        if algorithm.name == \"blake2b\" or algorithm.name == \"blake2s\":\n            alg = \"{}{}\".format(\n                algorithm.name, algorithm.digest_size * 8\n            ).encode(\"ascii\")\n        else:\n            alg = algorithm.name.encode(\"ascii\")\n\n        evp_md = self._lib.EVP_get_digestbyname(alg)\n        return evp_md\n\n    def _evp_md_non_null_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        self.openssl_assert(evp_md != self._ffi.NULL)\n        return evp_md\n\n    def hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and not isinstance(algorithm, self._fips_hashes):\n            return False\n\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        return evp_md != self._ffi.NULL\n\n    def signature_hash_supported(\n        self, algorithm: hashes.HashAlgorithm\n    ) -> bool:\n        # Dedicated check for hashing algorithm use in message digest for\n        # signatures, e.g. RSA PKCS#1 v1.5 SHA1 (sha1WithRSAEncryption).\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n        return self.hash_supported(algorithm)\n\n    def scrypt_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        else:\n            return self._lib.Cryptography_HAS_SCRYPT == 1\n\n    def hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        # FIPS mode still allows SHA1 for HMAC\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return True\n\n        return self.hash_supported(algorithm)\n\n    def cipher_supported(self, cipher: CipherAlgorithm, mode: Mode) -> bool:\n        if self._fips_enabled:\n            # FIPS mode requires AES. TripleDES is disallowed/deprecated in\n            # FIPS 140-3.\n            if not isinstance(cipher, self._fips_ciphers):\n                return False\n\n        try:\n            adapter = self._cipher_registry[type(cipher), type(mode)]\n        except KeyError:\n            return False\n        evp_cipher = adapter(self, cipher, mode)\n        return self._ffi.NULL != evp_cipher\n\n    def register_cipher_adapter(self, cipher_cls, mode_cls, adapter) -> None:\n        if (cipher_cls, mode_cls) in self._cipher_registry:\n            raise ValueError(\n                \"Duplicate registration for: {} {}.\".format(\n                    cipher_cls, mode_cls\n                )\n            )\n        self._cipher_registry[cipher_cls, mode_cls] = adapter\n\n    def _register_default_ciphers(self) -> None:\n        for cipher_cls in [AES, AES128, AES256]:\n            for mode_cls in [CBC, CTR, ECB, OFB, CFB, CFB8, GCM]:\n                self.register_cipher_adapter(\n                    cipher_cls,\n                    mode_cls,\n                    GetCipherByName(\n                        \"{cipher.name}-{cipher.key_size}-{mode.name}\"\n                    ),\n                )\n        for mode_cls in [CBC, CTR, ECB, OFB, CFB]:\n            self.register_cipher_adapter(\n                Camellia,\n                mode_cls,\n                GetCipherByName(\"{cipher.name}-{cipher.key_size}-{mode.name}\"),\n            )\n        for mode_cls in [CBC, CFB, CFB8, OFB]:\n            self.register_cipher_adapter(\n                TripleDES, mode_cls, GetCipherByName(\"des-ede3-{mode.name}\")\n            )\n        self.register_cipher_adapter(\n            TripleDES, ECB, GetCipherByName(\"des-ede3\")\n        )\n        self.register_cipher_adapter(\n            ChaCha20, type(None), GetCipherByName(\"chacha20\")\n        )\n        self.register_cipher_adapter(AES, XTS, _get_xts_cipher)\n        for mode_cls in [ECB, CBC, OFB, CFB, CTR]:\n            self.register_cipher_adapter(\n                SM4, mode_cls, GetCipherByName(\"sm4-{mode.name}\")\n            )\n        # Don't register legacy ciphers if they're unavailable. Hypothetically\n        # this wouldn't be necessary because we test availability by seeing if\n        # we get an EVP_CIPHER * in the _CipherContext __init__, but OpenSSL 3\n        # will return a valid pointer even though the cipher is unavailable.\n        if (\n            self._binding._legacy_provider_loaded\n            or not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n        ):\n            for mode_cls in [CBC, CFB, OFB, ECB]:\n                self.register_cipher_adapter(\n                    _BlowfishInternal,\n                    mode_cls,\n                    GetCipherByName(\"bf-{mode.name}\"),\n                )\n            for mode_cls in [CBC, CFB, OFB, ECB]:\n                self.register_cipher_adapter(\n                    _SEEDInternal,\n                    mode_cls,\n                    GetCipherByName(\"seed-{mode.name}\"),\n                )\n            for cipher_cls, mode_cls in itertools.product(\n                [_CAST5Internal, _IDEAInternal],\n                [CBC, OFB, CFB, ECB],\n            ):\n                self.register_cipher_adapter(\n                    cipher_cls,\n                    mode_cls,\n                    GetCipherByName(\"{cipher.name}-{mode.name}\"),\n                )\n            self.register_cipher_adapter(\n                ARC4, type(None), GetCipherByName(\"rc4\")\n            )\n            # We don't actually support RC2, this is just used by some tests.\n            self.register_cipher_adapter(\n                _RC2, type(None), GetCipherByName(\"rc2\")\n            )\n\n    def create_symmetric_encryption_ctx(\n        self, cipher: CipherAlgorithm, mode: Mode\n    ) -> _CipherContext:\n        return _CipherContext(self, cipher, mode, _CipherContext._ENCRYPT)\n\n    def create_symmetric_decryption_ctx(\n        self, cipher: CipherAlgorithm, mode: Mode\n    ) -> _CipherContext:\n        return _CipherContext(self, cipher, mode, _CipherContext._DECRYPT)\n\n    def pbkdf2_hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        return self.hmac_supported(algorithm)\n\n    def _consume_errors(self) -> typing.List[rust_openssl.OpenSSLError]:\n        return rust_openssl.capture_error_stack()\n\n    def _bn_to_int(self, bn) -> int:\n        assert bn != self._ffi.NULL\n        self.openssl_assert(not self._lib.BN_is_negative(bn))\n\n        bn_num_bytes = self._lib.BN_num_bytes(bn)\n        bin_ptr = self._ffi.new(\"unsigned char[]\", bn_num_bytes)\n        bin_len = self._lib.BN_bn2bin(bn, bin_ptr)\n        # A zero length means the BN has value 0\n        self.openssl_assert(bin_len >= 0)\n        val = int.from_bytes(self._ffi.buffer(bin_ptr)[:bin_len], \"big\")\n        return val\n\n    def _int_to_bn(self, num: int):\n        \"\"\"\n        Converts a python integer to a BIGNUM. The returned BIGNUM will not\n        be garbage collected (to support adding them to structs that take\n        ownership of the object). Be sure to register it for GC if it will\n        be discarded after use.\n        \"\"\"\n        binary = num.to_bytes(int(num.bit_length() / 8.0 + 1), \"big\")\n        bn_ptr = self._lib.BN_bin2bn(binary, len(binary), self._ffi.NULL)\n        self.openssl_assert(bn_ptr != self._ffi.NULL)\n        return bn_ptr\n\n    def generate_rsa_private_key(\n        self, public_exponent: int, key_size: int\n    ) -> rsa.RSAPrivateKey:\n        rsa._verify_rsa_parameters(public_exponent, key_size)\n\n        rsa_cdata = self._lib.RSA_new()\n        self.openssl_assert(rsa_cdata != self._ffi.NULL)\n        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n\n        bn = self._int_to_bn(public_exponent)\n        bn = self._ffi.gc(bn, self._lib.BN_free)\n\n        res = self._lib.RSA_generate_key_ex(\n            rsa_cdata, key_size, bn, self._ffi.NULL\n        )\n        self.openssl_assert(res == 1)\n        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n\n        # We can skip RSA key validation here since we just generated the key\n        return _RSAPrivateKey(\n            self, rsa_cdata, evp_pkey, unsafe_skip_rsa_key_validation=True\n        )\n\n    def generate_rsa_parameters_supported(\n        self, public_exponent: int, key_size: int\n    ) -> bool:\n        return (\n            public_exponent >= 3\n            and public_exponent & 1 != 0\n            and key_size >= 512\n        )\n\n    def load_rsa_private_numbers(\n        self,\n        numbers: rsa.RSAPrivateNumbers,\n        unsafe_skip_rsa_key_validation: bool,\n    ) -> rsa.RSAPrivateKey:\n        rsa._check_private_key_components(\n            numbers.p,\n            numbers.q,\n            numbers.d,\n            numbers.dmp1,\n            numbers.dmq1,\n            numbers.iqmp,\n            numbers.public_numbers.e,\n            numbers.public_numbers.n,\n        )\n        rsa_cdata = self._lib.RSA_new()\n        self.openssl_assert(rsa_cdata != self._ffi.NULL)\n        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n        p = self._int_to_bn(numbers.p)\n        q = self._int_to_bn(numbers.q)\n        d = self._int_to_bn(numbers.d)\n        dmp1 = self._int_to_bn(numbers.dmp1)\n        dmq1 = self._int_to_bn(numbers.dmq1)\n        iqmp = self._int_to_bn(numbers.iqmp)\n        e = self._int_to_bn(numbers.public_numbers.e)\n        n = self._int_to_bn(numbers.public_numbers.n)\n        res = self._lib.RSA_set0_factors(rsa_cdata, p, q)\n        self.openssl_assert(res == 1)\n        res = self._lib.RSA_set0_key(rsa_cdata, n, e, d)\n        self.openssl_assert(res == 1)\n        res = self._lib.RSA_set0_crt_params(rsa_cdata, dmp1, dmq1, iqmp)\n        self.openssl_assert(res == 1)\n        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n\n        return _RSAPrivateKey(\n            self,\n            rsa_cdata,\n            evp_pkey,\n            unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,\n        )\n\n    def load_rsa_public_numbers(\n        self, numbers: rsa.RSAPublicNumbers\n    ) -> rsa.RSAPublicKey:\n        rsa._check_public_key_components(numbers.e, numbers.n)\n        rsa_cdata = self._lib.RSA_new()\n        self.openssl_assert(rsa_cdata != self._ffi.NULL)\n        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n        e = self._int_to_bn(numbers.e)\n        n = self._int_to_bn(numbers.n)\n        res = self._lib.RSA_set0_key(rsa_cdata, n, e, self._ffi.NULL)\n        self.openssl_assert(res == 1)\n        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n\n        return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n\n    def _create_evp_pkey_gc(self):\n        evp_pkey = self._lib.EVP_PKEY_new()\n        self.openssl_assert(evp_pkey != self._ffi.NULL)\n        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n        return evp_pkey\n\n    def _rsa_cdata_to_evp_pkey(self, rsa_cdata):\n        evp_pkey = self._create_evp_pkey_gc()\n        res = self._lib.EVP_PKEY_set1_RSA(evp_pkey, rsa_cdata)\n        self.openssl_assert(res == 1)\n        return evp_pkey\n\n    def _bytes_to_bio(self, data: bytes) -> _MemoryBIO:\n        \"\"\"\n        Return a _MemoryBIO namedtuple of (BIO, char*).\n\n        The char* is the storage for the BIO and it must stay alive until the\n        BIO is finished with.\n        \"\"\"\n        data_ptr = self._ffi.from_buffer(data)\n        bio = self._lib.BIO_new_mem_buf(data_ptr, len(data))\n        self.openssl_assert(bio != self._ffi.NULL)\n\n        return _MemoryBIO(self._ffi.gc(bio, self._lib.BIO_free), data_ptr)\n\n    def _create_mem_bio_gc(self):\n        \"\"\"\n        Creates an empty memory BIO.\n        \"\"\"\n        bio_method = self._lib.BIO_s_mem()\n        self.openssl_assert(bio_method != self._ffi.NULL)\n        bio = self._lib.BIO_new(bio_method)\n        self.openssl_assert(bio != self._ffi.NULL)\n        bio = self._ffi.gc(bio, self._lib.BIO_free)\n        return bio\n\n    def _read_mem_bio(self, bio) -> bytes:\n        \"\"\"\n        Reads a memory BIO. This only works on memory BIOs.\n        \"\"\"\n        buf = self._ffi.new(\"char **\")\n        buf_len = self._lib.BIO_get_mem_data(bio, buf)\n        self.openssl_assert(buf_len > 0)\n        self.openssl_assert(buf[0] != self._ffi.NULL)\n        bio_data = self._ffi.buffer(buf[0], buf_len)[:]\n        return bio_data\n\n    def _evp_pkey_to_private_key(\n        self, evp_pkey, unsafe_skip_rsa_key_validation: bool\n    ) -> PrivateKeyTypes:\n        \"\"\"\n        Return the appropriate type of PrivateKey given an evp_pkey cdata\n        pointer.\n        \"\"\"\n\n        key_type = self._lib.EVP_PKEY_id(evp_pkey)\n\n        if key_type == self._lib.EVP_PKEY_RSA:\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            return _RSAPrivateKey(\n                self,\n                rsa_cdata,\n                evp_pkey,\n                unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,\n            )\n        elif (\n            key_type == self._lib.EVP_PKEY_RSA_PSS\n            and not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n            and not self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111E\n        ):\n            # At the moment the way we handle RSA PSS keys is to strip the\n            # PSS constraints from them and treat them as normal RSA keys\n            # Unfortunately the RSA * itself tracks this data so we need to\n            # extract, serialize, and reload it without the constraints.\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            bio = self._create_mem_bio_gc()\n            res = self._lib.i2d_RSAPrivateKey_bio(bio, rsa_cdata)\n            self.openssl_assert(res == 1)\n            return self.load_der_private_key(\n                self._read_mem_bio(bio),\n                password=None,\n                unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,\n            )\n        elif key_type == self._lib.EVP_PKEY_DSA:\n            return rust_openssl.dsa.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_EC:\n            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)\n            self.openssl_assert(ec_cdata != self._ffi.NULL)\n            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)\n            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n        elif key_type in self._dh_types:\n            return rust_openssl.dh.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED25519\", None):\n            # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed25519.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_X448\", None):\n            # EVP_PKEY_X448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.x448.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_X25519:\n            return rust_openssl.x25519.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED448\", None):\n            # EVP_PKEY_ED448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed448.private_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        else:\n            raise UnsupportedAlgorithm(\"Unsupported key type.\")\n\n    def _evp_pkey_to_public_key(self, evp_pkey) -> PublicKeyTypes:\n        \"\"\"\n        Return the appropriate type of PublicKey given an evp_pkey cdata\n        pointer.\n        \"\"\"\n\n        key_type = self._lib.EVP_PKEY_id(evp_pkey)\n\n        if key_type == self._lib.EVP_PKEY_RSA:\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n        elif (\n            key_type == self._lib.EVP_PKEY_RSA_PSS\n            and not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n            and not self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111E\n        ):\n            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)\n            self.openssl_assert(rsa_cdata != self._ffi.NULL)\n            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n            bio = self._create_mem_bio_gc()\n            res = self._lib.i2d_RSAPublicKey_bio(bio, rsa_cdata)\n            self.openssl_assert(res == 1)\n            return self.load_der_public_key(self._read_mem_bio(bio))\n        elif key_type == self._lib.EVP_PKEY_DSA:\n            return rust_openssl.dsa.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_EC:\n            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)\n            if ec_cdata == self._ffi.NULL:\n                errors = self._consume_errors()\n                raise ValueError(\"Unable to load EC key\", errors)\n            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)\n            return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)\n        elif key_type in self._dh_types:\n            return rust_openssl.dh.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED25519\", None):\n            # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed25519.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_X448\", None):\n            # EVP_PKEY_X448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.x448.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == self._lib.EVP_PKEY_X25519:\n            return rust_openssl.x25519.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        elif key_type == getattr(self._lib, \"EVP_PKEY_ED448\", None):\n            # EVP_PKEY_ED448 is not present in CRYPTOGRAPHY_IS_LIBRESSL\n            return rust_openssl.ed448.public_key_from_ptr(\n                int(self._ffi.cast(\"uintptr_t\", evp_pkey))\n            )\n        else:\n            raise UnsupportedAlgorithm(\"Unsupported key type.\")\n\n    def _oaep_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n\n        return isinstance(\n            algorithm,\n            (\n                hashes.SHA1,\n                hashes.SHA224,\n                hashes.SHA256,\n                hashes.SHA384,\n                hashes.SHA512,\n            ),\n        )\n\n    def rsa_padding_supported(self, padding: AsymmetricPadding) -> bool:\n        if isinstance(padding, PKCS1v15):\n            return True\n        elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):\n            # SHA1 is permissible in MGF1 in FIPS even when SHA1 is blocked\n            # as signature algorithm.\n            if self._fips_enabled and isinstance(\n                padding._mgf._algorithm, hashes.SHA1\n            ):\n                return True\n            else:\n                return self.hash_supported(padding._mgf._algorithm)\n        elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):\n            return self._oaep_hash_supported(\n                padding._mgf._algorithm\n            ) and self._oaep_hash_supported(padding._algorithm)\n        else:\n            return False\n\n    def rsa_encryption_supported(self, padding: AsymmetricPadding) -> bool:\n        if self._fips_enabled and isinstance(padding, PKCS1v15):\n            return False\n        else:\n            return self.rsa_padding_supported(padding)\n\n    def generate_dsa_parameters(self, key_size: int) -> dsa.DSAParameters:\n        if key_size not in (1024, 2048, 3072, 4096):\n            raise ValueError(\n                \"Key size must be 1024, 2048, 3072, or 4096 bits.\"\n            )\n\n        return rust_openssl.dsa.generate_parameters(key_size)\n\n    def generate_dsa_private_key(\n        self, parameters: dsa.DSAParameters\n    ) -> dsa.DSAPrivateKey:\n        return parameters.generate_private_key()\n\n    def generate_dsa_private_key_and_parameters(\n        self, key_size: int\n    ) -> dsa.DSAPrivateKey:\n        parameters = self.generate_dsa_parameters(key_size)\n        return self.generate_dsa_private_key(parameters)\n\n    def load_dsa_private_numbers(\n        self, numbers: dsa.DSAPrivateNumbers\n    ) -> dsa.DSAPrivateKey:\n        dsa._check_dsa_private_numbers(numbers)\n        return rust_openssl.dsa.from_private_numbers(numbers)\n\n    def load_dsa_public_numbers(\n        self, numbers: dsa.DSAPublicNumbers\n    ) -> dsa.DSAPublicKey:\n        dsa._check_dsa_parameters(numbers.parameter_numbers)\n        return rust_openssl.dsa.from_public_numbers(numbers)\n\n    def load_dsa_parameter_numbers(\n        self, numbers: dsa.DSAParameterNumbers\n    ) -> dsa.DSAParameters:\n        dsa._check_dsa_parameters(numbers)\n        return rust_openssl.dsa.from_parameter_numbers(numbers)\n\n    def dsa_supported(self) -> bool:\n        return (\n            not self._lib.CRYPTOGRAPHY_IS_BORINGSSL and not self._fips_enabled\n        )\n\n    def dsa_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if not self.dsa_supported():\n            return False\n        return self.signature_hash_supported(algorithm)\n\n    def cmac_algorithm_supported(self, algorithm) -> bool:\n        return self.cipher_supported(\n            algorithm, CBC(b\"\\x00\" * algorithm.block_size)\n        )\n\n    def create_cmac_ctx(self, algorithm: BlockCipherAlgorithm) -> _CMACContext:\n        return _CMACContext(self, algorithm)\n\n    def load_pem_private_key(\n        self,\n        data: bytes,\n        password: typing.Optional[bytes],\n        unsafe_skip_rsa_key_validation: bool,\n    ) -> PrivateKeyTypes:\n        return self._load_key(\n            self._lib.PEM_read_bio_PrivateKey,\n            data,\n            password,\n            unsafe_skip_rsa_key_validation,\n        )\n\n    def load_pem_public_key(self, data: bytes) -> PublicKeyTypes:\n        mem_bio = self._bytes_to_bio(data)\n        # In OpenSSL 3.0.x the PEM_read_bio_PUBKEY function will invoke\n        # the default password callback if you pass an encrypted private\n        # key. This is very, very, very bad as the default callback can\n        # trigger an interactive console prompt, which will hang the\n        # Python process. We therefore provide our own callback to\n        # catch this and error out properly.\n        userdata = self._ffi.new(\"CRYPTOGRAPHY_PASSWORD_DATA *\")\n        evp_pkey = self._lib.PEM_read_bio_PUBKEY(\n            mem_bio.bio,\n            self._ffi.NULL,\n            self._ffi.addressof(\n                self._lib._original_lib, \"Cryptography_pem_password_cb\"\n            ),\n            userdata,\n        )\n        if evp_pkey != self._ffi.NULL:\n            evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n            return self._evp_pkey_to_public_key(evp_pkey)\n        else:\n            # It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still\n            # need to check to see if it is a pure PKCS1 RSA public key (not\n            # embedded in a subjectPublicKeyInfo)\n            self._consume_errors()\n            res = self._lib.BIO_reset(mem_bio.bio)\n            self.openssl_assert(res == 1)\n            rsa_cdata = self._lib.PEM_read_bio_RSAPublicKey(\n                mem_bio.bio,\n                self._ffi.NULL,\n                self._ffi.addressof(\n                    self._lib._original_lib, \"Cryptography_pem_password_cb\"\n                ),\n                userdata,\n            )\n            if rsa_cdata != self._ffi.NULL:\n                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n                return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n            else:\n                self._handle_key_loading_error()\n\n    def load_pem_parameters(self, data: bytes) -> dh.DHParameters:\n        return rust_openssl.dh.from_pem_parameters(data)\n\n    def load_der_private_key(\n        self,\n        data: bytes,\n        password: typing.Optional[bytes],\n        unsafe_skip_rsa_key_validation: bool,\n    ) -> PrivateKeyTypes:\n        # OpenSSL has a function called d2i_AutoPrivateKey that in theory\n        # handles this automatically, however it doesn't handle encrypted\n        # private keys. Instead we try to load the key two different ways.\n        # First we'll try to load it as a traditional key.\n        bio_data = self._bytes_to_bio(data)\n        key = self._evp_pkey_from_der_traditional_key(bio_data, password)\n        if key:\n            return self._evp_pkey_to_private_key(\n                key, unsafe_skip_rsa_key_validation\n            )\n        else:\n            # Finally we try to load it with the method that handles encrypted\n            # PKCS8 properly.\n            return self._load_key(\n                self._lib.d2i_PKCS8PrivateKey_bio,\n                data,\n                password,\n                unsafe_skip_rsa_key_validation,\n            )\n\n    def _evp_pkey_from_der_traditional_key(self, bio_data, password):\n        key = self._lib.d2i_PrivateKey_bio(bio_data.bio, self._ffi.NULL)\n        if key != self._ffi.NULL:\n            key = self._ffi.gc(key, self._lib.EVP_PKEY_free)\n            if password is not None:\n                raise TypeError(\n                    \"Password was given but private key is not encrypted.\"\n                )\n\n            return key\n        else:\n            self._consume_errors()\n            return None\n\n    def load_der_public_key(self, data: bytes) -> PublicKeyTypes:\n        mem_bio = self._bytes_to_bio(data)\n        evp_pkey = self._lib.d2i_PUBKEY_bio(mem_bio.bio, self._ffi.NULL)\n        if evp_pkey != self._ffi.NULL:\n            evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n            return self._evp_pkey_to_public_key(evp_pkey)\n        else:\n            # It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still\n            # need to check to see if it is a pure PKCS1 RSA public key (not\n            # embedded in a subjectPublicKeyInfo)\n            self._consume_errors()\n            res = self._lib.BIO_reset(mem_bio.bio)\n            self.openssl_assert(res == 1)\n            rsa_cdata = self._lib.d2i_RSAPublicKey_bio(\n                mem_bio.bio, self._ffi.NULL\n            )\n            if rsa_cdata != self._ffi.NULL:\n                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)\n                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)\n                return _RSAPublicKey(self, rsa_cdata, evp_pkey)\n            else:\n                self._handle_key_loading_error()\n\n    def load_der_parameters(self, data: bytes) -> dh.DHParameters:\n        return rust_openssl.dh.from_der_parameters(data)\n\n    def _cert2ossl(self, cert: x509.Certificate) -> typing.Any:\n        data = cert.public_bytes(serialization.Encoding.DER)\n        mem_bio = self._bytes_to_bio(data)\n        x509 = self._lib.d2i_X509_bio(mem_bio.bio, self._ffi.NULL)\n        self.openssl_assert(x509 != self._ffi.NULL)\n        x509 = self._ffi.gc(x509, self._lib.X509_free)\n        return x509\n\n    def _ossl2cert(self, x509_ptr: typing.Any) -> x509.Certificate:\n        bio = self._create_mem_bio_gc()\n        res = self._lib.i2d_X509_bio(bio, x509_ptr)\n        self.openssl_assert(res == 1)\n        return x509.load_der_x509_certificate(self._read_mem_bio(bio))\n\n    def _key2ossl(self, key: PKCS12PrivateKeyTypes) -> typing.Any:\n        data = key.private_bytes(\n            serialization.Encoding.DER,\n            serialization.PrivateFormat.PKCS8,\n            serialization.NoEncryption(),\n        )\n        mem_bio = self._bytes_to_bio(data)\n\n        evp_pkey = self._lib.d2i_PrivateKey_bio(\n            mem_bio.bio,\n            self._ffi.NULL,\n        )\n        self.openssl_assert(evp_pkey != self._ffi.NULL)\n        return self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n\n    def _load_key(\n        self, openssl_read_func, data, password, unsafe_skip_rsa_key_validation\n    ) -> PrivateKeyTypes:\n        mem_bio = self._bytes_to_bio(data)\n\n        userdata = self._ffi.new(\"CRYPTOGRAPHY_PASSWORD_DATA *\")\n        if password is not None:\n            utils._check_byteslike(\"password\", password)\n            password_ptr = self._ffi.from_buffer(password)\n            userdata.password = password_ptr\n            userdata.length = len(password)\n\n        evp_pkey = openssl_read_func(\n            mem_bio.bio,\n            self._ffi.NULL,\n            self._ffi.addressof(\n                self._lib._original_lib, \"Cryptography_pem_password_cb\"\n            ),\n            userdata,\n        )\n\n        if evp_pkey == self._ffi.NULL:\n            if userdata.error != 0:\n                self._consume_errors()\n                if userdata.error == -1:\n                    raise TypeError(\n                        \"Password was not given but private key is encrypted\"\n                    )\n                else:\n                    assert userdata.error == -2\n                    raise ValueError(\n                        \"Passwords longer than {} bytes are not supported \"\n                        \"by this backend.\".format(userdata.maxsize - 1)\n                    )\n            else:\n                self._handle_key_loading_error()\n\n        evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n\n        if password is not None and userdata.called == 0:\n            raise TypeError(\n                \"Password was given but private key is not encrypted.\"\n            )\n\n        assert (\n            password is not None and userdata.called == 1\n        ) or password is None\n\n        return self._evp_pkey_to_private_key(\n            evp_pkey, unsafe_skip_rsa_key_validation\n        )\n\n    def _handle_key_loading_error(self) -> typing.NoReturn:\n        errors = self._consume_errors()\n\n        if not errors:\n            raise ValueError(\n                \"Could not deserialize key data. The data may be in an \"\n                \"incorrect format or it may be encrypted with an unsupported \"\n                \"algorithm.\"\n            )\n\n        elif (\n            errors[0]._lib_reason_match(\n                self._lib.ERR_LIB_EVP, self._lib.EVP_R_BAD_DECRYPT\n            )\n            or errors[0]._lib_reason_match(\n                self._lib.ERR_LIB_PKCS12,\n                self._lib.PKCS12_R_PKCS12_CIPHERFINAL_ERROR,\n            )\n            or (\n                self._lib.Cryptography_HAS_PROVIDERS\n                and errors[0]._lib_reason_match(\n                    self._lib.ERR_LIB_PROV,\n                    self._lib.PROV_R_BAD_DECRYPT,\n                )\n            )\n        ):\n            raise ValueError(\"Bad decrypt. Incorrect password?\")\n\n        elif any(\n            error._lib_reason_match(\n                self._lib.ERR_LIB_EVP,\n                self._lib.EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM,\n            )\n            for error in errors\n        ):\n            raise ValueError(\"Unsupported public key algorithm.\")\n\n        else:\n            raise ValueError(\n                \"Could not deserialize key data. The data may be in an \"\n                \"incorrect format, it may be encrypted with an unsupported \"\n                \"algorithm, or it may be an unsupported key type (e.g. EC \"\n                \"curves with explicit parameters).\",\n                errors,\n            )\n\n    def elliptic_curve_supported(self, curve: ec.EllipticCurve) -> bool:\n        try:\n            curve_nid = self._elliptic_curve_to_nid(curve)\n        except UnsupportedAlgorithm:\n            curve_nid = self._lib.NID_undef\n\n        group = self._lib.EC_GROUP_new_by_curve_name(curve_nid)\n\n        if group == self._ffi.NULL:\n            self._consume_errors()\n            return False\n        else:\n            self.openssl_assert(curve_nid != self._lib.NID_undef)\n            self._lib.EC_GROUP_free(group)\n            return True\n\n    def elliptic_curve_signature_algorithm_supported(\n        self,\n        signature_algorithm: ec.EllipticCurveSignatureAlgorithm,\n        curve: ec.EllipticCurve,\n    ) -> bool:\n        # We only support ECDSA right now.\n        if not isinstance(signature_algorithm, ec.ECDSA):\n            return False\n\n        return self.elliptic_curve_supported(curve)\n\n    def generate_elliptic_curve_private_key(\n        self, curve: ec.EllipticCurve\n    ) -> ec.EllipticCurvePrivateKey:\n        \"\"\"\n        Generate a new private key on the named curve.\n        \"\"\"\n\n        if self.elliptic_curve_supported(curve):\n            ec_cdata = self._ec_key_new_by_curve(curve)\n\n            res = self._lib.EC_KEY_generate_key(ec_cdata)\n            self.openssl_assert(res == 1)\n\n            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n        else:\n            raise UnsupportedAlgorithm(\n                f\"Backend object does not support {curve.name}.\",\n                _Reasons.UNSUPPORTED_ELLIPTIC_CURVE,\n            )\n\n    def load_elliptic_curve_private_numbers(\n        self, numbers: ec.EllipticCurvePrivateNumbers\n    ) -> ec.EllipticCurvePrivateKey:\n        public = numbers.public_numbers\n\n        ec_cdata = self._ec_key_new_by_curve(public.curve)\n\n        private_value = self._ffi.gc(\n            self._int_to_bn(numbers.private_value), self._lib.BN_clear_free\n        )\n        res = self._lib.EC_KEY_set_private_key(ec_cdata, private_value)\n        if res != 1:\n            self._consume_errors()\n            raise ValueError(\"Invalid EC key.\")\n\n        with self._tmp_bn_ctx() as bn_ctx:\n            self._ec_key_set_public_key_affine_coordinates(\n                ec_cdata, public.x, public.y, bn_ctx\n            )\n            # derive the expected public point and compare it to the one we\n            # just set based on the values we were given. If they don't match\n            # this isn't a valid key pair.\n            group = self._lib.EC_KEY_get0_group(ec_cdata)\n            self.openssl_assert(group != self._ffi.NULL)\n            set_point = backend._lib.EC_KEY_get0_public_key(ec_cdata)\n            self.openssl_assert(set_point != self._ffi.NULL)\n            computed_point = self._lib.EC_POINT_new(group)\n            self.openssl_assert(computed_point != self._ffi.NULL)\n            computed_point = self._ffi.gc(\n                computed_point, self._lib.EC_POINT_free\n            )\n            res = self._lib.EC_POINT_mul(\n                group,\n                computed_point,\n                private_value,\n                self._ffi.NULL,\n                self._ffi.NULL,\n                bn_ctx,\n            )\n            self.openssl_assert(res == 1)\n            if (\n                self._lib.EC_POINT_cmp(\n                    group, set_point, computed_point, bn_ctx\n                )\n                != 0\n            ):\n                raise ValueError(\"Invalid EC key.\")\n\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n\n    def load_elliptic_curve_public_numbers(\n        self, numbers: ec.EllipticCurvePublicNumbers\n    ) -> ec.EllipticCurvePublicKey:\n        ec_cdata = self._ec_key_new_by_curve(numbers.curve)\n        with self._tmp_bn_ctx() as bn_ctx:\n            self._ec_key_set_public_key_affine_coordinates(\n                ec_cdata, numbers.x, numbers.y, bn_ctx\n            )\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)\n\n    def load_elliptic_curve_public_bytes(\n        self, curve: ec.EllipticCurve, point_bytes: bytes\n    ) -> ec.EllipticCurvePublicKey:\n        ec_cdata = self._ec_key_new_by_curve(curve)\n        group = self._lib.EC_KEY_get0_group(ec_cdata)\n        self.openssl_assert(group != self._ffi.NULL)\n        point = self._lib.EC_POINT_new(group)\n        self.openssl_assert(point != self._ffi.NULL)\n        point = self._ffi.gc(point, self._lib.EC_POINT_free)\n        with self._tmp_bn_ctx() as bn_ctx:\n            res = self._lib.EC_POINT_oct2point(\n                group, point, point_bytes, len(point_bytes), bn_ctx\n            )\n            if res != 1:\n                self._consume_errors()\n                raise ValueError(\"Invalid public bytes for the given curve\")\n\n        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)\n        self.openssl_assert(res == 1)\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)\n\n    def derive_elliptic_curve_private_key(\n        self, private_value: int, curve: ec.EllipticCurve\n    ) -> ec.EllipticCurvePrivateKey:\n        ec_cdata = self._ec_key_new_by_curve(curve)\n\n        group = self._lib.EC_KEY_get0_group(ec_cdata)\n        self.openssl_assert(group != self._ffi.NULL)\n\n        point = self._lib.EC_POINT_new(group)\n        self.openssl_assert(point != self._ffi.NULL)\n        point = self._ffi.gc(point, self._lib.EC_POINT_free)\n\n        value = self._int_to_bn(private_value)\n        value = self._ffi.gc(value, self._lib.BN_clear_free)\n\n        with self._tmp_bn_ctx() as bn_ctx:\n            res = self._lib.EC_POINT_mul(\n                group, point, value, self._ffi.NULL, self._ffi.NULL, bn_ctx\n            )\n            self.openssl_assert(res == 1)\n\n            bn_x = self._lib.BN_CTX_get(bn_ctx)\n            bn_y = self._lib.BN_CTX_get(bn_ctx)\n\n            res = self._lib.EC_POINT_get_affine_coordinates(\n                group, point, bn_x, bn_y, bn_ctx\n            )\n            if res != 1:\n                self._consume_errors()\n                raise ValueError(\"Unable to derive key from private_value\")\n\n        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)\n        self.openssl_assert(res == 1)\n        private = self._int_to_bn(private_value)\n        private = self._ffi.gc(private, self._lib.BN_clear_free)\n        res = self._lib.EC_KEY_set_private_key(ec_cdata, private)\n        self.openssl_assert(res == 1)\n\n        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)\n\n        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)\n\n    def _ec_key_new_by_curve(self, curve: ec.EllipticCurve):\n        curve_nid = self._elliptic_curve_to_nid(curve)\n        return self._ec_key_new_by_curve_nid(curve_nid)\n\n    def _ec_key_new_by_curve_nid(self, curve_nid: int):\n        ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)\n        self.openssl_assert(ec_cdata != self._ffi.NULL)\n        return self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)\n\n    def elliptic_curve_exchange_algorithm_supported(\n        self, algorithm: ec.ECDH, curve: ec.EllipticCurve\n    ) -> bool:\n        if self._fips_enabled and not isinstance(\n            curve, self._fips_ecdh_curves\n        ):\n            return False\n\n        return self.elliptic_curve_supported(curve) and isinstance(\n            algorithm, ec.ECDH\n        )\n\n    def _ec_cdata_to_evp_pkey(self, ec_cdata):\n        evp_pkey = self._create_evp_pkey_gc()\n        res = self._lib.EVP_PKEY_set1_EC_KEY(evp_pkey, ec_cdata)\n        self.openssl_assert(res == 1)\n        return evp_pkey\n\n    def _elliptic_curve_to_nid(self, curve: ec.EllipticCurve) -> int:\n        \"\"\"\n        Get the NID for a curve name.\n        \"\"\"\n\n        curve_aliases = {\"secp192r1\": \"prime192v1\", \"secp256r1\": \"prime256v1\"}\n\n        curve_name = curve_aliases.get(curve.name, curve.name)\n\n        curve_nid = self._lib.OBJ_sn2nid(curve_name.encode())\n        if curve_nid == self._lib.NID_undef:\n            raise UnsupportedAlgorithm(\n                f\"{curve.name} is not a supported elliptic curve\",\n                _Reasons.UNSUPPORTED_ELLIPTIC_CURVE,\n            )\n        return curve_nid\n\n    @contextmanager\n    def _tmp_bn_ctx(self):\n        bn_ctx = self._lib.BN_CTX_new()\n        self.openssl_assert(bn_ctx != self._ffi.NULL)\n        bn_ctx = self._ffi.gc(bn_ctx, self._lib.BN_CTX_free)\n        self._lib.BN_CTX_start(bn_ctx)\n        try:\n            yield bn_ctx\n        finally:\n            self._lib.BN_CTX_end(bn_ctx)\n\n    def _ec_key_set_public_key_affine_coordinates(\n        self,\n        ec_cdata,\n        x: int,\n        y: int,\n        bn_ctx,\n    ) -> None:\n        \"\"\"\n        Sets the public key point in the EC_KEY context to the affine x and y\n        values.\n        \"\"\"\n\n        if x < 0 or y < 0:\n            raise ValueError(\n                \"Invalid EC key. Both x and y must be non-negative.\"\n            )\n\n        x = self._ffi.gc(self._int_to_bn(x), self._lib.BN_free)\n        y = self._ffi.gc(self._int_to_bn(y), self._lib.BN_free)\n        group = self._lib.EC_KEY_get0_group(ec_cdata)\n        self.openssl_assert(group != self._ffi.NULL)\n        point = self._lib.EC_POINT_new(group)\n        self.openssl_assert(point != self._ffi.NULL)\n        point = self._ffi.gc(point, self._lib.EC_POINT_free)\n        res = self._lib.EC_POINT_set_affine_coordinates(\n            group, point, x, y, bn_ctx\n        )\n        if res != 1:\n            self._consume_errors()\n            raise ValueError(\"Invalid EC key.\")\n        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)\n        self.openssl_assert(res == 1)\n\n    def _private_key_bytes(\n        self,\n        encoding: serialization.Encoding,\n        format: serialization.PrivateFormat,\n        encryption_algorithm: serialization.KeySerializationEncryption,\n        key,\n        evp_pkey,\n        cdata,\n    ) -> bytes:\n        # validate argument types\n        if not isinstance(encoding, serialization.Encoding):\n            raise TypeError(\"encoding must be an item from the Encoding enum\")\n        if not isinstance(format, serialization.PrivateFormat):\n            raise TypeError(\n                \"format must be an item from the PrivateFormat enum\"\n            )\n        if not isinstance(\n            encryption_algorithm, serialization.KeySerializationEncryption\n        ):\n            raise TypeError(\n                \"Encryption algorithm must be a KeySerializationEncryption \"\n                \"instance\"\n            )\n\n        # validate password\n        if isinstance(encryption_algorithm, serialization.NoEncryption):\n            password = b\"\"\n        elif isinstance(\n            encryption_algorithm, serialization.BestAvailableEncryption\n        ):\n            password = encryption_algorithm.password\n            if len(password) > 1023:\n                raise ValueError(\n                    \"Passwords longer than 1023 bytes are not supported by \"\n                    \"this backend\"\n                )\n        elif (\n            isinstance(\n                encryption_algorithm, serialization._KeySerializationEncryption\n            )\n            and encryption_algorithm._format\n            is format\n            is serialization.PrivateFormat.OpenSSH\n        ):\n            password = encryption_algorithm.password\n        else:\n            raise ValueError(\"Unsupported encryption type\")\n\n        # PKCS8 + PEM/DER\n        if format is serialization.PrivateFormat.PKCS8:\n            if encoding is serialization.Encoding.PEM:\n                write_bio = self._lib.PEM_write_bio_PKCS8PrivateKey\n            elif encoding is serialization.Encoding.DER:\n                write_bio = self._lib.i2d_PKCS8PrivateKey_bio\n            else:\n                raise ValueError(\"Unsupported encoding for PKCS8\")\n            return self._private_key_bytes_via_bio(\n                write_bio, evp_pkey, password\n            )\n\n        # TraditionalOpenSSL + PEM/DER\n        if format is serialization.PrivateFormat.TraditionalOpenSSL:\n            if self._fips_enabled and not isinstance(\n                encryption_algorithm, serialization.NoEncryption\n            ):\n                raise ValueError(\n                    \"Encrypted traditional OpenSSL format is not \"\n                    \"supported in FIPS mode.\"\n                )\n            key_type = self._lib.EVP_PKEY_id(evp_pkey)\n\n            if encoding is serialization.Encoding.PEM:\n                if key_type == self._lib.EVP_PKEY_RSA:\n                    write_bio = self._lib.PEM_write_bio_RSAPrivateKey\n                else:\n                    assert key_type == self._lib.EVP_PKEY_EC\n                    write_bio = self._lib.PEM_write_bio_ECPrivateKey\n                return self._private_key_bytes_via_bio(\n                    write_bio, cdata, password\n                )\n\n            if encoding is serialization.Encoding.DER:\n                if password:\n                    raise ValueError(\n                        \"Encryption is not supported for DER encoded \"\n                        \"traditional OpenSSL keys\"\n                    )\n                if key_type == self._lib.EVP_PKEY_RSA:\n                    write_bio = self._lib.i2d_RSAPrivateKey_bio\n                else:\n                    assert key_type == self._lib.EVP_PKEY_EC\n                    write_bio = self._lib.i2d_ECPrivateKey_bio\n                return self._bio_func_output(write_bio, cdata)\n\n            raise ValueError(\"Unsupported encoding for TraditionalOpenSSL\")\n\n        # OpenSSH + PEM\n        if format is serialization.PrivateFormat.OpenSSH:\n            if encoding is serialization.Encoding.PEM:\n                return ssh._serialize_ssh_private_key(\n                    key, password, encryption_algorithm\n                )\n\n            raise ValueError(\n                \"OpenSSH private key format can only be used\"\n                \" with PEM encoding\"\n            )\n\n        # Anything that key-specific code was supposed to handle earlier,\n        # like Raw.\n        raise ValueError(\"format is invalid with this key\")\n\n    def _private_key_bytes_via_bio(\n        self, write_bio, evp_pkey, password\n    ) -> bytes:\n        if not password:\n            evp_cipher = self._ffi.NULL\n        else:\n            # This is a curated value that we will update over time.\n            evp_cipher = self._lib.EVP_get_cipherbyname(b\"aes-256-cbc\")\n\n        return self._bio_func_output(\n            write_bio,\n            evp_pkey,\n            evp_cipher,\n            password,\n            len(password),\n            self._ffi.NULL,\n            self._ffi.NULL,\n        )\n\n    def _bio_func_output(self, write_bio, *args) -> bytes:\n        bio = self._create_mem_bio_gc()\n        res = write_bio(bio, *args)\n        self.openssl_assert(res == 1)\n        return self._read_mem_bio(bio)\n\n    def _public_key_bytes(\n        self,\n        encoding: serialization.Encoding,\n        format: serialization.PublicFormat,\n        key,\n        evp_pkey,\n        cdata,\n    ) -> bytes:\n        if not isinstance(encoding, serialization.Encoding):\n            raise TypeError(\"encoding must be an item from the Encoding enum\")\n        if not isinstance(format, serialization.PublicFormat):\n            raise TypeError(\n                \"format must be an item from the PublicFormat enum\"\n            )\n\n        # SubjectPublicKeyInfo + PEM/DER\n        if format is serialization.PublicFormat.SubjectPublicKeyInfo:\n            if encoding is serialization.Encoding.PEM:\n                write_bio = self._lib.PEM_write_bio_PUBKEY\n            elif encoding is serialization.Encoding.DER:\n                write_bio = self._lib.i2d_PUBKEY_bio\n            else:\n                raise ValueError(\n                    \"SubjectPublicKeyInfo works only with PEM or DER encoding\"\n                )\n            return self._bio_func_output(write_bio, evp_pkey)\n\n        # PKCS1 + PEM/DER\n        if format is serialization.PublicFormat.PKCS1:\n            # Only RSA is supported here.\n            key_type = self._lib.EVP_PKEY_id(evp_pkey)\n            if key_type != self._lib.EVP_PKEY_RSA:\n                raise ValueError(\"PKCS1 format is supported only for RSA keys\")\n\n            if encoding is serialization.Encoding.PEM:\n                write_bio = self._lib.PEM_write_bio_RSAPublicKey\n            elif encoding is serialization.Encoding.DER:\n                write_bio = self._lib.i2d_RSAPublicKey_bio\n            else:\n                raise ValueError(\"PKCS1 works only with PEM or DER encoding\")\n            return self._bio_func_output(write_bio, cdata)\n\n        # OpenSSH + OpenSSH\n        if format is serialization.PublicFormat.OpenSSH:\n            if encoding is serialization.Encoding.OpenSSH:\n                return ssh.serialize_ssh_public_key(key)\n\n            raise ValueError(\n                \"OpenSSH format must be used with OpenSSH encoding\"\n            )\n\n        # Anything that key-specific code was supposed to handle earlier,\n        # like Raw, CompressedPoint, UncompressedPoint\n        raise ValueError(\"format is invalid with this key\")\n\n    def dh_supported(self) -> bool:\n        return not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n\n    def generate_dh_parameters(\n        self, generator: int, key_size: int\n    ) -> dh.DHParameters:\n        return rust_openssl.dh.generate_parameters(generator, key_size)\n\n    def generate_dh_private_key(\n        self, parameters: dh.DHParameters\n    ) -> dh.DHPrivateKey:\n        return parameters.generate_private_key()\n\n    def generate_dh_private_key_and_parameters(\n        self, generator: int, key_size: int\n    ) -> dh.DHPrivateKey:\n        return self.generate_dh_private_key(\n            self.generate_dh_parameters(generator, key_size)\n        )\n\n    def load_dh_private_numbers(\n        self, numbers: dh.DHPrivateNumbers\n    ) -> dh.DHPrivateKey:\n        return rust_openssl.dh.from_private_numbers(numbers)\n\n    def load_dh_public_numbers(\n        self, numbers: dh.DHPublicNumbers\n    ) -> dh.DHPublicKey:\n        return rust_openssl.dh.from_public_numbers(numbers)\n\n    def load_dh_parameter_numbers(\n        self, numbers: dh.DHParameterNumbers\n    ) -> dh.DHParameters:\n        return rust_openssl.dh.from_parameter_numbers(numbers)\n\n    def dh_parameters_supported(\n        self, p: int, g: int, q: typing.Optional[int] = None\n    ) -> bool:\n        try:\n            rust_openssl.dh.from_parameter_numbers(\n                dh.DHParameterNumbers(p=p, g=g, q=q)\n            )\n        except ValueError:\n            return False\n        else:\n            return True\n\n    def dh_x942_serialization_supported(self) -> bool:\n        return self._lib.Cryptography_HAS_EVP_PKEY_DHX == 1\n\n    def x25519_load_public_bytes(self, data: bytes) -> x25519.X25519PublicKey:\n        return rust_openssl.x25519.from_public_bytes(data)\n\n    def x25519_load_private_bytes(\n        self, data: bytes\n    ) -> x25519.X25519PrivateKey:\n        return rust_openssl.x25519.from_private_bytes(data)\n\n    def x25519_generate_key(self) -> x25519.X25519PrivateKey:\n        return rust_openssl.x25519.generate_key()\n\n    def x25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return not self._lib.CRYPTOGRAPHY_LIBRESSL_LESS_THAN_370\n\n    def x448_load_public_bytes(self, data: bytes) -> x448.X448PublicKey:\n        return rust_openssl.x448.from_public_bytes(data)\n\n    def x448_load_private_bytes(self, data: bytes) -> x448.X448PrivateKey:\n        return rust_openssl.x448.from_private_bytes(data)\n\n    def x448_generate_key(self) -> x448.X448PrivateKey:\n        return rust_openssl.x448.generate_key()\n\n    def x448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ed25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return self._lib.CRYPTOGRAPHY_HAS_WORKING_ED25519\n\n    def ed25519_load_public_bytes(\n        self, data: bytes\n    ) -> ed25519.Ed25519PublicKey:\n        return rust_openssl.ed25519.from_public_bytes(data)\n\n    def ed25519_load_private_bytes(\n        self, data: bytes\n    ) -> ed25519.Ed25519PrivateKey:\n        return rust_openssl.ed25519.from_private_bytes(data)\n\n    def ed25519_generate_key(self) -> ed25519.Ed25519PrivateKey:\n        return rust_openssl.ed25519.generate_key()\n\n    def ed448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not self._lib.CRYPTOGRAPHY_IS_LIBRESSL\n            and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ed448_load_public_bytes(self, data: bytes) -> ed448.Ed448PublicKey:\n        return rust_openssl.ed448.from_public_bytes(data)\n\n    def ed448_load_private_bytes(self, data: bytes) -> ed448.Ed448PrivateKey:\n        return rust_openssl.ed448.from_private_bytes(data)\n\n    def ed448_generate_key(self) -> ed448.Ed448PrivateKey:\n        return rust_openssl.ed448.generate_key()\n\n    def aead_cipher_supported(self, cipher) -> bool:\n        return aead._aead_cipher_supported(self, cipher)\n\n    def _zero_data(self, data, length: int) -> None:\n        # We clear things this way because at the moment we're not\n        # sure of a better way that can guarantee it overwrites the\n        # memory of a bytearray and doesn't just replace the underlying char *.\n        for i in range(length):\n            data[i] = 0\n\n    @contextlib.contextmanager\n    def _zeroed_null_terminated_buf(self, data):\n        \"\"\"\n        This method takes bytes, which can be a bytestring or a mutable\n        buffer like a bytearray, and yields a null-terminated version of that\n        data. This is required because PKCS12_parse doesn't take a length with\n        its password char * and ffi.from_buffer doesn't provide null\n        termination. So, to support zeroing the data via bytearray we\n        need to build this ridiculous construct that copies the memory, but\n        zeroes it after use.\n        \"\"\"\n        if data is None:\n            yield self._ffi.NULL\n        else:\n            data_len = len(data)\n            buf = self._ffi.new(\"char[]\", data_len + 1)\n            self._ffi.memmove(buf, data, data_len)\n            try:\n                yield buf\n            finally:\n                # Cast to a uint8_t * so we can assign by integer\n                self._zero_data(self._ffi.cast(\"uint8_t *\", buf), data_len)\n\n    def load_key_and_certificates_from_pkcs12(\n        self, data: bytes, password: typing.Optional[bytes]\n    ) -> typing.Tuple[\n        typing.Optional[PrivateKeyTypes],\n        typing.Optional[x509.Certificate],\n        typing.List[x509.Certificate],\n    ]:\n        pkcs12 = self.load_pkcs12(data, password)\n        return (\n            pkcs12.key,\n            pkcs12.cert.certificate if pkcs12.cert else None,\n            [cert.certificate for cert in pkcs12.additional_certs],\n        )\n\n    def load_pkcs12(\n        self, data: bytes, password: typing.Optional[bytes]\n    ) -> PKCS12KeyAndCertificates:\n        if password is not None:\n            utils._check_byteslike(\"password\", password)\n\n        bio = self._bytes_to_bio(data)\n        p12 = self._lib.d2i_PKCS12_bio(bio.bio, self._ffi.NULL)\n        if p12 == self._ffi.NULL:\n            self._consume_errors()\n            raise ValueError(\"Could not deserialize PKCS12 data\")\n\n        p12 = self._ffi.gc(p12, self._lib.PKCS12_free)\n        evp_pkey_ptr = self._ffi.new(\"EVP_PKEY **\")\n        x509_ptr = self._ffi.new(\"X509 **\")\n        sk_x509_ptr = self._ffi.new(\"Cryptography_STACK_OF_X509 **\")\n        with self._zeroed_null_terminated_buf(password) as password_buf:\n            res = self._lib.PKCS12_parse(\n                p12, password_buf, evp_pkey_ptr, x509_ptr, sk_x509_ptr\n            )\n        if res == 0:\n            self._consume_errors()\n            raise ValueError(\"Invalid password or PKCS12 data\")\n\n        cert = None\n        key = None\n        additional_certificates = []\n\n        if evp_pkey_ptr[0] != self._ffi.NULL:\n            evp_pkey = self._ffi.gc(evp_pkey_ptr[0], self._lib.EVP_PKEY_free)\n            # We don't support turning off RSA key validation when loading\n            # PKCS12 keys\n            key = self._evp_pkey_to_private_key(\n                evp_pkey, unsafe_skip_rsa_key_validation=False\n            )\n\n        if x509_ptr[0] != self._ffi.NULL:\n            x509 = self._ffi.gc(x509_ptr[0], self._lib.X509_free)\n            cert_obj = self._ossl2cert(x509)\n            name = None\n            maybe_name = self._lib.X509_alias_get0(x509, self._ffi.NULL)\n            if maybe_name != self._ffi.NULL:\n                name = self._ffi.string(maybe_name)\n            cert = PKCS12Certificate(cert_obj, name)\n\n        if sk_x509_ptr[0] != self._ffi.NULL:\n            sk_x509 = self._ffi.gc(sk_x509_ptr[0], self._lib.sk_X509_free)\n            num = self._lib.sk_X509_num(sk_x509_ptr[0])\n\n            # In OpenSSL < 3.0.0 PKCS12 parsing reverses the order of the\n            # certificates.\n            indices: typing.Iterable[int]\n            if (\n                self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n                or self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n            ):\n                indices = range(num)\n            else:\n                indices = reversed(range(num))\n\n            for i in indices:\n                x509 = self._lib.sk_X509_value(sk_x509, i)\n                self.openssl_assert(x509 != self._ffi.NULL)\n                x509 = self._ffi.gc(x509, self._lib.X509_free)\n                addl_cert = self._ossl2cert(x509)\n                addl_name = None\n                maybe_name = self._lib.X509_alias_get0(x509, self._ffi.NULL)\n                if maybe_name != self._ffi.NULL:\n                    addl_name = self._ffi.string(maybe_name)\n                additional_certificates.append(\n                    PKCS12Certificate(addl_cert, addl_name)\n                )\n\n        return PKCS12KeyAndCertificates(key, cert, additional_certificates)\n\n    def serialize_key_and_certificates_to_pkcs12(\n        self,\n        name: typing.Optional[bytes],\n        key: typing.Optional[PKCS12PrivateKeyTypes],\n        cert: typing.Optional[x509.Certificate],\n        cas: typing.Optional[typing.List[_PKCS12CATypes]],\n        encryption_algorithm: serialization.KeySerializationEncryption,\n    ) -> bytes:\n        password = None\n        if name is not None:\n            utils._check_bytes(\"name\", name)\n\n        if isinstance(encryption_algorithm, serialization.NoEncryption):\n            nid_cert = -1\n            nid_key = -1\n            pkcs12_iter = 0\n            mac_iter = 0\n            mac_alg = self._ffi.NULL\n        elif isinstance(\n            encryption_algorithm, serialization.BestAvailableEncryption\n        ):\n            # PKCS12 encryption is hopeless trash and can never be fixed.\n            # OpenSSL 3 supports PBESv2, but Libre and Boring do not, so\n            # we use PBESv1 with 3DES on the older paths.\n            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            # At least we can set this higher than OpenSSL's default\n            pkcs12_iter = 20000\n            # mac_iter chosen for compatibility reasons, see:\n            # https://www.openssl.org/docs/man1.1.1/man3/PKCS12_create.html\n            # Did we mention how lousy PKCS12 encryption is?\n            mac_iter = 1\n            # MAC algorithm can only be set on OpenSSL 3.0.0+\n            mac_alg = self._ffi.NULL\n            password = encryption_algorithm.password\n        elif (\n            isinstance(\n                encryption_algorithm, serialization._KeySerializationEncryption\n            )\n            and encryption_algorithm._format\n            is serialization.PrivateFormat.PKCS12\n        ):\n            # Default to OpenSSL's defaults. Behavior will vary based on the\n            # version of OpenSSL cryptography is compiled against.\n            nid_cert = 0\n            nid_key = 0\n            # Use the default iters we use in best available\n            pkcs12_iter = 20000\n            # See the Best Available comment for why this is 1\n            mac_iter = 1\n            password = encryption_algorithm.password\n            keycertalg = encryption_algorithm._key_cert_algorithm\n            if keycertalg is PBES.PBESv1SHA1And3KeyTripleDESCBC:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            elif keycertalg is PBES.PBESv2SHA256AndAES256CBC:\n                if not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                    raise UnsupportedAlgorithm(\n                        \"PBESv2 is not supported by this version of OpenSSL\"\n                    )\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                assert keycertalg is None\n                # We use OpenSSL's defaults\n\n            if encryption_algorithm._hmac_hash is not None:\n                if not self._lib.Cryptography_HAS_PKCS12_SET_MAC:\n                    raise UnsupportedAlgorithm(\n                        \"Setting MAC algorithm is not supported by this \"\n                        \"version of OpenSSL.\"\n                    )\n                mac_alg = self._evp_md_non_null_from_algorithm(\n                    encryption_algorithm._hmac_hash\n                )\n                self.openssl_assert(mac_alg != self._ffi.NULL)\n            else:\n                mac_alg = self._ffi.NULL\n\n            if encryption_algorithm._kdf_rounds is not None:\n                pkcs12_iter = encryption_algorithm._kdf_rounds\n\n        else:\n            raise ValueError(\"Unsupported key encryption type\")\n\n        if cas is None or len(cas) == 0:\n            sk_x509 = self._ffi.NULL\n        else:\n            sk_x509 = self._lib.sk_X509_new_null()\n            sk_x509 = self._ffi.gc(sk_x509, self._lib.sk_X509_free)\n\n            # This list is to keep the x509 values alive until end of function\n            ossl_cas = []\n            for ca in cas:\n                if isinstance(ca, PKCS12Certificate):\n                    ca_alias = ca.friendly_name\n                    ossl_ca = self._cert2ossl(ca.certificate)\n                    if ca_alias is None:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, self._ffi.NULL, -1\n                        )\n                    else:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, ca_alias, len(ca_alias)\n                        )\n                    self.openssl_assert(res == 1)\n                else:\n                    ossl_ca = self._cert2ossl(ca)\n                ossl_cas.append(ossl_ca)\n                res = self._lib.sk_X509_push(sk_x509, ossl_ca)\n                backend.openssl_assert(res >= 1)\n\n        with self._zeroed_null_terminated_buf(password) as password_buf:\n            with self._zeroed_null_terminated_buf(name) as name_buf:\n                ossl_cert = self._cert2ossl(cert) if cert else self._ffi.NULL\n                ossl_pkey = (\n                    self._key2ossl(key) if key is not None else self._ffi.NULL\n                )\n\n                p12 = self._lib.PKCS12_create(\n                    password_buf,\n                    name_buf,\n                    ossl_pkey,\n                    ossl_cert,\n                    sk_x509,\n                    nid_key,\n                    nid_cert,\n                    pkcs12_iter,\n                    mac_iter,\n                    0,\n                )\n\n            if (\n                self._lib.Cryptography_HAS_PKCS12_SET_MAC\n                and mac_alg != self._ffi.NULL\n            ):\n                self._lib.PKCS12_set_mac(\n                    p12,\n                    password_buf,\n                    -1,\n                    self._ffi.NULL,\n                    0,\n                    mac_iter,\n                    mac_alg,\n                )\n\n        self.openssl_assert(p12 != self._ffi.NULL)\n        p12 = self._ffi.gc(p12, self._lib.PKCS12_free)\n\n        bio = self._create_mem_bio_gc()\n        res = self._lib.i2d_PKCS12_bio(bio, p12)\n        self.openssl_assert(res > 0)\n        return self._read_mem_bio(bio)\n\n    def poly1305_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return self._lib.Cryptography_HAS_POLY1305 == 1\n\n    def pkcs7_supported(self) -> bool:\n        return not self._lib.CRYPTOGRAPHY_IS_BORINGSSL\n\n    def load_pem_pkcs7_certificates(\n        self, data: bytes\n    ) -> typing.List[x509.Certificate]:\n        utils._check_bytes(\"data\", data)\n        bio = self._bytes_to_bio(data)\n        p7 = self._lib.PEM_read_bio_PKCS7(\n            bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL\n        )\n        if p7 == self._ffi.NULL:\n            self._consume_errors()\n            raise ValueError(\"Unable to parse PKCS7 data\")\n\n        p7 = self._ffi.gc(p7, self._lib.PKCS7_free)\n        return self._load_pkcs7_certificates(p7)\n\n    def load_der_pkcs7_certificates(\n        self, data: bytes\n    ) -> typing.List[x509.Certificate]:\n        utils._check_bytes(\"data\", data)\n        bio = self._bytes_to_bio(data)\n        p7 = self._lib.d2i_PKCS7_bio(bio.bio, self._ffi.NULL)\n        if p7 == self._ffi.NULL:\n            self._consume_errors()\n            raise ValueError(\"Unable to parse PKCS7 data\")\n\n        p7 = self._ffi.gc(p7, self._lib.PKCS7_free)\n        return self._load_pkcs7_certificates(p7)\n\n    def _load_pkcs7_certificates(self, p7) -> typing.List[x509.Certificate]:\n        nid = self._lib.OBJ_obj2nid(p7.type)\n        self.openssl_assert(nid != self._lib.NID_undef)\n        if nid != self._lib.NID_pkcs7_signed:\n            raise UnsupportedAlgorithm(\n                \"Only basic signed structures are currently supported. NID\"\n                \" for this data was {}\".format(nid),\n                _Reasons.UNSUPPORTED_SERIALIZATION,\n            )\n\n        certs: list[x509.Certificate] = []\n        if p7.d.sign == self._ffi.NULL:\n            return certs\n\n        sk_x509 = p7.d.sign.cert\n        num = self._lib.sk_X509_num(sk_x509)\n        for i in range(num):\n            x509 = self._lib.sk_X509_value(sk_x509, i)\n            self.openssl_assert(x509 != self._ffi.NULL)\n            cert = self._ossl2cert(x509)\n            certs.append(cert)\n\n        return certs\n\n\nclass GetCipherByName:\n    def __init__(self, fmt: str):\n        self._fmt = fmt\n\n    def __call__(self, backend: Backend, cipher: CipherAlgorithm, mode: Mode):\n        cipher_name = self._fmt.format(cipher=cipher, mode=mode).lower()\n        evp_cipher = backend._lib.EVP_get_cipherbyname(\n            cipher_name.encode(\"ascii\")\n        )\n\n        # try EVP_CIPHER_fetch if present\n        if (\n            evp_cipher == backend._ffi.NULL\n            and backend._lib.Cryptography_HAS_300_EVP_CIPHER\n        ):\n            evp_cipher = backend._lib.EVP_CIPHER_fetch(\n                backend._ffi.NULL,\n                cipher_name.encode(\"ascii\"),\n                backend._ffi.NULL,\n            )\n\n        backend._consume_errors()\n        return evp_cipher\n\n\ndef _get_xts_cipher(backend: Backend, cipher: AES, mode):\n    cipher_name = f\"aes-{cipher.key_size // 2}-xts\"\n    return backend._lib.EVP_get_cipherbyname(cipher_name.encode(\"ascii\"))\n\n\nbackend = Backend()\n", "// This file is dual licensed under the terms of the Apache License, Version\n// 2.0, and the BSD License. See the LICENSE file in the root of this repository\n// for complete details.\n\n#![deny(rust_2018_idioms)]\n// Work-around for https://github.com/PyO3/pyo3/issues/3561\n#![allow(unknown_lints, clippy::unnecessary_fallible_conversions)]\n\nmod asn1;\nmod backend;\nmod buf;\nmod error;\nmod exceptions;\npub(crate) mod oid;\nmod pkcs7;\nmod pool;\nmod x509;\n\n/// Returns the value of the input with the most-significant-bit copied to all\n/// of the bits.\nfn duplicate_msb_to_all(a: u8) -> u8 {\n    0u8.wrapping_sub(a >> 7)\n}\n\n/// This returns 0xFF if a < b else 0x00, but does so in a constant time\n/// fashion.\nfn constant_time_lt(a: u8, b: u8) -> u8 {\n    // Derived from:\n    // https://github.com/openssl/openssl/blob/OpenSSL_1_1_1i/include/internal/constant_time.h#L120\n    duplicate_msb_to_all(a ^ ((a ^ b) | (a.wrapping_sub(b) ^ b)))\n}\n\n#[pyo3::prelude::pyfunction]\nfn check_pkcs7_padding(data: &[u8]) -> bool {\n    let mut mismatch = 0;\n    let pad_size = *data.last().unwrap();\n    let len: u8 = data.len().try_into().expect(\"data too long\");\n    for (i, b) in (0..len).zip(data.iter().rev()) {\n        let mask = constant_time_lt(i, pad_size);\n        mismatch |= mask & (pad_size ^ b);\n    }\n\n    // Check to make sure the pad_size was within the valid range.\n    mismatch |= !constant_time_lt(0, pad_size);\n    mismatch |= constant_time_lt(len, pad_size);\n\n    // Make sure any bits set are copied to the lowest bit\n    mismatch |= mismatch >> 4;\n    mismatch |= mismatch >> 2;\n    mismatch |= mismatch >> 1;\n\n    // Now check the low bit to see if it's set\n    (mismatch & 1) == 0\n}\n\n#[pyo3::prelude::pyfunction]\nfn check_ansix923_padding(data: &[u8]) -> bool {\n    let mut mismatch = 0;\n    let pad_size = *data.last().unwrap();\n    let len: u8 = data.len().try_into().expect(\"data too long\");\n    // Skip the first one with the pad size\n    for (i, b) in (1..len).zip(data[..data.len() - 1].iter().rev()) {\n        let mask = constant_time_lt(i, pad_size);\n        mismatch |= mask & b;\n    }\n\n    // Check to make sure the pad_size was within the valid range.\n    mismatch |= !constant_time_lt(0, pad_size);\n    mismatch |= constant_time_lt(len, pad_size);\n\n    // Make sure any bits set are copied to the lowest bit\n    mismatch |= mismatch >> 4;\n    mismatch |= mismatch >> 2;\n    mismatch |= mismatch >> 1;\n\n    // Now check the low bit to see if it's set\n    (mismatch & 1) == 0\n}\n\n#[pyo3::prelude::pyfunction]\nfn openssl_version() -> i64 {\n    openssl::version::number()\n}\n\n#[pyo3::prelude::pyfunction]\nfn raise_openssl_error() -> crate::error::CryptographyResult<()> {\n    Err(openssl::error::ErrorStack::get().into())\n}\n\n#[pyo3::prelude::pyclass(module = \"cryptography.hazmat.bindings._rust.openssl\")]\nstruct OpenSSLError {\n    e: openssl::error::Error,\n}\n\n#[pyo3::pymethods]\nimpl OpenSSLError {\n    #[getter]\n    fn lib(&self) -> i32 {\n        self.e.library_code()\n    }\n\n    #[getter]\n    fn reason(&self) -> i32 {\n        self.e.reason_code()\n    }\n\n    #[getter]\n    fn reason_text(&self) -> &[u8] {\n        self.e.reason().unwrap_or(\"\").as_bytes()\n    }\n\n    fn _lib_reason_match(&self, lib: i32, reason: i32) -> bool {\n        self.e.library_code() == lib && self.e.reason_code() == reason\n    }\n\n    fn __repr__(&self) -> pyo3::PyResult<String> {\n        Ok(format!(\n            \"<OpenSSLError(code={}, lib={}, reason={}, reason_text={})>\",\n            self.e.code(),\n            self.e.library_code(),\n            self.e.reason_code(),\n            self.e.reason().unwrap_or(\"\")\n        ))\n    }\n}\n\n#[pyo3::prelude::pyfunction]\nfn capture_error_stack(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::types::PyList> {\n    let errs = pyo3::types::PyList::empty(py);\n    for e in openssl::error::ErrorStack::get().errors() {\n        errs.append(pyo3::PyCell::new(py, OpenSSLError { e: e.clone() })?)?;\n    }\n    Ok(errs)\n}\n\n#[pyo3::prelude::pyfunction]\nfn is_fips_enabled() -> bool {\n    cryptography_openssl::fips::is_enabled()\n}\n\n#[pyo3::prelude::pymodule]\nfn _rust(py: pyo3::Python<'_>, m: &pyo3::types::PyModule) -> pyo3::PyResult<()> {\n    m.add_function(pyo3::wrap_pyfunction!(check_pkcs7_padding, m)?)?;\n    m.add_function(pyo3::wrap_pyfunction!(check_ansix923_padding, m)?)?;\n    m.add_class::<oid::ObjectIdentifier>()?;\n    m.add_class::<pool::FixedPool>()?;\n\n    m.add_submodule(asn1::create_submodule(py)?)?;\n    m.add_submodule(pkcs7::create_submodule(py)?)?;\n    m.add_submodule(exceptions::create_submodule(py)?)?;\n\n    let x509_mod = pyo3::prelude::PyModule::new(py, \"x509\")?;\n    crate::x509::certificate::add_to_module(x509_mod)?;\n    crate::x509::common::add_to_module(x509_mod)?;\n    crate::x509::crl::add_to_module(x509_mod)?;\n    crate::x509::csr::add_to_module(x509_mod)?;\n    crate::x509::sct::add_to_module(x509_mod)?;\n    m.add_submodule(x509_mod)?;\n\n    let ocsp_mod = pyo3::prelude::PyModule::new(py, \"ocsp\")?;\n    crate::x509::ocsp_req::add_to_module(ocsp_mod)?;\n    crate::x509::ocsp_resp::add_to_module(ocsp_mod)?;\n    m.add_submodule(ocsp_mod)?;\n\n    m.add_submodule(cryptography_cffi::create_module(py)?)?;\n\n    let openssl_mod = pyo3::prelude::PyModule::new(py, \"openssl\")?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(openssl_version, m)?)?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(raise_openssl_error, m)?)?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(capture_error_stack, m)?)?;\n    openssl_mod.add_function(pyo3::wrap_pyfunction!(is_fips_enabled, m)?)?;\n    openssl_mod.add_class::<OpenSSLError>()?;\n    crate::backend::add_to_module(openssl_mod)?;\n    m.add_submodule(openssl_mod)?;\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::constant_time_lt;\n\n    #[test]\n    fn test_constant_time_lt() {\n        for a in 0..=255 {\n            for b in 0..=255 {\n                let expected = if a < b { 0xff } else { 0 };\n                assert_eq!(constant_time_lt(a, b), expected);\n            }\n        }\n    }\n}\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport email.parser\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.exceptions import _Reasons\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ed25519, rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs7\n\nfrom ...utils import load_vectors_from_file, raises_unsupported_algorithm\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7Loading:\n    def test_load_invalid_der_pkcs7(self, backend):\n        with pytest.raises(ValueError):\n            pkcs7.load_der_pkcs7_certificates(b\"nonsense\")\n\n    def test_load_invalid_pem_pkcs7(self, backend):\n        with pytest.raises(ValueError):\n            pkcs7.load_pem_pkcs7_certificates(b\"nonsense\")\n\n    def test_not_bytes_der(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.load_der_pkcs7_certificates(38)  # type: ignore[arg-type]\n\n    def test_not_bytes_pem(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.load_pem_pkcs7_certificates(38)  # type: ignore[arg-type]\n\n    def test_load_pkcs7_pem(self, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"isrg.pem\"),\n            lambda pemfile: pkcs7.load_pem_pkcs7_certificates(pemfile.read()),\n            mode=\"rb\",\n        )\n        assert len(certs) == 1\n        assert certs[0].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, \"ISRG Root X1\")]\n\n    @pytest.mark.parametrize(\n        \"filepath\",\n        [\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            os.path.join(\"pkcs7\", \"amazon-roots.p7b\"),\n        ],\n    )\n    def test_load_pkcs7_der(self, filepath, backend):\n        certs = load_vectors_from_file(\n            filepath,\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        assert len(certs) == 2\n        assert certs[0].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [\n            x509.NameAttribute(\n                x509.oid.NameOID.COMMON_NAME, \"Amazon Root CA 3\"\n            )\n        ]\n        assert certs[1].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [\n            x509.NameAttribute(\n                x509.oid.NameOID.COMMON_NAME, \"Amazon Root CA 2\"\n            )\n        ]\n\n    def test_load_pkcs7_unsupported_type(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):\n            load_vectors_from_file(\n                os.path.join(\"pkcs7\", \"enveloped.pem\"),\n                lambda pemfile: pkcs7.load_pem_pkcs7_certificates(\n                    pemfile.read()\n                ),\n                mode=\"rb\",\n            )\n\n    def test_load_pkcs7_empty_certificates(self, backend):\n        der = b\"\\x30\\x0B\\x06\\x09\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x01\\x07\\x02\"\n\n        certificates = pkcs7.load_der_pkcs7_certificates(der)\n        assert certificates == []\n\n\n# We have no public verification API and won't be adding one until we get\n# some requirements from users so this function exists to give us basic\n# verification for the signing tests.\ndef _pkcs7_verify(encoding, sig, msg, certs, options, backend):\n    sig_bio = backend._bytes_to_bio(sig)\n    if encoding is serialization.Encoding.DER:\n        p7 = backend._lib.d2i_PKCS7_bio(sig_bio.bio, backend._ffi.NULL)\n    elif encoding is serialization.Encoding.PEM:\n        p7 = backend._lib.PEM_read_bio_PKCS7(\n            sig_bio.bio,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n        )\n    else:\n        p7 = backend._lib.SMIME_read_PKCS7(sig_bio.bio, backend._ffi.NULL)\n    backend.openssl_assert(p7 != backend._ffi.NULL)\n    p7 = backend._ffi.gc(p7, backend._lib.PKCS7_free)\n    flags = 0\n    for option in options:\n        if option is pkcs7.PKCS7Options.Text:\n            flags |= backend._lib.PKCS7_TEXT\n    store = backend._lib.X509_STORE_new()\n    backend.openssl_assert(store != backend._ffi.NULL)\n    store = backend._ffi.gc(store, backend._lib.X509_STORE_free)\n    # This list is to keep the x509 values alive until end of function\n    ossl_certs = []\n    for cert in certs:\n        ossl_cert = backend._cert2ossl(cert)\n        ossl_certs.append(ossl_cert)\n        res = backend._lib.X509_STORE_add_cert(store, ossl_cert)\n        backend.openssl_assert(res == 1)\n    if msg is None:\n        res = backend._lib.PKCS7_verify(\n            p7,\n            backend._ffi.NULL,\n            store,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n            flags,\n        )\n    else:\n        msg_bio = backend._bytes_to_bio(msg)\n        # libressl 3.7.0 has a bug when NULL is passed as an `out_bio`. Work\n        # around it for now.\n        out_bio = backend._create_mem_bio_gc()\n        res = backend._lib.PKCS7_verify(\n            p7, backend._ffi.NULL, store, msg_bio.bio, out_bio, flags\n        )\n    backend.openssl_assert(res == 1)\n    # OpenSSL 3.0 leaves a random bio error on the stack:\n    # https://github.com/openssl/openssl/issues/16681\n    if backend._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n        backend._consume_errors()\n\n\ndef _load_cert_key():\n    key = load_vectors_from_file(\n        os.path.join(\"x509\", \"custom\", \"ca\", \"ca_key.pem\"),\n        lambda pemfile: serialization.load_pem_private_key(\n            pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n        ),\n        mode=\"rb\",\n    )\n    cert = load_vectors_from_file(\n        os.path.join(\"x509\", \"custom\", \"ca\", \"ca.pem\"),\n        loader=lambda pemfile: x509.load_pem_x509_certificate(pemfile.read()),\n        mode=\"rb\",\n    )\n    return cert, key\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7Builder:\n    def test_invalid_data(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder()\n        with pytest.raises(TypeError):\n            builder.set_data(\"not bytes\")  # type: ignore[arg-type]\n\n    def test_set_data_twice(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder().set_data(b\"test\")\n        with pytest.raises(ValueError):\n            builder.set_data(b\"test\")\n\n    def test_sign_no_signer(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder().set_data(b\"test\")\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, [])\n\n    def test_sign_no_data(self, backend):\n        cert, key = _load_cert_key()\n        builder = pkcs7.PKCS7SignatureBuilder().add_signer(\n            cert, key, hashes.SHA256()\n        )\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, [])\n\n    def test_unsupported_hash_alg(self, backend):\n        cert, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert, key, hashes.SHA512_256()  # type: ignore[arg-type]\n            )\n\n    def test_not_a_cert(self, backend):\n        cert, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                b\"notacert\", key, hashes.SHA256()  # type: ignore[arg-type]\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Does not support ed25519.\",\n    )\n    def test_unsupported_key_type(self, backend):\n        cert, _ = _load_cert_key()\n        key = ed25519.Ed25519PrivateKey.generate()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert, key, hashes.SHA256()  # type: ignore[arg-type]\n            )\n\n    def test_sign_invalid_options(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        with pytest.raises(ValueError):\n            builder.sign(\n                serialization.Encoding.SMIME,\n                [b\"invalid\"],  # type: ignore[list-item]\n            )\n\n    def test_sign_invalid_encoding(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.Raw, [])\n\n    def test_sign_invalid_options_text_no_detached(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [pkcs7.PKCS7Options.Text]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, options)\n\n    def test_sign_invalid_options_text_der_encoding(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [\n            pkcs7.PKCS7Options.Text,\n            pkcs7.PKCS7Options.DetachedSignature,\n        ]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.DER, options)\n\n    def test_sign_invalid_options_no_attrs_and_no_caps(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [\n            pkcs7.PKCS7Options.NoAttributes,\n            pkcs7.PKCS7Options.NoCapabilities,\n        ]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, options)\n\n    def test_smime_sign_detached(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        assert b\"text/plain\" not in sig\n        # We don't have a generic ASN.1 parser available to us so we instead\n        # will assert on specific byte sequences being present based on the\n        # parameters chosen above.\n        assert b\"sha-256\" in sig\n        # Detached signature means that the signed data is *not* embedded into\n        # the PKCS7 structure itself, but is present in the SMIME serialization\n        # as a separate section before the PKCS7 data. So we should expect to\n        # have data in sig but not in sig_binary\n        assert data in sig\n        # Parse the message to get the signed data, which is the\n        # first payload in the message\n        message = email.parser.BytesParser().parsebytes(sig)\n        signed_data = message.get_payload()[0].get_payload().encode()\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            signed_data,\n            [cert],\n            options,\n            backend,\n        )\n        assert data not in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_byteslike(self, backend):\n        data = bytearray(b\"hello world\")\n        cert, key = _load_cert_key()\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        assert bytes(data) in sig\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n        data = bytearray(b\"\")\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_pem(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options: typing.List[pkcs7.PKCS7Options] = []\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.PEM, options)\n        _pkcs7_verify(\n            serialization.Encoding.PEM,\n            sig,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    @pytest.mark.parametrize(\n        (\"hash_alg\", \"expected_value\"),\n        [\n            (hashes.SHA256(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x01\"),\n            (hashes.SHA384(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x02\"),\n            (hashes.SHA512(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\"),\n        ],\n    )\n    def test_sign_alternate_digests_der(\n        self, hash_alg, expected_value, backend\n    ):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hash_alg)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert expected_value in sig\n        _pkcs7_verify(\n            serialization.Encoding.DER, sig, None, [cert], options, backend\n        )\n\n    @pytest.mark.parametrize(\n        (\"hash_alg\", \"expected_value\"),\n        [\n            (hashes.SHA256(), b\"sha-256\"),\n            (hashes.SHA384(), b\"sha-384\"),\n            (hashes.SHA512(), b\"sha-512\"),\n        ],\n    )\n    def test_sign_alternate_digests_detached(\n        self, hash_alg, expected_value, backend\n    ):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hash_alg)\n        )\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        # When in detached signature mode the hash algorithm is stored as a\n        # byte string like \"sha-384\".\n        assert expected_value in sig\n\n    def test_sign_attached(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options: typing.List[pkcs7.PKCS7Options] = []\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # When not passing detached signature the signed data is embedded into\n        # the PKCS7 structure itself\n        assert data in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_binary(self, backend):\n        data = b\"hello\\nworld\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig_no_binary = builder.sign(serialization.Encoding.DER, options)\n        sig_binary = builder.sign(\n            serialization.Encoding.DER, [pkcs7.PKCS7Options.Binary]\n        )\n        # Binary prevents translation of LF to CR+LF (SMIME canonical form)\n        # so data should not be present in sig_no_binary, but should be present\n        # in sig_binary\n        assert data not in sig_no_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_no_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n        assert data in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_smime_canonicalization(self, backend):\n        data = b\"hello\\nworld\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # LF gets converted to CR+LF (SMIME canonical form)\n        # so data should not be present in the sig\n        assert data not in sig_binary\n        assert b\"hello\\r\\nworld\" in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_text(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [\n            pkcs7.PKCS7Options.Text,\n            pkcs7.PKCS7Options.DetachedSignature,\n        ]\n        sig_pem = builder.sign(serialization.Encoding.SMIME, options)\n        # The text option adds text/plain headers to the S/MIME message\n        # These headers are only relevant in SMIME mode, not binary, which is\n        # just the PKCS7 structure itself.\n        assert sig_pem.count(b\"text/plain\") == 1\n        assert b\"Content-Type: text/plain\\r\\n\\r\\nhello world\\r\\n\" in sig_pem\n        # Parse the message to get the signed data, which is the\n        # first payload in the message\n        message = email.parser.BytesParser().parsebytes(sig_pem)\n        signed_data = message.get_payload()[0].as_bytes(\n            policy=message.policy.clone(linesep=\"\\r\\n\")\n        )\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig_pem,\n            signed_data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_capabilities(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [pkcs7.PKCS7Options.NoCapabilities]\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # NoCapabilities removes the SMIMECapabilities attribute from the\n        # PKCS7 structure. This is an ASN.1 sequence with the\n        # OID 1.2.840.113549.1.9.15. It does NOT remove all authenticated\n        # attributes, so we verify that by looking for the signingTime OID.\n\n        # 1.2.840.113549.1.9.15 SMIMECapabilities as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" not in sig_binary\n        # 1.2.840.113549.1.9.5 signingTime as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x05\" in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_attributes(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [pkcs7.PKCS7Options.NoAttributes]\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # NoAttributes removes all authenticated attributes, so we shouldn't\n        # find SMIMECapabilities or signingTime.\n\n        # 1.2.840.113549.1.9.15 SMIMECapabilities as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" not in sig_binary\n        # 1.2.840.113549.1.9.5 signingTime as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x05\" not in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_certs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert sig.count(cert.public_bytes(serialization.Encoding.DER)) == 1\n\n        options = [pkcs7.PKCS7Options.NoCerts]\n        sig_no = builder.sign(serialization.Encoding.DER, options)\n        assert sig_no.count(cert.public_bytes(serialization.Encoding.DER)) == 0\n\n    def test_multiple_signers(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA512())\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # There should be three SHA512 OIDs in this structure\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 3\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig,\n            None,\n            [cert, rsa_cert],\n            options,\n            backend,\n        )\n\n    def test_multiple_signers_different_hash_algs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # There should be two SHA384 and two SHA512 OIDs in this structure\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x02\") == 2\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 2\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig,\n            None,\n            [cert, rsa_cert],\n            options,\n            backend,\n        )\n\n    def test_add_additional_cert_not_a_cert(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_certificate(\n                b\"notacert\"  # type: ignore[arg-type]\n            )\n\n    def test_add_additional_cert(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_certificate(rsa_cert)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert (\n            sig.count(rsa_cert.public_bytes(serialization.Encoding.DER)) == 1\n        )\n\n    def test_add_multiple_additional_certs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_certificate(rsa_cert)\n            .add_certificate(rsa_cert)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert (\n            sig.count(rsa_cert.public_bytes(serialization.Encoding.DER)) == 2\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7SerializeCerts:\n    @pytest.mark.parametrize(\n        (\"encoding\", \"loader\"),\n        [\n            (serialization.Encoding.PEM, pkcs7.load_pem_pkcs7_certificates),\n            (serialization.Encoding.DER, pkcs7.load_der_pkcs7_certificates),\n        ],\n    )\n    def test_roundtrip(self, encoding, loader, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        p7 = pkcs7.serialize_certificates(certs, encoding)\n        certs2 = loader(p7)\n        assert certs == certs2\n\n    def test_ordering(self, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        p7 = pkcs7.serialize_certificates(\n            list(reversed(certs)), serialization.Encoding.DER\n        )\n        certs2 = pkcs7.load_der_pkcs7_certificates(p7)\n        assert certs == certs2\n\n    def test_pem_matches_vector(self, backend):\n        p7_pem = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"isrg.pem\"),\n            lambda p: p.read(),\n            mode=\"rb\",\n        )\n        certs = pkcs7.load_pem_pkcs7_certificates(p7_pem)\n        p7 = pkcs7.serialize_certificates(certs, serialization.Encoding.PEM)\n        assert p7 == p7_pem\n\n    def test_der_matches_vector(self, backend):\n        p7_der = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda p: p.read(),\n            mode=\"rb\",\n        )\n        certs = pkcs7.load_der_pkcs7_certificates(p7_der)\n        p7 = pkcs7.serialize_certificates(certs, serialization.Encoding.DER)\n        assert p7 == p7_der\n\n    def test_invalid_types(self):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates(\n                object(),  # type: ignore[arg-type]\n                serialization.Encoding.PEM,\n            )\n\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates([], serialization.Encoding.PEM)\n\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates(\n                certs, \"not an encoding\"  # type: ignore[arg-type]\n            )\n", "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__all__ = [\n    \"__version__\",\n]\n\n__version__ = \"41.0.6\"\n", "[build-system]\nrequires = [\"setuptools\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"cryptography_vectors\"\nversion = \"41.0.6\"\nauthors = [\n    {name = \"The Python Cryptographic Authority and individual contributors\", email = \"cryptography-dev@python.org\"}\n]\ndescription = \"Test vectors for the cryptography package.\"\nlicense = {text = \"Apache-2.0 OR BSD-3-Clause\"}\n\n[project.urls]\nhomepage = \"https://github.com/pyca/cryptography\"\n\n[tool.setuptools]\nzip-safe = false\ninclude-package-data = true\n\n[tool.distutils.bdist_wheel]\nuniversal = true\n"], "filenames": ["CHANGELOG.rst", "docs/spelling_wordlist.txt", "pyproject.toml", "src/cryptography/__about__.py", "src/cryptography/hazmat/backends/openssl/backend.py", "src/rust/src/lib.rs", "tests/hazmat/primitives/test_pkcs7.py", "vectors/cryptography_vectors/__about__.py", "vectors/pyproject.toml"], "buggy_code_start_loc": [2, 40, 14, 13, 1892, 5, 90, 9, 7], "buggy_code_end_loc": [1724, 40, 15, 14, 1896, 5, 90, 10, 8], "fixing_code_start_loc": [3, 41, 14, 13, 1893, 6, 91, 9, 7], "fixing_code_end_loc": [1733, 42, 15, 14, 1898, 8, 97, 10, 8], "type": "CWE-476", "message": "cryptography is a package designed to expose cryptographic primitives and recipes to Python developers. Calling `load_pem_pkcs7_certificates` or `load_der_pkcs7_certificates` could lead to a NULL-pointer dereference and segfault. Exploitation of this vulnerability poses a serious risk of Denial of Service (DoS) for any application attempting to deserialize a PKCS7 blob/certificate. The consequences extend to potential disruptions in system availability and stability. This vulnerability has been patched in version 41.0.6.", "other": {"cve": {"id": "CVE-2023-49083", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-29T19:15:07.967", "lastModified": "2024-02-17T02:15:45.350", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "cryptography is a package designed to expose cryptographic primitives and recipes to Python developers. Calling `load_pem_pkcs7_certificates` or `load_der_pkcs7_certificates` could lead to a NULL-pointer dereference and segfault. Exploitation of this vulnerability poses a serious risk of Denial of Service (DoS) for any application attempting to deserialize a PKCS7 blob/certificate. The consequences extend to potential disruptions in system availability and stability. This vulnerability has been patched in version 41.0.6."}, {"lang": "es", "value": "cryptography es un paquete dise\u00f1ado para exponer recetas y primitivas criptogr\u00e1ficas a los desarrolladores de Python. Llamar a `load_pem_pkcs7_certificates` o `load_der_pkcs7_certificates` podr\u00eda provocar una desreferencia de puntero NULL y un error de segmentaci\u00f3n. La explotaci\u00f3n de esta vulnerabilidad plantea un grave riesgo de Denegaci\u00f3n de Servicio (DoS) para cualquier aplicaci\u00f3n que intente deserializar un blob/certificado PKCS7. Las consecuencias se extienden a posibles interrupciones en la disponibilidad y estabilidad del sistema. Esta vulnerabilidad ha sido parcheada en la versi\u00f3n 41.0.6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cryptography_project:cryptography:*:*:*:*:*:python:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "41.0.6", "matchCriteriaId": "D82EE66F-7D6B-4710-8F2B-08F1819F6860"}]}]}], "references": [{"url": "https://github.com/pyca/cryptography/commit/f09c261ca10a31fe41b1262306db7f8f1da0e48a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/pyca/cryptography/pull/9926", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/pyca/cryptography/security/advisories/GHSA-jfhm-5ghh-2f97", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QMNTYMUGFJSDBYBU22FUYBHFRZODRKXV/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/pyca/cryptography/commit/f09c261ca10a31fe41b1262306db7f8f1da0e48a"}}