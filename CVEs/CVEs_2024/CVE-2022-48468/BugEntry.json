{"buggy_code": ["/*\n * Copyright (c) 2008-2015, Dave Benson and the protobuf-c authors.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*! \\file\n * Support library for `protoc-c` generated code.\n *\n * This file implements the public API used by the code generated\n * by `protoc-c`.\n *\n * \\authors Dave Benson and the protobuf-c authors\n *\n * \\copyright 2008-2014. Licensed under the terms of the [BSD-2-Clause] license.\n */\n\n/**\n * \\todo 64-BIT OPTIMIZATION: certain implementations use 32-bit math\n * even on 64-bit platforms (uint64_size, uint64_pack, parse_uint64).\n *\n * \\todo Use size_t consistently.\n */\n\n#include <stdlib.h>\t/* for malloc, free */\n#include <string.h>\t/* for strcmp, strlen, memcpy, memmove, memset */\n\n#include \"protobuf-c.h\"\n\n#define TRUE\t\t\t\t1\n#define FALSE\t\t\t\t0\n\n#define PROTOBUF_C__ASSERT_NOT_REACHED() assert(0)\n\n/* Workaround for Microsoft compilers. */\n#ifdef _MSC_VER\n# define inline __inline\n#endif\n\n/**\n * \\defgroup internal Internal functions and macros\n *\n * These are not exported by the library but are useful to developers working\n * on `libprotobuf-c` itself.\n */\n\n/**\n * \\defgroup macros Utility macros for manipulating structures\n *\n * Macros and constants used to manipulate the base \"classes\" generated by\n * `protobuf-c`. They also define limits and check correctness.\n *\n * \\ingroup internal\n * @{\n */\n\n/** The maximum length of a 64-bit integer in varint encoding. */\n#define MAX_UINT64_ENCODED_SIZE\t\t10\n\n#ifndef PROTOBUF_C_UNPACK_ERROR\n# define PROTOBUF_C_UNPACK_ERROR(...)\n#endif\n\n#if !defined(_WIN32) || !defined(PROTOBUF_C_USE_SHARED_LIB)\nconst char protobuf_c_empty_string[] = \"\";\n#endif\n\n/**\n * Internal `ProtobufCMessage` manipulation macro.\n *\n * Base macro for manipulating a `ProtobufCMessage`. Used by STRUCT_MEMBER() and\n * STRUCT_MEMBER_PTR().\n */\n#define STRUCT_MEMBER_P(struct_p, struct_offset) \\\n    ((void *) ((uint8_t *) (struct_p) + (struct_offset)))\n\n/**\n * Return field in a `ProtobufCMessage` based on offset.\n *\n * Take a pointer to a `ProtobufCMessage` and find the field at the offset.\n * Cast it to the passed type.\n */\n#define STRUCT_MEMBER(member_type, struct_p, struct_offset) \\\n    (*(member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))\n\n/**\n * Return field in a `ProtobufCMessage` based on offset.\n *\n * Take a pointer to a `ProtobufCMessage` and find the field at the offset. Cast\n * it to a pointer to the passed type.\n */\n#define STRUCT_MEMBER_PTR(member_type, struct_p, struct_offset) \\\n    ((member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))\n\n/* Assertions for magic numbers. */\n\n#define ASSERT_IS_ENUM_DESCRIPTOR(desc) \\\n\tassert((desc)->magic == PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC)\n\n#define ASSERT_IS_MESSAGE_DESCRIPTOR(desc) \\\n\tassert((desc)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC)\n\n#define ASSERT_IS_MESSAGE(message) \\\n\tASSERT_IS_MESSAGE_DESCRIPTOR((message)->descriptor)\n\n#define ASSERT_IS_SERVICE_DESCRIPTOR(desc) \\\n\tassert((desc)->magic == PROTOBUF_C__SERVICE_DESCRIPTOR_MAGIC)\n\n/**@}*/\n\n/* --- version --- */\n\nconst char *\nprotobuf_c_version(void)\n{\n\treturn PROTOBUF_C_VERSION;\n}\n\nuint32_t\nprotobuf_c_version_number(void)\n{\n\treturn PROTOBUF_C_VERSION_NUMBER;\n}\n\n/* --- allocator --- */\n\nstatic void *\nsystem_alloc(void *allocator_data, size_t size)\n{\n\t(void)allocator_data;\n\treturn malloc(size);\n}\n\nstatic void\nsystem_free(void *allocator_data, void *data)\n{\n\t(void)allocator_data;\n\tfree(data);\n}\n\nstatic inline void *\ndo_alloc(ProtobufCAllocator *allocator, size_t size)\n{\n\treturn allocator->alloc(allocator->allocator_data, size);\n}\n\nstatic inline void\ndo_free(ProtobufCAllocator *allocator, void *data)\n{\n\tif (data != NULL)\n\t\tallocator->free(allocator->allocator_data, data);\n}\n\n/*\n * This allocator uses the system's malloc() and free(). It is the default\n * allocator used if NULL is passed as the ProtobufCAllocator to an exported\n * function.\n */\nstatic ProtobufCAllocator protobuf_c__allocator = {\n\t.alloc = &system_alloc,\n\t.free = &system_free,\n\t.allocator_data = NULL,\n};\n\n/* === buffer-simple === */\n\nvoid\nprotobuf_c_buffer_simple_append(ProtobufCBuffer *buffer,\n\t\t\t\tsize_t len, const uint8_t *data)\n{\n\tProtobufCBufferSimple *simp = (ProtobufCBufferSimple *) buffer;\n\tsize_t new_len = simp->len + len;\n\n\tif (new_len > simp->alloced) {\n\t\tProtobufCAllocator *allocator = simp->allocator;\n\t\tsize_t new_alloced = simp->alloced * 2;\n\t\tuint8_t *new_data;\n\n\t\tif (allocator == NULL)\n\t\t\tallocator = &protobuf_c__allocator;\n\t\twhile (new_alloced < new_len)\n\t\t\tnew_alloced += new_alloced;\n\t\tnew_data = do_alloc(allocator, new_alloced);\n\t\tif (!new_data)\n\t\t\treturn;\n\t\tmemcpy(new_data, simp->data, simp->len);\n\t\tif (simp->must_free_data)\n\t\t\tdo_free(allocator, simp->data);\n\t\telse\n\t\t\tsimp->must_free_data = TRUE;\n\t\tsimp->data = new_data;\n\t\tsimp->alloced = new_alloced;\n\t}\n\tmemcpy(simp->data + simp->len, data, len);\n\tsimp->len = new_len;\n}\n\n/**\n * \\defgroup packedsz protobuf_c_message_get_packed_size() implementation\n *\n * Routines mainly used by protobuf_c_message_get_packed_size().\n *\n * \\ingroup internal\n * @{\n */\n\n/**\n * Return the number of bytes required to store the tag for the field. Includes\n * 3 bits for the wire-type, and a single bit that denotes the end-of-tag.\n *\n * \\param number\n *      Field tag to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nget_tag_size(uint32_t number)\n{\n\tif (number < (1UL << 4)) {\n\t\treturn 1;\n\t} else if (number < (1UL << 11)) {\n\t\treturn 2;\n\t} else if (number < (1UL << 18)) {\n\t\treturn 3;\n\t} else if (number < (1UL << 25)) {\n\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\n/**\n * Return the number of bytes required to store a variable-length unsigned\n * 32-bit integer in base-128 varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nuint32_size(uint32_t v)\n{\n\tif (v < (1UL << 7)) {\n\t\treturn 1;\n\t} else if (v < (1UL << 14)) {\n\t\treturn 2;\n\t} else if (v < (1UL << 21)) {\n\t\treturn 3;\n\t} else if (v < (1UL << 28)) {\n\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\n/**\n * Return the number of bytes required to store a variable-length signed 32-bit\n * integer in base-128 varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nint32_size(int32_t v)\n{\n\tif (v < 0) {\n\t\treturn 10;\n\t} else if (v < (1L << 7)) {\n\t\treturn 1;\n\t} else if (v < (1L << 14)) {\n\t\treturn 2;\n\t} else if (v < (1L << 21)) {\n\t\treturn 3;\n\t} else if (v < (1L << 28)) {\n\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\n/**\n * Return the ZigZag-encoded 32-bit unsigned integer form of a 32-bit signed\n * integer.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      ZigZag encoded integer.\n */\nstatic inline uint32_t\nzigzag32(int32_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn ((uint32_t)v << 1) ^ -((uint32_t)v >> 31);\n}\n\n/**\n * Return the number of bytes required to store a signed 32-bit integer,\n * converted to an unsigned 32-bit integer with ZigZag encoding, using base-128\n * varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nsint32_size(int32_t v)\n{\n\treturn uint32_size(zigzag32(v));\n}\n\n/**\n * Return the number of bytes required to store a 64-bit unsigned integer in\n * base-128 varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nuint64_size(uint64_t v)\n{\n\tuint32_t upper_v = (uint32_t) (v >> 32);\n\n\tif (upper_v == 0) {\n\t\treturn uint32_size((uint32_t) v);\n\t} else if (upper_v < (1UL << 3)) {\n\t\treturn 5;\n\t} else if (upper_v < (1UL << 10)) {\n\t\treturn 6;\n\t} else if (upper_v < (1UL << 17)) {\n\t\treturn 7;\n\t} else if (upper_v < (1UL << 24)) {\n\t\treturn 8;\n\t} else if (upper_v < (1UL << 31)) {\n\t\treturn 9;\n\t} else {\n\t\treturn 10;\n\t}\n}\n\n/**\n * Return the ZigZag-encoded 64-bit unsigned integer form of a 64-bit signed\n * integer.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      ZigZag encoded integer.\n */\nstatic inline uint64_t\nzigzag64(int64_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn ((uint64_t)v << 1) ^ -((uint64_t)v >> 63);\n}\n\n/**\n * Return the number of bytes required to store a signed 64-bit integer,\n * converted to an unsigned 64-bit integer with ZigZag encoding, using base-128\n * varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nsint64_size(int64_t v)\n{\n\treturn uint64_size(zigzag64(v));\n}\n\n/**\n * Calculate the serialized size of a single required message field, including\n * the space needed by the preceding tag.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nrequired_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       const void *member)\n{\n\tsize_t rv = get_tag_size(field->id);\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\treturn rv + sint32_size(*(const int32_t *) member);\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\treturn rv + int32_size(*(const int32_t *) member);\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\treturn rv + uint32_size(*(const uint32_t *) member);\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\treturn rv + sint64_size(*(const int64_t *) member);\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\treturn rv + uint64_size(*(const uint64_t *) member);\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\treturn rv + 4;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\treturn rv + 8;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn rv + 1;\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\treturn rv + 4;\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn rv + 8;\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tconst char *str = *(char * const *) member;\n\t\tsize_t len = str ? strlen(str) : 0;\n\t\treturn rv + uint32_size(len) + len;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tsize_t len = ((const ProtobufCBinaryData *) member)->len;\n\t\treturn rv + uint32_size(len) + len;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tconst ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;\n\t\tsize_t subrv = msg ? protobuf_c_message_get_packed_size(msg) : 0;\n\t\treturn rv + uint32_size(subrv) + subrv;\n\t}\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Calculate the serialized size of a single oneof message field, including\n * the space needed by the preceding tag. Returns 0 if the oneof field isn't\n * selected or is not set.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param oneof_case\n *      Enum value that selects the field in the oneof.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\noneof_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t    uint32_t oneof_case,\n\t\t\t    const void *member)\n{\n\tif (oneof_case != field->id) {\n\t\treturn 0;\n\t}\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t}\n\treturn required_field_get_packed_size(field, member);\n}\n\n/**\n * Calculate the serialized size of a single optional message field, including\n * the space needed by the preceding tag. Returns 0 if the optional field isn't\n * set.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param has\n *      True if the field exists, false if not.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\noptional_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       const protobuf_c_boolean has,\n\t\t\t       const void *member)\n{\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!has)\n\t\t\treturn 0;\n\t}\n\treturn required_field_get_packed_size(field, member);\n}\n\nstatic protobuf_c_boolean\nfield_is_zeroish(const ProtobufCFieldDescriptor *field,\n\t\t const void *member)\n{\n\tprotobuf_c_boolean ret = FALSE;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tret = (0 == *(const protobuf_c_boolean *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\tret = (0 == *(const uint32_t *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\tret = (0 == *(const uint64_t *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tret = (0 == *(const float *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tret = (0 == *(const double *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_STRING:\n\t\tret = (NULL == *(const char * const *) member) ||\n\t\t      ('\\0' == **(const char * const *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BYTES:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\tret = (NULL == *(const void * const *) member);\n\t\tbreak;\n\tdefault:\n\t\tret = TRUE;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/**\n * Calculate the serialized size of a single unlabeled message field, including\n * the space needed by the preceding tag. Returns 0 if the field isn't set or\n * if it is set to a \"zeroish\" value (null pointer or 0 for numerical values).\n * Unlabeled fields are supported only in proto3.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nunlabeled_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t\tconst void *member)\n{\n\tif (field_is_zeroish(field, member))\n\t\treturn 0;\n\treturn required_field_get_packed_size(field, member);\n}\n\n/**\n * Calculate the serialized size of repeated message fields, which may consist\n * of any number of values (including 0). Includes the space needed by the\n * preceding tags (as needed).\n *\n * \\param field\n *      Field descriptor for member.\n * \\param count\n *      Number of repeated field members.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nrepeated_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       size_t count, const void *member)\n{\n\tsize_t header_size;\n\tsize_t rv = 0;\n\tunsigned i;\n\tvoid *array = *(void * const *) member;\n\n\tif (count == 0)\n\t\treturn 0;\n\theader_size = get_tag_size(field->id);\n\tif (0 == (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED))\n\t\theader_size *= count;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint32_size(((int32_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += int32_size(((int32_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint32_size(((uint32_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint64_size(((int64_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint64_size(((uint64_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\trv += 4 * count;\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\trv += 8 * count;\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\trv += count;\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_STRING:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsize_t len = strlen(((char **) array)[i]);\n\t\t\trv += uint32_size(len) + len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BYTES:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsize_t len = ((ProtobufCBinaryData *) array)[i].len;\n\t\t\trv += uint32_size(len) + len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsize_t len = protobuf_c_message_get_packed_size(\n\t\t\t\t((ProtobufCMessage **) array)[i]);\n\t\t\trv += uint32_size(len) + len;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED))\n\t\theader_size += uint32_size(rv);\n\treturn header_size + rv;\n}\n\n/**\n * Calculate the serialized size of an unknown field, i.e. one that is passed\n * through mostly uninterpreted. This is required for forward compatibility if\n * new fields are added to the message descriptor.\n *\n * \\param field\n *      Unknown field type.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nunknown_field_get_packed_size(const ProtobufCMessageUnknownField *field)\n{\n\treturn get_tag_size(field->tag) + field->len;\n}\n\n/**@}*/\n\n/*\n * Calculate the serialized size of the message.\n */\nsize_t protobuf_c_message_get_packed_size(const ProtobufCMessage *message)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member =\n\t\t\t((const char *) message) + field->offset;\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_get_packed_size(field, member);\n\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n\t\t\trv += oneof_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\t*(const uint32_t *) qmember,\n\t\t\t\tmember\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\trv += optional_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\t*(protobuf_c_boolean *) qmember,\n\t\t\t\tmember\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n\t\t\trv += unlabeled_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\tmember\n\t\t\t);\n\t\t} else {\n\t\t\trv += repeated_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\t*(const size_t *) qmember,\n\t\t\t\tmember\n\t\t\t);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_get_packed_size(&message->unknown_fields[i]);\n\treturn rv;\n}\n\n/**\n * \\defgroup pack protobuf_c_message_pack() implementation\n *\n * Routines mainly used by protobuf_c_message_pack().\n *\n * \\ingroup internal\n * @{\n */\n\n/**\n * Pack an unsigned 32-bit integer in base-128 varint encoding and return the\n * number of bytes written, which must be 5 or less.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nuint32_pack(uint32_t value, uint8_t *out)\n{\n\tunsigned rv = 0;\n\n\tif (value >= 0x80) {\n\t\tout[rv++] = value | 0x80;\n\t\tvalue >>= 7;\n\t\tif (value >= 0x80) {\n\t\t\tout[rv++] = value | 0x80;\n\t\t\tvalue >>= 7;\n\t\t\tif (value >= 0x80) {\n\t\t\t\tout[rv++] = value | 0x80;\n\t\t\t\tvalue >>= 7;\n\t\t\t\tif (value >= 0x80) {\n\t\t\t\t\tout[rv++] = value | 0x80;\n\t\t\t\t\tvalue >>= 7;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* assert: value<128 */\n\tout[rv++] = value;\n\treturn rv;\n}\n\n/**\n * Pack a signed 32-bit integer and return the number of bytes written,\n * passed as unsigned to avoid implementation-specific behavior.\n * Negative numbers are encoded as two's complement 64-bit integers.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nint32_pack(uint32_t value, uint8_t *out)\n{\n\tif ((int32_t)value < 0) {\n\t\tout[0] = value | 0x80;\n\t\tout[1] = (value >> 7) | 0x80;\n\t\tout[2] = (value >> 14) | 0x80;\n\t\tout[3] = (value >> 21) | 0x80;\n\t\tout[4] = (value >> 28) | 0xf0;\n\t\tout[5] = out[6] = out[7] = out[8] = 0xff;\n\t\tout[9] = 0x01;\n\t\treturn 10;\n\t} else {\n\t\treturn uint32_pack(value, out);\n\t}\n}\n\n/**\n * Pack a signed 32-bit integer using ZigZag encoding and return the number of\n * bytes written.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nsint32_pack(int32_t value, uint8_t *out)\n{\n\treturn uint32_pack(zigzag32(value), out);\n}\n\n/**\n * Pack a 64-bit unsigned integer using base-128 varint encoding and return the\n * number of bytes written.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\nuint64_pack(uint64_t value, uint8_t *out)\n{\n\tuint32_t hi = (uint32_t) (value >> 32);\n\tuint32_t lo = (uint32_t) value;\n\tunsigned rv;\n\n\tif (hi == 0)\n\t\treturn uint32_pack((uint32_t) lo, out);\n\tout[0] = (lo) | 0x80;\n\tout[1] = (lo >> 7) | 0x80;\n\tout[2] = (lo >> 14) | 0x80;\n\tout[3] = (lo >> 21) | 0x80;\n\tif (hi < 8) {\n\t\tout[4] = (hi << 4) | (lo >> 28);\n\t\treturn 5;\n\t} else {\n\t\tout[4] = ((hi & 7) << 4) | (lo >> 28) | 0x80;\n\t\thi >>= 3;\n\t}\n\trv = 5;\n\twhile (hi >= 128) {\n\t\tout[rv++] = hi | 0x80;\n\t\thi >>= 7;\n\t}\n\tout[rv++] = hi;\n\treturn rv;\n}\n\n/**\n * Pack a 64-bit signed integer in ZigZag encoding and return the number of\n * bytes written.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nsint64_pack(int64_t value, uint8_t *out)\n{\n\treturn uint64_pack(zigzag64(value), out);\n}\n\n/**\n * Pack a 32-bit quantity in little-endian byte order. Used for protobuf wire\n * types fixed32, sfixed32, float. Similar to \"htole32\".\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nfixed32_pack(uint32_t value, void *out)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, &value, 4);\n#else\n\tuint8_t *buf = out;\n\n\tbuf[0] = value;\n\tbuf[1] = value >> 8;\n\tbuf[2] = value >> 16;\n\tbuf[3] = value >> 24;\n#endif\n\treturn 4;\n}\n\n/**\n * Pack a 64-bit quantity in little-endian byte order. Used for protobuf wire\n * types fixed64, sfixed64, double. Similar to \"htole64\".\n *\n * \\todo The big-endian impl is really only good for 32-bit machines, a 64-bit\n * version would be appreciated, plus a way to decide to use 64-bit math where\n * convenient.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nfixed64_pack(uint64_t value, void *out)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, &value, 8);\n#else\n\tfixed32_pack(value, out);\n\tfixed32_pack(value >> 32, ((char *) out) + 4);\n#endif\n\treturn 8;\n}\n\n/**\n * Pack a boolean value as an integer and return the number of bytes written.\n *\n * \\todo Perhaps on some platforms *out = !!value would be a better impl, b/c\n * that is idiomatic C++ in some STL implementations.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nboolean_pack(protobuf_c_boolean value, uint8_t *out)\n{\n\t*out = value ? TRUE : FALSE;\n\treturn 1;\n}\n\n/**\n * Pack a NUL-terminated C string and return the number of bytes written. The\n * output includes a length delimiter.\n *\n * The NULL pointer is treated as an empty string. This isn't really necessary,\n * but it allows people to leave required strings blank. (See Issue #13 in the\n * bug tracker for a little more explanation).\n *\n * \\param str\n *      String to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nstring_pack(const char *str, uint8_t *out)\n{\n\tif (str == NULL) {\n\t\tout[0] = 0;\n\t\treturn 1;\n\t} else {\n\t\tsize_t len = strlen(str);\n\t\tsize_t rv = uint32_pack(len, out);\n\t\tmemcpy(out + rv, str, len);\n\t\treturn rv + len;\n\t}\n}\n\n/**\n * Pack a ProtobufCBinaryData and return the number of bytes written. The output\n * includes a length delimiter.\n *\n * \\param bd\n *      ProtobufCBinaryData to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nbinary_data_pack(const ProtobufCBinaryData *bd, uint8_t *out)\n{\n\tsize_t len = bd->len;\n\tsize_t rv = uint32_pack(len, out);\n\tmemcpy(out + rv, bd->data, len);\n\treturn rv + len;\n}\n\n/**\n * Pack a ProtobufCMessage and return the number of bytes written. The output\n * includes a length delimiter.\n *\n * \\param message\n *      ProtobufCMessage object to pack.\n * \\param[out] out\n *      Packed message.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nprefixed_message_pack(const ProtobufCMessage *message, uint8_t *out)\n{\n\tif (message == NULL) {\n\t\tout[0] = 0;\n\t\treturn 1;\n\t} else {\n\t\tsize_t rv = protobuf_c_message_pack(message, out + 1);\n\t\tuint32_t rv_packed_size = uint32_size(rv);\n\t\tif (rv_packed_size != 1)\n\t\t\tmemmove(out + rv_packed_size, out + 1, rv);\n\t\treturn uint32_pack(rv, out) + rv;\n\t}\n}\n\n/**\n * Pack a field tag.\n *\n * Wire-type will be added in required_field_pack().\n *\n * \\todo Just call uint64_pack on 64-bit platforms.\n *\n * \\param id\n *      Tag value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\ntag_pack(uint32_t id, uint8_t *out)\n{\n\tif (id < (1UL << (32 - 3)))\n\t\treturn uint32_pack(id << 3, out);\n\telse\n\t\treturn uint64_pack(((uint64_t) id) << 3, out);\n}\n\n/**\n * Pack a required field and return the number of bytes written.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\nrequired_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t    const void *member, uint8_t *out)\n{\n\tsize_t rv = tag_pack(field->id, out);\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + sint32_pack(*(const int32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + int32_pack(*(const int32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + uint32_pack(*(const uint32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + sint64_pack(*(const int64_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + uint64_pack(*(const uint64_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;\n\t\treturn rv + fixed32_pack(*(const uint32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;\n\t\treturn rv + fixed64_pack(*(const uint64_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + boolean_pack(*(const protobuf_c_boolean *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_STRING:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\treturn rv + string_pack(*(char *const *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_BYTES:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\treturn rv + binary_data_pack((const ProtobufCBinaryData *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\treturn rv + prefixed_message_pack(*(ProtobufCMessage * const *) member, out + rv);\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Pack a oneof field and return the number of bytes written. Only packs the\n * field that is selected by the case enum.\n *\n * \\param field\n *      Field descriptor.\n * \\param oneof_case\n *      Enum value that selects the field in the oneof.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\noneof_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t uint32_t oneof_case,\n\t\t const void *member, uint8_t *out)\n{\n\tif (oneof_case != field->id) {\n\t\treturn 0;\n\t}\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack(field, member, out);\n}\n\n/**\n * Pack an optional field and return the number of bytes written.\n *\n * \\param field\n *      Field descriptor.\n * \\param has\n *      Whether the field is set.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\noptional_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t    const protobuf_c_boolean has,\n\t\t    const void *member, uint8_t *out)\n{\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!has)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack(field, member, out);\n}\n\n/**\n * Pack an unlabeled field and return the number of bytes written.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\nunlabeled_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t     const void *member, uint8_t *out)\n{\n\tif (field_is_zeroish(field, member))\n\t\treturn 0;\n\treturn required_field_pack(field, member, out);\n}\n\n/**\n * Given a field type, return the in-memory size.\n *\n * \\todo Implement as a table lookup.\n *\n * \\param type\n *      Field type.\n * \\return\n *      Size of the field.\n */\nstatic inline size_t\nsizeof_elt_in_repeated_array(ProtobufCType type)\n{\n\tswitch (type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\tcase PROTOBUF_C_TYPE_ENUM:\n\t\treturn 4;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn 8;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn sizeof(protobuf_c_boolean);\n\tcase PROTOBUF_C_TYPE_STRING:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\treturn sizeof(void *);\n\tcase PROTOBUF_C_TYPE_BYTES:\n\t\treturn sizeof(ProtobufCBinaryData);\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Pack an array of 32-bit quantities.\n *\n * \\param[out] out\n *      Destination.\n * \\param[in] in\n *      Source.\n * \\param[in] n\n *      Number of elements in the source array.\n */\nstatic void\ncopy_to_little_endian_32(void *out, const void *in, const unsigned n)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, in, n * 4);\n#else\n\tunsigned i;\n\tconst uint32_t *ini = in;\n\tfor (i = 0; i < n; i++)\n\t\tfixed32_pack(ini[i], (uint32_t *) out + i);\n#endif\n}\n\n/**\n * Pack an array of 64-bit quantities.\n *\n * \\param[out] out\n *      Destination.\n * \\param[in] in\n *      Source.\n * \\param[in] n\n *      Number of elements in the source array.\n */\nstatic void\ncopy_to_little_endian_64(void *out, const void *in, const unsigned n)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, in, n * 8);\n#else\n\tunsigned i;\n\tconst uint64_t *ini = in;\n\tfor (i = 0; i < n; i++)\n\t\tfixed64_pack(ini[i], (uint64_t *) out + i);\n#endif\n}\n\n/**\n * Get the minimum number of bytes required to pack a field value of a\n * particular type.\n *\n * \\param type\n *      Field type.\n * \\return\n *      Number of bytes.\n */\nstatic unsigned\nget_type_min_size(ProtobufCType type)\n{\n\tif (type == PROTOBUF_C_TYPE_SFIXED32 ||\n\t    type == PROTOBUF_C_TYPE_FIXED32 ||\n\t    type == PROTOBUF_C_TYPE_FLOAT)\n\t{\n\t\treturn 4;\n\t}\n\tif (type == PROTOBUF_C_TYPE_SFIXED64 ||\n\t    type == PROTOBUF_C_TYPE_FIXED64 ||\n\t    type == PROTOBUF_C_TYPE_DOUBLE)\n\t{\n\t\treturn 8;\n\t}\n\treturn 1;\n}\n\n/**\n * Packs the elements of a repeated field and returns the serialised field and\n * its length.\n *\n * \\param field\n *      Field descriptor.\n * \\param count\n *      Number of elements in the repeated field array.\n * \\param member\n *      Pointer to the elements for this repeated field.\n * \\param[out] out\n *      Serialised representation of the repeated field.\n * \\return\n *      Number of bytes serialised to `out`.\n */\nstatic size_t\nrepeated_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t    size_t count, const void *member, uint8_t *out)\n{\n\tvoid *array = *(void * const *) member;\n\tunsigned i;\n\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {\n\t\tunsigned header_len;\n\t\tunsigned len_start;\n\t\tunsigned min_length;\n\t\tunsigned payload_len;\n\t\tunsigned length_size_min;\n\t\tunsigned actual_length_size;\n\t\tuint8_t *payload_at;\n\n\t\tif (count == 0)\n\t\t\treturn 0;\n\t\theader_len = tag_pack(field->id, out);\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\tlen_start = header_len;\n\t\tmin_length = get_type_min_size(field->type) * count;\n\t\tlength_size_min = uint32_size(min_length);\n\t\theader_len += length_size_min;\n\t\tpayload_at = out + header_len;\n\n\t\tswitch (field->type) {\n\t\tcase PROTOBUF_C_TYPE_SFIXED32:\n\t\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\t\tcopy_to_little_endian_32(payload_at, array, count);\n\t\t\tpayload_at += count * 4;\n\t\t\tbreak;\n\t\tcase PROTOBUF_C_TYPE_SFIXED64:\n\t\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\t\tcopy_to_little_endian_64(payload_at, array, count);\n\t\t\tpayload_at += count * 8;\n\t\t\tbreak;\n\t\tcase PROTOBUF_C_TYPE_ENUM:\n\t\tcase PROTOBUF_C_TYPE_INT32: {\n\t\t\tconst int32_t *arr = (const int32_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += int32_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_SINT32: {\n\t\t\tconst int32_t *arr = (const int32_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += sint32_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_SINT64: {\n\t\t\tconst int64_t *arr = (const int64_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += sint64_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_UINT32: {\n\t\t\tconst uint32_t *arr = (const uint32_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += uint32_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_INT64:\n\t\tcase PROTOBUF_C_TYPE_UINT64: {\n\t\t\tconst uint64_t *arr = (const uint64_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += uint64_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_BOOL: {\n\t\t\tconst protobuf_c_boolean *arr = (const protobuf_c_boolean *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += boolean_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t\t}\n\n\t\tpayload_len = payload_at - (out + header_len);\n\t\tactual_length_size = uint32_size(payload_len);\n\t\tif (length_size_min != actual_length_size) {\n\t\t\tassert(actual_length_size == length_size_min + 1);\n\t\t\tmemmove(out + header_len + 1, out + header_len,\n\t\t\t\tpayload_len);\n\t\t\theader_len++;\n\t\t}\n\t\tuint32_pack(payload_len, out + len_start);\n\t\treturn header_len + payload_len;\n\t} else {\n\t\t/* not \"packed\" cased */\n\t\t/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */\n\t\tsize_t rv = 0;\n\t\tunsigned siz = sizeof_elt_in_repeated_array(field->type);\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\trv += required_field_pack(field, array, out + rv);\n\t\t\tarray = (char *)array + siz;\n\t\t}\n\t\treturn rv;\n\t}\n}\n\nstatic size_t\nunknown_field_pack(const ProtobufCMessageUnknownField *field, uint8_t *out)\n{\n\tsize_t rv = tag_pack(field->tag, out);\n\tout[0] |= field->wire_type;\n\tmemcpy(out + rv, field->data, field->len);\n\treturn rv + field->len;\n}\n\n/**@}*/\n\nsize_t\nprotobuf_c_message_pack(const ProtobufCMessage *message, uint8_t *out)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member = ((const char *) message) + field->offset;\n\n\t\t/*\n\t\t * It doesn't hurt to compute qmember (a pointer to the\n\t\t * quantifier field of the structure), but the pointer is only\n\t\t * valid if the field is:\n\t\t *  - a repeated field, or\n\t\t *  - a field that is part of a oneof\n\t\t *  - an optional field that isn't a pointer type\n\t\t * (Meaning: not a message or a string).\n\t\t */\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_pack(field, member, out + rv);\n\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n\t\t\trv += oneof_field_pack(\n\t\t\t\tfield,\n\t\t\t\t*(const uint32_t *) qmember,\n\t\t\t\tmember,\n\t\t\t\tout + rv\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\trv += optional_field_pack(\n\t\t\t\tfield,\n\t\t\t\t*(const protobuf_c_boolean *) qmember,\n\t\t\t\tmember,\n\t\t\t\tout + rv\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n\t\t\trv += unlabeled_field_pack(field, member, out + rv);\n\t\t} else {\n\t\t\trv += repeated_field_pack(field, *(const size_t *) qmember,\n\t\t\t\tmember, out + rv);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_pack(&message->unknown_fields[i], out + rv);\n\treturn rv;\n}\n\n/**\n * \\defgroup packbuf protobuf_c_message_pack_to_buffer() implementation\n *\n * Routines mainly used by protobuf_c_message_pack_to_buffer().\n *\n * \\ingroup internal\n * @{\n */\n\n/**\n * Pack a required field to a virtual buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes packed.\n */\nstatic size_t\nrequired_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      const void *member, ProtobufCBuffer *buffer)\n{\n\tsize_t rv;\n\tuint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];\n\n\trv = tag_pack(field->id, scratch);\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += sint32_pack(*(const int32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += int32_pack(*(const int32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += uint32_pack(*(const uint32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += sint64_pack(*(const int64_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += uint64_pack(*(const uint64_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;\n\t\trv += fixed32_pack(*(const uint32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;\n\t\trv += fixed64_pack(*(const uint64_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += boolean_pack(*(const protobuf_c_boolean *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tconst char *str = *(char *const *) member;\n\t\tsize_t sublen = str ? strlen(str) : 0;\n\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(sublen, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbuffer->append(buffer, sublen, (const uint8_t *) str);\n\t\trv += sublen;\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tconst ProtobufCBinaryData *bd = ((const ProtobufCBinaryData *) member);\n\t\tsize_t sublen = bd->len;\n\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(sublen, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbuffer->append(buffer, sublen, bd->data);\n\t\trv += sublen;\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tconst ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;\n\t\t\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\tif (msg == NULL) {\n\t\t\trv += uint32_pack(0, scratch + rv);\n\t\t\tbuffer->append(buffer, rv, scratch);\n\t\t} else {\n\t\t\tsize_t sublen = protobuf_c_message_get_packed_size(msg);\n\t\t\trv += uint32_pack(sublen, scratch + rv);\n\t\t\tbuffer->append(buffer, rv, scratch);\n\t\t\tprotobuf_c_message_pack_to_buffer(msg, buffer);\n\t\t\trv += sublen;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\treturn rv;\n}\n\n/**\n * Pack a oneof field to a buffer. Only packs the field that is selected by the case enum.\n *\n * \\param field\n *      Field descriptor.\n * \\param oneof_case\n *      Enum value that selects the field in the oneof.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes serialised to `buffer`.\n */\nstatic size_t\noneof_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t   uint32_t oneof_case,\n\t\t\t   const void *member, ProtobufCBuffer *buffer)\n{\n\tif (oneof_case != field->id) {\n\t\treturn 0;\n\t}\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void *const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack_to_buffer(field, member, buffer);\n}\n\n/**\n * Pack an optional field to a buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param has\n *      Whether the field is set.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes serialised to `buffer`.\n */\nstatic size_t\noptional_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      const protobuf_c_boolean has,\n\t\t\t      const void *member, ProtobufCBuffer *buffer)\n{\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void *const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!has)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack_to_buffer(field, member, buffer);\n}\n\n/**\n * Pack an unlabeled field to a buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes serialised to `buffer`.\n */\nstatic size_t\nunlabeled_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t       const void *member, ProtobufCBuffer *buffer)\n{\n\tif (field_is_zeroish(field, member))\n\t\treturn 0;\n\treturn required_field_pack_to_buffer(field, member, buffer);\n}\n\n/**\n * Get the packed size of an array of same field type.\n *\n * \\param field\n *      Field descriptor.\n * \\param count\n *      Number of elements of this type.\n * \\param array\n *      The elements to get the size of.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nget_packed_payload_length(const ProtobufCFieldDescriptor *field,\n\t\t\t  unsigned count, const void *array)\n{\n\tunsigned rv = 0;\n\tunsigned i;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\treturn count * 4;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn count * 8;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32: {\n\t\tconst int32_t *arr = (const int32_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += int32_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_SINT32: {\n\t\tconst int32_t *arr = (const int32_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint32_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_UINT32: {\n\t\tconst uint32_t *arr = (const uint32_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint32_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_SINT64: {\n\t\tconst int64_t *arr = (const int64_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint64_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64: {\n\t\tconst uint64_t *arr = (const uint64_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint64_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn count;\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\treturn rv;\n}\n\n/**\n * Pack an array of same field type to a virtual buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param count\n *      Number of elements of this type.\n * \\param array\n *      The elements to get the size of.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes packed.\n */\nstatic size_t\npack_buffer_packed_payload(const ProtobufCFieldDescriptor *field,\n\t\t\t   unsigned count, const void *array,\n\t\t\t   ProtobufCBuffer *buffer)\n{\n\tuint8_t scratch[16];\n\tsize_t rv = 0;\n\tunsigned i;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n#if !defined(WORDS_BIGENDIAN)\n\t\trv = count * 4;\n\t\tgoto no_packing_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = fixed32_pack(((uint32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n#if !defined(WORDS_BIGENDIAN)\n\t\trv = count * 8;\n\t\tgoto no_packing_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = fixed64_pack(((uint64_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = int32_pack(((int32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = sint32_pack(((int32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = uint32_pack(((uint32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = sint64_pack(((int64_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = uint64_pack(((uint64_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = boolean_pack(((protobuf_c_boolean *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\treturn count;\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\treturn rv;\n\n#if !defined(WORDS_BIGENDIAN)\nno_packing_needed:\n\tbuffer->append(buffer, rv, array);\n\treturn rv;\n#endif\n}\n\nstatic size_t\nrepeated_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      unsigned count, const void *member,\n\t\t\t      ProtobufCBuffer *buffer)\n{\n\tchar *array = *(char * const *) member;\n\n\tif (count == 0)\n\t\treturn 0;\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {\n\t\tuint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];\n\t\tsize_t rv = tag_pack(field->id, scratch);\n\t\tsize_t payload_len = get_packed_payload_length(field, count, array);\n\t\tsize_t tmp;\n\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(payload_len, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\ttmp = pack_buffer_packed_payload(field, count, array, buffer);\n\t\tassert(tmp == payload_len);\n\t\treturn rv + payload_len;\n\t} else {\n\t\tsize_t siz;\n\t\tunsigned i;\n\t\t/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */\n\t\tunsigned rv = 0;\n\n\t\tsiz = sizeof_elt_in_repeated_array(field->type);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\trv += required_field_pack_to_buffer(field, array, buffer);\n\t\t\tarray += siz;\n\t\t}\n\t\treturn rv;\n\t}\n}\n\nstatic size_t\nunknown_field_pack_to_buffer(const ProtobufCMessageUnknownField *field,\n\t\t\t     ProtobufCBuffer *buffer)\n{\n\tuint8_t header[MAX_UINT64_ENCODED_SIZE];\n\tsize_t rv = tag_pack(field->tag, header);\n\n\theader[0] |= field->wire_type;\n\tbuffer->append(buffer, rv, header);\n\tbuffer->append(buffer, field->len, field->data);\n\treturn rv + field->len;\n}\n\n/**@}*/\n\nsize_t\nprotobuf_c_message_pack_to_buffer(const ProtobufCMessage *message,\n\t\t\t\t  ProtobufCBuffer *buffer)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member =\n\t\t\t((const char *) message) + field->offset;\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_pack_to_buffer(field, member, buffer);\n\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n\t\t\trv += oneof_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\t*(const uint32_t *) qmember,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\trv += optional_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\t*(const protobuf_c_boolean *) qmember,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n\t\t\trv += unlabeled_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t} else {\n\t\t\trv += repeated_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\t*(const size_t *) qmember,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_pack_to_buffer(&message->unknown_fields[i], buffer);\n\n\treturn rv;\n}\n\n/**\n * \\defgroup unpack unpacking implementation\n *\n * Routines mainly used by the unpacking functions.\n *\n * \\ingroup internal\n * @{\n */\n\nstatic inline int\nint_range_lookup(unsigned n_ranges, const ProtobufCIntRange *ranges, int value)\n{\n\tunsigned n;\n\tunsigned start;\n\n\tif (n_ranges == 0)\n\t\treturn -1;\n\tstart = 0;\n\tn = n_ranges;\n\twhile (n > 1) {\n\t\tunsigned mid = start + n / 2;\n\n\t\tif (value < ranges[mid].start_value) {\n\t\t\tn = mid - start;\n\t\t} else if (value >= ranges[mid].start_value +\n\t\t\t   (int) (ranges[mid + 1].orig_index -\n\t\t\t\t  ranges[mid].orig_index))\n\t\t{\n\t\t\tunsigned new_start = mid + 1;\n\t\t\tn = start + n - new_start;\n\t\t\tstart = new_start;\n\t\t} else\n\t\t\treturn (value - ranges[mid].start_value) +\n\t\t\t    ranges[mid].orig_index;\n\t}\n\tif (n > 0) {\n\t\tunsigned start_orig_index = ranges[start].orig_index;\n\t\tunsigned range_size =\n\t\t\tranges[start + 1].orig_index - start_orig_index;\n\n\t\tif (ranges[start].start_value <= value &&\n\t\t    value < (int) (ranges[start].start_value + range_size))\n\t\t{\n\t\t\treturn (value - ranges[start].start_value) +\n\t\t\t    start_orig_index;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic size_t\nparse_tag_and_wiretype(size_t len,\n\t\t       const uint8_t *data,\n\t\t       uint32_t *tag_out,\n\t\t       uint8_t *wiretype_out)\n{\n\tunsigned max_rv = len > 5 ? 5 : len;\n\tuint32_t tag = (data[0] & 0x7f) >> 3;\n\tunsigned shift = 4;\n\tunsigned rv;\n\n\t/* 0 is not a valid tag value */\n\tif ((data[0] & 0xf8) == 0) {\n\t\treturn 0;\n\t}\n\n\t*wiretype_out = data[0] & 7;\n\tif ((data[0] & 0x80) == 0) {\n\t\t*tag_out = tag;\n\t\treturn 1;\n\t}\n\tfor (rv = 1; rv < max_rv; rv++) {\n\t\tif (data[rv] & 0x80) {\n\t\t\ttag |= (data[rv] & 0x7f) << shift;\n\t\t\tshift += 7;\n\t\t} else {\n\t\t\ttag |= data[rv] << shift;\n\t\t\t*tag_out = tag;\n\t\t\treturn rv + 1;\n\t\t}\n\t}\n\treturn 0; /* error: bad header */\n}\n\n/* sizeof(ScannedMember) must be <= (1UL<<BOUND_SIZEOF_SCANNED_MEMBER_LOG2) */\n#define BOUND_SIZEOF_SCANNED_MEMBER_LOG2 5\ntypedef struct ScannedMember ScannedMember;\n/** Field as it's being read. */\nstruct ScannedMember {\n\tuint32_t tag;              /**< Field tag. */\n\tuint8_t wire_type;         /**< Field type. */\n\tuint8_t length_prefix_len; /**< Prefix length. */\n\tconst ProtobufCFieldDescriptor *field; /**< Field descriptor. */\n\tsize_t len;                /**< Field length. */\n\tconst uint8_t *data;       /**< Pointer to field data. */\n};\n\nstatic inline size_t\nscan_length_prefixed_data(size_t len, const uint8_t *data,\n\t\t\t  size_t *prefix_len_out)\n{\n\tunsigned hdr_max = len < 5 ? len : 5;\n\tunsigned hdr_len;\n\tsize_t val = 0;\n\tunsigned i;\n\tunsigned shift = 0;\n\n\tfor (i = 0; i < hdr_max; i++) {\n\t\tval |= ((size_t)data[i] & 0x7f) << shift;\n\t\tshift += 7;\n\t\tif ((data[i] & 0x80) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == hdr_max) {\n\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing length for length-prefixed data\");\n\t\treturn 0;\n\t}\n\thdr_len = i + 1;\n\t*prefix_len_out = hdr_len;\n\tif (val > INT_MAX) {\n\t\t// Protobuf messages should always be less than 2 GiB in size.\n\t\t// We also want to return early here so that hdr_len + val does\n\t\t// not overflow on 32-bit systems.\n\t\tPROTOBUF_C_UNPACK_ERROR(\"length prefix of %lu is too large\",\n\t\t\t(unsigned long int)val);\n\t\treturn 0;\n\t}\n\tif (hdr_len + val > len) {\n\t\tPROTOBUF_C_UNPACK_ERROR(\"data too short after length-prefix of %lu\",\n\t\t\t(unsigned long int)val);\n\t\treturn 0;\n\t}\n\treturn hdr_len + val;\n}\n\nstatic size_t\nmax_b128_numbers(size_t len, const uint8_t *data)\n{\n\tsize_t rv = 0;\n\twhile (len--)\n\t\tif ((*data++ & 0x80) == 0)\n\t\t\t++rv;\n\treturn rv;\n}\n\n/**@}*/\n\n/**\n * Merge earlier message into a latter message.\n *\n * For numeric types and strings, if the same value appears multiple\n * times, the parser accepts the last value it sees. For embedded\n * message fields, the parser merges multiple instances of the same\n * field. That is, all singular scalar fields in the latter instance\n * replace those in the former, singular embedded messages are merged,\n * and repeated fields are concatenated.\n *\n * The earlier message should be freed after calling this function, as\n * some of its fields may have been reused and changed to their default\n * values during the merge.\n */\nstatic protobuf_c_boolean\nmerge_messages(ProtobufCMessage *earlier_msg,\n\t       ProtobufCMessage *latter_msg,\n\t       ProtobufCAllocator *allocator)\n{\n\tunsigned i;\n\tconst ProtobufCFieldDescriptor *fields =\n\t\tlatter_msg->descriptor->fields;\n\tfor (i = 0; i < latter_msg->descriptor->n_fields; i++) {\n\t\tif (fields[i].label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *n_earlier =\n\t\t\t\tSTRUCT_MEMBER_PTR(size_t, earlier_msg,\n\t\t\t\t\t\t  fields[i].quantifier_offset);\n\t\t\tuint8_t **p_earlier =\n\t\t\t\tSTRUCT_MEMBER_PTR(uint8_t *, earlier_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\t\t\tsize_t *n_latter =\n\t\t\t\tSTRUCT_MEMBER_PTR(size_t, latter_msg,\n\t\t\t\t\t\t  fields[i].quantifier_offset);\n\t\t\tuint8_t **p_latter =\n\t\t\t\tSTRUCT_MEMBER_PTR(uint8_t *, latter_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\n\t\t\tif (*n_earlier > 0) {\n\t\t\t\tif (*n_latter > 0) {\n\t\t\t\t\t/* Concatenate the repeated field */\n\t\t\t\t\tsize_t el_size =\n\t\t\t\t\t\tsizeof_elt_in_repeated_array(fields[i].type);\n\t\t\t\t\tuint8_t *new_field;\n\n\t\t\t\t\tnew_field = do_alloc(allocator,\n\t\t\t\t\t\t(*n_earlier + *n_latter) * el_size);\n\t\t\t\t\tif (!new_field)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tmemcpy(new_field, *p_earlier,\n\t\t\t\t\t       *n_earlier * el_size);\n\t\t\t\t\tmemcpy(new_field +\n\t\t\t\t\t       *n_earlier * el_size,\n\t\t\t\t\t       *p_latter,\n\t\t\t\t\t       *n_latter * el_size);\n\n\t\t\t\t\tdo_free(allocator, *p_latter);\n\t\t\t\t\tdo_free(allocator, *p_earlier);\n\t\t\t\t\t*p_latter = new_field;\n\t\t\t\t\t*n_latter = *n_earlier + *n_latter;\n\t\t\t\t} else {\n\t\t\t\t\t/* Zero copy the repeated field from the earlier message */\n\t\t\t\t\t*n_latter = *n_earlier;\n\t\t\t\t\t*p_latter = *p_earlier;\n\t\t\t\t}\n\t\t\t\t/* Make sure the field does not get double freed */\n\t\t\t\t*n_earlier = 0;\n\t\t\t\t*p_earlier = 0;\n\t\t\t}\n\t\t} else if (fields[i].label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t   fields[i].label == PROTOBUF_C_LABEL_NONE) {\n\t\t\tconst ProtobufCFieldDescriptor *field;\n\t\t\tuint32_t *earlier_case_p = STRUCT_MEMBER_PTR(uint32_t,\n\t\t\t\t\t\t\t\t     earlier_msg,\n\t\t\t\t\t\t\t\t     fields[i].\n\t\t\t\t\t\t\t\t     quantifier_offset);\n\t\t\tuint32_t *latter_case_p = STRUCT_MEMBER_PTR(uint32_t,\n\t\t\t\t\t\t\t\t    latter_msg,\n\t\t\t\t\t\t\t\t    fields[i].\n\t\t\t\t\t\t\t\t    quantifier_offset);\n\t\t\tprotobuf_c_boolean need_to_merge = FALSE;\n\t\t\tvoid *earlier_elem;\n\t\t\tvoid *latter_elem;\n\t\t\tconst void *def_val;\n\n\t\t\tif (fields[i].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {\n\t\t\t\tif (*latter_case_p == 0) {\n\t\t\t\t\t/* lookup correct oneof field */\n\t\t\t\t\tint field_index =\n\t\t\t\t\t\tint_range_lookup(\n\t\t\t\t\t\t\tlatter_msg->descriptor\n\t\t\t\t\t\t\t->n_field_ranges,\n\t\t\t\t\t\t\tlatter_msg->descriptor\n\t\t\t\t\t\t\t->field_ranges,\n\t\t\t\t\t\t\t*earlier_case_p);\n\t\t\t\t\tif (field_index < 0)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tfield = latter_msg->descriptor->fields +\n\t\t\t\t\t\tfield_index;\n\t\t\t\t} else {\n\t\t\t\t\t/* Oneof is present in the latter message, move on */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfield = &fields[i];\n\t\t\t}\n\n\t\t\tearlier_elem = STRUCT_MEMBER_P(earlier_msg, field->offset);\n\t\t\tlatter_elem = STRUCT_MEMBER_P(latter_msg, field->offset);\n\t\t\tdef_val = field->default_value;\n\n\t\t\tswitch (field->type) {\n\t\t\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\t\t\tProtobufCMessage *em = *(ProtobufCMessage **) earlier_elem;\n\t\t\t\tProtobufCMessage *lm = *(ProtobufCMessage **) latter_elem;\n\t\t\t\tif (em != NULL) {\n\t\t\t\t\tif (lm != NULL) {\n\t\t\t\t\t\tif (!merge_messages(em, lm, allocator))\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t/* Already merged */\n\t\t\t\t\t\tneed_to_merge = FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Zero copy the message */\n\t\t\t\t\t\tneed_to_merge = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\t\t\tuint8_t *e_data =\n\t\t\t\t\t((ProtobufCBinaryData *) earlier_elem)->data;\n\t\t\t\tuint8_t *l_data =\n\t\t\t\t\t((ProtobufCBinaryData *) latter_elem)->data;\n\t\t\t\tconst ProtobufCBinaryData *d_bd =\n\t\t\t\t\t(ProtobufCBinaryData *) def_val;\n\n\t\t\t\tneed_to_merge =\n\t\t\t\t\t(e_data != NULL &&\n\t\t\t\t\t (d_bd == NULL ||\n\t\t\t\t\t  e_data != d_bd->data)) &&\n\t\t\t\t\t(l_data == NULL ||\n\t\t\t\t\t (d_bd != NULL &&\n\t\t\t\t\t  l_data == d_bd->data));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PROTOBUF_C_TYPE_STRING: {\n\t\t\t\tchar *e_str = *(char **) earlier_elem;\n\t\t\t\tchar *l_str = *(char **) latter_elem;\n\t\t\t\tconst char *d_str = def_val;\n\n\t\t\t\tneed_to_merge = e_str != d_str && l_str == d_str;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t/* Could be has field or case enum, the logic is\n\t\t\t\t * equivalent, since 0 (FALSE) means not set for\n\t\t\t\t * oneof */\n\t\t\t\tneed_to_merge = (*earlier_case_p != 0) &&\n\t\t\t\t\t\t(*latter_case_p == 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\n\t\t\tif (need_to_merge) {\n\t\t\t\tsize_t el_size =\n\t\t\t\t\tsizeof_elt_in_repeated_array(field->type);\n\t\t\t\tmemcpy(latter_elem, earlier_elem, el_size);\n\t\t\t\t/*\n\t\t\t\t * Reset the element from the old message to 0\n\t\t\t\t * to make sure earlier message deallocation\n\t\t\t\t * doesn't corrupt zero-copied data in the new\n\t\t\t\t * message, earlier message will be freed after\n\t\t\t\t * this function is called anyway\n\t\t\t\t */\n\t\t\t\tmemset(earlier_elem, 0, el_size);\n\n\t\t\t\tif (field->quantifier_offset != 0) {\n\t\t\t\t\t/* Set the has field or the case enum,\n\t\t\t\t\t * if applicable */\n\t\t\t\t\t*latter_case_p = *earlier_case_p;\n\t\t\t\t\t*earlier_case_p = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/**\n * Count packed elements.\n *\n * Given a raw slab of packed-repeated values, determine the number of\n * elements. This function detects certain kinds of errors but not\n * others; the remaining error checking is done by\n * parse_packed_repeated_member().\n */\nstatic protobuf_c_boolean\ncount_packed_elements(ProtobufCType type,\n\t\t      size_t len, const uint8_t *data, size_t *count_out)\n{\n\tswitch (type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tif (len % 4 != 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"length must be a multiple of 4 for fixed-length 32-bit types\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t*count_out = len / 4;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tif (len % 8 != 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"length must be a multiple of 8 for fixed-length 64-bit types\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t*count_out = len / 8;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\t*count_out = max_b128_numbers(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t*count_out = len;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_STRING:\n\tcase PROTOBUF_C_TYPE_BYTES:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\tdefault:\n\t\tPROTOBUF_C_UNPACK_ERROR(\"bad protobuf-c type %u for packed-repeated\", type);\n\t\treturn FALSE;\n\t}\n}\n\nstatic inline uint32_t\nparse_uint32(unsigned len, const uint8_t *data)\n{\n\tuint32_t rv = data[0] & 0x7f;\n\tif (len > 1) {\n\t\trv |= ((uint32_t) (data[1] & 0x7f) << 7);\n\t\tif (len > 2) {\n\t\t\trv |= ((uint32_t) (data[2] & 0x7f) << 14);\n\t\t\tif (len > 3) {\n\t\t\t\trv |= ((uint32_t) (data[3] & 0x7f) << 21);\n\t\t\t\tif (len > 4)\n\t\t\t\t\trv |= ((uint32_t) (data[4]) << 28);\n\t\t\t}\n\t\t}\n\t}\n\treturn rv;\n}\n\nstatic inline uint32_t\nparse_int32(unsigned len, const uint8_t *data)\n{\n\treturn parse_uint32(len, data);\n}\n\nstatic inline int32_t\nunzigzag32(uint32_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn (int32_t)((v >> 1) ^ -(v & 1));\n}\n\nstatic inline uint32_t\nparse_fixed_uint32(const uint8_t *data)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tuint32_t t;\n\tmemcpy(&t, data, 4);\n\treturn t;\n#else\n\treturn data[0] |\n\t\t((uint32_t) (data[1]) << 8) |\n\t\t((uint32_t) (data[2]) << 16) |\n\t\t((uint32_t) (data[3]) << 24);\n#endif\n}\n\nstatic uint64_t\nparse_uint64(unsigned len, const uint8_t *data)\n{\n\tunsigned shift, i;\n\tuint64_t rv;\n\n\tif (len < 5)\n\t\treturn parse_uint32(len, data);\n\trv = ((uint64_t) (data[0] & 0x7f)) |\n\t\t((uint64_t) (data[1] & 0x7f) << 7) |\n\t\t((uint64_t) (data[2] & 0x7f) << 14) |\n\t\t((uint64_t) (data[3] & 0x7f) << 21);\n\tshift = 28;\n\tfor (i = 4; i < len; i++) {\n\t\trv |= (((uint64_t) (data[i] & 0x7f)) << shift);\n\t\tshift += 7;\n\t}\n\treturn rv;\n}\n\nstatic inline int64_t\nunzigzag64(uint64_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn (int64_t)((v >> 1) ^ -(v & 1));\n}\n\nstatic inline uint64_t\nparse_fixed_uint64(const uint8_t *data)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tuint64_t t;\n\tmemcpy(&t, data, 8);\n\treturn t;\n#else\n\treturn (uint64_t) parse_fixed_uint32(data) |\n\t\t(((uint64_t) parse_fixed_uint32(data + 4)) << 32);\n#endif\n}\n\nstatic protobuf_c_boolean\nparse_boolean(unsigned len, const uint8_t *data)\n{\n\tunsigned i;\n\tfor (i = 0; i < len; i++)\n\t\tif (data[i] & 0x7f)\n\t\t\treturn TRUE;\n\treturn FALSE;\n}\n\nstatic protobuf_c_boolean\nparse_required_member(ScannedMember *scanned_member,\n\t\t      void *member,\n\t\t      ProtobufCAllocator *allocator,\n\t\t      protobuf_c_boolean maybe_clear)\n{\n\tunsigned len = scanned_member->len;\n\tconst uint8_t *data = scanned_member->data;\n\tuint8_t wire_type = scanned_member->wire_type;\n\n\tswitch (scanned_member->field->type) {\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(int32_t *) member = parse_int32(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(uint32_t *) member = parse_uint32(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(int32_t *) member = unzigzag32(parse_uint32(len, data));\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_32BIT)\n\t\t\treturn FALSE;\n\t\t*(uint32_t *) member = parse_fixed_uint32(data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(uint64_t *) member = parse_uint64(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(int64_t *) member = unzigzag64(parse_uint64(len, data));\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_64BIT)\n\t\t\treturn FALSE;\n\t\t*(uint64_t *) member = parse_fixed_uint64(data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t*(protobuf_c_boolean *) member = parse_boolean(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tchar **pstr = member;\n\t\tunsigned pref_len = scanned_member->length_prefix_len;\n\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)\n\t\t\treturn FALSE;\n\n\t\tif (maybe_clear && *pstr != NULL) {\n\t\t\tconst char *def = scanned_member->field->default_value;\n\t\t\tif (*pstr != NULL && *pstr != def)\n\t\t\t\tdo_free(allocator, *pstr);\n\t\t}\n\t\t*pstr = do_alloc(allocator, len - pref_len + 1);\n\t\tif (*pstr == NULL)\n\t\t\treturn FALSE;\n\t\tmemcpy(*pstr, data + pref_len, len - pref_len);\n\t\t(*pstr)[len - pref_len] = 0;\n\t\treturn TRUE;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tProtobufCBinaryData *bd = member;\n\t\tconst ProtobufCBinaryData *def_bd;\n\t\tunsigned pref_len = scanned_member->length_prefix_len;\n\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)\n\t\t\treturn FALSE;\n\n\t\tdef_bd = scanned_member->field->default_value;\n\t\tif (maybe_clear &&\n\t\t    bd->data != NULL &&\n\t\t    (def_bd == NULL || bd->data != def_bd->data))\n\t\t{\n\t\t\tdo_free(allocator, bd->data);\n\t\t}\n\t\tif (len > pref_len) {\n\t\t\tbd->data = do_alloc(allocator, len - pref_len);\n\t\t\tif (bd->data == NULL)\n\t\t\t\treturn FALSE;\n\t\t\tmemcpy(bd->data, data + pref_len, len - pref_len);\n\t\t} else {\n\t\t\tbd->data = NULL;\n\t\t}\n\t\tbd->len = len - pref_len;\n\t\treturn TRUE;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tProtobufCMessage **pmessage = member;\n\t\tProtobufCMessage *subm;\n\t\tconst ProtobufCMessage *def_mess;\n\t\tprotobuf_c_boolean merge_successful = TRUE;\n\t\tunsigned pref_len = scanned_member->length_prefix_len;\n\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)\n\t\t\treturn FALSE;\n\n\t\tdef_mess = scanned_member->field->default_value;\n\t\tsubm = protobuf_c_message_unpack(scanned_member->field->descriptor,\n\t\t\t\t\t\t allocator,\n\t\t\t\t\t\t len - pref_len,\n\t\t\t\t\t\t data + pref_len);\n\n\t\tif (maybe_clear &&\n\t\t    *pmessage != NULL &&\n\t\t    *pmessage != def_mess)\n\t\t{\n\t\t\tif (subm != NULL)\n\t\t\t\tmerge_successful = merge_messages(*pmessage, subm, allocator);\n\t\t\t/* Delete the previous message */\n\t\t\tprotobuf_c_message_free_unpacked(*pmessage, allocator);\n\t\t}\n\t\t*pmessage = subm;\n\t\tif (subm == NULL || !merge_successful)\n\t\t\treturn FALSE;\n\t\treturn TRUE;\n\t}\n\t}\n\treturn FALSE;\n}\n\nstatic protobuf_c_boolean\nparse_oneof_member (ScannedMember *scanned_member,\n\t\t    void *member,\n\t\t    ProtobufCMessage *message,\n\t\t    ProtobufCAllocator *allocator)\n{\n\tuint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, message,\n\t\t\t\t\t       scanned_member->field->quantifier_offset);\n\n\t/* If we have already parsed a member of this oneof, free it. */\n\tif (*oneof_case != 0) {\n\t\tconst ProtobufCFieldDescriptor *old_field;\n\t\tsize_t el_size;\n\t\t/* lookup field */\n\t\tint field_index =\n\t\t\tint_range_lookup(message->descriptor->n_field_ranges,\n\t\t\t\t\t message->descriptor->field_ranges,\n\t\t\t\t\t *oneof_case);\n\t\tif (field_index < 0)\n\t\t\treturn FALSE;\n\t\told_field = message->descriptor->fields + field_index;\n\t\tel_size = sizeof_elt_in_repeated_array(old_field->type);\n\n\t\tswitch (old_field->type) {\n\t        case PROTOBUF_C_TYPE_STRING: {\n\t\t\tchar **pstr = member;\n\t\t\tconst char *def = old_field->default_value;\n\t\t\tif (*pstr != NULL && *pstr != def)\n\t\t\t\tdo_free(allocator, *pstr);\n\t\t\tbreak;\n\t        }\n\t\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\t\tProtobufCBinaryData *bd = member;\n\t\t\tconst ProtobufCBinaryData *def_bd = old_field->default_value;\n\t\t\tif (bd->data != NULL &&\n\t\t\t   (def_bd == NULL || bd->data != def_bd->data))\n\t\t\t{\n\t\t\t\tdo_free(allocator, bd->data);\n\t\t\t}\n\t\t\tbreak;\n\t        }\n\t\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\t\tProtobufCMessage **pmessage = member;\n\t\t\tconst ProtobufCMessage *def_mess = old_field->default_value;\n\t\t\tif (*pmessage != NULL && *pmessage != def_mess)\n\t\t\t\tprotobuf_c_message_free_unpacked(*pmessage, allocator);\n\t\t\tbreak;\n\t        }\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset (member, 0, el_size);\n\t}\n\tif (!parse_required_member (scanned_member, member, allocator, TRUE))\n\t\treturn FALSE;\n\n\t*oneof_case = scanned_member->tag;\n\treturn TRUE;\n}\n\n\nstatic protobuf_c_boolean\nparse_optional_member(ScannedMember *scanned_member,\n\t\t      void *member,\n\t\t      ProtobufCMessage *message,\n\t\t      ProtobufCAllocator *allocator)\n{\n\tif (!parse_required_member(scanned_member, member, allocator, TRUE))\n\t\treturn FALSE;\n\tif (scanned_member->field->quantifier_offset != 0)\n\t\tSTRUCT_MEMBER(protobuf_c_boolean,\n\t\t\t      message,\n\t\t\t      scanned_member->field->quantifier_offset) = TRUE;\n\treturn TRUE;\n}\n\nstatic protobuf_c_boolean\nparse_repeated_member(ScannedMember *scanned_member,\n\t\t      void *member,\n\t\t      ProtobufCMessage *message,\n\t\t      ProtobufCAllocator *allocator)\n{\n\tconst ProtobufCFieldDescriptor *field = scanned_member->field;\n\tsize_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);\n\tsize_t siz = sizeof_elt_in_repeated_array(field->type);\n\tchar *array = *(char **) member;\n\n\tif (!parse_required_member(scanned_member, array + siz * (*p_n),\n\t\t\t\t   allocator, FALSE))\n\t{\n\t\treturn FALSE;\n\t}\n\t*p_n += 1;\n\treturn TRUE;\n}\n\nstatic unsigned\nscan_varint(unsigned len, const uint8_t *data)\n{\n\tunsigned i;\n\tif (len > 10)\n\t\tlen = 10;\n\tfor (i = 0; i < len; i++)\n\t\tif ((data[i] & 0x80) == 0)\n\t\t\tbreak;\n\tif (i == len)\n\t\treturn 0;\n\treturn i + 1;\n}\n\nstatic protobuf_c_boolean\nparse_packed_repeated_member(ScannedMember *scanned_member,\n\t\t\t     void *member,\n\t\t\t     ProtobufCMessage *message)\n{\n\tconst ProtobufCFieldDescriptor *field = scanned_member->field;\n\tsize_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);\n\tsize_t siz = sizeof_elt_in_repeated_array(field->type);\n\tvoid *array = *(char **) member + siz * (*p_n);\n\tconst uint8_t *at = scanned_member->data + scanned_member->length_prefix_len;\n\tsize_t rem = scanned_member->len - scanned_member->length_prefix_len;\n\tsize_t count = 0;\n#if defined(WORDS_BIGENDIAN)\n\tunsigned i;\n#endif\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tcount = (scanned_member->len - scanned_member->length_prefix_len) / 4;\n#if !defined(WORDS_BIGENDIAN)\n\t\tgoto no_unpacking_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t((uint32_t *) array)[i] = parse_fixed_uint32(at);\n\t\t\tat += 4;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tcount = (scanned_member->len - scanned_member->length_prefix_len) / 8;\n#if !defined(WORDS_BIGENDIAN)\n\t\tgoto no_unpacking_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t((uint64_t *) array)[i] = parse_fixed_uint64(at);\n\t\t\tat += 8;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated int32 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int32_t *) array)[count++] = parse_int32(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated sint32 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int32_t *) array)[count++] = unzigzag32(parse_uint32(s, at));\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated enum or uint32 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((uint32_t *) array)[count++] = parse_uint32(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated sint64 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int64_t *) array)[count++] = unzigzag64(parse_uint64(s, at));\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated int64/uint64 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int64_t *) array)[count++] = parse_uint64(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated boolean value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((protobuf_c_boolean *) array)[count++] = parse_boolean(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\t*p_n += count;\n\treturn TRUE;\n\n#if !defined(WORDS_BIGENDIAN)\nno_unpacking_needed:\n\tmemcpy(array, at, count * siz);\n\t*p_n += count;\n\treturn TRUE;\n#endif\n}\n\nstatic protobuf_c_boolean\nis_packable_type(ProtobufCType type)\n{\n\treturn\n\t\ttype != PROTOBUF_C_TYPE_STRING &&\n\t\ttype != PROTOBUF_C_TYPE_BYTES &&\n\t\ttype != PROTOBUF_C_TYPE_MESSAGE;\n}\n\nstatic protobuf_c_boolean\nparse_member(ScannedMember *scanned_member,\n\t     ProtobufCMessage *message,\n\t     ProtobufCAllocator *allocator)\n{\n\tconst ProtobufCFieldDescriptor *field = scanned_member->field;\n\tvoid *member;\n\n\tif (field == NULL) {\n\t\tProtobufCMessageUnknownField *ufield =\n\t\t\tmessage->unknown_fields +\n\t\t\t(message->n_unknown_fields++);\n\t\tufield->tag = scanned_member->tag;\n\t\tufield->wire_type = scanned_member->wire_type;\n\t\tufield->len = scanned_member->len;\n\t\tufield->data = do_alloc(allocator, scanned_member->len);\n\t\tif (ufield->data == NULL)\n\t\t\treturn FALSE;\n\t\tmemcpy(ufield->data, scanned_member->data, ufield->len);\n\t\treturn TRUE;\n\t}\n\tmember = (char *) message + field->offset;\n\tswitch (field->label) {\n\tcase PROTOBUF_C_LABEL_REQUIRED:\n\t\treturn parse_required_member(scanned_member, member,\n\t\t\t\t\t     allocator, TRUE);\n\tcase PROTOBUF_C_LABEL_OPTIONAL:\n\tcase PROTOBUF_C_LABEL_NONE:\n\t\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {\n\t\t\treturn parse_oneof_member(scanned_member, member,\n\t\t\t\t\t\t  message, allocator);\n\t\t} else {\n\t\t\treturn parse_optional_member(scanned_member, member,\n\t\t\t\t\t\t     message, allocator);\n\t\t}\n\tcase PROTOBUF_C_LABEL_REPEATED:\n\t\tif (scanned_member->wire_type ==\n\t\t    PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&\n\t\t    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||\n\t\t     is_packable_type(field->type)))\n\t\t{\n\t\t\treturn parse_packed_repeated_member(scanned_member,\n\t\t\t\t\t\t\t    member, message);\n\t\t} else {\n\t\t\treturn parse_repeated_member(scanned_member,\n\t\t\t\t\t\t     member, message,\n\t\t\t\t\t\t     allocator);\n\t\t}\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Initialise messages generated by old code.\n *\n * This function is used if desc->message_init == NULL (which occurs\n * for old code, and which would be useful to support allocating\n * descriptors dynamically).\n */\nstatic void\nmessage_init_generic(const ProtobufCMessageDescriptor *desc,\n\t\t     ProtobufCMessage *message)\n{\n\tunsigned i;\n\n\tmemset(message, 0, desc->sizeof_message);\n\tmessage->descriptor = desc;\n\tfor (i = 0; i < desc->n_fields; i++) {\n\t\tif (desc->fields[i].default_value != NULL &&\n\t\t    desc->fields[i].label != PROTOBUF_C_LABEL_REPEATED)\n\t\t{\n\t\t\tvoid *field =\n\t\t\t\tSTRUCT_MEMBER_P(message, desc->fields[i].offset);\n\t\t\tconst void *dv = desc->fields[i].default_value;\n\n\t\t\tswitch (desc->fields[i].type) {\n\t\t\tcase PROTOBUF_C_TYPE_INT32:\n\t\t\tcase PROTOBUF_C_TYPE_SINT32:\n\t\t\tcase PROTOBUF_C_TYPE_SFIXED32:\n\t\t\tcase PROTOBUF_C_TYPE_UINT32:\n\t\t\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\t\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\t\tcase PROTOBUF_C_TYPE_ENUM:\n\t\t\t\tmemcpy(field, dv, 4);\n\t\t\t\tbreak;\n\t\t\tcase PROTOBUF_C_TYPE_INT64:\n\t\t\tcase PROTOBUF_C_TYPE_SINT64:\n\t\t\tcase PROTOBUF_C_TYPE_SFIXED64:\n\t\t\tcase PROTOBUF_C_TYPE_UINT64:\n\t\t\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\t\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\t\t\tmemcpy(field, dv, 8);\n\t\t\t\tbreak;\n\t\t\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t\t\tmemcpy(field, dv, sizeof(protobuf_c_boolean));\n\t\t\t\tbreak;\n\t\t\tcase PROTOBUF_C_TYPE_BYTES:\n\t\t\t\tmemcpy(field, dv, sizeof(ProtobufCBinaryData));\n\t\t\t\tbreak;\n\n\t\t\tcase PROTOBUF_C_TYPE_STRING:\n\t\t\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\t\t\t/*\n\t\t\t\t * The next line essentially implements a cast\n\t\t\t\t * from const, which is totally unavoidable.\n\t\t\t\t */\n\t\t\t\t*(const void **) field = dv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**@}*/\n\n/*\n * ScannedMember slabs (an unpacking implementation detail). Before doing real\n * unpacking, we first scan through the elements to see how many there are (for\n * repeated fields), and which field to use (for non-repeated fields given\n * twice).\n *\n * In order to avoid allocations for small messages, we keep a stack-allocated\n * slab of ScannedMembers of size FIRST_SCANNED_MEMBER_SLAB_SIZE (16). After we\n * fill that up, we allocate each slab twice as large as the previous one.\n */\n#define FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2 4\n\n/*\n * The number of slabs, including the stack-allocated ones; choose the number so\n * that we would overflow if we needed a slab larger than provided.\n */\n#define MAX_SCANNED_MEMBER_SLAB\t\t\t\\\n  (sizeof(unsigned int)*8 - 1\t\t\t\\\n   - BOUND_SIZEOF_SCANNED_MEMBER_LOG2\t\t\\\n   - FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2)\n\n#define REQUIRED_FIELD_BITMAP_SET(index)\t\\\n\t(required_fields_bitmap[(index)/8] |= (1UL<<((index)%8)))\n\n#define REQUIRED_FIELD_BITMAP_IS_SET(index)\t\\\n\t(required_fields_bitmap[(index)/8] & (1UL<<((index)%8)))\n\nProtobufCMessage *\nprotobuf_c_message_unpack(const ProtobufCMessageDescriptor *desc,\n\t\t\t  ProtobufCAllocator *allocator,\n\t\t\t  size_t len, const uint8_t *data)\n{\n\tProtobufCMessage *rv;\n\tsize_t rem = len;\n\tconst uint8_t *at = data;\n\tconst ProtobufCFieldDescriptor *last_field = desc->fields + 0;\n\tScannedMember first_member_slab[1UL <<\n\t\t\t\t\tFIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2];\n\n\t/*\n\t * scanned_member_slabs[i] is an array of arrays of ScannedMember.\n\t * The first slab (scanned_member_slabs[0] is just a pointer to\n\t * first_member_slab), above. All subsequent slabs will be allocated\n\t * using the allocator.\n\t */\n\tScannedMember *scanned_member_slabs[MAX_SCANNED_MEMBER_SLAB + 1];\n\tunsigned which_slab = 0; /* the slab we are currently populating */\n\tunsigned in_slab_index = 0; /* number of members in the slab */\n\tsize_t n_unknown = 0;\n\tunsigned f;\n\tunsigned j;\n\tunsigned i_slab;\n\tunsigned last_field_index = 0;\n\tunsigned required_fields_bitmap_len;\n\tunsigned char required_fields_bitmap_stack[16];\n\tunsigned char *required_fields_bitmap = required_fields_bitmap_stack;\n\tprotobuf_c_boolean required_fields_bitmap_alloced = FALSE;\n\n\tASSERT_IS_MESSAGE_DESCRIPTOR(desc);\n\n\tif (allocator == NULL)\n\t\tallocator = &protobuf_c__allocator;\n\n\trv = do_alloc(allocator, desc->sizeof_message);\n\tif (!rv)\n\t\treturn (NULL);\n\tscanned_member_slabs[0] = first_member_slab;\n\n\trequired_fields_bitmap_len = (desc->n_fields + 7) / 8;\n\tif (required_fields_bitmap_len > sizeof(required_fields_bitmap_stack)) {\n\t\trequired_fields_bitmap = do_alloc(allocator, required_fields_bitmap_len);\n\t\tif (!required_fields_bitmap) {\n\t\t\tdo_free(allocator, rv);\n\t\t\treturn (NULL);\n\t\t}\n\t\trequired_fields_bitmap_alloced = TRUE;\n\t}\n\tmemset(required_fields_bitmap, 0, required_fields_bitmap_len);\n\n\t/*\n\t * Generated code always defines \"message_init\". However, we provide a\n\t * fallback for (1) users of old protobuf-c generated-code that do not\n\t * provide the function, and (2) descriptors constructed from some other\n\t * source (most likely, direct construction from the .proto file).\n\t */\n\tif (desc->message_init != NULL)\n\t\tprotobuf_c_message_init(desc, rv);\n\telse\n\t\tmessage_init_generic(desc, rv);\n\n\twhile (rem > 0) {\n\t\tuint32_t tag;\n\t\tuint8_t wire_type;\n\t\tsize_t used = parse_tag_and_wiretype(rem, at, &tag, &wire_type);\n\t\tconst ProtobufCFieldDescriptor *field;\n\t\tScannedMember tmp;\n\n\t\tif (used == 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing tag/wiretype at offset %u\",\n\t\t\t\t\t\t(unsigned) (at - data));\n\t\t\tgoto error_cleanup_during_scan;\n\t\t}\n\t\t/*\n\t\t * \\todo Consider optimizing for field[1].id == tag, if field[1]\n\t\t * exists!\n\t\t */\n\t\tif (last_field == NULL || last_field->id != tag) {\n\t\t\t/* lookup field */\n\t\t\tint field_index =\n\t\t\t    int_range_lookup(desc->n_field_ranges,\n\t\t\t\t\t     desc->field_ranges,\n\t\t\t\t\t     tag);\n\t\t\tif (field_index < 0) {\n\t\t\t\tfield = NULL;\n\t\t\t\tn_unknown++;\n\t\t\t} else {\n\t\t\t\tfield = desc->fields + field_index;\n\t\t\t\tlast_field = field;\n\t\t\t\tlast_field_index = field_index;\n\t\t\t}\n\t\t} else {\n\t\t\tfield = last_field;\n\t\t}\n\n\t\tif (field != NULL && field->label == PROTOBUF_C_LABEL_REQUIRED)\n\t\t\tREQUIRED_FIELD_BITMAP_SET(last_field_index);\n\n\t\tat += used;\n\t\trem -= used;\n\t\ttmp.tag = tag;\n\t\ttmp.wire_type = wire_type;\n\t\ttmp.field = field;\n\t\ttmp.data = at;\n\t\ttmp.length_prefix_len = 0;\n\n\t\tswitch (wire_type) {\n\t\tcase PROTOBUF_C_WIRE_TYPE_VARINT: {\n\t\t\tunsigned max_len = rem < 10 ? rem : 10;\n\t\t\tunsigned i;\n\n\t\t\tfor (i = 0; i < max_len; i++)\n\t\t\t\tif ((at[i] & 0x80) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (i == max_len) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"unterminated varint at offset %u\",\n\t\t\t\t\t\t\t(unsigned) (at - data));\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.len = i + 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_WIRE_TYPE_64BIT:\n\t\t\tif (rem < 8) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"too short after 64bit wiretype at offset %u\",\n\t\t\t\t\t\t\t(unsigned) (at - data));\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.len = 8;\n\t\t\tbreak;\n\t\tcase PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED: {\n\t\t\tsize_t pref_len;\n\n\t\t\ttmp.len = scan_length_prefixed_data(rem, at, &pref_len);\n\t\t\tif (tmp.len == 0) {\n\t\t\t\t/* NOTE: scan_length_prefixed_data calls UNPACK_ERROR */\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.length_prefix_len = pref_len;\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_WIRE_TYPE_32BIT:\n\t\t\tif (rem < 4) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"too short after 32bit wiretype at offset %u\",\n\t\t\t\t\t      (unsigned) (at - data));\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.len = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"unsupported tag %u at offset %u\",\n\t\t\t\t\t\twire_type, (unsigned) (at - data));\n\t\t\tgoto error_cleanup_during_scan;\n\t\t}\n\n\t\tif (in_slab_index == (1UL <<\n\t\t\t(which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2)))\n\t\t{\n\t\t\tsize_t size;\n\n\t\t\tin_slab_index = 0;\n\t\t\tif (which_slab == MAX_SCANNED_MEMBER_SLAB) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"too many fields\");\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\twhich_slab++;\n\t\t\tsize = sizeof(ScannedMember)\n\t\t\t\t<< (which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2);\n\t\t\tscanned_member_slabs[which_slab] = do_alloc(allocator, size);\n\t\t\tif (scanned_member_slabs[which_slab] == NULL)\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t}\n\t\tscanned_member_slabs[which_slab][in_slab_index++] = tmp;\n\n\t\tif (field != NULL && field->label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *n = STRUCT_MEMBER_PTR(size_t, rv,\n\t\t\t\t\t\t      field->quantifier_offset);\n\t\t\tif (wire_type == PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&\n\t\t\t    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||\n\t\t\t     is_packable_type(field->type)))\n\t\t\t{\n\t\t\t\tsize_t count;\n\t\t\t\tif (!count_packed_elements(field->type,\n\t\t\t\t\t\t\t   tmp.len -\n\t\t\t\t\t\t\t   tmp.length_prefix_len,\n\t\t\t\t\t\t\t   tmp.data +\n\t\t\t\t\t\t\t   tmp.length_prefix_len,\n\t\t\t\t\t\t\t   &count))\n\t\t\t\t{\n\t\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"counting packed elements\");\n\t\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t\t}\n\t\t\t\t*n += count;\n\t\t\t} else {\n\t\t\t\t*n += 1;\n\t\t\t}\n\t\t}\n\n\t\tat += tmp.len;\n\t\trem -= tmp.len;\n\t}\n\n\t/* allocate space for repeated fields, also check that all required fields have been set */\n\tfor (f = 0; f < desc->n_fields; f++) {\n\t\tconst ProtobufCFieldDescriptor *field = desc->fields + f;\n\t\tif (field->label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t siz =\n\t\t\t    sizeof_elt_in_repeated_array(field->type);\n\t\t\tsize_t *n_ptr =\n\t\t\t    STRUCT_MEMBER_PTR(size_t, rv,\n\t\t\t\t\t      field->quantifier_offset);\n\t\t\tif (*n_ptr != 0) {\n\t\t\t\tunsigned n = *n_ptr;\n\t\t\t\tvoid *a;\n\t\t\t\t*n_ptr = 0;\n\t\t\t\tassert(rv->descriptor != NULL);\n#define CLEAR_REMAINING_N_PTRS()                                              \\\n              for(f++;f < desc->n_fields; f++)                                \\\n                {                                                             \\\n                  field = desc->fields + f;                                   \\\n                  if (field->label == PROTOBUF_C_LABEL_REPEATED)              \\\n                    STRUCT_MEMBER (size_t, rv, field->quantifier_offset) = 0; \\\n                }\n\t\t\t\ta = do_alloc(allocator, siz * n);\n\t\t\t\tif (!a) {\n\t\t\t\t\tCLEAR_REMAINING_N_PTRS();\n\t\t\t\t\tgoto error_cleanup;\n\t\t\t\t}\n\t\t\t\tSTRUCT_MEMBER(void *, rv, field->offset) = a;\n\t\t\t}\n\t\t} else if (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\tif (field->default_value == NULL &&\n\t\t\t    !REQUIRED_FIELD_BITMAP_IS_SET(f))\n\t\t\t{\n\t\t\t\tCLEAR_REMAINING_N_PTRS();\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"message '%s': missing required field '%s'\",\n\t\t\t\t\t\t\tdesc->name, field->name);\n\t\t\t\tgoto error_cleanup;\n\t\t\t}\n\t\t}\n\t}\n#undef CLEAR_REMAINING_N_PTRS\n\n\t/* allocate space for unknown fields */\n\tif (n_unknown) {\n\t\trv->unknown_fields = do_alloc(allocator,\n\t\t\t\t\t      n_unknown * sizeof(ProtobufCMessageUnknownField));\n\t\tif (rv->unknown_fields == NULL)\n\t\t\tgoto error_cleanup;\n\t}\n\n\t/* do real parsing */\n\tfor (i_slab = 0; i_slab <= which_slab; i_slab++) {\n\t\tunsigned max = (i_slab == which_slab) ?\n\t\t\tin_slab_index : (1UL << (i_slab + 4));\n\t\tScannedMember *slab = scanned_member_slabs[i_slab];\n\n\t\tfor (j = 0; j < max; j++) {\n\t\t\tif (!parse_member(slab + j, rv, allocator)) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing member %s of %s\",\n\t\t\t\t\t\t\tslab->field ? slab->field->name : \"*unknown-field*\",\n\t\t\t\t\tdesc->name);\n\t\t\t\tgoto error_cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* cleanup */\n\tfor (j = 1; j <= which_slab; j++)\n\t\tdo_free(allocator, scanned_member_slabs[j]);\n\tif (required_fields_bitmap_alloced)\n\t\tdo_free(allocator, required_fields_bitmap);\n\treturn rv;\n\nerror_cleanup:\n\tprotobuf_c_message_free_unpacked(rv, allocator);\n\tfor (j = 1; j <= which_slab; j++)\n\t\tdo_free(allocator, scanned_member_slabs[j]);\n\tif (required_fields_bitmap_alloced)\n\t\tdo_free(allocator, required_fields_bitmap);\n\treturn NULL;\n\nerror_cleanup_during_scan:\n\tdo_free(allocator, rv);\n\tfor (j = 1; j <= which_slab; j++)\n\t\tdo_free(allocator, scanned_member_slabs[j]);\n\tif (required_fields_bitmap_alloced)\n\t\tdo_free(allocator, required_fields_bitmap);\n\treturn NULL;\n}\n\nvoid\nprotobuf_c_message_free_unpacked(ProtobufCMessage *message,\n\t\t\t\t ProtobufCAllocator *allocator)\n{\n\tconst ProtobufCMessageDescriptor *desc;\n\tunsigned f;\n\n\tif (message == NULL)\n\t\treturn;\n\n\tdesc = message->descriptor;\n\n\tASSERT_IS_MESSAGE(message);\n\n\tif (allocator == NULL)\n\t\tallocator = &protobuf_c__allocator;\n\tmessage->descriptor = NULL;\n\tfor (f = 0; f < desc->n_fields; f++) {\n\t\tif (0 != (desc->fields[f].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) &&\n\t\t    desc->fields[f].id !=\n\t\t    STRUCT_MEMBER(uint32_t, message, desc->fields[f].quantifier_offset))\n\t\t{\n\t\t\t/* This is not the selected oneof, skip it */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (desc->fields[f].label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t n = STRUCT_MEMBER(size_t,\n\t\t\t\t\t\t message,\n\t\t\t\t\t\t desc->fields[f].quantifier_offset);\n\t\t\tvoid *arr = STRUCT_MEMBER(void *,\n\t\t\t\t\t\t  message,\n\t\t\t\t\t\t  desc->fields[f].offset);\n\n\t\t\tif (arr != NULL) {\n\t\t\t\tif (desc->fields[f].type == PROTOBUF_C_TYPE_STRING) {\n\t\t\t\t\tunsigned i;\n\t\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t\tdo_free(allocator, ((char **) arr)[i]);\n\t\t\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\t\t\tunsigned i;\n\t\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t\tdo_free(allocator, ((ProtobufCBinaryData *) arr)[i].data);\n\t\t\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\t\t\tunsigned i;\n\t\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t\tprotobuf_c_message_free_unpacked(\n\t\t\t\t\t\t\t((ProtobufCMessage **) arr)[i],\n\t\t\t\t\t\t\tallocator\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdo_free(allocator, arr);\n\t\t\t}\n\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_STRING) {\n\t\t\tchar *str = STRUCT_MEMBER(char *, message,\n\t\t\t\t\t\t  desc->fields[f].offset);\n\n\t\t\tif (str && str != desc->fields[f].default_value)\n\t\t\t\tdo_free(allocator, str);\n\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\tvoid *data = STRUCT_MEMBER(ProtobufCBinaryData, message,\n\t\t\t\t\t\t   desc->fields[f].offset).data;\n\t\t\tconst ProtobufCBinaryData *default_bd;\n\n\t\t\tdefault_bd = desc->fields[f].default_value;\n\t\t\tif (data != NULL &&\n\t\t\t    (default_bd == NULL ||\n\t\t\t     default_bd->data != data))\n\t\t\t{\n\t\t\t\tdo_free(allocator, data);\n\t\t\t}\n\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\tProtobufCMessage *sm;\n\n\t\t\tsm = STRUCT_MEMBER(ProtobufCMessage *, message,\n\t\t\t\t\t   desc->fields[f].offset);\n\t\t\tif (sm && sm != desc->fields[f].default_value)\n\t\t\t\tprotobuf_c_message_free_unpacked(sm, allocator);\n\t\t}\n\t}\n\n\tfor (f = 0; f < message->n_unknown_fields; f++)\n\t\tdo_free(allocator, message->unknown_fields[f].data);\n\tif (message->unknown_fields != NULL)\n\t\tdo_free(allocator, message->unknown_fields);\n\n\tdo_free(allocator, message);\n}\n\nvoid\nprotobuf_c_message_init(const ProtobufCMessageDescriptor * descriptor,\n\t\t\tvoid *message)\n{\n\tdescriptor->message_init((ProtobufCMessage *) (message));\n}\n\nprotobuf_c_boolean\nprotobuf_c_message_check(const ProtobufCMessage *message)\n{\n\tunsigned i;\n\n\tif (!message ||\n\t    !message->descriptor ||\n\t    message->descriptor->magic != PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *f = message->descriptor->fields + i;\n\t\tProtobufCType type = f->type;\n\t\tProtobufCLabel label = f->label;\n\t\tvoid *field = STRUCT_MEMBER_P (message, f->offset);\n\n\t\tif (f->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {\n\t\t\tconst uint32_t *oneof_case = STRUCT_MEMBER_P (message, f->quantifier_offset);\n\t\t\tif (f->id != *oneof_case) {\n\t\t\t\tcontinue; //Do not check if it is an unpopulated oneof member.\n\t\t\t}\n\t\t}\n\n\t\tif (label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *quantity = STRUCT_MEMBER_P (message, f->quantifier_offset);\n\n\t\t\tif (*quantity > 0 && *(void **) field == NULL) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\t\tProtobufCMessage **submessage = *(ProtobufCMessage ***) field;\n\t\t\t\tunsigned j;\n\t\t\t\tfor (j = 0; j < *quantity; j++) {\n\t\t\t\t\tif (!protobuf_c_message_check(submessage[j]))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t} else if (type == PROTOBUF_C_TYPE_STRING) {\n\t\t\t\tchar **string = *(char ***) field;\n\t\t\t\tunsigned j;\n\t\t\t\tfor (j = 0; j < *quantity; j++) {\n\t\t\t\t\tif (!string[j])\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t} else if (type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\t\tProtobufCBinaryData *bd = *(ProtobufCBinaryData **) field;\n\t\t\t\tunsigned j;\n\t\t\t\tfor (j = 0; j < *quantity; j++) {\n\t\t\t\t\tif (bd[j].len > 0 && bd[j].data == NULL)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else { /* PROTOBUF_C_LABEL_REQUIRED or PROTOBUF_C_LABEL_OPTIONAL */\n\n\t\t\tif (type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\t\tProtobufCMessage *submessage = *(ProtobufCMessage **) field;\n\t\t\t\tif (label == PROTOBUF_C_LABEL_REQUIRED || submessage != NULL) {\n\t\t\t\t\tif (!protobuf_c_message_check(submessage))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t} else if (type == PROTOBUF_C_TYPE_STRING) {\n\t\t\t\tchar *string = *(char **) field;\n\t\t\t\tif (label == PROTOBUF_C_LABEL_REQUIRED && string == NULL)\n\t\t\t\t\treturn FALSE;\n\t\t\t} else if (type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\t\tprotobuf_c_boolean *has = STRUCT_MEMBER_P (message, f->quantifier_offset);\n\t\t\t\tProtobufCBinaryData *bd = field;\n\t\t\t\tif (label == PROTOBUF_C_LABEL_REQUIRED || *has == TRUE) {\n\t\t\t\t\tif (bd->len > 0 && bd->data == NULL)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/* === services === */\n\ntypedef void (*GenericHandler) (void *service,\n\t\t\t\tconst ProtobufCMessage *input,\n\t\t\t\tProtobufCClosure closure,\n\t\t\t\tvoid *closure_data);\nvoid\nprotobuf_c_service_invoke_internal(ProtobufCService *service,\n\t\t\t\t   unsigned method_index,\n\t\t\t\t   const ProtobufCMessage *input,\n\t\t\t\t   ProtobufCClosure closure,\n\t\t\t\t   void *closure_data)\n{\n\tGenericHandler *handlers;\n\tGenericHandler handler;\n\n\t/*\n\t * Verify that method_index is within range. If this fails, you are\n\t * likely invoking a newly added method on an old service. (Although\n\t * other memory corruption bugs can cause this assertion too.)\n\t */\n\tassert(method_index < service->descriptor->n_methods);\n\n\t/*\n\t * Get the array of virtual methods (which are enumerated by the\n\t * generated code).\n\t */\n\thandlers = (GenericHandler *) (service + 1);\n\n\t/*\n\t * Get our method and invoke it.\n\t * \\todo Seems like handler == NULL is a situation that needs handling.\n\t */\n\thandler = handlers[method_index];\n\t(*handler)(service, input, closure, closure_data);\n}\n\nvoid\nprotobuf_c_service_generated_init(ProtobufCService *service,\n\t\t\t\t  const ProtobufCServiceDescriptor *descriptor,\n\t\t\t\t  ProtobufCServiceDestroy destroy)\n{\n\tASSERT_IS_SERVICE_DESCRIPTOR(descriptor);\n\tservice->descriptor = descriptor;\n\tservice->destroy = destroy;\n\tservice->invoke = protobuf_c_service_invoke_internal;\n\tmemset(service + 1, 0, descriptor->n_methods * sizeof(GenericHandler));\n}\n\nvoid protobuf_c_service_destroy(ProtobufCService *service)\n{\n\tservice->destroy(service);\n}\n\n/* --- querying the descriptors --- */\n\nconst ProtobufCEnumValue *\nprotobuf_c_enum_descriptor_get_value_by_name(const ProtobufCEnumDescriptor *desc,\n\t\t\t\t\t     const char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\n\tif (desc == NULL || desc->values_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_value_names;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv = strcmp(desc->values_by_name[mid].name, name);\n\t\tif (rv == 0)\n\t\t\treturn desc->values + desc->values_by_name[mid].index;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tif (strcmp(desc->values_by_name[start].name, name) == 0)\n\t\treturn desc->values + desc->values_by_name[start].index;\n\treturn NULL;\n}\n\nconst ProtobufCEnumValue *\nprotobuf_c_enum_descriptor_get_value(const ProtobufCEnumDescriptor *desc,\n\t\t\t\t     int value)\n{\n\tint rv = int_range_lookup(desc->n_value_ranges, desc->value_ranges, value);\n\tif (rv < 0)\n\t\treturn NULL;\n\treturn desc->values + rv;\n}\n\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\tconst ProtobufCFieldDescriptor *field;\n\n\tif (desc == NULL || desc->fields_sorted_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_fields;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv;\n\t\tfield = desc->fields + desc->fields_sorted_by_name[mid];\n\t\trv = strcmp(field->name, name);\n\t\tif (rv == 0)\n\t\t\treturn field;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tfield = desc->fields + desc->fields_sorted_by_name[start];\n\tif (strcmp(field->name, name) == 0)\n\t\treturn field;\n\treturn NULL;\n}\n\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\tunsigned value)\n{\n\tint rv = int_range_lookup(desc->n_field_ranges,desc->field_ranges, value);\n\tif (rv < 0)\n\t\treturn NULL;\n\treturn desc->fields + rv;\n}\n\nconst ProtobufCMethodDescriptor *\nprotobuf_c_service_descriptor_get_method_by_name(const ProtobufCServiceDescriptor *desc,\n\t\t\t\t\t\t const char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\n\tif (desc == NULL || desc->method_indices_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_methods;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tunsigned mid_index = desc->method_indices_by_name[mid];\n\t\tconst char *mid_name = desc->methods[mid_index].name;\n\t\tint rv = strcmp(mid_name, name);\n\n\t\tif (rv == 0)\n\t\t\treturn desc->methods + desc->method_indices_by_name[mid];\n\t\tif (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else {\n\t\t\tcount = mid - start;\n\t\t}\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tif (strcmp(desc->methods[desc->method_indices_by_name[start]].name, name) == 0)\n\t\treturn desc->methods + desc->method_indices_by_name[start];\n\treturn NULL;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2008-2015, Dave Benson and the protobuf-c authors.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*! \\file\n * Support library for `protoc-c` generated code.\n *\n * This file implements the public API used by the code generated\n * by `protoc-c`.\n *\n * \\authors Dave Benson and the protobuf-c authors\n *\n * \\copyright 2008-2014. Licensed under the terms of the [BSD-2-Clause] license.\n */\n\n/**\n * \\todo 64-BIT OPTIMIZATION: certain implementations use 32-bit math\n * even on 64-bit platforms (uint64_size, uint64_pack, parse_uint64).\n *\n * \\todo Use size_t consistently.\n */\n\n#include <stdlib.h>\t/* for malloc, free */\n#include <string.h>\t/* for strcmp, strlen, memcpy, memmove, memset */\n\n#include \"protobuf-c.h\"\n\n#define TRUE\t\t\t\t1\n#define FALSE\t\t\t\t0\n\n#define PROTOBUF_C__ASSERT_NOT_REACHED() assert(0)\n\n/* Workaround for Microsoft compilers. */\n#ifdef _MSC_VER\n# define inline __inline\n#endif\n\n/**\n * \\defgroup internal Internal functions and macros\n *\n * These are not exported by the library but are useful to developers working\n * on `libprotobuf-c` itself.\n */\n\n/**\n * \\defgroup macros Utility macros for manipulating structures\n *\n * Macros and constants used to manipulate the base \"classes\" generated by\n * `protobuf-c`. They also define limits and check correctness.\n *\n * \\ingroup internal\n * @{\n */\n\n/** The maximum length of a 64-bit integer in varint encoding. */\n#define MAX_UINT64_ENCODED_SIZE\t\t10\n\n#ifndef PROTOBUF_C_UNPACK_ERROR\n# define PROTOBUF_C_UNPACK_ERROR(...)\n#endif\n\n#if !defined(_WIN32) || !defined(PROTOBUF_C_USE_SHARED_LIB)\nconst char protobuf_c_empty_string[] = \"\";\n#endif\n\n/**\n * Internal `ProtobufCMessage` manipulation macro.\n *\n * Base macro for manipulating a `ProtobufCMessage`. Used by STRUCT_MEMBER() and\n * STRUCT_MEMBER_PTR().\n */\n#define STRUCT_MEMBER_P(struct_p, struct_offset) \\\n    ((void *) ((uint8_t *) (struct_p) + (struct_offset)))\n\n/**\n * Return field in a `ProtobufCMessage` based on offset.\n *\n * Take a pointer to a `ProtobufCMessage` and find the field at the offset.\n * Cast it to the passed type.\n */\n#define STRUCT_MEMBER(member_type, struct_p, struct_offset) \\\n    (*(member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))\n\n/**\n * Return field in a `ProtobufCMessage` based on offset.\n *\n * Take a pointer to a `ProtobufCMessage` and find the field at the offset. Cast\n * it to a pointer to the passed type.\n */\n#define STRUCT_MEMBER_PTR(member_type, struct_p, struct_offset) \\\n    ((member_type *) STRUCT_MEMBER_P((struct_p), (struct_offset)))\n\n/* Assertions for magic numbers. */\n\n#define ASSERT_IS_ENUM_DESCRIPTOR(desc) \\\n\tassert((desc)->magic == PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC)\n\n#define ASSERT_IS_MESSAGE_DESCRIPTOR(desc) \\\n\tassert((desc)->magic == PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC)\n\n#define ASSERT_IS_MESSAGE(message) \\\n\tASSERT_IS_MESSAGE_DESCRIPTOR((message)->descriptor)\n\n#define ASSERT_IS_SERVICE_DESCRIPTOR(desc) \\\n\tassert((desc)->magic == PROTOBUF_C__SERVICE_DESCRIPTOR_MAGIC)\n\n/**@}*/\n\n/* --- version --- */\n\nconst char *\nprotobuf_c_version(void)\n{\n\treturn PROTOBUF_C_VERSION;\n}\n\nuint32_t\nprotobuf_c_version_number(void)\n{\n\treturn PROTOBUF_C_VERSION_NUMBER;\n}\n\n/* --- allocator --- */\n\nstatic void *\nsystem_alloc(void *allocator_data, size_t size)\n{\n\t(void)allocator_data;\n\treturn malloc(size);\n}\n\nstatic void\nsystem_free(void *allocator_data, void *data)\n{\n\t(void)allocator_data;\n\tfree(data);\n}\n\nstatic inline void *\ndo_alloc(ProtobufCAllocator *allocator, size_t size)\n{\n\treturn allocator->alloc(allocator->allocator_data, size);\n}\n\nstatic inline void\ndo_free(ProtobufCAllocator *allocator, void *data)\n{\n\tif (data != NULL)\n\t\tallocator->free(allocator->allocator_data, data);\n}\n\n/*\n * This allocator uses the system's malloc() and free(). It is the default\n * allocator used if NULL is passed as the ProtobufCAllocator to an exported\n * function.\n */\nstatic ProtobufCAllocator protobuf_c__allocator = {\n\t.alloc = &system_alloc,\n\t.free = &system_free,\n\t.allocator_data = NULL,\n};\n\n/* === buffer-simple === */\n\nvoid\nprotobuf_c_buffer_simple_append(ProtobufCBuffer *buffer,\n\t\t\t\tsize_t len, const uint8_t *data)\n{\n\tProtobufCBufferSimple *simp = (ProtobufCBufferSimple *) buffer;\n\tsize_t new_len = simp->len + len;\n\n\tif (new_len > simp->alloced) {\n\t\tProtobufCAllocator *allocator = simp->allocator;\n\t\tsize_t new_alloced = simp->alloced * 2;\n\t\tuint8_t *new_data;\n\n\t\tif (allocator == NULL)\n\t\t\tallocator = &protobuf_c__allocator;\n\t\twhile (new_alloced < new_len)\n\t\t\tnew_alloced += new_alloced;\n\t\tnew_data = do_alloc(allocator, new_alloced);\n\t\tif (!new_data)\n\t\t\treturn;\n\t\tmemcpy(new_data, simp->data, simp->len);\n\t\tif (simp->must_free_data)\n\t\t\tdo_free(allocator, simp->data);\n\t\telse\n\t\t\tsimp->must_free_data = TRUE;\n\t\tsimp->data = new_data;\n\t\tsimp->alloced = new_alloced;\n\t}\n\tmemcpy(simp->data + simp->len, data, len);\n\tsimp->len = new_len;\n}\n\n/**\n * \\defgroup packedsz protobuf_c_message_get_packed_size() implementation\n *\n * Routines mainly used by protobuf_c_message_get_packed_size().\n *\n * \\ingroup internal\n * @{\n */\n\n/**\n * Return the number of bytes required to store the tag for the field. Includes\n * 3 bits for the wire-type, and a single bit that denotes the end-of-tag.\n *\n * \\param number\n *      Field tag to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nget_tag_size(uint32_t number)\n{\n\tif (number < (1UL << 4)) {\n\t\treturn 1;\n\t} else if (number < (1UL << 11)) {\n\t\treturn 2;\n\t} else if (number < (1UL << 18)) {\n\t\treturn 3;\n\t} else if (number < (1UL << 25)) {\n\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\n/**\n * Return the number of bytes required to store a variable-length unsigned\n * 32-bit integer in base-128 varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nuint32_size(uint32_t v)\n{\n\tif (v < (1UL << 7)) {\n\t\treturn 1;\n\t} else if (v < (1UL << 14)) {\n\t\treturn 2;\n\t} else if (v < (1UL << 21)) {\n\t\treturn 3;\n\t} else if (v < (1UL << 28)) {\n\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\n/**\n * Return the number of bytes required to store a variable-length signed 32-bit\n * integer in base-128 varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nint32_size(int32_t v)\n{\n\tif (v < 0) {\n\t\treturn 10;\n\t} else if (v < (1L << 7)) {\n\t\treturn 1;\n\t} else if (v < (1L << 14)) {\n\t\treturn 2;\n\t} else if (v < (1L << 21)) {\n\t\treturn 3;\n\t} else if (v < (1L << 28)) {\n\t\treturn 4;\n\t} else {\n\t\treturn 5;\n\t}\n}\n\n/**\n * Return the ZigZag-encoded 32-bit unsigned integer form of a 32-bit signed\n * integer.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      ZigZag encoded integer.\n */\nstatic inline uint32_t\nzigzag32(int32_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn ((uint32_t)v << 1) ^ -((uint32_t)v >> 31);\n}\n\n/**\n * Return the number of bytes required to store a signed 32-bit integer,\n * converted to an unsigned 32-bit integer with ZigZag encoding, using base-128\n * varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nsint32_size(int32_t v)\n{\n\treturn uint32_size(zigzag32(v));\n}\n\n/**\n * Return the number of bytes required to store a 64-bit unsigned integer in\n * base-128 varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nuint64_size(uint64_t v)\n{\n\tuint32_t upper_v = (uint32_t) (v >> 32);\n\n\tif (upper_v == 0) {\n\t\treturn uint32_size((uint32_t) v);\n\t} else if (upper_v < (1UL << 3)) {\n\t\treturn 5;\n\t} else if (upper_v < (1UL << 10)) {\n\t\treturn 6;\n\t} else if (upper_v < (1UL << 17)) {\n\t\treturn 7;\n\t} else if (upper_v < (1UL << 24)) {\n\t\treturn 8;\n\t} else if (upper_v < (1UL << 31)) {\n\t\treturn 9;\n\t} else {\n\t\treturn 10;\n\t}\n}\n\n/**\n * Return the ZigZag-encoded 64-bit unsigned integer form of a 64-bit signed\n * integer.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      ZigZag encoded integer.\n */\nstatic inline uint64_t\nzigzag64(int64_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn ((uint64_t)v << 1) ^ -((uint64_t)v >> 63);\n}\n\n/**\n * Return the number of bytes required to store a signed 64-bit integer,\n * converted to an unsigned 64-bit integer with ZigZag encoding, using base-128\n * varint encoding.\n *\n * \\param v\n *      Value to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nsint64_size(int64_t v)\n{\n\treturn uint64_size(zigzag64(v));\n}\n\n/**\n * Calculate the serialized size of a single required message field, including\n * the space needed by the preceding tag.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nrequired_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       const void *member)\n{\n\tsize_t rv = get_tag_size(field->id);\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\treturn rv + sint32_size(*(const int32_t *) member);\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\treturn rv + int32_size(*(const int32_t *) member);\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\treturn rv + uint32_size(*(const uint32_t *) member);\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\treturn rv + sint64_size(*(const int64_t *) member);\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\treturn rv + uint64_size(*(const uint64_t *) member);\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\treturn rv + 4;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\treturn rv + 8;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn rv + 1;\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\treturn rv + 4;\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn rv + 8;\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tconst char *str = *(char * const *) member;\n\t\tsize_t len = str ? strlen(str) : 0;\n\t\treturn rv + uint32_size(len) + len;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tsize_t len = ((const ProtobufCBinaryData *) member)->len;\n\t\treturn rv + uint32_size(len) + len;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tconst ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;\n\t\tsize_t subrv = msg ? protobuf_c_message_get_packed_size(msg) : 0;\n\t\treturn rv + uint32_size(subrv) + subrv;\n\t}\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Calculate the serialized size of a single oneof message field, including\n * the space needed by the preceding tag. Returns 0 if the oneof field isn't\n * selected or is not set.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param oneof_case\n *      Enum value that selects the field in the oneof.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\noneof_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t    uint32_t oneof_case,\n\t\t\t    const void *member)\n{\n\tif (oneof_case != field->id) {\n\t\treturn 0;\n\t}\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t}\n\treturn required_field_get_packed_size(field, member);\n}\n\n/**\n * Calculate the serialized size of a single optional message field, including\n * the space needed by the preceding tag. Returns 0 if the optional field isn't\n * set.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param has\n *      True if the field exists, false if not.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\noptional_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       const protobuf_c_boolean has,\n\t\t\t       const void *member)\n{\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!has)\n\t\t\treturn 0;\n\t}\n\treturn required_field_get_packed_size(field, member);\n}\n\nstatic protobuf_c_boolean\nfield_is_zeroish(const ProtobufCFieldDescriptor *field,\n\t\t const void *member)\n{\n\tprotobuf_c_boolean ret = FALSE;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tret = (0 == *(const protobuf_c_boolean *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\tret = (0 == *(const uint32_t *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\tret = (0 == *(const uint64_t *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tret = (0 == *(const float *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tret = (0 == *(const double *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_STRING:\n\t\tret = (NULL == *(const char * const *) member) ||\n\t\t      ('\\0' == **(const char * const *) member);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BYTES:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\tret = (NULL == *(const void * const *) member);\n\t\tbreak;\n\tdefault:\n\t\tret = TRUE;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n/**\n * Calculate the serialized size of a single unlabeled message field, including\n * the space needed by the preceding tag. Returns 0 if the field isn't set or\n * if it is set to a \"zeroish\" value (null pointer or 0 for numerical values).\n * Unlabeled fields are supported only in proto3.\n *\n * \\param field\n *      Field descriptor for member.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nunlabeled_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t\tconst void *member)\n{\n\tif (field_is_zeroish(field, member))\n\t\treturn 0;\n\treturn required_field_get_packed_size(field, member);\n}\n\n/**\n * Calculate the serialized size of repeated message fields, which may consist\n * of any number of values (including 0). Includes the space needed by the\n * preceding tags (as needed).\n *\n * \\param field\n *      Field descriptor for member.\n * \\param count\n *      Number of repeated field members.\n * \\param member\n *      Field to encode.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nrepeated_field_get_packed_size(const ProtobufCFieldDescriptor *field,\n\t\t\t       size_t count, const void *member)\n{\n\tsize_t header_size;\n\tsize_t rv = 0;\n\tunsigned i;\n\tvoid *array = *(void * const *) member;\n\n\tif (count == 0)\n\t\treturn 0;\n\theader_size = get_tag_size(field->id);\n\tif (0 == (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED))\n\t\theader_size *= count;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint32_size(((int32_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += int32_size(((int32_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint32_size(((uint32_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint64_size(((int64_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint64_size(((uint64_t *) array)[i]);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\trv += 4 * count;\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\trv += 8 * count;\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\trv += count;\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_STRING:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsize_t len = strlen(((char **) array)[i]);\n\t\t\trv += uint32_size(len) + len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BYTES:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsize_t len = ((ProtobufCBinaryData *) array)[i].len;\n\t\t\trv += uint32_size(len) + len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tsize_t len = protobuf_c_message_get_packed_size(\n\t\t\t\t((ProtobufCMessage **) array)[i]);\n\t\t\trv += uint32_size(len) + len;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED))\n\t\theader_size += uint32_size(rv);\n\treturn header_size + rv;\n}\n\n/**\n * Calculate the serialized size of an unknown field, i.e. one that is passed\n * through mostly uninterpreted. This is required for forward compatibility if\n * new fields are added to the message descriptor.\n *\n * \\param field\n *      Unknown field type.\n * \\return\n *      Number of bytes required.\n */\nstatic inline size_t\nunknown_field_get_packed_size(const ProtobufCMessageUnknownField *field)\n{\n\treturn get_tag_size(field->tag) + field->len;\n}\n\n/**@}*/\n\n/*\n * Calculate the serialized size of the message.\n */\nsize_t protobuf_c_message_get_packed_size(const ProtobufCMessage *message)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member =\n\t\t\t((const char *) message) + field->offset;\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_get_packed_size(field, member);\n\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n\t\t\trv += oneof_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\t*(const uint32_t *) qmember,\n\t\t\t\tmember\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\trv += optional_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\t*(protobuf_c_boolean *) qmember,\n\t\t\t\tmember\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n\t\t\trv += unlabeled_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\tmember\n\t\t\t);\n\t\t} else {\n\t\t\trv += repeated_field_get_packed_size(\n\t\t\t\tfield,\n\t\t\t\t*(const size_t *) qmember,\n\t\t\t\tmember\n\t\t\t);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_get_packed_size(&message->unknown_fields[i]);\n\treturn rv;\n}\n\n/**\n * \\defgroup pack protobuf_c_message_pack() implementation\n *\n * Routines mainly used by protobuf_c_message_pack().\n *\n * \\ingroup internal\n * @{\n */\n\n/**\n * Pack an unsigned 32-bit integer in base-128 varint encoding and return the\n * number of bytes written, which must be 5 or less.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nuint32_pack(uint32_t value, uint8_t *out)\n{\n\tunsigned rv = 0;\n\n\tif (value >= 0x80) {\n\t\tout[rv++] = value | 0x80;\n\t\tvalue >>= 7;\n\t\tif (value >= 0x80) {\n\t\t\tout[rv++] = value | 0x80;\n\t\t\tvalue >>= 7;\n\t\t\tif (value >= 0x80) {\n\t\t\t\tout[rv++] = value | 0x80;\n\t\t\t\tvalue >>= 7;\n\t\t\t\tif (value >= 0x80) {\n\t\t\t\t\tout[rv++] = value | 0x80;\n\t\t\t\t\tvalue >>= 7;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* assert: value<128 */\n\tout[rv++] = value;\n\treturn rv;\n}\n\n/**\n * Pack a signed 32-bit integer and return the number of bytes written,\n * passed as unsigned to avoid implementation-specific behavior.\n * Negative numbers are encoded as two's complement 64-bit integers.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nint32_pack(uint32_t value, uint8_t *out)\n{\n\tif ((int32_t)value < 0) {\n\t\tout[0] = value | 0x80;\n\t\tout[1] = (value >> 7) | 0x80;\n\t\tout[2] = (value >> 14) | 0x80;\n\t\tout[3] = (value >> 21) | 0x80;\n\t\tout[4] = (value >> 28) | 0xf0;\n\t\tout[5] = out[6] = out[7] = out[8] = 0xff;\n\t\tout[9] = 0x01;\n\t\treturn 10;\n\t} else {\n\t\treturn uint32_pack(value, out);\n\t}\n}\n\n/**\n * Pack a signed 32-bit integer using ZigZag encoding and return the number of\n * bytes written.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nsint32_pack(int32_t value, uint8_t *out)\n{\n\treturn uint32_pack(zigzag32(value), out);\n}\n\n/**\n * Pack a 64-bit unsigned integer using base-128 varint encoding and return the\n * number of bytes written.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\nuint64_pack(uint64_t value, uint8_t *out)\n{\n\tuint32_t hi = (uint32_t) (value >> 32);\n\tuint32_t lo = (uint32_t) value;\n\tunsigned rv;\n\n\tif (hi == 0)\n\t\treturn uint32_pack((uint32_t) lo, out);\n\tout[0] = (lo) | 0x80;\n\tout[1] = (lo >> 7) | 0x80;\n\tout[2] = (lo >> 14) | 0x80;\n\tout[3] = (lo >> 21) | 0x80;\n\tif (hi < 8) {\n\t\tout[4] = (hi << 4) | (lo >> 28);\n\t\treturn 5;\n\t} else {\n\t\tout[4] = ((hi & 7) << 4) | (lo >> 28) | 0x80;\n\t\thi >>= 3;\n\t}\n\trv = 5;\n\twhile (hi >= 128) {\n\t\tout[rv++] = hi | 0x80;\n\t\thi >>= 7;\n\t}\n\tout[rv++] = hi;\n\treturn rv;\n}\n\n/**\n * Pack a 64-bit signed integer in ZigZag encoding and return the number of\n * bytes written.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nsint64_pack(int64_t value, uint8_t *out)\n{\n\treturn uint64_pack(zigzag64(value), out);\n}\n\n/**\n * Pack a 32-bit quantity in little-endian byte order. Used for protobuf wire\n * types fixed32, sfixed32, float. Similar to \"htole32\".\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nfixed32_pack(uint32_t value, void *out)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, &value, 4);\n#else\n\tuint8_t *buf = out;\n\n\tbuf[0] = value;\n\tbuf[1] = value >> 8;\n\tbuf[2] = value >> 16;\n\tbuf[3] = value >> 24;\n#endif\n\treturn 4;\n}\n\n/**\n * Pack a 64-bit quantity in little-endian byte order. Used for protobuf wire\n * types fixed64, sfixed64, double. Similar to \"htole64\".\n *\n * \\todo The big-endian impl is really only good for 32-bit machines, a 64-bit\n * version would be appreciated, plus a way to decide to use 64-bit math where\n * convenient.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nfixed64_pack(uint64_t value, void *out)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, &value, 8);\n#else\n\tfixed32_pack(value, out);\n\tfixed32_pack(value >> 32, ((char *) out) + 4);\n#endif\n\treturn 8;\n}\n\n/**\n * Pack a boolean value as an integer and return the number of bytes written.\n *\n * \\todo Perhaps on some platforms *out = !!value would be a better impl, b/c\n * that is idiomatic C++ in some STL implementations.\n *\n * \\param value\n *      Value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nboolean_pack(protobuf_c_boolean value, uint8_t *out)\n{\n\t*out = value ? TRUE : FALSE;\n\treturn 1;\n}\n\n/**\n * Pack a NUL-terminated C string and return the number of bytes written. The\n * output includes a length delimiter.\n *\n * The NULL pointer is treated as an empty string. This isn't really necessary,\n * but it allows people to leave required strings blank. (See Issue #13 in the\n * bug tracker for a little more explanation).\n *\n * \\param str\n *      String to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nstring_pack(const char *str, uint8_t *out)\n{\n\tif (str == NULL) {\n\t\tout[0] = 0;\n\t\treturn 1;\n\t} else {\n\t\tsize_t len = strlen(str);\n\t\tsize_t rv = uint32_pack(len, out);\n\t\tmemcpy(out + rv, str, len);\n\t\treturn rv + len;\n\t}\n}\n\n/**\n * Pack a ProtobufCBinaryData and return the number of bytes written. The output\n * includes a length delimiter.\n *\n * \\param bd\n *      ProtobufCBinaryData to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nbinary_data_pack(const ProtobufCBinaryData *bd, uint8_t *out)\n{\n\tsize_t len = bd->len;\n\tsize_t rv = uint32_pack(len, out);\n\tmemcpy(out + rv, bd->data, len);\n\treturn rv + len;\n}\n\n/**\n * Pack a ProtobufCMessage and return the number of bytes written. The output\n * includes a length delimiter.\n *\n * \\param message\n *      ProtobufCMessage object to pack.\n * \\param[out] out\n *      Packed message.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic inline size_t\nprefixed_message_pack(const ProtobufCMessage *message, uint8_t *out)\n{\n\tif (message == NULL) {\n\t\tout[0] = 0;\n\t\treturn 1;\n\t} else {\n\t\tsize_t rv = protobuf_c_message_pack(message, out + 1);\n\t\tuint32_t rv_packed_size = uint32_size(rv);\n\t\tif (rv_packed_size != 1)\n\t\t\tmemmove(out + rv_packed_size, out + 1, rv);\n\t\treturn uint32_pack(rv, out) + rv;\n\t}\n}\n\n/**\n * Pack a field tag.\n *\n * Wire-type will be added in required_field_pack().\n *\n * \\todo Just call uint64_pack on 64-bit platforms.\n *\n * \\param id\n *      Tag value to encode.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\ntag_pack(uint32_t id, uint8_t *out)\n{\n\tif (id < (1UL << (32 - 3)))\n\t\treturn uint32_pack(id << 3, out);\n\telse\n\t\treturn uint64_pack(((uint64_t) id) << 3, out);\n}\n\n/**\n * Pack a required field and return the number of bytes written.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\nrequired_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t    const void *member, uint8_t *out)\n{\n\tsize_t rv = tag_pack(field->id, out);\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + sint32_pack(*(const int32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + int32_pack(*(const int32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + uint32_pack(*(const uint32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + sint64_pack(*(const int64_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + uint64_pack(*(const uint64_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;\n\t\treturn rv + fixed32_pack(*(const uint32_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;\n\t\treturn rv + fixed64_pack(*(const uint64_t *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\treturn rv + boolean_pack(*(const protobuf_c_boolean *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_STRING:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\treturn rv + string_pack(*(char *const *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_BYTES:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\treturn rv + binary_data_pack((const ProtobufCBinaryData *) member, out + rv);\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\treturn rv + prefixed_message_pack(*(ProtobufCMessage * const *) member, out + rv);\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Pack a oneof field and return the number of bytes written. Only packs the\n * field that is selected by the case enum.\n *\n * \\param field\n *      Field descriptor.\n * \\param oneof_case\n *      Enum value that selects the field in the oneof.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\noneof_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t uint32_t oneof_case,\n\t\t const void *member, uint8_t *out)\n{\n\tif (oneof_case != field->id) {\n\t\treturn 0;\n\t}\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack(field, member, out);\n}\n\n/**\n * Pack an optional field and return the number of bytes written.\n *\n * \\param field\n *      Field descriptor.\n * \\param has\n *      Whether the field is set.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\noptional_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t    const protobuf_c_boolean has,\n\t\t    const void *member, uint8_t *out)\n{\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void * const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!has)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack(field, member, out);\n}\n\n/**\n * Pack an unlabeled field and return the number of bytes written.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The field member.\n * \\param[out] out\n *      Packed value.\n * \\return\n *      Number of bytes written to `out`.\n */\nstatic size_t\nunlabeled_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t     const void *member, uint8_t *out)\n{\n\tif (field_is_zeroish(field, member))\n\t\treturn 0;\n\treturn required_field_pack(field, member, out);\n}\n\n/**\n * Given a field type, return the in-memory size.\n *\n * \\todo Implement as a table lookup.\n *\n * \\param type\n *      Field type.\n * \\return\n *      Size of the field.\n */\nstatic inline size_t\nsizeof_elt_in_repeated_array(ProtobufCType type)\n{\n\tswitch (type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\tcase PROTOBUF_C_TYPE_ENUM:\n\t\treturn 4;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn 8;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn sizeof(protobuf_c_boolean);\n\tcase PROTOBUF_C_TYPE_STRING:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\treturn sizeof(void *);\n\tcase PROTOBUF_C_TYPE_BYTES:\n\t\treturn sizeof(ProtobufCBinaryData);\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Pack an array of 32-bit quantities.\n *\n * \\param[out] out\n *      Destination.\n * \\param[in] in\n *      Source.\n * \\param[in] n\n *      Number of elements in the source array.\n */\nstatic void\ncopy_to_little_endian_32(void *out, const void *in, const unsigned n)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, in, n * 4);\n#else\n\tunsigned i;\n\tconst uint32_t *ini = in;\n\tfor (i = 0; i < n; i++)\n\t\tfixed32_pack(ini[i], (uint32_t *) out + i);\n#endif\n}\n\n/**\n * Pack an array of 64-bit quantities.\n *\n * \\param[out] out\n *      Destination.\n * \\param[in] in\n *      Source.\n * \\param[in] n\n *      Number of elements in the source array.\n */\nstatic void\ncopy_to_little_endian_64(void *out, const void *in, const unsigned n)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tmemcpy(out, in, n * 8);\n#else\n\tunsigned i;\n\tconst uint64_t *ini = in;\n\tfor (i = 0; i < n; i++)\n\t\tfixed64_pack(ini[i], (uint64_t *) out + i);\n#endif\n}\n\n/**\n * Get the minimum number of bytes required to pack a field value of a\n * particular type.\n *\n * \\param type\n *      Field type.\n * \\return\n *      Number of bytes.\n */\nstatic unsigned\nget_type_min_size(ProtobufCType type)\n{\n\tif (type == PROTOBUF_C_TYPE_SFIXED32 ||\n\t    type == PROTOBUF_C_TYPE_FIXED32 ||\n\t    type == PROTOBUF_C_TYPE_FLOAT)\n\t{\n\t\treturn 4;\n\t}\n\tif (type == PROTOBUF_C_TYPE_SFIXED64 ||\n\t    type == PROTOBUF_C_TYPE_FIXED64 ||\n\t    type == PROTOBUF_C_TYPE_DOUBLE)\n\t{\n\t\treturn 8;\n\t}\n\treturn 1;\n}\n\n/**\n * Packs the elements of a repeated field and returns the serialised field and\n * its length.\n *\n * \\param field\n *      Field descriptor.\n * \\param count\n *      Number of elements in the repeated field array.\n * \\param member\n *      Pointer to the elements for this repeated field.\n * \\param[out] out\n *      Serialised representation of the repeated field.\n * \\return\n *      Number of bytes serialised to `out`.\n */\nstatic size_t\nrepeated_field_pack(const ProtobufCFieldDescriptor *field,\n\t\t    size_t count, const void *member, uint8_t *out)\n{\n\tvoid *array = *(void * const *) member;\n\tunsigned i;\n\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {\n\t\tunsigned header_len;\n\t\tunsigned len_start;\n\t\tunsigned min_length;\n\t\tunsigned payload_len;\n\t\tunsigned length_size_min;\n\t\tunsigned actual_length_size;\n\t\tuint8_t *payload_at;\n\n\t\tif (count == 0)\n\t\t\treturn 0;\n\t\theader_len = tag_pack(field->id, out);\n\t\tout[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\tlen_start = header_len;\n\t\tmin_length = get_type_min_size(field->type) * count;\n\t\tlength_size_min = uint32_size(min_length);\n\t\theader_len += length_size_min;\n\t\tpayload_at = out + header_len;\n\n\t\tswitch (field->type) {\n\t\tcase PROTOBUF_C_TYPE_SFIXED32:\n\t\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\t\tcopy_to_little_endian_32(payload_at, array, count);\n\t\t\tpayload_at += count * 4;\n\t\t\tbreak;\n\t\tcase PROTOBUF_C_TYPE_SFIXED64:\n\t\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\t\tcopy_to_little_endian_64(payload_at, array, count);\n\t\t\tpayload_at += count * 8;\n\t\t\tbreak;\n\t\tcase PROTOBUF_C_TYPE_ENUM:\n\t\tcase PROTOBUF_C_TYPE_INT32: {\n\t\t\tconst int32_t *arr = (const int32_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += int32_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_SINT32: {\n\t\t\tconst int32_t *arr = (const int32_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += sint32_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_SINT64: {\n\t\t\tconst int64_t *arr = (const int64_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += sint64_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_UINT32: {\n\t\t\tconst uint32_t *arr = (const uint32_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += uint32_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_INT64:\n\t\tcase PROTOBUF_C_TYPE_UINT64: {\n\t\t\tconst uint64_t *arr = (const uint64_t *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += uint64_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_TYPE_BOOL: {\n\t\t\tconst protobuf_c_boolean *arr = (const protobuf_c_boolean *) array;\n\t\t\tfor (i = 0; i < count; i++)\n\t\t\t\tpayload_at += boolean_pack(arr[i], payload_at);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t\t}\n\n\t\tpayload_len = payload_at - (out + header_len);\n\t\tactual_length_size = uint32_size(payload_len);\n\t\tif (length_size_min != actual_length_size) {\n\t\t\tassert(actual_length_size == length_size_min + 1);\n\t\t\tmemmove(out + header_len + 1, out + header_len,\n\t\t\t\tpayload_len);\n\t\t\theader_len++;\n\t\t}\n\t\tuint32_pack(payload_len, out + len_start);\n\t\treturn header_len + payload_len;\n\t} else {\n\t\t/* not \"packed\" cased */\n\t\t/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */\n\t\tsize_t rv = 0;\n\t\tunsigned siz = sizeof_elt_in_repeated_array(field->type);\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\trv += required_field_pack(field, array, out + rv);\n\t\t\tarray = (char *)array + siz;\n\t\t}\n\t\treturn rv;\n\t}\n}\n\nstatic size_t\nunknown_field_pack(const ProtobufCMessageUnknownField *field, uint8_t *out)\n{\n\tsize_t rv = tag_pack(field->tag, out);\n\tout[0] |= field->wire_type;\n\tmemcpy(out + rv, field->data, field->len);\n\treturn rv + field->len;\n}\n\n/**@}*/\n\nsize_t\nprotobuf_c_message_pack(const ProtobufCMessage *message, uint8_t *out)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member = ((const char *) message) + field->offset;\n\n\t\t/*\n\t\t * It doesn't hurt to compute qmember (a pointer to the\n\t\t * quantifier field of the structure), but the pointer is only\n\t\t * valid if the field is:\n\t\t *  - a repeated field, or\n\t\t *  - a field that is part of a oneof\n\t\t *  - an optional field that isn't a pointer type\n\t\t * (Meaning: not a message or a string).\n\t\t */\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_pack(field, member, out + rv);\n\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n\t\t\trv += oneof_field_pack(\n\t\t\t\tfield,\n\t\t\t\t*(const uint32_t *) qmember,\n\t\t\t\tmember,\n\t\t\t\tout + rv\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\trv += optional_field_pack(\n\t\t\t\tfield,\n\t\t\t\t*(const protobuf_c_boolean *) qmember,\n\t\t\t\tmember,\n\t\t\t\tout + rv\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n\t\t\trv += unlabeled_field_pack(field, member, out + rv);\n\t\t} else {\n\t\t\trv += repeated_field_pack(field, *(const size_t *) qmember,\n\t\t\t\tmember, out + rv);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_pack(&message->unknown_fields[i], out + rv);\n\treturn rv;\n}\n\n/**\n * \\defgroup packbuf protobuf_c_message_pack_to_buffer() implementation\n *\n * Routines mainly used by protobuf_c_message_pack_to_buffer().\n *\n * \\ingroup internal\n * @{\n */\n\n/**\n * Pack a required field to a virtual buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes packed.\n */\nstatic size_t\nrequired_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      const void *member, ProtobufCBuffer *buffer)\n{\n\tsize_t rv;\n\tuint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];\n\n\trv = tag_pack(field->id, scratch);\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += sint32_pack(*(const int32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += int32_pack(*(const int32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += uint32_pack(*(const uint32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += sint64_pack(*(const int64_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += uint64_pack(*(const uint64_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;\n\t\trv += fixed32_pack(*(const uint32_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;\n\t\trv += fixed64_pack(*(const uint64_t *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;\n\t\trv += boolean_pack(*(const protobuf_c_boolean *) member, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tconst char *str = *(char *const *) member;\n\t\tsize_t sublen = str ? strlen(str) : 0;\n\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(sublen, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbuffer->append(buffer, sublen, (const uint8_t *) str);\n\t\trv += sublen;\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tconst ProtobufCBinaryData *bd = ((const ProtobufCBinaryData *) member);\n\t\tsize_t sublen = bd->len;\n\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(sublen, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\tbuffer->append(buffer, sublen, bd->data);\n\t\trv += sublen;\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tconst ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;\n\t\t\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\tif (msg == NULL) {\n\t\t\trv += uint32_pack(0, scratch + rv);\n\t\t\tbuffer->append(buffer, rv, scratch);\n\t\t} else {\n\t\t\tsize_t sublen = protobuf_c_message_get_packed_size(msg);\n\t\t\trv += uint32_pack(sublen, scratch + rv);\n\t\t\tbuffer->append(buffer, rv, scratch);\n\t\t\tprotobuf_c_message_pack_to_buffer(msg, buffer);\n\t\t\trv += sublen;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\treturn rv;\n}\n\n/**\n * Pack a oneof field to a buffer. Only packs the field that is selected by the case enum.\n *\n * \\param field\n *      Field descriptor.\n * \\param oneof_case\n *      Enum value that selects the field in the oneof.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes serialised to `buffer`.\n */\nstatic size_t\noneof_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t   uint32_t oneof_case,\n\t\t\t   const void *member, ProtobufCBuffer *buffer)\n{\n\tif (oneof_case != field->id) {\n\t\treturn 0;\n\t}\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void *const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack_to_buffer(field, member, buffer);\n}\n\n/**\n * Pack an optional field to a buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param has\n *      Whether the field is set.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes serialised to `buffer`.\n */\nstatic size_t\noptional_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      const protobuf_c_boolean has,\n\t\t\t      const void *member, ProtobufCBuffer *buffer)\n{\n\tif (field->type == PROTOBUF_C_TYPE_MESSAGE ||\n\t    field->type == PROTOBUF_C_TYPE_STRING)\n\t{\n\t\tconst void *ptr = *(const void *const *) member;\n\t\tif (ptr == NULL || ptr == field->default_value)\n\t\t\treturn 0;\n\t} else {\n\t\tif (!has)\n\t\t\treturn 0;\n\t}\n\treturn required_field_pack_to_buffer(field, member, buffer);\n}\n\n/**\n * Pack an unlabeled field to a buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param member\n *      The element to be packed.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes serialised to `buffer`.\n */\nstatic size_t\nunlabeled_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t       const void *member, ProtobufCBuffer *buffer)\n{\n\tif (field_is_zeroish(field, member))\n\t\treturn 0;\n\treturn required_field_pack_to_buffer(field, member, buffer);\n}\n\n/**\n * Get the packed size of an array of same field type.\n *\n * \\param field\n *      Field descriptor.\n * \\param count\n *      Number of elements of this type.\n * \\param array\n *      The elements to get the size of.\n * \\return\n *      Number of bytes required.\n */\nstatic size_t\nget_packed_payload_length(const ProtobufCFieldDescriptor *field,\n\t\t\t  unsigned count, const void *array)\n{\n\tunsigned rv = 0;\n\tunsigned i;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\treturn count * 4;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\treturn count * 8;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32: {\n\t\tconst int32_t *arr = (const int32_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += int32_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_SINT32: {\n\t\tconst int32_t *arr = (const int32_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint32_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_UINT32: {\n\t\tconst uint32_t *arr = (const uint32_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint32_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_SINT64: {\n\t\tconst int64_t *arr = (const int64_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += sint64_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64: {\n\t\tconst uint64_t *arr = (const uint64_t *) array;\n\t\tfor (i = 0; i < count; i++)\n\t\t\trv += uint64_size(arr[i]);\n\t\tbreak;\n\t}\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\treturn count;\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\treturn rv;\n}\n\n/**\n * Pack an array of same field type to a virtual buffer.\n *\n * \\param field\n *      Field descriptor.\n * \\param count\n *      Number of elements of this type.\n * \\param array\n *      The elements to get the size of.\n * \\param[out] buffer\n *      Virtual buffer to append data to.\n * \\return\n *      Number of bytes packed.\n */\nstatic size_t\npack_buffer_packed_payload(const ProtobufCFieldDescriptor *field,\n\t\t\t   unsigned count, const void *array,\n\t\t\t   ProtobufCBuffer *buffer)\n{\n\tuint8_t scratch[16];\n\tsize_t rv = 0;\n\tunsigned i;\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n#if !defined(WORDS_BIGENDIAN)\n\t\trv = count * 4;\n\t\tgoto no_packing_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = fixed32_pack(((uint32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n#if !defined(WORDS_BIGENDIAN)\n\t\trv = count * 8;\n\t\tgoto no_packing_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = fixed64_pack(((uint64_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = int32_pack(((int32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = sint32_pack(((int32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = uint32_pack(((uint32_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = sint64_pack(((int64_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = uint64_pack(((uint64_t *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tunsigned len = boolean_pack(((protobuf_c_boolean *) array)[i], scratch);\n\t\t\tbuffer->append(buffer, len, scratch);\n\t\t\trv += len;\n\t\t}\n\t\treturn count;\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\treturn rv;\n\n#if !defined(WORDS_BIGENDIAN)\nno_packing_needed:\n\tbuffer->append(buffer, rv, array);\n\treturn rv;\n#endif\n}\n\nstatic size_t\nrepeated_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,\n\t\t\t      unsigned count, const void *member,\n\t\t\t      ProtobufCBuffer *buffer)\n{\n\tchar *array = *(char * const *) member;\n\n\tif (count == 0)\n\t\treturn 0;\n\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED)) {\n\t\tuint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];\n\t\tsize_t rv = tag_pack(field->id, scratch);\n\t\tsize_t payload_len = get_packed_payload_length(field, count, array);\n\t\tsize_t tmp;\n\n\t\tscratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;\n\t\trv += uint32_pack(payload_len, scratch + rv);\n\t\tbuffer->append(buffer, rv, scratch);\n\t\ttmp = pack_buffer_packed_payload(field, count, array, buffer);\n\t\tassert(tmp == payload_len);\n\t\treturn rv + payload_len;\n\t} else {\n\t\tsize_t siz;\n\t\tunsigned i;\n\t\t/* CONSIDER: optimize this case a bit (by putting the loop inside the switch) */\n\t\tunsigned rv = 0;\n\n\t\tsiz = sizeof_elt_in_repeated_array(field->type);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\trv += required_field_pack_to_buffer(field, array, buffer);\n\t\t\tarray += siz;\n\t\t}\n\t\treturn rv;\n\t}\n}\n\nstatic size_t\nunknown_field_pack_to_buffer(const ProtobufCMessageUnknownField *field,\n\t\t\t     ProtobufCBuffer *buffer)\n{\n\tuint8_t header[MAX_UINT64_ENCODED_SIZE];\n\tsize_t rv = tag_pack(field->tag, header);\n\n\theader[0] |= field->wire_type;\n\tbuffer->append(buffer, rv, header);\n\tbuffer->append(buffer, field->len, field->data);\n\treturn rv + field->len;\n}\n\n/**@}*/\n\nsize_t\nprotobuf_c_message_pack_to_buffer(const ProtobufCMessage *message,\n\t\t\t\t  ProtobufCBuffer *buffer)\n{\n\tunsigned i;\n\tsize_t rv = 0;\n\n\tASSERT_IS_MESSAGE(message);\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *field =\n\t\t\tmessage->descriptor->fields + i;\n\t\tconst void *member =\n\t\t\t((const char *) message) + field->offset;\n\t\tconst void *qmember =\n\t\t\t((const char *) message) + field->quantifier_offset;\n\n\t\tif (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\trv += required_field_pack_to_buffer(field, member, buffer);\n\t\t} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t    field->label == PROTOBUF_C_LABEL_NONE) &&\n\t\t\t   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {\n\t\t\trv += oneof_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\t*(const uint32_t *) qmember,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {\n\t\t\trv += optional_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\t*(const protobuf_c_boolean *) qmember,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t} else if (field->label == PROTOBUF_C_LABEL_NONE) {\n\t\t\trv += unlabeled_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t} else {\n\t\t\trv += repeated_field_pack_to_buffer(\n\t\t\t\tfield,\n\t\t\t\t*(const size_t *) qmember,\n\t\t\t\tmember,\n\t\t\t\tbuffer\n\t\t\t);\n\t\t}\n\t}\n\tfor (i = 0; i < message->n_unknown_fields; i++)\n\t\trv += unknown_field_pack_to_buffer(&message->unknown_fields[i], buffer);\n\n\treturn rv;\n}\n\n/**\n * \\defgroup unpack unpacking implementation\n *\n * Routines mainly used by the unpacking functions.\n *\n * \\ingroup internal\n * @{\n */\n\nstatic inline int\nint_range_lookup(unsigned n_ranges, const ProtobufCIntRange *ranges, int value)\n{\n\tunsigned n;\n\tunsigned start;\n\n\tif (n_ranges == 0)\n\t\treturn -1;\n\tstart = 0;\n\tn = n_ranges;\n\twhile (n > 1) {\n\t\tunsigned mid = start + n / 2;\n\n\t\tif (value < ranges[mid].start_value) {\n\t\t\tn = mid - start;\n\t\t} else if (value >= ranges[mid].start_value +\n\t\t\t   (int) (ranges[mid + 1].orig_index -\n\t\t\t\t  ranges[mid].orig_index))\n\t\t{\n\t\t\tunsigned new_start = mid + 1;\n\t\t\tn = start + n - new_start;\n\t\t\tstart = new_start;\n\t\t} else\n\t\t\treturn (value - ranges[mid].start_value) +\n\t\t\t    ranges[mid].orig_index;\n\t}\n\tif (n > 0) {\n\t\tunsigned start_orig_index = ranges[start].orig_index;\n\t\tunsigned range_size =\n\t\t\tranges[start + 1].orig_index - start_orig_index;\n\n\t\tif (ranges[start].start_value <= value &&\n\t\t    value < (int) (ranges[start].start_value + range_size))\n\t\t{\n\t\t\treturn (value - ranges[start].start_value) +\n\t\t\t    start_orig_index;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic size_t\nparse_tag_and_wiretype(size_t len,\n\t\t       const uint8_t *data,\n\t\t       uint32_t *tag_out,\n\t\t       uint8_t *wiretype_out)\n{\n\tunsigned max_rv = len > 5 ? 5 : len;\n\tuint32_t tag = (data[0] & 0x7f) >> 3;\n\tunsigned shift = 4;\n\tunsigned rv;\n\n\t/* 0 is not a valid tag value */\n\tif ((data[0] & 0xf8) == 0) {\n\t\treturn 0;\n\t}\n\n\t*wiretype_out = data[0] & 7;\n\tif ((data[0] & 0x80) == 0) {\n\t\t*tag_out = tag;\n\t\treturn 1;\n\t}\n\tfor (rv = 1; rv < max_rv; rv++) {\n\t\tif (data[rv] & 0x80) {\n\t\t\ttag |= (data[rv] & 0x7f) << shift;\n\t\t\tshift += 7;\n\t\t} else {\n\t\t\ttag |= data[rv] << shift;\n\t\t\t*tag_out = tag;\n\t\t\treturn rv + 1;\n\t\t}\n\t}\n\treturn 0; /* error: bad header */\n}\n\n/* sizeof(ScannedMember) must be <= (1UL<<BOUND_SIZEOF_SCANNED_MEMBER_LOG2) */\n#define BOUND_SIZEOF_SCANNED_MEMBER_LOG2 5\ntypedef struct ScannedMember ScannedMember;\n/** Field as it's being read. */\nstruct ScannedMember {\n\tuint32_t tag;              /**< Field tag. */\n\tuint8_t wire_type;         /**< Field type. */\n\tuint8_t length_prefix_len; /**< Prefix length. */\n\tconst ProtobufCFieldDescriptor *field; /**< Field descriptor. */\n\tsize_t len;                /**< Field length. */\n\tconst uint8_t *data;       /**< Pointer to field data. */\n};\n\nstatic inline size_t\nscan_length_prefixed_data(size_t len, const uint8_t *data,\n\t\t\t  size_t *prefix_len_out)\n{\n\tunsigned hdr_max = len < 5 ? len : 5;\n\tunsigned hdr_len;\n\tsize_t val = 0;\n\tunsigned i;\n\tunsigned shift = 0;\n\n\tfor (i = 0; i < hdr_max; i++) {\n\t\tval |= ((size_t)data[i] & 0x7f) << shift;\n\t\tshift += 7;\n\t\tif ((data[i] & 0x80) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == hdr_max) {\n\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing length for length-prefixed data\");\n\t\treturn 0;\n\t}\n\thdr_len = i + 1;\n\t*prefix_len_out = hdr_len;\n\tif (val > INT_MAX) {\n\t\t// Protobuf messages should always be less than 2 GiB in size.\n\t\t// We also want to return early here so that hdr_len + val does\n\t\t// not overflow on 32-bit systems.\n\t\tPROTOBUF_C_UNPACK_ERROR(\"length prefix of %lu is too large\",\n\t\t\t(unsigned long int)val);\n\t\treturn 0;\n\t}\n\tif (hdr_len + val > len) {\n\t\tPROTOBUF_C_UNPACK_ERROR(\"data too short after length-prefix of %lu\",\n\t\t\t(unsigned long int)val);\n\t\treturn 0;\n\t}\n\treturn hdr_len + val;\n}\n\nstatic size_t\nmax_b128_numbers(size_t len, const uint8_t *data)\n{\n\tsize_t rv = 0;\n\twhile (len--)\n\t\tif ((*data++ & 0x80) == 0)\n\t\t\t++rv;\n\treturn rv;\n}\n\n/**@}*/\n\n/**\n * Merge earlier message into a latter message.\n *\n * For numeric types and strings, if the same value appears multiple\n * times, the parser accepts the last value it sees. For embedded\n * message fields, the parser merges multiple instances of the same\n * field. That is, all singular scalar fields in the latter instance\n * replace those in the former, singular embedded messages are merged,\n * and repeated fields are concatenated.\n *\n * The earlier message should be freed after calling this function, as\n * some of its fields may have been reused and changed to their default\n * values during the merge.\n */\nstatic protobuf_c_boolean\nmerge_messages(ProtobufCMessage *earlier_msg,\n\t       ProtobufCMessage *latter_msg,\n\t       ProtobufCAllocator *allocator)\n{\n\tunsigned i;\n\tconst ProtobufCFieldDescriptor *fields =\n\t\tlatter_msg->descriptor->fields;\n\tfor (i = 0; i < latter_msg->descriptor->n_fields; i++) {\n\t\tif (fields[i].label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *n_earlier =\n\t\t\t\tSTRUCT_MEMBER_PTR(size_t, earlier_msg,\n\t\t\t\t\t\t  fields[i].quantifier_offset);\n\t\t\tuint8_t **p_earlier =\n\t\t\t\tSTRUCT_MEMBER_PTR(uint8_t *, earlier_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\t\t\tsize_t *n_latter =\n\t\t\t\tSTRUCT_MEMBER_PTR(size_t, latter_msg,\n\t\t\t\t\t\t  fields[i].quantifier_offset);\n\t\t\tuint8_t **p_latter =\n\t\t\t\tSTRUCT_MEMBER_PTR(uint8_t *, latter_msg,\n\t\t\t\t\t\t  fields[i].offset);\n\n\t\t\tif (*n_earlier > 0) {\n\t\t\t\tif (*n_latter > 0) {\n\t\t\t\t\t/* Concatenate the repeated field */\n\t\t\t\t\tsize_t el_size =\n\t\t\t\t\t\tsizeof_elt_in_repeated_array(fields[i].type);\n\t\t\t\t\tuint8_t *new_field;\n\n\t\t\t\t\tnew_field = do_alloc(allocator,\n\t\t\t\t\t\t(*n_earlier + *n_latter) * el_size);\n\t\t\t\t\tif (!new_field)\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tmemcpy(new_field, *p_earlier,\n\t\t\t\t\t       *n_earlier * el_size);\n\t\t\t\t\tmemcpy(new_field +\n\t\t\t\t\t       *n_earlier * el_size,\n\t\t\t\t\t       *p_latter,\n\t\t\t\t\t       *n_latter * el_size);\n\n\t\t\t\t\tdo_free(allocator, *p_latter);\n\t\t\t\t\tdo_free(allocator, *p_earlier);\n\t\t\t\t\t*p_latter = new_field;\n\t\t\t\t\t*n_latter = *n_earlier + *n_latter;\n\t\t\t\t} else {\n\t\t\t\t\t/* Zero copy the repeated field from the earlier message */\n\t\t\t\t\t*n_latter = *n_earlier;\n\t\t\t\t\t*p_latter = *p_earlier;\n\t\t\t\t}\n\t\t\t\t/* Make sure the field does not get double freed */\n\t\t\t\t*n_earlier = 0;\n\t\t\t\t*p_earlier = 0;\n\t\t\t}\n\t\t} else if (fields[i].label == PROTOBUF_C_LABEL_OPTIONAL ||\n\t\t\t   fields[i].label == PROTOBUF_C_LABEL_NONE) {\n\t\t\tconst ProtobufCFieldDescriptor *field;\n\t\t\tuint32_t *earlier_case_p = STRUCT_MEMBER_PTR(uint32_t,\n\t\t\t\t\t\t\t\t     earlier_msg,\n\t\t\t\t\t\t\t\t     fields[i].\n\t\t\t\t\t\t\t\t     quantifier_offset);\n\t\t\tuint32_t *latter_case_p = STRUCT_MEMBER_PTR(uint32_t,\n\t\t\t\t\t\t\t\t    latter_msg,\n\t\t\t\t\t\t\t\t    fields[i].\n\t\t\t\t\t\t\t\t    quantifier_offset);\n\t\t\tprotobuf_c_boolean need_to_merge = FALSE;\n\t\t\tvoid *earlier_elem;\n\t\t\tvoid *latter_elem;\n\t\t\tconst void *def_val;\n\n\t\t\tif (fields[i].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {\n\t\t\t\tif (*latter_case_p == 0) {\n\t\t\t\t\t/* lookup correct oneof field */\n\t\t\t\t\tint field_index =\n\t\t\t\t\t\tint_range_lookup(\n\t\t\t\t\t\t\tlatter_msg->descriptor\n\t\t\t\t\t\t\t->n_field_ranges,\n\t\t\t\t\t\t\tlatter_msg->descriptor\n\t\t\t\t\t\t\t->field_ranges,\n\t\t\t\t\t\t\t*earlier_case_p);\n\t\t\t\t\tif (field_index < 0)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\tfield = latter_msg->descriptor->fields +\n\t\t\t\t\t\tfield_index;\n\t\t\t\t} else {\n\t\t\t\t\t/* Oneof is present in the latter message, move on */\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfield = &fields[i];\n\t\t\t}\n\n\t\t\tearlier_elem = STRUCT_MEMBER_P(earlier_msg, field->offset);\n\t\t\tlatter_elem = STRUCT_MEMBER_P(latter_msg, field->offset);\n\t\t\tdef_val = field->default_value;\n\n\t\t\tswitch (field->type) {\n\t\t\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\t\t\tProtobufCMessage *em = *(ProtobufCMessage **) earlier_elem;\n\t\t\t\tProtobufCMessage *lm = *(ProtobufCMessage **) latter_elem;\n\t\t\t\tif (em != NULL) {\n\t\t\t\t\tif (lm != NULL) {\n\t\t\t\t\t\tif (!merge_messages(em, lm, allocator))\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t/* Already merged */\n\t\t\t\t\t\tneed_to_merge = FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Zero copy the message */\n\t\t\t\t\t\tneed_to_merge = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\t\t\tuint8_t *e_data =\n\t\t\t\t\t((ProtobufCBinaryData *) earlier_elem)->data;\n\t\t\t\tuint8_t *l_data =\n\t\t\t\t\t((ProtobufCBinaryData *) latter_elem)->data;\n\t\t\t\tconst ProtobufCBinaryData *d_bd =\n\t\t\t\t\t(ProtobufCBinaryData *) def_val;\n\n\t\t\t\tneed_to_merge =\n\t\t\t\t\t(e_data != NULL &&\n\t\t\t\t\t (d_bd == NULL ||\n\t\t\t\t\t  e_data != d_bd->data)) &&\n\t\t\t\t\t(l_data == NULL ||\n\t\t\t\t\t (d_bd != NULL &&\n\t\t\t\t\t  l_data == d_bd->data));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase PROTOBUF_C_TYPE_STRING: {\n\t\t\t\tchar *e_str = *(char **) earlier_elem;\n\t\t\t\tchar *l_str = *(char **) latter_elem;\n\t\t\t\tconst char *d_str = def_val;\n\n\t\t\t\tneed_to_merge = e_str != d_str && l_str == d_str;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t/* Could be has field or case enum, the logic is\n\t\t\t\t * equivalent, since 0 (FALSE) means not set for\n\t\t\t\t * oneof */\n\t\t\t\tneed_to_merge = (*earlier_case_p != 0) &&\n\t\t\t\t\t\t(*latter_case_p == 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\n\t\t\tif (need_to_merge) {\n\t\t\t\tsize_t el_size =\n\t\t\t\t\tsizeof_elt_in_repeated_array(field->type);\n\t\t\t\tmemcpy(latter_elem, earlier_elem, el_size);\n\t\t\t\t/*\n\t\t\t\t * Reset the element from the old message to 0\n\t\t\t\t * to make sure earlier message deallocation\n\t\t\t\t * doesn't corrupt zero-copied data in the new\n\t\t\t\t * message, earlier message will be freed after\n\t\t\t\t * this function is called anyway\n\t\t\t\t */\n\t\t\t\tmemset(earlier_elem, 0, el_size);\n\n\t\t\t\tif (field->quantifier_offset != 0) {\n\t\t\t\t\t/* Set the has field or the case enum,\n\t\t\t\t\t * if applicable */\n\t\t\t\t\t*latter_case_p = *earlier_case_p;\n\t\t\t\t\t*earlier_case_p = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}\n\n/**\n * Count packed elements.\n *\n * Given a raw slab of packed-repeated values, determine the number of\n * elements. This function detects certain kinds of errors but not\n * others; the remaining error checking is done by\n * parse_packed_repeated_member().\n */\nstatic protobuf_c_boolean\ncount_packed_elements(ProtobufCType type,\n\t\t      size_t len, const uint8_t *data, size_t *count_out)\n{\n\tswitch (type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tif (len % 4 != 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"length must be a multiple of 4 for fixed-length 32-bit types\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t*count_out = len / 4;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tif (len % 8 != 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"length must be a multiple of 8 for fixed-length 64-bit types\");\n\t\t\treturn FALSE;\n\t\t}\n\t\t*count_out = len / 8;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\tcase PROTOBUF_C_TYPE_SINT32:\n\tcase PROTOBUF_C_TYPE_UINT32:\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_SINT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\t*count_out = max_b128_numbers(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t*count_out = len;\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_STRING:\n\tcase PROTOBUF_C_TYPE_BYTES:\n\tcase PROTOBUF_C_TYPE_MESSAGE:\n\tdefault:\n\t\tPROTOBUF_C_UNPACK_ERROR(\"bad protobuf-c type %u for packed-repeated\", type);\n\t\treturn FALSE;\n\t}\n}\n\nstatic inline uint32_t\nparse_uint32(unsigned len, const uint8_t *data)\n{\n\tuint32_t rv = data[0] & 0x7f;\n\tif (len > 1) {\n\t\trv |= ((uint32_t) (data[1] & 0x7f) << 7);\n\t\tif (len > 2) {\n\t\t\trv |= ((uint32_t) (data[2] & 0x7f) << 14);\n\t\t\tif (len > 3) {\n\t\t\t\trv |= ((uint32_t) (data[3] & 0x7f) << 21);\n\t\t\t\tif (len > 4)\n\t\t\t\t\trv |= ((uint32_t) (data[4]) << 28);\n\t\t\t}\n\t\t}\n\t}\n\treturn rv;\n}\n\nstatic inline uint32_t\nparse_int32(unsigned len, const uint8_t *data)\n{\n\treturn parse_uint32(len, data);\n}\n\nstatic inline int32_t\nunzigzag32(uint32_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn (int32_t)((v >> 1) ^ -(v & 1));\n}\n\nstatic inline uint32_t\nparse_fixed_uint32(const uint8_t *data)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tuint32_t t;\n\tmemcpy(&t, data, 4);\n\treturn t;\n#else\n\treturn data[0] |\n\t\t((uint32_t) (data[1]) << 8) |\n\t\t((uint32_t) (data[2]) << 16) |\n\t\t((uint32_t) (data[3]) << 24);\n#endif\n}\n\nstatic uint64_t\nparse_uint64(unsigned len, const uint8_t *data)\n{\n\tunsigned shift, i;\n\tuint64_t rv;\n\n\tif (len < 5)\n\t\treturn parse_uint32(len, data);\n\trv = ((uint64_t) (data[0] & 0x7f)) |\n\t\t((uint64_t) (data[1] & 0x7f) << 7) |\n\t\t((uint64_t) (data[2] & 0x7f) << 14) |\n\t\t((uint64_t) (data[3] & 0x7f) << 21);\n\tshift = 28;\n\tfor (i = 4; i < len; i++) {\n\t\trv |= (((uint64_t) (data[i] & 0x7f)) << shift);\n\t\tshift += 7;\n\t}\n\treturn rv;\n}\n\nstatic inline int64_t\nunzigzag64(uint64_t v)\n{\n\t// Note:  Using unsigned types prevents undefined behavior\n\treturn (int64_t)((v >> 1) ^ -(v & 1));\n}\n\nstatic inline uint64_t\nparse_fixed_uint64(const uint8_t *data)\n{\n#if !defined(WORDS_BIGENDIAN)\n\tuint64_t t;\n\tmemcpy(&t, data, 8);\n\treturn t;\n#else\n\treturn (uint64_t) parse_fixed_uint32(data) |\n\t\t(((uint64_t) parse_fixed_uint32(data + 4)) << 32);\n#endif\n}\n\nstatic protobuf_c_boolean\nparse_boolean(unsigned len, const uint8_t *data)\n{\n\tunsigned i;\n\tfor (i = 0; i < len; i++)\n\t\tif (data[i] & 0x7f)\n\t\t\treturn TRUE;\n\treturn FALSE;\n}\n\nstatic protobuf_c_boolean\nparse_required_member(ScannedMember *scanned_member,\n\t\t      void *member,\n\t\t      ProtobufCAllocator *allocator,\n\t\t      protobuf_c_boolean maybe_clear)\n{\n\tunsigned len = scanned_member->len;\n\tconst uint8_t *data = scanned_member->data;\n\tuint8_t wire_type = scanned_member->wire_type;\n\n\tswitch (scanned_member->field->type) {\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(int32_t *) member = parse_int32(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(uint32_t *) member = parse_uint32(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(int32_t *) member = unzigzag32(parse_uint32(len, data));\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_32BIT)\n\t\t\treturn FALSE;\n\t\t*(uint32_t *) member = parse_fixed_uint32(data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(uint64_t *) member = parse_uint64(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_VARINT)\n\t\t\treturn FALSE;\n\t\t*(int64_t *) member = unzigzag64(parse_uint64(len, data));\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_64BIT)\n\t\t\treturn FALSE;\n\t\t*(uint64_t *) member = parse_fixed_uint64(data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t*(protobuf_c_boolean *) member = parse_boolean(len, data);\n\t\treturn TRUE;\n\tcase PROTOBUF_C_TYPE_STRING: {\n\t\tchar **pstr = member;\n\t\tunsigned pref_len = scanned_member->length_prefix_len;\n\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)\n\t\t\treturn FALSE;\n\n\t\tif (maybe_clear && *pstr != NULL) {\n\t\t\tconst char *def = scanned_member->field->default_value;\n\t\t\tif (*pstr != NULL && *pstr != def)\n\t\t\t\tdo_free(allocator, *pstr);\n\t\t}\n\t\t*pstr = do_alloc(allocator, len - pref_len + 1);\n\t\tif (*pstr == NULL)\n\t\t\treturn FALSE;\n\t\tmemcpy(*pstr, data + pref_len, len - pref_len);\n\t\t(*pstr)[len - pref_len] = 0;\n\t\treturn TRUE;\n\t}\n\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\tProtobufCBinaryData *bd = member;\n\t\tconst ProtobufCBinaryData *def_bd;\n\t\tunsigned pref_len = scanned_member->length_prefix_len;\n\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)\n\t\t\treturn FALSE;\n\n\t\tdef_bd = scanned_member->field->default_value;\n\t\tif (maybe_clear &&\n\t\t    bd->data != NULL &&\n\t\t    (def_bd == NULL || bd->data != def_bd->data))\n\t\t{\n\t\t\tdo_free(allocator, bd->data);\n\t\t}\n\t\tif (len > pref_len) {\n\t\t\tbd->data = do_alloc(allocator, len - pref_len);\n\t\t\tif (bd->data == NULL)\n\t\t\t\treturn FALSE;\n\t\t\tmemcpy(bd->data, data + pref_len, len - pref_len);\n\t\t} else {\n\t\t\tbd->data = NULL;\n\t\t}\n\t\tbd->len = len - pref_len;\n\t\treturn TRUE;\n\t}\n\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\tProtobufCMessage **pmessage = member;\n\t\tProtobufCMessage *subm;\n\t\tconst ProtobufCMessage *def_mess;\n\t\tprotobuf_c_boolean merge_successful = TRUE;\n\t\tunsigned pref_len = scanned_member->length_prefix_len;\n\n\t\tif (wire_type != PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED)\n\t\t\treturn FALSE;\n\n\t\tdef_mess = scanned_member->field->default_value;\n\t\tif (len >= pref_len)\n\t\t\tsubm = protobuf_c_message_unpack(scanned_member->field->descriptor,\n\t\t\t\t\t\t\t allocator,\n\t\t\t\t\t\t\t len - pref_len,\n\t\t\t\t\t\t\t data + pref_len);\n\t\telse\n\t\t\tsubm = NULL;\n\n\t\tif (maybe_clear &&\n\t\t    *pmessage != NULL &&\n\t\t    *pmessage != def_mess)\n\t\t{\n\t\t\tif (subm != NULL)\n\t\t\t\tmerge_successful = merge_messages(*pmessage, subm, allocator);\n\t\t\t/* Delete the previous message */\n\t\t\tprotobuf_c_message_free_unpacked(*pmessage, allocator);\n\t\t}\n\t\t*pmessage = subm;\n\t\tif (subm == NULL || !merge_successful)\n\t\t\treturn FALSE;\n\t\treturn TRUE;\n\t}\n\t}\n\treturn FALSE;\n}\n\nstatic protobuf_c_boolean\nparse_oneof_member (ScannedMember *scanned_member,\n\t\t    void *member,\n\t\t    ProtobufCMessage *message,\n\t\t    ProtobufCAllocator *allocator)\n{\n\tuint32_t *oneof_case = STRUCT_MEMBER_PTR(uint32_t, message,\n\t\t\t\t\t       scanned_member->field->quantifier_offset);\n\n\t/* If we have already parsed a member of this oneof, free it. */\n\tif (*oneof_case != 0) {\n\t\tconst ProtobufCFieldDescriptor *old_field;\n\t\tsize_t el_size;\n\t\t/* lookup field */\n\t\tint field_index =\n\t\t\tint_range_lookup(message->descriptor->n_field_ranges,\n\t\t\t\t\t message->descriptor->field_ranges,\n\t\t\t\t\t *oneof_case);\n\t\tif (field_index < 0)\n\t\t\treturn FALSE;\n\t\told_field = message->descriptor->fields + field_index;\n\t\tel_size = sizeof_elt_in_repeated_array(old_field->type);\n\n\t\tswitch (old_field->type) {\n\t        case PROTOBUF_C_TYPE_STRING: {\n\t\t\tchar **pstr = member;\n\t\t\tconst char *def = old_field->default_value;\n\t\t\tif (*pstr != NULL && *pstr != def)\n\t\t\t\tdo_free(allocator, *pstr);\n\t\t\tbreak;\n\t        }\n\t\tcase PROTOBUF_C_TYPE_BYTES: {\n\t\t\tProtobufCBinaryData *bd = member;\n\t\t\tconst ProtobufCBinaryData *def_bd = old_field->default_value;\n\t\t\tif (bd->data != NULL &&\n\t\t\t   (def_bd == NULL || bd->data != def_bd->data))\n\t\t\t{\n\t\t\t\tdo_free(allocator, bd->data);\n\t\t\t}\n\t\t\tbreak;\n\t        }\n\t\tcase PROTOBUF_C_TYPE_MESSAGE: {\n\t\t\tProtobufCMessage **pmessage = member;\n\t\t\tconst ProtobufCMessage *def_mess = old_field->default_value;\n\t\t\tif (*pmessage != NULL && *pmessage != def_mess)\n\t\t\t\tprotobuf_c_message_free_unpacked(*pmessage, allocator);\n\t\t\tbreak;\n\t        }\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset (member, 0, el_size);\n\t}\n\tif (!parse_required_member (scanned_member, member, allocator, TRUE))\n\t\treturn FALSE;\n\n\t*oneof_case = scanned_member->tag;\n\treturn TRUE;\n}\n\n\nstatic protobuf_c_boolean\nparse_optional_member(ScannedMember *scanned_member,\n\t\t      void *member,\n\t\t      ProtobufCMessage *message,\n\t\t      ProtobufCAllocator *allocator)\n{\n\tif (!parse_required_member(scanned_member, member, allocator, TRUE))\n\t\treturn FALSE;\n\tif (scanned_member->field->quantifier_offset != 0)\n\t\tSTRUCT_MEMBER(protobuf_c_boolean,\n\t\t\t      message,\n\t\t\t      scanned_member->field->quantifier_offset) = TRUE;\n\treturn TRUE;\n}\n\nstatic protobuf_c_boolean\nparse_repeated_member(ScannedMember *scanned_member,\n\t\t      void *member,\n\t\t      ProtobufCMessage *message,\n\t\t      ProtobufCAllocator *allocator)\n{\n\tconst ProtobufCFieldDescriptor *field = scanned_member->field;\n\tsize_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);\n\tsize_t siz = sizeof_elt_in_repeated_array(field->type);\n\tchar *array = *(char **) member;\n\n\tif (!parse_required_member(scanned_member, array + siz * (*p_n),\n\t\t\t\t   allocator, FALSE))\n\t{\n\t\treturn FALSE;\n\t}\n\t*p_n += 1;\n\treturn TRUE;\n}\n\nstatic unsigned\nscan_varint(unsigned len, const uint8_t *data)\n{\n\tunsigned i;\n\tif (len > 10)\n\t\tlen = 10;\n\tfor (i = 0; i < len; i++)\n\t\tif ((data[i] & 0x80) == 0)\n\t\t\tbreak;\n\tif (i == len)\n\t\treturn 0;\n\treturn i + 1;\n}\n\nstatic protobuf_c_boolean\nparse_packed_repeated_member(ScannedMember *scanned_member,\n\t\t\t     void *member,\n\t\t\t     ProtobufCMessage *message)\n{\n\tconst ProtobufCFieldDescriptor *field = scanned_member->field;\n\tsize_t *p_n = STRUCT_MEMBER_PTR(size_t, message, field->quantifier_offset);\n\tsize_t siz = sizeof_elt_in_repeated_array(field->type);\n\tvoid *array = *(char **) member + siz * (*p_n);\n\tconst uint8_t *at = scanned_member->data + scanned_member->length_prefix_len;\n\tsize_t rem = scanned_member->len - scanned_member->length_prefix_len;\n\tsize_t count = 0;\n#if defined(WORDS_BIGENDIAN)\n\tunsigned i;\n#endif\n\n\tswitch (field->type) {\n\tcase PROTOBUF_C_TYPE_SFIXED32:\n\tcase PROTOBUF_C_TYPE_FIXED32:\n\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\tcount = (scanned_member->len - scanned_member->length_prefix_len) / 4;\n#if !defined(WORDS_BIGENDIAN)\n\t\tgoto no_unpacking_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t((uint32_t *) array)[i] = parse_fixed_uint32(at);\n\t\t\tat += 4;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_SFIXED64:\n\tcase PROTOBUF_C_TYPE_FIXED64:\n\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\tcount = (scanned_member->len - scanned_member->length_prefix_len) / 8;\n#if !defined(WORDS_BIGENDIAN)\n\t\tgoto no_unpacking_needed;\n#else\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t((uint64_t *) array)[i] = parse_fixed_uint64(at);\n\t\t\tat += 8;\n\t\t}\n\t\tbreak;\n#endif\n\tcase PROTOBUF_C_TYPE_ENUM:\n\tcase PROTOBUF_C_TYPE_INT32:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated int32 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int32_t *) array)[count++] = parse_int32(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_SINT32:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated sint32 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int32_t *) array)[count++] = unzigzag32(parse_uint32(s, at));\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_UINT32:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated enum or uint32 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((uint32_t *) array)[count++] = parse_uint32(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\n\tcase PROTOBUF_C_TYPE_SINT64:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated sint64 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int64_t *) array)[count++] = unzigzag64(parse_uint64(s, at));\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_INT64:\n\tcase PROTOBUF_C_TYPE_UINT64:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated int64/uint64 value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((int64_t *) array)[count++] = parse_uint64(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tcase PROTOBUF_C_TYPE_BOOL:\n\t\twhile (rem > 0) {\n\t\t\tunsigned s = scan_varint(rem, at);\n\t\t\tif (s == 0) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"bad packed-repeated boolean value\");\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\t((protobuf_c_boolean *) array)[count++] = parse_boolean(s, at);\n\t\t\tat += s;\n\t\t\trem -= s;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\t}\n\t*p_n += count;\n\treturn TRUE;\n\n#if !defined(WORDS_BIGENDIAN)\nno_unpacking_needed:\n\tmemcpy(array, at, count * siz);\n\t*p_n += count;\n\treturn TRUE;\n#endif\n}\n\nstatic protobuf_c_boolean\nis_packable_type(ProtobufCType type)\n{\n\treturn\n\t\ttype != PROTOBUF_C_TYPE_STRING &&\n\t\ttype != PROTOBUF_C_TYPE_BYTES &&\n\t\ttype != PROTOBUF_C_TYPE_MESSAGE;\n}\n\nstatic protobuf_c_boolean\nparse_member(ScannedMember *scanned_member,\n\t     ProtobufCMessage *message,\n\t     ProtobufCAllocator *allocator)\n{\n\tconst ProtobufCFieldDescriptor *field = scanned_member->field;\n\tvoid *member;\n\n\tif (field == NULL) {\n\t\tProtobufCMessageUnknownField *ufield =\n\t\t\tmessage->unknown_fields +\n\t\t\t(message->n_unknown_fields++);\n\t\tufield->tag = scanned_member->tag;\n\t\tufield->wire_type = scanned_member->wire_type;\n\t\tufield->len = scanned_member->len;\n\t\tufield->data = do_alloc(allocator, scanned_member->len);\n\t\tif (ufield->data == NULL)\n\t\t\treturn FALSE;\n\t\tmemcpy(ufield->data, scanned_member->data, ufield->len);\n\t\treturn TRUE;\n\t}\n\tmember = (char *) message + field->offset;\n\tswitch (field->label) {\n\tcase PROTOBUF_C_LABEL_REQUIRED:\n\t\treturn parse_required_member(scanned_member, member,\n\t\t\t\t\t     allocator, TRUE);\n\tcase PROTOBUF_C_LABEL_OPTIONAL:\n\tcase PROTOBUF_C_LABEL_NONE:\n\t\tif (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF)) {\n\t\t\treturn parse_oneof_member(scanned_member, member,\n\t\t\t\t\t\t  message, allocator);\n\t\t} else {\n\t\t\treturn parse_optional_member(scanned_member, member,\n\t\t\t\t\t\t     message, allocator);\n\t\t}\n\tcase PROTOBUF_C_LABEL_REPEATED:\n\t\tif (scanned_member->wire_type ==\n\t\t    PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&\n\t\t    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||\n\t\t     is_packable_type(field->type)))\n\t\t{\n\t\t\treturn parse_packed_repeated_member(scanned_member,\n\t\t\t\t\t\t\t    member, message);\n\t\t} else {\n\t\t\treturn parse_repeated_member(scanned_member,\n\t\t\t\t\t\t     member, message,\n\t\t\t\t\t\t     allocator);\n\t\t}\n\t}\n\tPROTOBUF_C__ASSERT_NOT_REACHED();\n\treturn 0;\n}\n\n/**\n * Initialise messages generated by old code.\n *\n * This function is used if desc->message_init == NULL (which occurs\n * for old code, and which would be useful to support allocating\n * descriptors dynamically).\n */\nstatic void\nmessage_init_generic(const ProtobufCMessageDescriptor *desc,\n\t\t     ProtobufCMessage *message)\n{\n\tunsigned i;\n\n\tmemset(message, 0, desc->sizeof_message);\n\tmessage->descriptor = desc;\n\tfor (i = 0; i < desc->n_fields; i++) {\n\t\tif (desc->fields[i].default_value != NULL &&\n\t\t    desc->fields[i].label != PROTOBUF_C_LABEL_REPEATED)\n\t\t{\n\t\t\tvoid *field =\n\t\t\t\tSTRUCT_MEMBER_P(message, desc->fields[i].offset);\n\t\t\tconst void *dv = desc->fields[i].default_value;\n\n\t\t\tswitch (desc->fields[i].type) {\n\t\t\tcase PROTOBUF_C_TYPE_INT32:\n\t\t\tcase PROTOBUF_C_TYPE_SINT32:\n\t\t\tcase PROTOBUF_C_TYPE_SFIXED32:\n\t\t\tcase PROTOBUF_C_TYPE_UINT32:\n\t\t\tcase PROTOBUF_C_TYPE_FIXED32:\n\t\t\tcase PROTOBUF_C_TYPE_FLOAT:\n\t\t\tcase PROTOBUF_C_TYPE_ENUM:\n\t\t\t\tmemcpy(field, dv, 4);\n\t\t\t\tbreak;\n\t\t\tcase PROTOBUF_C_TYPE_INT64:\n\t\t\tcase PROTOBUF_C_TYPE_SINT64:\n\t\t\tcase PROTOBUF_C_TYPE_SFIXED64:\n\t\t\tcase PROTOBUF_C_TYPE_UINT64:\n\t\t\tcase PROTOBUF_C_TYPE_FIXED64:\n\t\t\tcase PROTOBUF_C_TYPE_DOUBLE:\n\t\t\t\tmemcpy(field, dv, 8);\n\t\t\t\tbreak;\n\t\t\tcase PROTOBUF_C_TYPE_BOOL:\n\t\t\t\tmemcpy(field, dv, sizeof(protobuf_c_boolean));\n\t\t\t\tbreak;\n\t\t\tcase PROTOBUF_C_TYPE_BYTES:\n\t\t\t\tmemcpy(field, dv, sizeof(ProtobufCBinaryData));\n\t\t\t\tbreak;\n\n\t\t\tcase PROTOBUF_C_TYPE_STRING:\n\t\t\tcase PROTOBUF_C_TYPE_MESSAGE:\n\t\t\t\t/*\n\t\t\t\t * The next line essentially implements a cast\n\t\t\t\t * from const, which is totally unavoidable.\n\t\t\t\t */\n\t\t\t\t*(const void **) field = dv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**@}*/\n\n/*\n * ScannedMember slabs (an unpacking implementation detail). Before doing real\n * unpacking, we first scan through the elements to see how many there are (for\n * repeated fields), and which field to use (for non-repeated fields given\n * twice).\n *\n * In order to avoid allocations for small messages, we keep a stack-allocated\n * slab of ScannedMembers of size FIRST_SCANNED_MEMBER_SLAB_SIZE (16). After we\n * fill that up, we allocate each slab twice as large as the previous one.\n */\n#define FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2 4\n\n/*\n * The number of slabs, including the stack-allocated ones; choose the number so\n * that we would overflow if we needed a slab larger than provided.\n */\n#define MAX_SCANNED_MEMBER_SLAB\t\t\t\\\n  (sizeof(unsigned int)*8 - 1\t\t\t\\\n   - BOUND_SIZEOF_SCANNED_MEMBER_LOG2\t\t\\\n   - FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2)\n\n#define REQUIRED_FIELD_BITMAP_SET(index)\t\\\n\t(required_fields_bitmap[(index)/8] |= (1UL<<((index)%8)))\n\n#define REQUIRED_FIELD_BITMAP_IS_SET(index)\t\\\n\t(required_fields_bitmap[(index)/8] & (1UL<<((index)%8)))\n\nProtobufCMessage *\nprotobuf_c_message_unpack(const ProtobufCMessageDescriptor *desc,\n\t\t\t  ProtobufCAllocator *allocator,\n\t\t\t  size_t len, const uint8_t *data)\n{\n\tProtobufCMessage *rv;\n\tsize_t rem = len;\n\tconst uint8_t *at = data;\n\tconst ProtobufCFieldDescriptor *last_field = desc->fields + 0;\n\tScannedMember first_member_slab[1UL <<\n\t\t\t\t\tFIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2];\n\n\t/*\n\t * scanned_member_slabs[i] is an array of arrays of ScannedMember.\n\t * The first slab (scanned_member_slabs[0] is just a pointer to\n\t * first_member_slab), above. All subsequent slabs will be allocated\n\t * using the allocator.\n\t */\n\tScannedMember *scanned_member_slabs[MAX_SCANNED_MEMBER_SLAB + 1];\n\tunsigned which_slab = 0; /* the slab we are currently populating */\n\tunsigned in_slab_index = 0; /* number of members in the slab */\n\tsize_t n_unknown = 0;\n\tunsigned f;\n\tunsigned j;\n\tunsigned i_slab;\n\tunsigned last_field_index = 0;\n\tunsigned required_fields_bitmap_len;\n\tunsigned char required_fields_bitmap_stack[16];\n\tunsigned char *required_fields_bitmap = required_fields_bitmap_stack;\n\tprotobuf_c_boolean required_fields_bitmap_alloced = FALSE;\n\n\tASSERT_IS_MESSAGE_DESCRIPTOR(desc);\n\n\tif (allocator == NULL)\n\t\tallocator = &protobuf_c__allocator;\n\n\trv = do_alloc(allocator, desc->sizeof_message);\n\tif (!rv)\n\t\treturn (NULL);\n\tscanned_member_slabs[0] = first_member_slab;\n\n\trequired_fields_bitmap_len = (desc->n_fields + 7) / 8;\n\tif (required_fields_bitmap_len > sizeof(required_fields_bitmap_stack)) {\n\t\trequired_fields_bitmap = do_alloc(allocator, required_fields_bitmap_len);\n\t\tif (!required_fields_bitmap) {\n\t\t\tdo_free(allocator, rv);\n\t\t\treturn (NULL);\n\t\t}\n\t\trequired_fields_bitmap_alloced = TRUE;\n\t}\n\tmemset(required_fields_bitmap, 0, required_fields_bitmap_len);\n\n\t/*\n\t * Generated code always defines \"message_init\". However, we provide a\n\t * fallback for (1) users of old protobuf-c generated-code that do not\n\t * provide the function, and (2) descriptors constructed from some other\n\t * source (most likely, direct construction from the .proto file).\n\t */\n\tif (desc->message_init != NULL)\n\t\tprotobuf_c_message_init(desc, rv);\n\telse\n\t\tmessage_init_generic(desc, rv);\n\n\twhile (rem > 0) {\n\t\tuint32_t tag;\n\t\tuint8_t wire_type;\n\t\tsize_t used = parse_tag_and_wiretype(rem, at, &tag, &wire_type);\n\t\tconst ProtobufCFieldDescriptor *field;\n\t\tScannedMember tmp;\n\n\t\tif (used == 0) {\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing tag/wiretype at offset %u\",\n\t\t\t\t\t\t(unsigned) (at - data));\n\t\t\tgoto error_cleanup_during_scan;\n\t\t}\n\t\t/*\n\t\t * \\todo Consider optimizing for field[1].id == tag, if field[1]\n\t\t * exists!\n\t\t */\n\t\tif (last_field == NULL || last_field->id != tag) {\n\t\t\t/* lookup field */\n\t\t\tint field_index =\n\t\t\t    int_range_lookup(desc->n_field_ranges,\n\t\t\t\t\t     desc->field_ranges,\n\t\t\t\t\t     tag);\n\t\t\tif (field_index < 0) {\n\t\t\t\tfield = NULL;\n\t\t\t\tn_unknown++;\n\t\t\t} else {\n\t\t\t\tfield = desc->fields + field_index;\n\t\t\t\tlast_field = field;\n\t\t\t\tlast_field_index = field_index;\n\t\t\t}\n\t\t} else {\n\t\t\tfield = last_field;\n\t\t}\n\n\t\tif (field != NULL && field->label == PROTOBUF_C_LABEL_REQUIRED)\n\t\t\tREQUIRED_FIELD_BITMAP_SET(last_field_index);\n\n\t\tat += used;\n\t\trem -= used;\n\t\ttmp.tag = tag;\n\t\ttmp.wire_type = wire_type;\n\t\ttmp.field = field;\n\t\ttmp.data = at;\n\t\ttmp.length_prefix_len = 0;\n\n\t\tswitch (wire_type) {\n\t\tcase PROTOBUF_C_WIRE_TYPE_VARINT: {\n\t\t\tunsigned max_len = rem < 10 ? rem : 10;\n\t\t\tunsigned i;\n\n\t\t\tfor (i = 0; i < max_len; i++)\n\t\t\t\tif ((at[i] & 0x80) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (i == max_len) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"unterminated varint at offset %u\",\n\t\t\t\t\t\t\t(unsigned) (at - data));\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.len = i + 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_WIRE_TYPE_64BIT:\n\t\t\tif (rem < 8) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"too short after 64bit wiretype at offset %u\",\n\t\t\t\t\t\t\t(unsigned) (at - data));\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.len = 8;\n\t\t\tbreak;\n\t\tcase PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED: {\n\t\t\tsize_t pref_len;\n\n\t\t\ttmp.len = scan_length_prefixed_data(rem, at, &pref_len);\n\t\t\tif (tmp.len == 0) {\n\t\t\t\t/* NOTE: scan_length_prefixed_data calls UNPACK_ERROR */\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.length_prefix_len = pref_len;\n\t\t\tbreak;\n\t\t}\n\t\tcase PROTOBUF_C_WIRE_TYPE_32BIT:\n\t\t\tif (rem < 4) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"too short after 32bit wiretype at offset %u\",\n\t\t\t\t\t      (unsigned) (at - data));\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\ttmp.len = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tPROTOBUF_C_UNPACK_ERROR(\"unsupported tag %u at offset %u\",\n\t\t\t\t\t\twire_type, (unsigned) (at - data));\n\t\t\tgoto error_cleanup_during_scan;\n\t\t}\n\n\t\tif (in_slab_index == (1UL <<\n\t\t\t(which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2)))\n\t\t{\n\t\t\tsize_t size;\n\n\t\t\tin_slab_index = 0;\n\t\t\tif (which_slab == MAX_SCANNED_MEMBER_SLAB) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"too many fields\");\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t}\n\t\t\twhich_slab++;\n\t\t\tsize = sizeof(ScannedMember)\n\t\t\t\t<< (which_slab + FIRST_SCANNED_MEMBER_SLAB_SIZE_LOG2);\n\t\t\tscanned_member_slabs[which_slab] = do_alloc(allocator, size);\n\t\t\tif (scanned_member_slabs[which_slab] == NULL)\n\t\t\t\tgoto error_cleanup_during_scan;\n\t\t}\n\t\tscanned_member_slabs[which_slab][in_slab_index++] = tmp;\n\n\t\tif (field != NULL && field->label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *n = STRUCT_MEMBER_PTR(size_t, rv,\n\t\t\t\t\t\t      field->quantifier_offset);\n\t\t\tif (wire_type == PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED &&\n\t\t\t    (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_PACKED) ||\n\t\t\t     is_packable_type(field->type)))\n\t\t\t{\n\t\t\t\tsize_t count;\n\t\t\t\tif (!count_packed_elements(field->type,\n\t\t\t\t\t\t\t   tmp.len -\n\t\t\t\t\t\t\t   tmp.length_prefix_len,\n\t\t\t\t\t\t\t   tmp.data +\n\t\t\t\t\t\t\t   tmp.length_prefix_len,\n\t\t\t\t\t\t\t   &count))\n\t\t\t\t{\n\t\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"counting packed elements\");\n\t\t\t\t\tgoto error_cleanup_during_scan;\n\t\t\t\t}\n\t\t\t\t*n += count;\n\t\t\t} else {\n\t\t\t\t*n += 1;\n\t\t\t}\n\t\t}\n\n\t\tat += tmp.len;\n\t\trem -= tmp.len;\n\t}\n\n\t/* allocate space for repeated fields, also check that all required fields have been set */\n\tfor (f = 0; f < desc->n_fields; f++) {\n\t\tconst ProtobufCFieldDescriptor *field = desc->fields + f;\n\t\tif (field->label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t siz =\n\t\t\t    sizeof_elt_in_repeated_array(field->type);\n\t\t\tsize_t *n_ptr =\n\t\t\t    STRUCT_MEMBER_PTR(size_t, rv,\n\t\t\t\t\t      field->quantifier_offset);\n\t\t\tif (*n_ptr != 0) {\n\t\t\t\tunsigned n = *n_ptr;\n\t\t\t\tvoid *a;\n\t\t\t\t*n_ptr = 0;\n\t\t\t\tassert(rv->descriptor != NULL);\n#define CLEAR_REMAINING_N_PTRS()                                              \\\n              for(f++;f < desc->n_fields; f++)                                \\\n                {                                                             \\\n                  field = desc->fields + f;                                   \\\n                  if (field->label == PROTOBUF_C_LABEL_REPEATED)              \\\n                    STRUCT_MEMBER (size_t, rv, field->quantifier_offset) = 0; \\\n                }\n\t\t\t\ta = do_alloc(allocator, siz * n);\n\t\t\t\tif (!a) {\n\t\t\t\t\tCLEAR_REMAINING_N_PTRS();\n\t\t\t\t\tgoto error_cleanup;\n\t\t\t\t}\n\t\t\t\tSTRUCT_MEMBER(void *, rv, field->offset) = a;\n\t\t\t}\n\t\t} else if (field->label == PROTOBUF_C_LABEL_REQUIRED) {\n\t\t\tif (field->default_value == NULL &&\n\t\t\t    !REQUIRED_FIELD_BITMAP_IS_SET(f))\n\t\t\t{\n\t\t\t\tCLEAR_REMAINING_N_PTRS();\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"message '%s': missing required field '%s'\",\n\t\t\t\t\t\t\tdesc->name, field->name);\n\t\t\t\tgoto error_cleanup;\n\t\t\t}\n\t\t}\n\t}\n#undef CLEAR_REMAINING_N_PTRS\n\n\t/* allocate space for unknown fields */\n\tif (n_unknown) {\n\t\trv->unknown_fields = do_alloc(allocator,\n\t\t\t\t\t      n_unknown * sizeof(ProtobufCMessageUnknownField));\n\t\tif (rv->unknown_fields == NULL)\n\t\t\tgoto error_cleanup;\n\t}\n\n\t/* do real parsing */\n\tfor (i_slab = 0; i_slab <= which_slab; i_slab++) {\n\t\tunsigned max = (i_slab == which_slab) ?\n\t\t\tin_slab_index : (1UL << (i_slab + 4));\n\t\tScannedMember *slab = scanned_member_slabs[i_slab];\n\n\t\tfor (j = 0; j < max; j++) {\n\t\t\tif (!parse_member(slab + j, rv, allocator)) {\n\t\t\t\tPROTOBUF_C_UNPACK_ERROR(\"error parsing member %s of %s\",\n\t\t\t\t\t\t\tslab->field ? slab->field->name : \"*unknown-field*\",\n\t\t\t\t\tdesc->name);\n\t\t\t\tgoto error_cleanup;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* cleanup */\n\tfor (j = 1; j <= which_slab; j++)\n\t\tdo_free(allocator, scanned_member_slabs[j]);\n\tif (required_fields_bitmap_alloced)\n\t\tdo_free(allocator, required_fields_bitmap);\n\treturn rv;\n\nerror_cleanup:\n\tprotobuf_c_message_free_unpacked(rv, allocator);\n\tfor (j = 1; j <= which_slab; j++)\n\t\tdo_free(allocator, scanned_member_slabs[j]);\n\tif (required_fields_bitmap_alloced)\n\t\tdo_free(allocator, required_fields_bitmap);\n\treturn NULL;\n\nerror_cleanup_during_scan:\n\tdo_free(allocator, rv);\n\tfor (j = 1; j <= which_slab; j++)\n\t\tdo_free(allocator, scanned_member_slabs[j]);\n\tif (required_fields_bitmap_alloced)\n\t\tdo_free(allocator, required_fields_bitmap);\n\treturn NULL;\n}\n\nvoid\nprotobuf_c_message_free_unpacked(ProtobufCMessage *message,\n\t\t\t\t ProtobufCAllocator *allocator)\n{\n\tconst ProtobufCMessageDescriptor *desc;\n\tunsigned f;\n\n\tif (message == NULL)\n\t\treturn;\n\n\tdesc = message->descriptor;\n\n\tASSERT_IS_MESSAGE(message);\n\n\tif (allocator == NULL)\n\t\tallocator = &protobuf_c__allocator;\n\tmessage->descriptor = NULL;\n\tfor (f = 0; f < desc->n_fields; f++) {\n\t\tif (0 != (desc->fields[f].flags & PROTOBUF_C_FIELD_FLAG_ONEOF) &&\n\t\t    desc->fields[f].id !=\n\t\t    STRUCT_MEMBER(uint32_t, message, desc->fields[f].quantifier_offset))\n\t\t{\n\t\t\t/* This is not the selected oneof, skip it */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (desc->fields[f].label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t n = STRUCT_MEMBER(size_t,\n\t\t\t\t\t\t message,\n\t\t\t\t\t\t desc->fields[f].quantifier_offset);\n\t\t\tvoid *arr = STRUCT_MEMBER(void *,\n\t\t\t\t\t\t  message,\n\t\t\t\t\t\t  desc->fields[f].offset);\n\n\t\t\tif (arr != NULL) {\n\t\t\t\tif (desc->fields[f].type == PROTOBUF_C_TYPE_STRING) {\n\t\t\t\t\tunsigned i;\n\t\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t\tdo_free(allocator, ((char **) arr)[i]);\n\t\t\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\t\t\tunsigned i;\n\t\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t\tdo_free(allocator, ((ProtobufCBinaryData *) arr)[i].data);\n\t\t\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\t\t\tunsigned i;\n\t\t\t\t\tfor (i = 0; i < n; i++)\n\t\t\t\t\t\tprotobuf_c_message_free_unpacked(\n\t\t\t\t\t\t\t((ProtobufCMessage **) arr)[i],\n\t\t\t\t\t\t\tallocator\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tdo_free(allocator, arr);\n\t\t\t}\n\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_STRING) {\n\t\t\tchar *str = STRUCT_MEMBER(char *, message,\n\t\t\t\t\t\t  desc->fields[f].offset);\n\n\t\t\tif (str && str != desc->fields[f].default_value)\n\t\t\t\tdo_free(allocator, str);\n\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\tvoid *data = STRUCT_MEMBER(ProtobufCBinaryData, message,\n\t\t\t\t\t\t   desc->fields[f].offset).data;\n\t\t\tconst ProtobufCBinaryData *default_bd;\n\n\t\t\tdefault_bd = desc->fields[f].default_value;\n\t\t\tif (data != NULL &&\n\t\t\t    (default_bd == NULL ||\n\t\t\t     default_bd->data != data))\n\t\t\t{\n\t\t\t\tdo_free(allocator, data);\n\t\t\t}\n\t\t} else if (desc->fields[f].type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\tProtobufCMessage *sm;\n\n\t\t\tsm = STRUCT_MEMBER(ProtobufCMessage *, message,\n\t\t\t\t\t   desc->fields[f].offset);\n\t\t\tif (sm && sm != desc->fields[f].default_value)\n\t\t\t\tprotobuf_c_message_free_unpacked(sm, allocator);\n\t\t}\n\t}\n\n\tfor (f = 0; f < message->n_unknown_fields; f++)\n\t\tdo_free(allocator, message->unknown_fields[f].data);\n\tif (message->unknown_fields != NULL)\n\t\tdo_free(allocator, message->unknown_fields);\n\n\tdo_free(allocator, message);\n}\n\nvoid\nprotobuf_c_message_init(const ProtobufCMessageDescriptor * descriptor,\n\t\t\tvoid *message)\n{\n\tdescriptor->message_init((ProtobufCMessage *) (message));\n}\n\nprotobuf_c_boolean\nprotobuf_c_message_check(const ProtobufCMessage *message)\n{\n\tunsigned i;\n\n\tif (!message ||\n\t    !message->descriptor ||\n\t    message->descriptor->magic != PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tfor (i = 0; i < message->descriptor->n_fields; i++) {\n\t\tconst ProtobufCFieldDescriptor *f = message->descriptor->fields + i;\n\t\tProtobufCType type = f->type;\n\t\tProtobufCLabel label = f->label;\n\t\tvoid *field = STRUCT_MEMBER_P (message, f->offset);\n\n\t\tif (f->flags & PROTOBUF_C_FIELD_FLAG_ONEOF) {\n\t\t\tconst uint32_t *oneof_case = STRUCT_MEMBER_P (message, f->quantifier_offset);\n\t\t\tif (f->id != *oneof_case) {\n\t\t\t\tcontinue; //Do not check if it is an unpopulated oneof member.\n\t\t\t}\n\t\t}\n\n\t\tif (label == PROTOBUF_C_LABEL_REPEATED) {\n\t\t\tsize_t *quantity = STRUCT_MEMBER_P (message, f->quantifier_offset);\n\n\t\t\tif (*quantity > 0 && *(void **) field == NULL) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\t\tProtobufCMessage **submessage = *(ProtobufCMessage ***) field;\n\t\t\t\tunsigned j;\n\t\t\t\tfor (j = 0; j < *quantity; j++) {\n\t\t\t\t\tif (!protobuf_c_message_check(submessage[j]))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t} else if (type == PROTOBUF_C_TYPE_STRING) {\n\t\t\t\tchar **string = *(char ***) field;\n\t\t\t\tunsigned j;\n\t\t\t\tfor (j = 0; j < *quantity; j++) {\n\t\t\t\t\tif (!string[j])\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t} else if (type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\t\tProtobufCBinaryData *bd = *(ProtobufCBinaryData **) field;\n\t\t\t\tunsigned j;\n\t\t\t\tfor (j = 0; j < *quantity; j++) {\n\t\t\t\t\tif (bd[j].len > 0 && bd[j].data == NULL)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else { /* PROTOBUF_C_LABEL_REQUIRED or PROTOBUF_C_LABEL_OPTIONAL */\n\n\t\t\tif (type == PROTOBUF_C_TYPE_MESSAGE) {\n\t\t\t\tProtobufCMessage *submessage = *(ProtobufCMessage **) field;\n\t\t\t\tif (label == PROTOBUF_C_LABEL_REQUIRED || submessage != NULL) {\n\t\t\t\t\tif (!protobuf_c_message_check(submessage))\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t} else if (type == PROTOBUF_C_TYPE_STRING) {\n\t\t\t\tchar *string = *(char **) field;\n\t\t\t\tif (label == PROTOBUF_C_LABEL_REQUIRED && string == NULL)\n\t\t\t\t\treturn FALSE;\n\t\t\t} else if (type == PROTOBUF_C_TYPE_BYTES) {\n\t\t\t\tprotobuf_c_boolean *has = STRUCT_MEMBER_P (message, f->quantifier_offset);\n\t\t\t\tProtobufCBinaryData *bd = field;\n\t\t\t\tif (label == PROTOBUF_C_LABEL_REQUIRED || *has == TRUE) {\n\t\t\t\t\tif (bd->len > 0 && bd->data == NULL)\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\n/* === services === */\n\ntypedef void (*GenericHandler) (void *service,\n\t\t\t\tconst ProtobufCMessage *input,\n\t\t\t\tProtobufCClosure closure,\n\t\t\t\tvoid *closure_data);\nvoid\nprotobuf_c_service_invoke_internal(ProtobufCService *service,\n\t\t\t\t   unsigned method_index,\n\t\t\t\t   const ProtobufCMessage *input,\n\t\t\t\t   ProtobufCClosure closure,\n\t\t\t\t   void *closure_data)\n{\n\tGenericHandler *handlers;\n\tGenericHandler handler;\n\n\t/*\n\t * Verify that method_index is within range. If this fails, you are\n\t * likely invoking a newly added method on an old service. (Although\n\t * other memory corruption bugs can cause this assertion too.)\n\t */\n\tassert(method_index < service->descriptor->n_methods);\n\n\t/*\n\t * Get the array of virtual methods (which are enumerated by the\n\t * generated code).\n\t */\n\thandlers = (GenericHandler *) (service + 1);\n\n\t/*\n\t * Get our method and invoke it.\n\t * \\todo Seems like handler == NULL is a situation that needs handling.\n\t */\n\thandler = handlers[method_index];\n\t(*handler)(service, input, closure, closure_data);\n}\n\nvoid\nprotobuf_c_service_generated_init(ProtobufCService *service,\n\t\t\t\t  const ProtobufCServiceDescriptor *descriptor,\n\t\t\t\t  ProtobufCServiceDestroy destroy)\n{\n\tASSERT_IS_SERVICE_DESCRIPTOR(descriptor);\n\tservice->descriptor = descriptor;\n\tservice->destroy = destroy;\n\tservice->invoke = protobuf_c_service_invoke_internal;\n\tmemset(service + 1, 0, descriptor->n_methods * sizeof(GenericHandler));\n}\n\nvoid protobuf_c_service_destroy(ProtobufCService *service)\n{\n\tservice->destroy(service);\n}\n\n/* --- querying the descriptors --- */\n\nconst ProtobufCEnumValue *\nprotobuf_c_enum_descriptor_get_value_by_name(const ProtobufCEnumDescriptor *desc,\n\t\t\t\t\t     const char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\n\tif (desc == NULL || desc->values_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_value_names;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv = strcmp(desc->values_by_name[mid].name, name);\n\t\tif (rv == 0)\n\t\t\treturn desc->values + desc->values_by_name[mid].index;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tif (strcmp(desc->values_by_name[start].name, name) == 0)\n\t\treturn desc->values + desc->values_by_name[start].index;\n\treturn NULL;\n}\n\nconst ProtobufCEnumValue *\nprotobuf_c_enum_descriptor_get_value(const ProtobufCEnumDescriptor *desc,\n\t\t\t\t     int value)\n{\n\tint rv = int_range_lookup(desc->n_value_ranges, desc->value_ranges, value);\n\tif (rv < 0)\n\t\treturn NULL;\n\treturn desc->values + rv;\n}\n\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field_by_name(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\tconst ProtobufCFieldDescriptor *field;\n\n\tif (desc == NULL || desc->fields_sorted_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_fields;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tint rv;\n\t\tfield = desc->fields + desc->fields_sorted_by_name[mid];\n\t\trv = strcmp(field->name, name);\n\t\tif (rv == 0)\n\t\t\treturn field;\n\t\telse if (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else\n\t\t\tcount = mid - start;\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tfield = desc->fields + desc->fields_sorted_by_name[start];\n\tif (strcmp(field->name, name) == 0)\n\t\treturn field;\n\treturn NULL;\n}\n\nconst ProtobufCFieldDescriptor *\nprotobuf_c_message_descriptor_get_field(const ProtobufCMessageDescriptor *desc,\n\t\t\t\t\tunsigned value)\n{\n\tint rv = int_range_lookup(desc->n_field_ranges,desc->field_ranges, value);\n\tif (rv < 0)\n\t\treturn NULL;\n\treturn desc->fields + rv;\n}\n\nconst ProtobufCMethodDescriptor *\nprotobuf_c_service_descriptor_get_method_by_name(const ProtobufCServiceDescriptor *desc,\n\t\t\t\t\t\t const char *name)\n{\n\tunsigned start = 0;\n\tunsigned count;\n\n\tif (desc == NULL || desc->method_indices_by_name == NULL)\n\t\treturn NULL;\n\n\tcount = desc->n_methods;\n\n\twhile (count > 1) {\n\t\tunsigned mid = start + count / 2;\n\t\tunsigned mid_index = desc->method_indices_by_name[mid];\n\t\tconst char *mid_name = desc->methods[mid_index].name;\n\t\tint rv = strcmp(mid_name, name);\n\n\t\tif (rv == 0)\n\t\t\treturn desc->methods + desc->method_indices_by_name[mid];\n\t\tif (rv < 0) {\n\t\t\tcount = start + count - (mid + 1);\n\t\t\tstart = mid + 1;\n\t\t} else {\n\t\t\tcount = mid - start;\n\t\t}\n\t}\n\tif (count == 0)\n\t\treturn NULL;\n\tif (strcmp(desc->methods[desc->method_indices_by_name[start]].name, name) == 0)\n\t\treturn desc->methods + desc->method_indices_by_name[start];\n\treturn NULL;\n}\n"], "filenames": ["protobuf-c/protobuf-c.c"], "buggy_code_start_loc": [2606], "buggy_code_end_loc": [2610], "fixing_code_start_loc": [2606], "fixing_code_end_loc": [2613], "type": "CWE-190", "message": "protobuf-c before 1.4.1 has an unsigned integer overflow in parse_required_member.", "other": {"cve": {"id": "CVE-2022-48468", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-13T21:15:07.077", "lastModified": "2023-04-29T07:15:07.207", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "protobuf-c before 1.4.1 has an unsigned integer overflow in parse_required_member."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:protobuf-c_project:protobuf-c:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.1", "matchCriteriaId": "036DA1F5-7D0A-427C-B29F-90FA388EBB1E"}]}]}], "references": [{"url": "https://github.com/protobuf-c/protobuf-c/commit/ec3d900001a13ccdaa8aef996b34c61159c76217", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/protobuf-c/protobuf-c/issues/499", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/protobuf-c/protobuf-c/pull/513", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/protobuf-c/protobuf-c/releases/tag/v1.4.1", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EI4JZSHJXW7WOOTAQSV5SUCC5GE2GC2B/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UGLZZYPOLI733DPETL444E3GY5KSS6LG/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VNUEZZEPR2F6M67ANXLOPJX6AQL3TK4P/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/protobuf-c/protobuf-c/commit/ec3d900001a13ccdaa8aef996b34c61159c76217"}}