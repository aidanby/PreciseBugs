{"buggy_code": ["namespace BlogEngine.Core.API.BlogML\n{\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Text;\n    using System.Xml;\n    using System.Linq;\n    using System.Globalization;\n\n    using global::BlogML;\n    using global::BlogML.Xml;\n\n    /// <summary>\n    /// Class to validate BlogML data and import it into Blog\n    /// </summary>\n    public class BlogReader : BaseReader\n    {\n        #region Constants and Fields\n\n        /// <summary>\n        ///     The xml data.\n        /// </summary>\n        private string xmlData = string.Empty;\n\n        /// <summary>\n        ///     The category lookup.\n        /// </summary>\n        private List<Category> categoryLookup = new List<Category>();\n\n        private List<BlogMlExtendedPost> blogsExtended = new List<BlogMlExtendedPost>();\n\n        #endregion\n\n        #region Properties\n\n        /// <summary>\n        /// imported posts counter\n        /// </summary>\n        public int PostCount { get; set; }\n\n        /// <summary>\n        ///     Sets BlogML data uploaded and saved as string\n        /// </summary>\n        public string XmlData\n        {\n            set\n            {\n                xmlData = value;\n            }\n        }\n\n        /// <summary>\n        ///     Gets an XmlReader that converts BlogML data saved as string into XML stream\n        /// </summary>\n        private XmlTextReader XmlReader\n        {\n            get\n            {\n                var byteArray = Encoding.UTF8.GetBytes(this.xmlData);\n                var stream = new MemoryStream(byteArray);\n                return new XmlTextReader(stream);\n            }\n        }\n\n        #endregion\n\n        #region Public Methods\n\n        /// <summary>\n        /// Imports BlogML file into blog\n        /// </summary>\n        /// <returns>\n        /// True if successful\n        /// </returns>\n        public override bool Import()\n        {\n            Message = string.Empty;\n            var blog = new BlogMLBlog();\n            try\n            {\n                blog = BlogMLSerializer.Deserialize(XmlReader);\n            }\n            catch (Exception ex)\n            {\n                Message = $\"BlogReader.Import: BlogML could not load with 2.0 specs. {ex.Message}\";\n                Utils.Log(Message);\n                return false;\n            }\n\n            try\n            {\n                LoadFromXmlDocument();\n\n                LoadBlogCategories(blog);\n\n                LoadBlogExtendedPosts(blog);\n\n                LoadBlogPosts();\n\n                Message = $\"Imported {PostCount} new posts\";\n            }\n            catch (Exception ex)\n            {\n                Message = $\"BlogReader.Import: {ex.Message}\";\n                Utils.Log(Message);\n                return false;\n            }\n\n            return true;\n        }\n\n        #endregion\n\n        #region Methods\n\n        private Dictionary<string, Dictionary<string, Guid>> _substitueGuids;\n        private Guid GetGuid(string type, string value)\n        {\n            value = (value ?? string.Empty).Trim();\n\n            // Value might be a GUID, or it could be a simple integer.\n\n            if (!String.IsNullOrWhiteSpace(value) &&\n                value.Length == 36)\n            {\n                return new Guid(value);\n            }\n\n            // If we've already retrieved a Guid for a particular type/value, then\n            // return the same Guid.  This is in case the type/value is referenced by\n            // other objects, we would want to use the same Guid to keep the\n            // references correct.\n\n            if (_substitueGuids == null)\n            {\n                _substitueGuids = new Dictionary<string, Dictionary<string, Guid>>(StringComparer.OrdinalIgnoreCase);\n            }\n\n            if (!_substitueGuids.ContainsKey(type))\n                _substitueGuids.Add(type, new Dictionary<string, Guid>(StringComparer.OrdinalIgnoreCase));\n\n            if (!_substitueGuids[type].ContainsKey(value))\n                _substitueGuids[type].Add(value, Guid.NewGuid());\n\n            return _substitueGuids[type][value];\n        }\n\n        private T GetAttributeValue<T>(XmlAttribute attr)\n        {\n            if (attr == null)\n                return default(T);\n\n            return (T)Convert.ChangeType(attr.Value, typeof(T));\n        }\n\n        private DateTime GetDate(XmlAttribute attr)\n        { \n            string value = GetAttributeValue<string>(attr);\n            DateTime defaultDate = DateTime.Now;\n\n            DateTime dt = defaultDate;\n            if (!String.IsNullOrWhiteSpace(value))\n            {\n                if (!DateTime.TryParseExact(value, \"yyyy-MM-ddTHH:mm:ss\", CultureInfo.InvariantCulture, DateTimeStyles.None, out dt))\n                    dt = defaultDate;\n            }\n\n            return dt;\n        }\n\n        private Uri GetUri(string value)\n        {\n            Uri uri;\n            if (Uri.TryCreate(value, UriKind.RelativeOrAbsolute, out uri))\n                return uri;\n\n            return null;\n        }\n\n        /// <summary>\n        /// BlogML does not support tags - load directly fro XML\n        /// </summary>\n        private void LoadFromXmlDocument()\n        {\n            var doc = new XmlDocument();\n            doc.Load(XmlReader);\n            var posts = doc.GetElementsByTagName(\"post\");\n\n            foreach (XmlNode post in posts)\n            {\n                var blogX = new BlogMlExtendedPost();\n\n                if (post.Attributes != null)\n                    blogX.PostUrl = GetAttributeValue<string>(post.Attributes[\"post-url\"]);\n\n                if (post.ChildNodes.Count <= 0)\n                {\n                    blogsExtended.Add(blogX);\n                    continue;\n                }\n\n                foreach (XmlNode child in post.ChildNodes)\n                {\n                    if (child.Name == \"tags\")\n                    {\n                        foreach (XmlNode tag in child.ChildNodes)\n                        {\n                            if (tag.Attributes != null)\n                            {\n                                if (blogX.Tags == null) blogX.Tags = new StateList<string>();\n                                blogX.Tags.Add(GetAttributeValue<string>(tag.Attributes[\"ref\"]));\n                            }\n                        }\n                    }\n\n                    if (child.Name == \"comments\")\n                        LoadBlogComments(blogX, child);\n\n                    if (child.Name == \"trackbacks\")\n                        LoadBlogTrackbacks(blogX, child);\n                }\n                blogsExtended.Add(blogX);\n            }\n        }\n\n        /// <summary>\n        /// Lost post comments from xml file\n        /// </summary>\n        /// <param name=\"blogX\">extended blog</param>\n        /// <param name=\"child\">comments xml node</param>\n        private void LoadBlogComments(BlogMlExtendedPost blogX, XmlNode child)\n        {\n            foreach (XmlNode com in child.ChildNodes)\n            {\n                if(com.Attributes != null)\n                {\n                    var c = new Comment\n                                {\n                                    Id = GetGuid(\"comment\", GetAttributeValue<string>(com.Attributes[\"id\"])),\n                                    Author = GetAttributeValue<string>(com.Attributes[\"user-name\"]),\n                                    Email = GetAttributeValue<string>(com.Attributes[\"user-email\"]),\n                                    ParentId = GetGuid(\"comment\", GetAttributeValue<string>(com.Attributes[\"parentid\"])),\n                                    IP = GetAttributeValue<string>(com.Attributes[\"user-ip\"]),\n                                    DateCreated = GetDate(com.Attributes[\"date-created\"])\n                                };\n\n                    if (!string.IsNullOrEmpty(GetAttributeValue<string>(com.Attributes[\"user-url\"])))\n                        c.Website = GetUri(GetAttributeValue<string>(com.Attributes[\"user-url\"]));\n\n                    c.IsApproved = GetAttributeValue<bool>(com.Attributes[\"approved\"]);\n\n                    foreach (XmlNode comNode in com.ChildNodes)\n                    {\n                        if(comNode.Name == \"content\")\n                        {\n                            c.Content = comNode.InnerText;\n                        }\n                    }\n                    if(blogX.Comments == null) blogX.Comments = new List<Comment>();\n                    blogX.Comments.Add(c);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Lost post trackbacks and pingbacks from xml file\n        /// </summary>\n        /// <param name=\"blogX\">extended blog</param>\n        /// <param name=\"child\">comments xml node</param>\n        private void LoadBlogTrackbacks(BlogMlExtendedPost blogX, XmlNode child)\n        {\n            foreach (XmlNode com in child.ChildNodes)\n            {\n                if (com.Attributes != null)\n                {\n                    var c = new Comment\n                    {\n                        Id = GetGuid(\"comment\", GetAttributeValue<string>(com.Attributes[\"id\"])), \n                        IP = \"127.0.0.1\",\n                        IsApproved = GetAttributeValue<bool>(com.Attributes[\"approved\"]),\n                        DateCreated = GetDate(com.Attributes[\"date-created\"])\n                    };\n\n                    if (!string.IsNullOrEmpty(GetAttributeValue<string>(com.Attributes[\"url\"])))\n                        c.Website = GetUri(GetAttributeValue<string>(com.Attributes[\"url\"]));\n\n                    foreach (XmlNode comNode in com.ChildNodes)\n                    {\n                        if (comNode.Name == \"title\")\n                        {\n                            c.Content = comNode.InnerText;\n                        }\n                    }\n\n                    c.Email = c.Content.ToLowerInvariant().Contains(\"pingback\") ? \"pingback\" : \"trackback\";\n                    c.Author = c.Email;\n\n                    if (blogX.Comments == null) blogX.Comments = new List<Comment>();\n                    blogX.Comments.Add(c);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Load blog categories\n        /// </summary>\n        /// <param name=\"blog\">BlogML blog</param>\n        private void LoadBlogCategories(BlogMLBlog blog)\n        {\n            foreach (var cat in blog.Categories)\n            {\n                var c = new Category\n                {\n                    Id = GetGuid(\"category\", cat.ID),\n                    Title = cat.Title,\n                    Description = string.IsNullOrEmpty(cat.Description) ? \"\" : cat.Description,\n                    DateCreated = cat.DateCreated,\n                    DateModified = cat.DateModified\n                };\n\n                if (!string.IsNullOrEmpty(cat.ParentRef) && cat.ParentRef != \"0\")\n                    c.Parent = GetGuid(\"category\", cat.ParentRef);\n\n                categoryLookup.Add(c);\n\n                if (Category.GetCategory(c.Id) == null)\n                {\n                    c.Save();\n                }\n            }\n        }\n\n        /// <summary>\n        /// extended post has all BlogML plus fields not supported\n        /// by BlogML like tags. here we assign BlogML post\n        /// to extended matching on post URL \n        /// </summary>\n        /// <param name=\"blog\">BlogML blog</param>\n        private void LoadBlogExtendedPosts(BlogMLBlog blog)\n        {\n            foreach (var post in blog.Posts)\n            {\n                if (post.PostType == BlogPostTypes.Normal)\n                {\n                    BlogMLPost p = post;\n                    blogsExtended.FirstOrDefault(b => b.PostUrl == p.PostUrl).BlogPost = post;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Loads the blog posts.\n        /// </summary>\n        private void LoadBlogPosts()\n        {\n            var bi = new BlogImporter();\n            Utils.Log(\"BlogReader.LoadBlogPosts: Start importing posts\");\n\n            foreach (BlogMlExtendedPost extPost in blogsExtended)\n            {\n                try\n                {\n                    BlogMlExtendedPost post = extPost;\n\n                    if (extPost.BlogPost.Categories.Count > 0)\n                    {\n                        for (var i = 0; i < extPost.BlogPost.Categories.Count; i++)\n                        {\n                            int i2 = i;\n                            var cId = GetGuid(\"category\", post.BlogPost.Categories[i2].Ref);\n\n                            foreach (var category in categoryLookup)\n                            {\n                                if (category.Id == cId)\n                                {\n                                    if (extPost.Categories == null)\n                                        extPost.Categories = new StateList<Category>();\n\n                                    extPost.Categories.Add(category);\n                                }\n                            }\n                        }\n                    }\n\n                    if (!string.IsNullOrEmpty(bi.AddPost(extPost)))\n                    {\n                        PostCount++;\n                    }\n                    else\n                    {\n                        Utils.Log(\"Post '{0}' has been skipped\" + extPost.BlogPost.Title);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Utils.Log(\"BlogReader.LoadBlogPosts: \" + ex.Message);\n                }\n            }\n            bi.ForceReload();\n            Utils.Log($\"BlogReader.LoadBlogPosts: Completed importing {PostCount} posts\");\n        }\n\n        #endregion\n    }\n}", "using BlogEngine.Core.Data.Contracts;\nusing BlogEngine.Core.FileSystem;\nusing BlogEngine.Core.Providers;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Web.Http;\n\npublic class FileManagerController : ApiController\n{\n    readonly IFileManagerRepository repository;\n\n    public FileManagerController(IFileManagerRepository repository)\n    {\n        this.repository = repository;\n    }\n\n    public IEnumerable<FileInstance> Get(int take = 10, int skip = 0, string path = \"\", string order = \"\")\n    {\n        return repository.Find(take, skip, path, order);\n    }\n\n    [HttpPut]\n    public HttpResponseMessage ProcessChecked([FromBody]List<FileInstance> items)\n    {\n        if (items == null || items.Count == 0)\n            throw new HttpResponseException(HttpStatusCode.ExpectationFailed);\n\n        var action = Request.GetRouteData().Values[\"id\"].ToString().ToLowerInvariant();\n\n        if (action == \"delete\")\n        {\n            foreach (var item in items)\n            {\n                if (item.IsChecked)\n                {\n                    if(item.FileType == FileType.File || item.FileType == FileType.Image)\n                        BlogService.DeleteFile(item.FullPath);\n\n                    if (item.FileType == FileType.Directory)\n                        BlogService.DeleteDirectory(item.FullPath);\n                }\n            }\n        }\n        return Request.CreateResponse(HttpStatusCode.OK);\n    }\n\n    [HttpPut]\n    public HttpResponseMessage AddFolder(FileInstance folder)\n    {\n        BlogService.CreateDirectory(folder.FullPath + \"/\" + folder.Name);\n        return Request.CreateResponse(HttpStatusCode.OK);\n    }\n\n}", "<%@ Application Language=\"C#\" %>\n<%@ Import Namespace=\"BlogEngine.NET.App_Start\" %>\n\n<script RunAt=\"server\">\n    void Application_BeginRequest(object sender, EventArgs e)\n    {\n        var app = (HttpApplication)sender;\n        BlogEngineConfig.Initialize(app.Context);\n    }\n        \n    void Application_PreRequestHandlerExecute(object sender, EventArgs e)\n    {\n        BlogEngineConfig.SetCulture(sender, e);\n    }\n</script>"], "fixing_code": ["namespace BlogEngine.Core.API.BlogML\n{\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Text;\n    using System.Xml;\n    using System.Linq;\n    using System.Globalization;\n\n    using global::BlogML;\n    using global::BlogML.Xml;\n\n    /// <summary>\n    /// Class to validate BlogML data and import it into Blog\n    /// </summary>\n    public class BlogReader : BaseReader\n    {\n        #region Constants and Fields\n\n        /// <summary>\n        ///     The xml data.\n        /// </summary>\n        private string xmlData = string.Empty;\n\n        /// <summary>\n        ///     The category lookup.\n        /// </summary>\n        private List<Category> categoryLookup = new List<Category>();\n\n        private List<BlogMlExtendedPost> blogsExtended = new List<BlogMlExtendedPost>();\n\n        #endregion\n\n        #region Properties\n\n        /// <summary>\n        /// imported posts counter\n        /// </summary>\n        public int PostCount { get; set; }\n\n        /// <summary>\n        ///     Sets BlogML data uploaded and saved as string\n        /// </summary>\n        public string XmlData\n        {\n            set\n            {\n                xmlData = value;\n            }\n        }\n\n        /// <summary>\n        ///     Gets an XmlReader that converts BlogML data saved as string into XML stream\n        /// </summary>\n        private XmlReader XmlReader\n        {\n            get\n            {\n                var byteArray = Encoding.UTF8.GetBytes(this.xmlData);\n                var stream = new MemoryStream(byteArray);\n                XmlReaderSettings settings = new XmlReaderSettings();\n                settings.XmlResolver = null;\n                return XmlReader.Create(stream, settings);\n            }\n        }\n\n        #endregion\n\n        #region Public Methods\n\n        /// <summary>\n        /// Imports BlogML file into blog\n        /// </summary>\n        /// <returns>\n        /// True if successful\n        /// </returns>\n        public override bool Import()\n        {\n            Message = string.Empty;\n            var blog = new BlogMLBlog();\n            try\n            {\n                blog = BlogMLSerializer.Deserialize(XmlReader);\n            }\n            catch (Exception ex)\n            {\n                Message = $\"BlogReader.Import: BlogML could not load with 2.0 specs. {ex.Message}\";\n                Utils.Log(Message);\n                return false;\n            }\n\n            try\n            {\n                LoadFromXmlDocument();\n\n                LoadBlogCategories(blog);\n\n                LoadBlogExtendedPosts(blog);\n\n                LoadBlogPosts();\n\n                Message = $\"Imported {PostCount} new posts\";\n            }\n            catch (Exception ex)\n            {\n                Message = $\"BlogReader.Import: {ex.Message}\";\n                Utils.Log(Message);\n                return false;\n            }\n\n            return true;\n        }\n\n        #endregion\n\n        #region Methods\n\n        private Dictionary<string, Dictionary<string, Guid>> _substitueGuids;\n        private Guid GetGuid(string type, string value)\n        {\n            value = (value ?? string.Empty).Trim();\n\n            // Value might be a GUID, or it could be a simple integer.\n\n            if (!String.IsNullOrWhiteSpace(value) &&\n                value.Length == 36)\n            {\n                return new Guid(value);\n            }\n\n            // If we've already retrieved a Guid for a particular type/value, then\n            // return the same Guid.  This is in case the type/value is referenced by\n            // other objects, we would want to use the same Guid to keep the\n            // references correct.\n\n            if (_substitueGuids == null)\n            {\n                _substitueGuids = new Dictionary<string, Dictionary<string, Guid>>(StringComparer.OrdinalIgnoreCase);\n            }\n\n            if (!_substitueGuids.ContainsKey(type))\n                _substitueGuids.Add(type, new Dictionary<string, Guid>(StringComparer.OrdinalIgnoreCase));\n\n            if (!_substitueGuids[type].ContainsKey(value))\n                _substitueGuids[type].Add(value, Guid.NewGuid());\n\n            return _substitueGuids[type][value];\n        }\n\n        private T GetAttributeValue<T>(XmlAttribute attr)\n        {\n            if (attr == null)\n                return default(T);\n\n            return (T)Convert.ChangeType(attr.Value, typeof(T));\n        }\n\n        private DateTime GetDate(XmlAttribute attr)\n        { \n            string value = GetAttributeValue<string>(attr);\n            DateTime defaultDate = DateTime.Now;\n\n            DateTime dt = defaultDate;\n            if (!String.IsNullOrWhiteSpace(value))\n            {\n                if (!DateTime.TryParseExact(value, \"yyyy-MM-ddTHH:mm:ss\", CultureInfo.InvariantCulture, DateTimeStyles.None, out dt))\n                    dt = defaultDate;\n            }\n\n            return dt;\n        }\n\n        private Uri GetUri(string value)\n        {\n            Uri uri;\n            if (Uri.TryCreate(value, UriKind.RelativeOrAbsolute, out uri))\n                return uri;\n\n            return null;\n        }\n\n        /// <summary>\n        /// BlogML does not support tags - load directly fro XML\n        /// </summary>\n        private void LoadFromXmlDocument()\n        {\n            var doc = new XmlDocument();\n            doc.Load(XmlReader);\n            var posts = doc.GetElementsByTagName(\"post\");\n\n            foreach (XmlNode post in posts)\n            {\n                var blogX = new BlogMlExtendedPost();\n\n                if (post.Attributes != null)\n                    blogX.PostUrl = GetAttributeValue<string>(post.Attributes[\"post-url\"]);\n\n                if (post.ChildNodes.Count <= 0)\n                {\n                    blogsExtended.Add(blogX);\n                    continue;\n                }\n\n                foreach (XmlNode child in post.ChildNodes)\n                {\n                    if (child.Name == \"tags\")\n                    {\n                        foreach (XmlNode tag in child.ChildNodes)\n                        {\n                            if (tag.Attributes != null)\n                            {\n                                if (blogX.Tags == null) blogX.Tags = new StateList<string>();\n                                blogX.Tags.Add(GetAttributeValue<string>(tag.Attributes[\"ref\"]));\n                            }\n                        }\n                    }\n\n                    if (child.Name == \"comments\")\n                        LoadBlogComments(blogX, child);\n\n                    if (child.Name == \"trackbacks\")\n                        LoadBlogTrackbacks(blogX, child);\n                }\n                blogsExtended.Add(blogX);\n            }\n        }\n\n        /// <summary>\n        /// Lost post comments from xml file\n        /// </summary>\n        /// <param name=\"blogX\">extended blog</param>\n        /// <param name=\"child\">comments xml node</param>\n        private void LoadBlogComments(BlogMlExtendedPost blogX, XmlNode child)\n        {\n            foreach (XmlNode com in child.ChildNodes)\n            {\n                if(com.Attributes != null)\n                {\n                    var c = new Comment\n                                {\n                                    Id = GetGuid(\"comment\", GetAttributeValue<string>(com.Attributes[\"id\"])),\n                                    Author = GetAttributeValue<string>(com.Attributes[\"user-name\"]),\n                                    Email = GetAttributeValue<string>(com.Attributes[\"user-email\"]),\n                                    ParentId = GetGuid(\"comment\", GetAttributeValue<string>(com.Attributes[\"parentid\"])),\n                                    IP = GetAttributeValue<string>(com.Attributes[\"user-ip\"]),\n                                    DateCreated = GetDate(com.Attributes[\"date-created\"])\n                                };\n\n                    if (!string.IsNullOrEmpty(GetAttributeValue<string>(com.Attributes[\"user-url\"])))\n                        c.Website = GetUri(GetAttributeValue<string>(com.Attributes[\"user-url\"]));\n\n                    c.IsApproved = GetAttributeValue<bool>(com.Attributes[\"approved\"]);\n\n                    foreach (XmlNode comNode in com.ChildNodes)\n                    {\n                        if(comNode.Name == \"content\")\n                        {\n                            c.Content = comNode.InnerText;\n                        }\n                    }\n                    if(blogX.Comments == null) blogX.Comments = new List<Comment>();\n                    blogX.Comments.Add(c);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Lost post trackbacks and pingbacks from xml file\n        /// </summary>\n        /// <param name=\"blogX\">extended blog</param>\n        /// <param name=\"child\">comments xml node</param>\n        private void LoadBlogTrackbacks(BlogMlExtendedPost blogX, XmlNode child)\n        {\n            foreach (XmlNode com in child.ChildNodes)\n            {\n                if (com.Attributes != null)\n                {\n                    var c = new Comment\n                    {\n                        Id = GetGuid(\"comment\", GetAttributeValue<string>(com.Attributes[\"id\"])), \n                        IP = \"127.0.0.1\",\n                        IsApproved = GetAttributeValue<bool>(com.Attributes[\"approved\"]),\n                        DateCreated = GetDate(com.Attributes[\"date-created\"])\n                    };\n\n                    if (!string.IsNullOrEmpty(GetAttributeValue<string>(com.Attributes[\"url\"])))\n                        c.Website = GetUri(GetAttributeValue<string>(com.Attributes[\"url\"]));\n\n                    foreach (XmlNode comNode in com.ChildNodes)\n                    {\n                        if (comNode.Name == \"title\")\n                        {\n                            c.Content = comNode.InnerText;\n                        }\n                    }\n\n                    c.Email = c.Content.ToLowerInvariant().Contains(\"pingback\") ? \"pingback\" : \"trackback\";\n                    c.Author = c.Email;\n\n                    if (blogX.Comments == null) blogX.Comments = new List<Comment>();\n                    blogX.Comments.Add(c);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Load blog categories\n        /// </summary>\n        /// <param name=\"blog\">BlogML blog</param>\n        private void LoadBlogCategories(BlogMLBlog blog)\n        {\n            foreach (var cat in blog.Categories)\n            {\n                var c = new Category\n                {\n                    Id = GetGuid(\"category\", cat.ID),\n                    Title = cat.Title,\n                    Description = string.IsNullOrEmpty(cat.Description) ? \"\" : cat.Description,\n                    DateCreated = cat.DateCreated,\n                    DateModified = cat.DateModified\n                };\n\n                if (!string.IsNullOrEmpty(cat.ParentRef) && cat.ParentRef != \"0\")\n                    c.Parent = GetGuid(\"category\", cat.ParentRef);\n\n                categoryLookup.Add(c);\n\n                if (Category.GetCategory(c.Id) == null)\n                {\n                    c.Save();\n                }\n            }\n        }\n\n        /// <summary>\n        /// extended post has all BlogML plus fields not supported\n        /// by BlogML like tags. here we assign BlogML post\n        /// to extended matching on post URL \n        /// </summary>\n        /// <param name=\"blog\">BlogML blog</param>\n        private void LoadBlogExtendedPosts(BlogMLBlog blog)\n        {\n            foreach (var post in blog.Posts)\n            {\n                if (post.PostType == BlogPostTypes.Normal)\n                {\n                    BlogMLPost p = post;\n                    blogsExtended.FirstOrDefault(b => b.PostUrl == p.PostUrl).BlogPost = post;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Loads the blog posts.\n        /// </summary>\n        private void LoadBlogPosts()\n        {\n            var bi = new BlogImporter();\n            Utils.Log(\"BlogReader.LoadBlogPosts: Start importing posts\");\n\n            foreach (BlogMlExtendedPost extPost in blogsExtended)\n            {\n                try\n                {\n                    BlogMlExtendedPost post = extPost;\n\n                    if (extPost.BlogPost.Categories.Count > 0)\n                    {\n                        for (var i = 0; i < extPost.BlogPost.Categories.Count; i++)\n                        {\n                            int i2 = i;\n                            var cId = GetGuid(\"category\", post.BlogPost.Categories[i2].Ref);\n\n                            foreach (var category in categoryLookup)\n                            {\n                                if (category.Id == cId)\n                                {\n                                    if (extPost.Categories == null)\n                                        extPost.Categories = new StateList<Category>();\n\n                                    extPost.Categories.Add(category);\n                                }\n                            }\n                        }\n                    }\n\n                    if (!string.IsNullOrEmpty(bi.AddPost(extPost)))\n                    {\n                        PostCount++;\n                    }\n                    else\n                    {\n                        Utils.Log(\"Post '{0}' has been skipped\" + extPost.BlogPost.Title);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Utils.Log(\"BlogReader.LoadBlogPosts: \" + ex.Message);\n                }\n            }\n            bi.ForceReload();\n            Utils.Log($\"BlogReader.LoadBlogPosts: Completed importing {PostCount} posts\");\n        }\n\n        #endregion\n    }\n}", "using BlogEngine.Core;\nusing BlogEngine.Core.Data.Contracts;\nusing BlogEngine.Core.FileSystem;\nusing BlogEngine.Core.Providers;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Web.Http;\n\npublic class FileManagerController : ApiController\n{\n    readonly IFileManagerRepository repository;\n\n    public FileManagerController(IFileManagerRepository repository)\n    {\n        this.repository = repository;\n    }\n\n    public IEnumerable<FileInstance> Get(int take = 10, int skip = 0, string path = \"\", string order = \"\")\n    {\n        return repository.Find(take, skip, path, order);\n    }\n\n    [HttpPut]\n    public HttpResponseMessage ProcessChecked([FromBody]List<FileInstance> items)\n    {\n        if (!Security.IsAdministrator)\n        {\n            throw new UnauthorizedAccessException();\n        }\n\n        if (items == null || items.Count == 0)\n            throw new HttpResponseException(HttpStatusCode.ExpectationFailed);\n\n        var action = Request.GetRouteData().Values[\"id\"].ToString().ToLowerInvariant();\n\n        if (action == \"delete\")\n        {\n            foreach (var item in items)\n            {\n                if (item.IsChecked)\n                {\n                    if(item.FileType == FileType.File || item.FileType == FileType.Image)\n                        BlogService.DeleteFile(Extensions.SanitizePath(item.FullPath));\n\n                    if (item.FileType == FileType.Directory)\n                        BlogService.DeleteDirectory(Extensions.SanitizePath(item.FullPath));\n                }\n            }\n        }\n        return Request.CreateResponse(HttpStatusCode.OK);\n    }\n\n    [HttpPut]\n    public HttpResponseMessage AddFolder(FileInstance folder)\n    {\n        if (!Security.IsAdministrator)\n        {\n            throw new UnauthorizedAccessException();\n        }\n        BlogService.CreateDirectory(Extensions.SanitizePath(folder.FullPath) + \"/\" + Extensions.SanitizePath(folder.Name));\n        return Request.CreateResponse(HttpStatusCode.OK);\n    }\n\n}", "<%@ Application Language=\"C#\" %>\n<%@ Import Namespace=\"BlogEngine.NET.App_Start\" %>\n\n<script RunAt=\"server\">\n    void Application_BeginRequest(object sender, EventArgs e)\n    {\n        var app = (HttpApplication)sender;\n        BlogEngineConfig.Initialize(app.Context);\n    }\n        \n    void Application_PreRequestHandlerExecute(object sender, EventArgs e)\n    {\n        BlogEngineConfig.SetCulture(sender, e);\n    }\n\n    protected void Application_PreSendRequestHeaders ()\n    {\n        var httpContext = HttpContext.Current;\n        if (httpContext != null) {\n            var cookieValueSuffix = \"; SameSite=Strict\";\n            var cookies = httpContext.Response.Cookies;\n            for (var i = 0; i < cookies.Count; i++)\n            {\n                var cookie = cookies[i]; cookie.Value += cookieValueSuffix;\n            }\n        }\n    }\n</script>"], "filenames": ["BlogEngine/BlogEngine.Core/Services/Syndication/BlogML/BlogReader.cs", "BlogEngine/BlogEngine.NET/AppCode/Api/FileManagerController.cs", "BlogEngine/BlogEngine.NET/Global.asax"], "buggy_code_start_loc": [56, 0, 14], "buggy_code_end_loc": [63, 53, 14], "fixing_code_start_loc": [56, 1, 15], "fixing_code_end_loc": [65, 63, 28], "type": "CWE-22", "message": "An issue in the component BlogEngine/BlogEngine.NET/AppCode/Api/UploadController.cs of BlogEngine.NET v3.3.8.0 allows attackers to execute arbitrary code via uploading a crafted PNG file.", "other": {"cve": {"id": "CVE-2022-41418", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-19T20:15:11.967", "lastModified": "2023-03-22T00:15:12.163", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue in the component BlogEngine/BlogEngine.NET/AppCode/Api/UploadController.cs of BlogEngine.NET v3.3.8.0 allows attackers to execute arbitrary code via uploading a crafted PNG file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:blogengine:blogengine.net:3.3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C215046E-4B0C-44AD-B0C4-D055FE17A873"}]}]}], "references": [{"url": "https://gist.github.com/tree-chtsec/22a0a531ea188fd5b76fe11d32f41e95", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://gist.github.com/tree-chtsec/a02258bb6dea0d16e7e631898c066e05", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/BlogEngine/BlogEngine.NET/commit/7f927567db94462ffd37e128c0a53c11c1f81a8d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.chtsecurity.com/news/8719b7f3-1129-4fb4-8801-298970d81df7", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/BlogEngine/BlogEngine.NET/commit/7f927567db94462ffd37e128c0a53c11c1f81a8d"}}