{"buggy_code": ["#include \"osxkeychain_darwin.h\"\n#include <CoreFoundation/CoreFoundation.h>\n#include <Foundation/NSValue.h>\n#include <stdio.h>\n#include <string.h>\n\nchar *get_error(OSStatus status) {\n  char *buf = malloc(128);\n  CFStringRef str = SecCopyErrorMessageString(status, NULL);\n  int success = CFStringGetCString(str, buf, 128, kCFStringEncodingUTF8);\n  if (!success) {\n    strncpy(buf, \"Unknown error\", 128);\n  }\n  return buf;\n}\n\nchar *keychain_add(struct Server *server, char *label, char *username, char *secret) {\n  SecKeychainItemRef item;\n\n  OSStatus status = SecKeychainAddInternetPassword(\n    NULL,\n    strlen(server->host), server->host,\n    0, NULL,\n    strlen(username), username,\n    strlen(server->path), server->path,\n    server->port,\n    server->proto,\n    kSecAuthenticationTypeDefault,\n    strlen(secret), secret,\n    &item\n  );\n\n  if (status) {\n    return get_error(status);\n  }\n\n  SecKeychainAttribute attribute;\n  SecKeychainAttributeList attrs;\n  attribute.tag = kSecLabelItemAttr;\n  attribute.data = label;\n  attribute.length = strlen(label);\n  attrs.count = 1;\n  attrs.attr = &attribute;\n\n  status = SecKeychainItemModifyContent(item, &attrs, 0, NULL);\n\n  if (status) {\n    return get_error(status);\n  }\n\n  return NULL;\n}\n\nchar *keychain_get(struct Server *server, unsigned int *username_l, char **username, unsigned int *secret_l, char **secret) {\n  char *tmp;\n  SecKeychainItemRef item;\n\n  OSStatus status = SecKeychainFindInternetPassword(\n    NULL,\n    strlen(server->host), server->host,\n    0, NULL,\n    0, NULL,\n    strlen(server->path), server->path,\n    server->port,\n    server->proto,\n    kSecAuthenticationTypeDefault,\n    secret_l, (void **)&tmp,\n    &item);\n\n  if (status) {\n    return get_error(status);\n  }\n\n  *secret = strdup(tmp);\n  SecKeychainItemFreeContent(NULL, tmp);\n\n  SecKeychainAttributeList list;\n  SecKeychainAttribute attr;\n\n  list.count = 1;\n  list.attr = &attr;\n  attr.tag = kSecAccountItemAttr;\n\n  status = SecKeychainItemCopyContent(item, NULL, &list, NULL, NULL);\n  if (status) {\n    return get_error(status);\n  }\n\n  *username = strdup(attr.data);\n  *username_l = attr.length;\n  SecKeychainItemFreeContent(&list, NULL);\n\n  return NULL;\n}\n\nchar *keychain_delete(struct Server *server) {\n  SecKeychainItemRef item;\n\n  OSStatus status = SecKeychainFindInternetPassword(\n    NULL,\n    strlen(server->host), server->host,\n    0, NULL,\n    0, NULL,\n    strlen(server->path), server->path,\n    server->port,\n    server->proto,\n    kSecAuthenticationTypeDefault,\n    0, NULL,\n    &item);\n\n  if (status) {\n    return get_error(status);\n  }\n\n  status = SecKeychainItemDelete(item);\n  if (status) {\n    return get_error(status);\n  }\n  return NULL;\n}\n\nchar * CFStringToCharArr(CFStringRef aString) {\n  if (aString == NULL) {\n    return NULL;\n  }\n  CFIndex length = CFStringGetLength(aString);\n  CFIndex maxSize =\n  CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8) + 1;\n  char *buffer = (char *)malloc(maxSize);\n  if (CFStringGetCString(aString, buffer, maxSize,\n                         kCFStringEncodingUTF8)) {\n    return buffer;\n  }\n  return NULL;\n}\n\nchar *keychain_list(char *credsLabel, char *** paths, char *** accts, unsigned int *list_l) {\n    CFStringRef credsLabelCF = CFStringCreateWithCString(NULL, credsLabel, kCFStringEncodingUTF8);\n    CFMutableDictionaryRef query = CFDictionaryCreateMutable (NULL, 1, NULL, NULL);\n    CFDictionaryAddValue(query, kSecClass, kSecClassInternetPassword);\n    CFDictionaryAddValue(query, kSecReturnAttributes, kCFBooleanTrue);\n    CFDictionaryAddValue(query, kSecMatchLimit, kSecMatchLimitAll);\n    CFDictionaryAddValue(query, kSecAttrLabel, credsLabelCF);\n    //Use this query dictionary\n    CFTypeRef result= NULL;\n    OSStatus status = SecItemCopyMatching(\n                                          query,\n                                          &result);\n\n    CFRelease(credsLabelCF);\n\n    //Ran a search and store the results in result\n    if (status) {\n        return get_error(status);\n    }\n    CFIndex numKeys = CFArrayGetCount(result);\n    *paths = (char **) malloc((int)sizeof(char *)*numKeys);\n    *accts = (char **) malloc((int)sizeof(char *)*numKeys);\n    //result is of type CFArray\n    for(CFIndex i=0; i<numKeys; i++) {\n        CFDictionaryRef currKey = CFArrayGetValueAtIndex(result,i);\n\n        CFStringRef protocolTmp = CFDictionaryGetValue(currKey, CFSTR(\"ptcl\"));\n        if (protocolTmp != NULL) {\n            CFStringRef protocolStr = CFStringCreateWithFormat(NULL, NULL, CFSTR(\"%@\"), protocolTmp);\n            if (CFStringCompare(protocolStr, CFSTR(\"htps\"), 0) == kCFCompareEqualTo) {\n                protocolTmp = CFSTR(\"https://\");\n            }\n            else {\n                protocolTmp = CFSTR(\"http://\");\n            }\n            CFRelease(protocolStr);\n        }\n        else {\n            char * path = \"0\";\n            char * acct = \"0\";\n            (*paths)[i] = (char *) malloc(sizeof(char)*(strlen(path)));\n            memcpy((*paths)[i], path, sizeof(char)*(strlen(path)));\n            (*accts)[i] = (char *) malloc(sizeof(char)*(strlen(acct)));\n            memcpy((*accts)[i], acct, sizeof(char)*(strlen(acct)));\n            continue;\n        }\n        \n        CFMutableStringRef str = CFStringCreateMutableCopy(NULL, 0, protocolTmp);\n        CFStringRef serverTmp = CFDictionaryGetValue(currKey, CFSTR(\"srvr\"));\n        if (serverTmp != NULL) {\n            CFStringAppend(str, serverTmp);\n        }\n        \n        CFStringRef pathTmp = CFDictionaryGetValue(currKey, CFSTR(\"path\"));\n        if (pathTmp != NULL) {\n            CFStringAppend(str, pathTmp);\n        }\n        \n        const NSNumber * portTmp = CFDictionaryGetValue(currKey, CFSTR(\"port\"));\n        if (portTmp != NULL && portTmp.integerValue != 0) {\n            CFStringRef portStr = CFStringCreateWithFormat(NULL, NULL, CFSTR(\"%@\"), portTmp);\n            CFStringAppend(str, CFSTR(\":\"));\n            CFStringAppend(str, portStr);\n            CFRelease(portStr);\n        }\n        \n        CFStringRef acctTmp = CFDictionaryGetValue(currKey, CFSTR(\"acct\"));\n        if (acctTmp == NULL) {\n            acctTmp = CFSTR(\"account not defined\");\n        }\n\n        char * path = CFStringToCharArr(str);\n        char * acct = CFStringToCharArr(acctTmp);\n\n        //We now have all we need, username and servername. Now export this to .go\n        (*paths)[i] = (char *) malloc(sizeof(char)*(strlen(path)+1));\n        memcpy((*paths)[i], path, sizeof(char)*(strlen(path)+1));\n        (*accts)[i] = (char *) malloc(sizeof(char)*(strlen(acct)+1));\n        memcpy((*accts)[i], acct, sizeof(char)*(strlen(acct)+1));\n\n        CFRelease(str);\n    }\n    *list_l = (int)numKeys;\n    return NULL;\n}\n\nvoid freeListData(char *** data, unsigned int length) {\n     for(int i=0; i<length; i++) {\n        free((*data)[i]);\n     }\n     free(*data);\n}\n", "package osxkeychain\n\n/*\n#cgo CFLAGS: -x objective-c -mmacosx-version-min=10.11\n#cgo LDFLAGS: -framework Security -framework Foundation -mmacosx-version-min=10.11\n\n#include \"osxkeychain_darwin.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"unsafe\"\n\n\t\"github.com/docker/docker-credential-helpers/credentials\"\n\t\"github.com/docker/docker-credential-helpers/registryurl\"\n)\n\n// errCredentialsNotFound is the specific error message returned by OS X\n// when the credentials are not in the keychain.\nconst errCredentialsNotFound = \"The specified item could not be found in the keychain.\"\n\n// Osxkeychain handles secrets using the OS X Keychain as store.\ntype Osxkeychain struct{}\n\n// Add adds new credentials to the keychain.\nfunc (h Osxkeychain) Add(creds *credentials.Credentials) error {\n\th.Delete(creds.ServerURL)\n\n\ts, err := splitServer(creds.ServerURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer freeServer(s)\n\n\tlabel := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(label))\n\tusername := C.CString(creds.Username)\n\tdefer C.free(unsafe.Pointer(username))\n\tsecret := C.CString(creds.Secret)\n\tdefer C.free(unsafe.Pointer(secret))\n\n\terrMsg := C.keychain_add(s, label, username, secret)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\n\treturn nil\n}\n\n// Delete removes credentials from the keychain.\nfunc (h Osxkeychain) Delete(serverURL string) error {\n\ts, err := splitServer(serverURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer freeServer(s)\n\n\terrMsg := C.keychain_delete(s)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\n\treturn nil\n}\n\n// Get returns the username and secret to use for a given registry server URL.\nfunc (h Osxkeychain) Get(serverURL string) (string, string, error) {\n\ts, err := splitServer(serverURL)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer freeServer(s)\n\n\tvar usernameLen C.uint\n\tvar username *C.char\n\tvar secretLen C.uint\n\tvar secret *C.char\n\tdefer C.free(unsafe.Pointer(username))\n\tdefer C.free(unsafe.Pointer(secret))\n\n\terrMsg := C.keychain_get(s, &usernameLen, &username, &secretLen, &secret)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\tgoMsg := C.GoString(errMsg)\n\t\tif goMsg == errCredentialsNotFound {\n\t\t\treturn \"\", \"\", credentials.NewErrCredentialsNotFound()\n\t\t}\n\n\t\treturn \"\", \"\", errors.New(goMsg)\n\t}\n\n\tuser := C.GoStringN(username, C.int(usernameLen))\n\tpass := C.GoStringN(secret, C.int(secretLen))\n\treturn user, pass, nil\n}\n\n// List returns the stored URLs and corresponding usernames.\nfunc (h Osxkeychain) List() (map[string]string, error) {\n\tcredsLabelC := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(credsLabelC))\n\n\tvar pathsC **C.char\n\tdefer C.free(unsafe.Pointer(pathsC))\n\tvar acctsC **C.char\n\tdefer C.free(unsafe.Pointer(acctsC))\n\tvar listLenC C.uint\n\terrMsg := C.keychain_list(credsLabelC, &pathsC, &acctsC, &listLenC)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\tgoMsg := C.GoString(errMsg)\n\t\tif goMsg == errCredentialsNotFound {\n\t\t\treturn make(map[string]string), nil\n\t\t}\n\n\t\treturn nil, errors.New(goMsg)\n\t}\n\n\tdefer C.freeListData(&pathsC, listLenC)\n\tdefer C.freeListData(&acctsC, listLenC)\n\n\tvar listLen int\n\tlistLen = int(listLenC)\n\tpathTmp := (*[1 << 30]*C.char)(unsafe.Pointer(pathsC))[:listLen:listLen]\n\tacctTmp := (*[1 << 30]*C.char)(unsafe.Pointer(acctsC))[:listLen:listLen]\n\t//taking the array of c strings into go while ignoring all the stuff irrelevant to credentials-helper\n\tresp := make(map[string]string)\n\tfor i := 0; i < listLen; i++ {\n\t\tif C.GoString(pathTmp[i]) == \"0\" {\n\t\t\tcontinue\n\t\t}\n\t\tresp[C.GoString(pathTmp[i])] = C.GoString(acctTmp[i])\n\t}\n\treturn resp, nil\n}\n\nfunc splitServer(serverURL string) (*C.struct_Server, error) {\n\tu, err := registryurl.Parse(serverURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproto := C.kSecProtocolTypeHTTPS\n\tif u.Scheme == \"http\" {\n\t\tproto = C.kSecProtocolTypeHTTP\n\t}\n\tvar port int\n\tp := registryurl.GetPort(u)\n\tif p != \"\" {\n\t\tport, err = strconv.Atoi(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &C.struct_Server{\n\t\tproto: C.SecProtocolType(proto),\n\t\thost:  C.CString(registryurl.GetHostname(u)),\n\t\tport:  C.uint(port),\n\t\tpath:  C.CString(u.Path),\n\t}, nil\n}\n\nfunc freeServer(s *C.struct_Server) {\n\tC.free(unsafe.Pointer(s.host))\n\tC.free(unsafe.Pointer(s.path))\n}\n", "#include <string.h>\n#include <stdlib.h>\n#include \"secretservice_linux.h\"\n\nconst SecretSchema *docker_get_schema(void)\n{\n\tstatic const SecretSchema docker_schema = {\n\t\t\"io.docker.Credentials\", SECRET_SCHEMA_NONE,\n\t\t{\n\t\t    { \"label\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"server\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"username\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"docker_cli\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"NULL\", 0 },\n\t\t}\n\t};\n\treturn &docker_schema;\n}\n\nGError *add(char *label, char *server, char *username, char *secret) {\n\tGError *err = NULL;\n\n\tsecret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,\n\t\t\tserver, secret, NULL, &err,\n\t\t\t\"label\", label,\n\t\t\t\"server\", server,\n\t\t\t\"username\", username,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\treturn err;\n}\n\nGError *delete(char *server) {\n\tGError *err = NULL;\n\n\tsecret_password_clear_sync(DOCKER_SCHEMA, NULL, &err,\n\t\t\t\"server\", server,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\tif (err != NULL)\n\t\treturn err;\n\treturn NULL;\n}\n\nchar *get_attribute(const char *attribute, SecretItem *item) {\n\tGHashTable *attributes;\n\tGHashTableIter iter;\n\tgchar *value, *key;\n\n\tattributes = secret_item_get_attributes(item);\n\tg_hash_table_iter_init(&iter, attributes);\n\twhile (g_hash_table_iter_next(&iter, (void **)&key, (void **)&value)) {\n\t\tif (strncmp(key, attribute, strlen(key)) == 0)\n\t\t\treturn (char *)value;\n\t}\n\tg_hash_table_unref(attributes);\n\treturn NULL;\n}\n\nGError *get(char *server, char **username, char **secret) {\n\tGError *err = NULL;\n\tGHashTable *attributes;\n\tSecretService *service;\n\tGList *items, *l;\n\tSecretSearchFlags flags = SECRET_SEARCH_LOAD_SECRETS | SECRET_SEARCH_ALL | SECRET_SEARCH_UNLOCK;\n\tSecretValue *secretValue;\n\tgsize length;\n\tgchar *value;\n\n\tattributes = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\tg_hash_table_insert(attributes, g_strdup(\"server\"), g_strdup(server));\n\tg_hash_table_insert(attributes, g_strdup(\"docker_cli\"), g_strdup(\"1\"));\n\n\tservice = secret_service_get_sync(SECRET_SERVICE_NONE, NULL, &err);\n\tif (err == NULL) {\n\t\titems = secret_service_search_sync(service, DOCKER_SCHEMA, attributes, flags, NULL, &err);\n\t\tif (err == NULL) {\n\t\t\tfor (l = items; l != NULL; l = g_list_next(l)) {\n\t\t\t\tvalue = secret_item_get_schema_name(l->data);\n\t\t\t\tif (strncmp(value, \"io.docker.Credentials\", strlen(value)) != 0) {\n\t\t\t\t\tg_free(value);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tg_free(value);\n\t\t\t\tsecretValue = secret_item_get_secret(l->data);\n\t\t\t\tif (secret != NULL) {\n\t\t\t\t\t*secret = strdup(secret_value_get(secretValue, &length));\n\t\t\t\t\tsecret_value_unref(secretValue);\n\t\t\t\t}\n\t\t\t\t*username = get_attribute(\"username\", l->data);\n\t\t\t}\n\t\t\tg_list_free_full(items, g_object_unref);\n\t\t}\n\t\tg_object_unref(service);\n\t}\n\tg_hash_table_unref(attributes);\n\tif (err != NULL) {\n\t\treturn err;\n\t}\n\treturn NULL;\n}\n\nGError *list(char *ref_label, char *** paths, char *** accts, unsigned int *list_l) {\n\tGList *items;\n\tGError *err = NULL;\n\tSecretService *service;\n\tSecretSearchFlags flags = SECRET_SEARCH_LOAD_SECRETS | SECRET_SEARCH_ALL | SECRET_SEARCH_UNLOCK;\n\tGHashTable *attributes = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\n\t// List credentials with the right label only\n\tg_hash_table_insert(attributes, g_strdup(\"label\"), g_strdup(ref_label));\n\n\tservice = secret_service_get_sync(SECRET_SERVICE_NONE, NULL, &err);\n\tif (err != NULL) {\n\t\treturn err;\n\t}\n\n\titems = secret_service_search_sync(service, NULL, attributes, flags, NULL, &err);\n\tint numKeys = g_list_length(items);\n\tif (err != NULL) {\n\t\treturn err;\n\t}\n\n\tchar **tmp_paths = (char **) calloc(1,(int)sizeof(char *)*numKeys);\n\tchar **tmp_accts = (char **) calloc(1,(int)sizeof(char *)*numKeys);\n\n\t// items now contains our keys from the gnome keyring\n\t// we will now put it in our two lists to return it to go\n\tGList *current;\n\tint listNumber = 0;\n\tfor(current = items; current!=NULL; current = current->next) {\n\t\tchar *pathTmp = secret_item_get_label(current->data);\n\t\t// you cannot have a key without a label in the gnome keyring\n\t\tchar *acctTmp = get_attribute(\"username\",current->data);\n\t\tif (acctTmp==NULL) {\n\t\t\tacctTmp = \"account not defined\";\n\t\t}\n\n\t\ttmp_paths[listNumber] = (char *) calloc(1, sizeof(char)*(strlen(pathTmp)+1));\n\t\ttmp_accts[listNumber] = (char *) calloc(1, sizeof(char)*(strlen(acctTmp)+1));\n\n\t\tmemcpy(tmp_paths[listNumber], pathTmp, sizeof(char)*(strlen(pathTmp)+1));\n\t\tmemcpy(tmp_accts[listNumber], acctTmp, sizeof(char)*(strlen(acctTmp)+1));\n\n\t\tlistNumber = listNumber + 1;\n\t}\n\n\t*paths = (char **) realloc(tmp_paths, (int)sizeof(char *)*listNumber);\n\t*accts = (char **) realloc(tmp_accts, (int)sizeof(char *)*listNumber);\n\n\t*list_l = listNumber;\n\n\treturn NULL;\n}\n\nvoid freeListData(char *** data, unsigned int length) {\n\tint i;\n\tfor(i=0; i<length; i++) {\n\t\tfree((*data)[i]);\n\t}\n\tfree(*data);\n}\n", "package secretservice\n\n/*\n#cgo pkg-config: libsecret-1\n\n#include \"secretservice_linux.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"unsafe\"\n\n\t\"github.com/docker/docker-credential-helpers/credentials\"\n)\n\n// Secretservice handles secrets using Linux secret-service as a store.\ntype Secretservice struct{}\n\n// Add adds new credentials to the keychain.\nfunc (h Secretservice) Add(creds *credentials.Credentials) error {\n\tif creds == nil {\n\t\treturn errors.New(\"missing credentials\")\n\t}\n\tcredsLabel := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(credsLabel))\n\tserver := C.CString(creds.ServerURL)\n\tdefer C.free(unsafe.Pointer(server))\n\tusername := C.CString(creds.Username)\n\tdefer C.free(unsafe.Pointer(username))\n\tsecret := C.CString(creds.Secret)\n\tdefer C.free(unsafe.Pointer(secret))\n\n\tif err := C.add(credsLabel, server, username, secret); err != nil {\n\t\tdefer C.g_error_free(err)\n\t\terrMsg := (*C.char)(unsafe.Pointer(err.message))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\treturn nil\n}\n\n// Delete removes credentials from the store.\nfunc (h Secretservice) Delete(serverURL string) error {\n\tif serverURL == \"\" {\n\t\treturn errors.New(\"missing server url\")\n\t}\n\tserver := C.CString(serverURL)\n\tdefer C.free(unsafe.Pointer(server))\n\n\tif err := C.delete(server); err != nil {\n\t\tdefer C.g_error_free(err)\n\t\terrMsg := (*C.char)(unsafe.Pointer(err.message))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\treturn nil\n}\n\n// Get returns the username and secret to use for a given registry server URL.\nfunc (h Secretservice) Get(serverURL string) (string, string, error) {\n\tif serverURL == \"\" {\n\t\treturn \"\", \"\", errors.New(\"missing server url\")\n\t}\n\tvar username *C.char\n\tdefer C.free(unsafe.Pointer(username))\n\tvar secret *C.char\n\tdefer C.free(unsafe.Pointer(secret))\n\tserver := C.CString(serverURL)\n\tdefer C.free(unsafe.Pointer(server))\n\n\terr := C.get(server, &username, &secret)\n\tif err != nil {\n\t\tdefer C.g_error_free(err)\n\t\terrMsg := (*C.char)(unsafe.Pointer(err.message))\n\t\treturn \"\", \"\", errors.New(C.GoString(errMsg))\n\t}\n\tuser := C.GoString(username)\n\tpass := C.GoString(secret)\n\tif pass == \"\" {\n\t\treturn \"\", \"\", credentials.NewErrCredentialsNotFound()\n\t}\n\treturn user, pass, nil\n}\n\n// List returns the stored URLs and corresponding usernames for a given credentials label\nfunc (h Secretservice) List() (map[string]string, error) {\n\tcredsLabelC := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(credsLabelC))\n\n\tvar pathsC **C.char\n\tdefer C.free(unsafe.Pointer(pathsC))\n\tvar acctsC **C.char\n\tdefer C.free(unsafe.Pointer(acctsC))\n\tvar listLenC C.uint\n\terr := C.list(credsLabelC, &pathsC, &acctsC, &listLenC)\n\tif err != nil {\n\t\tdefer C.g_error_free(err)\n\t\treturn nil, errors.New(\"Error from list function in secretservice_linux.c likely due to error in secretservice library\")\n\t}\n\tdefer C.freeListData(&pathsC, listLenC)\n\tdefer C.freeListData(&acctsC, listLenC)\n\n\tresp := make(map[string]string)\n\n\tlistLen := int(listLenC)\n\tif listLen == 0 {\n\t\treturn resp, nil\n\t}\n\t// The maximum capacity of the following two slices is limited to (2^29)-1 to remain compatible\n\t// with 32-bit platforms. The size of a `*C.char` (a pointer) is 4 Byte on a 32-bit system\n\t// and (2^29)*4 == math.MaxInt32 + 1. -- See issue golang/go#13656\n\tpathTmp := (*[(1 << 29) - 1]*C.char)(unsafe.Pointer(pathsC))[:listLen:listLen]\n\tacctTmp := (*[(1 << 29) - 1]*C.char)(unsafe.Pointer(acctsC))[:listLen:listLen]\n\tfor i := 0; i < listLen; i++ {\n\t\tresp[C.GoString(pathTmp[i])] = C.GoString(acctTmp[i])\n\t}\n\n\treturn resp, nil\n}\n"], "fixing_code": ["#include \"osxkeychain_darwin.h\"\n#include <CoreFoundation/CoreFoundation.h>\n#include <Foundation/NSValue.h>\n#include <stdio.h>\n#include <string.h>\n\nchar *get_error(OSStatus status) {\n  char *buf = malloc(128);\n  CFStringRef str = SecCopyErrorMessageString(status, NULL);\n  int success = CFStringGetCString(str, buf, 128, kCFStringEncodingUTF8);\n  if (!success) {\n    strncpy(buf, \"Unknown error\", 128);\n  }\n  return buf;\n}\n\nchar *keychain_add(struct Server *server, char *label, char *username, char *secret) {\n  SecKeychainItemRef item;\n\n  OSStatus status = SecKeychainAddInternetPassword(\n    NULL,\n    strlen(server->host), server->host,\n    0, NULL,\n    strlen(username), username,\n    strlen(server->path), server->path,\n    server->port,\n    server->proto,\n    kSecAuthenticationTypeDefault,\n    strlen(secret), secret,\n    &item\n  );\n\n  if (status) {\n    return get_error(status);\n  }\n\n  SecKeychainAttribute attribute;\n  SecKeychainAttributeList attrs;\n  attribute.tag = kSecLabelItemAttr;\n  attribute.data = label;\n  attribute.length = strlen(label);\n  attrs.count = 1;\n  attrs.attr = &attribute;\n\n  status = SecKeychainItemModifyContent(item, &attrs, 0, NULL);\n\n  if (status) {\n    return get_error(status);\n  }\n\n  return NULL;\n}\n\nchar *keychain_get(struct Server *server, unsigned int *username_l, char **username, unsigned int *secret_l, char **secret) {\n  char *tmp;\n  SecKeychainItemRef item;\n\n  OSStatus status = SecKeychainFindInternetPassword(\n    NULL,\n    strlen(server->host), server->host,\n    0, NULL,\n    0, NULL,\n    strlen(server->path), server->path,\n    server->port,\n    server->proto,\n    kSecAuthenticationTypeDefault,\n    secret_l, (void **)&tmp,\n    &item);\n\n  if (status) {\n    return get_error(status);\n  }\n\n  *secret = strdup(tmp);\n  SecKeychainItemFreeContent(NULL, tmp);\n\n  SecKeychainAttributeList list;\n  SecKeychainAttribute attr;\n\n  list.count = 1;\n  list.attr = &attr;\n  attr.tag = kSecAccountItemAttr;\n\n  status = SecKeychainItemCopyContent(item, NULL, &list, NULL, NULL);\n  if (status) {\n    return get_error(status);\n  }\n\n  *username = strdup(attr.data);\n  *username_l = attr.length;\n  SecKeychainItemFreeContent(&list, NULL);\n\n  return NULL;\n}\n\nchar *keychain_delete(struct Server *server) {\n  SecKeychainItemRef item;\n\n  OSStatus status = SecKeychainFindInternetPassword(\n    NULL,\n    strlen(server->host), server->host,\n    0, NULL,\n    0, NULL,\n    strlen(server->path), server->path,\n    server->port,\n    server->proto,\n    kSecAuthenticationTypeDefault,\n    0, NULL,\n    &item);\n\n  if (status) {\n    return get_error(status);\n  }\n\n  status = SecKeychainItemDelete(item);\n  if (status) {\n    return get_error(status);\n  }\n  return NULL;\n}\n\nchar * CFStringToCharArr(CFStringRef aString) {\n  if (aString == NULL) {\n    return NULL;\n  }\n  CFIndex length = CFStringGetLength(aString);\n  CFIndex maxSize =\n  CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8) + 1;\n  char *buffer = (char *)malloc(maxSize);\n  if (CFStringGetCString(aString, buffer, maxSize,\n                         kCFStringEncodingUTF8)) {\n    return buffer;\n  }\n  return NULL;\n}\n\nchar *keychain_list(char *credsLabel, char *** paths, char *** accts, unsigned int *list_l) {\n    CFStringRef credsLabelCF = CFStringCreateWithCString(NULL, credsLabel, kCFStringEncodingUTF8);\n    CFMutableDictionaryRef query = CFDictionaryCreateMutable (NULL, 1, NULL, NULL);\n    CFDictionaryAddValue(query, kSecClass, kSecClassInternetPassword);\n    CFDictionaryAddValue(query, kSecReturnAttributes, kCFBooleanTrue);\n    CFDictionaryAddValue(query, kSecMatchLimit, kSecMatchLimitAll);\n    CFDictionaryAddValue(query, kSecAttrLabel, credsLabelCF);\n    //Use this query dictionary\n    CFTypeRef result= NULL;\n    OSStatus status = SecItemCopyMatching(\n                                          query,\n                                          &result);\n\n    CFRelease(credsLabelCF);\n\n    //Ran a search and store the results in result\n    if (status) {\n        return get_error(status);\n    }\n    CFIndex numKeys = CFArrayGetCount(result);\n    *paths = (char **) malloc((int)sizeof(char *)*numKeys);\n    *accts = (char **) malloc((int)sizeof(char *)*numKeys);\n    //result is of type CFArray\n    for(CFIndex i=0; i<numKeys; i++) {\n        CFDictionaryRef currKey = CFArrayGetValueAtIndex(result,i);\n\n        CFStringRef protocolTmp = CFDictionaryGetValue(currKey, CFSTR(\"ptcl\"));\n        if (protocolTmp != NULL) {\n            CFStringRef protocolStr = CFStringCreateWithFormat(NULL, NULL, CFSTR(\"%@\"), protocolTmp);\n            if (CFStringCompare(protocolStr, CFSTR(\"htps\"), 0) == kCFCompareEqualTo) {\n                protocolTmp = CFSTR(\"https://\");\n            }\n            else {\n                protocolTmp = CFSTR(\"http://\");\n            }\n            CFRelease(protocolStr);\n        }\n        else {\n            char * path = \"0\";\n            char * acct = \"0\";\n            (*paths)[i] = (char *) malloc(sizeof(char)*(strlen(path)));\n            memcpy((*paths)[i], path, sizeof(char)*(strlen(path)));\n            (*accts)[i] = (char *) malloc(sizeof(char)*(strlen(acct)));\n            memcpy((*accts)[i], acct, sizeof(char)*(strlen(acct)));\n            continue;\n        }\n        \n        CFMutableStringRef str = CFStringCreateMutableCopy(NULL, 0, protocolTmp);\n        CFStringRef serverTmp = CFDictionaryGetValue(currKey, CFSTR(\"srvr\"));\n        if (serverTmp != NULL) {\n            CFStringAppend(str, serverTmp);\n        }\n        \n        CFStringRef pathTmp = CFDictionaryGetValue(currKey, CFSTR(\"path\"));\n        if (pathTmp != NULL) {\n            CFStringAppend(str, pathTmp);\n        }\n        \n        const NSNumber * portTmp = CFDictionaryGetValue(currKey, CFSTR(\"port\"));\n        if (portTmp != NULL && portTmp.integerValue != 0) {\n            CFStringRef portStr = CFStringCreateWithFormat(NULL, NULL, CFSTR(\"%@\"), portTmp);\n            CFStringAppend(str, CFSTR(\":\"));\n            CFStringAppend(str, portStr);\n            CFRelease(portStr);\n        }\n        \n        CFStringRef acctTmp = CFDictionaryGetValue(currKey, CFSTR(\"acct\"));\n        if (acctTmp == NULL) {\n            acctTmp = CFSTR(\"account not defined\");\n        }\n\n        char * path = CFStringToCharArr(str);\n        char * acct = CFStringToCharArr(acctTmp);\n\n        //We now have all we need, username and servername. Now export this to .go\n        (*paths)[i] = (char *) malloc(sizeof(char)*(strlen(path)+1));\n        memcpy((*paths)[i], path, sizeof(char)*(strlen(path)+1));\n        (*accts)[i] = (char *) malloc(sizeof(char)*(strlen(acct)+1));\n        memcpy((*accts)[i], acct, sizeof(char)*(strlen(acct)+1));\n\n        CFRelease(str);\n    }\n    *list_l = (int)numKeys;\n    return NULL;\n}\n\nvoid freeListData(char *** data, unsigned int length) {\n     for(int i=0; i<length; i++) {\n        free((*data)[i]);\n     }\n}\n", "package osxkeychain\n\n/*\n#cgo CFLAGS: -x objective-c -mmacosx-version-min=10.11\n#cgo LDFLAGS: -framework Security -framework Foundation -mmacosx-version-min=10.11\n\n#include \"osxkeychain_darwin.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"unsafe\"\n\n\t\"github.com/docker/docker-credential-helpers/credentials\"\n\t\"github.com/docker/docker-credential-helpers/registryurl\"\n)\n\n// errCredentialsNotFound is the specific error message returned by OS X\n// when the credentials are not in the keychain.\nconst errCredentialsNotFound = \"The specified item could not be found in the keychain.\"\n\n// Osxkeychain handles secrets using the OS X Keychain as store.\ntype Osxkeychain struct{}\n\n// Add adds new credentials to the keychain.\nfunc (h Osxkeychain) Add(creds *credentials.Credentials) error {\n\th.Delete(creds.ServerURL)\n\n\ts, err := splitServer(creds.ServerURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer freeServer(s)\n\n\tlabel := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(label))\n\tusername := C.CString(creds.Username)\n\tdefer C.free(unsafe.Pointer(username))\n\tsecret := C.CString(creds.Secret)\n\tdefer C.free(unsafe.Pointer(secret))\n\n\terrMsg := C.keychain_add(s, label, username, secret)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\n\treturn nil\n}\n\n// Delete removes credentials from the keychain.\nfunc (h Osxkeychain) Delete(serverURL string) error {\n\ts, err := splitServer(serverURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer freeServer(s)\n\n\terrMsg := C.keychain_delete(s)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\n\treturn nil\n}\n\n// Get returns the username and secret to use for a given registry server URL.\nfunc (h Osxkeychain) Get(serverURL string) (string, string, error) {\n\ts, err := splitServer(serverURL)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer freeServer(s)\n\n\tvar usernameLen C.uint\n\tvar username *C.char\n\tvar secretLen C.uint\n\tvar secret *C.char\n\tdefer C.free(unsafe.Pointer(username))\n\tdefer C.free(unsafe.Pointer(secret))\n\n\terrMsg := C.keychain_get(s, &usernameLen, &username, &secretLen, &secret)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\tgoMsg := C.GoString(errMsg)\n\t\tif goMsg == errCredentialsNotFound {\n\t\t\treturn \"\", \"\", credentials.NewErrCredentialsNotFound()\n\t\t}\n\n\t\treturn \"\", \"\", errors.New(goMsg)\n\t}\n\n\tuser := C.GoStringN(username, C.int(usernameLen))\n\tpass := C.GoStringN(secret, C.int(secretLen))\n\treturn user, pass, nil\n}\n\n// List returns the stored URLs and corresponding usernames.\nfunc (h Osxkeychain) List() (map[string]string, error) {\n\tcredsLabelC := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(credsLabelC))\n\n\tvar pathsC **C.char\n\tdefer C.free(unsafe.Pointer(pathsC))\n\tvar acctsC **C.char\n\tdefer C.free(unsafe.Pointer(acctsC))\n\tvar listLenC C.uint\n\terrMsg := C.keychain_list(credsLabelC, &pathsC, &acctsC, &listLenC)\n\tdefer C.freeListData(&pathsC, listLenC)\n\tdefer C.freeListData(&acctsC, listLenC)\n\tif errMsg != nil {\n\t\tdefer C.free(unsafe.Pointer(errMsg))\n\t\tgoMsg := C.GoString(errMsg)\n\t\tif goMsg == errCredentialsNotFound {\n\t\t\treturn make(map[string]string), nil\n\t\t}\n\n\t\treturn nil, errors.New(goMsg)\n\t}\n\n\tvar listLen int\n\tlistLen = int(listLenC)\n\tpathTmp := (*[1 << 30]*C.char)(unsafe.Pointer(pathsC))[:listLen:listLen]\n\tacctTmp := (*[1 << 30]*C.char)(unsafe.Pointer(acctsC))[:listLen:listLen]\n\t//taking the array of c strings into go while ignoring all the stuff irrelevant to credentials-helper\n\tresp := make(map[string]string)\n\tfor i := 0; i < listLen; i++ {\n\t\tif C.GoString(pathTmp[i]) == \"0\" {\n\t\t\tcontinue\n\t\t}\n\t\tresp[C.GoString(pathTmp[i])] = C.GoString(acctTmp[i])\n\t}\n\treturn resp, nil\n}\n\nfunc splitServer(serverURL string) (*C.struct_Server, error) {\n\tu, err := registryurl.Parse(serverURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproto := C.kSecProtocolTypeHTTPS\n\tif u.Scheme == \"http\" {\n\t\tproto = C.kSecProtocolTypeHTTP\n\t}\n\tvar port int\n\tp := registryurl.GetPort(u)\n\tif p != \"\" {\n\t\tport, err = strconv.Atoi(p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &C.struct_Server{\n\t\tproto: C.SecProtocolType(proto),\n\t\thost:  C.CString(registryurl.GetHostname(u)),\n\t\tport:  C.uint(port),\n\t\tpath:  C.CString(u.Path),\n\t}, nil\n}\n\nfunc freeServer(s *C.struct_Server) {\n\tC.free(unsafe.Pointer(s.host))\n\tC.free(unsafe.Pointer(s.path))\n}\n", "#include <string.h>\n#include <stdlib.h>\n#include \"secretservice_linux.h\"\n\nconst SecretSchema *docker_get_schema(void)\n{\n\tstatic const SecretSchema docker_schema = {\n\t\t\"io.docker.Credentials\", SECRET_SCHEMA_NONE,\n\t\t{\n\t\t    { \"label\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"server\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"username\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"docker_cli\", SECRET_SCHEMA_ATTRIBUTE_STRING },\n\t\t\t{ \"NULL\", 0 },\n\t\t}\n\t};\n\treturn &docker_schema;\n}\n\nGError *add(char *label, char *server, char *username, char *secret) {\n\tGError *err = NULL;\n\n\tsecret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,\n\t\t\tserver, secret, NULL, &err,\n\t\t\t\"label\", label,\n\t\t\t\"server\", server,\n\t\t\t\"username\", username,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\treturn err;\n}\n\nGError *delete(char *server) {\n\tGError *err = NULL;\n\n\tsecret_password_clear_sync(DOCKER_SCHEMA, NULL, &err,\n\t\t\t\"server\", server,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\tif (err != NULL)\n\t\treturn err;\n\treturn NULL;\n}\n\nchar *get_attribute(const char *attribute, SecretItem *item) {\n\tGHashTable *attributes;\n\tGHashTableIter iter;\n\tgchar *value, *key;\n\n\tattributes = secret_item_get_attributes(item);\n\tg_hash_table_iter_init(&iter, attributes);\n\twhile (g_hash_table_iter_next(&iter, (void **)&key, (void **)&value)) {\n\t\tif (strncmp(key, attribute, strlen(key)) == 0)\n\t\t\treturn (char *)value;\n\t}\n\tg_hash_table_unref(attributes);\n\treturn NULL;\n}\n\nGError *get(char *server, char **username, char **secret) {\n\tGError *err = NULL;\n\tGHashTable *attributes;\n\tSecretService *service;\n\tGList *items, *l;\n\tSecretSearchFlags flags = SECRET_SEARCH_LOAD_SECRETS | SECRET_SEARCH_ALL | SECRET_SEARCH_UNLOCK;\n\tSecretValue *secretValue;\n\tgsize length;\n\tgchar *value;\n\n\tattributes = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\tg_hash_table_insert(attributes, g_strdup(\"server\"), g_strdup(server));\n\tg_hash_table_insert(attributes, g_strdup(\"docker_cli\"), g_strdup(\"1\"));\n\n\tservice = secret_service_get_sync(SECRET_SERVICE_NONE, NULL, &err);\n\tif (err == NULL) {\n\t\titems = secret_service_search_sync(service, DOCKER_SCHEMA, attributes, flags, NULL, &err);\n\t\tif (err == NULL) {\n\t\t\tfor (l = items; l != NULL; l = g_list_next(l)) {\n\t\t\t\tvalue = secret_item_get_schema_name(l->data);\n\t\t\t\tif (strncmp(value, \"io.docker.Credentials\", strlen(value)) != 0) {\n\t\t\t\t\tg_free(value);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tg_free(value);\n\t\t\t\tsecretValue = secret_item_get_secret(l->data);\n\t\t\t\tif (secret != NULL) {\n\t\t\t\t\t*secret = strdup(secret_value_get(secretValue, &length));\n\t\t\t\t\tsecret_value_unref(secretValue);\n\t\t\t\t}\n\t\t\t\t*username = get_attribute(\"username\", l->data);\n\t\t\t}\n\t\t\tg_list_free_full(items, g_object_unref);\n\t\t}\n\t\tg_object_unref(service);\n\t}\n\tg_hash_table_unref(attributes);\n\tif (err != NULL) {\n\t\treturn err;\n\t}\n\treturn NULL;\n}\n\nGError *list(char *ref_label, char *** paths, char *** accts, unsigned int *list_l) {\n\tGList *items;\n\tGError *err = NULL;\n\tSecretService *service;\n\tSecretSearchFlags flags = SECRET_SEARCH_LOAD_SECRETS | SECRET_SEARCH_ALL | SECRET_SEARCH_UNLOCK;\n\tGHashTable *attributes = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);\n\n\t// List credentials with the right label only\n\tg_hash_table_insert(attributes, g_strdup(\"label\"), g_strdup(ref_label));\n\n\tservice = secret_service_get_sync(SECRET_SERVICE_NONE, NULL, &err);\n\tif (err != NULL) {\n\t\treturn err;\n\t}\n\n\titems = secret_service_search_sync(service, NULL, attributes, flags, NULL, &err);\n\tint numKeys = g_list_length(items);\n\tif (err != NULL) {\n\t\treturn err;\n\t}\n\n\tchar **tmp_paths = (char **) calloc(1,(int)sizeof(char *)*numKeys);\n\tchar **tmp_accts = (char **) calloc(1,(int)sizeof(char *)*numKeys);\n\n\t// items now contains our keys from the gnome keyring\n\t// we will now put it in our two lists to return it to go\n\tGList *current;\n\tint listNumber = 0;\n\tfor(current = items; current!=NULL; current = current->next) {\n\t\tchar *pathTmp = secret_item_get_label(current->data);\n\t\t// you cannot have a key without a label in the gnome keyring\n\t\tchar *acctTmp = get_attribute(\"username\",current->data);\n\t\tif (acctTmp==NULL) {\n\t\t\tacctTmp = \"account not defined\";\n\t\t}\n\n\t\ttmp_paths[listNumber] = (char *) calloc(1, sizeof(char)*(strlen(pathTmp)+1));\n\t\ttmp_accts[listNumber] = (char *) calloc(1, sizeof(char)*(strlen(acctTmp)+1));\n\n\t\tmemcpy(tmp_paths[listNumber], pathTmp, sizeof(char)*(strlen(pathTmp)+1));\n\t\tmemcpy(tmp_accts[listNumber], acctTmp, sizeof(char)*(strlen(acctTmp)+1));\n\n\t\tlistNumber = listNumber + 1;\n\t}\n\n\t*paths = (char **) realloc(tmp_paths, (int)sizeof(char *)*listNumber);\n\t*accts = (char **) realloc(tmp_accts, (int)sizeof(char *)*listNumber);\n\n\t*list_l = listNumber;\n\n\treturn NULL;\n}\n\nvoid freeListData(char *** data, unsigned int length) {\n\tint i;\n\tfor(i=0; i<length; i++) {\n\t\tfree((*data)[i]);\n\t}\n}\n", "package secretservice\n\n/*\n#cgo pkg-config: libsecret-1\n\n#include \"secretservice_linux.h\"\n#include <stdlib.h>\n*/\nimport \"C\"\nimport (\n\t\"errors\"\n\t\"unsafe\"\n\n\t\"github.com/docker/docker-credential-helpers/credentials\"\n)\n\n// Secretservice handles secrets using Linux secret-service as a store.\ntype Secretservice struct{}\n\n// Add adds new credentials to the keychain.\nfunc (h Secretservice) Add(creds *credentials.Credentials) error {\n\tif creds == nil {\n\t\treturn errors.New(\"missing credentials\")\n\t}\n\tcredsLabel := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(credsLabel))\n\tserver := C.CString(creds.ServerURL)\n\tdefer C.free(unsafe.Pointer(server))\n\tusername := C.CString(creds.Username)\n\tdefer C.free(unsafe.Pointer(username))\n\tsecret := C.CString(creds.Secret)\n\tdefer C.free(unsafe.Pointer(secret))\n\n\tif err := C.add(credsLabel, server, username, secret); err != nil {\n\t\tdefer C.g_error_free(err)\n\t\terrMsg := (*C.char)(unsafe.Pointer(err.message))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\treturn nil\n}\n\n// Delete removes credentials from the store.\nfunc (h Secretservice) Delete(serverURL string) error {\n\tif serverURL == \"\" {\n\t\treturn errors.New(\"missing server url\")\n\t}\n\tserver := C.CString(serverURL)\n\tdefer C.free(unsafe.Pointer(server))\n\n\tif err := C.delete(server); err != nil {\n\t\tdefer C.g_error_free(err)\n\t\terrMsg := (*C.char)(unsafe.Pointer(err.message))\n\t\treturn errors.New(C.GoString(errMsg))\n\t}\n\treturn nil\n}\n\n// Get returns the username and secret to use for a given registry server URL.\nfunc (h Secretservice) Get(serverURL string) (string, string, error) {\n\tif serverURL == \"\" {\n\t\treturn \"\", \"\", errors.New(\"missing server url\")\n\t}\n\tvar username *C.char\n\tdefer C.free(unsafe.Pointer(username))\n\tvar secret *C.char\n\tdefer C.free(unsafe.Pointer(secret))\n\tserver := C.CString(serverURL)\n\tdefer C.free(unsafe.Pointer(server))\n\n\terr := C.get(server, &username, &secret)\n\tif err != nil {\n\t\tdefer C.g_error_free(err)\n\t\terrMsg := (*C.char)(unsafe.Pointer(err.message))\n\t\treturn \"\", \"\", errors.New(C.GoString(errMsg))\n\t}\n\tuser := C.GoString(username)\n\tpass := C.GoString(secret)\n\tif pass == \"\" {\n\t\treturn \"\", \"\", credentials.NewErrCredentialsNotFound()\n\t}\n\treturn user, pass, nil\n}\n\n// List returns the stored URLs and corresponding usernames for a given credentials label\nfunc (h Secretservice) List() (map[string]string, error) {\n\tcredsLabelC := C.CString(credentials.CredsLabel)\n\tdefer C.free(unsafe.Pointer(credsLabelC))\n\n\tvar pathsC **C.char\n\tdefer C.free(unsafe.Pointer(pathsC))\n\tvar acctsC **C.char\n\tdefer C.free(unsafe.Pointer(acctsC))\n\tvar listLenC C.uint\n\terr := C.list(credsLabelC, &pathsC, &acctsC, &listLenC)\n\tdefer C.freeListData(&pathsC, listLenC)\n\tdefer C.freeListData(&acctsC, listLenC)\n\tif err != nil {\n\t\tdefer C.g_error_free(err)\n\t\treturn nil, errors.New(\"Error from list function in secretservice_linux.c likely due to error in secretservice library\")\n\t}\n\n\tresp := make(map[string]string)\n\n\tlistLen := int(listLenC)\n\tif listLen == 0 {\n\t\treturn resp, nil\n\t}\n\t// The maximum capacity of the following two slices is limited to (2^29)-1 to remain compatible\n\t// with 32-bit platforms. The size of a `*C.char` (a pointer) is 4 Byte on a 32-bit system\n\t// and (2^29)*4 == math.MaxInt32 + 1. -- See issue golang/go#13656\n\tpathTmp := (*[(1 << 29) - 1]*C.char)(unsafe.Pointer(pathsC))[:listLen:listLen]\n\tacctTmp := (*[(1 << 29) - 1]*C.char)(unsafe.Pointer(acctsC))[:listLen:listLen]\n\tfor i := 0; i < listLen; i++ {\n\t\tresp[C.GoString(pathTmp[i])] = C.GoString(acctTmp[i])\n\t}\n\n\treturn resp, nil\n}\n"], "filenames": ["osxkeychain/osxkeychain_darwin.c", "osxkeychain/osxkeychain_darwin.go", "secretservice/secretservice_linux.c", "secretservice/secretservice_linux.go"], "buggy_code_start_loc": [227, 111, 161, 94], "buggy_code_end_loc": [229, 124, 162, 101], "fixing_code_start_loc": [227, 112, 160, 95], "fixing_code_end_loc": [228, 122, 160, 100], "type": "CWE-415", "message": "docker-credential-helpers before 0.6.3 has a double free in the List functions.", "other": {"cve": {"id": "CVE-2019-1020014", "sourceIdentifier": "josh@bress.net", "published": "2019-07-29T13:15:11.997", "lastModified": "2022-10-06T20:20:30.410", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "docker-credential-helpers before 0.6.3 has a double free in the List functions."}, {"lang": "es", "value": "docker-credential-helpers anterior a versi\u00f3n 0.6.3, presenta una Vulnerabilidad de Doble Liberaci\u00f3n en las funciones List."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:docker:credential_helpers:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.3", "matchCriteriaId": "4DAD4CE2-D5C5-4BCE-A07F-61018736CDE0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}], "references": [{"url": "https://github.com/docker/docker-credential-helpers/commit/1c9f7ede70a5ab9851f4c9cb37d317fd89cd318a", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/docker/docker-credential-helpers/releases/tag/v0.6.3", "source": "josh@bress.net", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6VVFB6UWUK2GQQN7DVUU6GRRAL637A73/", "source": "josh@bress.net", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4103-1/", "source": "josh@bress.net", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4103-2/", "source": "josh@bress.net", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/docker/docker-credential-helpers/commit/1c9f7ede70a5ab9851f4c9cb37d317fd89cd318a"}}