{"buggy_code": ["/*\n * n_tty.c --- implements the N_TTY line discipline.\n *\n * This code used to be in tty_io.c, but things are getting hairy\n * enough that it made sense to split things off.  (The N_TTY\n * processing has changed so much that it's hardly recognizable,\n * anyway...)\n *\n * Note that the open routine for N_TTY is guaranteed never to return\n * an error.  This is because Linux will fall back to setting a line\n * to N_TTY if it can not switch to any other line discipline.\n *\n * Written by Theodore Ts'o, Copyright 1994.\n *\n * This file also contains code originally written by Linus Torvalds,\n * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.\n *\n * This file may be redistributed under the terms of the GNU General Public\n * License.\n *\n * Reduced memory usage for older ARM systems  - Russell King.\n *\n * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of\n *\t\tthe patch by Andrew J. Kroll <ag784@freenet.buffalo.edu>\n *\t\twho actually finally proved there really was a race.\n *\n * 2002/03/18   Implemented n_tty_wakeup to send SIGIO POLL_OUTs to\n *\t\twaiting writing processes-Sapan Bhatia <sapan@corewars.org>.\n *\t\tAlso fixed a bug in BLOCKING mode where n_tty_write returns\n *\t\tEAGAIN\n */\n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/audit.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n\n\n/* number of characters left in xmit buffer before select has we have room */\n#define WAKEUP_CHARS 256\n\n/*\n * This defines the low- and high-watermarks for throttling and\n * unthrottling the TTY driver.  These watermarks are used for\n * controlling the space in the read buffer.\n */\n#define TTY_THRESHOLD_THROTTLE\t\t128 /* now based on remaining room */\n#define TTY_THRESHOLD_UNTHROTTLE\t128\n\n/*\n * Special byte codes used in the echo buffer to represent operations\n * or special handling of characters.  Bytes in the echo buffer that\n * are not part of such special blocks are treated as normal character\n * codes.\n */\n#define ECHO_OP_START 0xff\n#define ECHO_OP_MOVE_BACK_COL 0x80\n#define ECHO_OP_SET_CANON_COL 0x81\n#define ECHO_OP_ERASE_TAB 0x82\n\n#define ECHO_COMMIT_WATERMARK\t256\n#define ECHO_BLOCK\t\t256\n#define ECHO_DISCARD_WATERMARK\tN_TTY_BUF_SIZE - (ECHO_BLOCK + 32)\n\n\n#undef N_TTY_TRACE\n#ifdef N_TTY_TRACE\n# define n_tty_trace(f, args...)\ttrace_printk(f, ##args)\n#else\n# define n_tty_trace(f, args...)\n#endif\n\nstruct n_tty_data {\n\t/* producer-published */\n\tsize_t read_head;\n\tsize_t canon_head;\n\tsize_t echo_head;\n\tsize_t echo_commit;\n\tsize_t echo_mark;\n\tDECLARE_BITMAP(char_map, 256);\n\n\t/* private to n_tty_receive_overrun (single-threaded) */\n\tunsigned long overrun_time;\n\tint num_overrun;\n\n\t/* non-atomic */\n\tbool no_room;\n\n\t/* must hold exclusive termios_rwsem to reset these */\n\tunsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;\n\tunsigned char push:1;\n\n\t/* shared by producer and consumer */\n\tchar read_buf[N_TTY_BUF_SIZE];\n\tDECLARE_BITMAP(read_flags, N_TTY_BUF_SIZE);\n\tunsigned char echo_buf[N_TTY_BUF_SIZE];\n\n\tint minimum_to_wake;\n\n\t/* consumer-published */\n\tsize_t read_tail;\n\tsize_t line_start;\n\n\t/* protected by output lock */\n\tunsigned int column;\n\tunsigned int canon_column;\n\tsize_t echo_tail;\n\n\tstruct mutex atomic_read_lock;\n\tstruct mutex output_lock;\n};\n\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n\nstatic inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char echo_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *echo_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline int tty_put_user(struct tty_struct *tty, unsigned char x,\n\t\t\t       unsigned char __user *ptr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\ttty_audit_add_data(tty, &x, 1, ldata->icanon);\n\treturn put_user(x, ptr);\n}\n\nstatic int receive_room(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint left;\n\n\tif (I_PARMRK(tty)) {\n\t\t/* Multiply read_cnt by 3, since each byte might take up to\n\t\t * three times as many spaces when PARMRK is set (depending on\n\t\t * its flags, e.g. parity error). */\n\t\tleft = N_TTY_BUF_SIZE - read_cnt(ldata) * 3 - 1;\n\t} else\n\t\tleft = N_TTY_BUF_SIZE - read_cnt(ldata) - 1;\n\n\t/*\n\t * If we are doing input canonicalization, and there are no\n\t * pending newlines, let characters through without limit, so\n\t * that erase characters will be handled.  Other excess\n\t * characters will be beeped.\n\t */\n\tif (left <= 0)\n\t\tleft = ldata->icanon && ldata->canon_head == ldata->read_tail;\n\n\treturn left;\n}\n\n/**\n *\tn_tty_set_room\t-\treceive space\n *\t@tty: terminal\n *\n *\tRe-schedules the flip buffer work if space just became available.\n *\n *\tCaller holds exclusive termios_rwsem\n *\t   or\n *\tn_tty_read()/consumer path:\n *\t\tholds non-exclusive termios_rwsem\n */\n\nstatic void n_tty_set_room(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t/* Did this open up the receive buffer? We may need to flip */\n\tif (unlikely(ldata->no_room) && receive_room(tty)) {\n\t\tldata->no_room = 0;\n\n\t\tWARN_RATELIMIT(tty->port->itty == NULL,\n\t\t\t\t\"scheduling with invalid itty\\n\");\n\t\t/* see if ldisc has been killed - if so, this means that\n\t\t * even though the ldisc has been halted and ->buf.work\n\t\t * cancelled, ->buf.work is about to be rescheduled\n\t\t */\n\t\tWARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),\n\t\t\t       \"scheduling buffer work for halted ldisc\\n\");\n\t\tqueue_work(system_unbound_wq, &tty->port->buf.work);\n\t}\n}\n\nstatic ssize_t chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tssize_t n = 0;\n\n\tif (!ldata->icanon)\n\t\tn = read_cnt(ldata);\n\telse\n\t\tn = ldata->canon_head - ldata->read_tail;\n\treturn n;\n}\n\n/**\n *\tn_tty_write_wakeup\t-\tasynchronous I/O notifier\n *\t@tty: tty device\n *\n *\tRequired for the ptys, serial driver etc. since processes\n *\tthat attach themselves to the master and rely on ASYNC\n *\tIO must be woken up\n */\n\nstatic void n_tty_write_wakeup(struct tty_struct *tty)\n{\n\tif (tty->fasync && test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags))\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void n_tty_check_throttle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY)\n\t\treturn;\n\t/*\n\t * Check the remaining room for the input canonicalization\n\t * mode.  We don't want to throttle the driver if we're in\n\t * canonical mode and don't have a newline yet!\n\t */\n\twhile (1) {\n\t\tint throttled;\n\t\ttty_set_flow_change(tty, TTY_THROTTLE_SAFE);\n\t\tif (receive_room(tty) >= TTY_THRESHOLD_THROTTLE)\n\t\t\tbreak;\n\t\tthrottled = tty_throttle_safe(tty);\n\t\tif (!throttled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->link->ldisc->ops->write_wakeup == n_tty_write_wakeup) {\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\treturn;\n\t\tif (!tty->count)\n\t\t\treturn;\n\t\tn_tty_set_room(tty);\n\t\tn_tty_write_wakeup(tty->link);\n\t\tif (waitqueue_active(&tty->link->write_wait))\n\t\t\twake_up_interruptible_poll(&tty->link->write_wait, POLLOUT);\n\t\treturn;\n\t}\n\n\t/* If there is enough space in the read buffer now, let the\n\t * low-level driver know. We use chars_in_buffer() to\n\t * check the buffer, as it now knows about canonical mode.\n\t * Otherwise, if the driver is throttled and the line is\n\t * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,\n\t * we won't get any more characters.\n\t */\n\n\twhile (1) {\n\t\tint unthrottled;\n\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\tbreak;\n\t\tif (!tty->count)\n\t\t\tbreak;\n\t\tn_tty_set_room(tty);\n\t\tunthrottled = tty_unthrottle_safe(tty);\n\t\tif (!unthrottled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\n/**\n *\tput_tty_queue\t\t-\tadd character to tty\n *\t@c: character\n *\t@ldata: n_tty data\n *\n *\tAdd a character to the tty read_buf queue.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tmodifies read_head\n *\n *\tread_head is only considered 'published' if canonical mode is\n *\tnot active.\n */\n\nstatic inline void put_tty_queue(unsigned char c, struct n_tty_data *ldata)\n{\n\t*read_buf_addr(ldata, ldata->read_head++) = c;\n}\n\n/**\n *\treset_buffer_flags\t-\treset buffer state\n *\t@tty: terminal to reset\n *\n *\tReset the read buffer counters and clear the flags.\n *\tCalled from n_tty_open() and n_tty_flush_buffer().\n *\n *\tLocking: caller holds exclusive termios_rwsem\n *\t\t (or locking is not required)\n */\n\nstatic void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}\n\nstatic void n_tty_packet_mode_flush(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\tif (tty->link->packet) {\n\t\ttty->ctrl_status |= TIOCPKT_FLUSHREAD;\n\t\tif (waitqueue_active(&tty->link->read_wait))\n\t\t\twake_up_interruptible(&tty->link->read_wait);\n\t}\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n}\n\n/**\n *\tn_tty_flush_buffer\t-\tclean input queue\n *\t@tty:\tterminal device\n *\n *\tFlush the input buffer. Called when the tty layer wants the\n *\tbuffer flushed (eg at hangup) or when the N_TTY line discipline\n *\tinternally has to clean the pending queue (for example some signals).\n *\n *\tHolds termios_rwsem to exclude producer/consumer while\n *\tbuffer indices are reset.\n *\n *\tLocking: ctrl_lock, exclusive termios_rwsem\n */\n\nstatic void n_tty_flush_buffer(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\treset_buffer_flags(tty->disc_data);\n\tn_tty_set_room(tty);\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tup_write(&tty->termios_rwsem);\n}\n\n/**\n *\tn_tty_chars_in_buffer\t-\treport available bytes\n *\t@tty: tty device\n *\n *\tReport the number of characters buffered to be delivered to user\n *\tat this instant in time.\n *\n *\tLocking: exclusive termios_rwsem\n */\n\nstatic ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}\n\n/**\n *\tis_utf8_continuation\t-\tutf8 multibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter. We use this to correctly compute the on screen size\n *\tof the character when printing\n */\n\nstatic inline int is_utf8_continuation(unsigned char c)\n{\n\treturn (c & 0xc0) == 0x80;\n}\n\n/**\n *\tis_continuation\t\t-\tmultibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter and the terminal is in unicode mode.\n */\n\nstatic inline int is_continuation(unsigned char c, struct tty_struct *tty)\n{\n\treturn I_IUTF8(tty) && is_utf8_continuation(c);\n}\n\n/**\n *\tdo_output_char\t\t\t-\toutput one character\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\t@space: space available in tty driver write buffer\n *\n *\tThis is a helper function that handles one output character\n *\t(including special characters like TAB, CR, LF, etc.),\n *\tdoing OPOST processing and putting the results in the\n *\ttty driver's write buffer.\n *\n *\tNote that Linux currently ignores TABDLY, CRDLY, VTDLY, FFDLY\n *\tand NLDLY.  They simply aren't relevant in the world today.\n *\tIf you ever need them, add them here.\n *\n *\tReturns the number of bytes of buffer space used or -1 if\n *\tno space left.\n *\n *\tLocking: should be called under the output_lock to protect\n *\t\t the column state and space left in the buffer\n */\n\nstatic int do_output_char(unsigned char c, struct tty_struct *tty, int space)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspaces;\n\n\tif (!space)\n\t\treturn -1;\n\n\tswitch (c) {\n\tcase '\\n':\n\t\tif (O_ONLRET(tty))\n\t\t\tldata->column = 0;\n\t\tif (O_ONLCR(tty)) {\n\t\t\tif (space < 2)\n\t\t\t\treturn -1;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\ttty->ops->write(tty, \"\\r\\n\", 2);\n\t\t\treturn 2;\n\t\t}\n\t\tldata->canon_column = ldata->column;\n\t\tbreak;\n\tcase '\\r':\n\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\treturn 0;\n\t\tif (O_OCRNL(tty)) {\n\t\t\tc = '\\n';\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\t}\n\t\tldata->canon_column = ldata->column = 0;\n\t\tbreak;\n\tcase '\\t':\n\t\tspaces = 8 - (ldata->column & 7);\n\t\tif (O_TABDLY(tty) == XTABS) {\n\t\t\tif (space < spaces)\n\t\t\t\treturn -1;\n\t\t\tldata->column += spaces;\n\t\t\ttty->ops->write(tty, \"        \", spaces);\n\t\t\treturn spaces;\n\t\t}\n\t\tldata->column += spaces;\n\t\tbreak;\n\tcase '\\b':\n\t\tif (ldata->column > 0)\n\t\t\tldata->column--;\n\t\tbreak;\n\tdefault:\n\t\tif (!iscntrl(c)) {\n\t\t\tif (O_OLCUC(tty))\n\t\t\t\tc = toupper(c);\n\t\t\tif (!is_continuation(c, tty))\n\t\t\t\tldata->column++;\n\t\t}\n\t\tbreak;\n\t}\n\n\ttty_put_char(tty, c);\n\treturn 1;\n}\n\n/**\n *\tprocess_output\t\t\t-\toutput post processor\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\n *\tOutput one character with OPOST processing.\n *\tReturns -1 when the output device is full and the character\n *\tmust be retried.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic int process_output(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, retval;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tretval = do_output_char(c, tty, space);\n\n\tmutex_unlock(&ldata->output_lock);\n\tif (retval < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n/**\n *\tprocess_output_block\t\t-\tblock post processor\n *\t@tty: terminal device\n *\t@buf: character buffer\n *\t@nr: number of bytes to output\n *\n *\tOutput a block of characters with OPOST processing.\n *\tReturns the number of characters output.\n *\n *\tThis path is used to speed up block console writes, among other\n *\tthings when processing blocks of output data. It handles only\n *\tthe simple cases normally found and helps to generate blocks of\n *\tsymbols for the console driver and thus improve performance.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}\n\n/**\n *\tprocess_echoes\t-\twrite pending echo characters\n *\t@tty: terminal device\n *\n *\tWrite previously buffered echo (and other ldisc-generated)\n *\tcharacters to the tty.\n *\n *\tCharacters generated by the ldisc (including echoes) need to\n *\tbe buffered because the driver's write buffer can fill during\n *\theavy program output.  Echoing straight to the driver will\n *\toften fail under these conditions, causing lost characters and\n *\tresulting mismatches of ldisc state information.\n *\n *\tSince the ldisc state must represent the characters actually sent\n *\tto the driver at the time of the write, operations like certain\n *\tchanges in column state are also saved in the buffer and executed\n *\there.\n *\n *\tA circular fifo buffer is used so that the most recent characters\n *\tare prioritized.  Also, when control characters are echoed with a\n *\tprefixed \"^\", the pair is treated atomically and thus not separated.\n *\n *\tLocking: callers must hold output_lock\n */\n\nstatic size_t __process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, old_space;\n\tsize_t tail;\n\tunsigned char c;\n\n\told_space = space = tty_write_room(tty);\n\n\ttail = ldata->echo_tail;\n\twhile (ldata->echo_commit != tail) {\n\t\tc = echo_buf(ldata, tail);\n\t\tif (c == ECHO_OP_START) {\n\t\t\tunsigned char op;\n\t\t\tint no_space_left = 0;\n\n\t\t\t/*\n\t\t\t * If the buffer byte is the start of a multi-byte\n\t\t\t * operation, get the next byte, which is either the\n\t\t\t * op code or a control character value.\n\t\t\t */\n\t\t\top = echo_buf(ldata, tail + 1);\n\n\t\t\tswitch (op) {\n\t\t\t\tunsigned int num_chars, num_bs;\n\n\t\t\tcase ECHO_OP_ERASE_TAB:\n\t\t\t\tnum_chars = echo_buf(ldata, tail + 2);\n\n\t\t\t\t/*\n\t\t\t\t * Determine how many columns to go back\n\t\t\t\t * in order to erase the tab.\n\t\t\t\t * This depends on the number of columns\n\t\t\t\t * used by other characters within the tab\n\t\t\t\t * area.  If this (modulo 8) count is from\n\t\t\t\t * the start of input rather than from a\n\t\t\t\t * previous tab, we offset by canon column.\n\t\t\t\t * Otherwise, tab spacing is normal.\n\t\t\t\t */\n\t\t\t\tif (!(num_chars & 0x80))\n\t\t\t\t\tnum_chars += ldata->canon_column;\n\t\t\t\tnum_bs = 8 - (num_chars & 7);\n\n\t\t\t\tif (num_bs > space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspace -= num_bs;\n\t\t\t\twhile (num_bs--) {\n\t\t\t\t\ttty_put_char(tty, '\\b');\n\t\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\t\tldata->column--;\n\t\t\t\t}\n\t\t\t\ttail += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_SET_CANON_COL:\n\t\t\t\tldata->canon_column = ldata->column;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_MOVE_BACK_COL:\n\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\tldata->column--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_START:\n\t\t\t\t/* This is an escaped echo op start code */\n\t\t\t\tif (!space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, ECHO_OP_START);\n\t\t\t\tldata->column++;\n\t\t\t\tspace--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * If the op is not a special byte code,\n\t\t\t\t * it is a ctrl char tagged to be echoed\n\t\t\t\t * as \"^X\" (where X is the letter\n\t\t\t\t * representing the control char).\n\t\t\t\t * Note that we must ensure there is\n\t\t\t\t * enough space for the whole ctrl pair.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (space < 2) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, '^');\n\t\t\t\ttty_put_char(tty, op ^ 0100);\n\t\t\t\tldata->column += 2;\n\t\t\t\tspace -= 2;\n\t\t\t\ttail += 2;\n\t\t\t}\n\n\t\t\tif (no_space_left)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (O_OPOST(tty)) {\n\t\t\t\tint retval = do_output_char(c, tty, space);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tspace -= retval;\n\t\t\t} else {\n\t\t\t\tif (!space)\n\t\t\t\t\tbreak;\n\t\t\t\ttty_put_char(tty, c);\n\t\t\t\tspace -= 1;\n\t\t\t}\n\t\t\ttail += 1;\n\t\t}\n\t}\n\n\t/* If the echo buffer is nearly full (so that the possibility exists\n\t * of echo overrun before the next commit), then discard enough\n\t * data at the tail to prevent a subsequent overrun */\n\twhile (ldata->echo_commit - tail >= ECHO_DISCARD_WATERMARK) {\n\t\tif (echo_buf(ldata, tail) == ECHO_OP_START) {\n\t\t\tif (echo_buf(ldata, tail + 1) == ECHO_OP_ERASE_TAB)\n\t\t\t\ttail += 3;\n\t\t\telse\n\t\t\t\ttail += 2;\n\t\t} else\n\t\t\ttail++;\n\t}\n\n\tldata->echo_tail = tail;\n\treturn old_space - space;\n}\n\nstatic void commit_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t nr, old, echoed;\n\tsize_t head;\n\n\thead = ldata->echo_head;\n\tldata->echo_mark = head;\n\told = ldata->echo_commit - ldata->echo_tail;\n\n\t/* Process committed echoes if the accumulated # of bytes\n\t * is over the threshold (and try again each time another\n\t * block is accumulated) */\n\tnr = head - ldata->echo_tail;\n\tif (nr < ECHO_COMMIT_WATERMARK || (nr % ECHO_BLOCK > old % ECHO_BLOCK))\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = head;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\nstatic void process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t echoed;\n\n\tif (ldata->echo_mark == ldata->echo_tail)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_mark;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\n/* NB: echo_mark and echo_head should be equivalent here */\nstatic void flush_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif ((!L_ECHO(tty) && !L_ECHONL(tty)) ||\n\t    ldata->echo_commit == ldata->echo_head)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_head;\n\t__process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n}\n\n/**\n *\tadd_echo_byte\t-\tadd a byte to the echo buffer\n *\t@c: unicode byte to echo\n *\t@ldata: n_tty data\n *\n *\tAdd a character or operation byte to the echo buffer.\n */\n\nstatic inline void add_echo_byte(unsigned char c, struct n_tty_data *ldata)\n{\n\t*echo_buf_addr(ldata, ldata->echo_head++) = c;\n}\n\n/**\n *\techo_move_back_col\t-\tadd operation to move back a column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to move back one column.\n */\n\nstatic void echo_move_back_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_MOVE_BACK_COL, ldata);\n}\n\n/**\n *\techo_set_canon_col\t-\tadd operation to set the canon column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to set the canon column\n *\tto the current column.\n */\n\nstatic void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n\n/**\n *\techo_erase_tab\t-\tadd operation to erase a tab\n *\t@num_chars: number of character columns already used\n *\t@after_tab: true if num_chars starts after a previous tab\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to erase a tab.\n *\n *\tCalled by the eraser function, which knows how many character\n *\tcolumns have been used since either a previous tab or the start\n *\tof input.  This information will be used later, along with\n *\tcanon column (if applicable), to go back the correct number\n *\tof columns.\n */\n\nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\n\t\t\t   struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_ERASE_TAB, ldata);\n\n\t/* We only need to know this modulo 8 (tab spacing) */\n\tnum_chars &= 7;\n\n\t/* Set the high bit as a flag if num_chars is after a previous tab */\n\tif (after_tab)\n\t\tnum_chars |= 0x80;\n\n\tadd_echo_byte(num_chars, ldata);\n}\n\n/**\n *\techo_char_raw\t-\techo a character raw\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant does not treat control characters specially.\n */\n\nstatic void echo_char_raw(unsigned char c, struct n_tty_data *ldata)\n{\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\techo_char\t-\techo a character\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant tags control characters to be echoed as \"^X\"\n *\t(where X is the letter representing the control char).\n */\n\nstatic void echo_char(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tif (L_ECHOCTL(tty) && iscntrl(c) && c != '\\t')\n\t\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\tfinish_erasing\t\t-\tcomplete erase\n *\t@ldata: n_tty data\n */\n\nstatic inline void finish_erasing(struct n_tty_data *ldata)\n{\n\tif (ldata->erasing) {\n\t\techo_char_raw('/', ldata);\n\t\tldata->erasing = 0;\n\t}\n}\n\n/**\n *\teraser\t\t-\thandle erase function\n *\t@c: character input\n *\t@tty: terminal device\n *\n *\tPerform erase and necessary output when an erase character is\n *\tpresent in the stream from the driver layer. Handles the complexities\n *\tof UTF-8 multibyte symbols.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tmodifies read_head\n *\n *\tModifying the read_head is not considered a publish in this context\n *\tbecause canonical mode is active -- only canon_head publishes\n */\n\nstatic void eraser(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tenum { ERASE, WERASE, KILL } kill_type;\n\tsize_t head;\n\tsize_t cnt;\n\tint seen_alnums;\n\n\tif (ldata->read_head == ldata->canon_head) {\n\t\t/* process_output('\\a', tty); */ /* what do you think? */\n\t\treturn;\n\t}\n\tif (c == ERASE_CHAR(tty))\n\t\tkill_type = ERASE;\n\telse if (c == WERASE_CHAR(tty))\n\t\tkill_type = WERASE;\n\telse {\n\t\tif (!L_ECHO(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\treturn;\n\t\t}\n\t\tif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(KILL_CHAR(tty), tty);\n\t\t\t/* Add a newline if ECHOK is on and ECHOKE is off. */\n\t\t\tif (L_ECHOK(tty))\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\treturn;\n\t\t}\n\t\tkill_type = KILL;\n\t}\n\n\tseen_alnums = 0;\n\twhile (ldata->read_head != ldata->canon_head) {\n\t\thead = ldata->read_head;\n\n\t\t/* erase a single possibly multibyte character */\n\t\tdo {\n\t\t\thead--;\n\t\t\tc = read_buf(ldata, head);\n\t\t} while (is_continuation(c, tty) && head != ldata->canon_head);\n\n\t\t/* do not partially erase */\n\t\tif (is_continuation(c, tty))\n\t\t\tbreak;\n\n\t\tif (kill_type == WERASE) {\n\t\t\t/* Equivalent to BSD's ALTWERASE. */\n\t\t\tif (isalnum(c) || c == '_')\n\t\t\t\tseen_alnums++;\n\t\t\telse if (seen_alnums)\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt = ldata->read_head - head;\n\t\tldata->read_head = head;\n\t\tif (L_ECHO(tty)) {\n\t\t\tif (L_ECHOPRT(tty)) {\n\t\t\t\tif (!ldata->erasing) {\n\t\t\t\t\techo_char_raw('\\\\', ldata);\n\t\t\t\t\tldata->erasing = 1;\n\t\t\t\t}\n\t\t\t\t/* if cnt > 1, output a multi-byte character */\n\t\t\t\techo_char(c, tty);\n\t\t\t\twhile (--cnt > 0) {\n\t\t\t\t\thead++;\n\t\t\t\t\techo_char_raw(read_buf(ldata, head), ldata);\n\t\t\t\t\techo_move_back_col(ldata);\n\t\t\t\t}\n\t\t\t} else if (kill_type == ERASE && !L_ECHOE(tty)) {\n\t\t\t\techo_char(ERASE_CHAR(tty), tty);\n\t\t\t} else if (c == '\\t') {\n\t\t\t\tunsigned int num_chars = 0;\n\t\t\t\tint after_tab = 0;\n\t\t\t\tsize_t tail = ldata->read_head;\n\n\t\t\t\t/*\n\t\t\t\t * Count the columns used for characters\n\t\t\t\t * since the start of input or after a\n\t\t\t\t * previous tab.\n\t\t\t\t * This info is used to go back the correct\n\t\t\t\t * number of columns.\n\t\t\t\t */\n\t\t\t\twhile (tail != ldata->canon_head) {\n\t\t\t\t\ttail--;\n\t\t\t\t\tc = read_buf(ldata, tail);\n\t\t\t\t\tif (c == '\\t') {\n\t\t\t\t\t\tafter_tab = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (iscntrl(c)) {\n\t\t\t\t\t\tif (L_ECHOCTL(tty))\n\t\t\t\t\t\t\tnum_chars += 2;\n\t\t\t\t\t} else if (!is_continuation(c, tty)) {\n\t\t\t\t\t\tnum_chars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\techo_erase_tab(num_chars, after_tab, ldata);\n\t\t\t} else {\n\t\t\t\tif (iscntrl(c) && L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t\tif (!iscntrl(c) || L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (kill_type == ERASE)\n\t\t\tbreak;\n\t}\n\tif (ldata->read_head == ldata->canon_head && L_ECHO(tty))\n\t\tfinish_erasing(ldata);\n}\n\n/**\n *\tisig\t\t-\thandle the ISIG optio\n *\t@sig: signal\n *\t@tty: terminal\n *\n *\tCalled when a signal is being sent due to terminal input.\n *\tCalled from the driver receive_buf path so serialized.\n *\n *\tLocking: ctrl_lock\n */\n\nstatic void isig(int sig, struct tty_struct *tty)\n{\n\tstruct pid *tty_pgrp = tty_get_pgrp(tty);\n\tif (tty_pgrp) {\n\t\tkill_pgrp(tty_pgrp, sig, 1);\n\t\tput_pid(tty_pgrp);\n\t}\n}\n\n/**\n *\tn_tty_receive_break\t-\thandle break\n *\t@tty: terminal\n *\n *\tAn RS232 break event has been hit in the incoming bitstream. This\n *\tcan cause a variety of events depending upon the termios settings.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes read_head via put_tty_queue()\n *\n *\tNote: may get exclusive termios_rwsem if flushing input buffer\n */\n\nstatic void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\t/* flushing needs exclusive termios_rwsem */\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}\n\n/**\n *\tn_tty_receive_overrun\t-\thandle overrun reporting\n *\t@tty: terminal\n *\n *\tData arrived faster than we could process it. While the tty\n *\tdriver has flagged this the bits that were missed are gone\n *\tforever.\n *\n *\tCalled from the receive_buf path so single threaded. Does not\n *\tneed locking as num_overrun and overrun_time are function\n *\tprivate.\n */\n\nstatic void n_tty_receive_overrun(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar buf[64];\n\n\tldata->num_overrun++;\n\tif (time_after(jiffies, ldata->overrun_time + HZ) ||\n\t\t\ttime_after(ldata->overrun_time, jiffies)) {\n\t\tprintk(KERN_WARNING \"%s: %d input overrun(s)\\n\",\n\t\t\ttty_name(tty, buf),\n\t\t\tldata->num_overrun);\n\t\tldata->overrun_time = jiffies;\n\t\tldata->num_overrun = 0;\n\t}\n}\n\n/**\n *\tn_tty_receive_parity_error\t-\terror notifier\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess a parity error and queue the right data to indicate\n *\tthe error case if necessary.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes read_head via put_tty_queue()\n */\nstatic void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNPAR(tty))\n\t\treturn;\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t\tput_tty_queue(c, ldata);\n\t} else\tif (I_INPCK(tty))\n\t\tput_tty_queue('\\0', ldata);\n\telse\n\t\tput_tty_queue(c, ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}\n\nstatic void\nn_tty_receive_signal_char(struct tty_struct *tty, int signal, unsigned char c)\n{\n\tif (!L_NOFLSH(tty)) {\n\t\t/* flushing needs exclusive termios_rwsem */\n\t\tup_read(&tty->termios_rwsem);\n\t\tn_tty_flush_buffer(tty);\n\t\ttty_driver_flush_buffer(tty);\n\t\tdown_read(&tty->termios_rwsem);\n\t}\n\tif (I_IXON(tty))\n\t\tstart_tty(tty);\n\tif (L_ECHO(tty)) {\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t} else\n\t\tprocess_echoes(tty);\n\tisig(signal, tty);\n\treturn;\n}\n\n/**\n *\tn_tty_receive_char\t-\tperform processing\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess an individual character of input received from the driver.\n *\tThis is serialized with respect to itself by the rules for the\n *\tdriver above.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes canon_head if canonical mode is active\n *\t\totherwise, publishes read_head via put_tty_queue()\n *\n *\tReturns 1 if LNEXT was received, else returns 0\n */\n\nstatic int\nn_tty_receive_char_special(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IXON(tty)) {\n\t\tif (c == START_CHAR(tty)) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == STOP_CHAR(tty)) {\n\t\t\tstop_tty(tty);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ISIG(tty)) {\n\t\tif (c == INTR_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGINT, c);\n\t\t\treturn 0;\n\t\t} else if (c == QUIT_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGQUIT, c);\n\t\t\treturn 0;\n\t\t} else if (c == SUSP_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGTSTP, c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\tif (c == '\\r') {\n\t\tif (I_IGNCR(tty))\n\t\t\treturn 0;\n\t\tif (I_ICRNL(tty))\n\t\t\tc = '\\n';\n\t} else if (c == '\\n' && I_INLCR(tty))\n\t\tc = '\\r';\n\n\tif (ldata->icanon) {\n\t\tif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\n\t\t    (c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\teraser(c, tty);\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\n\t\t\tldata->lnext = 1;\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\tfinish_erasing(ldata);\n\t\t\t\tif (L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('^', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\tcommit_echoes(tty);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (c == REPRINT_CHAR(tty) && L_ECHO(tty) && L_IEXTEN(tty)) {\n\t\t\tsize_t tail = ldata->canon_head;\n\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(c, tty);\n\t\t\techo_char_raw('\\n', ldata);\n\t\t\twhile (tail != ldata->read_head) {\n\t\t\t\techo_char(read_buf(ldata, tail), tty);\n\t\t\t\ttail++;\n\t\t\t}\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (L_ECHO(tty) || L_ECHONL(tty)) {\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif (c == EOF_CHAR(tty)) {\n\t\t\tc = __DISABLED_CHAR;\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif ((c == EOL_CHAR(tty)) ||\n\t\t    (c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\t/*\n\t\t\t * XXX are EOL_CHAR and EOL2_CHAR echoed?!?\n\t\t\t */\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\t/* Record the column of first canon char. */\n\t\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\t\techo_set_canon_col(ldata);\n\t\t\t\techo_char(c, tty);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\t/*\n\t\t\t * XXX does PARMRK doubling happen for\n\t\t\t * EOL_CHAR and EOL2_CHAR?\n\t\t\t */\n\t\t\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\t\t\tput_tty_queue(c, ldata);\n\nhandle_newline:\n\t\t\tset_bit(ldata->read_head & (N_TTY_BUF_SIZE - 1), ldata->read_flags);\n\t\t\tput_tty_queue(c, ldata);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\t\tif (waitqueue_active(&tty->read_wait))\n\t\t\t\twake_up_interruptible(&tty->read_wait);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\tif (c == '\\n')\n\t\t\techo_char_raw('\\n', ldata);\n\t\telse {\n\t\t\t/* Record the column of first canon char. */\n\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\techo_set_canon_col(ldata);\n\t\t\techo_char(c, tty);\n\t\t}\n\t\tcommit_echoes(tty);\n\t}\n\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\n\tput_tty_queue(c, ldata);\n\treturn 0;\n}\n\nstatic inline void\nn_tty_receive_char_inline(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\n{\n\tn_tty_receive_char_inline(tty, c);\n}\n\nstatic inline void\nn_tty_receive_char_fast(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c)\n{\n\tif (I_ISTRIP(tty))\n\t\tc &= 0x7f;\n\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\tc = tolower(c);\n\n\tif (I_IXON(tty)) {\n\t\tif (c == STOP_CHAR(tty))\n\t\t\tstop_tty(tty);\n\t\telse if (c == START_CHAR(tty) ||\n\t\t\t (tty->stopped && !tty->flow_stopped && I_IXANY(tty) &&\n\t\t\t  c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&\n\t\t\t  c != SUSP_CHAR(tty))) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t}\n\t}\n}\n\nstatic void\nn_tty_receive_char_flagged(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tchar buf[64];\n\n\tswitch (flag) {\n\tcase TTY_BREAK:\n\t\tn_tty_receive_break(tty);\n\t\tbreak;\n\tcase TTY_PARITY:\n\tcase TTY_FRAME:\n\t\tn_tty_receive_parity_error(tty, c);\n\t\tbreak;\n\tcase TTY_OVERRUN:\n\t\tn_tty_receive_overrun(tty);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: unknown flag %d\\n\",\n\t\t       tty_name(tty, buf), flag);\n\t\tbreak;\n\t}\n}\n\nstatic void\nn_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->lnext = 0;\n\tif (likely(flag == TTY_NORMAL)) {\n\t\tif (I_ISTRIP(tty))\n\t\t\tc &= 0x7f;\n\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\tc = tolower(c);\n\t\tn_tty_receive_char(tty, c);\n\t} else\n\t\tn_tty_receive_char_flagged(tty, c, flag);\n}\n\n/**\n *\tn_tty_receive_buf\t-\tdata receive\n *\t@tty: terminal device\n *\t@cp: buffer\n *\t@fp: flag buffer\n *\t@count: characters\n *\n *\tCalled by the terminal driver when a block of characters has\n *\tbeen received. This function must be called from soft contexts\n *\tnot from interrupt context. The driver is responsible for making\n *\tcalls one at a time and in order (or using flush_to_ldisc)\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes read_head and canon_head\n */\n\nstatic void\nn_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t   char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, head;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = N_TTY_BUF_SIZE - max(read_cnt(ldata), head);\n\tn = min_t(size_t, count, n);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n\tcp += n;\n\tcount -= n;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = N_TTY_BUF_SIZE - max(read_cnt(ldata), head);\n\tn = min_t(size_t, count, n);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n}\n\nstatic void\nn_tty_receive_buf_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t      char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tput_tty_queue(*cp++, ldata);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_standard(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (I_ISTRIP(tty))\n\t\t\t\tc &= 0x7f;\n\t\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\t\tc = tolower(c);\n\t\t\tif (L_EXTPROC(tty)) {\n\t\t\t\tput_tty_queue(c, ldata);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_inline(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_fast(struct tty_struct *tty, const unsigned char *cp,\n\t\t       char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_fast(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void __receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tbool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));\n\n\tif (ldata->real_raw)\n\t\tn_tty_receive_buf_real_raw(tty, cp, fp, count);\n\telse if (ldata->raw || (L_EXTPROC(tty) && !preops))\n\t\tn_tty_receive_buf_raw(tty, cp, fp, count);\n\telse if (tty->closing && !L_EXTPROC(tty))\n\t\tn_tty_receive_buf_closing(tty, cp, fp, count);\n\telse {\n\t\tif (ldata->lnext) {\n\t\t\tchar flag = TTY_NORMAL;\n\n\t\t\tif (fp)\n\t\t\t\tflag = *fp++;\n\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\tcount--;\n\t\t}\n\n\t\tif (!preops && !I_PARMRK(tty))\n\t\t\tn_tty_receive_buf_fast(tty, cp, fp, count);\n\t\telse\n\t\t\tn_tty_receive_buf_standard(tty, cp, fp, count);\n\n\t\tflush_echoes(tty);\n\t\tif (tty->ops->flush_chars)\n\t\t\ttty->ops->flush_chars(tty);\n\t}\n\n\tif ((!ldata->icanon && (read_cnt(ldata) >= ldata->minimum_to_wake)) ||\n\t\tL_EXTPROC(tty)) {\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\tif (waitqueue_active(&tty->read_wait))\n\t\t\twake_up_interruptible(&tty->read_wait);\n\t}\n}\n\nstatic int\nn_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t char *fp, int count, int flow)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint room, n, rcvd = 0;\n\n\tdown_read(&tty->termios_rwsem);\n\n\twhile (1) {\n\t\troom = receive_room(tty);\n\t\tn = min(count, room);\n\t\tif (!n) {\n\t\t\tif (flow && !room)\n\t\t\t\tldata->no_room = 1;\n\t\t\tbreak;\n\t\t}\n\t\t__receive_buf(tty, cp, fp, n);\n\t\tcp += n;\n\t\tif (fp)\n\t\t\tfp += n;\n\t\tcount -= n;\n\t\trcvd += n;\n\t}\n\n\ttty->receive_room = room;\n\tn_tty_check_throttle(tty);\n\tup_read(&tty->termios_rwsem);\n\n\treturn rcvd;\n}\n\nstatic void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\tn_tty_receive_buf_common(tty, cp, fp, count, 0);\n}\n\nstatic int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\n}\n\nint is_ignored(int sig)\n{\n\treturn (sigismember(&current->blocked, sig) ||\n\t\tcurrent->sighand->action[sig-1].sa.sa_handler == SIG_IGN);\n}\n\n/**\n *\tn_tty_set_termios\t-\ttermios data changed\n *\t@tty: terminal\n *\t@old: previous data\n *\n *\tCalled by the tty layer when the user changes termios flags so\n *\tthat the line discipline can plan ahead. This function cannot sleep\n *\tand is protected from re-entry by the tty layer. The user is\n *\tguaranteed that this function will not be re-entered or in progress\n *\twhen the ldisc is closed.\n *\n *\tLocking: Caller holds tty->termios_rwsem\n */\n\nstatic void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\tn_tty_set_room(tty);\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\tif (waitqueue_active(&tty->write_wait))\n\t\twake_up_interruptible(&tty->write_wait);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}\n\n/**\n *\tn_tty_close\t\t-\tclose the ldisc for this tty\n *\t@tty: device\n *\n *\tCalled from the terminal layer when this line discipline is\n *\tbeing shut down, either because of a close or becsuse of a\n *\tdiscipline change. The function will not be called while other\n *\tldisc methods are in progress.\n */\n\nstatic void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}\n\n/**\n *\tn_tty_open\t\t-\topen an ldisc\n *\t@tty: terminal to open\n *\n *\tCalled when this line discipline is being attached to the\n *\tterminal device. Can sleep. Called serialized so that no\n *\tother events will occur in parallel. No further open will occur\n *\tuntil a close.\n */\n\nstatic int n_tty_open(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata;\n\n\t/* Currently a malloc failure here can panic */\n\tldata = vmalloc(sizeof(*ldata));\n\tif (!ldata)\n\t\tgoto err;\n\n\tldata->overrun_time = jiffies;\n\tmutex_init(&ldata->atomic_read_lock);\n\tmutex_init(&ldata->output_lock);\n\n\ttty->disc_data = ldata;\n\treset_buffer_flags(tty->disc_data);\n\tldata->column = 0;\n\tldata->canon_column = 0;\n\tldata->minimum_to_wake = 1;\n\tldata->num_overrun = 0;\n\tldata->no_room = 0;\n\tldata->lnext = 0;\n\ttty->closing = 0;\n\t/* indicate buffer work may resume */\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\tn_tty_set_termios(tty, NULL);\n\ttty_unthrottle(tty);\n\n\treturn 0;\nerr:\n\treturn -ENOMEM;\n}\n\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn ldata->canon_head != ldata->read_tail;\n\telse\n\t\treturn read_cnt(ldata) >= amt;\n}\n\n/**\n *\tcopy_from_read_buf\t-\tcopy read data directly\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function to speed up n_tty_read.  It is only called when\n *\tICANON is off; it copies characters straight from the tty queue to\n *\tuser space directly.  It can be profitably called twice; once to\n *\tdrain the space from the tail pointer to the (physical) end of the\n *\tbuffer, and once to drain the space from the (physical) beginning of\n *\tthe buffer to head pointer.\n *\n *\tCalled under the ldata->atomic_read_lock sem\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t      unsigned char __user **b,\n\t\t\t\t      size_t *nr)\n\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tsize_t n;\n\tbool is_eof;\n\tsize_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\n\tretval = 0;\n\tn = min(read_cnt(ldata), N_TTY_BUF_SIZE - tail);\n\tn = min(*nr, n);\n\tif (n) {\n\t\tretval = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n\t\tn -= retval;\n\t\tis_eof = n == 1 && read_buf(ldata, tail) == EOF_CHAR(tty);\n\t\ttty_audit_add_data(tty, read_buf_addr(ldata, tail), n,\n\t\t\t\tldata->icanon);\n\t\tldata->read_tail += n;\n\t\t/* Turn single EOF into zero-length read */\n\t\tif (L_EXTPROC(tty) && ldata->icanon && is_eof && !read_cnt(ldata))\n\t\t\tn = 0;\n\t\t*b += n;\n\t\t*nr -= n;\n\t}\n\treturn retval;\n}\n\n/**\n *\tcanon_copy_from_read_buf\t-\tcopy read data in canonical mode\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function for n_tty_read.  It is only called when ICANON is on;\n *\tit copies one line of input up to and including the line-delimiting\n *\tcharacter into the user-space buffer.\n *\n *\tNB: When termios is changed from non-canonical to canonical mode and\n *\tthe read buffer contains data, n_tty_set_termios() simulates an EOF\n *\tpush (as if C-d were input) _without_ the DISABLED_CHAR in the buffer.\n *\tThis causes data already processed as input to be immediately available\n *\tas input although a newline has not been received.\n *\n *\tCalled under the atomic_read_lock mutex\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t    unsigned char __user **b,\n\t\t\t\t    size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail;\n\tint ret, found = 0;\n\tbool eof_push = 0;\n\n\t/* N.B. avoid overrun if nr == 0 */\n\tn = min(*nr, read_cnt(ldata));\n\tif (!n)\n\t\treturn 0;\n\n\ttail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t/* scan wrapped without finding set bit */\n\t\teol = find_next_bit(ldata->read_flags, more, 0);\n\t\tif (eol != more)\n\t\t\tfound = 1;\n\t} else if (eol != size)\n\t\tfound = 1;\n\n\tsize = N_TTY_BUF_SIZE - tail;\n\tn = eol - tail;\n\tif (n > 4096)\n\t\tn += 4096;\n\tn += found;\n\tc = n;\n\n\tif (found && !ldata->push && read_buf(ldata, eol) == __DISABLED_CHAR) {\n\t\tn--;\n\t\teof_push = !n && ldata->read_tail != ldata->line_start;\n\t}\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, size, more);\n\n\tif (n > size) {\n\t\tret = copy_to_user(*b, read_buf_addr(ldata, tail), size);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tret = copy_to_user(*b + size, ldata->read_buf, n - size);\n\t} else\n\t\tret = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n\n\tif (ret)\n\t\treturn -EFAULT;\n\t*b += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_mb__after_clear_bit();\n\tldata->read_tail += c;\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push(tty);\n\t}\n\treturn eof_push ? -EAGAIN : 0;\n}\n\nextern ssize_t redirected_tty_write(struct file *, const char __user *,\n\t\t\t\t\t\t\tsize_t, loff_t *);\n\n/**\n *\tjob_control\t\t-\tcheck job control\n *\t@tty: tty\n *\t@file: file handle\n *\n *\tPerform job control management checks on this file/tty descriptor\n *\tand if appropriate send any needed signals and return a negative\n *\terror code if action should be taken.\n *\n *\tLocking: redirected write test is safe\n *\t\t current->signal->tty check is safe\n *\t\t ctrl_lock to safely reference tty->pgrp\n */\n\nstatic int job_control(struct tty_struct *tty, struct file *file)\n{\n\t/* Job control check -- must be done at start and after\n\t   every sleep (POSIX.1 7.1.1.4). */\n\t/* NOTE: not yet done after every sleep pending a thorough\n\t   check of the logic of this change. -- jlc */\n\t/* don't stop on /dev/console */\n\tif (file->f_op->write == redirected_tty_write ||\n\t    current->signal->tty != tty)\n\t\treturn 0;\n\n\tspin_lock_irq(&tty->ctrl_lock);\n\tif (!tty->pgrp)\n\t\tprintk(KERN_ERR \"n_tty_read: no tty->pgrp!\\n\");\n\telse if (task_pgrp(current) != tty->pgrp) {\n\t\tspin_unlock_irq(&tty->ctrl_lock);\n\t\tif (is_ignored(SIGTTIN) || is_current_pgrp_orphaned())\n\t\t\treturn -EIO;\n\t\tkill_pgrp(task_pgrp(current), SIGTTIN, 1);\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\treturn -ERESTARTSYS;\n\t}\n\tspin_unlock_irq(&tty->ctrl_lock);\n\treturn 0;\n}\n\n\n/**\n *\tn_tty_read\t\t-\tread function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tPerform reads for the line discipline. We are guaranteed that the\n *\tline discipline will not be closed under us but we may get multiple\n *\tparallel readers and must handle this ourselves. We may also get\n *\ta hangup. Always called in user context, may sleep.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tn_tty_read()/consumer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes read_tail\n */\n\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t unsigned char __user *buf, size_t nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tunsigned char __user *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tint minimum, time;\n\tssize_t retval = 0;\n\tlong timeout;\n\tunsigned long flags;\n\tint packet;\n\n\tc = job_control(tty, file);\n\tif (c < 0)\n\t\treturn c;\n\n\t/*\n\t *\tInternal serialization of reads.\n\t */\n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&ldata->atomic_read_lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ldata->atomic_read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tif (!ldata->icanon) {\n\t\tminimum = MIN_CHAR(tty);\n\t\tif (minimum) {\n\t\t\ttime = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tif (time)\n\t\t\t\tldata->minimum_to_wake = 1;\n\t\t\telse if (!waitqueue_active(&tty->read_wait) ||\n\t\t\t\t (ldata->minimum_to_wake > minimum))\n\t\t\t\tldata->minimum_to_wake = minimum;\n\t\t} else {\n\t\t\ttimeout = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tldata->minimum_to_wake = minimum = 1;\n\t\t}\n\t}\n\n\tpacket = tty->packet;\n\n\tadd_wait_queue(&tty->read_wait, &wait);\n\twhile (nr) {\n\t\t/* First test for status change. */\n\t\tif (packet && tty->link->ctrl_status) {\n\t\t\tunsigned char cs;\n\t\t\tif (b != buf)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irqsave(&tty->link->ctrl_lock, flags);\n\t\t\tcs = tty->link->ctrl_status;\n\t\t\ttty->link->ctrl_status = 0;\n\t\t\tspin_unlock_irqrestore(&tty->link->ctrl_lock, flags);\n\t\t\tif (tty_put_user(tty, cs, b++)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tb--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnr--;\n\t\t\tbreak;\n\t\t}\n\t\t/* This statement must be first before checking for input\n\t\t   so that any interrupt will set the state back to\n\t\t   TASK_RUNNING. */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (((minimum - (b - buf)) < ldata->minimum_to_wake) &&\n\t\t    ((minimum - (b - buf)) >= 1))\n\t\t\tldata->minimum_to_wake = (minimum - (b - buf));\n\n\t\tif (!input_available_p(tty, 0)) {\n\t\t\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n\t\t\t\tup_read(&tty->termios_rwsem);\n\t\t\t\ttty_flush_to_ldisc(tty);\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tif (!input_available_p(tty, 0)) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tty_hung_up_p(file))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!timeout)\n\t\t\t\t\tbreak;\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn_tty_set_room(tty);\n\t\t\t\tup_read(&tty->termios_rwsem);\n\n\t\t\t\ttimeout = schedule_timeout(timeout);\n\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\t/* Deal with packet mode. */\n\t\tif (packet && b == buf) {\n\t\t\tif (tty_put_user(tty, TIOCPKT_DATA, b++)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tb--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnr--;\n\t\t}\n\n\t\tif (ldata->icanon && !L_EXTPROC(tty)) {\n\t\t\tretval = canon_copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (retval == -EAGAIN) {\n\t\t\t\tretval = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint uncopied;\n\t\t\t/* The copy function takes the read lock and handles\n\t\t\t   locking internally for this case */\n\t\t\tuncopied = copy_from_read_buf(tty, &b, &nr);\n\t\t\tuncopied += copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (uncopied) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tn_tty_check_unthrottle(tty);\n\n\t\tif (b - buf >= minimum)\n\t\t\tbreak;\n\t\tif (time)\n\t\t\ttimeout = time;\n\t}\n\tn_tty_set_room(tty);\n\tup_read(&tty->termios_rwsem);\n\n\tremove_wait_queue(&tty->read_wait, &wait);\n\tif (!waitqueue_active(&tty->read_wait))\n\t\tldata->minimum_to_wake = minimum;\n\n\tmutex_unlock(&ldata->atomic_read_lock);\n\n\t__set_current_state(TASK_RUNNING);\n\tif (b - buf)\n\t\tretval = b - buf;\n\n\treturn retval;\n}\n\n/**\n *\tn_tty_write\t\t-\twrite function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tWrite function of the terminal device.  This is serialized with\n *\trespect to other write callers but not to termios changes, reads\n *\tand other such events.  Since the receive code will echo characters,\n *\tthus calling driver write methods, the output_lock is used in\n *\tthe output processing functions called here as well as in the\n *\techo processing function to protect the column state and space\n *\tleft in the buffer.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (note that the process_output*() functions take this\n *\t\t  lock themselves)\n */\n\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty->ops->flush_chars)\n\t\t\t\ttty->ops->flush_chars(tty);\n\t\t} else {\n\t\t\twhile (nr > 0) {\n\t\t\t\tc = tty->ops->write(tty, b, nr);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tretval = c;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n\n/**\n *\tn_tty_poll\t\t-\tpoll method for N_TTY\n *\t@tty: terminal device\n *\t@file: file accessing it\n *\t@wait: poll table\n *\n *\tCalled when the line discipline is asked to poll() for data or\n *\tfor special events. This code is not serialized with respect to\n *\tother events save open/close.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\tCalled without the kernel lock held - fine\n */\n\nstatic unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tunsigned int mask = 0;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\tif (input_available_p(tty, 1))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (tty->packet && tty->link->ctrl_status)\n\t\tmask |= POLLPRI | POLLIN | POLLRDNORM;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= POLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= POLLHUP;\n\tif (!(mask & (POLLHUP | POLLIN | POLLRDNORM))) {\n\t\tif (MIN_CHAR(tty) && !TIME_CHAR(tty))\n\t\t\tldata->minimum_to_wake = MIN_CHAR(tty);\n\t\telse\n\t\t\tldata->minimum_to_wake = 1;\n\t}\n\tif (tty->ops->write && !tty_is_writelocked(tty) &&\n\t\t\ttty_chars_in_buffer(tty) < WAKEUP_CHARS &&\n\t\t\ttty_write_room(tty) > 0)\n\t\tmask |= POLLOUT | POLLWRNORM;\n\treturn mask;\n}\n\nstatic unsigned long inq_canon(struct n_tty_data *ldata)\n{\n\tsize_t nr, head, tail;\n\n\tif (ldata->canon_head == ldata->read_tail)\n\t\treturn 0;\n\thead = ldata->canon_head;\n\ttail = ldata->read_tail;\n\tnr = head - tail;\n\t/* Skip EOF-chars.. */\n\twhile (head != tail) {\n\t\tif (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&\n\t\t    read_buf(ldata, tail) == __DISABLED_CHAR)\n\t\t\tnr--;\n\t\ttail++;\n\t}\n\treturn nr;\n}\n\nstatic int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}\n\nstatic void n_tty_fasync(struct tty_struct *tty, int on)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!waitqueue_active(&tty->read_wait)) {\n\t\tif (on)\n\t\t\tldata->minimum_to_wake = 1;\n\t\telse if (!tty->fasync)\n\t\t\tldata->minimum_to_wake = N_TTY_BUF_SIZE;\n\t}\n}\n\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n\t.magic           = TTY_LDISC_MAGIC,\n\t.name            = \"n_tty\",\n\t.open            = n_tty_open,\n\t.close           = n_tty_close,\n\t.flush_buffer    = n_tty_flush_buffer,\n\t.chars_in_buffer = n_tty_chars_in_buffer,\n\t.read            = n_tty_read,\n\t.write           = n_tty_write,\n\t.ioctl           = n_tty_ioctl,\n\t.set_termios     = n_tty_set_termios,\n\t.poll            = n_tty_poll,\n\t.receive_buf     = n_tty_receive_buf,\n\t.write_wakeup    = n_tty_write_wakeup,\n\t.fasync\t\t = n_tty_fasync,\n\t.receive_buf2\t = n_tty_receive_buf2,\n};\n\n/**\n *\tn_tty_inherit_ops\t-\tinherit N_TTY methods\n *\t@ops: struct tty_ldisc_ops where to save N_TTY methods\n *\n *\tEnables a 'subclass' line discipline to 'inherit' N_TTY\n *\tmethods.\n */\n\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\n{\n\t*ops = tty_ldisc_N_TTY;\n\tops->owner = NULL;\n\tops->refcount = ops->flags = 0;\n}\nEXPORT_SYMBOL_GPL(n_tty_inherit_ops);\n"], "fixing_code": ["/*\n * n_tty.c --- implements the N_TTY line discipline.\n *\n * This code used to be in tty_io.c, but things are getting hairy\n * enough that it made sense to split things off.  (The N_TTY\n * processing has changed so much that it's hardly recognizable,\n * anyway...)\n *\n * Note that the open routine for N_TTY is guaranteed never to return\n * an error.  This is because Linux will fall back to setting a line\n * to N_TTY if it can not switch to any other line discipline.\n *\n * Written by Theodore Ts'o, Copyright 1994.\n *\n * This file also contains code originally written by Linus Torvalds,\n * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.\n *\n * This file may be redistributed under the terms of the GNU General Public\n * License.\n *\n * Reduced memory usage for older ARM systems  - Russell King.\n *\n * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of\n *\t\tthe patch by Andrew J. Kroll <ag784@freenet.buffalo.edu>\n *\t\twho actually finally proved there really was a race.\n *\n * 2002/03/18   Implemented n_tty_wakeup to send SIGIO POLL_OUTs to\n *\t\twaiting writing processes-Sapan Bhatia <sapan@corewars.org>.\n *\t\tAlso fixed a bug in BLOCKING mode where n_tty_write returns\n *\t\tEAGAIN\n */\n\n#include <linux/types.h>\n#include <linux/major.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/fcntl.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/bitops.h>\n#include <linux/audit.h>\n#include <linux/file.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/ratelimit.h>\n#include <linux/vmalloc.h>\n\n\n/* number of characters left in xmit buffer before select has we have room */\n#define WAKEUP_CHARS 256\n\n/*\n * This defines the low- and high-watermarks for throttling and\n * unthrottling the TTY driver.  These watermarks are used for\n * controlling the space in the read buffer.\n */\n#define TTY_THRESHOLD_THROTTLE\t\t128 /* now based on remaining room */\n#define TTY_THRESHOLD_UNTHROTTLE\t128\n\n/*\n * Special byte codes used in the echo buffer to represent operations\n * or special handling of characters.  Bytes in the echo buffer that\n * are not part of such special blocks are treated as normal character\n * codes.\n */\n#define ECHO_OP_START 0xff\n#define ECHO_OP_MOVE_BACK_COL 0x80\n#define ECHO_OP_SET_CANON_COL 0x81\n#define ECHO_OP_ERASE_TAB 0x82\n\n#define ECHO_COMMIT_WATERMARK\t256\n#define ECHO_BLOCK\t\t256\n#define ECHO_DISCARD_WATERMARK\tN_TTY_BUF_SIZE - (ECHO_BLOCK + 32)\n\n\n#undef N_TTY_TRACE\n#ifdef N_TTY_TRACE\n# define n_tty_trace(f, args...)\ttrace_printk(f, ##args)\n#else\n# define n_tty_trace(f, args...)\n#endif\n\nstruct n_tty_data {\n\t/* producer-published */\n\tsize_t read_head;\n\tsize_t canon_head;\n\tsize_t echo_head;\n\tsize_t echo_commit;\n\tsize_t echo_mark;\n\tDECLARE_BITMAP(char_map, 256);\n\n\t/* private to n_tty_receive_overrun (single-threaded) */\n\tunsigned long overrun_time;\n\tint num_overrun;\n\n\t/* non-atomic */\n\tbool no_room;\n\n\t/* must hold exclusive termios_rwsem to reset these */\n\tunsigned char lnext:1, erasing:1, raw:1, real_raw:1, icanon:1;\n\tunsigned char push:1;\n\n\t/* shared by producer and consumer */\n\tchar read_buf[N_TTY_BUF_SIZE];\n\tDECLARE_BITMAP(read_flags, N_TTY_BUF_SIZE);\n\tunsigned char echo_buf[N_TTY_BUF_SIZE];\n\n\tint minimum_to_wake;\n\n\t/* consumer-published */\n\tsize_t read_tail;\n\tsize_t line_start;\n\n\t/* protected by output lock */\n\tunsigned int column;\n\tunsigned int canon_column;\n\tsize_t echo_tail;\n\n\tstruct mutex atomic_read_lock;\n\tstruct mutex output_lock;\n};\n\nstatic inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}\n\nstatic inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char echo_buf(struct n_tty_data *ldata, size_t i)\n{\n\treturn ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline unsigned char *echo_buf_addr(struct n_tty_data *ldata, size_t i)\n{\n\treturn &ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\n}\n\nstatic inline int tty_put_user(struct tty_struct *tty, unsigned char x,\n\t\t\t       unsigned char __user *ptr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\ttty_audit_add_data(tty, &x, 1, ldata->icanon);\n\treturn put_user(x, ptr);\n}\n\nstatic int receive_room(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint left;\n\n\tif (I_PARMRK(tty)) {\n\t\t/* Multiply read_cnt by 3, since each byte might take up to\n\t\t * three times as many spaces when PARMRK is set (depending on\n\t\t * its flags, e.g. parity error). */\n\t\tleft = N_TTY_BUF_SIZE - read_cnt(ldata) * 3 - 1;\n\t} else\n\t\tleft = N_TTY_BUF_SIZE - read_cnt(ldata) - 1;\n\n\t/*\n\t * If we are doing input canonicalization, and there are no\n\t * pending newlines, let characters through without limit, so\n\t * that erase characters will be handled.  Other excess\n\t * characters will be beeped.\n\t */\n\tif (left <= 0)\n\t\tleft = ldata->icanon && ldata->canon_head == ldata->read_tail;\n\n\treturn left;\n}\n\n/**\n *\tn_tty_set_room\t-\treceive space\n *\t@tty: terminal\n *\n *\tRe-schedules the flip buffer work if space just became available.\n *\n *\tCaller holds exclusive termios_rwsem\n *\t   or\n *\tn_tty_read()/consumer path:\n *\t\tholds non-exclusive termios_rwsem\n */\n\nstatic void n_tty_set_room(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t/* Did this open up the receive buffer? We may need to flip */\n\tif (unlikely(ldata->no_room) && receive_room(tty)) {\n\t\tldata->no_room = 0;\n\n\t\tWARN_RATELIMIT(tty->port->itty == NULL,\n\t\t\t\t\"scheduling with invalid itty\\n\");\n\t\t/* see if ldisc has been killed - if so, this means that\n\t\t * even though the ldisc has been halted and ->buf.work\n\t\t * cancelled, ->buf.work is about to be rescheduled\n\t\t */\n\t\tWARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),\n\t\t\t       \"scheduling buffer work for halted ldisc\\n\");\n\t\tqueue_work(system_unbound_wq, &tty->port->buf.work);\n\t}\n}\n\nstatic ssize_t chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tssize_t n = 0;\n\n\tif (!ldata->icanon)\n\t\tn = read_cnt(ldata);\n\telse\n\t\tn = ldata->canon_head - ldata->read_tail;\n\treturn n;\n}\n\n/**\n *\tn_tty_write_wakeup\t-\tasynchronous I/O notifier\n *\t@tty: tty device\n *\n *\tRequired for the ptys, serial driver etc. since processes\n *\tthat attach themselves to the master and rely on ASYNC\n *\tIO must be woken up\n */\n\nstatic void n_tty_write_wakeup(struct tty_struct *tty)\n{\n\tif (tty->fasync && test_and_clear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags))\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void n_tty_check_throttle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY)\n\t\treturn;\n\t/*\n\t * Check the remaining room for the input canonicalization\n\t * mode.  We don't want to throttle the driver if we're in\n\t * canonical mode and don't have a newline yet!\n\t */\n\twhile (1) {\n\t\tint throttled;\n\t\ttty_set_flow_change(tty, TTY_THROTTLE_SAFE);\n\t\tif (receive_room(tty) >= TTY_THRESHOLD_THROTTLE)\n\t\t\tbreak;\n\t\tthrottled = tty_throttle_safe(tty);\n\t\tif (!throttled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->link->ldisc->ops->write_wakeup == n_tty_write_wakeup) {\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\treturn;\n\t\tif (!tty->count)\n\t\t\treturn;\n\t\tn_tty_set_room(tty);\n\t\tn_tty_write_wakeup(tty->link);\n\t\tif (waitqueue_active(&tty->link->write_wait))\n\t\t\twake_up_interruptible_poll(&tty->link->write_wait, POLLOUT);\n\t\treturn;\n\t}\n\n\t/* If there is enough space in the read buffer now, let the\n\t * low-level driver know. We use chars_in_buffer() to\n\t * check the buffer, as it now knows about canonical mode.\n\t * Otherwise, if the driver is throttled and the line is\n\t * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,\n\t * we won't get any more characters.\n\t */\n\n\twhile (1) {\n\t\tint unthrottled;\n\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\tbreak;\n\t\tif (!tty->count)\n\t\t\tbreak;\n\t\tn_tty_set_room(tty);\n\t\tunthrottled = tty_unthrottle_safe(tty);\n\t\tif (!unthrottled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}\n\n/**\n *\tput_tty_queue\t\t-\tadd character to tty\n *\t@c: character\n *\t@ldata: n_tty data\n *\n *\tAdd a character to the tty read_buf queue.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tmodifies read_head\n *\n *\tread_head is only considered 'published' if canonical mode is\n *\tnot active.\n */\n\nstatic inline void put_tty_queue(unsigned char c, struct n_tty_data *ldata)\n{\n\t*read_buf_addr(ldata, ldata->read_head++) = c;\n}\n\n/**\n *\treset_buffer_flags\t-\treset buffer state\n *\t@tty: terminal to reset\n *\n *\tReset the read buffer counters and clear the flags.\n *\tCalled from n_tty_open() and n_tty_flush_buffer().\n *\n *\tLocking: caller holds exclusive termios_rwsem\n *\t\t (or locking is not required)\n */\n\nstatic void reset_buffer_flags(struct n_tty_data *ldata)\n{\n\tldata->read_head = ldata->canon_head = ldata->read_tail = 0;\n\tldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\n\tldata->echo_mark = 0;\n\tldata->line_start = 0;\n\n\tldata->erasing = 0;\n\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\tldata->push = 0;\n}\n\nstatic void n_tty_packet_mode_flush(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\tif (tty->link->packet) {\n\t\ttty->ctrl_status |= TIOCPKT_FLUSHREAD;\n\t\tif (waitqueue_active(&tty->link->read_wait))\n\t\t\twake_up_interruptible(&tty->link->read_wait);\n\t}\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n}\n\n/**\n *\tn_tty_flush_buffer\t-\tclean input queue\n *\t@tty:\tterminal device\n *\n *\tFlush the input buffer. Called when the tty layer wants the\n *\tbuffer flushed (eg at hangup) or when the N_TTY line discipline\n *\tinternally has to clean the pending queue (for example some signals).\n *\n *\tHolds termios_rwsem to exclude producer/consumer while\n *\tbuffer indices are reset.\n *\n *\tLocking: ctrl_lock, exclusive termios_rwsem\n */\n\nstatic void n_tty_flush_buffer(struct tty_struct *tty)\n{\n\tdown_write(&tty->termios_rwsem);\n\treset_buffer_flags(tty->disc_data);\n\tn_tty_set_room(tty);\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\tup_write(&tty->termios_rwsem);\n}\n\n/**\n *\tn_tty_chars_in_buffer\t-\treport available bytes\n *\t@tty: tty device\n *\n *\tReport the number of characters buffered to be delivered to user\n *\tat this instant in time.\n *\n *\tLocking: exclusive termios_rwsem\n */\n\nstatic ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}\n\n/**\n *\tis_utf8_continuation\t-\tutf8 multibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter. We use this to correctly compute the on screen size\n *\tof the character when printing\n */\n\nstatic inline int is_utf8_continuation(unsigned char c)\n{\n\treturn (c & 0xc0) == 0x80;\n}\n\n/**\n *\tis_continuation\t\t-\tmultibyte check\n *\t@c: byte to check\n *\n *\tReturns true if the utf8 character 'c' is a multibyte continuation\n *\tcharacter and the terminal is in unicode mode.\n */\n\nstatic inline int is_continuation(unsigned char c, struct tty_struct *tty)\n{\n\treturn I_IUTF8(tty) && is_utf8_continuation(c);\n}\n\n/**\n *\tdo_output_char\t\t\t-\toutput one character\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\t@space: space available in tty driver write buffer\n *\n *\tThis is a helper function that handles one output character\n *\t(including special characters like TAB, CR, LF, etc.),\n *\tdoing OPOST processing and putting the results in the\n *\ttty driver's write buffer.\n *\n *\tNote that Linux currently ignores TABDLY, CRDLY, VTDLY, FFDLY\n *\tand NLDLY.  They simply aren't relevant in the world today.\n *\tIf you ever need them, add them here.\n *\n *\tReturns the number of bytes of buffer space used or -1 if\n *\tno space left.\n *\n *\tLocking: should be called under the output_lock to protect\n *\t\t the column state and space left in the buffer\n */\n\nstatic int do_output_char(unsigned char c, struct tty_struct *tty, int space)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspaces;\n\n\tif (!space)\n\t\treturn -1;\n\n\tswitch (c) {\n\tcase '\\n':\n\t\tif (O_ONLRET(tty))\n\t\t\tldata->column = 0;\n\t\tif (O_ONLCR(tty)) {\n\t\t\tif (space < 2)\n\t\t\t\treturn -1;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\ttty->ops->write(tty, \"\\r\\n\", 2);\n\t\t\treturn 2;\n\t\t}\n\t\tldata->canon_column = ldata->column;\n\t\tbreak;\n\tcase '\\r':\n\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\treturn 0;\n\t\tif (O_OCRNL(tty)) {\n\t\t\tc = '\\n';\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\t}\n\t\tldata->canon_column = ldata->column = 0;\n\t\tbreak;\n\tcase '\\t':\n\t\tspaces = 8 - (ldata->column & 7);\n\t\tif (O_TABDLY(tty) == XTABS) {\n\t\t\tif (space < spaces)\n\t\t\t\treturn -1;\n\t\t\tldata->column += spaces;\n\t\t\ttty->ops->write(tty, \"        \", spaces);\n\t\t\treturn spaces;\n\t\t}\n\t\tldata->column += spaces;\n\t\tbreak;\n\tcase '\\b':\n\t\tif (ldata->column > 0)\n\t\t\tldata->column--;\n\t\tbreak;\n\tdefault:\n\t\tif (!iscntrl(c)) {\n\t\t\tif (O_OLCUC(tty))\n\t\t\t\tc = toupper(c);\n\t\t\tif (!is_continuation(c, tty))\n\t\t\t\tldata->column++;\n\t\t}\n\t\tbreak;\n\t}\n\n\ttty_put_char(tty, c);\n\treturn 1;\n}\n\n/**\n *\tprocess_output\t\t\t-\toutput post processor\n *\t@c: character (or partial unicode symbol)\n *\t@tty: terminal device\n *\n *\tOutput one character with OPOST processing.\n *\tReturns -1 when the output device is full and the character\n *\tmust be retried.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic int process_output(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, retval;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tretval = do_output_char(c, tty, space);\n\n\tmutex_unlock(&ldata->output_lock);\n\tif (retval < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\n/**\n *\tprocess_output_block\t\t-\tblock post processor\n *\t@tty: terminal device\n *\t@buf: character buffer\n *\t@nr: number of bytes to output\n *\n *\tOutput a block of characters with OPOST processing.\n *\tReturns the number of characters output.\n *\n *\tThis path is used to speed up block console writes, among other\n *\tthings when processing blocks of output data. It handles only\n *\tthe simple cases normally found and helps to generate blocks of\n *\tsymbols for the console driver and thus improve performance.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (also, this is called from n_tty_write under the\n *\t\t  tty layer write lock)\n */\n\nstatic ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\n\tmutex_lock(&ldata->output_lock);\n\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}\n\n/**\n *\tprocess_echoes\t-\twrite pending echo characters\n *\t@tty: terminal device\n *\n *\tWrite previously buffered echo (and other ldisc-generated)\n *\tcharacters to the tty.\n *\n *\tCharacters generated by the ldisc (including echoes) need to\n *\tbe buffered because the driver's write buffer can fill during\n *\theavy program output.  Echoing straight to the driver will\n *\toften fail under these conditions, causing lost characters and\n *\tresulting mismatches of ldisc state information.\n *\n *\tSince the ldisc state must represent the characters actually sent\n *\tto the driver at the time of the write, operations like certain\n *\tchanges in column state are also saved in the buffer and executed\n *\there.\n *\n *\tA circular fifo buffer is used so that the most recent characters\n *\tare prioritized.  Also, when control characters are echoed with a\n *\tprefixed \"^\", the pair is treated atomically and thus not separated.\n *\n *\tLocking: callers must hold output_lock\n */\n\nstatic size_t __process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, old_space;\n\tsize_t tail;\n\tunsigned char c;\n\n\told_space = space = tty_write_room(tty);\n\n\ttail = ldata->echo_tail;\n\twhile (ldata->echo_commit != tail) {\n\t\tc = echo_buf(ldata, tail);\n\t\tif (c == ECHO_OP_START) {\n\t\t\tunsigned char op;\n\t\t\tint no_space_left = 0;\n\n\t\t\t/*\n\t\t\t * If the buffer byte is the start of a multi-byte\n\t\t\t * operation, get the next byte, which is either the\n\t\t\t * op code or a control character value.\n\t\t\t */\n\t\t\top = echo_buf(ldata, tail + 1);\n\n\t\t\tswitch (op) {\n\t\t\t\tunsigned int num_chars, num_bs;\n\n\t\t\tcase ECHO_OP_ERASE_TAB:\n\t\t\t\tnum_chars = echo_buf(ldata, tail + 2);\n\n\t\t\t\t/*\n\t\t\t\t * Determine how many columns to go back\n\t\t\t\t * in order to erase the tab.\n\t\t\t\t * This depends on the number of columns\n\t\t\t\t * used by other characters within the tab\n\t\t\t\t * area.  If this (modulo 8) count is from\n\t\t\t\t * the start of input rather than from a\n\t\t\t\t * previous tab, we offset by canon column.\n\t\t\t\t * Otherwise, tab spacing is normal.\n\t\t\t\t */\n\t\t\t\tif (!(num_chars & 0x80))\n\t\t\t\t\tnum_chars += ldata->canon_column;\n\t\t\t\tnum_bs = 8 - (num_chars & 7);\n\n\t\t\t\tif (num_bs > space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspace -= num_bs;\n\t\t\t\twhile (num_bs--) {\n\t\t\t\t\ttty_put_char(tty, '\\b');\n\t\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\t\tldata->column--;\n\t\t\t\t}\n\t\t\t\ttail += 3;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_SET_CANON_COL:\n\t\t\t\tldata->canon_column = ldata->column;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_MOVE_BACK_COL:\n\t\t\t\tif (ldata->column > 0)\n\t\t\t\t\tldata->column--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tcase ECHO_OP_START:\n\t\t\t\t/* This is an escaped echo op start code */\n\t\t\t\tif (!space) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, ECHO_OP_START);\n\t\t\t\tldata->column++;\n\t\t\t\tspace--;\n\t\t\t\ttail += 2;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t/*\n\t\t\t\t * If the op is not a special byte code,\n\t\t\t\t * it is a ctrl char tagged to be echoed\n\t\t\t\t * as \"^X\" (where X is the letter\n\t\t\t\t * representing the control char).\n\t\t\t\t * Note that we must ensure there is\n\t\t\t\t * enough space for the whole ctrl pair.\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (space < 2) {\n\t\t\t\t\tno_space_left = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_put_char(tty, '^');\n\t\t\t\ttty_put_char(tty, op ^ 0100);\n\t\t\t\tldata->column += 2;\n\t\t\t\tspace -= 2;\n\t\t\t\ttail += 2;\n\t\t\t}\n\n\t\t\tif (no_space_left)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (O_OPOST(tty)) {\n\t\t\t\tint retval = do_output_char(c, tty, space);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tspace -= retval;\n\t\t\t} else {\n\t\t\t\tif (!space)\n\t\t\t\t\tbreak;\n\t\t\t\ttty_put_char(tty, c);\n\t\t\t\tspace -= 1;\n\t\t\t}\n\t\t\ttail += 1;\n\t\t}\n\t}\n\n\t/* If the echo buffer is nearly full (so that the possibility exists\n\t * of echo overrun before the next commit), then discard enough\n\t * data at the tail to prevent a subsequent overrun */\n\twhile (ldata->echo_commit - tail >= ECHO_DISCARD_WATERMARK) {\n\t\tif (echo_buf(ldata, tail) == ECHO_OP_START) {\n\t\t\tif (echo_buf(ldata, tail + 1) == ECHO_OP_ERASE_TAB)\n\t\t\t\ttail += 3;\n\t\t\telse\n\t\t\t\ttail += 2;\n\t\t} else\n\t\t\ttail++;\n\t}\n\n\tldata->echo_tail = tail;\n\treturn old_space - space;\n}\n\nstatic void commit_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t nr, old, echoed;\n\tsize_t head;\n\n\thead = ldata->echo_head;\n\tldata->echo_mark = head;\n\told = ldata->echo_commit - ldata->echo_tail;\n\n\t/* Process committed echoes if the accumulated # of bytes\n\t * is over the threshold (and try again each time another\n\t * block is accumulated) */\n\tnr = head - ldata->echo_tail;\n\tif (nr < ECHO_COMMIT_WATERMARK || (nr % ECHO_BLOCK > old % ECHO_BLOCK))\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = head;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\nstatic void process_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t echoed;\n\n\tif (ldata->echo_mark == ldata->echo_tail)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_mark;\n\techoed = __process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n\n\tif (echoed && tty->ops->flush_chars)\n\t\ttty->ops->flush_chars(tty);\n}\n\n/* NB: echo_mark and echo_head should be equivalent here */\nstatic void flush_echoes(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif ((!L_ECHO(tty) && !L_ECHONL(tty)) ||\n\t    ldata->echo_commit == ldata->echo_head)\n\t\treturn;\n\n\tmutex_lock(&ldata->output_lock);\n\tldata->echo_commit = ldata->echo_head;\n\t__process_echoes(tty);\n\tmutex_unlock(&ldata->output_lock);\n}\n\n/**\n *\tadd_echo_byte\t-\tadd a byte to the echo buffer\n *\t@c: unicode byte to echo\n *\t@ldata: n_tty data\n *\n *\tAdd a character or operation byte to the echo buffer.\n */\n\nstatic inline void add_echo_byte(unsigned char c, struct n_tty_data *ldata)\n{\n\t*echo_buf_addr(ldata, ldata->echo_head++) = c;\n}\n\n/**\n *\techo_move_back_col\t-\tadd operation to move back a column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to move back one column.\n */\n\nstatic void echo_move_back_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_MOVE_BACK_COL, ldata);\n}\n\n/**\n *\techo_set_canon_col\t-\tadd operation to set the canon column\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to set the canon column\n *\tto the current column.\n */\n\nstatic void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n\n/**\n *\techo_erase_tab\t-\tadd operation to erase a tab\n *\t@num_chars: number of character columns already used\n *\t@after_tab: true if num_chars starts after a previous tab\n *\t@ldata: n_tty data\n *\n *\tAdd an operation to the echo buffer to erase a tab.\n *\n *\tCalled by the eraser function, which knows how many character\n *\tcolumns have been used since either a previous tab or the start\n *\tof input.  This information will be used later, along with\n *\tcanon column (if applicable), to go back the correct number\n *\tof columns.\n */\n\nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\n\t\t\t   struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_ERASE_TAB, ldata);\n\n\t/* We only need to know this modulo 8 (tab spacing) */\n\tnum_chars &= 7;\n\n\t/* Set the high bit as a flag if num_chars is after a previous tab */\n\tif (after_tab)\n\t\tnum_chars |= 0x80;\n\n\tadd_echo_byte(num_chars, ldata);\n}\n\n/**\n *\techo_char_raw\t-\techo a character raw\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant does not treat control characters specially.\n */\n\nstatic void echo_char_raw(unsigned char c, struct n_tty_data *ldata)\n{\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\techo_char\t-\techo a character\n *\t@c: unicode byte to echo\n *\t@tty: terminal device\n *\n *\tEcho user input back onto the screen. This must be called only when\n *\tL_ECHO(tty) is true. Called from the driver receive_buf path.\n *\n *\tThis variant tags control characters to be echoed as \"^X\"\n *\t(where X is the letter representing the control char).\n */\n\nstatic void echo_char(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (c == ECHO_OP_START) {\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t} else {\n\t\tif (L_ECHOCTL(tty) && iscntrl(c) && c != '\\t')\n\t\t\tadd_echo_byte(ECHO_OP_START, ldata);\n\t\tadd_echo_byte(c, ldata);\n\t}\n}\n\n/**\n *\tfinish_erasing\t\t-\tcomplete erase\n *\t@ldata: n_tty data\n */\n\nstatic inline void finish_erasing(struct n_tty_data *ldata)\n{\n\tif (ldata->erasing) {\n\t\techo_char_raw('/', ldata);\n\t\tldata->erasing = 0;\n\t}\n}\n\n/**\n *\teraser\t\t-\thandle erase function\n *\t@c: character input\n *\t@tty: terminal device\n *\n *\tPerform erase and necessary output when an erase character is\n *\tpresent in the stream from the driver layer. Handles the complexities\n *\tof UTF-8 multibyte symbols.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tmodifies read_head\n *\n *\tModifying the read_head is not considered a publish in this context\n *\tbecause canonical mode is active -- only canon_head publishes\n */\n\nstatic void eraser(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tenum { ERASE, WERASE, KILL } kill_type;\n\tsize_t head;\n\tsize_t cnt;\n\tint seen_alnums;\n\n\tif (ldata->read_head == ldata->canon_head) {\n\t\t/* process_output('\\a', tty); */ /* what do you think? */\n\t\treturn;\n\t}\n\tif (c == ERASE_CHAR(tty))\n\t\tkill_type = ERASE;\n\telse if (c == WERASE_CHAR(tty))\n\t\tkill_type = WERASE;\n\telse {\n\t\tif (!L_ECHO(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\treturn;\n\t\t}\n\t\tif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\n\t\t\tldata->read_head = ldata->canon_head;\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(KILL_CHAR(tty), tty);\n\t\t\t/* Add a newline if ECHOK is on and ECHOKE is off. */\n\t\t\tif (L_ECHOK(tty))\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\treturn;\n\t\t}\n\t\tkill_type = KILL;\n\t}\n\n\tseen_alnums = 0;\n\twhile (ldata->read_head != ldata->canon_head) {\n\t\thead = ldata->read_head;\n\n\t\t/* erase a single possibly multibyte character */\n\t\tdo {\n\t\t\thead--;\n\t\t\tc = read_buf(ldata, head);\n\t\t} while (is_continuation(c, tty) && head != ldata->canon_head);\n\n\t\t/* do not partially erase */\n\t\tif (is_continuation(c, tty))\n\t\t\tbreak;\n\n\t\tif (kill_type == WERASE) {\n\t\t\t/* Equivalent to BSD's ALTWERASE. */\n\t\t\tif (isalnum(c) || c == '_')\n\t\t\t\tseen_alnums++;\n\t\t\telse if (seen_alnums)\n\t\t\t\tbreak;\n\t\t}\n\t\tcnt = ldata->read_head - head;\n\t\tldata->read_head = head;\n\t\tif (L_ECHO(tty)) {\n\t\t\tif (L_ECHOPRT(tty)) {\n\t\t\t\tif (!ldata->erasing) {\n\t\t\t\t\techo_char_raw('\\\\', ldata);\n\t\t\t\t\tldata->erasing = 1;\n\t\t\t\t}\n\t\t\t\t/* if cnt > 1, output a multi-byte character */\n\t\t\t\techo_char(c, tty);\n\t\t\t\twhile (--cnt > 0) {\n\t\t\t\t\thead++;\n\t\t\t\t\techo_char_raw(read_buf(ldata, head), ldata);\n\t\t\t\t\techo_move_back_col(ldata);\n\t\t\t\t}\n\t\t\t} else if (kill_type == ERASE && !L_ECHOE(tty)) {\n\t\t\t\techo_char(ERASE_CHAR(tty), tty);\n\t\t\t} else if (c == '\\t') {\n\t\t\t\tunsigned int num_chars = 0;\n\t\t\t\tint after_tab = 0;\n\t\t\t\tsize_t tail = ldata->read_head;\n\n\t\t\t\t/*\n\t\t\t\t * Count the columns used for characters\n\t\t\t\t * since the start of input or after a\n\t\t\t\t * previous tab.\n\t\t\t\t * This info is used to go back the correct\n\t\t\t\t * number of columns.\n\t\t\t\t */\n\t\t\t\twhile (tail != ldata->canon_head) {\n\t\t\t\t\ttail--;\n\t\t\t\t\tc = read_buf(ldata, tail);\n\t\t\t\t\tif (c == '\\t') {\n\t\t\t\t\t\tafter_tab = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (iscntrl(c)) {\n\t\t\t\t\t\tif (L_ECHOCTL(tty))\n\t\t\t\t\t\t\tnum_chars += 2;\n\t\t\t\t\t} else if (!is_continuation(c, tty)) {\n\t\t\t\t\t\tnum_chars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\techo_erase_tab(num_chars, after_tab, ldata);\n\t\t\t} else {\n\t\t\t\tif (iscntrl(c) && L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t\tif (!iscntrl(c) || L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\techo_char_raw(' ', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (kill_type == ERASE)\n\t\t\tbreak;\n\t}\n\tif (ldata->read_head == ldata->canon_head && L_ECHO(tty))\n\t\tfinish_erasing(ldata);\n}\n\n/**\n *\tisig\t\t-\thandle the ISIG optio\n *\t@sig: signal\n *\t@tty: terminal\n *\n *\tCalled when a signal is being sent due to terminal input.\n *\tCalled from the driver receive_buf path so serialized.\n *\n *\tLocking: ctrl_lock\n */\n\nstatic void isig(int sig, struct tty_struct *tty)\n{\n\tstruct pid *tty_pgrp = tty_get_pgrp(tty);\n\tif (tty_pgrp) {\n\t\tkill_pgrp(tty_pgrp, sig, 1);\n\t\tput_pid(tty_pgrp);\n\t}\n}\n\n/**\n *\tn_tty_receive_break\t-\thandle break\n *\t@tty: terminal\n *\n *\tAn RS232 break event has been hit in the incoming bitstream. This\n *\tcan cause a variety of events depending upon the termios settings.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes read_head via put_tty_queue()\n *\n *\tNote: may get exclusive termios_rwsem if flushing input buffer\n */\n\nstatic void n_tty_receive_break(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNBRK(tty))\n\t\treturn;\n\tif (I_BRKINT(tty)) {\n\t\tisig(SIGINT, tty);\n\t\tif (!L_NOFLSH(tty)) {\n\t\t\t/* flushing needs exclusive termios_rwsem */\n\t\t\tup_read(&tty->termios_rwsem);\n\t\t\tn_tty_flush_buffer(tty);\n\t\t\ttty_driver_flush_buffer(tty);\n\t\t\tdown_read(&tty->termios_rwsem);\n\t\t}\n\t\treturn;\n\t}\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t}\n\tput_tty_queue('\\0', ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}\n\n/**\n *\tn_tty_receive_overrun\t-\thandle overrun reporting\n *\t@tty: terminal\n *\n *\tData arrived faster than we could process it. While the tty\n *\tdriver has flagged this the bits that were missed are gone\n *\tforever.\n *\n *\tCalled from the receive_buf path so single threaded. Does not\n *\tneed locking as num_overrun and overrun_time are function\n *\tprivate.\n */\n\nstatic void n_tty_receive_overrun(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar buf[64];\n\n\tldata->num_overrun++;\n\tif (time_after(jiffies, ldata->overrun_time + HZ) ||\n\t\t\ttime_after(ldata->overrun_time, jiffies)) {\n\t\tprintk(KERN_WARNING \"%s: %d input overrun(s)\\n\",\n\t\t\ttty_name(tty, buf),\n\t\t\tldata->num_overrun);\n\t\tldata->overrun_time = jiffies;\n\t\tldata->num_overrun = 0;\n\t}\n}\n\n/**\n *\tn_tty_receive_parity_error\t-\terror notifier\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess a parity error and queue the right data to indicate\n *\tthe error case if necessary.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes read_head via put_tty_queue()\n */\nstatic void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IGNPAR(tty))\n\t\treturn;\n\tif (I_PARMRK(tty)) {\n\t\tput_tty_queue('\\377', ldata);\n\t\tput_tty_queue('\\0', ldata);\n\t\tput_tty_queue(c, ldata);\n\t} else\tif (I_INPCK(tty))\n\t\tput_tty_queue('\\0', ldata);\n\telse\n\t\tput_tty_queue(c, ldata);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}\n\nstatic void\nn_tty_receive_signal_char(struct tty_struct *tty, int signal, unsigned char c)\n{\n\tif (!L_NOFLSH(tty)) {\n\t\t/* flushing needs exclusive termios_rwsem */\n\t\tup_read(&tty->termios_rwsem);\n\t\tn_tty_flush_buffer(tty);\n\t\ttty_driver_flush_buffer(tty);\n\t\tdown_read(&tty->termios_rwsem);\n\t}\n\tif (I_IXON(tty))\n\t\tstart_tty(tty);\n\tif (L_ECHO(tty)) {\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t} else\n\t\tprocess_echoes(tty);\n\tisig(signal, tty);\n\treturn;\n}\n\n/**\n *\tn_tty_receive_char\t-\tperform processing\n *\t@tty: terminal device\n *\t@c: character\n *\n *\tProcess an individual character of input received from the driver.\n *\tThis is serialized with respect to itself by the rules for the\n *\tdriver above.\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tpublishes canon_head if canonical mode is active\n *\t\totherwise, publishes read_head via put_tty_queue()\n *\n *\tReturns 1 if LNEXT was received, else returns 0\n */\n\nstatic int\nn_tty_receive_char_special(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (I_IXON(tty)) {\n\t\tif (c == START_CHAR(tty)) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == STOP_CHAR(tty)) {\n\t\t\tstop_tty(tty);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ISIG(tty)) {\n\t\tif (c == INTR_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGINT, c);\n\t\t\treturn 0;\n\t\t} else if (c == QUIT_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGQUIT, c);\n\t\t\treturn 0;\n\t\t} else if (c == SUSP_CHAR(tty)) {\n\t\t\tn_tty_receive_signal_char(tty, SIGTSTP, c);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\tif (c == '\\r') {\n\t\tif (I_IGNCR(tty))\n\t\t\treturn 0;\n\t\tif (I_ICRNL(tty))\n\t\t\tc = '\\n';\n\t} else if (c == '\\n' && I_INLCR(tty))\n\t\tc = '\\r';\n\n\tif (ldata->icanon) {\n\t\tif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\n\t\t    (c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\teraser(c, tty);\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\n\t\t\tldata->lnext = 1;\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\tfinish_erasing(ldata);\n\t\t\t\tif (L_ECHOCTL(tty)) {\n\t\t\t\t\techo_char_raw('^', ldata);\n\t\t\t\t\techo_char_raw('\\b', ldata);\n\t\t\t\t\tcommit_echoes(tty);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (c == REPRINT_CHAR(tty) && L_ECHO(tty) && L_IEXTEN(tty)) {\n\t\t\tsize_t tail = ldata->canon_head;\n\n\t\t\tfinish_erasing(ldata);\n\t\t\techo_char(c, tty);\n\t\t\techo_char_raw('\\n', ldata);\n\t\t\twhile (tail != ldata->read_head) {\n\t\t\t\techo_char(read_buf(ldata, tail), tty);\n\t\t\t\ttail++;\n\t\t\t}\n\t\t\tcommit_echoes(tty);\n\t\t\treturn 0;\n\t\t}\n\t\tif (c == '\\n') {\n\t\t\tif (L_ECHO(tty) || L_ECHONL(tty)) {\n\t\t\t\techo_char_raw('\\n', ldata);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif (c == EOF_CHAR(tty)) {\n\t\t\tc = __DISABLED_CHAR;\n\t\t\tgoto handle_newline;\n\t\t}\n\t\tif ((c == EOL_CHAR(tty)) ||\n\t\t    (c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\n\t\t\t/*\n\t\t\t * XXX are EOL_CHAR and EOL2_CHAR echoed?!?\n\t\t\t */\n\t\t\tif (L_ECHO(tty)) {\n\t\t\t\t/* Record the column of first canon char. */\n\t\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\t\techo_set_canon_col(ldata);\n\t\t\t\techo_char(c, tty);\n\t\t\t\tcommit_echoes(tty);\n\t\t\t}\n\t\t\t/*\n\t\t\t * XXX does PARMRK doubling happen for\n\t\t\t * EOL_CHAR and EOL2_CHAR?\n\t\t\t */\n\t\t\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\t\t\tput_tty_queue(c, ldata);\n\nhandle_newline:\n\t\t\tset_bit(ldata->read_head & (N_TTY_BUF_SIZE - 1), ldata->read_flags);\n\t\t\tput_tty_queue(c, ldata);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\t\tif (waitqueue_active(&tty->read_wait))\n\t\t\t\twake_up_interruptible(&tty->read_wait);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\tif (c == '\\n')\n\t\t\techo_char_raw('\\n', ldata);\n\t\telse {\n\t\t\t/* Record the column of first canon char. */\n\t\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\t\techo_set_canon_col(ldata);\n\t\t\techo_char(c, tty);\n\t\t}\n\t\tcommit_echoes(tty);\n\t}\n\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\n\tput_tty_queue(c, ldata);\n\treturn 0;\n}\n\nstatic inline void\nn_tty_receive_char_inline(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\t/* PARMRK doubling check */\n\tif (c == (unsigned char) '\\377' && I_PARMRK(tty))\n\t\tput_tty_queue(c, ldata);\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\n{\n\tn_tty_receive_char_inline(tty, c);\n}\n\nstatic inline void\nn_tty_receive_char_fast(struct tty_struct *tty, unsigned char c)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\tif (L_ECHO(tty)) {\n\t\tfinish_erasing(ldata);\n\t\t/* Record the column of first canon char. */\n\t\tif (ldata->canon_head == ldata->read_head)\n\t\t\techo_set_canon_col(ldata);\n\t\techo_char(c, tty);\n\t\tcommit_echoes(tty);\n\t}\n\tput_tty_queue(c, ldata);\n}\n\nstatic void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c)\n{\n\tif (I_ISTRIP(tty))\n\t\tc &= 0x7f;\n\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\tc = tolower(c);\n\n\tif (I_IXON(tty)) {\n\t\tif (c == STOP_CHAR(tty))\n\t\t\tstop_tty(tty);\n\t\telse if (c == START_CHAR(tty) ||\n\t\t\t (tty->stopped && !tty->flow_stopped && I_IXANY(tty) &&\n\t\t\t  c != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&\n\t\t\t  c != SUSP_CHAR(tty))) {\n\t\t\tstart_tty(tty);\n\t\t\tprocess_echoes(tty);\n\t\t}\n\t}\n}\n\nstatic void\nn_tty_receive_char_flagged(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tchar buf[64];\n\n\tswitch (flag) {\n\tcase TTY_BREAK:\n\t\tn_tty_receive_break(tty);\n\t\tbreak;\n\tcase TTY_PARITY:\n\tcase TTY_FRAME:\n\t\tn_tty_receive_parity_error(tty, c);\n\t\tbreak;\n\tcase TTY_OVERRUN:\n\t\tn_tty_receive_overrun(tty);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: unknown flag %d\\n\",\n\t\t       tty_name(tty, buf), flag);\n\t\tbreak;\n\t}\n}\n\nstatic void\nn_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tldata->lnext = 0;\n\tif (likely(flag == TTY_NORMAL)) {\n\t\tif (I_ISTRIP(tty))\n\t\t\tc &= 0x7f;\n\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\tc = tolower(c);\n\t\tn_tty_receive_char(tty, c);\n\t} else\n\t\tn_tty_receive_char_flagged(tty, c, flag);\n}\n\n/**\n *\tn_tty_receive_buf\t-\tdata receive\n *\t@tty: terminal device\n *\t@cp: buffer\n *\t@fp: flag buffer\n *\t@count: characters\n *\n *\tCalled by the terminal driver when a block of characters has\n *\tbeen received. This function must be called from soft contexts\n *\tnot from interrupt context. The driver is responsible for making\n *\tcalls one at a time and in order (or using flush_to_ldisc)\n *\n *\tn_tty_receive_buf()/producer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes read_head and canon_head\n */\n\nstatic void\nn_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t   char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, head;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = N_TTY_BUF_SIZE - max(read_cnt(ldata), head);\n\tn = min_t(size_t, count, n);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n\tcp += n;\n\tcount -= n;\n\n\thead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\n\tn = N_TTY_BUF_SIZE - max(read_cnt(ldata), head);\n\tn = min_t(size_t, count, n);\n\tmemcpy(read_buf_addr(ldata, head), cp, n);\n\tldata->read_head += n;\n}\n\nstatic void\nn_tty_receive_buf_raw(struct tty_struct *tty, const unsigned char *cp,\n\t\t      char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tput_tty_queue(*cp++, ldata);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_standard(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (I_ISTRIP(tty))\n\t\t\t\tc &= 0x7f;\n\t\t\tif (I_IUCLC(tty) && L_IEXTEN(tty))\n\t\t\t\tc = tolower(c);\n\t\t\tif (L_EXTPROC(tty)) {\n\t\t\t\tput_tty_queue(c, ldata);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_inline(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void\nn_tty_receive_buf_fast(struct tty_struct *tty, const unsigned char *cp,\n\t\t       char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL)) {\n\t\t\tunsigned char c = *cp++;\n\n\t\t\tif (!test_bit(c, ldata->char_map))\n\t\t\t\tn_tty_receive_char_fast(tty, c);\n\t\t\telse if (n_tty_receive_char_special(tty, c) && count) {\n\t\t\t\tif (fp)\n\t\t\t\t\tflag = *fp++;\n\t\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\t\tcount--;\n\t\t\t}\n\t\t} else\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n\nstatic void __receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tbool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));\n\n\tif (ldata->real_raw)\n\t\tn_tty_receive_buf_real_raw(tty, cp, fp, count);\n\telse if (ldata->raw || (L_EXTPROC(tty) && !preops))\n\t\tn_tty_receive_buf_raw(tty, cp, fp, count);\n\telse if (tty->closing && !L_EXTPROC(tty))\n\t\tn_tty_receive_buf_closing(tty, cp, fp, count);\n\telse {\n\t\tif (ldata->lnext) {\n\t\t\tchar flag = TTY_NORMAL;\n\n\t\t\tif (fp)\n\t\t\t\tflag = *fp++;\n\t\t\tn_tty_receive_char_lnext(tty, *cp++, flag);\n\t\t\tcount--;\n\t\t}\n\n\t\tif (!preops && !I_PARMRK(tty))\n\t\t\tn_tty_receive_buf_fast(tty, cp, fp, count);\n\t\telse\n\t\t\tn_tty_receive_buf_standard(tty, cp, fp, count);\n\n\t\tflush_echoes(tty);\n\t\tif (tty->ops->flush_chars)\n\t\t\ttty->ops->flush_chars(tty);\n\t}\n\n\tif ((!ldata->icanon && (read_cnt(ldata) >= ldata->minimum_to_wake)) ||\n\t\tL_EXTPROC(tty)) {\n\t\tkill_fasync(&tty->fasync, SIGIO, POLL_IN);\n\t\tif (waitqueue_active(&tty->read_wait))\n\t\t\twake_up_interruptible(&tty->read_wait);\n\t}\n}\n\nstatic int\nn_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t char *fp, int count, int flow)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint room, n, rcvd = 0;\n\n\tdown_read(&tty->termios_rwsem);\n\n\twhile (1) {\n\t\troom = receive_room(tty);\n\t\tn = min(count, room);\n\t\tif (!n) {\n\t\t\tif (flow && !room)\n\t\t\t\tldata->no_room = 1;\n\t\t\tbreak;\n\t\t}\n\t\t__receive_buf(tty, cp, fp, n);\n\t\tcp += n;\n\t\tif (fp)\n\t\t\tfp += n;\n\t\tcount -= n;\n\t\trcvd += n;\n\t}\n\n\ttty->receive_room = room;\n\tn_tty_check_throttle(tty);\n\tup_read(&tty->termios_rwsem);\n\n\treturn rcvd;\n}\n\nstatic void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\tn_tty_receive_buf_common(tty, cp, fp, count, 0);\n}\n\nstatic int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t      char *fp, int count)\n{\n\treturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\n}\n\nint is_ignored(int sig)\n{\n\treturn (sigismember(&current->blocked, sig) ||\n\t\tcurrent->sighand->action[sig-1].sa.sa_handler == SIG_IGN);\n}\n\n/**\n *\tn_tty_set_termios\t-\ttermios data changed\n *\t@tty: terminal\n *\t@old: previous data\n *\n *\tCalled by the tty layer when the user changes termios flags so\n *\tthat the line discipline can plan ahead. This function cannot sleep\n *\tand is protected from re-entry by the tty layer. The user is\n *\tguaranteed that this function will not be re-entered or in progress\n *\twhen the ldisc is closed.\n *\n *\tLocking: Caller holds tty->termios_rwsem\n */\n\nstatic void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\n\t\tbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\n\t\tldata->line_start = ldata->read_tail;\n\t\tif (!L_ICANON(tty) || !read_cnt(ldata)) {\n\t\t\tldata->canon_head = ldata->read_tail;\n\t\t\tldata->push = 0;\n\t\t} else {\n\t\t\tset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\n\t\t\t\tldata->read_flags);\n\t\t\tldata->canon_head = ldata->read_head;\n\t\t\tldata->push = 1;\n\t\t}\n\t\tldata->erasing = 0;\n\t\tldata->lnext = 0;\n\t}\n\n\tldata->icanon = (L_ICANON(tty) != 0);\n\n\tif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\n\t    I_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\n\t    I_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\n\t    I_PARMRK(tty)) {\n\t\tbitmap_zero(ldata->char_map, 256);\n\n\t\tif (I_IGNCR(tty) || I_ICRNL(tty))\n\t\t\tset_bit('\\r', ldata->char_map);\n\t\tif (I_INLCR(tty))\n\t\t\tset_bit('\\n', ldata->char_map);\n\n\t\tif (L_ICANON(tty)) {\n\t\t\tset_bit(ERASE_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(KILL_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(EOF_CHAR(tty), ldata->char_map);\n\t\t\tset_bit('\\n', ldata->char_map);\n\t\t\tset_bit(EOL_CHAR(tty), ldata->char_map);\n\t\t\tif (L_IEXTEN(tty)) {\n\t\t\t\tset_bit(WERASE_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(LNEXT_CHAR(tty), ldata->char_map);\n\t\t\t\tset_bit(EOL2_CHAR(tty), ldata->char_map);\n\t\t\t\tif (L_ECHO(tty))\n\t\t\t\t\tset_bit(REPRINT_CHAR(tty),\n\t\t\t\t\t\tldata->char_map);\n\t\t\t}\n\t\t}\n\t\tif (I_IXON(tty)) {\n\t\t\tset_bit(START_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(STOP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tif (L_ISIG(tty)) {\n\t\t\tset_bit(INTR_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(QUIT_CHAR(tty), ldata->char_map);\n\t\t\tset_bit(SUSP_CHAR(tty), ldata->char_map);\n\t\t}\n\t\tclear_bit(__DISABLED_CHAR, ldata->char_map);\n\t\tldata->raw = 0;\n\t\tldata->real_raw = 0;\n\t} else {\n\t\tldata->raw = 1;\n\t\tif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\n\t\t    (I_IGNPAR(tty) || !I_INPCK(tty)) &&\n\t\t    (tty->driver->flags & TTY_DRIVER_REAL_RAW))\n\t\t\tldata->real_raw = 1;\n\t\telse\n\t\t\tldata->real_raw = 0;\n\t}\n\tn_tty_set_room(tty);\n\t/*\n\t * Fix tty hang when I_IXON(tty) is cleared, but the tty\n\t * been stopped by STOP_CHAR(tty) before it.\n\t */\n\tif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\n\t\tstart_tty(tty);\n\t\tprocess_echoes(tty);\n\t}\n\n\t/* The termios change make the tty ready for I/O */\n\tif (waitqueue_active(&tty->write_wait))\n\t\twake_up_interruptible(&tty->write_wait);\n\tif (waitqueue_active(&tty->read_wait))\n\t\twake_up_interruptible(&tty->read_wait);\n}\n\n/**\n *\tn_tty_close\t\t-\tclose the ldisc for this tty\n *\t@tty: device\n *\n *\tCalled from the terminal layer when this line discipline is\n *\tbeing shut down, either because of a close or becsuse of a\n *\tdiscipline change. The function will not be called while other\n *\tldisc methods are in progress.\n */\n\nstatic void n_tty_close(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (tty->link)\n\t\tn_tty_packet_mode_flush(tty);\n\n\tvfree(ldata);\n\ttty->disc_data = NULL;\n}\n\n/**\n *\tn_tty_open\t\t-\topen an ldisc\n *\t@tty: terminal to open\n *\n *\tCalled when this line discipline is being attached to the\n *\tterminal device. Can sleep. Called serialized so that no\n *\tother events will occur in parallel. No further open will occur\n *\tuntil a close.\n */\n\nstatic int n_tty_open(struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata;\n\n\t/* Currently a malloc failure here can panic */\n\tldata = vmalloc(sizeof(*ldata));\n\tif (!ldata)\n\t\tgoto err;\n\n\tldata->overrun_time = jiffies;\n\tmutex_init(&ldata->atomic_read_lock);\n\tmutex_init(&ldata->output_lock);\n\n\ttty->disc_data = ldata;\n\treset_buffer_flags(tty->disc_data);\n\tldata->column = 0;\n\tldata->canon_column = 0;\n\tldata->minimum_to_wake = 1;\n\tldata->num_overrun = 0;\n\tldata->no_room = 0;\n\tldata->lnext = 0;\n\ttty->closing = 0;\n\t/* indicate buffer work may resume */\n\tclear_bit(TTY_LDISC_HALTED, &tty->flags);\n\tn_tty_set_termios(tty, NULL);\n\ttty_unthrottle(tty);\n\n\treturn 0;\nerr:\n\treturn -ENOMEM;\n}\n\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn ldata->canon_head != ldata->read_tail;\n\telse\n\t\treturn read_cnt(ldata) >= amt;\n}\n\n/**\n *\tcopy_from_read_buf\t-\tcopy read data directly\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function to speed up n_tty_read.  It is only called when\n *\tICANON is off; it copies characters straight from the tty queue to\n *\tuser space directly.  It can be profitably called twice; once to\n *\tdrain the space from the tail pointer to the (physical) end of the\n *\tbuffer, and once to drain the space from the (physical) beginning of\n *\tthe buffer to head pointer.\n *\n *\tCalled under the ldata->atomic_read_lock sem\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t      unsigned char __user **b,\n\t\t\t\t      size_t *nr)\n\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tsize_t n;\n\tbool is_eof;\n\tsize_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\n\tretval = 0;\n\tn = min(read_cnt(ldata), N_TTY_BUF_SIZE - tail);\n\tn = min(*nr, n);\n\tif (n) {\n\t\tretval = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n\t\tn -= retval;\n\t\tis_eof = n == 1 && read_buf(ldata, tail) == EOF_CHAR(tty);\n\t\ttty_audit_add_data(tty, read_buf_addr(ldata, tail), n,\n\t\t\t\tldata->icanon);\n\t\tldata->read_tail += n;\n\t\t/* Turn single EOF into zero-length read */\n\t\tif (L_EXTPROC(tty) && ldata->icanon && is_eof && !read_cnt(ldata))\n\t\t\tn = 0;\n\t\t*b += n;\n\t\t*nr -= n;\n\t}\n\treturn retval;\n}\n\n/**\n *\tcanon_copy_from_read_buf\t-\tcopy read data in canonical mode\n *\t@tty: terminal device\n *\t@b: user data\n *\t@nr: size of data\n *\n *\tHelper function for n_tty_read.  It is only called when ICANON is on;\n *\tit copies one line of input up to and including the line-delimiting\n *\tcharacter into the user-space buffer.\n *\n *\tNB: When termios is changed from non-canonical to canonical mode and\n *\tthe read buffer contains data, n_tty_set_termios() simulates an EOF\n *\tpush (as if C-d were input) _without_ the DISABLED_CHAR in the buffer.\n *\tThis causes data already processed as input to be immediately available\n *\tas input although a newline has not been received.\n *\n *\tCalled under the atomic_read_lock mutex\n *\n *\tn_tty_read()/consumer path:\n *\t\tcaller holds non-exclusive termios_rwsem\n *\t\tread_tail published\n */\n\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\n\t\t\t\t    unsigned char __user **b,\n\t\t\t\t    size_t *nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tsize_t n, size, more, c;\n\tsize_t eol;\n\tsize_t tail;\n\tint ret, found = 0;\n\tbool eof_push = 0;\n\n\t/* N.B. avoid overrun if nr == 0 */\n\tn = min(*nr, read_cnt(ldata));\n\tif (!n)\n\t\treturn 0;\n\n\ttail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\n\tsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\n\n\tn_tty_trace(\"%s: nr:%zu tail:%zu n:%zu size:%zu\\n\",\n\t\t    __func__, *nr, tail, n, size);\n\n\teol = find_next_bit(ldata->read_flags, size, tail);\n\tmore = n - (size - tail);\n\tif (eol == N_TTY_BUF_SIZE && more) {\n\t\t/* scan wrapped without finding set bit */\n\t\teol = find_next_bit(ldata->read_flags, more, 0);\n\t\tif (eol != more)\n\t\t\tfound = 1;\n\t} else if (eol != size)\n\t\tfound = 1;\n\n\tsize = N_TTY_BUF_SIZE - tail;\n\tn = eol - tail;\n\tif (n > 4096)\n\t\tn += 4096;\n\tn += found;\n\tc = n;\n\n\tif (found && !ldata->push && read_buf(ldata, eol) == __DISABLED_CHAR) {\n\t\tn--;\n\t\teof_push = !n && ldata->read_tail != ldata->line_start;\n\t}\n\n\tn_tty_trace(\"%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\\n\",\n\t\t    __func__, eol, found, n, c, size, more);\n\n\tif (n > size) {\n\t\tret = copy_to_user(*b, read_buf_addr(ldata, tail), size);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tret = copy_to_user(*b + size, ldata->read_buf, n - size);\n\t} else\n\t\tret = copy_to_user(*b, read_buf_addr(ldata, tail), n);\n\n\tif (ret)\n\t\treturn -EFAULT;\n\t*b += n;\n\t*nr -= n;\n\n\tif (found)\n\t\tclear_bit(eol, ldata->read_flags);\n\tsmp_mb__after_clear_bit();\n\tldata->read_tail += c;\n\n\tif (found) {\n\t\tif (!ldata->push)\n\t\t\tldata->line_start = ldata->read_tail;\n\t\telse\n\t\t\tldata->push = 0;\n\t\ttty_audit_push(tty);\n\t}\n\treturn eof_push ? -EAGAIN : 0;\n}\n\nextern ssize_t redirected_tty_write(struct file *, const char __user *,\n\t\t\t\t\t\t\tsize_t, loff_t *);\n\n/**\n *\tjob_control\t\t-\tcheck job control\n *\t@tty: tty\n *\t@file: file handle\n *\n *\tPerform job control management checks on this file/tty descriptor\n *\tand if appropriate send any needed signals and return a negative\n *\terror code if action should be taken.\n *\n *\tLocking: redirected write test is safe\n *\t\t current->signal->tty check is safe\n *\t\t ctrl_lock to safely reference tty->pgrp\n */\n\nstatic int job_control(struct tty_struct *tty, struct file *file)\n{\n\t/* Job control check -- must be done at start and after\n\t   every sleep (POSIX.1 7.1.1.4). */\n\t/* NOTE: not yet done after every sleep pending a thorough\n\t   check of the logic of this change. -- jlc */\n\t/* don't stop on /dev/console */\n\tif (file->f_op->write == redirected_tty_write ||\n\t    current->signal->tty != tty)\n\t\treturn 0;\n\n\tspin_lock_irq(&tty->ctrl_lock);\n\tif (!tty->pgrp)\n\t\tprintk(KERN_ERR \"n_tty_read: no tty->pgrp!\\n\");\n\telse if (task_pgrp(current) != tty->pgrp) {\n\t\tspin_unlock_irq(&tty->ctrl_lock);\n\t\tif (is_ignored(SIGTTIN) || is_current_pgrp_orphaned())\n\t\t\treturn -EIO;\n\t\tkill_pgrp(task_pgrp(current), SIGTTIN, 1);\n\t\tset_thread_flag(TIF_SIGPENDING);\n\t\treturn -ERESTARTSYS;\n\t}\n\tspin_unlock_irq(&tty->ctrl_lock);\n\treturn 0;\n}\n\n\n/**\n *\tn_tty_read\t\t-\tread function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tPerform reads for the line discipline. We are guaranteed that the\n *\tline discipline will not be closed under us but we may get multiple\n *\tparallel readers and must handle this ourselves. We may also get\n *\ta hangup. Always called in user context, may sleep.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tn_tty_read()/consumer path:\n *\t\tclaims non-exclusive termios_rwsem\n *\t\tpublishes read_tail\n */\n\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t unsigned char __user *buf, size_t nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tunsigned char __user *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tint minimum, time;\n\tssize_t retval = 0;\n\tlong timeout;\n\tunsigned long flags;\n\tint packet;\n\n\tc = job_control(tty, file);\n\tif (c < 0)\n\t\treturn c;\n\n\t/*\n\t *\tInternal serialization of reads.\n\t */\n\tif (file->f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&ldata->atomic_read_lock))\n\t\t\treturn -EAGAIN;\n\t} else {\n\t\tif (mutex_lock_interruptible(&ldata->atomic_read_lock))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\tminimum = time = 0;\n\ttimeout = MAX_SCHEDULE_TIMEOUT;\n\tif (!ldata->icanon) {\n\t\tminimum = MIN_CHAR(tty);\n\t\tif (minimum) {\n\t\t\ttime = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tif (time)\n\t\t\t\tldata->minimum_to_wake = 1;\n\t\t\telse if (!waitqueue_active(&tty->read_wait) ||\n\t\t\t\t (ldata->minimum_to_wake > minimum))\n\t\t\t\tldata->minimum_to_wake = minimum;\n\t\t} else {\n\t\t\ttimeout = (HZ / 10) * TIME_CHAR(tty);\n\t\t\tldata->minimum_to_wake = minimum = 1;\n\t\t}\n\t}\n\n\tpacket = tty->packet;\n\n\tadd_wait_queue(&tty->read_wait, &wait);\n\twhile (nr) {\n\t\t/* First test for status change. */\n\t\tif (packet && tty->link->ctrl_status) {\n\t\t\tunsigned char cs;\n\t\t\tif (b != buf)\n\t\t\t\tbreak;\n\t\t\tspin_lock_irqsave(&tty->link->ctrl_lock, flags);\n\t\t\tcs = tty->link->ctrl_status;\n\t\t\ttty->link->ctrl_status = 0;\n\t\t\tspin_unlock_irqrestore(&tty->link->ctrl_lock, flags);\n\t\t\tif (tty_put_user(tty, cs, b++)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tb--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnr--;\n\t\t\tbreak;\n\t\t}\n\t\t/* This statement must be first before checking for input\n\t\t   so that any interrupt will set the state back to\n\t\t   TASK_RUNNING. */\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\tif (((minimum - (b - buf)) < ldata->minimum_to_wake) &&\n\t\t    ((minimum - (b - buf)) >= 1))\n\t\t\tldata->minimum_to_wake = (minimum - (b - buf));\n\n\t\tif (!input_available_p(tty, 0)) {\n\t\t\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\n\t\t\t\tup_read(&tty->termios_rwsem);\n\t\t\t\ttty_flush_to_ldisc(tty);\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tif (!input_available_p(tty, 0)) {\n\t\t\t\t\tretval = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (tty_hung_up_p(file))\n\t\t\t\t\tbreak;\n\t\t\t\tif (!timeout)\n\t\t\t\t\tbreak;\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tretval = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tretval = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tn_tty_set_room(tty);\n\t\t\t\tup_read(&tty->termios_rwsem);\n\n\t\t\t\ttimeout = schedule_timeout(timeout);\n\n\t\t\t\tdown_read(&tty->termios_rwsem);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\t/* Deal with packet mode. */\n\t\tif (packet && b == buf) {\n\t\t\tif (tty_put_user(tty, TIOCPKT_DATA, b++)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tb--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnr--;\n\t\t}\n\n\t\tif (ldata->icanon && !L_EXTPROC(tty)) {\n\t\t\tretval = canon_copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (retval == -EAGAIN) {\n\t\t\t\tretval = 0;\n\t\t\t\tcontinue;\n\t\t\t} else if (retval)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint uncopied;\n\t\t\t/* The copy function takes the read lock and handles\n\t\t\t   locking internally for this case */\n\t\t\tuncopied = copy_from_read_buf(tty, &b, &nr);\n\t\t\tuncopied += copy_from_read_buf(tty, &b, &nr);\n\t\t\tif (uncopied) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tn_tty_check_unthrottle(tty);\n\n\t\tif (b - buf >= minimum)\n\t\t\tbreak;\n\t\tif (time)\n\t\t\ttimeout = time;\n\t}\n\tn_tty_set_room(tty);\n\tup_read(&tty->termios_rwsem);\n\n\tremove_wait_queue(&tty->read_wait, &wait);\n\tif (!waitqueue_active(&tty->read_wait))\n\t\tldata->minimum_to_wake = minimum;\n\n\tmutex_unlock(&ldata->atomic_read_lock);\n\n\t__set_current_state(TASK_RUNNING);\n\tif (b - buf)\n\t\tretval = b - buf;\n\n\treturn retval;\n}\n\n/**\n *\tn_tty_write\t\t-\twrite function for tty\n *\t@tty: tty device\n *\t@file: file object\n *\t@buf: userspace buffer pointer\n *\t@nr: size of I/O\n *\n *\tWrite function of the terminal device.  This is serialized with\n *\trespect to other write callers but not to termios changes, reads\n *\tand other such events.  Since the receive code will echo characters,\n *\tthus calling driver write methods, the output_lock is used in\n *\tthe output processing functions called here as well as in the\n *\techo processing function to protect the column state and space\n *\tleft in the buffer.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\n *\tLocking: output_lock to protect column state and space left\n *\t\t (note that the process_output*() functions take this\n *\t\t  lock themselves)\n */\n\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t   const unsigned char *buf, size_t nr)\n{\n\tconst unsigned char *b = buf;\n\tDECLARE_WAITQUEUE(wait, current);\n\tint c;\n\tssize_t retval = 0;\n\n\t/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */\n\tif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\n\t\tretval = tty_check_change(tty);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tdown_read(&tty->termios_rwsem);\n\n\t/* Write out any echoed characters that are still pending */\n\tprocess_echoes(tty);\n\n\tadd_wait_queue(&tty->write_wait, &wait);\n\twhile (1) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (signal_pending(current)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\n\t\t\tretval = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (O_OPOST(tty)) {\n\t\t\twhile (nr > 0) {\n\t\t\t\tssize_t num = process_output_block(tty, b, nr);\n\t\t\t\tif (num < 0) {\n\t\t\t\t\tif (num == -EAGAIN)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tretval = num;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tb += num;\n\t\t\t\tnr -= num;\n\t\t\t\tif (nr == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc = *b;\n\t\t\t\tif (process_output(c, tty) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tb++; nr--;\n\t\t\t}\n\t\t\tif (tty->ops->flush_chars)\n\t\t\t\ttty->ops->flush_chars(tty);\n\t\t} else {\n\t\t\tstruct n_tty_data *ldata = tty->disc_data;\n\n\t\t\twhile (nr > 0) {\n\t\t\t\tmutex_lock(&ldata->output_lock);\n\t\t\t\tc = tty->ops->write(tty, b, nr);\n\t\t\t\tmutex_unlock(&ldata->output_lock);\n\t\t\t\tif (c < 0) {\n\t\t\t\t\tretval = c;\n\t\t\t\t\tgoto break_out;\n\t\t\t\t}\n\t\t\t\tif (!c)\n\t\t\t\t\tbreak;\n\t\t\t\tb += c;\n\t\t\t\tnr -= c;\n\t\t\t}\n\t\t}\n\t\tif (!nr)\n\t\t\tbreak;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tup_read(&tty->termios_rwsem);\n\n\t\tschedule();\n\n\t\tdown_read(&tty->termios_rwsem);\n\t}\nbreak_out:\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (b - buf != nr && tty->fasync)\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\tup_read(&tty->termios_rwsem);\n\treturn (b - buf) ? b - buf : retval;\n}\n\n/**\n *\tn_tty_poll\t\t-\tpoll method for N_TTY\n *\t@tty: terminal device\n *\t@file: file accessing it\n *\t@wait: poll table\n *\n *\tCalled when the line discipline is asked to poll() for data or\n *\tfor special events. This code is not serialized with respect to\n *\tother events save open/close.\n *\n *\tThis code must be sure never to sleep through a hangup.\n *\tCalled without the kernel lock held - fine\n */\n\nstatic unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,\n\t\t\t\t\t\t\tpoll_table *wait)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tunsigned int mask = 0;\n\n\tpoll_wait(file, &tty->read_wait, wait);\n\tpoll_wait(file, &tty->write_wait, wait);\n\tif (input_available_p(tty, 1))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (tty->packet && tty->link->ctrl_status)\n\t\tmask |= POLLPRI | POLLIN | POLLRDNORM;\n\tif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\n\t\tmask |= POLLHUP;\n\tif (tty_hung_up_p(file))\n\t\tmask |= POLLHUP;\n\tif (!(mask & (POLLHUP | POLLIN | POLLRDNORM))) {\n\t\tif (MIN_CHAR(tty) && !TIME_CHAR(tty))\n\t\t\tldata->minimum_to_wake = MIN_CHAR(tty);\n\t\telse\n\t\t\tldata->minimum_to_wake = 1;\n\t}\n\tif (tty->ops->write && !tty_is_writelocked(tty) &&\n\t\t\ttty_chars_in_buffer(tty) < WAKEUP_CHARS &&\n\t\t\ttty_write_room(tty) > 0)\n\t\tmask |= POLLOUT | POLLWRNORM;\n\treturn mask;\n}\n\nstatic unsigned long inq_canon(struct n_tty_data *ldata)\n{\n\tsize_t nr, head, tail;\n\n\tif (ldata->canon_head == ldata->read_tail)\n\t\treturn 0;\n\thead = ldata->canon_head;\n\ttail = ldata->read_tail;\n\tnr = head - tail;\n\t/* Skip EOF-chars.. */\n\twhile (head != tail) {\n\t\tif (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&\n\t\t    read_buf(ldata, tail) == __DISABLED_CHAR)\n\t\t\tnr--;\n\t\ttail++;\n\t}\n\treturn nr;\n}\n\nstatic int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}\n\nstatic void n_tty_fasync(struct tty_struct *tty, int on)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\n\tif (!waitqueue_active(&tty->read_wait)) {\n\t\tif (on)\n\t\t\tldata->minimum_to_wake = 1;\n\t\telse if (!tty->fasync)\n\t\t\tldata->minimum_to_wake = N_TTY_BUF_SIZE;\n\t}\n}\n\nstruct tty_ldisc_ops tty_ldisc_N_TTY = {\n\t.magic           = TTY_LDISC_MAGIC,\n\t.name            = \"n_tty\",\n\t.open            = n_tty_open,\n\t.close           = n_tty_close,\n\t.flush_buffer    = n_tty_flush_buffer,\n\t.chars_in_buffer = n_tty_chars_in_buffer,\n\t.read            = n_tty_read,\n\t.write           = n_tty_write,\n\t.ioctl           = n_tty_ioctl,\n\t.set_termios     = n_tty_set_termios,\n\t.poll            = n_tty_poll,\n\t.receive_buf     = n_tty_receive_buf,\n\t.write_wakeup    = n_tty_write_wakeup,\n\t.fasync\t\t = n_tty_fasync,\n\t.receive_buf2\t = n_tty_receive_buf2,\n};\n\n/**\n *\tn_tty_inherit_ops\t-\tinherit N_TTY methods\n *\t@ops: struct tty_ldisc_ops where to save N_TTY methods\n *\n *\tEnables a 'subclass' line discipline to 'inherit' N_TTY\n *\tmethods.\n */\n\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\n{\n\t*ops = tty_ldisc_N_TTY;\n\tops->owner = NULL;\n\tops->refcount = ops->flags = 0;\n}\nEXPORT_SYMBOL_GPL(n_tty_inherit_ops);\n"], "filenames": ["drivers/tty/n_tty.c"], "buggy_code_start_loc": [2355], "buggy_code_end_loc": [2357], "fixing_code_start_loc": [2356], "fixing_code_end_loc": [2362], "type": "CWE-362", "message": "The n_tty_write function in drivers/tty/n_tty.c in the Linux kernel through 3.14.3 does not properly manage tty driver access in the \"LECHO & !OPOST\" case, which allows local users to cause a denial of service (memory corruption and system crash) or gain privileges by triggering a race condition involving read and write operations with long strings.", "other": {"cve": {"id": "CVE-2014-0196", "sourceIdentifier": "secalert@redhat.com", "published": "2014-05-07T10:55:04.337", "lastModified": "2023-02-13T00:36:17.733", "vulnStatus": "Modified", "cisaExploitAdd": "2023-05-12", "cisaActionDue": "2023-06-02", "cisaRequiredAction": "The impacted product is end-of-life and should be disconnected if still in use.", "cisaVulnerabilityName": "Linux Kernel Race Condition Vulnerability", "descriptions": [{"lang": "en", "value": "The n_tty_write function in drivers/tty/n_tty.c in the Linux kernel through 3.14.3 does not properly manage tty driver access in the \"LECHO & !OPOST\" case, which allows local users to cause a denial of service (memory corruption and system crash) or gain privileges by triggering a race condition involving read and write operations with long strings."}, {"lang": "es", "value": "La funci\u00f3n n_tty_write en drivers/tty/n_tty.c en el kernel de Linux hasta 3.14.3 no maneja debidamente acceso al controlador tty en el caso 'LECHO & !OPOST', lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (consumo de memoria y ca\u00edda de sistema) o ganar privilegios mediante la provocaci\u00f3n de una condici\u00f3n de carrera involucrando operaciones de lectura y escritura con cadenas largas."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.14.3", "matchCriteriaId": "B465C548-09E9-4CD5-A1C2-57ED09C9E3F4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "036E8A89-7A16-411F-9D31-676313BB7244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.3:*:*:*:*:*:*:*", "matchCriteriaId": "8382A145-CDD9-437E-9DE7-A349956778B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.4:*:*:*:*:*:*:*", "matchCriteriaId": "8A8E07B7-3739-4BEB-88F8-C7F62431E889"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:6.3:*:*:*:*:*:*:*", "matchCriteriaId": "413CC30E-5FFE-47A4-B38B-80E3A9B13238"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_desktop:11:sp3:*:*:*:-:*:*", "matchCriteriaId": "DD41513F-36F9-459C-A0CB-26C025E63CDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_high_availability_extension:11:sp3:*:*:*:*:*:*", "matchCriteriaId": "B39F3060-6F9E-4F20-8924-FEF5ED8A30CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp3:*:*:*:-:*:*", "matchCriteriaId": "B2866FAF-4340-4EA7-9009-6594ADA27AF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:suse_linux_enterprise_server:11:sp3:*:*:*:vmware:*:*", "matchCriteriaId": "0EA03350-8702-43D5-8605-5FB765A3F60B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:linux:6:-:*:*:*:*:*:*", "matchCriteriaId": "D7B037A8-72A6-4DFF-94B2-D688A5F6F876"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.10:*:*:*:*:*:*:*", "matchCriteriaId": "E2076871-2E80-4605-A470-A41C1A8EC7EE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:13.10:*:*:*:*:*:*:*", "matchCriteriaId": "7F61F047-129C-41A6-8A27-FFCBB8563E91"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_access_policy_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "8F315708-017C-4362-9C09-6774F89D9370"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_advanced_firewall_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.3.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "48BBEF73-E87D-467F-85EB-47BE212DF0E8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_analytics:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "A430FFB4-418C-43DA-8E17-020618A77A56"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_acceleration_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.4.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "C483253F-841E-4D4E-9B4A-932E9D07268B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_application_security_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "7A0CC74C-6914-4A6F-A1CE-65A695AE31F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_edge_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "9FF30167-0241-4136-82F8-2D2FB545C19A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_global_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "54A45725-FECD-4CA9-BFA4-E13FCDFDDF13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_link_controller:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "8C596B3F-9D93-49D2-99D7-D590CC9AEAA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_local_traffic_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "D8696A6B-1B56-43B5-A506-21E17735B9CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_policy_enforcement_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.3.0", "versionEndIncluding": "11.5.1", "matchCriteriaId": "E9A06D61-E6CB-4A8A-B06D-9FEA1812C167"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_protocol_security_module:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.4.1", "matchCriteriaId": "8C666A18-9DED-4B49-92DE-474403FC17BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_wan_optimization_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "A6B52D60-38DB-4BE9-91F4-B6553F5E5A93"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-ip_webaccelerator:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "E1E3204F-9464-4AC3-819B-D1A6B399FAE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_application_delivery_controller:4.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "222B4DE7-1D3D-40DF-A9EB-EFABDA8FAEA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_centralized_management:4.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "24AEF0B2-7C8C-432C-A840-C2441A70343F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_cloud:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.5.0", "matchCriteriaId": "8C8BF865-BA45-4711-829F-EC8E5EA22D2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_cloud_and_orchestration:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "E21D6206-4716-47FE-A733-F18343656E94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_device:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndIncluding": "4.5.0", "matchCriteriaId": "3BC0EAFD-DA5E-4A1B-81CB-0D5A964F9EB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:big-iq_security:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0.0", "versionEndIncluding": "4.5.0", "matchCriteriaId": "6B3E56EB-202A-4F58-8E94-B2DDA1693498"}, {"vulnerable": true, "criteria": "cpe:2.3:a:f5:enterprise_manager:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndIncluding": "3.1.1", "matchCriteriaId": "96A9D473-86E0-463E-94C3-0E76B2CB1EEF"}]}]}], "references": [{"url": "http://bugzilla.novell.com/show_bug.cgi?id=875690", "source": "secalert@redhat.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=4291086b1f081b869c6d79e5b7441633dc3ace00", "source": "secalert@redhat.com"}, {"url": "http://linux.oracle.com/errata/ELSA-2014-0771.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-05/msg00007.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2014-05/msg00012.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://pastebin.com/raw.php?i=yTSFUBgZ", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0512.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://secunia.com/advisories/59218", "source": "secalert@redhat.com", "tags": ["Not Applicable"]}, {"url": "http://source.android.com/security/bulletin/2016-07-01.html", "source": "secalert@redhat.com", "tags": ["Not Applicable"]}, {"url": "http://support.f5.com/kb/en-us/solutions/public/15000/300/sol15319.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2926", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2014/dsa-2928", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.exploit-db.com/exploits/33516", "source": "secalert@redhat.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "http://www.openwall.com/lists/oss-security/2014/05/05/6", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.osvdb.org/106646", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://www.ubuntu.com/usn/USN-2196-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2197-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2198-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2199-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2200-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2201-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2202-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2203-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2204-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1094232", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/4291086b1f081b869c6d79e5b7441633dc3ace00", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4291086b1f081b869c6d79e5b7441633dc3ace00"}}