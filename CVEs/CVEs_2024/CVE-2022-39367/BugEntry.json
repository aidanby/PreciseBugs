{"buggy_code": ["/* Copyright (c) 2012-2013, University of Edinburgh.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * * Neither the name of the University of Edinburgh nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * This software is derived from (and contains code from) QTItools and MathAssessEngine.\n * QTItools is (c) 2008, University of Southampton.\n * MathAssessEngine is (c) 2010, University of Edinburgh.\n */\npackage uk.ac.ed.ph.qtiworks.services;\n\nimport uk.ac.ed.ph.qtiworks.QtiWorksRuntimeException;\nimport uk.ac.ed.ph.qtiworks.domain.entities.AssessmentPackage;\nimport uk.ac.ed.ph.qtiworks.domain.entities.AssessmentPackageImportType;\nimport uk.ac.ed.ph.qtiworks.services.domain.AssessmentPackageDataImportException;\nimport uk.ac.ed.ph.qtiworks.services.domain.AssessmentPackageDataImportException.ImportFailureReason;\n\nimport uk.ac.ed.ph.jqtiplus.internal.util.Assert;\nimport uk.ac.ed.ph.jqtiplus.node.AssessmentObjectType;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.ContentPackageResource;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.ImsManifestException;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.QtiContentPackageExtractor;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.QtiContentPackageSummary;\nimport uk.ac.ed.ph.jqtiplus.xmlutils.XmlResourceNotFoundException;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipInputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport com.google.common.io.ByteStreams;\n\n/**\n * Tiny helper service for importing assessment package data into the filesystem\n * <p>\n * (This should have been absorbed into {@link AssessmentPackageFileService}, but its current lack\n * of dependencies makes it easy to unit test!)\n * <p>\n * This is NO authorisation at this level.\n *\n * @author David McKain\n */\n@Service\npublic class AssessmentPackageFileImporter {\n\n    private static final Logger logger = LoggerFactory.getLogger(AssessmentPackageFileImporter.class);\n\n    /** File name that will be used when uploading standalone XML */\n    private static final String STANDALONE_XML_IMPORT_FILE_NAME = \"qti.xml\";\n\n    /**\n     * Imports the assessment data from the given {@link MultipartFile} into the given\n     * sandbox directory, which the caller must have created.\n     * <p>\n     * Returns a partially-filled unpersisted {@link AssessmentPackage} object representing the\n     * results of this.\n     *\n     * @throws AssessmentPackageDataImportException\n     * @throws IllegalArgumentException if any of the provided arguments are null\n     * @throws QtiWorksRuntimeException if something unexpected happens, such as experiencing\n     *   an {@link IOException}\n     */\n    public AssessmentPackage importAssessmentPackageData(final File importSandboxDirectory,\n            final MultipartFile multipartFile)\n            throws AssessmentPackageDataImportException {\n        Assert.notNull(importSandboxDirectory, \"importSandboxDirectory\");\n        Assert.notNull(multipartFile, \"multipartFile\");\n        AssessmentPackage assessmentPackage = null;\n\n        final String contentType = ServiceUtilities.computeContentType(multipartFile);\n        if (\"application/xml\".equals(contentType) || \"text/xml\".equals(contentType) || contentType.endsWith(\"+xml\")) {\n            /* Looks like an XML content type */\n            logger.debug(\"Import data uses a known XML MIME type {} so saving to {} and treating as XML\", contentType, importSandboxDirectory);\n            assessmentPackage = importStandaloneXml(importSandboxDirectory, multipartFile);\n        }\n        else {\n            /* Try to treat as a ZIP */\n            final boolean zipSuccess = tryUnpackZipFile(importSandboxDirectory, multipartFile);\n            if (zipSuccess) {\n                logger.debug(\"Import data was successfully expanded as a ZIP file\");\n                assessmentPackage = processUnpackedZip(importSandboxDirectory);\n            }\n            else {\n                logger.warn(\"Import data with MIME type {} was neither a supported XML MIME type nor a ZIP file (containing at least one entry)\", contentType);\n                throw new AssessmentPackageDataImportException(ImportFailureReason.NOT_XML_OR_ZIP);\n            }\n        }\n\n        logger.info(\"Successfully imported data for new {}\", assessmentPackage);\n        return assessmentPackage;\n    }\n\n    private AssessmentPackage importStandaloneXml(final File importSandboxDirectory, final MultipartFile multipartFile) {\n        /* Save XML */\n        final File resultFile = new File(importSandboxDirectory, STANDALONE_XML_IMPORT_FILE_NAME);\n        try {\n            multipartFile.transferTo(resultFile);\n        }\n        catch (final IOException e) {\n            throw QtiWorksRuntimeException.unexpectedException(e);\n        }\n\n        /* Create AssessmentPackage representing this */\n        final AssessmentPackage assessmentPackage = new AssessmentPackage();\n        assessmentPackage.setAssessmentType(AssessmentObjectType.ASSESSMENT_ITEM);\n        assessmentPackage.setImportType(AssessmentPackageImportType.STANDALONE_ITEM_XML);\n        assessmentPackage.setAssessmentHref(STANDALONE_XML_IMPORT_FILE_NAME);\n        assessmentPackage.setSandboxPath(importSandboxDirectory.getAbsolutePath());\n        assessmentPackage.setQtiFileHrefs(new HashSet<String>(Arrays.asList(STANDALONE_XML_IMPORT_FILE_NAME)));\n        return assessmentPackage;\n    }\n\n    private boolean tryUnpackZipFile(final File importSandboxDirectory, final MultipartFile multipartFile) {\n        /* Extract ZIP contents */\n        ZipEntry zipEntry = null;\n        InputStream inputStream = null;\n        ZipInputStream zipInputStream = null;\n        boolean foundEntry = false;\n        try {\n            inputStream = ServiceUtilities.ensureInputSream(multipartFile);\n            zipInputStream = new ZipInputStream(inputStream);\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                foundEntry = true;\n                final File destFile = new File(importSandboxDirectory, zipEntry.getName());\n                if (!zipEntry.isDirectory()) {\n                    ServiceUtilities.ensureFileCreated(destFile);\n                    final FileOutputStream destOutputStream = new FileOutputStream(destFile);\n                    try {\n                        ByteStreams.copy(zipInputStream, destOutputStream);\n                    }\n                    finally {\n                        ServiceUtilities.ensureClose(destOutputStream);\n                    }\n                    zipInputStream.closeEntry();\n                }\n            }\n        }\n        catch (final EOFException e) {\n            /* (Might get this if the ZIP file is truncated for some reason) */\n            return false;\n        }\n        catch (final ZipException e) {\n            return false;\n        }\n        catch (final IOException e) {\n            throw QtiWorksRuntimeException.unexpectedException(e);\n        }\n        finally {\n            ServiceUtilities.ensureClose(zipInputStream, inputStream);\n        }\n        return foundEntry;\n    }\n\n    private AssessmentPackage processUnpackedZip(final File importSandboxDirectory)\n            throws AssessmentPackageDataImportException {\n        /* Expand content package */\n        final QtiContentPackageExtractor contentPackageExtractor = new QtiContentPackageExtractor(importSandboxDirectory);\n        QtiContentPackageSummary contentPackageSummary;\n        try {\n            contentPackageSummary = contentPackageExtractor.parse();\n        }\n        catch (final XmlResourceNotFoundException e) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.NOT_CONTENT_PACKAGE, e);\n        }\n        catch (final ImsManifestException e) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.BAD_IMS_MANIFEST, e);\n        }\n        logger.trace(\"Submitted content package was successfully parsed as {}\", contentPackageSummary);\n\n        /* Build appropriate result based on number of item & test resources found */\n        final int testCount = contentPackageSummary.getTestResources().size();\n        final int itemCount = contentPackageSummary.getItemResources().size();\n        final AssessmentPackage assessmentPackage = new AssessmentPackage();\n        assessmentPackage.setImportType(AssessmentPackageImportType.CONTENT_PACKAGE);\n        assessmentPackage.setSandboxPath(importSandboxDirectory.getAbsolutePath());\n        if (testCount==1) {\n            /* Treat as a test */\n            logger.debug(\"Package contains 1 test resource, so treating this as an AssessmentTest\");\n            assessmentPackage.setAssessmentType(AssessmentObjectType.ASSESSMENT_TEST);\n            assessmentPackage.setAssessmentHref(checkPackageFile(importSandboxDirectory,\n                    contentPackageSummary.getTestResources().get(0).getHref()));\n        }\n        else if (testCount==0 && itemCount==1) {\n            /* Treat as an item */\n            logger.debug(\"Package contains 1 item resource and no test resources, so treating this as an AssessmentItem\");\n            assessmentPackage.setAssessmentType(AssessmentObjectType.ASSESSMENT_ITEM);\n            assessmentPackage.setAssessmentHref(checkPackageFile(importSandboxDirectory,\n                    contentPackageSummary.getItemResources().get(0).getHref()));\n        }\n        else {\n            /* Barf */\n            logger.debug(\"Package contains {} items and {} tests. Don't know how to deal with this\", itemCount, testCount);\n            throw new AssessmentPackageDataImportException(ImportFailureReason.UNSUPPORTED_PACKAGE_CONTENTS, itemCount, testCount);\n        }\n\n        /* Build up Set of all files in the package. We need to be a bit careful to flag up the\n         * ones that correspond to QTI files. We'll assume that QTI files are the *first* ones\n         * listed in each item/test resource in the CP, though this is not clear from the CP spec\n         */\n        final Set<String> packageQtiFileBuilder = new HashSet<String>();\n        final Set<String> packageSafeFileBuilder = new HashSet<String>();\n        buildPackageFileMap(importSandboxDirectory, packageQtiFileBuilder, packageSafeFileBuilder, contentPackageSummary.getItemResources());\n        buildPackageFileMap(importSandboxDirectory, packageQtiFileBuilder, packageSafeFileBuilder, contentPackageSummary.getTestResources());\n        assessmentPackage.setQtiFileHrefs(packageQtiFileBuilder);\n        assessmentPackage.setSafeFileHrefs(packageSafeFileBuilder);\n\n        return assessmentPackage;\n    }\n\n    /**\n     * Builds up the provided Map of all files within this package, flagging those which correspond\n     * to QTI XML files, which are assumed to be the *first* files declared within item or test\n     * resource elements in the manifest.\n     */\n    private void buildPackageFileMap(final File importSandboxDirectory,\n            final Set<String> packageQtiFileBuilder, final Set<String> packageSafeFileBuilder,\n            final List<ContentPackageResource> qtiResources)\n            throws AssessmentPackageDataImportException {\n        for (final ContentPackageResource qtiResource : qtiResources) {\n            final List<URI> fileHrefs = qtiResource.getFileHrefs();\n            boolean isFirst = true;\n            for (final URI fileHref : fileHrefs) {\n                final String fileHrefString = checkPackageFile(importSandboxDirectory, fileHref);\n                if (isFirst) {\n                    packageQtiFileBuilder.add(fileHrefString);\n                }\n                else {\n                    packageSafeFileBuilder.add(fileHrefString);\n                }\n                isFirst = false;\n            }\n        }\n    }\n\n    /**\n     * Checks the given file URI (href) and makes sure it exists within the sandbox.\n     * Returns the original href as a String if successful, otherwise throws\n     * {@link AssessmentPackageDataImportException}.\n     */\n    private String checkPackageFile(final File importSandboxDirectory, final URI href)\n            throws AssessmentPackageDataImportException {\n        final String hrefString = href.toString();\n        final URI sandboxUri = importSandboxDirectory.toURI();\n        final URI resolvedFileUri = sandboxUri.resolve(href);\n\n        /* Make sure href points to something within the sandbox */\n        if (!resolvedFileUri.toString().startsWith(sandboxUri.toString())) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.HREF_OUTSIDE_PACKAGE, hrefString);\n        }\n\n        /* Make sure file exists */\n        final File resolvedFile = new File(resolvedFileUri);\n        if (!resolvedFile.exists()) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.FILE_MISSING, hrefString);\n        }\n\n        return hrefString;\n    }\n}\n"], "fixing_code": ["/* Copyright (c) 2012-2013, University of Edinburgh.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * * Neither the name of the University of Edinburgh nor the names of its\n *   contributors may be used to endorse or promote products derived from this\n *   software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n *\n * This software is derived from (and contains code from) QTItools and MathAssessEngine.\n * QTItools is (c) 2008, University of Southampton.\n * MathAssessEngine is (c) 2010, University of Edinburgh.\n */\npackage uk.ac.ed.ph.qtiworks.services;\n\nimport uk.ac.ed.ph.qtiworks.QtiWorksRuntimeException;\nimport uk.ac.ed.ph.qtiworks.domain.entities.AssessmentPackage;\nimport uk.ac.ed.ph.qtiworks.domain.entities.AssessmentPackageImportType;\nimport uk.ac.ed.ph.qtiworks.services.domain.AssessmentPackageDataImportException;\nimport uk.ac.ed.ph.qtiworks.services.domain.AssessmentPackageDataImportException.ImportFailureReason;\n\nimport uk.ac.ed.ph.jqtiplus.internal.util.Assert;\nimport uk.ac.ed.ph.jqtiplus.node.AssessmentObjectType;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.ContentPackageResource;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.ImsManifestException;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.QtiContentPackageExtractor;\nimport uk.ac.ed.ph.jqtiplus.utils.contentpackaging.QtiContentPackageSummary;\nimport uk.ac.ed.ph.jqtiplus.xmlutils.XmlResourceNotFoundException;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\nimport java.util.zip.ZipInputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport com.google.common.io.ByteStreams;\n\n/**\n * Tiny helper service for importing assessment package data into the filesystem\n * <p>\n * (This should have been absorbed into {@link AssessmentPackageFileService}, but its current lack\n * of dependencies makes it easy to unit test!)\n * <p>\n * This is NO authorisation at this level.\n *\n * @author David McKain\n */\n@Service\npublic class AssessmentPackageFileImporter {\n\n    private static final Logger logger = LoggerFactory.getLogger(AssessmentPackageFileImporter.class);\n\n    /** File name that will be used when uploading standalone XML */\n    private static final String STANDALONE_XML_IMPORT_FILE_NAME = \"qti.xml\";\n\n    /**\n     * Imports the assessment data from the given {@link MultipartFile} into the given\n     * sandbox directory, which the caller must have created.\n     * <p>\n     * Returns a partially-filled unpersisted {@link AssessmentPackage} object representing the\n     * results of this.\n     *\n     * @throws AssessmentPackageDataImportException\n     * @throws IllegalArgumentException if any of the provided arguments are null\n     * @throws QtiWorksRuntimeException if something unexpected happens, such as experiencing\n     *   an {@link IOException}\n     */\n    public AssessmentPackage importAssessmentPackageData(final File importSandboxDirectory,\n            final MultipartFile multipartFile)\n            throws AssessmentPackageDataImportException {\n        Assert.notNull(importSandboxDirectory, \"importSandboxDirectory\");\n        Assert.notNull(multipartFile, \"multipartFile\");\n        AssessmentPackage assessmentPackage = null;\n\n        final String contentType = ServiceUtilities.computeContentType(multipartFile);\n        if (\"application/xml\".equals(contentType) || \"text/xml\".equals(contentType) || contentType.endsWith(\"+xml\")) {\n            /* Looks like an XML content type */\n            logger.debug(\"Import data uses a known XML MIME type {} so saving to {} and treating as XML\", contentType, importSandboxDirectory);\n            assessmentPackage = importStandaloneXml(importSandboxDirectory, multipartFile);\n        }\n        else {\n            /* Try to treat as a ZIP */\n            final boolean zipSuccess = tryUnpackZipFile(importSandboxDirectory, multipartFile);\n            if (zipSuccess) {\n                logger.debug(\"Import data was successfully expanded as a ZIP file\");\n                assessmentPackage = processUnpackedZip(importSandboxDirectory);\n            }\n            else {\n                logger.warn(\"Import data with MIME type {} was neither a supported XML MIME type nor a ZIP file (containing at least one entry)\", contentType);\n                throw new AssessmentPackageDataImportException(ImportFailureReason.NOT_XML_OR_ZIP);\n            }\n        }\n\n        logger.info(\"Successfully imported data for new {}\", assessmentPackage);\n        return assessmentPackage;\n    }\n\n    private AssessmentPackage importStandaloneXml(final File importSandboxDirectory, final MultipartFile multipartFile) {\n        /* Save XML */\n        final File resultFile = new File(importSandboxDirectory, STANDALONE_XML_IMPORT_FILE_NAME);\n        try {\n            multipartFile.transferTo(resultFile);\n        }\n        catch (final IOException e) {\n            throw QtiWorksRuntimeException.unexpectedException(e);\n        }\n\n        /* Create AssessmentPackage representing this */\n        final AssessmentPackage assessmentPackage = new AssessmentPackage();\n        assessmentPackage.setAssessmentType(AssessmentObjectType.ASSESSMENT_ITEM);\n        assessmentPackage.setImportType(AssessmentPackageImportType.STANDALONE_ITEM_XML);\n        assessmentPackage.setAssessmentHref(STANDALONE_XML_IMPORT_FILE_NAME);\n        assessmentPackage.setSandboxPath(importSandboxDirectory.getAbsolutePath());\n        assessmentPackage.setQtiFileHrefs(new HashSet<String>(Arrays.asList(STANDALONE_XML_IMPORT_FILE_NAME)));\n        return assessmentPackage;\n    }\n\n    private boolean tryUnpackZipFile(final File importSandboxDirectory, final MultipartFile multipartFile) {\n        /* Extract ZIP contents */\n        ZipEntry zipEntry = null;\n        InputStream inputStream = null;\n        ZipInputStream zipInputStream = null;\n        boolean foundEntry = false;\n        try {\n            inputStream = ServiceUtilities.ensureInputSream(multipartFile);\n            zipInputStream = new ZipInputStream(inputStream);\n            while ((zipEntry = zipInputStream.getNextEntry()) != null) {\n                foundEntry = true;\n                final File destFile = new File(importSandboxDirectory, zipEntry.getName());\n                if (!destFile.toPath().normalize().startsWith(importSandboxDirectory.toPath().normalize())) {\n                    throw new RuntimeException(\"Bad zip entry\");\n                }\n                if (!zipEntry.isDirectory()) {\n                    ServiceUtilities.ensureFileCreated(destFile);\n                    final FileOutputStream destOutputStream = new FileOutputStream(destFile);\n                    try {\n                        ByteStreams.copy(zipInputStream, destOutputStream);\n                    }\n                    finally {\n                        ServiceUtilities.ensureClose(destOutputStream);\n                    }\n                    zipInputStream.closeEntry();\n                }\n            }\n        }\n        catch (final EOFException e) {\n            /* (Might get this if the ZIP file is truncated for some reason) */\n            return false;\n        }\n        catch (final ZipException e) {\n            return false;\n        }\n        catch (final IOException e) {\n            throw QtiWorksRuntimeException.unexpectedException(e);\n        }\n        finally {\n            ServiceUtilities.ensureClose(zipInputStream, inputStream);\n        }\n        return foundEntry;\n    }\n\n    private AssessmentPackage processUnpackedZip(final File importSandboxDirectory)\n            throws AssessmentPackageDataImportException {\n        /* Expand content package */\n        final QtiContentPackageExtractor contentPackageExtractor = new QtiContentPackageExtractor(importSandboxDirectory);\n        QtiContentPackageSummary contentPackageSummary;\n        try {\n            contentPackageSummary = contentPackageExtractor.parse();\n        }\n        catch (final XmlResourceNotFoundException e) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.NOT_CONTENT_PACKAGE, e);\n        }\n        catch (final ImsManifestException e) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.BAD_IMS_MANIFEST, e);\n        }\n        logger.trace(\"Submitted content package was successfully parsed as {}\", contentPackageSummary);\n\n        /* Build appropriate result based on number of item & test resources found */\n        final int testCount = contentPackageSummary.getTestResources().size();\n        final int itemCount = contentPackageSummary.getItemResources().size();\n        final AssessmentPackage assessmentPackage = new AssessmentPackage();\n        assessmentPackage.setImportType(AssessmentPackageImportType.CONTENT_PACKAGE);\n        assessmentPackage.setSandboxPath(importSandboxDirectory.getAbsolutePath());\n        if (testCount==1) {\n            /* Treat as a test */\n            logger.debug(\"Package contains 1 test resource, so treating this as an AssessmentTest\");\n            assessmentPackage.setAssessmentType(AssessmentObjectType.ASSESSMENT_TEST);\n            assessmentPackage.setAssessmentHref(checkPackageFile(importSandboxDirectory,\n                    contentPackageSummary.getTestResources().get(0).getHref()));\n        }\n        else if (testCount==0 && itemCount==1) {\n            /* Treat as an item */\n            logger.debug(\"Package contains 1 item resource and no test resources, so treating this as an AssessmentItem\");\n            assessmentPackage.setAssessmentType(AssessmentObjectType.ASSESSMENT_ITEM);\n            assessmentPackage.setAssessmentHref(checkPackageFile(importSandboxDirectory,\n                    contentPackageSummary.getItemResources().get(0).getHref()));\n        }\n        else {\n            /* Barf */\n            logger.debug(\"Package contains {} items and {} tests. Don't know how to deal with this\", itemCount, testCount);\n            throw new AssessmentPackageDataImportException(ImportFailureReason.UNSUPPORTED_PACKAGE_CONTENTS, itemCount, testCount);\n        }\n\n        /* Build up Set of all files in the package. We need to be a bit careful to flag up the\n         * ones that correspond to QTI files. We'll assume that QTI files are the *first* ones\n         * listed in each item/test resource in the CP, though this is not clear from the CP spec\n         */\n        final Set<String> packageQtiFileBuilder = new HashSet<String>();\n        final Set<String> packageSafeFileBuilder = new HashSet<String>();\n        buildPackageFileMap(importSandboxDirectory, packageQtiFileBuilder, packageSafeFileBuilder, contentPackageSummary.getItemResources());\n        buildPackageFileMap(importSandboxDirectory, packageQtiFileBuilder, packageSafeFileBuilder, contentPackageSummary.getTestResources());\n        assessmentPackage.setQtiFileHrefs(packageQtiFileBuilder);\n        assessmentPackage.setSafeFileHrefs(packageSafeFileBuilder);\n\n        return assessmentPackage;\n    }\n\n    /**\n     * Builds up the provided Map of all files within this package, flagging those which correspond\n     * to QTI XML files, which are assumed to be the *first* files declared within item or test\n     * resource elements in the manifest.\n     */\n    private void buildPackageFileMap(final File importSandboxDirectory,\n            final Set<String> packageQtiFileBuilder, final Set<String> packageSafeFileBuilder,\n            final List<ContentPackageResource> qtiResources)\n            throws AssessmentPackageDataImportException {\n        for (final ContentPackageResource qtiResource : qtiResources) {\n            final List<URI> fileHrefs = qtiResource.getFileHrefs();\n            boolean isFirst = true;\n            for (final URI fileHref : fileHrefs) {\n                final String fileHrefString = checkPackageFile(importSandboxDirectory, fileHref);\n                if (isFirst) {\n                    packageQtiFileBuilder.add(fileHrefString);\n                }\n                else {\n                    packageSafeFileBuilder.add(fileHrefString);\n                }\n                isFirst = false;\n            }\n        }\n    }\n\n    /**\n     * Checks the given file URI (href) and makes sure it exists within the sandbox.\n     * Returns the original href as a String if successful, otherwise throws\n     * {@link AssessmentPackageDataImportException}.\n     */\n    private String checkPackageFile(final File importSandboxDirectory, final URI href)\n            throws AssessmentPackageDataImportException {\n        final String hrefString = href.toString();\n        final URI sandboxUri = importSandboxDirectory.toURI();\n        final URI resolvedFileUri = sandboxUri.resolve(href);\n\n        /* Make sure href points to something within the sandbox */\n        if (!resolvedFileUri.toString().startsWith(sandboxUri.toString())) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.HREF_OUTSIDE_PACKAGE, hrefString);\n        }\n\n        /* Make sure file exists */\n        final File resolvedFile = new File(resolvedFileUri);\n        if (!resolvedFile.exists()) {\n            throw new AssessmentPackageDataImportException(ImportFailureReason.FILE_MISSING, hrefString);\n        }\n\n        return hrefString;\n    }\n}\n"], "filenames": ["qtiworks-engine/src/main/java/uk/ac/ed/ph/qtiworks/services/AssessmentPackageFileImporter.java"], "buggy_code_start_loc": [162], "buggy_code_end_loc": [162], "fixing_code_start_loc": [163], "fixing_code_end_loc": [166], "type": "CWE-22", "message": "QTIWorks is a software suite for standards-based assessment delivery. Prior to version 1.0-beta15, the QTIWorks Engine allows users to upload QTI content packages as ZIP files. The ZIP handling code does not sufficiently check the paths of files contained within ZIP files, so can insert files into other locations in the filesystem if they are writable by the process running the QTIWorks Engine. In extreme cases, this could allow anonymous users to change files in arbitrary locations in the filesystem. In normal QTIWorks Engine deployments, the impact is somewhat reduced because the default QTIWorks configuration does not enable the public demo functionality, so ZIP files can only be uploaded by users with \"instructor\" privileges. This vulnerability is fixed in version 1.0-beta15. There are no database configuration changes required when upgrading to this version. No known workarounds for this issue exist.", "other": {"cve": {"id": "CVE-2022-39367", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-28T16:15:16.287", "lastModified": "2022-11-01T18:46:26.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "QTIWorks is a software suite for standards-based assessment delivery. Prior to version 1.0-beta15, the QTIWorks Engine allows users to upload QTI content packages as ZIP files. The ZIP handling code does not sufficiently check the paths of files contained within ZIP files, so can insert files into other locations in the filesystem if they are writable by the process running the QTIWorks Engine. In extreme cases, this could allow anonymous users to change files in arbitrary locations in the filesystem. In normal QTIWorks Engine deployments, the impact is somewhat reduced because the default QTIWorks configuration does not enable the public demo functionality, so ZIP files can only be uploaded by users with \"instructor\" privileges. This vulnerability is fixed in version 1.0-beta15. There are no database configuration changes required when upgrading to this version. No known workarounds for this issue exist."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0", "matchCriteriaId": "D5D10056-0835-4246-A694-E5F3EFBCEFAB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:-:*:*:*:*:*:*", "matchCriteriaId": "7C2DB04F-A30B-4BA8-8C9B-58F447BB8953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "F4FA5FC7-446E-4DB0-9FC1-3EAE141CC4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "9CD6D802-69DA-445D-91BF-B68F0C2F3187"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "F834A302-473A-4D0A-9960-99D5BF1CA689"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "9A132D79-F228-4CAF-AA34-B1E7EDE24F1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta13:*:*:*:*:*:*", "matchCriteriaId": "0F03E83F-D91C-4A5E-971D-A85A4C3DC788"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta14:*:*:*:*:*:*", "matchCriteriaId": "668010D7-8B1E-436A-8A70-D4F4A30BA6B1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "0A95CEFD-5EC8-4CB5-9559-B5FED6F4B004"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "65BED771-1834-41F0-ABF7-3F94B6C26B0C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "82430ECA-C619-4749-ACDA-A9314038E376"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "C6ACEF3D-3C46-4383-9EE3-E35BF0BF5CC5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "72A683FD-E26D-44F6-BA3A-E6C52A93F1B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "0C90E360-3AC1-41C3-BF14-E2579A5DCBC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "22EDB2AE-B5D5-4805-94B2-AEA0CF9D4B61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qtiworks_project:qtiworks:1.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "9B9022F1-FA79-4579-B677-84902089EECA"}]}]}], "references": [{"url": "https://github.com/davemckain/qtiworks/commit/1a46d6d842877ba2b824d5c269845827e2e0ccac", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/davemckain/qtiworks/pull/81", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/davemckain/qtiworks/security/advisories/GHSA-xrjg-59rc-4j42", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davemckain/qtiworks/commit/1a46d6d842877ba2b824d5c269845827e2e0ccac"}}