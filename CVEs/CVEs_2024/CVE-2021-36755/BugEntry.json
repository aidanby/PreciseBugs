{"buggy_code": ["'use strict';\n\nfunction init (client, $) {\n\n  var notifies = {};\n\n  client.notifies = notifies;\n\n  notifies.notifies = [];\n  notifies.drawer = $('#adminNotifiesDrawer');\n  notifies.button = $('#adminnotifies');\n\n  notifies.updateAdminNotifies = function updateAdminNotifies() {\n\n    var src = '/api/v1/adminnotifies?t=' + new Date().getTime();\n\n    $.ajax({\n      method: 'GET'\n      , url: src\n      , headers: client.headers()\n    }).done(function success (results) {\n      if (results.message) {\n        var m = results.message;\n        client.notifies.notifies = m.notifies;\n        client.notifies.notifyCount = m.notifyCount;\n        if (m.notifyCount > 0) {\n          notifies.button.show();\n        }\n      }\n      window.setTimeout(notifies.updateAdminNotifies, 1000*60);\n    }).fail(function fail () {\n      console.error('Failed to load notifies');\n      window.setTimeout(notifies.updateAdminNotifies, 1000*60);\n    });\n  }\n\n  notifies.updateAdminNotifies();\n\n  function wrapmessage(title, message, count, ago, persistent) {\n    let html = '<hr><p><b>' + title + '</b></p><p class=\"adminNotifyMessage\">' + message + '</p>';\n\n    let additional = '';\n\n    if (count > 1) additional += client.translate('Event repeated %1 times.', count) + ' ';\n    let units = client.translate('minutes');\n    if (ago > 60) {\n      ago = ago / 60;\n      ago = Math.round((ago + Number.EPSILON) * 10) / 10;\n      units = client.translate('hours');\n    }\n    if (ago == 0) { ago = client.translate('less than 1'); }\n    if (!persistent && ago) additional += client.translate('Last recorded %1 %2 ago.', ago, units);\n\n    if (additional) html += '<p class=\"adminNotifyMessageAdditionalInfo\">' + additional + '</p>'\n    return html;\n  }\n\n  notifies.prepare = function prepare() {\n\n    var translate = client.translate;\n\n    var html = '<div id=\"adminNotifyContent\">';\n    var messages = client.notifies.notifies;\n    var messageCount = client.notifies.notifyCount;\n\n    if (messages && messages.length > 0) {\n      html += '<p><b>' + translate('You have administration messages') + '</b></p>';\n      for(var i = 0 ; i < messages.length; i++) {\n        /* eslint-disable-next-line security/detect-object-injection */ // verified false positive\n        var m = messages[i];\n        const ago = Math.round((Date.now() - m.lastRecorded) / 60000);\n        html += wrapmessage(translate(m.title), translate(m.message), m.count, ago, m.persistent);\n      }\n    } else {\n      if (messageCount > 0) {\n        html = wrapmessage(translate('Admin messages in queue'), translate('Please sign in using the API_SECRET to see your administration messages'));\n      } else {\n        html = wrapmessage(translate('Queue empty'), translate('There are no admin messages in queue'));\n      }\n    }\n    html += '<hr></div>';\n    notifies.drawer.html(html);\n  }\n\n  function maybePrevent (event) {\n    if (event) {\n      event.preventDefault();\n    }\n  }\n\n  notifies.toggleDrawer = function toggleDrawer (event) {\n    client.browserUtils.toggleDrawer('#adminNotifiesDrawer', notifies.prepare);\n    maybePrevent(event);\n  };\n\n  notifies.button.click(notifies.toggleDrawer);\n  notifies.button.css('color','red');\n\n  return notifies;\n\n}\n\nmodule.exports = init;\n", "'use strict';\n\nconst _ = require('lodash');\nconst UPDATE_THROTTLE = 5000;\n\nfunction boot (env, language) {\n\n  function startBoot(ctx, next) {\n\n    console.log('Executing startBoot');\n\n    ctx.runtimeState = 'booting';\n    ctx.settings = env.settings;\n    ctx.bus = require('../bus')(env.settings, ctx);\n    ctx.adminnotifies = require('../adminnotifies')(ctx);\n    if (env.notifies) {\n      for (var i = 0; i < env.notifies.length; i++) {\n        ctx.adminnotifies.addNotify(env.notifies[i]);\n      }\n    }\n    next();\n  }\n\n  //////////////////////////////////////////////////\n  // Check Node version.\n  // Latest Node 10 to 14 LTS are recommended and supported.\n  // Older Node versions or Node versions with known security issues will not work.\n  ///////////////////////////////////////////////////\n  function checkNodeVersion (ctx, next) {\n\n    console.log('Executing checkNodeVersion');\n\n    var semver = require('semver');\n    var nodeVersion = process.version;\n\n    const isLTS = process.release.lts ? true : false;\n  \n    if (isLTS && (semver.satisfies(nodeVersion, '^14.0.0') || semver.satisfies(nodeVersion, '^12.0.0') || semver.satisfies(nodeVersion, '^10.0.0'))) {\n      //Latest Node 10 LTS and Node 12 LTS are recommended and supported.\n      //Require at least Node 8 LTS and Node 10 LTS without known security issues\n      console.debug('Node LTS version ' + nodeVersion + ' is supported');\n      next();\n      return;\n    }\n\n    console.log( 'ERROR: Node version ' + nodeVersion + ' is not supported. Please use a secure LTS version or upgrade your Node');\n    process.exit(1);\n\n  }\n\n  function checkEnv (ctx, next) {\n\n    console.log('Executing checkEnv');\n\n    ctx.language = language;\n    if (env.err.length > 0) {\n      ctx.bootErrors = ctx.bootErrors || [ ];\n      ctx.bootErrors.push({'desc': 'ENV Error', err: env.err});\n    }\n    next();\n  }\n\n  function hasBootErrors(ctx) {\n    return ctx.bootErrors && ctx.bootErrors.length > 0;\n  }\n\n  function augmentSettings (ctx, next) {\n\n    console.log('Executing augmentSettings');\n\n    var configURL = env.IMPORT_CONFIG || null;\n    var url = require('url');\n    var href = null;\n    try {\n      href = url.parse(configURL).href;\n    } catch (e) {\n      console.error('Parsing config URL from IMPORT_CONFIG failed');\n    }\n    if(configURL && href) {\n      var request = require('request');\n      console.log('Getting settings from', href);\n      request.get({url: href, json: true}, function (err, resp, body) {\n        if (err) {\n          console.log('Attempt to fetch config', href, 'failed.');\n          console.error(err);\n          throw err;\n        } else {\n          var settings = body.settings || body;\n          console.log('extending settings with', settings);\n          _.merge(env.settings, settings);\n          if (body.extendedSettings) {\n            console.log('extending extendedSettings with', body.extendedSettings);\n            _.merge(env.extendedSettings, body.extendedSettings);\n          }\n        }\n        next( );\n      });\n    } else {\n      next( );\n    }\n  }\n\n  function checkSettings (ctx, next) {\n\n    console.log('Executing checkSettings');\n\n    ctx.bootErrors = ctx.bootErrors || [];\n\n    console.log('Checking settings');\n\n    if (!env.storageURI) {\n      ctx.bootErrors.push({'desc': 'Mandatory setting missing',\n      err: 'MONGODB_URI setting is missing, cannot connect to database'});\n    }\n\n    if (!env.enclave.isApiKeySet()) {\n      ctx.bootErrors.push({'desc': 'Mandatory setting missing',\n      err: 'API_SECRET setting is missing, cannot enable REST API'});\n    }\n\n    if (env.settings.authDefaultRoles == 'readable') {\n      const message = {\n        title: \"Nightscout readable by world\"\n        ,message: \"Your Nightscout installation is readable by anyone who knows the web page URL. Please consider closing access to the site by following the instructions in the <a href=\\\"http://nightscout.github.io/nightscout/security/#how-to-turn-off-unauthorized-access\\\" target=\\\"_new\\\">Nightscout documentation</a>.\"\n        ,persistent: true\n      };\n      ctx.adminnotifies.addNotify(message);\n    }\n\n    next();\n  }\n\n  function setupStorage (ctx, next) {\n\n    console.log('Executing setupStorage');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    try {\n      if (_.startsWith(env.storageURI, 'openaps://')) {\n        require('../storage/openaps-storage')(env, function ready (err, store) {\n          if (err) {\n            throw err;\n          }\n          ctx.store = store;\n          console.log('OpenAPS Storage system ready');\n          next();\n        });\n      } else {\n        //TODO assume mongo for now, when there are more storage options add a lookup\n        require('../storage/mongo-storage')(env, function ready(err, store) {\n          // FIXME, error is always null, if there is an error, the index.js will throw an exception\n          if (err) {\n            console.info('ERROR CONNECTING TO MONGO', err);\n            ctx.bootErrors = ctx.bootErrors || [ ];\n            ctx.bootErrors.push({'desc': 'Unable to connect to Mongo', err: err.message});\n          }\n          console.log('Mongo Storage system ready');\n          ctx.store = store;\n          next();\n        });\n      }\n    } catch (err) {\n      console.info('ERROR CONNECTING TO MONGO', err);\n      ctx.bootErrors = ctx.bootErrors || [ ];\n      ctx.bootErrors.push({'desc': 'Unable to connect to Mongo', err: err.message});\n      next();\n    }\n  }\n\n  function setupAuthorization (ctx, next) {\n\n    console.log('Executing setupAuthorization');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.authorization = require('../authorization')(env, ctx);\n    ctx.authorization.storage.reload(function loaded (err) {\n      if (err) {\n        ctx.bootErrors = ctx.bootErrors || [ ];\n        ctx.bootErrors.push({'desc': 'Unable to setup authorization', err: err});\n      }\n      next();\n    });\n  }\n\n  function setupInternals (ctx, next) {\n\n    console.log('Executing setupInternals');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.levels = require('../levels');\n    ctx.levels.translate = ctx.language.translate;\n\n    ///////////////////////////////////////////////////\n    // api and json object variables\n    ///////////////////////////////////////////////////\n    ctx.plugins = require('../plugins')({\n      settings: env.settings\n      , language: ctx.language\n      , levels: ctx.levels\n    }).registerServerDefaults();\n\n    ctx.pushover = require('../plugins/pushover')(env, ctx);\n    ctx.maker = require('../plugins/maker')(env);\n    ctx.pushnotify = require('./pushnotify')(env, ctx);\n    ctx.loop = require('./loop')(env, ctx);\n\n    ctx.activity = require('./activity')(env, ctx);\n    ctx.entries = require('./entries')(env, ctx);\n    ctx.treatments = require('./treatments')(env, ctx);\n    ctx.devicestatus = require('./devicestatus')(env.devicestatus_collection, ctx);\n    ctx.profile = require('./profile')(env.profile_collection, ctx);\n    ctx.food = require('./food')(env, ctx);\n    ctx.pebble = require('./pebble')(env, ctx);\n    ctx.properties = require('../api/properties')(env, ctx);\n    ctx.ddata = require('../data/ddata')();\n    ctx.cache = require('./cache')(env,ctx);\n    ctx.dataloader = require('../data/dataloader')(env, ctx);\n    ctx.notifications = require('../notifications')(env, ctx);\n    ctx.purifier = require('./purifier')(env,ctx);\n\n    if (env.settings.isEnabled('alexa') || env.settings.isEnabled('googlehome')) {\n      ctx.virtAsstBase = require('../plugins/virtAsstBase')(env, ctx);\n    }\n\n    if (env.settings.isEnabled('alexa')) {\n      ctx.alexa = require('../plugins/alexa')(env, ctx);\n    }\n\n    if (env.settings.isEnabled('googlehome')) {\n      ctx.googleHome = require('../plugins/googlehome')(env, ctx);\n    }\n\n    next( );\n  }\n\n  function ensureIndexes (ctx, next) {\n\n    console.log('Executing ensureIndexes');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    console.info('Ensuring indexes');\n    ctx.store.ensureIndexes(ctx.entries( ), ctx.entries.indexedFields);\n    ctx.store.ensureIndexes(ctx.treatments( ), ctx.treatments.indexedFields);\n    ctx.store.ensureIndexes(ctx.devicestatus( ), ctx.devicestatus.indexedFields);\n    ctx.store.ensureIndexes(ctx.profile( ), ctx.profile.indexedFields);\n    ctx.store.ensureIndexes(ctx.food( ), ctx.food.indexedFields);\n    ctx.store.ensureIndexes(ctx.activity( ), ctx.activity.indexedFields);\n\n    next( );\n  }\n\n  function setupListeners (ctx, next) {\n\n    console.log('Executing setupListeners');\n    \n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    var updateData = _.debounce(function debouncedUpdateData ( ) {\n      ctx.dataloader.update(ctx.ddata, function dataUpdated () {\n        ctx.bus.emit('data-loaded');\n      });\n    }, UPDATE_THROTTLE);\n\n    ctx.bus.on('tick', function timedReloadData (tick) {\n      console.info('tick', tick.now);\n      updateData();\n    });\n\n    ctx.bus.on('data-received', function forceReloadData ( ) {\n      console.info('got data-received event, requesting reload');\n      updateData();\n    });\n\n    ctx.bus.on('data-loaded', function updatePlugins ( ) {\n      console.info('data loaded: reloading sandbox data and updating plugins');\n      var sbx = require('../sandbox')().serverInit(env, ctx);\n      ctx.plugins.setProperties(sbx);\n      ctx.notifications.initRequests();\n      ctx.plugins.checkNotifications(sbx);\n      ctx.notifications.process(sbx);\n      ctx.bus.emit('data-processed');\n    });\n\n    ctx.bus.on('data-processed', function processed ( ) {\n      ctx.runtimeState = 'loaded';\n    });\n\n    ctx.bus.on('notification', ctx.pushnotify.emitNotification);\n\n    next( );\n  }\n\n  function setupBridge (ctx, next) {\n\n    console.log('Executing setupBridge');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.bridge = require('../plugins/bridge')(env, ctx.bus);\n    if (ctx.bridge) {\n      ctx.bridge.startEngine(ctx.entries);\n    }\n    next( );\n  }\n\n  function setupMMConnect (ctx, next) {\n\n    console.log('Executing setupMMConnect');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.mmconnect = require('../plugins/mmconnect').init(env, ctx.entries, ctx.devicestatus, ctx.bus);\n    if (ctx.mmconnect) {\n      ctx.mmconnect.run();\n    }\n    next( );\n  }\n\n  function finishBoot (ctx, next) {\n\n    console.log('Executing finishBoot');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.runtimeState = 'booted';\n    ctx.bus.uptime( );\n\n    next( );\n  }\n\n  return require('bootevent')( )\n    .acquire(startBoot)\n    .acquire(checkNodeVersion)\n    .acquire(checkEnv)\n    .acquire(augmentSettings)\n    .acquire(checkSettings)\n    .acquire(setupStorage)\n    .acquire(setupAuthorization)\n    .acquire(setupInternals)\n    .acquire(ensureIndexes)\n    .acquire(setupListeners)\n    .acquire(setupBridge)\n    .acquire(setupMMConnect)\n    .acquire(finishBoot);\n}\n\nmodule.exports = boot;\n"], "fixing_code": ["'use strict';\n\nfunction init (client, $) {\n\n  var notifies = {};\n\n  client.notifies = notifies;\n\n  notifies.notifies = [];\n  notifies.drawer = $('#adminNotifiesDrawer');\n  notifies.button = $('#adminnotifies');\n\n  notifies.updateAdminNotifies = function updateAdminNotifies() {\n\n    var src = '/api/v1/adminnotifies?t=' + new Date().getTime();\n\n    $.ajax({\n      method: 'GET'\n      , url: src\n      , headers: client.headers()\n    }).done(function success (results) {\n      if (results.message) {\n        var m = results.message;\n        client.notifies.notifies = m.notifies;\n        client.notifies.notifyCount = m.notifyCount;\n        if (m.notifyCount > 0) {\n          notifies.button.show();\n        }\n      }\n      window.setTimeout(notifies.updateAdminNotifies, 1000*60);\n    }).fail(function fail () {\n      console.error('Failed to load notifies');\n      window.setTimeout(notifies.updateAdminNotifies, 1000*60);\n    });\n  }\n\n  notifies.updateAdminNotifies();\n\n  function wrapmessage(title, message, count, ago, persistent, seeAlso) {\n    let html = $('<div><div><hr><p><b class=\"adminNotifyTitle\"></b></p><p class=\"adminNotifyMessage\"></p></div><p class=\"adminNotifyMessageAdditionalInfo\"></p></div>');\n    html.find('.adminNotifyTitle').text(title);\n    html.find('.adminNotifyMessage').text(message);\n\n    let additional = '';\n\n    if (count > 1) additional += client.translate('Event repeated %1 times.', count) + ' ';\n    let units = client.translate('minutes');\n    if (ago > 60) {\n      ago = ago / 60;\n      ago = Math.round((ago + Number.EPSILON) * 10) / 10;\n      units = client.translate('hours');\n    }\n    if (ago == 0) { ago = client.translate('less than 1'); }\n    if (!persistent && ago) additional += client.translate('Last recorded %1 %2 ago.', ago, units);\n\n    html.find('.adminNotifyMessageAdditionalInfo').text(additional);\n    if (seeAlso && init.addendums[seeAlso]) {\n      html.append($(init.addendums[seeAlso]));\n    }\n    return html.html( );\n  }\n\n  notifies.prepare = function prepare() {\n\n    var translate = client.translate;\n\n    var html = '<div id=\"adminNotifyContent\">';\n    var messages = client.notifies.notifies;\n    var messageCount = client.notifies.notifyCount;\n\n    if (messages && messages.length > 0) {\n      html += '<p><b>' + translate('You have administration messages') + '</b></p>';\n      for(var i = 0 ; i < messages.length; i++) {\n        /* eslint-disable-next-line security/detect-object-injection */ // verified false positive\n        var m = messages[i];\n        const ago = Math.round((Date.now() - m.lastRecorded) / 60000);\n        html += wrapmessage(translate(m.title), translate(m.message), m.count, ago, m.persistent, m.seeAlso);\n      }\n    } else {\n      if (messageCount > 0) {\n        html = wrapmessage(translate('Admin messages in queue'), translate('Please sign in using the API_SECRET to see your administration messages'));\n      } else {\n        html = wrapmessage(translate('Queue empty'), translate('There are no admin messages in queue'));\n      }\n    }\n    html += '<hr></div>';\n    notifies.drawer.html(html);\n  }\n\n  function maybePrevent (event) {\n    if (event) {\n      event.preventDefault();\n    }\n  }\n\n  notifies.toggleDrawer = function toggleDrawer (event) {\n    client.browserUtils.toggleDrawer('#adminNotifiesDrawer', notifies.prepare);\n    maybePrevent(event);\n  };\n\n  notifies.button.click(notifies.toggleDrawer);\n  notifies.button.css('color','red');\n\n  return notifies;\n\n}\ninit.addendums = {\n  disableWorldReadable: '<p>Please consider closing access to the site by following the instructions in the <a href=\"http://nightscout.github.io/nightscout/security/#how-to-turn-off-unauthorized-access\" target=\"_new\">Nightscout documentation</a>.</p>'\n\n};\n\nmodule.exports = init;\n", "'use strict';\n\nconst _ = require('lodash');\nconst UPDATE_THROTTLE = 5000;\n\nfunction boot (env, language) {\n\n  function startBoot(ctx, next) {\n\n    console.log('Executing startBoot');\n\n    ctx.runtimeState = 'booting';\n    ctx.settings = env.settings;\n    ctx.bus = require('../bus')(env.settings, ctx);\n    ctx.adminnotifies = require('../adminnotifies')(ctx);\n    if (env.notifies) {\n      for (var i = 0; i < env.notifies.length; i++) {\n        ctx.adminnotifies.addNotify(env.notifies[i]);\n      }\n    }\n    next();\n  }\n\n  //////////////////////////////////////////////////\n  // Check Node version.\n  // Latest Node 10 to 14 LTS are recommended and supported.\n  // Older Node versions or Node versions with known security issues will not work.\n  ///////////////////////////////////////////////////\n  function checkNodeVersion (ctx, next) {\n\n    console.log('Executing checkNodeVersion');\n\n    var semver = require('semver');\n    var nodeVersion = process.version;\n\n    const isLTS = process.release.lts ? true : false;\n  \n    if (isLTS && (semver.satisfies(nodeVersion, '^14.0.0') || semver.satisfies(nodeVersion, '^12.0.0') || semver.satisfies(nodeVersion, '^10.0.0'))) {\n      //Latest Node 10 LTS and Node 12 LTS are recommended and supported.\n      //Require at least Node 8 LTS and Node 10 LTS without known security issues\n      console.debug('Node LTS version ' + nodeVersion + ' is supported');\n      next();\n      return;\n    }\n\n    console.log( 'ERROR: Node version ' + nodeVersion + ' is not supported. Please use a secure LTS version or upgrade your Node');\n    process.exit(1);\n\n  }\n\n  function checkEnv (ctx, next) {\n\n    console.log('Executing checkEnv');\n\n    ctx.language = language;\n    if (env.err.length > 0) {\n      ctx.bootErrors = ctx.bootErrors || [ ];\n      ctx.bootErrors.push({'desc': 'ENV Error', err: env.err});\n    }\n    next();\n  }\n\n  function hasBootErrors(ctx) {\n    return ctx.bootErrors && ctx.bootErrors.length > 0;\n  }\n\n  function augmentSettings (ctx, next) {\n\n    console.log('Executing augmentSettings');\n\n    var configURL = env.IMPORT_CONFIG || null;\n    var url = require('url');\n    var href = null;\n    try {\n      href = url.parse(configURL).href;\n    } catch (e) {\n      console.error('Parsing config URL from IMPORT_CONFIG failed');\n    }\n    if(configURL && href) {\n      var request = require('request');\n      console.log('Getting settings from', href);\n      request.get({url: href, json: true}, function (err, resp, body) {\n        if (err) {\n          console.log('Attempt to fetch config', href, 'failed.');\n          console.error(err);\n          throw err;\n        } else {\n          var settings = body.settings || body;\n          console.log('extending settings with', settings);\n          _.merge(env.settings, settings);\n          if (body.extendedSettings) {\n            console.log('extending extendedSettings with', body.extendedSettings);\n            _.merge(env.extendedSettings, body.extendedSettings);\n          }\n        }\n        next( );\n      });\n    } else {\n      next( );\n    }\n  }\n\n  function checkSettings (ctx, next) {\n\n    console.log('Executing checkSettings');\n\n    ctx.bootErrors = ctx.bootErrors || [];\n\n    console.log('Checking settings');\n\n    if (!env.storageURI) {\n      ctx.bootErrors.push({'desc': 'Mandatory setting missing',\n      err: 'MONGODB_URI setting is missing, cannot connect to database'});\n    }\n\n    if (!env.enclave.isApiKeySet()) {\n      ctx.bootErrors.push({'desc': 'Mandatory setting missing',\n      err: 'API_SECRET setting is missing, cannot enable REST API'});\n    }\n\n    if (env.settings.authDefaultRoles == 'readable') {\n      const message = {\n        title: \"Nightscout readable by world\"\n        ,message: \"Your Nightscout installation is readable by anyone who knows the web page URL.\"\n        ,persistent: true\n        ,seeAlso: 'disableWorldReadable'\n      };\n      ctx.adminnotifies.addNotify(message);\n    }\n\n    next();\n  }\n\n  function setupStorage (ctx, next) {\n\n    console.log('Executing setupStorage');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    try {\n      if (_.startsWith(env.storageURI, 'openaps://')) {\n        require('../storage/openaps-storage')(env, function ready (err, store) {\n          if (err) {\n            throw err;\n          }\n          ctx.store = store;\n          console.log('OpenAPS Storage system ready');\n          next();\n        });\n      } else {\n        //TODO assume mongo for now, when there are more storage options add a lookup\n        require('../storage/mongo-storage')(env, function ready(err, store) {\n          // FIXME, error is always null, if there is an error, the index.js will throw an exception\n          if (err) {\n            console.info('ERROR CONNECTING TO MONGO', err);\n            ctx.bootErrors = ctx.bootErrors || [ ];\n            ctx.bootErrors.push({'desc': 'Unable to connect to Mongo', err: err.message});\n          }\n          console.log('Mongo Storage system ready');\n          ctx.store = store;\n          next();\n        });\n      }\n    } catch (err) {\n      console.info('ERROR CONNECTING TO MONGO', err);\n      ctx.bootErrors = ctx.bootErrors || [ ];\n      ctx.bootErrors.push({'desc': 'Unable to connect to Mongo', err: err.message});\n      next();\n    }\n  }\n\n  function setupAuthorization (ctx, next) {\n\n    console.log('Executing setupAuthorization');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.authorization = require('../authorization')(env, ctx);\n    ctx.authorization.storage.reload(function loaded (err) {\n      if (err) {\n        ctx.bootErrors = ctx.bootErrors || [ ];\n        ctx.bootErrors.push({'desc': 'Unable to setup authorization', err: err});\n      }\n      next();\n    });\n  }\n\n  function setupInternals (ctx, next) {\n\n    console.log('Executing setupInternals');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.levels = require('../levels');\n    ctx.levels.translate = ctx.language.translate;\n\n    ///////////////////////////////////////////////////\n    // api and json object variables\n    ///////////////////////////////////////////////////\n    ctx.plugins = require('../plugins')({\n      settings: env.settings\n      , language: ctx.language\n      , levels: ctx.levels\n    }).registerServerDefaults();\n\n    ctx.pushover = require('../plugins/pushover')(env, ctx);\n    ctx.maker = require('../plugins/maker')(env);\n    ctx.pushnotify = require('./pushnotify')(env, ctx);\n    ctx.loop = require('./loop')(env, ctx);\n\n    ctx.activity = require('./activity')(env, ctx);\n    ctx.entries = require('./entries')(env, ctx);\n    ctx.treatments = require('./treatments')(env, ctx);\n    ctx.devicestatus = require('./devicestatus')(env.devicestatus_collection, ctx);\n    ctx.profile = require('./profile')(env.profile_collection, ctx);\n    ctx.food = require('./food')(env, ctx);\n    ctx.pebble = require('./pebble')(env, ctx);\n    ctx.properties = require('../api/properties')(env, ctx);\n    ctx.ddata = require('../data/ddata')();\n    ctx.cache = require('./cache')(env,ctx);\n    ctx.dataloader = require('../data/dataloader')(env, ctx);\n    ctx.notifications = require('../notifications')(env, ctx);\n    ctx.purifier = require('./purifier')(env,ctx);\n\n    if (env.settings.isEnabled('alexa') || env.settings.isEnabled('googlehome')) {\n      ctx.virtAsstBase = require('../plugins/virtAsstBase')(env, ctx);\n    }\n\n    if (env.settings.isEnabled('alexa')) {\n      ctx.alexa = require('../plugins/alexa')(env, ctx);\n    }\n\n    if (env.settings.isEnabled('googlehome')) {\n      ctx.googleHome = require('../plugins/googlehome')(env, ctx);\n    }\n\n    next( );\n  }\n\n  function ensureIndexes (ctx, next) {\n\n    console.log('Executing ensureIndexes');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    console.info('Ensuring indexes');\n    ctx.store.ensureIndexes(ctx.entries( ), ctx.entries.indexedFields);\n    ctx.store.ensureIndexes(ctx.treatments( ), ctx.treatments.indexedFields);\n    ctx.store.ensureIndexes(ctx.devicestatus( ), ctx.devicestatus.indexedFields);\n    ctx.store.ensureIndexes(ctx.profile( ), ctx.profile.indexedFields);\n    ctx.store.ensureIndexes(ctx.food( ), ctx.food.indexedFields);\n    ctx.store.ensureIndexes(ctx.activity( ), ctx.activity.indexedFields);\n\n    next( );\n  }\n\n  function setupListeners (ctx, next) {\n\n    console.log('Executing setupListeners');\n    \n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    var updateData = _.debounce(function debouncedUpdateData ( ) {\n      ctx.dataloader.update(ctx.ddata, function dataUpdated () {\n        ctx.bus.emit('data-loaded');\n      });\n    }, UPDATE_THROTTLE);\n\n    ctx.bus.on('tick', function timedReloadData (tick) {\n      console.info('tick', tick.now);\n      updateData();\n    });\n\n    ctx.bus.on('data-received', function forceReloadData ( ) {\n      console.info('got data-received event, requesting reload');\n      updateData();\n    });\n\n    ctx.bus.on('data-loaded', function updatePlugins ( ) {\n      console.info('data loaded: reloading sandbox data and updating plugins');\n      var sbx = require('../sandbox')().serverInit(env, ctx);\n      ctx.plugins.setProperties(sbx);\n      ctx.notifications.initRequests();\n      ctx.plugins.checkNotifications(sbx);\n      ctx.notifications.process(sbx);\n      ctx.bus.emit('data-processed');\n    });\n\n    ctx.bus.on('data-processed', function processed ( ) {\n      ctx.runtimeState = 'loaded';\n    });\n\n    ctx.bus.on('notification', ctx.pushnotify.emitNotification);\n\n    next( );\n  }\n\n  function setupBridge (ctx, next) {\n\n    console.log('Executing setupBridge');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.bridge = require('../plugins/bridge')(env, ctx.bus);\n    if (ctx.bridge) {\n      ctx.bridge.startEngine(ctx.entries);\n    }\n    next( );\n  }\n\n  function setupMMConnect (ctx, next) {\n\n    console.log('Executing setupMMConnect');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.mmconnect = require('../plugins/mmconnect').init(env, ctx.entries, ctx.devicestatus, ctx.bus);\n    if (ctx.mmconnect) {\n      ctx.mmconnect.run();\n    }\n    next( );\n  }\n\n  function finishBoot (ctx, next) {\n\n    console.log('Executing finishBoot');\n\n    if (hasBootErrors(ctx)) {\n      return next();\n    }\n\n    ctx.runtimeState = 'booted';\n    ctx.bus.uptime( );\n\n    next( );\n  }\n\n  return require('bootevent')( )\n    .acquire(startBoot)\n    .acquire(checkNodeVersion)\n    .acquire(checkEnv)\n    .acquire(augmentSettings)\n    .acquire(checkSettings)\n    .acquire(setupStorage)\n    .acquire(setupAuthorization)\n    .acquire(setupInternals)\n    .acquire(ensureIndexes)\n    .acquire(setupListeners)\n    .acquire(setupBridge)\n    .acquire(setupMMConnect)\n    .acquire(finishBoot);\n}\n\nmodule.exports = boot;\n"], "filenames": ["lib/client/adminnotifiesclient.js", "lib/server/bootevent.js"], "buggy_code_start_loc": [39, 124], "buggy_code_end_loc": [101, 125], "fixing_code_start_loc": [39, 124], "fixing_code_end_loc": [111, 127], "type": "CWE-79", "message": "Nightscout Web Monitor (aka cgm-remote-monitor) 14.2.2 allows XSS via a crafted X-Forwarded-For header.", "other": {"cve": {"id": "CVE-2021-36755", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-16T00:15:07.730", "lastModified": "2021-07-27T16:00:35.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nightscout Web Monitor (aka cgm-remote-monitor) 14.2.2 allows XSS via a crafted X-Forwarded-For header."}, {"lang": "es", "value": "Nightscout Web Monitor (tambi\u00e9n conocido como cgm-remote-monitor) versi\u00f3n 14.2.2 permite el uso de XSS a trav\u00e9s de una cabecera X-Forwarded-For manipulada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cgm-remote-monitor_project:cgm-remote-monitor:14.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "50E9233F-75C4-46BF-AD50-BBF94A87E9BA"}]}]}], "references": [{"url": "https://github.com/nightscout/cgm-remote-monitor/commit/68f3f90e30cc1da57f7e5069f9c4e1467973521f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nightscout/cgm-remote-monitor/commit/68f3f90e30cc1da57f7e5069f9c4e1467973521f"}}