{"buggy_code": ["/**\n * Simple engine for creating PDF files.\n * It supports text, shapes, images etc...\n * Capable of handling millions of objects without too much performance\n * penalty.\n * Public domain license - no warrenty implied; use at your own risk.\n */\n\n/**\n * PDF HINTS & TIPS\n * The following sites have various bits & pieces about PDF document\n * generation\n * http://www.mactech.com/articles/mactech/Vol.15/15.09/PDFIntro/index.html\n * http://gnupdf.org/Introduction_to_PDF\n * http://www.planetpdf.com/mainpage.asp?WebPageID=63\n * http://archive.vector.org.uk/art10008970\n * http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf\n * https://blog.idrsolutions.com/2013/01/understanding-the-pdf-file-format-overview/\n *\n * To validate the PDF output, there are several online validators:\n * http://www.validatepdfa.com/online.htm\n * http://www.datalogics.com/products/callas/callaspdfA-onlinedemo.asp\n * http://www.pdf-tools.com/pdf/validate-pdfa-online.aspx\n *\n * In addition the 'pdftk' server can be used to analyse the output:\n * https://www.pdflabs.com/docs/pdftk-cli-examples/\n *\n * PDF page markup operators:\n * b    closepath, fill,and stroke path.\n * B    fill and stroke path.\n * b*   closepath, eofill,and stroke path.\n * B*   eofill and stroke path.\n * BI   begin image.\n * BMC  begin marked content.\n * BT   begin text object.\n * BX   begin section allowing undefined operators.\n * c    curveto.\n * cm   concat. Concatenates the matrix to the current transform.\n * cs   setcolorspace for fill.\n * CS   setcolorspace for stroke.\n * d    setdash.\n * Do   execute the named XObject.\n * DP   mark a place in the content stream, with a dictionary.\n * EI   end image.\n * EMC  end marked content.\n * ET   end text object.\n * EX   end section that allows undefined operators.\n * f    fill path.\n * f*   eofill Even/odd fill path.\n * g    setgray (fill).\n * G    setgray (stroke).\n * gs   set parameters in the extended graphics state.\n * h    closepath.\n * i    setflat.\n * ID   begin image data.\n * j    setlinejoin.\n * J    setlinecap.\n * k    setcmykcolor (fill).\n * K    setcmykcolor (stroke).\n * l    lineto.\n * m    moveto.\n * M    setmiterlimit.\n * n    end path without fill or stroke.\n * q    save graphics state.\n * Q    restore graphics state.\n * re   rectangle.\n * rg   setrgbcolor (fill).\n * RG   setrgbcolor (stroke).\n * s    closepath and stroke path.\n * S    stroke path.\n * sc   setcolor (fill).\n * SC   setcolor (stroke).\n * sh   shfill (shaded fill).\n * Tc   set character spacing.\n * Td   move text current point.\n * TD   move text current point and set leading.\n * Tf   set font name and size.\n * Tj   show text.\n * TJ   show text, allowing individual character positioning.\n * TL   set leading.\n * Tm   set text matrix.\n * Tr   set text rendering mode.\n * Ts   set super/subscripting text rise.\n * Tw   set word spacing.\n * Tz   set horizontal scaling.\n * T*   move to start of next line.\n * v    curveto.\n * w    setlinewidth.\n * W    clip.\n * y    curveto.\n */\n\n#define _POSIX_SOURCE /* For localtime_r */\n#include <sys/types.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"pdfgen.h\"\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\n#define PDF_RGB_R(c) ((((c) >> 16) & 0xff) / 255.0)\n#define PDF_RGB_G(c) ((((c) >>  8) & 0xff) / 255.0)\n#define PDF_RGB_B(c) ((((c) >>  0) & 0xff) / 255.0)\n\n#if defined(_MSC_VER)\n/*\n * As stated here: http://stackoverflow.com/questions/70013/how-to-detect-if-im-compiling-code-with-visual-studio-2008\n * Visual Studio 2015 has better support for C99\n * We need to use __inline for older version.\n */\n#if _MSC_VER < 1900\n#define inline __inline\n#endif\n#endif // _MSC_VER\n\ntypedef struct pdf_object pdf_object;\n\nenum {\n    OBJ_none, /* skipped */\n    OBJ_info,\n    OBJ_stream,\n    OBJ_font,\n    OBJ_page,\n    OBJ_bookmark,\n    OBJ_outline,\n    OBJ_catalog,\n    OBJ_pages,\n    OBJ_image,\n\n    OBJ_count,\n};\n\nstruct flexarray {\n    void ***bins;\n    int item_count;\n    int bin_count;\n};\n\nstruct pdf_object {\n    int type; /* See OBJ_xxxx */\n    int index; /* PDF output index */\n    int offset; /* Byte position within the output file */\n    struct pdf_object *prev; /* Previous of this type */\n    struct pdf_object *next; /* Next of this type */\n    union {\n        struct {\n            struct pdf_object *page;\n            char name[64];\n            struct pdf_object *parent;\n            struct flexarray children;\n        } bookmark;\n        struct {\n            char *text;\n            int len;\n        } stream;\n        struct {\n            int width;\n            int height;\n            struct flexarray children;\n        } page;\n        struct pdf_info info;\n        struct {\n            char name[64];\n            int index;\n        } font;\n    };\n};\n\nstruct pdf_doc {\n    char errstr[128];\n    int errval;\n    struct flexarray objects;\n\n    int width;\n    int height;\n\n    struct pdf_object *current_font;\n\n    struct pdf_object *last_objects[OBJ_count];\n    struct pdf_object *first_objects[OBJ_count];\n};\n\n/**\n * Simple flexible resizing array implementation\n * The bins get larger in powers of two\n * bin 0 = 1024 items\n *     1 = 2048 items\n *     2 = 4096 items\n *     etc...\n */\n/* What is the first index that will be in the given bin? */\n#define MIN_SHIFT 10\n#define MIN_OFFSET ((1 << MIN_SHIFT) - 1)\nstatic int bin_offset[] = {\n    (1 << (MIN_SHIFT + 0)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 1)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 2)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 3)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 4)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 5)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 6)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 7)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 8)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 9)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 10)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 11)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 12)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 13)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 14)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 15)) - 1 - MIN_OFFSET,\n};\n\nstatic inline int flexarray_get_bin(struct flexarray *flex, int index)\n{\n    int i;\n    (void)flex;\n    for (i = 0; i < ARRAY_SIZE(bin_offset); i++)\n        if (index < bin_offset[i])\n            return i - 1;\n    return -1;\n}\n\nstatic inline int flexarray_get_bin_size(struct flexarray *flex, int bin)\n{\n    (void)flex;\n    if (bin >= ARRAY_SIZE(bin_offset))\n        return -1;\n    int next = bin_offset[bin + 1];\n    return next - bin_offset[bin];\n}\n\nstatic inline int flexarray_get_bin_offset(struct flexarray *flex, int bin, int index)\n{\n    (void)flex;\n    return index - bin_offset[bin];\n}\n\nstatic void flexarray_clear(struct flexarray *flex)\n{\n    int i;\n    for (i = 0; i < flex->bin_count; i++)\n        free(flex->bins[i]);\n    free(flex->bins);\n    flex->bin_count = 0;\n    flex->item_count = 0;\n}\n\nstatic inline int flexarray_size(struct flexarray *flex)\n{\n    return flex->item_count;\n}\n\nstatic int flexarray_set(struct flexarray *flex, int index, void *data)\n{\n    int bin = flexarray_get_bin(flex, index);\n    if (bin < 0)\n        return -EINVAL;\n    if (bin >= flex->bin_count) {\n        void *bins = realloc(flex->bins, (flex->bin_count + 1) *\n                             sizeof(flex->bins));\n        if (!bins)\n            return -ENOMEM;\n        flex->bin_count++;\n        flex->bins = bins;\n        flex->bins[flex->bin_count - 1] =\n            calloc(flexarray_get_bin_size(flex, flex->bin_count - 1),\n                   sizeof(void *));\n        if (!flex->bins[flex->bin_count - 1]) {\n            flex->bin_count--;\n            return -ENOMEM;\n        }\n    }\n    flex->item_count++;\n    flex->bins[bin][flexarray_get_bin_offset(flex, bin, index)] = data;\n    return flex->item_count - 1;\n}\n\nstatic inline int flexarray_append(struct flexarray *flex, void *data)\n{\n    return flexarray_set(flex, flexarray_size(flex), data);\n}\n\nstatic inline void *flexarray_get(struct flexarray *flex, int index)\n{\n    int bin;\n\n    if (index >= flex->item_count)\n        return NULL;\n    bin = flexarray_get_bin(flex, index);\n    if (bin < 0 || bin >= flex->bin_count)\n        return NULL;\n    return flex->bins[bin][flexarray_get_bin_offset(flex, bin, index)];\n}\n\n/**\n * PDF Implementation\n */\n\nstatic int pdf_set_err(struct pdf_doc *doc, int errval,\n                       const char *buffer, ...)\n__attribute__ ((format(printf, 3, 4)));\nstatic int pdf_set_err(struct pdf_doc *doc, int errval,\n                       const char *buffer, ...)\n{\n    va_list ap;\n    int len;\n\n    va_start(ap, buffer);\n    len = vsnprintf(doc->errstr, sizeof(doc->errstr) - 2, buffer, ap);\n    va_end(ap);\n\n    /* Make sure we're properly terminated */\n    if (doc->errstr[len] != '\\n')\n        doc->errstr[len] = '\\n';\n    doc->errstr[len] = '\\0';\n    doc->errval = errval;\n\n    return errval;\n}\n\nconst char *pdf_get_err(struct pdf_doc *pdf, int *errval)\n{\n    if (!pdf)\n        return NULL;\n    if (pdf->errstr[0] == '\\0')\n        return NULL;\n    if (errval) *errval = pdf->errval;\n    return pdf->errstr;\n}\n\nvoid pdf_clear_err(struct pdf_doc *pdf)\n{\n    if (!pdf)\n        return;\n    pdf->errstr[0] = '\\0';\n    pdf->errval = 0;\n}\n\nstatic struct pdf_object *pdf_get_object(struct pdf_doc *pdf, int index)\n{\n    return flexarray_get(&pdf->objects, index);\n}\n\nstatic int pdf_append_object(struct pdf_doc *pdf, struct pdf_object *obj)\n{\n    int index = flexarray_append(&pdf->objects, obj);\n\n    if (index < 0)\n        return index;\n    obj->index = index;\n\n    if (pdf->last_objects[obj->type]) {\n        obj->prev = pdf->last_objects[obj->type];\n        pdf->last_objects[obj->type]->next = obj;\n    }\n    pdf->last_objects[obj->type] = obj;\n\n    if (!pdf->first_objects[obj->type])\n        pdf->first_objects[obj->type] = obj;\n\n    return 0;\n}\n\nstatic struct pdf_object *pdf_add_object(struct pdf_doc *pdf, int type)\n{\n    struct pdf_object *obj;\n\n    obj = calloc(1, sizeof(struct pdf_object));\n    if (!obj) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate object %d: %s\",\n                    flexarray_size(&pdf->objects) + 1, strerror(errno));\n        return NULL;\n    }\n\n    obj->type = type;\n\n    if (pdf_append_object(pdf, obj) < 0) {\n        free(obj);\n        return NULL;\n    }\n\n    return obj;\n}\n\nstruct pdf_doc *pdf_create(int width, int height, struct pdf_info *info)\n{\n    struct pdf_doc *pdf;\n    struct pdf_object *obj;\n\n    pdf = calloc(1, sizeof(struct pdf_doc));\n    pdf->width = width;\n    pdf->height = height;\n\n    /* We don't want to use ID 0 */\n    pdf_add_object(pdf, OBJ_none);\n\n    /* Create the 'info' object */\n    obj = pdf_add_object(pdf, OBJ_info);\n    if (info)\n        obj->info = *info;\n    /* FIXME: Should be quoting PDF strings? */\n    if (!obj->info.date[0]) {\n        time_t now = time(NULL);\n        struct tm tm;\n#ifdef _WIN32\n        struct tm *tmp;\n        tmp = localtime(&now);\n        tm = *tmp;\n#else\n        localtime_r(&now, &tm);\n#endif\n        strftime(obj->info.date, sizeof(obj->info.date),\n                 \"%Y%m%d%H%M%SZ\", &tm);\n    }\n    if (!obj->info.creator[0])\n        strcpy(obj->info.creator, \"pdfgen\");\n    if (!obj->info.producer[0])\n        strcpy(obj->info.producer, \"pdfgen\");\n    if (!obj->info.title[0])\n        strcpy(obj->info.title, \"pdfgen\");\n    if (!obj->info.author[0])\n        strcpy(obj->info.author, \"pdfgen\");\n    if (!obj->info.subject[0])\n        strcpy(obj->info.subject, \"pdfgen\");\n\n    pdf_add_object(pdf, OBJ_pages);\n    pdf_add_object(pdf, OBJ_catalog);\n\n    pdf_set_font(pdf, \"Times-Roman\");\n\n    return pdf;\n}\n\nint pdf_width(struct pdf_doc *pdf)\n{\n    return pdf->width;\n}\n\nint pdf_height(struct pdf_doc *pdf)\n{\n    return pdf->height;\n}\n\nstatic void pdf_object_destroy(struct pdf_object *object)\n{\n    switch (object->type) {\n    case OBJ_stream:\n    case OBJ_image:\n        free(object->stream.text);\n        break;\n    case OBJ_page:\n        flexarray_clear(&object->page.children);\n        break;\n    case OBJ_bookmark:\n        flexarray_clear(&object->bookmark.children);\n        break;\n    }\n    free(object);\n}\n\nvoid pdf_destroy(struct pdf_doc *pdf)\n{\n    if (pdf) {\n        int i;\n        for (i = 0; i < flexarray_size(&pdf->objects); i++)\n            pdf_object_destroy(pdf_get_object(pdf, i));\n        flexarray_clear(&pdf->objects);\n        free(pdf);\n    }\n}\n\nstatic struct pdf_object *pdf_find_first_object(struct pdf_doc *pdf,\n        int type)\n{\n    return pdf->first_objects[type];\n}\n\nstatic struct pdf_object *pdf_find_last_object(struct pdf_doc *pdf,\n        int type)\n{\n    return pdf->last_objects[type];\n}\n\nint pdf_set_font(struct pdf_doc *pdf, const char *font)\n{\n    struct pdf_object *obj;\n    int last_index = 0;\n\n    /* See if we've used this font before */\n    for (obj = pdf_find_first_object(pdf, OBJ_font); obj; obj = obj->next) {\n        if (strcmp(obj->font.name, font) == 0)\n            break;\n        last_index = obj->font.index;\n    }\n\n    /* Create a new font object if we need it */\n    if (!obj) {\n        obj = pdf_add_object(pdf, OBJ_font);\n        if (!obj)\n            return pdf->errval;\n        strncpy(obj->font.name, font, sizeof(obj->font.name));\n        obj->font.name[sizeof(obj->font.name) - 1] = '\\0';\n        obj->font.index = last_index + 1;\n    }\n\n    pdf->current_font = obj;\n\n    return 0;\n}\n\nstruct pdf_object *pdf_append_page(struct pdf_doc *pdf)\n{\n    struct pdf_object *page;\n\n    page = pdf_add_object(pdf, OBJ_page);\n\n    if (!page)\n        return NULL;\n\n    page->page.width = pdf->width;\n    page->page.height = pdf->height;\n\n    return page;\n}\n\nint pdf_page_set_size(struct pdf_doc *pdf, struct pdf_object *page, int width, int height)\n{\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n\n    if (!page || page->type != OBJ_page)\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PDF page\");\n    page->page.width = width;\n    page->page.height = height;\n    return 0;\n}\n\nstatic int pdf_save_object(struct pdf_doc *pdf, FILE *fp, int index)\n{\n    struct pdf_object *object = pdf_get_object(pdf, index);\n\n    if (object->type == OBJ_none)\n        return -ENOENT;\n\n    object->offset = ftell(fp);\n\n    fprintf(fp, \"%d 0 obj\\r\\n\", index);\n\n    switch (object->type) {\n    case OBJ_stream:\n    case OBJ_image: {\n        int len = object->stream.len ? object->stream.len :\n                  strlen(object->stream.text);\n        fwrite(object->stream.text, len, 1, fp);\n        break;\n    }\n    case OBJ_info: {\n        struct pdf_info *info = &object->info;\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"  /Creator (%s)\\r\\n\"\n                \"  /Producer (%s)\\r\\n\"\n                \"  /Title (%s)\\r\\n\"\n                \"  /Author (%s)\\r\\n\"\n                \"  /Subject (%s)\\r\\n\"\n                \"  /CreationDate (D:%s)\\r\\n\"\n                \">>\\r\\n\",\n                info->creator, info->producer, info->title,\n                info->author, info->subject, info->date);\n        break;\n    }\n\n    case OBJ_page: {\n        int i;\n        struct pdf_object *font;\n        struct pdf_object *pages = pdf_find_first_object(pdf, OBJ_pages);\n        struct pdf_object *image = pdf_find_first_object(pdf, OBJ_image);\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Page\\r\\n\"\n                \"/Parent %d 0 R\\r\\n\", pages->index);\n        fprintf(fp, \"/MediaBox [0 0 %d %d]\\r\\n\",\n                object->page.width, object->page.height);\n        fprintf(fp, \"/Resources <<\\r\\n\");\n        fprintf(fp, \"  /Font <<\\r\\n\");\n        for (font = pdf_find_first_object(pdf, OBJ_font); font; font = font->next)\n            fprintf(fp, \"    /F%d %d 0 R\\r\\n\",\n                    font->font.index, font->index);\n        fprintf(fp, \"  >>\\r\\n\");\n\n        if (image) {\n            fprintf(fp, \"  /XObject <<\");\n            for (; image; image = image->next)\n                fprintf(fp, \"/Image%d %d 0 R \", image->index, image->index);\n            fprintf(fp, \">>\\r\\n\");\n        }\n\n        fprintf(fp, \">>\\r\\n\");\n        fprintf(fp, \"/Contents [\\r\\n\");\n        for (i = 0; i < flexarray_size(&object->page.children); i++) {\n            struct pdf_object *child = flexarray_get(&object->page.children, i);\n            fprintf(fp, \"%d 0 R\\r\\n\", child->index);\n        }\n        fprintf(fp, \"]\\r\\n\");\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n\n    case OBJ_bookmark: {\n        struct pdf_object *parent, *other;\n\n        parent = object->bookmark.parent;\n        if (!parent)\n            parent = pdf_find_first_object(pdf, OBJ_outline);\n        if (!object->bookmark.page)\n            break;\n        fprintf(fp, \"<<\\r\\n\"\n                \"/A << /Type /Action\\r\\n\"\n                \"      /S /GoTo\\r\\n\"\n                \"      /D [%d 0 R /XYZ 0 %d null]\\r\\n\"\n                \"   >>\\r\\n\"\n                \"/Parent %d 0 R\\r\\n\"\n                \"/Title (%s)\\r\\n\",\n                object->bookmark.page->index,\n                pdf->height,\n                parent->index,\n                object->bookmark.name);\n        int nchildren = flexarray_size(&object->bookmark.children);\n        if (nchildren > 0) {\n            struct pdf_object *f, *l;\n            f = flexarray_get(&object->bookmark.children, 0);\n            l = flexarray_get(&object->bookmark.children, nchildren - 1);\n            fprintf(fp, \"/First %d 0 R\\r\\n\", f->index);\n            fprintf(fp, \"/Last %d 0 R\\r\\n\", l->index);\n        }\n        // Find the previous bookmark with the same parent\n        for (other = object->prev;\n                other && other->bookmark.parent != object->bookmark.parent;\n                other = other->prev)\n            ;\n        if (other)\n            fprintf(fp, \"/Prev %d 0 R\\r\\n\", other->index);\n        // Find the next bookmark with the same parent\n        for (other = object->next;\n                other && other->bookmark.parent != object->bookmark.parent;\n                other = other->next)\n            ;\n        if (other)\n            fprintf(fp, \"/Next %d 0 R\\r\\n\", other->index);\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n\n    case OBJ_outline: {\n        struct pdf_object *first, *last, *cur;\n        first = pdf_find_first_object(pdf, OBJ_bookmark);\n        last = pdf_find_last_object(pdf, OBJ_bookmark);\n\n        if (first && last) {\n            int count = 0;\n            cur = first;\n            while (cur) {\n                if (!cur->bookmark.parent)\n                    count++;\n                cur = cur->next;\n            }\n\n            /* Bookmark outline */\n            fprintf(fp, \"<<\\r\\n\"\n                    \"/Count %d\\r\\n\"\n                    \"/Type /Outlines\\r\\n\"\n                    \"/First %d 0 R\\r\\n\"\n                    \"/Last %d 0 R\\r\\n\"\n                    \">>\\r\\n\",\n                    count, first->index, last->index);\n        }\n        break;\n    }\n\n    case OBJ_font:\n        fprintf(fp, \"<<\\r\\n\"\n                \"  /Type /Font\\r\\n\"\n                \"  /Subtype /Type1\\r\\n\"\n                \"  /BaseFont /%s\\r\\n\"\n                \"  /Encoding /WinAnsiEncoding\\r\\n\"\n                \">>\\r\\n\", object->font.name);\n        break;\n\n    case OBJ_pages: {\n        struct pdf_object *page;\n        int npages = 0;\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Pages\\r\\n\"\n                \"/Kids [ \");\n        for (page = pdf_find_first_object(pdf, OBJ_page);\n                page;\n                page = page->next) {\n            npages++;\n            fprintf(fp, \"%d 0 R \", page->index);\n        }\n        fprintf(fp, \"]\\r\\n\");\n        fprintf(fp, \"/Count %d\\r\\n\", npages);\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n\n    case OBJ_catalog: {\n        struct pdf_object *outline = pdf_find_first_object(pdf, OBJ_outline);\n        struct pdf_object *pages = pdf_find_first_object(pdf, OBJ_pages);\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Catalog\\r\\n\");\n        if (outline)\n            fprintf(fp,\n                    \"/Outlines %d 0 R\\r\\n\"\n                    \"/PageMode /UseOutlines\\r\\n\", outline->index);\n        fprintf(fp, \"/Pages %d 0 R\\r\\n\"\n                \">>\\r\\n\",\n                pages->index);\n        break;\n    }\n\n    default:\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PDF object type %d\",\n                           object->type);\n    }\n\n    fprintf(fp, \"endobj\\r\\n\");\n\n    return 0;\n}\n\nint pdf_save(struct pdf_doc *pdf, const char *filename)\n{\n    FILE *fp;\n    int i;\n    struct pdf_object *obj;\n    int xref_offset;\n    int xref_count = 0;\n\n    if (filename == NULL)\n        fp = stdout;\n    else if ((fp = fopen(filename, \"wb\")) == NULL)\n        return pdf_set_err(pdf, -errno, \"Unable to open '%s': %s\",\n                           filename, strerror(errno));\n\n    fprintf(fp, \"%%PDF-1.2\\r\\n\");\n    /* Hibit bytes */\n    fprintf(fp, \"%c%c%c%c%c\\r\\n\", 0x25, 0xc7, 0xec, 0x8f, 0xa2);\n\n    /* Dump all the objects & get their file offsets */\n    for (i = 0; i < flexarray_size(&pdf->objects); i++)\n        if (pdf_save_object(pdf, fp, i) >= 0)\n            xref_count++;\n\n    /* xref */\n    xref_offset = ftell(fp);\n    fprintf(fp, \"xref\\r\\n\");\n    fprintf(fp, \"0 %d\\r\\n\", xref_count + 1);\n    fprintf(fp, \"0000000000 65535 f\\r\\n\");\n    for (i = 0; i < flexarray_size(&pdf->objects); i++) {\n        obj = pdf_get_object(pdf, i);\n        if (obj->type != OBJ_none)\n            fprintf(fp, \"%10.10d 00000 n\\r\\n\",\n                    obj->offset);\n    }\n\n    fprintf(fp, \"trailer\\r\\n\"\n            \"<<\\r\\n\"\n            \"/Size %d\\r\\n\", xref_count + 1);\n    obj = pdf_find_first_object(pdf, OBJ_catalog);\n    fprintf(fp, \"/Root %d 0 R\\r\\n\", obj->index);\n    obj = pdf_find_first_object(pdf, OBJ_info);\n    fprintf(fp, \"/Info %d 0 R\\r\\n\", obj->index);\n    /* FIXME: Not actually generating a unique ID */\n    fprintf(fp, \"/ID [<%16.16x> <%16.16x>]\\r\\n\", 0x123, 0x123);\n    fprintf(fp, \">>\\r\\n\"\n            \"startxref\\r\\n\");\n    fprintf(fp, \"%d\\r\\n\", xref_offset);\n    fprintf(fp, \"%%%%EOF\\r\\n\");\n    fclose(fp);\n\n    return 0;\n}\n\nstatic int pdf_add_stream(struct pdf_doc *pdf, struct pdf_object *page,\n                          char *buffer)\n{\n    struct pdf_object *obj;\n    int len;\n    char prefix[128];\n    char suffix[128];\n\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL, \"Invalid pdf page\");\n\n    len = strlen(buffer);\n    /* We don't want any trailing whitespace in the stream */\n    while (len >= 1 && (buffer[len - 1] == '\\r' ||\n                        buffer[len - 1] == '\\n')) {\n        buffer[len - 1] = '\\0';\n        len--;\n    }\n\n    sprintf(prefix, \"<< /Length %d >>stream\\r\\n\", len);\n    sprintf(suffix, \"\\r\\nendstream\\r\\n\");\n    len += strlen(prefix) + strlen(suffix);\n\n    obj = pdf_add_object(pdf, OBJ_stream);\n    if (!obj)\n        return pdf->errval;\n    obj->stream.text = malloc(len + 1);\n    if (!obj->stream.text) {\n        obj->type = OBJ_none;\n        return pdf_set_err(pdf, -ENOMEM, \"Insufficient memory for text (%d bytes)\",\n                           len + 1);\n    }\n    obj->stream.text[0] = '\\0';\n    strcat(obj->stream.text, prefix);\n    strcat(obj->stream.text, buffer);\n    strcat(obj->stream.text, suffix);\n    obj->stream.len = 0;\n\n    return flexarray_append(&page->page.children, obj);\n}\n\nint pdf_add_bookmark(struct pdf_doc *pdf, struct pdf_object *page,\n                     int parent, const char *name)\n{\n    struct pdf_object *obj;\n\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL,\n                           \"Unable to add bookmark, no pages available\");\n\n    if (!pdf_find_first_object(pdf, OBJ_outline))\n        if (!pdf_add_object(pdf, OBJ_outline))\n            return pdf->errval;\n\n    obj = pdf_add_object(pdf, OBJ_bookmark);\n    if (!obj)\n        return pdf->errval;\n\n    strncpy(obj->bookmark.name, name, sizeof(obj->bookmark.name));\n    obj->bookmark.name[sizeof(obj->bookmark.name) - 1] = '\\0';\n    obj->bookmark.page = page;\n    if (parent >= 0) {\n        struct pdf_object *parent_obj = pdf_get_object(pdf, parent);\n        if (!parent_obj)\n            return pdf_set_err(pdf, -EINVAL,\n                               \"Invalid parent ID %d supplied\", parent);\n        obj->bookmark.parent = parent_obj;\n        flexarray_append(&parent_obj->bookmark.children, obj);\n    }\n\n    return obj->index;\n}\n\nstruct dstr {\n    char *data;\n    int alloc_len;\n    int used_len;\n};\n\nstatic int dstr_ensure(struct dstr *str, int len)\n{\n    if (str->alloc_len < len) {\n        int new_len = len + 4096;\n        char *new_data = realloc(str->data, new_len);\n        if (!new_data)\n            return -ENOMEM;\n        str->data = new_data;\n        str->alloc_len = new_len;\n    }\n    return 0;\n}\n\nstatic int dstr_printf(struct dstr *str, const char *fmt, ...)\n__attribute__((format(printf,2,3)));\nstatic int dstr_printf(struct dstr *str, const char *fmt, ...)\n{\n    va_list ap, aq;\n    int len;\n\n    va_start(ap, fmt);\n    va_copy(aq, ap);\n    len = vsnprintf(NULL, 0, fmt, ap);\n    if (dstr_ensure(str, str->used_len + len + 1) < 0) {\n        va_end(ap);\n        va_end(aq);\n        return -ENOMEM;\n    }\n    vsprintf(&str->data[str->used_len], fmt, aq);\n    str->used_len += len;\n    va_end(ap);\n    va_end(aq);\n\n    return len;\n}\n\nstatic int dstr_append(struct dstr *str, const char *extend)\n{\n    int len = strlen(extend);\n    if (dstr_ensure(str, str->used_len + len + 1) < 0)\n        return -ENOMEM;\n    strcpy(&str->data[str->used_len], extend);\n    str->used_len += len;\n    return len;\n}\n\nstatic void dstr_free(struct dstr *str)\n{\n    free(str->data);\n}\n\nstatic int utf8_to_utf32(const char *utf8, int len, uint32_t *utf32)\n{\n    uint32_t ch = *utf8;\n    int i;\n    uint8_t mask;\n\n    if ((ch & 0x80) == 0) {\n        len = 1;\n        mask = 0x7f;\n    } else if ((ch & 0xe0) == 0xc0 && len >= 2) {\n        len = 2;\n        mask = 0x1f;\n    } else if ((ch & 0xf0) == 0xe0 && len >= 3) {\n        len = 3;\n        mask = 0xf;\n    } else if ((ch & 0xf8) == 0xf0 && len >= 4) {\n        len = 4;\n        mask = 0x7;\n    } else\n        return -EINVAL;\n\n    ch = 0;\n    for (i = 0; i < len; i++) {\n        int shift = (len - i - 1) * 6;\n        if (i == 0)\n            ch |= ((uint32_t)(*utf8++) & mask) << shift;\n        else\n            ch |= ((uint32_t)(*utf8++) & 0x3f) << shift;\n    }\n\n    *utf32 = ch;\n\n    return len;\n}\n\nint pdf_add_text(struct pdf_doc *pdf, struct pdf_object *page,\n                 const char *text, int size, int xoff, int yoff,\n                 uint32_t colour)\n{\n    int i, ret;\n    int len = text ? strlen(text) : 0;\n    struct dstr str = {0, 0, 0};\n\n    /* Don't bother adding empty/null strings */\n    if (!len)\n        return 0;\n\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%d %d TD \", xoff, yoff);\n    dstr_printf(&str, \"/F%d %d Tf \",\n                pdf->current_font->font.index, size);\n    dstr_printf(&str, \"%f %f %f rg \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_append(&str, \"(\");\n\n    /* Escape magic characters properly */\n    for (i = 0; i < len; ) {\n        uint32_t code;\n        int code_len;\n        code_len = utf8_to_utf32(&text[i], len - i, &code);\n        if (code_len < 0) {\n            dstr_free(&str);\n            return pdf_set_err(pdf, -EINVAL, \"Invalid UTF-8 encoding\");\n        }\n\n        if (code > 255) {\n            /* We support *some* minimal UTF-8 characters */\n            char buf[5] = {0};\n            switch (code) {\n            case 0x160:\n                buf[0] = (char)0x8a;\n                break;\n            case 0x161:\n                buf[0] = (char)0x9a;\n                break;\n            case 0x17d:\n                buf[0] = (char)0x8e;\n                break;\n            case 0x17e:\n                buf[0] = (char)0x9e;\n                break;\n            case 0x20ac:\n                strcpy(buf, \"\\\\200\");\n                break;\n            default:\n                dstr_free(&str);\n                return pdf_set_err(pdf, -EINVAL, \"Unsupported UTF-8 character: 0x%x 0o%o\", code, code);\n            }\n            dstr_append(&str, buf);\n        } else if (strchr(\"()\\\\\", code)) {\n            char buf[3];\n            /* Escape some characters */\n            buf[0] = '\\\\';\n            buf[1] = code;\n            buf[2] = '\\0';\n            dstr_append(&str, buf);\n        } else if (strrchr(\"\\n\\r\\t\\b\\f\", code)) {\n            /* Skip over these characters */\n            ;\n        } else {\n            char buf[2];\n            buf[0] = code;\n            buf[1] = '\\0';\n            dstr_append(&str, buf);\n        }\n\n        i += code_len;\n    }\n    dstr_append(&str, \") Tj \");\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n    return ret;\n}\n\n/* How wide is each character, in points, at size 14 */\nstatic const uint16_t helvetica_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 355, 556, 556, 889, 667, 191,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 278, 278, 584, 584, 584, 556,\n    1015, 667, 667, 722, 722, 667, 611, 778,\n    722, 278, 500, 667, 556, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 278, 278, 278, 469, 556,\n    333, 556, 556, 500, 556, 556, 278, 556,\n    556, 222, 222, 500, 222, 833, 556, 556,\n    556, 556, 333, 500, 278, 556, 500, 722,\n    500, 500, 500, 334, 260, 334, 584, 350,\n    556, 350, 222, 556, 333, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 222, 222, 333, 333, 350, 556, 1000,\n    333, 1000, 500, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 260, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 556, 537, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    667, 667, 667, 667, 667, 667, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 500,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 584,\n    611, 556, 556, 556, 556, 500, 556, 500\n};\n\nstatic const uint16_t helvetica_bold_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 333, 474, 556, 556, 889, 722, 238,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 333, 333, 584, 584, 584, 611,\n    975, 722, 722, 722, 722, 667, 611, 778,\n    722, 278, 556, 722, 611, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 333, 278, 333, 584, 556,\n    333, 556, 611, 556, 611, 556, 333, 611,\n    611, 278, 278, 556, 278, 889, 611, 611,\n    611, 611, 389, 556, 333, 611, 556, 778,\n    556, 556, 500, 389, 280, 389, 584, 350,\n    556, 350, 278, 556, 500, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 278, 278, 500, 500, 350, 556, 1000,\n    333, 1000, 556, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 280, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 611, 556, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 556,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    611, 611, 611, 611, 611, 611, 611, 584,\n    611, 611, 611, 611, 611, 556, 611, 556\n};\n\nstatic uint16_t helvetica_bold_oblique_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 333, 474, 556, 556, 889, 722, 238,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 333, 333, 584, 584, 584, 611,\n    975, 722, 722, 722, 722, 667, 611, 778,\n    722, 278, 556, 722, 611, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 333, 278, 333, 584, 556,\n    333, 556, 611, 556, 611, 556, 333, 611,\n    611, 278, 278, 556, 278, 889, 611, 611,\n    611, 611, 389, 556, 333, 611, 556, 778,\n    556, 556, 500, 389, 280, 389, 584, 350,\n    556, 350, 278, 556, 500, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 278, 278, 500, 500, 350, 556, 1000,\n    333, 1000, 556, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 280, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 611, 556, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 556,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    611, 611, 611, 611, 611, 611, 611, 584,\n    611, 611, 611, 611, 611, 556, 611, 556\n};\n\nstatic uint16_t helvetica_oblique_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 355, 556, 556, 889, 667, 191,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 278, 278, 584, 584, 584, 556,\n    1015, 667, 667, 722, 722, 667, 611, 778,\n    722, 278, 500, 667, 556, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 278, 278, 278, 469, 556,\n    333, 556, 556, 500, 556, 556, 278, 556,\n    556, 222, 222, 500, 222, 833, 556, 556,\n    556, 556, 333, 500, 278, 556, 500, 722,\n    500, 500, 500, 334, 260, 334, 584, 350,\n    556, 350, 222, 556, 333, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 222, 222, 333, 333, 350, 556, 1000,\n    333, 1000, 500, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 260, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 556, 537, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    667, 667, 667, 667, 667, 667, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 500,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 584,\n    611, 556, 556, 556, 556, 500, 556, 500\n};\n\nstatic uint16_t symbol_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 713, 500, 549, 833, 778, 439,\n    333, 333, 500, 549, 250, 549, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 278, 278, 549, 549, 549, 444,\n    549, 722, 667, 722, 612, 611, 763, 603,\n    722, 333, 631, 722, 686, 889, 722, 722,\n    768, 741, 556, 592, 611, 690, 439, 768,\n    645, 795, 611, 333, 863, 333, 658, 500,\n    500, 631, 549, 549, 494, 439, 521, 411,\n    603, 329, 603, 549, 549, 576, 521, 549,\n    549, 521, 549, 603, 439, 576, 713, 686,\n    493, 686, 494, 480, 200, 480, 549, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    750, 620, 247, 549, 167, 713, 500, 753,\n    753, 753, 753, 1042, 987, 603, 987, 603,\n    400, 549, 411, 549, 549, 713, 494, 460,\n    549, 549, 549, 549, 1000, 603, 1000, 658,\n    823, 686, 795, 987, 768, 768, 823, 768,\n    768, 713, 713, 713, 713, 713, 713, 713,\n    768, 713, 790, 790, 890, 823, 549, 250,\n    713, 603, 603, 1042, 987, 603, 987, 603,\n    494, 329, 790, 790, 786, 713, 384, 384,\n    384, 384, 384, 384, 494, 494, 494, 494,\n    0, 329, 274, 686, 686, 686, 384, 384,\n    384, 384, 384, 384, 494, 494, 494, 0\n};\n\nstatic uint16_t times_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 408, 500, 500, 833, 778, 180,\n    333, 333, 500, 564, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 278, 278, 564, 564, 564, 444,\n    921, 722, 667, 667, 722, 611, 556, 722,\n    722, 333, 389, 722, 611, 889, 722, 722,\n    556, 722, 667, 556, 611, 722, 722, 944,\n    722, 722, 611, 333, 278, 333, 469, 500,\n    333, 444, 500, 444, 500, 444, 333, 500,\n    500, 278, 278, 500, 278, 778, 500, 500,\n    500, 500, 333, 389, 278, 500, 500, 722,\n    500, 500, 444, 480, 200, 480, 541, 350,\n    500, 350, 333, 500, 444, 1000, 500, 500,\n    333, 1000, 556, 333, 889, 350, 611, 350,\n    350, 333, 333, 444, 444, 350, 500, 1000,\n    333, 980, 389, 333, 722, 350, 444, 722,\n    250, 333, 500, 500, 500, 500, 200, 500,\n    333, 760, 276, 500, 564, 333, 760, 333,\n    400, 564, 300, 300, 333, 500, 453, 250,\n    333, 300, 310, 500, 750, 750, 750, 444,\n    722, 722, 722, 722, 722, 722, 889, 667,\n    611, 611, 611, 611, 333, 333, 333, 333,\n    722, 722, 722, 722, 722, 722, 722, 564,\n    722, 722, 722, 722, 722, 722, 556, 500,\n    444, 444, 444, 444, 444, 444, 667, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 500, 500, 500, 500, 500, 500, 564,\n    500, 500, 500, 500, 500, 500, 500, 500\n};\n\nstatic uint16_t times_bold_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 555, 500, 500, 1000, 833, 278,\n    333, 333, 500, 570, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 570, 570, 570, 500,\n    930, 722, 667, 722, 722, 667, 611, 778,\n    778, 389, 500, 778, 667, 944, 722, 778,\n    611, 778, 722, 556, 667, 722, 722, 1000,\n    722, 722, 667, 333, 278, 333, 581, 500,\n    333, 500, 556, 444, 556, 444, 333, 500,\n    556, 278, 333, 556, 278, 833, 556, 500,\n    556, 556, 444, 389, 333, 556, 500, 722,\n    500, 500, 444, 394, 220, 394, 520, 350,\n    500, 350, 333, 500, 500, 1000, 500, 500,\n    333, 1000, 556, 333, 1000, 350, 667, 350,\n    350, 333, 333, 500, 500, 350, 500, 1000,\n    333, 1000, 389, 333, 722, 350, 444, 722,\n    250, 333, 500, 500, 500, 500, 220, 500,\n    333, 747, 300, 500, 570, 333, 747, 333,\n    400, 570, 300, 300, 333, 556, 540, 250,\n    333, 300, 330, 500, 750, 750, 750, 500,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 389, 389, 389, 389,\n    722, 722, 778, 778, 778, 778, 778, 570,\n    778, 722, 722, 722, 722, 722, 611, 556,\n    500, 500, 500, 500, 500, 500, 722, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 556, 500, 500, 500, 500, 500, 570,\n    500, 556, 556, 556, 556, 500, 556, 500\n} ;\n\nstatic uint16_t times_bold_italic_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 389, 555, 500, 500, 833, 778, 278,\n    333, 333, 500, 570, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 570, 570, 570, 500,\n    832, 667, 667, 667, 722, 667, 667, 722,\n    778, 389, 500, 667, 611, 889, 722, 722,\n    611, 722, 667, 556, 611, 722, 667, 889,\n    667, 611, 611, 333, 278, 333, 570, 500,\n    333, 500, 500, 444, 500, 444, 333, 500,\n    556, 278, 278, 500, 278, 778, 556, 500,\n    500, 500, 389, 389, 278, 556, 444, 667,\n    500, 444, 389, 348, 220, 348, 570, 350,\n    500, 350, 333, 500, 500, 1000, 500, 500,\n    333, 1000, 556, 333, 944, 350, 611, 350,\n    350, 333, 333, 500, 500, 350, 500, 1000,\n    333, 1000, 389, 333, 722, 350, 389, 611,\n    250, 389, 500, 500, 500, 500, 220, 500,\n    333, 747, 266, 500, 606, 333, 747, 333,\n    400, 570, 300, 300, 333, 576, 500, 250,\n    333, 300, 300, 500, 750, 750, 750, 500,\n    667, 667, 667, 667, 667, 667, 944, 667,\n    667, 667, 667, 667, 389, 389, 389, 389,\n    722, 722, 722, 722, 722, 722, 722, 570,\n    722, 722, 722, 722, 722, 611, 611, 500,\n    500, 500, 500, 500, 500, 500, 722, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 556, 500, 500, 500, 500, 500, 570,\n    500, 556, 556, 556, 556, 444, 500, 444\n};\n\nstatic uint16_t times_italic_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 420, 500, 500, 833, 778, 214,\n    333, 333, 500, 675, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 675, 675, 675, 500,\n    920, 611, 611, 667, 722, 611, 611, 722,\n    722, 333, 444, 667, 556, 833, 667, 722,\n    611, 722, 611, 500, 556, 722, 611, 833,\n    611, 556, 556, 389, 278, 389, 422, 500,\n    333, 500, 500, 444, 500, 444, 278, 500,\n    500, 278, 278, 444, 278, 722, 500, 500,\n    500, 500, 389, 389, 278, 500, 444, 667,\n    444, 444, 389, 400, 275, 400, 541, 350,\n    500, 350, 333, 500, 556, 889, 500, 500,\n    333, 1000, 500, 333, 944, 350, 556, 350,\n    350, 333, 333, 556, 556, 350, 500, 889,\n    333, 980, 389, 333, 667, 350, 389, 556,\n    250, 389, 500, 500, 500, 500, 275, 500,\n    333, 760, 276, 500, 675, 333, 760, 333,\n    400, 675, 300, 300, 333, 500, 523, 250,\n    333, 300, 310, 500, 750, 750, 750, 500,\n    611, 611, 611, 611, 611, 611, 889, 667,\n    611, 611, 611, 611, 333, 333, 333, 333,\n    722, 667, 722, 722, 722, 722, 722, 675,\n    722, 722, 722, 722, 722, 556, 611, 500,\n    500, 500, 500, 500, 500, 500, 667, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 500, 500, 500, 500, 500, 500, 675,\n    500, 500, 500, 500, 500, 444, 500, 444\n};\n\nstatic uint16_t zapfdingbats_widths[256] = {\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    278, 974, 961, 974, 980, 719, 789, 790,\n    791, 690, 960, 939, 549, 855, 911, 933,\n    911, 945, 974, 755, 846, 762, 761, 571,\n    677, 763, 760, 759, 754, 494, 552, 537,\n    577, 692, 786, 788, 788, 790, 793, 794,\n    816, 823, 789, 841, 823, 833, 816, 831,\n    923, 744, 723, 749, 790, 792, 695, 776,\n    768, 792, 759, 707, 708, 682, 701, 826,\n    815, 789, 789, 707, 687, 696, 689, 786,\n    787, 713, 791, 785, 791, 873, 761, 762,\n    762, 759, 759, 892, 892, 788, 784, 438,\n    138, 277, 415, 392, 392, 668, 668, 0,\n    390, 390, 317, 317, 276, 276, 509, 509,\n    410, 410, 234, 234, 334, 334, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 732, 544, 544, 910, 667, 760, 760,\n    776, 595, 694, 626, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 894, 838, 1016, 458,\n    748, 924, 748, 918, 927, 928, 928, 834,\n    873, 828, 924, 924, 917, 930, 931, 463,\n    883, 836, 836, 867, 867, 696, 696, 874,\n    0, 874, 760, 946, 771, 865, 771, 888,\n    967, 888, 831, 873, 927, 970, 918, 0\n};\n\nstatic uint16_t courier_widths[256] = {\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n};\n\nstatic int pdf_text_pixel_width(const char *text, int text_len, int size,\n                                const uint16_t *widths)\n{\n    int i;\n    int len = 0;\n    if (text_len < 0)\n        text_len = strlen(text);\n\n    for (i = 0; i < text_len; i++)\n        len += widths[(uint8_t)text[i]];\n\n    /* Our widths arrays are for 14pt fonts */\n    return len * size / (14 * 72);\n}\n\nstatic const uint16_t *find_font_widths(const char *font_name)\n{\n    if (strcmp(font_name, \"Helvetica\") == 0)\n        return helvetica_widths;\n    if (strcmp(font_name, \"Helvetica-Bold\") == 0)\n        return helvetica_bold_widths;\n    if (strcmp(font_name, \"Helvetica-BoldOblique\") == 0)\n        return helvetica_bold_oblique_widths;\n    if (strcmp(font_name, \"Helvetica-Oblique\") == 0)\n        return helvetica_oblique_widths;\n    if (strcmp(font_name, \"Courier\") == 0 ||\n            strcmp(font_name, \"Courier-Bold\") == 0 ||\n            strcmp(font_name, \"Courier-BoldOblique\") == 0 ||\n            strcmp(font_name, \"Courier-Oblique\") == 0)\n        return courier_widths;\n    if (strcmp(font_name, \"Times-Roman\") == 0)\n        return times_widths;\n    if (strcmp(font_name, \"Times-Bold\") == 0)\n        return times_bold_widths;\n    if (strcmp(font_name, \"Times-Italic\") == 0)\n        return times_italic_widths;\n    if (strcmp(font_name, \"Times-BoldItalic\") == 0)\n        return times_bold_italic_widths;\n    if (strcmp(font_name, \"Symbol\") == 0)\n        return symbol_widths;\n    if (strcmp(font_name, \"ZapfDingbats\") == 0)\n        return zapfdingbats_widths;\n\n    return NULL;\n}\n\nint pdf_get_font_text_width(struct pdf_doc *pdf, const char *font_name,\n                            const char *text, int size)\n{\n    const uint16_t *widths = find_font_widths(font_name);\n\n    if (!widths)\n        return pdf_set_err(pdf, -EINVAL, \"Unable to determine width for font '%s'\",\n                           pdf->current_font->font.name);\n    return pdf_text_pixel_width(text, -1, size, widths);\n}\n\nstatic const char *find_word_break(const char *string)\n{\n    /* Skip over the actual word */\n    while (string && *string && !isspace(*string))\n        string++;\n\n    return string;\n}\n\nint pdf_add_text_wrap(struct pdf_doc *pdf, struct pdf_object *page,\n                      const char *text, int size, int xoff, int yoff,\n                      uint32_t colour, int wrap_width)\n{\n    /* Move through the text string, stopping at word boundaries,\n     * trying to find the longest text string we can fit in the given width\n     */\n    const char *start = text;\n    const char *last_best = text;\n    const char *end = text;\n    char line[512];\n    const uint16_t *widths;\n    int orig_yoff = yoff;\n\n    widths = find_font_widths(pdf->current_font->font.name);\n    if (!widths)\n        return pdf_set_err(pdf, -EINVAL, \"Unable to determine width for font '%s'\",\n                           pdf->current_font->font.name);\n\n    while (start && *start) {\n        const char *new_end = find_word_break(end + 1);\n        int line_width;\n        int output = 0;\n\n        end = new_end;\n\n        line_width = pdf_text_pixel_width(start, end - start, size, widths);\n\n        if (line_width >= wrap_width) {\n            if (last_best == start) {\n                /* There is a single word that is too long for the line */\n                int i;\n                /* Find the best character to chop it at */\n                for (i = end - start - 1; i > 0; i--)\n                    if (pdf_text_pixel_width(start, i, size, widths) < wrap_width)\n                        break;\n\n                end = start + i;\n            } else\n                end = last_best;\n            output = 1;\n        }\n        if (*end == '\\0')\n            output = 1;\n\n        if (*end == '\\n' || *end == '\\r')\n            output = 1;\n\n        if (output) {\n            int len = end - start;\n            strncpy(line, start, len);\n            line[len] = '\\0';\n            pdf_add_text(pdf, page, line, size, xoff, yoff, colour);\n\n            if (*end == ' ')\n                end++;\n\n            start = last_best = end;\n            yoff -= size;\n        } else\n            last_best = end;\n    }\n\n    return orig_yoff - yoff;\n}\n\n\nint pdf_add_line(struct pdf_doc *pdf, struct pdf_object *page,\n                 int x1, int y1, int x2, int y2, int width, uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT\\r\\n\");\n    dstr_printf(&str, \"%d w\\r\\n\", width);\n    dstr_printf(&str, \"%d %d m\\r\\n\", x1, y1);\n    dstr_printf(&str, \"/DeviceRGB CS\\r\\n\");\n    dstr_printf(&str, \"%f %f %f RG\\r\\n\",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d %d l S\\r\\n\", x2, y2);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nint pdf_add_circle(struct pdf_doc *pdf, struct pdf_object *page,\n                   int x, int y, int radius, int width, uint32_t colour, bool filled)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT \");\n    if (filled)\n        dstr_printf(&str, \"%f %f %f rg \",\n                    PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    else\n        dstr_printf(&str, \"%f %f %f RG \",\n                    PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", width);\n    /* This is a bit of a rough approximation of a circle based on bezier curves.\n     * It's not exact\n     */\n    dstr_printf(&str, \"%d %d m \", x + radius, y);\n    dstr_printf(&str, \"%d %d %d %d v \", x + radius, y + radius, x, y + radius);\n    dstr_printf(&str, \"%d %d %d %d v \", x - radius, y + radius, x - radius, y);\n    dstr_printf(&str, \"%d %d %d %d v \", x - radius, y - radius, x, y - radius);\n    dstr_printf(&str, \"%d %d %d %d v \", x + radius, y - radius, x + radius, y);\n    if (filled)\n        dstr_append(&str, \"f \");\n    else\n        dstr_append(&str, \"S \");\n    dstr_append(&str, \"ET\");\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nint pdf_add_rectangle(struct pdf_doc *pdf, struct pdf_object *page,\n                      int x, int y, int width, int height, int border_width,\n                      uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%f %f %f RG \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", border_width);\n    dstr_printf(&str, \"%d %d %d %d re S \", x, y, width, height);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nint pdf_add_filled_rectangle(struct pdf_doc *pdf, struct pdf_object *page,\n                             int x, int y, int width, int height,\n                             int border_width, uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%f %f %f rg \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", border_width);\n    dstr_printf(&str, \"%d %d %d %d re f \", x, y, width, height);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nstatic const struct {\n    uint32_t code;\n    char ch;\n} code_128a_encoding[] = {\n    {0x212222, ' '},\n    {0x222122, '!'},\n    {0x222221, '\"'},\n    {0x121223, '#'},\n    {0x121322, '$'},\n    {0x131222, '%'},\n    {0x122213, '&'},\n    {0x122312, '\\''},\n    {0x132212, '('},\n    {0x221213, ')'},\n    {0x221312, '*'},\n    {0x231212, '+'},\n    {0x112232, ','},\n    {0x122132, '-'},\n    {0x122231, '.'},\n    {0x113222, '/'},\n    {0x123122, '0'},\n    {0x123221, '1'},\n    {0x223211, '2'},\n    {0x221132, '3'},\n    {0x221231, '4'},\n    {0x213212, '5'},\n    {0x223112, '6'},\n    {0x312131, '7'},\n    {0x311222, '8'},\n    {0x321122, '9'},\n    {0x321221, ':'},\n    {0x312212, ';'},\n    {0x322112, '<'},\n    {0x322211, '='},\n    {0x212123, '>'},\n    {0x212321, '?'},\n    {0x232121, '@'},\n    {0x111323, 'A'},\n    {0x131123, 'B'},\n    {0x131321, 'C'},\n    {0x112313, 'D'},\n    {0x132113, 'E'},\n    {0x132311, 'F'},\n    {0x211313, 'G'},\n    {0x231113, 'H'},\n    {0x231311, 'I'},\n    {0x112133, 'J'},\n    {0x112331, 'K'},\n    {0x132131, 'L'},\n    {0x113123, 'M'},\n    {0x113321, 'N'},\n    {0x133121, 'O'},\n    {0x313121, 'P'},\n    {0x211331, 'Q'},\n    {0x231131, 'R'},\n    {0x213113, 'S'},\n    {0x213311, 'T'},\n    {0x213131, 'U'},\n    {0x311123, 'V'},\n    {0x311321, 'W'},\n    {0x331121, 'X'},\n    {0x312113, 'Y'},\n    {0x312311, 'Z'},\n    {0x332111, '['},\n    {0x314111, '\\\\'},\n    {0x221411, ']'},\n    {0x431111, '^'},\n    {0x111224, '_'},\n    {0x111422, '`'},\n    {0x121124, 'a'},\n    {0x121421, 'b'},\n    {0x141122, 'c'},\n    {0x141221, 'd'},\n    {0x112214, 'e'},\n    {0x112412, 'f'},\n    {0x122114, 'g'},\n    {0x122411, 'h'},\n    {0x142112, 'i'},\n    {0x142211, 'j'},\n    {0x241211, 'k'},\n    {0x221114, 'l'},\n    {0x413111, 'm'},\n    {0x241112, 'n'},\n    {0x134111, 'o'},\n    {0x111242, 'p'},\n    {0x121142, 'q'},\n    {0x121241, 'r'},\n    {0x114212, 's'},\n    {0x124112, 't'},\n    {0x124211, 'u'},\n    {0x411212, 'v'},\n    {0x421112, 'w'},\n    {0x421211, 'x'},\n    {0x212141, 'y'},\n    {0x214121, 'z'},\n    {0x412121, '{'},\n    {0x111143, '|'},\n    {0x111341, '}'},\n    {0x131141, '~'},\n    {0x114113, '\\0'},\n    {0x114311, '\\0'},\n    {0x411113, '\\0'},\n    {0x411311, '\\0'},\n    {0x113141, '\\0'},\n    {0x114131, '\\0'},\n    {0x311141, '\\0'},\n    {0x411131, '\\0'},\n    {0x211412, '\\0'},\n    {0x211214, '\\0'},\n    {0x211232, '\\0'},\n    {0x2331112, '\\0'},\n};\n\nstatic int find_128_encoding(char ch)\n{\n    int i;\n    for (i = 0; i < ARRAY_SIZE(code_128a_encoding); i++) {\n        if (code_128a_encoding[i].ch == ch)\n            return i;\n    }\n    return -1;\n}\n\nstatic int pdf_barcode_128a_ch(struct pdf_doc *pdf, struct pdf_object *page,\n                               int x, int y, int width, int height,\n                               uint32_t colour, int index, int code_len)\n{\n    uint32_t code = code_128a_encoding[index].code;\n    int i;\n    int line_width = width / 11;\n\n    for (i = 0; i < code_len; i++) {\n        uint8_t shift = (code_len - 1 - i) * 4;\n        uint8_t mask = (code >> shift) & 0xf;\n\n        if (!(i % 2)) {\n            int j;\n            for (j = 0; j < mask; j++) {\n                pdf_add_line(pdf, page, x, y, x, y + height, line_width, colour);\n                x += line_width;\n            }\n        } else\n            x += line_width * mask;\n    }\n    return x;\n}\n\nstatic int pdf_add_barcode_128a(struct pdf_doc *pdf, struct pdf_object *page,\n                                int x, int y, int width, int height,\n                                const char *string, uint32_t colour)\n{\n    const char *s;\n    int len = strlen(string) + 3;\n    int char_width = width / len;\n    int checksum, i;\n\n    for (s = string; *s; s++)\n        if (find_128_encoding(*s) < 0)\n            return pdf_set_err(pdf, -EINVAL, \"Invalid barcode character 0x%x\", *s);\n\n    x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, 104,\n                            6);\n    checksum = 104;\n\n    for (i = 1, s = string; *s; s++, i++) {\n        int index = find_128_encoding(*s);\n        x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, index,\n                                6);\n        checksum += index * i;\n    }\n    x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour,\n                            checksum % 103, 6);\n    pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, 106,\n                        7);\n    return 0;\n}\n\n/* Code 39 character encoding. Each 4-bit value indicates:\n * 0 => wide bar\n * 1 => narrow bar\n * 2 => wide space\n */\nstatic const struct {\n    uint32_t code;\n    char ch;\n} code_39_encoding[] = {\n    {0x012110, '1'},\n    {0x102110, '2'},\n    {0x002111, '3'},\n    {0x112010, '4'},\n    {0x012011, '5'},\n    {0x102011, '6'},\n    {0x112100, '7'},\n    {0x012101, '8'},\n    {0x102101, '9'},\n    {0x112001, '0'},\n    {0x011210, 'A'},\n    {0x101210, 'B'},\n    {0x001211, 'C'},\n    {0x110210, 'D'},\n    {0x010211, 'E'},\n    {0x100211, 'F'},\n    {0x111200, 'G'},\n    {0x011201, 'H'},\n    {0x101201, 'I'},\n    {0x110201, 'J'},\n    {0x011120, 'K'},\n    {0x101120, 'L'},\n    {0x001121, 'M'},\n    {0x110120, 'N'},\n    {0x010121, 'O'},\n    {0x100121, 'P'},\n    {0x111020, 'Q'},\n    {0x011021, 'R'},\n    {0x101021, 'S'},\n    {0x110021, 'T'},\n    {0x021110, 'U'},\n    {0x120110, 'V'},\n    {0x020111, 'W'},\n    {0x121010, 'X'},\n    {0x021011, 'Y'},\n    {0x120011, 'Z'},\n    {0x121100, '-'},\n    {0x021101, '.'},\n    {0x120101, ' '},\n    {0x121001, '*'}, // 'stop' character\n};\n\n\nstatic int pdf_barcode_39_ch(struct pdf_doc *pdf, struct pdf_object *page, int x, int y, int char_width, int height, uint32_t colour, char ch)\n{\n    int nw = char_width / 12;\n    int ww = char_width / 4;\n    int i;\n    uint32_t code;\n\n    if (nw <= 1 || ww <= 1)\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient width for each character\");\n\n    for (i = 0; i < ARRAY_SIZE(code_39_encoding); i++) {\n        if (code_39_encoding[i].ch == ch) {\n            code = code_39_encoding[i].code;\n            break;\n        }\n    }\n    if (i == ARRAY_SIZE(code_39_encoding))\n        return pdf_set_err(pdf, -EINVAL, \"Invalid Code 39 character %c 0x%x\", ch, ch);\n\n\n    for (i = 5; i >= 0; i--) {\n        int pattern = (code >> i * 4) & 0xf;\n        if (pattern == 0) { // wide\n            if (pdf_add_filled_rectangle(pdf, page, x, y, ww - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += ww;\n        }\n        if (pattern == 1) { // narrow\n            if (pdf_add_filled_rectangle(pdf, page, x, y, nw - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += nw;\n        }\n        if (pattern == 2) { // space\n            x += nw;\n        }\n    }\n    return x;\n}\n\nstatic int pdf_add_barcode_39(struct pdf_doc *pdf, struct pdf_object *page,\n                              int x, int y, int width, int height,\n                              const char *string, uint32_t colour)\n{\n    int len = strlen(string);\n    int char_width = width / (len + 2);\n\n    x = pdf_barcode_39_ch(pdf, page, x, y, char_width, height, colour, '*');\n    if (x < 0)\n        return x;\n\n    while (string && *string) {\n        x = pdf_barcode_39_ch(pdf, page, x, y, char_width, height, colour, *string);\n        if (x < 0)\n            return x;\n        string++;\n    };\n\n    x = pdf_barcode_39_ch(pdf, page, x, y, char_width, height, colour, '*');\n    if (x < 0)\n        return x;\n\n    return 0;\n}\n\nint pdf_add_barcode(struct pdf_doc *pdf, struct pdf_object *page,\n                    int code, int x, int y, int width, int height,\n                    const char *string, uint32_t colour)\n{\n    if (!string || !*string)\n        return 0;\n    switch (code) {\n    case PDF_BARCODE_128A:\n        return pdf_add_barcode_128a(pdf, page, x, y,\n                                    width, height, string, colour);\n    case PDF_BARCODE_39:\n        return pdf_add_barcode_39(pdf, page, x, y, width, height, string, colour);\n    default:\n        return pdf_set_err(pdf, -EINVAL, \"Invalid barcode code %d\", code);\n    }\n}\n\nstatic pdf_object *pdf_add_raw_rgb24(struct pdf_doc *pdf,\n                                     uint8_t *data, int width, int height)\n{\n    struct pdf_object *obj;\n    char line[1024];\n    int len;\n    uint8_t *final_data;\n    const char *endstream = \">\\r\\nendstream\\r\\n\";\n    int i;\n\n    sprintf(line,\n            \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n/Subtype /Image\\r\\n\"\n            \"/ColorSpace /DeviceRGB\\r\\n/Height %d\\r\\n/Width %d\\r\\n\"\n            \"/BitsPerComponent 8\\r\\n/Filter /ASCIIHexDecode\\r\\n\"\n            \"/Length %d\\r\\n>>stream\\r\\n\",\n            flexarray_size(&pdf->objects), height, width, width * height * 3 * 2 + 1);\n\n    len = strlen(line) + width * height * 3 * 2 + strlen(endstream) + 1;\n    final_data = malloc(len);\n    if (!final_data) {\n        pdf_set_err(pdf, -ENOMEM, \"Unable to allocate %d bytes memory for image\",\n                    len);\n        return NULL;\n    }\n    strcpy((char *)final_data, line);\n    uint8_t *pos = &final_data[strlen(line)];\n    for (i = 0; i < width * height * 3; i++) {\n        *pos++ = \"0123456789ABCDEF\"[(data[i] >> 4) & 0xf];\n        *pos++ = \"0123456789ABCDEF\"[data[i] & 0xf];\n    }\n    strcpy((char *)pos, endstream);\n    pos += strlen(endstream);\n\n    obj = pdf_add_object(pdf, OBJ_image);\n    if (!obj) {\n        free(final_data);\n        return NULL;\n    }\n    obj->stream.text = (char *)final_data;\n    obj->stream.len = pos - final_data;\n\n    return obj;\n}\n\n/* See http://www.64lines.com/jpeg-width-height for details */\nstatic int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}\n\nstatic pdf_object *pdf_add_raw_jpeg(struct pdf_doc *pdf,\n                                    const char *jpeg_file)\n{\n    struct stat buf;\n    off_t len;\n    char *final_data;\n    uint8_t *jpeg_data;\n    int written = 0;\n    FILE *fp;\n    struct pdf_object *obj;\n    int width, height;\n\n    if (stat(jpeg_file, &buf) < 0) {\n        pdf_set_err(pdf, -errno, \"Unable to access %s: %s\", jpeg_file,\n                    strerror(errno));\n        return NULL;\n    }\n\n    len = buf.st_size;\n\n    if ((fp = fopen(jpeg_file, \"rb\")) == NULL) {\n        pdf_set_err(pdf, -errno, \"Unable to open %s: %s\", jpeg_file,\n                    strerror(errno));\n        return NULL;\n    }\n\n    jpeg_data = malloc(len);\n    if (!jpeg_data) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate: %zd\", len);\n        fclose(fp);\n        return NULL;\n    }\n\n    if (fread(jpeg_data, len, 1, fp) != 1) {\n        pdf_set_err(pdf, -errno, \"Unable to read full jpeg data\");\n        free(jpeg_data);\n        fclose(fp);\n        return NULL;\n    }\n    fclose(fp);\n\n    if (jpeg_size(jpeg_data, len, &width, &height) < 0) {\n        free(jpeg_data);\n        pdf_set_err(pdf, -EINVAL, \"Unable to determine jpeg width/height from %s\",\n                    jpeg_file);\n        return NULL;\n    }\n\n    final_data = malloc(len + 1024);\n    if (!final_data) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate jpeg data %zd\", len + 1024);\n        free(jpeg_data);\n        return NULL;\n    }\n\n    written = sprintf(final_data,\n                      \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n\"\n                      \"/Subtype /Image\\r\\n/ColorSpace /DeviceRGB\\r\\n\"\n                      \"/Width %d\\r\\n/Height %d\\r\\n\"\n                      \"/BitsPerComponent 8\\r\\n/Filter /DCTDecode\\r\\n\"\n                      \"/Length %d\\r\\n>>stream\\r\\n\",\n                      flexarray_size(&pdf->objects), width, height, (int)len);\n    memcpy(&final_data[written], jpeg_data, len);\n    written += len;\n    written += sprintf(&final_data[written], \"\\r\\nendstream\\r\\n\");\n\n    free(jpeg_data);\n\n    obj = pdf_add_object(pdf, OBJ_image);\n    if (!obj) {\n        free(final_data);\n        return NULL;\n    }\n    obj->stream.text = final_data;\n    obj->stream.len = written;\n\n    return obj;\n}\n\nstatic int pdf_add_image(struct pdf_doc *pdf, struct pdf_object *page,\n                         struct pdf_object *image, int x, int y, int width,\n                         int height)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"q \");\n    dstr_printf(&str, \"%d 0 0 %d %d %d cm \", width, height, x, y);\n    dstr_printf(&str, \"/Image%d Do \", image->index);\n    dstr_append(&str, \"Q\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n    return ret;\n}\n\nint pdf_add_ppm(struct pdf_doc *pdf, struct pdf_object *page,\n                int x, int y, int display_width, int display_height,\n                const char *ppm_file)\n{\n    struct pdf_object *obj;\n    uint8_t *data;\n    FILE *fp;\n    char line[1024];\n    unsigned width, height, size;\n\n    /* Load the PPM file */\n    fp = fopen(ppm_file, \"rb\");\n    if (!fp)\n        return pdf_set_err(pdf, -errno, \"Unable to open '%s'\", ppm_file);\n    if (!fgets(line, sizeof(line) - 1, fp)) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PPM file\");\n    }\n\n    /* We only support binary ppms */\n    if (strncmp(line, \"P6\", 2) != 0) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Only binary PPM files supported\");\n    }\n\n    /* Find the width line */\n    do {\n        if (!fgets(line, sizeof(line) - 1, fp)) {\n            fclose(fp);\n            return pdf_set_err(pdf, -EINVAL, \"Unable to find PPM size\");\n        }\n        if (line[0] == '#')\n            continue;\n\n        if (sscanf(line, \"%u %u\\n\", &width, &height) != 2) {\n            fclose(fp);\n            return pdf_set_err(pdf, -EINVAL, \"Unable to find PPM size\");\n        }\n        break;\n    } while (1);\n\n    /* Skip over the byte-size line */\n    if (!fgets(line, sizeof(line) - 1, fp)) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"No byte-size line in PPM file\");\n    }\n\n    if (width > INT_MAX || height > INT_MAX) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Invalid width/height in PPM file: %ux%u\", width, height);\n    }\n\n    size = width * height * 3;\n    data = malloc(size);\n    if (!data) {\n        fclose(fp);\n        return pdf_set_err(pdf, -ENOMEM, \"Unable to allocate memory for RGB data\");\n    }\n    if (fread(data, 1, size, fp) != size) {\n        free(data);\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient RGB data available\");\n\n    }\n    fclose(fp);\n    obj = pdf_add_raw_rgb24(pdf, data, width, height);\n    free(data);\n    if (!obj)\n        return pdf->errval;\n\n    return pdf_add_image(pdf, page, obj, x, y, display_width, display_height);\n}\n\nint pdf_add_jpeg(struct pdf_doc *pdf, struct pdf_object *page,\n                 int x, int y, int display_width, int display_height,\n                 const char *jpeg_file)\n{\n    struct pdf_object *obj;\n\n    obj = pdf_add_raw_jpeg(pdf, jpeg_file);\n    if (!obj)\n        return pdf->errval;\n\n    return pdf_add_image(pdf, page, obj, x, y, display_width, display_height);\n}\n"], "fixing_code": ["/**\n * Simple engine for creating PDF files.\n * It supports text, shapes, images etc...\n * Capable of handling millions of objects without too much performance\n * penalty.\n * Public domain license - no warrenty implied; use at your own risk.\n */\n\n/**\n * PDF HINTS & TIPS\n * The following sites have various bits & pieces about PDF document\n * generation\n * http://www.mactech.com/articles/mactech/Vol.15/15.09/PDFIntro/index.html\n * http://gnupdf.org/Introduction_to_PDF\n * http://www.planetpdf.com/mainpage.asp?WebPageID=63\n * http://archive.vector.org.uk/art10008970\n * http://www.adobe.com/devnet/acrobat/pdfs/pdf_reference_1-7.pdf\n * https://blog.idrsolutions.com/2013/01/understanding-the-pdf-file-format-overview/\n *\n * To validate the PDF output, there are several online validators:\n * http://www.validatepdfa.com/online.htm\n * http://www.datalogics.com/products/callas/callaspdfA-onlinedemo.asp\n * http://www.pdf-tools.com/pdf/validate-pdfa-online.aspx\n *\n * In addition the 'pdftk' server can be used to analyse the output:\n * https://www.pdflabs.com/docs/pdftk-cli-examples/\n *\n * PDF page markup operators:\n * b    closepath, fill,and stroke path.\n * B    fill and stroke path.\n * b*   closepath, eofill,and stroke path.\n * B*   eofill and stroke path.\n * BI   begin image.\n * BMC  begin marked content.\n * BT   begin text object.\n * BX   begin section allowing undefined operators.\n * c    curveto.\n * cm   concat. Concatenates the matrix to the current transform.\n * cs   setcolorspace for fill.\n * CS   setcolorspace for stroke.\n * d    setdash.\n * Do   execute the named XObject.\n * DP   mark a place in the content stream, with a dictionary.\n * EI   end image.\n * EMC  end marked content.\n * ET   end text object.\n * EX   end section that allows undefined operators.\n * f    fill path.\n * f*   eofill Even/odd fill path.\n * g    setgray (fill).\n * G    setgray (stroke).\n * gs   set parameters in the extended graphics state.\n * h    closepath.\n * i    setflat.\n * ID   begin image data.\n * j    setlinejoin.\n * J    setlinecap.\n * k    setcmykcolor (fill).\n * K    setcmykcolor (stroke).\n * l    lineto.\n * m    moveto.\n * M    setmiterlimit.\n * n    end path without fill or stroke.\n * q    save graphics state.\n * Q    restore graphics state.\n * re   rectangle.\n * rg   setrgbcolor (fill).\n * RG   setrgbcolor (stroke).\n * s    closepath and stroke path.\n * S    stroke path.\n * sc   setcolor (fill).\n * SC   setcolor (stroke).\n * sh   shfill (shaded fill).\n * Tc   set character spacing.\n * Td   move text current point.\n * TD   move text current point and set leading.\n * Tf   set font name and size.\n * Tj   show text.\n * TJ   show text, allowing individual character positioning.\n * TL   set leading.\n * Tm   set text matrix.\n * Tr   set text rendering mode.\n * Ts   set super/subscripting text rise.\n * Tw   set word spacing.\n * Tz   set horizontal scaling.\n * T*   move to start of next line.\n * v    curveto.\n * w    setlinewidth.\n * W    clip.\n * y    curveto.\n */\n\n#define _POSIX_SOURCE /* For localtime_r */\n#include <sys/types.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"pdfgen.h\"\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))\n\n#define PDF_RGB_R(c) ((((c) >> 16) & 0xff) / 255.0)\n#define PDF_RGB_G(c) ((((c) >>  8) & 0xff) / 255.0)\n#define PDF_RGB_B(c) ((((c) >>  0) & 0xff) / 255.0)\n\n#if defined(_MSC_VER)\n/*\n * As stated here: http://stackoverflow.com/questions/70013/how-to-detect-if-im-compiling-code-with-visual-studio-2008\n * Visual Studio 2015 has better support for C99\n * We need to use __inline for older version.\n */\n#if _MSC_VER < 1900\n#define inline __inline\n#endif\n#endif // _MSC_VER\n\ntypedef struct pdf_object pdf_object;\n\nenum {\n    OBJ_none, /* skipped */\n    OBJ_info,\n    OBJ_stream,\n    OBJ_font,\n    OBJ_page,\n    OBJ_bookmark,\n    OBJ_outline,\n    OBJ_catalog,\n    OBJ_pages,\n    OBJ_image,\n\n    OBJ_count,\n};\n\nstruct flexarray {\n    void ***bins;\n    int item_count;\n    int bin_count;\n};\n\nstruct pdf_object {\n    int type; /* See OBJ_xxxx */\n    int index; /* PDF output index */\n    int offset; /* Byte position within the output file */\n    struct pdf_object *prev; /* Previous of this type */\n    struct pdf_object *next; /* Next of this type */\n    union {\n        struct {\n            struct pdf_object *page;\n            char name[64];\n            struct pdf_object *parent;\n            struct flexarray children;\n        } bookmark;\n        struct {\n            char *text;\n            int len;\n        } stream;\n        struct {\n            int width;\n            int height;\n            struct flexarray children;\n        } page;\n        struct pdf_info info;\n        struct {\n            char name[64];\n            int index;\n        } font;\n    };\n};\n\nstruct pdf_doc {\n    char errstr[128];\n    int errval;\n    struct flexarray objects;\n\n    int width;\n    int height;\n\n    struct pdf_object *current_font;\n\n    struct pdf_object *last_objects[OBJ_count];\n    struct pdf_object *first_objects[OBJ_count];\n};\n\n/**\n * Simple flexible resizing array implementation\n * The bins get larger in powers of two\n * bin 0 = 1024 items\n *     1 = 2048 items\n *     2 = 4096 items\n *     etc...\n */\n/* What is the first index that will be in the given bin? */\n#define MIN_SHIFT 10\n#define MIN_OFFSET ((1 << MIN_SHIFT) - 1)\nstatic int bin_offset[] = {\n    (1 << (MIN_SHIFT + 0)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 1)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 2)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 3)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 4)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 5)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 6)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 7)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 8)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 9)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 10)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 11)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 12)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 13)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 14)) - 1 - MIN_OFFSET,\n    (1 << (MIN_SHIFT + 15)) - 1 - MIN_OFFSET,\n};\n\nstatic inline int flexarray_get_bin(struct flexarray *flex, int index)\n{\n    int i;\n    (void)flex;\n    for (i = 0; i < ARRAY_SIZE(bin_offset); i++)\n        if (index < bin_offset[i])\n            return i - 1;\n    return -1;\n}\n\nstatic inline int flexarray_get_bin_size(struct flexarray *flex, int bin)\n{\n    (void)flex;\n    if (bin >= ARRAY_SIZE(bin_offset))\n        return -1;\n    int next = bin_offset[bin + 1];\n    return next - bin_offset[bin];\n}\n\nstatic inline int flexarray_get_bin_offset(struct flexarray *flex, int bin, int index)\n{\n    (void)flex;\n    return index - bin_offset[bin];\n}\n\nstatic void flexarray_clear(struct flexarray *flex)\n{\n    int i;\n    for (i = 0; i < flex->bin_count; i++)\n        free(flex->bins[i]);\n    free(flex->bins);\n    flex->bin_count = 0;\n    flex->item_count = 0;\n}\n\nstatic inline int flexarray_size(struct flexarray *flex)\n{\n    return flex->item_count;\n}\n\nstatic int flexarray_set(struct flexarray *flex, int index, void *data)\n{\n    int bin = flexarray_get_bin(flex, index);\n    if (bin < 0)\n        return -EINVAL;\n    if (bin >= flex->bin_count) {\n        void *bins = realloc(flex->bins, (flex->bin_count + 1) *\n                             sizeof(flex->bins));\n        if (!bins)\n            return -ENOMEM;\n        flex->bin_count++;\n        flex->bins = bins;\n        flex->bins[flex->bin_count - 1] =\n            calloc(flexarray_get_bin_size(flex, flex->bin_count - 1),\n                   sizeof(void *));\n        if (!flex->bins[flex->bin_count - 1]) {\n            flex->bin_count--;\n            return -ENOMEM;\n        }\n    }\n    flex->item_count++;\n    flex->bins[bin][flexarray_get_bin_offset(flex, bin, index)] = data;\n    return flex->item_count - 1;\n}\n\nstatic inline int flexarray_append(struct flexarray *flex, void *data)\n{\n    return flexarray_set(flex, flexarray_size(flex), data);\n}\n\nstatic inline void *flexarray_get(struct flexarray *flex, int index)\n{\n    int bin;\n\n    if (index >= flex->item_count)\n        return NULL;\n    bin = flexarray_get_bin(flex, index);\n    if (bin < 0 || bin >= flex->bin_count)\n        return NULL;\n    return flex->bins[bin][flexarray_get_bin_offset(flex, bin, index)];\n}\n\n/**\n * PDF Implementation\n */\n\nstatic int pdf_set_err(struct pdf_doc *doc, int errval,\n                       const char *buffer, ...)\n__attribute__ ((format(printf, 3, 4)));\nstatic int pdf_set_err(struct pdf_doc *doc, int errval,\n                       const char *buffer, ...)\n{\n    va_list ap;\n    int len;\n\n    va_start(ap, buffer);\n    len = vsnprintf(doc->errstr, sizeof(doc->errstr) - 2, buffer, ap);\n    va_end(ap);\n\n    /* Make sure we're properly terminated */\n    if (doc->errstr[len] != '\\n')\n        doc->errstr[len] = '\\n';\n    doc->errstr[len] = '\\0';\n    doc->errval = errval;\n\n    return errval;\n}\n\nconst char *pdf_get_err(struct pdf_doc *pdf, int *errval)\n{\n    if (!pdf)\n        return NULL;\n    if (pdf->errstr[0] == '\\0')\n        return NULL;\n    if (errval) *errval = pdf->errval;\n    return pdf->errstr;\n}\n\nvoid pdf_clear_err(struct pdf_doc *pdf)\n{\n    if (!pdf)\n        return;\n    pdf->errstr[0] = '\\0';\n    pdf->errval = 0;\n}\n\nstatic struct pdf_object *pdf_get_object(struct pdf_doc *pdf, int index)\n{\n    return flexarray_get(&pdf->objects, index);\n}\n\nstatic int pdf_append_object(struct pdf_doc *pdf, struct pdf_object *obj)\n{\n    int index = flexarray_append(&pdf->objects, obj);\n\n    if (index < 0)\n        return index;\n    obj->index = index;\n\n    if (pdf->last_objects[obj->type]) {\n        obj->prev = pdf->last_objects[obj->type];\n        pdf->last_objects[obj->type]->next = obj;\n    }\n    pdf->last_objects[obj->type] = obj;\n\n    if (!pdf->first_objects[obj->type])\n        pdf->first_objects[obj->type] = obj;\n\n    return 0;\n}\n\nstatic struct pdf_object *pdf_add_object(struct pdf_doc *pdf, int type)\n{\n    struct pdf_object *obj;\n\n    obj = calloc(1, sizeof(struct pdf_object));\n    if (!obj) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate object %d: %s\",\n                    flexarray_size(&pdf->objects) + 1, strerror(errno));\n        return NULL;\n    }\n\n    obj->type = type;\n\n    if (pdf_append_object(pdf, obj) < 0) {\n        free(obj);\n        return NULL;\n    }\n\n    return obj;\n}\n\nstruct pdf_doc *pdf_create(int width, int height, struct pdf_info *info)\n{\n    struct pdf_doc *pdf;\n    struct pdf_object *obj;\n\n    pdf = calloc(1, sizeof(struct pdf_doc));\n    pdf->width = width;\n    pdf->height = height;\n\n    /* We don't want to use ID 0 */\n    pdf_add_object(pdf, OBJ_none);\n\n    /* Create the 'info' object */\n    obj = pdf_add_object(pdf, OBJ_info);\n    if (info)\n        obj->info = *info;\n    /* FIXME: Should be quoting PDF strings? */\n    if (!obj->info.date[0]) {\n        time_t now = time(NULL);\n        struct tm tm;\n#ifdef _WIN32\n        struct tm *tmp;\n        tmp = localtime(&now);\n        tm = *tmp;\n#else\n        localtime_r(&now, &tm);\n#endif\n        strftime(obj->info.date, sizeof(obj->info.date),\n                 \"%Y%m%d%H%M%SZ\", &tm);\n    }\n    if (!obj->info.creator[0])\n        strcpy(obj->info.creator, \"pdfgen\");\n    if (!obj->info.producer[0])\n        strcpy(obj->info.producer, \"pdfgen\");\n    if (!obj->info.title[0])\n        strcpy(obj->info.title, \"pdfgen\");\n    if (!obj->info.author[0])\n        strcpy(obj->info.author, \"pdfgen\");\n    if (!obj->info.subject[0])\n        strcpy(obj->info.subject, \"pdfgen\");\n\n    pdf_add_object(pdf, OBJ_pages);\n    pdf_add_object(pdf, OBJ_catalog);\n\n    pdf_set_font(pdf, \"Times-Roman\");\n\n    return pdf;\n}\n\nint pdf_width(struct pdf_doc *pdf)\n{\n    return pdf->width;\n}\n\nint pdf_height(struct pdf_doc *pdf)\n{\n    return pdf->height;\n}\n\nstatic void pdf_object_destroy(struct pdf_object *object)\n{\n    switch (object->type) {\n    case OBJ_stream:\n    case OBJ_image:\n        free(object->stream.text);\n        break;\n    case OBJ_page:\n        flexarray_clear(&object->page.children);\n        break;\n    case OBJ_bookmark:\n        flexarray_clear(&object->bookmark.children);\n        break;\n    }\n    free(object);\n}\n\nvoid pdf_destroy(struct pdf_doc *pdf)\n{\n    if (pdf) {\n        int i;\n        for (i = 0; i < flexarray_size(&pdf->objects); i++)\n            pdf_object_destroy(pdf_get_object(pdf, i));\n        flexarray_clear(&pdf->objects);\n        free(pdf);\n    }\n}\n\nstatic struct pdf_object *pdf_find_first_object(struct pdf_doc *pdf,\n        int type)\n{\n    return pdf->first_objects[type];\n}\n\nstatic struct pdf_object *pdf_find_last_object(struct pdf_doc *pdf,\n        int type)\n{\n    return pdf->last_objects[type];\n}\n\nint pdf_set_font(struct pdf_doc *pdf, const char *font)\n{\n    struct pdf_object *obj;\n    int last_index = 0;\n\n    /* See if we've used this font before */\n    for (obj = pdf_find_first_object(pdf, OBJ_font); obj; obj = obj->next) {\n        if (strcmp(obj->font.name, font) == 0)\n            break;\n        last_index = obj->font.index;\n    }\n\n    /* Create a new font object if we need it */\n    if (!obj) {\n        obj = pdf_add_object(pdf, OBJ_font);\n        if (!obj)\n            return pdf->errval;\n        strncpy(obj->font.name, font, sizeof(obj->font.name));\n        obj->font.name[sizeof(obj->font.name) - 1] = '\\0';\n        obj->font.index = last_index + 1;\n    }\n\n    pdf->current_font = obj;\n\n    return 0;\n}\n\nstruct pdf_object *pdf_append_page(struct pdf_doc *pdf)\n{\n    struct pdf_object *page;\n\n    page = pdf_add_object(pdf, OBJ_page);\n\n    if (!page)\n        return NULL;\n\n    page->page.width = pdf->width;\n    page->page.height = pdf->height;\n\n    return page;\n}\n\nint pdf_page_set_size(struct pdf_doc *pdf, struct pdf_object *page, int width, int height)\n{\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n\n    if (!page || page->type != OBJ_page)\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PDF page\");\n    page->page.width = width;\n    page->page.height = height;\n    return 0;\n}\n\nstatic int pdf_save_object(struct pdf_doc *pdf, FILE *fp, int index)\n{\n    struct pdf_object *object = pdf_get_object(pdf, index);\n\n    if (object->type == OBJ_none)\n        return -ENOENT;\n\n    object->offset = ftell(fp);\n\n    fprintf(fp, \"%d 0 obj\\r\\n\", index);\n\n    switch (object->type) {\n    case OBJ_stream:\n    case OBJ_image: {\n        int len = object->stream.len ? object->stream.len :\n                  strlen(object->stream.text);\n        fwrite(object->stream.text, len, 1, fp);\n        break;\n    }\n    case OBJ_info: {\n        struct pdf_info *info = &object->info;\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"  /Creator (%s)\\r\\n\"\n                \"  /Producer (%s)\\r\\n\"\n                \"  /Title (%s)\\r\\n\"\n                \"  /Author (%s)\\r\\n\"\n                \"  /Subject (%s)\\r\\n\"\n                \"  /CreationDate (D:%s)\\r\\n\"\n                \">>\\r\\n\",\n                info->creator, info->producer, info->title,\n                info->author, info->subject, info->date);\n        break;\n    }\n\n    case OBJ_page: {\n        int i;\n        struct pdf_object *font;\n        struct pdf_object *pages = pdf_find_first_object(pdf, OBJ_pages);\n        struct pdf_object *image = pdf_find_first_object(pdf, OBJ_image);\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Page\\r\\n\"\n                \"/Parent %d 0 R\\r\\n\", pages->index);\n        fprintf(fp, \"/MediaBox [0 0 %d %d]\\r\\n\",\n                object->page.width, object->page.height);\n        fprintf(fp, \"/Resources <<\\r\\n\");\n        fprintf(fp, \"  /Font <<\\r\\n\");\n        for (font = pdf_find_first_object(pdf, OBJ_font); font; font = font->next)\n            fprintf(fp, \"    /F%d %d 0 R\\r\\n\",\n                    font->font.index, font->index);\n        fprintf(fp, \"  >>\\r\\n\");\n\n        if (image) {\n            fprintf(fp, \"  /XObject <<\");\n            for (; image; image = image->next)\n                fprintf(fp, \"/Image%d %d 0 R \", image->index, image->index);\n            fprintf(fp, \">>\\r\\n\");\n        }\n\n        fprintf(fp, \">>\\r\\n\");\n        fprintf(fp, \"/Contents [\\r\\n\");\n        for (i = 0; i < flexarray_size(&object->page.children); i++) {\n            struct pdf_object *child = flexarray_get(&object->page.children, i);\n            fprintf(fp, \"%d 0 R\\r\\n\", child->index);\n        }\n        fprintf(fp, \"]\\r\\n\");\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n\n    case OBJ_bookmark: {\n        struct pdf_object *parent, *other;\n\n        parent = object->bookmark.parent;\n        if (!parent)\n            parent = pdf_find_first_object(pdf, OBJ_outline);\n        if (!object->bookmark.page)\n            break;\n        fprintf(fp, \"<<\\r\\n\"\n                \"/A << /Type /Action\\r\\n\"\n                \"      /S /GoTo\\r\\n\"\n                \"      /D [%d 0 R /XYZ 0 %d null]\\r\\n\"\n                \"   >>\\r\\n\"\n                \"/Parent %d 0 R\\r\\n\"\n                \"/Title (%s)\\r\\n\",\n                object->bookmark.page->index,\n                pdf->height,\n                parent->index,\n                object->bookmark.name);\n        int nchildren = flexarray_size(&object->bookmark.children);\n        if (nchildren > 0) {\n            struct pdf_object *f, *l;\n            f = flexarray_get(&object->bookmark.children, 0);\n            l = flexarray_get(&object->bookmark.children, nchildren - 1);\n            fprintf(fp, \"/First %d 0 R\\r\\n\", f->index);\n            fprintf(fp, \"/Last %d 0 R\\r\\n\", l->index);\n        }\n        // Find the previous bookmark with the same parent\n        for (other = object->prev;\n                other && other->bookmark.parent != object->bookmark.parent;\n                other = other->prev)\n            ;\n        if (other)\n            fprintf(fp, \"/Prev %d 0 R\\r\\n\", other->index);\n        // Find the next bookmark with the same parent\n        for (other = object->next;\n                other && other->bookmark.parent != object->bookmark.parent;\n                other = other->next)\n            ;\n        if (other)\n            fprintf(fp, \"/Next %d 0 R\\r\\n\", other->index);\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n\n    case OBJ_outline: {\n        struct pdf_object *first, *last, *cur;\n        first = pdf_find_first_object(pdf, OBJ_bookmark);\n        last = pdf_find_last_object(pdf, OBJ_bookmark);\n\n        if (first && last) {\n            int count = 0;\n            cur = first;\n            while (cur) {\n                if (!cur->bookmark.parent)\n                    count++;\n                cur = cur->next;\n            }\n\n            /* Bookmark outline */\n            fprintf(fp, \"<<\\r\\n\"\n                    \"/Count %d\\r\\n\"\n                    \"/Type /Outlines\\r\\n\"\n                    \"/First %d 0 R\\r\\n\"\n                    \"/Last %d 0 R\\r\\n\"\n                    \">>\\r\\n\",\n                    count, first->index, last->index);\n        }\n        break;\n    }\n\n    case OBJ_font:\n        fprintf(fp, \"<<\\r\\n\"\n                \"  /Type /Font\\r\\n\"\n                \"  /Subtype /Type1\\r\\n\"\n                \"  /BaseFont /%s\\r\\n\"\n                \"  /Encoding /WinAnsiEncoding\\r\\n\"\n                \">>\\r\\n\", object->font.name);\n        break;\n\n    case OBJ_pages: {\n        struct pdf_object *page;\n        int npages = 0;\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Pages\\r\\n\"\n                \"/Kids [ \");\n        for (page = pdf_find_first_object(pdf, OBJ_page);\n                page;\n                page = page->next) {\n            npages++;\n            fprintf(fp, \"%d 0 R \", page->index);\n        }\n        fprintf(fp, \"]\\r\\n\");\n        fprintf(fp, \"/Count %d\\r\\n\", npages);\n        fprintf(fp, \">>\\r\\n\");\n        break;\n    }\n\n    case OBJ_catalog: {\n        struct pdf_object *outline = pdf_find_first_object(pdf, OBJ_outline);\n        struct pdf_object *pages = pdf_find_first_object(pdf, OBJ_pages);\n\n        fprintf(fp, \"<<\\r\\n\"\n                \"/Type /Catalog\\r\\n\");\n        if (outline)\n            fprintf(fp,\n                    \"/Outlines %d 0 R\\r\\n\"\n                    \"/PageMode /UseOutlines\\r\\n\", outline->index);\n        fprintf(fp, \"/Pages %d 0 R\\r\\n\"\n                \">>\\r\\n\",\n                pages->index);\n        break;\n    }\n\n    default:\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PDF object type %d\",\n                           object->type);\n    }\n\n    fprintf(fp, \"endobj\\r\\n\");\n\n    return 0;\n}\n\nint pdf_save(struct pdf_doc *pdf, const char *filename)\n{\n    FILE *fp;\n    int i;\n    struct pdf_object *obj;\n    int xref_offset;\n    int xref_count = 0;\n\n    if (filename == NULL)\n        fp = stdout;\n    else if ((fp = fopen(filename, \"wb\")) == NULL)\n        return pdf_set_err(pdf, -errno, \"Unable to open '%s': %s\",\n                           filename, strerror(errno));\n\n    fprintf(fp, \"%%PDF-1.2\\r\\n\");\n    /* Hibit bytes */\n    fprintf(fp, \"%c%c%c%c%c\\r\\n\", 0x25, 0xc7, 0xec, 0x8f, 0xa2);\n\n    /* Dump all the objects & get their file offsets */\n    for (i = 0; i < flexarray_size(&pdf->objects); i++)\n        if (pdf_save_object(pdf, fp, i) >= 0)\n            xref_count++;\n\n    /* xref */\n    xref_offset = ftell(fp);\n    fprintf(fp, \"xref\\r\\n\");\n    fprintf(fp, \"0 %d\\r\\n\", xref_count + 1);\n    fprintf(fp, \"0000000000 65535 f\\r\\n\");\n    for (i = 0; i < flexarray_size(&pdf->objects); i++) {\n        obj = pdf_get_object(pdf, i);\n        if (obj->type != OBJ_none)\n            fprintf(fp, \"%10.10d 00000 n\\r\\n\",\n                    obj->offset);\n    }\n\n    fprintf(fp, \"trailer\\r\\n\"\n            \"<<\\r\\n\"\n            \"/Size %d\\r\\n\", xref_count + 1);\n    obj = pdf_find_first_object(pdf, OBJ_catalog);\n    fprintf(fp, \"/Root %d 0 R\\r\\n\", obj->index);\n    obj = pdf_find_first_object(pdf, OBJ_info);\n    fprintf(fp, \"/Info %d 0 R\\r\\n\", obj->index);\n    /* FIXME: Not actually generating a unique ID */\n    fprintf(fp, \"/ID [<%16.16x> <%16.16x>]\\r\\n\", 0x123, 0x123);\n    fprintf(fp, \">>\\r\\n\"\n            \"startxref\\r\\n\");\n    fprintf(fp, \"%d\\r\\n\", xref_offset);\n    fprintf(fp, \"%%%%EOF\\r\\n\");\n    fclose(fp);\n\n    return 0;\n}\n\nstatic int pdf_add_stream(struct pdf_doc *pdf, struct pdf_object *page,\n                          char *buffer)\n{\n    struct pdf_object *obj;\n    int len;\n    char prefix[128];\n    char suffix[128];\n\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL, \"Invalid pdf page\");\n\n    len = strlen(buffer);\n    /* We don't want any trailing whitespace in the stream */\n    while (len >= 1 && (buffer[len - 1] == '\\r' ||\n                        buffer[len - 1] == '\\n')) {\n        buffer[len - 1] = '\\0';\n        len--;\n    }\n\n    sprintf(prefix, \"<< /Length %d >>stream\\r\\n\", len);\n    sprintf(suffix, \"\\r\\nendstream\\r\\n\");\n    len += strlen(prefix) + strlen(suffix);\n\n    obj = pdf_add_object(pdf, OBJ_stream);\n    if (!obj)\n        return pdf->errval;\n    obj->stream.text = malloc(len + 1);\n    if (!obj->stream.text) {\n        obj->type = OBJ_none;\n        return pdf_set_err(pdf, -ENOMEM, \"Insufficient memory for text (%d bytes)\",\n                           len + 1);\n    }\n    obj->stream.text[0] = '\\0';\n    strcat(obj->stream.text, prefix);\n    strcat(obj->stream.text, buffer);\n    strcat(obj->stream.text, suffix);\n    obj->stream.len = 0;\n\n    return flexarray_append(&page->page.children, obj);\n}\n\nint pdf_add_bookmark(struct pdf_doc *pdf, struct pdf_object *page,\n                     int parent, const char *name)\n{\n    struct pdf_object *obj;\n\n    if (!page)\n        page = pdf_find_last_object(pdf, OBJ_page);\n\n    if (!page)\n        return pdf_set_err(pdf, -EINVAL,\n                           \"Unable to add bookmark, no pages available\");\n\n    if (!pdf_find_first_object(pdf, OBJ_outline))\n        if (!pdf_add_object(pdf, OBJ_outline))\n            return pdf->errval;\n\n    obj = pdf_add_object(pdf, OBJ_bookmark);\n    if (!obj)\n        return pdf->errval;\n\n    strncpy(obj->bookmark.name, name, sizeof(obj->bookmark.name));\n    obj->bookmark.name[sizeof(obj->bookmark.name) - 1] = '\\0';\n    obj->bookmark.page = page;\n    if (parent >= 0) {\n        struct pdf_object *parent_obj = pdf_get_object(pdf, parent);\n        if (!parent_obj)\n            return pdf_set_err(pdf, -EINVAL,\n                               \"Invalid parent ID %d supplied\", parent);\n        obj->bookmark.parent = parent_obj;\n        flexarray_append(&parent_obj->bookmark.children, obj);\n    }\n\n    return obj->index;\n}\n\nstruct dstr {\n    char *data;\n    int alloc_len;\n    int used_len;\n};\n\nstatic int dstr_ensure(struct dstr *str, int len)\n{\n    if (str->alloc_len < len) {\n        int new_len = len + 4096;\n        char *new_data = realloc(str->data, new_len);\n        if (!new_data)\n            return -ENOMEM;\n        str->data = new_data;\n        str->alloc_len = new_len;\n    }\n    return 0;\n}\n\nstatic int dstr_printf(struct dstr *str, const char *fmt, ...)\n__attribute__((format(printf,2,3)));\nstatic int dstr_printf(struct dstr *str, const char *fmt, ...)\n{\n    va_list ap, aq;\n    int len;\n\n    va_start(ap, fmt);\n    va_copy(aq, ap);\n    len = vsnprintf(NULL, 0, fmt, ap);\n    if (dstr_ensure(str, str->used_len + len + 1) < 0) {\n        va_end(ap);\n        va_end(aq);\n        return -ENOMEM;\n    }\n    vsprintf(&str->data[str->used_len], fmt, aq);\n    str->used_len += len;\n    va_end(ap);\n    va_end(aq);\n\n    return len;\n}\n\nstatic int dstr_append(struct dstr *str, const char *extend)\n{\n    int len = strlen(extend);\n    if (dstr_ensure(str, str->used_len + len + 1) < 0)\n        return -ENOMEM;\n    strcpy(&str->data[str->used_len], extend);\n    str->used_len += len;\n    return len;\n}\n\nstatic void dstr_free(struct dstr *str)\n{\n    free(str->data);\n}\n\nstatic int utf8_to_utf32(const char *utf8, int len, uint32_t *utf32)\n{\n    uint32_t ch = *utf8;\n    int i;\n    uint8_t mask;\n\n    if ((ch & 0x80) == 0) {\n        len = 1;\n        mask = 0x7f;\n    } else if ((ch & 0xe0) == 0xc0 && len >= 2) {\n        len = 2;\n        mask = 0x1f;\n    } else if ((ch & 0xf0) == 0xe0 && len >= 3) {\n        len = 3;\n        mask = 0xf;\n    } else if ((ch & 0xf8) == 0xf0 && len >= 4) {\n        len = 4;\n        mask = 0x7;\n    } else\n        return -EINVAL;\n\n    ch = 0;\n    for (i = 0; i < len; i++) {\n        int shift = (len - i - 1) * 6;\n        if (i == 0)\n            ch |= ((uint32_t)(*utf8++) & mask) << shift;\n        else\n            ch |= ((uint32_t)(*utf8++) & 0x3f) << shift;\n    }\n\n    *utf32 = ch;\n\n    return len;\n}\n\nint pdf_add_text(struct pdf_doc *pdf, struct pdf_object *page,\n                 const char *text, int size, int xoff, int yoff,\n                 uint32_t colour)\n{\n    int i, ret;\n    int len = text ? strlen(text) : 0;\n    struct dstr str = {0, 0, 0};\n\n    /* Don't bother adding empty/null strings */\n    if (!len)\n        return 0;\n\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%d %d TD \", xoff, yoff);\n    dstr_printf(&str, \"/F%d %d Tf \",\n                pdf->current_font->font.index, size);\n    dstr_printf(&str, \"%f %f %f rg \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_append(&str, \"(\");\n\n    /* Escape magic characters properly */\n    for (i = 0; i < len; ) {\n        uint32_t code;\n        int code_len;\n        code_len = utf8_to_utf32(&text[i], len - i, &code);\n        if (code_len < 0) {\n            dstr_free(&str);\n            return pdf_set_err(pdf, -EINVAL, \"Invalid UTF-8 encoding\");\n        }\n\n        if (code > 255) {\n            /* We support *some* minimal UTF-8 characters */\n            char buf[5] = {0};\n            switch (code) {\n            case 0x160:\n                buf[0] = (char)0x8a;\n                break;\n            case 0x161:\n                buf[0] = (char)0x9a;\n                break;\n            case 0x17d:\n                buf[0] = (char)0x8e;\n                break;\n            case 0x17e:\n                buf[0] = (char)0x9e;\n                break;\n            case 0x20ac:\n                strcpy(buf, \"\\\\200\");\n                break;\n            default:\n                dstr_free(&str);\n                return pdf_set_err(pdf, -EINVAL, \"Unsupported UTF-8 character: 0x%x 0o%o\", code, code);\n            }\n            dstr_append(&str, buf);\n        } else if (strchr(\"()\\\\\", code)) {\n            char buf[3];\n            /* Escape some characters */\n            buf[0] = '\\\\';\n            buf[1] = code;\n            buf[2] = '\\0';\n            dstr_append(&str, buf);\n        } else if (strrchr(\"\\n\\r\\t\\b\\f\", code)) {\n            /* Skip over these characters */\n            ;\n        } else {\n            char buf[2];\n            buf[0] = code;\n            buf[1] = '\\0';\n            dstr_append(&str, buf);\n        }\n\n        i += code_len;\n    }\n    dstr_append(&str, \") Tj \");\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n    return ret;\n}\n\n/* How wide is each character, in points, at size 14 */\nstatic const uint16_t helvetica_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 355, 556, 556, 889, 667, 191,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 278, 278, 584, 584, 584, 556,\n    1015, 667, 667, 722, 722, 667, 611, 778,\n    722, 278, 500, 667, 556, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 278, 278, 278, 469, 556,\n    333, 556, 556, 500, 556, 556, 278, 556,\n    556, 222, 222, 500, 222, 833, 556, 556,\n    556, 556, 333, 500, 278, 556, 500, 722,\n    500, 500, 500, 334, 260, 334, 584, 350,\n    556, 350, 222, 556, 333, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 222, 222, 333, 333, 350, 556, 1000,\n    333, 1000, 500, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 260, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 556, 537, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    667, 667, 667, 667, 667, 667, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 500,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 584,\n    611, 556, 556, 556, 556, 500, 556, 500\n};\n\nstatic const uint16_t helvetica_bold_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 333, 474, 556, 556, 889, 722, 238,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 333, 333, 584, 584, 584, 611,\n    975, 722, 722, 722, 722, 667, 611, 778,\n    722, 278, 556, 722, 611, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 333, 278, 333, 584, 556,\n    333, 556, 611, 556, 611, 556, 333, 611,\n    611, 278, 278, 556, 278, 889, 611, 611,\n    611, 611, 389, 556, 333, 611, 556, 778,\n    556, 556, 500, 389, 280, 389, 584, 350,\n    556, 350, 278, 556, 500, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 278, 278, 500, 500, 350, 556, 1000,\n    333, 1000, 556, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 280, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 611, 556, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 556,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    611, 611, 611, 611, 611, 611, 611, 584,\n    611, 611, 611, 611, 611, 556, 611, 556\n};\n\nstatic uint16_t helvetica_bold_oblique_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 333, 474, 556, 556, 889, 722, 238,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 333, 333, 584, 584, 584, 611,\n    975, 722, 722, 722, 722, 667, 611, 778,\n    722, 278, 556, 722, 611, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 333, 278, 333, 584, 556,\n    333, 556, 611, 556, 611, 556, 333, 611,\n    611, 278, 278, 556, 278, 889, 611, 611,\n    611, 611, 389, 556, 333, 611, 556, 778,\n    556, 556, 500, 389, 280, 389, 584, 350,\n    556, 350, 278, 556, 500, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 278, 278, 500, 500, 350, 556, 1000,\n    333, 1000, 556, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 280, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 611, 556, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 556,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    611, 611, 611, 611, 611, 611, 611, 584,\n    611, 611, 611, 611, 611, 556, 611, 556\n};\n\nstatic uint16_t helvetica_oblique_widths[256] = {\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 278, 278, 278, 278, 278, 278,\n    278, 278, 355, 556, 556, 889, 667, 191,\n    333, 333, 389, 584, 278, 333, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 556,\n    556, 556, 278, 278, 584, 584, 584, 556,\n    1015, 667, 667, 722, 722, 667, 611, 778,\n    722, 278, 500, 667, 556, 833, 722, 778,\n    667, 778, 722, 667, 611, 722, 667, 944,\n    667, 667, 611, 278, 278, 278, 469, 556,\n    333, 556, 556, 500, 556, 556, 278, 556,\n    556, 222, 222, 500, 222, 833, 556, 556,\n    556, 556, 333, 500, 278, 556, 500, 722,\n    500, 500, 500, 334, 260, 334, 584, 350,\n    556, 350, 222, 556, 333, 1000, 556, 556,\n    333, 1000, 667, 333, 1000, 350, 611, 350,\n    350, 222, 222, 333, 333, 350, 556, 1000,\n    333, 1000, 500, 333, 944, 350, 500, 667,\n    278, 333, 556, 556, 556, 556, 260, 556,\n    333, 737, 370, 556, 584, 333, 737, 333,\n    400, 584, 333, 333, 333, 556, 537, 278,\n    333, 333, 365, 556, 834, 834, 834, 611,\n    667, 667, 667, 667, 667, 667, 1000, 722,\n    667, 667, 667, 667, 278, 278, 278, 278,\n    722, 722, 778, 778, 778, 778, 778, 584,\n    778, 722, 722, 722, 722, 667, 667, 611,\n    556, 556, 556, 556, 556, 556, 889, 500,\n    556, 556, 556, 556, 278, 278, 278, 278,\n    556, 556, 556, 556, 556, 556, 556, 584,\n    611, 556, 556, 556, 556, 500, 556, 500\n};\n\nstatic uint16_t symbol_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 713, 500, 549, 833, 778, 439,\n    333, 333, 500, 549, 250, 549, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 278, 278, 549, 549, 549, 444,\n    549, 722, 667, 722, 612, 611, 763, 603,\n    722, 333, 631, 722, 686, 889, 722, 722,\n    768, 741, 556, 592, 611, 690, 439, 768,\n    645, 795, 611, 333, 863, 333, 658, 500,\n    500, 631, 549, 549, 494, 439, 521, 411,\n    603, 329, 603, 549, 549, 576, 521, 549,\n    549, 521, 549, 603, 439, 576, 713, 686,\n    493, 686, 494, 480, 200, 480, 549, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    750, 620, 247, 549, 167, 713, 500, 753,\n    753, 753, 753, 1042, 987, 603, 987, 603,\n    400, 549, 411, 549, 549, 713, 494, 460,\n    549, 549, 549, 549, 1000, 603, 1000, 658,\n    823, 686, 795, 987, 768, 768, 823, 768,\n    768, 713, 713, 713, 713, 713, 713, 713,\n    768, 713, 790, 790, 890, 823, 549, 250,\n    713, 603, 603, 1042, 987, 603, 987, 603,\n    494, 329, 790, 790, 786, 713, 384, 384,\n    384, 384, 384, 384, 494, 494, 494, 494,\n    0, 329, 274, 686, 686, 686, 384, 384,\n    384, 384, 384, 384, 494, 494, 494, 0\n};\n\nstatic uint16_t times_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 408, 500, 500, 833, 778, 180,\n    333, 333, 500, 564, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 278, 278, 564, 564, 564, 444,\n    921, 722, 667, 667, 722, 611, 556, 722,\n    722, 333, 389, 722, 611, 889, 722, 722,\n    556, 722, 667, 556, 611, 722, 722, 944,\n    722, 722, 611, 333, 278, 333, 469, 500,\n    333, 444, 500, 444, 500, 444, 333, 500,\n    500, 278, 278, 500, 278, 778, 500, 500,\n    500, 500, 333, 389, 278, 500, 500, 722,\n    500, 500, 444, 480, 200, 480, 541, 350,\n    500, 350, 333, 500, 444, 1000, 500, 500,\n    333, 1000, 556, 333, 889, 350, 611, 350,\n    350, 333, 333, 444, 444, 350, 500, 1000,\n    333, 980, 389, 333, 722, 350, 444, 722,\n    250, 333, 500, 500, 500, 500, 200, 500,\n    333, 760, 276, 500, 564, 333, 760, 333,\n    400, 564, 300, 300, 333, 500, 453, 250,\n    333, 300, 310, 500, 750, 750, 750, 444,\n    722, 722, 722, 722, 722, 722, 889, 667,\n    611, 611, 611, 611, 333, 333, 333, 333,\n    722, 722, 722, 722, 722, 722, 722, 564,\n    722, 722, 722, 722, 722, 722, 556, 500,\n    444, 444, 444, 444, 444, 444, 667, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 500, 500, 500, 500, 500, 500, 564,\n    500, 500, 500, 500, 500, 500, 500, 500\n};\n\nstatic uint16_t times_bold_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 555, 500, 500, 1000, 833, 278,\n    333, 333, 500, 570, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 570, 570, 570, 500,\n    930, 722, 667, 722, 722, 667, 611, 778,\n    778, 389, 500, 778, 667, 944, 722, 778,\n    611, 778, 722, 556, 667, 722, 722, 1000,\n    722, 722, 667, 333, 278, 333, 581, 500,\n    333, 500, 556, 444, 556, 444, 333, 500,\n    556, 278, 333, 556, 278, 833, 556, 500,\n    556, 556, 444, 389, 333, 556, 500, 722,\n    500, 500, 444, 394, 220, 394, 520, 350,\n    500, 350, 333, 500, 500, 1000, 500, 500,\n    333, 1000, 556, 333, 1000, 350, 667, 350,\n    350, 333, 333, 500, 500, 350, 500, 1000,\n    333, 1000, 389, 333, 722, 350, 444, 722,\n    250, 333, 500, 500, 500, 500, 220, 500,\n    333, 747, 300, 500, 570, 333, 747, 333,\n    400, 570, 300, 300, 333, 556, 540, 250,\n    333, 300, 330, 500, 750, 750, 750, 500,\n    722, 722, 722, 722, 722, 722, 1000, 722,\n    667, 667, 667, 667, 389, 389, 389, 389,\n    722, 722, 778, 778, 778, 778, 778, 570,\n    778, 722, 722, 722, 722, 722, 611, 556,\n    500, 500, 500, 500, 500, 500, 722, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 556, 500, 500, 500, 500, 500, 570,\n    500, 556, 556, 556, 556, 500, 556, 500\n} ;\n\nstatic uint16_t times_bold_italic_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 389, 555, 500, 500, 833, 778, 278,\n    333, 333, 500, 570, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 570, 570, 570, 500,\n    832, 667, 667, 667, 722, 667, 667, 722,\n    778, 389, 500, 667, 611, 889, 722, 722,\n    611, 722, 667, 556, 611, 722, 667, 889,\n    667, 611, 611, 333, 278, 333, 570, 500,\n    333, 500, 500, 444, 500, 444, 333, 500,\n    556, 278, 278, 500, 278, 778, 556, 500,\n    500, 500, 389, 389, 278, 556, 444, 667,\n    500, 444, 389, 348, 220, 348, 570, 350,\n    500, 350, 333, 500, 500, 1000, 500, 500,\n    333, 1000, 556, 333, 944, 350, 611, 350,\n    350, 333, 333, 500, 500, 350, 500, 1000,\n    333, 1000, 389, 333, 722, 350, 389, 611,\n    250, 389, 500, 500, 500, 500, 220, 500,\n    333, 747, 266, 500, 606, 333, 747, 333,\n    400, 570, 300, 300, 333, 576, 500, 250,\n    333, 300, 300, 500, 750, 750, 750, 500,\n    667, 667, 667, 667, 667, 667, 944, 667,\n    667, 667, 667, 667, 389, 389, 389, 389,\n    722, 722, 722, 722, 722, 722, 722, 570,\n    722, 722, 722, 722, 722, 611, 611, 500,\n    500, 500, 500, 500, 500, 500, 722, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 556, 500, 500, 500, 500, 500, 570,\n    500, 556, 556, 556, 556, 444, 500, 444\n};\n\nstatic uint16_t times_italic_widths[256] = {\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 250, 250, 250, 250, 250, 250, 250,\n    250, 333, 420, 500, 500, 833, 778, 214,\n    333, 333, 500, 675, 250, 333, 250, 278,\n    500, 500, 500, 500, 500, 500, 500, 500,\n    500, 500, 333, 333, 675, 675, 675, 500,\n    920, 611, 611, 667, 722, 611, 611, 722,\n    722, 333, 444, 667, 556, 833, 667, 722,\n    611, 722, 611, 500, 556, 722, 611, 833,\n    611, 556, 556, 389, 278, 389, 422, 500,\n    333, 500, 500, 444, 500, 444, 278, 500,\n    500, 278, 278, 444, 278, 722, 500, 500,\n    500, 500, 389, 389, 278, 500, 444, 667,\n    444, 444, 389, 400, 275, 400, 541, 350,\n    500, 350, 333, 500, 556, 889, 500, 500,\n    333, 1000, 500, 333, 944, 350, 556, 350,\n    350, 333, 333, 556, 556, 350, 500, 889,\n    333, 980, 389, 333, 667, 350, 389, 556,\n    250, 389, 500, 500, 500, 500, 275, 500,\n    333, 760, 276, 500, 675, 333, 760, 333,\n    400, 675, 300, 300, 333, 500, 523, 250,\n    333, 300, 310, 500, 750, 750, 750, 500,\n    611, 611, 611, 611, 611, 611, 889, 667,\n    611, 611, 611, 611, 333, 333, 333, 333,\n    722, 667, 722, 722, 722, 722, 722, 675,\n    722, 722, 722, 722, 722, 556, 611, 500,\n    500, 500, 500, 500, 500, 500, 667, 444,\n    444, 444, 444, 444, 278, 278, 278, 278,\n    500, 500, 500, 500, 500, 500, 500, 675,\n    500, 500, 500, 500, 500, 444, 500, 444\n};\n\nstatic uint16_t zapfdingbats_widths[256] = {\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    278, 974, 961, 974, 980, 719, 789, 790,\n    791, 690, 960, 939, 549, 855, 911, 933,\n    911, 945, 974, 755, 846, 762, 761, 571,\n    677, 763, 760, 759, 754, 494, 552, 537,\n    577, 692, 786, 788, 788, 790, 793, 794,\n    816, 823, 789, 841, 823, 833, 816, 831,\n    923, 744, 723, 749, 790, 792, 695, 776,\n    768, 792, 759, 707, 708, 682, 701, 826,\n    815, 789, 789, 707, 687, 696, 689, 786,\n    787, 713, 791, 785, 791, 873, 761, 762,\n    762, 759, 759, 892, 892, 788, 784, 438,\n    138, 277, 415, 392, 392, 668, 668, 0,\n    390, 390, 317, 317, 276, 276, 509, 509,\n    410, 410, 234, 234, 334, 334, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0,\n    0, 732, 544, 544, 910, 667, 760, 760,\n    776, 595, 694, 626, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 788, 788, 788, 788,\n    788, 788, 788, 788, 894, 838, 1016, 458,\n    748, 924, 748, 918, 927, 928, 928, 834,\n    873, 828, 924, 924, 917, 930, 931, 463,\n    883, 836, 836, 867, 867, 696, 696, 874,\n    0, 874, 760, 946, 771, 865, 771, 888,\n    967, 888, 831, 873, 927, 970, 918, 0\n};\n\nstatic uint16_t courier_widths[256] = {\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n    600, 600, 600, 600, 600, 600, 600, 600,\n};\n\nstatic int pdf_text_pixel_width(const char *text, int text_len, int size,\n                                const uint16_t *widths)\n{\n    int i;\n    int len = 0;\n    if (text_len < 0)\n        text_len = strlen(text);\n\n    for (i = 0; i < text_len; i++)\n        len += widths[(uint8_t)text[i]];\n\n    /* Our widths arrays are for 14pt fonts */\n    return len * size / (14 * 72);\n}\n\nstatic const uint16_t *find_font_widths(const char *font_name)\n{\n    if (strcmp(font_name, \"Helvetica\") == 0)\n        return helvetica_widths;\n    if (strcmp(font_name, \"Helvetica-Bold\") == 0)\n        return helvetica_bold_widths;\n    if (strcmp(font_name, \"Helvetica-BoldOblique\") == 0)\n        return helvetica_bold_oblique_widths;\n    if (strcmp(font_name, \"Helvetica-Oblique\") == 0)\n        return helvetica_oblique_widths;\n    if (strcmp(font_name, \"Courier\") == 0 ||\n            strcmp(font_name, \"Courier-Bold\") == 0 ||\n            strcmp(font_name, \"Courier-BoldOblique\") == 0 ||\n            strcmp(font_name, \"Courier-Oblique\") == 0)\n        return courier_widths;\n    if (strcmp(font_name, \"Times-Roman\") == 0)\n        return times_widths;\n    if (strcmp(font_name, \"Times-Bold\") == 0)\n        return times_bold_widths;\n    if (strcmp(font_name, \"Times-Italic\") == 0)\n        return times_italic_widths;\n    if (strcmp(font_name, \"Times-BoldItalic\") == 0)\n        return times_bold_italic_widths;\n    if (strcmp(font_name, \"Symbol\") == 0)\n        return symbol_widths;\n    if (strcmp(font_name, \"ZapfDingbats\") == 0)\n        return zapfdingbats_widths;\n\n    return NULL;\n}\n\nint pdf_get_font_text_width(struct pdf_doc *pdf, const char *font_name,\n                            const char *text, int size)\n{\n    const uint16_t *widths = find_font_widths(font_name);\n\n    if (!widths)\n        return pdf_set_err(pdf, -EINVAL, \"Unable to determine width for font '%s'\",\n                           pdf->current_font->font.name);\n    return pdf_text_pixel_width(text, -1, size, widths);\n}\n\nstatic const char *find_word_break(const char *string)\n{\n    /* Skip over the actual word */\n    while (string && *string && !isspace(*string))\n        string++;\n\n    return string;\n}\n\nint pdf_add_text_wrap(struct pdf_doc *pdf, struct pdf_object *page,\n                      const char *text, int size, int xoff, int yoff,\n                      uint32_t colour, int wrap_width)\n{\n    /* Move through the text string, stopping at word boundaries,\n     * trying to find the longest text string we can fit in the given width\n     */\n    const char *start = text;\n    const char *last_best = text;\n    const char *end = text;\n    char line[512];\n    const uint16_t *widths;\n    int orig_yoff = yoff;\n\n    widths = find_font_widths(pdf->current_font->font.name);\n    if (!widths)\n        return pdf_set_err(pdf, -EINVAL, \"Unable to determine width for font '%s'\",\n                           pdf->current_font->font.name);\n\n    while (start && *start) {\n        const char *new_end = find_word_break(end + 1);\n        int line_width;\n        int output = 0;\n\n        end = new_end;\n\n        line_width = pdf_text_pixel_width(start, end - start, size, widths);\n\n        if (line_width >= wrap_width) {\n            if (last_best == start) {\n                /* There is a single word that is too long for the line */\n                int i;\n                /* Find the best character to chop it at */\n                for (i = end - start - 1; i > 0; i--)\n                    if (pdf_text_pixel_width(start, i, size, widths) < wrap_width)\n                        break;\n\n                end = start + i;\n            } else\n                end = last_best;\n            output = 1;\n        }\n        if (*end == '\\0')\n            output = 1;\n\n        if (*end == '\\n' || *end == '\\r')\n            output = 1;\n\n        if (output) {\n            int len = end - start;\n            strncpy(line, start, len);\n            line[len] = '\\0';\n            pdf_add_text(pdf, page, line, size, xoff, yoff, colour);\n\n            if (*end == ' ')\n                end++;\n\n            start = last_best = end;\n            yoff -= size;\n        } else\n            last_best = end;\n    }\n\n    return orig_yoff - yoff;\n}\n\n\nint pdf_add_line(struct pdf_doc *pdf, struct pdf_object *page,\n                 int x1, int y1, int x2, int y2, int width, uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT\\r\\n\");\n    dstr_printf(&str, \"%d w\\r\\n\", width);\n    dstr_printf(&str, \"%d %d m\\r\\n\", x1, y1);\n    dstr_printf(&str, \"/DeviceRGB CS\\r\\n\");\n    dstr_printf(&str, \"%f %f %f RG\\r\\n\",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d %d l S\\r\\n\", x2, y2);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nint pdf_add_circle(struct pdf_doc *pdf, struct pdf_object *page,\n                   int x, int y, int radius, int width, uint32_t colour, bool filled)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT \");\n    if (filled)\n        dstr_printf(&str, \"%f %f %f rg \",\n                    PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    else\n        dstr_printf(&str, \"%f %f %f RG \",\n                    PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", width);\n    /* This is a bit of a rough approximation of a circle based on bezier curves.\n     * It's not exact\n     */\n    dstr_printf(&str, \"%d %d m \", x + radius, y);\n    dstr_printf(&str, \"%d %d %d %d v \", x + radius, y + radius, x, y + radius);\n    dstr_printf(&str, \"%d %d %d %d v \", x - radius, y + radius, x - radius, y);\n    dstr_printf(&str, \"%d %d %d %d v \", x - radius, y - radius, x, y - radius);\n    dstr_printf(&str, \"%d %d %d %d v \", x + radius, y - radius, x + radius, y);\n    if (filled)\n        dstr_append(&str, \"f \");\n    else\n        dstr_append(&str, \"S \");\n    dstr_append(&str, \"ET\");\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nint pdf_add_rectangle(struct pdf_doc *pdf, struct pdf_object *page,\n                      int x, int y, int width, int height, int border_width,\n                      uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%f %f %f RG \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", border_width);\n    dstr_printf(&str, \"%d %d %d %d re S \", x, y, width, height);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nint pdf_add_filled_rectangle(struct pdf_doc *pdf, struct pdf_object *page,\n                             int x, int y, int width, int height,\n                             int border_width, uint32_t colour)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"BT \");\n    dstr_printf(&str, \"%f %f %f rg \",\n                PDF_RGB_R(colour), PDF_RGB_G(colour), PDF_RGB_B(colour));\n    dstr_printf(&str, \"%d w \", border_width);\n    dstr_printf(&str, \"%d %d %d %d re f \", x, y, width, height);\n    dstr_append(&str, \"ET\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n\n    return ret;\n}\n\nstatic const struct {\n    uint32_t code;\n    char ch;\n} code_128a_encoding[] = {\n    {0x212222, ' '},\n    {0x222122, '!'},\n    {0x222221, '\"'},\n    {0x121223, '#'},\n    {0x121322, '$'},\n    {0x131222, '%'},\n    {0x122213, '&'},\n    {0x122312, '\\''},\n    {0x132212, '('},\n    {0x221213, ')'},\n    {0x221312, '*'},\n    {0x231212, '+'},\n    {0x112232, ','},\n    {0x122132, '-'},\n    {0x122231, '.'},\n    {0x113222, '/'},\n    {0x123122, '0'},\n    {0x123221, '1'},\n    {0x223211, '2'},\n    {0x221132, '3'},\n    {0x221231, '4'},\n    {0x213212, '5'},\n    {0x223112, '6'},\n    {0x312131, '7'},\n    {0x311222, '8'},\n    {0x321122, '9'},\n    {0x321221, ':'},\n    {0x312212, ';'},\n    {0x322112, '<'},\n    {0x322211, '='},\n    {0x212123, '>'},\n    {0x212321, '?'},\n    {0x232121, '@'},\n    {0x111323, 'A'},\n    {0x131123, 'B'},\n    {0x131321, 'C'},\n    {0x112313, 'D'},\n    {0x132113, 'E'},\n    {0x132311, 'F'},\n    {0x211313, 'G'},\n    {0x231113, 'H'},\n    {0x231311, 'I'},\n    {0x112133, 'J'},\n    {0x112331, 'K'},\n    {0x132131, 'L'},\n    {0x113123, 'M'},\n    {0x113321, 'N'},\n    {0x133121, 'O'},\n    {0x313121, 'P'},\n    {0x211331, 'Q'},\n    {0x231131, 'R'},\n    {0x213113, 'S'},\n    {0x213311, 'T'},\n    {0x213131, 'U'},\n    {0x311123, 'V'},\n    {0x311321, 'W'},\n    {0x331121, 'X'},\n    {0x312113, 'Y'},\n    {0x312311, 'Z'},\n    {0x332111, '['},\n    {0x314111, '\\\\'},\n    {0x221411, ']'},\n    {0x431111, '^'},\n    {0x111224, '_'},\n    {0x111422, '`'},\n    {0x121124, 'a'},\n    {0x121421, 'b'},\n    {0x141122, 'c'},\n    {0x141221, 'd'},\n    {0x112214, 'e'},\n    {0x112412, 'f'},\n    {0x122114, 'g'},\n    {0x122411, 'h'},\n    {0x142112, 'i'},\n    {0x142211, 'j'},\n    {0x241211, 'k'},\n    {0x221114, 'l'},\n    {0x413111, 'm'},\n    {0x241112, 'n'},\n    {0x134111, 'o'},\n    {0x111242, 'p'},\n    {0x121142, 'q'},\n    {0x121241, 'r'},\n    {0x114212, 's'},\n    {0x124112, 't'},\n    {0x124211, 'u'},\n    {0x411212, 'v'},\n    {0x421112, 'w'},\n    {0x421211, 'x'},\n    {0x212141, 'y'},\n    {0x214121, 'z'},\n    {0x412121, '{'},\n    {0x111143, '|'},\n    {0x111341, '}'},\n    {0x131141, '~'},\n    {0x114113, '\\0'},\n    {0x114311, '\\0'},\n    {0x411113, '\\0'},\n    {0x411311, '\\0'},\n    {0x113141, '\\0'},\n    {0x114131, '\\0'},\n    {0x311141, '\\0'},\n    {0x411131, '\\0'},\n    {0x211412, '\\0'},\n    {0x211214, '\\0'},\n    {0x211232, '\\0'},\n    {0x2331112, '\\0'},\n};\n\nstatic int find_128_encoding(char ch)\n{\n    int i;\n    for (i = 0; i < ARRAY_SIZE(code_128a_encoding); i++) {\n        if (code_128a_encoding[i].ch == ch)\n            return i;\n    }\n    return -1;\n}\n\nstatic int pdf_barcode_128a_ch(struct pdf_doc *pdf, struct pdf_object *page,\n                               int x, int y, int width, int height,\n                               uint32_t colour, int index, int code_len)\n{\n    uint32_t code = code_128a_encoding[index].code;\n    int i;\n    int line_width = width / 11;\n\n    for (i = 0; i < code_len; i++) {\n        uint8_t shift = (code_len - 1 - i) * 4;\n        uint8_t mask = (code >> shift) & 0xf;\n\n        if (!(i % 2)) {\n            int j;\n            for (j = 0; j < mask; j++) {\n                pdf_add_line(pdf, page, x, y, x, y + height, line_width, colour);\n                x += line_width;\n            }\n        } else\n            x += line_width * mask;\n    }\n    return x;\n}\n\nstatic int pdf_add_barcode_128a(struct pdf_doc *pdf, struct pdf_object *page,\n                                int x, int y, int width, int height,\n                                const char *string, uint32_t colour)\n{\n    const char *s;\n    int len = strlen(string) + 3;\n    int char_width = width / len;\n    int checksum, i;\n\n    for (s = string; *s; s++)\n        if (find_128_encoding(*s) < 0)\n            return pdf_set_err(pdf, -EINVAL, \"Invalid barcode character 0x%x\", *s);\n\n    x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, 104,\n                            6);\n    checksum = 104;\n\n    for (i = 1, s = string; *s; s++, i++) {\n        int index = find_128_encoding(*s);\n        x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, index,\n                                6);\n        checksum += index * i;\n    }\n    x = pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour,\n                            checksum % 103, 6);\n    pdf_barcode_128a_ch(pdf, page, x, y, char_width, height, colour, 106,\n                        7);\n    return 0;\n}\n\n/* Code 39 character encoding. Each 4-bit value indicates:\n * 0 => wide bar\n * 1 => narrow bar\n * 2 => wide space\n */\nstatic const struct {\n    uint32_t code;\n    char ch;\n} code_39_encoding[] = {\n    {0x012110, '1'},\n    {0x102110, '2'},\n    {0x002111, '3'},\n    {0x112010, '4'},\n    {0x012011, '5'},\n    {0x102011, '6'},\n    {0x112100, '7'},\n    {0x012101, '8'},\n    {0x102101, '9'},\n    {0x112001, '0'},\n    {0x011210, 'A'},\n    {0x101210, 'B'},\n    {0x001211, 'C'},\n    {0x110210, 'D'},\n    {0x010211, 'E'},\n    {0x100211, 'F'},\n    {0x111200, 'G'},\n    {0x011201, 'H'},\n    {0x101201, 'I'},\n    {0x110201, 'J'},\n    {0x011120, 'K'},\n    {0x101120, 'L'},\n    {0x001121, 'M'},\n    {0x110120, 'N'},\n    {0x010121, 'O'},\n    {0x100121, 'P'},\n    {0x111020, 'Q'},\n    {0x011021, 'R'},\n    {0x101021, 'S'},\n    {0x110021, 'T'},\n    {0x021110, 'U'},\n    {0x120110, 'V'},\n    {0x020111, 'W'},\n    {0x121010, 'X'},\n    {0x021011, 'Y'},\n    {0x120011, 'Z'},\n    {0x121100, '-'},\n    {0x021101, '.'},\n    {0x120101, ' '},\n    {0x121001, '*'}, // 'stop' character\n};\n\n\nstatic int pdf_barcode_39_ch(struct pdf_doc *pdf, struct pdf_object *page, int x, int y, int char_width, int height, uint32_t colour, char ch)\n{\n    int nw = char_width / 12;\n    int ww = char_width / 4;\n    int i;\n    uint32_t code;\n\n    if (nw <= 1 || ww <= 1)\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient width for each character\");\n\n    for (i = 0; i < ARRAY_SIZE(code_39_encoding); i++) {\n        if (code_39_encoding[i].ch == ch) {\n            code = code_39_encoding[i].code;\n            break;\n        }\n    }\n    if (i == ARRAY_SIZE(code_39_encoding))\n        return pdf_set_err(pdf, -EINVAL, \"Invalid Code 39 character %c 0x%x\", ch, ch);\n\n\n    for (i = 5; i >= 0; i--) {\n        int pattern = (code >> i * 4) & 0xf;\n        if (pattern == 0) { // wide\n            if (pdf_add_filled_rectangle(pdf, page, x, y, ww - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += ww;\n        }\n        if (pattern == 1) { // narrow\n            if (pdf_add_filled_rectangle(pdf, page, x, y, nw - 1, height, 0, colour) < 0)\n                return pdf->errval;\n            x += nw;\n        }\n        if (pattern == 2) { // space\n            x += nw;\n        }\n    }\n    return x;\n}\n\nstatic int pdf_add_barcode_39(struct pdf_doc *pdf, struct pdf_object *page,\n                              int x, int y, int width, int height,\n                              const char *string, uint32_t colour)\n{\n    int len = strlen(string);\n    int char_width = width / (len + 2);\n\n    x = pdf_barcode_39_ch(pdf, page, x, y, char_width, height, colour, '*');\n    if (x < 0)\n        return x;\n\n    while (string && *string) {\n        x = pdf_barcode_39_ch(pdf, page, x, y, char_width, height, colour, *string);\n        if (x < 0)\n            return x;\n        string++;\n    };\n\n    x = pdf_barcode_39_ch(pdf, page, x, y, char_width, height, colour, '*');\n    if (x < 0)\n        return x;\n\n    return 0;\n}\n\nint pdf_add_barcode(struct pdf_doc *pdf, struct pdf_object *page,\n                    int code, int x, int y, int width, int height,\n                    const char *string, uint32_t colour)\n{\n    if (!string || !*string)\n        return 0;\n    switch (code) {\n    case PDF_BARCODE_128A:\n        return pdf_add_barcode_128a(pdf, page, x, y,\n                                    width, height, string, colour);\n    case PDF_BARCODE_39:\n        return pdf_add_barcode_39(pdf, page, x, y, width, height, string, colour);\n    default:\n        return pdf_set_err(pdf, -EINVAL, \"Invalid barcode code %d\", code);\n    }\n}\n\nstatic pdf_object *pdf_add_raw_rgb24(struct pdf_doc *pdf,\n                                     uint8_t *data, int width, int height)\n{\n    struct pdf_object *obj;\n    char line[1024];\n    int len;\n    uint8_t *final_data;\n    const char *endstream = \">\\r\\nendstream\\r\\n\";\n    int i;\n\n    sprintf(line,\n            \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n/Subtype /Image\\r\\n\"\n            \"/ColorSpace /DeviceRGB\\r\\n/Height %d\\r\\n/Width %d\\r\\n\"\n            \"/BitsPerComponent 8\\r\\n/Filter /ASCIIHexDecode\\r\\n\"\n            \"/Length %d\\r\\n>>stream\\r\\n\",\n            flexarray_size(&pdf->objects), height, width, width * height * 3 * 2 + 1);\n\n    len = strlen(line) + width * height * 3 * 2 + strlen(endstream) + 1;\n    final_data = malloc(len);\n    if (!final_data) {\n        pdf_set_err(pdf, -ENOMEM, \"Unable to allocate %d bytes memory for image\",\n                    len);\n        return NULL;\n    }\n    strcpy((char *)final_data, line);\n    uint8_t *pos = &final_data[strlen(line)];\n    for (i = 0; i < width * height * 3; i++) {\n        *pos++ = \"0123456789ABCDEF\"[(data[i] >> 4) & 0xf];\n        *pos++ = \"0123456789ABCDEF\"[data[i] & 0xf];\n    }\n    strcpy((char *)pos, endstream);\n    pos += strlen(endstream);\n\n    obj = pdf_add_object(pdf, OBJ_image);\n    if (!obj) {\n        free(final_data);\n        return NULL;\n    }\n    obj->stream.text = (char *)final_data;\n    obj->stream.len = pos - final_data;\n\n    return obj;\n}\n\n/* See http://www.64lines.com/jpeg-width-height for details */\nstatic int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                if (i + 1 < data_size)\n                    block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}\n\nstatic pdf_object *pdf_add_raw_jpeg(struct pdf_doc *pdf,\n                                    const char *jpeg_file)\n{\n    struct stat buf;\n    off_t len;\n    char *final_data;\n    uint8_t *jpeg_data;\n    int written = 0;\n    FILE *fp;\n    struct pdf_object *obj;\n    int width, height;\n\n    if (stat(jpeg_file, &buf) < 0) {\n        pdf_set_err(pdf, -errno, \"Unable to access %s: %s\", jpeg_file,\n                    strerror(errno));\n        return NULL;\n    }\n\n    len = buf.st_size;\n\n    if ((fp = fopen(jpeg_file, \"rb\")) == NULL) {\n        pdf_set_err(pdf, -errno, \"Unable to open %s: %s\", jpeg_file,\n                    strerror(errno));\n        return NULL;\n    }\n\n    jpeg_data = malloc(len);\n    if (!jpeg_data) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate: %zd\", len);\n        fclose(fp);\n        return NULL;\n    }\n\n    if (fread(jpeg_data, len, 1, fp) != 1) {\n        pdf_set_err(pdf, -errno, \"Unable to read full jpeg data\");\n        free(jpeg_data);\n        fclose(fp);\n        return NULL;\n    }\n    fclose(fp);\n\n    if (jpeg_size(jpeg_data, len, &width, &height) < 0) {\n        free(jpeg_data);\n        pdf_set_err(pdf, -EINVAL, \"Unable to determine jpeg width/height from %s\",\n                    jpeg_file);\n        return NULL;\n    }\n\n    final_data = malloc(len + 1024);\n    if (!final_data) {\n        pdf_set_err(pdf, -errno, \"Unable to allocate jpeg data %zd\", len + 1024);\n        free(jpeg_data);\n        return NULL;\n    }\n\n    written = sprintf(final_data,\n                      \"<<\\r\\n/Type /XObject\\r\\n/Name /Image%d\\r\\n\"\n                      \"/Subtype /Image\\r\\n/ColorSpace /DeviceRGB\\r\\n\"\n                      \"/Width %d\\r\\n/Height %d\\r\\n\"\n                      \"/BitsPerComponent 8\\r\\n/Filter /DCTDecode\\r\\n\"\n                      \"/Length %d\\r\\n>>stream\\r\\n\",\n                      flexarray_size(&pdf->objects), width, height, (int)len);\n    memcpy(&final_data[written], jpeg_data, len);\n    written += len;\n    written += sprintf(&final_data[written], \"\\r\\nendstream\\r\\n\");\n\n    free(jpeg_data);\n\n    obj = pdf_add_object(pdf, OBJ_image);\n    if (!obj) {\n        free(final_data);\n        return NULL;\n    }\n    obj->stream.text = final_data;\n    obj->stream.len = written;\n\n    return obj;\n}\n\nstatic int pdf_add_image(struct pdf_doc *pdf, struct pdf_object *page,\n                         struct pdf_object *image, int x, int y, int width,\n                         int height)\n{\n    int ret;\n    struct dstr str = {0, 0, 0};\n\n    dstr_append(&str, \"q \");\n    dstr_printf(&str, \"%d 0 0 %d %d %d cm \", width, height, x, y);\n    dstr_printf(&str, \"/Image%d Do \", image->index);\n    dstr_append(&str, \"Q\");\n\n    ret = pdf_add_stream(pdf, page, str.data);\n    dstr_free(&str);\n    return ret;\n}\n\nint pdf_add_ppm(struct pdf_doc *pdf, struct pdf_object *page,\n                int x, int y, int display_width, int display_height,\n                const char *ppm_file)\n{\n    struct pdf_object *obj;\n    uint8_t *data;\n    FILE *fp;\n    char line[1024];\n    unsigned width, height, size;\n\n    /* Load the PPM file */\n    fp = fopen(ppm_file, \"rb\");\n    if (!fp)\n        return pdf_set_err(pdf, -errno, \"Unable to open '%s'\", ppm_file);\n    if (!fgets(line, sizeof(line) - 1, fp)) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Invalid PPM file\");\n    }\n\n    /* We only support binary ppms */\n    if (strncmp(line, \"P6\", 2) != 0) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Only binary PPM files supported\");\n    }\n\n    /* Find the width line */\n    do {\n        if (!fgets(line, sizeof(line) - 1, fp)) {\n            fclose(fp);\n            return pdf_set_err(pdf, -EINVAL, \"Unable to find PPM size\");\n        }\n        if (line[0] == '#')\n            continue;\n\n        if (sscanf(line, \"%u %u\\n\", &width, &height) != 2) {\n            fclose(fp);\n            return pdf_set_err(pdf, -EINVAL, \"Unable to find PPM size\");\n        }\n        break;\n    } while (1);\n\n    /* Skip over the byte-size line */\n    if (!fgets(line, sizeof(line) - 1, fp)) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"No byte-size line in PPM file\");\n    }\n\n    if (width > INT_MAX || height > INT_MAX) {\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Invalid width/height in PPM file: %ux%u\", width, height);\n    }\n\n    size = width * height * 3;\n    data = malloc(size);\n    if (!data) {\n        fclose(fp);\n        return pdf_set_err(pdf, -ENOMEM, \"Unable to allocate memory for RGB data\");\n    }\n    if (fread(data, 1, size, fp) != size) {\n        free(data);\n        fclose(fp);\n        return pdf_set_err(pdf, -EINVAL, \"Insufficient RGB data available\");\n\n    }\n    fclose(fp);\n    obj = pdf_add_raw_rgb24(pdf, data, width, height);\n    free(data);\n    if (!obj)\n        return pdf->errval;\n\n    return pdf_add_image(pdf, page, obj, x, y, display_width, display_height);\n}\n\nint pdf_add_jpeg(struct pdf_doc *pdf, struct pdf_object *page,\n                 int x, int y, int display_width, int display_height,\n                 const char *jpeg_file)\n{\n    struct pdf_object *obj;\n\n    obj = pdf_add_raw_jpeg(pdf, jpeg_file);\n    if (!obj)\n        return pdf->errval;\n\n    return pdf_add_image(pdf, page, obj, x, y, display_width, display_height);\n}\n"], "filenames": ["pdfgen.c"], "buggy_code_start_loc": [2039], "buggy_code_end_loc": [2040], "fixing_code_start_loc": [2039], "fixing_code_end_loc": [2041], "type": "CWE-125", "message": "jpeg_size in pdfgen.c in PDFGen before 2018-04-09 has a heap-based buffer over-read.", "other": {"cve": {"id": "CVE-2018-11363", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T04:29:00.217", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "jpeg_size in pdfgen.c in PDFGen before 2018-04-09 has a heap-based buffer over-read."}, {"lang": "es", "value": "jpeg_size en pdfgen.c en PDFGen, en versiones anteriores al 2018-04-09, tiene una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pdfgen:pdfgen:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-04-09", "matchCriteriaId": "9FEC7B81-30B3-405F-AFD9-F54965FF173A"}]}]}], "references": [{"url": "https://github.com/AndreRenaud/PDFGen/commit/ee58aff6918b8bbc3be29b9e3089485ea46ff956", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ChijinZ/security_advisories/tree/master/PDFgen-206ef1b", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AndreRenaud/PDFGen/commit/ee58aff6918b8bbc3be29b9e3089485ea46ff956"}}