{"buggy_code": ["/* $Id: etc.c,v 1.81 2007/05/23 15:06:05 inu Exp $ */\n#include \"fm.h\"\n#ifndef __MINGW32_VERSION\n#include <pwd.h>\n#endif\n#include \"myctype.h\"\n#include \"html.h\"\n#include \"local.h\"\n#include \"hash.h\"\n\n#include <fcntl.h>\n#include <sys/types.h>\n#include <time.h>\n#if defined(HAVE_WAITPID) || defined(HAVE_WAIT3)\n#include <sys/wait.h>\n#endif\n#include <signal.h>\n\n#ifdef\t__WATT32__\n#define\tread(a,b,c)\tread_s(a,b,c)\n#define\tclose(x)\tclose_s(x)\n#endif\t\t\t\t/* __WATT32__ */\n\nstruct auth_pass {\n    int bad;\n    int is_proxy;\n    Str host;\n    int port;\n/*    Str file; */\n    Str realm;\n    Str uname;\n    Str pwd;\n    struct auth_pass *next;\n};\n\nstruct auth_pass *passwords = NULL;\n\nint\ncolumnSkip(Buffer *buf, int offset)\n{\n    int i, maxColumn;\n    int column = buf->currentColumn + offset;\n    int nlines = buf->LINES + 1;\n    Line *l;\n\n    maxColumn = 0;\n    for (i = 0, l = buf->topLine; i < nlines && l != NULL; i++, l = l->next) {\n\tif (l->width < 0)\n\t    l->width = COLPOS(l, l->len);\n\tif (l->width - 1 > maxColumn)\n\t    maxColumn = l->width - 1;\n    }\n    maxColumn -= buf->COLS - 1;\n    if (column < maxColumn)\n\tmaxColumn = column;\n    if (maxColumn < 0)\n\tmaxColumn = 0;\n\n    if (buf->currentColumn == maxColumn)\n\treturn 0;\n    buf->currentColumn = maxColumn;\n    return 1;\n}\n\nint\ncolumnPos(Line *line, int column)\n{\n    int i;\n\n    for (i = 1; i < line->len; i++) {\n\tif (COLPOS(line, i) > column)\n\t    break;\n    }\n#ifdef USE_M17N\n    for (i--; i > 0 && line->propBuf[i] & PC_WCHAR2; i--) ;\n    return i;\n#else\n    return i - 1;\n#endif\n}\n\nLine *\nlineSkip(Buffer *buf, Line *line, int offset, int last)\n{\n    int i;\n    Line *l;\n\n    l = currentLineSkip(buf, line, offset, last);\n    if (!nextpage_topline)\n\tfor (i = buf->LINES - 1 - (buf->lastLine->linenumber - l->linenumber);\n\t     i > 0 && l->prev != NULL; i--, l = l->prev) ;\n    return l;\n}\n\nLine *\ncurrentLineSkip(Buffer *buf, Line *line, int offset, int last)\n{\n    int i, n;\n    Line *l = line;\n\n    if (buf->pagerSource && !(buf->bufferprop & BP_CLOSE)) {\n\tn = line->linenumber + offset + buf->LINES;\n\tif (buf->lastLine->linenumber < n)\n\t    getNextPage(buf, n - buf->lastLine->linenumber);\n\twhile ((last || (buf->lastLine->linenumber < n)) &&\n\t       (getNextPage(buf, 1) != NULL)) ;\n\tif (last)\n\t    l = buf->lastLine;\n    }\n\n    if (offset == 0)\n\treturn l;\n    if (offset > 0)\n\tfor (i = 0; i < offset && l->next != NULL; i++, l = l->next) ;\n    else\n\tfor (i = 0; i < -offset && l->prev != NULL; i++, l = l->prev) ;\n    return l;\n}\n\n#define MAX_CMD_LEN 128\n\nint\ngethtmlcmd(char **s)\n{\n    extern Hash_si tagtable;\n    char cmdstr[MAX_CMD_LEN];\n    char *p = cmdstr;\n    char *save = *s;\n    int cmd;\n\n    (*s)++;\n    /* first character */\n    if (IS_ALNUM(**s) || **s == '_' || **s == '/') {\n\t*(p++) = TOLOWER(**s);\n\t(*s)++;\n    }\n    else\n\treturn HTML_UNKNOWN;\n    if (p[-1] == '/')\n\tSKIP_BLANKS(*s);\n    while ((IS_ALNUM(**s) || **s == '_') && p - cmdstr < MAX_CMD_LEN) {\n\t*(p++) = TOLOWER(**s);\n\t(*s)++;\n    }\n    if (p - cmdstr == MAX_CMD_LEN) {\n\t/* buffer overflow: perhaps caused by bad HTML source */\n\t*s = save + 1;\n\treturn HTML_UNKNOWN;\n    }\n    *p = '\\0';\n\n    /* hash search */\n    cmd = getHash_si(&tagtable, cmdstr, HTML_UNKNOWN);\n    while (**s && **s != '>')\n\t(*s)++;\n    if (**s == '>')\n\t(*s)++;\n    return cmd;\n}\n\n#ifdef USE_ANSI_COLOR\nstatic int\nparse_ansi_color(char **str, Lineprop *effect, Linecolor *color)\n{\n    char *p = *str, *q;\n    Lineprop e = *effect;\n    Linecolor c = *color;\n    int i;\n\n    if (*p != ESC_CODE || *(p + 1) != '[')\n\treturn 0;\n    p += 2;\n    for (q = p; IS_DIGIT(*q) || *q == ';'; q++) ;\n    if (*q != 'm')\n\treturn 0;\n    *str = q + 1;\n    while (1) {\n\tif (*p == 'm') {\n\t    e = PE_NORMAL;\n\t    c = 0;\n\t    break;\n\t}\n\tif (IS_DIGIT(*p)) {\n\t    q = p;\n\t    for (p++; IS_DIGIT(*p); p++) ;\n\t    i = atoi(allocStr(q, p - q));\n\t    switch (i) {\n\t    case 0:\n\t\te = PE_NORMAL;\n\t\tc = 0;\n\t\tbreak;\n\t    case 1:\n\t    case 5:\n\t\te = PE_BOLD;\n\t\tbreak;\n\t    case 4:\n\t\te = PE_UNDER;\n\t\tbreak;\n\t    case 7:\n\t\te = PE_STAND;\n\t\tbreak;\n\t    case 100:\t\t/* for EWS4800 kterm */\n\t\tc = 0;\n\t\tbreak;\n\t    case 39:\n\t\tc &= 0xf0;\n\t\tbreak;\n\t    case 49:\n\t\tc &= 0x0f;\n\t\tbreak;\n\t    default:\n\t\tif (i >= 30 && i <= 37)\n\t\t    c = (c & 0xf0) | (i - 30) | 0x08;\n\t\telse if (i >= 40 && i <= 47)\n\t\t    c = (c & 0x0f) | ((i - 40) << 4) | 0x80;\n\t\tbreak;\n\t    }\n\t    if (*p == 'm')\n\t\tbreak;\n\t}\n\telse {\n\t    e = PE_NORMAL;\n\t    c = 0;\n\t    break;\n\t}\n\tp++;\t\t\t/* *p == ';' */\n    }\n    *effect = e;\n    *color = c;\n    return 1;\n}\n#endif\n/* \n * Check character type\n */\n\nStr\ncheckType(Str s, Lineprop **oprop, Linecolor **ocolor)\n{\n    Lineprop mode;\n    Lineprop effect = PE_NORMAL;\n    Lineprop *prop;\n    static Lineprop *prop_buffer = NULL;\n    static int prop_size = 0;\n    char *str = s->ptr, *endp = &s->ptr[s->length], *bs = NULL;\n#ifdef USE_ANSI_COLOR\n    Lineprop ceffect = PE_NORMAL;\n    Linecolor cmode = 0;\n    int check_color = FALSE;\n    Linecolor *color = NULL;\n    static Linecolor *color_buffer = NULL;\n    static int color_size = 0;\n    char *es = NULL;\n#endif\n    int do_copy = FALSE;\n#ifdef USE_M17N\n    int i;\n    int plen = 0, clen;\n    int *plens = NULL;\n    static int *plens_buffer = NULL;\n    static int plens_size = 0;\n#endif\n\n    if (prop_size < s->length) {\n\tprop_size = (s->length > LINELEN) ? s->length : LINELEN;\n\tprop_buffer = New_Reuse(Lineprop, prop_buffer, prop_size);\n    }\n    prop = prop_buffer;\n#ifdef USE_M17N\n    if (plens_size < s->length) {\n\tplens_size = (s->length > LINELEN) ? s->length : LINELEN;\n\tplens_buffer = New_Reuse(int, plens_buffer, plens_size);\n    }\n    plens = plens_buffer;\n#endif\n\n    if (ShowEffect) {\n\tbs = memchr(str, '\\b', s->length);\n#ifdef USE_ANSI_COLOR\n\tif (ocolor) {\n\t    es = memchr(str, ESC_CODE, s->length);\n\t    if (es) {\n\t\tif (color_size < s->length) {\n\t\t    color_size = (s->length > LINELEN) ? s->length : LINELEN;\n\t\t    color_buffer = New_Reuse(Linecolor, color_buffer,\n\t\t\t\t\t     color_size);\n\t\t}\n\t\tcolor = color_buffer;\n\t    }\n\t}\n#endif\n\tif ((bs != NULL)\n#ifdef USE_ANSI_COLOR\n\t    || (es != NULL)\n#endif\n\t    ) {\n\t    char *sp = str, *ep;\n\t    s = Strnew_size(s->length);\n\t    do_copy = TRUE;\n\t    ep = endp;\n\t    if (bs && ep > bs - 2)\n\t\tep = bs - 2;\n#ifdef USE_ANSI_COLOR\n\t    if (es && ep > es - 2)\n\t\tep = es - 2;\n#endif\n\t    for (; str < ep && IS_ASCII(*str); str++) {\n\t\t*(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);\n#ifdef USE_ANSI_COLOR\n\t\tif (color)\n\t\t    *(color++) = 0;\n#endif\n#ifdef USE_M17N\n\t\t*(plens++) = plen = 1;\n#endif\n\t    }\n\t    Strcat_charp_n(s, sp, (int)(str - sp));\n\t}\n    }\n    if (!do_copy) {\n\tfor (; str < endp && IS_ASCII(*str); str++) {\n\t    *(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);\n#ifdef USE_ANSI_COLOR\n\t    if (color)\n\t\t*(color++) = 0;\n#endif\n#ifdef USE_M17N\n\t    *(plens++) = plen = 1;\n#endif\n\t}\n    }\n\n    while (str < endp) {\n\tif (prop - prop_buffer >= prop_size)\n\t    break;\n\tif (bs != NULL) {\n#ifdef USE_M17N\n\t    if (str == bs - 2 && !strncmp(str, \"__\\b\\b\", 4)) {\n\t\tstr += 4;\n\t\teffect = PE_UNDER;\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n\t    else\n#endif\n\t    if (str == bs - 1 && *str == '_') {\n\t\tstr += 2;\n\t\teffect = PE_UNDER;\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n\t    else if (str == bs) {\n\t\tif (*(str + 1) == '_') {\n\t\t    if (s->length) {\n\t\t\tstr += 2;\n#ifdef USE_M17N\n\t\t\tfor (i = 1; i <= plen; i++)\n\t\t\t    *(prop - i) |= PE_UNDER;\n#else\n\t\t\t*(prop - 1) |= PE_UNDER;\n#endif\n\t\t    }\n\t\t    else {\n\t\t\tstr++;\n\t\t    }\n\t\t}\n#ifdef USE_M17N\n\t\telse if (!strncmp(str + 1, \"\\b__\", 3)) {\n\t\t    if (s->length) {\n\t\t\tstr += (plen == 1) ? 3 : 4;\n\t\t\tfor (i = 1; i <= plen; i++)\n\t\t\t    *(prop - i) |= PE_UNDER;\n\t\t    }\n\t\t    else {\n\t\t\tstr += 2;\n\t\t    }\n\t\t}\n\t\telse if (*(str + 1) == '\\b') {\n\t\t    if (s->length) {\n\t\t\tclen = get_mclen(str + 2);\n\t\t\tif (plen == clen &&\n\t\t\t    !strncmp(str - plen, str + 2, plen)) {\n\t\t\t    for (i = 1; i <= plen; i++)\n\t\t\t\t*(prop - i) |= PE_BOLD;\n\t\t\t    str += 2 + clen;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, plen);\n\t\t\t    prop -= plen;\n#ifdef USE_ANSI_COLOR\n\t\t\t    if (color)\n\t\t\t\tcolor -= plen;\n#endif\n\t\t\t    plen = *(--plens);\n\t\t\t    str += 2;\n\t\t\t}\n\t\t    }\n\t\t    else {\n\t\t\tstr += 2;\n\t\t    }\n\t\t}\n#endif\n\t\telse {\n\t\t    if (s->length) {\n#ifdef USE_M17N\n\t\t\tclen = get_mclen(str + 1);\n\t\t\tif (plen == clen &&\n\t\t\t    !strncmp(str - plen, str + 1, plen)) {\n\t\t\t    for (i = 1; i <= plen; i++)\n\t\t\t\t*(prop - i) |= PE_BOLD;\n\t\t\t    str += 1 + clen;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, plen);\n\t\t\t    prop -= plen;\n#ifdef USE_ANSI_COLOR\n\t\t\t    if (color)\n\t\t\t\tcolor -= plen;\n#endif\n\t\t\t    plen = *(--plens);\n\t\t\t    str++;\n\t\t\t}\n#else\n\t\t\tif (*(str - 1) == *(str + 1)) {\n\t\t\t    *(prop - 1) |= PE_BOLD;\n\t\t\t    str += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, 1);\n\t\t\t    prop--;\n#ifdef USE_ANSI_COLOR\n\t\t\t    if (color)\n\t\t\t\tcolor--;\n#endif\n\t\t\t    str++;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else {\n\t\t\tstr++;\n\t\t    }\n\t\t}\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n#ifdef USE_ANSI_COLOR\n\t    else if (str > bs)\n\t\tbs = memchr(str, '\\b', endp - str);\n#endif\n\t}\n#ifdef USE_ANSI_COLOR\n\tif (es != NULL) {\n\t    if (str == es) {\n\t\tint ok = parse_ansi_color(&str, &ceffect, &cmode);\n\t\tif (str < endp)\n\t\t    es = memchr(str, ESC_CODE, endp - str);\n\t\tif (ok) {\n\t\t    if (cmode)\n\t\t\tcheck_color = TRUE;\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (str > es)\n\t\tes = memchr(str, ESC_CODE, endp - str);\n\t}\n#endif\n\n\tmode = get_mctype(str) | effect;\n#ifdef USE_ANSI_COLOR\n\tif (color) {\n\t    *(color++) = cmode;\n\t    mode |= ceffect;\n\t}\n#endif\n\t*(prop++) = mode;\n#ifdef USE_M17N\n\tplen = get_mclen(str);\n\tif (str + plen > endp)\n\t    plen = endp - str;\n\t*(plens++) = plen;\n\tif (plen > 1) {\n\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t    for (i = 1; i < plen; i++) {\n\t\t*(prop++) = mode;\n#ifdef USE_ANSI_COLOR\n\t\tif (color)\n\t\t    *(color++) = cmode;\n#endif\n\t    }\n\t    if (do_copy)\n\t\tStrcat_charp_n(s, (char *)str, plen);\n\t    str += plen;\n\t}\n\telse\n#endif\n\t{\n\t    if (do_copy)\n\t\tStrcat_char(s, (char)*str);\n\t    str++;\n\t}\n\teffect = PE_NORMAL;\n    }\n    *oprop = prop_buffer;\n#ifdef USE_ANSI_COLOR\n    if (ocolor)\n\t*ocolor = check_color ? color_buffer : NULL;\n#endif\n    return s;\n}\n\nstatic int\nnextColumn(int n, char *p, Lineprop *pr)\n{\n    if (*pr & PC_CTRL) {\n\tif (*p == '\\t')\n\t    return (n + Tabstop) / Tabstop * Tabstop;\n\telse if (*p == '\\n')\n\t    return n + 1;\n\telse if (*p != '\\r')\n\t    return n + 2;\n\treturn n;\n    }\n#ifdef USE_M17N\n    if (*pr & PC_UNKNOWN)\n\treturn n + 4;\n    return n + wtf_width((wc_uchar *) p);\n#else\n    return n + 1;\n#endif\n}\n\nint\ncalcPosition(char *l, Lineprop *pr, int len, int pos, int bpos, int mode)\n{\n    static int *realColumn = NULL;\n    static int size = 0;\n    static char *prevl = NULL;\n    int i, j;\n\n    if (l == NULL || len == 0 || pos < 0)\n\treturn bpos;\n    if (l == prevl && mode == CP_AUTO) {\n\tif (pos <= len)\n\t    return realColumn[pos];\n    }\n    if (size < len + 1) {\n\tsize = (len + 1 > LINELEN) ? (len + 1) : LINELEN;\n\trealColumn = New_N(int, size);\n    }\n    prevl = l;\n    i = 0;\n    j = bpos;\n#ifdef USE_M17N\n    if (pr[i] & PC_WCHAR2) {\n\tfor (; i < len && pr[i] & PC_WCHAR2; i++)\n\t    realColumn[i] = j;\n\tif (i > 0 && pr[i - 1] & PC_KANJI && WcOption.use_wide)\n\t    j++;\n    }\n#endif\n    while (1) {\n\trealColumn[i] = j;\n\tif (i == len)\n\t    break;\n\tj = nextColumn(j, &l[i], &pr[i]);\n\ti++;\n#ifdef USE_M17N\n\tfor (; i < len && pr[i] & PC_WCHAR2; i++)\n\t    realColumn[i] = realColumn[i - 1];\n#endif\n    }\n    if (pos >= i)\n\treturn j;\n    return realColumn[pos];\n}\n\nint\ncolumnLen(Line *line, int column)\n{\n    int i, j;\n\n    for (i = 0, j = 0; i < line->len;) {\n\tj = nextColumn(j, &line->lineBuf[i], &line->propBuf[i]);\n\tif (j > column)\n\t    return i;\n\ti++;\n#ifdef USE_M17N\n\twhile (i < line->len && line->propBuf[i] & PC_WCHAR2)\n\t    i++;\n#endif\n    }\n    return line->len;\n}\n\nchar *\nlastFileName(char *path)\n{\n    char *p, *q;\n\n    p = q = path;\n    while (*p != '\\0') {\n\tif (*p == '/')\n\t    q = p + 1;\n\tp++;\n    }\n\n    return allocStr(q, -1);\n}\n\n#ifdef USE_INCLUDED_SRAND48\nstatic unsigned long R1 = 0x1234abcd;\nstatic unsigned long R2 = 0x330e;\n#define A1 0x5deec\n#define A2 0xe66d\n#define C 0xb\n\nvoid\nsrand48(long seed)\n{\n    R1 = (unsigned long)seed;\n    R2 = 0x330e;\n}\n\nlong\nlrand48(void)\n{\n    R1 = (A1 * R1 << 16) + A1 * R2 + A2 * R1 + ((A2 * R2 + C) >> 16);\n    R2 = (A2 * R2 + C) & 0xffff;\n    return (long)(R1 >> 1);\n}\n#endif\n\nchar *\nmybasename(char *s)\n{\n    char *p = s;\n    while (*p)\n\tp++;\n    while (s <= p && *p != '/')\n\tp--;\n    if (*p == '/')\n\tp++;\n    else\n\tp = s;\n    return allocStr(p, -1);\n}\n\nchar *\nmydirname(char *s)\n{\n    char *p = s;\n    while (*p)\n\tp++;\n    if (s != p)\n\tp--;\n    while (s != p && *p == '/')\n\tp--;\n    while (s != p && *p != '/')\n\tp--;\n    if (*p != '/')\n\treturn \".\";\n    while (s != p && *p == '/')\n\tp--;\n    return allocStr(s, strlen(s) - strlen(p) + 1);\n}\n\n#ifndef HAVE_STRERROR\nchar *\nstrerror(int errno)\n{\n    extern char *sys_errlist[];\n    return sys_errlist[errno];\n}\n#endif\t\t\t\t/* not HAVE_STRERROR */\n\nint\nnext_status(char c, int *status)\n{\n    switch (*status) {\n    case R_ST_NORMAL:\n\tif (c == '<') {\n\t    *status = R_ST_TAG0;\n\t    return 0;\n\t}\n\telse if (c == '&') {\n\t    *status = R_ST_AMP;\n\t    return 1;\n\t}\n\telse\n\t    return 1;\n\tbreak;\n    case R_ST_TAG0:\n\tif (c == '!') {\n\t    *status = R_ST_CMNT1;\n\t    return 0;\n\t}\n\t*status = R_ST_TAG;\n\t/* continues to next case */\n    case R_ST_TAG:\n\tif (c == '>')\n\t    *status = R_ST_NORMAL;\n\telse if (c == '=')\n\t    *status = R_ST_EQL;\n\treturn 0;\n    case R_ST_EQL:\n\tif (c == '\"')\n\t    *status = R_ST_DQUOTE;\n\telse if (c == '\\'')\n\t    *status = R_ST_QUOTE;\n\telse if (IS_SPACE(c))\n\t    *status = R_ST_EQL;\n\telse if (c == '>')\n\t    *status = R_ST_NORMAL;\n\telse\n\t    *status = R_ST_VALUE;\n\treturn 0;\n    case R_ST_QUOTE:\n\tif (c == '\\'')\n\t    *status = R_ST_TAG;\n\treturn 0;\n    case R_ST_DQUOTE:\n\tif (c == '\"')\n\t    *status = R_ST_TAG;\n\treturn 0;\n    case R_ST_VALUE:\n\tif (c == '>')\n\t    *status = R_ST_NORMAL;\n\telse if (IS_SPACE(c))\n\t    *status = R_ST_TAG;\n\treturn 0;\n    case R_ST_AMP:\n\tif (c == ';') {\n\t    *status = R_ST_NORMAL;\n\t    return 0;\n\t}\n\telse if (c != '#' && !IS_ALNUM(c) && c != '_') {\n\t    /* something's wrong! */\n\t    *status = R_ST_NORMAL;\n\t    return 0;\n\t}\n\telse\n\t    return 0;\n    case R_ST_CMNT1:\n\tswitch (c) {\n\tcase '-':\n\t    *status = R_ST_CMNT2;\n\t    break;\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tcase 'D':\n\tcase 'd':\n\t    /* could be a !doctype */\n\t    *status = R_ST_TAG;\n\t    break;\n\tdefault:\n\t    *status = R_ST_IRRTAG;\n\t}\n\treturn 0;\n    case R_ST_CMNT2:\n\tswitch (c) {\n\tcase '-':\n\t    *status = R_ST_CMNT;\n\t    break;\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tdefault:\n\t    *status = R_ST_IRRTAG;\n\t}\n\treturn 0;\n    case R_ST_CMNT:\n\tif (c == '-')\n\t    *status = R_ST_NCMNT1;\n\treturn 0;\n    case R_ST_NCMNT1:\n\tif (c == '-')\n\t    *status = R_ST_NCMNT2;\n\telse\n\t    *status = R_ST_CMNT;\n\treturn 0;\n    case R_ST_NCMNT2:\n\tswitch (c) {\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tcase '-':\n\t    *status = R_ST_NCMNT2;\n\t    break;\n\tdefault:\n\t    if (IS_SPACE(c))\n\t\t*status = R_ST_NCMNT3;\n\t    else\n\t\t*status = R_ST_CMNT;\n\t    break;\n\t}\n\tbreak;\n    case R_ST_NCMNT3:\n\tswitch (c) {\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tcase '-':\n\t    *status = R_ST_NCMNT1;\n\t    break;\n\tdefault:\n\t    if (IS_SPACE(c))\n\t\t*status = R_ST_NCMNT3;\n\t    else\n\t\t*status = R_ST_CMNT;\n\t    break;\n\t}\n\treturn 0;\n    case R_ST_IRRTAG:\n\tif (c == '>')\n\t    *status = R_ST_NORMAL;\n\treturn 0;\n    }\n    /* notreached */\n    return 0;\n}\n\nint\nread_token(Str buf, char **instr, int *status, int pre, int append)\n{\n    char *p;\n    int prev_status;\n\n    if (!append)\n\tStrclear(buf);\n    if (**instr == '\\0')\n\treturn 0;\n    for (p = *instr; *p; p++) {\n\t/* Drop Unicode soft hyphen */\n\tif (*(unsigned char *)p == 0210\n\t    && *(unsigned char *)(p + 1) == 0200\n\t    && *(unsigned char *)(p + 2) == 0201\n\t    && *(unsigned char *)(p + 3) == 0255) {\n\t    p += 3;\n\t    continue;\n\t}\n\n\tprev_status = *status;\n\tnext_status(*p, status);\n\tswitch (*status) {\n\tcase R_ST_NORMAL:\n\t    if (prev_status == R_ST_AMP && *p != ';') {\n\t\tp--;\n\t\tbreak;\n\t    }\n\t    if (prev_status == R_ST_NCMNT2 || prev_status == R_ST_NCMNT3 ||\n\t\tprev_status == R_ST_IRRTAG || prev_status == R_ST_CMNT1) {\n\t\tif (prev_status == R_ST_CMNT1 && !append && !pre)\n\t\t    Strclear(buf);\n\t\tif (pre)\n\t\t    Strcat_char(buf, *p);\n\t\tp++;\n\t\tgoto proc_end;\n\t    }\n\t    Strcat_char(buf, (!pre && IS_SPACE(*p)) ? ' ' : *p);\n\t    if (ST_IS_REAL_TAG(prev_status)) {\n\t\t*instr = p + 1;\n\t\tif (buf->length < 2 ||\n\t\t    buf->ptr[buf->length - 2] != '<' ||\n\t\t    buf->ptr[buf->length - 1] != '>')\n\t\t    return 1;\n\t\tStrshrink(buf, 2);\n\t    }\n\t    break;\n\tcase R_ST_TAG0:\n\tcase R_ST_TAG:\n\t    if (prev_status == R_ST_NORMAL && p != *instr) {\n\t\t*instr = p;\n\t\t*status = prev_status;\n\t\treturn 1;\n\t    }\n\t    if (*status == R_ST_TAG0 && !REALLY_THE_BEGINNING_OF_A_TAG(p)) {\n\t\t/* it seems that this '<' is not a beginning of a tag */\n\t\t/*\n\t\t * Strcat_charp(buf, \"&lt;\");\n\t\t */\n\t\tStrcat_char(buf, '<');\n\t\t*status = R_ST_NORMAL;\n\t    }\n\t    else\n\t\tStrcat_char(buf, *p);\n\t    break;\n\tcase R_ST_EQL:\n\tcase R_ST_QUOTE:\n\tcase R_ST_DQUOTE:\n\tcase R_ST_VALUE:\n\tcase R_ST_AMP:\n\t    Strcat_char(buf, *p);\n\t    break;\n\tcase R_ST_CMNT:\n\tcase R_ST_IRRTAG:\n\t    if (pre)\n\t\tStrcat_char(buf, *p);\n\t    else if (!append)\n\t\tStrclear(buf);\n\t    break;\n\tcase R_ST_CMNT1:\n\tcase R_ST_CMNT2:\n\tcase R_ST_NCMNT1:\n\tcase R_ST_NCMNT2:\n\tcase R_ST_NCMNT3:\n\t    /* do nothing */\n\t    if (pre)\n\t\tStrcat_char(buf, *p);\n\t    break;\n\t}\n    }\n  proc_end:\n    *instr = p;\n    return 1;\n}\n\nStr\ncorrect_irrtag(int status)\n{\n    char c;\n    Str tmp = Strnew();\n\n    while (status != R_ST_NORMAL) {\n\tswitch (status) {\n\tcase R_ST_CMNT:\t/* required \"-->\" */\n\tcase R_ST_NCMNT1:\t/* required \"->\" */\n\t    c = '-';\n\t    break;\n\tcase R_ST_NCMNT2:\n\tcase R_ST_NCMNT3:\n\tcase R_ST_IRRTAG:\n\tcase R_ST_CMNT1:\n\tcase R_ST_CMNT2:\n\tcase R_ST_TAG:\n\tcase R_ST_TAG0:\n\tcase R_ST_EQL:\t\t/* required \">\" */\n\tcase R_ST_VALUE:\n\t    c = '>';\n\t    break;\n\tcase R_ST_QUOTE:\n\t    c = '\\'';\n\t    break;\n\tcase R_ST_DQUOTE:\n\t    c = '\"';\n\t    break;\n\tcase R_ST_AMP:\n\t    c = ';';\n\t    break;\n\tdefault:\n\t    return tmp;\n\t}\n\tnext_status(c, &status);\n\tStrcat_char(tmp, c);\n    }\n    return tmp;\n}\n\n/*\n * RFC2617: 1.2 Access Authentication Framework\n *\n * The realm value (case-sensitive), in combination with the canonical root\n * URL (the absoluteURI for the server whose abs_path is empty; see section\n * 5.1.2 of RFC2616 ) of the server being accessed, defines the protection\n * space. These realms allow the protected resources on a server to be\n * partitioned into a set of protection spaces, each with its own\n * authentication scheme and/or authorization database.\n *\n */\nstatic void\nadd_auth_pass_entry(const struct auth_pass *ent, int netrc, int override)\n{\n    if ((ent->host || netrc)\t/* netrc accept default (host == NULL) */\n\t&&(ent->is_proxy || ent->realm || netrc)\n\t&& ent->uname && ent->pwd) {\n\tstruct auth_pass *newent = New(struct auth_pass);\n\tmemcpy(newent, ent, sizeof(struct auth_pass));\n\tif (override) {\n\t    newent->next = passwords;\n\t    passwords = newent;\n\t} \n\telse {\n\t    if (passwords == NULL)\n\t\tpasswords = newent;\n\t    else if (passwords->next == NULL)\n\t\tpasswords->next = newent;\n\t    else {\n\t\tstruct auth_pass *ep = passwords;\n\t\tfor (; ep->next; ep = ep->next) ;\n\t\tep->next = newent;\n\t    }\n\t}\n    }\n    /* ignore invalid entries */\n}\n\nstatic struct auth_pass *\nfind_auth_pass_entry(char *host, int port, char *realm, char *uname, \n\t\t     int is_proxy)\n{\n    struct auth_pass *ent;\n    for (ent = passwords; ent != NULL; ent = ent->next) {\n\tif (ent->is_proxy == is_proxy\n\t    && (ent->bad != TRUE)\n\t    && (!ent->host || !Strcasecmp_charp(ent->host, host))\n\t    && (!ent->port || ent->port == port)\n\t    && (!ent->uname || !uname || !Strcmp_charp(ent->uname, uname))\n\t    && (!ent->realm || !realm || !Strcmp_charp(ent->realm, realm))\n\t    )\n\t    return ent;\n    }\n    return NULL;\n}\n\nint\nfind_auth_user_passwd(ParsedURL *pu, char *realm,\n\t\t      Str *uname, Str *pwd, int is_proxy)\n{\n    struct auth_pass *ent;\n\n    if (pu->user && pu->pass) {\n\t*uname = Strnew_charp(pu->user);\n\t*pwd = Strnew_charp(pu->pass);\n\treturn 1;\n    }\n    ent = find_auth_pass_entry(pu->host, pu->port, realm, pu->user, is_proxy);\n    if (ent) {\n\t*uname = ent->uname;\n\t*pwd = ent->pwd;\n\treturn 1;\n    }\n    return 0;\n}\n\nvoid\nadd_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, \n\t\t     int is_proxy)\n{\n    struct auth_pass ent;\n    memset(&ent, 0, sizeof(ent));\n\n    ent.is_proxy = is_proxy;\n    ent.host = Strnew_charp(pu->host);\n    ent.port = pu->port;\n    ent.realm = Strnew_charp(realm);\n    ent.uname = uname;\n    ent.pwd = pwd;\n    add_auth_pass_entry(&ent, 0, 1);\n}\n\nvoid\ninvalidate_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, \n\t\t\t    int is_proxy)\n{\n    struct auth_pass *ent;\n    ent = find_auth_pass_entry(pu->host, pu->port, realm, NULL, is_proxy);\n    if (ent) {\n\tent->bad = TRUE;\n    }\n    return;\n}\n\n/* passwd */\n/*\n * machine <host>\n * host <host>\n * port <port>\n * proxy\n * path <file>\t; not used\n * realm <realm>\n * login <login>\n * passwd <passwd>\n * password <passwd>\n */\n\nstatic Str\nnext_token(Str arg)\n{\n    Str narg = NULL;\n    char *p, *q;\n    if (arg == NULL || arg->length == 0)\n\treturn NULL;\n    p = arg->ptr;\n    q = p;\n    SKIP_NON_BLANKS(q);\n    if (*q != '\\0') {\n\t*q++ = '\\0';\n\tSKIP_BLANKS(q);\n\tif (*q != '\\0')\n\t    narg = Strnew_charp(q);\n    }\n    return narg;\n}\n\nstatic void\nparsePasswd(FILE * fp, int netrc)\n{\n    struct auth_pass ent;\n    Str line = NULL;\n\n    bzero(&ent, sizeof(struct auth_pass));\n    while (1) {\n\tStr arg = NULL;\n\tchar *p;\n\n\tif (line == NULL || line->length == 0)\n\t    line = Strfgets(fp);\n\tif (line->length == 0)\n\t    break;\n\tStrchop(line);\n\tStrremovefirstspaces(line);\n\tp = line->ptr;\n\tif (*p == '#' || *p == '\\0') {\n\t    line = NULL;\n\t    continue;\t\t/* comment or empty line */\n\t}\n\targ = next_token(line);\n\n\tif (!strcmp(p, \"machine\") || !strcmp(p, \"host\")\n\t    || (netrc && !strcmp(p, \"default\"))) {\n\t    add_auth_pass_entry(&ent, netrc, 0);\n\t    bzero(&ent, sizeof(struct auth_pass));\n\t    if (netrc)\n\t\tent.port = 21;\t/* XXX: getservbyname(\"ftp\"); ? */\n\t    if (strcmp(p, \"default\") != 0) {\n\t\tline = next_token(arg);\n\t\tent.host = arg;\n\t    }\n\t    else {\n\t\tline = arg;\n\t    }\n\t}\n\telse if (!netrc && !strcmp(p, \"port\") && arg) {\n\t    line = next_token(arg);\n\t    ent.port = atoi(arg->ptr);\n\t}\n\telse if (!netrc && !strcmp(p, \"proxy\")) {\n\t    ent.is_proxy = 1;\n\t    line = arg;\n\t}\n\telse if (!netrc && !strcmp(p, \"path\")) {\n\t    line = next_token(arg);\n\t    /* ent.file = arg; */\n\t}\n\telse if (!netrc && !strcmp(p, \"realm\")) {\n\t    /* XXX: rest of line becomes arg for realm */\n\t    line = NULL;\n\t    ent.realm = arg;\n\t}\n\telse if (!strcmp(p, \"login\")) {\n\t    line = next_token(arg);\n\t    ent.uname = arg;\n\t}\n\telse if (!strcmp(p, \"password\") || !strcmp(p, \"passwd\")) {\n\t    line = next_token(arg);\n\t    ent.pwd = arg;\n\t}\n\telse if (netrc && !strcmp(p, \"machdef\")) {\n\t    while ((line = Strfgets(fp))->length != 0) {\n\t\tif (*line->ptr == '\\n')\n\t\t    break;\n\t    }\n\t    line = NULL;\n\t}\n\telse if (netrc && !strcmp(p, \"account\")) {\n\t    /* ignore */\n\t    line = next_token(arg);\n\t}\n\telse {\n\t    /* ignore rest of line */\n\t    line = NULL;\n\t}\n    }\n    add_auth_pass_entry(&ent, netrc, 0);\n}\n\n/* FIXME: gettextize? */\n#define FILE_IS_READABLE_MSG \"SECURITY NOTE: file %s must not be accessible by others\"\n\nFILE *\nopenSecretFile(char *fname)\n{\n    char *efname;\n    struct stat st;\n\n    if (fname == NULL)\n\treturn NULL;\n    efname = expandPath(fname);\n    if (stat(efname, &st) < 0)\n\treturn NULL;\n\n    /* check permissions, if group or others readable or writable,\n     * refuse it, because it's insecure.\n     *\n     * XXX: disable_secret_security_check will introduce some\n     *    security issues, but on some platform such as Windows\n     *    it's not possible (or feasible) to disable group|other\n     *    readable and writable.\n     *   [w3m-dev 03368][w3m-dev 03369][w3m-dev 03370]\n     */\n    if (disable_secret_security_check)\n\t/* do nothing */ ;\n    else if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {\n\tif (fmInitialized) {\n\t    message(Sprintf(FILE_IS_READABLE_MSG, fname)->ptr, 0, 0);\n\t    refresh();\n\t}\n\telse {\n\t    fputs(Sprintf(FILE_IS_READABLE_MSG, fname)->ptr, stderr);\n\t    fputc('\\n', stderr);\n\t}\n\tsleep(2);\n\treturn NULL;\n    }\n\n    return fopen(efname, \"r\");\n}\n\nvoid\nloadPasswd(void)\n{\n    FILE *fp;\n\n    passwords = NULL;\n    fp = openSecretFile(passwd_file);\n    if (fp != NULL) {\n\tparsePasswd(fp, 0);\n\tfclose(fp);\n    }\n\n    /* for FTP */\n    fp = openSecretFile(\"~/.netrc\");\n    if (fp != NULL) {\n\tparsePasswd(fp, 1);\n\tfclose(fp);\n    }\n    return;\n}\n\n/* get last modified time */\nchar *\nlast_modified(Buffer *buf)\n{\n    TextListItem *ti;\n    struct stat st;\n\n    if (buf->document_header) {\n\tfor (ti = buf->document_header->first; ti; ti = ti->next) {\n\t    if (strncasecmp(ti->ptr, \"Last-modified: \", 15) == 0) {\n\t\treturn ti->ptr + 15;\n\t    }\n\t}\n\treturn \"unknown\";\n    }\n    else if (buf->currentURL.scheme == SCM_LOCAL) {\n\tif (stat(buf->currentURL.file, &st) < 0)\n\t    return \"unknown\";\n\treturn ctime(&st.st_mtime);\n    }\n    return \"unknown\";\n}\n\nstatic char roman_num1[] = {\n    'i', 'x', 'c', 'm', '*',\n};\nstatic char roman_num5[] = {\n    'v', 'l', 'd', '*',\n};\n\nstatic Str\nromanNum2(int l, int n)\n{\n    Str s = Strnew();\n\n    switch (n) {\n    case 1:\n    case 2:\n    case 3:\n\tfor (; n > 0; n--)\n\t    Strcat_char(s, roman_num1[l]);\n\tbreak;\n    case 4:\n\tStrcat_char(s, roman_num1[l]);\n\tStrcat_char(s, roman_num5[l]);\n\tbreak;\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n\tStrcat_char(s, roman_num5[l]);\n\tfor (n -= 5; n > 0; n--)\n\t    Strcat_char(s, roman_num1[l]);\n\tbreak;\n    case 9:\n\tStrcat_char(s, roman_num1[l]);\n\tStrcat_char(s, roman_num1[l + 1]);\n\tbreak;\n    }\n    return s;\n}\n\nStr\nromanNumeral(int n)\n{\n    Str r = Strnew();\n\n    if (n <= 0)\n\treturn r;\n    if (n >= 4000) {\n\tStrcat_charp(r, \"**\");\n\treturn r;\n    }\n    Strcat(r, romanNum2(3, n / 1000));\n    Strcat(r, romanNum2(2, (n % 1000) / 100));\n    Strcat(r, romanNum2(1, (n % 100) / 10));\n    Strcat(r, romanNum2(0, n % 10));\n\n    return r;\n}\n\nStr\nromanAlphabet(int n)\n{\n    Str r = Strnew();\n    int l;\n    char buf[14];\n\n    if (n <= 0)\n\treturn r;\n\n    l = 0;\n    while (n) {\n\tbuf[l++] = 'a' + (n - 1) % 26;\n\tn = (n - 1) / 26;\n    }\n    l--;\n    for (; l >= 0; l--)\n\tStrcat_char(r, buf[l]);\n\n    return r;\n}\n\n#ifndef SIGIOT\n#define SIGIOT SIGABRT\n#endif\t\t\t\t/* not SIGIOT */\n\nstatic void\nreset_signals(void)\n{\n#ifdef SIGHUP\n    mySignal(SIGHUP, SIG_DFL);\t/* terminate process */\n#endif\n    mySignal(SIGINT, SIG_DFL);\t/* terminate process */\n#ifdef SIGQUIT\n    mySignal(SIGQUIT, SIG_DFL);\t/* terminate process */\n#endif\n    mySignal(SIGTERM, SIG_DFL);\t/* terminate process */\n    mySignal(SIGILL, SIG_DFL);\t/* create core image */\n    mySignal(SIGIOT, SIG_DFL);\t/* create core image */\n    mySignal(SIGFPE, SIG_DFL);\t/* create core image */\n#ifdef SIGBUS\n    mySignal(SIGBUS, SIG_DFL);\t/* create core image */\n#endif\t\t\t\t/* SIGBUS */\n#ifdef SIGCHLD\n    mySignal(SIGCHLD, SIG_IGN);\n#endif\n#ifdef SIGPIPE\n    mySignal(SIGPIPE, SIG_IGN);\n#endif\n}\n\n#ifndef FOPEN_MAX\n#define FOPEN_MAX 1024\t\t/* XXX */\n#endif\n\nstatic void\nclose_all_fds_except(int i, int f)\n{\n    switch (i) {\t\t/* fall through */\n    case 0:\n\tdup2(open(DEV_NULL_PATH, O_RDONLY), 0);\n    case 1:\n\tdup2(open(DEV_NULL_PATH, O_WRONLY), 1);\n    case 2:\n\tdup2(open(DEV_NULL_PATH, O_WRONLY), 2);\n    }\n    /* close all other file descriptors (socket, ...) */\n    for (i = 3; i < FOPEN_MAX; i++) {\n\tif (i != f)\n\t    close(i);\n    }\n}\n\nvoid\nsetup_child(int child, int i, int f)\n{\n    reset_signals();\n    mySignal(SIGINT, SIG_IGN);\n#ifndef __MINGW32_VERSION\n    if (!child)\n\tSETPGRP();\n#endif /* __MINGW32_VERSION */\n    /*\n     * I don't know why but close_tty() sometimes interrupts loadGeneralFile() in loadImage()\n     * and corrupt image data can be cached in ~/.w3m.\n     */\n#if 0\n    close_tty();\n#endif\n    close_all_fds_except(i, f);\n    QuietMessage = TRUE;\n    fmInitialized = FALSE;\n    TrapSignal = FALSE;\n}\n\n#ifndef __MINGW32_VERSION\npid_t\nopen_pipe_rw(FILE ** fr, FILE ** fw)\n{\n    int fdr[2];\n    int fdw[2];\n    pid_t pid;\n\n    if (fr && pipe(fdr) < 0)\n\tgoto err0;\n    if (fw && pipe(fdw) < 0)\n\tgoto err1;\n\n    flush_tty();\n    pid = fork();\n    if (pid < 0)\n\tgoto err2;\n    if (pid == 0) {\n\t/* child */\n\tif (fr) {\n\t    close(fdr[0]);\n\t    dup2(fdr[1], 1);\n\t}\n\tif (fw) {\n\t    close(fdw[1]);\n\t    dup2(fdw[0], 0);\n\t}\n    }\n    else {\n\tif (fr) {\n\t    close(fdr[1]);\n\t    if (*fr == stdin)\n\t\tdup2(fdr[0], 0);\n\t    else\n\t\t*fr = fdopen(fdr[0], \"r\");\n\t}\n\tif (fw) {\n\t    close(fdw[0]);\n\t    if (*fw == stdout)\n\t\tdup2(fdw[1], 1);\n\t    else\n\t\t*fw = fdopen(fdw[1], \"w\");\n\t}\n    }\n    return pid;\n  err2:\n    if (fw) {\n\tclose(fdw[0]);\n\tclose(fdw[1]);\n    }\n  err1:\n    if (fr) {\n\tclose(fdr[0]);\n\tclose(fdr[1]);\n    }\n  err0:\n    return (pid_t) - 1;\n}\n#endif /* __MINGW32_VERSION */\n\nvoid\nmyExec(char *command)\n{\n    mySignal(SIGINT, SIG_DFL);\n    execl(\"/bin/sh\", \"sh\", \"-c\", command, NULL);\n    exit(127);\n}\n\nvoid\nmySystem(char *command, int background)\n{\n#ifndef __MINGW32_VERSION\n    if (background) {\n#ifndef __EMX__\n\tflush_tty();\n\tif (!fork()) {\n\t    setup_child(FALSE, 0, -1);\n\t    myExec(command);\n\t}\n#else\n\tStr cmd = Strnew_charp(\"start /f \");\n\tStrcat_charp(cmd, command);\n\tsystem(cmd->ptr);\n#endif\n    }\n    else\n#endif /* __MINGW32_VERSION */\n\tsystem(command);\n}\n\nStr\nmyExtCommand(char *cmd, char *arg, int redirect)\n{\n    Str tmp = NULL;\n    char *p;\n    int set_arg = FALSE;\n\n    for (p = cmd; *p; p++) {\n\tif (*p == '%' && *(p + 1) == 's' && !set_arg) {\n\t    if (tmp == NULL)\n\t\ttmp = Strnew_charp_n(cmd, (int)(p - cmd));\n\t    Strcat_charp(tmp, arg);\n\t    set_arg = TRUE;\n\t    p++;\n\t}\n\telse {\n\t    if (tmp)\n\t\tStrcat_char(tmp, *p);\n\t}\n    }\n    if (!set_arg) {\n\tif (redirect)\n\t    tmp = Strnew_m_charp(\"(\", cmd, \") < \", arg, NULL);\n\telse\n\t    tmp = Strnew_m_charp(cmd, \" \", arg, NULL);\n    }\n    return tmp;\n}\n\nStr\nmyEditor(char *cmd, char *file, int line)\n{\n    Str tmp = NULL;\n    char *p;\n    int set_file = FALSE, set_line = FALSE;\n\n    for (p = cmd; *p; p++) {\n\tif (*p == '%' && *(p + 1) == 's' && !set_file) {\n\t    if (tmp == NULL)\n\t\ttmp = Strnew_charp_n(cmd, (int)(p - cmd));\n\t    Strcat_charp(tmp, file);\n\t    set_file = TRUE;\n\t    p++;\n\t}\n\telse if (*p == '%' && *(p + 1) == 'd' && !set_line && line > 0) {\n\t    if (tmp == NULL)\n\t\ttmp = Strnew_charp_n(cmd, (int)(p - cmd));\n\t    Strcat(tmp, Sprintf(\"%d\", line));\n\t    set_line = TRUE;\n\t    p++;\n\t}\n\telse {\n\t    if (tmp)\n\t\tStrcat_char(tmp, *p);\n\t}\n    }\n    if (!set_file) {\n\tif (tmp == NULL)\n\t    tmp = Strnew_charp(cmd);\n\tif (!set_line && line > 1 && strcasestr(cmd, \"vi\"))\n\t    Strcat(tmp, Sprintf(\" +%d\", line));\n\tStrcat_m_charp(tmp, \" \", file, NULL);\n    }\n    return tmp;\n}\n\n#ifdef __MINGW32_VERSION\nchar *\nexpandName(char *name)\n{\n    return getenv(\"HOME\");\n}\n#else\nchar *\nexpandName(char *name)\n{\n    char *p;\n    struct passwd *passent, *getpwnam(const char *);\n    Str extpath = NULL;\n\n    if (name == NULL)\n\treturn NULL;\n    p = name;\n    if (*p == '/') {\n\tif ((*(p + 1) == '~' && IS_ALPHA(*(p + 2)))\n\t    && personal_document_root) {\n\t    char *q;\n\t    p += 2;\n\t    q = strchr(p, '/');\n\t    if (q) {\t\t/* /~user/dir... */\n\t\tpassent = getpwnam(allocStr(p, q - p));\n\t\tp = q;\n\t    }\n\t    else {\t\t/* /~user */\n\t\tpassent = getpwnam(p);\n\t\tp = \"\";\n\t    }\n\t    if (!passent)\n\t\tgoto rest;\n\t    extpath = Strnew_m_charp(passent->pw_dir, \"/\",\n\t\t\t\t     personal_document_root, NULL);\n\t    if (*personal_document_root == '\\0' && *p == '/')\n\t\tp++;\n\t}\n\telse\n\t    goto rest;\n\tif (Strcmp_charp(extpath, \"/\") == 0 && *p == '/')\n\t    p++;\n\tStrcat_charp(extpath, p);\n\treturn extpath->ptr;\n    }\n    else\n\treturn expandPath(p);\n  rest:\n    return name;\n}\n#endif\n\nint\nis_localhost(const char *host)\n{\n    if (!host ||\n\t!strcasecmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\") ||\n\t(HostName && !strcasecmp(host, HostName)) || !strcmp(host, \"[::1]\"))\n\treturn TRUE;\n    return FALSE;\n}\n\nchar *\nfile_to_url(char *file)\n{\n    Str tmp;\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n    char *drive = NULL;\n#endif\n#ifdef SUPPORT_NETBIOS_SHARE\n    char *host = NULL;\n#endif\n\n    if (!(file = expandPath(file)))\n\treturn NULL;\n#ifdef SUPPORT_NETBIOS_SHARE\n    if (file[0] == '/' && file[1] == '/') {\n\tchar *p;\n\tfile += 2;\n\tif (*file) {\n\t    p = strchr(file, '/');\n\t    if (p != NULL && p != file) {\n\t\thost = allocStr(file, (p - file));\n\t\tfile = p;\n\t    }\n\t}\n    }\n#endif\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n    if (IS_ALPHA(file[0]) && file[1] == ':') {\n\tdrive = allocStr(file, 2);\n\tfile += 2;\n    }\n    else\n#endif\n    if (file[0] != '/') {\n\ttmp = Strnew_charp(CurrentDir);\n\tif (Strlastchar(tmp) != '/')\n\t    Strcat_char(tmp, '/');\n\tStrcat_charp(tmp, file);\n\tfile = tmp->ptr;\n    }\n    tmp = Strnew_charp(\"file://\");\n#ifdef SUPPORT_NETBIOS_SHARE\n    if (host)\n\tStrcat_charp(tmp, host);\n#endif\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n    if (drive)\n\tStrcat_charp(tmp, drive);\n#endif\n    Strcat_charp(tmp, file_quote(cleanupName(file)));\n    return tmp->ptr;\n}\n\n#ifdef USE_M17N\nchar *\nurl_unquote_conv(char *url, wc_ces charset)\n#else\nchar *\nurl_unquote_conv0(char *url)\n#endif\n{\n#ifdef USE_M17N\n    wc_uint8 old_auto_detect = WcOption.auto_detect;\n#endif\n    Str tmp;\n    tmp = Str_url_unquote(Strnew_charp(url), FALSE, TRUE);\n#ifdef USE_M17N\n    if (!charset || charset == WC_CES_US_ASCII)\n\tcharset = SystemCharset;\n    WcOption.auto_detect = WC_OPT_DETECT_ON;\n    tmp = convertLine(NULL, tmp, RAW_MODE, &charset, charset);\n    WcOption.auto_detect = old_auto_detect;\n#endif\n    return tmp->ptr;\n}\n\nstatic char *tmpf_base[MAX_TMPF_TYPE] = {\n    \"tmp\", \"src\", \"frame\", \"cache\", \"cookie\", \"hist\",\n};\nstatic unsigned int tmpf_seq[MAX_TMPF_TYPE];\n\nStr\ntmpfname(int type, char *ext)\n{\n    Str tmpf;\n    char *dir;\n\n    switch(type) {\n    case TMPF_HIST:\n\tdir = rc_dir;\n\tbreak;\n    case TMPF_DFL:\n    case TMPF_COOKIE:\n    case TMPF_SRC:\n    case TMPF_FRAME:\n    case TMPF_CACHE:\n    default:\n\tdir = tmp_dir;\n    }\n\n    tmpf = Sprintf(\"%s/w3m%s%d-%d%s\",\n\t\t   dir,\n\t\t   tmpf_base[type],\n\t\t   CurrentPid, tmpf_seq[type]++, (ext) ? ext : \"\");\n    pushText(fileToDelete, tmpf->ptr);\n    return tmpf;\n}\n\nstatic char *monthtbl[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic int\nget_day(char **s)\n{\n    Str tmp = Strnew();\n    int day;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n\n    day = atoi(tmp->ptr);\n\n    if (day < 1 || day > 31) {\n\t*s = ss;\n\treturn -1;\n    }\n    return day;\n}\n\nstatic int\nget_month(char **s)\n{\n    Str tmp = Strnew();\n    int mon;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (tmp->length > 0) {\n\tmon = atoi(tmp->ptr);\n    }\n    else {\n\twhile (**s && IS_ALPHA(**s))\n\t    Strcat_char(tmp, *((*s)++));\n\tfor (mon = 1; mon <= 12; mon++) {\n\t    if (strncmp(tmp->ptr, monthtbl[mon - 1], 3) == 0)\n\t\tbreak;\n\t}\n    }\n    if (mon < 1 || mon > 12) {\n\t*s = ss;\n\treturn -1;\n    }\n    return mon;\n}\n\nstatic int\nget_year(char **s)\n{\n    Str tmp = Strnew();\n    int year;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (tmp->length != 2 && tmp->length != 4) {\n\t*s = ss;\n\treturn -1;\n    }\n\n    year = atoi(tmp->ptr);\n    if (tmp->length == 2) {\n\tif (year >= 70)\n\t    year += 1900;\n\telse\n\t    year += 2000;\n    }\n    return year;\n}\n\nstatic int\nget_time(char **s, int *hour, int *min, int *sec)\n{\n    Str tmp = Strnew();\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (**s != ':') {\n\t*s = ss;\n\treturn -1;\n    }\n    *hour = atoi(tmp->ptr);\n\n    (*s)++;\n    Strclear(tmp);\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (**s != ':') {\n\t*s = ss;\n\treturn -1;\n    }\n    *min = atoi(tmp->ptr);\n\n    (*s)++;\n    Strclear(tmp);\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    *sec = atoi(tmp->ptr);\n\n    if (*hour < 0 || *hour >= 24 ||\n\t*min < 0 || *min >= 60 || *sec < 0 || *sec >= 60) {\n\t*s = ss;\n\treturn -1;\n    }\n    return 0;\n}\n\nstatic int\nget_zone(char **s, int *z_hour, int *z_min)\n{\n    Str tmp = Strnew();\n    int zone;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    if (**s == '+' || **s == '-')\n\tStrcat_char(tmp, *((*s)++));\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (!(tmp->length == 4 && IS_DIGIT(*ss)) &&\n\t!(tmp->length == 5 && (*ss == '+' || *ss == '-'))) {\n\t*s = ss;\n\treturn -1;\n    }\n\n    zone = atoi(tmp->ptr);\n    *z_hour = zone / 100;\n    *z_min = zone - (zone / 100) * 100;\n    return 0;\n}\n\n/* RFC 1123 or RFC 850 or ANSI C asctime() format string -> time_t */\ntime_t\nmymktime(char *timestr)\n{\n    char *s;\n    int day, mon, year, hour, min, sec, z_hour = 0, z_min = 0;\n\n    if (!(timestr && *timestr))\n\treturn -1;\n    s = timestr;\n\n#ifdef DEBUG\n    fprintf(stderr, \"mktime: %s\\n\", timestr);\n#endif\t\t\t\t/* DEBUG */\n\n    while (*s && IS_ALPHA(*s))\n\ts++;\n    while (*s && !IS_ALNUM(*s))\n\ts++;\n\n    if (IS_DIGIT(*s)) {\n\t/* RFC 1123 or RFC 850 format */\n\tif ((day = get_day(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_ALNUM(*s))\n\t    s++;\n\tif ((mon = get_month(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif ((year = get_year(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif (!*s) {\n\t    hour = 0;\n\t    min = 0;\n\t    sec = 0;\n\t}\n\telse {\n\t    if (get_time(&s, &hour, &min, &sec) == -1)\n\t\treturn -1;\n\t    while (*s && !IS_DIGIT(*s) && *s != '+' && *s != '-')\n\t\ts++;\n\t    get_zone(&s, &z_hour, &z_min);\n\t}\n    }\n    else {\n\t/* ANSI C asctime() format. */\n\twhile (*s && !IS_ALNUM(*s))\n\t    s++;\n\tif ((mon = get_month(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif ((day = get_day(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif (get_time(&s, &hour, &min, &sec) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif ((year = get_year(&s)) == -1)\n\t    return -1;\n    }\n#ifdef DEBUG\n    fprintf(stderr,\n\t    \"year=%d month=%d day=%d hour:min:sec=%d:%d:%d zone=%d:%d\\n\", year,\n\t    mon, day, hour, min, sec, z_hour, z_min);\n#endif\t\t\t\t/* DEBUG */\n\n    mon -= 3;\n    if (mon < 0) {\n\tmon += 12;\n\tyear--;\n    }\n    day += (year - 1968) * 1461 / 4;\n    day += ((((mon * 153) + 2) / 5) - 672);\n    hour -= z_hour;\n    min -= z_min;\n    return (time_t) ((day * 60 * 60 * 24) +\n\t\t     (hour * 60 * 60) + (min * 60) + sec);\n}\n\n#ifdef USE_COOKIE\n#ifdef INET6\n#include <sys/socket.h>\n#endif\t\t\t\t/* INET6 */\n#ifndef __MINGW32_VERSION\n#include <netdb.h>\n#else\n#include <winsock.h>\n#endif\nchar *\nFQDN(char *host)\n{\n    char *p;\n#ifndef INET6\n    struct hostent *entry;\n#else\t\t\t\t/* INET6 */\n    int *af;\n#endif\t\t\t\t/* INET6 */\n\n    if (host == NULL)\n\treturn NULL;\n\n    if (strcasecmp(host, \"localhost\") == 0)\n\treturn host;\n\n    for (p = host; *p && *p != '.'; p++) ;\n\n    if (*p == '.')\n\treturn host;\n\n#ifndef INET6\n    if (!(entry = gethostbyname(host)))\n\treturn NULL;\n\n    return allocStr(entry->h_name, -1);\n#else\t\t\t\t/* INET6 */\n    for (af = ai_family_order_table[DNS_order];; af++) {\n\tint error;\n\tstruct addrinfo hints;\n\tstruct addrinfo *res, *res0;\n\tchar *namebuf;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_flags = AI_CANONNAME;\n\thints.ai_family = *af;\n\thints.ai_socktype = SOCK_STREAM;\n\terror = getaddrinfo(host, NULL, &hints, &res0);\n\tif (error) {\n\t    if (*af == PF_UNSPEC) {\n\t\t/* all done */\n\t\tbreak;\n\t    }\n\t    /* try next address family */\n\t    continue;\n\t}\n\tfor (res = res0; res != NULL; res = res->ai_next) {\n\t    if (res->ai_canonname) {\n\t\t/* found */\n\t\tnamebuf = strdup(res->ai_canonname);\n\t\tfreeaddrinfo(res0);\n\t\treturn namebuf;\n\t    }\n\t}\n\tfreeaddrinfo(res0);\n\tif (*af == PF_UNSPEC) {\n\t    break;\n\t}\n    }\n    /* all failed */\n    return NULL;\n#endif\t\t\t\t/* INET6 */\n}\n\n#endif\t\t\t\t/* USE_COOKIE */\n\nvoid (*mySignal(int signal_number, void (*action) (int))) (int) {\n#ifdef\tSA_RESTART\n    struct sigaction new_action, old_action;\n\n    sigemptyset(&new_action.sa_mask);\n    new_action.sa_handler = action;\n    if (signal_number == SIGALRM) {\n#ifdef\tSA_INTERRUPT\n\tnew_action.sa_flags = SA_INTERRUPT;\n#else\n\tnew_action.sa_flags = 0;\n#endif\n    }\n    else {\n\tnew_action.sa_flags = SA_RESTART;\n    }\n    sigaction(signal_number, &new_action, &old_action);\n    return (old_action.sa_handler);\n#else\n    return (signal(signal_number, action));\n#endif\n}\n\nstatic char Base64Table[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nStr\nbase64_encode(const char *src, size_t len)\n{\n    Str dest;\n    const unsigned char *in, *endw, *s;\n    unsigned long j;\n    size_t k;\n\n    s = (unsigned char*)src;\n\n    k = len;\n    if (k % 3)\n\tk += 3 - (k % 3);\n\n    k = k / 3 * 4;\n\n    if (!len || k + 1 < len)\n\treturn Strnew();\n\n    dest = Strnew_size(k);\n    if (dest->area_size <= k) {\n\tStrfree(dest);\n\treturn Strnew();\n    }\n\n    in = s;\n\n    endw = s + len - 2;\n\n    while (in < endw) {\n\tj = *in++;\n\tj = j << 8 | *in++;\n\tj = j << 8 | *in++;\n\n\tStrcatc(dest, Base64Table[(j >> 18) & 0x3f]);\n\tStrcatc(dest, Base64Table[(j >> 12) & 0x3f]);\n\tStrcatc(dest, Base64Table[(j >> 6) & 0x3f]);\n\tStrcatc(dest, Base64Table[j & 0x3f]);\n    }\n\n    if (s + len - in) {\n\tj = *in++;\n\tif (s + len - in) {\n\t    j = j << 8 | *in++;\n\t    j = j << 8;\n\t    Strcatc(dest, Base64Table[(j >> 18) & 0x3f]);\n\t    Strcatc(dest, Base64Table[(j >> 12) & 0x3f]);\n\t    Strcatc(dest, Base64Table[(j >> 6) & 0x3f]);\n\t} else {\n\t    j = j << 8;\n\t    j = j << 8;\n\t    Strcatc(dest, Base64Table[(j >> 18) & 0x3f]);\n\t    Strcatc(dest, Base64Table[(j >> 12) & 0x3f]);\n\t    Strcatc(dest, '=');\n\t}\n\tStrcatc(dest, '=');\n    }\n    Strnulterm(dest);\n    return dest;\n}\n"], "fixing_code": ["/* $Id: etc.c,v 1.81 2007/05/23 15:06:05 inu Exp $ */\n#include \"fm.h\"\n#ifndef __MINGW32_VERSION\n#include <pwd.h>\n#endif\n#include \"myctype.h\"\n#include \"html.h\"\n#include \"local.h\"\n#include \"hash.h\"\n\n#include <fcntl.h>\n#include <sys/types.h>\n#include <time.h>\n#if defined(HAVE_WAITPID) || defined(HAVE_WAIT3)\n#include <sys/wait.h>\n#endif\n#include <signal.h>\n\n#ifdef\t__WATT32__\n#define\tread(a,b,c)\tread_s(a,b,c)\n#define\tclose(x)\tclose_s(x)\n#endif\t\t\t\t/* __WATT32__ */\n\nstruct auth_pass {\n    int bad;\n    int is_proxy;\n    Str host;\n    int port;\n/*    Str file; */\n    Str realm;\n    Str uname;\n    Str pwd;\n    struct auth_pass *next;\n};\n\nstruct auth_pass *passwords = NULL;\n\nint\ncolumnSkip(Buffer *buf, int offset)\n{\n    int i, maxColumn;\n    int column = buf->currentColumn + offset;\n    int nlines = buf->LINES + 1;\n    Line *l;\n\n    maxColumn = 0;\n    for (i = 0, l = buf->topLine; i < nlines && l != NULL; i++, l = l->next) {\n\tif (l->width < 0)\n\t    l->width = COLPOS(l, l->len);\n\tif (l->width - 1 > maxColumn)\n\t    maxColumn = l->width - 1;\n    }\n    maxColumn -= buf->COLS - 1;\n    if (column < maxColumn)\n\tmaxColumn = column;\n    if (maxColumn < 0)\n\tmaxColumn = 0;\n\n    if (buf->currentColumn == maxColumn)\n\treturn 0;\n    buf->currentColumn = maxColumn;\n    return 1;\n}\n\nint\ncolumnPos(Line *line, int column)\n{\n    int i;\n\n    for (i = 1; i < line->len; i++) {\n\tif (COLPOS(line, i) > column)\n\t    break;\n    }\n#ifdef USE_M17N\n    for (i--; i > 0 && line->propBuf[i] & PC_WCHAR2; i--) ;\n    return i;\n#else\n    return i - 1;\n#endif\n}\n\nLine *\nlineSkip(Buffer *buf, Line *line, int offset, int last)\n{\n    int i;\n    Line *l;\n\n    l = currentLineSkip(buf, line, offset, last);\n    if (!nextpage_topline)\n\tfor (i = buf->LINES - 1 - (buf->lastLine->linenumber - l->linenumber);\n\t     i > 0 && l->prev != NULL; i--, l = l->prev) ;\n    return l;\n}\n\nLine *\ncurrentLineSkip(Buffer *buf, Line *line, int offset, int last)\n{\n    int i, n;\n    Line *l = line;\n\n    if (buf->pagerSource && !(buf->bufferprop & BP_CLOSE)) {\n\tn = line->linenumber + offset + buf->LINES;\n\tif (buf->lastLine->linenumber < n)\n\t    getNextPage(buf, n - buf->lastLine->linenumber);\n\twhile ((last || (buf->lastLine->linenumber < n)) &&\n\t       (getNextPage(buf, 1) != NULL)) ;\n\tif (last)\n\t    l = buf->lastLine;\n    }\n\n    if (offset == 0)\n\treturn l;\n    if (offset > 0)\n\tfor (i = 0; i < offset && l->next != NULL; i++, l = l->next) ;\n    else\n\tfor (i = 0; i < -offset && l->prev != NULL; i++, l = l->prev) ;\n    return l;\n}\n\n#define MAX_CMD_LEN 128\n\nint\ngethtmlcmd(char **s)\n{\n    extern Hash_si tagtable;\n    char cmdstr[MAX_CMD_LEN];\n    char *p = cmdstr;\n    char *save = *s;\n    int cmd;\n\n    (*s)++;\n    /* first character */\n    if (IS_ALNUM(**s) || **s == '_' || **s == '/') {\n\t*(p++) = TOLOWER(**s);\n\t(*s)++;\n    }\n    else\n\treturn HTML_UNKNOWN;\n    if (p[-1] == '/')\n\tSKIP_BLANKS(*s);\n    while ((IS_ALNUM(**s) || **s == '_') && p - cmdstr < MAX_CMD_LEN) {\n\t*(p++) = TOLOWER(**s);\n\t(*s)++;\n    }\n    if (p - cmdstr == MAX_CMD_LEN) {\n\t/* buffer overflow: perhaps caused by bad HTML source */\n\t*s = save + 1;\n\treturn HTML_UNKNOWN;\n    }\n    *p = '\\0';\n\n    /* hash search */\n    cmd = getHash_si(&tagtable, cmdstr, HTML_UNKNOWN);\n    while (**s && **s != '>')\n\t(*s)++;\n    if (**s == '>')\n\t(*s)++;\n    return cmd;\n}\n\n#ifdef USE_ANSI_COLOR\nstatic int\nparse_ansi_color(char **str, Lineprop *effect, Linecolor *color)\n{\n    char *p = *str, *q;\n    Lineprop e = *effect;\n    Linecolor c = *color;\n    int i;\n\n    if (*p != ESC_CODE || *(p + 1) != '[')\n\treturn 0;\n    p += 2;\n    for (q = p; IS_DIGIT(*q) || *q == ';'; q++) ;\n    if (*q != 'm')\n\treturn 0;\n    *str = q + 1;\n    while (1) {\n\tif (*p == 'm') {\n\t    e = PE_NORMAL;\n\t    c = 0;\n\t    break;\n\t}\n\tif (IS_DIGIT(*p)) {\n\t    q = p;\n\t    for (p++; IS_DIGIT(*p); p++) ;\n\t    i = atoi(allocStr(q, p - q));\n\t    switch (i) {\n\t    case 0:\n\t\te = PE_NORMAL;\n\t\tc = 0;\n\t\tbreak;\n\t    case 1:\n\t    case 5:\n\t\te = PE_BOLD;\n\t\tbreak;\n\t    case 4:\n\t\te = PE_UNDER;\n\t\tbreak;\n\t    case 7:\n\t\te = PE_STAND;\n\t\tbreak;\n\t    case 100:\t\t/* for EWS4800 kterm */\n\t\tc = 0;\n\t\tbreak;\n\t    case 39:\n\t\tc &= 0xf0;\n\t\tbreak;\n\t    case 49:\n\t\tc &= 0x0f;\n\t\tbreak;\n\t    default:\n\t\tif (i >= 30 && i <= 37)\n\t\t    c = (c & 0xf0) | (i - 30) | 0x08;\n\t\telse if (i >= 40 && i <= 47)\n\t\t    c = (c & 0x0f) | ((i - 40) << 4) | 0x80;\n\t\tbreak;\n\t    }\n\t    if (*p == 'm')\n\t\tbreak;\n\t}\n\telse {\n\t    e = PE_NORMAL;\n\t    c = 0;\n\t    break;\n\t}\n\tp++;\t\t\t/* *p == ';' */\n    }\n    *effect = e;\n    *color = c;\n    return 1;\n}\n#endif\n/* \n * Check character type\n */\n\nStr\ncheckType(Str s, Lineprop **oprop, Linecolor **ocolor)\n{\n    Lineprop mode;\n    Lineprop effect = PE_NORMAL;\n    Lineprop *prop;\n    static Lineprop *prop_buffer = NULL;\n    static int prop_size = 0;\n    char *str = s->ptr, *endp = &s->ptr[s->length], *bs = NULL;\n#ifdef USE_ANSI_COLOR\n    Lineprop ceffect = PE_NORMAL;\n    Linecolor cmode = 0;\n    int check_color = FALSE;\n    Linecolor *color = NULL;\n    static Linecolor *color_buffer = NULL;\n    static int color_size = 0;\n    char *es = NULL;\n#endif\n    int do_copy = FALSE;\n#ifdef USE_M17N\n    int i;\n    int plen = 0, clen;\n    int *plens = NULL;\n    static int *plens_buffer = NULL;\n    static int plens_size = 0;\n#endif\n\n    if (prop_size < s->length) {\n\tprop_size = (s->length > LINELEN) ? s->length : LINELEN;\n\tprop_buffer = New_Reuse(Lineprop, prop_buffer, prop_size);\n    }\n    prop = prop_buffer;\n#ifdef USE_M17N\n    if (plens_size < s->length) {\n\tplens_size = (s->length > LINELEN) ? s->length : LINELEN;\n\tplens_buffer = New_Reuse(int, plens_buffer, plens_size);\n    }\n    plens = plens_buffer;\n#endif\n\n    if (ShowEffect) {\n\tbs = memchr(str, '\\b', s->length);\n#ifdef USE_ANSI_COLOR\n\tif (ocolor) {\n\t    es = memchr(str, ESC_CODE, s->length);\n\t    if (es) {\n\t\tif (color_size < s->length) {\n\t\t    color_size = (s->length > LINELEN) ? s->length : LINELEN;\n\t\t    color_buffer = New_Reuse(Linecolor, color_buffer,\n\t\t\t\t\t     color_size);\n\t\t}\n\t\tcolor = color_buffer;\n\t    }\n\t}\n#endif\n\tif ((bs != NULL)\n#ifdef USE_ANSI_COLOR\n\t    || (es != NULL)\n#endif\n\t    ) {\n\t    char *sp = str, *ep;\n\t    s = Strnew_size(s->length);\n\t    do_copy = TRUE;\n\t    ep = endp;\n\t    if (bs && ep > bs - 2)\n\t\tep = bs - 2;\n#ifdef USE_ANSI_COLOR\n\t    if (es && ep > es - 2)\n\t\tep = es - 2;\n#endif\n\t    for (; str < ep && IS_ASCII(*str); str++) {\n\t\t*(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);\n#ifdef USE_ANSI_COLOR\n\t\tif (color)\n\t\t    *(color++) = 0;\n#endif\n#ifdef USE_M17N\n\t\t*(plens++) = plen = 1;\n#endif\n\t    }\n\t    Strcat_charp_n(s, sp, (int)(str - sp));\n\t}\n    }\n    if (!do_copy) {\n\tfor (; str < endp && IS_ASCII(*str); str++) {\n\t    *(prop++) = PE_NORMAL | (IS_CNTRL(*str) ? PC_CTRL : PC_ASCII);\n#ifdef USE_ANSI_COLOR\n\t    if (color)\n\t\t*(color++) = 0;\n#endif\n#ifdef USE_M17N\n\t    *(plens++) = plen = 1;\n#endif\n\t}\n    }\n\n    while (str < endp) {\n\tif (prop - prop_buffer >= prop_size)\n\t    break;\n\tif (bs != NULL) {\n#ifdef USE_M17N\n\t    if (str == bs - 2 && !strncmp(str, \"__\\b\\b\", 4)) {\n\t\tstr += 4;\n\t\teffect = PE_UNDER;\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n\t    else\n#endif\n\t    if (str == bs - 1 && *str == '_') {\n\t\tstr += 2;\n\t\teffect = PE_UNDER;\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n\t    else if (str == bs) {\n\t\tif (*(str + 1) == '_') {\n\t\t    if (s->length) {\n\t\t\tstr += 2;\n#ifdef USE_M17N\n\t\t\tfor (i = 1; i <= plen; i++)\n\t\t\t    *(prop - i) |= PE_UNDER;\n#else\n\t\t\t*(prop - 1) |= PE_UNDER;\n#endif\n\t\t    }\n\t\t    else {\n\t\t\tstr++;\n\t\t    }\n\t\t}\n#ifdef USE_M17N\n\t\telse if (!strncmp(str + 1, \"\\b__\", 3)) {\n\t\t    if (s->length) {\n\t\t\tstr += (plen == 1) ? 3 : 4;\n\t\t\tfor (i = 1; i <= plen; i++)\n\t\t\t    *(prop - i) |= PE_UNDER;\n\t\t    }\n\t\t    else {\n\t\t\tstr += 2;\n\t\t    }\n\t\t}\n\t\telse if (*(str + 1) == '\\b') {\n\t\t    if (s->length) {\n\t\t\tclen = get_mclen(str + 2);\n\t\t\tif (plen == clen &&\n\t\t\t    !strncmp(str - plen, str + 2, plen)) {\n\t\t\t    for (i = 1; i <= plen; i++)\n\t\t\t\t*(prop - i) |= PE_BOLD;\n\t\t\t    str += 2 + clen;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, plen);\n\t\t\t    prop -= plen;\n#ifdef USE_ANSI_COLOR\n\t\t\t    if (color)\n\t\t\t\tcolor -= plen;\n#endif\n\t\t\t    if (plens == plens_buffer)\n\t\t\t\tplen = 0;\n\t\t\t    else\n\t\t\t\tplen = *(--plens);\n\t\t\t    str += 2;\n\t\t\t}\n\t\t    }\n\t\t    else {\n\t\t\tstr += 2;\n\t\t    }\n\t\t}\n#endif\n\t\telse {\n\t\t    if (s->length) {\n#ifdef USE_M17N\n\t\t\tclen = get_mclen(str + 1);\n\t\t\tif (plen == clen &&\n\t\t\t    !strncmp(str - plen, str + 1, plen)) {\n\t\t\t    for (i = 1; i <= plen; i++)\n\t\t\t\t*(prop - i) |= PE_BOLD;\n\t\t\t    str += 1 + clen;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, plen);\n\t\t\t    prop -= plen;\n#ifdef USE_ANSI_COLOR\n\t\t\t    if (color)\n\t\t\t\tcolor -= plen;\n#endif\n\t\t\t    if (plens == plens_buffer)\n\t\t\t\tplen = 0;\n\t\t\t    else\n\t\t\t\tplen = *(--plens);\n\t\t\t    str++;\n\t\t\t}\n#else\n\t\t\tif (*(str - 1) == *(str + 1)) {\n\t\t\t    *(prop - 1) |= PE_BOLD;\n\t\t\t    str += 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t    Strshrink(s, 1);\n\t\t\t    prop--;\n#ifdef USE_ANSI_COLOR\n\t\t\t    if (color)\n\t\t\t\tcolor--;\n#endif\n\t\t\t    str++;\n\t\t\t}\n#endif\n\t\t    }\n\t\t    else {\n\t\t\tstr++;\n\t\t    }\n\t\t}\n\t\tif (str < endp)\n\t\t    bs = memchr(str, '\\b', endp - str);\n\t\tcontinue;\n\t    }\n#ifdef USE_ANSI_COLOR\n\t    else if (str > bs)\n\t\tbs = memchr(str, '\\b', endp - str);\n#endif\n\t}\n#ifdef USE_ANSI_COLOR\n\tif (es != NULL) {\n\t    if (str == es) {\n\t\tint ok = parse_ansi_color(&str, &ceffect, &cmode);\n\t\tif (str < endp)\n\t\t    es = memchr(str, ESC_CODE, endp - str);\n\t\tif (ok) {\n\t\t    if (cmode)\n\t\t\tcheck_color = TRUE;\n\t\t    continue;\n\t\t}\n\t    }\n\t    else if (str > es)\n\t\tes = memchr(str, ESC_CODE, endp - str);\n\t}\n#endif\n\n\tmode = get_mctype(str) | effect;\n#ifdef USE_ANSI_COLOR\n\tif (color) {\n\t    *(color++) = cmode;\n\t    mode |= ceffect;\n\t}\n#endif\n\t*(prop++) = mode;\n#ifdef USE_M17N\n\tplen = get_mclen(str);\n\tif (str + plen > endp)\n\t    plen = endp - str;\n\t*(plens++) = plen;\n\tif (plen > 1) {\n\t    mode = (mode & ~PC_WCHAR1) | PC_WCHAR2;\n\t    for (i = 1; i < plen; i++) {\n\t\t*(prop++) = mode;\n#ifdef USE_ANSI_COLOR\n\t\tif (color)\n\t\t    *(color++) = cmode;\n#endif\n\t    }\n\t    if (do_copy)\n\t\tStrcat_charp_n(s, (char *)str, plen);\n\t    str += plen;\n\t}\n\telse\n#endif\n\t{\n\t    if (do_copy)\n\t\tStrcat_char(s, (char)*str);\n\t    str++;\n\t}\n\teffect = PE_NORMAL;\n    }\n    *oprop = prop_buffer;\n#ifdef USE_ANSI_COLOR\n    if (ocolor)\n\t*ocolor = check_color ? color_buffer : NULL;\n#endif\n    return s;\n}\n\nstatic int\nnextColumn(int n, char *p, Lineprop *pr)\n{\n    if (*pr & PC_CTRL) {\n\tif (*p == '\\t')\n\t    return (n + Tabstop) / Tabstop * Tabstop;\n\telse if (*p == '\\n')\n\t    return n + 1;\n\telse if (*p != '\\r')\n\t    return n + 2;\n\treturn n;\n    }\n#ifdef USE_M17N\n    if (*pr & PC_UNKNOWN)\n\treturn n + 4;\n    return n + wtf_width((wc_uchar *) p);\n#else\n    return n + 1;\n#endif\n}\n\nint\ncalcPosition(char *l, Lineprop *pr, int len, int pos, int bpos, int mode)\n{\n    static int *realColumn = NULL;\n    static int size = 0;\n    static char *prevl = NULL;\n    int i, j;\n\n    if (l == NULL || len == 0 || pos < 0)\n\treturn bpos;\n    if (l == prevl && mode == CP_AUTO) {\n\tif (pos <= len)\n\t    return realColumn[pos];\n    }\n    if (size < len + 1) {\n\tsize = (len + 1 > LINELEN) ? (len + 1) : LINELEN;\n\trealColumn = New_N(int, size);\n    }\n    prevl = l;\n    i = 0;\n    j = bpos;\n#ifdef USE_M17N\n    if (pr[i] & PC_WCHAR2) {\n\tfor (; i < len && pr[i] & PC_WCHAR2; i++)\n\t    realColumn[i] = j;\n\tif (i > 0 && pr[i - 1] & PC_KANJI && WcOption.use_wide)\n\t    j++;\n    }\n#endif\n    while (1) {\n\trealColumn[i] = j;\n\tif (i == len)\n\t    break;\n\tj = nextColumn(j, &l[i], &pr[i]);\n\ti++;\n#ifdef USE_M17N\n\tfor (; i < len && pr[i] & PC_WCHAR2; i++)\n\t    realColumn[i] = realColumn[i - 1];\n#endif\n    }\n    if (pos >= i)\n\treturn j;\n    return realColumn[pos];\n}\n\nint\ncolumnLen(Line *line, int column)\n{\n    int i, j;\n\n    for (i = 0, j = 0; i < line->len;) {\n\tj = nextColumn(j, &line->lineBuf[i], &line->propBuf[i]);\n\tif (j > column)\n\t    return i;\n\ti++;\n#ifdef USE_M17N\n\twhile (i < line->len && line->propBuf[i] & PC_WCHAR2)\n\t    i++;\n#endif\n    }\n    return line->len;\n}\n\nchar *\nlastFileName(char *path)\n{\n    char *p, *q;\n\n    p = q = path;\n    while (*p != '\\0') {\n\tif (*p == '/')\n\t    q = p + 1;\n\tp++;\n    }\n\n    return allocStr(q, -1);\n}\n\n#ifdef USE_INCLUDED_SRAND48\nstatic unsigned long R1 = 0x1234abcd;\nstatic unsigned long R2 = 0x330e;\n#define A1 0x5deec\n#define A2 0xe66d\n#define C 0xb\n\nvoid\nsrand48(long seed)\n{\n    R1 = (unsigned long)seed;\n    R2 = 0x330e;\n}\n\nlong\nlrand48(void)\n{\n    R1 = (A1 * R1 << 16) + A1 * R2 + A2 * R1 + ((A2 * R2 + C) >> 16);\n    R2 = (A2 * R2 + C) & 0xffff;\n    return (long)(R1 >> 1);\n}\n#endif\n\nchar *\nmybasename(char *s)\n{\n    char *p = s;\n    while (*p)\n\tp++;\n    while (s <= p && *p != '/')\n\tp--;\n    if (*p == '/')\n\tp++;\n    else\n\tp = s;\n    return allocStr(p, -1);\n}\n\nchar *\nmydirname(char *s)\n{\n    char *p = s;\n    while (*p)\n\tp++;\n    if (s != p)\n\tp--;\n    while (s != p && *p == '/')\n\tp--;\n    while (s != p && *p != '/')\n\tp--;\n    if (*p != '/')\n\treturn \".\";\n    while (s != p && *p == '/')\n\tp--;\n    return allocStr(s, strlen(s) - strlen(p) + 1);\n}\n\n#ifndef HAVE_STRERROR\nchar *\nstrerror(int errno)\n{\n    extern char *sys_errlist[];\n    return sys_errlist[errno];\n}\n#endif\t\t\t\t/* not HAVE_STRERROR */\n\nint\nnext_status(char c, int *status)\n{\n    switch (*status) {\n    case R_ST_NORMAL:\n\tif (c == '<') {\n\t    *status = R_ST_TAG0;\n\t    return 0;\n\t}\n\telse if (c == '&') {\n\t    *status = R_ST_AMP;\n\t    return 1;\n\t}\n\telse\n\t    return 1;\n\tbreak;\n    case R_ST_TAG0:\n\tif (c == '!') {\n\t    *status = R_ST_CMNT1;\n\t    return 0;\n\t}\n\t*status = R_ST_TAG;\n\t/* continues to next case */\n    case R_ST_TAG:\n\tif (c == '>')\n\t    *status = R_ST_NORMAL;\n\telse if (c == '=')\n\t    *status = R_ST_EQL;\n\treturn 0;\n    case R_ST_EQL:\n\tif (c == '\"')\n\t    *status = R_ST_DQUOTE;\n\telse if (c == '\\'')\n\t    *status = R_ST_QUOTE;\n\telse if (IS_SPACE(c))\n\t    *status = R_ST_EQL;\n\telse if (c == '>')\n\t    *status = R_ST_NORMAL;\n\telse\n\t    *status = R_ST_VALUE;\n\treturn 0;\n    case R_ST_QUOTE:\n\tif (c == '\\'')\n\t    *status = R_ST_TAG;\n\treturn 0;\n    case R_ST_DQUOTE:\n\tif (c == '\"')\n\t    *status = R_ST_TAG;\n\treturn 0;\n    case R_ST_VALUE:\n\tif (c == '>')\n\t    *status = R_ST_NORMAL;\n\telse if (IS_SPACE(c))\n\t    *status = R_ST_TAG;\n\treturn 0;\n    case R_ST_AMP:\n\tif (c == ';') {\n\t    *status = R_ST_NORMAL;\n\t    return 0;\n\t}\n\telse if (c != '#' && !IS_ALNUM(c) && c != '_') {\n\t    /* something's wrong! */\n\t    *status = R_ST_NORMAL;\n\t    return 0;\n\t}\n\telse\n\t    return 0;\n    case R_ST_CMNT1:\n\tswitch (c) {\n\tcase '-':\n\t    *status = R_ST_CMNT2;\n\t    break;\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tcase 'D':\n\tcase 'd':\n\t    /* could be a !doctype */\n\t    *status = R_ST_TAG;\n\t    break;\n\tdefault:\n\t    *status = R_ST_IRRTAG;\n\t}\n\treturn 0;\n    case R_ST_CMNT2:\n\tswitch (c) {\n\tcase '-':\n\t    *status = R_ST_CMNT;\n\t    break;\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tdefault:\n\t    *status = R_ST_IRRTAG;\n\t}\n\treturn 0;\n    case R_ST_CMNT:\n\tif (c == '-')\n\t    *status = R_ST_NCMNT1;\n\treturn 0;\n    case R_ST_NCMNT1:\n\tif (c == '-')\n\t    *status = R_ST_NCMNT2;\n\telse\n\t    *status = R_ST_CMNT;\n\treturn 0;\n    case R_ST_NCMNT2:\n\tswitch (c) {\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tcase '-':\n\t    *status = R_ST_NCMNT2;\n\t    break;\n\tdefault:\n\t    if (IS_SPACE(c))\n\t\t*status = R_ST_NCMNT3;\n\t    else\n\t\t*status = R_ST_CMNT;\n\t    break;\n\t}\n\tbreak;\n    case R_ST_NCMNT3:\n\tswitch (c) {\n\tcase '>':\n\t    *status = R_ST_NORMAL;\n\t    break;\n\tcase '-':\n\t    *status = R_ST_NCMNT1;\n\t    break;\n\tdefault:\n\t    if (IS_SPACE(c))\n\t\t*status = R_ST_NCMNT3;\n\t    else\n\t\t*status = R_ST_CMNT;\n\t    break;\n\t}\n\treturn 0;\n    case R_ST_IRRTAG:\n\tif (c == '>')\n\t    *status = R_ST_NORMAL;\n\treturn 0;\n    }\n    /* notreached */\n    return 0;\n}\n\nint\nread_token(Str buf, char **instr, int *status, int pre, int append)\n{\n    char *p;\n    int prev_status;\n\n    if (!append)\n\tStrclear(buf);\n    if (**instr == '\\0')\n\treturn 0;\n    for (p = *instr; *p; p++) {\n\t/* Drop Unicode soft hyphen */\n\tif (*(unsigned char *)p == 0210\n\t    && *(unsigned char *)(p + 1) == 0200\n\t    && *(unsigned char *)(p + 2) == 0201\n\t    && *(unsigned char *)(p + 3) == 0255) {\n\t    p += 3;\n\t    continue;\n\t}\n\n\tprev_status = *status;\n\tnext_status(*p, status);\n\tswitch (*status) {\n\tcase R_ST_NORMAL:\n\t    if (prev_status == R_ST_AMP && *p != ';') {\n\t\tp--;\n\t\tbreak;\n\t    }\n\t    if (prev_status == R_ST_NCMNT2 || prev_status == R_ST_NCMNT3 ||\n\t\tprev_status == R_ST_IRRTAG || prev_status == R_ST_CMNT1) {\n\t\tif (prev_status == R_ST_CMNT1 && !append && !pre)\n\t\t    Strclear(buf);\n\t\tif (pre)\n\t\t    Strcat_char(buf, *p);\n\t\tp++;\n\t\tgoto proc_end;\n\t    }\n\t    Strcat_char(buf, (!pre && IS_SPACE(*p)) ? ' ' : *p);\n\t    if (ST_IS_REAL_TAG(prev_status)) {\n\t\t*instr = p + 1;\n\t\tif (buf->length < 2 ||\n\t\t    buf->ptr[buf->length - 2] != '<' ||\n\t\t    buf->ptr[buf->length - 1] != '>')\n\t\t    return 1;\n\t\tStrshrink(buf, 2);\n\t    }\n\t    break;\n\tcase R_ST_TAG0:\n\tcase R_ST_TAG:\n\t    if (prev_status == R_ST_NORMAL && p != *instr) {\n\t\t*instr = p;\n\t\t*status = prev_status;\n\t\treturn 1;\n\t    }\n\t    if (*status == R_ST_TAG0 && !REALLY_THE_BEGINNING_OF_A_TAG(p)) {\n\t\t/* it seems that this '<' is not a beginning of a tag */\n\t\t/*\n\t\t * Strcat_charp(buf, \"&lt;\");\n\t\t */\n\t\tStrcat_char(buf, '<');\n\t\t*status = R_ST_NORMAL;\n\t    }\n\t    else\n\t\tStrcat_char(buf, *p);\n\t    break;\n\tcase R_ST_EQL:\n\tcase R_ST_QUOTE:\n\tcase R_ST_DQUOTE:\n\tcase R_ST_VALUE:\n\tcase R_ST_AMP:\n\t    Strcat_char(buf, *p);\n\t    break;\n\tcase R_ST_CMNT:\n\tcase R_ST_IRRTAG:\n\t    if (pre)\n\t\tStrcat_char(buf, *p);\n\t    else if (!append)\n\t\tStrclear(buf);\n\t    break;\n\tcase R_ST_CMNT1:\n\tcase R_ST_CMNT2:\n\tcase R_ST_NCMNT1:\n\tcase R_ST_NCMNT2:\n\tcase R_ST_NCMNT3:\n\t    /* do nothing */\n\t    if (pre)\n\t\tStrcat_char(buf, *p);\n\t    break;\n\t}\n    }\n  proc_end:\n    *instr = p;\n    return 1;\n}\n\nStr\ncorrect_irrtag(int status)\n{\n    char c;\n    Str tmp = Strnew();\n\n    while (status != R_ST_NORMAL) {\n\tswitch (status) {\n\tcase R_ST_CMNT:\t/* required \"-->\" */\n\tcase R_ST_NCMNT1:\t/* required \"->\" */\n\t    c = '-';\n\t    break;\n\tcase R_ST_NCMNT2:\n\tcase R_ST_NCMNT3:\n\tcase R_ST_IRRTAG:\n\tcase R_ST_CMNT1:\n\tcase R_ST_CMNT2:\n\tcase R_ST_TAG:\n\tcase R_ST_TAG0:\n\tcase R_ST_EQL:\t\t/* required \">\" */\n\tcase R_ST_VALUE:\n\t    c = '>';\n\t    break;\n\tcase R_ST_QUOTE:\n\t    c = '\\'';\n\t    break;\n\tcase R_ST_DQUOTE:\n\t    c = '\"';\n\t    break;\n\tcase R_ST_AMP:\n\t    c = ';';\n\t    break;\n\tdefault:\n\t    return tmp;\n\t}\n\tnext_status(c, &status);\n\tStrcat_char(tmp, c);\n    }\n    return tmp;\n}\n\n/*\n * RFC2617: 1.2 Access Authentication Framework\n *\n * The realm value (case-sensitive), in combination with the canonical root\n * URL (the absoluteURI for the server whose abs_path is empty; see section\n * 5.1.2 of RFC2616 ) of the server being accessed, defines the protection\n * space. These realms allow the protected resources on a server to be\n * partitioned into a set of protection spaces, each with its own\n * authentication scheme and/or authorization database.\n *\n */\nstatic void\nadd_auth_pass_entry(const struct auth_pass *ent, int netrc, int override)\n{\n    if ((ent->host || netrc)\t/* netrc accept default (host == NULL) */\n\t&&(ent->is_proxy || ent->realm || netrc)\n\t&& ent->uname && ent->pwd) {\n\tstruct auth_pass *newent = New(struct auth_pass);\n\tmemcpy(newent, ent, sizeof(struct auth_pass));\n\tif (override) {\n\t    newent->next = passwords;\n\t    passwords = newent;\n\t} \n\telse {\n\t    if (passwords == NULL)\n\t\tpasswords = newent;\n\t    else if (passwords->next == NULL)\n\t\tpasswords->next = newent;\n\t    else {\n\t\tstruct auth_pass *ep = passwords;\n\t\tfor (; ep->next; ep = ep->next) ;\n\t\tep->next = newent;\n\t    }\n\t}\n    }\n    /* ignore invalid entries */\n}\n\nstatic struct auth_pass *\nfind_auth_pass_entry(char *host, int port, char *realm, char *uname, \n\t\t     int is_proxy)\n{\n    struct auth_pass *ent;\n    for (ent = passwords; ent != NULL; ent = ent->next) {\n\tif (ent->is_proxy == is_proxy\n\t    && (ent->bad != TRUE)\n\t    && (!ent->host || !Strcasecmp_charp(ent->host, host))\n\t    && (!ent->port || ent->port == port)\n\t    && (!ent->uname || !uname || !Strcmp_charp(ent->uname, uname))\n\t    && (!ent->realm || !realm || !Strcmp_charp(ent->realm, realm))\n\t    )\n\t    return ent;\n    }\n    return NULL;\n}\n\nint\nfind_auth_user_passwd(ParsedURL *pu, char *realm,\n\t\t      Str *uname, Str *pwd, int is_proxy)\n{\n    struct auth_pass *ent;\n\n    if (pu->user && pu->pass) {\n\t*uname = Strnew_charp(pu->user);\n\t*pwd = Strnew_charp(pu->pass);\n\treturn 1;\n    }\n    ent = find_auth_pass_entry(pu->host, pu->port, realm, pu->user, is_proxy);\n    if (ent) {\n\t*uname = ent->uname;\n\t*pwd = ent->pwd;\n\treturn 1;\n    }\n    return 0;\n}\n\nvoid\nadd_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, \n\t\t     int is_proxy)\n{\n    struct auth_pass ent;\n    memset(&ent, 0, sizeof(ent));\n\n    ent.is_proxy = is_proxy;\n    ent.host = Strnew_charp(pu->host);\n    ent.port = pu->port;\n    ent.realm = Strnew_charp(realm);\n    ent.uname = uname;\n    ent.pwd = pwd;\n    add_auth_pass_entry(&ent, 0, 1);\n}\n\nvoid\ninvalidate_auth_user_passwd(ParsedURL *pu, char *realm, Str uname, Str pwd, \n\t\t\t    int is_proxy)\n{\n    struct auth_pass *ent;\n    ent = find_auth_pass_entry(pu->host, pu->port, realm, NULL, is_proxy);\n    if (ent) {\n\tent->bad = TRUE;\n    }\n    return;\n}\n\n/* passwd */\n/*\n * machine <host>\n * host <host>\n * port <port>\n * proxy\n * path <file>\t; not used\n * realm <realm>\n * login <login>\n * passwd <passwd>\n * password <passwd>\n */\n\nstatic Str\nnext_token(Str arg)\n{\n    Str narg = NULL;\n    char *p, *q;\n    if (arg == NULL || arg->length == 0)\n\treturn NULL;\n    p = arg->ptr;\n    q = p;\n    SKIP_NON_BLANKS(q);\n    if (*q != '\\0') {\n\t*q++ = '\\0';\n\tSKIP_BLANKS(q);\n\tif (*q != '\\0')\n\t    narg = Strnew_charp(q);\n    }\n    return narg;\n}\n\nstatic void\nparsePasswd(FILE * fp, int netrc)\n{\n    struct auth_pass ent;\n    Str line = NULL;\n\n    bzero(&ent, sizeof(struct auth_pass));\n    while (1) {\n\tStr arg = NULL;\n\tchar *p;\n\n\tif (line == NULL || line->length == 0)\n\t    line = Strfgets(fp);\n\tif (line->length == 0)\n\t    break;\n\tStrchop(line);\n\tStrremovefirstspaces(line);\n\tp = line->ptr;\n\tif (*p == '#' || *p == '\\0') {\n\t    line = NULL;\n\t    continue;\t\t/* comment or empty line */\n\t}\n\targ = next_token(line);\n\n\tif (!strcmp(p, \"machine\") || !strcmp(p, \"host\")\n\t    || (netrc && !strcmp(p, \"default\"))) {\n\t    add_auth_pass_entry(&ent, netrc, 0);\n\t    bzero(&ent, sizeof(struct auth_pass));\n\t    if (netrc)\n\t\tent.port = 21;\t/* XXX: getservbyname(\"ftp\"); ? */\n\t    if (strcmp(p, \"default\") != 0) {\n\t\tline = next_token(arg);\n\t\tent.host = arg;\n\t    }\n\t    else {\n\t\tline = arg;\n\t    }\n\t}\n\telse if (!netrc && !strcmp(p, \"port\") && arg) {\n\t    line = next_token(arg);\n\t    ent.port = atoi(arg->ptr);\n\t}\n\telse if (!netrc && !strcmp(p, \"proxy\")) {\n\t    ent.is_proxy = 1;\n\t    line = arg;\n\t}\n\telse if (!netrc && !strcmp(p, \"path\")) {\n\t    line = next_token(arg);\n\t    /* ent.file = arg; */\n\t}\n\telse if (!netrc && !strcmp(p, \"realm\")) {\n\t    /* XXX: rest of line becomes arg for realm */\n\t    line = NULL;\n\t    ent.realm = arg;\n\t}\n\telse if (!strcmp(p, \"login\")) {\n\t    line = next_token(arg);\n\t    ent.uname = arg;\n\t}\n\telse if (!strcmp(p, \"password\") || !strcmp(p, \"passwd\")) {\n\t    line = next_token(arg);\n\t    ent.pwd = arg;\n\t}\n\telse if (netrc && !strcmp(p, \"machdef\")) {\n\t    while ((line = Strfgets(fp))->length != 0) {\n\t\tif (*line->ptr == '\\n')\n\t\t    break;\n\t    }\n\t    line = NULL;\n\t}\n\telse if (netrc && !strcmp(p, \"account\")) {\n\t    /* ignore */\n\t    line = next_token(arg);\n\t}\n\telse {\n\t    /* ignore rest of line */\n\t    line = NULL;\n\t}\n    }\n    add_auth_pass_entry(&ent, netrc, 0);\n}\n\n/* FIXME: gettextize? */\n#define FILE_IS_READABLE_MSG \"SECURITY NOTE: file %s must not be accessible by others\"\n\nFILE *\nopenSecretFile(char *fname)\n{\n    char *efname;\n    struct stat st;\n\n    if (fname == NULL)\n\treturn NULL;\n    efname = expandPath(fname);\n    if (stat(efname, &st) < 0)\n\treturn NULL;\n\n    /* check permissions, if group or others readable or writable,\n     * refuse it, because it's insecure.\n     *\n     * XXX: disable_secret_security_check will introduce some\n     *    security issues, but on some platform such as Windows\n     *    it's not possible (or feasible) to disable group|other\n     *    readable and writable.\n     *   [w3m-dev 03368][w3m-dev 03369][w3m-dev 03370]\n     */\n    if (disable_secret_security_check)\n\t/* do nothing */ ;\n    else if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0) {\n\tif (fmInitialized) {\n\t    message(Sprintf(FILE_IS_READABLE_MSG, fname)->ptr, 0, 0);\n\t    refresh();\n\t}\n\telse {\n\t    fputs(Sprintf(FILE_IS_READABLE_MSG, fname)->ptr, stderr);\n\t    fputc('\\n', stderr);\n\t}\n\tsleep(2);\n\treturn NULL;\n    }\n\n    return fopen(efname, \"r\");\n}\n\nvoid\nloadPasswd(void)\n{\n    FILE *fp;\n\n    passwords = NULL;\n    fp = openSecretFile(passwd_file);\n    if (fp != NULL) {\n\tparsePasswd(fp, 0);\n\tfclose(fp);\n    }\n\n    /* for FTP */\n    fp = openSecretFile(\"~/.netrc\");\n    if (fp != NULL) {\n\tparsePasswd(fp, 1);\n\tfclose(fp);\n    }\n    return;\n}\n\n/* get last modified time */\nchar *\nlast_modified(Buffer *buf)\n{\n    TextListItem *ti;\n    struct stat st;\n\n    if (buf->document_header) {\n\tfor (ti = buf->document_header->first; ti; ti = ti->next) {\n\t    if (strncasecmp(ti->ptr, \"Last-modified: \", 15) == 0) {\n\t\treturn ti->ptr + 15;\n\t    }\n\t}\n\treturn \"unknown\";\n    }\n    else if (buf->currentURL.scheme == SCM_LOCAL) {\n\tif (stat(buf->currentURL.file, &st) < 0)\n\t    return \"unknown\";\n\treturn ctime(&st.st_mtime);\n    }\n    return \"unknown\";\n}\n\nstatic char roman_num1[] = {\n    'i', 'x', 'c', 'm', '*',\n};\nstatic char roman_num5[] = {\n    'v', 'l', 'd', '*',\n};\n\nstatic Str\nromanNum2(int l, int n)\n{\n    Str s = Strnew();\n\n    switch (n) {\n    case 1:\n    case 2:\n    case 3:\n\tfor (; n > 0; n--)\n\t    Strcat_char(s, roman_num1[l]);\n\tbreak;\n    case 4:\n\tStrcat_char(s, roman_num1[l]);\n\tStrcat_char(s, roman_num5[l]);\n\tbreak;\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n\tStrcat_char(s, roman_num5[l]);\n\tfor (n -= 5; n > 0; n--)\n\t    Strcat_char(s, roman_num1[l]);\n\tbreak;\n    case 9:\n\tStrcat_char(s, roman_num1[l]);\n\tStrcat_char(s, roman_num1[l + 1]);\n\tbreak;\n    }\n    return s;\n}\n\nStr\nromanNumeral(int n)\n{\n    Str r = Strnew();\n\n    if (n <= 0)\n\treturn r;\n    if (n >= 4000) {\n\tStrcat_charp(r, \"**\");\n\treturn r;\n    }\n    Strcat(r, romanNum2(3, n / 1000));\n    Strcat(r, romanNum2(2, (n % 1000) / 100));\n    Strcat(r, romanNum2(1, (n % 100) / 10));\n    Strcat(r, romanNum2(0, n % 10));\n\n    return r;\n}\n\nStr\nromanAlphabet(int n)\n{\n    Str r = Strnew();\n    int l;\n    char buf[14];\n\n    if (n <= 0)\n\treturn r;\n\n    l = 0;\n    while (n) {\n\tbuf[l++] = 'a' + (n - 1) % 26;\n\tn = (n - 1) / 26;\n    }\n    l--;\n    for (; l >= 0; l--)\n\tStrcat_char(r, buf[l]);\n\n    return r;\n}\n\n#ifndef SIGIOT\n#define SIGIOT SIGABRT\n#endif\t\t\t\t/* not SIGIOT */\n\nstatic void\nreset_signals(void)\n{\n#ifdef SIGHUP\n    mySignal(SIGHUP, SIG_DFL);\t/* terminate process */\n#endif\n    mySignal(SIGINT, SIG_DFL);\t/* terminate process */\n#ifdef SIGQUIT\n    mySignal(SIGQUIT, SIG_DFL);\t/* terminate process */\n#endif\n    mySignal(SIGTERM, SIG_DFL);\t/* terminate process */\n    mySignal(SIGILL, SIG_DFL);\t/* create core image */\n    mySignal(SIGIOT, SIG_DFL);\t/* create core image */\n    mySignal(SIGFPE, SIG_DFL);\t/* create core image */\n#ifdef SIGBUS\n    mySignal(SIGBUS, SIG_DFL);\t/* create core image */\n#endif\t\t\t\t/* SIGBUS */\n#ifdef SIGCHLD\n    mySignal(SIGCHLD, SIG_IGN);\n#endif\n#ifdef SIGPIPE\n    mySignal(SIGPIPE, SIG_IGN);\n#endif\n}\n\n#ifndef FOPEN_MAX\n#define FOPEN_MAX 1024\t\t/* XXX */\n#endif\n\nstatic void\nclose_all_fds_except(int i, int f)\n{\n    switch (i) {\t\t/* fall through */\n    case 0:\n\tdup2(open(DEV_NULL_PATH, O_RDONLY), 0);\n    case 1:\n\tdup2(open(DEV_NULL_PATH, O_WRONLY), 1);\n    case 2:\n\tdup2(open(DEV_NULL_PATH, O_WRONLY), 2);\n    }\n    /* close all other file descriptors (socket, ...) */\n    for (i = 3; i < FOPEN_MAX; i++) {\n\tif (i != f)\n\t    close(i);\n    }\n}\n\nvoid\nsetup_child(int child, int i, int f)\n{\n    reset_signals();\n    mySignal(SIGINT, SIG_IGN);\n#ifndef __MINGW32_VERSION\n    if (!child)\n\tSETPGRP();\n#endif /* __MINGW32_VERSION */\n    /*\n     * I don't know why but close_tty() sometimes interrupts loadGeneralFile() in loadImage()\n     * and corrupt image data can be cached in ~/.w3m.\n     */\n#if 0\n    close_tty();\n#endif\n    close_all_fds_except(i, f);\n    QuietMessage = TRUE;\n    fmInitialized = FALSE;\n    TrapSignal = FALSE;\n}\n\n#ifndef __MINGW32_VERSION\npid_t\nopen_pipe_rw(FILE ** fr, FILE ** fw)\n{\n    int fdr[2];\n    int fdw[2];\n    pid_t pid;\n\n    if (fr && pipe(fdr) < 0)\n\tgoto err0;\n    if (fw && pipe(fdw) < 0)\n\tgoto err1;\n\n    flush_tty();\n    pid = fork();\n    if (pid < 0)\n\tgoto err2;\n    if (pid == 0) {\n\t/* child */\n\tif (fr) {\n\t    close(fdr[0]);\n\t    dup2(fdr[1], 1);\n\t}\n\tif (fw) {\n\t    close(fdw[1]);\n\t    dup2(fdw[0], 0);\n\t}\n    }\n    else {\n\tif (fr) {\n\t    close(fdr[1]);\n\t    if (*fr == stdin)\n\t\tdup2(fdr[0], 0);\n\t    else\n\t\t*fr = fdopen(fdr[0], \"r\");\n\t}\n\tif (fw) {\n\t    close(fdw[0]);\n\t    if (*fw == stdout)\n\t\tdup2(fdw[1], 1);\n\t    else\n\t\t*fw = fdopen(fdw[1], \"w\");\n\t}\n    }\n    return pid;\n  err2:\n    if (fw) {\n\tclose(fdw[0]);\n\tclose(fdw[1]);\n    }\n  err1:\n    if (fr) {\n\tclose(fdr[0]);\n\tclose(fdr[1]);\n    }\n  err0:\n    return (pid_t) - 1;\n}\n#endif /* __MINGW32_VERSION */\n\nvoid\nmyExec(char *command)\n{\n    mySignal(SIGINT, SIG_DFL);\n    execl(\"/bin/sh\", \"sh\", \"-c\", command, NULL);\n    exit(127);\n}\n\nvoid\nmySystem(char *command, int background)\n{\n#ifndef __MINGW32_VERSION\n    if (background) {\n#ifndef __EMX__\n\tflush_tty();\n\tif (!fork()) {\n\t    setup_child(FALSE, 0, -1);\n\t    myExec(command);\n\t}\n#else\n\tStr cmd = Strnew_charp(\"start /f \");\n\tStrcat_charp(cmd, command);\n\tsystem(cmd->ptr);\n#endif\n    }\n    else\n#endif /* __MINGW32_VERSION */\n\tsystem(command);\n}\n\nStr\nmyExtCommand(char *cmd, char *arg, int redirect)\n{\n    Str tmp = NULL;\n    char *p;\n    int set_arg = FALSE;\n\n    for (p = cmd; *p; p++) {\n\tif (*p == '%' && *(p + 1) == 's' && !set_arg) {\n\t    if (tmp == NULL)\n\t\ttmp = Strnew_charp_n(cmd, (int)(p - cmd));\n\t    Strcat_charp(tmp, arg);\n\t    set_arg = TRUE;\n\t    p++;\n\t}\n\telse {\n\t    if (tmp)\n\t\tStrcat_char(tmp, *p);\n\t}\n    }\n    if (!set_arg) {\n\tif (redirect)\n\t    tmp = Strnew_m_charp(\"(\", cmd, \") < \", arg, NULL);\n\telse\n\t    tmp = Strnew_m_charp(cmd, \" \", arg, NULL);\n    }\n    return tmp;\n}\n\nStr\nmyEditor(char *cmd, char *file, int line)\n{\n    Str tmp = NULL;\n    char *p;\n    int set_file = FALSE, set_line = FALSE;\n\n    for (p = cmd; *p; p++) {\n\tif (*p == '%' && *(p + 1) == 's' && !set_file) {\n\t    if (tmp == NULL)\n\t\ttmp = Strnew_charp_n(cmd, (int)(p - cmd));\n\t    Strcat_charp(tmp, file);\n\t    set_file = TRUE;\n\t    p++;\n\t}\n\telse if (*p == '%' && *(p + 1) == 'd' && !set_line && line > 0) {\n\t    if (tmp == NULL)\n\t\ttmp = Strnew_charp_n(cmd, (int)(p - cmd));\n\t    Strcat(tmp, Sprintf(\"%d\", line));\n\t    set_line = TRUE;\n\t    p++;\n\t}\n\telse {\n\t    if (tmp)\n\t\tStrcat_char(tmp, *p);\n\t}\n    }\n    if (!set_file) {\n\tif (tmp == NULL)\n\t    tmp = Strnew_charp(cmd);\n\tif (!set_line && line > 1 && strcasestr(cmd, \"vi\"))\n\t    Strcat(tmp, Sprintf(\" +%d\", line));\n\tStrcat_m_charp(tmp, \" \", file, NULL);\n    }\n    return tmp;\n}\n\n#ifdef __MINGW32_VERSION\nchar *\nexpandName(char *name)\n{\n    return getenv(\"HOME\");\n}\n#else\nchar *\nexpandName(char *name)\n{\n    char *p;\n    struct passwd *passent, *getpwnam(const char *);\n    Str extpath = NULL;\n\n    if (name == NULL)\n\treturn NULL;\n    p = name;\n    if (*p == '/') {\n\tif ((*(p + 1) == '~' && IS_ALPHA(*(p + 2)))\n\t    && personal_document_root) {\n\t    char *q;\n\t    p += 2;\n\t    q = strchr(p, '/');\n\t    if (q) {\t\t/* /~user/dir... */\n\t\tpassent = getpwnam(allocStr(p, q - p));\n\t\tp = q;\n\t    }\n\t    else {\t\t/* /~user */\n\t\tpassent = getpwnam(p);\n\t\tp = \"\";\n\t    }\n\t    if (!passent)\n\t\tgoto rest;\n\t    extpath = Strnew_m_charp(passent->pw_dir, \"/\",\n\t\t\t\t     personal_document_root, NULL);\n\t    if (*personal_document_root == '\\0' && *p == '/')\n\t\tp++;\n\t}\n\telse\n\t    goto rest;\n\tif (Strcmp_charp(extpath, \"/\") == 0 && *p == '/')\n\t    p++;\n\tStrcat_charp(extpath, p);\n\treturn extpath->ptr;\n    }\n    else\n\treturn expandPath(p);\n  rest:\n    return name;\n}\n#endif\n\nint\nis_localhost(const char *host)\n{\n    if (!host ||\n\t!strcasecmp(host, \"localhost\") || !strcmp(host, \"127.0.0.1\") ||\n\t(HostName && !strcasecmp(host, HostName)) || !strcmp(host, \"[::1]\"))\n\treturn TRUE;\n    return FALSE;\n}\n\nchar *\nfile_to_url(char *file)\n{\n    Str tmp;\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n    char *drive = NULL;\n#endif\n#ifdef SUPPORT_NETBIOS_SHARE\n    char *host = NULL;\n#endif\n\n    if (!(file = expandPath(file)))\n\treturn NULL;\n#ifdef SUPPORT_NETBIOS_SHARE\n    if (file[0] == '/' && file[1] == '/') {\n\tchar *p;\n\tfile += 2;\n\tif (*file) {\n\t    p = strchr(file, '/');\n\t    if (p != NULL && p != file) {\n\t\thost = allocStr(file, (p - file));\n\t\tfile = p;\n\t    }\n\t}\n    }\n#endif\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n    if (IS_ALPHA(file[0]) && file[1] == ':') {\n\tdrive = allocStr(file, 2);\n\tfile += 2;\n    }\n    else\n#endif\n    if (file[0] != '/') {\n\ttmp = Strnew_charp(CurrentDir);\n\tif (Strlastchar(tmp) != '/')\n\t    Strcat_char(tmp, '/');\n\tStrcat_charp(tmp, file);\n\tfile = tmp->ptr;\n    }\n    tmp = Strnew_charp(\"file://\");\n#ifdef SUPPORT_NETBIOS_SHARE\n    if (host)\n\tStrcat_charp(tmp, host);\n#endif\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n    if (drive)\n\tStrcat_charp(tmp, drive);\n#endif\n    Strcat_charp(tmp, file_quote(cleanupName(file)));\n    return tmp->ptr;\n}\n\n#ifdef USE_M17N\nchar *\nurl_unquote_conv(char *url, wc_ces charset)\n#else\nchar *\nurl_unquote_conv0(char *url)\n#endif\n{\n#ifdef USE_M17N\n    wc_uint8 old_auto_detect = WcOption.auto_detect;\n#endif\n    Str tmp;\n    tmp = Str_url_unquote(Strnew_charp(url), FALSE, TRUE);\n#ifdef USE_M17N\n    if (!charset || charset == WC_CES_US_ASCII)\n\tcharset = SystemCharset;\n    WcOption.auto_detect = WC_OPT_DETECT_ON;\n    tmp = convertLine(NULL, tmp, RAW_MODE, &charset, charset);\n    WcOption.auto_detect = old_auto_detect;\n#endif\n    return tmp->ptr;\n}\n\nstatic char *tmpf_base[MAX_TMPF_TYPE] = {\n    \"tmp\", \"src\", \"frame\", \"cache\", \"cookie\", \"hist\",\n};\nstatic unsigned int tmpf_seq[MAX_TMPF_TYPE];\n\nStr\ntmpfname(int type, char *ext)\n{\n    Str tmpf;\n    char *dir;\n\n    switch(type) {\n    case TMPF_HIST:\n\tdir = rc_dir;\n\tbreak;\n    case TMPF_DFL:\n    case TMPF_COOKIE:\n    case TMPF_SRC:\n    case TMPF_FRAME:\n    case TMPF_CACHE:\n    default:\n\tdir = tmp_dir;\n    }\n\n    tmpf = Sprintf(\"%s/w3m%s%d-%d%s\",\n\t\t   dir,\n\t\t   tmpf_base[type],\n\t\t   CurrentPid, tmpf_seq[type]++, (ext) ? ext : \"\");\n    pushText(fileToDelete, tmpf->ptr);\n    return tmpf;\n}\n\nstatic char *monthtbl[] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n};\n\nstatic int\nget_day(char **s)\n{\n    Str tmp = Strnew();\n    int day;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n\n    day = atoi(tmp->ptr);\n\n    if (day < 1 || day > 31) {\n\t*s = ss;\n\treturn -1;\n    }\n    return day;\n}\n\nstatic int\nget_month(char **s)\n{\n    Str tmp = Strnew();\n    int mon;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (tmp->length > 0) {\n\tmon = atoi(tmp->ptr);\n    }\n    else {\n\twhile (**s && IS_ALPHA(**s))\n\t    Strcat_char(tmp, *((*s)++));\n\tfor (mon = 1; mon <= 12; mon++) {\n\t    if (strncmp(tmp->ptr, monthtbl[mon - 1], 3) == 0)\n\t\tbreak;\n\t}\n    }\n    if (mon < 1 || mon > 12) {\n\t*s = ss;\n\treturn -1;\n    }\n    return mon;\n}\n\nstatic int\nget_year(char **s)\n{\n    Str tmp = Strnew();\n    int year;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (tmp->length != 2 && tmp->length != 4) {\n\t*s = ss;\n\treturn -1;\n    }\n\n    year = atoi(tmp->ptr);\n    if (tmp->length == 2) {\n\tif (year >= 70)\n\t    year += 1900;\n\telse\n\t    year += 2000;\n    }\n    return year;\n}\n\nstatic int\nget_time(char **s, int *hour, int *min, int *sec)\n{\n    Str tmp = Strnew();\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (**s != ':') {\n\t*s = ss;\n\treturn -1;\n    }\n    *hour = atoi(tmp->ptr);\n\n    (*s)++;\n    Strclear(tmp);\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (**s != ':') {\n\t*s = ss;\n\treturn -1;\n    }\n    *min = atoi(tmp->ptr);\n\n    (*s)++;\n    Strclear(tmp);\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    *sec = atoi(tmp->ptr);\n\n    if (*hour < 0 || *hour >= 24 ||\n\t*min < 0 || *min >= 60 || *sec < 0 || *sec >= 60) {\n\t*s = ss;\n\treturn -1;\n    }\n    return 0;\n}\n\nstatic int\nget_zone(char **s, int *z_hour, int *z_min)\n{\n    Str tmp = Strnew();\n    int zone;\n    char *ss = *s;\n\n    if (!**s)\n\treturn -1;\n\n    if (**s == '+' || **s == '-')\n\tStrcat_char(tmp, *((*s)++));\n    while (**s && IS_DIGIT(**s))\n\tStrcat_char(tmp, *((*s)++));\n    if (!(tmp->length == 4 && IS_DIGIT(*ss)) &&\n\t!(tmp->length == 5 && (*ss == '+' || *ss == '-'))) {\n\t*s = ss;\n\treturn -1;\n    }\n\n    zone = atoi(tmp->ptr);\n    *z_hour = zone / 100;\n    *z_min = zone - (zone / 100) * 100;\n    return 0;\n}\n\n/* RFC 1123 or RFC 850 or ANSI C asctime() format string -> time_t */\ntime_t\nmymktime(char *timestr)\n{\n    char *s;\n    int day, mon, year, hour, min, sec, z_hour = 0, z_min = 0;\n\n    if (!(timestr && *timestr))\n\treturn -1;\n    s = timestr;\n\n#ifdef DEBUG\n    fprintf(stderr, \"mktime: %s\\n\", timestr);\n#endif\t\t\t\t/* DEBUG */\n\n    while (*s && IS_ALPHA(*s))\n\ts++;\n    while (*s && !IS_ALNUM(*s))\n\ts++;\n\n    if (IS_DIGIT(*s)) {\n\t/* RFC 1123 or RFC 850 format */\n\tif ((day = get_day(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_ALNUM(*s))\n\t    s++;\n\tif ((mon = get_month(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif ((year = get_year(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif (!*s) {\n\t    hour = 0;\n\t    min = 0;\n\t    sec = 0;\n\t}\n\telse {\n\t    if (get_time(&s, &hour, &min, &sec) == -1)\n\t\treturn -1;\n\t    while (*s && !IS_DIGIT(*s) && *s != '+' && *s != '-')\n\t\ts++;\n\t    get_zone(&s, &z_hour, &z_min);\n\t}\n    }\n    else {\n\t/* ANSI C asctime() format. */\n\twhile (*s && !IS_ALNUM(*s))\n\t    s++;\n\tif ((mon = get_month(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif ((day = get_day(&s)) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif (get_time(&s, &hour, &min, &sec) == -1)\n\t    return -1;\n\n\twhile (*s && !IS_DIGIT(*s))\n\t    s++;\n\tif ((year = get_year(&s)) == -1)\n\t    return -1;\n    }\n#ifdef DEBUG\n    fprintf(stderr,\n\t    \"year=%d month=%d day=%d hour:min:sec=%d:%d:%d zone=%d:%d\\n\", year,\n\t    mon, day, hour, min, sec, z_hour, z_min);\n#endif\t\t\t\t/* DEBUG */\n\n    mon -= 3;\n    if (mon < 0) {\n\tmon += 12;\n\tyear--;\n    }\n    day += (year - 1968) * 1461 / 4;\n    day += ((((mon * 153) + 2) / 5) - 672);\n    hour -= z_hour;\n    min -= z_min;\n    return (time_t) ((day * 60 * 60 * 24) +\n\t\t     (hour * 60 * 60) + (min * 60) + sec);\n}\n\n#ifdef USE_COOKIE\n#ifdef INET6\n#include <sys/socket.h>\n#endif\t\t\t\t/* INET6 */\n#ifndef __MINGW32_VERSION\n#include <netdb.h>\n#else\n#include <winsock.h>\n#endif\nchar *\nFQDN(char *host)\n{\n    char *p;\n#ifndef INET6\n    struct hostent *entry;\n#else\t\t\t\t/* INET6 */\n    int *af;\n#endif\t\t\t\t/* INET6 */\n\n    if (host == NULL)\n\treturn NULL;\n\n    if (strcasecmp(host, \"localhost\") == 0)\n\treturn host;\n\n    for (p = host; *p && *p != '.'; p++) ;\n\n    if (*p == '.')\n\treturn host;\n\n#ifndef INET6\n    if (!(entry = gethostbyname(host)))\n\treturn NULL;\n\n    return allocStr(entry->h_name, -1);\n#else\t\t\t\t/* INET6 */\n    for (af = ai_family_order_table[DNS_order];; af++) {\n\tint error;\n\tstruct addrinfo hints;\n\tstruct addrinfo *res, *res0;\n\tchar *namebuf;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_flags = AI_CANONNAME;\n\thints.ai_family = *af;\n\thints.ai_socktype = SOCK_STREAM;\n\terror = getaddrinfo(host, NULL, &hints, &res0);\n\tif (error) {\n\t    if (*af == PF_UNSPEC) {\n\t\t/* all done */\n\t\tbreak;\n\t    }\n\t    /* try next address family */\n\t    continue;\n\t}\n\tfor (res = res0; res != NULL; res = res->ai_next) {\n\t    if (res->ai_canonname) {\n\t\t/* found */\n\t\tnamebuf = strdup(res->ai_canonname);\n\t\tfreeaddrinfo(res0);\n\t\treturn namebuf;\n\t    }\n\t}\n\tfreeaddrinfo(res0);\n\tif (*af == PF_UNSPEC) {\n\t    break;\n\t}\n    }\n    /* all failed */\n    return NULL;\n#endif\t\t\t\t/* INET6 */\n}\n\n#endif\t\t\t\t/* USE_COOKIE */\n\nvoid (*mySignal(int signal_number, void (*action) (int))) (int) {\n#ifdef\tSA_RESTART\n    struct sigaction new_action, old_action;\n\n    sigemptyset(&new_action.sa_mask);\n    new_action.sa_handler = action;\n    if (signal_number == SIGALRM) {\n#ifdef\tSA_INTERRUPT\n\tnew_action.sa_flags = SA_INTERRUPT;\n#else\n\tnew_action.sa_flags = 0;\n#endif\n    }\n    else {\n\tnew_action.sa_flags = SA_RESTART;\n    }\n    sigaction(signal_number, &new_action, &old_action);\n    return (old_action.sa_handler);\n#else\n    return (signal(signal_number, action));\n#endif\n}\n\nstatic char Base64Table[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nStr\nbase64_encode(const char *src, size_t len)\n{\n    Str dest;\n    const unsigned char *in, *endw, *s;\n    unsigned long j;\n    size_t k;\n\n    s = (unsigned char*)src;\n\n    k = len;\n    if (k % 3)\n\tk += 3 - (k % 3);\n\n    k = k / 3 * 4;\n\n    if (!len || k + 1 < len)\n\treturn Strnew();\n\n    dest = Strnew_size(k);\n    if (dest->area_size <= k) {\n\tStrfree(dest);\n\treturn Strnew();\n    }\n\n    in = s;\n\n    endw = s + len - 2;\n\n    while (in < endw) {\n\tj = *in++;\n\tj = j << 8 | *in++;\n\tj = j << 8 | *in++;\n\n\tStrcatc(dest, Base64Table[(j >> 18) & 0x3f]);\n\tStrcatc(dest, Base64Table[(j >> 12) & 0x3f]);\n\tStrcatc(dest, Base64Table[(j >> 6) & 0x3f]);\n\tStrcatc(dest, Base64Table[j & 0x3f]);\n    }\n\n    if (s + len - in) {\n\tj = *in++;\n\tif (s + len - in) {\n\t    j = j << 8 | *in++;\n\t    j = j << 8;\n\t    Strcatc(dest, Base64Table[(j >> 18) & 0x3f]);\n\t    Strcatc(dest, Base64Table[(j >> 12) & 0x3f]);\n\t    Strcatc(dest, Base64Table[(j >> 6) & 0x3f]);\n\t} else {\n\t    j = j << 8;\n\t    j = j << 8;\n\t    Strcatc(dest, Base64Table[(j >> 18) & 0x3f]);\n\t    Strcatc(dest, Base64Table[(j >> 12) & 0x3f]);\n\t    Strcatc(dest, '=');\n\t}\n\tStrcatc(dest, '=');\n    }\n    Strnulterm(dest);\n    return dest;\n}\n"], "filenames": ["etc.c"], "buggy_code_start_loc": [396], "buggy_code_end_loc": [423], "fixing_code_start_loc": [396], "fixing_code_end_loc": [429], "type": "CWE-787", "message": "An out-of-bounds write issue has been discovered in the backspace handling of the checkType() function in etc.c within the W3M application. This vulnerability is triggered by supplying a specially crafted HTML file to the w3m binary. Exploitation of this flaw could lead to application crashes, resulting in a denial of service condition.", "other": {"cve": {"id": "CVE-2023-4255", "sourceIdentifier": "secalert@redhat.com", "published": "2023-12-21T16:15:10.017", "lastModified": "2024-01-03T02:30:35.597", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An out-of-bounds write issue has been discovered in the backspace handling of the checkType() function in etc.c within the W3M application. This vulnerability is triggered by supplying a specially crafted HTML file to the w3m binary. Exploitation of this flaw could lead to application crashes, resulting in a denial of service condition."}, {"lang": "es", "value": "Se descubri\u00f3 un problema de escritura fuera de los l\u00edmites en el manejo de retroceso de la funci\u00f3n checkType() en etc.c dentro de la aplicaci\u00f3n W3M. Esta vulnerabilidad se activa al proporcionar un archivo HTML especialmente manipulado al binario w3m. La explotaci\u00f3n de este fallo podr\u00eda provocar fallos en la aplicaci\u00f3n, lo que resultar\u00eda en una condici\u00f3n de denegaci\u00f3n de servicio."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tats:w3m:0.5.3\\+git20230121-1:*:*:*:*:*:*:*", "matchCriteriaId": "7A31CA22-C625-4E9C-9C57-CCDBC9E9B99A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tats:w3m:0.5.3\\+git20230121-2:*:*:*:*:*:*:*", "matchCriteriaId": "9E2BDFFC-F30D-47CE-B32E-E4C1713ACF1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tats:w3m:0.5.3\\+git20230129:*:*:*:*:*:*:*", "matchCriteriaId": "BB9F94C4-C1FC-4CD9-B5B4-E745E4B3BCBC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fedoraproject:extra_packages_for_enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "BB176AC3-3CDA-4DDA-9089-C67B2F73AA62"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2255207", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/tats/w3m/commit/edc602651c506aeeb60544b55534dd1722a340d3", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/tats/w3m/issues/268", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch"]}, {"url": "https://github.com/tats/w3m/pull/273", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/tats/w3m/commit/edc602651c506aeeb60544b55534dd1722a340d3"}}