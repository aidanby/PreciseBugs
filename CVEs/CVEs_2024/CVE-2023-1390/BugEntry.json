{"buggy_code": ["/*\n * net/tipc/link.c: TIPC link code\n *\n * Copyright (c) 1996-2007, 2012-2016, Ericsson AB\n * Copyright (c) 2004-2007, 2010-2013, Wind River Systems\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the names of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"core.h\"\n#include \"subscr.h\"\n#include \"link.h\"\n#include \"bcast.h\"\n#include \"socket.h\"\n#include \"name_distr.h\"\n#include \"discover.h\"\n#include \"netlink.h\"\n#include \"monitor.h\"\n#include \"trace.h\"\n#include \"crypto.h\"\n\n#include <linux/pkt_sched.h>\n\nstruct tipc_stats {\n\tu32 sent_pkts;\n\tu32 recv_pkts;\n\tu32 sent_states;\n\tu32 recv_states;\n\tu32 sent_probes;\n\tu32 recv_probes;\n\tu32 sent_nacks;\n\tu32 recv_nacks;\n\tu32 sent_acks;\n\tu32 sent_bundled;\n\tu32 sent_bundles;\n\tu32 recv_bundled;\n\tu32 recv_bundles;\n\tu32 retransmitted;\n\tu32 sent_fragmented;\n\tu32 sent_fragments;\n\tu32 recv_fragmented;\n\tu32 recv_fragments;\n\tu32 link_congs;\t\t/* # port sends blocked by congestion */\n\tu32 deferred_recv;\n\tu32 duplicates;\n\tu32 max_queue_sz;\t/* send queue size high water mark */\n\tu32 accu_queue_sz;\t/* used for send queue size profiling */\n\tu32 queue_sz_counts;\t/* used for send queue size profiling */\n\tu32 msg_length_counts;\t/* used for message length profiling */\n\tu32 msg_lengths_total;\t/* used for message length profiling */\n\tu32 msg_length_profile[7]; /* used for msg. length profiling */\n};\n\n/**\n * struct tipc_link - TIPC link data structure\n * @addr: network address of link's peer node\n * @name: link name character string\n * @media_addr: media address to use when sending messages over link\n * @timer: link timer\n * @net: pointer to namespace struct\n * @refcnt: reference counter for permanent references (owner node & timer)\n * @peer_session: link session # being used by peer end of link\n * @peer_bearer_id: bearer id used by link's peer endpoint\n * @bearer_id: local bearer id used by link\n * @tolerance: minimum link continuity loss needed to reset link [in ms]\n * @abort_limit: # of unacknowledged continuity probes needed to reset link\n * @state: current state of link FSM\n * @peer_caps: bitmap describing capabilities of peer node\n * @silent_intv_cnt: # of timer intervals without any reception from peer\n * @proto_msg: template for control messages generated by link\n * @pmsg: convenience pointer to \"proto_msg\" field\n * @priority: current link priority\n * @net_plane: current link network plane ('A' through 'H')\n * @mon_state: cookie with information needed by link monitor\n * @backlog_limit: backlog queue congestion thresholds (indexed by importance)\n * @exp_msg_count: # of tunnelled messages expected during link changeover\n * @reset_rcv_checkpt: seq # of last acknowledged message at time of link reset\n * @mtu: current maximum packet size for this link\n * @advertised_mtu: advertised own mtu when link is being established\n * @transmitq: queue for sent, non-acked messages\n * @backlogq: queue for messages waiting to be sent\n * @snt_nxt: next sequence number to use for outbound messages\n * @ackers: # of peers that needs to ack each packet before it can be released\n * @acked: # last packet acked by a certain peer. Used for broadcast.\n * @rcv_nxt: next sequence number to expect for inbound messages\n * @deferred_queue: deferred queue saved OOS b'cast message received from node\n * @unacked_window: # of inbound messages rx'd without ack'ing back to peer\n * @inputq: buffer queue for messages to be delivered upwards\n * @namedq: buffer queue for name table messages to be delivered upwards\n * @next_out: ptr to first unsent outbound message in queue\n * @wakeupq: linked list of wakeup msgs waiting for link congestion to abate\n * @long_msg_seq_no: next identifier to use for outbound fragmented messages\n * @reasm_buf: head of partially reassembled inbound message fragments\n * @bc_rcvr: marks that this is a broadcast receiver link\n * @stats: collects statistics regarding link activity\n * @session: session to be used by link\n * @snd_nxt_state: next send seq number\n * @rcv_nxt_state: next rcv seq number\n * @in_session: have received ACTIVATE_MSG from peer\n * @active: link is active\n * @if_name: associated interface name\n * @rst_cnt: link reset counter\n * @drop_point: seq number for failover handling (FIXME)\n * @failover_reasm_skb: saved failover msg ptr (FIXME)\n * @failover_deferdq: deferred message queue for failover processing (FIXME)\n * @transmq: the link's transmit queue\n * @backlog: link's backlog by priority (importance)\n * @snd_nxt: next sequence number to be used\n * @rcv_unacked: # messages read by user, but not yet acked back to peer\n * @deferdq: deferred receive queue\n * @window: sliding window size for congestion handling\n * @min_win: minimal send window to be used by link\n * @ssthresh: slow start threshold for congestion handling\n * @max_win: maximal send window to be used by link\n * @cong_acks: congestion acks for congestion avoidance (FIXME)\n * @checkpoint: seq number for congestion window size handling\n * @reasm_tnlmsg: fragmentation/reassembly area for tunnel protocol message\n * @last_gap: last gap ack blocks for bcast (FIXME)\n * @last_ga: ptr to gap ack blocks\n * @bc_rcvlink: the peer specific link used for broadcast reception\n * @bc_sndlink: the namespace global link used for broadcast sending\n * @nack_state: bcast nack state\n * @bc_peer_is_up: peer has acked the bcast init msg\n */\nstruct tipc_link {\n\tu32 addr;\n\tchar name[TIPC_MAX_LINK_NAME];\n\tstruct net *net;\n\n\t/* Management and link supervision data */\n\tu16 peer_session;\n\tu16 session;\n\tu16 snd_nxt_state;\n\tu16 rcv_nxt_state;\n\tu32 peer_bearer_id;\n\tu32 bearer_id;\n\tu32 tolerance;\n\tu32 abort_limit;\n\tu32 state;\n\tu16 peer_caps;\n\tbool in_session;\n\tbool active;\n\tu32 silent_intv_cnt;\n\tchar if_name[TIPC_MAX_IF_NAME];\n\tu32 priority;\n\tchar net_plane;\n\tstruct tipc_mon_state mon_state;\n\tu16 rst_cnt;\n\n\t/* Failover/synch */\n\tu16 drop_point;\n\tstruct sk_buff *failover_reasm_skb;\n\tstruct sk_buff_head failover_deferdq;\n\n\t/* Max packet negotiation */\n\tu16 mtu;\n\tu16 advertised_mtu;\n\n\t/* Sending */\n\tstruct sk_buff_head transmq;\n\tstruct sk_buff_head backlogq;\n\tstruct {\n\t\tu16 len;\n\t\tu16 limit;\n\t\tstruct sk_buff *target_bskb;\n\t} backlog[5];\n\tu16 snd_nxt;\n\n\t/* Reception */\n\tu16 rcv_nxt;\n\tu32 rcv_unacked;\n\tstruct sk_buff_head deferdq;\n\tstruct sk_buff_head *inputq;\n\tstruct sk_buff_head *namedq;\n\n\t/* Congestion handling */\n\tstruct sk_buff_head wakeupq;\n\tu16 window;\n\tu16 min_win;\n\tu16 ssthresh;\n\tu16 max_win;\n\tu16 cong_acks;\n\tu16 checkpoint;\n\n\t/* Fragmentation/reassembly */\n\tstruct sk_buff *reasm_buf;\n\tstruct sk_buff *reasm_tnlmsg;\n\n\t/* Broadcast */\n\tu16 ackers;\n\tu16 acked;\n\tu16 last_gap;\n\tstruct tipc_gap_ack_blks *last_ga;\n\tstruct tipc_link *bc_rcvlink;\n\tstruct tipc_link *bc_sndlink;\n\tu8 nack_state;\n\tbool bc_peer_is_up;\n\n\t/* Statistics */\n\tstruct tipc_stats stats;\n};\n\n/*\n * Error message prefixes\n */\nstatic const char *link_co_err = \"Link tunneling error, \";\nstatic const char *link_rst_msg = \"Resetting link \";\n\n/* Send states for broadcast NACKs\n */\nenum {\n\tBC_NACK_SND_CONDITIONAL,\n\tBC_NACK_SND_UNCONDITIONAL,\n\tBC_NACK_SND_SUPPRESS,\n};\n\n#define TIPC_BC_RETR_LIM  (jiffies + msecs_to_jiffies(10))\n#define TIPC_UC_RETR_TIME (jiffies + msecs_to_jiffies(1))\n\n/* Link FSM states:\n */\nenum {\n\tLINK_ESTABLISHED     = 0xe,\n\tLINK_ESTABLISHING    = 0xe  << 4,\n\tLINK_RESET           = 0x1  << 8,\n\tLINK_RESETTING       = 0x2  << 12,\n\tLINK_PEER_RESET      = 0xd  << 16,\n\tLINK_FAILINGOVER     = 0xf  << 20,\n\tLINK_SYNCHING        = 0xc  << 24\n};\n\n/* Link FSM state checking routines\n */\nstatic int link_is_up(struct tipc_link *l)\n{\n\treturn l->state & (LINK_ESTABLISHED | LINK_SYNCHING);\n}\n\nstatic int tipc_link_proto_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t       struct sk_buff_head *xmitq);\nstatic void tipc_link_build_proto_msg(struct tipc_link *l, int mtyp, bool probe,\n\t\t\t\t      bool probe_reply, u16 rcvgap,\n\t\t\t\t      int tolerance, int priority,\n\t\t\t\t      struct sk_buff_head *xmitq);\nstatic void link_print(struct tipc_link *l, const char *str);\nstatic int tipc_link_build_nack_msg(struct tipc_link *l,\n\t\t\t\t    struct sk_buff_head *xmitq);\nstatic void tipc_link_build_bc_init_msg(struct tipc_link *l,\n\t\t\t\t\tstruct sk_buff_head *xmitq);\nstatic u8 __tipc_build_gap_ack_blks(struct tipc_gap_ack_blks *ga,\n\t\t\t\t    struct tipc_link *l, u8 start_index);\nstatic u16 tipc_build_gap_ack_blks(struct tipc_link *l, struct tipc_msg *hdr);\nstatic int tipc_link_advance_transmq(struct tipc_link *l, struct tipc_link *r,\n\t\t\t\t     u16 acked, u16 gap,\n\t\t\t\t     struct tipc_gap_ack_blks *ga,\n\t\t\t\t     struct sk_buff_head *xmitq,\n\t\t\t\t     bool *retransmitted, int *rc);\nstatic void tipc_link_update_cwin(struct tipc_link *l, int released,\n\t\t\t\t  bool retransmitted);\n/*\n *  Simple non-static link routines (i.e. referenced outside this file)\n */\nbool tipc_link_is_up(struct tipc_link *l)\n{\n\treturn link_is_up(l);\n}\n\nbool tipc_link_peer_is_down(struct tipc_link *l)\n{\n\treturn l->state == LINK_PEER_RESET;\n}\n\nbool tipc_link_is_reset(struct tipc_link *l)\n{\n\treturn l->state & (LINK_RESET | LINK_FAILINGOVER | LINK_ESTABLISHING);\n}\n\nbool tipc_link_is_establishing(struct tipc_link *l)\n{\n\treturn l->state == LINK_ESTABLISHING;\n}\n\nbool tipc_link_is_synching(struct tipc_link *l)\n{\n\treturn l->state == LINK_SYNCHING;\n}\n\nbool tipc_link_is_failingover(struct tipc_link *l)\n{\n\treturn l->state == LINK_FAILINGOVER;\n}\n\nbool tipc_link_is_blocked(struct tipc_link *l)\n{\n\treturn l->state & (LINK_RESETTING | LINK_PEER_RESET | LINK_FAILINGOVER);\n}\n\nstatic bool link_is_bc_sndlink(struct tipc_link *l)\n{\n\treturn !l->bc_sndlink;\n}\n\nstatic bool link_is_bc_rcvlink(struct tipc_link *l)\n{\n\treturn ((l->bc_rcvlink == l) && !link_is_bc_sndlink(l));\n}\n\nvoid tipc_link_set_active(struct tipc_link *l, bool active)\n{\n\tl->active = active;\n}\n\nu32 tipc_link_id(struct tipc_link *l)\n{\n\treturn l->peer_bearer_id << 16 | l->bearer_id;\n}\n\nint tipc_link_min_win(struct tipc_link *l)\n{\n\treturn l->min_win;\n}\n\nint tipc_link_max_win(struct tipc_link *l)\n{\n\treturn l->max_win;\n}\n\nint tipc_link_prio(struct tipc_link *l)\n{\n\treturn l->priority;\n}\n\nunsigned long tipc_link_tolerance(struct tipc_link *l)\n{\n\treturn l->tolerance;\n}\n\nstruct sk_buff_head *tipc_link_inputq(struct tipc_link *l)\n{\n\treturn l->inputq;\n}\n\nchar tipc_link_plane(struct tipc_link *l)\n{\n\treturn l->net_plane;\n}\n\nvoid tipc_link_update_caps(struct tipc_link *l, u16 capabilities)\n{\n\tl->peer_caps = capabilities;\n}\n\nvoid tipc_link_add_bc_peer(struct tipc_link *snd_l,\n\t\t\t   struct tipc_link *uc_l,\n\t\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct tipc_link *rcv_l = uc_l->bc_rcvlink;\n\n\tsnd_l->ackers++;\n\trcv_l->acked = snd_l->snd_nxt - 1;\n\tsnd_l->state = LINK_ESTABLISHED;\n\ttipc_link_build_bc_init_msg(uc_l, xmitq);\n}\n\nvoid tipc_link_remove_bc_peer(struct tipc_link *snd_l,\n\t\t\t      struct tipc_link *rcv_l,\n\t\t\t      struct sk_buff_head *xmitq)\n{\n\tu16 ack = snd_l->snd_nxt - 1;\n\n\tsnd_l->ackers--;\n\trcv_l->bc_peer_is_up = true;\n\trcv_l->state = LINK_ESTABLISHED;\n\ttipc_link_bc_ack_rcv(rcv_l, ack, 0, NULL, xmitq, NULL);\n\ttrace_tipc_link_reset(rcv_l, TIPC_DUMP_ALL, \"bclink removed!\");\n\ttipc_link_reset(rcv_l);\n\trcv_l->state = LINK_RESET;\n\tif (!snd_l->ackers) {\n\t\ttrace_tipc_link_reset(snd_l, TIPC_DUMP_ALL, \"zero ackers!\");\n\t\ttipc_link_reset(snd_l);\n\t\tsnd_l->state = LINK_RESET;\n\t\t__skb_queue_purge(xmitq);\n\t}\n}\n\nint tipc_link_bc_peers(struct tipc_link *l)\n{\n\treturn l->ackers;\n}\n\nstatic u16 link_bc_rcv_gap(struct tipc_link *l)\n{\n\tstruct sk_buff *skb = skb_peek(&l->deferdq);\n\tu16 gap = 0;\n\n\tif (more(l->snd_nxt, l->rcv_nxt))\n\t\tgap = l->snd_nxt - l->rcv_nxt;\n\tif (skb)\n\t\tgap = buf_seqno(skb) - l->rcv_nxt;\n\treturn gap;\n}\n\nvoid tipc_link_set_mtu(struct tipc_link *l, int mtu)\n{\n\tl->mtu = mtu;\n}\n\nint tipc_link_mtu(struct tipc_link *l)\n{\n\treturn l->mtu;\n}\n\nint tipc_link_mss(struct tipc_link *l)\n{\n#ifdef CONFIG_TIPC_CRYPTO\n\treturn l->mtu - INT_H_SIZE - EMSG_OVERHEAD;\n#else\n\treturn l->mtu - INT_H_SIZE;\n#endif\n}\n\nu16 tipc_link_rcv_nxt(struct tipc_link *l)\n{\n\treturn l->rcv_nxt;\n}\n\nu16 tipc_link_acked(struct tipc_link *l)\n{\n\treturn l->acked;\n}\n\nchar *tipc_link_name(struct tipc_link *l)\n{\n\treturn l->name;\n}\n\nu32 tipc_link_state(struct tipc_link *l)\n{\n\treturn l->state;\n}\n\n/**\n * tipc_link_create - create a new link\n * @net: pointer to associated network namespace\n * @if_name: associated interface name\n * @bearer_id: id (index) of associated bearer\n * @tolerance: link tolerance to be used by link\n * @net_plane: network plane (A,B,c..) this link belongs to\n * @mtu: mtu to be advertised by link\n * @priority: priority to be used by link\n * @min_win: minimal send window to be used by link\n * @max_win: maximal send window to be used by link\n * @session: session to be used by link\n * @peer: node id of peer node\n * @peer_caps: bitmap describing peer node capabilities\n * @bc_sndlink: the namespace global link used for broadcast sending\n * @bc_rcvlink: the peer specific link used for broadcast reception\n * @inputq: queue to put messages ready for delivery\n * @namedq: queue to put binding table update messages ready for delivery\n * @link: return value, pointer to put the created link\n * @self: local unicast link id\n * @peer_id: 128-bit ID of peer\n *\n * Return: true if link was created, otherwise false\n */\nbool tipc_link_create(struct net *net, char *if_name, int bearer_id,\n\t\t      int tolerance, char net_plane, u32 mtu, int priority,\n\t\t      u32 min_win, u32 max_win, u32 session, u32 self,\n\t\t      u32 peer, u8 *peer_id, u16 peer_caps,\n\t\t      struct tipc_link *bc_sndlink,\n\t\t      struct tipc_link *bc_rcvlink,\n\t\t      struct sk_buff_head *inputq,\n\t\t      struct sk_buff_head *namedq,\n\t\t      struct tipc_link **link)\n{\n\tchar peer_str[NODE_ID_STR_LEN] = {0,};\n\tchar self_str[NODE_ID_STR_LEN] = {0,};\n\tstruct tipc_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_ATOMIC);\n\tif (!l)\n\t\treturn false;\n\t*link = l;\n\tl->session = session;\n\n\t/* Set link name for unicast links only */\n\tif (peer_id) {\n\t\ttipc_nodeid2string(self_str, tipc_own_id(net));\n\t\tif (strlen(self_str) > 16)\n\t\t\tsprintf(self_str, \"%x\", self);\n\t\ttipc_nodeid2string(peer_str, peer_id);\n\t\tif (strlen(peer_str) > 16)\n\t\t\tsprintf(peer_str, \"%x\", peer);\n\t}\n\t/* Peer i/f name will be completed by reset/activate message */\n\tsnprintf(l->name, sizeof(l->name), \"%s:%s-%s:unknown\",\n\t\t self_str, if_name, peer_str);\n\n\tstrcpy(l->if_name, if_name);\n\tl->addr = peer;\n\tl->peer_caps = peer_caps;\n\tl->net = net;\n\tl->in_session = false;\n\tl->bearer_id = bearer_id;\n\tl->tolerance = tolerance;\n\tif (bc_rcvlink)\n\t\tbc_rcvlink->tolerance = tolerance;\n\tl->net_plane = net_plane;\n\tl->advertised_mtu = mtu;\n\tl->mtu = mtu;\n\tl->priority = priority;\n\ttipc_link_set_queue_limits(l, min_win, max_win);\n\tl->ackers = 1;\n\tl->bc_sndlink = bc_sndlink;\n\tl->bc_rcvlink = bc_rcvlink;\n\tl->inputq = inputq;\n\tl->namedq = namedq;\n\tl->state = LINK_RESETTING;\n\t__skb_queue_head_init(&l->transmq);\n\t__skb_queue_head_init(&l->backlogq);\n\t__skb_queue_head_init(&l->deferdq);\n\t__skb_queue_head_init(&l->failover_deferdq);\n\tskb_queue_head_init(&l->wakeupq);\n\tskb_queue_head_init(l->inputq);\n\treturn true;\n}\n\n/**\n * tipc_link_bc_create - create new link to be used for broadcast\n * @net: pointer to associated network namespace\n * @mtu: mtu to be used initially if no peers\n * @min_win: minimal send window to be used by link\n * @max_win: maximal send window to be used by link\n * @inputq: queue to put messages ready for delivery\n * @namedq: queue to put binding table update messages ready for delivery\n * @link: return value, pointer to put the created link\n * @ownnode: identity of own node\n * @peer: node id of peer node\n * @peer_id: 128-bit ID of peer\n * @peer_caps: bitmap describing peer node capabilities\n * @bc_sndlink: the namespace global link used for broadcast sending\n *\n * Return: true if link was created, otherwise false\n */\nbool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer, u8 *peer_id,\n\t\t\t int mtu, u32 min_win, u32 max_win, u16 peer_caps,\n\t\t\t struct sk_buff_head *inputq,\n\t\t\t struct sk_buff_head *namedq,\n\t\t\t struct tipc_link *bc_sndlink,\n\t\t\t struct tipc_link **link)\n{\n\tstruct tipc_link *l;\n\n\tif (!tipc_link_create(net, \"\", MAX_BEARERS, 0, 'Z', mtu, 0, min_win,\n\t\t\t      max_win, 0, ownnode, peer, NULL, peer_caps,\n\t\t\t      bc_sndlink, NULL, inputq, namedq, link))\n\t\treturn false;\n\n\tl = *link;\n\tif (peer_id) {\n\t\tchar peer_str[NODE_ID_STR_LEN] = {0,};\n\n\t\ttipc_nodeid2string(peer_str, peer_id);\n\t\tif (strlen(peer_str) > 16)\n\t\t\tsprintf(peer_str, \"%x\", peer);\n\t\t/* Broadcast receiver link name: \"broadcast-link:<peer>\" */\n\t\tsnprintf(l->name, sizeof(l->name), \"%s:%s\", tipc_bclink_name,\n\t\t\t peer_str);\n\t} else {\n\t\tstrcpy(l->name, tipc_bclink_name);\n\t}\n\ttrace_tipc_link_reset(l, TIPC_DUMP_ALL, \"bclink created!\");\n\ttipc_link_reset(l);\n\tl->state = LINK_RESET;\n\tl->ackers = 0;\n\tl->bc_rcvlink = l;\n\n\t/* Broadcast send link is always up */\n\tif (link_is_bc_sndlink(l))\n\t\tl->state = LINK_ESTABLISHED;\n\n\t/* Disable replicast if even a single peer doesn't support it */\n\tif (link_is_bc_rcvlink(l) && !(peer_caps & TIPC_BCAST_RCAST))\n\t\ttipc_bcast_toggle_rcast(net, false);\n\n\treturn true;\n}\n\n/**\n * tipc_link_fsm_evt - link finite state machine\n * @l: pointer to link\n * @evt: state machine event to be processed\n */\nint tipc_link_fsm_evt(struct tipc_link *l, int evt)\n{\n\tint rc = 0;\n\tint old_state = l->state;\n\n\tswitch (l->state) {\n\tcase LINK_RESETTING:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_PEER_RESET;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_RESET:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_ESTABLISHING;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\t\tl->state = LINK_FAILINGOVER;\n\t\tcase LINK_FAILURE_EVT:\n\t\tcase LINK_RESET_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_PEER_RESET:\n\t\tswitch (evt) {\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_ESTABLISHING;\n\t\t\tbreak;\n\t\tcase LINK_PEER_RESET_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_FAILINGOVER:\n\t\tswitch (evt) {\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_PEER_RESET_EVT:\n\t\tcase LINK_RESET_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_ESTABLISHING:\n\t\tswitch (evt) {\n\t\tcase LINK_ESTABLISH_EVT:\n\t\t\tl->state = LINK_ESTABLISHED;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\t\tl->state = LINK_FAILINGOVER;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\tcase LINK_PEER_RESET_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_ESTABLISHED:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_PEER_RESET;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tl->state = LINK_RESETTING;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\t\tl->state = LINK_SYNCHING;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_SYNCHING:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_PEER_RESET;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tl->state = LINK_RESETTING;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_END_EVT:\n\t\t\tl->state = LINK_ESTABLISHED;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown FSM state %x in %s\\n\", l->state, l->name);\n\t}\n\ttrace_tipc_link_fsm(l->name, old_state, l->state, evt);\n\treturn rc;\nillegal_evt:\n\tpr_err(\"Illegal FSM event %x in state %x on link %s\\n\",\n\t       evt, l->state, l->name);\n\ttrace_tipc_link_fsm(l->name, old_state, l->state, evt);\n\treturn rc;\n}\n\n/* link_profile_stats - update statistical profiling of traffic\n */\nstatic void link_profile_stats(struct tipc_link *l)\n{\n\tstruct sk_buff *skb;\n\tstruct tipc_msg *msg;\n\tint length;\n\n\t/* Update counters used in statistical profiling of send traffic */\n\tl->stats.accu_queue_sz += skb_queue_len(&l->transmq);\n\tl->stats.queue_sz_counts++;\n\n\tskb = skb_peek(&l->transmq);\n\tif (!skb)\n\t\treturn;\n\tmsg = buf_msg(skb);\n\tlength = msg_size(msg);\n\n\tif (msg_user(msg) == MSG_FRAGMENTER) {\n\t\tif (msg_type(msg) != FIRST_FRAGMENT)\n\t\t\treturn;\n\t\tlength = msg_size(msg_inner_hdr(msg));\n\t}\n\tl->stats.msg_lengths_total += length;\n\tl->stats.msg_length_counts++;\n\tif (length <= 64)\n\t\tl->stats.msg_length_profile[0]++;\n\telse if (length <= 256)\n\t\tl->stats.msg_length_profile[1]++;\n\telse if (length <= 1024)\n\t\tl->stats.msg_length_profile[2]++;\n\telse if (length <= 4096)\n\t\tl->stats.msg_length_profile[3]++;\n\telse if (length <= 16384)\n\t\tl->stats.msg_length_profile[4]++;\n\telse if (length <= 32768)\n\t\tl->stats.msg_length_profile[5]++;\n\telse\n\t\tl->stats.msg_length_profile[6]++;\n}\n\n/**\n * tipc_link_too_silent - check if link is \"too silent\"\n * @l: tipc link to be checked\n *\n * Return: true if the link 'silent_intv_cnt' is about to reach the\n * 'abort_limit' value, otherwise false\n */\nbool tipc_link_too_silent(struct tipc_link *l)\n{\n\treturn (l->silent_intv_cnt + 2 > l->abort_limit);\n}\n\n/* tipc_link_timeout - perform periodic task as instructed from node timeout\n */\nint tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq)\n{\n\tint mtyp = 0;\n\tint rc = 0;\n\tbool state = false;\n\tbool probe = false;\n\tbool setup = false;\n\tu16 bc_snt = l->bc_sndlink->snd_nxt - 1;\n\tu16 bc_acked = l->bc_rcvlink->acked;\n\tstruct tipc_mon_state *mstate = &l->mon_state;\n\n\ttrace_tipc_link_timeout(l, TIPC_DUMP_NONE, \" \");\n\ttrace_tipc_link_too_silent(l, TIPC_DUMP_ALL, \" \");\n\tswitch (l->state) {\n\tcase LINK_ESTABLISHED:\n\tcase LINK_SYNCHING:\n\t\tmtyp = STATE_MSG;\n\t\tlink_profile_stats(l);\n\t\ttipc_mon_get_state(l->net, l->addr, mstate, l->bearer_id);\n\t\tif (mstate->reset || (l->silent_intv_cnt > l->abort_limit))\n\t\t\treturn tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\tstate = bc_acked != bc_snt;\n\t\tstate |= l->bc_rcvlink->rcv_unacked;\n\t\tstate |= l->rcv_unacked;\n\t\tstate |= !skb_queue_empty(&l->transmq);\n\t\tprobe = mstate->probing;\n\t\tprobe |= l->silent_intv_cnt;\n\t\tif (probe || mstate->monitoring)\n\t\t\tl->silent_intv_cnt++;\n\t\tprobe |= !skb_queue_empty(&l->deferdq);\n\t\tif (l->snd_nxt == l->checkpoint) {\n\t\t\ttipc_link_update_cwin(l, 0, 0);\n\t\t\tprobe = true;\n\t\t}\n\t\tl->checkpoint = l->snd_nxt;\n\t\tbreak;\n\tcase LINK_RESET:\n\t\tsetup = l->rst_cnt++ <= 4;\n\t\tsetup |= !(l->rst_cnt % 16);\n\t\tmtyp = RESET_MSG;\n\t\tbreak;\n\tcase LINK_ESTABLISHING:\n\t\tsetup = true;\n\t\tmtyp = ACTIVATE_MSG;\n\t\tbreak;\n\tcase LINK_PEER_RESET:\n\tcase LINK_RESETTING:\n\tcase LINK_FAILINGOVER:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (state || probe || setup)\n\t\ttipc_link_build_proto_msg(l, mtyp, probe, 0, 0, 0, 0, xmitq);\n\n\treturn rc;\n}\n\n/**\n * link_schedule_user - schedule a message sender for wakeup after congestion\n * @l: congested link\n * @hdr: header of message that is being sent\n * Create pseudo msg to send back to user when congestion abates\n */\nstatic int link_schedule_user(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tu32 dnode = tipc_own_addr(l->net);\n\tu32 dport = msg_origport(hdr);\n\tstruct sk_buff *skb;\n\n\t/* Create and schedule wakeup pseudo message */\n\tskb = tipc_msg_create(SOCK_WAKEUP, 0, INT_H_SIZE, 0,\n\t\t\t      dnode, l->addr, dport, 0, 0);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\tmsg_set_dest_droppable(buf_msg(skb), true);\n\tTIPC_SKB_CB(skb)->chain_imp = msg_importance(hdr);\n\tskb_queue_tail(&l->wakeupq, skb);\n\tl->stats.link_congs++;\n\ttrace_tipc_link_conges(l, TIPC_DUMP_ALL, \"wakeup scheduled!\");\n\treturn -ELINKCONG;\n}\n\n/**\n * link_prepare_wakeup - prepare users for wakeup after congestion\n * @l: congested link\n * Wake up a number of waiting users, as permitted by available space\n * in the send queue\n */\nstatic void link_prepare_wakeup(struct tipc_link *l)\n{\n\tstruct sk_buff_head *wakeupq = &l->wakeupq;\n\tstruct sk_buff_head *inputq = l->inputq;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sk_buff_head tmpq;\n\tint avail[5] = {0,};\n\tint imp = 0;\n\n\t__skb_queue_head_init(&tmpq);\n\n\tfor (; imp <= TIPC_SYSTEM_IMPORTANCE; imp++)\n\t\tavail[imp] = l->backlog[imp].limit - l->backlog[imp].len;\n\n\tskb_queue_walk_safe(wakeupq, skb, tmp) {\n\t\timp = TIPC_SKB_CB(skb)->chain_imp;\n\t\tif (avail[imp] <= 0)\n\t\t\tcontinue;\n\t\tavail[imp]--;\n\t\t__skb_unlink(skb, wakeupq);\n\t\t__skb_queue_tail(&tmpq, skb);\n\t}\n\n\tspin_lock_bh(&inputq->lock);\n\tskb_queue_splice_tail(&tmpq, inputq);\n\tspin_unlock_bh(&inputq->lock);\n\n}\n\n/**\n * tipc_link_set_skb_retransmit_time - set the time at which retransmission of\n *                                     the given skb should be next attempted\n * @skb: skb to set a future retransmission time for\n * @l: link the skb will be transmitted on\n */\nstatic void tipc_link_set_skb_retransmit_time(struct sk_buff *skb,\n\t\t\t\t\t      struct tipc_link *l)\n{\n\tif (link_is_bc_sndlink(l))\n\t\tTIPC_SKB_CB(skb)->nxt_retr = TIPC_BC_RETR_LIM;\n\telse\n\t\tTIPC_SKB_CB(skb)->nxt_retr = TIPC_UC_RETR_TIME;\n}\n\nvoid tipc_link_reset(struct tipc_link *l)\n{\n\tstruct sk_buff_head list;\n\tu32 imp;\n\n\t__skb_queue_head_init(&list);\n\n\tl->in_session = false;\n\t/* Force re-synch of peer session number before establishing */\n\tl->peer_session--;\n\tl->session++;\n\tl->mtu = l->advertised_mtu;\n\n\tspin_lock_bh(&l->wakeupq.lock);\n\tskb_queue_splice_init(&l->wakeupq, &list);\n\tspin_unlock_bh(&l->wakeupq.lock);\n\n\tspin_lock_bh(&l->inputq->lock);\n\tskb_queue_splice_init(&list, l->inputq);\n\tspin_unlock_bh(&l->inputq->lock);\n\n\t__skb_queue_purge(&l->transmq);\n\t__skb_queue_purge(&l->deferdq);\n\t__skb_queue_purge(&l->backlogq);\n\t__skb_queue_purge(&l->failover_deferdq);\n\tfor (imp = 0; imp <= TIPC_SYSTEM_IMPORTANCE; imp++) {\n\t\tl->backlog[imp].len = 0;\n\t\tl->backlog[imp].target_bskb = NULL;\n\t}\n\tkfree_skb(l->reasm_buf);\n\tkfree_skb(l->reasm_tnlmsg);\n\tkfree_skb(l->failover_reasm_skb);\n\tl->reasm_buf = NULL;\n\tl->reasm_tnlmsg = NULL;\n\tl->failover_reasm_skb = NULL;\n\tl->rcv_unacked = 0;\n\tl->snd_nxt = 1;\n\tl->rcv_nxt = 1;\n\tl->snd_nxt_state = 1;\n\tl->rcv_nxt_state = 1;\n\tl->acked = 0;\n\tl->last_gap = 0;\n\tkfree(l->last_ga);\n\tl->last_ga = NULL;\n\tl->silent_intv_cnt = 0;\n\tl->rst_cnt = 0;\n\tl->bc_peer_is_up = false;\n\tmemset(&l->mon_state, 0, sizeof(l->mon_state));\n\ttipc_link_reset_stats(l);\n}\n\n/**\n * tipc_link_xmit(): enqueue buffer list according to queue situation\n * @l: link to use\n * @list: chain of buffers containing message\n * @xmitq: returned list of packets to be sent by caller\n *\n * Consumes the buffer chain.\n * Messages at TIPC_SYSTEM_IMPORTANCE are always accepted\n * Return: 0 if success, or errno: -ELINKCONG, -EMSGSIZE or -ENOBUFS\n */\nint tipc_link_xmit(struct tipc_link *l, struct sk_buff_head *list,\n\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb_peek(list));\n\tstruct sk_buff_head *backlogq = &l->backlogq;\n\tstruct sk_buff_head *transmq = &l->transmq;\n\tstruct sk_buff *skb, *_skb;\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno = l->snd_nxt;\n\tint pkt_cnt = skb_queue_len(list);\n\tint imp = msg_importance(hdr);\n\tunsigned int mss = tipc_link_mss(l);\n\tunsigned int cwin = l->window;\n\tunsigned int mtu = l->mtu;\n\tbool new_bundle;\n\tint rc = 0;\n\n\tif (unlikely(msg_size(hdr) > mtu)) {\n\t\tpr_warn(\"Too large msg, purging xmit list %d %d %d %d %d!\\n\",\n\t\t\tskb_queue_len(list), msg_user(hdr),\n\t\t\tmsg_type(hdr), msg_size(hdr), mtu);\n\t\t__skb_queue_purge(list);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* Allow oversubscription of one data msg per source at congestion */\n\tif (unlikely(l->backlog[imp].len >= l->backlog[imp].limit)) {\n\t\tif (imp == TIPC_SYSTEM_IMPORTANCE) {\n\t\t\tpr_warn(\"%s<%s>, link overflow\", link_rst_msg, l->name);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\trc = link_schedule_user(l, hdr);\n\t}\n\n\tif (pkt_cnt > 1) {\n\t\tl->stats.sent_fragmented++;\n\t\tl->stats.sent_fragments += pkt_cnt;\n\t}\n\n\t/* Prepare each packet for sending, and add to relevant queue: */\n\twhile ((skb = __skb_dequeue(list))) {\n\t\tif (likely(skb_queue_len(transmq) < cwin)) {\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_seqno(hdr, seqno);\n\t\t\tmsg_set_ack(hdr, ack);\n\t\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\t\t_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!_skb) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\t__skb_queue_purge(list);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\t__skb_queue_tail(transmq, skb);\n\t\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\t\t\t__skb_queue_tail(xmitq, _skb);\n\t\t\tTIPC_SKB_CB(skb)->ackers = l->ackers;\n\t\t\tl->rcv_unacked = 0;\n\t\t\tl->stats.sent_pkts++;\n\t\t\tseqno++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tipc_msg_try_bundle(l->backlog[imp].target_bskb, &skb,\n\t\t\t\t\tmss, l->addr, &new_bundle)) {\n\t\t\tif (skb) {\n\t\t\t\t/* Keep a ref. to the skb for next try */\n\t\t\t\tl->backlog[imp].target_bskb = skb;\n\t\t\t\tl->backlog[imp].len++;\n\t\t\t\t__skb_queue_tail(backlogq, skb);\n\t\t\t} else {\n\t\t\t\tif (new_bundle) {\n\t\t\t\t\tl->stats.sent_bundles++;\n\t\t\t\t\tl->stats.sent_bundled++;\n\t\t\t\t}\n\t\t\t\tl->stats.sent_bundled++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tl->backlog[imp].target_bskb = NULL;\n\t\tl->backlog[imp].len += (1 + skb_queue_len(list));\n\t\t__skb_queue_tail(backlogq, skb);\n\t\tskb_queue_splice_tail_init(list, backlogq);\n\t}\n\tl->snd_nxt = seqno;\n\treturn rc;\n}\n\nstatic void tipc_link_update_cwin(struct tipc_link *l, int released,\n\t\t\t\t  bool retransmitted)\n{\n\tint bklog_len = skb_queue_len(&l->backlogq);\n\tstruct sk_buff_head *txq = &l->transmq;\n\tint txq_len = skb_queue_len(txq);\n\tu16 cwin = l->window;\n\n\t/* Enter fast recovery */\n\tif (unlikely(retransmitted)) {\n\t\tl->ssthresh = max_t(u16, l->window / 2, 300);\n\t\tl->window = min_t(u16, l->ssthresh, l->window);\n\t\treturn;\n\t}\n\t/* Enter slow start */\n\tif (unlikely(!released)) {\n\t\tl->ssthresh = max_t(u16, l->window / 2, 300);\n\t\tl->window = l->min_win;\n\t\treturn;\n\t}\n\t/* Don't increase window if no pressure on the transmit queue */\n\tif (txq_len + bklog_len < cwin)\n\t\treturn;\n\n\t/* Don't increase window if there are holes the transmit queue */\n\tif (txq_len && l->snd_nxt - buf_seqno(skb_peek(txq)) != txq_len)\n\t\treturn;\n\n\tl->cong_acks += released;\n\n\t/* Slow start  */\n\tif (cwin <= l->ssthresh) {\n\t\tl->window = min_t(u16, cwin + released, l->max_win);\n\t\treturn;\n\t}\n\t/* Congestion avoidance */\n\tif (l->cong_acks < cwin)\n\t\treturn;\n\tl->window = min_t(u16, ++cwin, l->max_win);\n\tl->cong_acks = 0;\n}\n\nstatic void tipc_link_advance_backlog(struct tipc_link *l,\n\t\t\t\t      struct sk_buff_head *xmitq)\n{\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tstruct sk_buff_head *txq = &l->transmq;\n\tstruct sk_buff *skb, *_skb;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno = l->snd_nxt;\n\tstruct tipc_msg *hdr;\n\tu16 cwin = l->window;\n\tu32 imp;\n\n\twhile (skb_queue_len(txq) < cwin) {\n\t\tskb = skb_peek(&l->backlogq);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\t_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!_skb)\n\t\t\tbreak;\n\t\t__skb_dequeue(&l->backlogq);\n\t\thdr = buf_msg(skb);\n\t\timp = msg_importance(hdr);\n\t\tl->backlog[imp].len--;\n\t\tif (unlikely(skb == l->backlog[imp].target_bskb))\n\t\t\tl->backlog[imp].target_bskb = NULL;\n\t\t__skb_queue_tail(&l->transmq, skb);\n\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\n\t\t__skb_queue_tail(xmitq, _skb);\n\t\tTIPC_SKB_CB(skb)->ackers = l->ackers;\n\t\tmsg_set_seqno(hdr, seqno);\n\t\tmsg_set_ack(hdr, ack);\n\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\tl->rcv_unacked = 0;\n\t\tl->stats.sent_pkts++;\n\t\tseqno++;\n\t}\n\tl->snd_nxt = seqno;\n}\n\n/**\n * link_retransmit_failure() - Detect repeated retransmit failures\n * @l: tipc link sender\n * @r: tipc link receiver (= l in case of unicast)\n * @rc: returned code\n *\n * Return: true if the repeated retransmit failures happens, otherwise\n * false\n */\nstatic bool link_retransmit_failure(struct tipc_link *l, struct tipc_link *r,\n\t\t\t\t    int *rc)\n{\n\tstruct sk_buff *skb = skb_peek(&l->transmq);\n\tstruct tipc_msg *hdr;\n\n\tif (!skb)\n\t\treturn false;\n\n\tif (!TIPC_SKB_CB(skb)->retr_cnt)\n\t\treturn false;\n\n\tif (!time_after(jiffies, TIPC_SKB_CB(skb)->retr_stamp +\n\t\t\tmsecs_to_jiffies(r->tolerance * 10)))\n\t\treturn false;\n\n\thdr = buf_msg(skb);\n\tif (link_is_bc_sndlink(l) && !less(r->acked, msg_seqno(hdr)))\n\t\treturn false;\n\n\tpr_warn(\"Retransmission failure on link <%s>\\n\", l->name);\n\tlink_print(l, \"State of link \");\n\tpr_info(\"Failed msg: usr %u, typ %u, len %u, err %u\\n\",\n\t\tmsg_user(hdr), msg_type(hdr), msg_size(hdr), msg_errcode(hdr));\n\tpr_info(\"sqno %u, prev: %x, dest: %x\\n\",\n\t\tmsg_seqno(hdr), msg_prevnode(hdr), msg_destnode(hdr));\n\tpr_info(\"retr_stamp %d, retr_cnt %d\\n\",\n\t\tjiffies_to_msecs(TIPC_SKB_CB(skb)->retr_stamp),\n\t\tTIPC_SKB_CB(skb)->retr_cnt);\n\n\ttrace_tipc_list_dump(&l->transmq, true, \"retrans failure!\");\n\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"retrans failure!\");\n\ttrace_tipc_link_dump(r, TIPC_DUMP_NONE, \"retrans failure!\");\n\n\tif (link_is_bc_sndlink(l)) {\n\t\tr->state = LINK_RESET;\n\t\t*rc |= TIPC_LINK_DOWN_EVT;\n\t} else {\n\t\t*rc |= tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t}\n\n\treturn true;\n}\n\n/* tipc_data_input - deliver data and name distr msgs to upper layer\n *\n * Consumes buffer if message is of right type\n * Node lock must be held\n */\nstatic bool tipc_data_input(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t    struct sk_buff_head *inputq)\n{\n\tstruct sk_buff_head *mc_inputq = l->bc_rcvlink->inputq;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\n\tswitch (msg_user(hdr)) {\n\tcase TIPC_LOW_IMPORTANCE:\n\tcase TIPC_MEDIUM_IMPORTANCE:\n\tcase TIPC_HIGH_IMPORTANCE:\n\tcase TIPC_CRITICAL_IMPORTANCE:\n\t\tif (unlikely(msg_in_group(hdr) || msg_mcast(hdr))) {\n\t\t\tskb_queue_tail(mc_inputq, skb);\n\t\t\treturn true;\n\t\t}\n\t\tfallthrough;\n\tcase CONN_MANAGER:\n\t\tskb_queue_tail(inputq, skb);\n\t\treturn true;\n\tcase GROUP_PROTOCOL:\n\t\tskb_queue_tail(mc_inputq, skb);\n\t\treturn true;\n\tcase NAME_DISTRIBUTOR:\n\t\tl->bc_rcvlink->state = LINK_ESTABLISHED;\n\t\tskb_queue_tail(l->namedq, skb);\n\t\treturn true;\n\tcase MSG_BUNDLER:\n\tcase TUNNEL_PROTOCOL:\n\tcase MSG_FRAGMENTER:\n\tcase BCAST_PROTOCOL:\n\t\treturn false;\n#ifdef CONFIG_TIPC_CRYPTO\n\tcase MSG_CRYPTO:\n\t\ttipc_crypto_msg_rcv(l->net, skb);\n\t\treturn true;\n#endif\n\tdefault:\n\t\tpr_warn(\"Dropping received illegal msg type\\n\");\n\t\tkfree_skb(skb);\n\t\treturn true;\n\t}\n}\n\n/* tipc_link_input - process packet that has passed link protocol check\n *\n * Consumes buffer\n */\nstatic int tipc_link_input(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t   struct sk_buff_head *inputq,\n\t\t\t   struct sk_buff **reasm_skb)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct sk_buff *iskb;\n\tstruct sk_buff_head tmpq;\n\tint usr = msg_user(hdr);\n\tint pos = 0;\n\n\tif (usr == MSG_BUNDLER) {\n\t\tskb_queue_head_init(&tmpq);\n\t\tl->stats.recv_bundles++;\n\t\tl->stats.recv_bundled += msg_msgcnt(hdr);\n\t\twhile (tipc_msg_extract(skb, &iskb, &pos))\n\t\t\ttipc_data_input(l, iskb, &tmpq);\n\t\ttipc_skb_queue_splice_tail(&tmpq, inputq);\n\t\treturn 0;\n\t} else if (usr == MSG_FRAGMENTER) {\n\t\tl->stats.recv_fragments++;\n\t\tif (tipc_buf_append(reasm_skb, &skb)) {\n\t\t\tl->stats.recv_fragmented++;\n\t\t\ttipc_data_input(l, skb, inputq);\n\t\t} else if (!*reasm_skb && !link_is_bc_rcvlink(l)) {\n\t\t\tpr_warn_ratelimited(\"Unable to build fragment list\\n\");\n\t\t\treturn tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\t\treturn 0;\n\t} else if (usr == BCAST_PROTOCOL) {\n\t\ttipc_bcast_lock(l->net);\n\t\ttipc_link_bc_init_rcv(l->bc_rcvlink, hdr);\n\t\ttipc_bcast_unlock(l->net);\n\t}\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/* tipc_link_tnl_rcv() - receive TUNNEL_PROTOCOL message, drop or process the\n *\t\t\t inner message along with the ones in the old link's\n *\t\t\t deferdq\n * @l: tunnel link\n * @skb: TUNNEL_PROTOCOL message\n * @inputq: queue to put messages ready for delivery\n */\nstatic int tipc_link_tnl_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t     struct sk_buff_head *inputq)\n{\n\tstruct sk_buff **reasm_skb = &l->failover_reasm_skb;\n\tstruct sk_buff **reasm_tnlmsg = &l->reasm_tnlmsg;\n\tstruct sk_buff_head *fdefq = &l->failover_deferdq;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct sk_buff *iskb;\n\tint ipos = 0;\n\tint rc = 0;\n\tu16 seqno;\n\n\tif (msg_type(hdr) == SYNCH_MSG) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* Not a fragment? */\n\tif (likely(!msg_nof_fragms(hdr))) {\n\t\tif (unlikely(!tipc_msg_extract(skb, &iskb, &ipos))) {\n\t\t\tpr_warn_ratelimited(\"Unable to extract msg, defq: %d\\n\",\n\t\t\t\t\t    skb_queue_len(fdefq));\n\t\t\treturn 0;\n\t\t}\n\t\tkfree_skb(skb);\n\t} else {\n\t\t/* Set fragment type for buf_append */\n\t\tif (msg_fragm_no(hdr) == 1)\n\t\t\tmsg_set_type(hdr, FIRST_FRAGMENT);\n\t\telse if (msg_fragm_no(hdr) < msg_nof_fragms(hdr))\n\t\t\tmsg_set_type(hdr, FRAGMENT);\n\t\telse\n\t\t\tmsg_set_type(hdr, LAST_FRAGMENT);\n\n\t\tif (!tipc_buf_append(reasm_tnlmsg, &skb)) {\n\t\t\t/* Successful but non-complete reassembly? */\n\t\t\tif (*reasm_tnlmsg || link_is_bc_rcvlink(l))\n\t\t\t\treturn 0;\n\t\t\tpr_warn_ratelimited(\"Unable to reassemble tunnel msg\\n\");\n\t\t\treturn tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\t\tiskb = skb;\n\t}\n\n\tdo {\n\t\tseqno = buf_seqno(iskb);\n\t\tif (unlikely(less(seqno, l->drop_point))) {\n\t\t\tkfree_skb(iskb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(seqno != l->drop_point)) {\n\t\t\t__tipc_skb_queue_sorted(fdefq, seqno, iskb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tl->drop_point++;\n\t\tif (!tipc_data_input(l, iskb, inputq))\n\t\t\trc |= tipc_link_input(l, iskb, inputq, reasm_skb);\n\t\tif (unlikely(rc))\n\t\t\tbreak;\n\t} while ((iskb = __tipc_skb_dequeue(fdefq, l->drop_point)));\n\n\treturn rc;\n}\n\n/**\n * tipc_get_gap_ack_blks - get Gap ACK blocks from PROTOCOL/STATE_MSG\n * @ga: returned pointer to the Gap ACK blocks if any\n * @l: the tipc link\n * @hdr: the PROTOCOL/STATE_MSG header\n * @uc: desired Gap ACK blocks type, i.e. unicast (= 1) or broadcast (= 0)\n *\n * Return: the total Gap ACK blocks size\n */\nu16 tipc_get_gap_ack_blks(struct tipc_gap_ack_blks **ga, struct tipc_link *l,\n\t\t\t  struct tipc_msg *hdr, bool uc)\n{\n\tstruct tipc_gap_ack_blks *p;\n\tu16 sz = 0;\n\n\t/* Does peer support the Gap ACK blocks feature? */\n\tif (l->peer_caps & TIPC_GAP_ACK_BLOCK) {\n\t\tp = (struct tipc_gap_ack_blks *)msg_data(hdr);\n\t\tsz = ntohs(p->len);\n\t\t/* Sanity check */\n\t\tif (sz == struct_size(p, gacks, p->ugack_cnt + p->bgack_cnt)) {\n\t\t\t/* Good, check if the desired type exists */\n\t\t\tif ((uc && p->ugack_cnt) || (!uc && p->bgack_cnt))\n\t\t\t\tgoto ok;\n\t\t/* Backward compatible: peer might not support bc, but uc? */\n\t\t} else if (uc && sz == struct_size(p, gacks, p->ugack_cnt)) {\n\t\t\tif (p->ugack_cnt) {\n\t\t\t\tp->bgack_cnt = 0;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t}\n\t}\n\t/* Other cases: ignore! */\n\tp = NULL;\n\nok:\n\t*ga = p;\n\treturn sz;\n}\n\nstatic u8 __tipc_build_gap_ack_blks(struct tipc_gap_ack_blks *ga,\n\t\t\t\t    struct tipc_link *l, u8 start_index)\n{\n\tstruct tipc_gap_ack *gacks = &ga->gacks[start_index];\n\tstruct sk_buff *skb = skb_peek(&l->deferdq);\n\tu16 expect, seqno = 0;\n\tu8 n = 0;\n\n\tif (!skb)\n\t\treturn 0;\n\n\texpect = buf_seqno(skb);\n\tskb_queue_walk(&l->deferdq, skb) {\n\t\tseqno = buf_seqno(skb);\n\t\tif (unlikely(more(seqno, expect))) {\n\t\t\tgacks[n].ack = htons(expect - 1);\n\t\t\tgacks[n].gap = htons(seqno - expect);\n\t\t\tif (++n >= MAX_GAP_ACK_BLKS / 2) {\n\t\t\t\tpr_info_ratelimited(\"Gacks on %s: %d, ql: %d!\\n\",\n\t\t\t\t\t\t    l->name, n,\n\t\t\t\t\t\t    skb_queue_len(&l->deferdq));\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} else if (unlikely(less(seqno, expect))) {\n\t\t\tpr_warn(\"Unexpected skb in deferdq!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\texpect = seqno + 1;\n\t}\n\n\t/* last block */\n\tgacks[n].ack = htons(seqno);\n\tgacks[n].gap = 0;\n\tn++;\n\treturn n;\n}\n\n/* tipc_build_gap_ack_blks - build Gap ACK blocks\n * @l: tipc unicast link\n * @hdr: the tipc message buffer to store the Gap ACK blocks after built\n *\n * The function builds Gap ACK blocks for both the unicast & broadcast receiver\n * links of a certain peer, the buffer after built has the network data format\n * as found at the struct tipc_gap_ack_blks definition.\n *\n * returns the actual allocated memory size\n */\nstatic u16 tipc_build_gap_ack_blks(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tstruct tipc_link *bcl = l->bc_rcvlink;\n\tstruct tipc_gap_ack_blks *ga;\n\tu16 len;\n\n\tga = (struct tipc_gap_ack_blks *)msg_data(hdr);\n\n\t/* Start with broadcast link first */\n\ttipc_bcast_lock(bcl->net);\n\tmsg_set_bcast_ack(hdr, bcl->rcv_nxt - 1);\n\tmsg_set_bc_gap(hdr, link_bc_rcv_gap(bcl));\n\tga->bgack_cnt = __tipc_build_gap_ack_blks(ga, bcl, 0);\n\ttipc_bcast_unlock(bcl->net);\n\n\t/* Now for unicast link, but an explicit NACK only (???) */\n\tga->ugack_cnt = (msg_seq_gap(hdr)) ?\n\t\t\t__tipc_build_gap_ack_blks(ga, l, ga->bgack_cnt) : 0;\n\n\t/* Total len */\n\tlen = struct_size(ga, gacks, ga->bgack_cnt + ga->ugack_cnt);\n\tga->len = htons(len);\n\treturn len;\n}\n\n/* tipc_link_advance_transmq - advance TIPC link transmq queue by releasing\n *\t\t\t       acked packets, also doing retransmissions if\n *\t\t\t       gaps found\n * @l: tipc link with transmq queue to be advanced\n * @r: tipc link \"receiver\" i.e. in case of broadcast (= \"l\" if unicast)\n * @acked: seqno of last packet acked by peer without any gaps before\n * @gap: # of gap packets\n * @ga: buffer pointer to Gap ACK blocks from peer\n * @xmitq: queue for accumulating the retransmitted packets if any\n * @retransmitted: returned boolean value if a retransmission is really issued\n * @rc: returned code e.g. TIPC_LINK_DOWN_EVT if a repeated retransmit failures\n *      happens (- unlikely case)\n *\n * Return: the number of packets released from the link transmq\n */\nstatic int tipc_link_advance_transmq(struct tipc_link *l, struct tipc_link *r,\n\t\t\t\t     u16 acked, u16 gap,\n\t\t\t\t     struct tipc_gap_ack_blks *ga,\n\t\t\t\t     struct sk_buff_head *xmitq,\n\t\t\t\t     bool *retransmitted, int *rc)\n{\n\tstruct tipc_gap_ack_blks *last_ga = r->last_ga, *this_ga = NULL;\n\tstruct tipc_gap_ack *gacks = NULL;\n\tstruct sk_buff *skb, *_skb, *tmp;\n\tstruct tipc_msg *hdr;\n\tu32 qlen = skb_queue_len(&l->transmq);\n\tu16 nacked = acked, ngap = gap, gack_cnt = 0;\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno, n = 0;\n\tu16 end = r->acked, start = end, offset = r->last_gap;\n\tu16 si = (last_ga) ? last_ga->start_index : 0;\n\tbool is_uc = !link_is_bc_sndlink(l);\n\tbool bc_has_acked = false;\n\n\ttrace_tipc_link_retrans(r, acked + 1, acked + gap, &l->transmq);\n\n\t/* Determine Gap ACK blocks if any for the particular link */\n\tif (ga && is_uc) {\n\t\t/* Get the Gap ACKs, uc part */\n\t\tgack_cnt = ga->ugack_cnt;\n\t\tgacks = &ga->gacks[ga->bgack_cnt];\n\t} else if (ga) {\n\t\t/* Copy the Gap ACKs, bc part, for later renewal if needed */\n\t\tthis_ga = kmemdup(ga, struct_size(ga, gacks, ga->bgack_cnt),\n\t\t\t\t  GFP_ATOMIC);\n\t\tif (likely(this_ga)) {\n\t\t\tthis_ga->start_index = 0;\n\t\t\t/* Start with the bc Gap ACKs */\n\t\t\tgack_cnt = this_ga->bgack_cnt;\n\t\t\tgacks = &this_ga->gacks[0];\n\t\t} else {\n\t\t\t/* Hmm, we can get in trouble..., simply ignore it */\n\t\t\tpr_warn_ratelimited(\"Ignoring bc Gap ACKs, no memory\\n\");\n\t\t}\n\t}\n\n\t/* Advance the link transmq */\n\tskb_queue_walk_safe(&l->transmq, skb, tmp) {\n\t\tseqno = buf_seqno(skb);\n\nnext_gap_ack:\n\t\tif (less_eq(seqno, nacked)) {\n\t\t\tif (is_uc)\n\t\t\t\tgoto release;\n\t\t\t/* Skip packets peer has already acked */\n\t\t\tif (!more(seqno, r->acked))\n\t\t\t\tcontinue;\n\t\t\t/* Get the next of last Gap ACK blocks */\n\t\t\twhile (more(seqno, end)) {\n\t\t\t\tif (!last_ga || si >= last_ga->bgack_cnt)\n\t\t\t\t\tbreak;\n\t\t\t\tstart = end + offset + 1;\n\t\t\t\tend = ntohs(last_ga->gacks[si].ack);\n\t\t\t\toffset = ntohs(last_ga->gacks[si].gap);\n\t\t\t\tsi++;\n\t\t\t\tWARN_ONCE(more(start, end) ||\n\t\t\t\t\t  (!offset &&\n\t\t\t\t\t   si < last_ga->bgack_cnt) ||\n\t\t\t\t\t  si > MAX_GAP_ACK_BLKS,\n\t\t\t\t\t  \"Corrupted Gap ACK: %d %d %d %d %d\\n\",\n\t\t\t\t\t  start, end, offset, si,\n\t\t\t\t\t  last_ga->bgack_cnt);\n\t\t\t}\n\t\t\t/* Check against the last Gap ACK block */\n\t\t\tif (in_range(seqno, start, end))\n\t\t\t\tcontinue;\n\t\t\t/* Update/release the packet peer is acking */\n\t\t\tbc_has_acked = true;\n\t\t\tif (--TIPC_SKB_CB(skb)->ackers)\n\t\t\t\tcontinue;\nrelease:\n\t\t\t/* release skb */\n\t\t\t__skb_unlink(skb, &l->transmq);\n\t\t\tkfree_skb(skb);\n\t\t} else if (less_eq(seqno, nacked + ngap)) {\n\t\t\t/* First gap: check if repeated retrans failures? */\n\t\t\tif (unlikely(seqno == acked + 1 &&\n\t\t\t\t     link_retransmit_failure(l, r, rc))) {\n\t\t\t\t/* Ignore this bc Gap ACKs if any */\n\t\t\t\tkfree(this_ga);\n\t\t\t\tthis_ga = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* retransmit skb if unrestricted*/\n\t\t\tif (time_before(jiffies, TIPC_SKB_CB(skb)->nxt_retr))\n\t\t\t\tcontinue;\n\t\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\t\t\t_skb = pskb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!_skb)\n\t\t\t\tcontinue;\n\t\t\thdr = buf_msg(_skb);\n\t\t\tmsg_set_ack(hdr, ack);\n\t\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\t\t_skb->priority = TC_PRIO_CONTROL;\n\t\t\t__skb_queue_tail(xmitq, _skb);\n\t\t\tl->stats.retransmitted++;\n\t\t\tif (!is_uc)\n\t\t\t\tr->stats.retransmitted++;\n\t\t\t*retransmitted = true;\n\t\t\t/* Increase actual retrans counter & mark first time */\n\t\t\tif (!TIPC_SKB_CB(skb)->retr_cnt++)\n\t\t\t\tTIPC_SKB_CB(skb)->retr_stamp = jiffies;\n\t\t} else {\n\t\t\t/* retry with Gap ACK blocks if any */\n\t\t\tif (n >= gack_cnt)\n\t\t\t\tbreak;\n\t\t\tnacked = ntohs(gacks[n].ack);\n\t\t\tngap = ntohs(gacks[n].gap);\n\t\t\tn++;\n\t\t\tgoto next_gap_ack;\n\t\t}\n\t}\n\n\t/* Renew last Gap ACK blocks for bc if needed */\n\tif (bc_has_acked) {\n\t\tif (this_ga) {\n\t\t\tkfree(last_ga);\n\t\t\tr->last_ga = this_ga;\n\t\t\tr->last_gap = gap;\n\t\t} else if (last_ga) {\n\t\t\tif (less(acked, start)) {\n\t\t\t\tsi--;\n\t\t\t\toffset = start - acked - 1;\n\t\t\t} else if (less(acked, end)) {\n\t\t\t\tacked = end;\n\t\t\t}\n\t\t\tif (si < last_ga->bgack_cnt) {\n\t\t\t\tlast_ga->start_index = si;\n\t\t\t\tr->last_gap = offset;\n\t\t\t} else {\n\t\t\t\tkfree(last_ga);\n\t\t\t\tr->last_ga = NULL;\n\t\t\t\tr->last_gap = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tr->last_gap = 0;\n\t\t}\n\t\tr->acked = acked;\n\t} else {\n\t\tkfree(this_ga);\n\t}\n\n\treturn qlen - skb_queue_len(&l->transmq);\n}\n\n/* tipc_link_build_state_msg: prepare link state message for transmission\n *\n * Note that sending of broadcast ack is coordinated among nodes, to reduce\n * risk of ack storms towards the sender\n */\nint tipc_link_build_state_msg(struct tipc_link *l, struct sk_buff_head *xmitq)\n{\n\tif (!l)\n\t\treturn 0;\n\n\t/* Broadcast ACK must be sent via a unicast link => defer to caller */\n\tif (link_is_bc_rcvlink(l)) {\n\t\tif (((l->rcv_nxt ^ tipc_own_addr(l->net)) & 0xf) != 0xf)\n\t\t\treturn 0;\n\t\tl->rcv_unacked = 0;\n\n\t\t/* Use snd_nxt to store peer's snd_nxt in broadcast rcv link */\n\t\tl->snd_nxt = l->rcv_nxt;\n\t\treturn TIPC_LINK_SND_STATE;\n\t}\n\t/* Unicast ACK */\n\tl->rcv_unacked = 0;\n\tl->stats.sent_acks++;\n\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, 0, 0, xmitq);\n\treturn 0;\n}\n\n/* tipc_link_build_reset_msg: prepare link RESET or ACTIVATE message\n */\nvoid tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq)\n{\n\tint mtyp = RESET_MSG;\n\tstruct sk_buff *skb;\n\n\tif (l->state == LINK_ESTABLISHING)\n\t\tmtyp = ACTIVATE_MSG;\n\n\ttipc_link_build_proto_msg(l, mtyp, 0, 0, 0, 0, 0, xmitq);\n\n\t/* Inform peer that this endpoint is going down if applicable */\n\tskb = skb_peek_tail(xmitq);\n\tif (skb && (l->state == LINK_RESET))\n\t\tmsg_set_peer_stopping(buf_msg(skb), 1);\n}\n\n/* tipc_link_build_nack_msg: prepare link nack message for transmission\n * Note that sending of broadcast NACK is coordinated among nodes, to\n * reduce the risk of NACK storms towards the sender\n */\nstatic int tipc_link_build_nack_msg(struct tipc_link *l,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tu32 def_cnt = ++l->stats.deferred_recv;\n\tstruct sk_buff_head *dfq = &l->deferdq;\n\tu32 defq_len = skb_queue_len(dfq);\n\tint match1, match2;\n\n\tif (link_is_bc_rcvlink(l)) {\n\t\tmatch1 = def_cnt & 0xf;\n\t\tmatch2 = tipc_own_addr(l->net) & 0xf;\n\t\tif (match1 == match2)\n\t\t\treturn TIPC_LINK_SND_STATE;\n\t\treturn 0;\n\t}\n\n\tif (defq_len >= 3 && !((defq_len - 3) % 16)) {\n\t\tu16 rcvgap = buf_seqno(skb_peek(dfq)) - l->rcv_nxt;\n\n\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0,\n\t\t\t\t\t  rcvgap, 0, 0, xmitq);\n\t}\n\treturn 0;\n}\n\n/* tipc_link_rcv - process TIPC packets/messages arriving from off-node\n * @l: the link that should handle the message\n * @skb: TIPC packet\n * @xmitq: queue to place packets to be sent after this call\n */\nint tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t  struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *defq = &l->deferdq;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tu16 seqno, rcv_nxt, win_lim;\n\tint released = 0;\n\tint rc = 0;\n\n\t/* Verify and update link state */\n\tif (unlikely(msg_user(hdr) == LINK_PROTOCOL))\n\t\treturn tipc_link_proto_rcv(l, skb, xmitq);\n\n\t/* Don't send probe at next timeout expiration */\n\tl->silent_intv_cnt = 0;\n\n\tdo {\n\t\thdr = buf_msg(skb);\n\t\tseqno = msg_seqno(hdr);\n\t\trcv_nxt = l->rcv_nxt;\n\t\twin_lim = rcv_nxt + TIPC_MAX_LINK_WIN;\n\n\t\tif (unlikely(!link_is_up(l))) {\n\t\t\tif (l->state == LINK_ESTABLISHING)\n\t\t\t\trc = TIPC_LINK_UP_EVT;\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop if outside receive window */\n\t\tif (unlikely(less(seqno, rcv_nxt) || more(seqno, win_lim))) {\n\t\t\tl->stats.duplicates++;\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t\treleased += tipc_link_advance_transmq(l, l, msg_ack(hdr), 0,\n\t\t\t\t\t\t      NULL, NULL, NULL, NULL);\n\n\t\t/* Defer delivery if sequence gap */\n\t\tif (unlikely(seqno != rcv_nxt)) {\n\t\t\tif (!__tipc_skb_queue_sorted(defq, seqno, skb))\n\t\t\t\tl->stats.duplicates++;\n\t\t\trc |= tipc_link_build_nack_msg(l, xmitq);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Deliver packet */\n\t\tl->rcv_nxt++;\n\t\tl->stats.recv_pkts++;\n\n\t\tif (unlikely(msg_user(hdr) == TUNNEL_PROTOCOL))\n\t\t\trc |= tipc_link_tnl_rcv(l, skb, l->inputq);\n\t\telse if (!tipc_data_input(l, skb, l->inputq))\n\t\t\trc |= tipc_link_input(l, skb, l->inputq, &l->reasm_buf);\n\t\tif (unlikely(++l->rcv_unacked >= TIPC_MIN_LINK_WIN))\n\t\t\trc |= tipc_link_build_state_msg(l, xmitq);\n\t\tif (unlikely(rc & ~TIPC_LINK_SND_STATE))\n\t\t\tbreak;\n\t} while ((skb = __tipc_skb_dequeue(defq, l->rcv_nxt)));\n\n\t/* Forward queues and wake up waiting users */\n\tif (released) {\n\t\ttipc_link_update_cwin(l, released, 0);\n\t\ttipc_link_advance_backlog(l, xmitq);\n\t\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\t\tlink_prepare_wakeup(l);\n\t}\n\treturn rc;\n}\n\nstatic void tipc_link_build_proto_msg(struct tipc_link *l, int mtyp, bool probe,\n\t\t\t\t      bool probe_reply, u16 rcvgap,\n\t\t\t\t      int tolerance, int priority,\n\t\t\t\t      struct sk_buff_head *xmitq)\n{\n\tstruct tipc_mon_state *mstate = &l->mon_state;\n\tstruct sk_buff_head *dfq = &l->deferdq;\n\tstruct tipc_link *bcl = l->bc_rcvlink;\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *skb;\n\tbool node_up = link_is_up(bcl);\n\tu16 glen = 0, bc_rcvgap = 0;\n\tint dlen = 0;\n\tvoid *data;\n\n\t/* Don't send protocol message during reset or link failover */\n\tif (tipc_link_is_blocked(l))\n\t\treturn;\n\n\tif (!tipc_link_is_up(l) && (mtyp == STATE_MSG))\n\t\treturn;\n\n\tif ((probe || probe_reply) && !skb_queue_empty(dfq))\n\t\trcvgap = buf_seqno(skb_peek(dfq)) - l->rcv_nxt;\n\n\tskb = tipc_msg_create(LINK_PROTOCOL, mtyp, INT_H_SIZE,\n\t\t\t      tipc_max_domain_size + MAX_GAP_ACK_BLKS_SZ,\n\t\t\t      l->addr, tipc_own_addr(l->net), 0, 0, 0);\n\tif (!skb)\n\t\treturn;\n\n\thdr = buf_msg(skb);\n\tdata = msg_data(hdr);\n\tmsg_set_session(hdr, l->session);\n\tmsg_set_bearer_id(hdr, l->bearer_id);\n\tmsg_set_net_plane(hdr, l->net_plane);\n\tmsg_set_next_sent(hdr, l->snd_nxt);\n\tmsg_set_ack(hdr, l->rcv_nxt - 1);\n\tmsg_set_bcast_ack(hdr, bcl->rcv_nxt - 1);\n\tmsg_set_bc_ack_invalid(hdr, !node_up);\n\tmsg_set_last_bcast(hdr, l->bc_sndlink->snd_nxt - 1);\n\tmsg_set_link_tolerance(hdr, tolerance);\n\tmsg_set_linkprio(hdr, priority);\n\tmsg_set_redundant_link(hdr, node_up);\n\tmsg_set_seq_gap(hdr, 0);\n\tmsg_set_seqno(hdr, l->snd_nxt + U16_MAX / 2);\n\n\tif (mtyp == STATE_MSG) {\n\t\tif (l->peer_caps & TIPC_LINK_PROTO_SEQNO)\n\t\t\tmsg_set_seqno(hdr, l->snd_nxt_state++);\n\t\tmsg_set_seq_gap(hdr, rcvgap);\n\t\tbc_rcvgap = link_bc_rcv_gap(bcl);\n\t\tmsg_set_bc_gap(hdr, bc_rcvgap);\n\t\tmsg_set_probe(hdr, probe);\n\t\tmsg_set_is_keepalive(hdr, probe || probe_reply);\n\t\tif (l->peer_caps & TIPC_GAP_ACK_BLOCK)\n\t\t\tglen = tipc_build_gap_ack_blks(l, hdr);\n\t\ttipc_mon_prep(l->net, data + glen, &dlen, mstate, l->bearer_id);\n\t\tmsg_set_size(hdr, INT_H_SIZE + glen + dlen);\n\t\tskb_trim(skb, INT_H_SIZE + glen + dlen);\n\t\tl->stats.sent_states++;\n\t\tl->rcv_unacked = 0;\n\t} else {\n\t\t/* RESET_MSG or ACTIVATE_MSG */\n\t\tif (mtyp == ACTIVATE_MSG) {\n\t\t\tmsg_set_dest_session_valid(hdr, 1);\n\t\t\tmsg_set_dest_session(hdr, l->peer_session);\n\t\t}\n\t\tmsg_set_max_pkt(hdr, l->advertised_mtu);\n\t\tstrcpy(data, l->if_name);\n\t\tmsg_set_size(hdr, INT_H_SIZE + TIPC_MAX_IF_NAME);\n\t\tskb_trim(skb, INT_H_SIZE + TIPC_MAX_IF_NAME);\n\t}\n\tif (probe)\n\t\tl->stats.sent_probes++;\n\tif (rcvgap)\n\t\tl->stats.sent_nacks++;\n\tif (bc_rcvgap)\n\t\tbcl->stats.sent_nacks++;\n\tskb->priority = TC_PRIO_CONTROL;\n\t__skb_queue_tail(xmitq, skb);\n\ttrace_tipc_proto_build(skb, false, l->name);\n}\n\nvoid tipc_link_create_dummy_tnl_msg(struct tipc_link *l,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tu32 onode = tipc_own_addr(l->net);\n\tstruct tipc_msg *hdr, *ihdr;\n\tstruct sk_buff_head tnlq;\n\tstruct sk_buff *skb;\n\tu32 dnode = l->addr;\n\n\t__skb_queue_head_init(&tnlq);\n\tskb = tipc_msg_create(TUNNEL_PROTOCOL, FAILOVER_MSG,\n\t\t\t      INT_H_SIZE, BASIC_H_SIZE,\n\t\t\t      dnode, onode, 0, 0, 0);\n\tif (!skb) {\n\t\tpr_warn(\"%sunable to create tunnel packet\\n\", link_co_err);\n\t\treturn;\n\t}\n\n\thdr = buf_msg(skb);\n\tmsg_set_msgcnt(hdr, 1);\n\tmsg_set_bearer_id(hdr, l->peer_bearer_id);\n\n\tihdr = (struct tipc_msg *)msg_data(hdr);\n\ttipc_msg_init(onode, ihdr, TIPC_LOW_IMPORTANCE, TIPC_DIRECT_MSG,\n\t\t      BASIC_H_SIZE, dnode);\n\tmsg_set_errcode(ihdr, TIPC_ERR_NO_PORT);\n\t__skb_queue_tail(&tnlq, skb);\n\ttipc_link_xmit(l, &tnlq, xmitq);\n}\n\n/* tipc_link_tnl_prepare(): prepare and return a list of tunnel packets\n * with contents of the link's transmit and backlog queues.\n */\nvoid tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,\n\t\t\t   int mtyp, struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *fdefq = &tnl->failover_deferdq;\n\tstruct sk_buff *skb, *tnlskb;\n\tstruct tipc_msg *hdr, tnlhdr;\n\tstruct sk_buff_head *queue = &l->transmq;\n\tstruct sk_buff_head tmpxq, tnlq, frags;\n\tu16 pktlen, pktcnt, seqno = l->snd_nxt;\n\tbool pktcnt_need_update = false;\n\tu16 syncpt;\n\tint rc;\n\n\tif (!tnl)\n\t\treturn;\n\n\t__skb_queue_head_init(&tnlq);\n\t/* Link Synching:\n\t * From now on, send only one single (\"dummy\") SYNCH message\n\t * to peer. The SYNCH message does not contain any data, just\n\t * a header conveying the synch point to the peer.\n\t */\n\tif (mtyp == SYNCH_MSG && (tnl->peer_caps & TIPC_TUNNEL_ENHANCED)) {\n\t\ttnlskb = tipc_msg_create(TUNNEL_PROTOCOL, SYNCH_MSG,\n\t\t\t\t\t INT_H_SIZE, 0, l->addr,\n\t\t\t\t\t tipc_own_addr(l->net),\n\t\t\t\t\t 0, 0, 0);\n\t\tif (!tnlskb) {\n\t\t\tpr_warn(\"%sunable to create dummy SYNCH_MSG\\n\",\n\t\t\t\tlink_co_err);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = buf_msg(tnlskb);\n\t\tsyncpt = l->snd_nxt + skb_queue_len(&l->backlogq) - 1;\n\t\tmsg_set_syncpt(hdr, syncpt);\n\t\tmsg_set_bearer_id(hdr, l->peer_bearer_id);\n\t\t__skb_queue_tail(&tnlq, tnlskb);\n\t\ttipc_link_xmit(tnl, &tnlq, xmitq);\n\t\treturn;\n\t}\n\n\t__skb_queue_head_init(&tmpxq);\n\t__skb_queue_head_init(&frags);\n\t/* At least one packet required for safe algorithm => add dummy */\n\tskb = tipc_msg_create(TIPC_LOW_IMPORTANCE, TIPC_DIRECT_MSG,\n\t\t\t      BASIC_H_SIZE, 0, l->addr, tipc_own_addr(l->net),\n\t\t\t      0, 0, TIPC_ERR_NO_PORT);\n\tif (!skb) {\n\t\tpr_warn(\"%sunable to create tunnel packet\\n\", link_co_err);\n\t\treturn;\n\t}\n\t__skb_queue_tail(&tnlq, skb);\n\ttipc_link_xmit(l, &tnlq, &tmpxq);\n\t__skb_queue_purge(&tmpxq);\n\n\t/* Initialize reusable tunnel packet header */\n\ttipc_msg_init(tipc_own_addr(l->net), &tnlhdr, TUNNEL_PROTOCOL,\n\t\t      mtyp, INT_H_SIZE, l->addr);\n\tif (mtyp == SYNCH_MSG)\n\t\tpktcnt = l->snd_nxt - buf_seqno(skb_peek(&l->transmq));\n\telse\n\t\tpktcnt = skb_queue_len(&l->transmq);\n\tpktcnt += skb_queue_len(&l->backlogq);\n\tmsg_set_msgcnt(&tnlhdr, pktcnt);\n\tmsg_set_bearer_id(&tnlhdr, l->peer_bearer_id);\ntnl:\n\t/* Wrap each packet into a tunnel packet */\n\tskb_queue_walk(queue, skb) {\n\t\thdr = buf_msg(skb);\n\t\tif (queue == &l->backlogq)\n\t\t\tmsg_set_seqno(hdr, seqno++);\n\t\tpktlen = msg_size(hdr);\n\n\t\t/* Tunnel link MTU is not large enough? This could be\n\t\t * due to:\n\t\t * 1) Link MTU has just changed or set differently;\n\t\t * 2) Or FAILOVER on the top of a SYNCH message\n\t\t *\n\t\t * The 2nd case should not happen if peer supports\n\t\t * TIPC_TUNNEL_ENHANCED\n\t\t */\n\t\tif (pktlen > tnl->mtu - INT_H_SIZE) {\n\t\t\tif (mtyp == FAILOVER_MSG &&\n\t\t\t    (tnl->peer_caps & TIPC_TUNNEL_ENHANCED)) {\n\t\t\t\trc = tipc_msg_fragment(skb, &tnlhdr, tnl->mtu,\n\t\t\t\t\t\t       &frags);\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_warn(\"%sunable to frag msg: rc %d\\n\",\n\t\t\t\t\t\tlink_co_err, rc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpktcnt += skb_queue_len(&frags) - 1;\n\t\t\t\tpktcnt_need_update = true;\n\t\t\t\tskb_queue_splice_tail_init(&frags, &tnlq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Unluckily, peer doesn't have TIPC_TUNNEL_ENHANCED\n\t\t\t * => Just warn it and return!\n\t\t\t */\n\t\t\tpr_warn_ratelimited(\"%stoo large msg <%d, %d>: %d!\\n\",\n\t\t\t\t\t    link_co_err, msg_user(hdr),\n\t\t\t\t\t    msg_type(hdr), msg_size(hdr));\n\t\t\treturn;\n\t\t}\n\n\t\tmsg_set_size(&tnlhdr, pktlen + INT_H_SIZE);\n\t\ttnlskb = tipc_buf_acquire(pktlen + INT_H_SIZE, GFP_ATOMIC);\n\t\tif (!tnlskb) {\n\t\t\tpr_warn(\"%sunable to send packet\\n\", link_co_err);\n\t\t\treturn;\n\t\t}\n\t\tskb_copy_to_linear_data(tnlskb, &tnlhdr, INT_H_SIZE);\n\t\tskb_copy_to_linear_data_offset(tnlskb, INT_H_SIZE, hdr, pktlen);\n\t\t__skb_queue_tail(&tnlq, tnlskb);\n\t}\n\tif (queue != &l->backlogq) {\n\t\tqueue = &l->backlogq;\n\t\tgoto tnl;\n\t}\n\n\tif (pktcnt_need_update)\n\t\tskb_queue_walk(&tnlq, skb) {\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_msgcnt(hdr, pktcnt);\n\t\t}\n\n\ttipc_link_xmit(tnl, &tnlq, xmitq);\n\n\tif (mtyp == FAILOVER_MSG) {\n\t\ttnl->drop_point = l->rcv_nxt;\n\t\ttnl->failover_reasm_skb = l->reasm_buf;\n\t\tl->reasm_buf = NULL;\n\n\t\t/* Failover the link's deferdq */\n\t\tif (unlikely(!skb_queue_empty(fdefq))) {\n\t\t\tpr_warn(\"Link failover deferdq not empty: %d!\\n\",\n\t\t\t\tskb_queue_len(fdefq));\n\t\t\t__skb_queue_purge(fdefq);\n\t\t}\n\t\tskb_queue_splice_init(&l->deferdq, fdefq);\n\t}\n}\n\n/**\n * tipc_link_failover_prepare() - prepare tnl for link failover\n *\n * This is a special version of the precursor - tipc_link_tnl_prepare(),\n * see the tipc_node_link_failover() for details\n *\n * @l: failover link\n * @tnl: tunnel link\n * @xmitq: queue for messages to be xmited\n */\nvoid tipc_link_failover_prepare(struct tipc_link *l, struct tipc_link *tnl,\n\t\t\t\tstruct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *fdefq = &tnl->failover_deferdq;\n\n\ttipc_link_create_dummy_tnl_msg(tnl, xmitq);\n\n\t/* This failover link endpoint was never established before,\n\t * so it has not received anything from peer.\n\t * Otherwise, it must be a normal failover situation or the\n\t * node has entered SELF_DOWN_PEER_LEAVING and both peer nodes\n\t * would have to start over from scratch instead.\n\t */\n\ttnl->drop_point = 1;\n\ttnl->failover_reasm_skb = NULL;\n\n\t/* Initiate the link's failover deferdq */\n\tif (unlikely(!skb_queue_empty(fdefq))) {\n\t\tpr_warn(\"Link failover deferdq not empty: %d!\\n\",\n\t\t\tskb_queue_len(fdefq));\n\t\t__skb_queue_purge(fdefq);\n\t}\n}\n\n/* tipc_link_validate_msg(): validate message against current link state\n * Returns true if message should be accepted, otherwise false\n */\nbool tipc_link_validate_msg(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tu16 curr_session = l->peer_session;\n\tu16 session = msg_session(hdr);\n\tint mtyp = msg_type(hdr);\n\n\tif (msg_user(hdr) != LINK_PROTOCOL)\n\t\treturn true;\n\n\tswitch (mtyp) {\n\tcase RESET_MSG:\n\t\tif (!l->in_session)\n\t\t\treturn true;\n\t\t/* Accept only RESET with new session number */\n\t\treturn more(session, curr_session);\n\tcase ACTIVATE_MSG:\n\t\tif (!l->in_session)\n\t\t\treturn true;\n\t\t/* Accept only ACTIVATE with new or current session number */\n\t\treturn !less(session, curr_session);\n\tcase STATE_MSG:\n\t\t/* Accept only STATE with current session number */\n\t\tif (!l->in_session)\n\t\t\treturn false;\n\t\tif (session != curr_session)\n\t\t\treturn false;\n\t\t/* Extra sanity check */\n\t\tif (!link_is_up(l) && msg_ack(hdr))\n\t\t\treturn false;\n\t\tif (!(l->peer_caps & TIPC_LINK_PROTO_SEQNO))\n\t\t\treturn true;\n\t\t/* Accept only STATE with new sequence number */\n\t\treturn !less(msg_seqno(hdr), l->rcv_nxt_state);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* tipc_link_proto_rcv(): receive link level protocol message :\n * Note that network plane id propagates through the network, and may\n * change at any time. The node with lowest numerical id determines\n * network plane\n */\nstatic int tipc_link_proto_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t       struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct tipc_gap_ack_blks *ga = NULL;\n\tbool reply = msg_probe(hdr), retransmitted = false;\n\tu16 dlen = msg_data_sz(hdr), glen = 0;\n\tu16 peers_snd_nxt =  msg_next_sent(hdr);\n\tu16 peers_tol = msg_link_tolerance(hdr);\n\tu16 peers_prio = msg_linkprio(hdr);\n\tu16 gap = msg_seq_gap(hdr);\n\tu16 ack = msg_ack(hdr);\n\tu16 rcv_nxt = l->rcv_nxt;\n\tu16 rcvgap = 0;\n\tint mtyp = msg_type(hdr);\n\tint rc = 0, released;\n\tchar *if_name;\n\tvoid *data;\n\n\ttrace_tipc_proto_rcv(skb, false, l->name);\n\tif (tipc_link_is_blocked(l) || !xmitq)\n\t\tgoto exit;\n\n\tif (tipc_own_addr(l->net) > msg_prevnode(hdr))\n\t\tl->net_plane = msg_net_plane(hdr);\n\n\tskb_linearize(skb);\n\thdr = buf_msg(skb);\n\tdata = msg_data(hdr);\n\n\tif (!tipc_link_validate_msg(l, hdr)) {\n\t\ttrace_tipc_skb_dump(skb, false, \"PROTO invalid (1)!\");\n\t\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"PROTO invalid (1)!\");\n\t\tgoto exit;\n\t}\n\n\tswitch (mtyp) {\n\tcase RESET_MSG:\n\tcase ACTIVATE_MSG:\n\t\t/* Complete own link name with peer's interface name */\n\t\tif_name =  strrchr(l->name, ':') + 1;\n\t\tif (sizeof(l->name) - (if_name - l->name) <= TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tif (msg_data_sz(hdr) < TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tstrncpy(if_name, data, TIPC_MAX_IF_NAME);\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own priority if peer's priority is higher */\n\t\tif (in_range(peers_prio, l->priority + 1, TIPC_MAX_LINK_PRI))\n\t\t\tl->priority = peers_prio;\n\n\t\t/* If peer is going down we want full re-establish cycle */\n\t\tif (msg_peer_stopping(hdr)) {\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this endpoint was re-created while peer was ESTABLISHING\n\t\t * it doesn't know current session number. Force re-synch.\n\t\t */\n\t\tif (mtyp == ACTIVATE_MSG && msg_dest_session_valid(hdr) &&\n\t\t    l->session != msg_dest_session(hdr)) {\n\t\t\tif (less(l->session, msg_dest_session(hdr)))\n\t\t\t\tl->session = msg_dest_session(hdr) + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ACTIVATE_MSG serves as PEER_RESET if link is already down */\n\t\tif (mtyp == RESET_MSG || !link_is_up(l))\n\t\t\trc = tipc_link_fsm_evt(l, LINK_PEER_RESET_EVT);\n\n\t\t/* ACTIVATE_MSG takes up link if it was already locally reset */\n\t\tif (mtyp == ACTIVATE_MSG && l->state == LINK_ESTABLISHING)\n\t\t\trc = TIPC_LINK_UP_EVT;\n\n\t\tl->peer_session = msg_session(hdr);\n\t\tl->in_session = true;\n\t\tl->peer_bearer_id = msg_bearer_id(hdr);\n\t\tif (l->mtu > msg_max_pkt(hdr))\n\t\t\tl->mtu = msg_max_pkt(hdr);\n\t\tbreak;\n\n\tcase STATE_MSG:\n\t\tl->rcv_nxt_state = msg_seqno(hdr) + 1;\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own prio if peer indicates a different value */\n\t\tif ((peers_prio != l->priority) &&\n\t\t    in_range(peers_prio, 1, TIPC_MAX_LINK_PRI)) {\n\t\t\tl->priority = peers_prio;\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\n\t\tl->silent_intv_cnt = 0;\n\t\tl->stats.recv_states++;\n\t\tif (msg_probe(hdr))\n\t\t\tl->stats.recv_probes++;\n\n\t\tif (!link_is_up(l)) {\n\t\t\tif (l->state == LINK_ESTABLISHING)\n\t\t\t\trc = TIPC_LINK_UP_EVT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Receive Gap ACK blocks from peer if any */\n\t\tglen = tipc_get_gap_ack_blks(&ga, l, hdr, true);\n\n\t\ttipc_mon_rcv(l->net, data + glen, dlen - glen, l->addr,\n\t\t\t     &l->mon_state, l->bearer_id);\n\n\t\t/* Send NACK if peer has sent pkts we haven't received yet */\n\t\tif ((reply || msg_is_keepalive(hdr)) &&\n\t\t    more(peers_snd_nxt, rcv_nxt) &&\n\t\t    !tipc_link_is_synching(l) &&\n\t\t    skb_queue_empty(&l->deferdq))\n\t\t\trcvgap = peers_snd_nxt - l->rcv_nxt;\n\t\tif (rcvgap || reply)\n\t\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, reply,\n\t\t\t\t\t\t  rcvgap, 0, 0, xmitq);\n\n\t\treleased = tipc_link_advance_transmq(l, l, ack, gap, ga, xmitq,\n\t\t\t\t\t\t     &retransmitted, &rc);\n\t\tif (gap)\n\t\t\tl->stats.recv_nacks++;\n\t\tif (released || retransmitted)\n\t\t\ttipc_link_update_cwin(l, released, retransmitted);\n\t\tif (released)\n\t\t\ttipc_link_advance_backlog(l, xmitq);\n\t\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\t\tlink_prepare_wakeup(l);\n\t}\nexit:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\n/* tipc_link_build_bc_proto_msg() - create broadcast protocol message\n */\nstatic bool tipc_link_build_bc_proto_msg(struct tipc_link *l, bool bcast,\n\t\t\t\t\t u16 peers_snd_nxt,\n\t\t\t\t\t struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff *skb;\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *dfrd_skb = skb_peek(&l->deferdq);\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 gap_to = peers_snd_nxt - 1;\n\n\tskb = tipc_msg_create(BCAST_PROTOCOL, STATE_MSG, INT_H_SIZE,\n\t\t\t      0, l->addr, tipc_own_addr(l->net), 0, 0, 0);\n\tif (!skb)\n\t\treturn false;\n\thdr = buf_msg(skb);\n\tmsg_set_last_bcast(hdr, l->bc_sndlink->snd_nxt - 1);\n\tmsg_set_bcast_ack(hdr, ack);\n\tmsg_set_bcgap_after(hdr, ack);\n\tif (dfrd_skb)\n\t\tgap_to = buf_seqno(dfrd_skb) - 1;\n\tmsg_set_bcgap_to(hdr, gap_to);\n\tmsg_set_non_seq(hdr, bcast);\n\t__skb_queue_tail(xmitq, skb);\n\treturn true;\n}\n\n/* tipc_link_build_bc_init_msg() - synchronize broadcast link endpoints.\n *\n * Give a newly added peer node the sequence number where it should\n * start receiving and acking broadcast packets.\n */\nstatic void tipc_link_build_bc_init_msg(struct tipc_link *l,\n\t\t\t\t\tstruct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head list;\n\n\t__skb_queue_head_init(&list);\n\tif (!tipc_link_build_bc_proto_msg(l->bc_rcvlink, false, 0, &list))\n\t\treturn;\n\tmsg_set_bc_ack_invalid(buf_msg(skb_peek(&list)), true);\n\ttipc_link_xmit(l, &list, xmitq);\n}\n\n/* tipc_link_bc_init_rcv - receive initial broadcast synch data from peer\n */\nvoid tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tint mtyp = msg_type(hdr);\n\tu16 peers_snd_nxt = msg_bc_snd_nxt(hdr);\n\n\tif (link_is_up(l))\n\t\treturn;\n\n\tif (msg_user(hdr) == BCAST_PROTOCOL) {\n\t\tl->rcv_nxt = peers_snd_nxt;\n\t\tl->state = LINK_ESTABLISHED;\n\t\treturn;\n\t}\n\n\tif (l->peer_caps & TIPC_BCAST_SYNCH)\n\t\treturn;\n\n\tif (msg_peer_node_is_up(hdr))\n\t\treturn;\n\n\t/* Compatibility: accept older, less safe initial synch data */\n\tif ((mtyp == RESET_MSG) || (mtyp == ACTIVATE_MSG))\n\t\tl->rcv_nxt = peers_snd_nxt;\n}\n\n/* tipc_link_bc_sync_rcv - update rcv link according to peer's send state\n */\nint tipc_link_bc_sync_rcv(struct tipc_link *l, struct tipc_msg *hdr,\n\t\t\t  struct sk_buff_head *xmitq)\n{\n\tu16 peers_snd_nxt = msg_bc_snd_nxt(hdr);\n\tint rc = 0;\n\n\tif (!link_is_up(l))\n\t\treturn rc;\n\n\tif (!msg_peer_node_is_up(hdr))\n\t\treturn rc;\n\n\t/* Open when peer acknowledges our bcast init msg (pkt #1) */\n\tif (msg_ack(hdr))\n\t\tl->bc_peer_is_up = true;\n\n\tif (!l->bc_peer_is_up)\n\t\treturn rc;\n\n\t/* Ignore if peers_snd_nxt goes beyond receive window */\n\tif (more(peers_snd_nxt, l->rcv_nxt + l->window))\n\t\treturn rc;\n\n\tl->snd_nxt = peers_snd_nxt;\n\tif (link_bc_rcv_gap(l))\n\t\trc |= TIPC_LINK_SND_STATE;\n\n\t/* Return now if sender supports nack via STATE messages */\n\tif (l->peer_caps & TIPC_BCAST_STATE_NACK)\n\t\treturn rc;\n\n\t/* Otherwise, be backwards compatible */\n\n\tif (!more(peers_snd_nxt, l->rcv_nxt)) {\n\t\tl->nack_state = BC_NACK_SND_CONDITIONAL;\n\t\treturn 0;\n\t}\n\n\t/* Don't NACK if one was recently sent or peeked */\n\tif (l->nack_state == BC_NACK_SND_SUPPRESS) {\n\t\tl->nack_state = BC_NACK_SND_UNCONDITIONAL;\n\t\treturn 0;\n\t}\n\n\t/* Conditionally delay NACK sending until next synch rcv */\n\tif (l->nack_state == BC_NACK_SND_CONDITIONAL) {\n\t\tl->nack_state = BC_NACK_SND_UNCONDITIONAL;\n\t\tif ((peers_snd_nxt - l->rcv_nxt) < TIPC_MIN_LINK_WIN)\n\t\t\treturn 0;\n\t}\n\n\t/* Send NACK now but suppress next one */\n\ttipc_link_build_bc_proto_msg(l, true, peers_snd_nxt, xmitq);\n\tl->nack_state = BC_NACK_SND_SUPPRESS;\n\treturn 0;\n}\n\nint tipc_link_bc_ack_rcv(struct tipc_link *r, u16 acked, u16 gap,\n\t\t\t struct tipc_gap_ack_blks *ga,\n\t\t\t struct sk_buff_head *xmitq,\n\t\t\t struct sk_buff_head *retrq)\n{\n\tstruct tipc_link *l = r->bc_sndlink;\n\tbool unused = false;\n\tint rc = 0;\n\n\tif (!link_is_up(r) || !r->bc_peer_is_up)\n\t\treturn 0;\n\n\tif (gap) {\n\t\tl->stats.recv_nacks++;\n\t\tr->stats.recv_nacks++;\n\t}\n\n\tif (less(acked, r->acked) || (acked == r->acked && !gap && !ga))\n\t\treturn 0;\n\n\ttrace_tipc_link_bc_ack(r, acked, gap, &l->transmq);\n\ttipc_link_advance_transmq(l, r, acked, gap, ga, retrq, &unused, &rc);\n\n\ttipc_link_advance_backlog(l, xmitq);\n\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\tlink_prepare_wakeup(l);\n\n\treturn rc;\n}\n\n/* tipc_link_bc_nack_rcv(): receive broadcast nack message\n * This function is here for backwards compatibility, since\n * no BCAST_PROTOCOL/STATE messages occur from TIPC v2.5.\n */\nint tipc_link_bc_nack_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t  struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tu32 dnode = msg_destnode(hdr);\n\tint mtyp = msg_type(hdr);\n\tu16 acked = msg_bcast_ack(hdr);\n\tu16 from = acked + 1;\n\tu16 to = msg_bcgap_to(hdr);\n\tu16 peers_snd_nxt = to + 1;\n\tint rc = 0;\n\n\tkfree_skb(skb);\n\n\tif (!tipc_link_is_up(l) || !l->bc_peer_is_up)\n\t\treturn 0;\n\n\tif (mtyp != STATE_MSG)\n\t\treturn 0;\n\n\tif (dnode == tipc_own_addr(l->net)) {\n\t\trc = tipc_link_bc_ack_rcv(l, acked, to - acked, NULL, xmitq,\n\t\t\t\t\t  xmitq);\n\t\tl->stats.recv_nacks++;\n\t\treturn rc;\n\t}\n\n\t/* Msg for other node => suppress own NACK at next sync if applicable */\n\tif (more(peers_snd_nxt, l->rcv_nxt) && !less(l->rcv_nxt, from))\n\t\tl->nack_state = BC_NACK_SND_SUPPRESS;\n\n\treturn 0;\n}\n\nvoid tipc_link_set_queue_limits(struct tipc_link *l, u32 min_win, u32 max_win)\n{\n\tint max_bulk = TIPC_MAX_PUBL / (l->mtu / ITEM_SIZE);\n\n\tl->min_win = min_win;\n\tl->ssthresh = max_win;\n\tl->max_win = max_win;\n\tl->window = min_win;\n\tl->backlog[TIPC_LOW_IMPORTANCE].limit      = min_win * 2;\n\tl->backlog[TIPC_MEDIUM_IMPORTANCE].limit   = min_win * 4;\n\tl->backlog[TIPC_HIGH_IMPORTANCE].limit     = min_win * 6;\n\tl->backlog[TIPC_CRITICAL_IMPORTANCE].limit = min_win * 8;\n\tl->backlog[TIPC_SYSTEM_IMPORTANCE].limit   = max_bulk;\n}\n\n/**\n * link_reset_stats - reset link statistics\n * @l: pointer to link\n */\nvoid tipc_link_reset_stats(struct tipc_link *l)\n{\n\tmemset(&l->stats, 0, sizeof(l->stats));\n}\n\nstatic void link_print(struct tipc_link *l, const char *str)\n{\n\tstruct sk_buff *hskb = skb_peek(&l->transmq);\n\tu16 head = hskb ? msg_seqno(buf_msg(hskb)) : l->snd_nxt - 1;\n\tu16 tail = l->snd_nxt - 1;\n\n\tpr_info(\"%s Link <%s> state %x\\n\", str, l->name, l->state);\n\tpr_info(\"XMTQ: %u [%u-%u], BKLGQ: %u, SNDNX: %u, RCVNX: %u\\n\",\n\t\tskb_queue_len(&l->transmq), head, tail,\n\t\tskb_queue_len(&l->backlogq), l->snd_nxt, l->rcv_nxt);\n}\n\n/* Parse and validate nested (link) properties valid for media, bearer and link\n */\nint tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[])\n{\n\tint err;\n\n\terr = nla_parse_nested_deprecated(props, TIPC_NLA_PROP_MAX, prop,\n\t\t\t\t\t  tipc_nl_prop_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (props[TIPC_NLA_PROP_PRIO]) {\n\t\tu32 prio;\n\n\t\tprio = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);\n\t\tif (prio > TIPC_MAX_LINK_PRI)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (props[TIPC_NLA_PROP_TOL]) {\n\t\tu32 tol;\n\n\t\ttol = nla_get_u32(props[TIPC_NLA_PROP_TOL]);\n\t\tif ((tol < TIPC_MIN_LINK_TOL) || (tol > TIPC_MAX_LINK_TOL))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (props[TIPC_NLA_PROP_WIN]) {\n\t\tu32 max_win;\n\n\t\tmax_win = nla_get_u32(props[TIPC_NLA_PROP_WIN]);\n\t\tif (max_win < TIPC_DEF_LINK_WIN || max_win > TIPC_MAX_LINK_WIN)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __tipc_nl_add_stats(struct sk_buff *skb, struct tipc_stats *s)\n{\n\tint i;\n\tstruct nlattr *stats;\n\n\tstruct nla_map {\n\t\tu32 key;\n\t\tu32 val;\n\t};\n\n\tstruct nla_map map[] = {\n\t\t{TIPC_NLA_STATS_RX_INFO, 0},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTS, s->recv_fragments},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTED, s->recv_fragmented},\n\t\t{TIPC_NLA_STATS_RX_BUNDLES, s->recv_bundles},\n\t\t{TIPC_NLA_STATS_RX_BUNDLED, s->recv_bundled},\n\t\t{TIPC_NLA_STATS_TX_INFO, 0},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTS, s->sent_fragments},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTED, s->sent_fragmented},\n\t\t{TIPC_NLA_STATS_TX_BUNDLES, s->sent_bundles},\n\t\t{TIPC_NLA_STATS_TX_BUNDLED, s->sent_bundled},\n\t\t{TIPC_NLA_STATS_MSG_PROF_TOT, (s->msg_length_counts) ?\n\t\t\ts->msg_length_counts : 1},\n\t\t{TIPC_NLA_STATS_MSG_LEN_CNT, s->msg_length_counts},\n\t\t{TIPC_NLA_STATS_MSG_LEN_TOT, s->msg_lengths_total},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P0, s->msg_length_profile[0]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P1, s->msg_length_profile[1]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P2, s->msg_length_profile[2]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P3, s->msg_length_profile[3]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P4, s->msg_length_profile[4]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P5, s->msg_length_profile[5]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P6, s->msg_length_profile[6]},\n\t\t{TIPC_NLA_STATS_RX_STATES, s->recv_states},\n\t\t{TIPC_NLA_STATS_RX_PROBES, s->recv_probes},\n\t\t{TIPC_NLA_STATS_RX_NACKS, s->recv_nacks},\n\t\t{TIPC_NLA_STATS_RX_DEFERRED, s->deferred_recv},\n\t\t{TIPC_NLA_STATS_TX_STATES, s->sent_states},\n\t\t{TIPC_NLA_STATS_TX_PROBES, s->sent_probes},\n\t\t{TIPC_NLA_STATS_TX_NACKS, s->sent_nacks},\n\t\t{TIPC_NLA_STATS_TX_ACKS, s->sent_acks},\n\t\t{TIPC_NLA_STATS_RETRANSMITTED, s->retransmitted},\n\t\t{TIPC_NLA_STATS_DUPLICATES, s->duplicates},\n\t\t{TIPC_NLA_STATS_LINK_CONGS, s->link_congs},\n\t\t{TIPC_NLA_STATS_MAX_QUEUE, s->max_queue_sz},\n\t\t{TIPC_NLA_STATS_AVG_QUEUE, s->queue_sz_counts ?\n\t\t\t(s->accu_queue_sz / s->queue_sz_counts) : 0}\n\t};\n\n\tstats = nla_nest_start_noflag(skb, TIPC_NLA_LINK_STATS);\n\tif (!stats)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i <  ARRAY_SIZE(map); i++)\n\t\tif (nla_put_u32(skb, map[i].key, map[i].val))\n\t\t\tgoto msg_full;\n\n\tnla_nest_end(skb, stats);\n\n\treturn 0;\nmsg_full:\n\tnla_nest_cancel(skb, stats);\n\n\treturn -EMSGSIZE;\n}\n\n/* Caller should hold appropriate locks to protect the link */\nint __tipc_nl_add_link(struct net *net, struct tipc_nl_msg *msg,\n\t\t       struct tipc_link *link, int nlflags)\n{\n\tu32 self = tipc_own_addr(net);\n\tstruct nlattr *attrs;\n\tstruct nlattr *prop;\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  nlflags, TIPC_NL_LINK_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_string(msg->skb, TIPC_NLA_LINK_NAME, link->name))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_DEST, tipc_cluster_mask(self)))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_MTU, link->mtu))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_RX, link->stats.recv_pkts))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_TX, link->stats.sent_pkts))\n\t\tgoto attr_msg_full;\n\n\tif (tipc_link_is_up(link))\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_UP))\n\t\t\tgoto attr_msg_full;\n\tif (link->active)\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_ACTIVE))\n\t\t\tgoto attr_msg_full;\n\n\tprop = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK_PROP);\n\tif (!prop)\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, link->priority))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_TOL, link->tolerance))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN,\n\t\t\tlink->window))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, link->priority))\n\t\tgoto prop_msg_full;\n\tnla_nest_end(msg->skb, prop);\n\n\terr = __tipc_nl_add_stats(msg->skb, &link->stats);\n\tif (err)\n\t\tgoto attr_msg_full;\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nprop_msg_full:\n\tnla_nest_cancel(msg->skb, prop);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int __tipc_nl_add_bc_link_stat(struct sk_buff *skb,\n\t\t\t\t      struct tipc_stats *stats)\n{\n\tint i;\n\tstruct nlattr *nest;\n\n\tstruct nla_map {\n\t\t__u32 key;\n\t\t__u32 val;\n\t};\n\n\tstruct nla_map map[] = {\n\t\t{TIPC_NLA_STATS_RX_INFO, stats->recv_pkts},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTS, stats->recv_fragments},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTED, stats->recv_fragmented},\n\t\t{TIPC_NLA_STATS_RX_BUNDLES, stats->recv_bundles},\n\t\t{TIPC_NLA_STATS_RX_BUNDLED, stats->recv_bundled},\n\t\t{TIPC_NLA_STATS_TX_INFO, stats->sent_pkts},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTS, stats->sent_fragments},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTED, stats->sent_fragmented},\n\t\t{TIPC_NLA_STATS_TX_BUNDLES, stats->sent_bundles},\n\t\t{TIPC_NLA_STATS_TX_BUNDLED, stats->sent_bundled},\n\t\t{TIPC_NLA_STATS_RX_NACKS, stats->recv_nacks},\n\t\t{TIPC_NLA_STATS_RX_DEFERRED, stats->deferred_recv},\n\t\t{TIPC_NLA_STATS_TX_NACKS, stats->sent_nacks},\n\t\t{TIPC_NLA_STATS_TX_ACKS, stats->sent_acks},\n\t\t{TIPC_NLA_STATS_RETRANSMITTED, stats->retransmitted},\n\t\t{TIPC_NLA_STATS_DUPLICATES, stats->duplicates},\n\t\t{TIPC_NLA_STATS_LINK_CONGS, stats->link_congs},\n\t\t{TIPC_NLA_STATS_MAX_QUEUE, stats->max_queue_sz},\n\t\t{TIPC_NLA_STATS_AVG_QUEUE, stats->queue_sz_counts ?\n\t\t\t(stats->accu_queue_sz / stats->queue_sz_counts) : 0}\n\t};\n\n\tnest = nla_nest_start_noflag(skb, TIPC_NLA_LINK_STATS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i <  ARRAY_SIZE(map); i++)\n\t\tif (nla_put_u32(skb, map[i].key, map[i].val))\n\t\t\tgoto msg_full;\n\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\nmsg_full:\n\tnla_nest_cancel(skb, nest);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_add_bc_link(struct net *net, struct tipc_nl_msg *msg,\n\t\t\tstruct tipc_link *bcl)\n{\n\tint err;\n\tvoid *hdr;\n\tstruct nlattr *attrs;\n\tstruct nlattr *prop;\n\tu32 bc_mode = tipc_bcast_get_mode(net);\n\tu32 bc_ratio = tipc_bcast_get_broadcast_ratio(net);\n\n\tif (!bcl)\n\t\treturn 0;\n\n\ttipc_bcast_lock(net);\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  NLM_F_MULTI, TIPC_NL_LINK_GET);\n\tif (!hdr) {\n\t\ttipc_bcast_unlock(net);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\t/* The broadcast link is always up */\n\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_UP))\n\t\tgoto attr_msg_full;\n\n\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_BROADCAST))\n\t\tgoto attr_msg_full;\n\tif (nla_put_string(msg->skb, TIPC_NLA_LINK_NAME, bcl->name))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_RX, 0))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_TX, 0))\n\t\tgoto attr_msg_full;\n\n\tprop = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK_PROP);\n\tif (!prop)\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN, bcl->max_win))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_BROADCAST, bc_mode))\n\t\tgoto prop_msg_full;\n\tif (bc_mode & BCLINK_MODE_SEL)\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_BROADCAST_RATIO,\n\t\t\t\tbc_ratio))\n\t\t\tgoto prop_msg_full;\n\tnla_nest_end(msg->skb, prop);\n\n\terr = __tipc_nl_add_bc_link_stat(msg->skb, &bcl->stats);\n\tif (err)\n\t\tgoto attr_msg_full;\n\n\ttipc_bcast_unlock(net);\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nprop_msg_full:\n\tnla_nest_cancel(msg->skb, prop);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\ttipc_bcast_unlock(net);\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nvoid tipc_link_set_tolerance(struct tipc_link *l, u32 tol,\n\t\t\t     struct sk_buff_head *xmitq)\n{\n\tl->tolerance = tol;\n\tif (l->bc_rcvlink)\n\t\tl->bc_rcvlink->tolerance = tol;\n\tif (link_is_up(l))\n\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, tol, 0, xmitq);\n}\n\nvoid tipc_link_set_prio(struct tipc_link *l, u32 prio,\n\t\t\tstruct sk_buff_head *xmitq)\n{\n\tl->priority = prio;\n\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, 0, prio, xmitq);\n}\n\nvoid tipc_link_set_abort_limit(struct tipc_link *l, u32 limit)\n{\n\tl->abort_limit = limit;\n}\n\n/**\n * tipc_link_dump - dump TIPC link data\n * @l: tipc link to be dumped\n * @dqueues: bitmask to decide if any link queue to be dumped?\n *           - TIPC_DUMP_NONE: don't dump link queues\n *           - TIPC_DUMP_TRANSMQ: dump link transmq queue\n *           - TIPC_DUMP_BACKLOGQ: dump link backlog queue\n *           - TIPC_DUMP_DEFERDQ: dump link deferd queue\n *           - TIPC_DUMP_INPUTQ: dump link input queue\n *           - TIPC_DUMP_WAKEUP: dump link wakeup queue\n *           - TIPC_DUMP_ALL: dump all the link queues above\n * @buf: returned buffer of dump data in format\n */\nint tipc_link_dump(struct tipc_link *l, u16 dqueues, char *buf)\n{\n\tint i = 0;\n\tsize_t sz = (dqueues) ? LINK_LMAX : LINK_LMIN;\n\tstruct sk_buff_head *list;\n\tstruct sk_buff *hskb, *tskb;\n\tu32 len;\n\n\tif (!l) {\n\t\ti += scnprintf(buf, sz, \"link data: (null)\\n\");\n\t\treturn i;\n\t}\n\n\ti += scnprintf(buf, sz, \"link data: %x\", l->addr);\n\ti += scnprintf(buf + i, sz - i, \" %x\", l->state);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->in_session);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->session);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->peer_session);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->snd_nxt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->rcv_nxt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->snd_nxt_state);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->rcv_nxt_state);\n\ti += scnprintf(buf + i, sz - i, \" %x\", l->peer_caps);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->silent_intv_cnt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->rst_cnt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", 0);\n\ti += scnprintf(buf + i, sz - i, \" %u\", 0);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->acked);\n\n\tlist = &l->transmq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tlist = &l->deferdq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tlist = &l->backlogq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tlist = l->inputq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\\n\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tif (dqueues & TIPC_DUMP_TRANSMQ) {\n\t\ti += scnprintf(buf + i, sz - i, \"transmq: \");\n\t\ti += tipc_list_dump(&l->transmq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_BACKLOGQ) {\n\t\ti += scnprintf(buf + i, sz - i,\n\t\t\t       \"backlogq: <%u %u %u %u %u>, \",\n\t\t\t       l->backlog[TIPC_LOW_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_MEDIUM_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_HIGH_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_CRITICAL_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_SYSTEM_IMPORTANCE].len);\n\t\ti += tipc_list_dump(&l->backlogq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_DEFERDQ) {\n\t\ti += scnprintf(buf + i, sz - i, \"deferdq: \");\n\t\ti += tipc_list_dump(&l->deferdq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_INPUTQ) {\n\t\ti += scnprintf(buf + i, sz - i, \"inputq: \");\n\t\ti += tipc_list_dump(l->inputq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_WAKEUP) {\n\t\ti += scnprintf(buf + i, sz - i, \"wakeup: \");\n\t\ti += tipc_list_dump(&l->wakeupq, false, buf + i);\n\t}\n\n\treturn i;\n}\n"], "fixing_code": ["/*\n * net/tipc/link.c: TIPC link code\n *\n * Copyright (c) 1996-2007, 2012-2016, Ericsson AB\n * Copyright (c) 2004-2007, 2010-2013, Wind River Systems\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the names of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * Alternatively, this software may be distributed under the terms of the\n * GNU General Public License (\"GPL\") version 2 as published by the Free\n * Software Foundation.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"core.h\"\n#include \"subscr.h\"\n#include \"link.h\"\n#include \"bcast.h\"\n#include \"socket.h\"\n#include \"name_distr.h\"\n#include \"discover.h\"\n#include \"netlink.h\"\n#include \"monitor.h\"\n#include \"trace.h\"\n#include \"crypto.h\"\n\n#include <linux/pkt_sched.h>\n\nstruct tipc_stats {\n\tu32 sent_pkts;\n\tu32 recv_pkts;\n\tu32 sent_states;\n\tu32 recv_states;\n\tu32 sent_probes;\n\tu32 recv_probes;\n\tu32 sent_nacks;\n\tu32 recv_nacks;\n\tu32 sent_acks;\n\tu32 sent_bundled;\n\tu32 sent_bundles;\n\tu32 recv_bundled;\n\tu32 recv_bundles;\n\tu32 retransmitted;\n\tu32 sent_fragmented;\n\tu32 sent_fragments;\n\tu32 recv_fragmented;\n\tu32 recv_fragments;\n\tu32 link_congs;\t\t/* # port sends blocked by congestion */\n\tu32 deferred_recv;\n\tu32 duplicates;\n\tu32 max_queue_sz;\t/* send queue size high water mark */\n\tu32 accu_queue_sz;\t/* used for send queue size profiling */\n\tu32 queue_sz_counts;\t/* used for send queue size profiling */\n\tu32 msg_length_counts;\t/* used for message length profiling */\n\tu32 msg_lengths_total;\t/* used for message length profiling */\n\tu32 msg_length_profile[7]; /* used for msg. length profiling */\n};\n\n/**\n * struct tipc_link - TIPC link data structure\n * @addr: network address of link's peer node\n * @name: link name character string\n * @media_addr: media address to use when sending messages over link\n * @timer: link timer\n * @net: pointer to namespace struct\n * @refcnt: reference counter for permanent references (owner node & timer)\n * @peer_session: link session # being used by peer end of link\n * @peer_bearer_id: bearer id used by link's peer endpoint\n * @bearer_id: local bearer id used by link\n * @tolerance: minimum link continuity loss needed to reset link [in ms]\n * @abort_limit: # of unacknowledged continuity probes needed to reset link\n * @state: current state of link FSM\n * @peer_caps: bitmap describing capabilities of peer node\n * @silent_intv_cnt: # of timer intervals without any reception from peer\n * @proto_msg: template for control messages generated by link\n * @pmsg: convenience pointer to \"proto_msg\" field\n * @priority: current link priority\n * @net_plane: current link network plane ('A' through 'H')\n * @mon_state: cookie with information needed by link monitor\n * @backlog_limit: backlog queue congestion thresholds (indexed by importance)\n * @exp_msg_count: # of tunnelled messages expected during link changeover\n * @reset_rcv_checkpt: seq # of last acknowledged message at time of link reset\n * @mtu: current maximum packet size for this link\n * @advertised_mtu: advertised own mtu when link is being established\n * @transmitq: queue for sent, non-acked messages\n * @backlogq: queue for messages waiting to be sent\n * @snt_nxt: next sequence number to use for outbound messages\n * @ackers: # of peers that needs to ack each packet before it can be released\n * @acked: # last packet acked by a certain peer. Used for broadcast.\n * @rcv_nxt: next sequence number to expect for inbound messages\n * @deferred_queue: deferred queue saved OOS b'cast message received from node\n * @unacked_window: # of inbound messages rx'd without ack'ing back to peer\n * @inputq: buffer queue for messages to be delivered upwards\n * @namedq: buffer queue for name table messages to be delivered upwards\n * @next_out: ptr to first unsent outbound message in queue\n * @wakeupq: linked list of wakeup msgs waiting for link congestion to abate\n * @long_msg_seq_no: next identifier to use for outbound fragmented messages\n * @reasm_buf: head of partially reassembled inbound message fragments\n * @bc_rcvr: marks that this is a broadcast receiver link\n * @stats: collects statistics regarding link activity\n * @session: session to be used by link\n * @snd_nxt_state: next send seq number\n * @rcv_nxt_state: next rcv seq number\n * @in_session: have received ACTIVATE_MSG from peer\n * @active: link is active\n * @if_name: associated interface name\n * @rst_cnt: link reset counter\n * @drop_point: seq number for failover handling (FIXME)\n * @failover_reasm_skb: saved failover msg ptr (FIXME)\n * @failover_deferdq: deferred message queue for failover processing (FIXME)\n * @transmq: the link's transmit queue\n * @backlog: link's backlog by priority (importance)\n * @snd_nxt: next sequence number to be used\n * @rcv_unacked: # messages read by user, but not yet acked back to peer\n * @deferdq: deferred receive queue\n * @window: sliding window size for congestion handling\n * @min_win: minimal send window to be used by link\n * @ssthresh: slow start threshold for congestion handling\n * @max_win: maximal send window to be used by link\n * @cong_acks: congestion acks for congestion avoidance (FIXME)\n * @checkpoint: seq number for congestion window size handling\n * @reasm_tnlmsg: fragmentation/reassembly area for tunnel protocol message\n * @last_gap: last gap ack blocks for bcast (FIXME)\n * @last_ga: ptr to gap ack blocks\n * @bc_rcvlink: the peer specific link used for broadcast reception\n * @bc_sndlink: the namespace global link used for broadcast sending\n * @nack_state: bcast nack state\n * @bc_peer_is_up: peer has acked the bcast init msg\n */\nstruct tipc_link {\n\tu32 addr;\n\tchar name[TIPC_MAX_LINK_NAME];\n\tstruct net *net;\n\n\t/* Management and link supervision data */\n\tu16 peer_session;\n\tu16 session;\n\tu16 snd_nxt_state;\n\tu16 rcv_nxt_state;\n\tu32 peer_bearer_id;\n\tu32 bearer_id;\n\tu32 tolerance;\n\tu32 abort_limit;\n\tu32 state;\n\tu16 peer_caps;\n\tbool in_session;\n\tbool active;\n\tu32 silent_intv_cnt;\n\tchar if_name[TIPC_MAX_IF_NAME];\n\tu32 priority;\n\tchar net_plane;\n\tstruct tipc_mon_state mon_state;\n\tu16 rst_cnt;\n\n\t/* Failover/synch */\n\tu16 drop_point;\n\tstruct sk_buff *failover_reasm_skb;\n\tstruct sk_buff_head failover_deferdq;\n\n\t/* Max packet negotiation */\n\tu16 mtu;\n\tu16 advertised_mtu;\n\n\t/* Sending */\n\tstruct sk_buff_head transmq;\n\tstruct sk_buff_head backlogq;\n\tstruct {\n\t\tu16 len;\n\t\tu16 limit;\n\t\tstruct sk_buff *target_bskb;\n\t} backlog[5];\n\tu16 snd_nxt;\n\n\t/* Reception */\n\tu16 rcv_nxt;\n\tu32 rcv_unacked;\n\tstruct sk_buff_head deferdq;\n\tstruct sk_buff_head *inputq;\n\tstruct sk_buff_head *namedq;\n\n\t/* Congestion handling */\n\tstruct sk_buff_head wakeupq;\n\tu16 window;\n\tu16 min_win;\n\tu16 ssthresh;\n\tu16 max_win;\n\tu16 cong_acks;\n\tu16 checkpoint;\n\n\t/* Fragmentation/reassembly */\n\tstruct sk_buff *reasm_buf;\n\tstruct sk_buff *reasm_tnlmsg;\n\n\t/* Broadcast */\n\tu16 ackers;\n\tu16 acked;\n\tu16 last_gap;\n\tstruct tipc_gap_ack_blks *last_ga;\n\tstruct tipc_link *bc_rcvlink;\n\tstruct tipc_link *bc_sndlink;\n\tu8 nack_state;\n\tbool bc_peer_is_up;\n\n\t/* Statistics */\n\tstruct tipc_stats stats;\n};\n\n/*\n * Error message prefixes\n */\nstatic const char *link_co_err = \"Link tunneling error, \";\nstatic const char *link_rst_msg = \"Resetting link \";\n\n/* Send states for broadcast NACKs\n */\nenum {\n\tBC_NACK_SND_CONDITIONAL,\n\tBC_NACK_SND_UNCONDITIONAL,\n\tBC_NACK_SND_SUPPRESS,\n};\n\n#define TIPC_BC_RETR_LIM  (jiffies + msecs_to_jiffies(10))\n#define TIPC_UC_RETR_TIME (jiffies + msecs_to_jiffies(1))\n\n/* Link FSM states:\n */\nenum {\n\tLINK_ESTABLISHED     = 0xe,\n\tLINK_ESTABLISHING    = 0xe  << 4,\n\tLINK_RESET           = 0x1  << 8,\n\tLINK_RESETTING       = 0x2  << 12,\n\tLINK_PEER_RESET      = 0xd  << 16,\n\tLINK_FAILINGOVER     = 0xf  << 20,\n\tLINK_SYNCHING        = 0xc  << 24\n};\n\n/* Link FSM state checking routines\n */\nstatic int link_is_up(struct tipc_link *l)\n{\n\treturn l->state & (LINK_ESTABLISHED | LINK_SYNCHING);\n}\n\nstatic int tipc_link_proto_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t       struct sk_buff_head *xmitq);\nstatic void tipc_link_build_proto_msg(struct tipc_link *l, int mtyp, bool probe,\n\t\t\t\t      bool probe_reply, u16 rcvgap,\n\t\t\t\t      int tolerance, int priority,\n\t\t\t\t      struct sk_buff_head *xmitq);\nstatic void link_print(struct tipc_link *l, const char *str);\nstatic int tipc_link_build_nack_msg(struct tipc_link *l,\n\t\t\t\t    struct sk_buff_head *xmitq);\nstatic void tipc_link_build_bc_init_msg(struct tipc_link *l,\n\t\t\t\t\tstruct sk_buff_head *xmitq);\nstatic u8 __tipc_build_gap_ack_blks(struct tipc_gap_ack_blks *ga,\n\t\t\t\t    struct tipc_link *l, u8 start_index);\nstatic u16 tipc_build_gap_ack_blks(struct tipc_link *l, struct tipc_msg *hdr);\nstatic int tipc_link_advance_transmq(struct tipc_link *l, struct tipc_link *r,\n\t\t\t\t     u16 acked, u16 gap,\n\t\t\t\t     struct tipc_gap_ack_blks *ga,\n\t\t\t\t     struct sk_buff_head *xmitq,\n\t\t\t\t     bool *retransmitted, int *rc);\nstatic void tipc_link_update_cwin(struct tipc_link *l, int released,\n\t\t\t\t  bool retransmitted);\n/*\n *  Simple non-static link routines (i.e. referenced outside this file)\n */\nbool tipc_link_is_up(struct tipc_link *l)\n{\n\treturn link_is_up(l);\n}\n\nbool tipc_link_peer_is_down(struct tipc_link *l)\n{\n\treturn l->state == LINK_PEER_RESET;\n}\n\nbool tipc_link_is_reset(struct tipc_link *l)\n{\n\treturn l->state & (LINK_RESET | LINK_FAILINGOVER | LINK_ESTABLISHING);\n}\n\nbool tipc_link_is_establishing(struct tipc_link *l)\n{\n\treturn l->state == LINK_ESTABLISHING;\n}\n\nbool tipc_link_is_synching(struct tipc_link *l)\n{\n\treturn l->state == LINK_SYNCHING;\n}\n\nbool tipc_link_is_failingover(struct tipc_link *l)\n{\n\treturn l->state == LINK_FAILINGOVER;\n}\n\nbool tipc_link_is_blocked(struct tipc_link *l)\n{\n\treturn l->state & (LINK_RESETTING | LINK_PEER_RESET | LINK_FAILINGOVER);\n}\n\nstatic bool link_is_bc_sndlink(struct tipc_link *l)\n{\n\treturn !l->bc_sndlink;\n}\n\nstatic bool link_is_bc_rcvlink(struct tipc_link *l)\n{\n\treturn ((l->bc_rcvlink == l) && !link_is_bc_sndlink(l));\n}\n\nvoid tipc_link_set_active(struct tipc_link *l, bool active)\n{\n\tl->active = active;\n}\n\nu32 tipc_link_id(struct tipc_link *l)\n{\n\treturn l->peer_bearer_id << 16 | l->bearer_id;\n}\n\nint tipc_link_min_win(struct tipc_link *l)\n{\n\treturn l->min_win;\n}\n\nint tipc_link_max_win(struct tipc_link *l)\n{\n\treturn l->max_win;\n}\n\nint tipc_link_prio(struct tipc_link *l)\n{\n\treturn l->priority;\n}\n\nunsigned long tipc_link_tolerance(struct tipc_link *l)\n{\n\treturn l->tolerance;\n}\n\nstruct sk_buff_head *tipc_link_inputq(struct tipc_link *l)\n{\n\treturn l->inputq;\n}\n\nchar tipc_link_plane(struct tipc_link *l)\n{\n\treturn l->net_plane;\n}\n\nvoid tipc_link_update_caps(struct tipc_link *l, u16 capabilities)\n{\n\tl->peer_caps = capabilities;\n}\n\nvoid tipc_link_add_bc_peer(struct tipc_link *snd_l,\n\t\t\t   struct tipc_link *uc_l,\n\t\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct tipc_link *rcv_l = uc_l->bc_rcvlink;\n\n\tsnd_l->ackers++;\n\trcv_l->acked = snd_l->snd_nxt - 1;\n\tsnd_l->state = LINK_ESTABLISHED;\n\ttipc_link_build_bc_init_msg(uc_l, xmitq);\n}\n\nvoid tipc_link_remove_bc_peer(struct tipc_link *snd_l,\n\t\t\t      struct tipc_link *rcv_l,\n\t\t\t      struct sk_buff_head *xmitq)\n{\n\tu16 ack = snd_l->snd_nxt - 1;\n\n\tsnd_l->ackers--;\n\trcv_l->bc_peer_is_up = true;\n\trcv_l->state = LINK_ESTABLISHED;\n\ttipc_link_bc_ack_rcv(rcv_l, ack, 0, NULL, xmitq, NULL);\n\ttrace_tipc_link_reset(rcv_l, TIPC_DUMP_ALL, \"bclink removed!\");\n\ttipc_link_reset(rcv_l);\n\trcv_l->state = LINK_RESET;\n\tif (!snd_l->ackers) {\n\t\ttrace_tipc_link_reset(snd_l, TIPC_DUMP_ALL, \"zero ackers!\");\n\t\ttipc_link_reset(snd_l);\n\t\tsnd_l->state = LINK_RESET;\n\t\t__skb_queue_purge(xmitq);\n\t}\n}\n\nint tipc_link_bc_peers(struct tipc_link *l)\n{\n\treturn l->ackers;\n}\n\nstatic u16 link_bc_rcv_gap(struct tipc_link *l)\n{\n\tstruct sk_buff *skb = skb_peek(&l->deferdq);\n\tu16 gap = 0;\n\n\tif (more(l->snd_nxt, l->rcv_nxt))\n\t\tgap = l->snd_nxt - l->rcv_nxt;\n\tif (skb)\n\t\tgap = buf_seqno(skb) - l->rcv_nxt;\n\treturn gap;\n}\n\nvoid tipc_link_set_mtu(struct tipc_link *l, int mtu)\n{\n\tl->mtu = mtu;\n}\n\nint tipc_link_mtu(struct tipc_link *l)\n{\n\treturn l->mtu;\n}\n\nint tipc_link_mss(struct tipc_link *l)\n{\n#ifdef CONFIG_TIPC_CRYPTO\n\treturn l->mtu - INT_H_SIZE - EMSG_OVERHEAD;\n#else\n\treturn l->mtu - INT_H_SIZE;\n#endif\n}\n\nu16 tipc_link_rcv_nxt(struct tipc_link *l)\n{\n\treturn l->rcv_nxt;\n}\n\nu16 tipc_link_acked(struct tipc_link *l)\n{\n\treturn l->acked;\n}\n\nchar *tipc_link_name(struct tipc_link *l)\n{\n\treturn l->name;\n}\n\nu32 tipc_link_state(struct tipc_link *l)\n{\n\treturn l->state;\n}\n\n/**\n * tipc_link_create - create a new link\n * @net: pointer to associated network namespace\n * @if_name: associated interface name\n * @bearer_id: id (index) of associated bearer\n * @tolerance: link tolerance to be used by link\n * @net_plane: network plane (A,B,c..) this link belongs to\n * @mtu: mtu to be advertised by link\n * @priority: priority to be used by link\n * @min_win: minimal send window to be used by link\n * @max_win: maximal send window to be used by link\n * @session: session to be used by link\n * @peer: node id of peer node\n * @peer_caps: bitmap describing peer node capabilities\n * @bc_sndlink: the namespace global link used for broadcast sending\n * @bc_rcvlink: the peer specific link used for broadcast reception\n * @inputq: queue to put messages ready for delivery\n * @namedq: queue to put binding table update messages ready for delivery\n * @link: return value, pointer to put the created link\n * @self: local unicast link id\n * @peer_id: 128-bit ID of peer\n *\n * Return: true if link was created, otherwise false\n */\nbool tipc_link_create(struct net *net, char *if_name, int bearer_id,\n\t\t      int tolerance, char net_plane, u32 mtu, int priority,\n\t\t      u32 min_win, u32 max_win, u32 session, u32 self,\n\t\t      u32 peer, u8 *peer_id, u16 peer_caps,\n\t\t      struct tipc_link *bc_sndlink,\n\t\t      struct tipc_link *bc_rcvlink,\n\t\t      struct sk_buff_head *inputq,\n\t\t      struct sk_buff_head *namedq,\n\t\t      struct tipc_link **link)\n{\n\tchar peer_str[NODE_ID_STR_LEN] = {0,};\n\tchar self_str[NODE_ID_STR_LEN] = {0,};\n\tstruct tipc_link *l;\n\n\tl = kzalloc(sizeof(*l), GFP_ATOMIC);\n\tif (!l)\n\t\treturn false;\n\t*link = l;\n\tl->session = session;\n\n\t/* Set link name for unicast links only */\n\tif (peer_id) {\n\t\ttipc_nodeid2string(self_str, tipc_own_id(net));\n\t\tif (strlen(self_str) > 16)\n\t\t\tsprintf(self_str, \"%x\", self);\n\t\ttipc_nodeid2string(peer_str, peer_id);\n\t\tif (strlen(peer_str) > 16)\n\t\t\tsprintf(peer_str, \"%x\", peer);\n\t}\n\t/* Peer i/f name will be completed by reset/activate message */\n\tsnprintf(l->name, sizeof(l->name), \"%s:%s-%s:unknown\",\n\t\t self_str, if_name, peer_str);\n\n\tstrcpy(l->if_name, if_name);\n\tl->addr = peer;\n\tl->peer_caps = peer_caps;\n\tl->net = net;\n\tl->in_session = false;\n\tl->bearer_id = bearer_id;\n\tl->tolerance = tolerance;\n\tif (bc_rcvlink)\n\t\tbc_rcvlink->tolerance = tolerance;\n\tl->net_plane = net_plane;\n\tl->advertised_mtu = mtu;\n\tl->mtu = mtu;\n\tl->priority = priority;\n\ttipc_link_set_queue_limits(l, min_win, max_win);\n\tl->ackers = 1;\n\tl->bc_sndlink = bc_sndlink;\n\tl->bc_rcvlink = bc_rcvlink;\n\tl->inputq = inputq;\n\tl->namedq = namedq;\n\tl->state = LINK_RESETTING;\n\t__skb_queue_head_init(&l->transmq);\n\t__skb_queue_head_init(&l->backlogq);\n\t__skb_queue_head_init(&l->deferdq);\n\t__skb_queue_head_init(&l->failover_deferdq);\n\tskb_queue_head_init(&l->wakeupq);\n\tskb_queue_head_init(l->inputq);\n\treturn true;\n}\n\n/**\n * tipc_link_bc_create - create new link to be used for broadcast\n * @net: pointer to associated network namespace\n * @mtu: mtu to be used initially if no peers\n * @min_win: minimal send window to be used by link\n * @max_win: maximal send window to be used by link\n * @inputq: queue to put messages ready for delivery\n * @namedq: queue to put binding table update messages ready for delivery\n * @link: return value, pointer to put the created link\n * @ownnode: identity of own node\n * @peer: node id of peer node\n * @peer_id: 128-bit ID of peer\n * @peer_caps: bitmap describing peer node capabilities\n * @bc_sndlink: the namespace global link used for broadcast sending\n *\n * Return: true if link was created, otherwise false\n */\nbool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer, u8 *peer_id,\n\t\t\t int mtu, u32 min_win, u32 max_win, u16 peer_caps,\n\t\t\t struct sk_buff_head *inputq,\n\t\t\t struct sk_buff_head *namedq,\n\t\t\t struct tipc_link *bc_sndlink,\n\t\t\t struct tipc_link **link)\n{\n\tstruct tipc_link *l;\n\n\tif (!tipc_link_create(net, \"\", MAX_BEARERS, 0, 'Z', mtu, 0, min_win,\n\t\t\t      max_win, 0, ownnode, peer, NULL, peer_caps,\n\t\t\t      bc_sndlink, NULL, inputq, namedq, link))\n\t\treturn false;\n\n\tl = *link;\n\tif (peer_id) {\n\t\tchar peer_str[NODE_ID_STR_LEN] = {0,};\n\n\t\ttipc_nodeid2string(peer_str, peer_id);\n\t\tif (strlen(peer_str) > 16)\n\t\t\tsprintf(peer_str, \"%x\", peer);\n\t\t/* Broadcast receiver link name: \"broadcast-link:<peer>\" */\n\t\tsnprintf(l->name, sizeof(l->name), \"%s:%s\", tipc_bclink_name,\n\t\t\t peer_str);\n\t} else {\n\t\tstrcpy(l->name, tipc_bclink_name);\n\t}\n\ttrace_tipc_link_reset(l, TIPC_DUMP_ALL, \"bclink created!\");\n\ttipc_link_reset(l);\n\tl->state = LINK_RESET;\n\tl->ackers = 0;\n\tl->bc_rcvlink = l;\n\n\t/* Broadcast send link is always up */\n\tif (link_is_bc_sndlink(l))\n\t\tl->state = LINK_ESTABLISHED;\n\n\t/* Disable replicast if even a single peer doesn't support it */\n\tif (link_is_bc_rcvlink(l) && !(peer_caps & TIPC_BCAST_RCAST))\n\t\ttipc_bcast_toggle_rcast(net, false);\n\n\treturn true;\n}\n\n/**\n * tipc_link_fsm_evt - link finite state machine\n * @l: pointer to link\n * @evt: state machine event to be processed\n */\nint tipc_link_fsm_evt(struct tipc_link *l, int evt)\n{\n\tint rc = 0;\n\tint old_state = l->state;\n\n\tswitch (l->state) {\n\tcase LINK_RESETTING:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_PEER_RESET;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_RESET:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_ESTABLISHING;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\t\tl->state = LINK_FAILINGOVER;\n\t\tcase LINK_FAILURE_EVT:\n\t\tcase LINK_RESET_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_PEER_RESET:\n\t\tswitch (evt) {\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_ESTABLISHING;\n\t\t\tbreak;\n\t\tcase LINK_PEER_RESET_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_FAILINGOVER:\n\t\tswitch (evt) {\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_PEER_RESET_EVT:\n\t\tcase LINK_RESET_EVT:\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_ESTABLISHING:\n\t\tswitch (evt) {\n\t\tcase LINK_ESTABLISH_EVT:\n\t\t\tl->state = LINK_ESTABLISHED;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\t\tl->state = LINK_FAILINGOVER;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\tcase LINK_PEER_RESET_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_ESTABLISHED:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_PEER_RESET;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tl->state = LINK_RESETTING;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_SYNCH_END_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\t\tl->state = LINK_SYNCHING;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tcase LINK_SYNCHING:\n\t\tswitch (evt) {\n\t\tcase LINK_PEER_RESET_EVT:\n\t\t\tl->state = LINK_PEER_RESET;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_FAILURE_EVT:\n\t\t\tl->state = LINK_RESETTING;\n\t\t\trc |= TIPC_LINK_DOWN_EVT;\n\t\t\tbreak;\n\t\tcase LINK_RESET_EVT:\n\t\t\tl->state = LINK_RESET;\n\t\t\tbreak;\n\t\tcase LINK_ESTABLISH_EVT:\n\t\tcase LINK_SYNCH_BEGIN_EVT:\n\t\t\tbreak;\n\t\tcase LINK_SYNCH_END_EVT:\n\t\t\tl->state = LINK_ESTABLISHED;\n\t\t\tbreak;\n\t\tcase LINK_FAILOVER_BEGIN_EVT:\n\t\tcase LINK_FAILOVER_END_EVT:\n\t\tdefault:\n\t\t\tgoto illegal_evt;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown FSM state %x in %s\\n\", l->state, l->name);\n\t}\n\ttrace_tipc_link_fsm(l->name, old_state, l->state, evt);\n\treturn rc;\nillegal_evt:\n\tpr_err(\"Illegal FSM event %x in state %x on link %s\\n\",\n\t       evt, l->state, l->name);\n\ttrace_tipc_link_fsm(l->name, old_state, l->state, evt);\n\treturn rc;\n}\n\n/* link_profile_stats - update statistical profiling of traffic\n */\nstatic void link_profile_stats(struct tipc_link *l)\n{\n\tstruct sk_buff *skb;\n\tstruct tipc_msg *msg;\n\tint length;\n\n\t/* Update counters used in statistical profiling of send traffic */\n\tl->stats.accu_queue_sz += skb_queue_len(&l->transmq);\n\tl->stats.queue_sz_counts++;\n\n\tskb = skb_peek(&l->transmq);\n\tif (!skb)\n\t\treturn;\n\tmsg = buf_msg(skb);\n\tlength = msg_size(msg);\n\n\tif (msg_user(msg) == MSG_FRAGMENTER) {\n\t\tif (msg_type(msg) != FIRST_FRAGMENT)\n\t\t\treturn;\n\t\tlength = msg_size(msg_inner_hdr(msg));\n\t}\n\tl->stats.msg_lengths_total += length;\n\tl->stats.msg_length_counts++;\n\tif (length <= 64)\n\t\tl->stats.msg_length_profile[0]++;\n\telse if (length <= 256)\n\t\tl->stats.msg_length_profile[1]++;\n\telse if (length <= 1024)\n\t\tl->stats.msg_length_profile[2]++;\n\telse if (length <= 4096)\n\t\tl->stats.msg_length_profile[3]++;\n\telse if (length <= 16384)\n\t\tl->stats.msg_length_profile[4]++;\n\telse if (length <= 32768)\n\t\tl->stats.msg_length_profile[5]++;\n\telse\n\t\tl->stats.msg_length_profile[6]++;\n}\n\n/**\n * tipc_link_too_silent - check if link is \"too silent\"\n * @l: tipc link to be checked\n *\n * Return: true if the link 'silent_intv_cnt' is about to reach the\n * 'abort_limit' value, otherwise false\n */\nbool tipc_link_too_silent(struct tipc_link *l)\n{\n\treturn (l->silent_intv_cnt + 2 > l->abort_limit);\n}\n\n/* tipc_link_timeout - perform periodic task as instructed from node timeout\n */\nint tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq)\n{\n\tint mtyp = 0;\n\tint rc = 0;\n\tbool state = false;\n\tbool probe = false;\n\tbool setup = false;\n\tu16 bc_snt = l->bc_sndlink->snd_nxt - 1;\n\tu16 bc_acked = l->bc_rcvlink->acked;\n\tstruct tipc_mon_state *mstate = &l->mon_state;\n\n\ttrace_tipc_link_timeout(l, TIPC_DUMP_NONE, \" \");\n\ttrace_tipc_link_too_silent(l, TIPC_DUMP_ALL, \" \");\n\tswitch (l->state) {\n\tcase LINK_ESTABLISHED:\n\tcase LINK_SYNCHING:\n\t\tmtyp = STATE_MSG;\n\t\tlink_profile_stats(l);\n\t\ttipc_mon_get_state(l->net, l->addr, mstate, l->bearer_id);\n\t\tif (mstate->reset || (l->silent_intv_cnt > l->abort_limit))\n\t\t\treturn tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\tstate = bc_acked != bc_snt;\n\t\tstate |= l->bc_rcvlink->rcv_unacked;\n\t\tstate |= l->rcv_unacked;\n\t\tstate |= !skb_queue_empty(&l->transmq);\n\t\tprobe = mstate->probing;\n\t\tprobe |= l->silent_intv_cnt;\n\t\tif (probe || mstate->monitoring)\n\t\t\tl->silent_intv_cnt++;\n\t\tprobe |= !skb_queue_empty(&l->deferdq);\n\t\tif (l->snd_nxt == l->checkpoint) {\n\t\t\ttipc_link_update_cwin(l, 0, 0);\n\t\t\tprobe = true;\n\t\t}\n\t\tl->checkpoint = l->snd_nxt;\n\t\tbreak;\n\tcase LINK_RESET:\n\t\tsetup = l->rst_cnt++ <= 4;\n\t\tsetup |= !(l->rst_cnt % 16);\n\t\tmtyp = RESET_MSG;\n\t\tbreak;\n\tcase LINK_ESTABLISHING:\n\t\tsetup = true;\n\t\tmtyp = ACTIVATE_MSG;\n\t\tbreak;\n\tcase LINK_PEER_RESET:\n\tcase LINK_RESETTING:\n\tcase LINK_FAILINGOVER:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (state || probe || setup)\n\t\ttipc_link_build_proto_msg(l, mtyp, probe, 0, 0, 0, 0, xmitq);\n\n\treturn rc;\n}\n\n/**\n * link_schedule_user - schedule a message sender for wakeup after congestion\n * @l: congested link\n * @hdr: header of message that is being sent\n * Create pseudo msg to send back to user when congestion abates\n */\nstatic int link_schedule_user(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tu32 dnode = tipc_own_addr(l->net);\n\tu32 dport = msg_origport(hdr);\n\tstruct sk_buff *skb;\n\n\t/* Create and schedule wakeup pseudo message */\n\tskb = tipc_msg_create(SOCK_WAKEUP, 0, INT_H_SIZE, 0,\n\t\t\t      dnode, l->addr, dport, 0, 0);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\tmsg_set_dest_droppable(buf_msg(skb), true);\n\tTIPC_SKB_CB(skb)->chain_imp = msg_importance(hdr);\n\tskb_queue_tail(&l->wakeupq, skb);\n\tl->stats.link_congs++;\n\ttrace_tipc_link_conges(l, TIPC_DUMP_ALL, \"wakeup scheduled!\");\n\treturn -ELINKCONG;\n}\n\n/**\n * link_prepare_wakeup - prepare users for wakeup after congestion\n * @l: congested link\n * Wake up a number of waiting users, as permitted by available space\n * in the send queue\n */\nstatic void link_prepare_wakeup(struct tipc_link *l)\n{\n\tstruct sk_buff_head *wakeupq = &l->wakeupq;\n\tstruct sk_buff_head *inputq = l->inputq;\n\tstruct sk_buff *skb, *tmp;\n\tstruct sk_buff_head tmpq;\n\tint avail[5] = {0,};\n\tint imp = 0;\n\n\t__skb_queue_head_init(&tmpq);\n\n\tfor (; imp <= TIPC_SYSTEM_IMPORTANCE; imp++)\n\t\tavail[imp] = l->backlog[imp].limit - l->backlog[imp].len;\n\n\tskb_queue_walk_safe(wakeupq, skb, tmp) {\n\t\timp = TIPC_SKB_CB(skb)->chain_imp;\n\t\tif (avail[imp] <= 0)\n\t\t\tcontinue;\n\t\tavail[imp]--;\n\t\t__skb_unlink(skb, wakeupq);\n\t\t__skb_queue_tail(&tmpq, skb);\n\t}\n\n\tspin_lock_bh(&inputq->lock);\n\tskb_queue_splice_tail(&tmpq, inputq);\n\tspin_unlock_bh(&inputq->lock);\n\n}\n\n/**\n * tipc_link_set_skb_retransmit_time - set the time at which retransmission of\n *                                     the given skb should be next attempted\n * @skb: skb to set a future retransmission time for\n * @l: link the skb will be transmitted on\n */\nstatic void tipc_link_set_skb_retransmit_time(struct sk_buff *skb,\n\t\t\t\t\t      struct tipc_link *l)\n{\n\tif (link_is_bc_sndlink(l))\n\t\tTIPC_SKB_CB(skb)->nxt_retr = TIPC_BC_RETR_LIM;\n\telse\n\t\tTIPC_SKB_CB(skb)->nxt_retr = TIPC_UC_RETR_TIME;\n}\n\nvoid tipc_link_reset(struct tipc_link *l)\n{\n\tstruct sk_buff_head list;\n\tu32 imp;\n\n\t__skb_queue_head_init(&list);\n\n\tl->in_session = false;\n\t/* Force re-synch of peer session number before establishing */\n\tl->peer_session--;\n\tl->session++;\n\tl->mtu = l->advertised_mtu;\n\n\tspin_lock_bh(&l->wakeupq.lock);\n\tskb_queue_splice_init(&l->wakeupq, &list);\n\tspin_unlock_bh(&l->wakeupq.lock);\n\n\tspin_lock_bh(&l->inputq->lock);\n\tskb_queue_splice_init(&list, l->inputq);\n\tspin_unlock_bh(&l->inputq->lock);\n\n\t__skb_queue_purge(&l->transmq);\n\t__skb_queue_purge(&l->deferdq);\n\t__skb_queue_purge(&l->backlogq);\n\t__skb_queue_purge(&l->failover_deferdq);\n\tfor (imp = 0; imp <= TIPC_SYSTEM_IMPORTANCE; imp++) {\n\t\tl->backlog[imp].len = 0;\n\t\tl->backlog[imp].target_bskb = NULL;\n\t}\n\tkfree_skb(l->reasm_buf);\n\tkfree_skb(l->reasm_tnlmsg);\n\tkfree_skb(l->failover_reasm_skb);\n\tl->reasm_buf = NULL;\n\tl->reasm_tnlmsg = NULL;\n\tl->failover_reasm_skb = NULL;\n\tl->rcv_unacked = 0;\n\tl->snd_nxt = 1;\n\tl->rcv_nxt = 1;\n\tl->snd_nxt_state = 1;\n\tl->rcv_nxt_state = 1;\n\tl->acked = 0;\n\tl->last_gap = 0;\n\tkfree(l->last_ga);\n\tl->last_ga = NULL;\n\tl->silent_intv_cnt = 0;\n\tl->rst_cnt = 0;\n\tl->bc_peer_is_up = false;\n\tmemset(&l->mon_state, 0, sizeof(l->mon_state));\n\ttipc_link_reset_stats(l);\n}\n\n/**\n * tipc_link_xmit(): enqueue buffer list according to queue situation\n * @l: link to use\n * @list: chain of buffers containing message\n * @xmitq: returned list of packets to be sent by caller\n *\n * Consumes the buffer chain.\n * Messages at TIPC_SYSTEM_IMPORTANCE are always accepted\n * Return: 0 if success, or errno: -ELINKCONG, -EMSGSIZE or -ENOBUFS\n */\nint tipc_link_xmit(struct tipc_link *l, struct sk_buff_head *list,\n\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *backlogq = &l->backlogq;\n\tstruct sk_buff_head *transmq = &l->transmq;\n\tstruct sk_buff *skb, *_skb;\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno = l->snd_nxt;\n\tint pkt_cnt = skb_queue_len(list);\n\tunsigned int mss = tipc_link_mss(l);\n\tunsigned int cwin = l->window;\n\tunsigned int mtu = l->mtu;\n\tstruct tipc_msg *hdr;\n\tbool new_bundle;\n\tint rc = 0;\n\tint imp;\n\n\tif (pkt_cnt <= 0)\n\t\treturn 0;\n\n\thdr = buf_msg(skb_peek(list));\n\tif (unlikely(msg_size(hdr) > mtu)) {\n\t\tpr_warn(\"Too large msg, purging xmit list %d %d %d %d %d!\\n\",\n\t\t\tskb_queue_len(list), msg_user(hdr),\n\t\t\tmsg_type(hdr), msg_size(hdr), mtu);\n\t\t__skb_queue_purge(list);\n\t\treturn -EMSGSIZE;\n\t}\n\n\timp = msg_importance(hdr);\n\t/* Allow oversubscription of one data msg per source at congestion */\n\tif (unlikely(l->backlog[imp].len >= l->backlog[imp].limit)) {\n\t\tif (imp == TIPC_SYSTEM_IMPORTANCE) {\n\t\t\tpr_warn(\"%s<%s>, link overflow\", link_rst_msg, l->name);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\trc = link_schedule_user(l, hdr);\n\t}\n\n\tif (pkt_cnt > 1) {\n\t\tl->stats.sent_fragmented++;\n\t\tl->stats.sent_fragments += pkt_cnt;\n\t}\n\n\t/* Prepare each packet for sending, and add to relevant queue: */\n\twhile ((skb = __skb_dequeue(list))) {\n\t\tif (likely(skb_queue_len(transmq) < cwin)) {\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_seqno(hdr, seqno);\n\t\t\tmsg_set_ack(hdr, ack);\n\t\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\t\t_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!_skb) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\t__skb_queue_purge(list);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\t__skb_queue_tail(transmq, skb);\n\t\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\t\t\t__skb_queue_tail(xmitq, _skb);\n\t\t\tTIPC_SKB_CB(skb)->ackers = l->ackers;\n\t\t\tl->rcv_unacked = 0;\n\t\t\tl->stats.sent_pkts++;\n\t\t\tseqno++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tipc_msg_try_bundle(l->backlog[imp].target_bskb, &skb,\n\t\t\t\t\tmss, l->addr, &new_bundle)) {\n\t\t\tif (skb) {\n\t\t\t\t/* Keep a ref. to the skb for next try */\n\t\t\t\tl->backlog[imp].target_bskb = skb;\n\t\t\t\tl->backlog[imp].len++;\n\t\t\t\t__skb_queue_tail(backlogq, skb);\n\t\t\t} else {\n\t\t\t\tif (new_bundle) {\n\t\t\t\t\tl->stats.sent_bundles++;\n\t\t\t\t\tl->stats.sent_bundled++;\n\t\t\t\t}\n\t\t\t\tl->stats.sent_bundled++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tl->backlog[imp].target_bskb = NULL;\n\t\tl->backlog[imp].len += (1 + skb_queue_len(list));\n\t\t__skb_queue_tail(backlogq, skb);\n\t\tskb_queue_splice_tail_init(list, backlogq);\n\t}\n\tl->snd_nxt = seqno;\n\treturn rc;\n}\n\nstatic void tipc_link_update_cwin(struct tipc_link *l, int released,\n\t\t\t\t  bool retransmitted)\n{\n\tint bklog_len = skb_queue_len(&l->backlogq);\n\tstruct sk_buff_head *txq = &l->transmq;\n\tint txq_len = skb_queue_len(txq);\n\tu16 cwin = l->window;\n\n\t/* Enter fast recovery */\n\tif (unlikely(retransmitted)) {\n\t\tl->ssthresh = max_t(u16, l->window / 2, 300);\n\t\tl->window = min_t(u16, l->ssthresh, l->window);\n\t\treturn;\n\t}\n\t/* Enter slow start */\n\tif (unlikely(!released)) {\n\t\tl->ssthresh = max_t(u16, l->window / 2, 300);\n\t\tl->window = l->min_win;\n\t\treturn;\n\t}\n\t/* Don't increase window if no pressure on the transmit queue */\n\tif (txq_len + bklog_len < cwin)\n\t\treturn;\n\n\t/* Don't increase window if there are holes the transmit queue */\n\tif (txq_len && l->snd_nxt - buf_seqno(skb_peek(txq)) != txq_len)\n\t\treturn;\n\n\tl->cong_acks += released;\n\n\t/* Slow start  */\n\tif (cwin <= l->ssthresh) {\n\t\tl->window = min_t(u16, cwin + released, l->max_win);\n\t\treturn;\n\t}\n\t/* Congestion avoidance */\n\tif (l->cong_acks < cwin)\n\t\treturn;\n\tl->window = min_t(u16, ++cwin, l->max_win);\n\tl->cong_acks = 0;\n}\n\nstatic void tipc_link_advance_backlog(struct tipc_link *l,\n\t\t\t\t      struct sk_buff_head *xmitq)\n{\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tstruct sk_buff_head *txq = &l->transmq;\n\tstruct sk_buff *skb, *_skb;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno = l->snd_nxt;\n\tstruct tipc_msg *hdr;\n\tu16 cwin = l->window;\n\tu32 imp;\n\n\twhile (skb_queue_len(txq) < cwin) {\n\t\tskb = skb_peek(&l->backlogq);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\t_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!_skb)\n\t\t\tbreak;\n\t\t__skb_dequeue(&l->backlogq);\n\t\thdr = buf_msg(skb);\n\t\timp = msg_importance(hdr);\n\t\tl->backlog[imp].len--;\n\t\tif (unlikely(skb == l->backlog[imp].target_bskb))\n\t\t\tl->backlog[imp].target_bskb = NULL;\n\t\t__skb_queue_tail(&l->transmq, skb);\n\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\n\t\t__skb_queue_tail(xmitq, _skb);\n\t\tTIPC_SKB_CB(skb)->ackers = l->ackers;\n\t\tmsg_set_seqno(hdr, seqno);\n\t\tmsg_set_ack(hdr, ack);\n\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\tl->rcv_unacked = 0;\n\t\tl->stats.sent_pkts++;\n\t\tseqno++;\n\t}\n\tl->snd_nxt = seqno;\n}\n\n/**\n * link_retransmit_failure() - Detect repeated retransmit failures\n * @l: tipc link sender\n * @r: tipc link receiver (= l in case of unicast)\n * @rc: returned code\n *\n * Return: true if the repeated retransmit failures happens, otherwise\n * false\n */\nstatic bool link_retransmit_failure(struct tipc_link *l, struct tipc_link *r,\n\t\t\t\t    int *rc)\n{\n\tstruct sk_buff *skb = skb_peek(&l->transmq);\n\tstruct tipc_msg *hdr;\n\n\tif (!skb)\n\t\treturn false;\n\n\tif (!TIPC_SKB_CB(skb)->retr_cnt)\n\t\treturn false;\n\n\tif (!time_after(jiffies, TIPC_SKB_CB(skb)->retr_stamp +\n\t\t\tmsecs_to_jiffies(r->tolerance * 10)))\n\t\treturn false;\n\n\thdr = buf_msg(skb);\n\tif (link_is_bc_sndlink(l) && !less(r->acked, msg_seqno(hdr)))\n\t\treturn false;\n\n\tpr_warn(\"Retransmission failure on link <%s>\\n\", l->name);\n\tlink_print(l, \"State of link \");\n\tpr_info(\"Failed msg: usr %u, typ %u, len %u, err %u\\n\",\n\t\tmsg_user(hdr), msg_type(hdr), msg_size(hdr), msg_errcode(hdr));\n\tpr_info(\"sqno %u, prev: %x, dest: %x\\n\",\n\t\tmsg_seqno(hdr), msg_prevnode(hdr), msg_destnode(hdr));\n\tpr_info(\"retr_stamp %d, retr_cnt %d\\n\",\n\t\tjiffies_to_msecs(TIPC_SKB_CB(skb)->retr_stamp),\n\t\tTIPC_SKB_CB(skb)->retr_cnt);\n\n\ttrace_tipc_list_dump(&l->transmq, true, \"retrans failure!\");\n\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"retrans failure!\");\n\ttrace_tipc_link_dump(r, TIPC_DUMP_NONE, \"retrans failure!\");\n\n\tif (link_is_bc_sndlink(l)) {\n\t\tr->state = LINK_RESET;\n\t\t*rc |= TIPC_LINK_DOWN_EVT;\n\t} else {\n\t\t*rc |= tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t}\n\n\treturn true;\n}\n\n/* tipc_data_input - deliver data and name distr msgs to upper layer\n *\n * Consumes buffer if message is of right type\n * Node lock must be held\n */\nstatic bool tipc_data_input(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t    struct sk_buff_head *inputq)\n{\n\tstruct sk_buff_head *mc_inputq = l->bc_rcvlink->inputq;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\n\tswitch (msg_user(hdr)) {\n\tcase TIPC_LOW_IMPORTANCE:\n\tcase TIPC_MEDIUM_IMPORTANCE:\n\tcase TIPC_HIGH_IMPORTANCE:\n\tcase TIPC_CRITICAL_IMPORTANCE:\n\t\tif (unlikely(msg_in_group(hdr) || msg_mcast(hdr))) {\n\t\t\tskb_queue_tail(mc_inputq, skb);\n\t\t\treturn true;\n\t\t}\n\t\tfallthrough;\n\tcase CONN_MANAGER:\n\t\tskb_queue_tail(inputq, skb);\n\t\treturn true;\n\tcase GROUP_PROTOCOL:\n\t\tskb_queue_tail(mc_inputq, skb);\n\t\treturn true;\n\tcase NAME_DISTRIBUTOR:\n\t\tl->bc_rcvlink->state = LINK_ESTABLISHED;\n\t\tskb_queue_tail(l->namedq, skb);\n\t\treturn true;\n\tcase MSG_BUNDLER:\n\tcase TUNNEL_PROTOCOL:\n\tcase MSG_FRAGMENTER:\n\tcase BCAST_PROTOCOL:\n\t\treturn false;\n#ifdef CONFIG_TIPC_CRYPTO\n\tcase MSG_CRYPTO:\n\t\ttipc_crypto_msg_rcv(l->net, skb);\n\t\treturn true;\n#endif\n\tdefault:\n\t\tpr_warn(\"Dropping received illegal msg type\\n\");\n\t\tkfree_skb(skb);\n\t\treturn true;\n\t}\n}\n\n/* tipc_link_input - process packet that has passed link protocol check\n *\n * Consumes buffer\n */\nstatic int tipc_link_input(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t   struct sk_buff_head *inputq,\n\t\t\t   struct sk_buff **reasm_skb)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct sk_buff *iskb;\n\tstruct sk_buff_head tmpq;\n\tint usr = msg_user(hdr);\n\tint pos = 0;\n\n\tif (usr == MSG_BUNDLER) {\n\t\tskb_queue_head_init(&tmpq);\n\t\tl->stats.recv_bundles++;\n\t\tl->stats.recv_bundled += msg_msgcnt(hdr);\n\t\twhile (tipc_msg_extract(skb, &iskb, &pos))\n\t\t\ttipc_data_input(l, iskb, &tmpq);\n\t\ttipc_skb_queue_splice_tail(&tmpq, inputq);\n\t\treturn 0;\n\t} else if (usr == MSG_FRAGMENTER) {\n\t\tl->stats.recv_fragments++;\n\t\tif (tipc_buf_append(reasm_skb, &skb)) {\n\t\t\tl->stats.recv_fragmented++;\n\t\t\ttipc_data_input(l, skb, inputq);\n\t\t} else if (!*reasm_skb && !link_is_bc_rcvlink(l)) {\n\t\t\tpr_warn_ratelimited(\"Unable to build fragment list\\n\");\n\t\t\treturn tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\t\treturn 0;\n\t} else if (usr == BCAST_PROTOCOL) {\n\t\ttipc_bcast_lock(l->net);\n\t\ttipc_link_bc_init_rcv(l->bc_rcvlink, hdr);\n\t\ttipc_bcast_unlock(l->net);\n\t}\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n/* tipc_link_tnl_rcv() - receive TUNNEL_PROTOCOL message, drop or process the\n *\t\t\t inner message along with the ones in the old link's\n *\t\t\t deferdq\n * @l: tunnel link\n * @skb: TUNNEL_PROTOCOL message\n * @inputq: queue to put messages ready for delivery\n */\nstatic int tipc_link_tnl_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t     struct sk_buff_head *inputq)\n{\n\tstruct sk_buff **reasm_skb = &l->failover_reasm_skb;\n\tstruct sk_buff **reasm_tnlmsg = &l->reasm_tnlmsg;\n\tstruct sk_buff_head *fdefq = &l->failover_deferdq;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct sk_buff *iskb;\n\tint ipos = 0;\n\tint rc = 0;\n\tu16 seqno;\n\n\tif (msg_type(hdr) == SYNCH_MSG) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t/* Not a fragment? */\n\tif (likely(!msg_nof_fragms(hdr))) {\n\t\tif (unlikely(!tipc_msg_extract(skb, &iskb, &ipos))) {\n\t\t\tpr_warn_ratelimited(\"Unable to extract msg, defq: %d\\n\",\n\t\t\t\t\t    skb_queue_len(fdefq));\n\t\t\treturn 0;\n\t\t}\n\t\tkfree_skb(skb);\n\t} else {\n\t\t/* Set fragment type for buf_append */\n\t\tif (msg_fragm_no(hdr) == 1)\n\t\t\tmsg_set_type(hdr, FIRST_FRAGMENT);\n\t\telse if (msg_fragm_no(hdr) < msg_nof_fragms(hdr))\n\t\t\tmsg_set_type(hdr, FRAGMENT);\n\t\telse\n\t\t\tmsg_set_type(hdr, LAST_FRAGMENT);\n\n\t\tif (!tipc_buf_append(reasm_tnlmsg, &skb)) {\n\t\t\t/* Successful but non-complete reassembly? */\n\t\t\tif (*reasm_tnlmsg || link_is_bc_rcvlink(l))\n\t\t\t\treturn 0;\n\t\t\tpr_warn_ratelimited(\"Unable to reassemble tunnel msg\\n\");\n\t\t\treturn tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\t\tiskb = skb;\n\t}\n\n\tdo {\n\t\tseqno = buf_seqno(iskb);\n\t\tif (unlikely(less(seqno, l->drop_point))) {\n\t\t\tkfree_skb(iskb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(seqno != l->drop_point)) {\n\t\t\t__tipc_skb_queue_sorted(fdefq, seqno, iskb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tl->drop_point++;\n\t\tif (!tipc_data_input(l, iskb, inputq))\n\t\t\trc |= tipc_link_input(l, iskb, inputq, reasm_skb);\n\t\tif (unlikely(rc))\n\t\t\tbreak;\n\t} while ((iskb = __tipc_skb_dequeue(fdefq, l->drop_point)));\n\n\treturn rc;\n}\n\n/**\n * tipc_get_gap_ack_blks - get Gap ACK blocks from PROTOCOL/STATE_MSG\n * @ga: returned pointer to the Gap ACK blocks if any\n * @l: the tipc link\n * @hdr: the PROTOCOL/STATE_MSG header\n * @uc: desired Gap ACK blocks type, i.e. unicast (= 1) or broadcast (= 0)\n *\n * Return: the total Gap ACK blocks size\n */\nu16 tipc_get_gap_ack_blks(struct tipc_gap_ack_blks **ga, struct tipc_link *l,\n\t\t\t  struct tipc_msg *hdr, bool uc)\n{\n\tstruct tipc_gap_ack_blks *p;\n\tu16 sz = 0;\n\n\t/* Does peer support the Gap ACK blocks feature? */\n\tif (l->peer_caps & TIPC_GAP_ACK_BLOCK) {\n\t\tp = (struct tipc_gap_ack_blks *)msg_data(hdr);\n\t\tsz = ntohs(p->len);\n\t\t/* Sanity check */\n\t\tif (sz == struct_size(p, gacks, p->ugack_cnt + p->bgack_cnt)) {\n\t\t\t/* Good, check if the desired type exists */\n\t\t\tif ((uc && p->ugack_cnt) || (!uc && p->bgack_cnt))\n\t\t\t\tgoto ok;\n\t\t/* Backward compatible: peer might not support bc, but uc? */\n\t\t} else if (uc && sz == struct_size(p, gacks, p->ugack_cnt)) {\n\t\t\tif (p->ugack_cnt) {\n\t\t\t\tp->bgack_cnt = 0;\n\t\t\t\tgoto ok;\n\t\t\t}\n\t\t}\n\t}\n\t/* Other cases: ignore! */\n\tp = NULL;\n\nok:\n\t*ga = p;\n\treturn sz;\n}\n\nstatic u8 __tipc_build_gap_ack_blks(struct tipc_gap_ack_blks *ga,\n\t\t\t\t    struct tipc_link *l, u8 start_index)\n{\n\tstruct tipc_gap_ack *gacks = &ga->gacks[start_index];\n\tstruct sk_buff *skb = skb_peek(&l->deferdq);\n\tu16 expect, seqno = 0;\n\tu8 n = 0;\n\n\tif (!skb)\n\t\treturn 0;\n\n\texpect = buf_seqno(skb);\n\tskb_queue_walk(&l->deferdq, skb) {\n\t\tseqno = buf_seqno(skb);\n\t\tif (unlikely(more(seqno, expect))) {\n\t\t\tgacks[n].ack = htons(expect - 1);\n\t\t\tgacks[n].gap = htons(seqno - expect);\n\t\t\tif (++n >= MAX_GAP_ACK_BLKS / 2) {\n\t\t\t\tpr_info_ratelimited(\"Gacks on %s: %d, ql: %d!\\n\",\n\t\t\t\t\t\t    l->name, n,\n\t\t\t\t\t\t    skb_queue_len(&l->deferdq));\n\t\t\t\treturn n;\n\t\t\t}\n\t\t} else if (unlikely(less(seqno, expect))) {\n\t\t\tpr_warn(\"Unexpected skb in deferdq!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\texpect = seqno + 1;\n\t}\n\n\t/* last block */\n\tgacks[n].ack = htons(seqno);\n\tgacks[n].gap = 0;\n\tn++;\n\treturn n;\n}\n\n/* tipc_build_gap_ack_blks - build Gap ACK blocks\n * @l: tipc unicast link\n * @hdr: the tipc message buffer to store the Gap ACK blocks after built\n *\n * The function builds Gap ACK blocks for both the unicast & broadcast receiver\n * links of a certain peer, the buffer after built has the network data format\n * as found at the struct tipc_gap_ack_blks definition.\n *\n * returns the actual allocated memory size\n */\nstatic u16 tipc_build_gap_ack_blks(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tstruct tipc_link *bcl = l->bc_rcvlink;\n\tstruct tipc_gap_ack_blks *ga;\n\tu16 len;\n\n\tga = (struct tipc_gap_ack_blks *)msg_data(hdr);\n\n\t/* Start with broadcast link first */\n\ttipc_bcast_lock(bcl->net);\n\tmsg_set_bcast_ack(hdr, bcl->rcv_nxt - 1);\n\tmsg_set_bc_gap(hdr, link_bc_rcv_gap(bcl));\n\tga->bgack_cnt = __tipc_build_gap_ack_blks(ga, bcl, 0);\n\ttipc_bcast_unlock(bcl->net);\n\n\t/* Now for unicast link, but an explicit NACK only (???) */\n\tga->ugack_cnt = (msg_seq_gap(hdr)) ?\n\t\t\t__tipc_build_gap_ack_blks(ga, l, ga->bgack_cnt) : 0;\n\n\t/* Total len */\n\tlen = struct_size(ga, gacks, ga->bgack_cnt + ga->ugack_cnt);\n\tga->len = htons(len);\n\treturn len;\n}\n\n/* tipc_link_advance_transmq - advance TIPC link transmq queue by releasing\n *\t\t\t       acked packets, also doing retransmissions if\n *\t\t\t       gaps found\n * @l: tipc link with transmq queue to be advanced\n * @r: tipc link \"receiver\" i.e. in case of broadcast (= \"l\" if unicast)\n * @acked: seqno of last packet acked by peer without any gaps before\n * @gap: # of gap packets\n * @ga: buffer pointer to Gap ACK blocks from peer\n * @xmitq: queue for accumulating the retransmitted packets if any\n * @retransmitted: returned boolean value if a retransmission is really issued\n * @rc: returned code e.g. TIPC_LINK_DOWN_EVT if a repeated retransmit failures\n *      happens (- unlikely case)\n *\n * Return: the number of packets released from the link transmq\n */\nstatic int tipc_link_advance_transmq(struct tipc_link *l, struct tipc_link *r,\n\t\t\t\t     u16 acked, u16 gap,\n\t\t\t\t     struct tipc_gap_ack_blks *ga,\n\t\t\t\t     struct sk_buff_head *xmitq,\n\t\t\t\t     bool *retransmitted, int *rc)\n{\n\tstruct tipc_gap_ack_blks *last_ga = r->last_ga, *this_ga = NULL;\n\tstruct tipc_gap_ack *gacks = NULL;\n\tstruct sk_buff *skb, *_skb, *tmp;\n\tstruct tipc_msg *hdr;\n\tu32 qlen = skb_queue_len(&l->transmq);\n\tu16 nacked = acked, ngap = gap, gack_cnt = 0;\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno, n = 0;\n\tu16 end = r->acked, start = end, offset = r->last_gap;\n\tu16 si = (last_ga) ? last_ga->start_index : 0;\n\tbool is_uc = !link_is_bc_sndlink(l);\n\tbool bc_has_acked = false;\n\n\ttrace_tipc_link_retrans(r, acked + 1, acked + gap, &l->transmq);\n\n\t/* Determine Gap ACK blocks if any for the particular link */\n\tif (ga && is_uc) {\n\t\t/* Get the Gap ACKs, uc part */\n\t\tgack_cnt = ga->ugack_cnt;\n\t\tgacks = &ga->gacks[ga->bgack_cnt];\n\t} else if (ga) {\n\t\t/* Copy the Gap ACKs, bc part, for later renewal if needed */\n\t\tthis_ga = kmemdup(ga, struct_size(ga, gacks, ga->bgack_cnt),\n\t\t\t\t  GFP_ATOMIC);\n\t\tif (likely(this_ga)) {\n\t\t\tthis_ga->start_index = 0;\n\t\t\t/* Start with the bc Gap ACKs */\n\t\t\tgack_cnt = this_ga->bgack_cnt;\n\t\t\tgacks = &this_ga->gacks[0];\n\t\t} else {\n\t\t\t/* Hmm, we can get in trouble..., simply ignore it */\n\t\t\tpr_warn_ratelimited(\"Ignoring bc Gap ACKs, no memory\\n\");\n\t\t}\n\t}\n\n\t/* Advance the link transmq */\n\tskb_queue_walk_safe(&l->transmq, skb, tmp) {\n\t\tseqno = buf_seqno(skb);\n\nnext_gap_ack:\n\t\tif (less_eq(seqno, nacked)) {\n\t\t\tif (is_uc)\n\t\t\t\tgoto release;\n\t\t\t/* Skip packets peer has already acked */\n\t\t\tif (!more(seqno, r->acked))\n\t\t\t\tcontinue;\n\t\t\t/* Get the next of last Gap ACK blocks */\n\t\t\twhile (more(seqno, end)) {\n\t\t\t\tif (!last_ga || si >= last_ga->bgack_cnt)\n\t\t\t\t\tbreak;\n\t\t\t\tstart = end + offset + 1;\n\t\t\t\tend = ntohs(last_ga->gacks[si].ack);\n\t\t\t\toffset = ntohs(last_ga->gacks[si].gap);\n\t\t\t\tsi++;\n\t\t\t\tWARN_ONCE(more(start, end) ||\n\t\t\t\t\t  (!offset &&\n\t\t\t\t\t   si < last_ga->bgack_cnt) ||\n\t\t\t\t\t  si > MAX_GAP_ACK_BLKS,\n\t\t\t\t\t  \"Corrupted Gap ACK: %d %d %d %d %d\\n\",\n\t\t\t\t\t  start, end, offset, si,\n\t\t\t\t\t  last_ga->bgack_cnt);\n\t\t\t}\n\t\t\t/* Check against the last Gap ACK block */\n\t\t\tif (in_range(seqno, start, end))\n\t\t\t\tcontinue;\n\t\t\t/* Update/release the packet peer is acking */\n\t\t\tbc_has_acked = true;\n\t\t\tif (--TIPC_SKB_CB(skb)->ackers)\n\t\t\t\tcontinue;\nrelease:\n\t\t\t/* release skb */\n\t\t\t__skb_unlink(skb, &l->transmq);\n\t\t\tkfree_skb(skb);\n\t\t} else if (less_eq(seqno, nacked + ngap)) {\n\t\t\t/* First gap: check if repeated retrans failures? */\n\t\t\tif (unlikely(seqno == acked + 1 &&\n\t\t\t\t     link_retransmit_failure(l, r, rc))) {\n\t\t\t\t/* Ignore this bc Gap ACKs if any */\n\t\t\t\tkfree(this_ga);\n\t\t\t\tthis_ga = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* retransmit skb if unrestricted*/\n\t\t\tif (time_before(jiffies, TIPC_SKB_CB(skb)->nxt_retr))\n\t\t\t\tcontinue;\n\t\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\t\t\t_skb = pskb_copy(skb, GFP_ATOMIC);\n\t\t\tif (!_skb)\n\t\t\t\tcontinue;\n\t\t\thdr = buf_msg(_skb);\n\t\t\tmsg_set_ack(hdr, ack);\n\t\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\t\t_skb->priority = TC_PRIO_CONTROL;\n\t\t\t__skb_queue_tail(xmitq, _skb);\n\t\t\tl->stats.retransmitted++;\n\t\t\tif (!is_uc)\n\t\t\t\tr->stats.retransmitted++;\n\t\t\t*retransmitted = true;\n\t\t\t/* Increase actual retrans counter & mark first time */\n\t\t\tif (!TIPC_SKB_CB(skb)->retr_cnt++)\n\t\t\t\tTIPC_SKB_CB(skb)->retr_stamp = jiffies;\n\t\t} else {\n\t\t\t/* retry with Gap ACK blocks if any */\n\t\t\tif (n >= gack_cnt)\n\t\t\t\tbreak;\n\t\t\tnacked = ntohs(gacks[n].ack);\n\t\t\tngap = ntohs(gacks[n].gap);\n\t\t\tn++;\n\t\t\tgoto next_gap_ack;\n\t\t}\n\t}\n\n\t/* Renew last Gap ACK blocks for bc if needed */\n\tif (bc_has_acked) {\n\t\tif (this_ga) {\n\t\t\tkfree(last_ga);\n\t\t\tr->last_ga = this_ga;\n\t\t\tr->last_gap = gap;\n\t\t} else if (last_ga) {\n\t\t\tif (less(acked, start)) {\n\t\t\t\tsi--;\n\t\t\t\toffset = start - acked - 1;\n\t\t\t} else if (less(acked, end)) {\n\t\t\t\tacked = end;\n\t\t\t}\n\t\t\tif (si < last_ga->bgack_cnt) {\n\t\t\t\tlast_ga->start_index = si;\n\t\t\t\tr->last_gap = offset;\n\t\t\t} else {\n\t\t\t\tkfree(last_ga);\n\t\t\t\tr->last_ga = NULL;\n\t\t\t\tr->last_gap = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tr->last_gap = 0;\n\t\t}\n\t\tr->acked = acked;\n\t} else {\n\t\tkfree(this_ga);\n\t}\n\n\treturn qlen - skb_queue_len(&l->transmq);\n}\n\n/* tipc_link_build_state_msg: prepare link state message for transmission\n *\n * Note that sending of broadcast ack is coordinated among nodes, to reduce\n * risk of ack storms towards the sender\n */\nint tipc_link_build_state_msg(struct tipc_link *l, struct sk_buff_head *xmitq)\n{\n\tif (!l)\n\t\treturn 0;\n\n\t/* Broadcast ACK must be sent via a unicast link => defer to caller */\n\tif (link_is_bc_rcvlink(l)) {\n\t\tif (((l->rcv_nxt ^ tipc_own_addr(l->net)) & 0xf) != 0xf)\n\t\t\treturn 0;\n\t\tl->rcv_unacked = 0;\n\n\t\t/* Use snd_nxt to store peer's snd_nxt in broadcast rcv link */\n\t\tl->snd_nxt = l->rcv_nxt;\n\t\treturn TIPC_LINK_SND_STATE;\n\t}\n\t/* Unicast ACK */\n\tl->rcv_unacked = 0;\n\tl->stats.sent_acks++;\n\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, 0, 0, xmitq);\n\treturn 0;\n}\n\n/* tipc_link_build_reset_msg: prepare link RESET or ACTIVATE message\n */\nvoid tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq)\n{\n\tint mtyp = RESET_MSG;\n\tstruct sk_buff *skb;\n\n\tif (l->state == LINK_ESTABLISHING)\n\t\tmtyp = ACTIVATE_MSG;\n\n\ttipc_link_build_proto_msg(l, mtyp, 0, 0, 0, 0, 0, xmitq);\n\n\t/* Inform peer that this endpoint is going down if applicable */\n\tskb = skb_peek_tail(xmitq);\n\tif (skb && (l->state == LINK_RESET))\n\t\tmsg_set_peer_stopping(buf_msg(skb), 1);\n}\n\n/* tipc_link_build_nack_msg: prepare link nack message for transmission\n * Note that sending of broadcast NACK is coordinated among nodes, to\n * reduce the risk of NACK storms towards the sender\n */\nstatic int tipc_link_build_nack_msg(struct tipc_link *l,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tu32 def_cnt = ++l->stats.deferred_recv;\n\tstruct sk_buff_head *dfq = &l->deferdq;\n\tu32 defq_len = skb_queue_len(dfq);\n\tint match1, match2;\n\n\tif (link_is_bc_rcvlink(l)) {\n\t\tmatch1 = def_cnt & 0xf;\n\t\tmatch2 = tipc_own_addr(l->net) & 0xf;\n\t\tif (match1 == match2)\n\t\t\treturn TIPC_LINK_SND_STATE;\n\t\treturn 0;\n\t}\n\n\tif (defq_len >= 3 && !((defq_len - 3) % 16)) {\n\t\tu16 rcvgap = buf_seqno(skb_peek(dfq)) - l->rcv_nxt;\n\n\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0,\n\t\t\t\t\t  rcvgap, 0, 0, xmitq);\n\t}\n\treturn 0;\n}\n\n/* tipc_link_rcv - process TIPC packets/messages arriving from off-node\n * @l: the link that should handle the message\n * @skb: TIPC packet\n * @xmitq: queue to place packets to be sent after this call\n */\nint tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t  struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *defq = &l->deferdq;\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tu16 seqno, rcv_nxt, win_lim;\n\tint released = 0;\n\tint rc = 0;\n\n\t/* Verify and update link state */\n\tif (unlikely(msg_user(hdr) == LINK_PROTOCOL))\n\t\treturn tipc_link_proto_rcv(l, skb, xmitq);\n\n\t/* Don't send probe at next timeout expiration */\n\tl->silent_intv_cnt = 0;\n\n\tdo {\n\t\thdr = buf_msg(skb);\n\t\tseqno = msg_seqno(hdr);\n\t\trcv_nxt = l->rcv_nxt;\n\t\twin_lim = rcv_nxt + TIPC_MAX_LINK_WIN;\n\n\t\tif (unlikely(!link_is_up(l))) {\n\t\t\tif (l->state == LINK_ESTABLISHING)\n\t\t\t\trc = TIPC_LINK_UP_EVT;\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop if outside receive window */\n\t\tif (unlikely(less(seqno, rcv_nxt) || more(seqno, win_lim))) {\n\t\t\tl->stats.duplicates++;\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t\treleased += tipc_link_advance_transmq(l, l, msg_ack(hdr), 0,\n\t\t\t\t\t\t      NULL, NULL, NULL, NULL);\n\n\t\t/* Defer delivery if sequence gap */\n\t\tif (unlikely(seqno != rcv_nxt)) {\n\t\t\tif (!__tipc_skb_queue_sorted(defq, seqno, skb))\n\t\t\t\tl->stats.duplicates++;\n\t\t\trc |= tipc_link_build_nack_msg(l, xmitq);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Deliver packet */\n\t\tl->rcv_nxt++;\n\t\tl->stats.recv_pkts++;\n\n\t\tif (unlikely(msg_user(hdr) == TUNNEL_PROTOCOL))\n\t\t\trc |= tipc_link_tnl_rcv(l, skb, l->inputq);\n\t\telse if (!tipc_data_input(l, skb, l->inputq))\n\t\t\trc |= tipc_link_input(l, skb, l->inputq, &l->reasm_buf);\n\t\tif (unlikely(++l->rcv_unacked >= TIPC_MIN_LINK_WIN))\n\t\t\trc |= tipc_link_build_state_msg(l, xmitq);\n\t\tif (unlikely(rc & ~TIPC_LINK_SND_STATE))\n\t\t\tbreak;\n\t} while ((skb = __tipc_skb_dequeue(defq, l->rcv_nxt)));\n\n\t/* Forward queues and wake up waiting users */\n\tif (released) {\n\t\ttipc_link_update_cwin(l, released, 0);\n\t\ttipc_link_advance_backlog(l, xmitq);\n\t\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\t\tlink_prepare_wakeup(l);\n\t}\n\treturn rc;\n}\n\nstatic void tipc_link_build_proto_msg(struct tipc_link *l, int mtyp, bool probe,\n\t\t\t\t      bool probe_reply, u16 rcvgap,\n\t\t\t\t      int tolerance, int priority,\n\t\t\t\t      struct sk_buff_head *xmitq)\n{\n\tstruct tipc_mon_state *mstate = &l->mon_state;\n\tstruct sk_buff_head *dfq = &l->deferdq;\n\tstruct tipc_link *bcl = l->bc_rcvlink;\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *skb;\n\tbool node_up = link_is_up(bcl);\n\tu16 glen = 0, bc_rcvgap = 0;\n\tint dlen = 0;\n\tvoid *data;\n\n\t/* Don't send protocol message during reset or link failover */\n\tif (tipc_link_is_blocked(l))\n\t\treturn;\n\n\tif (!tipc_link_is_up(l) && (mtyp == STATE_MSG))\n\t\treturn;\n\n\tif ((probe || probe_reply) && !skb_queue_empty(dfq))\n\t\trcvgap = buf_seqno(skb_peek(dfq)) - l->rcv_nxt;\n\n\tskb = tipc_msg_create(LINK_PROTOCOL, mtyp, INT_H_SIZE,\n\t\t\t      tipc_max_domain_size + MAX_GAP_ACK_BLKS_SZ,\n\t\t\t      l->addr, tipc_own_addr(l->net), 0, 0, 0);\n\tif (!skb)\n\t\treturn;\n\n\thdr = buf_msg(skb);\n\tdata = msg_data(hdr);\n\tmsg_set_session(hdr, l->session);\n\tmsg_set_bearer_id(hdr, l->bearer_id);\n\tmsg_set_net_plane(hdr, l->net_plane);\n\tmsg_set_next_sent(hdr, l->snd_nxt);\n\tmsg_set_ack(hdr, l->rcv_nxt - 1);\n\tmsg_set_bcast_ack(hdr, bcl->rcv_nxt - 1);\n\tmsg_set_bc_ack_invalid(hdr, !node_up);\n\tmsg_set_last_bcast(hdr, l->bc_sndlink->snd_nxt - 1);\n\tmsg_set_link_tolerance(hdr, tolerance);\n\tmsg_set_linkprio(hdr, priority);\n\tmsg_set_redundant_link(hdr, node_up);\n\tmsg_set_seq_gap(hdr, 0);\n\tmsg_set_seqno(hdr, l->snd_nxt + U16_MAX / 2);\n\n\tif (mtyp == STATE_MSG) {\n\t\tif (l->peer_caps & TIPC_LINK_PROTO_SEQNO)\n\t\t\tmsg_set_seqno(hdr, l->snd_nxt_state++);\n\t\tmsg_set_seq_gap(hdr, rcvgap);\n\t\tbc_rcvgap = link_bc_rcv_gap(bcl);\n\t\tmsg_set_bc_gap(hdr, bc_rcvgap);\n\t\tmsg_set_probe(hdr, probe);\n\t\tmsg_set_is_keepalive(hdr, probe || probe_reply);\n\t\tif (l->peer_caps & TIPC_GAP_ACK_BLOCK)\n\t\t\tglen = tipc_build_gap_ack_blks(l, hdr);\n\t\ttipc_mon_prep(l->net, data + glen, &dlen, mstate, l->bearer_id);\n\t\tmsg_set_size(hdr, INT_H_SIZE + glen + dlen);\n\t\tskb_trim(skb, INT_H_SIZE + glen + dlen);\n\t\tl->stats.sent_states++;\n\t\tl->rcv_unacked = 0;\n\t} else {\n\t\t/* RESET_MSG or ACTIVATE_MSG */\n\t\tif (mtyp == ACTIVATE_MSG) {\n\t\t\tmsg_set_dest_session_valid(hdr, 1);\n\t\t\tmsg_set_dest_session(hdr, l->peer_session);\n\t\t}\n\t\tmsg_set_max_pkt(hdr, l->advertised_mtu);\n\t\tstrcpy(data, l->if_name);\n\t\tmsg_set_size(hdr, INT_H_SIZE + TIPC_MAX_IF_NAME);\n\t\tskb_trim(skb, INT_H_SIZE + TIPC_MAX_IF_NAME);\n\t}\n\tif (probe)\n\t\tl->stats.sent_probes++;\n\tif (rcvgap)\n\t\tl->stats.sent_nacks++;\n\tif (bc_rcvgap)\n\t\tbcl->stats.sent_nacks++;\n\tskb->priority = TC_PRIO_CONTROL;\n\t__skb_queue_tail(xmitq, skb);\n\ttrace_tipc_proto_build(skb, false, l->name);\n}\n\nvoid tipc_link_create_dummy_tnl_msg(struct tipc_link *l,\n\t\t\t\t    struct sk_buff_head *xmitq)\n{\n\tu32 onode = tipc_own_addr(l->net);\n\tstruct tipc_msg *hdr, *ihdr;\n\tstruct sk_buff_head tnlq;\n\tstruct sk_buff *skb;\n\tu32 dnode = l->addr;\n\n\t__skb_queue_head_init(&tnlq);\n\tskb = tipc_msg_create(TUNNEL_PROTOCOL, FAILOVER_MSG,\n\t\t\t      INT_H_SIZE, BASIC_H_SIZE,\n\t\t\t      dnode, onode, 0, 0, 0);\n\tif (!skb) {\n\t\tpr_warn(\"%sunable to create tunnel packet\\n\", link_co_err);\n\t\treturn;\n\t}\n\n\thdr = buf_msg(skb);\n\tmsg_set_msgcnt(hdr, 1);\n\tmsg_set_bearer_id(hdr, l->peer_bearer_id);\n\n\tihdr = (struct tipc_msg *)msg_data(hdr);\n\ttipc_msg_init(onode, ihdr, TIPC_LOW_IMPORTANCE, TIPC_DIRECT_MSG,\n\t\t      BASIC_H_SIZE, dnode);\n\tmsg_set_errcode(ihdr, TIPC_ERR_NO_PORT);\n\t__skb_queue_tail(&tnlq, skb);\n\ttipc_link_xmit(l, &tnlq, xmitq);\n}\n\n/* tipc_link_tnl_prepare(): prepare and return a list of tunnel packets\n * with contents of the link's transmit and backlog queues.\n */\nvoid tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,\n\t\t\t   int mtyp, struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *fdefq = &tnl->failover_deferdq;\n\tstruct sk_buff *skb, *tnlskb;\n\tstruct tipc_msg *hdr, tnlhdr;\n\tstruct sk_buff_head *queue = &l->transmq;\n\tstruct sk_buff_head tmpxq, tnlq, frags;\n\tu16 pktlen, pktcnt, seqno = l->snd_nxt;\n\tbool pktcnt_need_update = false;\n\tu16 syncpt;\n\tint rc;\n\n\tif (!tnl)\n\t\treturn;\n\n\t__skb_queue_head_init(&tnlq);\n\t/* Link Synching:\n\t * From now on, send only one single (\"dummy\") SYNCH message\n\t * to peer. The SYNCH message does not contain any data, just\n\t * a header conveying the synch point to the peer.\n\t */\n\tif (mtyp == SYNCH_MSG && (tnl->peer_caps & TIPC_TUNNEL_ENHANCED)) {\n\t\ttnlskb = tipc_msg_create(TUNNEL_PROTOCOL, SYNCH_MSG,\n\t\t\t\t\t INT_H_SIZE, 0, l->addr,\n\t\t\t\t\t tipc_own_addr(l->net),\n\t\t\t\t\t 0, 0, 0);\n\t\tif (!tnlskb) {\n\t\t\tpr_warn(\"%sunable to create dummy SYNCH_MSG\\n\",\n\t\t\t\tlink_co_err);\n\t\t\treturn;\n\t\t}\n\n\t\thdr = buf_msg(tnlskb);\n\t\tsyncpt = l->snd_nxt + skb_queue_len(&l->backlogq) - 1;\n\t\tmsg_set_syncpt(hdr, syncpt);\n\t\tmsg_set_bearer_id(hdr, l->peer_bearer_id);\n\t\t__skb_queue_tail(&tnlq, tnlskb);\n\t\ttipc_link_xmit(tnl, &tnlq, xmitq);\n\t\treturn;\n\t}\n\n\t__skb_queue_head_init(&tmpxq);\n\t__skb_queue_head_init(&frags);\n\t/* At least one packet required for safe algorithm => add dummy */\n\tskb = tipc_msg_create(TIPC_LOW_IMPORTANCE, TIPC_DIRECT_MSG,\n\t\t\t      BASIC_H_SIZE, 0, l->addr, tipc_own_addr(l->net),\n\t\t\t      0, 0, TIPC_ERR_NO_PORT);\n\tif (!skb) {\n\t\tpr_warn(\"%sunable to create tunnel packet\\n\", link_co_err);\n\t\treturn;\n\t}\n\t__skb_queue_tail(&tnlq, skb);\n\ttipc_link_xmit(l, &tnlq, &tmpxq);\n\t__skb_queue_purge(&tmpxq);\n\n\t/* Initialize reusable tunnel packet header */\n\ttipc_msg_init(tipc_own_addr(l->net), &tnlhdr, TUNNEL_PROTOCOL,\n\t\t      mtyp, INT_H_SIZE, l->addr);\n\tif (mtyp == SYNCH_MSG)\n\t\tpktcnt = l->snd_nxt - buf_seqno(skb_peek(&l->transmq));\n\telse\n\t\tpktcnt = skb_queue_len(&l->transmq);\n\tpktcnt += skb_queue_len(&l->backlogq);\n\tmsg_set_msgcnt(&tnlhdr, pktcnt);\n\tmsg_set_bearer_id(&tnlhdr, l->peer_bearer_id);\ntnl:\n\t/* Wrap each packet into a tunnel packet */\n\tskb_queue_walk(queue, skb) {\n\t\thdr = buf_msg(skb);\n\t\tif (queue == &l->backlogq)\n\t\t\tmsg_set_seqno(hdr, seqno++);\n\t\tpktlen = msg_size(hdr);\n\n\t\t/* Tunnel link MTU is not large enough? This could be\n\t\t * due to:\n\t\t * 1) Link MTU has just changed or set differently;\n\t\t * 2) Or FAILOVER on the top of a SYNCH message\n\t\t *\n\t\t * The 2nd case should not happen if peer supports\n\t\t * TIPC_TUNNEL_ENHANCED\n\t\t */\n\t\tif (pktlen > tnl->mtu - INT_H_SIZE) {\n\t\t\tif (mtyp == FAILOVER_MSG &&\n\t\t\t    (tnl->peer_caps & TIPC_TUNNEL_ENHANCED)) {\n\t\t\t\trc = tipc_msg_fragment(skb, &tnlhdr, tnl->mtu,\n\t\t\t\t\t\t       &frags);\n\t\t\t\tif (rc) {\n\t\t\t\t\tpr_warn(\"%sunable to frag msg: rc %d\\n\",\n\t\t\t\t\t\tlink_co_err, rc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpktcnt += skb_queue_len(&frags) - 1;\n\t\t\t\tpktcnt_need_update = true;\n\t\t\t\tskb_queue_splice_tail_init(&frags, &tnlq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Unluckily, peer doesn't have TIPC_TUNNEL_ENHANCED\n\t\t\t * => Just warn it and return!\n\t\t\t */\n\t\t\tpr_warn_ratelimited(\"%stoo large msg <%d, %d>: %d!\\n\",\n\t\t\t\t\t    link_co_err, msg_user(hdr),\n\t\t\t\t\t    msg_type(hdr), msg_size(hdr));\n\t\t\treturn;\n\t\t}\n\n\t\tmsg_set_size(&tnlhdr, pktlen + INT_H_SIZE);\n\t\ttnlskb = tipc_buf_acquire(pktlen + INT_H_SIZE, GFP_ATOMIC);\n\t\tif (!tnlskb) {\n\t\t\tpr_warn(\"%sunable to send packet\\n\", link_co_err);\n\t\t\treturn;\n\t\t}\n\t\tskb_copy_to_linear_data(tnlskb, &tnlhdr, INT_H_SIZE);\n\t\tskb_copy_to_linear_data_offset(tnlskb, INT_H_SIZE, hdr, pktlen);\n\t\t__skb_queue_tail(&tnlq, tnlskb);\n\t}\n\tif (queue != &l->backlogq) {\n\t\tqueue = &l->backlogq;\n\t\tgoto tnl;\n\t}\n\n\tif (pktcnt_need_update)\n\t\tskb_queue_walk(&tnlq, skb) {\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_msgcnt(hdr, pktcnt);\n\t\t}\n\n\ttipc_link_xmit(tnl, &tnlq, xmitq);\n\n\tif (mtyp == FAILOVER_MSG) {\n\t\ttnl->drop_point = l->rcv_nxt;\n\t\ttnl->failover_reasm_skb = l->reasm_buf;\n\t\tl->reasm_buf = NULL;\n\n\t\t/* Failover the link's deferdq */\n\t\tif (unlikely(!skb_queue_empty(fdefq))) {\n\t\t\tpr_warn(\"Link failover deferdq not empty: %d!\\n\",\n\t\t\t\tskb_queue_len(fdefq));\n\t\t\t__skb_queue_purge(fdefq);\n\t\t}\n\t\tskb_queue_splice_init(&l->deferdq, fdefq);\n\t}\n}\n\n/**\n * tipc_link_failover_prepare() - prepare tnl for link failover\n *\n * This is a special version of the precursor - tipc_link_tnl_prepare(),\n * see the tipc_node_link_failover() for details\n *\n * @l: failover link\n * @tnl: tunnel link\n * @xmitq: queue for messages to be xmited\n */\nvoid tipc_link_failover_prepare(struct tipc_link *l, struct tipc_link *tnl,\n\t\t\t\tstruct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *fdefq = &tnl->failover_deferdq;\n\n\ttipc_link_create_dummy_tnl_msg(tnl, xmitq);\n\n\t/* This failover link endpoint was never established before,\n\t * so it has not received anything from peer.\n\t * Otherwise, it must be a normal failover situation or the\n\t * node has entered SELF_DOWN_PEER_LEAVING and both peer nodes\n\t * would have to start over from scratch instead.\n\t */\n\ttnl->drop_point = 1;\n\ttnl->failover_reasm_skb = NULL;\n\n\t/* Initiate the link's failover deferdq */\n\tif (unlikely(!skb_queue_empty(fdefq))) {\n\t\tpr_warn(\"Link failover deferdq not empty: %d!\\n\",\n\t\t\tskb_queue_len(fdefq));\n\t\t__skb_queue_purge(fdefq);\n\t}\n}\n\n/* tipc_link_validate_msg(): validate message against current link state\n * Returns true if message should be accepted, otherwise false\n */\nbool tipc_link_validate_msg(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tu16 curr_session = l->peer_session;\n\tu16 session = msg_session(hdr);\n\tint mtyp = msg_type(hdr);\n\n\tif (msg_user(hdr) != LINK_PROTOCOL)\n\t\treturn true;\n\n\tswitch (mtyp) {\n\tcase RESET_MSG:\n\t\tif (!l->in_session)\n\t\t\treturn true;\n\t\t/* Accept only RESET with new session number */\n\t\treturn more(session, curr_session);\n\tcase ACTIVATE_MSG:\n\t\tif (!l->in_session)\n\t\t\treturn true;\n\t\t/* Accept only ACTIVATE with new or current session number */\n\t\treturn !less(session, curr_session);\n\tcase STATE_MSG:\n\t\t/* Accept only STATE with current session number */\n\t\tif (!l->in_session)\n\t\t\treturn false;\n\t\tif (session != curr_session)\n\t\t\treturn false;\n\t\t/* Extra sanity check */\n\t\tif (!link_is_up(l) && msg_ack(hdr))\n\t\t\treturn false;\n\t\tif (!(l->peer_caps & TIPC_LINK_PROTO_SEQNO))\n\t\t\treturn true;\n\t\t/* Accept only STATE with new sequence number */\n\t\treturn !less(msg_seqno(hdr), l->rcv_nxt_state);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/* tipc_link_proto_rcv(): receive link level protocol message :\n * Note that network plane id propagates through the network, and may\n * change at any time. The node with lowest numerical id determines\n * network plane\n */\nstatic int tipc_link_proto_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t       struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tstruct tipc_gap_ack_blks *ga = NULL;\n\tbool reply = msg_probe(hdr), retransmitted = false;\n\tu16 dlen = msg_data_sz(hdr), glen = 0;\n\tu16 peers_snd_nxt =  msg_next_sent(hdr);\n\tu16 peers_tol = msg_link_tolerance(hdr);\n\tu16 peers_prio = msg_linkprio(hdr);\n\tu16 gap = msg_seq_gap(hdr);\n\tu16 ack = msg_ack(hdr);\n\tu16 rcv_nxt = l->rcv_nxt;\n\tu16 rcvgap = 0;\n\tint mtyp = msg_type(hdr);\n\tint rc = 0, released;\n\tchar *if_name;\n\tvoid *data;\n\n\ttrace_tipc_proto_rcv(skb, false, l->name);\n\tif (tipc_link_is_blocked(l) || !xmitq)\n\t\tgoto exit;\n\n\tif (tipc_own_addr(l->net) > msg_prevnode(hdr))\n\t\tl->net_plane = msg_net_plane(hdr);\n\n\tskb_linearize(skb);\n\thdr = buf_msg(skb);\n\tdata = msg_data(hdr);\n\n\tif (!tipc_link_validate_msg(l, hdr)) {\n\t\ttrace_tipc_skb_dump(skb, false, \"PROTO invalid (1)!\");\n\t\ttrace_tipc_link_dump(l, TIPC_DUMP_NONE, \"PROTO invalid (1)!\");\n\t\tgoto exit;\n\t}\n\n\tswitch (mtyp) {\n\tcase RESET_MSG:\n\tcase ACTIVATE_MSG:\n\t\t/* Complete own link name with peer's interface name */\n\t\tif_name =  strrchr(l->name, ':') + 1;\n\t\tif (sizeof(l->name) - (if_name - l->name) <= TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tif (msg_data_sz(hdr) < TIPC_MAX_IF_NAME)\n\t\t\tbreak;\n\t\tstrncpy(if_name, data, TIPC_MAX_IF_NAME);\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own priority if peer's priority is higher */\n\t\tif (in_range(peers_prio, l->priority + 1, TIPC_MAX_LINK_PRI))\n\t\t\tl->priority = peers_prio;\n\n\t\t/* If peer is going down we want full re-establish cycle */\n\t\tif (msg_peer_stopping(hdr)) {\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If this endpoint was re-created while peer was ESTABLISHING\n\t\t * it doesn't know current session number. Force re-synch.\n\t\t */\n\t\tif (mtyp == ACTIVATE_MSG && msg_dest_session_valid(hdr) &&\n\t\t    l->session != msg_dest_session(hdr)) {\n\t\t\tif (less(l->session, msg_dest_session(hdr)))\n\t\t\t\tl->session = msg_dest_session(hdr) + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* ACTIVATE_MSG serves as PEER_RESET if link is already down */\n\t\tif (mtyp == RESET_MSG || !link_is_up(l))\n\t\t\trc = tipc_link_fsm_evt(l, LINK_PEER_RESET_EVT);\n\n\t\t/* ACTIVATE_MSG takes up link if it was already locally reset */\n\t\tif (mtyp == ACTIVATE_MSG && l->state == LINK_ESTABLISHING)\n\t\t\trc = TIPC_LINK_UP_EVT;\n\n\t\tl->peer_session = msg_session(hdr);\n\t\tl->in_session = true;\n\t\tl->peer_bearer_id = msg_bearer_id(hdr);\n\t\tif (l->mtu > msg_max_pkt(hdr))\n\t\t\tl->mtu = msg_max_pkt(hdr);\n\t\tbreak;\n\n\tcase STATE_MSG:\n\t\tl->rcv_nxt_state = msg_seqno(hdr) + 1;\n\n\t\t/* Update own tolerance if peer indicates a non-zero value */\n\t\tif (in_range(peers_tol, TIPC_MIN_LINK_TOL, TIPC_MAX_LINK_TOL)) {\n\t\t\tl->tolerance = peers_tol;\n\t\t\tl->bc_rcvlink->tolerance = peers_tol;\n\t\t}\n\t\t/* Update own prio if peer indicates a different value */\n\t\tif ((peers_prio != l->priority) &&\n\t\t    in_range(peers_prio, 1, TIPC_MAX_LINK_PRI)) {\n\t\t\tl->priority = peers_prio;\n\t\t\trc = tipc_link_fsm_evt(l, LINK_FAILURE_EVT);\n\t\t}\n\n\t\tl->silent_intv_cnt = 0;\n\t\tl->stats.recv_states++;\n\t\tif (msg_probe(hdr))\n\t\t\tl->stats.recv_probes++;\n\n\t\tif (!link_is_up(l)) {\n\t\t\tif (l->state == LINK_ESTABLISHING)\n\t\t\t\trc = TIPC_LINK_UP_EVT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Receive Gap ACK blocks from peer if any */\n\t\tglen = tipc_get_gap_ack_blks(&ga, l, hdr, true);\n\n\t\ttipc_mon_rcv(l->net, data + glen, dlen - glen, l->addr,\n\t\t\t     &l->mon_state, l->bearer_id);\n\n\t\t/* Send NACK if peer has sent pkts we haven't received yet */\n\t\tif ((reply || msg_is_keepalive(hdr)) &&\n\t\t    more(peers_snd_nxt, rcv_nxt) &&\n\t\t    !tipc_link_is_synching(l) &&\n\t\t    skb_queue_empty(&l->deferdq))\n\t\t\trcvgap = peers_snd_nxt - l->rcv_nxt;\n\t\tif (rcvgap || reply)\n\t\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, reply,\n\t\t\t\t\t\t  rcvgap, 0, 0, xmitq);\n\n\t\treleased = tipc_link_advance_transmq(l, l, ack, gap, ga, xmitq,\n\t\t\t\t\t\t     &retransmitted, &rc);\n\t\tif (gap)\n\t\t\tl->stats.recv_nacks++;\n\t\tif (released || retransmitted)\n\t\t\ttipc_link_update_cwin(l, released, retransmitted);\n\t\tif (released)\n\t\t\ttipc_link_advance_backlog(l, xmitq);\n\t\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\t\tlink_prepare_wakeup(l);\n\t}\nexit:\n\tkfree_skb(skb);\n\treturn rc;\n}\n\n/* tipc_link_build_bc_proto_msg() - create broadcast protocol message\n */\nstatic bool tipc_link_build_bc_proto_msg(struct tipc_link *l, bool bcast,\n\t\t\t\t\t u16 peers_snd_nxt,\n\t\t\t\t\t struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff *skb;\n\tstruct tipc_msg *hdr;\n\tstruct sk_buff *dfrd_skb = skb_peek(&l->deferdq);\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 gap_to = peers_snd_nxt - 1;\n\n\tskb = tipc_msg_create(BCAST_PROTOCOL, STATE_MSG, INT_H_SIZE,\n\t\t\t      0, l->addr, tipc_own_addr(l->net), 0, 0, 0);\n\tif (!skb)\n\t\treturn false;\n\thdr = buf_msg(skb);\n\tmsg_set_last_bcast(hdr, l->bc_sndlink->snd_nxt - 1);\n\tmsg_set_bcast_ack(hdr, ack);\n\tmsg_set_bcgap_after(hdr, ack);\n\tif (dfrd_skb)\n\t\tgap_to = buf_seqno(dfrd_skb) - 1;\n\tmsg_set_bcgap_to(hdr, gap_to);\n\tmsg_set_non_seq(hdr, bcast);\n\t__skb_queue_tail(xmitq, skb);\n\treturn true;\n}\n\n/* tipc_link_build_bc_init_msg() - synchronize broadcast link endpoints.\n *\n * Give a newly added peer node the sequence number where it should\n * start receiving and acking broadcast packets.\n */\nstatic void tipc_link_build_bc_init_msg(struct tipc_link *l,\n\t\t\t\t\tstruct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head list;\n\n\t__skb_queue_head_init(&list);\n\tif (!tipc_link_build_bc_proto_msg(l->bc_rcvlink, false, 0, &list))\n\t\treturn;\n\tmsg_set_bc_ack_invalid(buf_msg(skb_peek(&list)), true);\n\ttipc_link_xmit(l, &list, xmitq);\n}\n\n/* tipc_link_bc_init_rcv - receive initial broadcast synch data from peer\n */\nvoid tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr)\n{\n\tint mtyp = msg_type(hdr);\n\tu16 peers_snd_nxt = msg_bc_snd_nxt(hdr);\n\n\tif (link_is_up(l))\n\t\treturn;\n\n\tif (msg_user(hdr) == BCAST_PROTOCOL) {\n\t\tl->rcv_nxt = peers_snd_nxt;\n\t\tl->state = LINK_ESTABLISHED;\n\t\treturn;\n\t}\n\n\tif (l->peer_caps & TIPC_BCAST_SYNCH)\n\t\treturn;\n\n\tif (msg_peer_node_is_up(hdr))\n\t\treturn;\n\n\t/* Compatibility: accept older, less safe initial synch data */\n\tif ((mtyp == RESET_MSG) || (mtyp == ACTIVATE_MSG))\n\t\tl->rcv_nxt = peers_snd_nxt;\n}\n\n/* tipc_link_bc_sync_rcv - update rcv link according to peer's send state\n */\nint tipc_link_bc_sync_rcv(struct tipc_link *l, struct tipc_msg *hdr,\n\t\t\t  struct sk_buff_head *xmitq)\n{\n\tu16 peers_snd_nxt = msg_bc_snd_nxt(hdr);\n\tint rc = 0;\n\n\tif (!link_is_up(l))\n\t\treturn rc;\n\n\tif (!msg_peer_node_is_up(hdr))\n\t\treturn rc;\n\n\t/* Open when peer acknowledges our bcast init msg (pkt #1) */\n\tif (msg_ack(hdr))\n\t\tl->bc_peer_is_up = true;\n\n\tif (!l->bc_peer_is_up)\n\t\treturn rc;\n\n\t/* Ignore if peers_snd_nxt goes beyond receive window */\n\tif (more(peers_snd_nxt, l->rcv_nxt + l->window))\n\t\treturn rc;\n\n\tl->snd_nxt = peers_snd_nxt;\n\tif (link_bc_rcv_gap(l))\n\t\trc |= TIPC_LINK_SND_STATE;\n\n\t/* Return now if sender supports nack via STATE messages */\n\tif (l->peer_caps & TIPC_BCAST_STATE_NACK)\n\t\treturn rc;\n\n\t/* Otherwise, be backwards compatible */\n\n\tif (!more(peers_snd_nxt, l->rcv_nxt)) {\n\t\tl->nack_state = BC_NACK_SND_CONDITIONAL;\n\t\treturn 0;\n\t}\n\n\t/* Don't NACK if one was recently sent or peeked */\n\tif (l->nack_state == BC_NACK_SND_SUPPRESS) {\n\t\tl->nack_state = BC_NACK_SND_UNCONDITIONAL;\n\t\treturn 0;\n\t}\n\n\t/* Conditionally delay NACK sending until next synch rcv */\n\tif (l->nack_state == BC_NACK_SND_CONDITIONAL) {\n\t\tl->nack_state = BC_NACK_SND_UNCONDITIONAL;\n\t\tif ((peers_snd_nxt - l->rcv_nxt) < TIPC_MIN_LINK_WIN)\n\t\t\treturn 0;\n\t}\n\n\t/* Send NACK now but suppress next one */\n\ttipc_link_build_bc_proto_msg(l, true, peers_snd_nxt, xmitq);\n\tl->nack_state = BC_NACK_SND_SUPPRESS;\n\treturn 0;\n}\n\nint tipc_link_bc_ack_rcv(struct tipc_link *r, u16 acked, u16 gap,\n\t\t\t struct tipc_gap_ack_blks *ga,\n\t\t\t struct sk_buff_head *xmitq,\n\t\t\t struct sk_buff_head *retrq)\n{\n\tstruct tipc_link *l = r->bc_sndlink;\n\tbool unused = false;\n\tint rc = 0;\n\n\tif (!link_is_up(r) || !r->bc_peer_is_up)\n\t\treturn 0;\n\n\tif (gap) {\n\t\tl->stats.recv_nacks++;\n\t\tr->stats.recv_nacks++;\n\t}\n\n\tif (less(acked, r->acked) || (acked == r->acked && !gap && !ga))\n\t\treturn 0;\n\n\ttrace_tipc_link_bc_ack(r, acked, gap, &l->transmq);\n\ttipc_link_advance_transmq(l, r, acked, gap, ga, retrq, &unused, &rc);\n\n\ttipc_link_advance_backlog(l, xmitq);\n\tif (unlikely(!skb_queue_empty(&l->wakeupq)))\n\t\tlink_prepare_wakeup(l);\n\n\treturn rc;\n}\n\n/* tipc_link_bc_nack_rcv(): receive broadcast nack message\n * This function is here for backwards compatibility, since\n * no BCAST_PROTOCOL/STATE messages occur from TIPC v2.5.\n */\nint tipc_link_bc_nack_rcv(struct tipc_link *l, struct sk_buff *skb,\n\t\t\t  struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb);\n\tu32 dnode = msg_destnode(hdr);\n\tint mtyp = msg_type(hdr);\n\tu16 acked = msg_bcast_ack(hdr);\n\tu16 from = acked + 1;\n\tu16 to = msg_bcgap_to(hdr);\n\tu16 peers_snd_nxt = to + 1;\n\tint rc = 0;\n\n\tkfree_skb(skb);\n\n\tif (!tipc_link_is_up(l) || !l->bc_peer_is_up)\n\t\treturn 0;\n\n\tif (mtyp != STATE_MSG)\n\t\treturn 0;\n\n\tif (dnode == tipc_own_addr(l->net)) {\n\t\trc = tipc_link_bc_ack_rcv(l, acked, to - acked, NULL, xmitq,\n\t\t\t\t\t  xmitq);\n\t\tl->stats.recv_nacks++;\n\t\treturn rc;\n\t}\n\n\t/* Msg for other node => suppress own NACK at next sync if applicable */\n\tif (more(peers_snd_nxt, l->rcv_nxt) && !less(l->rcv_nxt, from))\n\t\tl->nack_state = BC_NACK_SND_SUPPRESS;\n\n\treturn 0;\n}\n\nvoid tipc_link_set_queue_limits(struct tipc_link *l, u32 min_win, u32 max_win)\n{\n\tint max_bulk = TIPC_MAX_PUBL / (l->mtu / ITEM_SIZE);\n\n\tl->min_win = min_win;\n\tl->ssthresh = max_win;\n\tl->max_win = max_win;\n\tl->window = min_win;\n\tl->backlog[TIPC_LOW_IMPORTANCE].limit      = min_win * 2;\n\tl->backlog[TIPC_MEDIUM_IMPORTANCE].limit   = min_win * 4;\n\tl->backlog[TIPC_HIGH_IMPORTANCE].limit     = min_win * 6;\n\tl->backlog[TIPC_CRITICAL_IMPORTANCE].limit = min_win * 8;\n\tl->backlog[TIPC_SYSTEM_IMPORTANCE].limit   = max_bulk;\n}\n\n/**\n * link_reset_stats - reset link statistics\n * @l: pointer to link\n */\nvoid tipc_link_reset_stats(struct tipc_link *l)\n{\n\tmemset(&l->stats, 0, sizeof(l->stats));\n}\n\nstatic void link_print(struct tipc_link *l, const char *str)\n{\n\tstruct sk_buff *hskb = skb_peek(&l->transmq);\n\tu16 head = hskb ? msg_seqno(buf_msg(hskb)) : l->snd_nxt - 1;\n\tu16 tail = l->snd_nxt - 1;\n\n\tpr_info(\"%s Link <%s> state %x\\n\", str, l->name, l->state);\n\tpr_info(\"XMTQ: %u [%u-%u], BKLGQ: %u, SNDNX: %u, RCVNX: %u\\n\",\n\t\tskb_queue_len(&l->transmq), head, tail,\n\t\tskb_queue_len(&l->backlogq), l->snd_nxt, l->rcv_nxt);\n}\n\n/* Parse and validate nested (link) properties valid for media, bearer and link\n */\nint tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[])\n{\n\tint err;\n\n\terr = nla_parse_nested_deprecated(props, TIPC_NLA_PROP_MAX, prop,\n\t\t\t\t\t  tipc_nl_prop_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (props[TIPC_NLA_PROP_PRIO]) {\n\t\tu32 prio;\n\n\t\tprio = nla_get_u32(props[TIPC_NLA_PROP_PRIO]);\n\t\tif (prio > TIPC_MAX_LINK_PRI)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (props[TIPC_NLA_PROP_TOL]) {\n\t\tu32 tol;\n\n\t\ttol = nla_get_u32(props[TIPC_NLA_PROP_TOL]);\n\t\tif ((tol < TIPC_MIN_LINK_TOL) || (tol > TIPC_MAX_LINK_TOL))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (props[TIPC_NLA_PROP_WIN]) {\n\t\tu32 max_win;\n\n\t\tmax_win = nla_get_u32(props[TIPC_NLA_PROP_WIN]);\n\t\tif (max_win < TIPC_DEF_LINK_WIN || max_win > TIPC_MAX_LINK_WIN)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __tipc_nl_add_stats(struct sk_buff *skb, struct tipc_stats *s)\n{\n\tint i;\n\tstruct nlattr *stats;\n\n\tstruct nla_map {\n\t\tu32 key;\n\t\tu32 val;\n\t};\n\n\tstruct nla_map map[] = {\n\t\t{TIPC_NLA_STATS_RX_INFO, 0},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTS, s->recv_fragments},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTED, s->recv_fragmented},\n\t\t{TIPC_NLA_STATS_RX_BUNDLES, s->recv_bundles},\n\t\t{TIPC_NLA_STATS_RX_BUNDLED, s->recv_bundled},\n\t\t{TIPC_NLA_STATS_TX_INFO, 0},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTS, s->sent_fragments},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTED, s->sent_fragmented},\n\t\t{TIPC_NLA_STATS_TX_BUNDLES, s->sent_bundles},\n\t\t{TIPC_NLA_STATS_TX_BUNDLED, s->sent_bundled},\n\t\t{TIPC_NLA_STATS_MSG_PROF_TOT, (s->msg_length_counts) ?\n\t\t\ts->msg_length_counts : 1},\n\t\t{TIPC_NLA_STATS_MSG_LEN_CNT, s->msg_length_counts},\n\t\t{TIPC_NLA_STATS_MSG_LEN_TOT, s->msg_lengths_total},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P0, s->msg_length_profile[0]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P1, s->msg_length_profile[1]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P2, s->msg_length_profile[2]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P3, s->msg_length_profile[3]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P4, s->msg_length_profile[4]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P5, s->msg_length_profile[5]},\n\t\t{TIPC_NLA_STATS_MSG_LEN_P6, s->msg_length_profile[6]},\n\t\t{TIPC_NLA_STATS_RX_STATES, s->recv_states},\n\t\t{TIPC_NLA_STATS_RX_PROBES, s->recv_probes},\n\t\t{TIPC_NLA_STATS_RX_NACKS, s->recv_nacks},\n\t\t{TIPC_NLA_STATS_RX_DEFERRED, s->deferred_recv},\n\t\t{TIPC_NLA_STATS_TX_STATES, s->sent_states},\n\t\t{TIPC_NLA_STATS_TX_PROBES, s->sent_probes},\n\t\t{TIPC_NLA_STATS_TX_NACKS, s->sent_nacks},\n\t\t{TIPC_NLA_STATS_TX_ACKS, s->sent_acks},\n\t\t{TIPC_NLA_STATS_RETRANSMITTED, s->retransmitted},\n\t\t{TIPC_NLA_STATS_DUPLICATES, s->duplicates},\n\t\t{TIPC_NLA_STATS_LINK_CONGS, s->link_congs},\n\t\t{TIPC_NLA_STATS_MAX_QUEUE, s->max_queue_sz},\n\t\t{TIPC_NLA_STATS_AVG_QUEUE, s->queue_sz_counts ?\n\t\t\t(s->accu_queue_sz / s->queue_sz_counts) : 0}\n\t};\n\n\tstats = nla_nest_start_noflag(skb, TIPC_NLA_LINK_STATS);\n\tif (!stats)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i <  ARRAY_SIZE(map); i++)\n\t\tif (nla_put_u32(skb, map[i].key, map[i].val))\n\t\t\tgoto msg_full;\n\n\tnla_nest_end(skb, stats);\n\n\treturn 0;\nmsg_full:\n\tnla_nest_cancel(skb, stats);\n\n\treturn -EMSGSIZE;\n}\n\n/* Caller should hold appropriate locks to protect the link */\nint __tipc_nl_add_link(struct net *net, struct tipc_nl_msg *msg,\n\t\t       struct tipc_link *link, int nlflags)\n{\n\tu32 self = tipc_own_addr(net);\n\tstruct nlattr *attrs;\n\tstruct nlattr *prop;\n\tvoid *hdr;\n\tint err;\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  nlflags, TIPC_NL_LINK_GET);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\tif (nla_put_string(msg->skb, TIPC_NLA_LINK_NAME, link->name))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_DEST, tipc_cluster_mask(self)))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_MTU, link->mtu))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_RX, link->stats.recv_pkts))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_TX, link->stats.sent_pkts))\n\t\tgoto attr_msg_full;\n\n\tif (tipc_link_is_up(link))\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_UP))\n\t\t\tgoto attr_msg_full;\n\tif (link->active)\n\t\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_ACTIVE))\n\t\t\tgoto attr_msg_full;\n\n\tprop = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK_PROP);\n\tif (!prop)\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, link->priority))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_TOL, link->tolerance))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN,\n\t\t\tlink->window))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_PRIO, link->priority))\n\t\tgoto prop_msg_full;\n\tnla_nest_end(msg->skb, prop);\n\n\terr = __tipc_nl_add_stats(msg->skb, &link->stats);\n\tif (err)\n\t\tgoto attr_msg_full;\n\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nprop_msg_full:\n\tnla_nest_cancel(msg->skb, prop);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nstatic int __tipc_nl_add_bc_link_stat(struct sk_buff *skb,\n\t\t\t\t      struct tipc_stats *stats)\n{\n\tint i;\n\tstruct nlattr *nest;\n\n\tstruct nla_map {\n\t\t__u32 key;\n\t\t__u32 val;\n\t};\n\n\tstruct nla_map map[] = {\n\t\t{TIPC_NLA_STATS_RX_INFO, stats->recv_pkts},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTS, stats->recv_fragments},\n\t\t{TIPC_NLA_STATS_RX_FRAGMENTED, stats->recv_fragmented},\n\t\t{TIPC_NLA_STATS_RX_BUNDLES, stats->recv_bundles},\n\t\t{TIPC_NLA_STATS_RX_BUNDLED, stats->recv_bundled},\n\t\t{TIPC_NLA_STATS_TX_INFO, stats->sent_pkts},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTS, stats->sent_fragments},\n\t\t{TIPC_NLA_STATS_TX_FRAGMENTED, stats->sent_fragmented},\n\t\t{TIPC_NLA_STATS_TX_BUNDLES, stats->sent_bundles},\n\t\t{TIPC_NLA_STATS_TX_BUNDLED, stats->sent_bundled},\n\t\t{TIPC_NLA_STATS_RX_NACKS, stats->recv_nacks},\n\t\t{TIPC_NLA_STATS_RX_DEFERRED, stats->deferred_recv},\n\t\t{TIPC_NLA_STATS_TX_NACKS, stats->sent_nacks},\n\t\t{TIPC_NLA_STATS_TX_ACKS, stats->sent_acks},\n\t\t{TIPC_NLA_STATS_RETRANSMITTED, stats->retransmitted},\n\t\t{TIPC_NLA_STATS_DUPLICATES, stats->duplicates},\n\t\t{TIPC_NLA_STATS_LINK_CONGS, stats->link_congs},\n\t\t{TIPC_NLA_STATS_MAX_QUEUE, stats->max_queue_sz},\n\t\t{TIPC_NLA_STATS_AVG_QUEUE, stats->queue_sz_counts ?\n\t\t\t(stats->accu_queue_sz / stats->queue_sz_counts) : 0}\n\t};\n\n\tnest = nla_nest_start_noflag(skb, TIPC_NLA_LINK_STATS);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tfor (i = 0; i <  ARRAY_SIZE(map); i++)\n\t\tif (nla_put_u32(skb, map[i].key, map[i].val))\n\t\t\tgoto msg_full;\n\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\nmsg_full:\n\tnla_nest_cancel(skb, nest);\n\n\treturn -EMSGSIZE;\n}\n\nint tipc_nl_add_bc_link(struct net *net, struct tipc_nl_msg *msg,\n\t\t\tstruct tipc_link *bcl)\n{\n\tint err;\n\tvoid *hdr;\n\tstruct nlattr *attrs;\n\tstruct nlattr *prop;\n\tu32 bc_mode = tipc_bcast_get_mode(net);\n\tu32 bc_ratio = tipc_bcast_get_broadcast_ratio(net);\n\n\tif (!bcl)\n\t\treturn 0;\n\n\ttipc_bcast_lock(net);\n\n\thdr = genlmsg_put(msg->skb, msg->portid, msg->seq, &tipc_genl_family,\n\t\t\t  NLM_F_MULTI, TIPC_NL_LINK_GET);\n\tif (!hdr) {\n\t\ttipc_bcast_unlock(net);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tattrs = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK);\n\tif (!attrs)\n\t\tgoto msg_full;\n\n\t/* The broadcast link is always up */\n\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_UP))\n\t\tgoto attr_msg_full;\n\n\tif (nla_put_flag(msg->skb, TIPC_NLA_LINK_BROADCAST))\n\t\tgoto attr_msg_full;\n\tif (nla_put_string(msg->skb, TIPC_NLA_LINK_NAME, bcl->name))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_RX, 0))\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_LINK_TX, 0))\n\t\tgoto attr_msg_full;\n\n\tprop = nla_nest_start_noflag(msg->skb, TIPC_NLA_LINK_PROP);\n\tif (!prop)\n\t\tgoto attr_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_WIN, bcl->max_win))\n\t\tgoto prop_msg_full;\n\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_BROADCAST, bc_mode))\n\t\tgoto prop_msg_full;\n\tif (bc_mode & BCLINK_MODE_SEL)\n\t\tif (nla_put_u32(msg->skb, TIPC_NLA_PROP_BROADCAST_RATIO,\n\t\t\t\tbc_ratio))\n\t\t\tgoto prop_msg_full;\n\tnla_nest_end(msg->skb, prop);\n\n\terr = __tipc_nl_add_bc_link_stat(msg->skb, &bcl->stats);\n\tif (err)\n\t\tgoto attr_msg_full;\n\n\ttipc_bcast_unlock(net);\n\tnla_nest_end(msg->skb, attrs);\n\tgenlmsg_end(msg->skb, hdr);\n\n\treturn 0;\n\nprop_msg_full:\n\tnla_nest_cancel(msg->skb, prop);\nattr_msg_full:\n\tnla_nest_cancel(msg->skb, attrs);\nmsg_full:\n\ttipc_bcast_unlock(net);\n\tgenlmsg_cancel(msg->skb, hdr);\n\n\treturn -EMSGSIZE;\n}\n\nvoid tipc_link_set_tolerance(struct tipc_link *l, u32 tol,\n\t\t\t     struct sk_buff_head *xmitq)\n{\n\tl->tolerance = tol;\n\tif (l->bc_rcvlink)\n\t\tl->bc_rcvlink->tolerance = tol;\n\tif (link_is_up(l))\n\t\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, tol, 0, xmitq);\n}\n\nvoid tipc_link_set_prio(struct tipc_link *l, u32 prio,\n\t\t\tstruct sk_buff_head *xmitq)\n{\n\tl->priority = prio;\n\ttipc_link_build_proto_msg(l, STATE_MSG, 0, 0, 0, 0, prio, xmitq);\n}\n\nvoid tipc_link_set_abort_limit(struct tipc_link *l, u32 limit)\n{\n\tl->abort_limit = limit;\n}\n\n/**\n * tipc_link_dump - dump TIPC link data\n * @l: tipc link to be dumped\n * @dqueues: bitmask to decide if any link queue to be dumped?\n *           - TIPC_DUMP_NONE: don't dump link queues\n *           - TIPC_DUMP_TRANSMQ: dump link transmq queue\n *           - TIPC_DUMP_BACKLOGQ: dump link backlog queue\n *           - TIPC_DUMP_DEFERDQ: dump link deferd queue\n *           - TIPC_DUMP_INPUTQ: dump link input queue\n *           - TIPC_DUMP_WAKEUP: dump link wakeup queue\n *           - TIPC_DUMP_ALL: dump all the link queues above\n * @buf: returned buffer of dump data in format\n */\nint tipc_link_dump(struct tipc_link *l, u16 dqueues, char *buf)\n{\n\tint i = 0;\n\tsize_t sz = (dqueues) ? LINK_LMAX : LINK_LMIN;\n\tstruct sk_buff_head *list;\n\tstruct sk_buff *hskb, *tskb;\n\tu32 len;\n\n\tif (!l) {\n\t\ti += scnprintf(buf, sz, \"link data: (null)\\n\");\n\t\treturn i;\n\t}\n\n\ti += scnprintf(buf, sz, \"link data: %x\", l->addr);\n\ti += scnprintf(buf + i, sz - i, \" %x\", l->state);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->in_session);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->session);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->peer_session);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->snd_nxt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->rcv_nxt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->snd_nxt_state);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->rcv_nxt_state);\n\ti += scnprintf(buf + i, sz - i, \" %x\", l->peer_caps);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->silent_intv_cnt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->rst_cnt);\n\ti += scnprintf(buf + i, sz - i, \" %u\", 0);\n\ti += scnprintf(buf + i, sz - i, \" %u\", 0);\n\ti += scnprintf(buf + i, sz - i, \" %u\", l->acked);\n\n\tlist = &l->transmq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tlist = &l->deferdq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tlist = &l->backlogq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tlist = l->inputq;\n\tlen = skb_queue_len(list);\n\thskb = skb_peek(list);\n\ttskb = skb_peek_tail(list);\n\ti += scnprintf(buf + i, sz - i, \" | %u %u %u\\n\", len,\n\t\t       (hskb) ? msg_seqno(buf_msg(hskb)) : 0,\n\t\t       (tskb) ? msg_seqno(buf_msg(tskb)) : 0);\n\n\tif (dqueues & TIPC_DUMP_TRANSMQ) {\n\t\ti += scnprintf(buf + i, sz - i, \"transmq: \");\n\t\ti += tipc_list_dump(&l->transmq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_BACKLOGQ) {\n\t\ti += scnprintf(buf + i, sz - i,\n\t\t\t       \"backlogq: <%u %u %u %u %u>, \",\n\t\t\t       l->backlog[TIPC_LOW_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_MEDIUM_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_HIGH_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_CRITICAL_IMPORTANCE].len,\n\t\t\t       l->backlog[TIPC_SYSTEM_IMPORTANCE].len);\n\t\ti += tipc_list_dump(&l->backlogq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_DEFERDQ) {\n\t\ti += scnprintf(buf + i, sz - i, \"deferdq: \");\n\t\ti += tipc_list_dump(&l->deferdq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_INPUTQ) {\n\t\ti += scnprintf(buf + i, sz - i, \"inputq: \");\n\t\ti += tipc_list_dump(l->inputq, false, buf + i);\n\t}\n\tif (dqueues & TIPC_DUMP_WAKEUP) {\n\t\ti += scnprintf(buf + i, sz - i, \"wakeup: \");\n\t\ti += tipc_list_dump(&l->wakeupq, false, buf + i);\n\t}\n\n\treturn i;\n}\n"], "filenames": ["net/tipc/link.c"], "buggy_code_start_loc": [1033], "buggy_code_end_loc": [1055], "fixing_code_start_loc": [1032], "fixing_code_end_loc": [1061], "type": "NVD-CWE-Other", "message": "A remote denial of service vulnerability was found in the Linux kernel\u2019s TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state while attempting to parse SKBs, which are not in the queue. Sending two small UDP packets to a system with a UDP bearer results in the CPU utilization for the system to instantly spike to 100%, causing a denial of service condition.", "other": {"cve": {"id": "CVE-2023-1390", "sourceIdentifier": "secalert@redhat.com", "published": "2023-03-16T21:15:11.447", "lastModified": "2023-06-07T12:46:27.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A remote denial of service vulnerability was found in the Linux kernel\u2019s TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state while attempting to parse SKBs, which are not in the queue. Sending two small UDP packets to a system with a UDP bearer results in the CPU utilization for the system to instantly spike to 100%, causing a denial of service condition."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1050"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3", "versionEndExcluding": "4.9.253", "matchCriteriaId": "AF22C9B4-BCE0-4E42-8C4C-5DAE22C582DE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.217", "matchCriteriaId": "D777E229-ADCF-4C7F-A9F7-B2382137F407"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.170", "matchCriteriaId": "671B1493-DB61-421B-B0A9-893B3A862EB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.92", "matchCriteriaId": "2F6DB7A0-9052-479E-894D-15F862F4D3BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.10", "matchCriteriaId": "AAA1C6A6-3B03-4EC3-935C-C9FA0B50DB70"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.11:rc1:*:*:*:*:*:*", "matchCriteriaId": "18B1C9CE-F7E4-426B-A770-79F86AB5CC38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.11:rc2:*:*:*:*:*:*", "matchCriteriaId": "7A70E596-2EF7-4651-B2EF-2CEE31DB6893"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:5.11:rc3:*:*:*:*:*:*", "matchCriteriaId": "18C82C96-2853-4DFE-93AD-F6E59B4129CA"}]}]}], "references": [{"url": "https://gist.github.com/netspooky/bee2d07022f6350bb88eaa48e571d9b5", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b77413446408fdd256599daf00d5be72b5f3e7c6", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://infosec.exchange/@_mattata/109427999461122360", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230420-0001/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/b77413446408fdd256599daf00d5be72b5f3e7c6"}}