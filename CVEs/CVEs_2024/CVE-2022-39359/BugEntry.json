{"buggy_code": ["(ns metabase.api.geojson\n  (:require [clojure.java.io :as io]\n            [compojure.core :refer [GET]]\n            [metabase.api.common :as api]\n            [metabase.api.common.validation :as validation]\n            [metabase.models.setting :as setting :refer [defsetting]]\n            [metabase.util.i18n :refer [deferred-tru tru]]\n            [metabase.util.schema :as su]\n            [ring.util.codec :as codec]\n            [ring.util.response :as response]\n            [schema.core :as s])\n  (:import [java.net InetAddress URL]\n           org.apache.commons.io.input.ReaderInputStream))\n\n(defsetting custom-geojson-enabled\n  (deferred-tru \"Whether or not the use of custom GeoJSON is enabled.\")\n  :visibility :admin\n  :type       :boolean\n  :setter     :none\n  :default    true)\n\n(def ^:private CustomGeoJSON\n  {s/Keyword {:name                     su/NonBlankString\n              :url                      su/NonBlankString\n              :region_key               (s/maybe s/Str)\n              :region_name              (s/maybe s/Str)\n              (s/optional-key :builtin) s/Bool}})\n\n(def ^:private builtin-geojson\n  {:us_states       {:name        \"United States\"\n                     :url         \"app/assets/geojson/us-states.json\"\n                     :region_key  \"STATE\"\n                     :region_name \"NAME\"\n                     :builtin     true}\n   :world_countries {:name        \"World\"\n                     :url         \"app/assets/geojson/world.json\"\n                     :region_key  \"ISO_A2\"\n                     :region_name \"NAME\"\n                     :builtin     true}})\n\n(defn-  invalid-location-msg []\n  (str (tru \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to a file on the classpath.\")\n       \" \"\n       (tru \"URLs referring to hosts that supply internal hosting metadata are prohibited.\")))\n\n(def ^:private invalid-hosts\n  #{\"metadata.google.internal\"}) ; internal metadata for GCP\n\n(defn- valid-host?\n  [^URL url]\n  (let [host (.getHost url)\n        host->url (fn [host] (URL. (str \"http://\" host)))\n        base-url  (host->url (.getHost url))]\n    (and (not-any? (fn [invalid-url] (.equals ^URL base-url invalid-url))\n                   (map host->url invalid-hosts))\n         (not (.isLinkLocalAddress (InetAddress/getByName host))))))\n\n(defn- valid-protocol?\n  [^URL url]\n  (#{\"http\" \"https\"} (.getProtocol url)))\n\n(defn- valid-url?\n  [url-string]\n  (try\n    (let [url (URL. url-string)]\n      (and (valid-protocol? url)\n           (valid-host? url)))\n    (catch Throwable e\n      (throw (ex-info (invalid-location-msg) {:status-code 400, :url url-string} e)))))\n\n(defn- valid-geojson-url?\n  [url]\n  (or (io/resource url)\n      (valid-url? url)))\n\n(defn- valid-geojson-urls?\n  [geojson]\n  (every? (fn [[_ {:keys [url]}]] (valid-geojson-url? url))\n          geojson))\n\n(defn- validate-geojson\n  \"Throws a 400 if the supplied `geojson` is poorly structured or has an illegal URL/path\"\n  [geojson]\n  (try\n    (s/validate CustomGeoJSON geojson)\n    (catch Throwable e\n      (throw (ex-info (tru \"Invalid custom GeoJSON\") {:status-code 400} e))))\n  (or (valid-geojson-urls? geojson)\n      (throw (ex-info (invalid-location-msg) {:status-code 400}))))\n\n(defsetting custom-geojson\n  (deferred-tru \"JSON containing information about custom GeoJSON files for use in map visualizations instead of the default US State or World GeoJSON.\")\n  :type    :json\n  :default {}\n  :getter  (fn [] (merge (setting/get-value-of-type :json :custom-geojson) builtin-geojson))\n  :setter  (fn [new-value]\n             ;; remove the built-in keys you can't override them and we don't want those to be subject to validation.\n             (let [new-value (not-empty (reduce dissoc new-value (keys builtin-geojson)))]\n               (when new-value\n                 (validate-geojson new-value))\n               (setting/set-value-of-type! :json :custom-geojson new-value)))\n  :visibility :public)\n\n(api/defendpoint-async GET \"/:key\"\n  \"Fetch a custom GeoJSON file as defined in the `custom-geojson` setting. (This just acts as a simple proxy for the\n  file specified for `key`).\"\n  [{{:keys [key]} :params} respond raise]\n  {key su/NonBlankString}\n  (when-not (or (custom-geojson-enabled) (builtin-geojson (keyword key)))\n    (raise (ex-info (tru \"Custom GeoJSON is not enabled\") {:status-code 400})))\n  (if-let [url (get-in (custom-geojson) [(keyword key) :url])]\n    (try\n      (with-open [reader (io/reader (or (io/resource url)\n                                        url))\n                  is     (ReaderInputStream. reader)]\n        (respond (-> (response/response is)\n                     (response/content-type \"application/json\"))))\n      (catch Throwable _e\n        (raise (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))\n    (raise (ex-info (tru \"Invalid custom GeoJSON key: {0}\" key) {:status-code 400}))))\n\n(api/defendpoint-async GET \"/\"\n  \"Load a custom GeoJSON file based on a URL or file path provided as a query parameter.\n  This behaves similarly to /api/geojson/:key but doesn't require the custom map to be saved to the DB first.\"\n  [{{:keys [url]} :params} respond raise]\n  {url su/NonBlankString}\n  (validation/check-has-application-permission :setting)\n  (when-not (custom-geojson-enabled)\n    (raise (ex-info (tru \"Custom GeoJSON is not enabled\") {:status-code 400})))\n  (let [decoded-url (codec/url-decode url)]\n    (try\n      (when-not (valid-geojson-url? decoded-url)\n        (throw (ex-info (invalid-location-msg) {:status-code 400})))\n      (try\n        (with-open [reader (io/reader (or (io/resource decoded-url)\n                                          decoded-url))\n                    is     (ReaderInputStream. reader)]\n          (respond (-> (response/response is)\n                       (response/content-type \"application/json\"))))\n        (catch Throwable _\n          (throw (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))\n      (catch Throwable e\n        (raise e)))))\n\n(api/define-routes)\n"], "fixing_code": ["(ns metabase.api.geojson\n  (:require [clj-http.client :as http]\n            [clojure.java.io :as io]\n            [compojure.core :refer [GET]]\n            [metabase.api.common :as api]\n            [metabase.api.common.validation :as validation]\n            [metabase.models.setting :as setting :refer [defsetting]]\n            [metabase.util.i18n :refer [deferred-tru tru]]\n            [metabase.util.schema :as su]\n            [ring.util.codec :as codec]\n            [ring.util.response :as response]\n            [schema.core :as s])\n  (:import java.io.BufferedReader\n           [java.net InetAddress URL]\n           org.apache.commons.io.input.ReaderInputStream))\n\n(defsetting custom-geojson-enabled\n  (deferred-tru \"Whether or not the use of custom GeoJSON is enabled.\")\n  :visibility :admin\n  :type       :boolean\n  :setter     :none\n  :default    true)\n\n(def ^:private CustomGeoJSON\n  {s/Keyword {:name                     su/NonBlankString\n              :url                      su/NonBlankString\n              :region_key               (s/maybe s/Str)\n              :region_name              (s/maybe s/Str)\n              (s/optional-key :builtin) s/Bool}})\n\n(def ^:private builtin-geojson\n  {:us_states       {:name        \"United States\"\n                     :url         \"app/assets/geojson/us-states.json\"\n                     :region_key  \"STATE\"\n                     :region_name \"NAME\"\n                     :builtin     true}\n   :world_countries {:name        \"World\"\n                     :url         \"app/assets/geojson/world.json\"\n                     :region_key  \"ISO_A2\"\n                     :region_name \"NAME\"\n                     :builtin     true}})\n\n(defn-  invalid-location-msg []\n  (str (tru \"Invalid GeoJSON file location: must either start with http:// or https:// or be a relative path to a file on the classpath.\")\n       \" \"\n       (tru \"URLs referring to hosts that supply internal hosting metadata are prohibited.\")))\n\n(def ^:private invalid-hosts\n  #{\"metadata.google.internal\"}) ; internal metadata for GCP\n\n(defn- valid-host?\n  [^URL url]\n  (let [host (.getHost url)\n        host->url (fn [host] (URL. (str \"http://\" host)))\n        base-url  (host->url (.getHost url))]\n    (and (not-any? (fn [invalid-url] (.equals ^URL base-url invalid-url))\n                   (map host->url invalid-hosts))\n         (not (.isLinkLocalAddress (InetAddress/getByName host))))))\n\n(defn- valid-protocol?\n  [^URL url]\n  (#{\"http\" \"https\"} (.getProtocol url)))\n\n(defn- valid-url?\n  [url-string]\n  (try\n    (let [url (URL. url-string)]\n      (and (valid-protocol? url)\n           (valid-host? url)))\n    (catch Throwable e\n      (throw (ex-info (invalid-location-msg) {:status-code 400, :url url-string} e)))))\n\n(defn- valid-geojson-url?\n  [url]\n  (or (io/resource url)\n      (valid-url? url)))\n\n(defn- valid-geojson-urls?\n  [geojson]\n  (every? (fn [[_ {:keys [url]}]] (valid-geojson-url? url))\n          geojson))\n\n(defn- validate-geojson\n  \"Throws a 400 if the supplied `geojson` is poorly structured or has an illegal URL/path\"\n  [geojson]\n  (try\n    (s/validate CustomGeoJSON geojson)\n    (catch Throwable e\n      (throw (ex-info (tru \"Invalid custom GeoJSON\") {:status-code 400} e))))\n  (or (valid-geojson-urls? geojson)\n      (throw (ex-info (invalid-location-msg) {:status-code 400}))))\n\n(defsetting custom-geojson\n  (deferred-tru \"JSON containing information about custom GeoJSON files for use in map visualizations instead of the default US State or World GeoJSON.\")\n  :type    :json\n  :default {}\n  :getter  (fn [] (merge (setting/get-value-of-type :json :custom-geojson) builtin-geojson))\n  :setter  (fn [new-value]\n             ;; remove the built-in keys you can't override them and we don't want those to be subject to validation.\n             (let [new-value (not-empty (reduce dissoc new-value (keys builtin-geojson)))]\n               (when new-value\n                 (validate-geojson new-value))\n               (setting/set-value-of-type! :json :custom-geojson new-value)))\n  :visibility :public)\n\n(defn- read-url-and-respond\n  \"Reads the provided URL and responds with the contents as a stream.\"\n  [url respond]\n  (with-open [^BufferedReader reader (if-let [resource (io/resource url)]\n                                       (io/reader resource)\n                                       (:body (http/get url {:as                :reader\n                                                             :redirect-strategy :none})))\n              is                     (ReaderInputStream. reader)]\n    (respond (-> (response/response is)\n                 (response/content-type \"application/json\")))))\n\n(api/defendpoint-async GET \"/:key\"\n  \"Fetch a custom GeoJSON file as defined in the `custom-geojson` setting. (This just acts as a simple proxy for the\n  file specified for `key`).\"\n  [{{:keys [key]} :params} respond raise]\n  {key su/NonBlankString}\n  (when-not (or (custom-geojson-enabled) (builtin-geojson (keyword key)))\n    (raise (ex-info (tru \"Custom GeoJSON is not enabled\") {:status-code 400})))\n  (if-let [url (get-in (custom-geojson) [(keyword key) :url])]\n    (try\n      (read-url-and-respond url respond)\n      (catch Throwable _e\n        (raise (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))\n    (raise (ex-info (tru \"Invalid custom GeoJSON key: {0}\" key) {:status-code 400}))))\n\n(api/defendpoint-async GET \"/\"\n  \"Load a custom GeoJSON file based on a URL or file path provided as a query parameter.\n  This behaves similarly to /api/geojson/:key but doesn't require the custom map to be saved to the DB first.\"\n  [{{:keys [url]} :params} respond raise]\n  {url su/NonBlankString}\n  (validation/check-has-application-permission :setting)\n  (when-not (custom-geojson-enabled)\n    (raise (ex-info (tru \"Custom GeoJSON is not enabled\") {:status-code 400})))\n  (let [decoded-url (codec/url-decode url)]\n    (try\n      (when-not (valid-geojson-url? decoded-url)\n        (throw (ex-info (invalid-location-msg) {:status-code 400})))\n      (try\n        (read-url-and-respond decoded-url respond)\n        (catch Throwable _\n          (throw (ex-info (tru \"GeoJSON URL failed to load\") {:status-code 400}))))\n      (catch Throwable e\n        (raise e)))))\n\n(api/define-routes)\n"], "filenames": ["src/metabase/api/geojson.clj"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [140], "fixing_code_start_loc": [2], "fixing_code_end_loc": [145], "type": "CWE-601", "message": "Metabase is data visualization software. Prior to versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9, custom GeoJSON map URL address would follow redirects to addresses that were otherwise disallowed, like link-local or private-network. This issue is patched in versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9. Metabase no longer follow redirects on GeoJSON map URLs. An environment variable `MB_CUSTOM_GEOJSON_ENABLED` was also added to disable custom GeoJSON completely (`true` by default).", "other": {"cve": {"id": "CVE-2022-39359", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-26T19:15:12.410", "lastModified": "2022-10-28T16:10:28.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Metabase is data visualization software. Prior to versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9, custom GeoJSON map URL address would follow redirects to addresses that were otherwise disallowed, like link-local or private-network. This issue is patched in versions 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9, and 1.41.9. Metabase no longer follow redirects on GeoJSON map URLs. An environment variable `MB_CUSTOM_GEOJSON_ENABLED` was also added to disable custom GeoJSON completely (`true` by default)."}, {"lang": "es", "value": "Metabase es un software de visualizaci\u00f3n de datos. En versiones anteriores a 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9 y 1.41.9, las direcciones URL de los mapas GeoJSON personalizados segu\u00edan redireccionamientos a direcciones que no estaban permitidas, como link-local o private-network. Este problema ha sido corregido en versiones 0.44.5, 1.44.5, 0.43.7, 1.43.7, 0.42.6, 1.42.6, 0.41.9 y 1.41.9. Metabase ya no sigue los redireccionamientos en las URL de mapas GeoJSON. Tambi\u00e9n fue a\u00f1adida una variable de entorno \"MB_CUSTOM_GEOJSON_ENABLED\" para deshabilitar completamente el GeoJSON personalizado (\"true\" por defecto)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.41.0", "versionEndExcluding": "0.41.9", "matchCriteriaId": "BCD50540-E323-41CE-9D9C-EDA8CB718E42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.42.0", "versionEndExcluding": "0.42.6", "matchCriteriaId": "EF01C7BF-CB4C-4990-9082-587CFD555225"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.43.0", "versionEndExcluding": "0.43.7", "matchCriteriaId": "8858058E-C597-4752-8625-9B279DC65A48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.44.0", "versionEndExcluding": "0.44.5", "matchCriteriaId": "6A94F7EA-BC18-4013-9A93-7962226FDD98"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.41.0", "versionEndExcluding": "1.41.9", "matchCriteriaId": "804B84E1-5D1A-4251-9829-65F5FD927D99"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.42.0", "versionEndExcluding": "1.42.6", "matchCriteriaId": "73310924-8CD4-4696-89B9-EED3390375A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.43.0", "versionEndExcluding": "1.43.7", "matchCriteriaId": "A86AA0C8-2C4F-4DDD-8371-6B43611E2479"}, {"vulnerable": true, "criteria": "cpe:2.3:a:metabase:metabase:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.44.0", "versionEndExcluding": "1.44.5", "matchCriteriaId": "EF7A60F6-5062-4094-91A5-71445F9B7BC1"}]}]}], "references": [{"url": "https://github.com/metabase/metabase/commit/057e2d67fcbeb6b48db68b697e022243e3a5771e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/metabase/metabase/security/advisories/GHSA-w5j7-4mgm-77f4", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/metabase/metabase/commit/057e2d67fcbeb6b48db68b697e022243e3a5771e"}}