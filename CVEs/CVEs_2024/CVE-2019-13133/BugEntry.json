{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            BBBB   M   M  PPPP                               %\n%                            B   B  MM MM  P   P                              %\n%                            BBBB   M M M  PPPP                               %\n%                            B   B  M   M  P                                  %\n%                            BBBB   M   M  P                                  %\n%                                                                             %\n%                                                                             %\n%             Read/Write Microsoft Windows Bitmap Image Format                %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                            Glenn Randers-Pehrson                            %\n%                               December 2001                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n\f\n/*\n  Macro definitions (from Windows wingdi.h).\n*/\n#undef BI_JPEG\n#define BI_JPEG  4\n#undef BI_PNG\n#define BI_PNG  5\n#if !defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__MINGW32__)\n#undef BI_RGB\n#define BI_RGB  0\n#undef BI_RLE8\n#define BI_RLE8  1\n#undef BI_RLE4\n#define BI_RLE4  2\n#undef BI_BITFIELDS\n#define BI_BITFIELDS  3\n\n#undef LCS_CALIBRATED_RBG\n#define LCS_CALIBRATED_RBG  0\n#undef LCS_sRGB\n#define LCS_sRGB  1\n#undef LCS_WINDOWS_COLOR_SPACE\n#define LCS_WINDOWS_COLOR_SPACE  2\n#undef PROFILE_LINKED\n#define PROFILE_LINKED  3\n#undef PROFILE_EMBEDDED\n#define PROFILE_EMBEDDED  4\n\n#undef LCS_GM_BUSINESS\n#define LCS_GM_BUSINESS  1  /* Saturation */\n#undef LCS_GM_GRAPHICS\n#define LCS_GM_GRAPHICS  2  /* Relative */\n#undef LCS_GM_IMAGES\n#define LCS_GM_IMAGES  4  /* Perceptual */\n#undef LCS_GM_ABS_COLORIMETRIC\n#define LCS_GM_ABS_COLORIMETRIC  8  /* Absolute */\n#endif\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  UndefinedSubtype,\n  RGB555,\n  RGB565,\n  ARGB4444,\n  ARGB1555\n} BMPSubtype;\n\n/*\n  Typedef declarations.\n*/\ntypedef struct _BMPInfo\n{\n  unsigned int\n    file_size,\n    ba_offset,\n    offset_bits,\n    size;\n\n  ssize_t\n    width,\n    height;\n\n  unsigned short\n    planes,\n    bits_per_pixel;\n\n  unsigned int\n    compression,\n    image_size,\n    x_pixels,\n    y_pixels,\n    number_colors,\n    red_mask,\n    green_mask,\n    blue_mask,\n    alpha_mask,\n    colors_important;\n\n  long\n    colorspace;\n\n  PrimaryInfo\n    red_primary,\n    green_primary,\n    blue_primary,\n    gamma_scale;\n} BMPInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteBMPImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into runlength-encoded\n%  pixel packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,const size_t compression,\n%        unsigned char *pixels,const size_t number_pixels)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o compression:  Zero means uncompressed.  A value of 1 means the\n%      compressed pixels are runlength encoded for a 256-color bitmap.\n%      A value of 2 means a 16-color bitmap.  A value of 3 means bitfields\n%      encoding.\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the decoding process.\n%\n%    o number_pixels:  The number of pixels.\n%\n*/\nstatic MagickBooleanType DecodeImage(Image *image,const size_t compression,\n  unsigned char *pixels,const size_t number_pixels)\n{\n  int\n    byte,\n    count;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p,\n    *q;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  (void) memset(pixels,0,number_pixels*sizeof(*pixels));\n  byte=0;\n  x=0;\n  p=pixels;\n  q=pixels+number_pixels;\n  for (y=0; y < (ssize_t) image->rows; )\n  {\n    MagickBooleanType\n      status;\n\n    if ((p < pixels) || (p > q))\n      break;\n    count=ReadBlobByte(image);\n    if (count == EOF)\n      break;\n    if (count > 0)\n      {\n        /*\n          Encoded mode.\n        */\n        count=(int) MagickMin((ssize_t) count,(ssize_t) (q-p));\n        byte=ReadBlobByte(image);\n        if (byte == EOF)\n          break;\n        if (compression == BI_RLE8)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              *p++=(unsigned char) byte;\n          }\n        else\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              *p++=(unsigned char)\n                ((i & 0x01) != 0 ? (byte & 0x0f) : ((byte >> 4) & 0x0f));\n          }\n        x+=count;\n      }\n    else\n      {\n        /*\n          Escape mode.\n        */\n        count=ReadBlobByte(image);\n        if (count == EOF)\n          break;\n        if (count == 0x01)\n          return(MagickTrue);\n        switch (count)\n        {\n          case 0x00:\n          {\n            /*\n              End of line.\n            */\n            x=0;\n            y++;\n            p=pixels+y*image->columns;\n            break;\n          }\n          case 0x02:\n          {\n            /*\n              Delta mode.\n            */\n            x+=ReadBlobByte(image);\n            y+=ReadBlobByte(image);\n            p=pixels+y*image->columns+x;\n            break;\n          }\n          default:\n          {\n            /*\n              Absolute mode.\n            */\n            count=(int) MagickMin((ssize_t) count,(ssize_t) (q-p));\n            if (compression == BI_RLE8)\n              for (i=0; i < (ssize_t) count; i++)\n              {\n                byte=ReadBlobByte(image);\n                if (byte == EOF)\n                  break;\n                *p++=(unsigned char) byte;\n              }\n            else\n              for (i=0; i < (ssize_t) count; i++)\n              {\n                if ((i & 0x01) == 0)\n                  {\n                    byte=ReadBlobByte(image);\n                    if (byte == EOF)\n                      break;\n                  }\n                *p++=(unsigned char)\n                  ((i & 0x01) != 0 ? (byte & 0x0f) : ((byte >> 4) & 0x0f));\n              }\n            x+=count;\n            /*\n              Read pad byte.\n            */\n            if (compression == BI_RLE8)\n              {\n                if ((count & 0x01) != 0)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              if (((count & 0x03) == 1) || ((count & 0x03) == 2))\n                if (ReadBlobByte(image) == EOF)\n                  break;\n            break;\n          }\n        }\n      }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) ReadBlobByte(image);  /* end of line */\n  (void) ReadBlobByte(image);\n  return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses pixels using a runlength encoded format.\n%\n%  The format of the EncodeImage method is:\n%\n%    static MagickBooleanType EncodeImage(Image *image,\n%      const size_t bytes_per_line,const unsigned char *pixels,\n%      unsigned char *compressed_pixels)\n%\n%  A description of each parameter follows:\n%\n%    o image:  The image.\n%\n%    o bytes_per_line: the number of bytes in a scanline of compressed pixels\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the compression process.\n%\n%    o compressed_pixels:  The address of a byte (8 bits) array of compressed\n%      pixel data.\n%\n*/\nstatic size_t EncodeImage(Image *image,const size_t bytes_per_line,\n  const unsigned char *pixels,unsigned char *compressed_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register const unsigned char\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Runlength encode pixels.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (const unsigned char *) NULL);\n  assert(compressed_pixels != (unsigned char *) NULL);\n  p=pixels;\n  q=compressed_pixels;\n  i=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    for (x=0; x < (ssize_t) bytes_per_line; x+=i)\n    {\n      /*\n        Determine runlength.\n      */\n      for (i=1; ((x+i) < (ssize_t) bytes_per_line); i++)\n        if ((i == 255) || (*(p+i) != *p))\n          break;\n      *q++=(unsigned char) i;\n      *q++=(*p);\n      p+=i;\n    }\n    /*\n      End of line.\n    */\n    *q++=(unsigned char) 0x00;\n    *q++=(unsigned char) 0x00;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    End of bitmap.\n  */\n  *q++=(unsigned char) 0x00;\n  *q++=(unsigned char) 0x01;\n  return((size_t) (q-compressed_pixels));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B M P                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBMP() returns MagickTrue if the image format type, identified by the\n%  magick string, is BMP.\n%\n%  The format of the IsBMP method is:\n%\n%      MagickBooleanType IsBMP(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsBMP(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if ((LocaleNCompare((char *) magick,\"BA\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"BM\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"IC\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"PI\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"CI\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"CP\",2) == 0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d B M P I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBMPImage() reads a Microsoft Windows bitmap image file, Version\n%  2, 3 (for Windows or NT), or 4, and  returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the ReadBMPImage method is:\n%\n%      image=ReadBMPImage(image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    profile_data,\n    profile_size,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    PixelInfo\n      quantum_bits;\n\n    PixelPacket\n      shift;\n\n    /*\n      Verify BMP identifier.\n    */\n    start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    profile_data=0;\n    profile_size=0;\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MagickPathExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch (bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n            double\n              gamma;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MagickPathExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            profile_data=(MagickOffsetType)ReadBlobLSBLong(image);\n            profile_size=(MagickOffsetType)ReadBlobLSBLong(image);\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->alpha_trait=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    image->resolution.x=(double) bmp_info.x_pixels/100.0;\n    image->resolution.y=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    if ((MagickSizeType) (length/256) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n          We should ignore the alpha value in BMP3 files but there have been\n          reports about 32 bit files with alpha. We do a quick check to see if\n          the alpha channel contains a value that is not zero (default value).\n          If we find a non zero value we asume the program that wrote the file\n          wants to use the alpha channel.\n        */\n        if ((image->alpha_trait == UndefinedPixelTrait) &&\n            (bmp_info.size == 40) && (bmp_info.bits_per_pixel == 32))\n          {\n            bytes_per_line=4*(image->columns);\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (*(p+3) != 0)\n                  {\n                    image->alpha_trait=BlendPixelTrait;\n                    y=-1;\n                    break;\n                  }\n                p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?\n          0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register unsigned int\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n            shift.red++;\n            if (shift.red >= 32U)\n              break;\n          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n            if (shift.green >= 32U)\n              break;\n          }\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if (shift.blue >= 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)\n          {\n            shift.alpha++;\n            if (shift.alpha >= 32U)\n              break;\n          }\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.red=(MagickRealType) (sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.green=(MagickRealType) (sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.blue=(MagickRealType) (sample-shift.blue);\n        sample=shift.alpha;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,\n              exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,\n                exception);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n              p++;\n              x++;\n            }\n          if (x < (ssize_t) image->columns)\n            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 16:\n      {\n        unsigned int\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha <= 8)\n                  alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha == 8)\n                  alpha|=(alpha >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Read embeded ICC profile\n    */\n    if ((bmp_info.colorspace == 0x4D424544L) && (profile_data > 0) &&\n        (profile_size > 0))\n      {\n        StringInfo\n          *profile;\n\n        unsigned char\n          *datum;\n\n        offset=start_position+14+profile_data;\n        if ((offset < TellBlob(image)) ||\n            (SeekBlob(image,offset,SEEK_SET) != offset) ||\n            (GetBlobSize(image) < (MagickSizeType) (offset+profile_size)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        profile=AcquireStringInfo((size_t) profile_size);\n        if (profile == (StringInfo *) NULL)\n          ThrowReaderException(CorruptImageError,\"MemoryAllocationFailed\");\n        datum=GetStringInfoDatum(profile);\n        if (ReadBlob(image,(size_t) profile_size,datum) == (ssize_t) profile_size)\n          {\n            MagickOffsetType\n              profile_size_orig;\n\n            /*\n             Trimming padded bytes.\n            */\n            profile_size_orig=(MagickOffsetType) datum[0] << 24;\n            profile_size_orig|=(MagickOffsetType) datum[1] << 16;\n            profile_size_orig|=(MagickOffsetType) datum[2] << 8;\n            profile_size_orig|=(MagickOffsetType) datum[3];\n            if (profile_size_orig < profile_size)\n              SetStringInfoLength(profile,(size_t) profile_size_orig);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Profile: ICC, %u bytes\",(unsigned int) profile_size_orig);\n            (void) SetImageProfile(image,\"icc\",profile,exception);\n          }\n        profile=DestroyStringInfo(profile);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    offset=(MagickOffsetType) bmp_info.ba_offset;\n    if (offset != 0)\n      if ((offset < TellBlob(image)) ||\n          (SeekBlob(image,offset,SEEK_SET) != offset))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    *magick='\\0';\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r B M P I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterBMPImage() adds attributes for the BMP image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterBMPImage method is:\n%\n%      size_t RegisterBMPImage(void)\n%\n*/\nModuleExport size_t RegisterBMPImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"BMP\",\"BMP\",\"Microsoft Windows bitmap image\");\n  entry->decoder=(DecodeImageHandler *) ReadBMPImage;\n  entry->encoder=(EncodeImageHandler *) WriteBMPImage;\n  entry->magick=(IsImageFormatHandler *) IsBMP;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"BMP\",\"BMP2\",\"Microsoft Windows bitmap image (V2)\");\n  entry->decoder=(DecodeImageHandler *) ReadBMPImage;\n  entry->encoder=(EncodeImageHandler *) WriteBMPImage;\n  entry->magick=(IsImageFormatHandler *) IsBMP;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"BMP\",\"BMP3\",\"Microsoft Windows bitmap image (V3)\");\n  entry->decoder=(DecodeImageHandler *) ReadBMPImage;\n  entry->encoder=(EncodeImageHandler *) WriteBMPImage;\n  entry->magick=(IsImageFormatHandler *) IsBMP;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r B M P I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterBMPImage() removes format registrations made by the\n%  BMP module from the list of supported formats.\n%\n%  The format of the UnregisterBMPImage method is:\n%\n%      UnregisterBMPImage(void)\n%\n*/\nModuleExport void UnregisterBMPImage(void)\n{\n  (void) UnregisterMagickInfo(\"BMP\");\n  (void) UnregisterMagickInfo(\"BMP2\");\n  (void) UnregisterMagickInfo(\"BMP3\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e B M P I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBMPImage() writes an image in Microsoft Windows bitmap encoded\n%  image format, version 3 for Windows or (if the image has a matte channel)\n%  version 4.\n%\n%  The format of the WriteBMPImage method is:\n%\n%      MagickBooleanType WriteBMPImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  BMPSubtype\n    bmp_subtype;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    imageListLength,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  MagickOffsetType\n    profile_data,\n    profile_size,\n    profile_size_pad;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (((image->columns << 3) != (int) (image->columns << 3)) ||\n      ((image->rows << 3) != (int) (image->rows << 3)))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) memset(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    bmp_info.red_mask=0x00ff0000U;\n    bmp_info.green_mask=0x0000ff00U;\n    bmp_info.blue_mask=0x000000ffU;\n    bmp_info.alpha_mask=0xff000000U;\n    bmp_subtype=UndefinedSubtype;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        option=GetImageOption(image_info,\"bmp:subtype\");\n        if (option != (const char *) NULL)\n        {\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              if (LocaleNCompare(option,\"ARGB4444\",8) == 0)\n                {\n                  bmp_subtype=ARGB4444;\n                  bmp_info.red_mask=0x00000f00U;\n                  bmp_info.green_mask=0x000000f0U;\n                  bmp_info.blue_mask=0x0000000fU;\n                  bmp_info.alpha_mask=0x0000f000U;\n                }\n              else if (LocaleNCompare(option,\"ARGB1555\",8) == 0)\n                {\n                  bmp_subtype=ARGB1555;\n                  bmp_info.red_mask=0x00007c00U;\n                  bmp_info.green_mask=0x000003e0U;\n                  bmp_info.blue_mask=0x0000001fU;\n                  bmp_info.alpha_mask=0x00008000U;\n                }\n            }\n          else\n          {\n            if (LocaleNCompare(option,\"RGB555\",6) == 0)\n              {\n                bmp_subtype=RGB555;\n                bmp_info.red_mask=0x00007c00U;\n                bmp_info.green_mask=0x000003e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n            else if (LocaleNCompare(option,\"RGB565\",6) == 0)\n              {\n                bmp_subtype=RGB565;\n                bmp_info.red_mask=0x0000f800U;\n                bmp_info.green_mask=0x000007e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n          }\n        }\n        if (bmp_subtype != UndefinedSubtype)\n          {\n            bmp_info.bits_per_pixel=16;\n            bmp_info.compression=BI_BITFIELDS;\n          }\n        else\n          {\n            bmp_info.bits_per_pixel=(unsigned short) ((type > 3) &&\n               (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n            bmp_info.compression=(unsigned int) ((type > 3) &&\n              (image->alpha_trait != UndefinedPixelTrait) ? BI_BITFIELDS : BI_RGB);\n            if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n              {\n                option=GetImageOption(image_info,\"bmp3:alpha\");\n                if (IsStringTrue(option))\n                  bmp_info.bits_per_pixel=32;\n              }\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if (((ssize_t) image->columns != (ssize_t) ((signed int) image->columns)) ||\n        ((ssize_t) image->rows != (ssize_t) ((signed int) image->rows)))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n      image->columns+256UL)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        unsigned int\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((unsigned int) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 16:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            unsigned short\n              pixel;\n\n            pixel=0;\n            if (bmp_subtype == ARGB4444)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelAlpha(image,p),15) << 12);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),15) << 8);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),15) << 4);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),15));\n              }\n            else if (bmp_subtype == RGB565)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 11);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),63) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            else\n              {\n                if (bmp_subtype == ARGB1555)\n                  pixel=(unsigned short) (ScaleQuantumToAny(\n                    GetPixelAlpha(image,p),1) << 15);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 10);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),31) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            *((unsigned short *) q)=pixel;\n            q+=2;\n            p+=GetPixelChannels(image);\n          }\n          for (x=2L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%u)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%u\",bmp_info.number_colors);\n      }\n    profile_data=0;\n    profile_size=0;\n    profile_size_pad=0;\n    if (profile != (StringInfo *) NULL)\n      {\n        profile_data=(MagickOffsetType) bmp_info.file_size-14;  /* from head of BMP info header */\n        profile_size=(MagickOffsetType) GetStringInfoLength(profile);\n        if ((profile_size % 4) > 0)\n          profile_size_pad=4-(profile_size%4);\n        bmp_info.file_size+=profile_size+profile_size_pad;\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.red_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.green_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.blue_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.alpha_mask);\n        if (profile != (StringInfo *) NULL)\n          (void) WriteBlobLSBLong(image,0x4D424544U);  /* PROFILE_EMBEDDED */\n        else\n          (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,(unsigned int) profile_data);\n            (void) WriteBlobLSBLong(image,(unsigned int)\n              (profile_size+profile_size_pad));\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %u bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    if (profile != (StringInfo *) NULL)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                                \"  Profile:  %g bytes\",(double) profile_size+profile_size_pad);\n        (void) WriteBlob(image,(size_t) profile_size,GetStringInfoDatum(profile));\n        if (profile_size_pad > 0)  /* padding for 4 bytes multiple */\n          (void) WriteBlob(image,(size_t) profile_size_pad,\"\\0\\0\\0\");\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\253\\001\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    if (count != 512)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    /*\n      Verify that we can read this VIFF image.\n    */\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if ((MagickSizeType) viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=(MagickRealType)\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Create bi-level colormap.\n        */\n        image->colors=2;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        image->colorspace=GRAYColorspace;\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*\n      bytes_per_pixel*sizeof(*pixels));\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red),q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green),q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue),q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count == 1) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r V I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterVIFFImage() adds properties for the VIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterVIFFImage method is:\n%\n%      size_t RegisterVIFFImage(void)\n%\n*/\nModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"VIFF\",\"VIFF\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r V I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterVIFFImage() removes format registrations made by the\n%  VIFF module from the list of supported formats.\n%\n%  The format of the UnregisterVIFFImage method is:\n%\n%      UnregisterVIFFImage(void)\n%\n*/\nModuleExport void UnregisterVIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"VIFF\");\n  (void) UnregisterMagickInfo(\"XV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e V I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteVIFFImage() writes an image to a file in the VIFF image format.\n%\n%  The format of the WriteVIFFImage method is:\n%\n%      MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n\n    size_t\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels,\n    packets;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    imageListLength;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) memset(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize VIFF image structure.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  /* IEEE byte ordering */\n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  /* no colormap */\n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color VIFF raster.\n        */\n        viff_info.number_data_bands=image->alpha_trait ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (SetImageGray(image,exception) == MagickFalse)\n          {\n            /*\n              Colormapped VIFF raster.\n            */\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              /*\n                Monochrome VIFF raster.\n              */\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    /*\n      Write VIFF image header (pad to 1024 bytes).\n    */\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    /*\n      Convert MIFF to VIFF raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert DirectClass packet to VIFF RGB pixel.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(image,p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (SetImageGray(image,exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          /*\n            Convert PseudoClass packet to VIFF colormapped pixels.\n          */\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a VIFF monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            /*\n              Convert PseudoClass packet to VIFF grayscale pixel.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                            BBBB   M   M  PPPP                               %\n%                            B   B  MM MM  P   P                              %\n%                            BBBB   M M M  PPPP                               %\n%                            B   B  M   M  P                                  %\n%                            BBBB   M   M  P                                  %\n%                                                                             %\n%                                                                             %\n%             Read/Write Microsoft Windows Bitmap Image Format                %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                            Glenn Randers-Pehrson                            %\n%                               December 2001                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n\f\n/*\n  Macro definitions (from Windows wingdi.h).\n*/\n#undef BI_JPEG\n#define BI_JPEG  4\n#undef BI_PNG\n#define BI_PNG  5\n#if !defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__MINGW32__)\n#undef BI_RGB\n#define BI_RGB  0\n#undef BI_RLE8\n#define BI_RLE8  1\n#undef BI_RLE4\n#define BI_RLE4  2\n#undef BI_BITFIELDS\n#define BI_BITFIELDS  3\n\n#undef LCS_CALIBRATED_RBG\n#define LCS_CALIBRATED_RBG  0\n#undef LCS_sRGB\n#define LCS_sRGB  1\n#undef LCS_WINDOWS_COLOR_SPACE\n#define LCS_WINDOWS_COLOR_SPACE  2\n#undef PROFILE_LINKED\n#define PROFILE_LINKED  3\n#undef PROFILE_EMBEDDED\n#define PROFILE_EMBEDDED  4\n\n#undef LCS_GM_BUSINESS\n#define LCS_GM_BUSINESS  1  /* Saturation */\n#undef LCS_GM_GRAPHICS\n#define LCS_GM_GRAPHICS  2  /* Relative */\n#undef LCS_GM_IMAGES\n#define LCS_GM_IMAGES  4  /* Perceptual */\n#undef LCS_GM_ABS_COLORIMETRIC\n#define LCS_GM_ABS_COLORIMETRIC  8  /* Absolute */\n#endif\n\f\n/*\n  Enumerated declaractions.\n*/\ntypedef enum\n{\n  UndefinedSubtype,\n  RGB555,\n  RGB565,\n  ARGB4444,\n  ARGB1555\n} BMPSubtype;\n\n/*\n  Typedef declarations.\n*/\ntypedef struct _BMPInfo\n{\n  unsigned int\n    file_size,\n    ba_offset,\n    offset_bits,\n    size;\n\n  ssize_t\n    width,\n    height;\n\n  unsigned short\n    planes,\n    bits_per_pixel;\n\n  unsigned int\n    compression,\n    image_size,\n    x_pixels,\n    y_pixels,\n    number_colors,\n    red_mask,\n    green_mask,\n    blue_mask,\n    alpha_mask,\n    colors_important;\n\n  long\n    colorspace;\n\n  PrimaryInfo\n    red_primary,\n    green_primary,\n    blue_primary,\n    gamma_scale;\n} BMPInfo;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteBMPImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage unpacks the packed image pixels into runlength-encoded\n%  pixel packets.\n%\n%  The format of the DecodeImage method is:\n%\n%      MagickBooleanType DecodeImage(Image *image,const size_t compression,\n%        unsigned char *pixels,const size_t number_pixels)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o compression:  Zero means uncompressed.  A value of 1 means the\n%      compressed pixels are runlength encoded for a 256-color bitmap.\n%      A value of 2 means a 16-color bitmap.  A value of 3 means bitfields\n%      encoding.\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the decoding process.\n%\n%    o number_pixels:  The number of pixels.\n%\n*/\nstatic MagickBooleanType DecodeImage(Image *image,const size_t compression,\n  unsigned char *pixels,const size_t number_pixels)\n{\n  int\n    byte,\n    count;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p,\n    *q;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (unsigned char *) NULL);\n  (void) memset(pixels,0,number_pixels*sizeof(*pixels));\n  byte=0;\n  x=0;\n  p=pixels;\n  q=pixels+number_pixels;\n  for (y=0; y < (ssize_t) image->rows; )\n  {\n    MagickBooleanType\n      status;\n\n    if ((p < pixels) || (p > q))\n      break;\n    count=ReadBlobByte(image);\n    if (count == EOF)\n      break;\n    if (count > 0)\n      {\n        /*\n          Encoded mode.\n        */\n        count=(int) MagickMin((ssize_t) count,(ssize_t) (q-p));\n        byte=ReadBlobByte(image);\n        if (byte == EOF)\n          break;\n        if (compression == BI_RLE8)\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              *p++=(unsigned char) byte;\n          }\n        else\n          {\n            for (i=0; i < (ssize_t) count; i++)\n              *p++=(unsigned char)\n                ((i & 0x01) != 0 ? (byte & 0x0f) : ((byte >> 4) & 0x0f));\n          }\n        x+=count;\n      }\n    else\n      {\n        /*\n          Escape mode.\n        */\n        count=ReadBlobByte(image);\n        if (count == EOF)\n          break;\n        if (count == 0x01)\n          return(MagickTrue);\n        switch (count)\n        {\n          case 0x00:\n          {\n            /*\n              End of line.\n            */\n            x=0;\n            y++;\n            p=pixels+y*image->columns;\n            break;\n          }\n          case 0x02:\n          {\n            /*\n              Delta mode.\n            */\n            x+=ReadBlobByte(image);\n            y+=ReadBlobByte(image);\n            p=pixels+y*image->columns+x;\n            break;\n          }\n          default:\n          {\n            /*\n              Absolute mode.\n            */\n            count=(int) MagickMin((ssize_t) count,(ssize_t) (q-p));\n            if (compression == BI_RLE8)\n              for (i=0; i < (ssize_t) count; i++)\n              {\n                byte=ReadBlobByte(image);\n                if (byte == EOF)\n                  break;\n                *p++=(unsigned char) byte;\n              }\n            else\n              for (i=0; i < (ssize_t) count; i++)\n              {\n                if ((i & 0x01) == 0)\n                  {\n                    byte=ReadBlobByte(image);\n                    if (byte == EOF)\n                      break;\n                  }\n                *p++=(unsigned char)\n                  ((i & 0x01) != 0 ? (byte & 0x0f) : ((byte >> 4) & 0x0f));\n              }\n            x+=count;\n            /*\n              Read pad byte.\n            */\n            if (compression == BI_RLE8)\n              {\n                if ((count & 0x01) != 0)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              if (((count & 0x03) == 1) || ((count & 0x03) == 2))\n                if (ReadBlobByte(image) == EOF)\n                  break;\n            break;\n          }\n        }\n      }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) ReadBlobByte(image);  /* end of line */\n  (void) ReadBlobByte(image);\n  return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses pixels using a runlength encoded format.\n%\n%  The format of the EncodeImage method is:\n%\n%    static MagickBooleanType EncodeImage(Image *image,\n%      const size_t bytes_per_line,const unsigned char *pixels,\n%      unsigned char *compressed_pixels)\n%\n%  A description of each parameter follows:\n%\n%    o image:  The image.\n%\n%    o bytes_per_line: the number of bytes in a scanline of compressed pixels\n%\n%    o pixels:  The address of a byte (8 bits) array of pixel data created by\n%      the compression process.\n%\n%    o compressed_pixels:  The address of a byte (8 bits) array of compressed\n%      pixel data.\n%\n*/\nstatic size_t EncodeImage(Image *image,const size_t bytes_per_line,\n  const unsigned char *pixels,unsigned char *compressed_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register const unsigned char\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Runlength encode pixels.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(pixels != (const unsigned char *) NULL);\n  assert(compressed_pixels != (unsigned char *) NULL);\n  p=pixels;\n  q=compressed_pixels;\n  i=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    for (x=0; x < (ssize_t) bytes_per_line; x+=i)\n    {\n      /*\n        Determine runlength.\n      */\n      for (i=1; ((x+i) < (ssize_t) bytes_per_line); i++)\n        if ((i == 255) || (*(p+i) != *p))\n          break;\n      *q++=(unsigned char) i;\n      *q++=(*p);\n      p+=i;\n    }\n    /*\n      End of line.\n    */\n    *q++=(unsigned char) 0x00;\n    *q++=(unsigned char) 0x00;\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    End of bitmap.\n  */\n  *q++=(unsigned char) 0x00;\n  *q++=(unsigned char) 0x01;\n  return((size_t) (q-compressed_pixels));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s B M P                                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsBMP() returns MagickTrue if the image format type, identified by the\n%  magick string, is BMP.\n%\n%  The format of the IsBMP method is:\n%\n%      MagickBooleanType IsBMP(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsBMP(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if ((LocaleNCompare((char *) magick,\"BA\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"BM\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"IC\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"PI\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"CI\",2) == 0) ||\n      (LocaleNCompare((char *) magick,\"CP\",2) == 0))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d B M P I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadBMPImage() reads a Microsoft Windows bitmap image file, Version\n%  2, 3 (for Windows or NT), or 4, and  returns it.  It allocates the memory\n%  necessary for the new Image structure and returns a pointer to the new\n%  image.\n%\n%  The format of the ReadBMPImage method is:\n%\n%      image=ReadBMPImage(image_info)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    profile_data,\n    profile_size,\n    start_position;\n\n  MemoryInfo\n    *pixel_info;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    magick[12],\n    *pixels;\n\n  unsigned int\n    blue,\n    green,\n    offset_bits,\n    red;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a BMP file.\n  */\n  (void) memset(&bmp_info,0,sizeof(bmp_info));\n  bmp_info.ba_offset=0;\n  start_position=0;\n  offset_bits=0;\n  count=ReadBlob(image,2,magick);\n  if (count != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    PixelInfo\n      quantum_bits;\n\n    PixelPacket\n      shift;\n\n    /*\n      Verify BMP identifier.\n    */\n    start_position=TellBlob(image)-2;\n    bmp_info.ba_offset=0;\n    while (LocaleNCompare((char *) magick,\"BA\",2) == 0)\n    {\n      bmp_info.file_size=ReadBlobLSBLong(image);\n      bmp_info.ba_offset=ReadBlobLSBLong(image);\n      bmp_info.offset_bits=ReadBlobLSBLong(image);\n      count=ReadBlob(image,2,magick);\n      if (count != 2)\n        break;\n    }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Magick: %c%c\",\n        magick[0],magick[1]);\n    if ((count != 2) || ((LocaleNCompare((char *) magick,\"BM\",2) != 0) &&\n        (LocaleNCompare((char *) magick,\"CI\",2) != 0)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bmp_info.file_size=ReadBlobLSBLong(image);\n    (void) ReadBlobLSBLong(image);\n    bmp_info.offset_bits=ReadBlobLSBLong(image);\n    bmp_info.size=ReadBlobLSBLong(image);\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  BMP size: %u\",\n        bmp_info.size);\n    profile_data=0;\n    profile_size=0;\n    if (bmp_info.size == 12)\n      {\n        /*\n          OS/2 BMP image file.\n        */\n        (void) CopyMagickString(image->magick,\"BMP2\",MagickPathExtent);\n        bmp_info.width=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.height=(ssize_t) ((short) ReadBlobLSBShort(image));\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.x_pixels=0;\n        bmp_info.y_pixels=0;\n        bmp_info.number_colors=0;\n        bmp_info.compression=BI_RGB;\n        bmp_info.image_size=0;\n        bmp_info.alpha_mask=0;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: OS/2 Bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n          }\n      }\n    else\n      {\n        /*\n          Microsoft Windows BMP image file.\n        */\n        if (bmp_info.size < 40)\n          ThrowReaderException(CorruptImageError,\"NonOS2HeaderSizeError\");\n        bmp_info.width=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.height=(ssize_t) ReadBlobLSBSignedLong(image);\n        bmp_info.planes=ReadBlobLSBShort(image);\n        bmp_info.bits_per_pixel=ReadBlobLSBShort(image);\n        bmp_info.compression=ReadBlobLSBLong(image);\n        bmp_info.image_size=ReadBlobLSBLong(image);\n        bmp_info.x_pixels=ReadBlobLSBLong(image);\n        bmp_info.y_pixels=ReadBlobLSBLong(image);\n        bmp_info.number_colors=ReadBlobLSBLong(image);\n        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        bmp_info.colors_important=ReadBlobLSBLong(image);\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Format: MS Windows bitmap\");\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Geometry: %.20gx%.20g\",(double) bmp_info.width,(double)\n              bmp_info.height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Bits per pixel: %.20g\",(double) bmp_info.bits_per_pixel);\n            switch (bmp_info.compression)\n            {\n              case BI_RGB:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RGB\");\n                break;\n              }\n              case BI_RLE4:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE4\");\n                break;\n              }\n              case BI_RLE8:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_RLE8\");\n                break;\n              }\n              case BI_BITFIELDS:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_BITFIELDS\");\n                break;\n              }\n              case BI_PNG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_PNG\");\n                break;\n              }\n              case BI_JPEG:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: BI_JPEG\");\n                break;\n              }\n              default:\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"  Compression: UNKNOWN (%u)\",bmp_info.compression);\n              }\n            }\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Number of colors: %u\",bmp_info.number_colors);\n          }\n        bmp_info.red_mask=ReadBlobLSBLong(image);\n        bmp_info.green_mask=ReadBlobLSBLong(image);\n        bmp_info.blue_mask=ReadBlobLSBLong(image);\n        if (bmp_info.size > 40)\n          {\n            double\n              gamma;\n\n            /*\n              Read color management information.\n            */\n            bmp_info.alpha_mask=ReadBlobLSBLong(image);\n            bmp_info.colorspace=ReadBlobLSBSignedLong(image);\n            /*\n              Decode 2^30 fixed point formatted CIE primaries.\n            */\n#           define BMP_DENOM ((double) 0x40000000)\n            bmp_info.red_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.red_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.green_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.x=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.y=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n            bmp_info.blue_primary.z=(double) ReadBlobLSBLong(image)/BMP_DENOM;\n\n            gamma=bmp_info.red_primary.x+bmp_info.red_primary.y+\n              bmp_info.red_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.red_primary.x*=gamma;\n            bmp_info.red_primary.y*=gamma;\n            image->chromaticity.red_primary.x=bmp_info.red_primary.x;\n            image->chromaticity.red_primary.y=bmp_info.red_primary.y;\n\n            gamma=bmp_info.green_primary.x+bmp_info.green_primary.y+\n              bmp_info.green_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.green_primary.x*=gamma;\n            bmp_info.green_primary.y*=gamma;\n            image->chromaticity.green_primary.x=bmp_info.green_primary.x;\n            image->chromaticity.green_primary.y=bmp_info.green_primary.y;\n\n            gamma=bmp_info.blue_primary.x+bmp_info.blue_primary.y+\n              bmp_info.blue_primary.z;\n            gamma=PerceptibleReciprocal(gamma);\n            bmp_info.blue_primary.x*=gamma;\n            bmp_info.blue_primary.y*=gamma;\n            image->chromaticity.blue_primary.x=bmp_info.blue_primary.x;\n            image->chromaticity.blue_primary.y=bmp_info.blue_primary.y;\n\n            /*\n              Decode 16^16 fixed point formatted gamma_scales.\n            */\n            bmp_info.gamma_scale.x=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.y=(double) ReadBlobLSBLong(image)/0x10000;\n            bmp_info.gamma_scale.z=(double) ReadBlobLSBLong(image)/0x10000;\n            /*\n              Compute a single gamma from the BMP 3-channel gamma.\n            */\n            image->gamma=(bmp_info.gamma_scale.x+bmp_info.gamma_scale.y+\n              bmp_info.gamma_scale.z)/3.0;\n          }\n        else\n          (void) CopyMagickString(image->magick,\"BMP3\",MagickPathExtent);\n\n        if (bmp_info.size > 108)\n          {\n            size_t\n              intent;\n\n            /*\n              Read BMP Version 5 color management information.\n            */\n            intent=ReadBlobLSBLong(image);\n            switch ((int) intent)\n            {\n              case LCS_GM_BUSINESS:\n              {\n                image->rendering_intent=SaturationIntent;\n                break;\n              }\n              case LCS_GM_GRAPHICS:\n              {\n                image->rendering_intent=RelativeIntent;\n                break;\n              }\n              case LCS_GM_IMAGES:\n              {\n                image->rendering_intent=PerceptualIntent;\n                break;\n              }\n              case LCS_GM_ABS_COLORIMETRIC:\n              {\n                image->rendering_intent=AbsoluteIntent;\n                break;\n              }\n            }\n            profile_data=(MagickOffsetType)ReadBlobLSBLong(image);\n            profile_size=(MagickOffsetType)ReadBlobLSBLong(image);\n            (void) ReadBlobLSBLong(image);  /* Reserved byte */\n          }\n      }\n    if ((MagickSizeType) bmp_info.file_size > GetBlobSize(image))\n      (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,\n        \"LengthAndFilesizeDoNotMatch\",\"`%s'\",image->filename);\n    else\n      if ((MagickSizeType) bmp_info.file_size < GetBlobSize(image))\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"LengthAndFilesizeDoNotMatch\",\"`%s'\",\n          image->filename);\n    if (bmp_info.width <= 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.height == 0)\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    if (bmp_info.planes != 1)\n      ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n    if ((bmp_info.bits_per_pixel != 1) && (bmp_info.bits_per_pixel != 4) &&\n        (bmp_info.bits_per_pixel != 8) && (bmp_info.bits_per_pixel != 16) &&\n        (bmp_info.bits_per_pixel != 24) && (bmp_info.bits_per_pixel != 32))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if (bmp_info.bits_per_pixel < 16 &&\n        bmp_info.number_colors > (1U << bmp_info.bits_per_pixel))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n    if ((bmp_info.compression == 1) && (bmp_info.bits_per_pixel != 8))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if ((bmp_info.compression == 2) && (bmp_info.bits_per_pixel != 4))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    if ((bmp_info.compression == 3) && (bmp_info.bits_per_pixel < 16))\n      ThrowReaderException(CorruptImageError,\"UnsupportedBitsPerPixel\");\n    switch (bmp_info.compression)\n    {\n      case BI_RGB:\n        image->compression=NoCompression;\n        break;\n      case BI_RLE8:\n      case BI_RLE4:\n        image->compression=RLECompression;\n        break;\n      case BI_BITFIELDS:\n        break;\n      case BI_JPEG:\n        ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n      case BI_PNG:\n        ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n      default:\n        ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    }\n    image->columns=(size_t) MagickAbsoluteValue(bmp_info.width);\n    image->rows=(size_t) MagickAbsoluteValue(bmp_info.height);\n    image->depth=bmp_info.bits_per_pixel <= 8 ? bmp_info.bits_per_pixel : 8;\n    image->alpha_trait=((bmp_info.alpha_mask != 0) &&\n      (bmp_info.compression == BI_BITFIELDS)) ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    if (bmp_info.bits_per_pixel < 16)\n      {\n        size_t\n          one;\n\n        image->storage_class=PseudoClass;\n        image->colors=bmp_info.number_colors;\n        one=1;\n        if (image->colors == 0)\n          image->colors=one << bmp_info.bits_per_pixel;\n      }\n    image->resolution.x=(double) bmp_info.x_pixels/100.0;\n    image->resolution.y=(double) bmp_info.y_pixels/100.0;\n    image->units=PixelsPerCentimeterResolution;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        size_t\n          packet_size;\n\n        /*\n          Read BMP raster colormap.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading colormap of %.20g colors\",(double) image->colors);\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n          image->colors,4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((bmp_info.size == 12) || (bmp_info.size == 64))\n          packet_size=3;\n        else\n          packet_size=4;\n        offset=SeekBlob(image,start_position+14+bmp_info.size,SEEK_SET);\n        if (offset < 0)\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n        count=ReadBlob(image,packet_size*image->colors,bmp_colormap);\n        if (count != (ssize_t) (packet_size*image->colors))\n          {\n            bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        p=bmp_colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(*p++);\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(*p++);\n          if (packet_size == 4)\n            p++;\n        }\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    /*\n      Read image data.\n    */\n    if (bmp_info.offset_bits == offset_bits)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    offset_bits=bmp_info.offset_bits;\n    offset=SeekBlob(image,start_position+bmp_info.offset_bits,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (bmp_info.compression == BI_RLE4)\n      bmp_info.bits_per_pixel<<=1;\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    length=(size_t) bytes_per_line*image->rows;\n    if ((MagickSizeType) (length/256) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if ((bmp_info.compression == BI_RGB) ||\n        (bmp_info.compression == BI_BITFIELDS))\n      {\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Reading pixels (%.20g bytes)\",(double) length);\n        count=ReadBlob(image,length,pixels);\n        if (count != (ssize_t) length)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n      }\n    else\n      {\n        /*\n          Convert run-length encoded raster pixels.\n        */\n        pixel_info=AcquireVirtualMemory(image->rows,\n          MagickMax(bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n        if (pixel_info == (MemoryInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n        status=DecodeImage(image,bmp_info.compression,pixels,\n          image->columns*image->rows);\n        if (status == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnableToRunlengthDecodeImage\");\n          }\n      }\n    /*\n      Convert BMP raster image to pixel packets.\n    */\n    if (bmp_info.compression == BI_RGB)\n      {\n        /*\n          We should ignore the alpha value in BMP3 files but there have been\n          reports about 32 bit files with alpha. We do a quick check to see if\n          the alpha channel contains a value that is not zero (default value).\n          If we find a non zero value we asume the program that wrote the file\n          wants to use the alpha channel.\n        */\n        if ((image->alpha_trait == UndefinedPixelTrait) &&\n            (bmp_info.size == 40) && (bmp_info.bits_per_pixel == 32))\n          {\n            bytes_per_line=4*(image->columns);\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              p=pixels+(image->rows-y-1)*bytes_per_line;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (*(p+3) != 0)\n                  {\n                    image->alpha_trait=BlendPixelTrait;\n                    y=-1;\n                    break;\n                  }\n                p+=4;\n              }\n            }\n          }\n        bmp_info.alpha_mask=image->alpha_trait != UndefinedPixelTrait ?\n          0xff000000U : 0U;\n        bmp_info.red_mask=0x00ff0000U;\n        bmp_info.green_mask=0x0000ff00U;\n        bmp_info.blue_mask=0x000000ffU;\n        if (bmp_info.bits_per_pixel == 16)\n          {\n            /*\n              RGB555.\n            */\n            bmp_info.red_mask=0x00007c00U;\n            bmp_info.green_mask=0x000003e0U;\n            bmp_info.blue_mask=0x0000001fU;\n          }\n      }\n    (void) memset(&shift,0,sizeof(shift));\n    (void) memset(&quantum_bits,0,sizeof(quantum_bits));\n    if ((bmp_info.bits_per_pixel == 16) || (bmp_info.bits_per_pixel == 32))\n      {\n        register unsigned int\n          sample;\n\n        /*\n          Get shift and quantum bits info from bitfield masks.\n        */\n        if (bmp_info.red_mask != 0)\n          while (((bmp_info.red_mask << shift.red) & 0x80000000UL) == 0)\n          {\n            shift.red++;\n            if (shift.red >= 32U)\n              break;\n          }\n        if (bmp_info.green_mask != 0)\n          while (((bmp_info.green_mask << shift.green) & 0x80000000UL) == 0)\n          {\n            shift.green++;\n            if (shift.green >= 32U)\n              break;\n          }\n        if (bmp_info.blue_mask != 0)\n          while (((bmp_info.blue_mask << shift.blue) & 0x80000000UL) == 0)\n          {\n            shift.blue++;\n            if (shift.blue >= 32U)\n              break;\n          }\n        if (bmp_info.alpha_mask != 0)\n          while (((bmp_info.alpha_mask << shift.alpha) & 0x80000000UL) == 0)\n          {\n            shift.alpha++;\n            if (shift.alpha >= 32U)\n              break;\n          }\n        sample=shift.red;\n        while (((bmp_info.red_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.red=(MagickRealType) (sample-shift.red);\n        sample=shift.green;\n        while (((bmp_info.green_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.green=(MagickRealType) (sample-shift.green);\n        sample=shift.blue;\n        while (((bmp_info.blue_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.blue=(MagickRealType) (sample-shift.blue);\n        sample=shift.alpha;\n        while (((bmp_info.alpha_mask << sample) & 0x80000000UL) != 0)\n        {\n          sample++;\n          if (sample >= 32U)\n            break;\n        }\n        quantum_bits.alpha=(MagickRealType) (sample-shift.alpha);\n      }\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (image->columns % 8); bit++)\n              {\n                index=(Quantum) (((*p) & (0x80 >> bit)) != 0 ? 0x01 : 0x00);\n                SetPixelIndex(image,index,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 4:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n          {\n            ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0x0f),&index,\n              exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            ValidateColormapValue(image,(ssize_t) (*p & 0x0f),&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n            p++;\n          }\n          if ((image->columns % 2) != 0)\n            {\n              ValidateColormapValue(image,(ssize_t) ((*p >> 4) & 0xf),&index,\n                exception);\n              SetPixelIndex(image,index,q);\n              q+=GetPixelChannels(image);\n              p++;\n              x++;\n            }\n          if (x < (ssize_t) image->columns)\n            break;\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoColor scanline.\n        */\n        if ((bmp_info.compression == BI_RLE8) ||\n            (bmp_info.compression == BI_RLE4))\n          bytes_per_line=image->columns;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=(ssize_t) image->columns; x != 0; --x)\n          {\n            ValidateColormapValue(image,(ssize_t) *p++,&index,exception);\n            SetPixelIndex(image,index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        (void) SyncImage(image,exception);\n        break;\n      }\n      case 16:\n      {\n        unsigned int\n          alpha,\n          pixel;\n\n        /*\n          Convert bitfield encoded 16-bit PseudoColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=2*(image->columns+image->columns % 2);\n        image->storage_class=DirectClass;\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=(*p++) << 8;\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 5)\n              red|=((red & 0xe000) >> 5);\n            if (quantum_bits.red <= 8)\n              red|=((red & 0xff00) >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 5)\n              green|=((green & 0xe000) >> 5);\n            if (quantum_bits.green == 6)\n              green|=((green & 0xc000) >> 6);\n            if (quantum_bits.green <= 8)\n              green|=((green & 0xff00) >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 5)\n              blue|=((blue & 0xe000) >> 5);\n            if (quantum_bits.blue <= 8)\n              blue|=((blue & 0xff00) >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha <= 8)\n                  alpha|=((alpha & 0xff00) >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectColor scanline.\n        */\n        bytes_per_line=4*((image->columns*24+31)/32);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n            SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert bitfield encoded DirectColor scanline.\n        */\n        if ((bmp_info.compression != BI_RGB) &&\n            (bmp_info.compression != BI_BITFIELDS))\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(CorruptImageError,\n              \"UnrecognizedImageCompression\");\n          }\n        bytes_per_line=4*(image->columns);\n        for (y=(ssize_t) image->rows-1; y >= 0; y--)\n        {\n          unsigned int\n            alpha,\n            pixel;\n\n          p=pixels+(image->rows-y-1)*bytes_per_line;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            pixel=(unsigned int) (*p++);\n            pixel|=((unsigned int) *p++ << 8);\n            pixel|=((unsigned int) *p++ << 16);\n            pixel|=((unsigned int) *p++ << 24);\n            red=((pixel & bmp_info.red_mask) << shift.red) >> 16;\n            if (quantum_bits.red == 8)\n              red|=(red >> 8);\n            green=((pixel & bmp_info.green_mask) << shift.green) >> 16;\n            if (quantum_bits.green == 8)\n              green|=(green >> 8);\n            blue=((pixel & bmp_info.blue_mask) << shift.blue) >> 16;\n            if (quantum_bits.blue == 8)\n              blue|=(blue >> 8);\n            SetPixelRed(image,ScaleShortToQuantum((unsigned short) red),q);\n            SetPixelGreen(image,ScaleShortToQuantum((unsigned short) green),q);\n            SetPixelBlue(image,ScaleShortToQuantum((unsigned short) blue),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                alpha=((pixel & bmp_info.alpha_mask) << shift.alpha) >> 16;\n                if (quantum_bits.alpha == 8)\n                  alpha|=(alpha >> 8);\n                SetPixelAlpha(image,ScaleShortToQuantum(\n                  (unsigned short) alpha),q);\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          offset=(MagickOffsetType) (image->rows-y-1);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                (image->rows-y),image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      default:\n      {\n        pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (y > 0)\n      break;\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (bmp_info.height < 0)\n      {\n        Image\n          *flipped_image;\n\n        /*\n          Correct image orientation.\n        */\n        flipped_image=FlipImage(image,exception);\n        if (flipped_image != (Image *) NULL)\n          {\n            DuplicateBlob(flipped_image,image);\n            ReplaceImageInList(&image, flipped_image);\n            image=flipped_image;\n          }\n      }\n    /*\n      Read embeded ICC profile\n    */\n    if ((bmp_info.colorspace == 0x4D424544L) && (profile_data > 0) &&\n        (profile_size > 0))\n      {\n        StringInfo\n          *profile;\n\n        unsigned char\n          *datum;\n\n        offset=start_position+14+profile_data;\n        if ((offset < TellBlob(image)) ||\n            (SeekBlob(image,offset,SEEK_SET) != offset) ||\n            (GetBlobSize(image) < (MagickSizeType) (offset+profile_size)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        profile=AcquireStringInfo((size_t) profile_size);\n        if (profile == (StringInfo *) NULL)\n          ThrowReaderException(CorruptImageError,\"MemoryAllocationFailed\");\n        datum=GetStringInfoDatum(profile);\n        if (ReadBlob(image,(size_t) profile_size,datum) == (ssize_t) profile_size)\n          {\n            MagickOffsetType\n              profile_size_orig;\n\n            /*\n             Trimming padded bytes.\n            */\n            profile_size_orig=(MagickOffsetType) datum[0] << 24;\n            profile_size_orig|=(MagickOffsetType) datum[1] << 16;\n            profile_size_orig|=(MagickOffsetType) datum[2] << 8;\n            profile_size_orig|=(MagickOffsetType) datum[3];\n            if (profile_size_orig < profile_size)\n              SetStringInfoLength(profile,(size_t) profile_size_orig);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"Profile: ICC, %u bytes\",(unsigned int) profile_size_orig);\n            (void) SetImageProfile(image,\"icc\",profile,exception);\n          }\n        profile=DestroyStringInfo(profile);\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    offset=(MagickOffsetType) bmp_info.ba_offset;\n    if (offset != 0)\n      if ((offset < TellBlob(image)) ||\n          (SeekBlob(image,offset,SEEK_SET) != offset))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    *magick='\\0';\n    count=ReadBlob(image,2,magick);\n    if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n      {\n        /*\n          Acquire next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (IsBMP(magick,2) != MagickFalse);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r B M P I m a g e                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterBMPImage() adds attributes for the BMP image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterBMPImage method is:\n%\n%      size_t RegisterBMPImage(void)\n%\n*/\nModuleExport size_t RegisterBMPImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"BMP\",\"BMP\",\"Microsoft Windows bitmap image\");\n  entry->decoder=(DecodeImageHandler *) ReadBMPImage;\n  entry->encoder=(EncodeImageHandler *) WriteBMPImage;\n  entry->magick=(IsImageFormatHandler *) IsBMP;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"BMP\",\"BMP2\",\"Microsoft Windows bitmap image (V2)\");\n  entry->decoder=(DecodeImageHandler *) ReadBMPImage;\n  entry->encoder=(EncodeImageHandler *) WriteBMPImage;\n  entry->magick=(IsImageFormatHandler *) IsBMP;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"BMP\",\"BMP3\",\"Microsoft Windows bitmap image (V3)\");\n  entry->decoder=(DecodeImageHandler *) ReadBMPImage;\n  entry->encoder=(EncodeImageHandler *) WriteBMPImage;\n  entry->magick=(IsImageFormatHandler *) IsBMP;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r B M P I m a g e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterBMPImage() removes format registrations made by the\n%  BMP module from the list of supported formats.\n%\n%  The format of the UnregisterBMPImage method is:\n%\n%      UnregisterBMPImage(void)\n%\n*/\nModuleExport void UnregisterBMPImage(void)\n{\n  (void) UnregisterMagickInfo(\"BMP\");\n  (void) UnregisterMagickInfo(\"BMP2\");\n  (void) UnregisterMagickInfo(\"BMP3\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e B M P I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteBMPImage() writes an image in Microsoft Windows bitmap encoded\n%  image format, version 3 for Windows or (if the image has a matte channel)\n%  version 4.\n%\n%  The format of the WriteBMPImage method is:\n%\n%      MagickBooleanType WriteBMPImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteBMPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  BMPInfo\n    bmp_info;\n\n  BMPSubtype\n    bmp_subtype;\n\n  const char\n    *option;\n\n  const StringInfo\n    *profile;\n\n  MagickBooleanType\n    have_color_info,\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bytes_per_line,\n    imageListLength,\n    type;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *bmp_data,\n    *pixels;\n\n  MagickOffsetType\n    profile_data,\n    profile_size,\n    profile_size_pad;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if (((image->columns << 3) != (int) (image->columns << 3)) ||\n      ((image->rows << 3) != (int) (image->rows << 3)))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  type=4;\n  if (LocaleCompare(image_info->magick,\"BMP2\") == 0)\n    type=2;\n  else\n    if (LocaleCompare(image_info->magick,\"BMP3\") == 0)\n      type=3;\n  option=GetImageOption(image_info,\"bmp:format\");\n  if (option != (char *) NULL)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Format=%s\",option);\n      if (LocaleCompare(option,\"bmp2\") == 0)\n        type=2;\n      if (LocaleCompare(option,\"bmp3\") == 0)\n        type=3;\n      if (LocaleCompare(option,\"bmp4\") == 0)\n        type=4;\n    }\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize BMP raster file header.\n    */\n    if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n      (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) memset(&bmp_info,0,sizeof(bmp_info));\n    bmp_info.file_size=14+12;\n    if (type > 2)\n      bmp_info.file_size+=28;\n    bmp_info.offset_bits=bmp_info.file_size;\n    bmp_info.compression=BI_RGB;\n    bmp_info.red_mask=0x00ff0000U;\n    bmp_info.green_mask=0x0000ff00U;\n    bmp_info.blue_mask=0x000000ffU;\n    bmp_info.alpha_mask=0xff000000U;\n    bmp_subtype=UndefinedSubtype;\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class != DirectClass)\n      {\n        /*\n          Colormapped BMP raster.\n        */\n        bmp_info.bits_per_pixel=8;\n        if (image->colors <= 2)\n          bmp_info.bits_per_pixel=1;\n        else\n          if (image->colors <= 16)\n            bmp_info.bits_per_pixel=4;\n          else\n            if (image->colors <= 256)\n              bmp_info.bits_per_pixel=8;\n        if (image_info->compression == RLECompression)\n          bmp_info.bits_per_pixel=8;\n        bmp_info.number_colors=1U << bmp_info.bits_per_pixel;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) SetImageStorageClass(image,DirectClass,exception);\n        else\n          if ((size_t) bmp_info.number_colors < image->colors)\n            (void) SetImageStorageClass(image,DirectClass,exception);\n          else\n            {\n              bmp_info.file_size+=3*(1UL << bmp_info.bits_per_pixel);\n              bmp_info.offset_bits+=3*(1UL << bmp_info.bits_per_pixel);\n              if (type > 2)\n                {\n                  bmp_info.file_size+=(1UL << bmp_info.bits_per_pixel);\n                  bmp_info.offset_bits+=(1UL << bmp_info.bits_per_pixel);\n                }\n            }\n      }\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color BMP raster.\n        */\n        bmp_info.number_colors=0;\n        option=GetImageOption(image_info,\"bmp:subtype\");\n        if (option != (const char *) NULL)\n        {\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              if (LocaleNCompare(option,\"ARGB4444\",8) == 0)\n                {\n                  bmp_subtype=ARGB4444;\n                  bmp_info.red_mask=0x00000f00U;\n                  bmp_info.green_mask=0x000000f0U;\n                  bmp_info.blue_mask=0x0000000fU;\n                  bmp_info.alpha_mask=0x0000f000U;\n                }\n              else if (LocaleNCompare(option,\"ARGB1555\",8) == 0)\n                {\n                  bmp_subtype=ARGB1555;\n                  bmp_info.red_mask=0x00007c00U;\n                  bmp_info.green_mask=0x000003e0U;\n                  bmp_info.blue_mask=0x0000001fU;\n                  bmp_info.alpha_mask=0x00008000U;\n                }\n            }\n          else\n          {\n            if (LocaleNCompare(option,\"RGB555\",6) == 0)\n              {\n                bmp_subtype=RGB555;\n                bmp_info.red_mask=0x00007c00U;\n                bmp_info.green_mask=0x000003e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n            else if (LocaleNCompare(option,\"RGB565\",6) == 0)\n              {\n                bmp_subtype=RGB565;\n                bmp_info.red_mask=0x0000f800U;\n                bmp_info.green_mask=0x000007e0U;\n                bmp_info.blue_mask=0x0000001fU;\n                bmp_info.alpha_mask=0U;\n              }\n          }\n        }\n        if (bmp_subtype != UndefinedSubtype)\n          {\n            bmp_info.bits_per_pixel=16;\n            bmp_info.compression=BI_BITFIELDS;\n          }\n        else\n          {\n            bmp_info.bits_per_pixel=(unsigned short) ((type > 3) &&\n               (image->alpha_trait != UndefinedPixelTrait) ? 32 : 24);\n            bmp_info.compression=(unsigned int) ((type > 3) &&\n              (image->alpha_trait != UndefinedPixelTrait) ? BI_BITFIELDS : BI_RGB);\n            if ((type == 3) && (image->alpha_trait != UndefinedPixelTrait))\n              {\n                option=GetImageOption(image_info,\"bmp3:alpha\");\n                if (IsStringTrue(option))\n                  bmp_info.bits_per_pixel=32;\n              }\n          }\n      }\n    bytes_per_line=4*((image->columns*bmp_info.bits_per_pixel+31)/32);\n    bmp_info.ba_offset=0;\n    profile=GetImageProfile(image,\"icc\");\n    have_color_info=(image->rendering_intent != UndefinedIntent) ||\n      (profile != (StringInfo *) NULL) || (image->gamma != 0.0) ?  MagickTrue :\n      MagickFalse;\n    if (type == 2)\n      bmp_info.size=12;\n    else\n      if ((type == 3) || ((image->alpha_trait == UndefinedPixelTrait) &&\n          (have_color_info == MagickFalse)))\n        {\n          type=3;\n          bmp_info.size=40;\n        }\n      else\n        {\n          int\n            extra_size;\n\n          bmp_info.size=108;\n          extra_size=68;\n          if ((image->rendering_intent != UndefinedIntent) ||\n              (profile != (StringInfo *) NULL))\n            {\n              bmp_info.size=124;\n              extra_size+=16;\n            }\n          bmp_info.file_size+=extra_size;\n          bmp_info.offset_bits+=extra_size;\n        }\n    if (((ssize_t) image->columns != (ssize_t) ((signed int) image->columns)) ||\n        ((ssize_t) image->rows != (ssize_t) ((signed int) image->rows)))\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    bmp_info.width=(ssize_t) image->columns;\n    bmp_info.height=(ssize_t) image->rows;\n    bmp_info.planes=1;\n    bmp_info.image_size=(unsigned int) (bytes_per_line*image->rows);\n    bmp_info.file_size+=bmp_info.image_size;\n    bmp_info.x_pixels=75*39;\n    bmp_info.y_pixels=75*39;\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x/2.54);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y/2.54);\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        bmp_info.x_pixels=(unsigned int) (100.0*image->resolution.x);\n        bmp_info.y_pixels=(unsigned int) (100.0*image->resolution.y);\n        break;\n      }\n    }\n    bmp_info.colors_important=bmp_info.number_colors;\n    /*\n      Convert MIFF to BMP raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory(image->rows,MagickMax(bytes_per_line,\n      image->columns+256UL)*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    (void) memset(pixels,0,(size_t) bmp_info.image_size);\n    switch (bmp_info.bits_per_pixel)\n    {\n      case 1:\n      {\n        size_t\n          bit,\n          byte;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          ssize_t\n            offset;\n\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          bit=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=1;\n            byte|=GetPixelIndex(image,p) != 0 ? 0x01 : 0x00;\n            bit++;\n            if (bit == 8)\n              {\n                *q++=(unsigned char) byte;\n                bit=0;\n                byte=0;\n              }\n             p+=GetPixelChannels(image);\n           }\n           if (bit != 0)\n             {\n               *q++=(unsigned char) (byte << (8-bit));\n               x++;\n             }\n          offset=(ssize_t) (image->columns+7)/8;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 4:\n      {\n        unsigned int\n          byte,\n          nibble;\n\n        ssize_t\n          offset;\n\n        /*\n          Convert PseudoClass image to a BMP monochrome image.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          nibble=0;\n          byte=0;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            byte<<=4;\n            byte|=((unsigned int) GetPixelIndex(image,p) & 0x0f);\n            nibble++;\n            if (nibble == 2)\n              {\n                *q++=(unsigned char) byte;\n                nibble=0;\n                byte=0;\n              }\n            p+=GetPixelChannels(image);\n          }\n          if (nibble != 0)\n            {\n              *q++=(unsigned char) (byte << 4);\n              x++;\n            }\n          offset=(ssize_t) (image->columns+1)/2;\n          for (x=offset; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 8:\n      {\n        /*\n          Convert PseudoClass packet to BMP pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=(unsigned char) GetPixelIndex(image,p);\n            p+=GetPixelChannels(image);\n          }\n          for ( ; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 16:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            unsigned short\n              pixel;\n\n            pixel=0;\n            if (bmp_subtype == ARGB4444)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelAlpha(image,p),15) << 12);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),15) << 8);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),15) << 4);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),15));\n              }\n            else if (bmp_subtype == RGB565)\n              {\n                pixel=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 11);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),63) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            else\n              {\n                if (bmp_subtype == ARGB1555)\n                  pixel=(unsigned short) (ScaleQuantumToAny(\n                    GetPixelAlpha(image,p),1) << 15);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelRed(image,p),31) << 10);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelGreen(image,p),31) << 5);\n                pixel|=(unsigned short) (ScaleQuantumToAny(\n                  GetPixelBlue(image,p),31));\n              }\n            *((unsigned short *) q)=pixel;\n            q+=2;\n            p+=GetPixelChannels(image);\n          }\n          for (x=2L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 24:\n      {\n        /*\n          Convert DirectClass packet to BMP BGR888.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            p+=GetPixelChannels(image);\n          }\n          for (x=3L*(ssize_t) image->columns; x < (ssize_t) bytes_per_line; x++)\n            *q++=0x00;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n      case 32:\n      {\n        /*\n          Convert DirectClass packet to ARGB8888 pixel.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          q=pixels+(image->rows-y-1)*bytes_per_line;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n            p+=GetPixelChannels(image);\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n        break;\n      }\n    }\n    if ((type > 2) && (bmp_info.bits_per_pixel == 8))\n      if (image_info->compression != NoCompression)\n        {\n          MemoryInfo\n            *rle_info;\n\n          /*\n            Convert run-length encoded raster pixels.\n          */\n          rle_info=AcquireVirtualMemory((size_t) (2*(bytes_per_line+2)+2),\n            (image->rows+2)*sizeof(*pixels));\n          if (rle_info == (MemoryInfo *) NULL)\n            {\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n            }\n          bmp_data=(unsigned char *) GetVirtualMemoryBlob(rle_info);\n          bmp_info.file_size-=bmp_info.image_size;\n          bmp_info.image_size=(unsigned int) EncodeImage(image,bytes_per_line,\n            pixels,bmp_data);\n          bmp_info.file_size+=bmp_info.image_size;\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          pixel_info=rle_info;\n          pixels=bmp_data;\n          bmp_info.compression=BI_RLE8;\n        }\n    /*\n      Write BMP for Windows, all versions, 14-byte header.\n    */\n    if (image->debug != MagickFalse)\n      {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Writing BMP version %.20g datastream\",(double) type);\n        if (image->storage_class == DirectClass)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=DirectClass\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Storage class=PseudoClass\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   Image depth=%.20g\",(double) image->depth);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=True\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Matte=MagickFalse\");\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"   BMP bits_per_pixel=%.20g\",(double) bmp_info.bits_per_pixel);\n        switch ((int) bmp_info.compression)\n        {\n           case BI_RGB:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RGB\");\n             break;\n           }\n           case BI_RLE8:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_RLE8\");\n             break;\n           }\n           case BI_BITFIELDS:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=BI_BITFIELDS\");\n             break;\n           }\n           default:\n           {\n             (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"   Compression=UNKNOWN (%u)\",bmp_info.compression);\n             break;\n           }\n        }\n        if (bmp_info.number_colors == 0)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=unspecified\");\n        else\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   Number_colors=%u\",bmp_info.number_colors);\n      }\n    profile_data=0;\n    profile_size=0;\n    profile_size_pad=0;\n    if (profile != (StringInfo *) NULL)\n      {\n        profile_data=(MagickOffsetType) bmp_info.file_size-14;  /* from head of BMP info header */\n        profile_size=(MagickOffsetType) GetStringInfoLength(profile);\n        if ((profile_size % 4) > 0)\n          profile_size_pad=4-(profile_size%4);\n        bmp_info.file_size+=profile_size+profile_size_pad;\n      }\n    (void) WriteBlob(image,2,(unsigned char *) \"BM\");\n    (void) WriteBlobLSBLong(image,bmp_info.file_size);\n    (void) WriteBlobLSBLong(image,bmp_info.ba_offset);  /* always 0 */\n    (void) WriteBlobLSBLong(image,bmp_info.offset_bits);\n    if (type == 2)\n      {\n        /*\n          Write 12-byte version 2 bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.width);\n        (void) WriteBlobLSBSignedShort(image,(signed short) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n      }\n    else\n      {\n        /*\n          Write 40-byte version 3+ bitmap header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.size);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.width);\n        (void) WriteBlobLSBSignedLong(image,(signed int) bmp_info.height);\n        (void) WriteBlobLSBShort(image,bmp_info.planes);\n        (void) WriteBlobLSBShort(image,bmp_info.bits_per_pixel);\n        (void) WriteBlobLSBLong(image,bmp_info.compression);\n        (void) WriteBlobLSBLong(image,bmp_info.image_size);\n        (void) WriteBlobLSBLong(image,bmp_info.x_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.y_pixels);\n        (void) WriteBlobLSBLong(image,bmp_info.number_colors);\n        (void) WriteBlobLSBLong(image,bmp_info.colors_important);\n      }\n    if ((type > 3) && ((image->alpha_trait != UndefinedPixelTrait) ||\n        (have_color_info != MagickFalse)))\n      {\n        /*\n          Write the rest of the 108-byte BMP Version 4 header.\n        */\n        (void) WriteBlobLSBLong(image,bmp_info.red_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.green_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.blue_mask);\n        (void) WriteBlobLSBLong(image,bmp_info.alpha_mask);\n        if (profile != (StringInfo *) NULL)\n          (void) WriteBlobLSBLong(image,0x4D424544U);  /* PROFILE_EMBEDDED */\n        else\n          (void) WriteBlobLSBLong(image,0x73524742U);  /* sRGB */\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.red_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.red_primary.x+\n          image->chromaticity.red_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.green_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.green_primary.x+\n          image->chromaticity.green_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.x*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (image->chromaticity.blue_primary.y*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          ((1.000f-(image->chromaticity.blue_primary.x+\n          image->chromaticity.blue_primary.y))*0x40000000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.x*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.y*0x10000));\n        (void) WriteBlobLSBLong(image,(unsigned int)\n          (bmp_info.gamma_scale.z*0x10000));\n        if ((image->rendering_intent != UndefinedIntent) ||\n            (profile != (StringInfo *) NULL))\n          {\n            ssize_t\n              intent;\n\n            switch ((int) image->rendering_intent)\n            {\n              case SaturationIntent:\n              {\n                intent=LCS_GM_BUSINESS;\n                break;\n              }\n              case RelativeIntent:\n              {\n                intent=LCS_GM_GRAPHICS;\n                break;\n              }\n              case PerceptualIntent:\n              {\n                intent=LCS_GM_IMAGES;\n                break;\n              }\n              case AbsoluteIntent:\n              {\n                intent=LCS_GM_ABS_COLORIMETRIC;\n                break;\n              }\n              default:\n              {\n                intent=0;\n                break;\n              }\n            }\n            (void) WriteBlobLSBLong(image,(unsigned int) intent);\n            (void) WriteBlobLSBLong(image,(unsigned int) profile_data);\n            (void) WriteBlobLSBLong(image,(unsigned int)\n              (profile_size+profile_size_pad));\n            (void) WriteBlobLSBLong(image,0x00);  /* reserved */\n          }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        unsigned char\n          *bmp_colormap;\n\n        /*\n          Dump colormap to file.\n        */\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  Colormap: %.20g entries\",(double) image->colors);\n        bmp_colormap=(unsigned char *) AcquireQuantumMemory((size_t) (1UL <<\n          bmp_info.bits_per_pixel),4*sizeof(*bmp_colormap));\n        if (bmp_colormap == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        q=bmp_colormap;\n        for (i=0; i < (ssize_t) MagickMin((ssize_t) image->colors,(ssize_t) bmp_info.number_colors); i++)\n        {\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          if (type > 2)\n            *q++=(unsigned char) 0x0;\n        }\n        for ( ; i < (ssize_t) (1UL << bmp_info.bits_per_pixel); i++)\n        {\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          *q++=(unsigned char) 0x00;\n          if (type > 2)\n            *q++=(unsigned char) 0x00;\n        }\n        if (type <= 2)\n          (void) WriteBlob(image,(size_t) (3*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        else\n          (void) WriteBlob(image,(size_t) (4*(1L << bmp_info.bits_per_pixel)),\n            bmp_colormap);\n        bmp_colormap=(unsigned char *) RelinquishMagickMemory(bmp_colormap);\n      }\n    if (image->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Pixels:  %u bytes\",bmp_info.image_size);\n    (void) WriteBlob(image,(size_t) bmp_info.image_size,pixels);\n    if (profile != (StringInfo *) NULL)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                                \"  Profile:  %g bytes\",(double) profile_size+profile_size_pad);\n        (void) WriteBlob(image,(size_t) profile_size,GetStringInfoDatum(profile));\n        if (profile_size_pad > 0)  /* padding for 4 bytes multiple */\n          (void) WriteBlob(image,(size_t) profile_size_pad,\"\\0\\0\\0\");\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        V   V  IIIII  FFFFF  FFFFF                           %\n%                        V   V    I    F      F                               %\n%                        V   V    I    FFF    FFF                             %\n%                         V V     I    F      F                               %\n%                          V    IIIII  F      F                               %\n%                                                                             %\n%                                                                             %\n%                Read/Write Khoros Visualization Image Format                 %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/memory-private.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WriteVIFFImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s V I F F                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsVIFF() returns MagickTrue if the image format type, identified by the\n%  magick string, is VIFF.\n%\n%  The format of the IsVIFF method is:\n%\n%      MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsVIFF(const unsigned char *magick,const size_t length)\n{\n  if (length < 2)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\253\\001\",2) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d V I F F I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadVIFFImage() reads a Khoros Visualization image file and returns\n%  it.  It allocates the memory necessary for the new Image structure and\n%  returns a pointer to the new image.\n%\n%  The format of the ReadVIFFImage method is:\n%\n%      Image *ReadVIFFImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: Method ReadVIFFImage returns a pointer to the image after\n%      reading.  A null image is returned if there is a memory shortage or if\n%      the image cannot be read.\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    if (count != 512)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=ReadBlobSignedLong(image);\n    viff_info.y_offset=ReadBlobSignedLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    (void) SetImageBackgroundColor(image,exception);\n    /*\n      Verify that we can read this VIFF image.\n    */\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        if ((MagickSizeType) viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=(MagickRealType)\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Create bi-level colormap.\n        */\n        image->colors=2;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        image->colorspace=GRAYColorspace;\n      }\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n      number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*\n      bytes_per_pixel*sizeof(*pixels));\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red),q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green),q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue),q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count == 1) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            status=MagickFalse;\n            break;\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r V I F F I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterVIFFImage() adds properties for the VIFF image format to\n%  the list of supported formats.  The properties include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterVIFFImage method is:\n%\n%      size_t RegisterVIFFImage(void)\n%\n*/\nModuleExport size_t RegisterVIFFImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"VIFF\",\"VIFF\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->magick=(IsImageFormatHandler *) IsVIFF;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"VIFF\",\"XV\",\"Khoros Visualization image\");\n  entry->decoder=(DecodeImageHandler *) ReadVIFFImage;\n  entry->encoder=(EncodeImageHandler *) WriteVIFFImage;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r V I F F I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterVIFFImage() removes format registrations made by the\n%  VIFF module from the list of supported formats.\n%\n%  The format of the UnregisterVIFFImage method is:\n%\n%      UnregisterVIFFImage(void)\n%\n*/\nModuleExport void UnregisterVIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"VIFF\");\n  (void) UnregisterMagickInfo(\"XV\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e V I F F I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WriteVIFFImage() writes an image to a file in the VIFF image format.\n%\n%  The format of the WriteVIFFImage method is:\n%\n%      MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n\n    size_t\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels,\n    packets;\n\n  MemoryInfo\n    *pixel_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    imageListLength;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) memset(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Initialize VIFF image structure.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  /* IEEE byte ordering */\n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  /* no colormap */\n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Full color VIFF raster.\n        */\n        viff_info.number_data_bands=image->alpha_trait ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (SetImageGray(image,exception) == MagickFalse)\n          {\n            /*\n              Colormapped VIFF raster.\n            */\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              /*\n                Monochrome VIFF raster.\n              */\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    /*\n      Write VIFF image header (pad to 1024 bytes).\n    */\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    /*\n      Convert MIFF to VIFF raster pixels.\n    */\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert DirectClass packet to VIFF RGB pixel.\n        */\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(image,p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (SetImageGray(image,exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n\n          /*\n            Dump colormap to file.\n          */\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          /*\n            Convert PseudoClass packet to VIFF colormapped pixels.\n          */\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a VIFF monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            /*\n              Convert PseudoClass packet to VIFF grayscale pixel.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p+=GetPixelChannels(image);\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,imageListLength);\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/bmp.c", "coders/viff.c"], "buggy_code_start_loc": [1517, 780], "buggy_code_end_loc": [1518, 782], "fixing_code_start_loc": [1517, 780], "fixing_code_end_loc": [1518, 782], "type": "CWE-401", "message": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadBMPImage in coders/bmp.c.", "other": {"cve": {"id": "CVE-2019-13133", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-01T20:15:11.180", "lastModified": "2021-06-02T19:51:24.950", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick before 7.0.8-50 has a memory leak vulnerability in the function ReadBMPImage in coders/bmp.c."}, {"lang": "es", "value": "ImageMagick en versiones anteriores a la 7.0.8-50 tiene una vulnerabilidad de fuga de memoria en la funci\u00f3n ReadBMPImage in coders/bmp.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-50", "matchCriteriaId": "F8AB2B06-598F-4F38-813C-B1E3E1E7EEE5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/fe3066122ef72c82415811d25e9e3fad622c0a99", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1600", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/fe3066122ef72c82415811d25e9e3fad622c0a99"}}