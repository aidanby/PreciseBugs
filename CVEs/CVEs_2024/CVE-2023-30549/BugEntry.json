{"buggy_code": ["// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage actions\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/exec\"\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/require\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs\"\n\t\"github.com/pkg/errors\"\n)\n\ntype actionTests struct {\n\tenv e2e.TestEnv\n}\n\n// run tests min fuctionality for singularity symlink using actionRun\nfunc (c actionTests) singularityLink(t *testing.T) {\n\tsaveCmdPath := c.env.CmdPath\n\ti := strings.LastIndex(saveCmdPath, \"apptainer\")\n\tc.env.CmdPath = saveCmdPath[:i] + \"singularity\"\n\n\tc.actionRun(t)\n\n\tc.env.CmdPath = saveCmdPath\n}\n\n// run tests min fuctionality for apptainer run\nfunc (c actionTests) actionRun(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname string\n\t\targv []string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname: \"NoCommand\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targv: []string{c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targv: []string{c.env.ImagePath, \"false\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestAppGood\",\n\t\t\targv: []string{\"--app\", \"testapp\", c.env.ImagePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestAppBad\",\n\t\t\targv: []string{\"--app\", \"fakeapp\", c.env.ImagePath},\n\t\t\texit: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"run\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// exec tests min fuctionality for apptainer exec\nfunc (c actionTests) actionExec(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tuser := e2e.CurrentUser(t)\n\n\t// Create a temp testfile\n\ttestdata, err := fs.MakeTmpDir(c.env.TestDir, \"testdata\", 0o755)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(testdata)\n\n\ttestdataTmp := filepath.Join(testdata, \"tmp\")\n\tif err := os.Mkdir(testdataTmp, 0o755); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a temp testfile\n\ttmpfile, err := fs.MakeTmpFile(testdataTmp, \"testApptainerExec.\", 0o644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmpfile.Close()\n\n\tbasename := filepath.Base(tmpfile.Name())\n\ttmpfilePath := filepath.Join(\"/tmp\", basename)\n\tvartmpfilePath := filepath.Join(\"/var/tmp\", basename)\n\thomePath := filepath.Join(\"/home\", basename)\n\n\ttests := []struct {\n\t\tname string\n\t\targv []string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname: \"NoCommand\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targv: []string{c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"TrueAbsPAth\",\n\t\t\targv: []string{c.env.ImagePath, \"/bin/true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targv: []string{c.env.ImagePath, \"false\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"FalseAbsPath\",\n\t\t\targv: []string{c.env.ImagePath, \"/bin/false\"},\n\t\t\texit: 1,\n\t\t},\n\t\t// Scif apps tests\n\t\t{\n\t\t\tname: \"ScifTestAppGood\",\n\t\t\targv: []string{\"--app\", \"testapp\", c.env.ImagePath, \"testapp.sh\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestAppBad\",\n\t\t\targv: []string{\"--app\", \"fakeapp\", c.env.ImagePath, \"testapp.sh\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/apps\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/data\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/apps/foo\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/apps/bar\"},\n\t\t\texit: 0,\n\t\t},\n\t\t// blocked by issue [scif-apps] Files created at install step fall into an unexpected path #2404\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-f\", \"/scif/apps/foo/filefoo.exec\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-f\", \"/scif/apps/bar/filebar.exec\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/data/foo/output\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/data/foo/input\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ContainOnly\",\n\t\t\targv: []string{\"--contain\", c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirOnly\",\n\t\t\targv: []string{\"--workdir\", testdata, c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirContain\",\n\t\t\targv: []string{\"--workdir\", testdata, \"--contain\", c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"PwdGood\",\n\t\t\targv: []string{\"--pwd\", \"/etc\", c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Home\",\n\t\t\targv: []string{\"--home\", testdata, c.env.ImagePath, \"test\", \"-f\", tmpfile.Name()},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"HomePath\",\n\t\t\targv: []string{\"--home\", testdataTmp + \":/home\", c.env.ImagePath, \"test\", \"-f\", homePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"HomeTmp\",\n\t\t\targv: []string{\"--home\", \"/tmp\", c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"HomeTmpExplicit\",\n\t\t\targv: []string{\"--home\", \"/tmp:/home\", c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"UserBindTmp\",\n\t\t\targv: []string{\"--bind\", testdataTmp + \":/tmp\", c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"UserBindVarTmp\",\n\t\t\targv: []string{\"--bind\", testdataTmp + \":/var/tmp\", c.env.ImagePath, \"test\", \"-f\", vartmpfilePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NoHome\",\n\t\t\targv: []string{\"--no-home\", c.env.ImagePath, \"ls\", \"-ld\", user.Dir},\n\t\t\texit: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithDir(\"/tmp\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// Shell interaction tests\nfunc (c actionTests) actionShell(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\thostname, err := os.Hostname()\n\terr = errors.Wrap(err, \"getting hostname\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not get hostname: %+v\", err)\n\t}\n\n\ttests := []struct {\n\t\tname       string\n\t\targv       []string\n\t\tconsoleOps []e2e.ApptainerConsoleOp\n\t\texit       int\n\t}{\n\t\t{\n\t\t\tname: \"ShellExit\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\tconsoleOps: []e2e.ApptainerConsoleOp{\n\t\t\t\t// \"cd /\" to work around issue where a long\n\t\t\t\t// working directory name causes the test\n\t\t\t\t// to fail because the \"Apptainer\" that\n\t\t\t\t// we are looking for is chopped from the\n\t\t\t\t// front.\n\t\t\t\t// TODO(mem): This test was added back in 491a71716013654acb2276e4b37c2e015d2dfe09\n\t\t\t\te2e.ConsoleSendLine(\"cd /\"),\n\t\t\t\te2e.ConsoleExpect(\"Singularity\"),\n\t\t\t\te2e.ConsoleSendLine(\"exit\"),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ShellHostname\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\tconsoleOps: []e2e.ApptainerConsoleOp{\n\t\t\t\te2e.ConsoleSendLine(\"hostname\"),\n\t\t\t\te2e.ConsoleExpect(hostname),\n\t\t\t\te2e.ConsoleSendLine(\"exit\"),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ShellBadCommand\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\tconsoleOps: []e2e.ApptainerConsoleOp{\n\t\t\t\te2e.ConsoleSendLine(\"_a_fake_command\"),\n\t\t\t\te2e.ConsoleSendLine(\"exit\"),\n\t\t\t},\n\t\t\texit: 127,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"shell\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ConsoleRun(tt.consoleOps...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// STDPipe tests pipe stdin/stdout to apptainer actions cmd\nfunc (c actionTests) STDPipe(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tstdinTests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\tinput   string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"TrueSTDIN\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.ImagePath, \"grep\", \"hi\"},\n\t\t\tinput:   \"hi\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"FalseSTDIN\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.ImagePath, \"grep\", \"hi\"},\n\t\t\tinput:   \"bye\",\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"TrueLibrary\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\"},\n\t\t\tinput:   \"true\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"FalseLibrary\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\"},\n\t\t\tinput:   \"false\",\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"TrueDocker\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"docker://busybox\"},\n\t\t\tinput:   \"true\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"FalseDocker\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"docker://busybox\"},\n\t\t\tinput:   \"false\",\n\t\t\texit:    1,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"TrueShub\",\n\t\t// \tcommand: \"shell\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\"},\n\t\t// \tinput:   \"true\",\n\t\t// \texit:    0,\n\t\t// },\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"FalseShub\",\n\t\t// \tcommand: \"shell\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\"},\n\t\t// \tinput:   \"false\",\n\t\t// \texit:    1,\n\t\t// },\n\t}\n\n\tvar input bytes.Buffer\n\n\tfor _, tt := range stdinTests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.WithStdin(&input),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tinput.WriteString(tt.input)\n\t\t\t}),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t\tinput.Reset()\n\t}\n\n\tuser := e2e.CurrentUser(t)\n\tstdoutTests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\toutput  string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"AppsFoo\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--app\", \"foo\", c.env.ImagePath},\n\t\t\toutput:  \"RUNNING FOO\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"PwdPath\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"--pwd\", \"/etc\", c.env.ImagePath, \"pwd\"},\n\t\t\toutput:  \"/etc\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Arguments\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{c.env.ImagePath, \"foo\"},\n\t\t\toutput:  \"Running command: foo\",\n\t\t\texit:    127,\n\t\t},\n\t\t{\n\t\t\tname:    \"Permissions\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.ImagePath, \"id\", \"-un\"},\n\t\t\toutput:  user.Name,\n\t\t\texit:    0,\n\t\t},\n\t}\n\tfor _, tt := range stdoutTests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(\n\t\t\t\ttt.exit,\n\t\t\t\te2e.ExpectOutput(e2e.ExactMatch, tt.output),\n\t\t\t),\n\t\t)\n\t}\n}\n\n// RunFromURI tests min fuctionality for apptainer run/exec URI://\nfunc (c actionTests) RunFromURI(t *testing.T) {\n\te2e.EnsureORASImage(t, c.env)\n\n\trunScript := \"testdata/runscript.sh\"\n\tbind := fmt.Sprintf(\"%s:/.singularity.d/runscript\", runScript)\n\n\tfi, err := os.Stat(runScript)\n\tif err != nil {\n\t\tt.Fatalf(\"can't find %s\", runScript)\n\t}\n\tsize := strconv.Itoa(int(fi.Size()))\n\n\ttests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\texit    int\n\t\tprofile e2e.Profile\n\t}{\n\t\t// Run from supported URI's and check the runscript call works\n\t\t{\n\t\t\tname:    \"RunFromDockerOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"docker://busybox:latest\", size},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromDockerWithoutShellOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"docker://hello-world\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromLibraryOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"oras://ghcr.io/apptainer/busybox:1.31.1\", size},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"RunFromShubOK\",\n\t\t// \tcommand: \"run\",\n\t\t// \targv:    []string{\"--bind\", bind, \"shub://singularityhub/busybox\", size},\n\t\t// \texit:    0,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"RunFromOrasOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, c.env.OrasTestImage, size},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromDockerKO\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"docker://busybox:latest\", \"0\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromLibraryKO\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"oras://ghcr.io/apptainer/busybox:1.31.1\", \"0\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"RunFromShubKO\",\n\t\t// \tcommand: \"run\",\n\t\t// \targv:    []string{\"--bind\", bind, \"shub://singularityhub/busybox\", \"0\"},\n\t\t// \texit:    1,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"RunFromOrasKO\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, c.env.OrasTestImage, \"0\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\n\t\t// exec from a supported URI's and check the exit code\n\t\t{\n\t\t\tname:    \"ExecTrueDocker\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecTrueLibrary\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecTrueShub\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"true\"},\n\t\t// \texit:    0,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecTrueOras\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseDocker\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseLibrary\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecFalseShub\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"false\"},\n\t\t// \texit:    1,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecFalseOras\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\n\t\t// exec from URI with user namespace enabled\n\t\t{\n\t\t\tname:    \"ExecTrueDockerUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecTrueLibraryUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecTrueShubUserns\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"true\"},\n\t\t// \texit:    0,\n\t\t// \tprofile: e2e.UserNamespaceProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecTrueOrasUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseDockerUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseLibraryUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecFalseShubUserns\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"false\"},\n\t\t// \texit:    1,\n\t\t// \tprofile: e2e.UserNamespaceProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecFalseOrasUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// PersistentOverlay test the --overlay function\nfunc (c actionTests) PersistentOverlay(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\trequire.Filesystem(t, \"overlay\")\n\n\trequire.Command(t, \"mkfs.ext3\")\n\trequire.Command(t, \"mksquashfs\")\n\trequire.Command(t, \"dd\")\n\n\ttestdir, err := ioutil.TempDir(c.env.TestDir, \"persistent-overlay-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func(t *testing.T) {\n\t\tif t.Failed() {\n\t\t\tt.Logf(\"Not removing directory %s for test %s\", testdir, t.Name())\n\t\t\treturn\n\t\t}\n\t\terr := os.RemoveAll(testdir)\n\t\tif err != nil {\n\t\t\tt.Logf(\"Error while removing directory %s for test %s: %#v\", testdir, t.Name(), err)\n\t\t}\n\t}\n\t// sandbox overlay implies creation of upper/work directories by\n\t// Apptainer, so we would need privileges to delete the test\n\t// directory correctly\n\tdefer e2e.Privileged(cleanup)\n\n\tsquashfsImage := filepath.Join(testdir, \"squashfs.simg\")\n\text3Img := filepath.Join(testdir, \"ext3_fs.img\")\n\tsandboxImage := filepath.Join(testdir, \"sandbox\")\n\n\t// create an overlay directory\n\tdir, err := ioutil.TempDir(testdir, \"overlay-dir-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create root directory for squashfs image\n\tsquashDir, err := ioutil.TempDir(testdir, \"root-squash-dir-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsquashMarkerFile := \"squash_marker\"\n\tif err := fs.Touch(filepath.Join(squashDir, squashMarkerFile)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create the squashfs overlay image\n\tcmd := exec.Command(\"mksquashfs\", squashDir, squashfsImage, \"-noappend\", \"-all-root\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create the overlay ext3 image\n\tcmd = exec.Command(\"dd\", \"if=/dev/zero\", \"of=\"+ext3Img, \"bs=1M\", \"count=64\", \"status=none\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\tcmd = exec.Command(\"mkfs.ext3\", \"-q\", \"-F\", ext3Img)\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create a sandbox image from test image\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--sandbox\", sandboxImage, c.env.ImagePath),\n\t\te2e.PostRun(func(t *testing.T) {\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatalf(\"failed to create sandbox %s from test image %s\", sandboxImage, c.env.ImagePath)\n\t\t\t}\n\t\t}),\n\t\te2e.ExpectExit(0),\n\t)\n\n\ttests := []struct {\n\t\tname    string\n\t\targv    []string\n\t\tdir     string\n\t\texit    int\n\t\tprofile e2e.Profile\n\t}{\n\t\t{\n\t\t\tname:    \"overlay_create\",\n\t\t\targv:    []string{\"--overlay\", dir, c.env.ImagePath, \"touch\", \"/dir_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_ext3_create\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, c.env.ImagePath, \"touch\", \"/ext3_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_create\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"touch\", \"/multiple_overlay_fs\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find\",\n\t\t\targv:    []string{\"--overlay\", dir, c.env.ImagePath, \"test\", \"-f\", \"/dir_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find_with_writable_fail\",\n\t\t\targv:    []string{\"--overlay\", dir, \"--writable\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find_with_writable_tmpfs\",\n\t\t\targv:    []string{\"--overlay\", dir + \":ro\", \"--writable-tmpfs\", c.env.ImagePath, \"test\", \"-f\", \"/dir_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find_with_writable_tmpfs_fail\",\n\t\t\targv:    []string{\"--overlay\", dir, \"--writable-tmpfs\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_ext3_find\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, c.env.ImagePath, \"test\", \"-f\", \"/ext3_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_writable_fail\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", ext3Img, c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_squashFS_find\",\n\t\t\targv:    []string{\"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"test\", \"-f\", fmt.Sprintf(\"/%s\", squashMarkerFile)},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_squashFS_find_without_ro\",\n\t\t\targv:    []string{\"--overlay\", squashfsImage, c.env.ImagePath, \"test\", \"-f\", fmt.Sprintf(\"/%s\", squashMarkerFile)},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_find_ext3\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"test\", \"-f\", \"/multiple_overlay_fs\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_find_squashfs\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"test\", \"-f\", fmt.Sprintf(\"/%s\", squashMarkerFile)},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_noroot\",\n\t\t\targv:    []string{\"--overlay\", dir, c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_noflag\",\n\t\t\targv:    []string{c.env.ImagePath, \"test\", \"-f\", \"/foo_overlay\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\t// https://github.com/apptainer/singularity/issues/4329\n\t\t\tname:    \"SIF_writable_without_overlay_partition_issue_4329\",\n\t\t\targv:    []string{\"--writable\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\t// https://github.com/apptainer/singularity/issues/4270\n\t\t\tname:    \"overlay_dir_relative_path_issue_4270\",\n\t\t\targv:    []string{\"--overlay\", filepath.Base(dir), sandboxImage, \"test\", \"-f\", \"/dir_overlay\"},\n\t\t\tdir:     filepath.Dir(dir),\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithDir(tt.dir),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\nfunc (c actionTests) actionBasicProfiles(t *testing.T) {\n\tenv := c.env\n\n\te2e.EnsureImage(t, env)\n\n\ttests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"ExecTrue\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecPidNsTrue\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalse\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecPidNsFalse\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunTrue\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunPidNsTrue\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFalse\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunPidNsFalse\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunBindTrue\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", \"/etc/passwd\", env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunBindFalse\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", \"/etc/passwd\", env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t}\n\n\tfor _, profile := range e2e.Profiles {\n\t\tprofile := profile\n\n\t\tt.Run(profile.String(), func(t *testing.T) {\n\t\t\tfor _, tt := range tests {\n\t\t\t\tenv.RunApptainer(\n\t\t\t\t\tt,\n\t\t\t\t\te2e.AsSubtest(tt.name),\n\t\t\t\t\te2e.WithProfile(profile),\n\t\t\t\t\te2e.WithCommand(tt.command),\n\t\t\t\t\te2e.WithArgs(tt.argv...),\n\t\t\t\t\te2e.ExpectExit(tt.exit),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (c actionTests) actionNetwork(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\te2e.Privileged(require.Network)(t)\n\n\ttests := []struct {\n\t\tname       string\n\t\tprofile    e2e.Profile\n\t\tnetType    string\n\t\texpectExit int\n\t}{\n\t\t{\n\t\t\tname:       \"BridgeNetwork\",\n\t\t\tprofile:    e2e.RootProfile,\n\t\t\tnetType:    \"bridge\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"PtpNetwork\",\n\t\t\tprofile:    e2e.RootProfile,\n\t\t\tnetType:    \"ptp\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"UnknownNetwork\",\n\t\t\tprofile:    e2e.RootProfile,\n\t\t\tnetType:    \"unknown\",\n\t\t\texpectExit: 255,\n\t\t},\n\t\t{\n\t\t\tname:       \"FakerootNetwork\",\n\t\t\tprofile:    e2e.FakerootProfile,\n\t\t\tnetType:    \"fakeroot\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"NoneNetwork\",\n\t\t\tprofile:    e2e.UserProfile,\n\t\t\tnetType:    \"none\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"UserBridgeNetwork\",\n\t\t\tprofile:    e2e.UserProfile,\n\t\t\tnetType:    \"bridge\",\n\t\t\texpectExit: 255,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(\"--net\", \"--network\", tt.netType, c.env.ImagePath, \"id\"),\n\t\t\te2e.ExpectExit(tt.expectExit),\n\t\t)\n\t}\n}\n\n//nolint:maintidx\nfunc (c actionTests) actionBinds(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tworkspace, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"bind-workspace-\", \"\")\n\tsandbox, _ := e2e.MakeTempDir(t, workspace, \"sandbox-\", \"\")\n\tdefer e2e.Privileged(cleanup)\n\n\tcontCanaryDir := \"/canary\"\n\thostCanaryDir := filepath.Join(workspace, \"canary\")\n\n\tcontCanaryFile := \"/canary/file\"\n\thostCanaryFile := filepath.Join(hostCanaryDir, \"file\")\n\thostCanaryFileWithComma := filepath.Join(hostCanaryDir, \"file,comma\")\n\thostCanaryFileWithColon := filepath.Join(hostCanaryDir, \"file:colon\")\n\n\tcanaryFileBind := hostCanaryFile + \":\" + contCanaryFile\n\tcanaryFileMount := \"type=bind,source=\" + hostCanaryFile + \",destination=\" + contCanaryFile\n\tcanaryDirBind := hostCanaryDir + \":\" + contCanaryDir\n\tcanaryDirMount := \"type=bind,source=\" + hostCanaryDir + \",destination=\" + contCanaryDir\n\n\thostHomeDir := filepath.Join(workspace, \"home\")\n\thostWorkDir := filepath.Join(workspace, \"workdir\")\n\n\tcreateWorkspaceDirs := func(t *testing.T) {\n\t\te2e.Privileged(func(t *testing.T) {\n\t\t\tif err := os.RemoveAll(hostCanaryDir); err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete canary_dir: %s\", err)\n\t\t\t}\n\t\t\tif err := os.RemoveAll(hostHomeDir); err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete workspace home: %s\", err)\n\t\t\t}\n\t\t\tif err := os.RemoveAll(hostWorkDir); err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete workspace work: %s\", err)\n\t\t\t}\n\t\t})(t)\n\n\t\tif err := fs.Mkdir(hostCanaryDir, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_dir: %s\", err)\n\t\t}\n\t\tif err := fs.Touch(hostCanaryFile); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_file: %s\", err)\n\t\t}\n\t\tif err := fs.Touch(hostCanaryFileWithComma); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_file_comma: %s\", err)\n\t\t}\n\t\tif err := fs.Touch(hostCanaryFileWithColon); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_file_colon: %s\", err)\n\t\t}\n\t\tif err := os.Chmod(hostCanaryFile, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to apply permissions on canary_file: %s\", err)\n\t\t}\n\t\tif err := fs.Mkdir(hostHomeDir, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to create workspace home directory: %s\", err)\n\t\t}\n\t\tif err := fs.Mkdir(hostWorkDir, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to create workspace work directory: %s\", err)\n\t\t}\n\t}\n\n\t// convert test image to sandbox\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--force\", \"--sandbox\", sandbox, c.env.ImagePath),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tcheckHostFn := func(path string, fn func(string) bool) func(*testing.T) {\n\t\treturn func(t *testing.T) {\n\t\t\tif t.Failed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !fn(path) {\n\t\t\t\tt.Errorf(\"%s not found on host\", path)\n\t\t\t}\n\t\t\tif err := os.RemoveAll(path); err != nil {\n\t\t\t\tt.Errorf(\"failed to delete %s: %s\", path, err)\n\t\t\t}\n\t\t}\n\t}\n\tcheckHostFile := func(path string) func(*testing.T) {\n\t\treturn checkHostFn(path, fs.IsFile)\n\t}\n\tcheckHostDir := func(path string) func(*testing.T) {\n\t\treturn checkHostFn(path, fs.IsDir)\n\t}\n\n\ttests := []struct {\n\t\tname    string\n\t\targs    []string\n\t\tpostRun func(*testing.T)\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname: \"NonExistentSource\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", \"/non/existent/source/path\",\n\t\t\t\tsandbox,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"RelativeBindDestination\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFile + \":relative\",\n\t\t\t\tsandbox,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFile\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryFileBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFilePwd\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryFileBind,\n\t\t\t\t\"--pwd\", contCanaryDir,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDir\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDirPwd\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--pwd\", contCanaryDir,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFileWritableOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", hostCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", hostCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFileWritableKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", canaryFileBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDirWritableOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", hostCanaryDir,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", hostCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDirWritableKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"HomeContainOverride\",\n\t\t\targs: []string{\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/home\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/home/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"TmpContainOverride\",\n\t\t\targs: []string{\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/tmp\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/tmp/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"VarTmpContainOverride\",\n\t\t\targs: []string{\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/tmp\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/var/tmp/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkOneLevelFileBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFile + \":/var/etc/symlink1\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/etc/symlink1\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkTwoLevelFileBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFile + \":/var/etc/madness/symlink2\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/madness/symlink2\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkOneLevelDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/etc/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkTwoLevelDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc/madness\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/madness/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkOneLevelNewDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc/new\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/etc/new/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkTwoLevelNewDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc/madness/new\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/madness/new/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NestedBindFile\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--bind\", hostCanaryFile + \":\" + filepath.Join(contCanaryDir, \"file2\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/canary/file2\",\n\t\t\t},\n\t\t\tpostRun: checkHostFile(filepath.Join(hostCanaryDir, \"file2\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"NestedBindDir\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--bind\", hostCanaryDir + \":\" + filepath.Join(contCanaryDir, \"dir2\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-d\", \"/canary/dir2\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostCanaryDir, \"dir2\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"MultipleNestedBindDir\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--bind\", hostCanaryDir + \":\" + filepath.Join(contCanaryDir, \"dir2\"),\n\t\t\t\t\"--bind\", hostCanaryFile + \":\" + filepath.Join(filepath.Join(contCanaryDir, \"dir2\"), \"nested\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/canary/dir2/nested\",\n\t\t\t},\n\t\t\tpostRun: checkHostFile(filepath.Join(hostCanaryDir, \"nested\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeOneToOne\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", hostHomeDir,\n\t\t\t\t\"--bind\", hostCanaryDir + \":\" + filepath.Join(hostHomeDir, \"canary121RO\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", filepath.Join(hostHomeDir, \"canary121RO/file\"),\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostHomeDir, \"canary121RO\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", hostHomeDir + \":/home/e2e\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/home/e2e/canaryRO\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/home/e2e/canaryRO/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostHomeDir, \"canaryRO\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeBindWritableOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", hostHomeDir + \":/home/e2e\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/home/e2e/canaryRW\",\n\t\t\t\t\"--writable\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/home/e2e/canaryRW/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostHomeDir, \"canaryRW\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeBindWritableKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", canaryDirBind,\n\t\t\t\t\"--writable\",\n\t\t\t\tsandbox,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirTmpBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirTmpBindWritable\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirVarTmpBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/var/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"var_tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirVarTmpBindWritable\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/var/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"var_tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScratchTmpfsBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--scratch\", \"/scratch\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/scratch/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/scratch/dir/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScratchWorkdirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--scratch\", \"/scratch\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/scratch/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/scratch/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"scratch/scratch\", \"dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithCommaOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", strings.ReplaceAll(hostCanaryFileWithComma, \",\", \"\\\\,\") + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithCommaKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFileWithComma + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithColonOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", strings.ReplaceAll(hostCanaryFileWithColon, \":\", \"\\\\:\") + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithColonKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFileWithColon + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t// For the --mount variants we are really just verifying the CLI\n\t\t// acceptance of one or more --mount flags. Translation from --mount\n\t\t// strings to BindPath structs is checked in unit tests. The\n\t\t// functionality of bind mounts of various kinds is already checked\n\t\t// above, with --bind flags. No need to duplicate all of these.\n\t\t{\n\t\t\tname: \"MountSingle\",\n\t\t\targs: []string{\n\t\t\t\t\"--mount\", canaryFileMount,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"MountNested\",\n\t\t\targs: []string{\n\t\t\t\t\"--mount\", canaryDirMount,\n\t\t\t\t\"--mount\", \"source=\" + hostCanaryFile + \",destination=\" + filepath.Join(contCanaryDir, \"file3\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/canary/file3\",\n\t\t\t},\n\t\t\tpostRun: checkHostFile(filepath.Join(hostCanaryDir, \"file3\")),\n\t\t\texit:    0,\n\t\t},\n\t}\n\n\tfor _, profile := range e2e.Profiles {\n\t\tprofile := profile\n\t\tcreateWorkspaceDirs(t)\n\n\t\tt.Run(profile.String(), func(t *testing.T) {\n\t\t\tfor _, tt := range tests {\n\t\t\t\tc.env.RunApptainer(\n\t\t\t\t\tt,\n\t\t\t\t\te2e.AsSubtest(tt.name),\n\t\t\t\t\te2e.WithProfile(profile),\n\t\t\t\t\te2e.WithCommand(\"exec\"),\n\t\t\t\t\te2e.WithArgs(tt.args...),\n\t\t\t\t\te2e.PostRun(tt.postRun),\n\t\t\t\t\te2e.ExpectExit(tt.exit),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (c actionTests) exitSignals(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname string\n\t\targs []string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname: \"Exit0\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"exit 0\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Exit1\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"exit 1\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Exit134\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"exit 134\"},\n\t\t\texit: 134,\n\t\t},\n\t\t{\n\t\t\tname: \"SignalKill\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"kill -KILL $$\"},\n\t\t\texit: 137,\n\t\t},\n\t\t{\n\t\t\tname: \"SignalAbort\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"kill -ABRT $$\"},\n\t\t\texit: 134,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\nfunc (c actionTests) fuseMount(t *testing.T) {\n\tt.Skip(\"Broken on github for ubuntu 18.04/20.04\")\n\n\trequire.Filesystem(t, \"fuse\")\n\n\tu := e2e.UserProfile.HostUser(t)\n\n\timageDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"sshfs-\", \"\")\n\tdefer e2e.Privileged(cleanup)\n\n\tsshfsWrapper := filepath.Join(imageDir, \"sshfs-wrapper\")\n\trootPrivKey := filepath.Join(imageDir, \"/etc/ssh/ssh_host_rsa_key\")\n\tuserPrivKey := filepath.Join(imageDir, \"user.key\")\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--force\", \"--sandbox\", imageDir, \"testdata/sshfs.def\"),\n\t\te2e.PostRun(func(t *testing.T) {\n\t\t\tif t.Failed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontent, err := ioutil.ReadFile(rootPrivKey)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"could not read ssh private key: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := ioutil.WriteFile(userPrivKey, content, 0o600); err != nil {\n\t\t\t\tt.Errorf(\"could not write ssh user private key: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := os.Chown(userPrivKey, int(u.UID), int(u.GID)); err != nil {\n\t\t\t\tt.Errorf(\"could not change ssh user private key owner: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tstdinReader, stdinWriter := io.Pipe()\n\n\t// we don't use an instance as it could conflict with\n\t// instance tests running in parallel\n\tgo func() {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\te2e.WithStdin(stdinReader),\n\t\t\te2e.WithCommand(\"run\"),\n\t\t\te2e.WithArgs(\"--writable\", \"--no-home\", imageDir),\n\t\t\te2e.PostRun(func(t *testing.T) {\n\t\t\t\tstdinReader.Close()\n\t\t\t\tstdinWriter.Close()\n\t\t\t}),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\t}()\n\n\t// terminate ssh server once done\n\tdefer stdinWriter.Write([]byte(\"bye\"))\n\n\t// wait until ssh server is up and running\n\tretry := 0\n\tfor {\n\t\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:2022\")\n\t\tif err == nil {\n\t\t\tconn.Close()\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t\tretry++\n\t\tif retry == 5 {\n\t\t\tt.Fatalf(\"ssh server unreachable after 5 seconds: %+v\", err)\n\t\t}\n\t}\n\n\tbasicTests := []struct {\n\t\tname    string\n\t\tspec    string\n\t\tkey     string\n\t\tprofile e2e.Profile\n\t}{\n\t\t{\n\t\t\tname:    \"HostDaemonAsRoot\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsRoot\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsRoot\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsRoot\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostDaemonAsUser\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsUser\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsUser\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsUser\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostDaemonAsUserNamespace\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsUserNamespace\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsUserNamespace\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsUserNamespace\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostDaemonAsFakeroot\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsFakeroot\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsFakeroot\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsFakeroot\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t}\n\n\toptionFmt := \"%s:%s root@127.0.0.1:/ -p 2022 -F %s -o IdentityFile=%s -o StrictHostKeyChecking=no %s\"\n\tsshConfig := filepath.Join(imageDir, \"etc\", \"ssh\", \"ssh_config\")\n\n\tfor _, tt := range basicTests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs([]string{\n\t\t\t\t\"--fusemount\", fmt.Sprintf(optionFmt, tt.spec, sshfsWrapper, sshConfig, tt.key, \"/mnt\"),\n\t\t\t\timageDir,\n\t\t\t\t\"test\", \"-d\", \"/mnt/etc\",\n\t\t\t}...),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\t}\n}\n\n//nolint:maintidx\nfunc (c actionTests) bindImage(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\trequire.Command(t, \"mkfs.ext3\")\n\trequire.Command(t, \"mksquashfs\")\n\trequire.Command(t, \"dd\")\n\n\ttestdir, err := ioutil.TempDir(c.env.TestDir, \"bind-image-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tscratchDir := filepath.Join(testdir, \"scratch\")\n\tif err := os.MkdirAll(filepath.Join(scratchDir, \"bin\"), 0o700); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func(t *testing.T) {\n\t\tif t.Failed() {\n\t\t\tt.Logf(\"Not removing directory %s for test %s\", testdir, t.Name())\n\t\t\treturn\n\t\t}\n\t\terr := os.RemoveAll(testdir)\n\t\tif err != nil {\n\t\t\tt.Logf(\"Error while removing directory %s for test %s: %#v\", testdir, t.Name(), err)\n\t\t}\n\t}\n\tdefer cleanup(t)\n\n\tsifSquashImage := filepath.Join(testdir, \"data_squash.sif\")\n\tsifExt3Image := filepath.Join(testdir, \"data_ext3.sif\")\n\tsquashfsImage := filepath.Join(testdir, \"squashfs.simg\")\n\text3Img := filepath.Join(testdir, \"ext3_fs.img\")\n\n\t// create root directory for squashfs image\n\tsquashDir, err := ioutil.TempDir(testdir, \"root-squash-dir-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chmod(squashDir, 0o755); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsquashMarkerFile := \"squash_marker\"\n\tif err := fs.Touch(filepath.Join(squashDir, squashMarkerFile)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create the squashfs overlay image\n\tcmd := exec.Command(\"mksquashfs\", squashDir, squashfsImage, \"-noappend\", \"-all-root\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create the overlay ext3 image\n\tcmd = exec.Command(\"dd\", \"if=/dev/zero\", \"of=\"+ext3Img, \"bs=1M\", \"count=64\", \"status=none\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\tcmd = exec.Command(\"mkfs.ext3\", \"-q\", \"-F\", ext3Img)\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create new SIF images\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\"new\", sifSquashImage}...),\n\t\te2e.ExpectExit(0),\n\t)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\"new\", sifExt3Image}...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// arch partition doesn't matter for data partition so\n\t// take amd64 by default\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\n\t\t\t\"add\",\n\t\t\t\"--datatype\", \"4\", \"--partarch\", \"2\",\n\t\t\t\"--partfs\", \"1\", \"--parttype\", \"3\",\n\t\t\tsifSquashImage, squashfsImage,\n\t\t}...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\n\t\t\t\"add\",\n\t\t\t\"--datatype\", \"4\", \"--partarch\", \"2\",\n\t\t\t\"--partfs\", \"2\", \"--parttype\", \"3\",\n\t\t\tsifExt3Image, ext3Img,\n\t\t}...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\ttests := []struct {\n\t\tname    string\n\t\tprofile e2e.Profile\n\t\targs    []string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"NoBindOption\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname:    \"BadIDValue\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind:id=0\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"BadBindOption\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind:fake_option=fake\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SandboxKO\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashDir + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"Squashfs\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SquashfsDouble\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", squashfsImage + \":/bind2:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind1\", squashMarkerFile), \"-a\", \"-f\", filepath.Join(\"/bind2\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SquashfsBadSource\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs:    []string{\"--bind\", squashfsImage + \":/bind:image-src=/ko\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SquashfsMixedBind\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", squashDir + \":/bind2\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind1\", squashMarkerFile), \"-a\", \"-f\", filepath.Join(\"/bind2\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3Write\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"touch\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3WriteKO\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind:image-src=/,ro\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"touch\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3Write\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"touch\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3Read\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3Double\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", ext3Img + \":/bind2:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataSquash\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifSquashImage + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3Read\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3AndSquash\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/ext3:image-src=/\",\n\t\t\t\t\"--bind\", sifSquashImage + \":/squash:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/squash\", squashMarkerFile), \"-a\", \"-f\", \"/ext3/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3Double\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind2:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifWithID\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t// rootfs ID is now '4'\n\t\t\t\t\"--bind\", c.env.ImagePath + \":/rootfs:id=4\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-d\", \"/rootfs/etc\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t// check ordering between image and user bind\n\t\t{\n\t\t\tname:    \"SquashfsBeforeScratch\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifSquashImage + \":/scratch/bin:image-src=/\",\n\t\t\t\t\"--bind\", scratchDir + \":/scratch\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/scratch/bin\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname:    \"ScratchBeforeSquashfs\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", scratchDir + \":/scratch\",\n\t\t\t\t\"--bind\", sifSquashImage + \":/scratch/bin:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/scratch/bin\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t// For the --mount variants we are really just verifying the CLI\n\t\t// acceptance of one or more image bind mount strings. Translation from\n\t\t// --mount strings to BindPath structs is checked in unit tests. The\n\t\t// functionality of image mounts of various kinds is already checked\n\t\t// above, with --bind flags. No need to duplicate all of these.\n\t\t{\n\t\t\tname:    \"MountSifWithID\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t// rootfs ID is now '4'\n\t\t\t\t\"--mount\", \"type=bind,source=\" + c.env.ImagePath + \",destination=/rootfs,id=4\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-d\", \"/rootfs/etc\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"MountSifDataExt3AndSquash\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--mount\", \"type=bind,source=\" + sifExt3Image + \",destination=/ext3,image-src=/\",\n\t\t\t\t\"--mount\", \"type=bind,source=\" + sifSquashImage + \",destination=/squash,image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/squash\", squashMarkerFile), \"-a\", \"-f\", \"/ext3/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// actionUmask tests that the within-container umask is correct in action flows\nfunc (c actionTests) actionUmask(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tu := e2e.UserProfile.HostUser(t)\n\n\t// Set umask for tests to 0000\n\toldUmask := syscall.Umask(0)\n\tdefer syscall.Umask(oldUmask)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithDir(u.Dir),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(c.env.ImagePath, \"sh\", \"-c\", \"umask\"),\n\t\te2e.ExpectExit(\n\t\t\t0,\n\t\t\te2e.ExpectOutput(e2e.ExactMatch, \"0000\"),\n\t\t),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithDir(u.Dir),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-umask\", c.env.ImagePath, \"sh\", \"-c\", \"umask\"),\n\t\te2e.ExpectExit(\n\t\t\t0,\n\t\t\te2e.ExpectOutput(e2e.ExactMatch, \"0022\"),\n\t\t),\n\t)\n}\n\n// actionUnsquash tests that the --unsquash option succeeds in conversion\nfunc (c actionTests) actionUnsquash(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname    string\n\t\tprofile e2e.Profile\n\t}{\n\t\t{\n\t\t\tname:    \"user\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"userns\",\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"fakeroot\",\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(\"--unsquash\", c.env.ImagePath, \"true\"),\n\t\t\te2e.ExpectExit(\n\t\t\t\t0,\n\t\t\t\te2e.ExpectError(e2e.ContainMatch, \"Converting SIF\"),\n\t\t\t),\n\t\t)\n\t}\n}\n\nfunc (c actionTests) actionNoMount(t *testing.T) {\n\t// TODO - this does not test --no-mount hostfs as that is a little tricky\n\t// We are in a mount namespace for e2e tests, so we can setup some mounts in there,\n\t// create a custom config with `mount hostfs = yes` set, and then look for presence\n\t// or absence of the mounts. I'd like to think about this a bit more though - work up\n\t// some nice helpers & cleanup for the actions we need.\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname string\n\t\t// Which mount directive to override (disable)\n\t\tnoMount string\n\t\t// Output of `mount` command to ensure we should not find\n\t\t// e.g for `--no-mount home` \"on /home\" as mount command output is of the form:\n\t\t//   tmpfs on /home/dave type tmpfs (rw,seclabel,nosuid,nodev,relatime,size=16384k,uid=1000,gid=1000)\n\t\tnoMatch string\n\t\t// Whether to run the test in default and/or contained modes\n\t\t// Needs to be specified as e.g. by default `/dev` mount is a full bind that will always include `/dev/pts`\n\t\t// ... but in --contained mode disabling devpts stops it being bound in.\n\t\ttestDefault   bool\n\t\ttestContained bool\n\t\t// To test --no-mount cwd we need to chdir for the execution\n\t\tcwd  string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname:          \"proc\",\n\t\t\tnoMount:       \"proc\",\n\t\t\tnoMatch:       \"on /proc\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          1, // mount fails with exit code 1 when there is no `/proc`\n\t\t},\n\t\t{\n\t\t\tname:          \"sys\",\n\t\t\tnoMount:       \"sys\",\n\t\t\tnoMatch:       \"on /sys\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"dev\",\n\t\t\tnoMount:       \"dev\",\n\t\t\tnoMatch:       \"on /dev\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"devpts\",\n\t\t\tnoMount:       \"devpts\",\n\t\t\tnoMatch:       \"on /dev/pts\",\n\t\t\ttestDefault:   false,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"tmp\",\n\t\t\tnoMount:       \"tmp\",\n\t\t\tnoMatch:       \"on /tmp\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"home\",\n\t\t\tnoMount:       \"home\",\n\t\t\tnoMatch:       \"on /home\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\t// /srv is an LSB directory we should be able to rely on for our CWD test\n\t\t\tname:        \"cwd\",\n\t\t\tnoMount:     \"cwd\",\n\t\t\tnoMatch:     \"on /srv\",\n\t\t\ttestDefault: true,\n\t\t\t// CWD is never mounted with contain so --no-mount CWD doesn't have an effect,\n\t\t\t// but let's verify it isn't mounted anyway.\n\t\t\ttestContained: true,\n\t\t\tcwd:           \"/srv\",\n\t\t\texit:          0,\n\t\t},\n\t\t// /etc/hosts & /etc/localtime are default 'bind path' entries we should\n\t\t// be able to disable by abs path. Although other 'bind path' entries\n\t\t// are ignored under '--contain' these two are handled specially in\n\t\t// addBindsMount(), so make sure that `--no-mount` applies properly\n\t\t// under contain also.\n\t\t{\n\t\t\tname:          \"/etc/hosts\",\n\t\t\tnoMount:       \"/etc/hosts\",\n\t\t\tnoMatch:       \"on /etc/hosts\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"/etc/localtime\",\n\t\t\tnoMount:       \"/etc/localtime\",\n\t\t\tnoMatch:       \"on /etc/localtime\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\n\t\tif tt.testDefault {\n\t\t\tc.env.RunApptainer(\n\t\t\t\tt,\n\t\t\t\te2e.WithDir(tt.cwd),\n\t\t\t\te2e.AsSubtest(tt.name),\n\t\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\t\te2e.WithCommand(\"exec\"),\n\t\t\t\te2e.WithArgs(\"--no-mount\", tt.noMount, c.env.ImagePath, \"mount\"),\n\t\t\t\te2e.ExpectExit(tt.exit,\n\t\t\t\t\te2e.ExpectOutput(e2e.UnwantedContainMatch, tt.noMatch)),\n\t\t\t)\n\t\t}\n\t\tif tt.testContained {\n\t\t\tc.env.RunApptainer(\n\t\t\t\tt,\n\t\t\t\te2e.WithDir(tt.cwd),\n\t\t\t\te2e.AsSubtest(tt.name+\"Contained\"),\n\t\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\t\te2e.WithCommand(\"exec\"),\n\t\t\t\te2e.WithArgs(\"--contain\", \"--no-mount\", tt.noMount, c.env.ImagePath, \"mount\"),\n\t\t\t\te2e.ExpectExit(tt.exit,\n\t\t\t\t\te2e.ExpectOutput(e2e.UnwantedContainMatch, tt.noMatch)),\n\t\t\t)\n\t\t}\n\t}\n}\n\n// actionCompat checks that the --compat flag sets up the expected environment\n// for improved oci/docker compatibility\nfunc (c actionTests) actionCompat(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttype test struct {\n\t\tname     string\n\t\targs     []string\n\t\texitCode int\n\t\texpect   e2e.ApptainerCmdResultOp\n\t}\n\n\ttests := []test{\n\t\t{\n\t\t\tname:     \"containall\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"ls -lah $HOME\"},\n\t\t\texitCode: 0,\n\t\t\texpect:   e2e.ExpectOutput(e2e.ContainMatch, \"total 0\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"writable-tmpfs\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"touch /test\"},\n\t\t\texitCode: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"no-init\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"ps\"},\n\t\t\texitCode: 0,\n\t\t\texpect:   e2e.ExpectOutput(e2e.UnwantedContainMatch, \"appinit\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"no-umask\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"umask\"},\n\t\t\texitCode: 0,\n\t\t\texpect:   e2e.ExpectOutput(e2e.ContainMatch, \"0022\"),\n\t\t},\n\t}\n\n\toldUmask := syscall.Umask(0)\n\tdefer syscall.Umask(oldUmask)\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(\n\t\t\t\ttt.exitCode,\n\t\t\t\ttt.expect,\n\t\t\t),\n\t\t)\n\t}\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := actionTests{\n\t\tenv: env,\n\t}\n\n\tnp := testhelper.NoParallel\n\n\treturn testhelper.Tests{\n\t\t\"action URI\":            c.RunFromURI,          // action_URI\n\t\t\"singularity link\":      c.singularityLink,     // singularity symlink\n\t\t\"exec\":                  c.actionExec,          // apptainer exec\n\t\t\"persistent overlay\":    c.PersistentOverlay,   // Persistent Overlay\n\t\t\"run\":                   c.actionRun,           // apptainer run\n\t\t\"shell\":                 c.actionShell,         // shell interaction\n\t\t\"STDPIPE\":               c.STDPipe,             // stdin/stdout pipe\n\t\t\"action basic profiles\": c.actionBasicProfiles, // run basic action under different profiles\n\t\t\"issue 4488\":            c.issue4488,           // https://github.com/apptainer/singularity/issues/4488\n\t\t\"issue 4587\":            c.issue4587,           // https://github.com/apptainer/singularity/issues/4587\n\t\t\"issue 4755\":            c.issue4755,           // https://github.com/apptainer/singularity/issues/4755\n\t\t\"issue 4768\":            c.issue4768,           // https://github.com/apptainer/singularity/issues/4768\n\t\t\"issue 4797\":            c.issue4797,           // https://github.com/apptainer/singularity/issues/4797\n\t\t\"issue 4823\":            c.issue4823,           // https://github.com/apptainer/singularity/issues/4823\n\t\t\"issue 4836\":            c.issue4836,           // https://github.com/apptainer/singularity/issues/4836\n\t\t\"issue 5211\":            c.issue5211,           // https://github.com/apptainer/singularity/issues/5211\n\t\t\"issue 5228\":            c.issue5228,           // https://github.com/apptainer/singularity/issues/5228\n\t\t\"issue 5271\":            c.issue5271,           // https://github.com/apptainer/singularity/issues/5271\n\t\t\"issue 5399\":            c.issue5399,           // https://github.com/apptainer/singularity/issues/5399\n\t\t\"issue 5455\":            c.issue5455,           // https://github.com/apptainer/singularity/issues/5455\n\t\t\"issue 5465\":            c.issue5465,           // https://github.com/apptainer/singularity/issues/5465\n\t\t\"issue 5599\":            c.issue5599,           // https://github.com/apptainer/singularity/issues/5599\n\t\t\"issue 5631\":            c.issue5631,           // https://github.com/apptainer/singularity/issues/5631\n\t\t\"issue 5690\":            c.issue5690,           // https://github.com/apptainer/singularity/issues/5690\n\t\t\"issue 6165\":            c.issue6165,           // https://github.com/apptainer/singularity/issues/6165\n\t\t\"issue 619\":             c.issue619,            // https://github.com/apptainer/apptainer/issues/619\n\t\t\"network\":               c.actionNetwork,       // test basic networking\n\t\t\"binds\":                 c.actionBinds,         // test various binds with --bind and --mount\n\t\t\"exit and signals\":      c.exitSignals,         // test exit and signals propagation\n\t\t\"fuse mount\":            c.fuseMount,           // test fusemount option\n\t\t\"bind image\":            c.bindImage,           // test bind image with --bind and --mount\n\t\t\"umask\":                 c.actionUmask,         // test umask propagation\n\t\t\"unsquash\":              c.actionUnsquash,      // test --unsquash\n\t\t\"no-mount\":              c.actionNoMount,       // test --no-mount\n\t\t\"compat\":                c.actionCompat,        // test --compat\n\t\t\"invalidRemote\":         np(c.invalidRemote),   // GHSA-5mv9-q7fq-9394\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage config\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/require\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/user\"\n)\n\ntype configTests struct {\n\tenv            e2e.TestEnv\n\tsifImage       string\n\tencryptedImage string\n\tsquashfsImage  string\n\text3Image      string\n\tsandboxImage   string\n\tpemPublic      string\n\tpemPrivate     string\n}\n\n// prepImages creates containers covering all image formats to test the\n// `allow container xxx` directives.\nfunc (c *configTests) prepImages(t *testing.T) (cleanup func(t *testing.T)) {\n\trequire.MkfsExt3(t)\n\trequire.Command(t, \"truncate\")\n\trequire.Command(t, \"mksquashfs\")\n\n\ttmpDir, cleanup := e2e.MakeTempDir(t, \"\", \"config-\", \"CONFIG\")\n\n\t// An unencrypted SIF\n\te2e.EnsureImage(t, c.env)\n\tc.sifImage = c.env.ImagePath\n\n\t// An encrypted SIF\n\tc.pemPublic, c.pemPrivate = e2e.GeneratePemFiles(t, tmpDir)\n\tc.encryptedImage = filepath.Join(tmpDir, \"encrypted.sif\")\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"PrepareEncryptedSIF\"),\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--encrypt\", \"--pem-path\", c.pemPublic, c.encryptedImage, c.sifImage),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// A sandbox directory\n\tc.sandboxImage = filepath.Join(tmpDir, \"sandbox\")\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"PrepareSandbox\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"-s\", c.sandboxImage, c.sifImage),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// A bare ext3 image\n\tt.Run(\"PrepareExt3\", func(t *testing.T) {\n\t\tc.ext3Image = filepath.Join(tmpDir, \"ext3.img\")\n\t\tcmd := exec.Command(\"truncate\", \"-s\", \"16M\", c.ext3Image)\n\t\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\t\tdefer cleanup(t)\n\t\t\tt.Fatalf(\"Error creating blank ext3 image: %v: %s\", err, out)\n\t\t}\n\t\tcmd = exec.Command(\"mkfs.ext3\", \"-d\", c.sandboxImage, c.ext3Image)\n\t\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\t\tdefer cleanup(t)\n\t\t\tt.Fatalf(\"Error creating populated ext3 image: %v: %s\", err, out)\n\t\t}\n\t})\n\n\t// A bare squashfs image\n\tt.Run(\"PrepareSquashfs\", func(t *testing.T) {\n\t\tc.squashfsImage = filepath.Join(tmpDir, \"squashfs.img\")\n\t\tcmd := exec.Command(\"mksquashfs\", c.sandboxImage, c.squashfsImage)\n\t\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\t\tdefer cleanup(t)\n\t\t\tt.Fatalf(\"Error creating squashfs image: %v: %s\", err, out)\n\t\t}\n\t})\n\n\treturn cleanup\n}\n\n//nolint:maintidx\nfunc (c configTests) configGlobal(t *testing.T) {\n\tcleanup := c.prepImages(t)\n\tdefer cleanup(t)\n\n\tsetDirective := func(t *testing.T, directive, value string) {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\te2e.WithCommand(\"config global\"),\n\t\t\te2e.WithArgs(\"--set\", directive, value),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\t}\n\tresetDirective := func(t *testing.T, directive string) {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\te2e.WithCommand(\"config global\"),\n\t\t\te2e.WithArgs(\"--reset\", directive),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\t}\n\n\tu := e2e.UserProfile.HostUser(t)\n\tg, err := user.GetGrGID(u.GID)\n\tif err != nil {\n\t\tt.Fatalf(\"could not retrieve user group information: %s\", err)\n\t}\n\n\ttests := []struct {\n\t\tname              string\n\t\targv              []string\n\t\tprofile           e2e.Profile\n\t\taddRequirementsFn func(*testing.T)\n\t\tcwd               string\n\t\tdirective         string\n\t\tdirectiveValue    string\n\t\texit              int\n\t\tresultOp          e2e.ApptainerCmdResultOp\n\t}{\n\t\t{\n\t\t\tname: \"AllowSetuid\",\n\t\t\targv: []string{c.env.ImagePath, \"true\"},\n\t\t\t// We are testing if we fall back to user namespace without `--userns`\n\t\t\t// so we need to use the UserProfile, and check separately if userns\n\t\t\t// support is possible.\n\t\t\tprofile:           e2e.UserProfile,\n\t\t\taddRequirementsFn: require.UserNamespace,\n\t\t\tdirective:         \"allow setuid\",\n\t\t\tdirectiveValue:    \"no\",\n\t\t\texit:              0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MaxLoopDevices\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"max loop devices\",\n\t\t\tdirectiveValue: \"0\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowPidNsNo\",\n\t\t\targv:           []string{\"--pid\", \"--no-init\", c.env.ImagePath, \"/bin/sh\", \"-c\", \"echo $$\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow pid ns\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t\tresultOp:       e2e.ExpectOutput(e2e.UnwantedExactMatch, \"1\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowPidNsYes\",\n\t\t\targv:           []string{\"--pid\", \"--no-init\", c.env.ImagePath, \"/bin/sh\", \"-c\", \"echo $$\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow pid ns\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t\tresultOp:       e2e.ExpectOutput(e2e.ExactMatch, \"1\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigPasswdNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/passwd.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config passwd\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigPasswdYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/passwd.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config passwd\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigGroupNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/group.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config group\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigGroupYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/group.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config group\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigResolvConfNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/resolv.conf.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config resolv_conf\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigResolvConfYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/resolv.conf.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config resolv_conf\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountProcNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/proc/self\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount proc\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountProcYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/proc/self\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount proc\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountSysNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/sys/kernel\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount sys\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountSysYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/sys/kernel\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount sys\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountDevNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/dev/pts\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount dev\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountDevMinimal\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-b\", \"/dev/loop0\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount dev\",\n\t\t\tdirectiveValue: \"minimal\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountDevYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-b\", \"/dev/loop0\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount dev\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// just test 'mount devpts = no' as yes depends of kernel version\n\t\t{\n\t\t\tname:           \"MountDevPtsNo\",\n\t\t\targv:           []string{\"-C\", c.env.ImagePath, \"test\", \"-d\", \"/dev/pts\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount devpts\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountHomeNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", u.Dir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tcwd:            \"/\",\n\t\t\tdirective:      \"mount home\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountHomeYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", u.Dir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tcwd:            \"/\",\n\t\t\tdirective:      \"mount home\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountTmpNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", c.env.TestDir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount tmp\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountTmpYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", c.env.TestDir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount tmp\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"BindPathPasswd\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"bind path\",\n\t\t\tdirectiveValue: \"/etc/passwd:/passwd\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"UserBindControlNo\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"user bind control\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"UserBindControlYes\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"user bind control\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// overlay may or not be available, just test with no\n\t\t{\n\t\t\tname:           \"EnableOverlayNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"\\\\- overlay overlay\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"enable overlay\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t// use user namespace profile to force underlay use\n\t\t{\n\t\t\tname:           \"EnableUnderlayNo\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"enable underlay\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"EnableUnderlayYes\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"enable underlay\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// test image is owned by root:root\n\t\t{\n\t\t\tname:           \"LimitContainerOwnersUser\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container owners\",\n\t\t\tdirectiveValue: u.Name,\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerOwnersUserAndRoot\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container owners\",\n\t\t\tdirectiveValue: u.Name + \", root\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerGroupsUser\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container groups\",\n\t\t\tdirectiveValue: g.Name,\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerGroupsUserAndRoot\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container groups\",\n\t\t\tdirectiveValue: g.Name + \", root\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerPathsProc\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container paths\",\n\t\t\tdirectiveValue: \"/proc\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerPathsTestdir\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container paths\",\n\t\t\tdirectiveValue: c.env.TestDir,\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSifNo\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container sif\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSifYes\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container sif\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerEncryptedNo\",\n\t\t\targv:           []string{\"--pem-path\", c.pemPrivate, c.encryptedImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container encrypted\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerEncryptedYes\",\n\t\t\targv:           []string{\"--pem-path\", c.pemPrivate, c.encryptedImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container encrypted\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSquashfsNo\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSquashfsYes\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container squashfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerExfs3No\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerExtfsYes\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container extfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerDirNo\",\n\t\t\targv:           []string{c.sandboxImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container dir\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerDirYes\",\n\t\t\targv:           []string{c.sandboxImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container dir\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// FIXME\n\t\t// The e2e tests currently run inside a PID namespace.\n\t\t//   (see internal/init/init_linux.go)\n\t\t// We can't instruct systemd to manage our cgroups as the PIDs in our test namespace\n\t\t// won't match what systemd sees.\n\t\t// {\n\t\t// \tname:           \"SystemdCgroupsYes\",\n\t\t// \targv:           []string{\"--apply-cgroups\", \"testdata/cgroups/pids_limit.toml\", c.sandboxImage, \"true\"},\n\t\t// \tprofile:        e2e.RootProfile,\n\t\t// \tdirective:      \"systemd cgroups\",\n\t\t// \tdirectiveValue: \"yes\",\n\t\t// \texit:           0,\n\t\t// },\n\t\t{\n\t\t\tname:           \"SystemdCgroupNo\",\n\t\t\targv:           []string{\"--apply-cgroups\", \"testdata/cgroups/pids_limit.toml\", c.sandboxImage, \"true\"},\n\t\t\tprofile:        e2e.RootProfile,\n\t\t\tdirective:      \"systemd cgroups\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithDir(tt.cwd),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tif tt.addRequirementsFn != nil {\n\t\t\t\t\ttt.addRequirementsFn(t)\n\t\t\t\t}\n\t\t\t\tsetDirective(t, tt.directive, tt.directiveValue)\n\t\t\t}),\n\t\t\te2e.PostRun(func(t *testing.T) {\n\t\t\t\tresetDirective(t, tt.directive)\n\t\t\t}),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit, tt.resultOp),\n\t\t)\n\t}\n}\n\n// Tests that require combinations of directives to be set\nfunc (c configTests) configGlobalCombination(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tsetDirective := func(t *testing.T, directives map[string]string) {\n\t\tfor k, v := range directives {\n\t\t\tc.env.RunApptainer(\n\t\t\t\tt,\n\t\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\t\te2e.WithCommand(\"config global\"),\n\t\t\t\te2e.WithArgs(\"--set\", k, v),\n\t\t\t\te2e.ExpectExit(0),\n\t\t\t)\n\t\t}\n\t}\n\tresetDirective := func(t *testing.T, directives map[string]string) {\n\t\tfor k := range directives {\n\t\t\tc.env.RunApptainer(\n\t\t\t\tt,\n\t\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\t\te2e.WithCommand(\"config global\"),\n\t\t\t\te2e.WithArgs(\"--reset\", k),\n\t\t\t\te2e.ExpectExit(0),\n\t\t\t)\n\t\t}\n\t}\n\n\tu := e2e.UserProfile.HostUser(t)\n\tg, err := user.GetGrGID(u.GID)\n\tif err != nil {\n\t\tt.Fatalf(\"could not retrieve user group information: %s\", err)\n\t}\n\n\ttests := []struct {\n\t\tname              string\n\t\targv              []string\n\t\tprofile           e2e.Profile\n\t\taddRequirementsFn func(*testing.T)\n\t\tcwd               string\n\t\tdirectives        map[string]string\n\t\texit              int\n\t\tresultOp          e2e.ApptainerCmdResultOp\n\t}{\n\t\t{\n\t\t\tname:    \"AllowNetUsersNobody\",\n\t\t\targv:    []string{\"--net\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": \"nobody\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUser\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": u.Name,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUID\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": fmt.Sprintf(\"%d\", u.UID),\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUserOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUIDOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    fmt.Sprintf(\"%d\", u.UID),\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsNobody\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\": \"nobody\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGroup\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\": g.Name,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGID\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\": fmt.Sprintf(\"%d\", g.GID),\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGroupOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\":   g.Name,\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGIDOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\":   fmt.Sprintf(\"%d\", g.GID),\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"AllowNetNetworksMultiMulti\",\n\t\t\t// Two networks allowed, asking for both\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge,ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge,ptp\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\t// Two networks allowed, asking for one\n\t\t\tname:    \"AllowNetNetworksMultiOne\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge,ptp\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\t// One network allowed, but asking for two\n\t\t\tname:    \"AllowNetNetworksOneMulti\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge,ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\t// No networks allowed, asking for two\n\t\t\tname:    \"AllowNetNetworksNoneMulti\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge,ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": u.Name,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithDir(tt.cwd),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tif tt.addRequirementsFn != nil {\n\t\t\t\t\ttt.addRequirementsFn(t)\n\t\t\t\t}\n\t\t\t\tsetDirective(t, tt.directives)\n\t\t\t}),\n\t\t\te2e.PostRun(func(t *testing.T) {\n\t\t\t\tresetDirective(t, tt.directives)\n\t\t\t}),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit, tt.resultOp),\n\t\t)\n\t}\n}\n\nfunc (c configTests) configFile(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname    string\n\t\targv    []string\n\t\tprofile e2e.Profile\n\t\tconf    string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"MaxLoopDevicesKO\",\n\t\t\targv:    []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.RootProfile,\n\t\t\tconf:    \"max loop devices = 0\\n\",\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"MaxLoopDevicesOK\",\n\t\t\targv:    []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.RootProfile,\n\t\t\tconf:    \"max loop devices = 128\\n\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"UserForbidden\",\n\t\t\targv:    []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tconf:    \"max loop devices = 128\\n\",\n\t\t\texit:    255,\n\t\t},\n\t}\n\n\t// Create a temp testfile\n\tf, err := fs.MakeTmpFile(c.env.TestDir, \"config-\", 0o644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconfigFile := f.Name()\n\tdefer os.Remove(configFile)\n\tf.Close()\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithGlobalOptions(\"--config\", configFile),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tif err := ioutil.WriteFile(configFile, []byte(tt.conf), 0o644); err != nil {\n\t\t\t\t\tt.Errorf(\"could not write configuration file %s: %s\", configFile, err)\n\t\t\t\t}\n\t\t\t}),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := configTests{\n\t\tenv: env,\n\t}\n\n\tnp := testhelper.NoParallel\n\n\treturn testhelper.Tests{\n\t\t\"config file\":               c.configFile,                  // test --config file option\n\t\t\"config global\":             np(c.configGlobal),            // test various global configuration\n\t\t\"config global combination\": np(c.configGlobalCombination), // test various global configuration with combination\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage e2e\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/internal/pkg/buildcfg\"\n\t\"github.com/apptainer/apptainer/pkg/util/apptainerconf\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc SetupDefaultConfig(t *testing.T, path string) {\n\tc, err := apptainerconf.Parse(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"while generating apptainer configuration: %s\", err)\n\t}\n\tapptainerconf.SetCurrentConfig(c)\n\tapptainerconf.SetBinaryPath(buildcfg.LIBEXECDIR, true)\n\n\tPrivileged(func(t *testing.T) {\n\t\tf, err := os.Create(path)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"while creating apptainer configuration: %s\", err)\n\t\t}\n\n\t\tif err := apptainerconf.Generate(f, \"\", c); err != nil {\n\t\t\tt.Fatalf(\"while generating apptainer configuration: %s\", err)\n\t\t}\n\n\t\tf.Close()\n\n\t\tif err := unix.Mount(path, buildcfg.APPTAINER_CONF_FILE, \"\", unix.MS_BIND, \"\"); err != nil {\n\t\t\tt.Fatalf(\"while mounting %s to %s: %s\", path, buildcfg.APPTAINER_CONF_FILE, err)\n\t\t}\n\t})(t)\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n\npackage overlay\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/require\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n)\n\ntype ctx struct {\n\tenv e2e.TestEnv\n}\n\nfunc (c ctx) testOverlayCreate(t *testing.T) {\n\trequire.Filesystem(t, \"overlay\")\n\trequire.MkfsExt3(t)\n\te2e.EnsureImage(t, c.env)\n\n\ttmpDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"overlay\", \"\")\n\tdefer cleanup(t)\n\n\tpgpDir, _ := e2e.MakeKeysDir(t, tmpDir)\n\tc.env.KeyringDir = pgpDir\n\n\tsifSignedImage := filepath.Join(tmpDir, \"signed.sif\")\n\tsifImage := filepath.Join(tmpDir, \"unsigned.sif\")\n\text3SparseImage := filepath.Join(tmpDir, \"image.sparse.ext3\")\n\text3Image := filepath.Join(tmpDir, \"image.ext3\")\n\text3DirImage := filepath.Join(tmpDir, \"imagedir.ext3\")\n\n\t// signed SIF image\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(sifSignedImage, \"oras://ghcr.io/apptainer/busybox:1.31.1\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"key import\"),\n\t\te2e.WithArgs(\"testdata/ecl-pgpkeys/key1.asc\"),\n\t\te2e.ConsoleRun(e2e.ConsoleSendLine(\"e2e\")),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sign\"),\n\t\te2e.WithArgs(\"-k\", \"0\", sifSignedImage),\n\t\te2e.ConsoleRun(e2e.ConsoleSendLine(\"e2e\")),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// unsigned SIF image\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(sifImage, \"oras://ghcr.io/apptainer/busybox:1.31.1\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\ttype test struct {\n\t\tname    string\n\t\tprofile e2e.Profile\n\t\tcommand string\n\t\targs    []string\n\t\texit    int\n\t}\n\n\ttests := []test{\n\t\t{\n\t\t\tname:    \"create ext3 overlay with small size\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--size\", \"1\", ext3Image},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 sparse overlay image\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--size\", \"128\", \"--sparse\", ext3SparseImage},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--size\", \"128\", ext3Image},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"check ext3 overlay size\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"exec\",\n\t\t\targs:    []string{\"-B\", ext3Image + \":/mnt/image\", c.env.ImagePath, \"/bin/sh\", \"-c\", \"[ $(stat -c %s /mnt/image) = 134217728 ] || false\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay with an existing image\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", ext3Image},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay with dir\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--create-dir\", \"/usr/local/testing\", ext3DirImage},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"check overlay dir permissions\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"exec\",\n\t\t\targs:    []string{\"-o\", ext3DirImage, c.env.ImagePath, \"mkdir\", \"/usr/local/testing/perms\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image in unsigned SIF\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifImage},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image in SIF with an existing overlay\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifImage},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image in signed SIF\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifSignedImage},\n\t\t\texit:    255,\n\t\t},\n\t}\n\n\terr := e2e.CheckCryptsetupVersion()\n\tif err == nil {\n\t\t// encrypted SIF image\n\t\tpassphraseEnvVar := fmt.Sprintf(\"%s=%s\", \"APPTAINER_ENCRYPTION_PASSPHRASE\", e2e.Passphrase)\n\n\t\tsifEncryptedImage := filepath.Join(tmpDir, \"encrypted.sif\")\n\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\te2e.WithCommand(\"build\"),\n\t\t\te2e.WithArgs(\"--encrypt\", sifEncryptedImage, \"oras://ghcr.io/apptainer/busybox:1.31.1\"),\n\t\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\n\t\ttests = append(tests, test{\n\t\t\tname:    \"create ext3 overlay image in encrypted SIF\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifEncryptedImage},\n\t\t\texit:    255,\n\t\t})\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := ctx{\n\t\tenv: env,\n\t}\n\n\treturn testhelper.Tests{\n\t\t\"create\": c.testOverlayCreate,\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2020, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage run\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n\t\"github.com/apptainer/apptainer/internal/pkg/cache\"\n)\n\ntype ctx struct {\n\tenv e2e.TestEnv\n}\n\n// testRun555Cache tests the specific case where the cache directory is\n// 0555 for access rights, and we try to run an Apptainer run command\n// using that directory as cache. This reflects a problem that is important\n// for the grid use case.\nfunc (c ctx) testRun555Cache(t *testing.T) {\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\tcacheDir := filepath.Join(tempDir, \"image-cache\")\n\terr := os.Mkdir(cacheDir, 0o555)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create a temporary image cache: %s\", err)\n\t}\n\t// Directory is deleted when tempDir is deleted\n\n\tcmdArgs := []string{\"oras://ghcr.io/apptainer/alpine:3.15.0\", \"/bin/true\"}\n\t// We explicitly pass the environment to the command, not through c.env.ImgCacheDir\n\t// because c.env is shared between all the tests, something we do not want here.\n\tcacheDirEnv := fmt.Sprintf(\"%s=%s\", cache.DirEnv, cacheDir)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), cacheDirEnv)),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\nfunc (c ctx) testRunPEMEncrypted(t *testing.T) {\n\t// If the version of cryptsetup is not compatible with Apptainer encryption,\n\t// the build commands are expected to fail\n\terr := e2e.CheckCryptsetupVersion()\n\tif err != nil {\n\t\tt.Skip(\"cryptsetup is not compatible, skipping test\")\n\t}\n\n\t// It is too complicated right now to deal with a PEM file, the Sylabs infrastructure\n\t// does not let us attach one to a image in the library, so we generate one.\n\tpemPubFile, pemPrivFile := e2e.GeneratePemFiles(t, c.env.TestDir)\n\n\t// We create a temporary directory to store the image, making sure tests\n\t// will not pollute each other\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\timgPath := filepath.Join(tempDir, \"encrypted_cmdline_pem-path.sif\")\n\tcmdArgs := []string{\"--encrypt\", \"--pem-path\", pemPubFile, imgPath, \"oras://ghcr.io/apptainer/alpine:3.15.0\"}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Using command line\n\tcmdArgs = []string{\"--pem-path\", pemPrivFile, imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"pem file cmdline\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Using environment variable\n\tcmdArgs = []string{imgPath}\n\tpemEnvVar := fmt.Sprintf(\"%s=%s\", \"APPTAINER_ENCRYPTION_PEM_PATH\", pemPrivFile)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"pem file cmdline\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), pemEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\nfunc (c ctx) testRunPassphraseEncrypted(t *testing.T) {\n\t// If the version of cryptsetup is not compatible with Apptainer encryption,\n\t// the build commands are expected to fail\n\terr := e2e.CheckCryptsetupVersion()\n\tif err != nil {\n\t\tt.Skip(\"cryptsetup is not compatible, skipping test\")\n\t}\n\n\tpassphraseEnvVar := fmt.Sprintf(\"%s=%s\", \"APPTAINER_ENCRYPTION_PASSPHRASE\", e2e.Passphrase)\n\n\t// We create a temporary directory to store the image, making sure tests\n\t// will not pollute each other\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\timgPath := filepath.Join(tempDir, \"encrypted_cmdline_passphrase.sif\")\n\tcmdArgs := []string{\"--encrypt\", imgPath, \"oras://ghcr.io/apptainer/alpine:3.15.0\"}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tpassphraseInput := []e2e.ApptainerConsoleOp{\n\t\te2e.ConsoleSendLine(e2e.Passphrase),\n\t}\n\n\t// Interactive command\n\tcmdArgs = []string{\"--passphrase\", imgPath, \"/bin/true\"}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"interactive passphrase\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.ConsoleRun(passphraseInput...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Using the environment variable to specify the passphrase\n\tcmdArgs = []string{imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"env var passphrase\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Ensure decryption works with an IPC namespace\n\tcmdArgs = []string{\"--ipc\", imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"env var passphrase with ipc namespace\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Ensure decryption works with containall (IPC and PID namespaces)\n\tcmdArgs = []string{\"--containall\", imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"env var passphrase with containall\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Specifying the passphrase on the command line should always fail\n\tcmdArgs = []string{\"--passphrase\", e2e.Passphrase, imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"passphrase on cmdline\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(255),\n\t)\n}\n\nfunc (c ctx) testFuseOverlayfs(t *testing.T) {\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\toverlayPath := fmt.Sprintf(\"%s/overlay.img\", tempDir)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"overlay\"),\n\t\te2e.WithArgs(\"create\", \"--size\", \"64\", overlayPath),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserNamespaceProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--writable-tmpfs\", \"testdata/busybox_amd64.sif\", \"touch\", \"file\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserNamespaceProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--overlay\", overlayPath, \"testdata/busybox_amd64.sif\", \"touch\", \"file\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserNamespaceProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--overlay\", tempDir, \"testdata/busybox_amd64.sif\", \"touch\", \"file\"),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\nfunc (c ctx) testFuseSquashMount(t *testing.T) {\n\tdataDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfile, err := ioutil.TempFile(dataDir, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp file under temp data dir: %s\", dataDir)\n\t}\n\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfilename := file.Name()\n\tfile.Close()\n\n\tsquashfile := fmt.Sprintf(\"%s/input.squashfs\", tempDir)\n\t_, err = exec.Command(\"mksquashfs\", dataDir, squashfile).Output()\n\tif err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--mount\", fmt.Sprintf(\"type=bind,src=%s,dst=/input-data,image-src=/\", squashfile), \"testdata/busybox_amd64.sif\", \"ls\", \"/input-data\"),\n\t\te2e.ExpectExit(0, e2e.ExpectOutput(e2e.ContainMatch, filepath.Base(filename))),\n\t)\n}\n\nfunc (c ctx) testFuseExt3Mount(t *testing.T) {\n\tdataDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfile, err := ioutil.TempFile(dataDir, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp file under temp data dir: %s\", dataDir)\n\t}\n\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfilename := file.Name()\n\tfile.Close()\n\n\text3file := fmt.Sprintf(\"%s/input.img\", tempDir)\n\t_, err = exec.Command(\"mkfs.ext3\", \"-d\", dataDir, ext3file, \"64M\").Output()\n\tif err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--mount\", fmt.Sprintf(\"type=bind,src=%s,dst=/input-data,image-src=/\", ext3file), \"testdata/busybox_amd64.sif\", \"ls\", \"/input-data\"),\n\t\te2e.ExpectExit(0, e2e.ExpectOutput(e2e.ContainMatch, filepath.Base(filename))),\n\t)\n}\n\nfunc (c ctx) testAddPackageWithFakerootAndTmpfs(t *testing.T) {\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer e2e.Privileged(cleanup)\n\n\tsandbox, err := ioutil.TempDir(tempDir, \"sandbox\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not create sandbox folder inside tempdir: %s\", tempDir)\n\t}\n\n\tsif := fmt.Sprintf(\"%s/centos7.sif\", tempDir)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(sif, \"docker://centos:7\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--sandbox\", \"--force\", sandbox, sif),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// we need to increase sessiondir max size to 32MB\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"config\"),\n\t\te2e.WithArgs(\"global\", \"-s\", \"sessiondir max size\", \"1024\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// restore sessiondir max size to 16MB\n\tdefer c.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"config\"),\n\t\te2e.WithArgs(\"global\", \"-s\", \"sessiondir max size\", \"16\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 1, 1a (--with-suid) (https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--writable-tmpfs\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 1, 1b (--without-suid) (https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 2(https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", \"--ignore-subuid\", \"--ignore-fakeroot-command\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(1),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", \"--ignore-subuid\", \"--ignore-fakeroot-command\", sif, \"yum\", \"install\", \"-y\", \"epel-release\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 3(https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", \"--ignore-subuid\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 4(https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--writable-tmpfs\", \"--ignore-userns\", \"--ignore-subuid\", sandbox, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(1), // because only fakeroot is used. cpio: open failure\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--writable-tmpfs\", \"--ignore-userns\", \"--ignore-subuid\", sandbox, \"yum\", \"install\", \"-y\", \"epel-release\"),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := ctx{\n\t\tenv: env,\n\t}\n\n\treturn testhelper.Tests{\n\t\t\"0555 cache\":                          c.testRun555Cache,\n\t\t\"inaccessible home\":                   c.issue409,\n\t\t\"passphrase encrypted\":                c.testRunPassphraseEncrypted,\n\t\t\"PEM encrypted\":                       c.testRunPEMEncrypted,\n\t\t\"fuse overlayfs\":                      c.testFuseOverlayfs,\n\t\t\"fuse squash mount\":                   c.testFuseSquashMount,\n\t\t\"fuse ext3 mount\":                     c.testFuseExt3Mount,\n\t\t\"add package with fakeroot and tmpfs\": c.testAddPackageWithFakerootAndTmpfs,\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2020, Control Command Inc. All rights reserved.\n// Copyright (c) 2018-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage apptainer\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/ProtonMail/go-crypto/openpgp\"\n\t\"github.com/apptainer/apptainer/internal/pkg/buildcfg\"\n\t\"github.com/apptainer/apptainer/internal/pkg/cgroups\"\n\tfakerootutil \"github.com/apptainer/apptainer/internal/pkg/fakeroot\"\n\t\"github.com/apptainer/apptainer/internal/pkg/image/driver\"\n\t\"github.com/apptainer/apptainer/internal/pkg/instance\"\n\t\"github.com/apptainer/apptainer/internal/pkg/plugin\"\n\t\"github.com/apptainer/apptainer/internal/pkg/runtime/engine/config/starter\"\n\t\"github.com/apptainer/apptainer/internal/pkg/security\"\n\t\"github.com/apptainer/apptainer/internal/pkg/security/seccomp\"\n\t\"github.com/apptainer/apptainer/internal/pkg/syecl\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs/overlay\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/mainthread\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/user\"\n\t\"github.com/apptainer/apptainer/pkg/image\"\n\tfakerootcallback \"github.com/apptainer/apptainer/pkg/plugin/callback/runtime/fakeroot\"\n\tapptainerConfig \"github.com/apptainer/apptainer/pkg/runtime/engine/apptainer/config\"\n\t\"github.com/apptainer/apptainer/pkg/runtime/engine/config\"\n\t\"github.com/apptainer/apptainer/pkg/sylog\"\n\t\"github.com/apptainer/apptainer/pkg/sypgp\"\n\t\"github.com/apptainer/apptainer/pkg/util/capabilities\"\n\t\"github.com/apptainer/apptainer/pkg/util/fs/proc\"\n\t\"github.com/apptainer/apptainer/pkg/util/namespaces\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"golang.org/x/sys/unix\"\n)\n\nvar nsProcName = map[specs.LinuxNamespaceType]string{\n\tspecs.PIDNamespace:     \"pid\",\n\tspecs.UTSNamespace:     \"uts\",\n\tspecs.IPCNamespace:     \"ipc\",\n\tspecs.MountNamespace:   \"mnt\",\n\tspecs.CgroupNamespace:  \"cgroup\",\n\tspecs.NetworkNamespace: \"net\",\n\tspecs.UserNamespace:    \"user\",\n}\n\n// PrepareConfig is called during stage1 to validate and prepare\n// container configuration. It is responsible for apptainer\n// configuration file parsing, handling user input, reading capabilities,\n// and checking what namespaces are required.\n//\n// No additional privileges can be gained as any of them are already\n// dropped by the time PrepareConfig is called.\nfunc (e *EngineOperations) PrepareConfig(starterConfig *starter.Config) error {\n\tvar err error\n\n\tif e.CommonConfig.EngineName != apptainerConfig.Name {\n\t\treturn fmt.Errorf(\"incorrect engine\")\n\t}\n\n\tif e.EngineConfig.OciConfig.Generator.Config != &e.EngineConfig.OciConfig.Spec {\n\t\treturn fmt.Errorf(\"bad engine configuration provided\")\n\t}\n\n\tif !e.EngineConfig.File.AllowSetuid && starterConfig.GetIsSUID() {\n\t\treturn fmt.Errorf(\"suid workflow disabled by administrator\")\n\t}\n\n\tif starterConfig.GetIsSUID() {\n\t\t// check for ownership of apptainer.conf\n\t\tif !fs.IsOwner(buildcfg.APPTAINER_CONF_FILE, 0) {\n\t\t\treturn fmt.Errorf(\"%s must be owned by root\", buildcfg.APPTAINER_CONF_FILE)\n\t\t}\n\t\t// check for ownership of capability.json\n\t\tif !fs.IsOwner(buildcfg.CAPABILITY_FILE, 0) {\n\t\t\treturn fmt.Errorf(\"%s must be owned by root\", buildcfg.CAPABILITY_FILE)\n\t\t}\n\t\t// check for ownership of ecl.toml\n\t\tif !fs.IsOwner(buildcfg.ECL_FILE, 0) {\n\t\t\treturn fmt.Errorf(\"%s must be owned by root\", buildcfg.ECL_FILE)\n\t\t}\n\t\tif fakerootPath := e.EngineConfig.GetFakerootPath(); fakerootPath != \"\" {\n\t\t\t// look for fakeroot again because the PATH used is\n\t\t\t//  more restricted at this point than it was earlier\n\t\t\tnewPath, err := fakerootutil.FindFake()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error finding fakeroot in privileged PATH: %v\", err)\n\t\t\t}\n\t\t\tif newPath != fakerootPath {\n\t\t\t\tsylog.Verbosef(\"path to fakeroot changed from %v to %v\", fakerootPath, newPath)\n\t\t\t}\n\t\t\te.EngineConfig.SetFakerootPath(newPath)\n\t\t}\n\t}\n\n\t// Save the current working directory if not set\n\tif e.EngineConfig.GetCwd() == \"\" {\n\t\tif pwd, err := os.Getwd(); err == nil {\n\t\t\te.EngineConfig.SetCwd(pwd)\n\t\t} else {\n\t\t\tsylog.Warningf(\"can't determine current working directory\")\n\t\t\te.EngineConfig.SetCwd(\"/\")\n\t\t}\n\t}\n\n\tif e.EngineConfig.OciConfig.Process == nil {\n\t\te.EngineConfig.OciConfig.Process = &specs.Process{}\n\t}\n\tif e.EngineConfig.OciConfig.Process.Capabilities == nil {\n\t\te.EngineConfig.OciConfig.Process.Capabilities = &specs.LinuxCapabilities{}\n\t}\n\tif len(e.EngineConfig.OciConfig.Process.Args) == 0 {\n\t\treturn fmt.Errorf(\"container process arguments not found\")\n\t}\n\n\tuid := e.EngineConfig.GetTargetUID()\n\tgids := e.EngineConfig.GetTargetGID()\n\n\tif os.Getuid() == 0 && (uid != 0 || len(gids) > 0) {\n\t\tstarterConfig.SetTargetUID(uid)\n\t\tstarterConfig.SetTargetGID(gids)\n\t\te.EngineConfig.OciConfig.SetProcessNoNewPrivileges(true)\n\t}\n\n\tuserNS := !starterConfig.GetIsSUID() || e.EngineConfig.GetFakeroot()\n\tdriver.InitImageDrivers(true, userNS, e.EngineConfig.File, 0)\n\timageDriver = image.GetDriver(e.EngineConfig.File.ImageDriver)\n\n\tif e.EngineConfig.GetInstanceJoin() {\n\t\tif err := e.prepareInstanceJoinConfig(starterConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := e.prepareContainerConfig(starterConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.loadImages(starterConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tstarterConfig.SetMasterPropagateMount(true)\n\tstarterConfig.SetNoNewPrivs(e.EngineConfig.OciConfig.Process.NoNewPrivileges)\n\n\tif e.EngineConfig.OciConfig.Process != nil && e.EngineConfig.OciConfig.Process.Capabilities != nil {\n\t\tstarterConfig.SetCapabilities(capabilities.Permitted, e.EngineConfig.OciConfig.Process.Capabilities.Permitted)\n\t\tstarterConfig.SetCapabilities(capabilities.Effective, e.EngineConfig.OciConfig.Process.Capabilities.Effective)\n\t\tstarterConfig.SetCapabilities(capabilities.Inheritable, e.EngineConfig.OciConfig.Process.Capabilities.Inheritable)\n\t\tstarterConfig.SetCapabilities(capabilities.Bounding, e.EngineConfig.OciConfig.Process.Capabilities.Bounding)\n\t\tstarterConfig.SetCapabilities(capabilities.Ambient, e.EngineConfig.OciConfig.Process.Capabilities.Ambient)\n\t}\n\n\t// determine if engine need to propagate signals across processes\n\te.checkSignalPropagation()\n\n\t// We must call this here because at this point we haven't\n\t// spawned the master process nor the RPC server. The assumption\n\t// is that this function runs in stage 1 and that even if it's a\n\t// separate process, it's created in such a way that it's\n\t// sharing its file descriptor table with the wrapper / stage 2.\n\t//\n\t// At this point we do not have elevated privileges. We assume\n\t// that the user running apptainer has access to /dev/fuse\n\t// (typically it's 0666, or 0660 belonging to a group that\n\t// allows the user to read and write to it).\n\tsendFd, err := openDevFuse(e, starterConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsylog.Debugf(\"image driver is %v\", e.EngineConfig.File.ImageDriver)\n\tif sendFd || e.EngineConfig.File.ImageDriver != \"\" {\n\t\tfds, err := unix.Socketpair(unix.AF_UNIX, unix.SOCK_STREAM|unix.SOCK_CLOEXEC, 0)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create socketpair to pass file descriptor: %s\", err)\n\t\t}\n\t\te.EngineConfig.SetUnixSocketPair(fds)\n\t\tstarterConfig.KeepFileDescriptor(fds[0])\n\t\tstarterConfig.KeepFileDescriptor(fds[1])\n\t} else {\n\t\te.EngineConfig.SetUnixSocketPair([2]int{-1, -1})\n\t}\n\n\t// nvidia-container-cli requires additional caps in the starter bounding set.\n\t// These are within the capability set for the starter process itself, *not* the capabilities\n\t// that will be set on the running container process, which are defined with SetCapabilities above.\n\tif e.EngineConfig.GetNvCCLI() {\n\t\t// Disallow this feature under setuid mode because running\n\t\t// the external command is too risky\n\t\tif starterConfig.GetIsSUID() && os.Geteuid() != 0 {\n\t\t\treturn fmt.Errorf(\"nvidia-container-cli not allowed in setuid mode\")\n\t\t}\n\n\t\tstarterConfig.SetNvCCLICaps(true)\n\t}\n\n\treturn nil\n}\n\n// prepareUserCaps is responsible for checking that user's requested\n// capabilities are authorized.\nfunc (e *EngineOperations) prepareUserCaps(enforced bool) error {\n\tcommonCaps := make([]string, 0)\n\tcommonUnauthorizedCaps := make([]string, 0)\n\n\te.EngineConfig.OciConfig.SetProcessNoNewPrivileges(true)\n\n\tfile, err := os.OpenFile(buildcfg.CAPABILITY_FILE, os.O_RDONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while opening capability config file: %s\", err)\n\t}\n\tdefer file.Close()\n\n\tcapConfig, err := capabilities.ReadFrom(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while parsing capability config data: %s\", err)\n\t}\n\n\tpw, err := user.Current()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaps, ignoredCaps := capabilities.Split(e.EngineConfig.GetAddCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't add unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tcaps = append(caps, e.EngineConfig.OciConfig.Process.Capabilities.Permitted...)\n\n\tif enforced {\n\t\tauthorizedCaps, unauthorizedCaps := capConfig.CheckUserCaps(pw.Name, caps)\n\t\tif len(authorizedCaps) > 0 {\n\t\t\tsylog.Debugf(\"User capabilities %s added\", strings.Join(authorizedCaps, \",\"))\n\t\t\tcommonCaps = authorizedCaps\n\t\t}\n\t\tif len(unauthorizedCaps) > 0 {\n\t\t\tcommonUnauthorizedCaps = append(commonUnauthorizedCaps, unauthorizedCaps...)\n\t\t}\n\n\t\tgroups, err := os.Getgroups()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, g := range groups {\n\t\t\tgr, err := user.GetGrGID(uint32(g))\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Ignoring group %d: %s\", g, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tauthorizedCaps, unauthorizedCaps := capConfig.CheckGroupCaps(gr.Name, caps)\n\t\t\tif len(authorizedCaps) > 0 {\n\t\t\t\tsylog.Debugf(\"%s group capabilities %s added\", gr.Name, strings.Join(authorizedCaps, \",\"))\n\t\t\t\tcommonCaps = append(commonCaps, authorizedCaps...)\n\t\t\t}\n\t\t\tif len(unauthorizedCaps) > 0 {\n\t\t\t\tcommonUnauthorizedCaps = append(commonUnauthorizedCaps, unauthorizedCaps...)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcommonCaps = caps\n\t}\n\n\tcommonCaps = capabilities.RemoveDuplicated(commonCaps)\n\tcommonUnauthorizedCaps = capabilities.RemoveDuplicated(commonUnauthorizedCaps)\n\n\t// remove authorized capabilities from unauthorized capabilities list\n\t// to end with the really unauthorized capabilities\n\tfor _, c := range commonCaps {\n\t\tfor i := len(commonUnauthorizedCaps) - 1; i >= 0; i-- {\n\t\t\tif commonUnauthorizedCaps[i] == c {\n\t\t\t\tcommonUnauthorizedCaps = append(commonUnauthorizedCaps[:i], commonUnauthorizedCaps[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif len(commonUnauthorizedCaps) > 0 {\n\t\tsylog.Warningf(\"not authorized to add capability: %s\", strings.Join(commonUnauthorizedCaps, \",\"))\n\t}\n\n\tcaps, ignoredCaps = capabilities.Split(e.EngineConfig.GetDropCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't drop unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tfor _, capability := range caps {\n\t\tfor i, c := range commonCaps {\n\t\t\tif c == capability {\n\t\t\t\tsylog.Debugf(\"Capability %s dropped\", capability)\n\t\t\t\tcommonCaps = append(commonCaps[:i], commonCaps[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\te.EngineConfig.OciConfig.Process.Capabilities.Permitted = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Effective = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Inheritable = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Bounding = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Ambient = commonCaps\n\n\treturn nil\n}\n\n// prepareRootCaps is responsible for setting root capabilities\n// based on capability/configuration files and requested capabilities.\nfunc (e *EngineOperations) prepareRootCaps() error {\n\tcommonCaps := make([]string, 0)\n\tdefaultCapabilities := e.EngineConfig.File.RootDefaultCapabilities\n\n\tuid := e.EngineConfig.GetTargetUID()\n\tgids := e.EngineConfig.GetTargetGID()\n\n\tif uid != 0 || len(gids) > 0 {\n\t\tdefaultCapabilities = \"no\"\n\t}\n\n\t// is no-privs/keep-privs set on command line\n\tif e.EngineConfig.GetNoPrivs() {\n\t\tsylog.Debugf(\"--no-privs requested, no new privileges enabled\")\n\t\tdefaultCapabilities = \"no\"\n\t} else if e.EngineConfig.GetKeepPrivs() {\n\t\tsylog.Debugf(\"--keep-privs requested\")\n\t\tdefaultCapabilities = \"full\"\n\t}\n\n\tsylog.Debugf(\"Root %s capabilities\", defaultCapabilities)\n\n\t// set default capabilities based on configuration file directive\n\tswitch defaultCapabilities {\n\tcase \"full\":\n\t\te.EngineConfig.OciConfig.SetupPrivileged(true)\n\t\tcommonCaps = e.EngineConfig.OciConfig.Process.Capabilities.Permitted\n\tcase \"file\":\n\t\tfile, err := os.OpenFile(buildcfg.CAPABILITY_FILE, os.O_RDONLY, 0o644)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while opening capability config file: %s\", err)\n\t\t}\n\t\tdefer file.Close()\n\n\t\tcapConfig, err := capabilities.ReadFrom(file)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while parsing capability config data: %s\", err)\n\t\t}\n\n\t\tcommonCaps = append(commonCaps, capConfig.ListUserCaps(\"root\")...)\n\n\t\tgroups, err := os.Getgroups()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while getting groups: %s\", err)\n\t\t}\n\n\t\tfor _, g := range groups {\n\t\t\tgr, err := user.GetGrGID(uint32(g))\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Ignoring group %d: %s\", g, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcaps := capConfig.ListGroupCaps(gr.Name)\n\t\t\tcommonCaps = append(commonCaps, caps...)\n\t\t\tsylog.Debugf(\"%s group capabilities %s added\", gr.Name, strings.Join(caps, \",\"))\n\t\t}\n\tdefault:\n\t\te.EngineConfig.OciConfig.SetProcessNoNewPrivileges(true)\n\t}\n\n\tcaps, ignoredCaps := capabilities.Split(e.EngineConfig.GetAddCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't add unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tfor _, capability := range caps {\n\t\tfound := false\n\t\tfor _, c := range commonCaps {\n\t\t\tif c == capability {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tsylog.Debugf(\"Root capability %s added\", capability)\n\t\t\tcommonCaps = append(commonCaps, capability)\n\t\t}\n\t}\n\n\tcommonCaps = capabilities.RemoveDuplicated(commonCaps)\n\n\tcaps, ignoredCaps = capabilities.Split(e.EngineConfig.GetDropCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't add unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tfor _, capability := range caps {\n\t\tfor i, c := range commonCaps {\n\t\t\tif c == capability {\n\t\t\t\tsylog.Debugf(\"Root capability %s dropped\", capability)\n\t\t\t\tcommonCaps = append(commonCaps[:i], commonCaps[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\te.EngineConfig.OciConfig.Process.Capabilities.Permitted = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Effective = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Inheritable = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Bounding = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Ambient = commonCaps\n\n\treturn nil\n}\n\nfunc keepAutofsMount(source string, autoFsPoints []string) (int, error) {\n\tresolved, err := filepath.EvalSymlinks(source)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tfor _, p := range autoFsPoints {\n\t\tif strings.HasPrefix(resolved, p) {\n\t\t\tsylog.Debugf(\"Open file descriptor for %s\", resolved)\n\t\t\tf, err := os.Open(resolved)\n\t\t\tif err != nil {\n\t\t\t\treturn -1, err\n\t\t\t}\n\t\t\treturn int(f.Fd()), nil\n\t\t}\n\t}\n\n\treturn -1, fmt.Errorf(\"no mount point\")\n}\n\nfunc (e *EngineOperations) prepareAutofs(starterConfig *starter.Config) error {\n\tconst mountInfoPath = \"/proc/self/mountinfo\"\n\n\tentries, err := proc.GetMountInfoEntry(mountInfoPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while parsing %s: %s\", mountInfoPath, err)\n\t}\n\tautoFsPoints := make([]string, 0)\n\tfor _, e := range entries {\n\t\tif e.FSType == \"autofs\" {\n\t\t\tsylog.Debugf(\"Found %q as autofs mount point\", e.Point)\n\t\t\tautoFsPoints = append(autoFsPoints, e.Point)\n\t\t}\n\t}\n\tif len(autoFsPoints) == 0 {\n\t\tsylog.Debugf(\"No autofs mount point found\")\n\t\treturn nil\n\t}\n\n\tfds := make([]int, 0)\n\n\tif e.EngineConfig.File.UserBindControl {\n\t\tfor _, b := range e.EngineConfig.GetBindPath() {\n\t\t\tfd, err := keepAutofsMount(b.Source, autoFsPoints)\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Could not keep file descriptor for user bind path %s: %s\", b.Source, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfds = append(fds, fd)\n\t\t}\n\t}\n\n\tif !e.EngineConfig.GetContain() {\n\t\tfor _, bindpath := range e.EngineConfig.File.BindPath {\n\t\t\tsplitted := strings.Split(bindpath, \":\")\n\n\t\t\tfd, err := keepAutofsMount(splitted[0], autoFsPoints)\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Could not keep file descriptor for bind path %s: %s\", splitted[0], err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfds = append(fds, fd)\n\t\t}\n\n\t\t// check home source directory\n\t\tdir := e.EngineConfig.GetHomeSource()\n\t\tfd, err := keepAutofsMount(dir, autoFsPoints)\n\t\tif err != nil {\n\t\t\tsylog.Debugf(\"Could not keep file descriptor for home directory %s: %s\", dir, err)\n\t\t} else {\n\t\t\tfds = append(fds, fd)\n\t\t}\n\n\t\t// check the current working directory\n\t\tdir = e.EngineConfig.GetCwd()\n\t\tfd, err = keepAutofsMount(dir, autoFsPoints)\n\t\tif err != nil {\n\t\t\tsylog.Debugf(\"Could not keep file descriptor for current working directory %s: %s\", dir, err)\n\t\t} else {\n\t\t\tfds = append(fds, fd)\n\t\t}\n\t} else {\n\t\t// check workdir\n\t\tdir := e.EngineConfig.GetWorkdir()\n\t\tfd, err := keepAutofsMount(dir, autoFsPoints)\n\t\tif err != nil {\n\t\t\tsylog.Debugf(\"Could not keep file descriptor for workdir %s: %s\", dir, err)\n\t\t} else {\n\t\t\tfds = append(fds, fd)\n\t\t}\n\t}\n\n\tfor _, f := range fds {\n\t\tif err := starterConfig.KeepFileDescriptor(f); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\te.EngineConfig.SetOpenFd(fds)\n\n\treturn nil\n}\n\n// prepareContainerConfig is responsible for getting and applying\n// user supplied configuration for container creation.\nfunc (e *EngineOperations) prepareContainerConfig(starterConfig *starter.Config) error {\n\t// always set mount namespace\n\te.EngineConfig.OciConfig.AddOrReplaceLinuxNamespace(specs.MountNamespace, \"\")\n\n\t// if PID namespace is not allowed remove it from namespaces\n\tif !e.EngineConfig.File.AllowPidNs && e.EngineConfig.OciConfig.Linux != nil {\n\t\tnamespaces := e.EngineConfig.OciConfig.Linux.Namespaces\n\t\tfor i, ns := range namespaces {\n\t\t\tif ns.Type == specs.PIDNamespace {\n\t\t\t\tsylog.Debugf(\"Not virtualizing PID namespace by configuration\")\n\t\t\t\te.EngineConfig.OciConfig.Linux.Namespaces = append(namespaces[:i], namespaces[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif os.Getuid() == 0 {\n\t\tif err := e.prepareRootCaps(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tenforced := starterConfig.GetIsSUID()\n\t\tif err := e.prepareUserCaps(enforced); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif e.EngineConfig.File.MountSlave {\n\t\tstarterConfig.SetMountPropagation(\"rslave\")\n\t} else {\n\t\tstarterConfig.SetMountPropagation(\"rprivate\")\n\t}\n\n\tif e.EngineConfig.GetFakeroot() {\n\t\tuid := uint32(os.Getuid())\n\t\tgid := uint32(os.Getgid())\n\n\t\tif !starterConfig.GetIsSUID() && fakerootutil.IsUIDMapped(uid) {\n\t\t\t// no SUID workflow, check if newuidmap/newgidmap are present\n\t\t\tsylog.Verbosef(\"Fakeroot requested with unprivileged workflow, fallback to newuidmap/newgidmap\")\n\t\t\tsylog.Debugf(\"Search for newuidmap binary\")\n\t\t\tif err := starterConfig.SetNewUIDMapPath(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsylog.Debugf(\"Search for newgidmap binary\")\n\t\t\tif err := starterConfig.SetNewGIDMapPath(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tgetIDRange := fakerootutil.GetIDRange\n\n\t\tcallbackType := (fakerootcallback.UserMapping)(nil)\n\t\tcallbacks, err := plugin.LoadCallbacks(callbackType)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while loading plugins callbacks '%T': %s\", callbackType, err)\n\t\t}\n\t\tif len(callbacks) > 1 {\n\t\t\treturn fmt.Errorf(\"multiple plugins have registered hook callback for fakeroot\")\n\t\t} else if len(callbacks) == 1 {\n\t\t\tgetIDRange = callbacks[0].(fakerootcallback.UserMapping)\n\t\t}\n\n\t\te.EngineConfig.OciConfig.AddLinuxUIDMapping(uid, 0, 1)\n\t\tidRange, err := getIDRange(fakerootutil.SubUIDFile, uid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not use fakeroot: %s\", err)\n\t\t}\n\t\te.EngineConfig.OciConfig.AddLinuxUIDMapping(idRange.HostID, idRange.ContainerID, idRange.Size)\n\t\tstarterConfig.AddUIDMappings(e.EngineConfig.OciConfig.Linux.UIDMappings)\n\n\t\te.EngineConfig.OciConfig.AddLinuxGIDMapping(gid, 0, 1)\n\t\tidRange, err = getIDRange(fakerootutil.SubGIDFile, uid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not use fakeroot: %s\", err)\n\t\t}\n\t\te.EngineConfig.OciConfig.AddLinuxGIDMapping(idRange.HostID, idRange.ContainerID, idRange.Size)\n\t\tstarterConfig.AddGIDMappings(e.EngineConfig.OciConfig.Linux.GIDMappings)\n\n\t\te.EngineConfig.OciConfig.SetupPrivileged(true)\n\n\t\te.EngineConfig.OciConfig.AddOrReplaceLinuxNamespace(specs.UserNamespace, \"\")\n\n\t\tstarterConfig.SetHybridWorkflow(true)\n\t\tstarterConfig.SetAllowSetgroups(true)\n\n\t\tstarterConfig.SetTargetUID(0)\n\t\tstarterConfig.SetTargetGID([]int{0})\n\t}\n\n\tstarterConfig.SetBringLoopbackInterface(true)\n\n\tstarterConfig.SetInstance(e.EngineConfig.GetInstance())\n\n\tstarterConfig.SetNsFlagsFromSpec(e.EngineConfig.OciConfig.Linux.Namespaces)\n\n\t// user namespace ID mappings\n\tif e.EngineConfig.OciConfig.Linux != nil {\n\t\tif err := starterConfig.AddUIDMappings(e.EngineConfig.OciConfig.Linux.UIDMappings); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := starterConfig.AddGIDMappings(e.EngineConfig.OciConfig.Linux.GIDMappings); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tparam := security.GetParam(e.EngineConfig.GetSecurity(), \"selinux\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying SELinux context %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessSelinuxLabel(param)\n\t}\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"apparmor\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying Apparmor profile %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessApparmorProfile(param)\n\t}\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"seccomp\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying seccomp rule from %s\", param)\n\t\tgenerator := &e.EngineConfig.OciConfig.Generator\n\t\tif err := seccomp.LoadProfileFromFile(param, generator); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// open file descriptors (autofs bug path)\n\treturn e.prepareAutofs(starterConfig)\n}\n\n// prepareInstanceJoinConfig is responsible for getting and\n// applying configuration to join a running instance.\n//nolint:maintidx\nfunc (e *EngineOperations) prepareInstanceJoinConfig(starterConfig *starter.Config) error {\n\tname := instance.ExtractName(e.EngineConfig.GetImage())\n\tfile, err := instance.Get(name, instance.AppSubDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tuid := os.Getuid()\n\tgid := os.Getgid()\n\tsuidRequired := uid != 0 && !file.UserNs\n\n\t// basic checks:\n\t// 1. a user must not use SUID workflow to join an instance\n\t//    started with user namespace\n\t// 2. a user must use SUID workflow to join an instance\n\t//    started without user namespace\n\tif starterConfig.GetIsSUID() && !suidRequired {\n\t\treturn fmt.Errorf(\"joining user namespace with suid workflow is not allowed\")\n\t} else if !starterConfig.GetIsSUID() && suidRequired {\n\t\treturn fmt.Errorf(\"a setuid installation is required to join this instance\")\n\t}\n\n\t// Pid and PPid are stored in instance file and can be controlled\n\t// by users, check to make sure these values are sane\n\tif file.Pid <= 1 || file.PPid <= 1 {\n\t\treturn fmt.Errorf(\"bad instance process ID found\")\n\t}\n\n\t// instance configuration holding configuration read\n\t// from instance file\n\tinstanceEngineConfig := apptainerConfig.NewConfig()\n\n\t// extract engine configuration from instance file, the whole content\n\t// of this file can't be trusted\n\tinstanceConfig := &config.Common{\n\t\tEngineConfig: instanceEngineConfig,\n\t}\n\tif err := json.Unmarshal(file.Config, instanceConfig); err != nil {\n\t\treturn err\n\t}\n\n\t// configuration may be altered, be sure to not panic\n\tif instanceEngineConfig.OciConfig.Linux == nil {\n\t\tinstanceEngineConfig.OciConfig.Linux = &specs.Linux{}\n\t}\n\n\t// go into /proc/<pid> directory to open namespaces inodes\n\t// relative to current working directory while joining\n\t// namespaces within C starter code as changing directory\n\t// here will also affects starter process thanks to\n\t// SetWorkingDirectoryFd call.\n\t// Additionally it would prevent TOCTOU races and symlink\n\t// usage.\n\t// And if instance process exits during checks or while\n\t// entering in namespace, we would get a \"no such process\"\n\t// error because current working directory would point to a\n\t// deleted inode: \"/proc/self/cwd -> /proc/<pid> (deleted)\"\n\tpath := filepath.Join(\"/proc\", strconv.Itoa(file.Pid))\n\tfd, err := syscall.Open(path, syscall.O_RDONLY|syscall.O_DIRECTORY, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not open proc directory %s: %s\", path, err)\n\t}\n\tif err := mainthread.Fchdir(fd); err != nil {\n\t\treturn err\n\t}\n\t// will set starter (via fchdir too) in the same proc directory\n\t// in order to open namespace inodes with relative paths for the\n\t// right process\n\tstarterConfig.SetWorkingDirectoryFd(fd)\n\n\t// enforce checks while joining an instance process with SUID workflow\n\t// since instance file is stored in user home directory, we can't trust\n\t// its content when using SUID workflow\n\tif suidRequired {\n\t\t// check if instance is running with user namespace enabled\n\t\t// by reading /proc/pid/uid_map\n\t\t_, hid, err := proc.ReadIDMap(\"uid_map\")\n\n\t\t// if the error returned is \"no such file or directory\" it means\n\t\t// that user namespaces are not supported, just skip this check\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"failed to read user namespace mapping: %s\", err)\n\t\t} else if err == nil && hid > 0 {\n\t\t\t// a host uid greater than 0 means user namespace is in use for this process\n\t\t\treturn fmt.Errorf(\"trying to join an instance running with user namespace enabled\")\n\t\t}\n\n\t\t// read \"/proc/pid/root\" link of instance process must return\n\t\t// a permission denied error.\n\t\t// This is the \"appinit\" process (PID 1 in container) and it inherited\n\t\t// setuid bit, so most of \"/proc/pid\" entries are owned by root:root\n\t\t// like \"/proc/pid/root\" link even if the process has dropped all\n\t\t// privileges and run with user UID/GID. So we expect a \"permission denied\"\n\t\t// error when reading link.\n\t\tif _, err := mainthread.Readlink(\"root\"); !os.IsPermission(err) {\n\t\t\treturn fmt.Errorf(\"trying to join a wrong instance process\")\n\t\t}\n\t\t// Since we could be tricked to join namespaces of a root owned process,\n\t\t// we will get UID/GID information of task directory to be sure it belongs\n\t\t// to the user currently joining the instance. Also ensure that a user won't\n\t\t// be able to join other user's instances.\n\t\tfi, err := os.Stat(\"task\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error while getting information for instance task directory: %s\", err)\n\t\t}\n\t\tst := fi.Sys().(*syscall.Stat_t)\n\t\tif st.Uid != uint32(uid) || st.Gid != uint32(gid) {\n\t\t\treturn fmt.Errorf(\"instance process owned by %d:%d instead of %d:%d\", st.Uid, st.Gid, uid, gid)\n\t\t}\n\n\t\tppid := -1\n\n\t\t// read \"/proc/pid/status\" to check if instance process\n\t\t// is neither orphaned or faked\n\t\tf, err := os.Open(\"status\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not open status: %s\", err)\n\t\t}\n\n\t\tfor s := bufio.NewScanner(f); s.Scan(); {\n\t\t\tif n, _ := fmt.Sscanf(s.Text(), \"PPid:\\t%d\", &ppid); n == 1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tf.Close()\n\n\t\t// check that Ppid/Pid read from instance file are \"somewhat\" valid\n\t\t// processes\n\t\tif ppid <= 1 || ppid != file.PPid {\n\t\t\treturn fmt.Errorf(\"orphaned (or faked) instance process\")\n\t\t}\n\n\t\t// read \"/proc/ppid/root\" link of parent instance process must return\n\t\t// a permission denied error (same logic than \"appinit\" process).\n\t\t// Also we don't use absolute path because we want to return an error\n\t\t// if current working directory is deleted meaning that instance process\n\t\t// exited.\n\t\tpath := filepath.Join(\"..\", strconv.Itoa(file.PPid), \"root\")\n\t\tif _, err := mainthread.Readlink(path); !os.IsPermission(err) {\n\t\t\treturn fmt.Errorf(\"trying to join a wrong instance process\")\n\t\t}\n\t\t// \"/proc/ppid/task\" directory must be owned by user UID/GID\n\t\tpath = filepath.Join(\"..\", strconv.Itoa(file.PPid), \"task\")\n\t\tfi, err = os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error while getting information for parent task directory: %s\", err)\n\t\t}\n\t\tst = fi.Sys().(*syscall.Stat_t)\n\t\tif st.Uid != uint32(uid) || st.Gid != uint32(gid) {\n\t\t\treturn fmt.Errorf(\"parent instance process owned by %d:%d instead of %d:%d\", st.Uid, st.Gid, uid, gid)\n\t\t}\n\n\t\tpath, err = filepath.Abs(\"comm\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine absolute path for comm: %s\", err)\n\t\t}\n\n\t\t// we must read \"appinit\\n\"\n\t\tb, err := ioutil.ReadFile(\"comm\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to read %s: %s\", path, err)\n\t\t}\n\t\t// check that we are currently joining appinit process\n\t\tif \"appinit\" != strings.Trim(string(b), \"\\n\") {\n\t\t\treturn fmt.Errorf(\"appinit not found in %s, wrong instance process\", path)\n\t\t}\n\t}\n\n\t// tell starter that we are joining an instance\n\tstarterConfig.SetNamespaceJoinOnly(true)\n\n\t// update namespaces path relative to /proc/<pid>\n\t// since starter process is in /proc/<pid> directory\n\tfor i := range instanceEngineConfig.OciConfig.Linux.Namespaces {\n\t\t// ignore unknown namespaces\n\t\tt := instanceEngineConfig.OciConfig.Linux.Namespaces[i].Type\n\t\tif _, ok := nsProcName[t]; !ok {\n\t\t\tcontinue\n\t\t}\n\t\t// set namespace relative path\n\t\tinstanceEngineConfig.OciConfig.Linux.Namespaces[i].Path = filepath.Join(\"ns\", nsProcName[t])\n\t}\n\n\t// store namespace paths in starter configuration that will\n\t// be passed via a shared memory area and used by starter C code\n\t// once this process exit\n\tif err := starterConfig.SetNsPathFromSpec(instanceEngineConfig.OciConfig.Linux.Namespaces); err != nil {\n\t\treturn err\n\t}\n\n\t// duplicate instance capabilities\n\tif instanceEngineConfig.OciConfig.Process != nil && instanceEngineConfig.OciConfig.Process.Capabilities != nil {\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Permitted = instanceEngineConfig.OciConfig.Process.Capabilities.Permitted\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Effective = instanceEngineConfig.OciConfig.Process.Capabilities.Effective\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Inheritable = instanceEngineConfig.OciConfig.Process.Capabilities.Inheritable\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Bounding = instanceEngineConfig.OciConfig.Process.Capabilities.Bounding\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Ambient = instanceEngineConfig.OciConfig.Process.Capabilities.Ambient\n\t}\n\n\t// check if user is authorized to set those capabilities and remove\n\t// unauthorized capabilities from current set according to capability\n\t// configuration file\n\tif uid == 0 {\n\t\tif err := e.prepareRootCaps(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := e.prepareUserCaps(suidRequired); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// set UID/GID for the fakeroot context\n\tif instanceEngineConfig.GetFakeroot() {\n\t\tstarterConfig.SetTargetUID(0)\n\t\tstarterConfig.SetTargetGID([]int{0})\n\t}\n\n\t// restore HOME environment variable to match the\n\t// one set during instance start\n\te.EngineConfig.OciConfig.SetProcessEnv(\"HOME\", instanceEngineConfig.GetHomeDest())\n\n\t// restore apparmor profile or apply a new one if provided\n\tparam := security.GetParam(e.EngineConfig.GetSecurity(), \"apparmor\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying Apparmor profile %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessApparmorProfile(param)\n\t} else {\n\t\te.EngineConfig.OciConfig.SetProcessApparmorProfile(instanceEngineConfig.OciConfig.Process.ApparmorProfile)\n\t}\n\n\t// restore selinux context or apply a new one if provided\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"selinux\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying SELinux context %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessSelinuxLabel(param)\n\t} else {\n\t\te.EngineConfig.OciConfig.SetProcessSelinuxLabel(instanceEngineConfig.OciConfig.Process.SelinuxLabel)\n\t}\n\n\t// restore seccomp filter or apply a new one if provided\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"seccomp\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying seccomp rule from %s\", param)\n\t\tgenerator := &e.EngineConfig.OciConfig.Generator\n\t\tif err := seccomp.LoadProfileFromFile(param, generator); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif e.EngineConfig.OciConfig.Linux == nil {\n\t\t\te.EngineConfig.OciConfig.Linux = &specs.Linux{}\n\t\t}\n\t\te.EngineConfig.OciConfig.Linux.Seccomp = instanceEngineConfig.OciConfig.Linux.Seccomp\n\t}\n\n\tif file.Cgroup {\n\t\tsylog.Debugf(\"Adding process to instance cgroup\")\n\t\tppid := os.Getppid()\n\t\tmanager, err := cgroups.GetManagerForPid(file.Pid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't create cgroup manager: %v\", err)\n\t\t}\n\t\tif err := manager.AddProc(ppid); err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't add process to instance cgroup: %v\", err)\n\t\t}\n\t}\n\n\t// only root user can set this value based on instance file\n\t// and always set to true for normal users or if instance file\n\t// returned a wrong configuration\n\tif uid == 0 && instanceEngineConfig.OciConfig.Process != nil {\n\t\te.EngineConfig.OciConfig.Process.NoNewPrivileges = instanceEngineConfig.OciConfig.Process.NoNewPrivileges\n\t} else {\n\t\te.EngineConfig.OciConfig.Process.NoNewPrivileges = true\n\t}\n\n\treturn nil\n}\n\n// openDevFuse is a helper function that opens /dev/fuse once for each\n// plugin that wants to mount a FUSE filesystem.\nfunc openDevFuse(e *EngineOperations, starterConfig *starter.Config) (bool, error) {\n\t// do we require to send file descriptor\n\tsendFd := false\n\n\t// we won't copy slice while iterating fuse mounts\n\tmounts := e.EngineConfig.GetFuseMount()\n\n\tif len(mounts) == 0 {\n\t\treturn false, nil\n\t}\n\n\tif !e.EngineConfig.File.EnableFusemount {\n\t\treturn false, fmt.Errorf(\"fusemount disabled by configuration 'enable fusemount = no'\")\n\t}\n\n\tfor i := range mounts {\n\t\tsylog.Debugf(\"Opening /dev/fuse for FUSE mount point %s\\n\", mounts[i].MountPoint)\n\t\tfd, err := syscall.Open(\"/dev/fuse\", syscall.O_RDWR, 0)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tmounts[i].Fd = fd\n\t\tstarterConfig.KeepFileDescriptor(fd)\n\n\t\tif (!starterConfig.GetIsSUID() || e.EngineConfig.GetFakeroot()) && !mounts[i].FromContainer {\n\t\t\tsendFd = true\n\t\t}\n\t}\n\n\treturn sendFd, nil\n}\n\nfunc (e *EngineOperations) checkSignalPropagation() {\n\t// obtain the process group ID of the associated controlling\n\t// terminal (if there's one).\n\tpgrp := 0\n\tfor i := 0; i <= 2; i++ {\n\t\t// The two possible errors:\n\t\t// - EBADF will return 0 as process group\n\t\t// - ENOTTY will also return 0 as process group\n\t\tpgrp, _ = unix.IoctlGetInt(i, unix.TIOCGPGRP)\n\t\t// based on kernel source a 0 value for process group\n\t\t// theoretically be set but really not sure it can happen\n\t\t// with linux tty behavior\n\t\tif pgrp != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\t// cases we need to propagate signals to container process:\n\t// - when pgrp == 0 because container won't run in a terminal\n\t// - when process group is different from the process group controlling terminal\n\tif pgrp == 0 || (pgrp > 0 && pgrp != syscall.Getpgrp()) {\n\t\te.EngineConfig.SetSignalPropagation(true)\n\t}\n}\n\n// setSessionLayer will test if overlay is supported/allowed.\nfunc (e *EngineOperations) setSessionLayer(img *image.Image) error {\n\te.EngineConfig.SetSessionLayer(apptainerConfig.DefaultLayer)\n\n\twritableTmpfs := e.EngineConfig.GetWritableTmpfs()\n\twritableImage := e.EngineConfig.GetWritableImage()\n\thasOverlayImage := len(e.EngineConfig.GetOverlayImage()) > 0\n\toverlayDriver := e.EngineConfig.File.EnableOverlay == \"driver\"\n\n\tif writableImage && hasOverlayImage {\n\t\treturn fmt.Errorf(\"cannot use --overlay in conjunction with --writable\")\n\t}\n\n\t// a SIF image may contain one or more overlay partition\n\t// check there is at least one ext3 overlay partition\n\t// to validate overlay with writable flag\n\thasSIFOverlay := false\n\n\tif img.Type == image.SIF {\n\t\toverlays, err := img.GetOverlayPartitions()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while getting overlay partition in SIF image %s: %s\", img.Path, err)\n\t\t}\n\t\tfor _, o := range overlays {\n\t\t\tif o.Type == image.EXT3 {\n\t\t\t\thasSIFOverlay = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif overlayDriver {\n\t\t// overlay is always handled by the image driver\n\t\tif e.EngineConfig.File.ImageDriver == \"\" {\n\t\t\treturn fmt.Errorf(\"you need to specify an image driver with 'enable overlay = driver'\")\n\t\t}\n\t\tif !writableImage || hasSIFOverlay {\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\treturn nil\n\t}\n\n\t// Check for implicit user namespace, e.g when we run %test in a fakeroot build\n\t// https://github.com/apptainer/singularity/issues/5315\n\tuserNS, _ := namespaces.IsInsideUserNamespace(os.Getpid())\n\n\t// NEED FIX: on ubuntu until 4.15 kernel it was possible to mount overlay\n\t// with the current workflow, since 4.18 we get an operation not permitted\n\tif !userNS {\n\t\tfor _, ns := range e.EngineConfig.OciConfig.Linux.Namespaces {\n\t\t\tif ns.Type == specs.UserNamespace {\n\t\t\t\tuserNS = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif userNS {\n\t\tif writableTmpfs || hasOverlayImage {\n\t\t\tsylog.Debugf(\"Overlay requested while in user namespace\")\n\t\t\t// Try overlay although it will only work if the image driver or the\n\t\t\t//  kernel support unprivileged overlay\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tif hasSIFOverlay {\n\t\t\tsylog.Debugf(\"Overlay partition found while in user namespace\")\n\t\t\t// Likewise try the overlay because of the partition\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tif !e.EngineConfig.File.EnableUnderlay {\n\t\t\tsylog.Debugf(\"Not attempting to use underlay with user namespace: disabled by configuration ('enable underlay = no')\")\n\t\t\treturn nil\n\t\t}\n\t\tif !writableImage {\n\t\t\tsylog.Debugf(\"Using underlay layer: user namespace requested\")\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.UnderlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\treturn nil\n\t}\n\n\t// starter was forced to load overlay module, now check if there\n\t// is an overlay entry in /proc/filesystems\n\tif has, _ := proc.HasFilesystem(\"overlay\"); has {\n\t\tsylog.Debugf(\"Overlay seems supported and allowed by kernel\")\n\t\tswitch e.EngineConfig.File.EnableOverlay {\n\t\tcase \"yes\", \"try\":\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\n\t\t\tif !writableImage || hasSIFOverlay {\n\t\t\t\tsylog.Debugf(\"Attempting to use overlayfs (enable overlay = %v)\\n\", e.EngineConfig.File.EnableOverlay)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.DefaultLayer)\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tif hasOverlayImage {\n\t\t\t\treturn fmt.Errorf(\"overlay images requires 'enable overlay = yes', but set to 'no' by administrator\")\n\t\t\t}\n\t\t\tif writableTmpfs {\n\t\t\t\treturn fmt.Errorf(\"--writable-tmpfs requires 'enable overlay = yes', but set to 'no' by administrator\")\n\t\t\t}\n\t\t\tsylog.Debugf(\"Could not use overlay, disabled by configuration ('enable overlay = no')\")\n\t\t}\n\t} else {\n\t\tif writableTmpfs {\n\t\t\treturn fmt.Errorf(\"--writable-tmpfs requires overlay kernel support: your kernel doesn't support it\")\n\t\t}\n\t\tif hasOverlayImage {\n\t\t\treturn fmt.Errorf(\"overlay images requires overlay kernel support: your kernel doesn't support it\")\n\t\t}\n\t}\n\n\t// if --writable wasn't set, use underlay if possible\n\tif !writableImage && e.EngineConfig.File.EnableUnderlay {\n\t\tsylog.Debugf(\"Attempting to use underlay (enable underlay = yes)\\n\")\n\t\te.EngineConfig.SetSessionLayer(apptainerConfig.UnderlayLayer)\n\t\treturn nil\n\t} else if writableImage {\n\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\treturn nil\n\t}\n\n\tsylog.Debugf(\"Not attempting to use overlay or underlay: both disabled by administrator\")\n\treturn nil\n}\n\nfunc (e *EngineOperations) loadImages(starterConfig *starter.Config) error {\n\timages := make([]image.Image, 0)\n\n\t// load rootfs image\n\twritable := e.EngineConfig.GetWritableImage()\n\timg, err := e.loadImage(e.EngineConfig.GetImage(), writable)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trootFs, err := img.GetRootFsPartition()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while getting root filesystem partition in %s: %s\", e.EngineConfig.GetImage(), err)\n\t}\n\n\tif writable && !img.Writable {\n\t\treturn fmt.Errorf(\"could not use %s for writing, you don't have write permissions\", img.Path)\n\t}\n\n\tif err := e.setSessionLayer(img); err != nil {\n\t\treturn err\n\t}\n\n\t// first image is always the root filesystem\n\timages = append(images, *img)\n\twritableOverlayPath := \"\"\n\n\tif err := starterConfig.KeepFileDescriptor(int(img.Fd)); err != nil {\n\t\treturn err\n\t}\n\n\t// sandbox are handled differently for security reasons\n\tif img.Type == image.SANDBOX {\n\t\tif img.Path == \"/\" {\n\t\t\treturn fmt.Errorf(\"/ as sandbox is not authorized\")\n\t\t}\n\n\t\t// C starter code will position current working directory\n\t\tstarterConfig.SetWorkingDirectoryFd(int(img.Fd))\n\n\t\tif e.EngineConfig.GetSessionLayer() == apptainerConfig.OverlayLayer &&\n\t\t\t(imageDriver == nil || imageDriver.Features()&image.OverlayFeature == 0) {\n\t\t\tif err := overlay.CheckLower(img.Path); overlay.IsIncompatible(err) {\n\t\t\t\tlayer := apptainerConfig.UnderlayLayer\n\t\t\t\tif !e.EngineConfig.File.EnableUnderlay {\n\t\t\t\t\tsylog.Warningf(\"Could not fallback to underlay, disabled by configuration ('enable underlay = no')\")\n\t\t\t\t\tlayer = apptainerConfig.DefaultLayer\n\t\t\t\t}\n\t\t\t\te.EngineConfig.SetSessionLayer(layer)\n\n\t\t\t\t// show a warning message if --writable-tmpfs or overlay images\n\t\t\t\t// are requested otherwise make it verbose to not annoy users\n\t\t\t\tif e.EngineConfig.GetWritableTmpfs() || len(e.EngineConfig.GetOverlayImage()) > 0 {\n\t\t\t\t\tsylog.Warningf(\"Fallback to %s layer: %s\", layer, err)\n\n\t\t\t\t\tif e.EngineConfig.GetWritableTmpfs() {\n\t\t\t\t\t\te.EngineConfig.SetWritableTmpfs(false)\n\t\t\t\t\t\tsylog.Warningf(\"--writable-tmpfs disabled due to sandbox filesystem incompatibility with overlay\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(e.EngineConfig.GetOverlayImage()) > 0 {\n\t\t\t\t\t\te.EngineConfig.SetOverlayImage(nil)\n\t\t\t\t\t\tsylog.Warningf(\"overlay image(s) not loaded due to sandbox filesystem incompatibility with overlay\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsylog.Verbosef(\"Fallback to %s layer: %s\", layer, err)\n\t\t\t\t}\n\t\t\t} else if err != nil {\n\t\t\t\treturn fmt.Errorf(\"while checking image compatibility with overlay: %s\", err)\n\t\t\t}\n\t\t}\n\t} else if img.Type == image.SIF {\n\t\t// query the ECL module, proceed if an ecl config file is found\n\t\tecl, err := syecl.LoadConfig(buildcfg.ECL_FILE)\n\t\tif err == nil {\n\t\t\tif err = ecl.ValidateConfig(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"while validating ECL configuration: %s\", err)\n\t\t\t}\n\n\t\t\t// Only try to load the global keyring here if the ECL is active.\n\t\t\t// Otherwise pass through an empty keyring rather than avoiding calling\n\t\t\t// the ECL functions as this keeps the logic for applying / ignoring ECL in a\n\t\t\t// single location.\n\t\t\tvar kr openpgp.KeyRing = openpgp.EntityList{}\n\t\t\tif ecl.Activated {\n\t\t\t\tkeyring := sypgp.NewHandle(buildcfg.APPTAINER_CONFDIR, sypgp.GlobalHandleOpt())\n\t\t\t\tkr, err = keyring.LoadPubKeyring()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"while obtaining keyring for ECL: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ok, err := ecl.ShouldRunFp(img.File, kr); err != nil {\n\t\t\t\treturn fmt.Errorf(\"while checking container image with ECL: %s\", err)\n\t\t\t} else if !ok {\n\t\t\t\treturn errors.New(\"image prohibited by ECL\")\n\t\t\t}\n\t\t}\n\n\t\t// look for potential overlay partition in SIF image\n\t\tif e.EngineConfig.GetSessionLayer() == apptainerConfig.OverlayLayer {\n\t\t\toverlays, err := img.GetOverlayPartitions()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"while getting overlay partitions in %s: %s\", img.Path, err)\n\t\t\t}\n\t\t\tfor _, p := range overlays {\n\t\t\t\tif img.Writable && p.Type == image.EXT3 {\n\t\t\t\t\twritableOverlayPath = img.Path\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// SIF image open for writing without writable\n\t\t// overlay partition, assuming that the root\n\t\t// filesystem is squashfs or encrypted squashfs\n\t\tif img.Writable && rootFs.Type != image.EXT3 && writableOverlayPath == \"\" {\n\t\t\treturn fmt.Errorf(\"no SIF writable overlay partition found in %s\", img.Path)\n\t\t}\n\t}\n\n\tswitch e.EngineConfig.GetSessionLayer() {\n\tcase apptainerConfig.OverlayLayer:\n\t\toverlayImages, err := e.loadOverlayImages(starterConfig, writableOverlayPath)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while loading overlay images: %s\", err)\n\t\t}\n\t\timages = append(images, overlayImages...)\n\tcase apptainerConfig.UnderlayLayer:\n\t\tif e.EngineConfig.GetWritableTmpfs() {\n\t\t\tsylog.Warningf(\"Disabling --writable-tmpfs as it can't be used in conjunction with underlay\")\n\t\t\te.EngineConfig.SetWritableTmpfs(false)\n\t\t}\n\t}\n\n\tbindImages, err := e.loadBindImages(starterConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while loading data bind images: %s\", err)\n\t}\n\timages = append(images, bindImages...)\n\n\te.EngineConfig.SetImageList(images)\n\n\treturn nil\n}\n\n// loadOverlayImages loads overlay images.\nfunc (e *EngineOperations) loadOverlayImages(starterConfig *starter.Config, writableOverlayPath string) ([]image.Image, error) {\n\timages := make([]image.Image, 0)\n\n\tfor _, overlayImg := range e.EngineConfig.GetOverlayImage() {\n\t\twritableOverlay := true\n\n\t\tsplitted := strings.SplitN(overlayImg, \":\", 2)\n\t\tif len(splitted) == 2 {\n\t\t\tif splitted[1] == \"ro\" {\n\t\t\t\twritableOverlay = false\n\t\t\t}\n\t\t}\n\n\t\timg, err := e.loadImage(splitted[0], writableOverlay)\n\t\tif err != nil {\n\t\t\tif !image.IsReadOnlyFilesytem(err) {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to open overlay image %s: %s\", splitted[0], err)\n\t\t\t}\n\t\t\t// let's proceed with readonly filesystem and set\n\t\t\t// writableOverlay to appropriate value\n\t\t\twritableOverlay = false\n\t\t}\n\t\timg.Usage = image.OverlayUsage\n\n\t\tif writableOverlay && img.Writable {\n\t\t\tif writableOverlayPath != \"\" {\n\t\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\t\"you can't specify more than one writable overlay, \"+\n\t\t\t\t\t\t\"%s contains a writable overlay, requires to use '--overlay %s:ro'\",\n\t\t\t\t\twritableOverlayPath, img.Path,\n\t\t\t\t)\n\t\t\t}\n\t\t\twritableOverlayPath = img.Path\n\t\t}\n\n\t\tif err := starterConfig.KeepFileDescriptor(int(img.Fd)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\timages = append(images, *img)\n\t}\n\n\tif e.EngineConfig.GetWritableTmpfs() && writableOverlayPath != \"\" {\n\t\treturn nil, fmt.Errorf(\"you can't specify --writable-tmpfs with another writable overlay image (%s)\", writableOverlayPath)\n\t}\n\n\treturn images, nil\n}\n\n// loadBindImages load data bind images.\nfunc (e *EngineOperations) loadBindImages(starterConfig *starter.Config) ([]image.Image, error) {\n\timages := make([]image.Image, 0)\n\n\tbinds := e.EngineConfig.GetBindPath()\n\n\tfor i := range binds {\n\t\tif binds[i].ImageSrc() == \"\" && binds[i].ID() == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\timagePath := binds[i].Source\n\n\t\tsylog.Debugf(\"Loading data image %s\", imagePath)\n\n\t\timg, err := e.loadImage(imagePath, !binds[i].Readonly())\n\t\tif err != nil && !image.IsReadOnlyFilesytem(err) {\n\t\t\treturn nil, fmt.Errorf(\"failed to load data image %s: %s\", imagePath, err)\n\t\t}\n\t\timg.Usage = image.DataUsage\n\n\t\tif err := starterConfig.KeepFileDescriptor(int(img.Fd)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\timages = append(images, *img)\n\t\tbinds[i].Source = img.Source\n\t}\n\n\treturn images, nil\n}\n\nfunc (e *EngineOperations) loadImage(path string, writable bool) (*image.Image, error) {\n\tconst delSuffix = \" (deleted)\"\n\n\timgObject, imgErr := image.Init(path, writable)\n\t// pass imgObject if not nil for overlay and read-only filesystem error.\n\t// Do not remove this line\n\tif imgObject == nil {\n\t\tif imgErr == nil {\n\t\t\timgErr = errors.New(\"nil imageObject\")\n\t\t}\n\t\treturn nil, imgErr\n\t}\n\n\t// get the real path from /proc/self/fd/X\n\timgTarget, err := mainthread.Readlink(imgObject.Source)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"while reading symlink %s: %s\", imgObject.Source, err)\n\t}\n\t// imgObject.Path is the resolved path provided to image.Init and imgTarget point\n\t// to the opened path, if they are not identical (for some obscure reasons) we use\n\t// the resolved path from /proc/self/fd/X\n\tif imgObject.Path != imgTarget {\n\t\t// With some kernel/filesystem combination the symlink target of /proc/self/fd/X\n\t\t// may return a path with the suffix \" (deleted)\" even if not deleted, we just\n\t\t// remove it because it won't impact ACL path check\n\t\tfinalTarget := strings.TrimSuffix(imgTarget, delSuffix)\n\t\tsylog.Debugf(\"Replacing image resolved path %s by %s\", imgObject.Path, finalTarget)\n\t\timgObject.Path = finalTarget\n\t}\n\n\tif len(e.EngineConfig.File.LimitContainerPaths) != 0 {\n\t\tif authorized, err := imgObject.AuthorizedPath(e.EngineConfig.File.LimitContainerPaths); err != nil {\n\t\t\treturn nil, err\n\t\t} else if !authorized {\n\t\t\treturn nil, fmt.Errorf(\"apptainer image is not in an allowed configured path\")\n\t\t}\n\t}\n\tif len(e.EngineConfig.File.LimitContainerGroups) != 0 {\n\t\tif authorized, err := imgObject.AuthorizedGroup(e.EngineConfig.File.LimitContainerGroups); err != nil {\n\t\t\treturn nil, err\n\t\t} else if !authorized {\n\t\t\treturn nil, fmt.Errorf(\"apptainer image is not owned by required group(s)\")\n\t\t}\n\t}\n\tif len(e.EngineConfig.File.LimitContainerOwners) != 0 {\n\t\tif authorized, err := imgObject.AuthorizedOwner(e.EngineConfig.File.LimitContainerOwners); err != nil {\n\t\t\treturn nil, err\n\t\t} else if !authorized {\n\t\t\treturn nil, fmt.Errorf(\"apptainer image is not owned by required user(s)\")\n\t\t}\n\t}\n\n\tswitch imgObject.Type {\n\t// Bare SquashFS\n\tcase image.SQUASHFS:\n\t\tif !e.EngineConfig.File.AllowContainerSquashfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running squashFS containers\")\n\t\t}\n\t// Bare EXT3\n\tcase image.EXT3:\n\t\tif !e.EngineConfig.File.AllowContainerExtfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running extFS containers\")\n\t\t}\n\t// Bare sandbox directory\n\tcase image.SANDBOX:\n\t\tif !e.EngineConfig.File.AllowContainerDir {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running sandbox containers\")\n\t\t}\n\t// SIF\n\tcase image.SIF:\n\t\t// Check if SIF contains an encrypted rootfs partition.\n\t\t// We don't support encryption for other partitions at present.\n\t\tencrypted, err := imgObject.HasEncryptedRootFs()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"while checking for encrypted root FS: %v\", err)\n\t\t}\n\t\t// SIF with encryption\n\t\tif encrypted && !e.EngineConfig.File.AllowContainerEncrypted {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running encrypted SIF containers\")\n\t\t}\n\t\t// SIF without encryption - regardless of rootfs filesystem type\n\t\tif !encrypted && !e.EngineConfig.File.AllowContainerSIF {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running unencrypted SIF containers\")\n\t\t}\n\t// We shouldn't be able to run anything else, but make sure we don't!\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown image format %d\", imgObject.Type)\n\t}\n\n\treturn imgObject, imgErr\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2021, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage apptainerconf\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/apptainer/apptainer/pkg/sylog\"\n)\n\n// currentConfig corresponds to the current configuration, may\n// be useful for packages requiring to share the same configuration.\nvar currentConfig *File\n\n// SetCurrentConfig sets the provided configuration as the current\n// configuration.\nfunc SetCurrentConfig(config *File) {\n\tcurrentConfig = config\n}\n\n// GetCurrentConfig returns the current configuration if any.\nfunc GetCurrentConfig() *File {\n\treturn currentConfig\n}\n\n// GetBuildConfig returns the configuration to be used for building containers\nfunc ApplyBuildConfig(config *File) {\n\t// Remove default binds when doing builds\n\tconfig.BindPath = nil\n\tconfig.ConfigResolvConf = false\n\tconfig.MountHome = false\n\tconfig.MountDevPts = false\n}\n\n// SetBinaryPath sets the value of the binary path, substituting the\n// user's $PATH plus \":\" for \"$PATH:\" in BinaryPath.  If nonSuid is true,\n// then SuidBinaryPath gets the same value as BinaryPath, otherwise\n// SuidBinaryPath gets the value of the binary path with with \"$PATH:\"\n// replaced with nothing.  libexecdir + \"apptainer/bin\" is always included\n// either at the beginning of $PATH if present, or the very beginning.\nfunc SetBinaryPath(libexecDir string, nonSuid bool) {\n\tif currentConfig == nil {\n\t\tsylog.Fatalf(\"apptainerconf.SetCurrentConfig() must be called before SetBinaryPath()\")\n\t}\n\tuserPath := os.Getenv(\"PATH\")\n\tif userPath != \"\" {\n\t\tuserPath += \":\"\n\t}\n\tinternalPath := filepath.Join(libexecDir, \"apptainer/bin\") + \":\"\n\tif !strings.Contains(currentConfig.BinaryPath, \"$PATH:\") {\n\t\t// If there's no \"$PATH:\" in binary path, add internalPath\n\t\t//  beginning of search path.  Otherwise put it at the\n\t\t//  beginning of where \"$PATH:\" is, below.\n\t\tcurrentConfig.BinaryPath = internalPath + currentConfig.BinaryPath\n\t}\n\tbinaryPath := currentConfig.BinaryPath\n\tcurrentConfig.BinaryPath = strings.Replace(binaryPath, \"$PATH:\", internalPath+userPath, 1)\n\tsylog.Debugf(\"Setting binary path to %v\", currentConfig.BinaryPath)\n\tif nonSuid {\n\t\tsylog.Debugf(\"Using that path for all binaries\")\n\t\tcurrentConfig.SuidBinaryPath = currentConfig.BinaryPath\n\t} else {\n\t\tcurrentConfig.SuidBinaryPath = strings.Replace(binaryPath, \"$PATH:\", internalPath, 1)\n\t\tsylog.Debugf(\"Setting suid binary path to %v\", currentConfig.SuidBinaryPath)\n\t}\n}\n\n// File describes the apptainer.conf file options\ntype File struct {\n\tAllowSetuid             bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow setuid\"`\n\tAllowPidNs              bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow pid ns\"`\n\tConfigPasswd            bool     `default:\"yes\" authorized:\"yes,no\" directive:\"config passwd\"`\n\tConfigGroup             bool     `default:\"yes\" authorized:\"yes,no\" directive:\"config group\"`\n\tConfigResolvConf        bool     `default:\"yes\" authorized:\"yes,no\" directive:\"config resolv_conf\"`\n\tMountProc               bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount proc\"`\n\tMountSys                bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount sys\"`\n\tMountDevPts             bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount devpts\"`\n\tMountHome               bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount home\"`\n\tMountTmp                bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount tmp\"`\n\tMountHostfs             bool     `default:\"no\" authorized:\"yes,no\" directive:\"mount hostfs\"`\n\tUserBindControl         bool     `default:\"yes\" authorized:\"yes,no\" directive:\"user bind control\"`\n\tEnableFusemount         bool     `default:\"yes\" authorized:\"yes,no\" directive:\"enable fusemount\"`\n\tEnableUnderlay          bool     `default:\"yes\" authorized:\"yes,no\" directive:\"enable underlay\"`\n\tMountSlave              bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount slave\"`\n\tAllowContainerSIF       bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container sif\"`\n\tAllowContainerEncrypted bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container encrypted\"`\n\tAllowContainerSquashfs  bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container squashfs\"`\n\tAllowContainerExtfs     bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container extfs\"`\n\tAllowContainerDir       bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container dir\"`\n\tAlwaysUseNv             bool     `default:\"no\" authorized:\"yes,no\" directive:\"always use nv\"`\n\tUseNvCCLI               bool     `default:\"no\" authorized:\"yes,no\" directive:\"use nvidia-container-cli\"`\n\tAlwaysUseRocm           bool     `default:\"no\" authorized:\"yes,no\" directive:\"always use rocm\"`\n\tSharedLoopDevices       bool     `default:\"no\" authorized:\"yes,no\" directive:\"shared loop devices\"`\n\tMaxLoopDevices          uint     `default:\"256\" directive:\"max loop devices\"`\n\tSessiondirMaxSize       uint     `default:\"16\" directive:\"sessiondir max size\"`\n\tMountDev                string   `default:\"yes\" authorized:\"yes,no,minimal\" directive:\"mount dev\"`\n\tEnableOverlay           string   `default:\"try\" authorized:\"yes,no,try,driver\" directive:\"enable overlay\"`\n\tBindPath                []string `default:\"/etc/localtime,/etc/hosts\" directive:\"bind path\"`\n\tLimitContainerOwners    []string `directive:\"limit container owners\"`\n\tLimitContainerGroups    []string `directive:\"limit container groups\"`\n\tLimitContainerPaths     []string `directive:\"limit container paths\"`\n\tAllowNetUsers           []string `directive:\"allow net users\"`\n\tAllowNetGroups          []string `directive:\"allow net groups\"`\n\tAllowNetNetworks        []string `directive:\"allow net networks\"`\n\tRootDefaultCapabilities string   `default:\"full\" authorized:\"full,file,no\" directive:\"root default capabilities\"`\n\tMemoryFSType            string   `default:\"tmpfs\" authorized:\"tmpfs,ramfs\" directive:\"memory fs type\"`\n\tCniConfPath             string   `directive:\"cni configuration path\"`\n\tCniPluginPath           string   `directive:\"cni plugin path\"`\n\tBinaryPath              string   `default:\"$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" directive:\"binary path\"`\n\t// SuidBinaryPath is hidden; it is not referenced below, and overwritten\n\tSuidBinaryPath      string `directive:\"suidbinary path\"`\n\tMksquashfsProcs     uint   `default:\"0\" directive:\"mksquashfs procs\"`\n\tMksquashfsMem       string `directive:\"mksquashfs mem\"`\n\tImageDriver         string `directive:\"image driver\"`\n\tDownloadConcurrency uint   `default:\"3\" directive:\"download concurrency\"`\n\tDownloadPartSize    uint   `default:\"5242880\" directive:\"download part size\"`\n\tDownloadBufferSize  uint   `default:\"32768\" directive:\"download buffer size\"`\n\tSystemdCgroups      bool   `default:\"yes\" authorized:\"yes,no\" directive:\"systemd cgroups\"`\n}\n\nconst TemplateAsset = `# APPTAINER.CONF\n# This is the global configuration file for Apptainer. This file controls\n# what the container is allowed to do on a particular host, and as a result\n# this file must be owned by root.\n\n# ALLOW SETUID: [BOOL]\n# DEFAULT: yes\n# Should we allow users to utilize the setuid program flow within Apptainer?\n# note1: This is the default mode, and to utilize all features, this option\n# must be enabled.  For example, without this option loop mounts of image \n# files will not work; only sandbox image directories, which do not need loop\n# mounts, will work (subject to note 2).\n# note2: If this option is disabled, it will rely on unprivileged user\n# namespaces which have not been integrated equally between different Linux\n# distributions.\nallow setuid = {{ if eq .AllowSetuid true }}yes{{ else }}no{{ end }}\n\n# MAX LOOP DEVICES: [INT]\n# DEFAULT: 256\n# Set the maximum number of loop devices that Apptainer should ever attempt\n# to utilize.\nmax loop devices = {{ .MaxLoopDevices }}\n\n# ALLOW PID NS: [BOOL]\n# DEFAULT: yes\n# Should we allow users to request the PID namespace? Note that for some HPC\n# resources, the PID namespace may confuse the resource manager and break how\n# some MPI implementations utilize shared memory. (note, on some older\n# systems, the PID namespace is always used)\nallow pid ns = {{ if eq .AllowPidNs true }}yes{{ else }}no{{ end }}\n\n# CONFIG PASSWD: [BOOL]\n# DEFAULT: yes\n# If /etc/passwd exists within the container, this will automatically append\n# an entry for the calling user.\nconfig passwd = {{ if eq .ConfigPasswd true }}yes{{ else }}no{{ end }}\n\n# CONFIG GROUP: [BOOL]\n# DEFAULT: yes\n# If /etc/group exists within the container, this will automatically append\n# group entries for the calling user.\nconfig group = {{ if eq .ConfigGroup true }}yes{{ else }}no{{ end }}\n\n# CONFIG RESOLV_CONF: [BOOL]\n# DEFAULT: yes\n# If there is a bind point within the container, use the host's\n# /etc/resolv.conf.\nconfig resolv_conf = {{ if eq .ConfigResolvConf true }}yes{{ else }}no{{ end }}\n\n# MOUNT PROC: [BOOL]\n# DEFAULT: yes\n# Should we automatically bind mount /proc within the container?\nmount proc = {{ if eq .MountProc true }}yes{{ else }}no{{ end }}\n\n# MOUNT SYS: [BOOL]\n# DEFAULT: yes\n# Should we automatically bind mount /sys within the container?\nmount sys = {{ if eq .MountSys true }}yes{{ else }}no{{ end }}\n\n# MOUNT DEV: [yes/no/minimal]\n# DEFAULT: yes\n# Should we automatically bind mount /dev within the container? If 'minimal'\n# is chosen, then only 'null', 'zero', 'random', 'urandom', and 'shm' will\n# be included (the same effect as the --contain options)\nmount dev = {{ .MountDev }}\n\n# MOUNT DEVPTS: [BOOL]\n# DEFAULT: yes\n# Should we mount a new instance of devpts if there is a 'minimal'\n# /dev, or -C is passed?  Note, this requires that your kernel was\n# configured with CONFIG_DEVPTS_MULTIPLE_INSTANCES=y, or that you're\n# running kernel 4.7 or newer.\nmount devpts = {{ if eq .MountDevPts true }}yes{{ else }}no{{ end }}\n\n# MOUNT HOME: [BOOL]\n# DEFAULT: yes\n# Should we automatically determine the calling user's home directory and\n# attempt to mount it's base path into the container? If the --contain option\n# is used, the home directory will be created within the session directory or\n# can be overridden with the APPTAINER_HOME or APPTAINER_WORKDIR\n# environment variables (or their corresponding command line options).\nmount home = {{ if eq .MountHome true }}yes{{ else }}no{{ end }}\n\n# MOUNT TMP: [BOOL]\n# DEFAULT: yes\n# Should we automatically bind mount /tmp and /var/tmp into the container? If\n# the --contain option is used, both tmp locations will be created in the\n# session directory or can be specified via the  APPTAINER_WORKDIR\n# environment variable (or the --workingdir command line option).\nmount tmp = {{ if eq .MountTmp true }}yes{{ else }}no{{ end }}\n\n# MOUNT HOSTFS: [BOOL]\n# DEFAULT: no\n# Probe for all mounted file systems that are mounted on the host, and bind\n# those into the container?\nmount hostfs = {{ if eq .MountHostfs true }}yes{{ else }}no{{ end }}\n\n# BIND PATH: [STRING]\n# DEFAULT: Undefined\n# Define a list of files/directories that should be made available from within\n# the container. The file or directory must exist within the container on\n# which to attach to. you can specify a different source and destination\n# path (respectively) with a colon; otherwise source and dest are the same.\n# NOTE: these are ignored if apptainer is invoked with --contain except\n# for /etc/hosts and /etc/localtime. When invoked with --contain and --net,\n# /etc/hosts would contain a default generated content for localhost resolution.\n#bind path = /etc/apptainer/default-nsswitch.conf:/etc/nsswitch.conf\n#bind path = /opt\n#bind path = /scratch\n{{ range $path := .BindPath }}\n{{- if ne $path \"\" -}}\nbind path = {{$path}}\n{{ end -}}\n{{ end }}\n# USER BIND CONTROL: [BOOL]\n# DEFAULT: yes\n# Allow users to influence and/or define bind points at runtime? This will allow\n# users to specify bind points, scratch and tmp locations. (note: User bind\n# control is only allowed if the host also supports PR_SET_NO_NEW_PRIVS)\nuser bind control = {{ if eq .UserBindControl true }}yes{{ else }}no{{ end }}\n\n# ENABLE FUSEMOUNT: [BOOL]\n# DEFAULT: yes\n# Allow users to mount fuse filesystems inside containers with the --fusemount\n# command line option.\nenable fusemount = {{ if eq .EnableFusemount true }}yes{{ else }}no{{ end }}\n\n# ENABLE OVERLAY: [yes/no/try/driver]\n# DEFAULT: try\n# Enabling this option will make it possible to specify bind paths to locations\n# that do not currently exist within the container.  If 'try' is chosen,\n# overlayfs will be tried but if it is unavailable it will be silently ignored.\n# If 'driver' is chosen, overlayfs is handled by the image driver.\nenable overlay = {{ .EnableOverlay }}\n\n# ENABLE UNDERLAY: [yes/no]\n# DEFAULT: yes\n# Enabling this option will make it possible to specify bind paths to locations\n# that do not currently exist within the container even if overlay is not\n# working.  If overlay is available, it will be tried first.\nenable underlay = {{ if eq .EnableUnderlay true }}yes{{ else }}no{{ end }}\n\n# MOUNT SLAVE: [BOOL]\n# DEFAULT: yes\n# Should we automatically propagate file-system changes from the host?\n# This should be set to 'yes' when autofs mounts in the system should\n# show up in the container.\nmount slave = {{ if eq .MountSlave true }}yes{{ else }}no{{ end }}\n\n# SESSIONDIR MAXSIZE: [STRING]\n# DEFAULT: 16\n# This specifies how large the default sessiondir should be (in MB). It will\n# affect users who use the \"--contain\" options and don't also specify a\n# location to do default read/writes to (e.g. \"--workdir\" or \"--home\") and\n# it will also affect users of \"--writable-tmpfs\".\nsessiondir max size = {{ .SessiondirMaxSize }}\n\n# LIMIT CONTAINER OWNERS: [STRING]\n# DEFAULT: NULL\n# Only allow containers to be used that are owned by a given user. If this\n# configuration is undefined (commented or set to NULL), all containers are\n# allowed to be used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#limit container owners = gmk, apptainer, nobody\n{{ range $index, $owner := .LimitContainerOwners }}\n{{- if eq $index 0 }}limit container owners = {{ else }}, {{ end }}{{$owner}}\n{{- end }}\n\n# LIMIT CONTAINER GROUPS: [STRING]\n# DEFAULT: NULL\n# Only allow containers to be used that are owned by a given group. If this\n# configuration is undefined (commented or set to NULL), all containers are\n# allowed to be used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#limit container groups = group1, apptainer, nobody\n{{ range $index, $group := .LimitContainerGroups }}\n{{- if eq $index 0 }}limit container groups = {{ else }}, {{ end }}{{$group}}\n{{- end }}\n\n# LIMIT CONTAINER PATHS: [STRING]\n# DEFAULT: NULL\n# Only allow containers to be used that are located within an allowed path\n# prefix. If this configuration is undefined (commented or set to NULL),\n# containers will be allowed to run from anywhere on the file system. This\n# feature only applies when Apptainer is running in SUID mode and the user is\n# non-root.\n#limit container paths = /scratch, /tmp, /global\n{{ range $index, $path := .LimitContainerPaths }}\n{{- if eq $index 0 }}limit container paths = {{ else }}, {{ end }}{{$path}}\n{{- end }}\n\n# ALLOW CONTAINER ${TYPE}: [BOOL]\n# DEFAULT: yes\n# This feature limits what kind of containers that Apptainer will allow\n# users to use (note this does not apply for root).\n#\n# Allow use of unencrypted SIF containers\nallow container sif = {{ if eq .AllowContainerSIF true}}yes{{ else }}no{{ end }}\n#\n# Allow use of encrypted SIF containers\nallow container encrypted = {{ if eq .AllowContainerEncrypted true }}yes{{ else }}no{{ end }}\n#\n# Allow use of non-SIF image formats\nallow container squashfs = {{ if eq .AllowContainerSquashfs true }}yes{{ else }}no{{ end }}\nallow container extfs = {{ if eq .AllowContainerExtfs true }}yes{{ else }}no{{ end }}\nallow container dir = {{ if eq .AllowContainerDir true }}yes{{ else }}no{{ end }}\n\n# ALLOW NET USERS: [STRING]\n# DEFAULT: NULL\n# Allow specified root administered CNI network configurations to be used by the\n# specified list of users. By default only root may use CNI configuration,\n# except in the case of a fakeroot execution where only 40_fakeroot.conflist\n# is used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#allow net users = gmk, apptainer\n{{ range $index, $owner := .AllowNetUsers }}\n{{- if eq $index 0 }}allow net users = {{ else }}, {{ end }}{{$owner}}\n{{- end }}\n\n# ALLOW NET GROUPS: [STRING]\n# DEFAULT: NULL\n# Allow specified root administered CNI network configurations to be used by the\n# specified list of users. By default only root may use CNI configuration,\n# except in the case of a fakeroot execution where only 40_fakeroot.conflist\n# is used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#allow net groups = group1, apptainer\n{{ range $index, $group := .AllowNetGroups }}\n{{- if eq $index 0 }}allow net groups = {{ else }}, {{ end }}{{$group}}\n{{- end }}\n\n# ALLOW NET NETWORKS: [STRING]\n# DEFAULT: NULL\n# Specify the names of CNI network configurations that may be used by users and\n# groups listed in the allow net users / allow net groups directives. Thus feature\n# only applies when Apptainer is running in SUID mode and the user is non-root.\n#allow net networks = bridge\n{{ range $index, $group := .AllowNetNetworks }}\n{{- if eq $index 0 }}allow net networks = {{ else }}, {{ end }}{{$group}}\n{{- end }}\n\n# ALWAYS USE NV ${TYPE}: [BOOL]\n# DEFAULT: no\n# This feature allows an administrator to determine that every action command\n# should be executed implicitly with the --nv option (useful for GPU only \n# environments). \nalways use nv = {{ if eq .AlwaysUseNv true }}yes{{ else }}no{{ end }}\n\n# USE NVIDIA-NVIDIA-CONTAINER-CLI ${TYPE}: [BOOL]\n# DEFAULT: no\n# EXPERIMENTAL\n# If set to yes, Apptainer will attempt to use nvidia-container-cli to setup\n# GPUs within a container when the --nv flag is enabled.\n# If no (default), the legacy binding of entries in nvbliblist.conf will be performed.\nuse nvidia-container-cli = {{ if eq .UseNvCCLI true }}yes{{ else }}no{{ end }}\n\n# ALWAYS USE ROCM ${TYPE}: [BOOL]\n# DEFAULT: no\n# This feature allows an administrator to determine that every action command\n# should be executed implicitly with the --rocm option (useful for GPU only\n# environments).\nalways use rocm = {{ if eq .AlwaysUseRocm true }}yes{{ else }}no{{ end }}\n\n# ROOT DEFAULT CAPABILITIES: [full/file/no]\n# DEFAULT: full\n# Define default root capability set kept during runtime\n# - full: keep all capabilities (same as --keep-privs)\n# - file: keep capabilities configured in ${prefix}/etc/apptainer/capabilities/user.root\n# - no: no capabilities (same as --no-privs)\nroot default capabilities = {{ .RootDefaultCapabilities }}\n\n# MEMORY FS TYPE: [tmpfs/ramfs]\n# DEFAULT: tmpfs\n# This feature allow to choose temporary filesystem type used by Apptainer.\n# Cray CLE 5 and 6 up to CLE 6.0.UP05 there is an issue (kernel panic) when Apptainer\n# use tmpfs, so on affected version it's recommended to set this value to ramfs to avoid\n# kernel panic\nmemory fs type = {{ .MemoryFSType }}\n\n# CNI CONFIGURATION PATH: [STRING]\n# DEFAULT: Undefined\n# Defines path where CNI configuration files are stored\n#cni configuration path =\n{{ if ne .CniConfPath \"\" }}cni configuration path = {{ .CniConfPath }}{{ end }}\n# CNI PLUGIN PATH: [STRING]\n# DEFAULT: Undefined\n# Defines path where CNI executable plugins are stored\n#cni plugin path =\n{{ if ne .CniPluginPath \"\" }}cni plugin path = {{ .CniPluginPath }}{{ end }}\n\n# BINARY PATH: [STRING]\n# DEFAULT: $PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n# Colon-separated list of directories to search for many binaries.  May include\n# \"$PATH:\", which will be replaced by the user's PATH when not running a binary\n# that may be run with elevated privileges from the setuid program flow.  The\n# internal bin ${prefix}/libexec/apptainer/bin is always included, either at the\n# beginning of \"$PATH:\" if it is present or at the very beginning if \"$PATH:\" is\n# not present.\n# binary path = \n\n# MKSQUASHFS PROCS: [UINT]\n# DEFAULT: 0 (All CPUs)\n# This allows the administrator to specify the number of CPUs for mksquashfs \n# to use when building an image.  The fewer processors the longer it takes.\n# To enable it to use all available CPU's set this to 0.\n# mksquashfs procs = 0\nmksquashfs procs = {{ .MksquashfsProcs }}\n\n# MKSQUASHFS MEM: [STRING]\n# DEFAULT: Unlimited\n# This allows the administrator to set the maximum amount of memory for mkswapfs\n# to use when building an image.  e.g. 1G for 1gb or 500M for 500mb. Restricting memory\n# can have a major impact on the time it takes mksquashfs to create the image.\n# NOTE: This fuctionality did not exist in squashfs-tools prior to version 4.3\n# If using an earlier version you should not set this.\n# mksquashfs mem = 1G\n{{ if ne .MksquashfsMem \"\" }}mksquashfs mem = {{ .MksquashfsMem }}{{ end }}\n\n# SHARED LOOP DEVICES: [BOOL]\n# DEFAULT: no\n# Allow to share same images associated with loop devices to minimize loop\n# usage and optimize kernel cache (useful for MPI)\nshared loop devices = {{ if eq .SharedLoopDevices true }}yes{{ else }}no{{ end }}\n\n# IMAGE DRIVER: [STRING]\n# DEFAULT: Undefined\n# This option specifies the name of an image driver provided by a plugin that\n# will be used to handle image mounts. If the 'enable overlay' option is set\n# to 'driver' the driver name specified here will also be used to handle\n# overlay mounts.\n# If the driver name specified has not been registered via a plugin installation\n# the run-time will abort.\nimage driver = {{ .ImageDriver }}\n\n# DOWNLOAD CONCURRENCY: [UINT]\n# DEFAULT: 3\n# This option specifies how many concurrent streams when downloading (pulling)\n# an image from cloud library.\ndownload concurrency = {{ .DownloadConcurrency }}\n\n# DOWNLOAD PART SIZE: [UINT]\n# DEFAULT: 5242880\n# This option specifies the size of each part when concurrent downloads are\n# enabled.\ndownload part size = {{ .DownloadPartSize }}\n\n# DOWNLOAD BUFFER SIZE: [UINT]\n# DEFAULT: 32768\n# This option specifies the transfer buffer size when concurrent downloads\n# are enabled.\ndownload buffer size = {{ .DownloadBufferSize }}\n\n# SYSTEMD CGROUPS: [BOOL]\n# DEFAULT: yes\n# Whether to use systemd to manage container cgroups. Required for rootless cgroups\n# functionality. 'no' will manage cgroups directly via cgroupfs.\nsystemd cgroups = {{ if eq .SystemdCgroups true }}yes{{ else }}no{{ end }}\n`\n", "#!/bin/sh\n# Copyright (c) Contributors to the Apptainer project, established as\n#   Apptainer a Series of LF Projects LLC.\n#   For website terms of use, trademark policy, privacy policy and other\n#   project policies see https://lfprojects.org/policies\n\nset -e\n\nusage() {\n\tcat <<-EOT\n\tE: Invalid usage. Abort.\n\n\tUsage:\n\n\t    $0 {github_repository} {github_branch} [github_pr_url]\n\n\tIf a {github_pr_url} is provided, it's used to obtain additional\n\tinformation like the target branch and the labels. Otherwise it\n\tis assumed that the code is already merged and that only the\n\tmost recent commit should be examined.\n\tEOT\n}\n\n# Give the possibility to force E2E run\nif ! test -z \"${FORCE_E2E}\" ; then\n    echo \"FORCE_E2E set, forcing e2e tests.\"\n    exit 0\nfi\n\n# Skip e2e by default\nrequire_e2e=false\n\nGITHUB_REPOSITORY=$1\nGITHUB_BRANCH=$2\nGITHUB_PR_NUMBER=$3\n\nif test -z \"${GITHUB_REPOSITORY}\" ; then\n\tusage \"$0\"\n\texit 2\nelif test -z \"${GITHUB_BRANCH}\" ; then\n\tusage \"$0\"\n\texit 2\nfi\n\nif test -z \"${GITHUB_PR_NUMBER}\" ; then\n\techo \"Running directly against branch ${GITHUB_BRANCH}\"\n\tTARGET_BRANCH=\"${GITHUB_BRANCH}\"\n\tBASE_COMMIT=\"HEAD~\"\n\t# Assume E2E is required for all runs against a branch; below we\n\t# constrain this to specific branches.\n\trequire_e2e=true\nelse\n\tpull_info_file=$(mktemp)\n\ttrap \"rm -f ${pull_info_file}\" EXIT\n\n\tcurl -s \"https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${GITHUB_PR_NUMBER}\" > \"${pull_info_file}\"\n\n\t# Keep the matching lines instead of simply looking at the exit\n\t# code for debugging purposes\n\tE2E_LABELS=$(jq -r '.labels[].name' < \"${pull_info_file}\" | grep --line-regexp --fixed-strings ci:e2e || true)\n\n\tif test -n \"${E2E_LABELS}\" ; then\n\t\techo \"Honoring request to run E2E tests from pull request labels\"\n\t\texit 0\n\tfi\n\n\tTARGET_BRANCH=$(jq -r .base.ref < \"${pull_info_file}\")\n\tBASE_COMMIT=\"origin/${TARGET_BRANCH}\"\nfi\n\ncase \"${TARGET_BRANCH}\" in\n\tmaster|main)\n\t\tif git --no-pager diff --name-only HEAD \"${BASE_COMMIT}\" |\n\t\t\tgrep -q -E -f .ci/e2e_triggers\n\t\tthen\n\t\t\t# There are changes in critical components, require e2e\n\t\t\trequire_e2e=true\n\t\tfi\n\t\t;;\n\n\trelease-*)\n\t\t# Require E2E for all changes going into a release branch\n\t\trequire_e2e=true\n\t\t;;\n\n\t*)\n\t\t# The branch is not master or release, skip e2e\n\t\trequire_e2e=false\n\t\t;;\nesac\n\nif ${require_e2e} ; then\n\techo \"Critical changes detected.\"\n\texit 0\nelse\n\techo \"No critical changes detected.\"\n\texit 1\nfi\n"], "fixing_code": ["// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage actions\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/exec\"\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/require\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs\"\n\t\"github.com/pkg/errors\"\n)\n\ntype actionTests struct {\n\tenv e2e.TestEnv\n}\n\n// run tests min fuctionality for singularity symlink using actionRun\nfunc (c actionTests) singularityLink(t *testing.T) {\n\tsaveCmdPath := c.env.CmdPath\n\ti := strings.LastIndex(saveCmdPath, \"apptainer\")\n\tc.env.CmdPath = saveCmdPath[:i] + \"singularity\"\n\n\tc.actionRun(t)\n\n\tc.env.CmdPath = saveCmdPath\n}\n\n// run tests min fuctionality for apptainer run\nfunc (c actionTests) actionRun(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname string\n\t\targv []string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname: \"NoCommand\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targv: []string{c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targv: []string{c.env.ImagePath, \"false\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestAppGood\",\n\t\t\targv: []string{\"--app\", \"testapp\", c.env.ImagePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestAppBad\",\n\t\t\targv: []string{\"--app\", \"fakeapp\", c.env.ImagePath},\n\t\t\texit: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"run\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// exec tests min fuctionality for apptainer exec\nfunc (c actionTests) actionExec(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tuser := e2e.CurrentUser(t)\n\n\t// Create a temp testfile\n\ttestdata, err := fs.MakeTmpDir(c.env.TestDir, \"testdata\", 0o755)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(testdata)\n\n\ttestdataTmp := filepath.Join(testdata, \"tmp\")\n\tif err := os.Mkdir(testdataTmp, 0o755); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a temp testfile\n\ttmpfile, err := fs.MakeTmpFile(testdataTmp, \"testApptainerExec.\", 0o644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttmpfile.Close()\n\n\tbasename := filepath.Base(tmpfile.Name())\n\ttmpfilePath := filepath.Join(\"/tmp\", basename)\n\tvartmpfilePath := filepath.Join(\"/var/tmp\", basename)\n\thomePath := filepath.Join(\"/home\", basename)\n\n\ttests := []struct {\n\t\tname string\n\t\targv []string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname: \"NoCommand\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"True\",\n\t\t\targv: []string{c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"TrueAbsPAth\",\n\t\t\targv: []string{c.env.ImagePath, \"/bin/true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"False\",\n\t\t\targv: []string{c.env.ImagePath, \"false\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"FalseAbsPath\",\n\t\t\targv: []string{c.env.ImagePath, \"/bin/false\"},\n\t\t\texit: 1,\n\t\t},\n\t\t// Scif apps tests\n\t\t{\n\t\t\tname: \"ScifTestAppGood\",\n\t\t\targv: []string{\"--app\", \"testapp\", c.env.ImagePath, \"testapp.sh\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestAppBad\",\n\t\t\targv: []string{\"--app\", \"fakeapp\", c.env.ImagePath, \"testapp.sh\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/apps\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/data\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/apps/foo\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/apps/bar\"},\n\t\t\texit: 0,\n\t\t},\n\t\t// blocked by issue [scif-apps] Files created at install step fall into an unexpected path #2404\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-f\", \"/scif/apps/foo/filefoo.exec\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-f\", \"/scif/apps/bar/filebar.exec\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/data/foo/output\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScifTestfolderOrg\",\n\t\t\targv: []string{c.env.ImagePath, \"test\", \"-d\", \"/scif/data/foo/input\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ContainOnly\",\n\t\t\targv: []string{\"--contain\", c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirOnly\",\n\t\t\targv: []string{\"--workdir\", testdata, c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirContain\",\n\t\t\targv: []string{\"--workdir\", testdata, \"--contain\", c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"PwdGood\",\n\t\t\targv: []string{\"--pwd\", \"/etc\", c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Home\",\n\t\t\targv: []string{\"--home\", testdata, c.env.ImagePath, \"test\", \"-f\", tmpfile.Name()},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"HomePath\",\n\t\t\targv: []string{\"--home\", testdataTmp + \":/home\", c.env.ImagePath, \"test\", \"-f\", homePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"HomeTmp\",\n\t\t\targv: []string{\"--home\", \"/tmp\", c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"HomeTmpExplicit\",\n\t\t\targv: []string{\"--home\", \"/tmp:/home\", c.env.ImagePath, \"true\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"UserBindTmp\",\n\t\t\targv: []string{\"--bind\", testdataTmp + \":/tmp\", c.env.ImagePath, \"test\", \"-f\", tmpfilePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"UserBindVarTmp\",\n\t\t\targv: []string{\"--bind\", testdataTmp + \":/var/tmp\", c.env.ImagePath, \"test\", \"-f\", vartmpfilePath},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NoHome\",\n\t\t\targv: []string{\"--no-home\", c.env.ImagePath, \"ls\", \"-ld\", user.Dir},\n\t\t\texit: 1,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithDir(\"/tmp\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// Shell interaction tests\nfunc (c actionTests) actionShell(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\thostname, err := os.Hostname()\n\terr = errors.Wrap(err, \"getting hostname\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not get hostname: %+v\", err)\n\t}\n\n\ttests := []struct {\n\t\tname       string\n\t\targv       []string\n\t\tconsoleOps []e2e.ApptainerConsoleOp\n\t\texit       int\n\t}{\n\t\t{\n\t\t\tname: \"ShellExit\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\tconsoleOps: []e2e.ApptainerConsoleOp{\n\t\t\t\t// \"cd /\" to work around issue where a long\n\t\t\t\t// working directory name causes the test\n\t\t\t\t// to fail because the \"Apptainer\" that\n\t\t\t\t// we are looking for is chopped from the\n\t\t\t\t// front.\n\t\t\t\t// TODO(mem): This test was added back in 491a71716013654acb2276e4b37c2e015d2dfe09\n\t\t\t\te2e.ConsoleSendLine(\"cd /\"),\n\t\t\t\te2e.ConsoleExpect(\"Singularity\"),\n\t\t\t\te2e.ConsoleSendLine(\"exit\"),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ShellHostname\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\tconsoleOps: []e2e.ApptainerConsoleOp{\n\t\t\t\te2e.ConsoleSendLine(\"hostname\"),\n\t\t\t\te2e.ConsoleExpect(hostname),\n\t\t\t\te2e.ConsoleSendLine(\"exit\"),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ShellBadCommand\",\n\t\t\targv: []string{c.env.ImagePath},\n\t\t\tconsoleOps: []e2e.ApptainerConsoleOp{\n\t\t\t\te2e.ConsoleSendLine(\"_a_fake_command\"),\n\t\t\t\te2e.ConsoleSendLine(\"exit\"),\n\t\t\t},\n\t\t\texit: 127,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"shell\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ConsoleRun(tt.consoleOps...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// STDPipe tests pipe stdin/stdout to apptainer actions cmd\nfunc (c actionTests) STDPipe(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tstdinTests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\tinput   string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"TrueSTDIN\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.ImagePath, \"grep\", \"hi\"},\n\t\t\tinput:   \"hi\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"FalseSTDIN\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.ImagePath, \"grep\", \"hi\"},\n\t\t\tinput:   \"bye\",\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"TrueLibrary\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\"},\n\t\t\tinput:   \"true\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"FalseLibrary\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\"},\n\t\t\tinput:   \"false\",\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"TrueDocker\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"docker://busybox\"},\n\t\t\tinput:   \"true\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"FalseDocker\",\n\t\t\tcommand: \"shell\",\n\t\t\targv:    []string{\"docker://busybox\"},\n\t\t\tinput:   \"false\",\n\t\t\texit:    1,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"TrueShub\",\n\t\t// \tcommand: \"shell\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\"},\n\t\t// \tinput:   \"true\",\n\t\t// \texit:    0,\n\t\t// },\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"FalseShub\",\n\t\t// \tcommand: \"shell\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\"},\n\t\t// \tinput:   \"false\",\n\t\t// \texit:    1,\n\t\t// },\n\t}\n\n\tvar input bytes.Buffer\n\n\tfor _, tt := range stdinTests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.WithStdin(&input),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tinput.WriteString(tt.input)\n\t\t\t}),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t\tinput.Reset()\n\t}\n\n\tuser := e2e.CurrentUser(t)\n\tstdoutTests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\toutput  string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"AppsFoo\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--app\", \"foo\", c.env.ImagePath},\n\t\t\toutput:  \"RUNNING FOO\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"PwdPath\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"--pwd\", \"/etc\", c.env.ImagePath, \"pwd\"},\n\t\t\toutput:  \"/etc\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Arguments\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{c.env.ImagePath, \"foo\"},\n\t\t\toutput:  \"Running command: foo\",\n\t\t\texit:    127,\n\t\t},\n\t\t{\n\t\t\tname:    \"Permissions\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.ImagePath, \"id\", \"-un\"},\n\t\t\toutput:  user.Name,\n\t\t\texit:    0,\n\t\t},\n\t}\n\tfor _, tt := range stdoutTests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(\n\t\t\t\ttt.exit,\n\t\t\t\te2e.ExpectOutput(e2e.ExactMatch, tt.output),\n\t\t\t),\n\t\t)\n\t}\n}\n\n// RunFromURI tests min fuctionality for apptainer run/exec URI://\nfunc (c actionTests) RunFromURI(t *testing.T) {\n\te2e.EnsureORASImage(t, c.env)\n\n\trunScript := \"testdata/runscript.sh\"\n\tbind := fmt.Sprintf(\"%s:/.singularity.d/runscript\", runScript)\n\n\tfi, err := os.Stat(runScript)\n\tif err != nil {\n\t\tt.Fatalf(\"can't find %s\", runScript)\n\t}\n\tsize := strconv.Itoa(int(fi.Size()))\n\n\ttests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\texit    int\n\t\tprofile e2e.Profile\n\t}{\n\t\t// Run from supported URI's and check the runscript call works\n\t\t{\n\t\t\tname:    \"RunFromDockerOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"docker://busybox:latest\", size},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromDockerWithoutShellOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"docker://hello-world\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromLibraryOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"oras://ghcr.io/apptainer/busybox:1.31.1\", size},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"RunFromShubOK\",\n\t\t// \tcommand: \"run\",\n\t\t// \targv:    []string{\"--bind\", bind, \"shub://singularityhub/busybox\", size},\n\t\t// \texit:    0,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"RunFromOrasOK\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, c.env.OrasTestImage, size},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromDockerKO\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"docker://busybox:latest\", \"0\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFromLibraryKO\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, \"oras://ghcr.io/apptainer/busybox:1.31.1\", \"0\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"RunFromShubKO\",\n\t\t// \tcommand: \"run\",\n\t\t// \targv:    []string{\"--bind\", bind, \"shub://singularityhub/busybox\", \"0\"},\n\t\t// \texit:    1,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"RunFromOrasKO\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", bind, c.env.OrasTestImage, \"0\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\n\t\t// exec from a supported URI's and check the exit code\n\t\t{\n\t\t\tname:    \"ExecTrueDocker\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecTrueLibrary\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecTrueShub\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"true\"},\n\t\t// \texit:    0,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecTrueOras\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseDocker\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseLibrary\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecFalseShub\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"false\"},\n\t\t// \texit:    1,\n\t\t// \tprofile: e2e.UserProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecFalseOras\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\n\t\t// exec from URI with user namespace enabled\n\t\t{\n\t\t\tname:    \"ExecTrueDockerUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecTrueLibraryUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecTrueShubUserns\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"true\"},\n\t\t// \texit:    0,\n\t\t// \tprofile: e2e.UserNamespaceProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecTrueOrasUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"true\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseDockerUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"docker://busybox:latest\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalseLibraryUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"oras://ghcr.io/apptainer/busybox:1.31.1\", \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t// TODO(mem): reenable this; disabled while shub is down\n\t\t// {\n\t\t// \tname:    \"ExecFalseShubUserns\",\n\t\t// \tcommand: \"exec\",\n\t\t// \targv:    []string{\"shub://singularityhub/busybox\", \"false\"},\n\t\t// \texit:    1,\n\t\t// \tprofile: e2e.UserNamespaceProfile,\n\t\t// },\n\t\t{\n\t\t\tname:    \"ExecFalseOrasUserns\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{c.env.OrasTestImage, \"false\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// PersistentOverlay test the --overlay function\nfunc (c actionTests) PersistentOverlay(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\trequire.Filesystem(t, \"overlay\")\n\n\trequire.Command(t, \"mkfs.ext3\")\n\trequire.Command(t, \"mksquashfs\")\n\trequire.Command(t, \"dd\")\n\n\ttestdir, err := ioutil.TempDir(c.env.TestDir, \"persistent-overlay-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func(t *testing.T) {\n\t\tif t.Failed() {\n\t\t\tt.Logf(\"Not removing directory %s for test %s\", testdir, t.Name())\n\t\t\treturn\n\t\t}\n\t\terr := os.RemoveAll(testdir)\n\t\tif err != nil {\n\t\t\tt.Logf(\"Error while removing directory %s for test %s: %#v\", testdir, t.Name(), err)\n\t\t}\n\t}\n\t// sandbox overlay implies creation of upper/work directories by\n\t// Apptainer, so we would need privileges to delete the test\n\t// directory correctly\n\tdefer e2e.Privileged(cleanup)\n\n\tsquashfsImage := filepath.Join(testdir, \"squashfs.simg\")\n\text3Img := filepath.Join(testdir, \"ext3_fs.img\")\n\tsandboxImage := filepath.Join(testdir, \"sandbox\")\n\n\t// create an overlay directory\n\tdir, err := ioutil.TempDir(testdir, \"overlay-dir-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create root directory for squashfs image\n\tsquashDir, err := ioutil.TempDir(testdir, \"root-squash-dir-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsquashMarkerFile := \"squash_marker\"\n\tif err := fs.Touch(filepath.Join(squashDir, squashMarkerFile)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create the squashfs overlay image\n\tcmd := exec.Command(\"mksquashfs\", squashDir, squashfsImage, \"-noappend\", \"-all-root\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create the overlay ext3 image\n\tcmd = exec.Command(\"dd\", \"if=/dev/zero\", \"of=\"+ext3Img, \"bs=1M\", \"count=64\", \"status=none\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\tcmd = exec.Command(\"mkfs.ext3\", \"-q\", \"-F\", ext3Img)\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create a sandbox image from test image\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--sandbox\", sandboxImage, c.env.ImagePath),\n\t\te2e.PostRun(func(t *testing.T) {\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatalf(\"failed to create sandbox %s from test image %s\", sandboxImage, c.env.ImagePath)\n\t\t\t}\n\t\t}),\n\t\te2e.ExpectExit(0),\n\t)\n\n\te2e.SetDirective(t, c.env, \"allow setuid-mount extfs\", \"yes\")\n\tdefer e2e.ResetDirective(t, c.env, \"allow setuid-mount extfs\")\n\n\ttests := []struct {\n\t\tname    string\n\t\targv    []string\n\t\tdir     string\n\t\texit    int\n\t\tprofile e2e.Profile\n\t}{\n\t\t{\n\t\t\tname:    \"overlay_create\",\n\t\t\targv:    []string{\"--overlay\", dir, c.env.ImagePath, \"touch\", \"/dir_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_ext3_create\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, c.env.ImagePath, \"touch\", \"/ext3_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_create\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"touch\", \"/multiple_overlay_fs\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find\",\n\t\t\targv:    []string{\"--overlay\", dir, c.env.ImagePath, \"test\", \"-f\", \"/dir_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find_with_writable_fail\",\n\t\t\targv:    []string{\"--overlay\", dir, \"--writable\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find_with_writable_tmpfs\",\n\t\t\targv:    []string{\"--overlay\", dir + \":ro\", \"--writable-tmpfs\", c.env.ImagePath, \"test\", \"-f\", \"/dir_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_find_with_writable_tmpfs_fail\",\n\t\t\targv:    []string{\"--overlay\", dir, \"--writable-tmpfs\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_ext3_find\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, c.env.ImagePath, \"test\", \"-f\", \"/ext3_overlay\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_writable_fail\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", ext3Img, c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_squashFS_find\",\n\t\t\targv:    []string{\"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"test\", \"-f\", fmt.Sprintf(\"/%s\", squashMarkerFile)},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_squashFS_find_without_ro\",\n\t\t\targv:    []string{\"--overlay\", squashfsImage, c.env.ImagePath, \"test\", \"-f\", fmt.Sprintf(\"/%s\", squashMarkerFile)},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_find_ext3\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"test\", \"-f\", \"/multiple_overlay_fs\"},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_multiple_find_squashfs\",\n\t\t\targv:    []string{\"--overlay\", ext3Img, \"--overlay\", squashfsImage + \":ro\", c.env.ImagePath, \"test\", \"-f\", fmt.Sprintf(\"/%s\", squashMarkerFile)},\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_noroot\",\n\t\t\targv:    []string{\"--overlay\", dir, c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"overlay_noflag\",\n\t\t\targv:    []string{c.env.ImagePath, \"test\", \"-f\", \"/foo_overlay\"},\n\t\t\texit:    1,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\t// https://github.com/apptainer/singularity/issues/4329\n\t\t\tname:    \"SIF_writable_without_overlay_partition_issue_4329\",\n\t\t\targv:    []string{\"--writable\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\t// https://github.com/apptainer/singularity/issues/4270\n\t\t\tname:    \"overlay_dir_relative_path_issue_4270\",\n\t\t\targv:    []string{\"--overlay\", filepath.Base(dir), sandboxImage, \"test\", \"-f\", \"/dir_overlay\"},\n\t\t\tdir:     filepath.Dir(dir),\n\t\t\texit:    0,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithDir(tt.dir),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\nfunc (c actionTests) actionBasicProfiles(t *testing.T) {\n\tenv := c.env\n\n\te2e.EnsureImage(t, env)\n\n\ttests := []struct {\n\t\tname    string\n\t\tcommand string\n\t\targv    []string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"ExecTrue\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecPidNsTrue\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecFalse\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"ExecPidNsFalse\",\n\t\t\tcommand: \"exec\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunTrue\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunPidNsTrue\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunFalse\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunPidNsFalse\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--pid\", env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunBindTrue\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", \"/etc/passwd\", env.ImagePath, \"true\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"RunBindFalse\",\n\t\t\tcommand: \"run\",\n\t\t\targv:    []string{\"--bind\", \"/etc/passwd\", env.ImagePath, \"false\"},\n\t\t\texit:    1,\n\t\t},\n\t}\n\n\tfor _, profile := range e2e.Profiles {\n\t\tprofile := profile\n\n\t\tt.Run(profile.String(), func(t *testing.T) {\n\t\t\tfor _, tt := range tests {\n\t\t\t\tenv.RunApptainer(\n\t\t\t\t\tt,\n\t\t\t\t\te2e.AsSubtest(tt.name),\n\t\t\t\t\te2e.WithProfile(profile),\n\t\t\t\t\te2e.WithCommand(tt.command),\n\t\t\t\t\te2e.WithArgs(tt.argv...),\n\t\t\t\t\te2e.ExpectExit(tt.exit),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (c actionTests) actionNetwork(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\te2e.Privileged(require.Network)(t)\n\n\ttests := []struct {\n\t\tname       string\n\t\tprofile    e2e.Profile\n\t\tnetType    string\n\t\texpectExit int\n\t}{\n\t\t{\n\t\t\tname:       \"BridgeNetwork\",\n\t\t\tprofile:    e2e.RootProfile,\n\t\t\tnetType:    \"bridge\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"PtpNetwork\",\n\t\t\tprofile:    e2e.RootProfile,\n\t\t\tnetType:    \"ptp\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"UnknownNetwork\",\n\t\t\tprofile:    e2e.RootProfile,\n\t\t\tnetType:    \"unknown\",\n\t\t\texpectExit: 255,\n\t\t},\n\t\t{\n\t\t\tname:       \"FakerootNetwork\",\n\t\t\tprofile:    e2e.FakerootProfile,\n\t\t\tnetType:    \"fakeroot\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"NoneNetwork\",\n\t\t\tprofile:    e2e.UserProfile,\n\t\t\tnetType:    \"none\",\n\t\t\texpectExit: 0,\n\t\t},\n\t\t{\n\t\t\tname:       \"UserBridgeNetwork\",\n\t\t\tprofile:    e2e.UserProfile,\n\t\t\tnetType:    \"bridge\",\n\t\t\texpectExit: 255,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(\"--net\", \"--network\", tt.netType, c.env.ImagePath, \"id\"),\n\t\t\te2e.ExpectExit(tt.expectExit),\n\t\t)\n\t}\n}\n\n//nolint:maintidx\nfunc (c actionTests) actionBinds(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tworkspace, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"bind-workspace-\", \"\")\n\tsandbox, _ := e2e.MakeTempDir(t, workspace, \"sandbox-\", \"\")\n\tdefer e2e.Privileged(cleanup)\n\n\tcontCanaryDir := \"/canary\"\n\thostCanaryDir := filepath.Join(workspace, \"canary\")\n\n\tcontCanaryFile := \"/canary/file\"\n\thostCanaryFile := filepath.Join(hostCanaryDir, \"file\")\n\thostCanaryFileWithComma := filepath.Join(hostCanaryDir, \"file,comma\")\n\thostCanaryFileWithColon := filepath.Join(hostCanaryDir, \"file:colon\")\n\n\tcanaryFileBind := hostCanaryFile + \":\" + contCanaryFile\n\tcanaryFileMount := \"type=bind,source=\" + hostCanaryFile + \",destination=\" + contCanaryFile\n\tcanaryDirBind := hostCanaryDir + \":\" + contCanaryDir\n\tcanaryDirMount := \"type=bind,source=\" + hostCanaryDir + \",destination=\" + contCanaryDir\n\n\thostHomeDir := filepath.Join(workspace, \"home\")\n\thostWorkDir := filepath.Join(workspace, \"workdir\")\n\n\tcreateWorkspaceDirs := func(t *testing.T) {\n\t\te2e.Privileged(func(t *testing.T) {\n\t\t\tif err := os.RemoveAll(hostCanaryDir); err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete canary_dir: %s\", err)\n\t\t\t}\n\t\t\tif err := os.RemoveAll(hostHomeDir); err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete workspace home: %s\", err)\n\t\t\t}\n\t\t\tif err := os.RemoveAll(hostWorkDir); err != nil && !os.IsNotExist(err) {\n\t\t\t\tt.Fatalf(\"failed to delete workspace work: %s\", err)\n\t\t\t}\n\t\t})(t)\n\n\t\tif err := fs.Mkdir(hostCanaryDir, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_dir: %s\", err)\n\t\t}\n\t\tif err := fs.Touch(hostCanaryFile); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_file: %s\", err)\n\t\t}\n\t\tif err := fs.Touch(hostCanaryFileWithComma); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_file_comma: %s\", err)\n\t\t}\n\t\tif err := fs.Touch(hostCanaryFileWithColon); err != nil {\n\t\t\tt.Fatalf(\"failed to create canary_file_colon: %s\", err)\n\t\t}\n\t\tif err := os.Chmod(hostCanaryFile, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to apply permissions on canary_file: %s\", err)\n\t\t}\n\t\tif err := fs.Mkdir(hostHomeDir, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to create workspace home directory: %s\", err)\n\t\t}\n\t\tif err := fs.Mkdir(hostWorkDir, 0o777); err != nil {\n\t\t\tt.Fatalf(\"failed to create workspace work directory: %s\", err)\n\t\t}\n\t}\n\n\t// convert test image to sandbox\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--force\", \"--sandbox\", sandbox, c.env.ImagePath),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tcheckHostFn := func(path string, fn func(string) bool) func(*testing.T) {\n\t\treturn func(t *testing.T) {\n\t\t\tif t.Failed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !fn(path) {\n\t\t\t\tt.Errorf(\"%s not found on host\", path)\n\t\t\t}\n\t\t\tif err := os.RemoveAll(path); err != nil {\n\t\t\t\tt.Errorf(\"failed to delete %s: %s\", path, err)\n\t\t\t}\n\t\t}\n\t}\n\tcheckHostFile := func(path string) func(*testing.T) {\n\t\treturn checkHostFn(path, fs.IsFile)\n\t}\n\tcheckHostDir := func(path string) func(*testing.T) {\n\t\treturn checkHostFn(path, fs.IsDir)\n\t}\n\n\ttests := []struct {\n\t\tname    string\n\t\targs    []string\n\t\tpostRun func(*testing.T)\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname: \"NonExistentSource\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", \"/non/existent/source/path\",\n\t\t\t\tsandbox,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"RelativeBindDestination\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFile + \":relative\",\n\t\t\t\tsandbox,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFile\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryFileBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFilePwd\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryFileBind,\n\t\t\t\t\"--pwd\", contCanaryDir,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDir\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDirPwd\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--pwd\", contCanaryDir,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFileWritableOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", hostCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", hostCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleFileWritableKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", canaryFileBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDirWritableOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", hostCanaryDir,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", hostCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SimpleDirWritableKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"HomeContainOverride\",\n\t\t\targs: []string{\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/home\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/home/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"TmpContainOverride\",\n\t\t\targs: []string{\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/tmp\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/tmp/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"VarTmpContainOverride\",\n\t\t\targs: []string{\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/tmp\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/var/tmp/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkOneLevelFileBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFile + \":/var/etc/symlink1\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/etc/symlink1\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkTwoLevelFileBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFile + \":/var/etc/madness/symlink2\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/madness/symlink2\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkOneLevelDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/etc/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkTwoLevelDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc/madness\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/madness/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkOneLevelNewDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc/new\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/etc/new/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"SymlinkTwoLevelNewDirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/etc/madness/new\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/madness/new/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"NestedBindFile\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--bind\", hostCanaryFile + \":\" + filepath.Join(contCanaryDir, \"file2\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/canary/file2\",\n\t\t\t},\n\t\t\tpostRun: checkHostFile(filepath.Join(hostCanaryDir, \"file2\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"NestedBindDir\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--bind\", hostCanaryDir + \":\" + filepath.Join(contCanaryDir, \"dir2\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-d\", \"/canary/dir2\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostCanaryDir, \"dir2\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"MultipleNestedBindDir\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", canaryDirBind,\n\t\t\t\t\"--bind\", hostCanaryDir + \":\" + filepath.Join(contCanaryDir, \"dir2\"),\n\t\t\t\t\"--bind\", hostCanaryFile + \":\" + filepath.Join(filepath.Join(contCanaryDir, \"dir2\"), \"nested\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/canary/dir2/nested\",\n\t\t\t},\n\t\t\tpostRun: checkHostFile(filepath.Join(hostCanaryDir, \"nested\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeOneToOne\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", hostHomeDir,\n\t\t\t\t\"--bind\", hostCanaryDir + \":\" + filepath.Join(hostHomeDir, \"canary121RO\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", filepath.Join(hostHomeDir, \"canary121RO/file\"),\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostHomeDir, \"canary121RO\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", hostHomeDir + \":/home/e2e\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/home/e2e/canaryRO\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/home/e2e/canaryRO/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostHomeDir, \"canaryRO\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeBindWritableOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", hostHomeDir + \":/home/e2e\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/home/e2e/canaryRW\",\n\t\t\t\t\"--writable\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/home/e2e/canaryRW/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostHomeDir, \"canaryRW\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"CustomHomeBindWritableKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--home\", canaryDirBind,\n\t\t\t\t\"--writable\",\n\t\t\t\tsandbox,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirTmpBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirTmpBindWritable\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirVarTmpBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/var/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"var_tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"WorkdirVarTmpBindWritable\",\n\t\t\targs: []string{\n\t\t\t\t\"--writable\",\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--contain\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/var/tmp/canary/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/var/tmp/canary/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"var_tmp\", \"canary/dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScratchTmpfsBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--scratch\", \"/scratch\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/scratch/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/scratch/dir/file\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"ScratchWorkdirBind\",\n\t\t\targs: []string{\n\t\t\t\t\"--workdir\", hostWorkDir,\n\t\t\t\t\"--scratch\", \"/scratch\",\n\t\t\t\t\"--bind\", hostCanaryDir + \":/scratch/dir\",\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/scratch/dir/file\",\n\t\t\t},\n\t\t\tpostRun: checkHostDir(filepath.Join(hostWorkDir, \"scratch/scratch\", \"dir\")),\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithCommaOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", strings.ReplaceAll(hostCanaryFileWithComma, \",\", \"\\\\,\") + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithCommaKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFileWithComma + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithColonOK\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", strings.ReplaceAll(hostCanaryFileWithColon, \":\", \"\\\\:\") + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"BindFileWithColonKO\",\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", hostCanaryFileWithColon + \":\" + contCanaryFile,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t// For the --mount variants we are really just verifying the CLI\n\t\t// acceptance of one or more --mount flags. Translation from --mount\n\t\t// strings to BindPath structs is checked in unit tests. The\n\t\t// functionality of bind mounts of various kinds is already checked\n\t\t// above, with --bind flags. No need to duplicate all of these.\n\t\t{\n\t\t\tname: \"MountSingle\",\n\t\t\targs: []string{\n\t\t\t\t\"--mount\", canaryFileMount,\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", contCanaryFile,\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"MountNested\",\n\t\t\targs: []string{\n\t\t\t\t\"--mount\", canaryDirMount,\n\t\t\t\t\"--mount\", \"source=\" + hostCanaryFile + \",destination=\" + filepath.Join(contCanaryDir, \"file3\"),\n\t\t\t\tsandbox,\n\t\t\t\t\"test\", \"-f\", \"/canary/file3\",\n\t\t\t},\n\t\t\tpostRun: checkHostFile(filepath.Join(hostCanaryDir, \"file3\")),\n\t\t\texit:    0,\n\t\t},\n\t}\n\n\tfor _, profile := range e2e.Profiles {\n\t\tprofile := profile\n\t\tcreateWorkspaceDirs(t)\n\n\t\tt.Run(profile.String(), func(t *testing.T) {\n\t\t\tfor _, tt := range tests {\n\t\t\t\tc.env.RunApptainer(\n\t\t\t\t\tt,\n\t\t\t\t\te2e.AsSubtest(tt.name),\n\t\t\t\t\te2e.WithProfile(profile),\n\t\t\t\t\te2e.WithCommand(\"exec\"),\n\t\t\t\t\te2e.WithArgs(tt.args...),\n\t\t\t\t\te2e.PostRun(tt.postRun),\n\t\t\t\t\te2e.ExpectExit(tt.exit),\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc (c actionTests) exitSignals(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname string\n\t\targs []string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname: \"Exit0\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"exit 0\"},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"Exit1\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"exit 1\"},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"Exit134\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"exit 134\"},\n\t\t\texit: 134,\n\t\t},\n\t\t{\n\t\t\tname: \"SignalKill\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"kill -KILL $$\"},\n\t\t\texit: 137,\n\t\t},\n\t\t{\n\t\t\tname: \"SignalAbort\",\n\t\t\targs: []string{c.env.ImagePath, \"/bin/sh\", \"-c\", \"kill -ABRT $$\"},\n\t\t\texit: 134,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\nfunc (c actionTests) fuseMount(t *testing.T) {\n\tt.Skip(\"Broken on github for ubuntu 18.04/20.04\")\n\n\trequire.Filesystem(t, \"fuse\")\n\n\tu := e2e.UserProfile.HostUser(t)\n\n\timageDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"sshfs-\", \"\")\n\tdefer e2e.Privileged(cleanup)\n\n\tsshfsWrapper := filepath.Join(imageDir, \"sshfs-wrapper\")\n\trootPrivKey := filepath.Join(imageDir, \"/etc/ssh/ssh_host_rsa_key\")\n\tuserPrivKey := filepath.Join(imageDir, \"user.key\")\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--force\", \"--sandbox\", imageDir, \"testdata/sshfs.def\"),\n\t\te2e.PostRun(func(t *testing.T) {\n\t\t\tif t.Failed() {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcontent, err := ioutil.ReadFile(rootPrivKey)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"could not read ssh private key: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := ioutil.WriteFile(userPrivKey, content, 0o600); err != nil {\n\t\t\t\tt.Errorf(\"could not write ssh user private key: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := os.Chown(userPrivKey, int(u.UID), int(u.GID)); err != nil {\n\t\t\t\tt.Errorf(\"could not change ssh user private key owner: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tstdinReader, stdinWriter := io.Pipe()\n\n\t// we don't use an instance as it could conflict with\n\t// instance tests running in parallel\n\tgo func() {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\te2e.WithStdin(stdinReader),\n\t\t\te2e.WithCommand(\"run\"),\n\t\t\te2e.WithArgs(\"--writable\", \"--no-home\", imageDir),\n\t\t\te2e.PostRun(func(t *testing.T) {\n\t\t\t\tstdinReader.Close()\n\t\t\t\tstdinWriter.Close()\n\t\t\t}),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\t}()\n\n\t// terminate ssh server once done\n\tdefer stdinWriter.Write([]byte(\"bye\"))\n\n\t// wait until ssh server is up and running\n\tretry := 0\n\tfor {\n\t\tconn, err := net.Dial(\"tcp\", \"127.0.0.1:2022\")\n\t\tif err == nil {\n\t\t\tconn.Close()\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t\tretry++\n\t\tif retry == 5 {\n\t\t\tt.Fatalf(\"ssh server unreachable after 5 seconds: %+v\", err)\n\t\t}\n\t}\n\n\tbasicTests := []struct {\n\t\tname    string\n\t\tspec    string\n\t\tkey     string\n\t\tprofile e2e.Profile\n\t}{\n\t\t{\n\t\t\tname:    \"HostDaemonAsRoot\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsRoot\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsRoot\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsRoot\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     rootPrivKey,\n\t\t\tprofile: e2e.RootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostDaemonAsUser\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsUser\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsUser\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsUser\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostDaemonAsUserNamespace\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsUserNamespace\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsUserNamespace\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsUserNamespace\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostDaemonAsFakeroot\",\n\t\t\tspec:    \"host-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"HostAsFakeroot\",\n\t\t\tspec:    \"host\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerDaemonAsFakeroot\",\n\t\t\tspec:    \"container-daemon\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"ContainerAsFakeroot\",\n\t\t\tspec:    \"container\",\n\t\t\tkey:     userPrivKey,\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t}\n\n\toptionFmt := \"%s:%s root@127.0.0.1:/ -p 2022 -F %s -o IdentityFile=%s -o StrictHostKeyChecking=no %s\"\n\tsshConfig := filepath.Join(imageDir, \"etc\", \"ssh\", \"ssh_config\")\n\n\tfor _, tt := range basicTests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs([]string{\n\t\t\t\t\"--fusemount\", fmt.Sprintf(optionFmt, tt.spec, sshfsWrapper, sshConfig, tt.key, \"/mnt\"),\n\t\t\t\timageDir,\n\t\t\t\t\"test\", \"-d\", \"/mnt/etc\",\n\t\t\t}...),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\t}\n}\n\n//nolint:maintidx\nfunc (c actionTests) bindImage(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\trequire.Command(t, \"mkfs.ext3\")\n\trequire.Command(t, \"mksquashfs\")\n\trequire.Command(t, \"dd\")\n\n\ttestdir, err := ioutil.TempDir(c.env.TestDir, \"bind-image-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tscratchDir := filepath.Join(testdir, \"scratch\")\n\tif err := os.MkdirAll(filepath.Join(scratchDir, \"bin\"), 0o700); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcleanup := func(t *testing.T) {\n\t\tif t.Failed() {\n\t\t\tt.Logf(\"Not removing directory %s for test %s\", testdir, t.Name())\n\t\t\treturn\n\t\t}\n\t\terr := os.RemoveAll(testdir)\n\t\tif err != nil {\n\t\t\tt.Logf(\"Error while removing directory %s for test %s: %#v\", testdir, t.Name(), err)\n\t\t}\n\t}\n\tdefer cleanup(t)\n\n\tsifSquashImage := filepath.Join(testdir, \"data_squash.sif\")\n\tsifExt3Image := filepath.Join(testdir, \"data_ext3.sif\")\n\tsquashfsImage := filepath.Join(testdir, \"squashfs.simg\")\n\text3Img := filepath.Join(testdir, \"ext3_fs.img\")\n\n\t// create root directory for squashfs image\n\tsquashDir, err := ioutil.TempDir(testdir, \"root-squash-dir-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Chmod(squashDir, 0o755); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsquashMarkerFile := \"squash_marker\"\n\tif err := fs.Touch(filepath.Join(squashDir, squashMarkerFile)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create the squashfs overlay image\n\tcmd := exec.Command(\"mksquashfs\", squashDir, squashfsImage, \"-noappend\", \"-all-root\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create the overlay ext3 image\n\tcmd = exec.Command(\"dd\", \"if=/dev/zero\", \"of=\"+ext3Img, \"bs=1M\", \"count=64\", \"status=none\")\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\tcmd = exec.Command(\"mkfs.ext3\", \"-q\", \"-F\", ext3Img)\n\tif res := cmd.Run(t); res.Error != nil {\n\t\tt.Fatalf(\"Unexpected error while running command.\\n%s\", res)\n\t}\n\n\t// create new SIF images\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\"new\", sifSquashImage}...),\n\t\te2e.ExpectExit(0),\n\t)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\"new\", sifExt3Image}...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// arch partition doesn't matter for data partition so\n\t// take amd64 by default\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\n\t\t\t\"add\",\n\t\t\t\"--datatype\", \"4\", \"--partarch\", \"2\",\n\t\t\t\"--partfs\", \"1\", \"--parttype\", \"3\",\n\t\t\tsifSquashImage, squashfsImage,\n\t\t}...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sif\"),\n\t\te2e.WithArgs([]string{\n\t\t\t\"add\",\n\t\t\t\"--datatype\", \"4\", \"--partarch\", \"2\",\n\t\t\t\"--partfs\", \"2\", \"--parttype\", \"3\",\n\t\t\tsifExt3Image, ext3Img,\n\t\t}...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\te2e.SetDirective(t, c.env, \"allow setuid-mount extfs\", \"yes\")\n\tdefer e2e.ResetDirective(t, c.env, \"allow setuid-mount extfs\")\n\n\ttests := []struct {\n\t\tname    string\n\t\tprofile e2e.Profile\n\t\targs    []string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"NoBindOption\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname:    \"BadIDValue\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind:id=0\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"BadBindOption\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind:fake_option=fake\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SandboxKO\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashDir + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"Squashfs\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SquashfsDouble\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", squashfsImage + \":/bind2:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind1\", squashMarkerFile), \"-a\", \"-f\", filepath.Join(\"/bind2\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SquashfsBadSource\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs:    []string{\"--bind\", squashfsImage + \":/bind:image-src=/ko\", c.env.ImagePath, \"true\"},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SquashfsMixedBind\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", squashfsImage + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", squashDir + \":/bind2\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind1\", squashMarkerFile), \"-a\", \"-f\", filepath.Join(\"/bind2\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3Write\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"touch\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3WriteKO\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind:image-src=/,ro\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"touch\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3Write\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"touch\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3Read\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"Ext3Double\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", ext3Img + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", ext3Img + \":/bind2:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataSquash\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifSquashImage + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/bind\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3Read\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", \"/bind/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3AndSquash\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/ext3:image-src=/\",\n\t\t\t\t\"--bind\", sifSquashImage + \":/squash:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/squash\", squashMarkerFile), \"-a\", \"-f\", \"/ext3/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifDataExt3Double\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind1:image-src=/\",\n\t\t\t\t\"--bind\", sifExt3Image + \":/bind2:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"true\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"SifWithID\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t// rootfs ID is now '4'\n\t\t\t\t\"--bind\", c.env.ImagePath + \":/rootfs:id=4\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-d\", \"/rootfs/etc\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t// check ordering between image and user bind\n\t\t{\n\t\t\tname:    \"SquashfsBeforeScratch\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", sifSquashImage + \":/scratch/bin:image-src=/\",\n\t\t\t\t\"--bind\", scratchDir + \":/scratch\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/scratch/bin\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 1,\n\t\t},\n\t\t{\n\t\t\tname:    \"ScratchBeforeSquashfs\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--bind\", scratchDir + \":/scratch\",\n\t\t\t\t\"--bind\", sifSquashImage + \":/scratch/bin:image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/scratch/bin\", squashMarkerFile),\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t// For the --mount variants we are really just verifying the CLI\n\t\t// acceptance of one or more image bind mount strings. Translation from\n\t\t// --mount strings to BindPath structs is checked in unit tests. The\n\t\t// functionality of image mounts of various kinds is already checked\n\t\t// above, with --bind flags. No need to duplicate all of these.\n\t\t{\n\t\t\tname:    \"MountSifWithID\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t// rootfs ID is now '4'\n\t\t\t\t\"--mount\", \"type=bind,source=\" + c.env.ImagePath + \",destination=/rootfs,id=4\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-d\", \"/rootfs/etc\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"MountSifDataExt3AndSquash\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\targs: []string{\n\t\t\t\t\"--mount\", \"type=bind,source=\" + sifExt3Image + \",destination=/ext3,image-src=/\",\n\t\t\t\t\"--mount\", \"type=bind,source=\" + sifSquashImage + \",destination=/squash,image-src=/\",\n\t\t\t\tc.env.ImagePath,\n\t\t\t\t\"test\", \"-f\", filepath.Join(\"/squash\", squashMarkerFile), \"-a\", \"-f\", \"/ext3/ext3_marker\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// actionUmask tests that the within-container umask is correct in action flows\nfunc (c actionTests) actionUmask(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tu := e2e.UserProfile.HostUser(t)\n\n\t// Set umask for tests to 0000\n\toldUmask := syscall.Umask(0)\n\tdefer syscall.Umask(oldUmask)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithDir(u.Dir),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(c.env.ImagePath, \"sh\", \"-c\", \"umask\"),\n\t\te2e.ExpectExit(\n\t\t\t0,\n\t\t\te2e.ExpectOutput(e2e.ExactMatch, \"0000\"),\n\t\t),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithDir(u.Dir),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-umask\", c.env.ImagePath, \"sh\", \"-c\", \"umask\"),\n\t\te2e.ExpectExit(\n\t\t\t0,\n\t\t\te2e.ExpectOutput(e2e.ExactMatch, \"0022\"),\n\t\t),\n\t)\n}\n\n// actionUnsquash tests that the --unsquash option succeeds in conversion\nfunc (c actionTests) actionUnsquash(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname    string\n\t\tprofile e2e.Profile\n\t}{\n\t\t{\n\t\t\tname:    \"user\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"userns\",\n\t\t\tprofile: e2e.UserNamespaceProfile,\n\t\t},\n\t\t{\n\t\t\tname:    \"fakeroot\",\n\t\t\tprofile: e2e.FakerootProfile,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(\"--unsquash\", c.env.ImagePath, \"true\"),\n\t\t\te2e.ExpectExit(\n\t\t\t\t0,\n\t\t\t\te2e.ExpectError(e2e.ContainMatch, \"Converting SIF\"),\n\t\t\t),\n\t\t)\n\t}\n}\n\nfunc (c actionTests) actionNoMount(t *testing.T) {\n\t// TODO - this does not test --no-mount hostfs as that is a little tricky\n\t// We are in a mount namespace for e2e tests, so we can setup some mounts in there,\n\t// create a custom config with `mount hostfs = yes` set, and then look for presence\n\t// or absence of the mounts. I'd like to think about this a bit more though - work up\n\t// some nice helpers & cleanup for the actions we need.\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname string\n\t\t// Which mount directive to override (disable)\n\t\tnoMount string\n\t\t// Output of `mount` command to ensure we should not find\n\t\t// e.g for `--no-mount home` \"on /home\" as mount command output is of the form:\n\t\t//   tmpfs on /home/dave type tmpfs (rw,seclabel,nosuid,nodev,relatime,size=16384k,uid=1000,gid=1000)\n\t\tnoMatch string\n\t\t// Whether to run the test in default and/or contained modes\n\t\t// Needs to be specified as e.g. by default `/dev` mount is a full bind that will always include `/dev/pts`\n\t\t// ... but in --contained mode disabling devpts stops it being bound in.\n\t\ttestDefault   bool\n\t\ttestContained bool\n\t\t// To test --no-mount cwd we need to chdir for the execution\n\t\tcwd  string\n\t\texit int\n\t}{\n\t\t{\n\t\t\tname:          \"proc\",\n\t\t\tnoMount:       \"proc\",\n\t\t\tnoMatch:       \"on /proc\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          1, // mount fails with exit code 1 when there is no `/proc`\n\t\t},\n\t\t{\n\t\t\tname:          \"sys\",\n\t\t\tnoMount:       \"sys\",\n\t\t\tnoMatch:       \"on /sys\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"dev\",\n\t\t\tnoMount:       \"dev\",\n\t\t\tnoMatch:       \"on /dev\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"devpts\",\n\t\t\tnoMount:       \"devpts\",\n\t\t\tnoMatch:       \"on /dev/pts\",\n\t\t\ttestDefault:   false,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"tmp\",\n\t\t\tnoMount:       \"tmp\",\n\t\t\tnoMatch:       \"on /tmp\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"home\",\n\t\t\tnoMount:       \"home\",\n\t\t\tnoMatch:       \"on /home\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\t// /srv is an LSB directory we should be able to rely on for our CWD test\n\t\t\tname:        \"cwd\",\n\t\t\tnoMount:     \"cwd\",\n\t\t\tnoMatch:     \"on /srv\",\n\t\t\ttestDefault: true,\n\t\t\t// CWD is never mounted with contain so --no-mount CWD doesn't have an effect,\n\t\t\t// but let's verify it isn't mounted anyway.\n\t\t\ttestContained: true,\n\t\t\tcwd:           \"/srv\",\n\t\t\texit:          0,\n\t\t},\n\t\t// /etc/hosts & /etc/localtime are default 'bind path' entries we should\n\t\t// be able to disable by abs path. Although other 'bind path' entries\n\t\t// are ignored under '--contain' these two are handled specially in\n\t\t// addBindsMount(), so make sure that `--no-mount` applies properly\n\t\t// under contain also.\n\t\t{\n\t\t\tname:          \"/etc/hosts\",\n\t\t\tnoMount:       \"/etc/hosts\",\n\t\t\tnoMatch:       \"on /etc/hosts\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t\t{\n\t\t\tname:          \"/etc/localtime\",\n\t\t\tnoMount:       \"/etc/localtime\",\n\t\t\tnoMatch:       \"on /etc/localtime\",\n\t\t\ttestDefault:   true,\n\t\t\ttestContained: true,\n\t\t\texit:          0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\n\t\tif tt.testDefault {\n\t\t\tc.env.RunApptainer(\n\t\t\t\tt,\n\t\t\t\te2e.WithDir(tt.cwd),\n\t\t\t\te2e.AsSubtest(tt.name),\n\t\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\t\te2e.WithCommand(\"exec\"),\n\t\t\t\te2e.WithArgs(\"--no-mount\", tt.noMount, c.env.ImagePath, \"mount\"),\n\t\t\t\te2e.ExpectExit(tt.exit,\n\t\t\t\t\te2e.ExpectOutput(e2e.UnwantedContainMatch, tt.noMatch)),\n\t\t\t)\n\t\t}\n\t\tif tt.testContained {\n\t\t\tc.env.RunApptainer(\n\t\t\t\tt,\n\t\t\t\te2e.WithDir(tt.cwd),\n\t\t\t\te2e.AsSubtest(tt.name+\"Contained\"),\n\t\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\t\te2e.WithCommand(\"exec\"),\n\t\t\t\te2e.WithArgs(\"--contain\", \"--no-mount\", tt.noMount, c.env.ImagePath, \"mount\"),\n\t\t\t\te2e.ExpectExit(tt.exit,\n\t\t\t\t\te2e.ExpectOutput(e2e.UnwantedContainMatch, tt.noMatch)),\n\t\t\t)\n\t\t}\n\t}\n}\n\n// actionCompat checks that the --compat flag sets up the expected environment\n// for improved oci/docker compatibility\nfunc (c actionTests) actionCompat(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttype test struct {\n\t\tname     string\n\t\targs     []string\n\t\texitCode int\n\t\texpect   e2e.ApptainerCmdResultOp\n\t}\n\n\ttests := []test{\n\t\t{\n\t\t\tname:     \"containall\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"ls -lah $HOME\"},\n\t\t\texitCode: 0,\n\t\t\texpect:   e2e.ExpectOutput(e2e.ContainMatch, \"total 0\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"writable-tmpfs\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"touch /test\"},\n\t\t\texitCode: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"no-init\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"ps\"},\n\t\t\texitCode: 0,\n\t\t\texpect:   e2e.ExpectOutput(e2e.UnwantedContainMatch, \"appinit\"),\n\t\t},\n\t\t{\n\t\t\tname:     \"no-umask\",\n\t\t\targs:     []string{\"--compat\", c.env.ImagePath, \"sh\", \"-c\", \"umask\"},\n\t\t\texitCode: 0,\n\t\t\texpect:   e2e.ExpectOutput(e2e.ContainMatch, \"0022\"),\n\t\t},\n\t}\n\n\toldUmask := syscall.Umask(0)\n\tdefer syscall.Umask(oldUmask)\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(e2e.UserProfile),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(\n\t\t\t\ttt.exitCode,\n\t\t\t\ttt.expect,\n\t\t\t),\n\t\t)\n\t}\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := actionTests{\n\t\tenv: env,\n\t}\n\n\tnp := testhelper.NoParallel\n\n\treturn testhelper.Tests{\n\t\t\"action URI\":            c.RunFromURI,          // action_URI\n\t\t\"singularity link\":      c.singularityLink,     // singularity symlink\n\t\t\"exec\":                  c.actionExec,          // apptainer exec\n\t\t\"persistent overlay\":    c.PersistentOverlay,   // Persistent Overlay\n\t\t\"run\":                   c.actionRun,           // apptainer run\n\t\t\"shell\":                 c.actionShell,         // shell interaction\n\t\t\"STDPIPE\":               c.STDPipe,             // stdin/stdout pipe\n\t\t\"action basic profiles\": c.actionBasicProfiles, // run basic action under different profiles\n\t\t\"issue 4488\":            c.issue4488,           // https://github.com/apptainer/singularity/issues/4488\n\t\t\"issue 4587\":            c.issue4587,           // https://github.com/apptainer/singularity/issues/4587\n\t\t\"issue 4755\":            c.issue4755,           // https://github.com/apptainer/singularity/issues/4755\n\t\t\"issue 4768\":            c.issue4768,           // https://github.com/apptainer/singularity/issues/4768\n\t\t\"issue 4797\":            c.issue4797,           // https://github.com/apptainer/singularity/issues/4797\n\t\t\"issue 4823\":            c.issue4823,           // https://github.com/apptainer/singularity/issues/4823\n\t\t\"issue 4836\":            c.issue4836,           // https://github.com/apptainer/singularity/issues/4836\n\t\t\"issue 5211\":            c.issue5211,           // https://github.com/apptainer/singularity/issues/5211\n\t\t\"issue 5228\":            c.issue5228,           // https://github.com/apptainer/singularity/issues/5228\n\t\t\"issue 5271\":            c.issue5271,           // https://github.com/apptainer/singularity/issues/5271\n\t\t\"issue 5399\":            c.issue5399,           // https://github.com/apptainer/singularity/issues/5399\n\t\t\"issue 5455\":            c.issue5455,           // https://github.com/apptainer/singularity/issues/5455\n\t\t\"issue 5465\":            c.issue5465,           // https://github.com/apptainer/singularity/issues/5465\n\t\t\"issue 5599\":            c.issue5599,           // https://github.com/apptainer/singularity/issues/5599\n\t\t\"issue 5631\":            c.issue5631,           // https://github.com/apptainer/singularity/issues/5631\n\t\t\"issue 5690\":            c.issue5690,           // https://github.com/apptainer/singularity/issues/5690\n\t\t\"issue 6165\":            c.issue6165,           // https://github.com/apptainer/singularity/issues/6165\n\t\t\"issue 619\":             c.issue619,            // https://github.com/apptainer/apptainer/issues/619\n\t\t\"network\":               c.actionNetwork,       // test basic networking\n\t\t\"binds\":                 c.actionBinds,         // test various binds with --bind and --mount\n\t\t\"exit and signals\":      c.exitSignals,         // test exit and signals propagation\n\t\t\"fuse mount\":            c.fuseMount,           // test fusemount option\n\t\t\"bind image\":            c.bindImage,           // test bind image with --bind and --mount\n\t\t\"umask\":                 c.actionUmask,         // test umask propagation\n\t\t\"unsquash\":              c.actionUnsquash,      // test --unsquash\n\t\t\"no-mount\":              c.actionNoMount,       // test --no-mount\n\t\t\"compat\":                c.actionCompat,        // test --compat\n\t\t\"invalidRemote\":         np(c.invalidRemote),   // GHSA-5mv9-q7fq-9394\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage config\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/require\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/user\"\n)\n\ntype configTests struct {\n\tenv              e2e.TestEnv\n\tsifImage         string\n\tencryptedImage   string\n\tsquashfsImage    string\n\text3Image        string\n\text3OverlayImage string\n\tsandboxImage     string\n\tpemPublic        string\n\tpemPrivate       string\n}\n\n// prepImages creates containers covering all image formats to test the\n// `allow container xxx` directives.\nfunc (c *configTests) prepImages(t *testing.T) (cleanup func(t *testing.T)) {\n\trequire.MkfsExt3(t)\n\trequire.Command(t, \"truncate\")\n\trequire.Command(t, \"mksquashfs\")\n\n\ttmpDir, cleanup := e2e.MakeTempDir(t, \"\", \"config-\", \"CONFIG\")\n\n\t// An unencrypted SIF\n\te2e.EnsureImage(t, c.env)\n\tc.sifImage = c.env.ImagePath\n\n\t// An encrypted SIF\n\tc.pemPublic, c.pemPrivate = e2e.GeneratePemFiles(t, tmpDir)\n\tc.encryptedImage = filepath.Join(tmpDir, \"encrypted.sif\")\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"PrepareEncryptedSIF\"),\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--encrypt\", \"--pem-path\", c.pemPublic, c.encryptedImage, c.sifImage),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// A sandbox directory\n\tc.sandboxImage = filepath.Join(tmpDir, \"sandbox\")\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"PrepareSandbox\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"-s\", c.sandboxImage, c.sifImage),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// A bare ext3 image\n\tt.Run(\"PrepareExt3\", func(t *testing.T) {\n\t\tc.ext3Image = filepath.Join(tmpDir, \"ext3.img\")\n\t\tcmd := exec.Command(\"truncate\", \"-s\", \"16M\", c.ext3Image)\n\t\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\t\tdefer cleanup(t)\n\t\t\tt.Fatalf(\"Error creating blank ext3 image: %v: %s\", err, out)\n\t\t}\n\t\tcmd = exec.Command(\"mkfs.ext3\", \"-d\", c.sandboxImage, c.ext3Image)\n\t\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\t\tdefer cleanup(t)\n\t\t\tt.Fatalf(\"Error creating populated ext3 image: %v: %s\", err, out)\n\t\t}\n\t})\n\n\t// A bare squashfs image\n\tt.Run(\"PrepareSquashfs\", func(t *testing.T) {\n\t\tc.squashfsImage = filepath.Join(tmpDir, \"squashfs.img\")\n\t\tcmd := exec.Command(\"mksquashfs\", c.sandboxImage, c.squashfsImage)\n\t\tif out, err := cmd.CombinedOutput(); err != nil {\n\t\t\tdefer cleanup(t)\n\t\t\tt.Fatalf(\"Error creating squashfs image: %v: %s\", err, out)\n\t\t}\n\t})\n\n\t// An ext3 overlay embedded in a SIF\n\tc.ext3OverlayImage = filepath.Join(tmpDir, \"ext3Overlay.img\")\n\tif err := fs.CopyFile(c.sifImage, c.ext3OverlayImage, 0o755); err != nil {\n\t\tt.Fatalf(\"Could not copy test image file: %v\", err)\n\t}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"PrepareExt3Overlay\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"overlay\"),\n\t\te2e.WithArgs(\"create\", c.ext3OverlayImage),\n\t\te2e.ExpectExit(0),\n\t)\n\n\treturn cleanup\n}\n\n//nolint:maintidx\nfunc (c configTests) configGlobal(t *testing.T) {\n\tcleanup := c.prepImages(t)\n\tdefer cleanup(t)\n\n\te2e.SetDirective(t, c.env, \"allow setuid-mount extfs\", \"yes\")\n\tdefer e2e.ResetDirective(t, c.env, \"allow setuid-mount extfs\")\n\n\tu := e2e.UserProfile.HostUser(t)\n\tg, err := user.GetGrGID(u.GID)\n\tif err != nil {\n\t\tt.Fatalf(\"could not retrieve user group information: %s\", err)\n\t}\n\n\ttests := []struct {\n\t\tname              string\n\t\targv              []string\n\t\tprofile           e2e.Profile\n\t\taddRequirementsFn func(*testing.T)\n\t\tcwd               string\n\t\tdirective         string\n\t\tdirectiveValue    string\n\t\texit              int\n\t\tresultOp          e2e.ApptainerCmdResultOp\n\t}{\n\t\t{\n\t\t\tname: \"AllowSetuid\",\n\t\t\targv: []string{c.env.ImagePath, \"true\"},\n\t\t\t// We are testing if we fall back to user namespace without `--userns`\n\t\t\t// so we need to use the UserProfile, and check separately if userns\n\t\t\t// support is possible.\n\t\t\tprofile:           e2e.UserProfile,\n\t\t\taddRequirementsFn: require.UserNamespace,\n\t\t\tdirective:         \"allow setuid\",\n\t\t\tdirectiveValue:    \"no\",\n\t\t\texit:              0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MaxLoopDevices\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"max loop devices\",\n\t\t\tdirectiveValue: \"0\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowPidNsNo\",\n\t\t\targv:           []string{\"--pid\", \"--no-init\", c.env.ImagePath, \"/bin/sh\", \"-c\", \"echo $$\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow pid ns\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t\tresultOp:       e2e.ExpectOutput(e2e.UnwantedExactMatch, \"1\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowPidNsYes\",\n\t\t\targv:           []string{\"--pid\", \"--no-init\", c.env.ImagePath, \"/bin/sh\", \"-c\", \"echo $$\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow pid ns\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t\tresultOp:       e2e.ExpectOutput(e2e.ExactMatch, \"1\"),\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigPasswdNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/passwd.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config passwd\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigPasswdYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/passwd.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config passwd\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigGroupNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/group.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config group\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigGroupYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/group.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config group\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigResolvConfNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/resolv.conf.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config resolv_conf\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"ConfigResolvConfYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"/etc/resolv.conf.*- tmpfs\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"config resolv_conf\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountProcNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/proc/self\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount proc\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountProcYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/proc/self\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount proc\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountSysNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/sys/kernel\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount sys\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountSysYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/sys/kernel\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount sys\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountDevNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", \"/dev/pts\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount dev\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountDevMinimal\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-b\", \"/dev/loop0\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount dev\",\n\t\t\tdirectiveValue: \"minimal\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountDevYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-b\", \"/dev/loop0\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount dev\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// just test 'mount devpts = no' as yes depends of kernel version\n\t\t{\n\t\t\tname:           \"MountDevPtsNo\",\n\t\t\targv:           []string{\"-C\", c.env.ImagePath, \"test\", \"-d\", \"/dev/pts\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount devpts\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountHomeNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", u.Dir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tcwd:            \"/\",\n\t\t\tdirective:      \"mount home\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountHomeYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", u.Dir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tcwd:            \"/\",\n\t\t\tdirective:      \"mount home\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountTmpNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", c.env.TestDir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount tmp\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"MountTmpYes\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-d\", c.env.TestDir},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"mount tmp\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"BindPathPasswd\",\n\t\t\targv:           []string{c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"bind path\",\n\t\t\tdirectiveValue: \"/etc/passwd:/passwd\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"UserBindControlNo\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"user bind control\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t{\n\t\t\tname:           \"UserBindControlYes\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"user bind control\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// overlay may or not be available, just test with no\n\t\t{\n\t\t\tname:           \"EnableOverlayNo\",\n\t\t\targv:           []string{c.env.ImagePath, \"grep\", \"\\\\- overlay overlay\", \"/proc/self/mountinfo\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"enable overlay\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           1,\n\t\t},\n\t\t// use user namespace profile to force underlay use\n\t\t{\n\t\t\tname:           \"EnableUnderlayNo\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"enable underlay\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"EnableUnderlayYes\",\n\t\t\targv:           []string{\"--bind\", \"/etc/passwd:/passwd\", c.env.ImagePath, \"test\", \"-f\", \"/passwd\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"enable underlay\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// test image is owned by root:root\n\t\t{\n\t\t\tname:           \"LimitContainerOwnersUser\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container owners\",\n\t\t\tdirectiveValue: u.Name,\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerOwnersUserAndRoot\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container owners\",\n\t\t\tdirectiveValue: u.Name + \", root\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerGroupsUser\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container groups\",\n\t\t\tdirectiveValue: g.Name,\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerGroupsUserAndRoot\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container groups\",\n\t\t\tdirectiveValue: g.Name + \", root\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerPathsProc\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container paths\",\n\t\t\tdirectiveValue: \"/proc\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"LimitContainerPathsTestdir\",\n\t\t\targv:           []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"limit container paths\",\n\t\t\tdirectiveValue: c.env.TestDir,\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSifNo\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container sif\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSifYes\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container sif\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerEncryptedNo\",\n\t\t\targv:           []string{\"--pem-path\", c.pemPrivate, c.encryptedImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container encrypted\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerEncryptedYes\",\n\t\t\targv:           []string{\"--pem-path\", c.pemPrivate, c.encryptedImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container encrypted\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSquashfsNo\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerSquashfsYes\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container squashfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerExfs3No\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerExtfsYes\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container extfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerDirNo\",\n\t\t\targv:           []string{c.sandboxImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container dir\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowContainerDirYes\",\n\t\t\targv:           []string{c.sandboxImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow container dir\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// NOTE: the \"allow setuid-mount\" tests have to stay after the\n\t\t// \"allow container\" tests because they will be left in their\n\t\t// default settings which can interfere with \"allow container\" tests.\n\t\t{\n\t\t\tname:           \"AllowSetuidMountEncryptedNo\",\n\t\t\targv:           []string{\"--pem-path\", c.pemPrivate, c.encryptedImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount encrypted\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountEncryptedYes\",\n\t\t\targv:           []string{\"--pem-path\", c.pemPrivate, c.encryptedImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount encrypted\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsNo\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsNoSif\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsNoBind\",\n\t\t\targv:           []string{\"-B\", c.squashfsImage + \":/sqsh:image-src=/\", c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsNoUserns\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsNoUsernsSif\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsNoUsernsBind\",\n\t\t\targv:           []string{\"-B\", c.squashfsImage + \":/sqsh:image-src=/\", c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsYes\",\n\t\t\targv:           []string{c.squashfsImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsYesSif\",\n\t\t\targv:           []string{c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountSquashfsYesBind\",\n\t\t\targv:           []string{\"-B\", c.squashfsImage + \":/sqsh:image-src=/\", c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount squashfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsNo\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsNoSif\",\n\t\t\targv:           []string{c.ext3OverlayImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsNoBind\",\n\t\t\targv:           []string{\"-B\", c.ext3Image + \":/ext3:image-src=/\", c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           255,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsNoUserns\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsNoUsernsSif\",\n\t\t\targv:           []string{c.ext3OverlayImage, \"true\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsNoUsernsBind\",\n\t\t\targv:           []string{\"-B\", c.ext3Image + \":/ext3:image-src=/\", c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserNamespaceProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsYes\",\n\t\t\targv:           []string{c.ext3Image, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsYesSif\",\n\t\t\targv:           []string{c.ext3OverlayImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t{\n\t\t\tname:           \"AllowSetuidMountExtfsYesBind\",\n\t\t\targv:           []string{\"-B\", c.ext3Image + \":/ext3:image-src=/\", c.sifImage, \"true\"},\n\t\t\tprofile:        e2e.UserProfile,\n\t\t\tdirective:      \"allow setuid-mount extfs\",\n\t\t\tdirectiveValue: \"yes\",\n\t\t\texit:           0,\n\t\t},\n\t\t// FIXME\n\t\t// The e2e tests currently run inside a PID namespace.\n\t\t//   (see internal/init/init_linux.go)\n\t\t// We can't instruct systemd to manage our cgroups as the PIDs in our test namespace\n\t\t// won't match what systemd sees.\n\t\t// {\n\t\t// \tname:           \"SystemdCgroupsYes\",\n\t\t// \targv:           []string{\"--apply-cgroups\", \"testdata/cgroups/pids_limit.toml\", c.sandboxImage, \"true\"},\n\t\t// \tprofile:        e2e.RootProfile,\n\t\t// \tdirective:      \"systemd cgroups\",\n\t\t// \tdirectiveValue: \"yes\",\n\t\t// \texit:           0,\n\t\t// },\n\t\t{\n\t\t\tname:           \"SystemdCgroupNo\",\n\t\t\targv:           []string{\"--apply-cgroups\", \"testdata/cgroups/pids_limit.toml\", c.sandboxImage, \"true\"},\n\t\t\tprofile:        e2e.RootProfile,\n\t\t\tdirective:      \"systemd cgroups\",\n\t\t\tdirectiveValue: \"no\",\n\t\t\texit:           0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithDir(tt.cwd),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tif tt.addRequirementsFn != nil {\n\t\t\t\t\ttt.addRequirementsFn(t)\n\t\t\t\t}\n\t\t\t\te2e.SetDirective(t, c.env, tt.directive, tt.directiveValue)\n\t\t\t}),\n\t\t\te2e.PostRun(func(t *testing.T) {\n\t\t\t\te2e.ResetDirective(t, c.env, tt.directive)\n\t\t\t}),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit, tt.resultOp),\n\t\t)\n\t}\n}\n\n// Tests that require combinations of directives to be set\nfunc (c configTests) configGlobalCombination(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\tsetDirectives := func(t *testing.T, directives map[string]string) {\n\t\tfor k, v := range directives {\n\t\t\te2e.SetDirective(t, c.env, k, v)\n\t\t}\n\t}\n\tresetDirectives := func(t *testing.T, directives map[string]string) {\n\t\tfor k := range directives {\n\t\t\te2e.ResetDirective(t, c.env, k)\n\t\t}\n\t}\n\n\tu := e2e.UserProfile.HostUser(t)\n\tg, err := user.GetGrGID(u.GID)\n\tif err != nil {\n\t\tt.Fatalf(\"could not retrieve user group information: %s\", err)\n\t}\n\n\ttests := []struct {\n\t\tname              string\n\t\targv              []string\n\t\tprofile           e2e.Profile\n\t\taddRequirementsFn func(*testing.T)\n\t\tcwd               string\n\t\tdirectives        map[string]string\n\t\texit              int\n\t\tresultOp          e2e.ApptainerCmdResultOp\n\t}{\n\t\t{\n\t\t\tname:    \"AllowNetUsersNobody\",\n\t\t\targv:    []string{\"--net\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": \"nobody\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUser\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": u.Name,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUID\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": fmt.Sprintf(\"%d\", u.UID),\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUserOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetUsersUIDOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    fmt.Sprintf(\"%d\", u.UID),\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsNobody\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\": \"nobody\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGroup\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\": g.Name,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGID\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\": fmt.Sprintf(\"%d\", g.GID),\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGroupOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\":   g.Name,\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"AllowNetGroupsGIDOK\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net groups\":   fmt.Sprintf(\"%d\", g.GID),\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"AllowNetNetworksMultiMulti\",\n\t\t\t// Two networks allowed, asking for both\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge,ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge,ptp\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\t// Two networks allowed, asking for one\n\t\t\tname:    \"AllowNetNetworksMultiOne\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge,ptp\",\n\t\t\t},\n\t\t\texit: 0,\n\t\t},\n\t\t{\n\t\t\t// One network allowed, but asking for two\n\t\t\tname:    \"AllowNetNetworksOneMulti\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge,ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\":    u.Name,\n\t\t\t\t\"allow net networks\": \"bridge\",\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t\t{\n\t\t\t// No networks allowed, asking for two\n\t\t\tname:    \"AllowNetNetworksNoneMulti\",\n\t\t\targv:    []string{\"--net\", \"--network\", \"bridge,ptp\", c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tdirectives: map[string]string{\n\t\t\t\t\"allow net users\": u.Name,\n\t\t\t},\n\t\t\texit: 255,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithDir(tt.cwd),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tif tt.addRequirementsFn != nil {\n\t\t\t\t\ttt.addRequirementsFn(t)\n\t\t\t\t}\n\t\t\t\tsetDirectives(t, tt.directives)\n\t\t\t}),\n\t\t\te2e.PostRun(func(t *testing.T) {\n\t\t\t\tresetDirectives(t, tt.directives)\n\t\t\t}),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit, tt.resultOp),\n\t\t)\n\t}\n}\n\nfunc (c configTests) configFile(t *testing.T) {\n\te2e.EnsureImage(t, c.env)\n\n\ttests := []struct {\n\t\tname    string\n\t\targv    []string\n\t\tprofile e2e.Profile\n\t\tconf    string\n\t\texit    int\n\t}{\n\t\t{\n\t\t\tname:    \"MaxLoopDevicesKO\",\n\t\t\targv:    []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.RootProfile,\n\t\t\tconf:    \"max loop devices = 0\\n\",\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"MaxLoopDevicesOK\",\n\t\t\targv:    []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.RootProfile,\n\t\t\tconf:    \"max loop devices = 128\\n\",\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"UserForbidden\",\n\t\t\targv:    []string{c.env.ImagePath, \"true\"},\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tconf:    \"max loop devices = 128\\n\",\n\t\t\texit:    255,\n\t\t},\n\t}\n\n\t// Create a temp testfile\n\tf, err := fs.MakeTmpFile(c.env.TestDir, \"config-\", 0o644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconfigFile := f.Name()\n\tdefer os.Remove(configFile)\n\tf.Close()\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithGlobalOptions(\"--config\", configFile),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.PreRun(func(t *testing.T) {\n\t\t\t\tif err := ioutil.WriteFile(configFile, []byte(tt.conf), 0o644); err != nil {\n\t\t\t\t\tt.Errorf(\"could not write configuration file %s: %s\", configFile, err)\n\t\t\t\t}\n\t\t\t}),\n\t\t\te2e.WithCommand(\"exec\"),\n\t\t\te2e.WithArgs(tt.argv...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := configTests{\n\t\tenv: env,\n\t}\n\n\tnp := testhelper.NoParallel\n\n\treturn testhelper.Tests{\n\t\t\"config file\":               c.configFile,                  // test --config file option\n\t\t\"config global\":             np(c.configGlobal),            // test various global configuration\n\t\t\"config global combination\": np(c.configGlobalCombination), // test various global configuration with combination\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage e2e\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/internal/pkg/buildcfg\"\n\t\"github.com/apptainer/apptainer/pkg/util/apptainerconf\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc SetupDefaultConfig(t *testing.T, path string) {\n\tc, err := apptainerconf.Parse(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"while generating apptainer configuration: %s\", err)\n\t}\n\tapptainerconf.SetCurrentConfig(c)\n\tapptainerconf.SetBinaryPath(buildcfg.LIBEXECDIR, true)\n\n\tPrivileged(func(t *testing.T) {\n\t\tf, err := os.Create(path)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"while creating apptainer configuration: %s\", err)\n\t\t}\n\n\t\tif err := apptainerconf.Generate(f, \"\", c); err != nil {\n\t\t\tt.Fatalf(\"while generating apptainer configuration: %s\", err)\n\t\t}\n\n\t\tf.Close()\n\n\t\tif err := unix.Mount(path, buildcfg.APPTAINER_CONF_FILE, \"\", unix.MS_BIND, \"\"); err != nil {\n\t\t\tt.Fatalf(\"while mounting %s to %s: %s\", path, buildcfg.APPTAINER_CONF_FILE, err)\n\t\t}\n\t})(t)\n}\n\nfunc SetDirective(t *testing.T, env TestEnv, directive, value string) {\n\tenv.RunApptainer(\n\t\tt,\n\t\tWithProfile(RootProfile),\n\t\tWithCommand(\"config global\"),\n\t\tWithArgs(\"--set\", directive, value),\n\t\tExpectExit(0),\n\t)\n}\n\nfunc ResetDirective(t *testing.T, env TestEnv, directive string) {\n\tenv.RunApptainer(\n\t\tt,\n\t\tWithProfile(RootProfile),\n\t\tWithCommand(\"config global\"),\n\t\tWithArgs(\"--reset\", directive),\n\t\tExpectExit(0),\n\t)\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n\npackage overlay\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/internal/pkg/test/tool/require\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n)\n\ntype ctx struct {\n\tenv e2e.TestEnv\n}\n\nfunc (c ctx) testOverlayCreate(t *testing.T) {\n\trequire.Filesystem(t, \"overlay\")\n\trequire.MkfsExt3(t)\n\te2e.EnsureImage(t, c.env)\n\n\ttmpDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"overlay\", \"\")\n\tdefer cleanup(t)\n\n\tpgpDir, _ := e2e.MakeKeysDir(t, tmpDir)\n\tc.env.KeyringDir = pgpDir\n\n\tsifSignedImage := filepath.Join(tmpDir, \"signed.sif\")\n\tsifImage := filepath.Join(tmpDir, \"unsigned.sif\")\n\text3SparseImage := filepath.Join(tmpDir, \"image.sparse.ext3\")\n\text3Image := filepath.Join(tmpDir, \"image.ext3\")\n\text3DirImage := filepath.Join(tmpDir, \"imagedir.ext3\")\n\n\t// signed SIF image\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(sifSignedImage, \"oras://ghcr.io/apptainer/busybox:1.31.1\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"key import\"),\n\t\te2e.WithArgs(\"testdata/ecl-pgpkeys/key1.asc\"),\n\t\te2e.ConsoleRun(e2e.ConsoleSendLine(\"e2e\")),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"sign\"),\n\t\te2e.WithArgs(\"-k\", \"0\", sifSignedImage),\n\t\te2e.ConsoleRun(e2e.ConsoleSendLine(\"e2e\")),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// unsigned SIF image\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(sifImage, \"oras://ghcr.io/apptainer/busybox:1.31.1\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\te2e.SetDirective(t, c.env, \"allow setuid-mount extfs\", \"yes\")\n\tdefer e2e.ResetDirective(t, c.env, \"allow setuid-mount extfs\")\n\n\ttype test struct {\n\t\tname    string\n\t\tprofile e2e.Profile\n\t\tcommand string\n\t\targs    []string\n\t\texit    int\n\t}\n\n\ttests := []test{\n\t\t{\n\t\t\tname:    \"create ext3 overlay with small size\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--size\", \"1\", ext3Image},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 sparse overlay image\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--size\", \"128\", \"--sparse\", ext3SparseImage},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--size\", \"128\", ext3Image},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"check ext3 overlay size\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"exec\",\n\t\t\targs:    []string{\"-B\", ext3Image + \":/mnt/image\", c.env.ImagePath, \"/bin/sh\", \"-c\", \"[ $(stat -c %s /mnt/image) = 134217728 ] || false\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay with an existing image\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", ext3Image},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay with dir\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", \"--create-dir\", \"/usr/local/testing\", ext3DirImage},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"check overlay dir permissions\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"exec\",\n\t\t\targs:    []string{\"-o\", ext3DirImage, c.env.ImagePath, \"mkdir\", \"/usr/local/testing/perms\"},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image in unsigned SIF\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifImage},\n\t\t\texit:    0,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image in SIF with an existing overlay\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifImage},\n\t\t\texit:    255,\n\t\t},\n\t\t{\n\t\t\tname:    \"create ext3 overlay image in signed SIF\",\n\t\t\tprofile: e2e.UserProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifSignedImage},\n\t\t\texit:    255,\n\t\t},\n\t}\n\n\terr := e2e.CheckCryptsetupVersion()\n\tif err == nil {\n\t\t// encrypted SIF image\n\t\tpassphraseEnvVar := fmt.Sprintf(\"%s=%s\", \"APPTAINER_ENCRYPTION_PASSPHRASE\", e2e.Passphrase)\n\n\t\tsifEncryptedImage := filepath.Join(tmpDir, \"encrypted.sif\")\n\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.WithProfile(e2e.RootProfile),\n\t\t\te2e.WithCommand(\"build\"),\n\t\t\te2e.WithArgs(\"--encrypt\", sifEncryptedImage, \"oras://ghcr.io/apptainer/busybox:1.31.1\"),\n\t\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\t\te2e.ExpectExit(0),\n\t\t)\n\n\t\ttests = append(tests, test{\n\t\t\tname:    \"create ext3 overlay image in encrypted SIF\",\n\t\t\tprofile: e2e.RootProfile,\n\t\t\tcommand: \"overlay\",\n\t\t\targs:    []string{\"create\", sifEncryptedImage},\n\t\t\texit:    255,\n\t\t})\n\t}\n\n\tfor _, tt := range tests {\n\t\tc.env.RunApptainer(\n\t\t\tt,\n\t\t\te2e.AsSubtest(tt.name),\n\t\t\te2e.WithProfile(tt.profile),\n\t\t\te2e.WithCommand(tt.command),\n\t\t\te2e.WithArgs(tt.args...),\n\t\t\te2e.ExpectExit(tt.exit),\n\t\t)\n\t}\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := ctx{\n\t\tenv: env,\n\t}\n\n\treturn testhelper.Tests{\n\t\t\"create\": c.testOverlayCreate,\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2020, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage run\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/apptainer/apptainer/e2e/internal/e2e\"\n\t\"github.com/apptainer/apptainer/e2e/internal/testhelper\"\n\t\"github.com/apptainer/apptainer/internal/pkg/cache\"\n)\n\ntype ctx struct {\n\tenv e2e.TestEnv\n}\n\n// testRun555Cache tests the specific case where the cache directory is\n// 0555 for access rights, and we try to run an Apptainer run command\n// using that directory as cache. This reflects a problem that is important\n// for the grid use case.\nfunc (c ctx) testRun555Cache(t *testing.T) {\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\tcacheDir := filepath.Join(tempDir, \"image-cache\")\n\terr := os.Mkdir(cacheDir, 0o555)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create a temporary image cache: %s\", err)\n\t}\n\t// Directory is deleted when tempDir is deleted\n\n\tcmdArgs := []string{\"oras://ghcr.io/apptainer/alpine:3.15.0\", \"/bin/true\"}\n\t// We explicitly pass the environment to the command, not through c.env.ImgCacheDir\n\t// because c.env is shared between all the tests, something we do not want here.\n\tcacheDirEnv := fmt.Sprintf(\"%s=%s\", cache.DirEnv, cacheDir)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), cacheDirEnv)),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\nfunc (c ctx) testRunPEMEncrypted(t *testing.T) {\n\t// If the version of cryptsetup is not compatible with Apptainer encryption,\n\t// the build commands are expected to fail\n\terr := e2e.CheckCryptsetupVersion()\n\tif err != nil {\n\t\tt.Skip(\"cryptsetup is not compatible, skipping test\")\n\t}\n\n\t// It is too complicated right now to deal with a PEM file, the Sylabs infrastructure\n\t// does not let us attach one to a image in the library, so we generate one.\n\tpemPubFile, pemPrivFile := e2e.GeneratePemFiles(t, c.env.TestDir)\n\n\t// We create a temporary directory to store the image, making sure tests\n\t// will not pollute each other\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\timgPath := filepath.Join(tempDir, \"encrypted_cmdline_pem-path.sif\")\n\tcmdArgs := []string{\"--encrypt\", \"--pem-path\", pemPubFile, imgPath, \"oras://ghcr.io/apptainer/alpine:3.15.0\"}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Using command line\n\tcmdArgs = []string{\"--pem-path\", pemPrivFile, imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"pem file cmdline\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Using environment variable\n\tcmdArgs = []string{imgPath}\n\tpemEnvVar := fmt.Sprintf(\"%s=%s\", \"APPTAINER_ENCRYPTION_PEM_PATH\", pemPrivFile)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"pem file cmdline\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), pemEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\nfunc (c ctx) testRunPassphraseEncrypted(t *testing.T) {\n\t// If the version of cryptsetup is not compatible with Apptainer encryption,\n\t// the build commands are expected to fail\n\terr := e2e.CheckCryptsetupVersion()\n\tif err != nil {\n\t\tt.Skip(\"cryptsetup is not compatible, skipping test\")\n\t}\n\n\tpassphraseEnvVar := fmt.Sprintf(\"%s=%s\", \"APPTAINER_ENCRYPTION_PASSPHRASE\", e2e.Passphrase)\n\n\t// We create a temporary directory to store the image, making sure tests\n\t// will not pollute each other\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\timgPath := filepath.Join(tempDir, \"encrypted_cmdline_passphrase.sif\")\n\tcmdArgs := []string{\"--encrypt\", imgPath, \"oras://ghcr.io/apptainer/alpine:3.15.0\"}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tpassphraseInput := []e2e.ApptainerConsoleOp{\n\t\te2e.ConsoleSendLine(e2e.Passphrase),\n\t}\n\n\t// Interactive command\n\tcmdArgs = []string{\"--passphrase\", imgPath, \"/bin/true\"}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"interactive passphrase\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.ConsoleRun(passphraseInput...),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Using the environment variable to specify the passphrase\n\tcmdArgs = []string{imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"env var passphrase\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Ensure decryption works with an IPC namespace\n\tcmdArgs = []string{\"--ipc\", imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"env var passphrase with ipc namespace\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Ensure decryption works with containall (IPC and PID namespaces)\n\tcmdArgs = []string{\"--containall\", imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"env var passphrase with containall\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// Specifying the passphrase on the command line should always fail\n\tcmdArgs = []string{\"--passphrase\", e2e.Passphrase, imgPath}\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.AsSubtest(\"passphrase on cmdline\"),\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"run\"),\n\t\te2e.WithArgs(cmdArgs...),\n\t\te2e.WithEnv(append(os.Environ(), passphraseEnvVar)),\n\t\te2e.ExpectExit(255),\n\t)\n}\n\nfunc (c ctx) testFuseOverlayfs(t *testing.T) {\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\toverlayPath := fmt.Sprintf(\"%s/overlay.img\", tempDir)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"overlay\"),\n\t\te2e.WithArgs(\"create\", \"--size\", \"64\", overlayPath),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserNamespaceProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--writable-tmpfs\", \"testdata/busybox_amd64.sif\", \"touch\", \"file\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserNamespaceProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--overlay\", overlayPath, \"testdata/busybox_amd64.sif\", \"touch\", \"file\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserNamespaceProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--overlay\", tempDir, \"testdata/busybox_amd64.sif\", \"touch\", \"file\"),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\nfunc (c ctx) testFuseSquashMount(t *testing.T) {\n\tdataDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfile, err := ioutil.TempFile(dataDir, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp file under temp data dir: %s\", dataDir)\n\t}\n\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfilename := file.Name()\n\tfile.Close()\n\n\tsquashfile := fmt.Sprintf(\"%s/input.squashfs\", tempDir)\n\t_, err = exec.Command(\"mksquashfs\", dataDir, squashfile).Output()\n\tif err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--mount\", fmt.Sprintf(\"type=bind,src=%s,dst=/input-data,image-src=/\", squashfile), \"testdata/busybox_amd64.sif\", \"ls\", \"/input-data\"),\n\t\te2e.ExpectExit(0, e2e.ExpectOutput(e2e.ContainMatch, filepath.Base(filename))),\n\t)\n}\n\nfunc (c ctx) testFuseExt3Mount(t *testing.T) {\n\tdataDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfile, err := ioutil.TempFile(dataDir, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp file under temp data dir: %s\", dataDir)\n\t}\n\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer cleanup(t)\n\n\tfilename := file.Name()\n\tfile.Close()\n\n\text3file := fmt.Sprintf(\"%s/input.img\", tempDir)\n\t_, err = exec.Command(\"mkfs.ext3\", \"-d\", dataDir, ext3file, \"64M\").Output()\n\tif err != nil {\n\t\tt.Fatalf(err.Error())\n\t}\n\n\te2e.SetDirective(t, c.env, \"allow setuid-mount extfs\", \"yes\")\n\tdefer e2e.ResetDirective(t, c.env, \"allow setuid-mount extfs\")\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--no-home\", \"--mount\", fmt.Sprintf(\"type=bind,src=%s,dst=/input-data,image-src=/\", ext3file), \"testdata/busybox_amd64.sif\", \"ls\", \"/input-data\"),\n\t\te2e.ExpectExit(0, e2e.ExpectOutput(e2e.ContainMatch, filepath.Base(filename))),\n\t)\n}\n\nfunc (c ctx) testAddPackageWithFakerootAndTmpfs(t *testing.T) {\n\ttempDir, cleanup := e2e.MakeTempDir(t, c.env.TestDir, \"\", \"\")\n\tdefer e2e.Privileged(cleanup)\n\n\tsandbox, err := ioutil.TempDir(tempDir, \"sandbox\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not create sandbox folder inside tempdir: %s\", tempDir)\n\t}\n\n\tsif := fmt.Sprintf(\"%s/centos7.sif\", tempDir)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(sif, \"docker://centos:7\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.UserProfile),\n\t\te2e.WithCommand(\"build\"),\n\t\te2e.WithArgs(\"--sandbox\", \"--force\", sandbox, sif),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// we need to increase sessiondir max size to 32MB\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"config\"),\n\t\te2e.WithArgs(\"global\", \"-s\", \"sessiondir max size\", \"1024\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// restore sessiondir max size to 16MB\n\tdefer c.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.RootProfile),\n\t\te2e.WithCommand(\"config\"),\n\t\te2e.WithArgs(\"global\", \"-s\", \"sessiondir max size\", \"16\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 1, 1a (--with-suid) (https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--writable-tmpfs\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 1, 1b (--without-suid) (https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 2(https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", \"--ignore-subuid\", \"--ignore-fakeroot-command\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(1),\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", \"--ignore-subuid\", \"--ignore-fakeroot-command\", sif, \"yum\", \"install\", \"-y\", \"epel-release\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 3(https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--userns\", \"--writable-tmpfs\", \"--ignore-subuid\", sif, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(0),\n\t)\n\n\t// running under the mode 4(https://apptainer.org/docs/user/main/fakeroot.html)\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--writable-tmpfs\", \"--ignore-userns\", \"--ignore-subuid\", sandbox, \"yum\", \"install\", \"-y\", \"openssh\"),\n\t\te2e.ExpectExit(1), // because only fakeroot is used. cpio: open failure\n\t)\n\n\tc.env.RunApptainer(\n\t\tt,\n\t\te2e.WithProfile(e2e.FakerootProfile),\n\t\te2e.WithCommand(\"exec\"),\n\t\te2e.WithArgs(\"--writable-tmpfs\", \"--ignore-userns\", \"--ignore-subuid\", sandbox, \"yum\", \"install\", \"-y\", \"epel-release\"),\n\t\te2e.ExpectExit(0),\n\t)\n}\n\n// E2ETests is the main func to trigger the test suite\nfunc E2ETests(env e2e.TestEnv) testhelper.Tests {\n\tc := ctx{\n\t\tenv: env,\n\t}\n\n\treturn testhelper.Tests{\n\t\t\"0555 cache\":                          c.testRun555Cache,\n\t\t\"inaccessible home\":                   c.issue409,\n\t\t\"passphrase encrypted\":                c.testRunPassphraseEncrypted,\n\t\t\"PEM encrypted\":                       c.testRunPEMEncrypted,\n\t\t\"fuse overlayfs\":                      c.testFuseOverlayfs,\n\t\t\"fuse squash mount\":                   c.testFuseSquashMount,\n\t\t\"fuse ext3 mount\":                     c.testFuseExt3Mount,\n\t\t\"add package with fakeroot and tmpfs\": c.testAddPackageWithFakerootAndTmpfs,\n\t}\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2020, Control Command Inc. All rights reserved.\n// Copyright (c) 2018-2022, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage apptainer\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/ProtonMail/go-crypto/openpgp\"\n\t\"github.com/apptainer/apptainer/internal/pkg/buildcfg\"\n\t\"github.com/apptainer/apptainer/internal/pkg/cgroups\"\n\tfakerootutil \"github.com/apptainer/apptainer/internal/pkg/fakeroot\"\n\t\"github.com/apptainer/apptainer/internal/pkg/image/driver\"\n\t\"github.com/apptainer/apptainer/internal/pkg/instance\"\n\t\"github.com/apptainer/apptainer/internal/pkg/plugin\"\n\t\"github.com/apptainer/apptainer/internal/pkg/runtime/engine/config/starter\"\n\t\"github.com/apptainer/apptainer/internal/pkg/security\"\n\t\"github.com/apptainer/apptainer/internal/pkg/security/seccomp\"\n\t\"github.com/apptainer/apptainer/internal/pkg/syecl\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/fs/overlay\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/mainthread\"\n\t\"github.com/apptainer/apptainer/internal/pkg/util/user\"\n\t\"github.com/apptainer/apptainer/pkg/image\"\n\tfakerootcallback \"github.com/apptainer/apptainer/pkg/plugin/callback/runtime/fakeroot\"\n\tapptainerConfig \"github.com/apptainer/apptainer/pkg/runtime/engine/apptainer/config\"\n\t\"github.com/apptainer/apptainer/pkg/runtime/engine/config\"\n\t\"github.com/apptainer/apptainer/pkg/sylog\"\n\t\"github.com/apptainer/apptainer/pkg/sypgp\"\n\t\"github.com/apptainer/apptainer/pkg/util/capabilities\"\n\t\"github.com/apptainer/apptainer/pkg/util/fs/proc\"\n\t\"github.com/apptainer/apptainer/pkg/util/namespaces\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"golang.org/x/sys/unix\"\n)\n\nvar nsProcName = map[specs.LinuxNamespaceType]string{\n\tspecs.PIDNamespace:     \"pid\",\n\tspecs.UTSNamespace:     \"uts\",\n\tspecs.IPCNamespace:     \"ipc\",\n\tspecs.MountNamespace:   \"mnt\",\n\tspecs.CgroupNamespace:  \"cgroup\",\n\tspecs.NetworkNamespace: \"net\",\n\tspecs.UserNamespace:    \"user\",\n}\n\n// PrepareConfig is called during stage1 to validate and prepare\n// container configuration. It is responsible for apptainer\n// configuration file parsing, handling user input, reading capabilities,\n// and checking what namespaces are required.\n//\n// No additional privileges can be gained as any of them are already\n// dropped by the time PrepareConfig is called.\nfunc (e *EngineOperations) PrepareConfig(starterConfig *starter.Config) error {\n\tvar err error\n\n\tif e.CommonConfig.EngineName != apptainerConfig.Name {\n\t\treturn fmt.Errorf(\"incorrect engine\")\n\t}\n\n\tif e.EngineConfig.OciConfig.Generator.Config != &e.EngineConfig.OciConfig.Spec {\n\t\treturn fmt.Errorf(\"bad engine configuration provided\")\n\t}\n\n\tif !e.EngineConfig.File.AllowSetuid && starterConfig.GetIsSUID() {\n\t\treturn fmt.Errorf(\"suid workflow disabled by administrator\")\n\t}\n\n\tif starterConfig.GetIsSUID() {\n\t\t// check for ownership of apptainer.conf\n\t\tif !fs.IsOwner(buildcfg.APPTAINER_CONF_FILE, 0) {\n\t\t\treturn fmt.Errorf(\"%s must be owned by root\", buildcfg.APPTAINER_CONF_FILE)\n\t\t}\n\t\t// check for ownership of capability.json\n\t\tif !fs.IsOwner(buildcfg.CAPABILITY_FILE, 0) {\n\t\t\treturn fmt.Errorf(\"%s must be owned by root\", buildcfg.CAPABILITY_FILE)\n\t\t}\n\t\t// check for ownership of ecl.toml\n\t\tif !fs.IsOwner(buildcfg.ECL_FILE, 0) {\n\t\t\treturn fmt.Errorf(\"%s must be owned by root\", buildcfg.ECL_FILE)\n\t\t}\n\t\tif fakerootPath := e.EngineConfig.GetFakerootPath(); fakerootPath != \"\" {\n\t\t\t// look for fakeroot again because the PATH used is\n\t\t\t//  more restricted at this point than it was earlier\n\t\t\tnewPath, err := fakerootutil.FindFake()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error finding fakeroot in privileged PATH: %v\", err)\n\t\t\t}\n\t\t\tif newPath != fakerootPath {\n\t\t\t\tsylog.Verbosef(\"path to fakeroot changed from %v to %v\", fakerootPath, newPath)\n\t\t\t}\n\t\t\te.EngineConfig.SetFakerootPath(newPath)\n\t\t}\n\t}\n\n\t// Save the current working directory if not set\n\tif e.EngineConfig.GetCwd() == \"\" {\n\t\tif pwd, err := os.Getwd(); err == nil {\n\t\t\te.EngineConfig.SetCwd(pwd)\n\t\t} else {\n\t\t\tsylog.Warningf(\"can't determine current working directory\")\n\t\t\te.EngineConfig.SetCwd(\"/\")\n\t\t}\n\t}\n\n\tif e.EngineConfig.OciConfig.Process == nil {\n\t\te.EngineConfig.OciConfig.Process = &specs.Process{}\n\t}\n\tif e.EngineConfig.OciConfig.Process.Capabilities == nil {\n\t\te.EngineConfig.OciConfig.Process.Capabilities = &specs.LinuxCapabilities{}\n\t}\n\tif len(e.EngineConfig.OciConfig.Process.Args) == 0 {\n\t\treturn fmt.Errorf(\"container process arguments not found\")\n\t}\n\n\tuid := e.EngineConfig.GetTargetUID()\n\tgids := e.EngineConfig.GetTargetGID()\n\n\tif os.Getuid() == 0 && (uid != 0 || len(gids) > 0) {\n\t\tstarterConfig.SetTargetUID(uid)\n\t\tstarterConfig.SetTargetGID(gids)\n\t\te.EngineConfig.OciConfig.SetProcessNoNewPrivileges(true)\n\t}\n\n\tuserNS := !starterConfig.GetIsSUID() || e.EngineConfig.GetFakeroot()\n\tdriver.InitImageDrivers(true, userNS, e.EngineConfig.File, 0)\n\timageDriver = image.GetDriver(e.EngineConfig.File.ImageDriver)\n\n\tif e.EngineConfig.GetInstanceJoin() {\n\t\tif err := e.prepareInstanceJoinConfig(starterConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := e.prepareContainerConfig(starterConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.loadImages(starterConfig, userNS); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tstarterConfig.SetMasterPropagateMount(true)\n\tstarterConfig.SetNoNewPrivs(e.EngineConfig.OciConfig.Process.NoNewPrivileges)\n\n\tif e.EngineConfig.OciConfig.Process != nil && e.EngineConfig.OciConfig.Process.Capabilities != nil {\n\t\tstarterConfig.SetCapabilities(capabilities.Permitted, e.EngineConfig.OciConfig.Process.Capabilities.Permitted)\n\t\tstarterConfig.SetCapabilities(capabilities.Effective, e.EngineConfig.OciConfig.Process.Capabilities.Effective)\n\t\tstarterConfig.SetCapabilities(capabilities.Inheritable, e.EngineConfig.OciConfig.Process.Capabilities.Inheritable)\n\t\tstarterConfig.SetCapabilities(capabilities.Bounding, e.EngineConfig.OciConfig.Process.Capabilities.Bounding)\n\t\tstarterConfig.SetCapabilities(capabilities.Ambient, e.EngineConfig.OciConfig.Process.Capabilities.Ambient)\n\t}\n\n\t// determine if engine need to propagate signals across processes\n\te.checkSignalPropagation()\n\n\t// We must call this here because at this point we haven't\n\t// spawned the master process nor the RPC server. The assumption\n\t// is that this function runs in stage 1 and that even if it's a\n\t// separate process, it's created in such a way that it's\n\t// sharing its file descriptor table with the wrapper / stage 2.\n\t//\n\t// At this point we do not have elevated privileges. We assume\n\t// that the user running apptainer has access to /dev/fuse\n\t// (typically it's 0666, or 0660 belonging to a group that\n\t// allows the user to read and write to it).\n\tsendFd, err := openDevFuse(e, starterConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsylog.Debugf(\"image driver is %v\", e.EngineConfig.File.ImageDriver)\n\tif sendFd || e.EngineConfig.File.ImageDriver != \"\" {\n\t\tfds, err := unix.Socketpair(unix.AF_UNIX, unix.SOCK_STREAM|unix.SOCK_CLOEXEC, 0)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to create socketpair to pass file descriptor: %s\", err)\n\t\t}\n\t\te.EngineConfig.SetUnixSocketPair(fds)\n\t\tstarterConfig.KeepFileDescriptor(fds[0])\n\t\tstarterConfig.KeepFileDescriptor(fds[1])\n\t} else {\n\t\te.EngineConfig.SetUnixSocketPair([2]int{-1, -1})\n\t}\n\n\t// nvidia-container-cli requires additional caps in the starter bounding set.\n\t// These are within the capability set for the starter process itself, *not* the capabilities\n\t// that will be set on the running container process, which are defined with SetCapabilities above.\n\tif e.EngineConfig.GetNvCCLI() {\n\t\t// Disallow this feature under setuid mode because running\n\t\t// the external command is too risky\n\t\tif starterConfig.GetIsSUID() && os.Geteuid() != 0 {\n\t\t\treturn fmt.Errorf(\"nvidia-container-cli not allowed in setuid mode\")\n\t\t}\n\n\t\tstarterConfig.SetNvCCLICaps(true)\n\t}\n\n\treturn nil\n}\n\n// prepareUserCaps is responsible for checking that user's requested\n// capabilities are authorized.\nfunc (e *EngineOperations) prepareUserCaps(enforced bool) error {\n\tcommonCaps := make([]string, 0)\n\tcommonUnauthorizedCaps := make([]string, 0)\n\n\te.EngineConfig.OciConfig.SetProcessNoNewPrivileges(true)\n\n\tfile, err := os.OpenFile(buildcfg.CAPABILITY_FILE, os.O_RDONLY, 0o644)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while opening capability config file: %s\", err)\n\t}\n\tdefer file.Close()\n\n\tcapConfig, err := capabilities.ReadFrom(file)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while parsing capability config data: %s\", err)\n\t}\n\n\tpw, err := user.Current()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcaps, ignoredCaps := capabilities.Split(e.EngineConfig.GetAddCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't add unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tcaps = append(caps, e.EngineConfig.OciConfig.Process.Capabilities.Permitted...)\n\n\tif enforced {\n\t\tauthorizedCaps, unauthorizedCaps := capConfig.CheckUserCaps(pw.Name, caps)\n\t\tif len(authorizedCaps) > 0 {\n\t\t\tsylog.Debugf(\"User capabilities %s added\", strings.Join(authorizedCaps, \",\"))\n\t\t\tcommonCaps = authorizedCaps\n\t\t}\n\t\tif len(unauthorizedCaps) > 0 {\n\t\t\tcommonUnauthorizedCaps = append(commonUnauthorizedCaps, unauthorizedCaps...)\n\t\t}\n\n\t\tgroups, err := os.Getgroups()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, g := range groups {\n\t\t\tgr, err := user.GetGrGID(uint32(g))\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Ignoring group %d: %s\", g, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tauthorizedCaps, unauthorizedCaps := capConfig.CheckGroupCaps(gr.Name, caps)\n\t\t\tif len(authorizedCaps) > 0 {\n\t\t\t\tsylog.Debugf(\"%s group capabilities %s added\", gr.Name, strings.Join(authorizedCaps, \",\"))\n\t\t\t\tcommonCaps = append(commonCaps, authorizedCaps...)\n\t\t\t}\n\t\t\tif len(unauthorizedCaps) > 0 {\n\t\t\t\tcommonUnauthorizedCaps = append(commonUnauthorizedCaps, unauthorizedCaps...)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tcommonCaps = caps\n\t}\n\n\tcommonCaps = capabilities.RemoveDuplicated(commonCaps)\n\tcommonUnauthorizedCaps = capabilities.RemoveDuplicated(commonUnauthorizedCaps)\n\n\t// remove authorized capabilities from unauthorized capabilities list\n\t// to end with the really unauthorized capabilities\n\tfor _, c := range commonCaps {\n\t\tfor i := len(commonUnauthorizedCaps) - 1; i >= 0; i-- {\n\t\t\tif commonUnauthorizedCaps[i] == c {\n\t\t\t\tcommonUnauthorizedCaps = append(commonUnauthorizedCaps[:i], commonUnauthorizedCaps[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif len(commonUnauthorizedCaps) > 0 {\n\t\tsylog.Warningf(\"not authorized to add capability: %s\", strings.Join(commonUnauthorizedCaps, \",\"))\n\t}\n\n\tcaps, ignoredCaps = capabilities.Split(e.EngineConfig.GetDropCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't drop unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tfor _, capability := range caps {\n\t\tfor i, c := range commonCaps {\n\t\t\tif c == capability {\n\t\t\t\tsylog.Debugf(\"Capability %s dropped\", capability)\n\t\t\t\tcommonCaps = append(commonCaps[:i], commonCaps[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\te.EngineConfig.OciConfig.Process.Capabilities.Permitted = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Effective = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Inheritable = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Bounding = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Ambient = commonCaps\n\n\treturn nil\n}\n\n// prepareRootCaps is responsible for setting root capabilities\n// based on capability/configuration files and requested capabilities.\nfunc (e *EngineOperations) prepareRootCaps() error {\n\tcommonCaps := make([]string, 0)\n\tdefaultCapabilities := e.EngineConfig.File.RootDefaultCapabilities\n\n\tuid := e.EngineConfig.GetTargetUID()\n\tgids := e.EngineConfig.GetTargetGID()\n\n\tif uid != 0 || len(gids) > 0 {\n\t\tdefaultCapabilities = \"no\"\n\t}\n\n\t// is no-privs/keep-privs set on command line\n\tif e.EngineConfig.GetNoPrivs() {\n\t\tsylog.Debugf(\"--no-privs requested, no new privileges enabled\")\n\t\tdefaultCapabilities = \"no\"\n\t} else if e.EngineConfig.GetKeepPrivs() {\n\t\tsylog.Debugf(\"--keep-privs requested\")\n\t\tdefaultCapabilities = \"full\"\n\t}\n\n\tsylog.Debugf(\"Root %s capabilities\", defaultCapabilities)\n\n\t// set default capabilities based on configuration file directive\n\tswitch defaultCapabilities {\n\tcase \"full\":\n\t\te.EngineConfig.OciConfig.SetupPrivileged(true)\n\t\tcommonCaps = e.EngineConfig.OciConfig.Process.Capabilities.Permitted\n\tcase \"file\":\n\t\tfile, err := os.OpenFile(buildcfg.CAPABILITY_FILE, os.O_RDONLY, 0o644)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while opening capability config file: %s\", err)\n\t\t}\n\t\tdefer file.Close()\n\n\t\tcapConfig, err := capabilities.ReadFrom(file)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while parsing capability config data: %s\", err)\n\t\t}\n\n\t\tcommonCaps = append(commonCaps, capConfig.ListUserCaps(\"root\")...)\n\n\t\tgroups, err := os.Getgroups()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while getting groups: %s\", err)\n\t\t}\n\n\t\tfor _, g := range groups {\n\t\t\tgr, err := user.GetGrGID(uint32(g))\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Ignoring group %d: %s\", g, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcaps := capConfig.ListGroupCaps(gr.Name)\n\t\t\tcommonCaps = append(commonCaps, caps...)\n\t\t\tsylog.Debugf(\"%s group capabilities %s added\", gr.Name, strings.Join(caps, \",\"))\n\t\t}\n\tdefault:\n\t\te.EngineConfig.OciConfig.SetProcessNoNewPrivileges(true)\n\t}\n\n\tcaps, ignoredCaps := capabilities.Split(e.EngineConfig.GetAddCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't add unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tfor _, capability := range caps {\n\t\tfound := false\n\t\tfor _, c := range commonCaps {\n\t\t\tif c == capability {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tsylog.Debugf(\"Root capability %s added\", capability)\n\t\t\tcommonCaps = append(commonCaps, capability)\n\t\t}\n\t}\n\n\tcommonCaps = capabilities.RemoveDuplicated(commonCaps)\n\n\tcaps, ignoredCaps = capabilities.Split(e.EngineConfig.GetDropCaps())\n\tif len(ignoredCaps) > 0 {\n\t\tsylog.Warningf(\"won't add unknown capability: %s\", strings.Join(ignoredCaps, \",\"))\n\t}\n\tfor _, capability := range caps {\n\t\tfor i, c := range commonCaps {\n\t\t\tif c == capability {\n\t\t\t\tsylog.Debugf(\"Root capability %s dropped\", capability)\n\t\t\t\tcommonCaps = append(commonCaps[:i], commonCaps[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\te.EngineConfig.OciConfig.Process.Capabilities.Permitted = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Effective = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Inheritable = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Bounding = commonCaps\n\te.EngineConfig.OciConfig.Process.Capabilities.Ambient = commonCaps\n\n\treturn nil\n}\n\nfunc keepAutofsMount(source string, autoFsPoints []string) (int, error) {\n\tresolved, err := filepath.EvalSymlinks(source)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tfor _, p := range autoFsPoints {\n\t\tif strings.HasPrefix(resolved, p) {\n\t\t\tsylog.Debugf(\"Open file descriptor for %s\", resolved)\n\t\t\tf, err := os.Open(resolved)\n\t\t\tif err != nil {\n\t\t\t\treturn -1, err\n\t\t\t}\n\t\t\treturn int(f.Fd()), nil\n\t\t}\n\t}\n\n\treturn -1, fmt.Errorf(\"no mount point\")\n}\n\nfunc (e *EngineOperations) prepareAutofs(starterConfig *starter.Config) error {\n\tconst mountInfoPath = \"/proc/self/mountinfo\"\n\n\tentries, err := proc.GetMountInfoEntry(mountInfoPath)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while parsing %s: %s\", mountInfoPath, err)\n\t}\n\tautoFsPoints := make([]string, 0)\n\tfor _, e := range entries {\n\t\tif e.FSType == \"autofs\" {\n\t\t\tsylog.Debugf(\"Found %q as autofs mount point\", e.Point)\n\t\t\tautoFsPoints = append(autoFsPoints, e.Point)\n\t\t}\n\t}\n\tif len(autoFsPoints) == 0 {\n\t\tsylog.Debugf(\"No autofs mount point found\")\n\t\treturn nil\n\t}\n\n\tfds := make([]int, 0)\n\n\tif e.EngineConfig.File.UserBindControl {\n\t\tfor _, b := range e.EngineConfig.GetBindPath() {\n\t\t\tfd, err := keepAutofsMount(b.Source, autoFsPoints)\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Could not keep file descriptor for user bind path %s: %s\", b.Source, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfds = append(fds, fd)\n\t\t}\n\t}\n\n\tif !e.EngineConfig.GetContain() {\n\t\tfor _, bindpath := range e.EngineConfig.File.BindPath {\n\t\t\tsplitted := strings.Split(bindpath, \":\")\n\n\t\t\tfd, err := keepAutofsMount(splitted[0], autoFsPoints)\n\t\t\tif err != nil {\n\t\t\t\tsylog.Debugf(\"Could not keep file descriptor for bind path %s: %s\", splitted[0], err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfds = append(fds, fd)\n\t\t}\n\n\t\t// check home source directory\n\t\tdir := e.EngineConfig.GetHomeSource()\n\t\tfd, err := keepAutofsMount(dir, autoFsPoints)\n\t\tif err != nil {\n\t\t\tsylog.Debugf(\"Could not keep file descriptor for home directory %s: %s\", dir, err)\n\t\t} else {\n\t\t\tfds = append(fds, fd)\n\t\t}\n\n\t\t// check the current working directory\n\t\tdir = e.EngineConfig.GetCwd()\n\t\tfd, err = keepAutofsMount(dir, autoFsPoints)\n\t\tif err != nil {\n\t\t\tsylog.Debugf(\"Could not keep file descriptor for current working directory %s: %s\", dir, err)\n\t\t} else {\n\t\t\tfds = append(fds, fd)\n\t\t}\n\t} else {\n\t\t// check workdir\n\t\tdir := e.EngineConfig.GetWorkdir()\n\t\tfd, err := keepAutofsMount(dir, autoFsPoints)\n\t\tif err != nil {\n\t\t\tsylog.Debugf(\"Could not keep file descriptor for workdir %s: %s\", dir, err)\n\t\t} else {\n\t\t\tfds = append(fds, fd)\n\t\t}\n\t}\n\n\tfor _, f := range fds {\n\t\tif err := starterConfig.KeepFileDescriptor(f); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\te.EngineConfig.SetOpenFd(fds)\n\n\treturn nil\n}\n\n// prepareContainerConfig is responsible for getting and applying\n// user supplied configuration for container creation.\nfunc (e *EngineOperations) prepareContainerConfig(starterConfig *starter.Config) error {\n\t// always set mount namespace\n\te.EngineConfig.OciConfig.AddOrReplaceLinuxNamespace(specs.MountNamespace, \"\")\n\n\t// if PID namespace is not allowed remove it from namespaces\n\tif !e.EngineConfig.File.AllowPidNs && e.EngineConfig.OciConfig.Linux != nil {\n\t\tnamespaces := e.EngineConfig.OciConfig.Linux.Namespaces\n\t\tfor i, ns := range namespaces {\n\t\t\tif ns.Type == specs.PIDNamespace {\n\t\t\t\tsylog.Debugf(\"Not virtualizing PID namespace by configuration\")\n\t\t\t\te.EngineConfig.OciConfig.Linux.Namespaces = append(namespaces[:i], namespaces[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif os.Getuid() == 0 {\n\t\tif err := e.prepareRootCaps(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tenforced := starterConfig.GetIsSUID()\n\t\tif err := e.prepareUserCaps(enforced); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif e.EngineConfig.File.MountSlave {\n\t\tstarterConfig.SetMountPropagation(\"rslave\")\n\t} else {\n\t\tstarterConfig.SetMountPropagation(\"rprivate\")\n\t}\n\n\tif e.EngineConfig.GetFakeroot() {\n\t\tuid := uint32(os.Getuid())\n\t\tgid := uint32(os.Getgid())\n\n\t\tif !starterConfig.GetIsSUID() && fakerootutil.IsUIDMapped(uid) {\n\t\t\t// no SUID workflow, check if newuidmap/newgidmap are present\n\t\t\tsylog.Verbosef(\"Fakeroot requested with unprivileged workflow, fallback to newuidmap/newgidmap\")\n\t\t\tsylog.Debugf(\"Search for newuidmap binary\")\n\t\t\tif err := starterConfig.SetNewUIDMapPath(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsylog.Debugf(\"Search for newgidmap binary\")\n\t\t\tif err := starterConfig.SetNewGIDMapPath(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tgetIDRange := fakerootutil.GetIDRange\n\n\t\tcallbackType := (fakerootcallback.UserMapping)(nil)\n\t\tcallbacks, err := plugin.LoadCallbacks(callbackType)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while loading plugins callbacks '%T': %s\", callbackType, err)\n\t\t}\n\t\tif len(callbacks) > 1 {\n\t\t\treturn fmt.Errorf(\"multiple plugins have registered hook callback for fakeroot\")\n\t\t} else if len(callbacks) == 1 {\n\t\t\tgetIDRange = callbacks[0].(fakerootcallback.UserMapping)\n\t\t}\n\n\t\te.EngineConfig.OciConfig.AddLinuxUIDMapping(uid, 0, 1)\n\t\tidRange, err := getIDRange(fakerootutil.SubUIDFile, uid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not use fakeroot: %s\", err)\n\t\t}\n\t\te.EngineConfig.OciConfig.AddLinuxUIDMapping(idRange.HostID, idRange.ContainerID, idRange.Size)\n\t\tstarterConfig.AddUIDMappings(e.EngineConfig.OciConfig.Linux.UIDMappings)\n\n\t\te.EngineConfig.OciConfig.AddLinuxGIDMapping(gid, 0, 1)\n\t\tidRange, err = getIDRange(fakerootutil.SubGIDFile, uid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not use fakeroot: %s\", err)\n\t\t}\n\t\te.EngineConfig.OciConfig.AddLinuxGIDMapping(idRange.HostID, idRange.ContainerID, idRange.Size)\n\t\tstarterConfig.AddGIDMappings(e.EngineConfig.OciConfig.Linux.GIDMappings)\n\n\t\te.EngineConfig.OciConfig.SetupPrivileged(true)\n\n\t\te.EngineConfig.OciConfig.AddOrReplaceLinuxNamespace(specs.UserNamespace, \"\")\n\n\t\tstarterConfig.SetHybridWorkflow(true)\n\t\tstarterConfig.SetAllowSetgroups(true)\n\n\t\tstarterConfig.SetTargetUID(0)\n\t\tstarterConfig.SetTargetGID([]int{0})\n\t}\n\n\tstarterConfig.SetBringLoopbackInterface(true)\n\n\tstarterConfig.SetInstance(e.EngineConfig.GetInstance())\n\n\tstarterConfig.SetNsFlagsFromSpec(e.EngineConfig.OciConfig.Linux.Namespaces)\n\n\t// user namespace ID mappings\n\tif e.EngineConfig.OciConfig.Linux != nil {\n\t\tif err := starterConfig.AddUIDMappings(e.EngineConfig.OciConfig.Linux.UIDMappings); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := starterConfig.AddGIDMappings(e.EngineConfig.OciConfig.Linux.GIDMappings); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tparam := security.GetParam(e.EngineConfig.GetSecurity(), \"selinux\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying SELinux context %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessSelinuxLabel(param)\n\t}\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"apparmor\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying Apparmor profile %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessApparmorProfile(param)\n\t}\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"seccomp\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying seccomp rule from %s\", param)\n\t\tgenerator := &e.EngineConfig.OciConfig.Generator\n\t\tif err := seccomp.LoadProfileFromFile(param, generator); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// open file descriptors (autofs bug path)\n\treturn e.prepareAutofs(starterConfig)\n}\n\n// prepareInstanceJoinConfig is responsible for getting and\n// applying configuration to join a running instance.\n//nolint:maintidx\nfunc (e *EngineOperations) prepareInstanceJoinConfig(starterConfig *starter.Config) error {\n\tname := instance.ExtractName(e.EngineConfig.GetImage())\n\tfile, err := instance.Get(name, instance.AppSubDir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tuid := os.Getuid()\n\tgid := os.Getgid()\n\tsuidRequired := uid != 0 && !file.UserNs\n\n\t// basic checks:\n\t// 1. a user must not use SUID workflow to join an instance\n\t//    started with user namespace\n\t// 2. a user must use SUID workflow to join an instance\n\t//    started without user namespace\n\tif starterConfig.GetIsSUID() && !suidRequired {\n\t\treturn fmt.Errorf(\"joining user namespace with suid workflow is not allowed\")\n\t} else if !starterConfig.GetIsSUID() && suidRequired {\n\t\treturn fmt.Errorf(\"a setuid installation is required to join this instance\")\n\t}\n\n\t// Pid and PPid are stored in instance file and can be controlled\n\t// by users, check to make sure these values are sane\n\tif file.Pid <= 1 || file.PPid <= 1 {\n\t\treturn fmt.Errorf(\"bad instance process ID found\")\n\t}\n\n\t// instance configuration holding configuration read\n\t// from instance file\n\tinstanceEngineConfig := apptainerConfig.NewConfig()\n\n\t// extract engine configuration from instance file, the whole content\n\t// of this file can't be trusted\n\tinstanceConfig := &config.Common{\n\t\tEngineConfig: instanceEngineConfig,\n\t}\n\tif err := json.Unmarshal(file.Config, instanceConfig); err != nil {\n\t\treturn err\n\t}\n\n\t// configuration may be altered, be sure to not panic\n\tif instanceEngineConfig.OciConfig.Linux == nil {\n\t\tinstanceEngineConfig.OciConfig.Linux = &specs.Linux{}\n\t}\n\n\t// go into /proc/<pid> directory to open namespaces inodes\n\t// relative to current working directory while joining\n\t// namespaces within C starter code as changing directory\n\t// here will also affects starter process thanks to\n\t// SetWorkingDirectoryFd call.\n\t// Additionally it would prevent TOCTOU races and symlink\n\t// usage.\n\t// And if instance process exits during checks or while\n\t// entering in namespace, we would get a \"no such process\"\n\t// error because current working directory would point to a\n\t// deleted inode: \"/proc/self/cwd -> /proc/<pid> (deleted)\"\n\tpath := filepath.Join(\"/proc\", strconv.Itoa(file.Pid))\n\tfd, err := syscall.Open(path, syscall.O_RDONLY|syscall.O_DIRECTORY, 0)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not open proc directory %s: %s\", path, err)\n\t}\n\tif err := mainthread.Fchdir(fd); err != nil {\n\t\treturn err\n\t}\n\t// will set starter (via fchdir too) in the same proc directory\n\t// in order to open namespace inodes with relative paths for the\n\t// right process\n\tstarterConfig.SetWorkingDirectoryFd(fd)\n\n\t// enforce checks while joining an instance process with SUID workflow\n\t// since instance file is stored in user home directory, we can't trust\n\t// its content when using SUID workflow\n\tif suidRequired {\n\t\t// check if instance is running with user namespace enabled\n\t\t// by reading /proc/pid/uid_map\n\t\t_, hid, err := proc.ReadIDMap(\"uid_map\")\n\n\t\t// if the error returned is \"no such file or directory\" it means\n\t\t// that user namespaces are not supported, just skip this check\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\treturn fmt.Errorf(\"failed to read user namespace mapping: %s\", err)\n\t\t} else if err == nil && hid > 0 {\n\t\t\t// a host uid greater than 0 means user namespace is in use for this process\n\t\t\treturn fmt.Errorf(\"trying to join an instance running with user namespace enabled\")\n\t\t}\n\n\t\t// read \"/proc/pid/root\" link of instance process must return\n\t\t// a permission denied error.\n\t\t// This is the \"appinit\" process (PID 1 in container) and it inherited\n\t\t// setuid bit, so most of \"/proc/pid\" entries are owned by root:root\n\t\t// like \"/proc/pid/root\" link even if the process has dropped all\n\t\t// privileges and run with user UID/GID. So we expect a \"permission denied\"\n\t\t// error when reading link.\n\t\tif _, err := mainthread.Readlink(\"root\"); !os.IsPermission(err) {\n\t\t\treturn fmt.Errorf(\"trying to join a wrong instance process\")\n\t\t}\n\t\t// Since we could be tricked to join namespaces of a root owned process,\n\t\t// we will get UID/GID information of task directory to be sure it belongs\n\t\t// to the user currently joining the instance. Also ensure that a user won't\n\t\t// be able to join other user's instances.\n\t\tfi, err := os.Stat(\"task\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error while getting information for instance task directory: %s\", err)\n\t\t}\n\t\tst := fi.Sys().(*syscall.Stat_t)\n\t\tif st.Uid != uint32(uid) || st.Gid != uint32(gid) {\n\t\t\treturn fmt.Errorf(\"instance process owned by %d:%d instead of %d:%d\", st.Uid, st.Gid, uid, gid)\n\t\t}\n\n\t\tppid := -1\n\n\t\t// read \"/proc/pid/status\" to check if instance process\n\t\t// is neither orphaned or faked\n\t\tf, err := os.Open(\"status\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not open status: %s\", err)\n\t\t}\n\n\t\tfor s := bufio.NewScanner(f); s.Scan(); {\n\t\t\tif n, _ := fmt.Sscanf(s.Text(), \"PPid:\\t%d\", &ppid); n == 1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tf.Close()\n\n\t\t// check that Ppid/Pid read from instance file are \"somewhat\" valid\n\t\t// processes\n\t\tif ppid <= 1 || ppid != file.PPid {\n\t\t\treturn fmt.Errorf(\"orphaned (or faked) instance process\")\n\t\t}\n\n\t\t// read \"/proc/ppid/root\" link of parent instance process must return\n\t\t// a permission denied error (same logic than \"appinit\" process).\n\t\t// Also we don't use absolute path because we want to return an error\n\t\t// if current working directory is deleted meaning that instance process\n\t\t// exited.\n\t\tpath := filepath.Join(\"..\", strconv.Itoa(file.PPid), \"root\")\n\t\tif _, err := mainthread.Readlink(path); !os.IsPermission(err) {\n\t\t\treturn fmt.Errorf(\"trying to join a wrong instance process\")\n\t\t}\n\t\t// \"/proc/ppid/task\" directory must be owned by user UID/GID\n\t\tpath = filepath.Join(\"..\", strconv.Itoa(file.PPid), \"task\")\n\t\tfi, err = os.Stat(path)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error while getting information for parent task directory: %s\", err)\n\t\t}\n\t\tst = fi.Sys().(*syscall.Stat_t)\n\t\tif st.Uid != uint32(uid) || st.Gid != uint32(gid) {\n\t\t\treturn fmt.Errorf(\"parent instance process owned by %d:%d instead of %d:%d\", st.Uid, st.Gid, uid, gid)\n\t\t}\n\n\t\tpath, err = filepath.Abs(\"comm\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine absolute path for comm: %s\", err)\n\t\t}\n\n\t\t// we must read \"appinit\\n\"\n\t\tb, err := ioutil.ReadFile(\"comm\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to read %s: %s\", path, err)\n\t\t}\n\t\t// check that we are currently joining appinit process\n\t\tif \"appinit\" != strings.Trim(string(b), \"\\n\") {\n\t\t\treturn fmt.Errorf(\"appinit not found in %s, wrong instance process\", path)\n\t\t}\n\t}\n\n\t// tell starter that we are joining an instance\n\tstarterConfig.SetNamespaceJoinOnly(true)\n\n\t// update namespaces path relative to /proc/<pid>\n\t// since starter process is in /proc/<pid> directory\n\tfor i := range instanceEngineConfig.OciConfig.Linux.Namespaces {\n\t\t// ignore unknown namespaces\n\t\tt := instanceEngineConfig.OciConfig.Linux.Namespaces[i].Type\n\t\tif _, ok := nsProcName[t]; !ok {\n\t\t\tcontinue\n\t\t}\n\t\t// set namespace relative path\n\t\tinstanceEngineConfig.OciConfig.Linux.Namespaces[i].Path = filepath.Join(\"ns\", nsProcName[t])\n\t}\n\n\t// store namespace paths in starter configuration that will\n\t// be passed via a shared memory area and used by starter C code\n\t// once this process exit\n\tif err := starterConfig.SetNsPathFromSpec(instanceEngineConfig.OciConfig.Linux.Namespaces); err != nil {\n\t\treturn err\n\t}\n\n\t// duplicate instance capabilities\n\tif instanceEngineConfig.OciConfig.Process != nil && instanceEngineConfig.OciConfig.Process.Capabilities != nil {\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Permitted = instanceEngineConfig.OciConfig.Process.Capabilities.Permitted\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Effective = instanceEngineConfig.OciConfig.Process.Capabilities.Effective\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Inheritable = instanceEngineConfig.OciConfig.Process.Capabilities.Inheritable\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Bounding = instanceEngineConfig.OciConfig.Process.Capabilities.Bounding\n\t\te.EngineConfig.OciConfig.Process.Capabilities.Ambient = instanceEngineConfig.OciConfig.Process.Capabilities.Ambient\n\t}\n\n\t// check if user is authorized to set those capabilities and remove\n\t// unauthorized capabilities from current set according to capability\n\t// configuration file\n\tif uid == 0 {\n\t\tif err := e.prepareRootCaps(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := e.prepareUserCaps(suidRequired); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// set UID/GID for the fakeroot context\n\tif instanceEngineConfig.GetFakeroot() {\n\t\tstarterConfig.SetTargetUID(0)\n\t\tstarterConfig.SetTargetGID([]int{0})\n\t}\n\n\t// restore HOME environment variable to match the\n\t// one set during instance start\n\te.EngineConfig.OciConfig.SetProcessEnv(\"HOME\", instanceEngineConfig.GetHomeDest())\n\n\t// restore apparmor profile or apply a new one if provided\n\tparam := security.GetParam(e.EngineConfig.GetSecurity(), \"apparmor\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying Apparmor profile %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessApparmorProfile(param)\n\t} else {\n\t\te.EngineConfig.OciConfig.SetProcessApparmorProfile(instanceEngineConfig.OciConfig.Process.ApparmorProfile)\n\t}\n\n\t// restore selinux context or apply a new one if provided\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"selinux\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying SELinux context %s\", param)\n\t\te.EngineConfig.OciConfig.SetProcessSelinuxLabel(param)\n\t} else {\n\t\te.EngineConfig.OciConfig.SetProcessSelinuxLabel(instanceEngineConfig.OciConfig.Process.SelinuxLabel)\n\t}\n\n\t// restore seccomp filter or apply a new one if provided\n\tparam = security.GetParam(e.EngineConfig.GetSecurity(), \"seccomp\")\n\tif param != \"\" {\n\t\tsylog.Debugf(\"Applying seccomp rule from %s\", param)\n\t\tgenerator := &e.EngineConfig.OciConfig.Generator\n\t\tif err := seccomp.LoadProfileFromFile(param, generator); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif e.EngineConfig.OciConfig.Linux == nil {\n\t\t\te.EngineConfig.OciConfig.Linux = &specs.Linux{}\n\t\t}\n\t\te.EngineConfig.OciConfig.Linux.Seccomp = instanceEngineConfig.OciConfig.Linux.Seccomp\n\t}\n\n\tif file.Cgroup {\n\t\tsylog.Debugf(\"Adding process to instance cgroup\")\n\t\tppid := os.Getppid()\n\t\tmanager, err := cgroups.GetManagerForPid(file.Pid)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't create cgroup manager: %v\", err)\n\t\t}\n\t\tif err := manager.AddProc(ppid); err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't add process to instance cgroup: %v\", err)\n\t\t}\n\t}\n\n\t// only root user can set this value based on instance file\n\t// and always set to true for normal users or if instance file\n\t// returned a wrong configuration\n\tif uid == 0 && instanceEngineConfig.OciConfig.Process != nil {\n\t\te.EngineConfig.OciConfig.Process.NoNewPrivileges = instanceEngineConfig.OciConfig.Process.NoNewPrivileges\n\t} else {\n\t\te.EngineConfig.OciConfig.Process.NoNewPrivileges = true\n\t}\n\n\treturn nil\n}\n\n// openDevFuse is a helper function that opens /dev/fuse once for each\n// plugin that wants to mount a FUSE filesystem.\nfunc openDevFuse(e *EngineOperations, starterConfig *starter.Config) (bool, error) {\n\t// do we require to send file descriptor\n\tsendFd := false\n\n\t// we won't copy slice while iterating fuse mounts\n\tmounts := e.EngineConfig.GetFuseMount()\n\n\tif len(mounts) == 0 {\n\t\treturn false, nil\n\t}\n\n\tif !e.EngineConfig.File.EnableFusemount {\n\t\treturn false, fmt.Errorf(\"fusemount disabled by configuration 'enable fusemount = no'\")\n\t}\n\n\tfor i := range mounts {\n\t\tsylog.Debugf(\"Opening /dev/fuse for FUSE mount point %s\\n\", mounts[i].MountPoint)\n\t\tfd, err := syscall.Open(\"/dev/fuse\", syscall.O_RDWR, 0)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tmounts[i].Fd = fd\n\t\tstarterConfig.KeepFileDescriptor(fd)\n\n\t\tif (!starterConfig.GetIsSUID() || e.EngineConfig.GetFakeroot()) && !mounts[i].FromContainer {\n\t\t\tsendFd = true\n\t\t}\n\t}\n\n\treturn sendFd, nil\n}\n\nfunc (e *EngineOperations) checkSignalPropagation() {\n\t// obtain the process group ID of the associated controlling\n\t// terminal (if there's one).\n\tpgrp := 0\n\tfor i := 0; i <= 2; i++ {\n\t\t// The two possible errors:\n\t\t// - EBADF will return 0 as process group\n\t\t// - ENOTTY will also return 0 as process group\n\t\tpgrp, _ = unix.IoctlGetInt(i, unix.TIOCGPGRP)\n\t\t// based on kernel source a 0 value for process group\n\t\t// theoretically be set but really not sure it can happen\n\t\t// with linux tty behavior\n\t\tif pgrp != 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\t// cases we need to propagate signals to container process:\n\t// - when pgrp == 0 because container won't run in a terminal\n\t// - when process group is different from the process group controlling terminal\n\tif pgrp == 0 || (pgrp > 0 && pgrp != syscall.Getpgrp()) {\n\t\te.EngineConfig.SetSignalPropagation(true)\n\t}\n}\n\n// setSessionLayer will test if overlay is supported/allowed.\nfunc (e *EngineOperations) setSessionLayer(img *image.Image) error {\n\te.EngineConfig.SetSessionLayer(apptainerConfig.DefaultLayer)\n\n\twritableTmpfs := e.EngineConfig.GetWritableTmpfs()\n\twritableImage := e.EngineConfig.GetWritableImage()\n\thasOverlayImage := len(e.EngineConfig.GetOverlayImage()) > 0\n\toverlayDriver := e.EngineConfig.File.EnableOverlay == \"driver\"\n\n\tif writableImage && hasOverlayImage {\n\t\treturn fmt.Errorf(\"cannot use --overlay in conjunction with --writable\")\n\t}\n\n\t// a SIF image may contain one or more overlay partition\n\t// check there is at least one ext3 overlay partition\n\t// to validate overlay with writable flag\n\thasSIFOverlay := false\n\n\tif img.Type == image.SIF {\n\t\toverlays, err := img.GetOverlayPartitions()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while getting overlay partition in SIF image %s: %s\", img.Path, err)\n\t\t}\n\t\tfor _, o := range overlays {\n\t\t\tif o.Type == image.EXT3 {\n\t\t\t\thasSIFOverlay = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif overlayDriver {\n\t\t// overlay is always handled by the image driver\n\t\tif e.EngineConfig.File.ImageDriver == \"\" {\n\t\t\treturn fmt.Errorf(\"you need to specify an image driver with 'enable overlay = driver'\")\n\t\t}\n\t\tif !writableImage || hasSIFOverlay {\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\treturn nil\n\t}\n\n\t// Check for implicit user namespace, e.g when we run %test in a fakeroot build\n\t// https://github.com/apptainer/singularity/issues/5315\n\tuserNS, _ := namespaces.IsInsideUserNamespace(os.Getpid())\n\n\t// NEED FIX: on ubuntu until 4.15 kernel it was possible to mount overlay\n\t// with the current workflow, since 4.18 we get an operation not permitted\n\tif !userNS {\n\t\tfor _, ns := range e.EngineConfig.OciConfig.Linux.Namespaces {\n\t\t\tif ns.Type == specs.UserNamespace {\n\t\t\t\tuserNS = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif userNS {\n\t\tif writableTmpfs || hasOverlayImage {\n\t\t\tsylog.Debugf(\"Overlay requested while in user namespace\")\n\t\t\t// Try overlay although it will only work if the image driver or the\n\t\t\t//  kernel support unprivileged overlay\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tif hasSIFOverlay {\n\t\t\tsylog.Debugf(\"Overlay partition found while in user namespace\")\n\t\t\t// Likewise try the overlay because of the partition\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tif !e.EngineConfig.File.EnableUnderlay {\n\t\t\tsylog.Debugf(\"Not attempting to use underlay with user namespace: disabled by configuration ('enable underlay = no')\")\n\t\t\treturn nil\n\t\t}\n\t\tif !writableImage {\n\t\t\tsylog.Debugf(\"Using underlay layer: user namespace requested\")\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.UnderlayLayer)\n\t\t\treturn nil\n\t\t}\n\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\treturn nil\n\t}\n\n\t// starter was forced to load overlay module, now check if there\n\t// is an overlay entry in /proc/filesystems\n\tif has, _ := proc.HasFilesystem(\"overlay\"); has {\n\t\tsylog.Debugf(\"Overlay seems supported and allowed by kernel\")\n\t\tswitch e.EngineConfig.File.EnableOverlay {\n\t\tcase \"yes\", \"try\":\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.OverlayLayer)\n\n\t\t\tif !writableImage || hasSIFOverlay {\n\t\t\t\tsylog.Debugf(\"Attempting to use overlayfs (enable overlay = %v)\\n\", e.EngineConfig.File.EnableOverlay)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\t\te.EngineConfig.SetSessionLayer(apptainerConfig.DefaultLayer)\n\t\t\treturn nil\n\t\tdefault:\n\t\t\tif hasOverlayImage {\n\t\t\t\treturn fmt.Errorf(\"overlay images requires 'enable overlay = yes', but set to 'no' by administrator\")\n\t\t\t}\n\t\t\tif writableTmpfs {\n\t\t\t\treturn fmt.Errorf(\"--writable-tmpfs requires 'enable overlay = yes', but set to 'no' by administrator\")\n\t\t\t}\n\t\t\tsylog.Debugf(\"Could not use overlay, disabled by configuration ('enable overlay = no')\")\n\t\t}\n\t} else {\n\t\tif writableTmpfs {\n\t\t\treturn fmt.Errorf(\"--writable-tmpfs requires overlay kernel support: your kernel doesn't support it\")\n\t\t}\n\t\tif hasOverlayImage {\n\t\t\treturn fmt.Errorf(\"overlay images requires overlay kernel support: your kernel doesn't support it\")\n\t\t}\n\t}\n\n\t// if --writable wasn't set, use underlay if possible\n\tif !writableImage && e.EngineConfig.File.EnableUnderlay {\n\t\tsylog.Debugf(\"Attempting to use underlay (enable underlay = yes)\\n\")\n\t\te.EngineConfig.SetSessionLayer(apptainerConfig.UnderlayLayer)\n\t\treturn nil\n\t} else if writableImage {\n\t\tsylog.Debugf(\"Not attempting to use overlay or underlay: writable flag requested\")\n\t\treturn nil\n\t}\n\n\tsylog.Debugf(\"Not attempting to use overlay or underlay: both disabled by administrator\")\n\treturn nil\n}\n\nfunc (e *EngineOperations) loadImages(starterConfig *starter.Config, userNS bool) error {\n\timages := make([]image.Image, 0)\n\n\t// load rootfs image\n\twritable := e.EngineConfig.GetWritableImage()\n\timg, err := e.loadImage(e.EngineConfig.GetImage(), writable, userNS)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trootFs, err := img.GetRootFsPartition()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while getting root filesystem partition in %s: %s\", e.EngineConfig.GetImage(), err)\n\t}\n\n\tif writable && !img.Writable {\n\t\treturn fmt.Errorf(\"could not use %s for writing, you don't have write permissions\", img.Path)\n\t}\n\n\tif err := e.setSessionLayer(img); err != nil {\n\t\treturn err\n\t}\n\n\t// first image is always the root filesystem\n\timages = append(images, *img)\n\twritableOverlayPath := \"\"\n\n\tif err := starterConfig.KeepFileDescriptor(int(img.Fd)); err != nil {\n\t\treturn err\n\t}\n\n\t// sandbox are handled differently for security reasons\n\tif img.Type == image.SANDBOX {\n\t\tif img.Path == \"/\" {\n\t\t\treturn fmt.Errorf(\"/ as sandbox is not authorized\")\n\t\t}\n\n\t\t// C starter code will position current working directory\n\t\tstarterConfig.SetWorkingDirectoryFd(int(img.Fd))\n\n\t\tif e.EngineConfig.GetSessionLayer() == apptainerConfig.OverlayLayer &&\n\t\t\t(imageDriver == nil || imageDriver.Features()&image.OverlayFeature == 0) {\n\t\t\tif err := overlay.CheckLower(img.Path); overlay.IsIncompatible(err) {\n\t\t\t\tlayer := apptainerConfig.UnderlayLayer\n\t\t\t\tif !e.EngineConfig.File.EnableUnderlay {\n\t\t\t\t\tsylog.Warningf(\"Could not fallback to underlay, disabled by configuration ('enable underlay = no')\")\n\t\t\t\t\tlayer = apptainerConfig.DefaultLayer\n\t\t\t\t}\n\t\t\t\te.EngineConfig.SetSessionLayer(layer)\n\n\t\t\t\t// show a warning message if --writable-tmpfs or overlay images\n\t\t\t\t// are requested otherwise make it verbose to not annoy users\n\t\t\t\tif e.EngineConfig.GetWritableTmpfs() || len(e.EngineConfig.GetOverlayImage()) > 0 {\n\t\t\t\t\tsylog.Warningf(\"Fallback to %s layer: %s\", layer, err)\n\n\t\t\t\t\tif e.EngineConfig.GetWritableTmpfs() {\n\t\t\t\t\t\te.EngineConfig.SetWritableTmpfs(false)\n\t\t\t\t\t\tsylog.Warningf(\"--writable-tmpfs disabled due to sandbox filesystem incompatibility with overlay\")\n\t\t\t\t\t}\n\t\t\t\t\tif len(e.EngineConfig.GetOverlayImage()) > 0 {\n\t\t\t\t\t\te.EngineConfig.SetOverlayImage(nil)\n\t\t\t\t\t\tsylog.Warningf(\"overlay image(s) not loaded due to sandbox filesystem incompatibility with overlay\")\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsylog.Verbosef(\"Fallback to %s layer: %s\", layer, err)\n\t\t\t\t}\n\t\t\t} else if err != nil {\n\t\t\t\treturn fmt.Errorf(\"while checking image compatibility with overlay: %s\", err)\n\t\t\t}\n\t\t}\n\t} else if img.Type == image.SIF {\n\t\t// query the ECL module, proceed if an ecl config file is found\n\t\tecl, err := syecl.LoadConfig(buildcfg.ECL_FILE)\n\t\tif err == nil {\n\t\t\tif err = ecl.ValidateConfig(); err != nil {\n\t\t\t\treturn fmt.Errorf(\"while validating ECL configuration: %s\", err)\n\t\t\t}\n\n\t\t\t// Only try to load the global keyring here if the ECL is active.\n\t\t\t// Otherwise pass through an empty keyring rather than avoiding calling\n\t\t\t// the ECL functions as this keeps the logic for applying / ignoring ECL in a\n\t\t\t// single location.\n\t\t\tvar kr openpgp.KeyRing = openpgp.EntityList{}\n\t\t\tif ecl.Activated {\n\t\t\t\tkeyring := sypgp.NewHandle(buildcfg.APPTAINER_CONFDIR, sypgp.GlobalHandleOpt())\n\t\t\t\tkr, err = keyring.LoadPubKeyring()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"while obtaining keyring for ECL: %s\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ok, err := ecl.ShouldRunFp(img.File, kr); err != nil {\n\t\t\t\treturn fmt.Errorf(\"while checking container image with ECL: %s\", err)\n\t\t\t} else if !ok {\n\t\t\t\treturn errors.New(\"image prohibited by ECL\")\n\t\t\t}\n\t\t}\n\n\t\t// look for potential overlay partition in SIF image\n\t\tif e.EngineConfig.GetSessionLayer() == apptainerConfig.OverlayLayer {\n\t\t\toverlays, err := img.GetOverlayPartitions()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"while getting overlay partitions in %s: %s\", img.Path, err)\n\t\t\t}\n\t\t\tfor _, p := range overlays {\n\t\t\t\tif p.Type != image.EXT3 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif !userNS && !e.EngineConfig.File.AllowSetuidMountExtfs {\n\t\t\t\t\treturn fmt.Errorf(\"configuration disallows users from mounting SIF extfs partition in setuid mode, try --userns\")\n\t\t\t\t}\n\t\t\t\tif img.Writable {\n\t\t\t\t\twritableOverlayPath = img.Path\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// SIF image open for writing without writable\n\t\t// overlay partition, assuming that the root\n\t\t// filesystem is squashfs or encrypted squashfs\n\t\tif img.Writable && rootFs.Type != image.EXT3 && writableOverlayPath == \"\" {\n\t\t\treturn fmt.Errorf(\"no SIF writable overlay partition found in %s\", img.Path)\n\t\t}\n\t}\n\n\tswitch e.EngineConfig.GetSessionLayer() {\n\tcase apptainerConfig.OverlayLayer:\n\t\toverlayImages, err := e.loadOverlayImages(starterConfig, writableOverlayPath, userNS)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"while loading overlay images: %s\", err)\n\t\t}\n\t\timages = append(images, overlayImages...)\n\tcase apptainerConfig.UnderlayLayer:\n\t\tif e.EngineConfig.GetWritableTmpfs() {\n\t\t\tsylog.Warningf(\"Disabling --writable-tmpfs as it can't be used in conjunction with underlay\")\n\t\t\te.EngineConfig.SetWritableTmpfs(false)\n\t\t}\n\t}\n\n\tbindImages, err := e.loadBindImages(starterConfig, userNS)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"while loading data bind images: %s\", err)\n\t}\n\timages = append(images, bindImages...)\n\n\te.EngineConfig.SetImageList(images)\n\n\treturn nil\n}\n\n// loadOverlayImages loads overlay images.\nfunc (e *EngineOperations) loadOverlayImages(starterConfig *starter.Config, writableOverlayPath string, userNS bool) ([]image.Image, error) {\n\timages := make([]image.Image, 0)\n\n\tfor _, overlayImg := range e.EngineConfig.GetOverlayImage() {\n\t\twritableOverlay := true\n\n\t\tsplitted := strings.SplitN(overlayImg, \":\", 2)\n\t\tif len(splitted) == 2 {\n\t\t\tif splitted[1] == \"ro\" {\n\t\t\t\twritableOverlay = false\n\t\t\t}\n\t\t}\n\n\t\timg, err := e.loadImage(splitted[0], writableOverlay, userNS)\n\t\tif err != nil {\n\t\t\tif !image.IsReadOnlyFilesytem(err) {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to open overlay image %s: %s\", splitted[0], err)\n\t\t\t}\n\t\t\t// let's proceed with readonly filesystem and set\n\t\t\t// writableOverlay to appropriate value\n\t\t\twritableOverlay = false\n\t\t}\n\t\timg.Usage = image.OverlayUsage\n\n\t\tif writableOverlay && img.Writable {\n\t\t\tif writableOverlayPath != \"\" {\n\t\t\t\treturn nil, fmt.Errorf(\n\t\t\t\t\t\"you can't specify more than one writable overlay, \"+\n\t\t\t\t\t\t\"%s contains a writable overlay, requires to use '--overlay %s:ro'\",\n\t\t\t\t\twritableOverlayPath, img.Path,\n\t\t\t\t)\n\t\t\t}\n\t\t\twritableOverlayPath = img.Path\n\t\t}\n\n\t\tif err := starterConfig.KeepFileDescriptor(int(img.Fd)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\timages = append(images, *img)\n\t}\n\n\tif e.EngineConfig.GetWritableTmpfs() && writableOverlayPath != \"\" {\n\t\treturn nil, fmt.Errorf(\"you can't specify --writable-tmpfs with another writable overlay image (%s)\", writableOverlayPath)\n\t}\n\n\treturn images, nil\n}\n\n// loadBindImages load data bind images.\nfunc (e *EngineOperations) loadBindImages(starterConfig *starter.Config, userNS bool) ([]image.Image, error) {\n\timages := make([]image.Image, 0)\n\n\tbinds := e.EngineConfig.GetBindPath()\n\n\tfor i := range binds {\n\t\tif binds[i].ImageSrc() == \"\" && binds[i].ID() == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\timagePath := binds[i].Source\n\n\t\tsylog.Debugf(\"Loading data image %s\", imagePath)\n\n\t\timg, err := e.loadImage(imagePath, !binds[i].Readonly(), userNS)\n\t\tif err != nil && !image.IsReadOnlyFilesytem(err) {\n\t\t\treturn nil, fmt.Errorf(\"failed to load data image %s: %s\", imagePath, err)\n\t\t}\n\t\timg.Usage = image.DataUsage\n\n\t\tif err := starterConfig.KeepFileDescriptor(int(img.Fd)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\timages = append(images, *img)\n\t\tbinds[i].Source = img.Source\n\t}\n\n\treturn images, nil\n}\n\nfunc (e *EngineOperations) loadImage(path string, writable bool, userNS bool) (*image.Image, error) {\n\tconst delSuffix = \" (deleted)\"\n\n\timgObject, imgErr := image.Init(path, writable)\n\t// pass imgObject if not nil for overlay and read-only filesystem error.\n\t// Do not remove this line\n\tif imgObject == nil {\n\t\tif imgErr == nil {\n\t\t\timgErr = errors.New(\"nil imageObject\")\n\t\t}\n\t\treturn nil, imgErr\n\t}\n\n\t// get the real path from /proc/self/fd/X\n\timgTarget, err := mainthread.Readlink(imgObject.Source)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"while reading symlink %s: %s\", imgObject.Source, err)\n\t}\n\t// imgObject.Path is the resolved path provided to image.Init and imgTarget point\n\t// to the opened path, if they are not identical (for some obscure reasons) we use\n\t// the resolved path from /proc/self/fd/X\n\tif imgObject.Path != imgTarget {\n\t\t// With some kernel/filesystem combination the symlink target of /proc/self/fd/X\n\t\t// may return a path with the suffix \" (deleted)\" even if not deleted, we just\n\t\t// remove it because it won't impact ACL path check\n\t\tfinalTarget := strings.TrimSuffix(imgTarget, delSuffix)\n\t\tsylog.Debugf(\"Replacing image resolved path %s by %s\", imgObject.Path, finalTarget)\n\t\timgObject.Path = finalTarget\n\t}\n\n\tif len(e.EngineConfig.File.LimitContainerPaths) != 0 {\n\t\tif authorized, err := imgObject.AuthorizedPath(e.EngineConfig.File.LimitContainerPaths); err != nil {\n\t\t\treturn nil, err\n\t\t} else if !authorized {\n\t\t\treturn nil, fmt.Errorf(\"apptainer image is not in an allowed configured path\")\n\t\t}\n\t}\n\tif len(e.EngineConfig.File.LimitContainerGroups) != 0 {\n\t\tif authorized, err := imgObject.AuthorizedGroup(e.EngineConfig.File.LimitContainerGroups); err != nil {\n\t\t\treturn nil, err\n\t\t} else if !authorized {\n\t\t\treturn nil, fmt.Errorf(\"apptainer image is not owned by required group(s)\")\n\t\t}\n\t}\n\tif len(e.EngineConfig.File.LimitContainerOwners) != 0 {\n\t\tif authorized, err := imgObject.AuthorizedOwner(e.EngineConfig.File.LimitContainerOwners); err != nil {\n\t\t\treturn nil, err\n\t\t} else if !authorized {\n\t\t\treturn nil, fmt.Errorf(\"apptainer image is not owned by required user(s)\")\n\t\t}\n\t}\n\n\tswitch imgObject.Type {\n\t// Bare SquashFS\n\tcase image.SQUASHFS:\n\t\tif !e.EngineConfig.File.AllowContainerSquashfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running squashFS containers\")\n\t\t}\n\t\tif !userNS && !e.EngineConfig.File.AllowSetuidMountSquashfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from mounting squashFS in setuid mode, try --userns\")\n\t\t}\n\t// Bare EXT3\n\tcase image.EXT3:\n\t\tif !e.EngineConfig.File.AllowContainerExtfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running extFS containers\")\n\t\t}\n\t\tif !userNS && !e.EngineConfig.File.AllowSetuidMountExtfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from mounting extfs in setuid mode, try --userns\")\n\t\t}\n\t// Bare sandbox directory\n\tcase image.SANDBOX:\n\t\tif !e.EngineConfig.File.AllowContainerDir {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running sandbox containers\")\n\t\t}\n\t// SIF\n\tcase image.SIF:\n\t\tif !userNS && !e.EngineConfig.File.AllowSetuidMountSquashfs {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from mounting SIF squashFS partition in setuid mode, try --userns\")\n\t\t}\n\t\t// Check if SIF contains an encrypted rootfs partition.\n\t\t// We don't support encryption for other partitions at present.\n\t\tencrypted, err := imgObject.HasEncryptedRootFs()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"while checking for encrypted root FS: %v\", err)\n\t\t}\n\t\t// SIF with encryption\n\t\tif encrypted && !e.EngineConfig.File.AllowContainerEncrypted {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running encrypted SIF containers\")\n\t\t}\n\t\tif encrypted && !userNS && !e.EngineConfig.File.AllowSetuidMountEncrypted {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from mounting encrypted files in setuid mode\")\n\t\t}\n\t\t// SIF without encryption - regardless of rootfs filesystem type\n\t\tif !encrypted && !e.EngineConfig.File.AllowContainerSIF {\n\t\t\treturn nil, fmt.Errorf(\"configuration disallows users from running unencrypted SIF containers\")\n\t\t}\n\t// We shouldn't be able to run anything else, but make sure we don't!\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown image format %d\", imgObject.Type)\n\t}\n\n\treturn imgObject, imgErr\n}\n", "// Copyright (c) Contributors to the Apptainer project, established as\n//   Apptainer a Series of LF Projects LLC.\n//   For website terms of use, trademark policy, privacy policy and other\n//   project policies see https://lfprojects.org/policies\n// Copyright (c) 2019-2021, Sylabs Inc. All rights reserved.\n// This software is licensed under a 3-clause BSD license. Please consult the\n// LICENSE.md file distributed with the sources of this project regarding your\n// rights to use or distribute this software.\n\npackage apptainerconf\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/apptainer/apptainer/pkg/sylog\"\n)\n\n// currentConfig corresponds to the current configuration, may\n// be useful for packages requiring to share the same configuration.\nvar currentConfig *File\n\n// SetCurrentConfig sets the provided configuration as the current\n// configuration.\nfunc SetCurrentConfig(config *File) {\n\tcurrentConfig = config\n}\n\n// GetCurrentConfig returns the current configuration if any.\nfunc GetCurrentConfig() *File {\n\treturn currentConfig\n}\n\n// GetBuildConfig returns the configuration to be used for building containers\nfunc ApplyBuildConfig(config *File) {\n\t// Remove default binds when doing builds\n\tconfig.BindPath = nil\n\tconfig.ConfigResolvConf = false\n\tconfig.MountHome = false\n\tconfig.MountDevPts = false\n}\n\n// SetBinaryPath sets the value of the binary path, substituting the\n// user's $PATH plus \":\" for \"$PATH:\" in BinaryPath.  If nonSuid is true,\n// then SuidBinaryPath gets the same value as BinaryPath, otherwise\n// SuidBinaryPath gets the value of the binary path with with \"$PATH:\"\n// replaced with nothing.  libexecdir + \"apptainer/bin\" is always included\n// either at the beginning of $PATH if present, or the very beginning.\nfunc SetBinaryPath(libexecDir string, nonSuid bool) {\n\tif currentConfig == nil {\n\t\tsylog.Fatalf(\"apptainerconf.SetCurrentConfig() must be called before SetBinaryPath()\")\n\t}\n\tuserPath := os.Getenv(\"PATH\")\n\tif userPath != \"\" {\n\t\tuserPath += \":\"\n\t}\n\tinternalPath := filepath.Join(libexecDir, \"apptainer/bin\") + \":\"\n\tif !strings.Contains(currentConfig.BinaryPath, \"$PATH:\") {\n\t\t// If there's no \"$PATH:\" in binary path, add internalPath\n\t\t//  beginning of search path.  Otherwise put it at the\n\t\t//  beginning of where \"$PATH:\" is, below.\n\t\tcurrentConfig.BinaryPath = internalPath + currentConfig.BinaryPath\n\t}\n\tbinaryPath := currentConfig.BinaryPath\n\tcurrentConfig.BinaryPath = strings.Replace(binaryPath, \"$PATH:\", internalPath+userPath, 1)\n\tsylog.Debugf(\"Setting binary path to %v\", currentConfig.BinaryPath)\n\tif nonSuid {\n\t\tsylog.Debugf(\"Using that path for all binaries\")\n\t\tcurrentConfig.SuidBinaryPath = currentConfig.BinaryPath\n\t} else {\n\t\tcurrentConfig.SuidBinaryPath = strings.Replace(binaryPath, \"$PATH:\", internalPath, 1)\n\t\tsylog.Debugf(\"Setting suid binary path to %v\", currentConfig.SuidBinaryPath)\n\t}\n}\n\n// File describes the apptainer.conf file options\ntype File struct {\n\tAllowSetuid               bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow setuid\"`\n\tAllowPidNs                bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow pid ns\"`\n\tConfigPasswd              bool     `default:\"yes\" authorized:\"yes,no\" directive:\"config passwd\"`\n\tConfigGroup               bool     `default:\"yes\" authorized:\"yes,no\" directive:\"config group\"`\n\tConfigResolvConf          bool     `default:\"yes\" authorized:\"yes,no\" directive:\"config resolv_conf\"`\n\tMountProc                 bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount proc\"`\n\tMountSys                  bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount sys\"`\n\tMountDevPts               bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount devpts\"`\n\tMountHome                 bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount home\"`\n\tMountTmp                  bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount tmp\"`\n\tMountHostfs               bool     `default:\"no\" authorized:\"yes,no\" directive:\"mount hostfs\"`\n\tUserBindControl           bool     `default:\"yes\" authorized:\"yes,no\" directive:\"user bind control\"`\n\tEnableFusemount           bool     `default:\"yes\" authorized:\"yes,no\" directive:\"enable fusemount\"`\n\tEnableUnderlay            bool     `default:\"yes\" authorized:\"yes,no\" directive:\"enable underlay\"`\n\tMountSlave                bool     `default:\"yes\" authorized:\"yes,no\" directive:\"mount slave\"`\n\tAllowContainerSIF         bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container sif\"`\n\tAllowContainerEncrypted   bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container encrypted\"`\n\tAllowContainerSquashfs    bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container squashfs\"`\n\tAllowContainerExtfs       bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container extfs\"`\n\tAllowContainerDir         bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow container dir\"`\n\tAllowSetuidMountEncrypted bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow setuid-mount encrypted\"`\n\tAllowSetuidMountSquashfs  bool     `default:\"yes\" authorized:\"yes,no\" directive:\"allow setuid-mount squashfs\"`\n\tAllowSetuidMountExtfs     bool     `default:\"no\" authorized:\"yes,no\" directive:\"allow setuid-mount extfs\"`\n\tAlwaysUseNv               bool     `default:\"no\" authorized:\"yes,no\" directive:\"always use nv\"`\n\tUseNvCCLI                 bool     `default:\"no\" authorized:\"yes,no\" directive:\"use nvidia-container-cli\"`\n\tAlwaysUseRocm             bool     `default:\"no\" authorized:\"yes,no\" directive:\"always use rocm\"`\n\tSharedLoopDevices         bool     `default:\"no\" authorized:\"yes,no\" directive:\"shared loop devices\"`\n\tMaxLoopDevices            uint     `default:\"256\" directive:\"max loop devices\"`\n\tSessiondirMaxSize         uint     `default:\"16\" directive:\"sessiondir max size\"`\n\tMountDev                  string   `default:\"yes\" authorized:\"yes,no,minimal\" directive:\"mount dev\"`\n\tEnableOverlay             string   `default:\"try\" authorized:\"yes,no,try,driver\" directive:\"enable overlay\"`\n\tBindPath                  []string `default:\"/etc/localtime,/etc/hosts\" directive:\"bind path\"`\n\tLimitContainerOwners      []string `directive:\"limit container owners\"`\n\tLimitContainerGroups      []string `directive:\"limit container groups\"`\n\tLimitContainerPaths       []string `directive:\"limit container paths\"`\n\tAllowNetUsers             []string `directive:\"allow net users\"`\n\tAllowNetGroups            []string `directive:\"allow net groups\"`\n\tAllowNetNetworks          []string `directive:\"allow net networks\"`\n\tRootDefaultCapabilities   string   `default:\"full\" authorized:\"full,file,no\" directive:\"root default capabilities\"`\n\tMemoryFSType              string   `default:\"tmpfs\" authorized:\"tmpfs,ramfs\" directive:\"memory fs type\"`\n\tCniConfPath               string   `directive:\"cni configuration path\"`\n\tCniPluginPath             string   `directive:\"cni plugin path\"`\n\tBinaryPath                string   `default:\"$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" directive:\"binary path\"`\n\t// SuidBinaryPath is hidden; it is not referenced below, and overwritten\n\tSuidBinaryPath      string `directive:\"suidbinary path\"`\n\tMksquashfsProcs     uint   `default:\"0\" directive:\"mksquashfs procs\"`\n\tMksquashfsMem       string `directive:\"mksquashfs mem\"`\n\tImageDriver         string `directive:\"image driver\"`\n\tDownloadConcurrency uint   `default:\"3\" directive:\"download concurrency\"`\n\tDownloadPartSize    uint   `default:\"5242880\" directive:\"download part size\"`\n\tDownloadBufferSize  uint   `default:\"32768\" directive:\"download buffer size\"`\n\tSystemdCgroups      bool   `default:\"yes\" authorized:\"yes,no\" directive:\"systemd cgroups\"`\n}\n\n// NOTE: if you think that we may want to change the default for any\n// configuration parameter in the future, it is a good idea to conditionally\n// insert a comment before the default setting when the setting is equal\n// to the current default.  That enables the defaults to get updated in\n// a new release even if an administrator has changed one of the *other*\n// settings.  This gets around the problem of packagers such as rpm\n// refusing to overwrite a configuration file if any change has been made.\n// This technique is used for example in the \"allow setuid-mount\" options\n// below.  If a default is changed in a future release, both the default\n// setting above and the expression for the conditional comment below need\n// to change at the same time.\n\nconst TemplateAsset = `# APPTAINER.CONF\n# This is the global configuration file for Apptainer. This file controls\n# what the container is allowed to do on a particular host, and as a result\n# this file must be owned by root.\n\n# ALLOW SETUID: [BOOL]\n# DEFAULT: yes\n# Should we allow users to utilize the setuid program flow within Apptainer?\n# note1: This is the default mode, and to utilize all features, this option\n# must be enabled.  For example, without this option loop mounts of image \n# files will not work; only sandbox image directories, which do not need loop\n# mounts, will work (subject to note 2).\n# note2: If this option is disabled, it will rely on unprivileged user\n# namespaces which have not been integrated equally between different Linux\n# distributions.\nallow setuid = {{ if eq .AllowSetuid true }}yes{{ else }}no{{ end }}\n\n# MAX LOOP DEVICES: [INT]\n# DEFAULT: 256\n# Set the maximum number of loop devices that Apptainer should ever attempt\n# to utilize.\nmax loop devices = {{ .MaxLoopDevices }}\n\n# ALLOW PID NS: [BOOL]\n# DEFAULT: yes\n# Should we allow users to request the PID namespace? Note that for some HPC\n# resources, the PID namespace may confuse the resource manager and break how\n# some MPI implementations utilize shared memory. (note, on some older\n# systems, the PID namespace is always used)\nallow pid ns = {{ if eq .AllowPidNs true }}yes{{ else }}no{{ end }}\n\n# CONFIG PASSWD: [BOOL]\n# DEFAULT: yes\n# If /etc/passwd exists within the container, this will automatically append\n# an entry for the calling user.\nconfig passwd = {{ if eq .ConfigPasswd true }}yes{{ else }}no{{ end }}\n\n# CONFIG GROUP: [BOOL]\n# DEFAULT: yes\n# If /etc/group exists within the container, this will automatically append\n# group entries for the calling user.\nconfig group = {{ if eq .ConfigGroup true }}yes{{ else }}no{{ end }}\n\n# CONFIG RESOLV_CONF: [BOOL]\n# DEFAULT: yes\n# If there is a bind point within the container, use the host's\n# /etc/resolv.conf.\nconfig resolv_conf = {{ if eq .ConfigResolvConf true }}yes{{ else }}no{{ end }}\n\n# MOUNT PROC: [BOOL]\n# DEFAULT: yes\n# Should we automatically bind mount /proc within the container?\nmount proc = {{ if eq .MountProc true }}yes{{ else }}no{{ end }}\n\n# MOUNT SYS: [BOOL]\n# DEFAULT: yes\n# Should we automatically bind mount /sys within the container?\nmount sys = {{ if eq .MountSys true }}yes{{ else }}no{{ end }}\n\n# MOUNT DEV: [yes/no/minimal]\n# DEFAULT: yes\n# Should we automatically bind mount /dev within the container? If 'minimal'\n# is chosen, then only 'null', 'zero', 'random', 'urandom', and 'shm' will\n# be included (the same effect as the --contain options)\nmount dev = {{ .MountDev }}\n\n# MOUNT DEVPTS: [BOOL]\n# DEFAULT: yes\n# Should we mount a new instance of devpts if there is a 'minimal'\n# /dev, or -C is passed?  Note, this requires that your kernel was\n# configured with CONFIG_DEVPTS_MULTIPLE_INSTANCES=y, or that you're\n# running kernel 4.7 or newer.\nmount devpts = {{ if eq .MountDevPts true }}yes{{ else }}no{{ end }}\n\n# MOUNT HOME: [BOOL]\n# DEFAULT: yes\n# Should we automatically determine the calling user's home directory and\n# attempt to mount it's base path into the container? If the --contain option\n# is used, the home directory will be created within the session directory or\n# can be overridden with the APPTAINER_HOME or APPTAINER_WORKDIR\n# environment variables (or their corresponding command line options).\nmount home = {{ if eq .MountHome true }}yes{{ else }}no{{ end }}\n\n# MOUNT TMP: [BOOL]\n# DEFAULT: yes\n# Should we automatically bind mount /tmp and /var/tmp into the container? If\n# the --contain option is used, both tmp locations will be created in the\n# session directory or can be specified via the  APPTAINER_WORKDIR\n# environment variable (or the --workingdir command line option).\nmount tmp = {{ if eq .MountTmp true }}yes{{ else }}no{{ end }}\n\n# MOUNT HOSTFS: [BOOL]\n# DEFAULT: no\n# Probe for all mounted file systems that are mounted on the host, and bind\n# those into the container?\nmount hostfs = {{ if eq .MountHostfs true }}yes{{ else }}no{{ end }}\n\n# BIND PATH: [STRING]\n# DEFAULT: Undefined\n# Define a list of files/directories that should be made available from within\n# the container. The file or directory must exist within the container on\n# which to attach to. you can specify a different source and destination\n# path (respectively) with a colon; otherwise source and dest are the same.\n# NOTE: these are ignored if apptainer is invoked with --contain except\n# for /etc/hosts and /etc/localtime. When invoked with --contain and --net,\n# /etc/hosts would contain a default generated content for localhost resolution.\n#bind path = /etc/apptainer/default-nsswitch.conf:/etc/nsswitch.conf\n#bind path = /opt\n#bind path = /scratch\n{{ range $path := .BindPath }}\n{{- if ne $path \"\" -}}\nbind path = {{$path}}\n{{ end -}}\n{{ end }}\n# USER BIND CONTROL: [BOOL]\n# DEFAULT: yes\n# Allow users to influence and/or define bind points at runtime? This will allow\n# users to specify bind points, scratch and tmp locations. (note: User bind\n# control is only allowed if the host also supports PR_SET_NO_NEW_PRIVS)\nuser bind control = {{ if eq .UserBindControl true }}yes{{ else }}no{{ end }}\n\n# ENABLE FUSEMOUNT: [BOOL]\n# DEFAULT: yes\n# Allow users to mount fuse filesystems inside containers with the --fusemount\n# command line option.\nenable fusemount = {{ if eq .EnableFusemount true }}yes{{ else }}no{{ end }}\n\n# ENABLE OVERLAY: [yes/no/try/driver]\n# DEFAULT: try\n# Enabling this option will make it possible to specify bind paths to locations\n# that do not currently exist within the container.  If 'try' is chosen,\n# overlayfs will be tried but if it is unavailable it will be silently ignored.\n# If 'driver' is chosen, overlayfs is handled by the image driver.\nenable overlay = {{ .EnableOverlay }}\n\n# ENABLE UNDERLAY: [yes/no]\n# DEFAULT: yes\n# Enabling this option will make it possible to specify bind paths to locations\n# that do not currently exist within the container even if overlay is not\n# working.  If overlay is available, it will be tried first.\nenable underlay = {{ if eq .EnableUnderlay true }}yes{{ else }}no{{ end }}\n\n# MOUNT SLAVE: [BOOL]\n# DEFAULT: yes\n# Should we automatically propagate file-system changes from the host?\n# This should be set to 'yes' when autofs mounts in the system should\n# show up in the container.\nmount slave = {{ if eq .MountSlave true }}yes{{ else }}no{{ end }}\n\n# SESSIONDIR MAXSIZE: [STRING]\n# DEFAULT: 16\n# This specifies how large the default sessiondir should be (in MB). It will\n# affect users who use the \"--contain\" options and don't also specify a\n# location to do default read/writes to (e.g. \"--workdir\" or \"--home\") and\n# it will also affect users of \"--writable-tmpfs\".\nsessiondir max size = {{ .SessiondirMaxSize }}\n\n# LIMIT CONTAINER OWNERS: [STRING]\n# DEFAULT: NULL\n# Only allow containers to be used that are owned by a given user. If this\n# configuration is undefined (commented or set to NULL), all containers are\n# allowed to be used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#limit container owners = gmk, apptainer, nobody\n{{ range $index, $owner := .LimitContainerOwners }}\n{{- if eq $index 0 }}limit container owners = {{ else }}, {{ end }}{{$owner}}\n{{- end }}\n\n# LIMIT CONTAINER GROUPS: [STRING]\n# DEFAULT: NULL\n# Only allow containers to be used that are owned by a given group. If this\n# configuration is undefined (commented or set to NULL), all containers are\n# allowed to be used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#limit container groups = group1, apptainer, nobody\n{{ range $index, $group := .LimitContainerGroups }}\n{{- if eq $index 0 }}limit container groups = {{ else }}, {{ end }}{{$group}}\n{{- end }}\n\n# LIMIT CONTAINER PATHS: [STRING]\n# DEFAULT: NULL\n# Only allow containers to be used that are located within an allowed path\n# prefix. If this configuration is undefined (commented or set to NULL),\n# containers will be allowed to run from anywhere on the file system. This\n# feature only applies when Apptainer is running in SUID mode and the user is\n# non-root.\n#limit container paths = /scratch, /tmp, /global\n{{ range $index, $path := .LimitContainerPaths }}\n{{- if eq $index 0 }}limit container paths = {{ else }}, {{ end }}{{$path}}\n{{- end }}\n\n# ALLOW CONTAINER ${TYPE}: [BOOL]\n# DEFAULT: yes\n# This feature limits what kind of containers that Apptainer will allow\n# users to use (note this does not apply for root).  Note that some of the\n# same operations can be limited in setuid mode by the ALLOW SETUID-MOUNT\n# feature below; both types need to be \"yes\" to be allowed.\n#\n# Allow use of unencrypted SIF containers\nallow container sif = {{ if eq .AllowContainerSIF true}}yes{{ else }}no{{ end }}\n#\n# Allow use of encrypted SIF containers\nallow container encrypted = {{ if eq .AllowContainerEncrypted true }}yes{{ else }}no{{ end }}\n#\n# Allow use of non-SIF image formats\nallow container squashfs = {{ if eq .AllowContainerSquashfs true }}yes{{ else }}no{{ end }}\nallow container extfs = {{ if eq .AllowContainerExtfs true }}yes{{ else }}no{{ end }}\nallow container dir = {{ if eq .AllowContainerDir true }}yes{{ else }}no{{ end }}\n\n# ALLOW SETUID-MOUNT ${TYPE}: [BOOL]\n# DEFAULT: yes, except no for extfs\n# This feature limits what types of mounts that Apptainer will allow\n# unprivileged users to use in setuid mode.  Normally these operations\n# require the elevated privileges of setuid mode, although Apptainer\n# has unprivileged alternatives for squashfs and extfs.  Note that some of\n# the same operations can also be limited by the ALLOW CONTAINER feature\n# above; both types need to be \"yes\" to be allowed.\n#\n# Allow mounting of SIF encryption (using the kernel device-mapper) in\n# setuid mode\n{{ if eq .AllowSetuidMountEncrypted true}}# {{ end }}allow setuid-mount encrypted = {{ if eq .AllowSetuidMountEncrypted true}}yes{{ else }}no{{ end }}\n#\n# Allow mounting of squashfs filesystem types in setuid mode, both inside and\n# outside of SIF files\n{{ if eq .AllowSetuidMountSquashfs true}}# {{ end }}allow setuid-mount squashfs = {{ if eq .AllowSetuidMountSquashfs true}}yes{{ else }}no{{ end }}\n#\n# Allow mounting of extfs filesystem types in setuid mode, both inside and\n# outside of SIF files.  WARNING: this filesystem type frequently has relevant\n# CVEs that that take a very long time for vendors to patch because they are\n# not considered to be High severity since normally unprivileged users do\n# not have write access to the raw filesystem data.  This is why this option\n# defaults to \"no\".  Change it at your own risk and consider using the\n# LIMIT CONTAINER features above if you do.\n{{ if eq .AllowSetuidMountExtfs false}}# {{ end }}allow setuid-mount extfs = {{ if eq .AllowSetuidMountExtfs true}}yes{{ else }}no{{ end }}\n\n# ALLOW NET USERS: [STRING]\n# DEFAULT: NULL\n# Allow specified root administered CNI network configurations to be used by the\n# specified list of users. By default only root may use CNI configuration,\n# except in the case of a fakeroot execution where only 40_fakeroot.conflist\n# is used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#allow net users = gmk, apptainer\n{{ range $index, $owner := .AllowNetUsers }}\n{{- if eq $index 0 }}allow net users = {{ else }}, {{ end }}{{$owner}}\n{{- end }}\n\n# ALLOW NET GROUPS: [STRING]\n# DEFAULT: NULL\n# Allow specified root administered CNI network configurations to be used by the\n# specified list of users. By default only root may use CNI configuration,\n# except in the case of a fakeroot execution where only 40_fakeroot.conflist\n# is used. This feature only applies when Apptainer is running in\n# SUID mode and the user is non-root.\n#allow net groups = group1, apptainer\n{{ range $index, $group := .AllowNetGroups }}\n{{- if eq $index 0 }}allow net groups = {{ else }}, {{ end }}{{$group}}\n{{- end }}\n\n# ALLOW NET NETWORKS: [STRING]\n# DEFAULT: NULL\n# Specify the names of CNI network configurations that may be used by users and\n# groups listed in the allow net users / allow net groups directives. Thus feature\n# only applies when Apptainer is running in SUID mode and the user is non-root.\n#allow net networks = bridge\n{{ range $index, $group := .AllowNetNetworks }}\n{{- if eq $index 0 }}allow net networks = {{ else }}, {{ end }}{{$group}}\n{{- end }}\n\n# ALWAYS USE NV ${TYPE}: [BOOL]\n# DEFAULT: no\n# This feature allows an administrator to determine that every action command\n# should be executed implicitly with the --nv option (useful for GPU only \n# environments). \nalways use nv = {{ if eq .AlwaysUseNv true }}yes{{ else }}no{{ end }}\n\n# USE NVIDIA-NVIDIA-CONTAINER-CLI ${TYPE}: [BOOL]\n# DEFAULT: no\n# EXPERIMENTAL\n# If set to yes, Apptainer will attempt to use nvidia-container-cli to setup\n# GPUs within a container when the --nv flag is enabled.\n# If no (default), the legacy binding of entries in nvbliblist.conf will be performed.\nuse nvidia-container-cli = {{ if eq .UseNvCCLI true }}yes{{ else }}no{{ end }}\n\n# ALWAYS USE ROCM ${TYPE}: [BOOL]\n# DEFAULT: no\n# This feature allows an administrator to determine that every action command\n# should be executed implicitly with the --rocm option (useful for GPU only\n# environments).\nalways use rocm = {{ if eq .AlwaysUseRocm true }}yes{{ else }}no{{ end }}\n\n# ROOT DEFAULT CAPABILITIES: [full/file/no]\n# DEFAULT: full\n# Define default root capability set kept during runtime\n# - full: keep all capabilities (same as --keep-privs)\n# - file: keep capabilities configured in ${prefix}/etc/apptainer/capabilities/user.root\n# - no: no capabilities (same as --no-privs)\nroot default capabilities = {{ .RootDefaultCapabilities }}\n\n# MEMORY FS TYPE: [tmpfs/ramfs]\n# DEFAULT: tmpfs\n# This feature allow to choose temporary filesystem type used by Apptainer.\n# Cray CLE 5 and 6 up to CLE 6.0.UP05 there is an issue (kernel panic) when Apptainer\n# use tmpfs, so on affected version it's recommended to set this value to ramfs to avoid\n# kernel panic\nmemory fs type = {{ .MemoryFSType }}\n\n# CNI CONFIGURATION PATH: [STRING]\n# DEFAULT: Undefined\n# Defines path where CNI configuration files are stored\n#cni configuration path =\n{{ if ne .CniConfPath \"\" }}cni configuration path = {{ .CniConfPath }}{{ end }}\n# CNI PLUGIN PATH: [STRING]\n# DEFAULT: Undefined\n# Defines path where CNI executable plugins are stored\n#cni plugin path =\n{{ if ne .CniPluginPath \"\" }}cni plugin path = {{ .CniPluginPath }}{{ end }}\n\n# BINARY PATH: [STRING]\n# DEFAULT: $PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n# Colon-separated list of directories to search for many binaries.  May include\n# \"$PATH:\", which will be replaced by the user's PATH when not running a binary\n# that may be run with elevated privileges from the setuid program flow.  The\n# internal bin ${prefix}/libexec/apptainer/bin is always included, either at the\n# beginning of \"$PATH:\" if it is present or at the very beginning if \"$PATH:\" is\n# not present.\n# binary path = \n\n# MKSQUASHFS PROCS: [UINT]\n# DEFAULT: 0 (All CPUs)\n# This allows the administrator to specify the number of CPUs for mksquashfs \n# to use when building an image.  The fewer processors the longer it takes.\n# To enable it to use all available CPU's set this to 0.\n# mksquashfs procs = 0\nmksquashfs procs = {{ .MksquashfsProcs }}\n\n# MKSQUASHFS MEM: [STRING]\n# DEFAULT: Unlimited\n# This allows the administrator to set the maximum amount of memory for mkswapfs\n# to use when building an image.  e.g. 1G for 1gb or 500M for 500mb. Restricting memory\n# can have a major impact on the time it takes mksquashfs to create the image.\n# NOTE: This fuctionality did not exist in squashfs-tools prior to version 4.3\n# If using an earlier version you should not set this.\n# mksquashfs mem = 1G\n{{ if ne .MksquashfsMem \"\" }}mksquashfs mem = {{ .MksquashfsMem }}{{ end }}\n\n# SHARED LOOP DEVICES: [BOOL]\n# DEFAULT: no\n# Allow to share same images associated with loop devices to minimize loop\n# usage and optimize kernel cache (useful for MPI)\nshared loop devices = {{ if eq .SharedLoopDevices true }}yes{{ else }}no{{ end }}\n\n# IMAGE DRIVER: [STRING]\n# DEFAULT: Undefined\n# This option specifies the name of an image driver provided by a plugin that\n# will be used to handle image mounts. If the 'enable overlay' option is set\n# to 'driver' the driver name specified here will also be used to handle\n# overlay mounts.\n# If the driver name specified has not been registered via a plugin installation\n# the run-time will abort.\nimage driver = {{ .ImageDriver }}\n\n# DOWNLOAD CONCURRENCY: [UINT]\n# DEFAULT: 3\n# This option specifies how many concurrent streams when downloading (pulling)\n# an image from cloud library.\ndownload concurrency = {{ .DownloadConcurrency }}\n\n# DOWNLOAD PART SIZE: [UINT]\n# DEFAULT: 5242880\n# This option specifies the size of each part when concurrent downloads are\n# enabled.\ndownload part size = {{ .DownloadPartSize }}\n\n# DOWNLOAD BUFFER SIZE: [UINT]\n# DEFAULT: 32768\n# This option specifies the transfer buffer size when concurrent downloads\n# are enabled.\ndownload buffer size = {{ .DownloadBufferSize }}\n\n# SYSTEMD CGROUPS: [BOOL]\n# DEFAULT: yes\n# Whether to use systemd to manage container cgroups. Required for rootless cgroups\n# functionality. 'no' will manage cgroups directly via cgroupfs.\nsystemd cgroups = {{ if eq .SystemdCgroups true }}yes{{ else }}no{{ end }}\n`\n", "#!/bin/sh\n# Copyright (c) Contributors to the Apptainer project, established as\n#   Apptainer a Series of LF Projects LLC.\n#   For website terms of use, trademark policy, privacy policy and other\n#   project policies see https://lfprojects.org/policies\n\nset -e\n\nusage() {\n\tcat <<-EOT\n\tE: Invalid usage. Abort.\n\n\tUsage:\n\n\t    $0 {github_repository} {github_branch} [github_pr_url]\n\n\tIf a {github_pr_url} is provided, it's used to obtain additional\n\tinformation like the target branch and the labels. Otherwise it\n\tis assumed that the code is already merged and that only the\n\tmost recent commit should be examined.\n\tEOT\n}\n\n# Give the possibility to force E2E run\nif ! test -z \"${FORCE_E2E}\" ; then\n    echo \"FORCE_E2E set, forcing e2e tests.\"\n    exit 0\nfi\n\n# Skip e2e by default\nrequire_e2e=false\n\nGITHUB_REPOSITORY=$1\nGITHUB_BRANCH=$2\nGITHUB_PR_NUMBER=$3\n\nif test -z \"${GITHUB_REPOSITORY}\" ; then\n\tusage \"$0\"\n\texit 2\nelif test -z \"${GITHUB_BRANCH}\" ; then\n\tusage \"$0\"\n\texit 2\nfi\n\nif test -z \"${GITHUB_PR_NUMBER}\" ; then\n\techo \"Running directly against branch ${GITHUB_BRANCH}\"\n\tTARGET_BRANCH=\"${GITHUB_BRANCH}\"\n\tBASE_COMMIT=\"HEAD~\"\n\t# Assume E2E is required for all runs against a branch; below we\n\t# constrain this to specific branches.\n\trequire_e2e=true\nelse\n\tpull_info_file=$(mktemp)\n\ttrap \"rm -f ${pull_info_file}\" EXIT\n\n\tcurl -s \"https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${GITHUB_PR_NUMBER}\" > \"${pull_info_file}\"\n\n\t# Keep the matching lines instead of simply looking at the exit\n\t# code for debugging purposes\n\tE2E_LABELS=$(jq -r '.labels[].name' < \"${pull_info_file}\" | grep --line-regexp --fixed-strings ci:e2e || true)\n\n\tif test -n \"${E2E_LABELS}\" ; then\n\t\techo \"Honoring request to run E2E tests from pull request labels\"\n\t\texit 0\n\tfi\n\n\tTARGET_BRANCH=$(jq -r .base.ref < \"${pull_info_file}\")\n\tBASE_COMMIT=\"origin/${TARGET_BRANCH}\"\nfi\n\ncase \"${TARGET_BRANCH}\" in\n\tmaster|main)\n\t\tif git --no-pager diff --name-only HEAD \"${BASE_COMMIT}\" |\n\t\t\tgrep -q -E -f .ci/e2e_triggers\n\t\tthen\n\t\t\t# There are changes in critical components, require e2e\n\t\t\trequire_e2e=true\n\t\tfi\n\t\t;;\n\n\trelease-*)\n\t\t# Require E2E for all changes going into a release branch\n\t\trequire_e2e=true\n\t\t;;\n\n\tnull)\n\t\t# Failed to read api, could be private repo.  Run tests.\n\t\trequire_e2e=true\n\t\t;;\n\t*)\n\t\t# The branch is not master or release, skip e2e\n\t\trequire_e2e=false\n\t\t;;\nesac\n\nif ${require_e2e} ; then\n\techo \"Critical changes detected.\"\n\texit 0\nelse\n\techo \"No critical changes detected.\"\n\texit 1\nfi\n"], "filenames": ["e2e/actions/actions.go", "e2e/config/config.go", "e2e/internal/e2e/config.go", "e2e/overlay/overlay.go", "e2e/run/run.go", "internal/pkg/runtime/engine/apptainer/prepare_linux.go", "pkg/util/apptainerconf/config.go", "scripts/should-e2e-run"], "buggy_code_start_loc": [791, 28, 45, 75, 287, 153, 79, 85], "buggy_code_end_loc": [1935, 748, 45, 75, 287, 1437, 336, 85], "fixing_code_start_loc": [792, 28, 46, 76, 288, 153, 79, 86], "fixing_code_end_loc": [1942, 898, 66, 79, 291, 1456, 380, 90], "type": "CWE-416", "message": "Apptainer is an open source container platform for Linux. There is an ext4 use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0, installations that include apptainer-suid < 1.1.8, and all versions of Singularity in their default configurations on older operating systems where that CVE has not been patched. That includes Red Hat Enterprise Linux 7, Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack the kernel for denial of service and potentially for privilege escalation. Apptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem types in setuid-root mode, while continuing to allow mounting of extfs filesystems in non-setuid \"rootless\" mode using fuse2fs. Some workarounds are possible. Either do not install apptainer-suid (for versions 1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf (or singularity.conf for singularity versions). This requires having unprivileged user namespaces enabled and except for apptainer 1.1.x versions will disallow mounting of sif files, extfs files, and squashfs files in addition to other, less significant impacts. (Encrypted sif files are also not supported unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options in apptainer.conf/singularity.conf to limit sif files to trusted users, groups, and/or paths, and set `allow container extfs = no` to disallow mounting of extfs overlay files. The latter option by itself does not disallow mounting of extfs overlay partitions inside SIF files, so that's why the former options are also needed.", "other": {"cve": {"id": "CVE-2023-30549", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-25T21:15:10.767", "lastModified": "2023-05-26T21:15:19.493", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Apptainer is an open source container platform for Linux. There is an ext4 use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0, installations that include apptainer-suid < 1.1.8, and all versions of Singularity in their default configurations on older operating systems where that CVE has not been patched. That includes Red Hat Enterprise Linux 7, Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack the kernel for denial of service and potentially for privilege escalation. Apptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem types in setuid-root mode, while continuing to allow mounting of extfs filesystems in non-setuid \"rootless\" mode using fuse2fs. Some workarounds are possible. Either do not install apptainer-suid (for versions 1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf (or singularity.conf for singularity versions). This requires having unprivileged user namespaces enabled and except for apptainer 1.1.x versions will disallow mounting of sif files, extfs files, and squashfs files in addition to other, less significant impacts. (Encrypted sif files are also not supported unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options in apptainer.conf/singularity.conf to limit sif files to trusted users, groups, and/or paths, and set `allow container extfs = no` to disallow mounting of extfs overlay files. The latter option by itself does not disallow mounting of extfs overlay partitions inside SIF files, so that's why the former options are also needed."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lfprojects:apptainer:*:*:*:*:*:go:*:*", "versionEndExcluding": "1.1.8", "matchCriteriaId": "DE6873C2-2BED-4420-B34A-0D4621743ED0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sylabs:singularity:*:*:*:*:*:*:*:*", "matchCriteriaId": "E717102A-7916-4153-A201-B868E3235ED4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/cve-2022-1184", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://github.com/apptainer/apptainer/commit/5a4964f5ba9c8d89a0e353b97f51fd607670a9f7", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/apptainer/apptainer/releases/tag/v1.1.8", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/apptainer/apptainer/security/advisories/GHSA-j4rf-7357-f4cg", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2022-1184", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://ubuntu.com/security/CVE-2022-1184", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}, {"url": "https://www.suse.com/security/cve/CVE-2022-1184.html", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}]}, "github_commit_url": "https://github.com/apptainer/apptainer/commit/5a4964f5ba9c8d89a0e353b97f51fd607670a9f7"}}