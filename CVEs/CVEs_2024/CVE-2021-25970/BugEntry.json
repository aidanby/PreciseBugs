{"buggy_code": ["class CamaleonCms::Admin::UsersController < CamaleonCms::AdminController\n  before_action :validate_role, except: [:profile, :profile_edit]\n  add_breadcrumb I18n.t(\"camaleon_cms.admin.sidebar.users\"), :cama_admin_users_url\n  before_action :set_user, only: [:show, :edit, :update, :destroy, :impersonate]\n\n  def index\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.list_users\")\n    @users = current_site.users.paginate(:page => params[:page], :per_page => current_site.admin_per_page)\n  end\n\n  def profile\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.profile\")\n    @user = params[:user_id].present? ? current_site.the_user(params[:user_id].to_i).object : cama_current_user.object\n    return edit\n  end\n\n  def profile_edit\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.profile\")\n    @user = cama_current_user.object\n    return edit\n  end\n\n  def show\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.profile\")\n    render 'profile'\n  end\n\n  def update\n    r={user: @user}; hooks_run('user_update', r)\n    if @user.update(user_params)\n      @user.set_metas(params[:meta]) if params[:meta].present?\n      @user.set_field_values(params[:field_options])\n      r = {user: @user, message: t('camaleon_cms.admin.users.message.updated'), params: params}; hooks_run('user_after_edited', r)\n      flash[:notice] = r[:message]\n      r={user: @user}; hooks_run('user_updated', r)\n      if cama_current_user.id == @user.id\n        redirect_to action: :profile_edit\n      else\n        redirect_to action: :index\n      end\n    else\n      render 'form'\n    end\n  end\n\n  # update som ajax requests from profile or user form\n  def updated_ajax\n    @user = current_site.users.find(params[:user_id])\n    render inline: @user.update(params.require(:password).permit!) ? \"\" : @user.errors.full_messages.join(', ')\n  end\n\n  def edit\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.button.edit\")\n    r = {user: @user, render: 'form' }\n    hooks_run('user_edit', r)\n    render r[:render]\n  end\n\n  def new\n    @user ||= current_site.users.new\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.button.new\")\n    r = {user: @user, render: 'form' }\n    hooks_run('user_new', r)\n    render r[:render]\n  end\n\n  def create\n    user_data = params.require(:user).permit!\n    @user = current_site.users.new(user_data)\n    r={user: @user}; hooks_run('user_create', r)\n    if @user.save\n      @user.set_metas(params[:meta]) if params[:meta].present?\n      @user.set_field_values(params[:field_options])\n      r={user: @user}; hooks_run('user_created', r)\n      flash[:notice] = t('camaleon_cms.admin.users.message.created')\n      redirect_to action: :index\n    else\n      new\n    end\n  end\n\n  def destroy\n    if cama_current_user.id == @user.id\n      flash[:error] = t('camaleon_cms.admin.users.message.user_can_not_delete_own_account', default: 'User can not delete own account')\n    elsif @user.destroy\n      flash[:notice] = t('camaleon_cms.admin.users.message.deleted')\n      r={user: @user}; hooks_run('user_destroyed', r)\n    end\n    redirect_to action: :index\n  end\n\n  def impersonate\n    authorize! :impersonate, @user\n    session_switch_user(@user, cama_admin_dashboard_path)\n  end\n\n  private\n\n  def validate_role\n    (user_id_param.present? && cama_current_user.id.to_s == user_id_param) || authorize!(:manage, :users)\n  end\n\n  def user_id_param\n    params[:id] || params[:user_id]\n  end\n\n  def user_params\n    parameters = params.require(:user)\n    if cama_current_user.role_grantor?(@user)\n      parameters.permit(:username, :email, :role, :first_name, :last_name)\n    else\n      parameters.permit(:username, :email, :first_name, :last_name)\n    end\n  end\n\n  def set_user\n    begin\n      @user = current_site.users.find(user_id_param)\n    rescue\n      flash[:error] = t('camaleon_cms.admin.users.message.error')\n      redirect_to cama_admin_path\n    end\n  end\nend\n", "module CamaleonCms::SessionHelper\n  # log in the user in to system\n  # user: User model\n  # remember_me: true/false (remember session permanently)\n  # redirect_url (default nil): after initialized the session, this will be redirected to\n  #   \"redirect_url\" if defined\n  #   it doesn't redirect if redirect_url === false\n  #   return to previous page if defined the cookie['return_to'] or login url received extra param: return_to=http://mysite.com\n  def login_user(user, remember_me = false, redirect_url = nil)\n    c = {value: [user.auth_token, request.user_agent, request.ip], expires: 24.hours.from_now}\n    c[:domain] = :all if PluginRoutes.system_info[\"users_share_sites\"].present? && CamaleonCms::Site.count > 1\n    c[:expires] = 1.month.from_now if remember_me\n\n    # fix to overwrite a cookie\n    cookies.delete(:auth_token, domain: :all)\n    cookies.delete(:auth_token)\n\n    user.update({last_login_at: Time.zone.now})\n    cookies[:auth_token] = c\n\n    # user redirection\n    flash[:notice] = t('camaleon_cms.admin.login.message.success', locale: current_site.get_admin_language)\n    return if redirect_url === false\n    if redirect_url.present?\n      redirect_to redirect_url\n    elsif (return_to = cookies.delete(:return_to)).present?\n      redirect_to return_to\n    else\n      redirect_to cama_admin_dashboard_path\n    end\n  end\n\n  # login a user using username and password\n  # return boolean: true => authenticated, false => authentication failed\n  def login_user_with_password(username, password)\n    @user = current_site.users.find_by_username(username)\n    r = {user: @user, params: params, password: password, captcha_validate: true}; hooks_run('user_before_login', r)\n    @user && @user.authenticate(password)\n  end\n\n  ##\n  # User registration.\n  #\n  # user_data must contain:\n  # - first_name\n  # - email\n  # - username\n  # - password\n  # - password_confirmation\n\n  def cama_register_user(user_data, meta)\n    @user = current_site.users.new(user_data)\n    r = {user: @user, params: params}; hook_run('user_before_register', r)\n\n    if current_site.security_user_register_captcha_enabled? && !cama_captcha_verified?\n      {:result => false, :type => :captcha_error, :message => t('camaleon_cms.admin.users.message.error_captcha')}\n    else\n      if @user.save\n        @user.set_metas(meta)\n        message = current_site.need_validate_email? ? t('camaleon_cms.admin.users.message.created_pending_validate_email') : t('camaleon_cms.admin.users.message.created')\n        r = {user: @user, message: message, redirect_url: cama_admin_login_path}; hooks_run('user_after_register', r)\n        {:result => true, :message => r[:message], :redirect_url => r[:redirect_url]}\n      else\n        {:result => false, :type => :no_saved}\n      end\n    end\n  end\n\n  # check if current host is heroku\n  def cama_on_heroku?\n    ENV.keys.any? { |var_name| var_name.match(/(heroku|dyno)/i) }\n  end\n\n  # switch current session user into other (user)\n  # after switched, this will be redirected to redirect_url or admin dashboard\n  def session_switch_user(user, redirect_url = nil)\n    if cama_sign_in?\n      session[:parent_auth_token] = cookies[:auth_token]\n      login_user(user, false, redirect_url)\n    end\n  end\n\n  # switch current session into parent session called by session_switch_user\n  # after returned into parent session, this will be redirected to redirect_url or admin dashboard\n  def session_back_to_parent(redirect_url = nil)\n    if cama_sign_in? && session[:parent_auth_token].present?\n      cookies[:auth_token] = session[:parent_auth_token]\n      session.delete(:parent_auth_token)\n      redirect_to (redirect_url || cama_admin_dashboard_path), notice: \"Welcome back!\"\n    end\n  end\n\n  # logout current user\n  def cama_logout_user\n    cookies.delete(:auth_token, domain: :all)\n    cookies.delete(:auth_token, domain: nil)\n    c_data = {value: nil, expires: 24.hours.ago}\n    c_data[:domain] = :all if PluginRoutes.system_info[\"users_share_sites\"].present? && CamaleonCms::Site.count > 1\n    cookies[:auth_token] = c_data\n    redirect_to params[:return_to].present? ? params[:return_to] : cama_admin_login_path, :notice => t('camaleon_cms.admin.logout.message.closed')\n  end\n\n  # check if current user is already signed\n  def cama_sign_in?\n    !cama_current_user.nil?\n  end\n\n  alias_method :signin?, :cama_sign_in?\n\n  # return the role for current user\n  # if not logged in, then return 'public'\n  def cama_current_role\n    current_site.visitor_role\n  end\n\n  # return current user logged in\n  def cama_current_user\n    return @cama_current_user if defined?(@cama_current_user)\n    # api current user...\n    @cama_current_user = cama_calc_api_current_user\n    return @cama_current_user if @cama_current_user\n\n    return nil unless cookies[:auth_token].present?\n    c = cookies[:auth_token].split(\"&\")\n    return nil unless c.size == 3\n\n    @cama_current_user = current_site.users_include_admins.find_by_auth_token(c[0]).try(:decorate)\n  end\n\n  # check if a visitor was logged in\n  # if the user was not logged in, then redirect to login url\n  def cama_authenticate(redirect_uri = nil)\n    params[:return_to] = redirect_uri\n    unless cama_sign_in?\n      flash[:error] = t('camaleon_cms.admin.login.please_login')\n      cookies[:return_to] = params[:return_to].present? ? params[:return_to] : ((request.get? && params[:controller] != \"admin/sessions\") ? request.original_url : nil)\n      redirect_to cama_admin_login_path\n    end\n  end\n\n  # return the session id\n  def cama_get_session_id\n    session[:autor] = \"Owen Peredo Diaz\" unless request.session_options[:id].present?\n    id = request.session_options[:id]\n    id = id.public_id if id && id.class.name == 'Rack::Session::SessionId'\n    id\n  end\n\n  private\n  # calculate the current user for API\n  def cama_calc_api_current_user\n    begin\n      doorkeeper_token\n    rescue NameError\n      # hack, this method should be called from a context which has\n      # doorkeeper_token defined\n      return nil\n    end\n    current_site.users_include_admins.find_by_id(doorkeeper_token.resource_owner_id).try(:decorate) if doorkeeper_token\n  end\nend\n", "module CamaleonCms::UserMethods extend ActiveSupport::Concern\n  included do\n    include CamaleonCms::Metas\n    include CamaleonCms::CustomFieldsRead\n\n    validates_uniqueness_of :username, scope: [:site_id], case_sensitive: false, message: I18n.t('camaleon_cms.admin.users.message.requires_different_username', default: 'Requires different username')\n    validates_uniqueness_of :email, scope: [:site_id], case_sensitive: false, message: I18n.t('camaleon_cms.admin.users.message.requires_different_email', default: 'Requires different email')\n\n    # callbacks\n    before_validation :cama_before_validation\n    before_destroy :reassign_posts\n    after_destroy :reassign_comments\n    before_create { generate_token(:auth_token) }\n\n    # relations\n    cama_define_common_relationships('User')\n    has_many :all_posts, class_name: \"CamaleonCms::Post\", foreign_key: :user_id\n    has_many :all_comments, class_name: 'CamaleonCms::PostComment'\n    belongs_to :site, class_name: 'CamaleonCms::Site', optional: true\n\n    #scopes\n    scope :admin_scope, -> { where(:role => 'admin') }\n    scope :actives, -> { where(:active => 1) }\n    scope :not_actives, -> { where(:active => 0) }\n\n    #vars\n    STATUS = {0 => 'Active', 1=>'Not Active'}\n    ROLE = { 'admin'=>'Administrator', 'client' => 'Client'}\n\n    def self.decorator_class\n      'CamaleonCms::UserDecorator'.constantize\n    end\n  end\n\n  # return all posts of this user on site\n  def posts(site)\n    site.posts.where(user_id: self.id)\n  end\n\n  def fullname\n    \"#{self.first_name} #{self.last_name}\".titleize\n  end\n\n  def admin?\n    role == 'admin'\n  end\n\n  def client?\n    self.role == 'client'\n  end\n\n  # return the UserRole Object of this user in Site\n  def get_role(site)\n    @_user_role ||= site.user_roles.where(slug: self.role).first\n  end\n\n  # assign a new site for current user\n  def assign_site(site)\n    self.update_column(:site_id, site.id)\n  end\n\n  def sites\n    if PluginRoutes.system_info[\"users_share_sites\"]\n      CamaleonCms::Site.all\n    else\n      CamaleonCms::Site.where(id: self.site_id)\n    end\n  end\n\n  def created\n    self.created_at.strftime('%d/%m/%Y %H:%M')\n  end\n\n  def updated\n    self.updated_at.strftime('%d/%m/%Y %H:%M')\n  end\n\n  # auth\n  def generate_token(column)\n    begin\n      self[column] = SecureRandom.urlsafe_base64\n    end while CamaleonCms::User.unscoped.exists?(column => self[column])\n  end\n\n  def send_password_reset\n    generate_token(:password_reset_token)\n    self.password_reset_sent_at = Time.zone.now\n    save!\n  end\n\n  def send_confirm_email\n    generate_token(:confirm_email_token)\n    self.confirm_email_sent_at = Time.zone.now\n    save!\n  end\n    # end auth\n\n  private\n  def cama_before_validation\n    self.role = PluginRoutes.system_info[\"default_user_role\"] if self.role.blank?\n    self.email = self.email.downcase if self.email.present?\n    self.username = self.username.downcase if self.username.present?\n  end\n\n  # deprecated\n  def set_all_sites\n    return\n  end\n\n  # reassign all posts of this user to first admin\n  # reassign all comments of this user to first admin\n  # if doesn't exist any other administrator, this will cancel the user destroy\n  def reassign_posts\n    all_posts.each do |p|\n      s = p.post_type.site\n      u = s.users.admin_scope.where.not(id: self.id).first\n      if u.present?\n        p.update_column(:user_id, u.id)\n        p.comments.where(user_id: self.id).each do |c|\n          c.update_column(:user_id, u.id)\n        end\n      end\n    end\n  end\n\n  def reassign_comments\n    all_comments.includes(post: {post_type: :site}).each do |comment|\n      site = comment.post.post_type.site\n      user = site.get_anonymous_user\n      comment.update_column(:user_id, user.id)\n    end\n  end\nend\n"], "fixing_code": ["class CamaleonCms::Admin::UsersController < CamaleonCms::AdminController\n  before_action :validate_role, except: [:profile, :profile_edit]\n  add_breadcrumb I18n.t(\"camaleon_cms.admin.sidebar.users\"), :cama_admin_users_url\n  before_action :set_user, only: [:show, :edit, :update, :destroy, :impersonate]\n\n  def index\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.list_users\")\n    @users = current_site.users.paginate(:page => params[:page], :per_page => current_site.admin_per_page)\n  end\n\n  def profile\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.profile\")\n    @user = params[:user_id].present? ? current_site.the_user(params[:user_id].to_i).object : cama_current_user.object\n    return edit\n  end\n\n  def profile_edit\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.profile\")\n    @user = cama_current_user.object\n    return edit\n  end\n\n  def show\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.users.profile\")\n    render 'profile'\n  end\n\n  def update\n    r={user: @user}; hooks_run('user_update', r)\n    if @user.update(user_params)\n      @user.set_metas(params[:meta]) if params[:meta].present?\n      @user.set_field_values(params[:field_options])\n      r = {user: @user, message: t('camaleon_cms.admin.users.message.updated'), params: params}; hooks_run('user_after_edited', r)\n      flash[:notice] = r[:message]\n      r={user: @user}; hooks_run('user_updated', r)\n      if cama_current_user.id == @user.id\n        redirect_to action: :profile_edit\n      else\n        redirect_to action: :index\n      end\n    else\n      render 'form'\n    end\n  end\n\n  # update som ajax requests from profile or user form\n  def updated_ajax\n    @user = current_site.users.find(params[:user_id])\n    update_session = current_user_is?(@user)\n    @user.update(params.require(:password).permit!)\n    render inline: @user.errors.full_messages.join(', ')\n    # keep user logged in when changing their own password\n    update_auth_token_in_cookie @user.auth_token if update_session && @user.saved_change_to_password_digest?\n  end\n\n  def update_auth_token_in_cookie(token)\n    return unless cookie_auth_token_complete?\n    current_token = cookie_split_auth_token\n    updated_token = [token, *current_token[1..-1]]\n    cookies[:auth_token] = updated_token.join(\"&\")\n  end\n\n  def current_user_is?(user)\n    user_auth_token_from_cookie == user.auth_token rescue false\n  end\n\n  def edit\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.button.edit\")\n    r = {user: @user, render: 'form' }\n    hooks_run('user_edit', r)\n    render r[:render]\n  end\n\n  def new\n    @user ||= current_site.users.new\n    add_breadcrumb I18n.t(\"camaleon_cms.admin.button.new\")\n    r = {user: @user, render: 'form' }\n    hooks_run('user_new', r)\n    render r[:render]\n  end\n\n  def create\n    user_data = params.require(:user).permit!\n    @user = current_site.users.new(user_data)\n    r={user: @user}; hooks_run('user_create', r)\n    if @user.save\n      @user.set_metas(params[:meta]) if params[:meta].present?\n      @user.set_field_values(params[:field_options])\n      r={user: @user}; hooks_run('user_created', r)\n      flash[:notice] = t('camaleon_cms.admin.users.message.created')\n      redirect_to action: :index\n    else\n      new\n    end\n  end\n\n  def destroy\n    if cama_current_user.id == @user.id\n      flash[:error] = t('camaleon_cms.admin.users.message.user_can_not_delete_own_account', default: 'User can not delete own account')\n    elsif @user.destroy\n      flash[:notice] = t('camaleon_cms.admin.users.message.deleted')\n      r={user: @user}; hooks_run('user_destroyed', r)\n    end\n    redirect_to action: :index\n  end\n\n  def impersonate\n    authorize! :impersonate, @user\n    session_switch_user(@user, cama_admin_dashboard_path)\n  end\n\n  private\n\n  def validate_role\n    (user_id_param.present? && cama_current_user.id.to_s == user_id_param) || authorize!(:manage, :users)\n  end\n\n  def user_id_param\n    params[:id] || params[:user_id]\n  end\n\n  def user_params\n    parameters = params.require(:user)\n    if cama_current_user.role_grantor?(@user)\n      parameters.permit(:username, :email, :role, :first_name, :last_name)\n    else\n      parameters.permit(:username, :email, :first_name, :last_name)\n    end\n  end\n\n  def set_user\n    begin\n      @user = current_site.users.find(user_id_param)\n    rescue\n      flash[:error] = t('camaleon_cms.admin.users.message.error')\n      redirect_to cama_admin_path\n    end\n  end\nend\n", "module CamaleonCms::SessionHelper\n  # log in the user in to system\n  # user: User model\n  # remember_me: true/false (remember session permanently)\n  # redirect_url (default nil): after initialized the session, this will be redirected to\n  #   \"redirect_url\" if defined\n  #   it doesn't redirect if redirect_url === false\n  #   return to previous page if defined the cookie['return_to'] or login url received extra param: return_to=http://mysite.com\n  def login_user(user, remember_me = false, redirect_url = nil)\n    c = {value: [user.auth_token, request.user_agent, request.ip], expires: 24.hours.from_now}\n    c[:domain] = :all if PluginRoutes.system_info[\"users_share_sites\"].present? && CamaleonCms::Site.count > 1\n    c[:expires] = 1.month.from_now if remember_me\n\n    # fix to overwrite a cookie\n    cookies.delete(:auth_token, domain: :all)\n    cookies.delete(:auth_token)\n\n    user.update({last_login_at: Time.zone.now})\n    cookies[:auth_token] = c\n\n    # user redirection\n    flash[:notice] = t('camaleon_cms.admin.login.message.success', locale: current_site.get_admin_language)\n    return if redirect_url === false\n    if redirect_url.present?\n      redirect_to redirect_url\n    elsif (return_to = cookies.delete(:return_to)).present?\n      redirect_to return_to\n    else\n      redirect_to cama_admin_dashboard_path\n    end\n  end\n\n  # login a user using username and password\n  # return boolean: true => authenticated, false => authentication failed\n  def login_user_with_password(username, password)\n    @user = current_site.users.find_by_username(username)\n    r = {user: @user, params: params, password: password, captcha_validate: true}; hooks_run('user_before_login', r)\n    @user && @user.authenticate(password)\n  end\n\n  ##\n  # User registration.\n  #\n  # user_data must contain:\n  # - first_name\n  # - email\n  # - username\n  # - password\n  # - password_confirmation\n\n  def cama_register_user(user_data, meta)\n    @user = current_site.users.new(user_data)\n    r = {user: @user, params: params}; hook_run('user_before_register', r)\n\n    if current_site.security_user_register_captcha_enabled? && !cama_captcha_verified?\n      {:result => false, :type => :captcha_error, :message => t('camaleon_cms.admin.users.message.error_captcha')}\n    else\n      if @user.save\n        @user.set_metas(meta)\n        message = current_site.need_validate_email? ? t('camaleon_cms.admin.users.message.created_pending_validate_email') : t('camaleon_cms.admin.users.message.created')\n        r = {user: @user, message: message, redirect_url: cama_admin_login_path}; hooks_run('user_after_register', r)\n        {:result => true, :message => r[:message], :redirect_url => r[:redirect_url]}\n      else\n        {:result => false, :type => :no_saved}\n      end\n    end\n  end\n\n  # check if current host is heroku\n  def cama_on_heroku?\n    ENV.keys.any? { |var_name| var_name.match(/(heroku|dyno)/i) }\n  end\n\n  # switch current session user into other (user)\n  # after switched, this will be redirected to redirect_url or admin dashboard\n  def session_switch_user(user, redirect_url = nil)\n    if cama_sign_in?\n      session[:parent_auth_token] = cookies[:auth_token]\n      login_user(user, false, redirect_url)\n    end\n  end\n\n  # switch current session into parent session called by session_switch_user\n  # after returned into parent session, this will be redirected to redirect_url or admin dashboard\n  def session_back_to_parent(redirect_url = nil)\n    if cama_sign_in? && session[:parent_auth_token].present?\n      cookies[:auth_token] = session[:parent_auth_token]\n      session.delete(:parent_auth_token)\n      redirect_to (redirect_url || cama_admin_dashboard_path), notice: \"Welcome back!\"\n    end\n  end\n\n  # logout current user\n  def cama_logout_user\n    cookies.delete(:auth_token, domain: :all)\n    cookies.delete(:auth_token, domain: nil)\n    c_data = {value: nil, expires: 24.hours.ago}\n    c_data[:domain] = :all if PluginRoutes.system_info[\"users_share_sites\"].present? && CamaleonCms::Site.count > 1\n    cookies[:auth_token] = c_data\n    redirect_to params[:return_to].present? ? params[:return_to] : cama_admin_login_path, :notice => t('camaleon_cms.admin.logout.message.closed')\n  end\n\n  # check if current user is already signed\n  def cama_sign_in?\n    !cama_current_user.nil?\n  end\n\n  alias_method :signin?, :cama_sign_in?\n\n  # return the role for current user\n  # if not logged in, then return 'public'\n  def cama_current_role\n    current_site.visitor_role\n  end\n\n  # return current user logged in\n  def cama_current_user\n    return @cama_current_user if defined?(@cama_current_user)\n    # api current user...\n    @cama_current_user = cama_calc_api_current_user\n    return @cama_current_user if @cama_current_user\n\n    return nil unless cookie_auth_token_complete?\n\n    @cama_current_user = current_site.users_include_admins.find_by_auth_token(user_auth_token_from_cookie).try(:decorate)\n  end\n\n  def cookie_auth_token_complete?\n    cookie_split_auth_token&.size == 3\n  end\n\n  def cookie_split_auth_token\n    cookies[:auth_token]&.split(\"&\")\n  end\n\n  def user_auth_token_from_cookie\n    cookie_split_auth_token.first\n  end\n\n  # check if a visitor was logged in\n  # if the user was not logged in, then redirect to login url\n  def cama_authenticate(redirect_uri = nil)\n    params[:return_to] = redirect_uri\n    unless cama_sign_in?\n      flash[:error] = t('camaleon_cms.admin.login.please_login')\n      cookies[:return_to] = params[:return_to].present? ? params[:return_to] : ((request.get? && params[:controller] != \"admin/sessions\") ? request.original_url : nil)\n      redirect_to cama_admin_login_path\n    end\n  end\n\n  # return the session id\n  def cama_get_session_id\n    session[:autor] = \"Owen Peredo Diaz\" unless request.session_options[:id].present?\n    id = request.session_options[:id]\n    id = id.public_id if id && id.class.name == 'Rack::Session::SessionId'\n    id\n  end\n\n  private\n  # calculate the current user for API\n  def cama_calc_api_current_user\n    begin\n      doorkeeper_token\n    rescue NameError\n      # hack, this method should be called from a context which has\n      # doorkeeper_token defined\n      return nil\n    end\n    current_site.users_include_admins.find_by_id(doorkeeper_token.resource_owner_id).try(:decorate) if doorkeeper_token\n  end\nend\n", "module CamaleonCms::UserMethods extend ActiveSupport::Concern\n  included do\n    include CamaleonCms::Metas\n    include CamaleonCms::CustomFieldsRead\n\n    validates_uniqueness_of :username, scope: [:site_id], case_sensitive: false, message: I18n.t('camaleon_cms.admin.users.message.requires_different_username', default: 'Requires different username')\n    validates_uniqueness_of :email, scope: [:site_id], case_sensitive: false, message: I18n.t('camaleon_cms.admin.users.message.requires_different_email', default: 'Requires different email')\n\n    # callbacks\n    before_validation :cama_before_validation\n    before_destroy :reassign_posts\n    after_destroy :reassign_comments\n    before_create { generate_token(:auth_token) }\n    # invaliidate sessions when changing password\n    before_update { generate_token :auth_token if will_save_change_to_password_digest? }\n\n    # relations\n    cama_define_common_relationships('User')\n    has_many :all_posts, class_name: \"CamaleonCms::Post\", foreign_key: :user_id\n    has_many :all_comments, class_name: 'CamaleonCms::PostComment'\n    belongs_to :site, class_name: 'CamaleonCms::Site', optional: true\n\n    #scopes\n    scope :admin_scope, -> { where(:role => 'admin') }\n    scope :actives, -> { where(:active => 1) }\n    scope :not_actives, -> { where(:active => 0) }\n\n    #vars\n    STATUS = {0 => 'Active', 1=>'Not Active'}\n    ROLE = { 'admin'=>'Administrator', 'client' => 'Client'}\n\n    def self.decorator_class\n      'CamaleonCms::UserDecorator'.constantize\n    end\n  end\n\n  # return all posts of this user on site\n  def posts(site)\n    site.posts.where(user_id: self.id)\n  end\n\n  def fullname\n    \"#{self.first_name} #{self.last_name}\".titleize\n  end\n\n  def admin?\n    role == 'admin'\n  end\n\n  def client?\n    self.role == 'client'\n  end\n\n  # return the UserRole Object of this user in Site\n  def get_role(site)\n    @_user_role ||= site.user_roles.where(slug: self.role).first\n  end\n\n  # assign a new site for current user\n  def assign_site(site)\n    self.update_column(:site_id, site.id)\n  end\n\n  def sites\n    if PluginRoutes.system_info[\"users_share_sites\"]\n      CamaleonCms::Site.all\n    else\n      CamaleonCms::Site.where(id: self.site_id)\n    end\n  end\n\n  def created\n    self.created_at.strftime('%d/%m/%Y %H:%M')\n  end\n\n  def updated\n    self.updated_at.strftime('%d/%m/%Y %H:%M')\n  end\n\n  # auth\n  def generate_token(column)\n    begin\n      self[column] = SecureRandom.urlsafe_base64\n    end while CamaleonCms::User.unscoped.exists?(column => self[column])\n  end\n\n  def send_password_reset\n    generate_token(:password_reset_token)\n    self.password_reset_sent_at = Time.zone.now\n    save!\n  end\n\n  def send_confirm_email\n    generate_token(:confirm_email_token)\n    self.confirm_email_sent_at = Time.zone.now\n    save!\n  end\n    # end auth\n\n  private\n  def cama_before_validation\n    self.role = PluginRoutes.system_info[\"default_user_role\"] if self.role.blank?\n    self.email = self.email.downcase if self.email.present?\n    self.username = self.username.downcase if self.username.present?\n  end\n\n  # deprecated\n  def set_all_sites\n    return\n  end\n\n  # reassign all posts of this user to first admin\n  # reassign all comments of this user to first admin\n  # if doesn't exist any other administrator, this will cancel the user destroy\n  def reassign_posts\n    all_posts.each do |p|\n      s = p.post_type.site\n      u = s.users.admin_scope.where.not(id: self.id).first\n      if u.present?\n        p.update_column(:user_id, u.id)\n        p.comments.where(user_id: self.id).each do |c|\n          c.update_column(:user_id, u.id)\n        end\n      end\n    end\n  end\n\n  def reassign_comments\n    all_comments.includes(post: {post_type: :site}).each do |comment|\n      site = comment.post.post_type.site\n      user = site.get_anonymous_user\n      comment.update_column(:user_id, user.id)\n    end\n  end\nend\n"], "filenames": ["app/controllers/camaleon_cms/admin/users_controller.rb", "app/helpers/camaleon_cms/session_helper.rb", "app/models/concerns/camaleon_cms/user_methods.rb"], "buggy_code_start_loc": [49, 123, 13], "buggy_code_end_loc": [50, 128, 13], "fixing_code_start_loc": [49, 123, 14], "fixing_code_end_loc": [65, 138, 16], "type": "CWE-613", "message": "Camaleon CMS 0.1.7 to 2.6.0 doesn\u2019t terminate the active session of the users, even after the admin changes the user\u2019s password. A user that was already logged in, will still have access to the application even after the password was changed.", "other": {"cve": {"id": "CVE-2021-25970", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-10-20T12:15:07.587", "lastModified": "2021-10-29T18:40:59.727", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Camaleon CMS 0.1.7 to 2.6.0 doesn\u2019t terminate the active session of the users, even after the admin changes the user\u2019s password. A user that was already logged in, will still have access to the application even after the password was changed."}, {"lang": "es", "value": "Camaleon CMS versiones 0.1.7 a 2.6.0, no termina la sesi\u00f3n activa de los usuarios, incluso despu\u00e9s de que el administrador cambie la contrase\u00f1a del usuario. Un usuario que ya estaba conectado, seguir\u00e1 teniendo acceso a la aplicaci\u00f3n incluso despu\u00e9s de que la contrase\u00f1a fue cambiada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tuzitio:camaleon_cms:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.1.7", "versionEndIncluding": "2.6.0", "matchCriteriaId": "DAC41EAB-C69C-42B1-8B07-D9C56B010CC5"}]}]}], "references": [{"url": "https://github.com/owen2345/camaleon-cms/commit/77e31bc6cdde7c951fba104aebcd5ebb3f02b030", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25970", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/owen2345/camaleon-cms/commit/77e31bc6cdde7c951fba104aebcd5ebb3f02b030"}}